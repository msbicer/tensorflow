<?php// $Id$?><div id="node-<?php print $node->nid; ?>" class="node<?php if ($sticky) { print ' sticky'; } ?><?php if (!$status) { print ' node-unpublished'; } ?>"><?php print $picture ?><?php if ($page == 0): ?>  <h2><a href="<?php print $node_url ?>" title="<?php print $title ?>"><?php print $title ?></a></h2><?php endif; ?>  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted; ?></span>  <?php endif; ?>  <div class="content clear-block">    <?php print $content ?>  </div>  <div class="clear-block">    <div class="meta">    <?php if ($taxonomy): ?>      <div class="terms"><?php print $terms ?></div>    <?php endif;?>    </div>    <?php if ($links): ?>      <div class="links"><?php print $links; ?></div>    <?php endif; ?>  </div></div>
<?php// $Id$/** * @file * User page callbacks for the tracker module. *//** * Menu callback. Prints a listing of active nodes on the site. */function tracker_page($account = NULL, $set_title = FALSE) {  // Add CSS  drupal_add_css(drupal_get_path('module', 'tracker') .'/tracker.css', 'module', 'all', FALSE);  if ($account) {    if ($set_title) {      // When viewed from user/%user/track, display the name of the user      // as page title -- the tab title remains Track so this needs to be done      // here and not in the menu definiton.      drupal_set_title(check_plain($account->name));    }  // TODO: These queries are very expensive, see http://drupal.org/node/105639    $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.changed, n.uid, u.name, GREATEST(n.changed, l.last_comment_timestamp) AS last_updated, l.comment_count FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {users} u ON n.uid = u.uid LEFT JOIN {comments} c ON n.nid = c.nid AND (c.status = %d OR c.status IS NULL) WHERE n.status = 1 AND (n.uid = %d OR c.uid = %d) ORDER BY last_updated DESC';    $sql = db_rewrite_sql($sql);    $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n LEFT JOIN {comments} c ON n.nid = c.nid AND (c.status = %d OR c.status IS NULL) WHERE n.status = 1 AND (n.uid = %d OR c.uid = %d)';    $sql_count = db_rewrite_sql($sql_count);    $result = pager_query($sql, 25, 0, $sql_count, COMMENT_PUBLISHED, $account->uid, $account->uid);  }  else {    $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.changed, n.uid, u.name, GREATEST(n.changed, l.last_comment_timestamp) AS last_updated, l.comment_count FROM {node} n INNER JOIN {users} u ON n.uid = u.uid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 ORDER BY last_updated DESC';    $sql = db_rewrite_sql($sql);    $sql_count = 'SELECT COUNT(n.nid) FROM {node} n WHERE n.status = 1';    $sql_count = db_rewrite_sql($sql_count);    $result = pager_query($sql, 25, 0, $sql_count);  }  $rows = array();  while ($node = db_fetch_object($result)) {    // Determine the number of comments:    $comments = 0;    if ($node->comment_count) {      $comments = $node->comment_count;      if ($new = comment_num_new($node->nid)) {        $comments .= '<br />';        $comments .= l(format_plural($new, '1 new', '@count new'), "node/$node->nid", array('query' => comment_new_page_count($node->comment_count, $new, $node), 'fragment' => 'new'));      }    }    $rows[] = array(      check_plain(node_get_types('name', $node->type)),      l($node->title, "node/$node->nid") .' '. theme('mark', node_mark($node->nid, $node->changed)),      theme('username', $node),      array('class' => 'replies', 'data' => $comments),      t('!time ago', array('!time' => format_interval(time() - $node->last_updated)))    );  }  if (!$rows) {    $rows[] = array(array('data' => t('No posts available.'), 'colspan' => '5'));  }  $header = array(t('Type'), t('Post'), t('Author'), t('Replies'), t('Last updated'));  $output = '<div id="tracker">';  $output .= theme('table', $header, $rows);  $output .= theme('pager', NULL, 25, 0);  $output .= '</div>';  return $output;}
<?php// $Id$/** * @file * A database-mediated implementation of a locking mechanism. *//** * @defgroup lock Functions to coordinate long-running operations across requests. * @{ * In most environments, multiple Drupal page requests (a.k.a. threads or * processes) will execute in parallel. This leads to potential conflicts or * race conditions when two requests execute the same code at the same time. A * common example of this is a rebuild like menu_rebuild() where we invoke many * hook implementations to get and process data from all active modules, and * then delete the current data in the database to insert the new afterwards. * * This is a cooperative, advisory lock system. Any long-running operation * that could potentially be attempted in parallel by multiple requests should * try to acquire a lock before proceeding. By obtaiing a lock, one request * notifies any other requests that a specific opertation is in progress which * must not be executed in parallel. * * To use this API, pick a unique name for the lock. A sensible choice is the * name of the function performing the operation. A very simple example use of * this API: * @code * function mymodule_long_operation() { *   if (lock_acquire('mymodule_long_operation')) { *     // Do the long operation here. *     // ... *     lock_release('mymodule_long_operation'); *   } * } * @endcode * * If a function acquires a lock it should always release it when the * operation is complete by calling lock_release(), as in the example. * * A function that has acquired a lock may attempt to renew a lock (extend the * duration of the lock) by calling lock_acquire() again during the operation. * Failure to renew a lock is indicative that another request has acquired * the lock, and that the current operation may need to be aborted. * * If a function fails to acquire a lock it may either immediately return, or * it may call lock_wait() if the rest of the current page request requires * that the operation in question be complete.  After lock_wait() returns, * the function may again attempt to acquire the lock, or may simply allow the * page request to proceed on the  assumption that a parallel request completed * the operation. * * lock_acquire() and lock_wait() will automatically break (delete) a lock * whose duration has exceeded the timeout specified when it was acquired. * * A function that has acquired a lock may attempt to renew a lock (extend the * duration of the lock) by calling lock_acquire() again during the operation. * Failure to renew a lock is indicative that another request has acquired * the lock, and that the current operation may need to be aborted. * * Alternative implementations of this API (such as APC) may be substituted * by setting the 'lock_inc' variable to an alternate include filepath.  Since * this is an API intended to support alternative implementations, code using * this API should never rely upon specific implementation details (for example * no code should look for or directly modify a lock in the {semaphore} table). *//** * Initialize the locking system. */function lock_init() {  global $locks;  $locks = array();}/** * Helper function to get this request's unique id. */function _lock_id() {  static $lock_id;  if (!isset($lock_id)) {    // Assign a unique id.    $lock_id = uniqid(mt_rand(), TRUE);    // We only register a shutdown function if a lock is used.    register_shutdown_function('lock_release_all', $lock_id);  }  return $lock_id;}/** * Acquire (or renew) a lock, but do not block if it fails. * * @param $name *   The name of the lock. * @param $timeout *   A number of seconds (float) before the lock expires. * @return *   TRUE if the lock was acquired, FALSE if it failed. */function lock_acquire($name, $timeout = 30.0) {  global $locks;  // Insure that the timeout is at least 1 ms.  $timeout = max($timeout, 0.001);  list($usec, $sec) = explode(' ', microtime());  $expire = (float)$usec + (float)$sec + $timeout;  if (isset($locks[$name])) {    // Try to extend the expiration of a lock we already acquired.    if (!db_result(db_query("UPDATE {semaphore} SET expire = %f WHERE name = '%s' AND value = '%s'", $expire, $name, _lock_id()))) {      // The lock was broken.      unset($locks[$name]);    }  }  else {    // Optimistically try to acquire the lock, then retry once if it fails.    // The first time through the loop cannot be a retry.    $retry = FALSE;    // We always want to do this code at least once.    do {      if (@db_query("INSERT INTO {semaphore} (name, value, expire) VALUES ('%s', '%s', %f)", $name, _lock_id(), $expire)) {        // We track all acquired locks in the global variable.        $locks[$name] = TRUE;        // We never need to try again.        $retry = FALSE;      }      else {        // Suppress the error. If this is our first pass through the loop,        // then $retry is FALSE. In this case, the insert must have failed        // meaning some other request acquired the lock but did not release it.        // We decide whether to retry by checking lock_may_be_available()        // Since this will break the lock in case it is expired.        $retry = $retry ? FALSE : lock_may_be_available($name);      }      // We only retry in case the first attempt failed, but we then broke      // an expired lock.    } while ($retry);  }  return isset($locks[$name]);}/** * Check if lock acquired by a different process may be available. * * If an existing lock has expired, it is removed. * * @param $name *   The name of the lock. * @return *   TRUE if there is no lock or it was removed, FALSE otherwise. */function lock_may_be_available($name) {  $lock = db_fetch_array(db_query("SELECT expire, value FROM {semaphore} WHERE name = '%s'", $name));  if (!$lock) {    return TRUE;  }  $expire = (float) $lock['expire'];  list($usec, $sec) = explode(' ', microtime());  $now = (float)$usec + (float)$sec;  if ($now > $lock['expire']) {    // We check two conditions to prevent a race condition where another    // request acquired the lock and set a new expire time.  We add a small    // number to $expire to avoid errors with float to string conversion.    db_query("DELETE FROM {semaphore} WHERE name = '%s' AND value = '%s' AND expire <= %f", $name, $lock['value'], 0.0001 + $expire);    return (bool)db_affected_rows();  }  return FALSE;}/** * Wait for a lock to be available. * * This function may be called in a request that fails to acquire a desired * lock. This will block further execution until the lock is available or the * specified delay in seconds is reached.  This should not be used with locks * that are acquired very frequently, since the lock is likely to be acquired * again by a different request during the sleep(). * * @param $name *   The name of the lock. * @param $delay *   The maximum number of seconds to wait, as an integer. * @return *   TRUE if the lock holds, FALSE if it is available. */function lock_wait($name, $delay = 30) {  while ($delay--) {    // This function should only be called by a request that failed to get a    // lock, so we sleep first to give the parallel request a chance to finish    // and release the lock.    sleep(1);    if (lock_may_be_available($name)) {      // No longer need to wait.      return FALSE;    }  }  // The caller must still wait longer to get the lock.  return TRUE;}/** * Release a lock previously acquired by lock_acquire(). * * This will release the named lock if it is still held by the current request. * * @param $name *   The name of the lock. */function lock_release($name) {  global $locks;  unset($locks[$name]);  db_query("DELETE FROM {semaphore} WHERE name = '%s' AND value = '%s'", $name, _lock_id());}/** * Release all previously acquired locks. */function lock_release_all($lock_id = NULL) {  global $locks;  $locks = array();  if (empty($lock_id)) {    $lock_id = _lock_id();  }  db_query("DELETE FROM {semaphore} WHERE value = '%s'", _lock_id());}/** * @} End of "defgroup locks". */
<?php// $Id$/** * @file page.tpl.php * * Theme implementation to display a single Drupal page. * * Available variables: * * General utility variables: * - $base_path: The base URL path of the Drupal installation. At the very *   least, this will always default to /. * - $css: An array of CSS files for the current page. * - $directory: The directory the theme is located in, e.g. themes/garland or *   themes/garland/minelli. * - $is_front: TRUE if the current page is the front page. Used to toggle the mission statement. * - $logged_in: TRUE if the user is registered and signed in. * - $is_admin: TRUE if the user has permission to access administration pages. * * Page metadata: * - $language: (object) The language the site is being displayed in. *   $language->language contains its textual representation. *   $language->dir contains the language direction. It will either be 'ltr' or 'rtl'. * - $head_title: A modified version of the page title, for use in the TITLE tag. * - $head: Markup for the HEAD section (including meta tags, keyword tags, and *   so on). * - $styles: Style tags necessary to import all CSS files for the page. * - $scripts: Script tags necessary to load the JavaScript files and settings *   for the page. * - $body_classes: A set of CSS classes for the BODY tag. This contains flags *   indicating the current layout (multiple columns, single column), the current *   path, whether the user is logged in, and so on. * * Site identity: * - $front_page: The URL of the front page. Use this instead of $base_path, *   when linking to the front page. This includes the language domain or prefix. * - $logo: The path to the logo image, as defined in theme configuration. * - $site_name: The name of the site, empty when display has been disabled *   in theme settings. * - $site_slogan: The slogan of the site, empty when display has been disabled *   in theme settings. * - $mission: The text of the site mission, empty when display has been disabled *   in theme settings. * * Navigation: * - $search_box: HTML to display the search box, empty if search has been disabled. * - $primary_links (array): An array containing primary navigation links for the *   site, if they have been configured. * - $secondary_links (array): An array containing secondary navigation links for *   the site, if they have been configured. * * Page content (in order of occurrance in the default page.tpl.php): * - $left: The HTML for the left sidebar. * * - $breadcrumb: The breadcrumb trail for the current page. * - $title: The page title, for use in the actual HTML content. * - $help: Dynamic help text, mostly for admin pages. * - $messages: HTML for status and error messages. Should be displayed prominently. * - $tabs: Tabs linking to any sub-pages beneath the current page (e.g., the view *   and edit tabs when displaying a node). * * - $content: The main content of the current Drupal page. * * - $right: The HTML for the right sidebar. * * Footer/closing data: * - $feed_icons: A string of all feed icons for the current page. * - $footer_message: The footer message as defined in the admin settings. * - $footer : The footer region. * - $closure: Final closing markup from any modules that have altered the page. *   This variable should always be output last, after all other dynamic content. * * @see template_preprocess() * @see template_preprocess_page() */?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>"><head>  <?php print $head; ?>  <title><?php print $head_title; ?></title>  <?php print $styles; ?>  <?php print $scripts; ?>  <script type="text/javascript"><?php /* Needed to avoid Flash of Unstyled Content in IE */ ?> </script></head><body class="<?php print $body_classes; ?>">  <div id="page">    <div id="header">      <div id="logo-title">        <?php if (!empty($logo)): ?>          <a href="<?php print $front_page; ?>" title="<?php print t('Home'); ?>" rel="home" id="logo">            <img src="<?php print $logo; ?>" alt="<?php print t('Home'); ?>" />          </a>        <?php endif; ?>        <div id="name-and-slogan">          <?php if (!empty($site_name)): ?>            <h1 id="site-name">              <a href="<?php print $front_page ?>" title="<?php print t('Home'); ?>" rel="home"><span><?php print $site_name; ?></span></a>            </h1>          <?php endif; ?>          <?php if (!empty($site_slogan)): ?>            <div id="site-slogan"><?php print $site_slogan; ?></div>          <?php endif; ?>        </div> <!-- /name-and-slogan -->      </div> <!-- /logo-title -->      <?php if (!empty($search_box)): ?>        <div id="search-box"><?php print $search_box; ?></div>      <?php endif; ?>      <?php if (!empty($header)): ?>        <div id="header-region">          <?php print $header; ?>        </div>      <?php endif; ?>    </div> <!-- /header -->    <div id="container" class="clear-block">      <div id="navigation" class="menu <?php if (!empty($primary_links)) { print "withprimary"; } if (!empty($secondary_links)) { print " withsecondary"; } ?> ">        <?php if (!empty($primary_links)): ?>          <div id="primary" class="clear-block">            <?php print theme('links', $primary_links, array('class' => 'links primary-links')); ?>          </div>        <?php endif; ?>        <?php if (!empty($secondary_links)): ?>          <div id="secondary" class="clear-block">            <?php print theme('links', $secondary_links, array('class' => 'links secondary-links')); ?>          </div>        <?php endif; ?>      </div> <!-- /navigation -->      <?php if (!empty($left)): ?>        <div id="sidebar-left" class="column sidebar">          <?php print $left; ?>        </div> <!-- /sidebar-left -->      <?php endif; ?>      <div id="main" class="column"><div id="main-squeeze">        <?php if (!empty($breadcrumb)): ?><div id="breadcrumb"><?php print $breadcrumb; ?></div><?php endif; ?>        <?php if (!empty($mission)): ?><div id="mission"><?php print $mission; ?></div><?php endif; ?>        <div id="content">          <?php if (!empty($title)): ?><h1 class="title" id="page-title"><?php print $title; ?></h1><?php endif; ?>          <?php if (!empty($tabs)): ?><div class="tabs"><?php print $tabs; ?></div><?php endif; ?>          <?php if (!empty($messages)): print $messages; endif; ?>          <?php if (!empty($help)): print $help; endif; ?>          <div id="content-content" class="clear-block">            <?php print $content; ?>          </div> <!-- /content-content -->          <?php print $feed_icons; ?>        </div> <!-- /content -->      </div></div> <!-- /main-squeeze /main -->      <?php if (!empty($right)): ?>        <div id="sidebar-right" class="column sidebar">          <?php print $right; ?>        </div> <!-- /sidebar-right -->      <?php endif; ?>    </div> <!-- /container -->    <div id="footer-wrapper">      <div id="footer">        <?php print $footer_message; ?>        <?php if (!empty($footer)): print $footer; endif; ?>      </div> <!-- /footer -->    </div> <!-- /footer-wrapper -->    <?php print $closure; ?>  </div> <!-- /page --></body></html>
<?php// $Id$/** * @file * User page callbacks for the openid module. *//** * Menu callback; Process an OpenID authentication. */function openid_authentication_page() {  $result = openid_complete();  switch ($result['status']) {    case 'success':      return openid_authentication($result);    case 'failed':      drupal_set_message(t('OpenID login failed.'), 'error');      break;    case 'cancel':      drupal_set_message(t('OpenID login cancelled.'));      break;  }  drupal_goto();}/** * Menu callback; Manage OpenID identities for the specified user. */function openid_user_identities($account) {  drupal_set_title(check_plain($account->name));  drupal_add_css(drupal_get_path('module', 'openid') .'/openid.css', 'module');  // Check to see if we got a response  $result = openid_complete();  if ($result['status'] == 'success') {    $identity = $result['openid.claimed_id'];    db_query("INSERT INTO {authmap} (uid, authname, module) VALUES (%d, '%s','openid')", $account->uid, $identity);    drupal_set_message(t('Successfully added %identity', array('%identity' => $identity)));  }  $header = array(t('OpenID'), t('Operations'));  $rows = array();  $result = db_query("SELECT * FROM {authmap} WHERE module='openid' AND uid=%d", $account->uid);  while ($identity = db_fetch_object($result)) {    $rows[] = array(check_plain($identity->authname), l(t('Delete'), 'user/'. $account->uid .'/openid/delete/'. $identity->aid));  }  $output = theme('table', $header, $rows);  $output .= drupal_get_form('openid_user_add');  return $output;}/** * Form builder; Add an OpenID identity. * * @ingroup forms * @see openid_user_add_validate() */function openid_user_add() {  $form['openid_identifier'] = array(    '#type' => 'textfield',    '#title' => t('OpenID'),  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Add an OpenID'));  return $form;}function openid_user_add_validate($form, &$form_state) {  // Check for existing entries.  $claimed_id = _openid_normalize($form_state['values']['openid_identifier']);  if (db_result(db_query("SELECT authname FROM {authmap} WHERE authname='%s'", $claimed_id))) {    form_set_error('openid_identifier', t('That OpenID is already in use on this site.'));  }}function openid_user_add_submit($form, &$form_state) {  $return_to = url('user/'. arg(1) .'/openid', array('absolute' => TRUE));  openid_begin($form_state['values']['openid_identifier'], $return_to);}/** * Present a confirmation form to delete the specified OpenID identity from the system. * * @ingroup forms * @see openid_user_delete_form_submit() */function openid_user_delete_form($form_state, $account, $aid = 0) {  $authname = db_result(db_query('SELECT authname FROM {authmap} WHERE uid = %d AND aid = %d', $account->uid, $aid));  $form = array();  $form['uid'] = array(    '#type' => 'value',    '#value' => $account->uid,  );  $form['aid'] = array(    '#type' => 'value',    '#value' => $aid,  );  return confirm_form($form, t('Are you sure you want to delete the OpenID %authname for %user?', array('%authname' => $authname, '%user' => $account->name)), 'user/'. $account->uid .'/openid');}function openid_user_delete_form_submit($form, &$form_state) {  db_query("DELETE FROM {authmap} WHERE uid = %d AND aid = %d AND module = 'openid'", $form_state['values']['uid'], $form_state['values']['aid']);  if (db_affected_rows()) {    drupal_set_message(t('OpenID deleted.'));  }  $form_state['redirect'] = 'user/'. $form_state['values']['uid'] .'/openid';}
<?php// $Id$/** * @file * The core that allows content to be submitted to the site. Modules and scripts may * programmatically submit nodes using the usual form API pattern. *//** * Nodes changed before this time are always marked as read. * * Nodes changed after this time may be marked new, updated, or read, depending * on their state for the current user. Defaults to 30 days ago. */define('NODE_NEW_LIMIT', time() - 30 * 24 * 60 * 60);define('NODE_BUILD_NORMAL', 0);define('NODE_BUILD_PREVIEW', 1);define('NODE_BUILD_SEARCH_INDEX', 2);define('NODE_BUILD_SEARCH_RESULT', 3);define('NODE_BUILD_RSS', 4);define('NODE_BUILD_PRINT', 5);/** * Implementation of hook_help(). */function node_help($path, $arg) {  // Remind site administrators about the {node_access} table being flagged  // for rebuild. We don't need to issue the message on the confirm form, or  // while the rebuild is being processed.  if ($path != 'admin/content/node-settings/rebuild' && $path != 'batch' && strpos($path, '#') === FALSE      && user_access('access administration pages') && node_access_needs_rebuild()) {    if ($path == 'admin/content/node-settings') {      $message = t('The content access permissions need to be rebuilt.');    }    else {      $message = t('The content access permissions need to be rebuilt. Please visit <a href="@node_access_rebuild">this page</a>.', array('@node_access_rebuild' => url('admin/content/node-settings/rebuild')));    }    drupal_set_message($message, 'error');  }  switch ($path) {    case 'admin/help#node':      $output = '<p>'. t('The node module manages content on your site, and stores all posts (regardless of type) as a "node". In addition to basic publishing settings, including whether the post has been published, promoted to the site front page, or should remain present (or sticky) at the top of lists, the node module also records basic information about the author of a post. Optional revision control over edits is available. For additional functionality, the node module is often extended by other modules.') .'</p>';      $output .= '<p>'. t('Though each post on your site is a node, each post is also of a particular <a href="@content-type">content type</a>. <a href="@content-type">Content types</a> are used to define the characteristics of a post, including the title and description of the fields displayed on its add and edit pages. Each content type may have different default settings for <em>Publishing options</em> and other workflow controls. By default, the two content types in a standard Drupal installation are <em>Page</em> and <em>Story</em>. Use the <a href="@content-type">content types page</a> to add new or edit existing content types. Additional content types also become available as you enable additional core, contributed and custom modules.', array('@content-type' => url('admin/content/types'))) .'</p>';      $output .= '<p>'. t('The administrative <a href="@content">content page</a> allows you to review and manage your site content. The <a href="@post-settings">post settings page</a> sets certain options for the display of posts. The node module makes a number of permissions available for each content type, which may be set by role on the <a href="@permissions">permissions page</a>.', array('@content' => url('admin/content/node'), '@post-settings' => url('admin/content/node-settings'), '@permissions' => url('admin/user/permissions'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@node">Node module</a>.', array('@node' => 'http://drupal.org/handbook/modules/node/')) .'</p>';      return $output;    case 'admin/content/node':      return ' '; // Return a non-null value so that the 'more help' link is shown.    case 'admin/content/types':      return '<p>'. t('Below is a list of all the content types on your site. All posts that exist on your site are instances of one of these content types.') .'</p>';    case 'admin/content/types/add':      return '<p>'. t('To create a new content type, enter the human-readable name, the machine-readable name, and all other relevant fields that are on this page. Once created, users of your site will be able to create posts that are instances of this content type.') .'</p>';    case 'node/%/revisions':      return '<p>'. t('The revisions let you track differences between multiple versions of a post.') .'</p>';    case 'node/%/edit':      $node = node_load($arg[1]);      $type = node_get_types('type', $node->type);      return (!empty($type->help) ? '<p>'. filter_xss_admin($type->help) .'</p>' : '');  }  if ($arg[0] == 'node' && $arg[1] == 'add' && $arg[2]) {    $type = node_get_types('type', str_replace('-', '_', $arg[2]));    return (!empty($type->help) ? '<p>'. filter_xss_admin($type->help) .'</p>' : '');  }}/** * Implementation of hook_theme() */function node_theme() {  return array(    'node' => array(      'arguments' => array('node' => NULL, 'teaser' => FALSE, 'page' => FALSE),      'template' => 'node',    ),    'node_list' => array(      'arguments' => array('items' => NULL, 'title' => NULL),    ),    'node_search_admin' => array(      'arguments' => array('form' => NULL),    ),    'node_filter_form' => array(      'arguments' => array('form' => NULL),      'file' => 'node.admin.inc',    ),    'node_filters' => array(      'arguments' => array('form' => NULL),      'file' => 'node.admin.inc',    ),    'node_admin_nodes' => array(      'arguments' => array('form' => NULL),      'file' => 'node.admin.inc',    ),    'node_add_list' => array(      'arguments' => array('content' => NULL),      'file' => 'node.pages.inc',    ),    'node_form' => array(      'arguments' => array('form' => NULL),      'file' => 'node.pages.inc',    ),    'node_preview' => array(      'arguments' => array('node' => NULL),      'file' => 'node.pages.inc',    ),    'node_log_message' => array(      'arguments' => array('log' => NULL),    ),    'node_submitted' => array(      'arguments' => array('node' => NULL),    ),  );}/** * Implementation of hook_cron(). */function node_cron() {  db_query('DELETE FROM {history} WHERE timestamp < %d', NODE_NEW_LIMIT);}/** * Gather a listing of links to nodes. * * @param $result *   A DB result object from a query to fetch node objects. If your query *   joins the <code>node_comment_statistics</code> table so that the *   <code>comment_count</code> field is available, a title attribute will *   be added to show the number of comments. * @param $title *   A heading for the resulting list. * * @return *   An HTML list suitable as content for a block, or FALSE if no result can *   fetch from DB result object. */function node_title_list($result, $title = NULL) {  $items = array();  $num_rows = FALSE;  while ($node = db_fetch_object($result)) {    $items[] = l($node->title, 'node/'. $node->nid, !empty($node->comment_count) ? array('attributes' => array('title' => format_plural($node->comment_count, '1 comment', '@count comments'))) : array());    $num_rows = TRUE;  }  return $num_rows ? theme('node_list', $items, $title) : FALSE;}/** * Format a listing of links to nodes. * * @ingroup themeable */function theme_node_list($items, $title = NULL) {  return theme('item_list', $items, $title);}/** * Update the 'last viewed' timestamp of the specified node for current user. */function node_tag_new($nid) {  global $user;  if ($user->uid) {    if (node_last_viewed($nid)) {      db_query('UPDATE {history} SET timestamp = %d WHERE uid = %d AND nid = %d', time(), $user->uid, $nid);    }    else {      @db_query('INSERT INTO {history} (uid, nid, timestamp) VALUES (%d, %d, %d)', $user->uid, $nid, time());    }  }}/** * Retrieves the timestamp at which the current user last viewed the * specified node. */function node_last_viewed($nid) {  global $user;  static $history;  if (!isset($history[$nid])) {    $history[$nid] = db_fetch_object(db_query("SELECT timestamp FROM {history} WHERE uid = %d AND nid = %d", $user->uid, $nid));  }  return (isset($history[$nid]->timestamp) ? $history[$nid]->timestamp : 0);}/** * Decide on the type of marker to be displayed for a given node. * * @param $nid *   Node ID whose history supplies the "last viewed" timestamp. * @param $timestamp *   Time which is compared against node's "last viewed" timestamp. * @return *   One of the MARK constants. */function node_mark($nid, $timestamp) {  global $user;  static $cache;  if (!$user->uid) {    return MARK_READ;  }  if (!isset($cache[$nid])) {    $cache[$nid] = node_last_viewed($nid);  }  if ($cache[$nid] == 0 && $timestamp > NODE_NEW_LIMIT) {    return MARK_NEW;  }  elseif ($timestamp > $cache[$nid] && $timestamp > NODE_NEW_LIMIT) {    return MARK_UPDATED;  }  return MARK_READ;}/** * See if the user used JS to submit a teaser. */function node_teaser_js(&$form, &$form_state) {  if (isset($form['#post']['teaser_js'])) {    // Glue the teaser to the body.    if (trim($form_state['values']['teaser_js'])) {      // Space the teaser from the body      $body = trim($form_state['values']['teaser_js']) ."\r\n<!--break-->\r\n". trim($form_state['values']['body']);    }    else {      // Empty teaser, no spaces.      $body = '<!--break-->'. $form_state['values']['body'];    }    // Pass updated body value on to preview/submit form processing.    form_set_value($form['body'], $body, $form_state);    // Pass updated body value back onto form for those cases    // in which the form is redisplayed.    $form['body']['#value'] = $body;  }  return $form;}/** * Ensure value of "teaser_include" checkbox is consistent with other form data. * * This handles two situations in which an unchecked checkbox is rejected: * *   1. The user defines a teaser (summary) but it is empty; *   2. The user does not define a teaser (summary) (in this case an *      unchecked checkbox would cause the body to be empty, or missing *      the auto-generated teaser). * * If JavaScript is active then it is used to force the checkbox to be * checked when hidden, and so the second case will not arise. * * In either case a warning message is output. */function node_teaser_include_verify(&$form, &$form_state) {  $message = '';  // $form['#post'] is set only when the form is built for preview/submit.  if (isset($form['#post']['body']) && isset($form_state['values']['teaser_include']) && !$form_state['values']['teaser_include']) {    // "teaser_include" checkbox is present and unchecked.    if (strpos($form_state['values']['body'], '<!--break-->') === 0) {      // Teaser is empty string.      $message = t('You specified that the summary should not be shown when this post is displayed in full view. This setting is ignored when the summary is empty.');    }    elseif (strpos($form_state['values']['body'], '<!--break-->') === FALSE) {      // Teaser delimiter is not present in the body.      $message = t('You specified that the summary should not be shown when this post is displayed in full view. This setting has been ignored since you have not defined a summary for the post. (To define a summary, insert the delimiter "&lt;!--break--&gt;" (without the quotes) in the Body of the post to indicate the end of the summary and the start of the main content.)');    }    if (!empty($message)) {      drupal_set_message($message, 'warning');      // Pass new checkbox value on to preview/submit form processing.      form_set_value($form['teaser_include'], 1, $form_state);      // Pass new checkbox value back onto form for those cases      // in which form is redisplayed.      $form['teaser_include']['#value'] = 1;    }  }  return $form;}/** * Generate a teaser for a node body. * * If the end of the teaser is not indicated using the <!--break--> delimiter * then we generate the teaser automatically, trying to end it at a sensible * place such as the end of a paragraph, a line break, or the end of a * sentence (in that order of preference). * * @param $body *   The content for which a teaser will be generated. * @param $format *   The format of the content. If the content contains PHP code, we do not *   split it up to prevent parse errors. If the line break filter is present *   then we treat newlines embedded in $body as line breaks. * @param $size *   The desired character length of the teaser. If omitted, the default *   value will be used. Ignored if the special delimiter is present *   in $body. * @return *   The generated teaser. */function node_teaser($body, $format = NULL, $size = NULL) {  if (!isset($size)) {    $size = variable_get('teaser_length', 600);  }  // Find where the delimiter is in the body  $delimiter = strpos($body, '<!--break-->');  // If the size is zero, and there is no delimiter, the entire body is the teaser.  if ($size == 0 && $delimiter === FALSE) {    return $body;  }  // If a valid delimiter has been specified, use it to chop off the teaser.  if ($delimiter !== FALSE) {    return substr($body, 0, $delimiter);  }  // We check for the presence of the PHP evaluator filter in the current  // format. If the body contains PHP code, we do not split it up to prevent  // parse errors.  if (isset($format)) {    $filters = filter_list_format($format);    if (isset($filters['php/0']) && strpos($body, '<?') !== FALSE) {      return $body;    }  }  // If we have a short body, the entire body is the teaser.  if (drupal_strlen($body) <= $size) {    return $body;  }  // If the delimiter has not been specified, try to split at paragraph or  // sentence boundaries.  // The teaser may not be longer than maximum length specified. Initial slice.  $teaser = truncate_utf8($body, $size);  // Store the actual length of the UTF8 string -- which might not be the same  // as $size.  $max_rpos = strlen($teaser);  // How much to cut off the end of the teaser so that it doesn't end in the  // middle of a paragraph, sentence, or word.  // Initialize it to maximum in order to find the minimum.  $min_rpos = $max_rpos;  // Store the reverse of the teaser.  We use strpos on the reversed needle and  // haystack for speed and convenience.  $reversed = strrev($teaser);  // Build an array of arrays of break points grouped by preference.  $break_points = array();  // A paragraph near the end of sliced teaser is most preferable.  $break_points[] = array('</p>' => 0);  // If no complete paragraph then treat line breaks as paragraphs.  $line_breaks = array('<br />' => 6, '<br>' => 4);  // Newline only indicates a line break if line break converter  // filter is present.  if (isset($filters['filter/1'])) {    $line_breaks["\n"] = 1;  }  $break_points[] = $line_breaks;  // If the first paragraph is too long, split at the end of a sentence.  $break_points[] = array('. ' => 1, '! ' => 1, '? ' => 1, '' => 0, ' ' => 1);  // Iterate over the groups of break points until a break point is found.  foreach ($break_points as $points) {    // Look for each break point, starting at the end of the teaser.    foreach ($points as $point => $offset) {      // The teaser is already reversed, but the break point isn't.      $rpos = strpos($reversed, strrev($point));      if ($rpos !== FALSE) {        $min_rpos = min($rpos + $offset, $min_rpos);      }    }    // If a break point was found in this group, slice and return the teaser.    if ($min_rpos !== $max_rpos) {      // Don't slice with length 0.  Length must be <0 to slice from RHS.      return ($min_rpos === 0) ? $teaser : substr($teaser, 0, 0 - $min_rpos);    }  }  // If a break point was not found, still return a teaser.  return $teaser;}/** * Builds a list of available node types, and returns all of part of this list * in the specified format. * * @param $op *   The format in which to return the list. When this is set to 'type', *   'module', or 'name', only the specified node type is returned. When set to *   'types' or 'names', all node types are returned. * @param $node *   A node object, array, or string that indicates the node type to return. *   Leave at default value (NULL) to return a list of all node types. * @param $reset *   Whether or not to reset this function's internal cache (defaults to *   FALSE). * * @return *   Either an array of all available node types, or a single node type, in a *   variable format. Returns FALSE if the node type is not found. */function node_get_types($op = 'types', $node = NULL, $reset = FALSE) {  static $_node_types, $_node_names;  if ($reset || !isset($_node_types)) {    list($_node_types, $_node_names) = _node_types_build();  }  if ($node) {    if (is_array($node)) {      $type = $node['type'];    }    elseif (is_object($node)) {      $type = $node->type;    }    elseif (is_string($node)) {      $type = $node;    }    if (!isset($_node_types[$type])) {      return FALSE;    }  }  switch ($op) {    case 'types':      return $_node_types;    case 'type':      return isset($_node_types[$type]) ? $_node_types[$type] : FALSE;    case 'module':      return isset($_node_types[$type]->module) ? $_node_types[$type]->module : FALSE;    case 'names':      return $_node_names;    case 'name':      return isset($_node_names[$type]) ? $_node_names[$type] : FALSE;  }}/** * Resets the database cache of node types, and saves all new or non-modified * module-defined node types to the database. */function node_types_rebuild() {  _node_types_build();  $node_types = node_get_types('types', NULL, TRUE);  foreach ($node_types as $type => $info) {    if (!empty($info->is_new)) {      node_type_save($info);    }    if (!empty($info->disabled)) {      node_type_delete($info->type);    }  }  _node_types_build();}/** * Saves a node type to the database. * * @param $info *   The node type to save, as an object. * * @return *   Status flag indicating outcome of the operation. */function node_type_save($info) {  $is_existing = FALSE;  $existing_type = !empty($info->old_type) ? $info->old_type : $info->type;  $is_existing = db_result(db_query("SELECT COUNT(*) FROM {node_type} WHERE type = '%s'", $existing_type));  if (!isset($info->help)) {    $info->help = '';  }  if (!isset($info->min_word_count)) {    $info->min_word_count = 0;  }  if (!isset($info->body_label)) {    $info->body_label = '';  }  if ($is_existing) {    db_query("UPDATE {node_type} SET type = '%s', name = '%s', module = '%s', has_title = %d, title_label = '%s', has_body = %d, body_label = '%s', description = '%s', help = '%s', min_word_count = %d, custom = %d, modified = %d, locked = %d WHERE type = '%s'", $info->type, $info->name, $info->module, $info->has_title, $info->title_label, $info->has_body, $info->body_label, $info->description, $info->help, $info->min_word_count, $info->custom, $info->modified, $info->locked, $existing_type);    module_invoke_all('node_type', 'update', $info);    return SAVED_UPDATED;  }  else {    db_query("INSERT INTO {node_type} (type, name, module, has_title, title_label, has_body, body_label, description, help, min_word_count, custom, modified, locked, orig_type) VALUES ('%s', '%s', '%s', %d, '%s', %d, '%s', '%s', '%s', %d, %d, %d, %d, '%s')", $info->type, $info->name, $info->module, $info->has_title, $info->title_label, $info->has_body, $info->body_label, $info->description, $info->help, $info->min_word_count, $info->custom, $info->modified, $info->locked, $info->orig_type);    module_invoke_all('node_type', 'insert', $info);    return SAVED_NEW;  }}/** * Deletes a node type from the database. * * @param $type *   The machine-readable name of the node type to be deleted. */function node_type_delete($type) {  $info = node_get_types('type', $type);  db_query("DELETE FROM {node_type} WHERE type = '%s'", $type);  module_invoke_all('node_type', 'delete', $info);}/** * Updates all nodes of one type to be of another type. * * @param $old_type *   The current node type of the nodes. * @param $type *   The new node type of the nodes. * * @return *   The number of nodes whose node type field was modified. */function node_type_update_nodes($old_type, $type) {  db_query("UPDATE {node} SET type = '%s' WHERE type = '%s'", $type, $old_type);  return db_affected_rows();}/** * Builds and returns the list of available node types. * * The list of types is built by querying hook_node_info() in all modules, and * by comparing this information with the node types in the {node_type} table. * */function _node_types_build() {  $_node_types = array();  $_node_names = array();  $info_array = module_invoke_all('node_info');  foreach ($info_array as $type => $info) {    $info['type'] = $type;    $_node_types[$type] = (object) _node_type_set_defaults($info);    $_node_names[$type] = $info['name'];  }  $type_result = db_query(db_rewrite_sql('SELECT nt.type, nt.* FROM {node_type} nt ORDER BY nt.type ASC', 'nt', 'type'));  while ($type_object = db_fetch_object($type_result)) {    // Check for node types from disabled modules and mark their types for removal.    // Types defined by the node module in the database (rather than by a separate    // module using hook_node_info) have a module value of 'node'.    if ($type_object->module != 'node' && empty($info_array[$type_object->type])) {      $type_object->disabled = TRUE;    }    if (!isset($_node_types[$type_object->type]) || $type_object->modified) {      $_node_types[$type_object->type] = $type_object;      $_node_names[$type_object->type] = $type_object->name;      if ($type_object->type != $type_object->orig_type) {        unset($_node_types[$type_object->orig_type]);        unset($_node_names[$type_object->orig_type]);      }    }  }  asort($_node_names);  return array($_node_types, $_node_names);}/** * Set default values for a node type defined through hook_node_info(). */function _node_type_set_defaults($info) {  if (!isset($info['has_title'])) {    $info['has_title'] = TRUE;  }  if ($info['has_title'] && !isset($info['title_label'])) {    $info['title_label'] = t('Title');  }  if (!isset($info['has_body'])) {    $info['has_body'] = TRUE;  }  if ($info['has_body'] && !isset($info['body_label'])) {    $info['body_label'] = t('Body');  }  if (!isset($info['help'])) {    $info['help'] = '';  }  if (!isset($info['min_word_count'])) {    $info['min_word_count'] = 0;  }  if (!isset($info['custom'])) {    $info['custom'] = FALSE;  }  if (!isset($info['modified'])) {    $info['modified'] = FALSE;  }  if (!isset($info['locked'])) {    $info['locked'] = TRUE;  }  $info['orig_type'] = $info['type'];  $info['is_new'] = TRUE;  return $info;}/** * Determine whether a node hook exists. * * @param &$node *   Either a node object, node array, or a string containing the node type. * @param $hook *   A string containing the name of the hook. * @return *   TRUE iff the $hook exists in the node type of $node. */function node_hook(&$node, $hook) {  $module = node_get_types('module', $node);  if ($module == 'node') {    $module = 'node_content'; // Avoid function name collisions.  }  return module_hook($module, $hook);}/** * Invoke a node hook. * * @param &$node *   Either a node object, node array, or a string containing the node type. * @param $hook *   A string containing the name of the hook. * @param $a2, $a3, $a4 *   Arguments to pass on to the hook, after the $node argument. * @return *   The returned value of the invoked hook. */function node_invoke(&$node, $hook, $a2 = NULL, $a3 = NULL, $a4 = NULL) {  if (node_hook($node, $hook)) {    $module = node_get_types('module', $node);    if ($module == 'node') {      $module = 'node_content'; // Avoid function name collisions.    }    $function = $module .'_'. $hook;    return ($function($node, $a2, $a3, $a4));  }}/** * Invoke a hook_nodeapi() operation in all modules. * * @param &$node *   A node object. * @param $op *   A string containing the name of the nodeapi operation. * @param $a3, $a4 *   Arguments to pass on to the hook, after the $node and $op arguments. * @return *   The returned value of the invoked hooks. */function node_invoke_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {  $return = array();  foreach (module_implements('nodeapi') as $name) {    $function = $name .'_nodeapi';    $result = $function($node, $op, $a3, $a4);    if (isset($result) && is_array($result)) {      $return = array_merge($return, $result);    }    else if (isset($result)) {      $return[] = $result;    }  }  return $return;}/** * Load a node object from the database. * * @param $param *   Either the nid of the node or an array of conditions to match against in the database query * @param $revision *   Which numbered revision to load. Defaults to the current version. * @param $reset *   Whether to reset the internal node_load cache. * * @return *   A fully-populated node object. */function node_load($param = array(), $revision = NULL, $reset = NULL) {  static $nodes = array();  if ($reset) {    $nodes = array();  }  $cachable = ($revision == NULL);  $arguments = array();  if (is_numeric($param)) {    if ($cachable) {      // Is the node statically cached?      if (isset($nodes[$param])) {        return is_object($nodes[$param]) ? drupal_clone($nodes[$param]) : $nodes[$param];      }    }    $cond = 'n.nid = %d';    $arguments[] = $param;  }  elseif (is_array($param)) {    // Turn the conditions into a query.    foreach ($param as $key => $value) {      $cond[] = 'n.'. db_escape_table($key) ." = '%s'";      $arguments[] = $value;    }    $cond = implode(' AND ', $cond);  }  else {    return FALSE;  }  // Retrieve a field list based on the site's schema.  $fields = drupal_schema_fields_sql('node', 'n');  $fields = array_merge($fields, drupal_schema_fields_sql('node_revisions', 'r'));  $fields = array_merge($fields, array('u.name', 'u.picture', 'u.data'));  // Remove fields not needed in the query: n.vid and r.nid are redundant,  // n.title is unnecessary because the node title comes from the  // node_revisions table.  We'll keep r.vid, r.title, and n.nid.  $fields = array_diff($fields, array('n.vid', 'n.title', 'r.nid'));  $fields = implode(', ', $fields);  // Rename timestamp field for clarity.  $fields = str_replace('r.timestamp', 'r.timestamp AS revision_timestamp', $fields);  // Change name of revision uid so it doesn't conflict with n.uid.  $fields = str_replace('r.uid', 'r.uid AS revision_uid', $fields);  // Retrieve the node.  // No db_rewrite_sql is applied so as to get complete indexing for search.  if ($revision) {    array_unshift($arguments, $revision);    $node = db_fetch_object(db_query('SELECT '. $fields .' FROM {node} n INNER JOIN {users} u ON u.uid = n.uid INNER JOIN {node_revisions} r ON r.nid = n.nid AND r.vid = %d WHERE '. $cond, $arguments));  }  else {    $node = db_fetch_object(db_query('SELECT '. $fields .' FROM {node} n INNER JOIN {users} u ON u.uid = n.uid INNER JOIN {node_revisions} r ON r.vid = n.vid WHERE '. $cond, $arguments));  }  if ($node && $node->nid) {    // Call the node specific callback (if any) and piggy-back the    // results to the node or overwrite some values.    if ($extra = node_invoke($node, 'load')) {      foreach ($extra as $key => $value) {        $node->$key = $value;      }    }    if ($extra = node_invoke_nodeapi($node, 'load')) {      foreach ($extra as $key => $value) {        $node->$key = $value;      }    }    if ($cachable) {      $nodes[$node->nid] = is_object($node) ? drupal_clone($node) : $node;    }  }  return $node;}/** * Perform validation checks on the given node. */function node_validate($node, $form = array()) {  // Convert the node to an object, if necessary.  $node = (object)$node;  $type = node_get_types('type', $node);  // Make sure the body has the minimum number of words.  // TODO : use a better word counting algorithm that will work in other languages  if (!empty($type->min_word_count) && isset($node->body) && count(explode(' ', $node->body)) < $type->min_word_count) {    form_set_error('body', t('The body of your @type is too short. You need at least %words words.', array('%words' => $type->min_word_count, '@type' => $type->name)));  }  if (isset($node->nid) && (node_last_changed($node->nid) > $node->changed)) {    form_set_error('changed', t('This content has been modified by another user, changes cannot be saved.'));  }  if (user_access('administer nodes')) {    // Validate the "authored by" field.    if (!empty($node->name) && !($account = user_load(array('name' => $node->name)))) {      // The use of empty() is mandatory in the context of usernames      // as the empty string denotes the anonymous user. In case we      // are dealing with an anonymous user we set the user ID to 0.      form_set_error('name', t('The username %name does not exist.', array('%name' => $node->name)));    }    // Validate the "authored on" field. As of PHP 5.1.0, strtotime returns FALSE instead of -1 upon failure.    if (!empty($node->date) && strtotime($node->date) <= 0) {      form_set_error('date', t('You have to specify a valid date.'));    }  }  // Do node-type-specific validation checks.  node_invoke($node, 'validate', $form);  node_invoke_nodeapi($node, 'validate', $form);}/** * Prepare node for save and allow modules to make changes. */function node_submit($node) {  global $user;  // Convert the node to an object, if necessary.  $node = (object)$node;  // Generate the teaser, but only if it hasn't been set (e.g. by a  // module-provided 'teaser' form item).  if (!isset($node->teaser)) {    if (isset($node->body)) {      $node->teaser = node_teaser($node->body, isset($node->format) ? $node->format : NULL);      // Chop off the teaser from the body if needed. The teaser_include      // property might not be set (eg. in Blog API postings), so only act on      // it, if it was set with a given value.      if (isset($node->teaser_include) && !$node->teaser_include && $node->teaser == substr($node->body, 0, strlen($node->teaser))) {        $node->body = substr($node->body, strlen($node->teaser));      }    }    else {      $node->teaser = '';      $node->format = 0;    }  }  if (user_access('administer nodes')) {    // Populate the "authored by" field.    if ($account = user_load(array('name' => $node->name))) {      $node->uid = $account->uid;    }    else {      $node->uid = 0;    }  }  $node->created = !empty($node->date) ? strtotime($node->date) : time();  $node->validated = TRUE;  return $node;}/** * Save a node object into the database. */function node_save(&$node) {  // Let modules modify the node before it is saved to the database.  node_invoke_nodeapi($node, 'presave');  global $user;  // Insert a new node.  $node->is_new = empty($node->nid);  if ($node->is_new || !empty($node->revision)) {    // When inserting a node, $node->log must be set because    // {node_revisions}.log does not (and cannot) have a default    // value.  If the user does not have permission to create    // revisions, however, the form will not contain an element for    // log so $node->log will be unset at this point.    if (!isset($node->log)) {      $node->log = '';    }  }  elseif (empty($node->log)) {    // When updating a node, however, avoid clobbering an existing    // log entry with an empty one.    unset($node->log);  }  // For the same reasons, make sure we have $node->teaser and  // $node->body set.  if (!isset($node->teaser)) {    $node->teaser = '';  }  if (!isset($node->body)) {    $node->body = '';  }  // Save the old revision if needed.  if (!$node->is_new && !empty($node->revision) && $node->vid) {    $node->old_vid = $node->vid;  }  $time = time();  if (empty($node->created)) {    $node->created = $time;  }  // The changed timestamp is always updated for bookkeeping purposes (revisions, searching, ...)  $node->changed = $time;  $node->timestamp = $time;  $node->format = isset($node->format) ? $node->format : FILTER_FORMAT_DEFAULT;  // Generate the node table query and the node_revisions table query.  if ($node->is_new) {    _node_save_revision($node, $user->uid);    drupal_write_record('node', $node);    db_query('UPDATE {node_revisions} SET nid = %d WHERE vid = %d', $node->nid, $node->vid);    $op = 'insert';  }  else {    drupal_write_record('node', $node, 'nid');    if (!empty($node->revision)) {      _node_save_revision($node, $user->uid);      db_query('UPDATE {node} SET vid = %d WHERE nid = %d', $node->vid, $node->nid);    }    else {      _node_save_revision($node, $user->uid, 'vid');    }    $op = 'update';  }  // Call the node specific callback (if any).  node_invoke($node, $op);  node_invoke_nodeapi($node, $op);  // Update the node access table for this node.  node_access_acquire_grants($node);  // Clear the page and block caches.  cache_clear_all();}/** * Helper function to save a revision with the uid of the current user. * * Node is taken by reference, becuse drupal_write_record() updates the * $node with the revision id, and we need to pass that back to the caller. */function _node_save_revision(&$node, $uid, $update = NULL) {  $temp_uid = $node->uid;  $node->uid = $uid;  if (isset($update)) {    drupal_write_record('node_revisions', $node, $update);  }  else {    drupal_write_record('node_revisions', $node);  }  $node->uid = $temp_uid;}/** * Delete a node. */function node_delete($nid) {  // Clear the cache before the load, so if multiple nodes are deleted, the  // memory will not fill up with nodes (possibly) already removed.  $node = node_load($nid, NULL, TRUE);  if (node_access('delete', $node)) {    db_query('DELETE FROM {node} WHERE nid = %d', $node->nid);    db_query('DELETE FROM {node_revisions} WHERE nid = %d', $node->nid);    // Call the node-specific callback (if any):    node_invoke($node, 'delete');    node_invoke_nodeapi($node, 'delete');    // Clear the page and block caches.    cache_clear_all();    // Remove this node from the search index if needed.    if (function_exists('search_wipe')) {      search_wipe($node->nid, 'node');    }    watchdog('content', '@type: deleted %title.', array('@type' => $node->type, '%title' => $node->title));    drupal_set_message(t('@type %title has been deleted.', array('@type' => node_get_types('name', $node), '%title' => $node->title)));  }}/** * Generate a display of the given node. * * @param $node *   A node array or node object. * @param $teaser *   Whether to display the teaser only or the full form. * @param $page *   Whether the node is being displayed by itself as a page. * @param $links *   Whether or not to display node links. Links are omitted for node previews. * * @return *   An HTML representation of the themed node. */function node_view($node, $teaser = FALSE, $page = FALSE, $links = TRUE) {  $node = (object)$node;  $node = node_build_content($node, $teaser, $page);  if ($links) {    $node->links = module_invoke_all('link', 'node', $node, $teaser);    drupal_alter('link', $node->links, $node);  }  // Set the proper node part, then unset unused $node part so that a bad  // theme can not open a security hole.  $content = drupal_render($node->content);  if ($teaser) {    $node->teaser = $content;    unset($node->body);  }  else {    $node->body = $content;    unset($node->teaser);  }  // Allow modules to modify the fully-built node.  node_invoke_nodeapi($node, 'alter', $teaser, $page);  return theme('node', $node, $teaser, $page);}/** * Apply filters and build the node's standard elements. */function node_prepare($node, $teaser = FALSE) {  // First we'll overwrite the existing node teaser and body with  // the filtered copies! Then, we'll stick those into the content  // array and set the read more flag if appropriate.  $node->readmore = $node->teaser != $node->body;  if ($teaser == FALSE) {    $node->body = check_markup($node->body, $node->format, FALSE);  }  else {    $node->teaser = check_markup($node->teaser, $node->format, FALSE);  }  $node->content['body'] = array(    '#value' => $teaser ? $node->teaser : $node->body,    '#weight' => 0,  );  return $node;}/** * Builds a structured array representing the node's content. * * @param $node *   A node object. * @param $teaser *   Whether to display the teaser only, as on the main page. * @param $page *   Whether the node is being displayed by itself as a page. * * @return *   An structured array containing the individual elements *   of the node's body. */function node_build_content($node, $teaser = FALSE, $page = FALSE) {  // The build mode identifies the target for which the node is built.  if (!isset($node->build_mode)) {    $node->build_mode = NODE_BUILD_NORMAL;  }  // Remove the delimiter (if any) that separates the teaser from the body.  $node->body = isset($node->body) ? str_replace('<!--break-->', '', $node->body) : '';  // The 'view' hook can be implemented to overwrite the default function  // to display nodes.  if (node_hook($node, 'view')) {    $node = node_invoke($node, 'view', $teaser, $page);  }  else {    $node = node_prepare($node, $teaser);  }  // Allow modules to make their own additions to the node.  node_invoke_nodeapi($node, 'view', $teaser, $page);  return $node;}/** * Generate a page displaying a single node, along with its comments. */function node_show($node, $cid, $message = FALSE) {  if ($message) {    drupal_set_title(t('Revision of %title from %date', array('%title' => $node->title, '%date' => format_date($node->revision_timestamp))));  }  $output = node_view($node, FALSE, TRUE);  if (function_exists('comment_render') && $node->comment) {    $output .= comment_render($node, $cid);  }  // Update the history table, stating that this user viewed this node.  node_tag_new($node->nid);  return $output;}/** * Theme a log message. * * @ingroup themeable */function theme_node_log_message($log) {  return '<div class="log"><div class="title">'. t('Log') .':</div>'. $log .'</div>';}/** * Implementation of hook_perm(). */function node_perm() {  $perms = array('administer content types', 'administer nodes', 'access content', 'view revisions', 'revert revisions', 'delete revisions');  foreach (node_get_types() as $type) {    if ($type->module == 'node') {      $name = check_plain($type->type);      $perms[] = 'create '. $name .' content';      $perms[] = 'delete own '. $name .' content';      $perms[] = 'delete any '. $name .' content';      $perms[] = 'edit own '. $name .' content';      $perms[] = 'edit any '. $name .' content';    }  }  return $perms;}/** * Implementation of hook_search(). */function node_search($op = 'search', $keys = NULL) {  switch ($op) {    case 'name':      return t('Content');    case 'reset':      db_query("UPDATE {search_dataset} SET reindex = %d WHERE type = 'node'", time());      return;    case 'status':      $total = db_result(db_query('SELECT COUNT(*) FROM {node} WHERE status = 1'));      $remaining = db_result(db_query("SELECT COUNT(*) FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE n.status = 1 AND (d.sid IS NULL OR d.reindex <> 0)"));      return array('remaining' => $remaining, 'total' => $total);    case 'admin':      $form = array();      // Output form for defining rank factor weights.      $form['content_ranking'] = array(        '#type' => 'fieldset',        '#title' => t('Content ranking'),      );      $form['content_ranking']['#theme'] = 'node_search_admin';      $form['content_ranking']['info'] = array(        '#value' => '<em>'. t('The following numbers control which properties the content search should favor when ordering the results. Higher numbers mean more influence, zero means the property is ignored. Changing these numbers does not require the search index to be rebuilt. Changes take effect immediately.') .'</em>'      );      $ranking = array('node_rank_relevance' => t('Keyword relevance'),                       'node_rank_recent' => t('Recently posted'));      if (module_exists('comment')) {        $ranking['node_rank_comments'] = t('Number of comments');      }      if (module_exists('statistics') && variable_get('statistics_count_content_views', 0)) {        $ranking['node_rank_views'] = t('Number of views');      }      // Note: reversed to reflect that higher number = higher ranking.      $options = drupal_map_assoc(range(0, 10));      foreach ($ranking as $var => $title) {        $form['content_ranking']['factors'][$var] = array(          '#title' => $title,          '#type' => 'select',          '#options' => $options,          '#default_value' => variable_get($var, 5),        );      }      return $form;    case 'search':      // Build matching conditions      list($join1, $where1) = _db_rewrite_sql();      $arguments1 = array();      $conditions1 = 'n.status = 1';      if ($type = search_query_extract($keys, 'type')) {        $types = array();        foreach (explode(',', $type) as $t) {          $types[] = "n.type = '%s'";          $arguments1[] = $t;        }        $conditions1 .= ' AND ('. implode(' OR ', $types) .')';        $keys = search_query_insert($keys, 'type');      }      if ($category = search_query_extract($keys, 'category')) {        $categories = array();        foreach (explode(',', $category) as $c) {          $categories[] = "tn.tid = %d";          $arguments1[] = $c;        }        $conditions1 .= ' AND ('. implode(' OR ', $categories) .')';        $join1 .= ' INNER JOIN {term_node} tn ON n.vid = tn.vid';        $keys = search_query_insert($keys, 'category');      }      // Build ranking expression (we try to map each parameter to a      // uniform distribution in the range 0..1).      $ranking = array();      $arguments2 = array();      $join2 = '';      // Used to avoid joining on node_comment_statistics twice      $stats_join = FALSE;      $total = 0;      if ($weight = (int)variable_get('node_rank_relevance', 5)) {        // Average relevance values hover around 0.15        $ranking[] = '%d * i.relevance';        $arguments2[] = $weight;        $total += $weight;      }      if ($weight = (int)variable_get('node_rank_recent', 5)) {        // Exponential decay with half-life of 6 months, starting at last indexed node        $ranking[] = '%d * POW(2, (GREATEST(MAX(n.created), MAX(n.changed), MAX(c.last_comment_timestamp)) - %d) * 6.43e-8)';        $arguments2[] = $weight;        $arguments2[] = (int)variable_get('node_cron_last', 0);        $join2 .= ' LEFT JOIN {node_comment_statistics} c ON c.nid = i.sid';        $stats_join = TRUE;        $total += $weight;      }      if (module_exists('comment') && $weight = (int)variable_get('node_rank_comments', 5)) {        // Inverse law that maps the highest reply count on the site to 1 and 0 to 0.        $scale = variable_get('node_cron_comments_scale', 0.0);        $ranking[] = '%d * (2.0 - 2.0 / (1.0 + MAX(c.comment_count) * %f))';        $arguments2[] = $weight;        $arguments2[] = $scale;        if (!$stats_join) {          $join2 .= ' LEFT JOIN {node_comment_statistics} c ON c.nid = i.sid';        }        $total += $weight;      }      if (module_exists('statistics') && variable_get('statistics_count_content_views', 0) &&          $weight = (int)variable_get('node_rank_views', 5)) {        // Inverse law that maps the highest view count on the site to 1 and 0 to 0.        $scale = variable_get('node_cron_views_scale', 0.0);        $ranking[] = '%d * (2.0 - 2.0 / (1.0 + MAX(nc.totalcount) * %f))';        $arguments2[] = $weight;        $arguments2[] = $scale;        $join2 .= ' LEFT JOIN {node_counter} nc ON nc.nid = i.sid';        $total += $weight;      }            // When all search factors are disabled (ie they have a weight of zero),       // the default score is based only on keyword relevance and there is no need to       // adjust the score of each item.       if ($total == 0) {        $select2 = 'i.relevance AS score';        $total = 1;      }      else {        $select2 = implode(' + ', $ranking) . ' AS score';      }            // Do search.      $find = do_search($keys, 'node', 'INNER JOIN {node} n ON n.nid = i.sid '. $join1, $conditions1 . (empty($where1) ? '' : ' AND '. $where1), $arguments1, $select2, $join2, $arguments2);      // Load results.      $results = array();      foreach ($find as $item) {        // Build the node body.        $node = node_load($item->sid);        $node->build_mode = NODE_BUILD_SEARCH_RESULT;        $node = node_build_content($node, FALSE, FALSE);        $node->body = drupal_render($node->content);        // Fetch comments for snippet.        $node->body .= module_invoke('comment', 'nodeapi', $node, 'update index');        // Fetch terms for snippet.        $node->body .= module_invoke('taxonomy', 'nodeapi', $node, 'update index');        $extra = node_invoke_nodeapi($node, 'search result');        $results[] = array(          'link' => url('node/'. $item->sid, array('absolute' => TRUE)),          'type' => check_plain(node_get_types('name', $node)),          'title' => $node->title,          'user' => theme('username', $node),          'date' => $node->changed,          'node' => $node,          'extra' => $extra,          'score' => $item->score / $total,          'snippet' => search_excerpt($keys, $node->body),        );      }      return $results;  }}/** * Implementation of hook_user(). */function node_user($op, &$edit, &$user) {  if ($op == 'delete') {    db_query('UPDATE {node} SET uid = 0 WHERE uid = %d', $user->uid);    db_query('UPDATE {node_revisions} SET uid = 0 WHERE uid = %d', $user->uid);  }}/** * Theme the content ranking part of the search settings admin page. * * @ingroup themeable */function theme_node_search_admin($form) {  $output = drupal_render($form['info']);  $header = array(t('Factor'), t('Weight'));  foreach (element_children($form['factors']) as $key) {    $row = array();    $row[] = $form['factors'][$key]['#title'];    unset($form['factors'][$key]['#title']);    $row[] = drupal_render($form['factors'][$key]);    $rows[] = $row;  }  $output .= theme('table', $header, $rows);  $output .= drupal_render($form);  return $output;}/** * Retrieve the comment mode for the given node ID (none, read, or read/write). */function node_comment_mode($nid) {  static $comment_mode;  if (!isset($comment_mode[$nid])) {    $comment_mode[$nid] = db_result(db_query('SELECT comment FROM {node} WHERE nid = %d', $nid));  }  return $comment_mode[$nid];}/** * Implementation of hook_link(). */function node_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node') {    if ($teaser == 1 && $node->teaser && !empty($node->readmore)) {      $links['node_read_more'] = array(        'title' => t('Read more'),        'href' => "node/$node->nid",        // The title attribute gets escaped when the links are processed, so        // there is no need to escape here.        'attributes' => array('title' => t('Read the rest of !title.', array('!title' => $node->title)))      );    }  }  return $links;}function _node_revision_access($node, $op = 'view') {  static $access = array();  if (!isset($access[$node->vid])) {    $node_current_revision = node_load($node->nid);    $is_current_revision = $node_current_revision->vid == $node->vid;    // There should be at least two revisions. If the vid of the given node    // and the vid of the current revision differs, then we already have two    // different revisions so there is no need for a separate database check.    // Also, if you try to revert to or delete the current revision, that's    // not good.    if ($is_current_revision && (db_result(db_query('SELECT COUNT(vid) FROM {node_revisions} WHERE nid = %d', $node->nid)) == 1 || $op == 'update' || $op == 'delete')) {      $access[$node->vid] = FALSE;    }    elseif (user_access('administer nodes')) {      $access[$node->vid] = TRUE;    }    else {      $map = array('view' => 'view revisions', 'update' => 'revert revisions', 'delete' => 'delete revisions');      // First check the user permission, second check the access to the      // current revision and finally, if the node passed in is not the current      // revision then access to that, too.      $access[$node->vid] = isset($map[$op]) && user_access($map[$op]) && node_access($op, $node_current_revision) && ($is_current_revision || node_access($op, $node));    }  }  return $access[$node->vid];}function _node_add_access() {  $types = node_get_types();  foreach ($types as $type) {    if (node_hook($type->type, 'form') && node_access('create', $type->type)) {      return TRUE;    }  }  return FALSE;}/** * Implementation of hook_menu(). */function node_menu() {  $items['admin/content/node'] = array(    'title' => 'Content',    'description' => "View, edit, and delete your site's content.",    'page callback' => 'drupal_get_form',    'page arguments' => array('node_admin_content'),    'access arguments' => array('administer nodes'),    'file' => 'node.admin.inc',  );  $items['admin/content/node/overview'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/node-settings'] = array(    'title' => 'Post settings',    'description' => 'Control posting behavior, such as teaser length, requiring previews before posting, and the number of posts on the front page.',    'page callback' => 'drupal_get_form',    'page arguments' => array('node_configure'),    'access arguments' => array('administer nodes'),    'file' => 'node.admin.inc',  );  $items['admin/content/node-settings/rebuild'] = array(    'title' => 'Rebuild permissions',    'page arguments' => array('node_configure_rebuild_confirm'),    'file' => 'node.admin.inc',    // Any user than can potentially trigger a node_acess_needs_rebuild(TRUE)    // has to be allowed access to the 'node access rebuild' confirm form.    'access arguments' => array('access administration pages'),    'type' => MENU_CALLBACK,  );  $items['admin/content/types'] = array(    'title' => 'Content types',    'description' => 'Manage posts by content type, including default status, front page promotion, etc.',    'page callback' => 'node_overview_types',    'access arguments' => array('administer content types'),    'file' => 'content_types.inc',  );  $items['admin/content/types/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/types/add'] = array(    'title' => 'Add content type',    'page callback' => 'drupal_get_form',    'page arguments' => array('node_type_form'),    'access arguments' => array('administer content types'),    'file' => 'content_types.inc',    'type' => MENU_LOCAL_TASK,  );  $items['node'] = array(    'title' => 'Content',    'page callback' => 'node_page_default',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,  );  $items['node/add'] = array(    'title' => 'Create content',    'page callback' => 'node_add_page',    'access callback' => '_node_add_access',    'weight' => 1,    'file' => 'node.pages.inc',  );  $items['rss.xml'] = array(    'title' => 'RSS feed',    'page callback' => 'node_feed',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,  );  foreach (node_get_types('types', NULL, TRUE) as $type) {    $type_url_str = str_replace('_', '-', $type->type);    $items['node/add/'. $type_url_str] = array(      'title' => drupal_ucfirst($type->name),      'title callback' => 'check_plain',      'page callback' => 'node_add',      'page arguments' => array(2),      'access callback' => 'node_access',      'access arguments' => array('create', $type->type),      'description' => $type->description,      'file' => 'node.pages.inc',    );    $items['admin/content/node-type/'. $type_url_str] = array(      'title' => $type->name,      'page callback' => 'drupal_get_form',      'page arguments' => array('node_type_form', $type),      'access arguments' => array('administer content types'),      'file' => 'content_types.inc',      'type' => MENU_CALLBACK,    );    $items['admin/content/node-type/'. $type_url_str .'/edit'] = array(      'title' => 'Edit',      'type' => MENU_DEFAULT_LOCAL_TASK,    );    $items['admin/content/node-type/'. $type_url_str .'/delete'] = array(      'title' => 'Delete',      'page arguments' => array('node_type_delete_confirm', $type),      'access arguments' => array('administer content types'),      'file' => 'content_types.inc',      'type' => MENU_CALLBACK,    );  }  $items['node/%node'] = array(    'title callback' => 'node_page_title',    'title arguments' => array(1),    'page callback' => 'node_page_view',    'page arguments' => array(1),    'access callback' => 'node_access',    'access arguments' => array('view', 1),    'type' => MENU_CALLBACK);  $items['node/%node/view'] = array(    'title' => 'View',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10);  $items['node/%node/edit'] = array(    'title' => 'Edit',    'page callback' => 'node_page_edit',    'page arguments' => array(1),    'access callback' => 'node_access',    'access arguments' => array('update', 1),    'weight' => 1,    'file' => 'node.pages.inc',    'type' => MENU_LOCAL_TASK,  );  $items['node/%node/delete'] = array(    'title' => 'Delete',    'page callback' => 'drupal_get_form',    'page arguments' => array('node_delete_confirm', 1),    'access callback' => 'node_access',    'access arguments' => array('delete', 1),    'file' => 'node.pages.inc',    'weight' => 1,    'type' => MENU_CALLBACK);  $items['node/%node/revisions'] = array(    'title' => 'Revisions',    'page callback' => 'node_revision_overview',    'page arguments' => array(1),    'access callback' => '_node_revision_access',    'access arguments' => array(1),    'weight' => 2,    'file' => 'node.pages.inc',    'type' => MENU_LOCAL_TASK,  );  $items['node/%node/revisions/%/view'] = array(    'title' => 'Revisions',    'load arguments' => array(3),    'page callback' => 'node_show',    'page arguments' => array(1, NULL, TRUE),    'access callback' => '_node_revision_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,  );  $items['node/%node/revisions/%/revert'] = array(    'title' => 'Revert to earlier revision',    'load arguments' => array(3),    'page callback' => 'drupal_get_form',    'page arguments' => array('node_revision_revert_confirm', 1),    'access callback' => '_node_revision_access',    'access arguments' => array(1, 'update'),    'file' => 'node.pages.inc',    'type' => MENU_CALLBACK,  );  $items['node/%node/revisions/%/delete'] = array(    'title' => 'Delete earlier revision',    'load arguments' => array(3),    'page callback' => 'drupal_get_form',    'page arguments' => array('node_revision_delete_confirm', 1),    'access callback' => '_node_revision_access',    'access arguments' => array(1, 'delete'),    'file' => 'node.pages.inc',    'type' => MENU_CALLBACK,  );  return $items;}/** * Title callback. */function node_page_title($node) {  return $node->title;}/** * Implementation of hook_init(). */function node_init() {  drupal_add_css(drupal_get_path('module', 'node') .'/node.css');}function node_last_changed($nid) {  $node = db_fetch_object(db_query('SELECT changed FROM {node} WHERE nid = %d', $nid));  return ($node->changed);}/** * Return a list of all the existing revision numbers. */function node_revision_list($node) {  $revisions = array();  $result = db_query('SELECT r.vid, r.title, r.log, r.uid, n.vid AS current_vid, r.timestamp, u.name FROM {node_revisions} r LEFT JOIN {node} n ON n.vid = r.vid INNER JOIN {users} u ON u.uid = r.uid WHERE r.nid = %d ORDER BY r.timestamp DESC', $node->nid);  while ($revision = db_fetch_object($result)) {    $revisions[$revision->vid] = $revision;  }  return $revisions;}/** * Implementation of hook_block(). */function node_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Syndicate');    // Not worth caching.    $blocks[0]['cache'] = BLOCK_NO_CACHE;    return $blocks;  }  else if ($op == 'view') {    $block['subject'] = t('Syndicate');    $block['content'] = theme('feed_icon', url('rss.xml'), t('Syndicate'));    return $block;  }}/** * A generic function for generating RSS feeds from a set of nodes. * * @param $nids *   An array of node IDs (nid). Defaults to FALSE so empty feeds can be *   generated with passing an empty array, if no items are to be added *   to the feed. * @param $channel *   An associative array containing title, link, description and other keys. *   The link should be an absolute URL. */function node_feed($nids = FALSE, $channel = array()) {  global $base_url, $language;  if ($nids === FALSE) {    $nids = array();    $result = db_query_range(db_rewrite_sql('SELECT n.nid, n.created FROM {node} n WHERE n.promote = 1 AND n.status = 1 ORDER BY n.created DESC'), 0, variable_get('feed_default_items', 10));    while ($row = db_fetch_object($result)) {      $nids[] = $row->nid;    }  }  $item_length = variable_get('feed_item_length', 'teaser');  $namespaces = array('xmlns:dc' => 'http://purl.org/dc/elements/1.1/');  $items = '';  foreach ($nids as $nid) {    // Load the specified node:    $item = node_load($nid);    $item->build_mode = NODE_BUILD_RSS;    $item->link = url("node/$nid", array('absolute' => TRUE));    if ($item_length != 'title') {      $teaser = ($item_length == 'teaser') ? TRUE : FALSE;      // Filter and prepare node teaser      if (node_hook($item, 'view')) {        $item = node_invoke($item, 'view', $teaser, FALSE);      }      else {        $item = node_prepare($item, $teaser);      }      // Allow modules to change $node->content before the node is rendered.      node_invoke_nodeapi($item, 'view', $teaser, FALSE);      // Set the proper node property, then unset unused $node property so that a      // bad theme can not open a security hole.      $content = drupal_render($item->content);      if ($teaser) {        $item->teaser = $content;        unset($item->body);      }      else {        $item->body = $content;        unset($item->teaser);      }          // Allow modules to modify the fully-built node.      node_invoke_nodeapi($item, 'alter', $teaser, FALSE);    }    // Allow modules to add additional item fields and/or modify $item    $extra = node_invoke_nodeapi($item, 'rss item');    $extra = array_merge($extra, array(array('key' => 'pubDate', 'value' => gmdate('r', $item->created)), array('key' => 'dc:creator', 'value' => $item->name), array('key' => 'guid', 'value' => $item->nid .' at '. $base_url, 'attributes' => array('isPermaLink' => 'false'))));    foreach ($extra as $element) {      if (isset($element['namespace'])) {        $namespaces = array_merge($namespaces, $element['namespace']);      }    }    // Prepare the item description    switch ($item_length) {      case 'fulltext':        $item_text = $item->body;        break;      case 'teaser':        $item_text = $item->teaser;        if (!empty($item->readmore)) {          $item_text .= '<p>'. l(t('read more'), 'node/'. $item->nid, array('absolute' => TRUE, 'attributes' => array('target' => '_blank'))) .'</p>';        }        break;      case 'title':        $item_text = '';        break;    }    $items .= format_rss_item($item->title, $item->link, $item_text, $extra);  }  $channel_defaults = array(    'version'     => '2.0',    'title'       => variable_get('site_name', 'Drupal'),    'link'        => $base_url,    'description' => variable_get('site_mission', ''),    'language'    => $language->language  );  $channel = array_merge($channel_defaults, $channel);  $output = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";  $output .= "<rss version=\"". $channel["version"] ."\" xml:base=\"". $base_url ."\" ". drupal_attributes($namespaces) .">\n";  $output .= format_rss_channel($channel['title'], $channel['link'], $channel['description'], $items, $channel['language']);  $output .= "</rss>\n";  drupal_set_header('Content-Type: application/rss+xml; charset=utf-8');  print $output;}/** * Menu callback; Generate a listing of promoted nodes. */function node_page_default() {  $result = pager_query(db_rewrite_sql('SELECT n.nid, n.sticky, n.created FROM {node} n WHERE n.promote = 1 AND n.status = 1 ORDER BY n.sticky DESC, n.created DESC'), variable_get('default_nodes_main', 10));  $output = '';  $num_rows = FALSE;  while ($node = db_fetch_object($result)) {    $output .= node_view(node_load($node->nid), 1);    $num_rows = TRUE;  }  if ($num_rows) {    $feed_url = url('rss.xml', array('absolute' => TRUE));    drupal_add_feed($feed_url, variable_get('site_name', 'Drupal') .' '. t('RSS'));    $output .= theme('pager', NULL, variable_get('default_nodes_main', 10));  }  else {    $default_message = t('<h1 class="title">Welcome to your new Drupal website!</h1><p>Please follow these steps to set up and start using your website:</p>');    $default_message .= '<ol>';    $default_message .= '<li>'. t('<strong>Configure your website</strong> Once logged in, visit the <a href="@admin">administration section</a>, where you can <a href="@config">customize and configure</a> all aspects of your website.', array('@admin' => url('admin'), '@config' => url('admin/settings'))) .'</li>';    $default_message .= '<li>'. t('<strong>Enable additional functionality</strong> Next, visit the <a href="@modules">module list</a> and enable features which suit your specific needs. You can find additional modules in the <a href="@download_modules">Drupal modules download section</a>.', array('@modules' => url('admin/build/modules'), '@download_modules' => 'http://drupal.org/project/modules')) .'</li>';    $default_message .= '<li>'. t('<strong>Customize your website design</strong> To change the "look and feel" of your website, visit the <a href="@themes">themes section</a>. You may choose from one of the included themes or download additional themes from the <a href="@download_themes">Drupal themes download section</a>.', array('@themes' => url('admin/build/themes'), '@download_themes' => 'http://drupal.org/project/themes')) .'</li>';    $default_message .= '<li>'. t('<strong>Start posting content</strong> Finally, you can <a href="@content">create content</a> for your website. This message will disappear once you have promoted a post to the front page.', array('@content' => url('node/add'))) .'</li>';    $default_message .= '</ol>';    $default_message .= '<p>'. t('For more information, please refer to the <a href="@help">help section</a>, or the <a href="@handbook">online Drupal handbooks</a>. You may also post at the <a href="@forum">Drupal forum</a>, or view the wide range of <a href="@support">other support options</a> available.', array('@help' => url('admin/help'), '@handbook' => 'http://drupal.org/handbooks', '@forum' => 'http://drupal.org/forum', '@support' => 'http://drupal.org/support')) .'</p>';    $output = '<div id="first-time">'. $default_message .'</div>';  }  drupal_set_title('');  return $output;}/** * Menu callback; view a single node. */function node_page_view($node, $cid = NULL) {  drupal_set_title(check_plain($node->title));  return node_show($node, $cid);}/** * Implementation of hook_update_index(). */function node_update_index() {  $limit = (int)variable_get('search_cron_limit', 100);  // Store the maximum possible comments per thread (used for ranking by reply count)  variable_set('node_cron_comments_scale', 1.0 / max(1, db_result(db_query('SELECT MAX(comment_count) FROM {node_comment_statistics}'))));  variable_set('node_cron_views_scale', 1.0 / max(1, db_result(db_query('SELECT MAX(totalcount) FROM {node_counter}'))));  $result = db_query_range("SELECT n.nid FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE d.sid IS NULL OR d.reindex <> 0 ORDER BY d.reindex ASC, n.nid ASC", 0, $limit);  while ($node = db_fetch_object($result)) {    _node_index_node($node);  }}/** * Index a single node. * * @param $node *   The node to index. */function _node_index_node($node) {  $node = node_load($node->nid);  // save the changed time of the most recent indexed node, for the search results half-life calculation  variable_set('node_cron_last', $node->changed);  // Build the node body.  $node->build_mode = NODE_BUILD_SEARCH_INDEX;  $node = node_build_content($node, FALSE, FALSE);  $node->body = drupal_render($node->content);  $text = '<h1>'. check_plain($node->title) .'</h1>'. $node->body;  // Fetch extra data normally not visible  $extra = node_invoke_nodeapi($node, 'update index');  foreach ($extra as $t) {    $text .= $t;  }  // Update index  search_index($node->nid, 'node', $text);}/** * Implementation of hook_form_alter(). */function node_form_alter(&$form, $form_state, $form_id) {  // Advanced node search form  if ($form_id == 'search_form' && $form['module']['#value'] == 'node' && user_access('use advanced search')) {    // Keyword boxes:    $form['advanced'] = array(      '#type' => 'fieldset',      '#title' => t('Advanced search'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#attributes' => array('class' => 'search-advanced'),    );    $form['advanced']['keywords'] = array(      '#prefix' => '<div class="criterion">',      '#suffix' => '</div>',    );    $form['advanced']['keywords']['or'] = array(      '#type' => 'textfield',      '#title' => t('Containing any of the words'),      '#size' => 30,      '#maxlength' => 255,    );    $form['advanced']['keywords']['phrase'] = array(      '#type' => 'textfield',      '#title' => t('Containing the phrase'),      '#size' => 30,      '#maxlength' => 255,    );    $form['advanced']['keywords']['negative'] = array(      '#type' => 'textfield',      '#title' => t('Containing none of the words'),      '#size' => 30,      '#maxlength' => 255,    );    // Taxonomy box:    if ($taxonomy = module_invoke('taxonomy', 'form_all', 1)) {      $form['advanced']['category'] = array(        '#type' => 'select',        '#title' => t('Only in the category(s)'),        '#prefix' => '<div class="criterion">',        '#size' => 10,        '#suffix' => '</div>',        '#options' => $taxonomy,        '#multiple' => TRUE,      );    }    // Node types:    $types = array_map('check_plain', node_get_types('names'));    $form['advanced']['type'] = array(      '#type' => 'checkboxes',      '#title' => t('Only of the type(s)'),      '#prefix' => '<div class="criterion">',      '#suffix' => '</div>',      '#options' => $types,    );    $form['advanced']['submit'] = array(      '#type' => 'submit',      '#value' => t('Advanced search'),      '#prefix' => '<div class="action">',      '#suffix' => '</div>',    );    $form['#validate'][] = 'node_search_validate';  }}/** * Form API callback for the search form. Registered in node_form_alter(). */function node_search_validate($form, &$form_state) {  // Initialise using any existing basic search keywords.  $keys = $form_state['values']['processed_keys'];  // Insert extra restrictions into the search keywords string.  if (isset($form_state['values']['type']) && is_array($form_state['values']['type'])) {    // Retrieve selected types - Forms API sets the value of unselected checkboxes to 0.    $form_state['values']['type'] = array_filter($form_state['values']['type']);    if (count($form_state['values']['type'])) {      $keys = search_query_insert($keys, 'type', implode(',', array_keys($form_state['values']['type'])));    }  }  if (isset($form_state['values']['category']) && is_array($form_state['values']['category'])) {    $keys = search_query_insert($keys, 'category', implode(',', $form_state['values']['category']));  }  if ($form_state['values']['or'] != '') {    if (preg_match_all('/ ("[^"]+"|[^" ]+)/i', ' '. $form_state['values']['or'], $matches)) {      $keys .= ' '. implode(' OR ', $matches[1]);    }  }  if ($form_state['values']['negative'] != '') {    if (preg_match_all('/ ("[^"]+"|[^" ]+)/i', ' '. $form_state['values']['negative'], $matches)) {      $keys .= ' -'. implode(' -', $matches[1]);    }  }  if ($form_state['values']['phrase'] != '') {    $keys .= ' "'. str_replace('"', ' ', $form_state['values']['phrase']) .'"';  }  if (!empty($keys)) {    form_set_value($form['basic']['inline']['processed_keys'], trim($keys), $form_state);  }}/** * @defgroup node_access Node access rights * @{ * The node access system determines who can do what to which nodes. * * In determining access rights for a node, node_access() first checks * whether the user has the "administer nodes" permission. Such users have * unrestricted access to all nodes. Then the node module's hook_access() * is called, and a TRUE or FALSE return value will grant or deny access. * This allows, for example, the blog module to always grant access to the * blog author, and for the book module to always deny editing access to * PHP pages. * * If node module does not intervene (returns NULL), then the * node_access table is used to determine access. All node access * modules are queried using hook_node_grants() to assemble a list of * "grant IDs" for the user. This list is compared against the table. * If any row contains the node ID in question (or 0, which stands for "all * nodes"), one of the grant IDs returned, and a value of TRUE for the * operation in question, then access is granted. Note that this table is a * list of grants; any matching row is sufficient to grant access to the * node. * * In node listings, the process above is followed except that * hook_access() is not called on each node for performance reasons and for * proper functioning of the pager system. When adding a node listing to your * module, be sure to use db_rewrite_sql() to add * the appropriate clauses to your query for access checks. * * To see how to write a node access module of your own, see * node_access_example.module. *//** * Determine whether the current user may perform the given operation on the * specified node. * * @param $op *   The operation to be performed on the node. Possible values are: *   - "view" *   - "update" *   - "delete" *   - "create" * @param $node *   The node object (or node array) on which the operation is to be performed, *   or node type (e.g. 'forum') for "create" operation. * @param $account *   Optional, a user object representing the user for whom the operation is to *   be performed. Determines access for a user other than the current user. * @return *   TRUE if the operation may be performed, or FALSE otherwise. */function node_access($op, $node, $account = NULL) {  global $user;  if (!$node || !in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {    // If there was no node to check against, or the $op was not one of the    // supported ones, we return access denied.    return FALSE;  }  // Convert the node to an object if necessary:  if ($op != 'create') {    $node = (object)$node;  }  // If no user object is supplied, the access check is for the current user.  if (empty($account)) {    $account = $user;  }  // If the node is in a restricted format, disallow editing.  if ($op == 'update' && !filter_access($node->format)) {    return FALSE;  }  if (user_access('administer nodes', $account)) {    return TRUE;  }  if (!user_access('access content', $account)) {    return FALSE;  }  // Can't use node_invoke(), because the access hook takes the $op parameter  // before the $node parameter.  $module = node_get_types('module', $node);  if ($module == 'node') {    $module = 'node_content'; // Avoid function name collisions.  }  $access = module_invoke($module, 'access', $op, $node, $account);  if (!is_null($access)) {    return $access;  }  // If the module did not override the access rights, use those set in the  // node_access table.  if ($op != 'create' && $node->nid && $node->status) {    $grants = array();    foreach (node_access_grants($op, $account) as $realm => $gids) {      foreach ($gids as $gid) {        $grants[] = "(gid = $gid AND realm = '$realm')";      }    }    $grants_sql = '';    if (count($grants)) {      $grants_sql = 'AND ('. implode(' OR ', $grants) .')';    }    $sql = "SELECT 1 FROM {node_access} WHERE (nid = 0 OR nid = %d) $grants_sql AND grant_$op >= 1";    $result = db_query_range($sql, $node->nid, 0, 1);    return (bool) db_result($result);  }  // Let authors view their own nodes.  if ($op == 'view' && $account->uid == $node->uid && $account->uid != 0) {    return TRUE;  }  return FALSE;}/** * Generate an SQL join clause for use in fetching a node listing. * * @param $node_alias *   If the node table has been given an SQL alias other than the default *   "n", that must be passed here. * @param $node_access_alias *   If the node_access table has been given an SQL alias other than the default *   "na", that must be passed here. * @return *   An SQL join clause. */function _node_access_join_sql($node_alias = 'n', $node_access_alias = 'na') {  if (user_access('administer nodes')) {    return '';  }  return 'INNER JOIN {node_access} '. $node_access_alias .' ON '. $node_access_alias .'.nid = '. $node_alias .'.nid';}/** * Generate an SQL where clause for use in fetching a node listing. * * @param $op *   The operation that must be allowed to return a node. * @param $node_access_alias *   If the node_access table has been given an SQL alias other than the default *   "na", that must be passed here. * @param $account *   The user object for the user performing the operation. If omitted, the *   current user is used. * @return *   An SQL where clause. */function _node_access_where_sql($op = 'view', $node_access_alias = 'na', $account = NULL) {  if (user_access('administer nodes')) {    return;  }  $grants = array();  foreach (node_access_grants($op, $account) as $realm => $gids) {    foreach ($gids as $gid) {      $grants[] = "($node_access_alias.gid = $gid AND $node_access_alias.realm = '$realm')";    }  }  $grants_sql = '';  if (count($grants)) {    $grants_sql = 'AND ('. implode(' OR ', $grants) .')';  }  $sql = "$node_access_alias.grant_$op >= 1 $grants_sql";  return $sql;}/** * Fetch an array of permission IDs granted to the given user ID. * * The implementation here provides only the universal "all" grant. A node * access module should implement hook_node_grants() to provide a grant * list for the user. * * @param $op *   The operation that the user is trying to perform. * @param $account *   The user object for the user performing the operation. If omitted, the *   current user is used. * @return *   An associative array in which the keys are realms, and the values are *   arrays of grants for those realms. */function node_access_grants($op, $account = NULL) {  if (!isset($account)) {    $account = $GLOBALS['user'];  }  return array_merge(array('all' => array(0)), module_invoke_all('node_grants', $account, $op));}/** * Determine whether the user has a global viewing grant for all nodes. */function node_access_view_all_nodes() {  static $access;  if (!isset($access)) {    $grants = array();    foreach (node_access_grants('view') as $realm => $gids) {      foreach ($gids as $gid) {        $grants[] = "(gid = $gid AND realm = '$realm')";      }    }    $grants_sql = '';    if (count($grants)) {      $grants_sql = 'AND ('. implode(' OR ', $grants) .')';    }    $sql = "SELECT COUNT(*) FROM {node_access} WHERE nid = 0 $grants_sql AND grant_view >= 1";    $result = db_query($sql);    $access = db_result($result);  }  return $access;}/** * Implementation of hook_db_rewrite_sql */function node_db_rewrite_sql($query, $primary_table, $primary_field) {  if ($primary_field == 'nid' && !node_access_view_all_nodes()) {    $return['join'] = _node_access_join_sql($primary_table);    $return['where'] = _node_access_where_sql();    $return['distinct'] = 1;    return $return;  }}/** * This function will call module invoke to get a list of grants and then * write them to the database. It is called at node save, and should be * called by modules whenever something other than a node_save causes * the permissions on a node to change. * * This function is the only function that should write to the node_access * table. * * @param $node *   The $node to acquire grants for. */function node_access_acquire_grants($node) {  $grants = module_invoke_all('node_access_records', $node);  if (empty($grants)) {    $grants[] = array('realm' => 'all', 'gid' => 0, 'grant_view' => 1, 'grant_update' => 0, 'grant_delete' => 0);  }  else {    // retain grants by highest priority    $grant_by_priority = array();    foreach ($grants as $g) {      $grant_by_priority[intval($g['priority'])][] = $g;    }    krsort($grant_by_priority);    $grants = array_shift($grant_by_priority);  }  node_access_write_grants($node, $grants);}/** * This function will write a list of grants to the database, deleting * any pre-existing grants. If a realm is provided, it will only * delete grants from that realm, but it will always delete a grant * from the 'all' realm. Modules which utilize node_access can * use this function when doing mass updates due to widespread permission * changes. * * @param $node *   The $node being written to. All that is necessary is that it contain a nid. * @param $grants *   A list of grants to write. Each grant is an array that must contain the *   following keys: realm, gid, grant_view, grant_update, grant_delete. *   The realm is specified by a particular module; the gid is as well, and *   is a module-defined id to define grant privileges. each grant_* field *   is a boolean value. * @param $realm *   If provided, only read/write grants for that realm. * @param $delete *   If false, do not delete records. This is only for optimization purposes, *   and assumes the caller has already performed a mass delete of some form. */function node_access_write_grants($node, $grants, $realm = NULL, $delete = TRUE) {  if ($delete) {    $query = 'DELETE FROM {node_access} WHERE nid = %d';    if ($realm) {      $query .= " AND realm in ('%s', 'all')";    }    db_query($query, $node->nid, $realm);  }  // Only perform work when node_access modules are active.  if (count(module_implements('node_grants'))) {    foreach ($grants as $grant) {      if ($realm && $realm != $grant['realm']) {        continue;      }      // Only write grants; denies are implicit.      if ($grant['grant_view'] || $grant['grant_update'] || $grant['grant_delete']) {        db_query("INSERT INTO {node_access} (nid, realm, gid, grant_view, grant_update, grant_delete) VALUES (%d, '%s', %d, %d, %d, %d)", $node->nid, $grant['realm'], $grant['gid'], $grant['grant_view'], $grant['grant_update'], $grant['grant_delete']);      }    }  }}/** * Flag / unflag the node access grants for rebuilding, or read the current * value of the flag. * * When the flag is set, a message is displayed to users with 'access * administration pages' permission, pointing to the 'rebuild' confirm form. * This can be used as an alternative to direct node_access_rebuild calls, * allowing administrators to decide when they want to perform the actual * (possibly time consuming) rebuild. * When unsure the current user is an adminisrator, node_access_rebuild * should be used instead. * * @param $rebuild *   (Optional) The boolean value to be written.  * @return *   (If no value was provided for $rebuild) The current value of the flag. */function node_access_needs_rebuild($rebuild = NULL) {  if (!isset($rebuild)) {    return variable_get('node_access_needs_rebuild', FALSE);  }  elseif ($rebuild) {    variable_set('node_access_needs_rebuild', TRUE);  }  else {    variable_del('node_access_needs_rebuild');  }}/** * Rebuild the node access database. This is occasionally needed by modules * that make system-wide changes to access levels. * * When the rebuild is required by an admin-triggered action (e.g module * settings form), calling node_access_needs_rebuild(TRUE) instead of * node_access_rebuild() lets the user perform his changes and actually * rebuild only once he is done. * * Note : As of Drupal 6, node access modules are not required to (and actually * should not) call node_access_rebuild() in hook_enable/disable anymore. * * @see node_access_needs_rebuild() * * @param $batch_mode *   Set to TRUE to process in 'batch' mode, spawning processing over several *   HTTP requests (thus avoiding the risk of PHP timeout if the site has a *   large number of nodes). *   hook_update_N and any form submit handler are safe contexts to use the *   'batch mode'. Less decidable cases (such as calls from hook_user, *   hook_taxonomy, hook_node_type...) might consider using the non-batch mode. */function node_access_rebuild($batch_mode = FALSE) {  db_query("DELETE FROM {node_access}");  // Only recalculate if the site is using a node_access module.  if (count(module_implements('node_grants'))) {    if ($batch_mode) {      $batch = array(        'title' => t('Rebuilding content access permissions'),        'operations' => array(          array('_node_access_rebuild_batch_operation', array()),        ),        'finished' => '_node_access_rebuild_batch_finished'      );      batch_set($batch);    }    else {      // Try to allocate enough time to rebuild node grants      if (function_exists('set_time_limit')) {        @set_time_limit(240);      }      $result = db_query("SELECT nid FROM {node}");      while ($node = db_fetch_object($result)) {        $loaded_node = node_load($node->nid, NULL, TRUE);        // To preserve database integrity, only aquire grants if the node        // loads successfully.        if (!empty($loaded_node)) {          node_access_acquire_grants($loaded_node);        }      }    }  }  else {    // Not using any node_access modules. Add the default grant.    db_query("INSERT INTO {node_access} VALUES (0, 0, 'all', 1, 0, 0)");  }  if (!isset($batch)) {    drupal_set_message(t('Content permissions have been rebuilt.'));    node_access_needs_rebuild(FALSE);    cache_clear_all();  }}/** * Batch operation for node_access_rebuild_batch. * * This is a mutlistep operation : we go through all nodes by packs of 20. * The batch processing engine interrupts processing and sends progress * feedback after 1 second execution time. */function _node_access_rebuild_batch_operation(&$context) {  if (empty($context['sandbox'])) {    // Initiate multistep processing.    $context['sandbox']['progress'] = 0;    $context['sandbox']['current_node'] = 0;    $context['sandbox']['max'] = db_result(db_query('SELECT COUNT(DISTINCT nid) FROM {node}'));  }  // Process the next 20 nodes.  $limit = 20;  $result = db_query_range("SELECT nid FROM {node} WHERE nid > %d ORDER BY nid ASC", $context['sandbox']['current_node'], 0, $limit);  while ($row = db_fetch_array($result)) {    $loaded_node = node_load($row['nid'], NULL, TRUE);    // To preserve database integrity, only aquire grants if the node    // loads successfully.    if (!empty($loaded_node)) {      node_access_acquire_grants($loaded_node);    }    $context['sandbox']['progress']++;    $context['sandbox']['current_node'] = $loaded_node->nid;  }  // Multistep processing : report progress.  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];  }}/** * Post-processing for node_access_rebuild_batch. */function _node_access_rebuild_batch_finished($success, $results, $operations) {  if ($success) {    drupal_set_message(t('The content access permissions have been rebuilt.'));    node_access_needs_rebuild(FALSE);  }  else {    drupal_set_message(t('The content access permissions have not been properly rebuilt.'), 'error');  }  cache_clear_all();}/** * @} End of "defgroup node_access". *//** * @defgroup node_content Hook implementations for user-created content types. * @{ *//** * Implementation of hook_access(). * * Named so as not to conflict with node_access() */function node_content_access($op, $node, $account) {  $type = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);  if ($op == 'create') {    return user_access('create '. $type .' content', $account);  }  if ($op == 'update') {    if (user_access('edit any '. $type .' content', $account) || (user_access('edit own '. $type .' content', $account) && ($account->uid == $node->uid))) {      return TRUE;    }  }  if ($op == 'delete') {    if (user_access('delete any '. $type .' content', $account) || (user_access('delete own '. $type .' content', $account) && ($account->uid == $node->uid))) {      return TRUE;    }  }}/** * Implementation of hook_form(). */function node_content_form($node, $form_state) {  $type = node_get_types('type', $node);  $form = array();  if ($type->has_title) {    $form['title'] = array(      '#type' => 'textfield',      '#title' => check_plain($type->title_label),      '#required' => TRUE,      '#default_value' => $node->title,      '#maxlength' => 255,      '#weight' => -5,    );  }  if ($type->has_body) {    $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);  }  return $form;}/** * @} End of "defgroup node_content". *//** * Implementation of hook_forms(). All node forms share the same form handler */function node_forms() {  $forms = array();  if ($types = node_get_types()) {    foreach (array_keys($types) as $type) {      $forms[$type .'_node_form']['callback'] = 'node_form';    }  }  return $forms;}/** * Format the "Submitted by username on date/time" for each node * * @ingroup themeable */function theme_node_submitted($node) {  return t('Submitted by !username on @datetime',    array(      '!username' => theme('username', $node),      '@datetime' => format_date($node->created),    ));}/** * Implementation of hook_hook_info(). */function node_hook_info() {  return array(    'node' => array(      'nodeapi' => array(        'presave' => array(          'runs when' => t('When either saving a new post or updating an existing post'),        ),        'insert' => array(          'runs when' => t('After saving a new post'),        ),        'update' => array(          'runs when' => t('After saving an updated post'),        ),        'delete' => array(          'runs when' => t('After deleting a post')        ),        'view' => array(          'runs when' => t('When content is viewed by an authenticated user')        ),      ),    ),  );}/** * Implementation of hook_action_info(). */function node_action_info() {  return array(    'node_publish_action' => array(      'type' => 'node',      'description' => t('Publish post'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('insert', 'update'),      ),    ),    'node_unpublish_action' => array(      'type' => 'node',      'description' => t('Unpublish post'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('delete', 'insert', 'update'),      ),    ),    'node_make_sticky_action' => array(      'type' => 'node',      'description' => t('Make post sticky'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('insert', 'update'),      ),    ),    'node_make_unsticky_action' => array(      'type' => 'node',      'description' => t('Make post unsticky'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('delete', 'insert', 'update'),      ),    ),    'node_promote_action' => array(      'type' => 'node',      'description' => t('Promote post to front page'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('insert', 'update'),      ),    ),    'node_unpromote_action' => array(      'type' => 'node',      'description' => t('Remove post from front page'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('delete', 'insert', 'update'),      ),    ),    'node_assign_owner_action' => array(      'type' => 'node',      'description' => t('Change the author of a post'),      'configurable' => TRUE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'any' => TRUE,        'nodeapi' => array('presave'),        'comment' => array('delete', 'insert', 'update'),      ),    ),    'node_save_action' => array(      'type' => 'node',      'description' => t('Save post'),      'configurable' => FALSE,      'hooks' => array(        'comment' => array('delete', 'insert', 'update'),      ),    ),    'node_unpublish_by_keyword_action' => array(      'type' => 'node',      'description' => t('Unpublish post containing keyword(s)'),      'configurable' => TRUE,      'hooks' => array(        'nodeapi' => array('presave', 'insert', 'update'),      ),    ),  );}/** * Implementation of a Drupal action. * Sets the status of a node to 1, meaning published. */function node_publish_action(&$node, $context = array()) {  $node->status = 1;  watchdog('action', 'Set @type %title to published.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Sets the status of a node to 0, meaning unpublished. */function node_unpublish_action(&$node, $context = array()) {  $node->status = 0;  watchdog('action', 'Set @type %title to unpublished.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Sets the sticky-at-top-of-list property of a node to 1. */function node_make_sticky_action(&$node, $context = array()) {  $node->sticky = 1;  watchdog('action', 'Set @type %title to sticky.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Sets the sticky-at-top-of-list property of a node to 0. */function node_make_unsticky_action(&$node, $context = array()) {  $node->sticky = 0;  watchdog('action', 'Set @type %title to unsticky.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Sets the promote property of a node to 1. */function node_promote_action(&$node, $context = array()) {  $node->promote = 1;  watchdog('action', 'Promoted @type %title to front page.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Sets the promote property of a node to 0. */function node_unpromote_action(&$node, $context = array()) {  $node->promote = 0;  watchdog('action', 'Removed @type %title from front page.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Saves a node. */function node_save_action($node) {  node_save($node);  watchdog('action', 'Saved @type %title', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a configurable Drupal action. * Assigns ownership of a node to a user. */function node_assign_owner_action(&$node, $context) {  $node->uid = $context['owner_uid'];  $owner_name = db_result(db_query("SELECT name FROM {users} WHERE uid = %d", $context['owner_uid']));  watchdog('action', 'Changed owner of @type %title to uid %name.', array('@type' => node_get_types('type', $node), '%title' => $node->title, '%name' => $owner_name));}function node_assign_owner_action_form($context) {  $description = t('The username of the user to which you would like to assign ownership.');  $count = db_result(db_query("SELECT COUNT(*) FROM {users}"));  $owner_name = '';  if (isset($context['owner_uid'])) {    $owner_name = db_result(db_query("SELECT name FROM {users} WHERE uid = %d", $context['owner_uid']));  }  // Use dropdown for fewer than 200 users; textbox for more than that.  if (intval($count) < 200) {    $options = array();    $result = db_query("SELECT uid, name FROM {users} WHERE uid > 0 ORDER BY name");    while ($data = db_fetch_object($result)) {      $options[$data->name] = $data->name;    }    $form['owner_name'] = array(      '#type' => 'select',      '#title' => t('Username'),      '#default_value' => $owner_name,      '#options' => $options,      '#description' => $description,    );  }  else {    $form['owner_name'] = array(      '#type' => 'textfield',      '#title' => t('Username'),      '#default_value' => $owner_name,      '#autocomplete_path' => 'user/autocomplete',      '#size' => '6',      '#maxlength' => '60',      '#description' => $description,    );  }  return $form;}function node_assign_owner_action_validate($form, $form_state) {  $count = db_result(db_query("SELECT COUNT(*) FROM {users} WHERE name = '%s'", $form_state['values']['owner_name']));  if (intval($count) != 1) {    form_set_error('owner_name', t('Please enter a valid username.'));  }}function node_assign_owner_action_submit($form, $form_state) {  // Username can change, so we need to store the ID, not the username.  $uid = db_result(db_query("SELECT uid from {users} WHERE name = '%s'", $form_state['values']['owner_name']));  return array('owner_uid' => $uid);}function node_unpublish_by_keyword_action_form($context) {  $form['keywords'] = array(    '#title' => t('Keywords'),    '#type' => 'textarea',    '#description' => t('The post will be unpublished if it contains any of the character sequences above. Use a comma-separated list of character sequences. Example: funny, bungee jumping, "Company, Inc.". Character sequences are case-sensitive.'),    '#default_value' => isset($context['keywords']) ? drupal_implode_tags($context['keywords']) : '',  );  return $form;}function node_unpublish_by_keyword_action_submit($form, $form_state) {  return array('keywords' => drupal_explode_tags($form_state['values']['keywords']));}/** * Implementation of a configurable Drupal action. * Unpublish a node if it contains a certain string. * * @param $context *   An array providing more information about the context of the call to this action. * @param $comment *   A node object. */function node_unpublish_by_keyword_action($node, $context) {  foreach ($context['keywords'] as $keyword) {    if (strstr(node_view(drupal_clone($node)), $keyword) || strstr($node->title, $keyword)) {      $node->status = 0;      watchdog('action', 'Set @type %title to unpublished.', array('@type' => node_get_types('name', $node), '%title' => $node->title));      break;    }  }}
<?php// $Id$/** * Implementation of hook_install(). */function search_install() {  // Create tables.  drupal_install_schema('search');}/** * Implementation of hook_uninstall(). */function search_uninstall() {  // Remove tables.  drupal_uninstall_schema('search');  variable_del('minimum_word_size');  variable_del('overlap_cjk');  variable_del('search_cron_limit');}/** * Implementation of hook_schema(). */function search_schema() {  $schema['search_dataset'] = array(    'description' => 'Stores items that will be searched.',    'fields' => array(      'sid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Search item ID, e.g. node ID for nodes.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => FALSE,        'description' => 'Type of item, e.g. node.',      ),      'data' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'List of space-separated words from the item.',      ),      'reindex' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Set to force node reindexing.',      ),    ),    'unique keys' => array('sid_type' => array('sid', 'type')),  );  $schema['search_index'] = array(    'description' => 'Stores the search index, associating words, items and scores.',    'fields' => array(      'word' => array(        'type' => 'varchar',        'length' => 50,        'not null' => TRUE,        'default' => '',        'description' => 'The {search_total}.word that is associated with the search item.',      ),      'sid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {search_dataset}.sid of the searchable item to which the word belongs.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => FALSE,        'description' => 'The {search_dataset}.type of the searchable item to which the word belongs.',      ),      'score' => array(        'type' => 'float',        'not null' => FALSE,        'description' => 'The numeric score of the word, higher being more important.',      ),    ),    'indexes' => array(      'sid_type' => array('sid', 'type'),      'word' => array('word')    ),    'unique keys' => array('word_sid_type' => array('word', 'sid', 'type')),  );  $schema['search_total'] = array(    'description' => 'Stores search totals for words.',    'fields' => array(      'word' => array(        'description' => 'Primary Key: Unique word in the search index.',        'type' => 'varchar',        'length' => 50,        'not null' => TRUE,        'default' => '',      ),      'count' => array(        'description' => "The count of the word in the index using Zipf's law to equalize the probability distribution.",        'type' => 'float',        'not null' => FALSE,      ),    ),    'primary key' => array('word'),  );  $schema['search_node_links'] = array(    'description' => 'Stores items (like nodes) that link to other nodes, used to improve search scores for nodes that are frequently linked to.',    'fields' => array(      'sid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {search_dataset}.sid of the searchable item containing the link to the node.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => TRUE,        'default' => '',        'description' => 'The {search_dataset}.type of the searchable item containing the link to the node.',      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid that this item links to.',      ),      'caption' => array(        'type' => 'text',        'size' => 'big',        'not null' => FALSE,        'description' => 'The text used to link to the {node}.nid.',      ),    ),    'primary key' => array('sid', 'type', 'nid'),    'indexes' => array('nid' => array('nid')),  );  return $schema;}
<?php// $Id$/** * @file * Enables tracking of recent posts for users. *//** * Implementation of hook_help(). */function tracker_help($path, $arg) {  switch ($path) {    case 'admin/help#tracker':      $output = '<p>'. t('The tracker module displays the most recently added or updated content on your site, and provides user-level tracking to follow the contributions of particular authors.') .'</p>';      $output .= '<p>'. t("The <em>Recent posts</em> page is available via a link in the navigation menu block and displays new and recently-updated content (including the content type, the title, the author's name, number of comments, and time of last update) in reverse chronological order. Posts are marked updated when changes occur in the text, or when new comments are added. To use the tracker module to follow a specific user's contributions, select the <em>Track</em> tab from the user's profile page.") .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@tracker">Tracker module</a>.', array('@tracker' => 'http://drupal.org/handbook/modules/tracker/')) .'</p>';      return $output;  }}/** * Implementation of hook_menu(). */function tracker_menu() {  $items['tracker'] = array(    'title' => 'Recent posts',    'page callback' => 'tracker_page',    'access arguments' => array('access content'),    'weight' => 1,    'file' => 'tracker.pages.inc',  );  $items['tracker/all'] = array(    'title' => 'All recent posts',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['tracker/%user_uid_optional'] = array(    'title' => 'My recent posts',    'access callback' => '_tracker_myrecent_access',    'access arguments' => array(1),    'page arguments' => array(1),    'type' => MENU_LOCAL_TASK,  );  $items['user/%user/track'] = array(    'title' => 'Track',    'page callback' => 'tracker_page',    'page arguments' => array(1, TRUE),    'access callback' => '_tracker_user_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'file' => 'tracker.pages.inc',  );  $items['user/%user/track/posts'] = array(    'title' => 'Track posts',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  return $items;}/** * Access callback for tracker/%user_uid_optional */function _tracker_myrecent_access($account) {  // This path is only allowed for authenticated users looking at their own posts.  return $account->uid && ($GLOBALS['user']->uid == $account->uid) && user_access('access content');}/** * Access callback for user/%user/track */function _tracker_user_access($account) {  return user_view_access($account) && user_access('access content');}
<?php// $Id$/** * @file * API for loading and interacting with Drupal modules. *//** * Load all the modules that have been enabled in the system table. */function module_load_all() {  foreach (module_list(TRUE, FALSE) as $module) {    drupal_load('module', $module);  }}/** * Call a function repeatedly with each module in turn as an argument. */function module_iterate($function, $argument = '') {  foreach (module_list() as $name) {    $function($name, $argument);  }}/** * Collect a list of all loaded modules. During the bootstrap, return only * vital modules. See bootstrap.inc * * @param $refresh *   Whether to force the module list to be regenerated (such as after the *   administrator has changed the system settings). * @param $bootstrap *   Whether to return the reduced set of modules loaded in "bootstrap mode" *   for cached pages. See bootstrap.inc. * @param $sort *   By default, modules are ordered by weight and filename, settings this option *   to TRUE, module list will be ordered by module name. * @param $fixed_list *   (Optional) Override the module list with the given modules. Stays until the *   next call with $refresh = TRUE. * @return *   An associative array whose keys and values are the names of all loaded *   modules. */function module_list($refresh = FALSE, $bootstrap = TRUE, $sort = FALSE, $fixed_list = NULL) {  static $list, $sorted_list;  if ($refresh || $fixed_list) {    $list = array();    $sorted_list = NULL;    if ($fixed_list) {      foreach ($fixed_list as $name => $module) {        drupal_get_filename('module', $name, $module['filename']);        $list[$name] = $name;      }    }    else {      if ($bootstrap) {        $result = db_query("SELECT name, filename, throttle FROM {system} WHERE type = 'module' AND status = 1 AND bootstrap = 1 ORDER BY weight ASC, filename ASC");      }      else {        $result = db_query("SELECT name, filename, throttle FROM {system} WHERE type = 'module' AND status = 1 ORDER BY weight ASC, filename ASC");      }      while ($module = db_fetch_object($result)) {        if (file_exists($module->filename)) {          // Determine the current throttle status and see if the module should be          // loaded based on server load. We have to directly access the throttle          // variables, since throttle.module may not be loaded yet.          $throttle = ($module->throttle && variable_get('throttle_level', 0) > 0);          if (!$throttle) {            drupal_get_filename('module', $module->name, $module->filename);            $list[$module->name] = $module->name;          }        }      }    }  }  if ($sort) {    if (!isset($sorted_list)) {      $sorted_list = $list;      ksort($sorted_list);    }    return $sorted_list;  }  return $list;}/** * Rebuild the database cache of module files. * * @return *   The array of filesystem objects used to rebuild the cache. */function module_rebuild_cache() {  // Get current list of modules  $files = drupal_system_listing('\.module$', 'modules', 'name', 0);  // Extract current files from database.  system_get_files_database($files, 'module');  ksort($files);  // Set defaults for module info  $defaults = array(    'dependencies' => array(),    'dependents' => array(),    'description' => '',    'version' => NULL,    'php' => DRUPAL_MINIMUM_PHP,  );  foreach ($files as $filename => $file) {    // Look for the info file.    $file->info = drupal_parse_info_file(dirname($file->filename) .'/'. $file->name .'.info');    // Skip modules that don't provide info.    if (empty($file->info)) {      unset($files[$filename]);      continue;    }    // Merge in defaults and save.    $files[$filename]->info = $file->info + $defaults;    // Invoke hook_system_info_alter() to give installed modules a chance to    // modify the data in the .info files if necessary.    drupal_alter('system_info', $files[$filename]->info, $files[$filename]);    // Log the critical hooks implemented by this module.    $bootstrap = 0;    foreach (bootstrap_hooks() as $hook) {      if (module_hook($file->name, $hook)) {        $bootstrap = 1;        break;      }    }    // Update the contents of the system table:    if (isset($file->status) || (isset($file->old_filename) && $file->old_filename != $file->filename)) {      db_query("UPDATE {system} SET info = '%s', name = '%s', filename = '%s', bootstrap = %d WHERE filename = '%s'", serialize($files[$filename]->info), $file->name, $file->filename, $bootstrap, $file->old_filename);    }    else {      // This is a new module.      $files[$filename]->status = 0;      $files[$filename]->throttle = 0;      db_query("INSERT INTO {system} (name, info, type, filename, status, throttle, bootstrap) VALUES ('%s', '%s', '%s', '%s', %d, %d, %d)", $file->name, serialize($files[$filename]->info), 'module', $file->filename, 0, 0, $bootstrap);    }  }  $files = _module_build_dependencies($files);  return $files;}/** * Find dependencies any level deep and fill in dependents information too. * * If module A depends on B which in turn depends on C then this function will * add C to the list of modules A depends on. This will be repeated until * module A has a list of all modules it depends on. If it depends on itself, * called a circular dependency, that's marked by adding a nonexistent module, * called -circular- to this list of modules. Because this does not exist, * it'll be impossible to switch module A on. * * Also we fill in a dependents array in $file->info. Using the names above, * the dependents array of module B lists A. * * @param $files *   The array of filesystem objects used to rebuild the cache. * @return *   The same array with dependencies and dependents added where applicable. */function _module_build_dependencies($files) {  do {    $new_dependency = FALSE;    foreach ($files as $filename => $file) {      // We will modify this object (module A, see doxygen for module A, B, C).      $file = &$files[$filename];      if (isset($file->info['dependencies']) && is_array($file->info['dependencies'])) {        foreach ($file->info['dependencies'] as $dependency_name) {          // This is a nonexistent module.          if ($dependency_name == '-circular-' || !isset($files[$dependency_name])) {            continue;          }          // $dependency_name is module B (again, see doxygen).          $files[$dependency_name]->info['dependents'][$filename] = $filename;          $dependency = $files[$dependency_name];          if (isset($dependency->info['dependencies']) && is_array($dependency->info['dependencies'])) {            // Let's find possible C modules.            foreach ($dependency->info['dependencies'] as $candidate) {              if (array_search($candidate, $file->info['dependencies']) === FALSE) {                // Is this a circular dependency?                if ($candidate == $filename) {                  // As a module name can not contain dashes, this makes                  // impossible to switch on the module.                  $candidate = '-circular-';                  // Do not display the message or add -circular- more than once.                  if (array_search($candidate, $file->info['dependencies']) !== FALSE) {                    continue;                  }                  drupal_set_message(t('%module is part of a circular dependency. This is not supported and you will not be able to switch it on.', array('%module' => $file->info['name'])), 'error');                }                else {                  // We added a new dependency to module A. The next loop will                  // be able to use this as "B module" thus finding even                  // deeper dependencies.                  $new_dependency = TRUE;                }                $file->info['dependencies'][] = $candidate;              }            }          }        }      }      // Don't forget to break the reference.      unset($file);    }  } while ($new_dependency);  return $files;}/** * Determine whether a given module exists. * * @param $module *   The name of the module (without the .module extension). * @return *   TRUE if the module is both installed and enabled. */function module_exists($module) {  $list = module_list();  return array_key_exists($module, $list);}/** * Load a module's installation hooks. */function module_load_install($module) {  // Make sure the installation API is available  include_once './includes/install.inc';  module_load_include('install', $module);}/** * Load a module include file. *  * Examples: * @code *   // Load node.admin.inc from the node module. *   module_load_include('inc', 'node', 'node.admin'); *   // Load content_types.inc from the node module. *   module_load_include('inc', 'node', 'content_types');   * @endcode *  * Do not use this function to load an install file. Use module_load_install() * instead. * * @param $type *   The include file's type (file extension). * @param $module *   The module to which the include file belongs. * @param $name *   Optionally, specify the base file name (without the $type extension).  *   If not set, $module is used. */function module_load_include($type, $module, $name = NULL) {  if (empty($name)) {    $name = $module;  }  $file = './'. drupal_get_path('module', $module) ."/$name.$type";  if (is_file($file)) {    require_once $file;  }  else {    return FALSE;  }}/** * Load an include file for each of the modules that have been enabled in * the system table. */function module_load_all_includes($type, $name = NULL) {  $modules = module_list();  foreach ($modules as $module) {    module_load_include($type, $module, $name);  }}/** * Enable a given list of modules. * * @param $module_list *   An array of module names. */function module_enable($module_list) {  $invoke_modules = array();  foreach ($module_list as $module) {    $existing = db_fetch_object(db_query("SELECT status FROM {system} WHERE type = '%s' AND name = '%s'", 'module', $module));    if ($existing->status == 0) {      module_load_install($module);      db_query("UPDATE {system} SET status = %d, throttle = %d WHERE type = '%s' AND name = '%s'", 1, 0, 'module', $module);      drupal_load('module', $module);      $invoke_modules[] = $module;    }  }  if (!empty($invoke_modules)) {    // Refresh the module list to include the new enabled module.    module_list(TRUE, FALSE);    // Force to regenerate the stored list of hook implementations.    module_implements('', FALSE, TRUE);  }  foreach ($invoke_modules as $module) {    module_invoke($module, 'enable');    // Check if node_access table needs rebuilding.    // We check for the existence of node_access_needs_rebuild() since    // at install time, module_enable() could be called while node.module    // is not enabled yet.    if (function_exists('node_access_needs_rebuild') && !node_access_needs_rebuild() && module_hook($module, 'node_grants')) {      node_access_needs_rebuild(TRUE);    }  }}/** * Disable a given set of modules. * * @param $module_list *   An array of module names. */function module_disable($module_list) {  $invoke_modules = array();  foreach ($module_list as $module) {    if (module_exists($module)) {      // Check if node_access table needs rebuilding.      if (!node_access_needs_rebuild() && module_hook($module, 'node_grants')) {        node_access_needs_rebuild(TRUE);      }      module_load_install($module);      module_invoke($module, 'disable');      db_query("UPDATE {system} SET status = %d, throttle = %d WHERE type = '%s' AND name = '%s'", 0, 0, 'module', $module);      $invoke_modules[] = $module;    }  }  if (!empty($invoke_modules)) {    // Refresh the module list to exclude the disabled modules.    module_list(TRUE, FALSE);    // Force to regenerate the stored list of hook implementations.    module_implements('', FALSE, TRUE);  }  // If there remains no more node_access module, rebuilding will be  // straightforward, we can do it right now.  if (node_access_needs_rebuild() && count(module_implements('node_grants')) == 0) {    node_access_rebuild();  }}/** * @defgroup hooks Hooks * @{ * Allow modules to interact with the Drupal core. * * Drupal's module system is based on the concept of "hooks". A hook is a PHP * function that is named foo_bar(), where "foo" is the name of the module * (whose filename is thus foo.module) and "bar" is the name of the hook. Each * hook has a defined set of parameters and a specified result type. * * To extend Drupal, a module need simply implement a hook. When Drupal wishes * to allow intervention from modules, it determines which modules implement a * hook and calls that hook in all enabled modules that implement it. * * The available hooks to implement are explained here in the Hooks section of * the developer documentation. The string "hook" is used as a placeholder for * the module name in the hook definitions. For example, if the module file is * called example.module, then hook_help() as implemented by that module would * be defined as example_help(). *//** * Determine whether a module implements a hook. * * @param $module *   The name of the module (without the .module extension). * @param $hook *   The name of the hook (e.g. "help" or "menu"). * @return *   TRUE if the module is both installed and enabled, and the hook is *   implemented in that module. */function module_hook($module, $hook) {  return function_exists($module .'_'. $hook);}/** * Determine which modules are implementing a hook. * * @param $hook *   The name of the hook (e.g. "help" or "menu"). * @param $sort *   By default, modules are ordered by weight and filename, settings this option *   to TRUE, module list will be ordered by module name. * @param $refresh *   For internal use only: Whether to force the stored list of hook *   implementations to be regenerated (such as after enabling a new module, *   before processing hook_enable). * @return *   An array with the names of the modules which are implementing this hook. */function module_implements($hook, $sort = FALSE, $refresh = FALSE) {  static $implementations;  if ($refresh) {    $implementations = array();    return;  }  if (!isset($implementations[$hook])) {    $implementations[$hook] = array();    $list = module_list(FALSE, TRUE, $sort);    foreach ($list as $module) {      if (module_hook($module, $hook)) {        $implementations[$hook][] = $module;      }    }  }  // The explicit cast forces a copy to be made. This is needed because  // $implementations[$hook] is only a reference to an element of  // $implementations and if there are nested foreaches (due to nested node  // API calls, for example), they would both manipulate the same array's  // references, which causes some modules' hooks not to be called.  // See also http://www.zend.com/zend/art/ref-count.php.  return (array)$implementations[$hook];}/** * Invoke a hook in a particular module. * * @param $module *   The name of the module (without the .module extension). * @param $hook *   The name of the hook to invoke. * @param ... *   Arguments to pass to the hook implementation. * @return *   The return value of the hook implementation. */function module_invoke() {  $args = func_get_args();  $module = $args[0];  $hook = $args[1];  unset($args[0], $args[1]);  $function = $module .'_'. $hook;  if (module_hook($module, $hook)) {    return call_user_func_array($function, $args);  }}/** * Invoke a hook in all enabled modules that implement it. * * @param $hook *   The name of the hook to invoke. * @param ... *   Arguments to pass to the hook. * @return *   An array of return values of the hook implementations. If modules return *   arrays from their implementations, those are merged into one array. */function module_invoke_all() {  $args = func_get_args();  $hook = $args[0];  unset($args[0]);  $return = array();  foreach (module_implements($hook) as $module) {    $function = $module .'_'. $hook;    $result = call_user_func_array($function, $args);    if (isset($result) && is_array($result)) {      $return = array_merge_recursive($return, $result);    }    else if (isset($result)) {      $return[] = $result;    }  }  return $return;}/** * @} End of "defgroup hooks". *//** * Array of modules required by core. */function drupal_required_modules() {  return array('block', 'filter', 'node', 'system', 'user');}
<?php// $Id$/** * @file * Admin page callbacks for the block module. *//** * Menu callback for admin/build/block. */function block_admin_display($theme = NULL) {  global $custom_theme;  // If non-default theme configuration has been selected, set the custom theme.  $custom_theme = isset($theme) ? $theme : variable_get('theme_default', 'garland');  // Fetch and sort blocks  $blocks = _block_rehash();  usort($blocks, '_block_compare');  return drupal_get_form('block_admin_display_form', $blocks, $theme);}/** * Generate main blocks administration form. */function block_admin_display_form(&$form_state, $blocks, $theme = NULL) {  global $theme_key, $custom_theme;  // Add CSS  drupal_add_css(drupal_get_path('module', 'block') .'/block.css', 'module', 'all', FALSE);  // If non-default theme configuration has been selected, set the custom theme.  $custom_theme = isset($theme) ? $theme : variable_get('theme_default', 'garland');  init_theme();  $throttle = module_exists('throttle');  $block_regions = system_region_list($theme_key) + array(BLOCK_REGION_NONE => '<'. t('none') .'>');  // Weights range from -delta to +delta, so delta should be at least half  // of the amount of blocks present. This makes sure all blocks in the same  // region get an unique weight.  $weight_delta = round(count($blocks) / 2);  // Build form tree  $form = array(    '#action' => arg(4) ? url('admin/build/block/list/'. $theme_key) : url('admin/build/block'),    '#tree' => TRUE,  );  foreach ($blocks as $i => $block) {    $key = $block['module'] .'_'. $block['delta'];    $form[$key]['module'] = array(      '#type' => 'value',      '#value' => $block['module'],    );    $form[$key]['delta'] = array(      '#type' => 'value',      '#value' => $block['delta'],    );    $form[$key]['info'] = array(      '#value' => check_plain($block['info'])    );    $form[$key]['theme'] = array(      '#type' => 'hidden',      '#value' => $theme_key    );    $form[$key]['weight'] = array(      '#type' => 'weight',      '#default_value' => $block['weight'],      '#delta' => $weight_delta,    );    $form[$key]['region'] = array(      '#type' => 'select',      '#default_value' => $block['region'],      '#options' => $block_regions,    );    if ($throttle) {      $form[$key]['throttle'] = array('#type' => 'checkbox', '#default_value' => isset($block['throttle']) ? $block['throttle'] : FALSE);    }    $form[$key]['configure'] = array('#value' => l(t('configure'), 'admin/build/block/configure/'. $block['module'] .'/'. $block['delta']));    if ($block['module'] == 'block') {      $form[$key]['delete'] = array('#value' => l(t('delete'), 'admin/build/block/delete/'. $block['delta']));    }  }  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save blocks'),  );  return $form;}/** * Process main blocks administration form submission. */function block_admin_display_form_submit($form, &$form_state) {  foreach ($form_state['values'] as $block) {    $block['status'] = $block['region'] != BLOCK_REGION_NONE;    $block['region'] = $block['status'] ? $block['region'] : '';    db_query("UPDATE {blocks} SET status = %d, weight = %d, region = '%s', throttle = %d WHERE module = '%s' AND delta = '%s' AND theme = '%s'", $block['status'], $block['weight'], $block['region'], isset($block['throttle']) ? $block['throttle'] : 0, $block['module'], $block['delta'], $block['theme']);  }  drupal_set_message(t('The block settings have been updated.'));  cache_clear_all();}/** * Helper function for sorting blocks on admin/build/block. * * Active blocks are sorted by region, then by weight. * Disabled blocks are sorted by name. */function _block_compare($a, $b) {  global $theme_key;  static $regions;  // We need the region list to correctly order by region.  if (!isset($regions)) {    $regions = array_flip(array_keys(system_region_list($theme_key)));    $regions[BLOCK_REGION_NONE] = count($regions);  }  // Separate enabled from disabled.  $status = $b['status'] - $a['status'];  if ($status) {    return $status;  }  // Sort by region (in the order defined by theme .info file).  if ((!empty($a['region']) && !empty($b['region'])) && ($place = ($regions[$a['region']] - $regions[$b['region']]))) {    return $place;  }  // Sort by weight.  $weight = $a['weight'] - $b['weight'];  if ($weight) {    return $weight;  }  // Sort by title.  return strcmp($a['info'], $b['info']);}/** * Menu callback; displays the block configuration form. */function block_admin_configure(&$form_state, $module = NULL, $delta = 0) {  $form['module'] = array('#type' => 'value', '#value' => $module);  $form['delta'] = array('#type' => 'value', '#value' => $delta);  $edit = db_fetch_array(db_query("SELECT pages, visibility, custom, title FROM {blocks} WHERE module = '%s' AND delta = '%s'", $module, $delta));  $form['block_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Block specific settings'),    '#collapsible' => TRUE,  );  $form['block_settings']['title'] = array(    '#type' => 'textfield',    '#title' => t('Block title'),    '#maxlength' => 64,    '#description' => $module == 'block' ? t('The title of the block as shown to the user.') : t('Override the default title for the block. Use <em>&lt;none&gt;</em> to display no title, or leave blank to use the default block title.'),    '#default_value' => $edit['title'],    '#weight' => -18,  );  // Module-specific block configurations.  if ($settings = module_invoke($module, 'block', 'configure', $delta)) {    foreach ($settings as $k => $v) {      $form['block_settings'][$k] = $v;    }  }  // Get the block subject for the page title.  $info = module_invoke($module, 'block', 'list');  if (isset($info[$delta])) {    drupal_set_title(t("'%name' block", array('%name' => $info[$delta]['info'])));  }  // Standard block configurations.  $form['user_vis_settings'] = array(    '#type' => 'fieldset',    '#title' => t('User specific visibility settings'),    '#collapsible' => TRUE,  );  $form['user_vis_settings']['custom'] = array(    '#type' => 'radios',    '#title' => t('Custom visibility settings'),    '#options' => array(      t('Users cannot control whether or not they see this block.'),      t('Show this block by default, but let individual users hide it.'),      t('Hide this block by default but let individual users show it.')    ),    '#description' => t('Allow individual users to customize the visibility of this block in their account settings.'),    '#default_value' => $edit['custom'],  );  // Role-based visibility settings  $default_role_options = array();  $result = db_query("SELECT rid FROM {blocks_roles} WHERE module = '%s' AND delta = '%s'", $module, $delta);  while ($role = db_fetch_object($result)) {    $default_role_options[] = $role->rid;  }  $result = db_query('SELECT rid, name FROM {role} ORDER BY name');  $role_options = array();  while ($role = db_fetch_object($result)) {    $role_options[$role->rid] = $role->name;  }  $form['role_vis_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Role specific visibility settings'),    '#collapsible' => TRUE,  );  $form['role_vis_settings']['roles'] = array(    '#type' => 'checkboxes',    '#title' => t('Show block for specific roles'),    '#default_value' => $default_role_options,    '#options' => $role_options,    '#description' => t('Show this block only for the selected role(s). If you select no roles, the block will be visible to all users.'),  );  $form['page_vis_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Page specific visibility settings'),    '#collapsible' => TRUE,  );  $access = user_access('use PHP for block visibility');  if ($edit['visibility'] == 2 && !$access) {    $form['page_vis_settings'] = array();    $form['page_vis_settings']['visibility'] = array('#type' => 'value', '#value' => 2);    $form['page_vis_settings']['pages'] = array('#type' => 'value', '#value' => $edit['pages']);  }  else {    $options = array(t('Show on every page except the listed pages.'), t('Show on only the listed pages.'));    $description = t("Enter one page per line as Drupal paths. The '*' character is a wildcard. Example paths are %blog for the blog page and %blog-wildcard for every personal blog. %front is the front page.", array('%blog' => 'blog', '%blog-wildcard' => 'blog/*', '%front' => '<front>'));    if ($access) {      $options[] = t('Show if the following PHP code returns <code>TRUE</code> (PHP-mode, experts only).');      $description .= ' '. t('If the PHP-mode is chosen, enter PHP code between %php. Note that executing incorrect PHP-code can break your Drupal site.', array('%php' => '<?php ?>'));    }    $form['page_vis_settings']['visibility'] = array(      '#type' => 'radios',      '#title' => t('Show block on specific pages'),      '#options' => $options,      '#default_value' => $edit['visibility'],    );    $form['page_vis_settings']['pages'] = array(      '#type' => 'textarea',      '#title' => t('Pages'),      '#default_value' => $edit['pages'],      '#description' => $description,    );  }  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save block'),  );  return $form;}function block_admin_configure_validate($form, &$form_state) {  if ($form_state['values']['module'] == 'block') {    if (empty($form_state['values']['info']) || db_result(db_query("SELECT COUNT(*) FROM {boxes} WHERE bid != %d AND info = '%s'", $form_state['values']['delta'], $form_state['values']['info']))) {      form_set_error('info', t('Please ensure that each block description is unique.'));    }  }}function block_admin_configure_submit($form, &$form_state) {  if (!form_get_errors()) {    db_query("UPDATE {blocks} SET visibility = %d, pages = '%s', custom = %d, title = '%s' WHERE module = '%s' AND delta = '%s'", $form_state['values']['visibility'], trim($form_state['values']['pages']), $form_state['values']['custom'], $form_state['values']['title'], $form_state['values']['module'], $form_state['values']['delta']);    db_query("DELETE FROM {blocks_roles} WHERE module = '%s' AND delta = '%s'", $form_state['values']['module'], $form_state['values']['delta']);    foreach (array_filter($form_state['values']['roles']) as $rid) {      db_query("INSERT INTO {blocks_roles} (rid, module, delta) VALUES (%d, '%s', '%s')", $rid, $form_state['values']['module'], $form_state['values']['delta']);    }    module_invoke($form_state['values']['module'], 'block', 'save', $form_state['values']['delta'], $form_state['values']);    drupal_set_message(t('The block configuration has been saved.'));    cache_clear_all();    $form_state['redirect'] = 'admin/build/block';    return;  }}/** * Menu callback: display the custom block addition form. */function block_add_block_form(&$form_state) {  return block_admin_configure($form_state, 'block', NULL);}function block_add_block_form_validate($form, &$form_state) {  if (empty($form_state['values']['info']) || db_result(db_query("SELECT COUNT(*) FROM {boxes} WHERE info = '%s'", $form_state['values']['info']))) {    form_set_error('info', t('Please ensure that each block description is unique.'));  }}/** * Save the new custom block. */function block_add_block_form_submit($form, &$form_state) {  db_query("INSERT INTO {boxes} (body, info, format) VALUES ('%s', '%s', %d)", $form_state['values']['body'], $form_state['values']['info'], $form_state['values']['format']);  $delta = db_last_insert_id('boxes', 'bid');  foreach (list_themes() as $key => $theme) {    if ($theme->status) {      db_query("INSERT INTO {blocks} (visibility, pages, custom, title, module, theme, status, weight, delta, cache) VALUES(%d, '%s', %d, '%s', '%s', '%s', %d, %d, '%s', %d)", $form_state['values']['visibility'], trim($form_state['values']['pages']), $form_state['values']['custom'], $form_state['values']['title'], $form_state['values']['module'], $theme->name, 0, 0, $delta, BLOCK_NO_CACHE);    }  }  foreach (array_filter($form_state['values']['roles']) as $rid) {    db_query("INSERT INTO {blocks_roles} (rid, module, delta) VALUES (%d, '%s', '%s')", $rid, $form_state['values']['module'], $delta);  }  drupal_set_message(t('The block has been created.'));  cache_clear_all();  $form_state['redirect'] = 'admin/build/block';  return;}/** * Menu callback; confirm deletion of custom blocks. */function block_box_delete(&$form_state, $bid = 0) {  $box = block_box_get($bid);  $form['info'] = array('#type' => 'hidden', '#value' => $box['info']);  $form['bid'] = array('#type' => 'hidden', '#value' => $bid);  return confirm_form($form, t('Are you sure you want to delete the block %name?', array('%name' => $box['info'])), 'admin/build/block', '', t('Delete'), t('Cancel'));}/** * Deletion of custom blocks. */function block_box_delete_submit($form, &$form_state) {  db_query('DELETE FROM {boxes} WHERE bid = %d', $form_state['values']['bid']);  db_query("DELETE FROM {blocks} WHERE module = 'block' AND delta = '%s'", $form_state['values']['bid']);  drupal_set_message(t('The block %name has been removed.', array('%name' => $form_state['values']['info'])));  cache_clear_all();  $form_state['redirect'] = 'admin/build/block';  return;}/** * Process variables for block-admin-display.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see block-admin-display.tpl.php * @see theme_block_admin_display() */function template_preprocess_block_admin_display_form(&$variables) {  global $theme_key;  $block_regions = system_region_list($theme_key);  $variables['throttle'] = module_exists('throttle');  $variables['block_regions'] = $block_regions + array(BLOCK_REGION_NONE => t('Disabled'));  foreach ($block_regions as $key => $value) {    // Highlight regions on page to provide visual reference.    drupal_set_content($key, '<div class="block-region">'. $value .'</div>');    // Initialize an empty array for the region.    $variables['block_listing'][$key] = array();  }  // Initialize disabled blocks array.  $variables['block_listing'][BLOCK_REGION_NONE] = array();  // Set up to track previous region in loop.  $last_region = '';  foreach (element_children($variables['form']) as $i) {    $block = &$variables['form'][$i];    // Only take form elements that are blocks.    if (isset($block['info'])) {      // Fetch region for current block.      $region = $block['region']['#default_value'];      // Set special classes needed for table drag and drop.      $variables['form'][$i]['region']['#attributes']['class'] = 'block-region-select block-region-'. $region;      $variables['form'][$i]['weight']['#attributes']['class'] = 'block-weight block-weight-'. $region;      $variables['block_listing'][$region][$i]->row_class = isset($block['#attributes']['class']) ? $block['#attributes']['class'] : '';      $variables['block_listing'][$region][$i]->block_modified = isset($block['#attributes']['class']) && strpos($block['#attributes']['class'], 'block-modified') !== FALSE ? TRUE : FALSE;      $variables['block_listing'][$region][$i]->block_title =  drupal_render($block['info']);      $variables['block_listing'][$region][$i]->region_select = drupal_render($block['region']) . drupal_render($block['theme']);      $variables['block_listing'][$region][$i]->weight_select = drupal_render($block['weight']);      $variables['block_listing'][$region][$i]->throttle_check = $variables['throttle'] ? drupal_render($block['throttle']) : '';      $variables['block_listing'][$region][$i]->configure_link = drupal_render($block['configure']);      $variables['block_listing'][$region][$i]->delete_link = !empty($block['delete']) ? drupal_render($block['delete']) : '';      $variables['block_listing'][$region][$i]->printed = FALSE;      $last_region = $region;    }  }  $variables['form_submit'] = drupal_render($variables['form']);}
<?php// $Id$/** * @file comment.tpl.php * Default theme implementation for comments. * * Available variables: * - $author: Comment author. Can be link or plain text. * - $content: Body of the post. * - $date: Date and time of posting. * - $links: Various operational links. * - $new: New comment marker. * - $picture: Authors picture. * - $signature: Authors signature. * - $status: Comment status. Possible values are: *   comment-unpublished, comment-published or comment-preview. * - $submitted: By line with date and time. * - $title: Linked title. * * These two variables are provided for context. * - $comment: Full comment object. * - $node: Node object the comments are attached to. * * @see template_preprocess_comment() * @see theme_comment() */?><div class="comment<?php print ($comment->new) ? ' comment-new' : ''; print ' '. $status ?> clear-block">  <?php print $picture ?>  <?php if ($comment->new): ?>    <span class="new"><?php print $new ?></span>  <?php endif; ?>  <h3><?php print $title ?></h3>  <div class="submitted">    <?php print $submitted ?>  </div>  <div class="content">    <?php print $content ?>    <?php if ($signature): ?>    <div class="user-signature clear-block">      <?php print $signature ?>    </div>    <?php endif; ?>  </div>  <?php print $links ?></div>
<?php// $Id$/** * @file * Enables the use of personal and site-wide contact forms. *//** * Implementation of hook_help(). */function contact_help($path, $arg) {  switch ($path) {    case 'admin/help#contact':      $output = '<p>'. t('The contact module facilitates communication via e-mail, by allowing your site\'s visitors to contact one another (personal contact forms), and by providing a simple way to direct messages to a set of administrator-defined recipients (the <a href="@contact">contact page</a>). With either form, users specify a subject, write their message, and (optionally) have a copy of their message sent to their own e-mail address.', array('@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t("Personal contact forms allow users to be contacted via e-mail, while keeping recipient e-mail addresses private. Users may enable or disable their personal contact forms by editing their <em>My account</em> page. If enabled, a <em>Contact</em> tab leading to their personal contact form is available on their user profile. Site administrators have access to all personal contact forms (even if they have been disabled). The <em>Contact</em> tab is only visible when viewing another user's profile (users do not see their own <em>Contact</em> tab).") .'</p>';      $output .= '<p>'. t('The <a href="@contact">contact page</a> provides a simple form for visitors to leave comments, feedback, or other requests. Messages are routed by selecting a category from a list of administrator-defined options; each category has its own set of e-mail recipients. Common categories for a business site include, for example, "Website feedback" (messages are forwarded to web site administrators) and "Product information" (messages are forwarded to members of the sales department). The actual e-mail addresses defined within a category are not displayed. Only users in roles with the <em>access site-wide contact form</em> permission may access the <a href="@contact">contact page</a>.', array('@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t('A link to your site\'s <a href="@contact">contact page</a> from the main <em>Navigation</em> menu is created, but is disabled by default. Create a similar link on another menu by adding a menu item pointing to the path "contact"', array('@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t('Customize the <a href="@contact">contact page</a> with additional information (like physical location, mailing address, and telephone number) using the <a href="@contact-settings">contact form settings page</a>. The <a href="@contact-settings">settings page</a> also provides configuration options for the maximum number of contact form submissions a user may perform per hour, and the default status of users\' personal contact forms.', array('@contact-settings' => url('admin/build/contact/settings'), '@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@contact">Contact module</a>.', array('@contact' => url('http://drupal.org/handbook/modules/contact/', array('absolute' => TRUE)))) .'</p>';      return $output;    case 'admin/build/contact':      $output = '<p>'. t('This page lets you set up <a href="@form">your site-wide contact form</a>. To do so, add one or more categories. You can associate different recipients with each category to route e-mails to different people. For example, you can route website feedback to the webmaster and direct product information requests to the sales department. On the <a href="@settings">settings page</a>, you can customize the information shown above the contact form. This can be useful to provide additional contact information such as your postal address and telephone number.', array('@settings' => url('admin/build/contact/settings'), '@form' => url('contact'))) .'</p>';      if (!module_exists('menu')) {        $menu_note = t('The menu item can be customized and configured only once the menu module has been <a href="@modules-page">enabled</a>.', array('@modules-page' => url('admin/settings/modules')));      }      else {        $menu_note = '';      }      $output .= '<p>'. t('The contact module also adds a <a href="@menu-settings">menu item</a> (disabled by default) to the navigation block.', array('@menu-settings' => url('admin/build/menu'))) .' '. $menu_note .'</p>';      return $output;  }}/** * Implementation of hook_perm */function contact_perm() {  return array('access site-wide contact form', 'administer site-wide contact form');}/** * Implementation of hook_menu(). */function contact_menu() {  $items['admin/build/contact'] = array(    'title' => 'Contact form',    'description' => 'Create a system contact form and set up categories for the form to use.',    'page callback' => 'contact_admin_categories',    'access arguments' => array('administer site-wide contact form'),    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/list'] = array(    'title' => 'List',    'page callback' => 'contact_admin_categories',    'type' => MENU_DEFAULT_LOCAL_TASK,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/add'] = array(    'title' => 'Add category',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_edit', 3),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/edit/%contact'] = array(    'title' => 'Edit contact category',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_edit', 3, 4),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_CALLBACK,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/delete/%contact'] = array(    'title' => 'Delete contact',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_delete', 4),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_CALLBACK,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_settings'),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'contact.admin.inc',  );  $items['contact'] = array(    'title' => 'Contact',    'page callback' => 'contact_site_page',    'access arguments' => array('access site-wide contact form'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'contact.pages.inc',  );  $items['user/%user/contact'] = array(    'title' => 'Contact',    'page callback' => 'contact_user_page',    'page arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'access callback' => '_contact_user_tab_access',    'access arguments' => array(1),    'weight' => 2,    'file' => 'contact.pages.inc',  );  return $items;}/** * Menu access callback for a user's personal contact form. * * @param $account *   A user account object. * @return *   TRUE if the current user has access to the requested user's contact form, *   or FALSE otherwise. */function _contact_user_tab_access($account) {  global $user;  // Anonymous users cannot use or have contact forms.  if (!$user->uid || !$account->uid) {    return FALSE;  }  // User administrators should always have access to personal contact forms.  if (user_access('administer users')) {    return TRUE;  }  // Users may not contact themselves.  if ($user->uid == $account->uid) {    return FALSE;  }  // If the requested user has disabled their contact form, or this preference  // has not yet been saved, do not allow users to contact them.  if (empty($account->contact)) {    return FALSE;  }  return TRUE;}/** * Load the data for a single contact category. */function contact_load($cid) {  $contact = db_fetch_array(db_query("SELECT * FROM {contact} WHERE cid = %d", $cid));  return empty($contact) ? FALSE : $contact;}/** * Implementation of hook_user(). * * Allows the user the option of enabling/disabling his personal contact form. */function contact_user($type, &$edit, &$user, $category = NULL) {  if ($type == 'form' && $category == 'account') {    $form['contact'] = array('#type' => 'fieldset',      '#title' => t('Contact settings'),      '#weight' => 5,      '#collapsible' => TRUE,    );    $form['contact']['contact'] = array('#type' => 'checkbox',      '#title' => t('Personal contact form'),      '#default_value' => !empty($edit['contact']) ? $edit['contact'] : FALSE,      '#description' => t('Allow other users to contact you by e-mail via <a href="@url">your personal contact form</a>. Note that while your e-mail address is not made public to other members of the community, privileged users such as site administrators are able to contact you even if you choose not to enable this feature.', array('@url' => url("user/$user->uid/contact"))),    );    return $form;  }  elseif ($type == 'validate') {    return array('contact' => isset($edit['contact']) ? $edit['contact'] : FALSE);  }  elseif ($type == 'insert') {    $edit['contact'] = variable_get('contact_default_status', 1);  }}/** * Implementation of hook_mail(). */function contact_mail($key, &$message, $params) {  $language = $message['language'];  switch ($key) {    case 'page_mail':    case 'page_copy':      $contact = $params['contact'];      $message['subject'] .= t('[!category] !subject', array('!category' => $contact['category'], '!subject' => $params['subject']), $language->language);      $message['body'][] = t("!name sent a message using the contact form at !form.", array('!name' => $params['name'], '!form' => url($_GET['q'], array('absolute' => TRUE, 'language' => $language))), $language->language);      $message['body'][] = $params['message'];      break;    case 'page_autoreply':      $contact = $params['contact'];      $message['subject'] .= t('[!category] !subject', array('!category' => $contact['category'], '!subject' => $params['subject']), $language->language);      $message['body'][] = $contact['reply'];      break;    case 'user_mail':    case 'user_copy':      $user = $params['user'];      $account = $params['account'];      $message['subject'] .= '['. variable_get('site_name', 'Drupal') .'] '. $params['subject'];      $message['body'][] = "$account->name,";      $message['body'][] = t("!name (!name-url) has sent you a message via your contact form (!form-url) at !site.", array('!name' => $user->name, '!name-url' => url("user/$user->uid", array('absolute' => TRUE, 'language' => $language)), '!form-url' => url($_GET['q'], array('absolute' => TRUE, 'language' => $language)), '!site' => variable_get('site_name', 'Drupal')), $language->language);      $message['body'][] = t("If you don't want to receive such e-mails, you can change your settings at !url.", array('!url' => url("user/$account->uid", array('absolute' => TRUE, 'language' => $language))), $language->language);      $message['body'][] = t('Message:', NULL, $language->language);      $message['body'][] = $params['message'];      break;  }}
<?php// $Id$/** * @file maintenance-page.tpl.php * * This is an override of the default maintenance page. Used for Garland and * Minnelli, this file should not be moved or modified since the installation * and update pages depend on this file. * * This mirrors closely page.tpl.php for Garland in order to share the same * styles. */?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>">  <head>    <?php print $head ?>    <title><?php print $head_title ?></title>    <?php print $styles ?>    <?php print $scripts ?>    <!--[if lt IE 7]>      <?php print phptemplate_get_ie_styles(); ?>    <![endif]-->  </head>  <body<?php print phptemplate_body_class($left, $right); ?>><!-- Layout -->  <div id="header-region" class="clear-block"><?php print $header; ?></div>    <div id="wrapper">    <div id="container" class="clear-block">      <div id="header">        <div id="logo-floater">        <?php          // Prepare header          $site_fields = array();          if ($site_name) {            $site_fields[] = check_plain($site_name);          }          if ($site_slogan) {            $site_fields[] = check_plain($site_slogan);          }          $site_title = implode(' ', $site_fields);          if ($site_fields) {            $site_fields[0] = '<span>'. $site_fields[0] .'</span>';          }          $site_html = implode(' ', $site_fields);          if ($logo || $site_title) {            print '<h1><a href="'. check_url($base_path) .'" title="'. $site_title .'">';            if ($logo) {              print '<img src="'. check_url($logo) .'" alt="'. $site_title .'" id="logo" />';            }            print $site_html .'</a></h1>';          }        ?>        </div>      </div> <!-- /header -->      <?php if ($left): ?>        <div id="sidebar-left" class="sidebar">          <?php if ($search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $left ?>        </div>      <?php endif; ?>      <div id="center"><div id="squeeze"><div class="right-corner"><div class="left-corner">          <?php if ($title): print '<h2'. ($tabs ? ' class="with-tabs"' : '') .'>'. $title .'</h2>'; endif; ?>          <?php print $help; ?>          <?php print $messages; ?>          <div class="clear-block">            <?php print $content ?>          </div>          <div id="footer"><?php print $footer_message . $footer ?></div>      </div></div></div></div> <!-- /.left-corner, /.right-corner, /#squeeze, /#center -->      <?php if ($right): ?>        <div id="sidebar-right" class="sidebar">          <?php print $right ?>        </div>      <?php endif; ?>    </div> <!-- /container -->  </div><!-- /layout -->  </body></html>
<?php// $Id$/** * @file * User page callbacks for the book module. *//** * Menu callback; prints a listing of all books. */function book_render() {  $book_list = array();  foreach (book_get_books() as $book) {    $book_list[] = l($book['title'], $book['href'], $book['options']);  }  return theme('item_list', $book_list);}/** * Menu callback; Generates various representation of a book page and its children. * * The function delegates the generation of output to helper functions. * The function name is derived by prepending 'book_export_' to the * given output type. So, e.g., a type of 'html' results in a call to * the function book_export_html(). * * @param $type *   A string encoding the type of output requested. The following *   types are currently supported in book module: * *   - html: HTML (printer friendly output) * *   Other types may be supported in contributed modules. * @param $nid *   An integer representing the node id (nid) of the node to export * @return *   A string representing the node and its children in the book hierarchy *   in a format determined by the $type parameter. */function book_export($type, $nid) {  $type = drupal_strtolower($type);  $export_function = 'book_export_'. $type;  if (function_exists($export_function)) {    print call_user_func($export_function, $nid);  }  else {    drupal_set_message(t('Unknown export format.'));    drupal_not_found();  }}/** * This function is called by book_export() to generate HTML for export. * * The given node is /embedded to its absolute depth in a top level * section/. For example, a child node with depth 2 in the hierarchy * is contained in (otherwise empty) &lt;div&gt; elements * corresponding to depth 0 and depth 1. This is intended to support * WYSIWYG output - e.g., level 3 sections always look like level 3 * sections, no matter their depth relative to the node selected to be * exported as printer-friendly HTML. * * @param $nid *   An integer representing the node id (nid) of the node to export. * @return *   A string containing HTML representing the node and its children in *   the book hierarchy. */function book_export_html($nid) {  if (user_access('access printer-friendly version')) {    $export_data = array();    $node = node_load($nid);    if (isset($node->book)) {      $tree = book_menu_subtree_data($node->book);      $contents = book_export_traverse($tree, 'book_node_export');    }    return theme('book_export_html', $node->title, $contents, $node->book['depth']);  }  else {    drupal_access_denied();  }}/** * Menu callback; show the outline form for a single node. */function book_outline($node) {  drupal_set_title(check_plain($node->title));  return drupal_get_form('book_outline_form', $node);}/** * Build the form to handle all book outline operations via the outline tab. * * @see book_outline_form_submit() * @see book_remove_button_submit() * * @ingroup forms */function book_outline_form(&$form_state, $node) {  if (!isset($node->book)) {    // The node is not part of any book yet - set default options.    $node->book = _book_link_defaults($node->nid);  }  else {    $node->book['original_bid'] = $node->book['bid'];  }  // Find the depth limit for the parent select.  if (!isset($node->book['parent_depth_limit'])) {    $node->book['parent_depth_limit'] = _book_parent_depth_limit($node->book);  }  $form['#node'] = $node;  $form['#id'] = 'book-outline';  _book_add_form_elements($form, $node);  $form['book']['#collapsible'] = FALSE;  $form['update'] = array(    '#type' => 'submit',    '#value' => $node->book['original_bid'] ? t('Update book outline') : t('Add to book outline'),    '#weight' => 15,  );  $form['remove'] = array(    '#type' => 'submit',    '#value' => t('Remove from book outline'),    '#access' => $node->nid != $node->book['bid'] && $node->book['bid'],    '#weight' => 20,    '#submit' => array('book_remove_button_submit'),  );  return $form;}/** * Button submit function to redirect to removal confirm form. * * @see book_outline_form() */function book_remove_button_submit($form, &$form_state) {  $form_state['redirect'] = 'node/'. $form['#node']->nid .'/outline/remove';}/** * Handles book outline form submissions from the outline tab. * * @see book_outline_form() */function book_outline_form_submit($form, &$form_state) {  $node = $form['#node'];  $form_state['redirect'] = "node/". $node->nid;  $book_link = $form_state['values']['book'];  if (!$book_link['bid']) {    drupal_set_message(t('No changes were made'));    return;  }  $book_link['menu_name'] = book_menu_name($book_link['bid']);  $node->book = $book_link;  if (_book_update_outline($node)) {    if ($node->book['parent_mismatch']) {      // This will usually only happen when JS is disabled.      drupal_set_message(t('The post has been added to the selected book. You may now position it relative to other pages.'));      $form_state['redirect'] = "node/". $node->nid ."/outline";    }    else {      drupal_set_message(t('The book outline has been updated.'));    }  }  else {    drupal_set_message(t('There was an error adding the post to the book.'), 'error');  }}/** * Menu callback; builds a form to confirm removal of a node from the book. * * @see book_remove_form_submit() * * @ingroup forms */function book_remove_form(&$form_state, $node) {  $form['#node'] = $node;  $title = array('%title' => $node->title);  if ($node->book['has_children']) {    $description = t('%title has associated child pages, which will be relocated automatically to maintain their connection to the book. To recreate the hierarchy (as it was before removing this page), %title may be added again using the Outline tab, and each of its former child pages will need to be relocated manually.', $title);  }  else {    $description = t('%title may be added to hierarchy again using the Outline tab.', $title);  }  return confirm_form($form, t('Are you sure you want to remove %title from the book hierarchy?', $title), 'node/'. $node->nid, $description, t('Remove'));}/** * Confirm form submit function to remove a node from the book. * * @see book_remove_form() */function book_remove_form_submit($form, &$form_state) {  $node = $form['#node'];  if ($node->nid != $node->book['bid']) {    // Only allowed when this is not a book (top-level page).    menu_link_delete($node->book['mlid']);    db_query('DELETE FROM {book} WHERE nid = %d', $node->nid);    drupal_set_message(t('The post has been removed from the book.'));  }  $form_state['redirect'] = 'node/'. $node->nid;}/** * AJAX callback to replace the book parent select options. * * This function is called when the selected book is changed.  It updates the * cached form (either the node form or the book outline form) and returns * rendered output to be used to replace the select containing the possible * parent pages in the newly selected book. * * @param $build_id *   The form's build_id. * @param $bid *   A bid from from among those in the form's book select. * @return *   Prints the replacement HTML in JSON format. */function book_form_update() {  $bid = $_POST['book']['bid'];  if ($form = form_get_cache($_POST['form_build_id'], $form_state)) {    // Validate the bid.    if (isset($form['book']['bid']['#options'][$bid])) {      $book_link = $form['#node']->book;      $book_link['bid'] = $bid;      // Get the new options and update the cache.      $form['book']['plid'] = _book_parent_select($book_link);      form_set_cache($_POST['form_build_id'], $form, $form_state);      // Build and render the new select element, then return it in JSON format.      $form_state = array();      $form['#post'] = array();      $form = form_builder($form['form_id']['#value'] , $form, $form_state);      $output = drupal_render($form['book']['plid']);      drupal_json(array('status' => TRUE, 'data' => $output));    }    else {      drupal_json(array('status' => FALSE, 'data' => ''));    }  }  else {    drupal_json(array('status' => FALSE, 'data' => ''));  }  exit();}
<?php// $Id$/** * @file * Configuration system that lets administrators modify the workings of the site. *//** * The current system version. */define('VERSION', '6.16');/** * Core API compatibility. */define('DRUPAL_CORE_COMPATIBILITY', '6.x');/** * Minimum supported version of PHP. */define('DRUPAL_MINIMUM_PHP',    '4.3.5');/** * Minimum recommended value of PHP memory_limit. */define('DRUPAL_MINIMUM_PHP_MEMORY_LIMIT',    '16M');/** * Minimum supported version of MySQL, if it is used. */define('DRUPAL_MINIMUM_MYSQL',  '4.1.1');/** * Minimum supported version of PostgreSQL, if it is used. */define('DRUPAL_MINIMUM_PGSQL',  '7.4');/** * Maximum age of temporary files in seconds. */define('DRUPAL_MAXIMUM_TEMP_FILE_AGE', 21600);/** * Implementation of hook_help(). */function system_help($path, $arg) {  global $base_url;  switch ($path) {    case 'admin/help#system':      $output = '<p>'. t('The system module is at the foundation of your Drupal website, and provides basic but extensible functionality for use by other modules and themes. Some integral elements of Drupal are contained in and managed by the system module, including caching, enabling or disabling of modules and themes, preparing and displaying the administrative page, and configuring fundamental site settings. A number of key system maintenance operations are also part of the system module.') .'</p>';      $output .= '<p>'. t('The system module provides:') .'</p>';      $output .= '<ul><li>'. t('support for enabling and disabling <a href="@modules">modules</a>. Drupal comes packaged with a number of core modules; each module provides a discrete set of features and may be enabled depending on the needs of your site. A wide array of additional modules contributed by members of the Drupal community are available for download at the <a href="@drupal-modules">Drupal.org module page</a>.', array('@modules' => url('admin/build/modules'), '@drupal-modules' => 'http://drupal.org/project/modules')) .'</li>';      $output .= '<li>'. t('support for enabling and disabling <a href="@themes">themes</a>, which determine the design and presentation of your site. Drupal comes packaged with several core themes and additional contributed themes are available at the <a href="@drupal-themes">Drupal.org theme page</a>.', array('@themes' => url('admin/build/themes'), '@drupal-themes' => 'http://drupal.org/project/themes')) .'</li>';      $output .= '<li>'. t('a robust <a href="@cache-settings">caching system</a> that allows the efficient re-use of previously-constructed web pages and web page components. Drupal stores the pages requested by anonymous users in a compressed format; depending on your site configuration and the amount of your web traffic tied to anonymous visitors, Drupal\'s caching system may significantly increase the speed of your site.', array('@cache-settings' => url('admin/settings/performance'))) .'</li>';      $output .= '<li>'. t('a set of routine administrative operations that rely on a correctly-configured <a href="@cron">cron maintenance task</a> to run automatically. A number of other modules, including the feed aggregator, ping module and search also rely on <a href="@cron">cron maintenance tasks</a>. For more information, see the online handbook entry for <a href="@handbook">configuring cron jobs</a>.', array('@cron' => url('admin/reports/status'), '@handbook' => 'http://drupal.org/cron')) .'</li>';      $output .= '<li>'. t('basic configuration options for your site, including <a href="@date-settings">date and time settings</a>, <a href="@file-system">file system settings</a>, <a href="@clean-url">clean URL support</a>, <a href="@site-info">site name and other information</a>, and a <a href="@site-maintenance">site maintenance</a> function for taking your site temporarily off-line.', array('@date-settings' => url('admin/settings/date-time'), '@file-system' => url('admin/settings/file-system'), '@clean-url' => url('admin/settings/clean-urls'), '@site-info' => url('admin/settings/site-information'), '@site-maintenance' => url('admin/settings/site-maintenance'))) .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@system">System module</a>.', array('@system' => 'http://drupal.org/handbook/modules/system/')) .'</p>';      return $output;    case 'admin':      return '<p>'. t('Welcome to the administration section. Here you may control how your site functions.') .'</p>';    case 'admin/by-module':      return '<p>'. t('This page shows you all available administration tasks for each module.') .'</p>';    case 'admin/build/themes':      $output = '<p>'. t('Select which themes are available to your users and specify the default theme. To configure site-wide display settings, click the "configure" task above. Alternatively, to override these settings in a specific theme, click the "configure" link for that theme. Note that different themes may have different regions available for displaying content; for consistency in presentation, you may wish to enable only one theme.') .'</p>';      $output .= '<p>'. t('To change the appearance of your site, a number of <a href="@themes">contributed themes</a> are available.', array('@themes' => 'http://drupal.org/project/themes')) .'</p>';      return $output;    case 'admin/build/themes/settings/'. $arg[4]:      $reference = explode('.', $arg[4], 2);      $theme = array_pop($reference);      return '<p>'. t('These options control the display settings for the <code>%template</code> theme. When your site is displayed using this theme, these settings will be used. By clicking "Reset to defaults," you can choose to use the <a href="@global">global settings</a> for this theme.', array('%template' => $theme, '@global' => url('admin/build/themes/settings'))) .'</p>';    case 'admin/build/themes/settings':      return '<p>'. t('These options control the default display settings for your entire site, across all themes. Unless they have been overridden by a specific theme, these settings will be used.') .'</p>';    case 'admin/build/modules':      $output = '<p>'. t('Modules are plugins that extend Drupal\'s core functionality. Enable modules by selecting the <em>Enabled</em> checkboxes below and clicking the <em>Save configuration</em> button. Once a module is enabled, new <a href="@permissions">permissions</a> may be available. To reduce server load, modules with their <em>Throttle</em> checkbox selected are temporarily disabled when your site becomes extremely busy. (Note that the <em>Throttle</em> checkbox is only available if the Throttle module is enabled.)', array('@permissions' => url('admin/user/permissions')));      if (module_exists('throttle')) {        $output .= ' '. t('The auto-throttle functionality must be enabled on the <a href="@throttle">throttle configuration page</a> after having enabled the throttle module.', array('@throttle' => url('admin/settings/throttle')));      }      $output .= '</p>';      $output .= '<p>'. t('It is important that <a href="@update-php">update.php</a> is run every time a module is updated to a newer version.', array('@update-php' => $base_url .'/update.php')) .'</p>';      $output .= '<p>'. t('You can find all administration tasks belonging to a particular module on the <a href="@by-module">administration by module page</a>.', array('@by-module' => url('admin/by-module'))) .'</p>';      $output .= '<p>'. t('To extend the functionality of your site, a number of <a href="@modules">contributed modules</a> are available.', array('@modules' => 'http://drupal.org/project/modules')) .'</p>';      $output .= '<p>'. t('To clear all caches, click the button on the <a href="@performance">Performance page</a>.', array('@performance' => url('admin/settings/performance', array('fragment' => 'edit-clear')))) .'</p>';      return $output;    case 'admin/build/modules/uninstall':      return '<p>'. t('The uninstall process removes all data related to a module. To uninstall a module, you must first disable it. Not all modules support this feature.') .'</p>';    case 'admin/build/block/configure':      if ($arg[4] == 'system' && $arg[5] == 0) {        return '<p>'. t('The <em>Powered by Drupal</em> block is an optional link to the home page of the Drupal project. While there is absolutely no requirement that sites feature this link, it may be used to show support for Drupal.') .'</p>';      }      break;    case 'admin/settings/actions':    case 'admin/settings/actions/manage':      $output = '<p>'. t('Actions are individual tasks that the system can do, such as unpublishing a piece of content or banning a user. Modules, such as the trigger module, can fire these actions when certain system events happen; for example, when a new post is added or when a user logs in. Modules may also provide additional actions.') .'</p>';      $output .= '<p>'. t('There are two types of actions: simple and advanced. Simple actions do not require any additional configuration, and are listed here automatically. Advanced actions can do more than simple actions; for example, send an e-mail to a specified address, or check for certain words within a piece of content. These actions need to be created and configured first before they may be used. To create an advanced action, select the action from the drop-down below and click the <em>Create</em> button.') .'</p>';      if (module_exists('trigger')) {        $output .= '<p>'. t('You may proceed to the <a href="@url">Triggers</a> page to assign these actions to system events.', array('@url' => url('admin/build/trigger'))) .'</p>';      }      return $output;    case 'admin/settings/actions/configure':      return t('An advanced action offers additional configuration options which may be filled out below. Changing the <em>Description</em> field is recommended, in order to better identify the precise action taking place. This description will be displayed in modules such as the trigger module when assigning actions to system events, so it is best if it is as descriptive as possible (for example, "Send e-mail to Moderation Team" rather than simply "Send e-mail").');    case 'admin/reports/status':      return '<p>'. t("Here you can find a short overview of your site's parameters as well as any problems detected with your installation. It may be useful to copy and paste this information into support requests filed on drupal.org's support forums and project issue queues.") .'</p>';  }}/** * Implementation of hook_theme(). */function system_theme() {  return array_merge(drupal_common_theme(), array(    'system_theme_select_form' => array(      'arguments' => array('form' => NULL),      'file' => 'system.admin.inc',    ),    'system_themes_form' => array(      'arguments' => array('form' => NULL),      'file' => 'system.admin.inc',    ),    'system_modules' => array(      'arguments' => array('form' => NULL),      'file' => 'system.admin.inc',    ),    'system_modules_uninstall' => array(      'arguments' => array('form' => NULL),      'file' => 'system.admin.inc',    ),    'status_report' => array(      'arguments' => array('requirements' => NULL),      'file' => 'system.admin.inc',    ),    'admin_page' => array(      'arguments' => array('blocks' => NULL),      'file' => 'system.admin.inc',    ),    'admin_block' => array(      'arguments' => array('block' => NULL),      'file' => 'system.admin.inc',    ),    'admin_block_content' => array(      'arguments' => array('content' => NULL),      'file' => 'system.admin.inc',    ),    'system_admin_by_module' => array(      'arguments' => array('menu_items' => NULL),      'file' => 'system.admin.inc',    ),    'system_powered_by' => array(      'arguments' => array('image_path' => NULL),    ),  ));}/** * Implementation of hook_perm(). */function system_perm() {  return array('administer site configuration', 'access administration pages', 'administer actions', 'access site reports', 'select different theme', 'administer files');}/** * Implementation of hook_elements(). */function system_elements() {  // Top level form  $type['form'] = array('#method' => 'post', '#action' => request_uri());  // Inputs  $type['submit'] = array('#input' => TRUE, '#name' => 'op', '#button_type' => 'submit', '#executes_submit_callback' => TRUE, '#process' => array('form_expand_ahah'));  $type['button'] = array('#input' => TRUE, '#name' => 'op', '#button_type' => 'submit', '#executes_submit_callback' => FALSE, '#process' => array('form_expand_ahah'));  $type['image_button'] = array('#input' => TRUE, '#button_type' => 'submit', '#executes_submit_callback' => TRUE, '#process' => array('form_expand_ahah'), '#return_value' => TRUE, '#has_garbage_value' => TRUE, '#src' => NULL);  $type['textfield'] = array('#input' => TRUE, '#size' => 60, '#maxlength' => 128, '#autocomplete_path' => FALSE, '#process' => array('form_expand_ahah'));  $type['password'] = array('#input' => TRUE, '#size' => 60, '#maxlength' => 128, '#process' => array('form_expand_ahah'));  $type['password_confirm'] = array('#input' => TRUE, '#process' => array('expand_password_confirm'));  $type['textarea'] = array('#input' => TRUE, '#cols' => 60, '#rows' => 5, '#resizable' => TRUE, '#process' => array('form_expand_ahah'));  $type['radios'] = array('#input' => TRUE, '#process' => array('expand_radios'));  $type['radio'] = array('#input' => TRUE, '#default_value' => NULL, '#process' => array('form_expand_ahah'));  $type['checkboxes'] = array('#input' => TRUE, '#process' => array('expand_checkboxes'), '#tree' => TRUE);  $type['checkbox'] = array('#input' => TRUE, '#return_value' => 1, '#process' => array('form_expand_ahah'));  $type['select'] = array('#input' => TRUE, '#size' => 0, '#multiple' => FALSE, '#process' => array('form_expand_ahah'));  $type['weight'] = array('#input' => TRUE, '#delta' => 10, '#default_value' => 0, '#process' => array('process_weight', 'form_expand_ahah'));  $type['date'] = array('#input' => TRUE, '#process' => array('expand_date'), '#element_validate' => array('date_validate'));  $type['file'] = array('#input' => TRUE, '#size' => 60);  // Form structure  $type['item'] = array('#value' => '');  $type['hidden'] = array('#input' => TRUE, '#process' => array('form_expand_ahah'));  $type['value'] = array('#input' => TRUE);  $type['markup'] = array('#prefix' => '', '#suffix' => '');  $type['fieldset'] = array('#collapsible' => FALSE, '#collapsed' => FALSE, '#value' => NULL, '#process' => array('form_expand_ahah'));  $type['token'] = array('#input' => TRUE);  return $type;}/** * Implementation of hook_menu(). */function system_menu() {  $items['system/files'] = array(    'title' => 'File download',    'page callback' => 'file_download',    'access callback' => TRUE,    'type' => MENU_CALLBACK,  );  $items['admin'] = array(    'title' => 'Administer',    'access arguments' => array('access administration pages'),    'page callback' => 'system_main_admin_page',    'weight' => 9,    'file' => 'system.admin.inc',  );  $items['admin/compact'] = array(    'title' => 'Compact mode',    'page callback' => 'system_admin_compact_page',    'access arguments' => array('access administration pages'),    'type' => MENU_CALLBACK,    'file' => 'system.admin.inc',  );  $items['admin/by-task'] = array(    'title' => 'By task',    'page callback' => 'system_main_admin_page',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/by-module'] = array(    'title' => 'By module',    'page callback' => 'system_admin_by_module',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',    'type' => MENU_LOCAL_TASK,    'weight' => 2,  );  $items['admin/content'] = array(    'title' => 'Content management',    'description' => "Manage your site's content.",    'position' => 'left',    'weight' => -10,    'page callback' => 'system_admin_menu_block_page',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',  );  // menu items that are basically just menu blocks  $items['admin/settings'] = array(    'title' => 'Site configuration',    'description' => 'Adjust basic site configuration options.',    'position' => 'right',    'weight' => -5,    'page callback' => 'system_settings_overview',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',  );  $items['admin/build'] = array(    'title' => 'Site building',    'description' => 'Control how your site looks and feels.',    'position' => 'right',    'weight' => -10,    'page callback' => 'system_admin_menu_block_page',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',  );  $items['admin/settings/admin'] = array(    'title' => 'Administration theme',    'description' => 'Settings for how your administrative pages should look.',    'position' => 'left',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_admin_theme_settings'),    'access arguments' => array('administer site configuration'),    'block callback' => 'system_admin_theme_settings',    'file' => 'system.admin.inc',  );  // Themes:  $items['admin/build/themes'] = array(    'title' => 'Themes',    'description' => 'Change which theme your site uses or allows users to set.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_themes_form', NULL),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/build/themes/select'] = array(    'title' => 'List',    'description' => 'Select the default theme.',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -1,  );  $items['admin/build/themes/settings'] = array(    'title' => 'Configure',    'page arguments' => array('system_theme_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_LOCAL_TASK,  );  // Theme configuration subtabs  $items['admin/build/themes/settings/global'] = array(    'title' => 'Global settings',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -1,  );  foreach (list_themes() as $theme) {    $items['admin/build/themes/settings/'. $theme->name] = array(      'title' => $theme->info['name'],      'page arguments' => array('system_theme_settings', $theme->name),      'type' => MENU_LOCAL_TASK,      'access callback' => '_system_themes_access',      'access arguments' => array($theme),    );  }  // Modules:  $items['admin/build/modules'] = array(    'title' => 'Modules',    'description' => 'Enable or disable add-on modules for your site.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_modules'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/build/modules/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/build/modules/list/confirm'] = array(    'title' => 'List',    'access arguments' => array('administer site configuration'),    'type' => MENU_CALLBACK,  );  $items['admin/build/modules/uninstall'] = array(    'title' => 'Uninstall',    'page arguments' => array('system_modules_uninstall'),    'access arguments' => array('administer site configuration'),    'type' => MENU_LOCAL_TASK,  );  $items['admin/build/modules/uninstall/confirm'] = array(    'title' => 'Uninstall',    'access arguments' => array('administer site configuration'),    'type' => MENU_CALLBACK,  );  // Actions:  $items['admin/settings/actions'] = array(    'title' => 'Actions',    'description' => 'Manage the actions defined for your site.',    'access arguments' => array('administer actions'),    'page callback' => 'system_actions_manage'  );  $items['admin/settings/actions/manage'] = array(    'title' => 'Manage actions',    'description' => 'Manage the actions defined for your site.',    'page callback' => 'system_actions_manage',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -2,  );  $items['admin/settings/actions/configure'] = array(    'title' => 'Configure an advanced action',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_actions_configure'),    'access arguments' => array('administer actions'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/actions/delete/%actions'] = array(    'title' => 'Delete action',    'description' => 'Delete an action.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_actions_delete_form', 4),    'access arguments' => array('administer actions'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/actions/orphan'] = array(    'title' => 'Remove orphans',    'page callback' => 'system_actions_remove_orphans',    'access arguments' => array('administer actions'),    'type' => MENU_CALLBACK,  );  // Settings:  $items['admin/settings/site-information'] = array(    'title' => 'Site information',    'description' => 'Change basic site information, such as the site name, slogan, e-mail address, mission, front page and more.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_site_information_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/error-reporting'] = array(    'title' => 'Error reporting',    'description' => 'Control how Drupal deals with errors including 403/404 errors as well as PHP error reporting.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_error_reporting_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/logging'] = array(    'title' => 'Logging and alerts',    'description' => "Settings for logging and alerts modules. Various modules can route Drupal's system events to different destination, such as syslog, database, email, ...etc.",    'page callback' => 'system_logging_overview',    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/performance'] = array(    'title' => 'Performance',    'description' => 'Enable or disable page caching for anonymous users and set CSS and JS bandwidth optimization options.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_performance_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/file-system'] = array(    'title' => 'File system',    'description' => 'Tell Drupal where to store uploaded files and how they are accessed.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_file_system_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/image-toolkit'] = array(    'title' => 'Image toolkit',    'description' => 'Choose which image toolkit to use if you have installed optional toolkits.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_image_toolkit_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/content/rss-publishing'] = array(    'title' => 'RSS publishing',    'description' => 'Configure the number of items per feed and whether feeds should be titles/teasers/full-text.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_rss_feeds_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/date-time'] = array(    'title' => 'Date and time',    'description' => "Settings for how Drupal displays date and time, as well as the system's default timezone.",    'page callback' => 'drupal_get_form',    'page arguments' => array('system_date_time_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/date-time/lookup'] = array(    'title' => 'Date and time lookup',    'type' => MENU_CALLBACK,    'page callback' => 'system_date_time_lookup',    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/site-maintenance'] = array(    'title' => 'Site maintenance',    'description' => 'Take the site off-line for maintenance or bring it back online.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_site_maintenance_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/clean-urls'] = array(    'title' => 'Clean URLs',    'description' => 'Enable or disable clean URLs for your site.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_clean_url_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/clean-urls/check'] = array(    'title' => 'Clean URL check',    'page callback' => 'drupal_json',    'page arguments' => array(array('status' => TRUE)),    'access callback' => TRUE,    'type' => MENU_CALLBACK,  );  // Reports:  $items['admin/reports'] = array(    'title' => 'Reports',    'description' => 'View reports from system logs and other status information.',    'page callback' => 'system_admin_menu_block_page',    'access arguments' => array('access site reports'),    'weight' => 5,    'position' => 'left',    'file' => 'system.admin.inc',  );  $items['admin/reports/status'] = array(    'title' => 'Status report',    'description' => "Get a status report about your site's operation and any detected problems.",    'page callback' => 'system_status',    'weight' => 10,    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/reports/status/run-cron'] = array(    'title' => 'Run cron',    'page callback' => 'system_run_cron',    'access arguments' => array('administer site configuration'),    'type' => MENU_CALLBACK,    'file' => 'system.admin.inc',  );  $items['admin/reports/status/php'] = array(    'title' => 'PHP',    'page callback' => 'system_php',    'access arguments' => array('administer site configuration'),    'type' => MENU_CALLBACK,    'file' => 'system.admin.inc',  );  $items['admin/reports/status/sql'] = array(    'title' => 'SQL',    'page callback' => 'system_sql',    'access arguments' => array('administer site configuration'),    'type' => MENU_CALLBACK,    'file' => 'system.admin.inc',  );  // Default page for batch operations  $items['batch'] = array(    'page callback' => 'system_batch_page',    'access callback' => TRUE,    'type' => MENU_CALLBACK,    'file' => 'system.admin.inc',  );  return $items;}/** * Menu item access callback - only admin or enabled themes can be accessed. */function _system_themes_access($theme) {  return user_access('administer site configuration') && ($theme->status || $theme->name == variable_get('admin_theme', '0'));}/** * Implementation of hook_init(). */function system_init() {  // Use the administrative theme if the user is looking at a page in the admin/* path.  if (arg(0) == 'admin' || (variable_get('node_admin_theme', '0') && arg(0) == 'node' && (arg(1) == 'add' || arg(2) == 'edit'))) {    global $custom_theme;    $custom_theme = variable_get('admin_theme', '0');    drupal_add_css(drupal_get_path('module', 'system') .'/admin.css', 'module');  }  // Add the CSS for this module.  drupal_add_css(drupal_get_path('module', 'system') .'/defaults.css', 'module');  drupal_add_css(drupal_get_path('module', 'system') .'/system.css', 'module');  drupal_add_css(drupal_get_path('module', 'system') .'/system-menus.css', 'module');}/** * Implementation of hook_user(). * * Allows users to individually set their theme and time zone. */function system_user($type, $edit, &$user, $category = NULL) {  if ($type == 'form' && $category == 'account') {    $form['theme_select'] = system_theme_select_form(t('Selecting a different theme will change the look and feel of the site.'), isset($edit['theme']) ? $edit['theme'] : NULL, 2);    if (variable_get('configurable_timezones', 1)) {      $zones = _system_zonelist();      $form['timezone'] = array(        '#type' => 'fieldset',        '#title' => t('Locale settings'),        '#weight' => 6,        '#collapsible' => TRUE,      );      $form['timezone']['timezone'] = array(        '#type' => 'select',        '#title' => t('Time zone'),        '#default_value' => strlen($edit['timezone']) ? $edit['timezone'] : variable_get('date_default_timezone', 0),        '#options' => $zones,        '#description' => t('Select your current local time. Dates and times throughout this site will be displayed using this time zone.'),      );    }    return $form;  }}/** * Implementation of hook_block(). * * Generate a block with a promotional link to Drupal.org. */function system_block($op = 'list', $delta = 0, $edit = NULL) {  switch ($op) {    case 'list':      $blocks[0] = array(        'info' => t('Powered by Drupal'),        'weight' => '10',         // Not worth caching.        'cache' => BLOCK_NO_CACHE,      );      return $blocks;    case 'configure':      // Compile a list of fields to show      $form['wrapper']['color'] = array(        '#type' => 'select',        '#title' => t('Badge color'),        '#default_value' => variable_get('drupal_badge_color', 'powered-blue'),        '#options' => array('powered-black' => t('Black'), 'powered-blue' => t('Blue'), 'powered-gray' => t('Gray')),      );      $form['wrapper']['size'] = array(        '#type' => 'select',        '#title' => t('Badge size'),        '#default_value' => variable_get('drupal_badge_size', '80x15'),        '#options' => array('80x15' => t('Small'), '88x31' => t('Medium'), '135x42' => t('Large')),      );      return $form;    case 'save':      variable_set('drupal_badge_color', $edit['color']);      variable_set('drupal_badge_size', $edit['size']);      break;    case 'view':      $image_path = 'misc/'. variable_get('drupal_badge_color', 'powered-blue') .'-'. variable_get('drupal_badge_size', '80x15') .'.png';      $block['subject'] = NULL; // Don't display a title      $block['content'] = theme('system_powered_by', $image_path);      return $block;  }}/** * Provide a single block on the administration overview page. * * @param $item *   The menu item to be displayed. */function system_admin_menu_block($item) {  $content = array();  if (!isset($item['mlid'])) {    $item += db_fetch_array(db_query("SELECT mlid, menu_name FROM {menu_links} ml WHERE ml.router_path = '%s' AND module = 'system'", $item['path']));  }  $result = db_query("    SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*    FROM {menu_links} ml    LEFT JOIN {menu_router} m ON ml.router_path = m.path    WHERE ml.plid = %d AND ml.menu_name = '%s' AND hidden = 0", $item['mlid'], $item['menu_name']);  while ($item = db_fetch_array($result)) {    _menu_link_translate($item);    if (!$item['access']) {      continue;    }    // The link 'description' either derived from the hook_menu 'description' or    // entered by the user via menu module is saved as the title attribute.    if (!empty($item['localized_options']['attributes']['title'])) {      $item['description'] = $item['localized_options']['attributes']['title'];    }    // Prepare for sorting as in function _menu_tree_check_access().    // The weight is offset so it is always positive, with a uniform 5-digits.    $content[(50000 + $item['weight']) .' '. drupal_strtolower($item['title']) .' '. $item['mlid']] = $item;  }  ksort($content);  return $content;}/** * Process admin theme form submissions. */function system_admin_theme_submit($form, &$form_state) {  // If we're changing themes, make sure the theme has its blocks initialized.  if ($form_state['values']['admin_theme'] && $form_state['values']['admin_theme'] != variable_get('admin_theme', '0')) {    $result = db_result(db_query("SELECT COUNT(*) FROM {blocks} WHERE theme = '%s'", $form_state['values']['admin_theme']));    if (!$result) {      system_initialize_theme_blocks($form_state['values']['admin_theme']);    }  }}/** * Returns a fieldset containing the theme select form. * * @param $description *    description of the fieldset * @param $default_value *    default value of theme radios * @param $weight *    weight of the fieldset * @return *    a form array */function system_theme_select_form($description = '', $default_value = '', $weight = 0) {  if (user_access('select different theme')) {    $enabled = array();    $themes = list_themes();    foreach ($themes as $theme) {      if ($theme->status) {        $enabled[] = $theme;      }    }    if (count($enabled) > 1) {      ksort($enabled);      $form['themes'] = array(        '#type' => 'fieldset',        '#title' => t('Theme configuration'),        '#description' => $description,        '#collapsible' => TRUE,        '#theme' => 'system_theme_select_form'      );      foreach ($enabled as $info) {        // For the default theme, revert to an empty string so the user's theme updates when the site theme is changed.        $info->key = $info->name == variable_get('theme_default', 'garland') ? '' : $info->name;        $screenshot = NULL;        $theme_key = $info->name;        while ($theme_key) {          if (file_exists($themes[$theme_key]->info['screenshot'])) {            $screenshot = $themes[$theme_key]->info['screenshot'];            break;          }          $theme_key = isset($themes[$theme_key]->info['base theme']) ? $themes[$theme_key]->info['base theme'] : NULL;        }        $screenshot = $screenshot ? theme('image', $screenshot, t('Screenshot for %theme theme', array('%theme' => $info->name)), '', array('class' => 'screenshot'), FALSE) : t('no screenshot');        $form['themes'][$info->key]['screenshot'] = array('#value' => $screenshot);        $form['themes'][$info->key]['description'] = array('#type' => 'item', '#title' => $info->name, '#value' => dirname($info->filename) . ($info->name == variable_get('theme_default', 'garland') ? '<br /> <em>'. t('(site default theme)') .'</em>' : ''));        $options[$info->key] = '';      }      $form['themes']['theme'] = array('#type' => 'radios', '#options' => $options, '#default_value' => $default_value ? $default_value : '');      $form['#weight'] = $weight;      return $form;    }  }}/** * Checks the existence of the directory specified in $form_element. This * function is called from the system_settings form to check both the * file_directory_path and file_directory_temp directories. If validation * fails, the form element is flagged with an error from within the * file_check_directory function. * * @param $form_element *   The form element containing the name of the directory to check. */function system_check_directory($form_element) {  file_check_directory($form_element['#value'], FILE_CREATE_DIRECTORY, $form_element['#parents'][0]);  return $form_element;}/** * Retrieves the current status of an array of files in the system table. * * @param $files *   An array of files to check. * @param $type *   The type of the files. */function system_get_files_database(&$files, $type) {  // Extract current files from database.  $result = db_query("SELECT filename, name, type, status, throttle, schema_version FROM {system} WHERE type = '%s'", $type);  while ($file = db_fetch_object($result)) {    if (isset($files[$file->name]) && is_object($files[$file->name])) {      $file->old_filename = $file->filename;      foreach ($file as $key => $value) {        if (!isset($files[$file->name]) || !isset($files[$file->name]->$key)) {          $files[$file->name]->$key = $value;        }      }    }  }}/** * Prepare defaults for themes. * * @return *   An array of default themes settings. */function system_theme_default() {  return array(    'regions' => array(      'left' => 'Left sidebar',      'right' => 'Right sidebar',      'content' => 'Content',      'header' => 'Header',      'footer' => 'Footer',    ),    'description' => '',    'features' => array(      'comment_user_picture',      'favicon',      'mission',      'logo',      'name',      'node_user_picture',      'search',      'slogan',      'primary_links',      'secondary_links',    ),    'stylesheets' => array(      'all' => array('style.css')    ),    'scripts' => array('script.js'),    'screenshot' => 'screenshot.png',    'php' => DRUPAL_MINIMUM_PHP,  );}/** * Collect data about all currently available themes. * * @return *   Array of all available themes and their data. */function system_theme_data() {  // Scan the installation theme .info files and their engines.  $themes = _system_theme_data();  // Extract current files from database.  system_get_files_database($themes, 'theme');  db_query("DELETE FROM {system} WHERE type = 'theme'");  foreach ($themes as $theme) {    if (!isset($theme->owner)) {      $theme->owner = '';    }    db_query("INSERT INTO {system} (name, owner, info, type, filename, status, throttle, bootstrap) VALUES ('%s', '%s', '%s', '%s', '%s', %d, %d, %d)", $theme->name, $theme->owner, serialize($theme->info), 'theme', $theme->filename, isset($theme->status) ? $theme->status : 0, 0, 0);  }  return $themes;}/** * Helper function to scan and collect theme .info data and their engines. * * @return *   An associative array of themes information. */function _system_theme_data() {  static $themes_info = array();  if (empty($themes_info)) {    // Find themes    $themes = drupal_system_listing('\.info$', 'themes');    // Find theme engines    $engines = drupal_system_listing('\.engine$', 'themes/engines');    $defaults = system_theme_default();    $sub_themes = array();    // Read info files for each theme    foreach ($themes as $key => $theme) {      $themes[$key]->info = drupal_parse_info_file($theme->filename) + $defaults;      // Invoke hook_system_info_alter() to give installed modules a chance to      // modify the data in the .info files if necessary.      drupal_alter('system_info', $themes[$key]->info, $themes[$key]);      if (!empty($themes[$key]->info['base theme'])) {        $sub_themes[] = $key;      }      if (empty($themes[$key]->info['engine'])) {        $filename = dirname($themes[$key]->filename) .'/'. $themes[$key]->name .'.theme';        if (file_exists($filename)) {          $themes[$key]->owner = $filename;          $themes[$key]->prefix = $key;        }      }      else {        $engine = $themes[$key]->info['engine'];        if (isset($engines[$engine])) {          $themes[$key]->owner = $engines[$engine]->filename;          $themes[$key]->prefix = $engines[$engine]->name;          $themes[$key]->template = TRUE;        }      }      // Give the stylesheets proper path information.      $pathed_stylesheets = array();      foreach ($themes[$key]->info['stylesheets'] as $media => $stylesheets) {        foreach ($stylesheets as $stylesheet) {          $pathed_stylesheets[$media][$stylesheet] = dirname($themes[$key]->filename) .'/'. $stylesheet;        }      }      $themes[$key]->info['stylesheets'] = $pathed_stylesheets;      // Give the scripts proper path information.      $scripts = array();      foreach ($themes[$key]->info['scripts'] as $script) {        $scripts[$script] = dirname($themes[$key]->filename) .'/'. $script;      }      $themes[$key]->info['scripts'] = $scripts;      // Give the screenshot proper path information.      if (!empty($themes[$key]->info['screenshot'])) {        $themes[$key]->info['screenshot'] = dirname($themes[$key]->filename) .'/'. $themes[$key]->info['screenshot'];      }    }    // Now that we've established all our master themes, go back and fill in    // data for subthemes.    foreach ($sub_themes as $key) {      $themes[$key]->base_themes = system_find_base_themes($themes, $key);      // Don't proceed if there was a problem with the root base theme.      if (!current($themes[$key]->base_themes)) {        continue;      }      $base_key = key($themes[$key]->base_themes);      foreach (array_keys($themes[$key]->base_themes) as $base_theme) {        $themes[$base_theme]->sub_themes[$key] = $themes[$key]->info['name'];      }      // Copy the 'owner' and 'engine' over if the top level theme uses a      // theme engine.      if (isset($themes[$base_key]->owner)) {        if (isset($themes[$base_key]->info['engine'])) {          $themes[$key]->info['engine'] = $themes[$base_key]->info['engine'];          $themes[$key]->owner = $themes[$base_key]->owner;          $themes[$key]->prefix = $themes[$base_key]->prefix;        }        else {          $themes[$key]->prefix = $key;        }      }    }    $themes_info = $themes;  }  return $themes_info;}/** * Find all the base themes for the specified theme. * * Themes can inherit templates and function implementations from earlier themes. * * @param $themes *   An array of available themes. * @param $key *   The name of the theme whose base we are looking for. * @param $used_keys *   A recursion parameter preventing endless loops. * @return *   Returns an array of all of the theme's ancestors; the first element's value *   will be NULL if an error occurred. */function system_find_base_themes($themes, $key, $used_keys = array()) {  $base_key = $themes[$key]->info['base theme'];  // Does the base theme exist?  if (!isset($themes[$base_key])) {    return array($base_key => NULL);  }  $current_base_theme = array($base_key => $themes[$base_key]->info['name']);  // Is the base theme itself a child of another theme?  if (isset($themes[$base_key]->info['base theme'])) {    // Do we already know the base themes of this theme?    if (isset($themes[$base_key]->base_themes)) {      return $themes[$base_key]->base_themes + $current_base_theme;    }    // Prevent loops.    if (!empty($used_keys[$base_key])) {      return array($base_key => NULL);    }    $used_keys[$base_key] = TRUE;    return system_find_base_themes($themes, $base_key, $used_keys) + $current_base_theme;  }  // If we get here, then this is our parent theme.  return $current_base_theme;}/** * This function has been deprecated in favor of system_find_base_themes(). * * Recursive function to find the top level base theme. Themes can inherit * templates and function implementations from earlier themes. * * @param $themes *   An array of available themes. * @param $key *   The name of the theme whose base we are looking for. * @param $used_keys *   A recursion parameter preventing endless loops. * @return *   Returns the top level parent that has no ancestor or returns NULL if there isn't a valid parent. */function system_find_base_theme($themes, $key, $used_keys = array()) {  $base_key = $themes[$key]->info['base theme'];  // Does the base theme exist?  if (!isset($themes[$base_key])) {    return NULL;  }  // Is the base theme itself a child of another theme?  if (isset($themes[$base_key]->info['base theme'])) {    // Prevent loops.    if (!empty($used_keys[$base_key])) {      return NULL;    }    $used_keys[$base_key] = TRUE;    return system_find_base_theme($themes, $base_key, $used_keys);  }  // If we get here, then this is our parent theme.  return $base_key;}/** * Get a list of available regions from a specified theme. * * @param $theme_key *   The name of a theme. * @return *   An array of regions in the form $region['name'] = 'description'. */function system_region_list($theme_key) {  static $list = array();  if (!array_key_exists($theme_key, $list)) {    $info = unserialize(db_result(db_query("SELECT info FROM {system} WHERE type = 'theme' AND name = '%s'", $theme_key)));    $list[$theme_key] = array_map('t', $info['regions']);  }  return $list[$theme_key];}/** * Get the name of the default region for a given theme. * * @param $theme *   The name of a theme. * @return *   A string that is the region name. */function system_default_region($theme) {  $regions = array_keys(system_region_list($theme));  return isset($regions[0]) ? $regions[0] : '';}/** * Assign an initial, default set of blocks for a theme. * * This function is called the first time a new theme is enabled. The new theme * gets a copy of the default theme's blocks, with the difference that if a * particular region isn't available in the new theme, the block is assigned * to the new theme's default region. * * @param $theme *   The name of a theme. */function system_initialize_theme_blocks($theme) {  // Initialize theme's blocks if none already registered.  if (!(db_result(db_query("SELECT COUNT(*) FROM {blocks} WHERE theme = '%s'", $theme)))) {    $default_theme = variable_get('theme_default', 'garland');    $regions = system_region_list($theme);    $result = db_query("SELECT * FROM {blocks} WHERE theme = '%s'", $default_theme);    while ($block = db_fetch_array($result)) {      // If the region isn't supported by the theme, assign the block to the theme's default region.      if (!array_key_exists($block['region'], $regions)) {        $block['region'] = system_default_region($theme);      }      db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, visibility, pages, custom, throttle, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', %d, '%s', %d, %d, %d)",          $block['module'], $block['delta'], $theme, $block['status'], $block['weight'], $block['region'], $block['visibility'], $block['pages'], $block['custom'], $block['throttle'], $block['cache']);    }  }}/** * Add default buttons to a form and set its prefix. * * @ingroup forms * @see system_settings_form_submit() * @param $form *   An associative array containing the structure of the form. * @return *   The form structure. */function system_settings_form($form) {  $form['buttons']['submit'] = array('#type' => 'submit', '#value' => t('Save configuration') );  $form['buttons']['reset'] = array('#type' => 'submit', '#value' => t('Reset to defaults') );  if (!empty($_POST) && form_get_errors()) {    drupal_set_message(t('The settings have not been saved because of the errors.'), 'error');  }  $form['#submit'][] = 'system_settings_form_submit';  $form['#theme'] = 'system_settings_form';  return $form;}/** * Execute the system_settings_form. * * If you want node type configure style handling of your checkboxes, * add an array_filter value to your form. */function system_settings_form_submit($form, &$form_state) {  $op = isset($form_state['values']['op']) ? $form_state['values']['op'] : '';  // Exclude unnecessary elements.  unset($form_state['values']['submit'], $form_state['values']['reset'], $form_state['values']['form_id'], $form_state['values']['op'], $form_state['values']['form_token'], $form_state['values']['form_build_id']);  foreach ($form_state['values'] as $key => $value) {    if ($op == t('Reset to defaults')) {      variable_del($key);    }    else {      if (is_array($value) && isset($form_state['values']['array_filter'])) {        $value = array_keys(array_filter($value));      }      variable_set($key, $value);    }  }  if ($op == t('Reset to defaults')) {    drupal_set_message(t('The configuration options have been reset to their default values.'));  }  else {    drupal_set_message(t('The configuration options have been saved.'));  }  cache_clear_all();  drupal_rebuild_theme_registry();}/** * Helper function to sort requirements. */function _system_sort_requirements($a, $b) {  if (!isset($a['weight'])) {    if (!isset($b['weight'])) {      return strcmp($a['title'], $b['title']);    }    return -$b['weight'];  }  return isset($b['weight']) ? $a['weight'] - $b['weight'] : $a['weight'];}/** * Implementation of hook_node_type(). * * Updates theme settings after a node type change. */function system_node_type($op, $info) {  if ($op == 'update' && !empty($info->old_type) && $info->type != $info->old_type) {    $old = 'toggle_node_info_'. $info->old_type;    $new = 'toggle_node_info_'. $info->type;    $theme_settings = variable_get('theme_settings', array());    if (isset($theme_settings[$old])) {      $theme_settings[$new] = $theme_settings[$old];      unset($theme_settings[$old]);      variable_set('theme_settings', $theme_settings);    }  }}/** * Output a confirmation form * * This function returns a complete form for confirming an action. A link is * offered to go back to the item that is being changed in case the user changes * his/her mind. * * If the submit handler for this form is invoked, the user successfully * confirmed the action. You should never directly inspect $_POST to see if an * action was confirmed. * * @ingroup forms * @param $form *   Additional elements to inject into the form, for example hidden elements. * @param $question *   The question to ask the user (e.g. "Are you sure you want to delete the *   block <em>foo</em>?"). * @param $path *   The page to go to if the user denies the action. *   Can be either a drupal path, or an array with the keys 'path', 'query', 'fragment'. * @param $description *   Additional text to display (defaults to "This action cannot be undone."). * @param $yes *   A caption for the button which confirms the action (e.g. "Delete", *   "Replace", ...). * @param $no *   A caption for the link which denies the action (e.g. "Cancel"). * @param $name *   The internal name used to refer to the confirmation item. * @return *   The form. */function confirm_form($form, $question, $path, $description = NULL, $yes = NULL, $no = NULL, $name = 'confirm') {  $description = isset($description) ? $description : t('This action cannot be undone.');  // Prepare cancel link  $query = $fragment = NULL;  if (is_array($path)) {    $query = isset($path['query']) ? $path['query'] : NULL;    $fragment = isset($path['fragment']) ? $path['fragment'] : NULL;    $path = isset($path['path']) ? $path['path'] : NULL;  }  $cancel = l($no ? $no : t('Cancel'), $path, array('query' => $query, 'fragment' => $fragment));  drupal_set_title($question);  // Confirm form fails duplication check, as the form values rarely change -- so skip it.  $form['#skip_duplicate_check'] = TRUE;  $form['#attributes'] = array('class' => 'confirmation');  $form['description'] = array('#value' => $description);  $form[$name] = array('#type' => 'hidden', '#value' => 1);  $form['actions'] = array('#prefix' => '<div class="container-inline">', '#suffix' => '</div>');  $form['actions']['submit'] = array('#type' => 'submit', '#value' => $yes ? $yes : t('Confirm'));  $form['actions']['cancel'] = array('#value' => $cancel);  $form['#theme'] = 'confirm_form';  return $form;}/** * Determine if a user is in compact mode. */function system_admin_compact_mode() {  global $user;  return (isset($user->admin_compact_mode)) ? $user->admin_compact_mode : variable_get('admin_compact_mode', FALSE);}/** * Generate a list of tasks offered by a specified module. * * @param $module *   Module name. * @return *   An array of task links. */function system_get_module_admin_tasks($module) {  static $items;  $admin_access = user_access('administer permissions');  $admin_tasks = array();  if (!isset($items)) {    $result = db_query("       SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, ml.*       FROM {menu_links} ml INNER JOIN {menu_router} m ON ml.router_path = m.path WHERE ml.link_path LIKE 'admin/%' AND hidden >= 0 AND module = 'system' AND m.number_parts > 2");    $items = array();    while ($item = db_fetch_array($result)) {      _menu_link_translate($item);      if ($item['access']) {        $items[$item['router_path']] = $item;      }    }  }  $admin_tasks = array();  $admin_task_count = 0;  // Check for permissions.  if (module_hook($module, 'perm') && $admin_access) {    $admin_tasks[-1] = l(t('Configure permissions'), 'admin/user/permissions', array('fragment' => 'module-'. $module));  }  // Check for menu items that are admin links.  if ($menu = module_invoke($module, 'menu')) {    foreach (array_keys($menu) as $path) {      if (isset($items[$path])) {        $admin_tasks[$items[$path]['title'] . $admin_task_count ++] = l($items[$path]['title'], $path);      }    }  }  return $admin_tasks;}/** * Implementation of hook_cron(). * * Remove older rows from flood and batch table. Remove old temporary files. */function system_cron() {  // Cleanup the flood.  db_query('DELETE FROM {flood} WHERE timestamp < %d', time() - 3600);  // Cleanup the batch table.  db_query('DELETE FROM {batch} WHERE timestamp < %d', time() - 864000);  // Remove temporary files that are older than DRUPAL_MAXIMUM_TEMP_FILE_AGE.  $result = db_query('SELECT * FROM {files} WHERE status = %d and timestamp < %d', FILE_STATUS_TEMPORARY, time() - DRUPAL_MAXIMUM_TEMP_FILE_AGE);  while ($file = db_fetch_object($result)) {    if (file_exists($file->filepath)) {      // If files that exist cannot be deleted, continue so the database remains      // consistent.      if (!file_delete($file->filepath)) {        watchdog('file system', 'Could not delete temporary file "%path" during garbage collection', array('%path' => $file->filepath), 'error');        continue;      }    }    db_query('DELETE FROM {files} WHERE fid = %d', $file->fid);  }  $core = array('cache', 'cache_block', 'cache_filter', 'cache_page', 'cache_form', 'cache_menu');  $cache_tables = array_merge(module_invoke_all('flush_caches'), $core);  foreach ($cache_tables as $table) {    cache_clear_all(NULL, $table);  }}/** * Implementation of hook_hook_info(). */function system_hook_info() {  return array(    'system' => array(      'cron' => array(        'run' => array(          'runs when' => t('When cron runs'),        ),      ),    ),  );}/** * Implementation of hook_action_info(). */function system_action_info() {  return array(    'system_message_action' => array(      'type' => 'system',      'description' => t('Display a message to the user'),      'configurable' => TRUE,      'hooks' => array(        'nodeapi' => array('view', 'insert', 'update', 'delete'),        'comment' => array('view', 'insert', 'update', 'delete'),        'user' => array('view', 'insert', 'update', 'delete', 'login'),        'taxonomy' => array('insert', 'update', 'delete'),      ),    ),    'system_send_email_action' => array(      'description' => t('Send e-mail'),      'type' => 'system',      'configurable' => TRUE,      'hooks' => array(        'nodeapi' => array('view', 'insert', 'update', 'delete'),        'comment' => array('view', 'insert', 'update', 'delete'),        'user' => array('view', 'insert', 'update', 'delete', 'login'),        'taxonomy' => array('insert', 'update', 'delete'),      )    ),    'system_goto_action' => array(      'description' => t('Redirect to URL'),      'type' => 'system',      'configurable' => TRUE,      'hooks' => array(        'nodeapi' => array('view', 'insert', 'update', 'delete'),        'comment' => array('view', 'insert', 'update', 'delete'),        'user' => array('view', 'insert', 'update', 'delete', 'login'),      )    )  );}/** * Menu callback. Display an overview of available and configured actions. */function system_actions_manage() {  $output = '';  $actions = actions_list();  actions_synchronize($actions);  $actions_map = actions_actions_map($actions);  $options = array(t('Choose an advanced action'));  $unconfigurable = array();  foreach ($actions_map as $key => $array) {    if ($array['configurable']) {      $options[$key] = $array['description'] .'...';    }    else {      $unconfigurable[] = $array;    }  }  $row = array();  $instances_present = db_fetch_object(db_query("SELECT aid FROM {actions} WHERE parameters <> ''"));  $header = array(    array('data' => t('Action type'), 'field' => 'type'),    array('data' => t('Description'), 'field' => 'description'),    array('data' => $instances_present ? t('Operations') : '', 'colspan' => '2')  );  $sql = 'SELECT * FROM {actions}';  $result = pager_query($sql . tablesort_sql($header), 50);  while ($action = db_fetch_object($result)) {    $row[] = array(      array('data' => $action->type),      array('data' => $action->description),      array('data' => $action->parameters ? l(t('configure'), "admin/settings/actions/configure/$action->aid") : ''),      array('data' => $action->parameters ? l(t('delete'), "admin/settings/actions/delete/$action->aid") : '')    );  }  if ($row) {    $pager = theme('pager', NULL, 50, 0);    if (!empty($pager)) {      $row[] = array(array('data' => $pager, 'colspan' => '3'));    }    $output .= '<h3>'. t('Actions available to Drupal:') .'</h3>';    $output .= theme('table', $header, $row);  }  if ($actions_map) {    $output .= drupal_get_form('system_actions_manage_form', $options);  }  return $output;}/** * Define the form for the actions overview page. * * @see system_actions_manage_form_submit() * @ingroup forms * @param $form_state *   An associative array containing the current state of the form; not used. * @param $options *   An array of configurable actions. * @return *   Form definition. */function system_actions_manage_form($form_state, $options = array()) {  $form['parent'] = array(    '#type' => 'fieldset',    '#title' => t('Make a new advanced action available'),    '#prefix' => '<div class="container-inline">',    '#suffix' => '</div>',  );  $form['parent']['action'] = array(    '#type' => 'select',    '#default_value' => '',    '#options' => $options,    '#description' => '',  );  $form['parent']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Create'),  );  return $form;}/** * Process system_actions_manage form submissions. */function system_actions_manage_form_submit($form, &$form_state) {  if ($form_state['values']['action']) {    $form_state['redirect'] = 'admin/settings/actions/configure/'. $form_state['values']['action'];  }}/** * Menu callback. Create the form for configuration of a single action. * * We provide the "Description" field. The rest of the form * is provided by the action. We then provide the Save button. * Because we are combining unknown form elements with the action * configuration form, we use actions_ prefix on our elements. * * @see system_actions_configure_validate() * @see system_actions_configure_submit() * @param $action *   md5 hash of action ID or an integer. If it's an md5 hash, we *   are creating a new instance. If it's an integer, we're editing *   an existing instance. * @return *   Form definition. */function system_actions_configure($form_state, $action = NULL) {  if ($action === NULL) {    drupal_goto('admin/settings/actions');  }  $actions_map = actions_actions_map(actions_list());  $edit = array();  // Numeric action denotes saved instance of a configurable action;  // else we are creating a new action instance.  if (is_numeric($action)) {    $aid = $action;    // Load stored parameter values from database.    $data = db_fetch_object(db_query("SELECT * FROM {actions} WHERE aid = '%s'", $aid));    $edit['actions_description'] = $data->description;    $edit['actions_type'] = $data->type;    $function = $data->callback;    $action = md5($data->callback);    $params = unserialize($data->parameters);    if ($params) {      foreach ($params as $name => $val) {        $edit[$name] = $val;      }    }  }  else {    $function = $actions_map[$action]['callback'];    $edit['actions_description'] = $actions_map[$action]['description'];    $edit['actions_type'] = $actions_map[$action]['type'];  }  $form['actions_description'] = array(    '#type' => 'textfield',    '#title' => t('Description'),    '#default_value' => $edit['actions_description'],    '#maxlength' => '255',    '#description' => t('A unique description for this advanced action. This description will be displayed in the interface of modules that integrate with actions, such as Trigger module.'),    '#weight' => -10  );  $action_form = $function .'_form';  $form = array_merge($form, $action_form($edit));  $form['actions_type'] = array(    '#type' => 'value',    '#value' => $edit['actions_type'],  );  $form['actions_action'] = array(    '#type' => 'hidden',    '#value' => $action,  );  // $aid is set when configuring an existing action instance.  if (isset($aid)) {    $form['actions_aid'] = array(      '#type' => 'hidden',      '#value' => $aid,    );  }  $form['actions_configured'] = array(    '#type' => 'hidden',    '#value' => '1',  );  $form['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Save'),    '#weight' => 13  );  return $form;}/** * Validate system_actions_configure form submissions. */function system_actions_configure_validate($form, $form_state) {  $function = actions_function_lookup($form_state['values']['actions_action']) .'_validate';  // Hand off validation to the action.  if (function_exists($function)) {    $function($form, $form_state);  }}/** * Process system_actions_configure form submissions. */function system_actions_configure_submit($form, &$form_state) {  $function = actions_function_lookup($form_state['values']['actions_action']);  $submit_function = $function .'_submit';  // Action will return keyed array of values to store.  $params = $submit_function($form, $form_state);  $aid = isset($form_state['values']['actions_aid']) ? $form_state['values']['actions_aid'] : NULL;  actions_save($function, $form_state['values']['actions_type'], $params, $form_state['values']['actions_description'], $aid);  drupal_set_message(t('The action has been successfully saved.'));  $form_state['redirect'] = 'admin/settings/actions/manage';}/** * Create the form for confirmation of deleting an action. * * @ingroup forms * @see system_actions_delete_form_submit() */function system_actions_delete_form($form_state, $action) {  $form['aid'] = array(    '#type' => 'hidden',    '#value' => $action->aid,  );  return confirm_form($form,    t('Are you sure you want to delete the action %action?', array('%action' => $action->description)),    'admin/settings/actions/manage',    t('This cannot be undone.'),    t('Delete'), t('Cancel')  );}/** * Process system_actions_delete form submissions. * * Post-deletion operations for action deletion. */function system_actions_delete_form_submit($form, &$form_state) {  $aid = $form_state['values']['aid'];  $action = actions_load($aid);  actions_delete($aid);  $description = check_plain($action->description);  watchdog('user', 'Deleted action %aid (%action)', array('%aid' => $aid, '%action' => $description));  drupal_set_message(t('Action %action was deleted', array('%action' => $description)));  $form_state['redirect'] = 'admin/settings/actions/manage';}/** * Post-deletion operations for deleting action orphans. * * @param $orphaned *   An array of orphaned actions. */function system_action_delete_orphans_post($orphaned) {  foreach ($orphaned as $callback) {    drupal_set_message(t("Deleted orphaned action (%action).", array('%action' => $callback)));  }}/** * Remove actions that are in the database but not supported by any enabled module. */function system_actions_remove_orphans() {  actions_synchronize(actions_list(), TRUE);  drupal_goto('admin/settings/actions/manage');}/** * Return a form definition so the Send email action can be configured. * * @see system_send_email_action_validate() * @see system_send_email_action_submit() * @param $context *   Default values (if we are editing an existing action instance). * @return *   Form definition. */function system_send_email_action_form($context) {  // Set default values for form.  if (!isset($context['recipient'])) {    $context['recipient'] = '';  }  if (!isset($context['subject'])) {    $context['subject'] = '';  }  if (!isset($context['message'])) {    $context['message'] = '';  }  $form['recipient'] = array(    '#type' => 'textfield',    '#title' => t('Recipient'),    '#default_value' => $context['recipient'],    '#maxlength' => '254',    '#description' => t('The email address to which the message should be sent OR enter %author if you would like to send an e-mail to the author of the original post.', array('%author' => '%author')),  );  $form['subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => $context['subject'],    '#maxlength' => '254',    '#description' => t('The subject of the message.'),  );  $form['message'] = array(    '#type' => 'textarea',    '#title' => t('Message'),    '#default_value' => $context['message'],    '#cols' => '80',    '#rows' => '20',    '#description' => t('The message that should be sent. You may include the following variables: %site_name, %username, %node_url, %node_type, %title, %teaser, %body. Not all variables will be available in all contexts.'),  );  return $form;}/** * Validate system_send_email_action form submissions. */function system_send_email_action_validate($form, $form_state) {  $form_values = $form_state['values'];  // Validate the configuration form.  if (!valid_email_address($form_values['recipient']) && $form_values['recipient'] != '%author') {    // We want the literal %author placeholder to be emphasized in the error message.    form_set_error('recipient', t('Please enter a valid email address or %author.', array('%author' => '%author')));  }}/** * Process system_send_email_action form submissions. */function system_send_email_action_submit($form, $form_state) {  $form_values = $form_state['values'];  // Process the HTML form to store configuration. The keyed array that  // we return will be serialized to the database.  $params = array(    'recipient' => $form_values['recipient'],    'subject'   => $form_values['subject'],    'message'   => $form_values['message'],  );  return $params;}/** * Implementation of a configurable Drupal action. Sends an email. */function system_send_email_action($object, $context) {  global $user;  switch ($context['hook']) {    case 'nodeapi':      // Because this is not an action of type 'node' the node      // will not be passed as $object, but it will still be available      // in $context.      $node = $context['node'];      break;    // The comment hook provides nid, in $context.    case 'comment':      $comment = $context['comment'];      $node = node_load($comment->nid);      break;    case 'user':      // Because this is not an action of type 'user' the user      // object is not passed as $object, but it will still be available      // in $context.      $account = $context['account'];      if (isset($context['node'])) {        $node = $context['node'];      }      elseif ($context['recipient'] == '%author') {        // If we don't have a node, we don't have a node author.        watchdog('error', 'Cannot use %author token in this context.');        return;      }      break;    default:      // We are being called directly.      $node = $object;  }  $recipient = $context['recipient'];  if (isset($node)) {    if (!isset($account)) {      $account = user_load(array('uid' => $node->uid));    }    if ($recipient == '%author') {      $recipient = $account->mail;    }  }  if (!isset($account)) {    $account = $user;  }  $language = user_preferred_language($account);  $params = array('account' => $account, 'object' => $object, 'context' => $context);  if (isset($node)) {    $params['node'] = $node;  }  if (drupal_mail('system', 'action_send_email', $recipient, $language, $params)) {    watchdog('action', 'Sent email to %recipient', array('%recipient' => $recipient));  }  else {    watchdog('error', 'Unable to send email to %recipient', array('%recipient' => $recipient));  }}/** * Implementation of hook_mail(). */function system_mail($key, &$message, $params) {  $account = $params['account'];  $context = $params['context'];  $variables = array(    '%site_name' => variable_get('site_name', 'Drupal'),    '%username' => $account->name,  );  if ($context['hook'] == 'taxonomy') {    $object = $params['object'];    $vocabulary = taxonomy_vocabulary_load($object->vid);    $variables += array(      '%term_name' => $object->name,      '%term_description' => $object->description,      '%term_id' => $object->tid,      '%vocabulary_name' => $vocabulary->name,      '%vocabulary_description' => $vocabulary->description,      '%vocabulary_id' => $vocabulary->vid,    );  }  // Node-based variable translation is only available if we have a node.  if (isset($params['node'])) {    $node = $params['node'];    $variables += array(      '%uid' => $node->uid,      '%node_url' => url('node/'. $node->nid, array('absolute' => TRUE)),      '%node_type' => node_get_types('name', $node),      '%title' => $node->title,      '%teaser' => $node->teaser,      '%body' => $node->body,    );  }  $subject = strtr($context['subject'], $variables);  $body = strtr($context['message'], $variables);  $message['subject'] .= str_replace(array("\r", "\n"), '', $subject);  $message['body'][] = drupal_html_to_text($body);}function system_message_action_form($context) {  $form['message'] = array(    '#type' => 'textarea',    '#title' => t('Message'),    '#default_value' => isset($context['message']) ? $context['message'] : '',    '#required' => TRUE,    '#rows' => '8',    '#description' => t('The message to be displayed to the current user. You may include the following variables: %site_name, %username, %node_url, %node_type, %title, %teaser, %body. Not all variables will be available in all contexts.'),  );  return $form;}function system_message_action_submit($form, $form_state) {  return array('message' => $form_state['values']['message']);}/** * A configurable Drupal action. Sends a message to the current user's screen. */function system_message_action(&$object, $context = array()) {  global $user;  $variables = array(    '%site_name' => variable_get('site_name', 'Drupal'),    '%username' => $user->name ? $user->name : variable_get('anonymous', t('Anonymous')),  );  // This action can be called in any context, but if placeholders  // are used a node object must be present to be the source  // of substituted text.  switch ($context['hook']) {    case 'nodeapi':      // Because this is not an action of type 'node' the node      // will not be passed as $object, but it will still be available      // in $context.      $node = $context['node'];      break;    // The comment hook also provides the node, in context.    case 'comment':      $comment = $context['comment'];      $node = node_load($comment->nid);      break;    case 'taxonomy':      $vocabulary = taxonomy_vocabulary_load($object->vid);      $variables = array_merge($variables, array(        '%term_name' => $object->name,        '%term_description' => $object->description,        '%term_id' => $object->tid,        '%vocabulary_name' => $vocabulary->name,        '%vocabulary_description' => $vocabulary->description,        '%vocabulary_id' => $vocabulary->vid,        )      );      break;    default:      // We are being called directly.      $node = $object;  }  if (isset($node) && is_object($node)) {    $variables = array_merge($variables, array(      '%uid' => $node->uid,      '%node_url' => url('node/'. $node->nid, array('absolute' => TRUE)),      '%node_type' => check_plain(node_get_types('name', $node)),      '%title' => filter_xss($node->title),      '%teaser' => filter_xss($node->teaser),      '%body' => filter_xss($node->body),      )    );  }  $context['message'] = strtr($context['message'], $variables);  drupal_set_message($context['message']);}/** * Implementation of a configurable Drupal action. Redirect user to a URL. */function system_goto_action_form($context) {  $form['url'] = array(    '#type' => 'textfield',    '#title' => t('URL'),    '#description' => t('The URL to which the user should be redirected. This can be an internal URL like node/1234 or an external URL like http://drupal.org.'),    '#default_value' => isset($context['url']) ? $context['url'] : '',    '#required' => TRUE,  );  return $form;}function system_goto_action_submit($form, $form_state) {  return array(    'url' => $form_state['values']['url']  );}function system_goto_action($object, $context) {  drupal_goto($context['url']);}/** * Generate an array of time zones and their local time&date. */function _system_zonelist() {  $timestamp = time();  $zonelist = array(-11, -10, -9.5, -9, -8, -7, -6, -5, -4.5, -4, -3.5, -3, -2.5, -2, -1, 0, 1, 2, 3, 3.5, 4, 5, 5.5, 5.75, 6, 6.5, 7, 8, 9, 9.5, 10, 10.5, 11, 11.5, 12, 12.75, 13, 14);  $zones = array();  foreach ($zonelist as $offset) {    $zone = $offset * 3600;    $zones[$zone] = format_date($timestamp, 'custom', variable_get('date_format_long', 'l, F j, Y - H:i') .' O', $zone);  }  return $zones;}/** * Checks whether the server is capable of issuing HTTP requests. * * The function sets the drupal_http_request_fail system variable to TRUE if * drupal_http_request() does not work and then the system status report page * will contain an error. * * @return *  TRUE if this installation can issue HTTP requests. */function system_check_http_request() {  // Try to get the content of the front page via drupal_http_request().  $result = drupal_http_request(url('', array('absolute' => TRUE)));  // We only care that we get a http response - this means that Drupal  // can make a http request.  $works = isset($result->code) && ($result->code >= 100) && ($result->code < 600);  variable_set('drupal_http_request_fails', !$works);  return $works;}/** * Format the Powered by Drupal text. * * @ingroup themeable */function theme_system_powered_by($image_path) {  $image = theme('image', $image_path, t('Powered by Drupal, an open source content management system'), t('Powered by Drupal, an open source content management system'));  return l($image, 'http://drupal.org', array('html' => TRUE, 'absolute' => TRUE, 'external' => TRUE));}
<?php// $Id$/** * @file * Admin page callbacks for the filter module. *//** * Menu callback; Displays a list of all input formats and which * one is the default. * * @ingroup forms * @see filter_admin_overview_submit() */function filter_admin_overview() {  // Overview of all formats.  $formats = filter_formats();  $error = FALSE;  foreach ($formats as $id => $format) {    $roles = array();    foreach (user_roles() as $rid => $name) {      // Prepare a roles array with roles that may access the filter.      if (strstr($format->roles, ",$rid,")) {        $roles[] = $name;      }    }    $default = ($id == variable_get('filter_default_format', 1));    $options[$id] = '';    $form[$format->name]['id'] = array('#value' => $id);    $form[$format->name]['roles'] = array('#value' => $default ? t('All roles may use default format') : ($roles ? implode(', ', $roles) : t('No roles may use this format')));    $form[$format->name]['configure'] = array('#value' => l(t('configure'), 'admin/settings/filters/'. $id));    $form[$format->name]['delete'] = array('#value' => $default ? '' : l(t('delete'), 'admin/settings/filters/delete/'. $id));  }  $form['default'] = array('#type' => 'radios', '#options' => $options, '#default_value' => variable_get('filter_default_format', 1));  $form['submit'] = array('#type' => 'submit', '#value' => t('Set default format'));  return $form;}function filter_admin_overview_submit($form, &$form_state) {  // Process form submission to set the default format.  if (is_numeric($form_state['values']['default'])) {    drupal_set_message(t('Default format updated.'));    variable_set('filter_default_format', $form_state['values']['default']);  }}/** * Theme the admin overview form. * * @ingroup themeable */function theme_filter_admin_overview($form) {  $rows = array();  foreach ($form as $name => $element) {    if (isset($element['roles']) && is_array($element['roles'])) {      $rows[] = array(        drupal_render($form['default'][$element['id']['#value']]),        check_plain($name),        drupal_render($element['roles']),        drupal_render($element['configure']),        drupal_render($element['delete'])      );      unset($form[$name]);    }  }  $header = array(t('Default'), t('Name'), t('Roles'), array('data' => t('Operations'), 'colspan' => 2));  $output = theme('table', $header, $rows);  $output .= drupal_render($form);  return $output;}/** * Menu callback; Display a filter format form. */function filter_admin_format_page($format = NULL) {  if (!isset($format->name)) {    drupal_set_title(t("Add input format"));    $format = (object)array('name' => '', 'roles' => '', 'format' => '');  }  return drupal_get_form('filter_admin_format_form', $format);}/** * Generate a filter format form. * * @ingroup forms * @see filter_admin_format_form_validate() * @see filter_admin_format_form_submit() */function filter_admin_format_form(&$form_state, $format) {  $default = ($format->format == variable_get('filter_default_format', 1));  if ($default) {    $help = t('All roles for the default format must be enabled and cannot be changed.');    $form['default_format'] = array('#type' => 'hidden', '#value' => 1);  }  $form['name'] = array('#type' => 'textfield',    '#title' => t('Name'),    '#default_value' => $format->name,    '#description' => t('Specify a unique name for this filter format.'),    '#required' => TRUE,  );  // Add a row of checkboxes for form group.  $form['roles'] = array('#type' => 'fieldset',    '#title' => t('Roles'),    '#description' => $default ? $help : t('Choose which roles may use this filter format. Note that roles with the "administer filters" permission can always use all the filter formats.'),    '#tree' => TRUE,  );  foreach (user_roles() as $rid => $name) {    $checked = strstr($format->roles, ",$rid,");    $form['roles'][$rid] = array('#type' => 'checkbox',      '#title' => $name,      '#default_value' => ($default || $checked),    );    if ($default) {      $form['roles'][$rid]['#disabled'] = TRUE;    }  }  // Table with filters  $all = filter_list_all();  $enabled = filter_list_format($format->format);  $form['filters'] = array('#type' => 'fieldset',    '#title' => t('Filters'),    '#description' => t('Choose the filters that will be used in this filter format.'),    '#tree' => TRUE,  );  foreach ($all as $id => $filter) {    $form['filters'][$id] = array('#type' => 'checkbox',      '#title' => $filter->name,      '#default_value' => isset($enabled[$id]),      '#description' => module_invoke($filter->module, 'filter', 'description', $filter->delta),    );  }  if (!empty($format->format)) {    $form['format'] = array('#type' => 'hidden', '#value' => $format->format);    // Composition tips (guidelines)    $tips = _filter_tips($format->format, FALSE);    $extra = '<p>'. l(t('More information about formatting options'), 'filter/tips') .'</p>';    $tiplist = theme('filter_tips', $tips, FALSE, $extra);    if (!$tiplist) {      $tiplist = '<p>'. t('No guidelines available.') .'</p>';    }    $group = '<p>'. t('These are the guidelines that users will see for posting in this input format. They are automatically generated from the filter settings.') .'</p>';    $group .= $tiplist;    $form['tips'] = array('#value' => '<h2>'. t('Formatting guidelines') .'</h2>'. $group);  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save configuration'));  return $form;}/** * Validate filter format form submissions. */function filter_admin_format_form_validate($form, &$form_state) {  if (!isset($form_state['values']['format'])) {    $name = trim($form_state['values']['name']);    $result = db_fetch_object(db_query("SELECT format FROM {filter_formats} WHERE name='%s'", $name));    if ($result) {      form_set_error('name', t('Filter format names need to be unique. A format named %name already exists.', array('%name' => $name)));    }  }}/** * Process filter format form submissions. */function filter_admin_format_form_submit($form, &$form_state) {  $format = isset($form_state['values']['format']) ? $form_state['values']['format'] : NULL;  $current = filter_list_format($format);  $name = trim($form_state['values']['name']);  $cache = TRUE;  // Add a new filter format.  if (!$format) {    $new = TRUE;    db_query("INSERT INTO {filter_formats} (name) VALUES ('%s')", $name);    $format = db_result(db_query("SELECT MAX(format) AS format FROM {filter_formats}"));    drupal_set_message(t('Added input format %format.', array('%format' => $name)));  }  else {    drupal_set_message(t('The input format settings have been updated.'));  }  db_query("DELETE FROM {filters} WHERE format = %d", $format);  foreach ($form_state['values']['filters'] as $id => $checked) {    if ($checked) {      list($module, $delta) = explode('/', $id);      // Add new filters to the bottom.      $weight = isset($current[$id]->weight) ? $current[$id]->weight : 10;      db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $format, $module, $delta, $weight);      // Check if there are any 'no cache' filters.      $cache &= !module_invoke($module, 'filter', 'no cache', $delta);    }  }  // We store the roles as a string for ease of use.  // We should always set all roles to TRUE when saving a default role.  // We use leading and trailing comma's to allow easy substring matching.  $roles = array();  if (isset($form_state['values']['roles'])) {    foreach ($form_state['values']['roles'] as $id => $checked) {      if ($checked) {        $roles[] = $id;      }    }  }  if (!empty($form_state['values']['default_format'])) {    $roles = ','. implode(',', array_keys(user_roles())) .',';  }  else {    $roles = ','. implode(',', $roles) .',';  }  db_query("UPDATE {filter_formats} SET cache = %d, name='%s', roles = '%s' WHERE format = %d", $cache, $name, $roles, $format);  cache_clear_all($format .':', 'cache_filter', TRUE);  // If a new filter was added, return to the main list of filters. Otherwise, stay on edit filter page to show new changes.  $return = 'admin/settings/filters';  if (!empty($new)) {    $return .= '/'. $format;  }  $form_state['redirect'] = $return;  return;}/** * Menu callback; confirm deletion of a format. * * @ingroup forms * @see filter_admin_delete_submit() */function filter_admin_delete() {  $format = arg(4);  $format = db_fetch_object(db_query('SELECT * FROM {filter_formats} WHERE format = %d', $format));  if ($format) {    if ($format->format != variable_get('filter_default_format', 1)) {      $form['format'] = array('#type' => 'hidden', '#value' => $format->format);      $form['name'] = array('#type' => 'hidden', '#value' => $format->name);      return confirm_form($form, t('Are you sure you want to delete the input format %format?', array('%format' => $format->name)), 'admin/settings/filters', t('If you have any content left in this input format, it will be switched to the default input format. This action cannot be undone.'), t('Delete'), t('Cancel'));    }    else {      drupal_set_message(t('The default format cannot be deleted.'));      drupal_goto('admin/settings/filters');    }  }  else {    drupal_not_found();  }}/** * Process filter delete form submission. */function filter_admin_delete_submit($form, &$form_state) {  db_query("DELETE FROM {filter_formats} WHERE format = %d", $form_state['values']['format']);  db_query("DELETE FROM {filters} WHERE format = %d", $form_state['values']['format']);  $default = variable_get('filter_default_format', 1);  // Replace existing instances of the deleted format with the default format.  db_query("UPDATE {node_revisions} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  db_query("UPDATE {comments} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  db_query("UPDATE {boxes} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);  drupal_set_message(t('Deleted input format %format.', array('%format' => $form_state['values']['name'])));  $form_state['redirect'] = 'admin/settings/filters';  return;}/** * Menu callback; display settings defined by a format's filters. */function filter_admin_configure_page($format) {  drupal_set_title(t("Configure %format", array('%format' => $format->name)));  return drupal_get_form('filter_admin_configure', $format);}/** * Build a form to change the settings for a format's filters. * * @ingroup forms */function filter_admin_configure(&$form_state, $format) {  $list = filter_list_format($format->format);  $form = array();  foreach ($list as $filter) {    $form_module = module_invoke($filter->module, 'filter', 'settings', $filter->delta, $format->format);    if (isset($form_module) && is_array($form_module)) {      $form = array_merge($form, $form_module);    }  }  if (!empty($form)) {    $form = system_settings_form($form);  }  else {    $form['error'] = array('#value' => t('No settings are available.'));  }  $form['format'] = array('#type' => 'hidden', '#value' => $format->format);  $form['#submit'][] = 'filter_admin_configure_submit';  return $form;}/** * Clear the filter's cache when configuration settings are saved. */function filter_admin_configure_submit($form, &$form_state) {  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);}/** * Menu callback; display form for ordering filters for a format. */function filter_admin_order_page($format) {  drupal_set_title(t("Rearrange %format", array('%format' => $format->name)));  return drupal_get_form('filter_admin_order', $format);}/** * Build the form for ordering filters for a format. * * @ingroup forms * @see theme_filter_admin_order() * @see filter_admin_order_submit() */function filter_admin_order(&$form_state, $format = NULL) {  // Get list (with forced refresh).  $filters = filter_list_format($format->format);  $form['weights'] = array('#tree' => TRUE);  foreach ($filters as $id => $filter) {    $form['names'][$id] = array('#value' => $filter->name);    $form['weights'][$id] = array('#type' => 'weight', '#default_value' => $filter->weight);  }  $form['format'] = array('#type' => 'hidden', '#value' => $format->format);  $form['submit'] = array('#type' => 'submit', '#value' => t('Save configuration'));  return $form;}/** * Theme filter order configuration form. * * @ingroup themeable */function theme_filter_admin_order($form) {  $header = array(t('Name'), t('Weight'));  $rows = array();  foreach (element_children($form['names']) as $id) {    // Don't take form control structures.    if (is_array($form['names'][$id])) {      $form['weights'][$id]['#attributes']['class'] = 'filter-order-weight';      $rows[] = array(        'data' => array(drupal_render($form['names'][$id]), drupal_render($form['weights'][$id])),        'class' => 'draggable',      );    }  }  $output = theme('table', $header, $rows, array('id' => 'filter-order'));  $output .= drupal_render($form);  drupal_add_tabledrag('filter-order', 'order', 'sibling', 'filter-order-weight', NULL, NULL, FALSE);  return $output;}/** * Process filter order configuration form submission. */function filter_admin_order_submit($form, &$form_state) {  foreach ($form_state['values']['weights'] as $id => $weight) {    list($module, $delta) = explode('/', $id);    db_query("UPDATE {filters} SET weight = %d WHERE format = %d AND module = '%s' AND delta = %d", $weight, $form_state['values']['format'], $module, $delta);  }  drupal_set_message(t('The filter ordering has been saved.'));  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);}
<?php// $Id$/** * @file * Manages displaying online help. *//** * Implementation of hook_menu(). */function help_menu() {  $items['admin/help'] = array(    'title' => 'Help',    'page callback' => 'help_main',    'access arguments' => array('access administration pages'),    'weight' => 9,    'file' => 'help.admin.inc',  );  foreach (module_implements('help', TRUE) as $module) {    $items['admin/help/'. $module] = array(      'title' => $module,      'page callback' => 'help_page',      'page arguments' => array(2),      'access arguments' => array('access administration pages'),      'type' => MENU_CALLBACK,      'file' => 'help.admin.inc',    );  }  return $items;}/** * Implementation of hook_help(). */function help_help($path, $arg) {  switch ($path) {    case 'admin/help':      $output = '<p>'. t('This guide provides context sensitive help on the use and configuration of <a href="@drupal">Drupal</a> and its modules, and is a supplement to the more extensive online <a href="@handbook">Drupal handbook</a>. The online handbook may contain more up-to-date information, is annotated with helpful user-contributed comments, and serves as the definitive reference point for all Drupal documentation.', array('@drupal' => 'http://drupal.org', '@handbook' => 'http://drupal.org/handbook')) .'</p>';      return $output;    case 'admin/help#help':      $output = '<p>'. t('The help module provides context sensitive help on the use and configuration of <a href="@drupal">Drupal</a> and its modules, and is a supplement to the more extensive online <a href="@handbook">Drupal handbook</a>. The online handbook may contain more up-to-date information, is annotated with helpful user-contributed comments, and serves as the definitive reference point for all Drupal documentation.', array('@drupal' => 'http://drupal.org', '@handbook' => 'http://drupal.org/handbook')) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@help">Help module</a>.', array('@help' => 'http://drupal.org/handbook/modules/help/')) .'</p>';      return $output;  }}
<?php// $Id$?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>">  <head>    <?php print $head ?>    <title><?php print $head_title ?></title>    <?php print $styles ?>    <?php print $scripts ?>    <!--[if lt IE 7]>      <?php print phptemplate_get_ie_styles(); ?>    <![endif]-->  </head>  <body<?php print phptemplate_body_class($left, $right); ?>><!-- Layout -->  <div id="header-region" class="clear-block"><?php print $header; ?></div>    <div id="wrapper">    <div id="container" class="clear-block">      <div id="header">        <div id="logo-floater">        <?php          // Prepare header          $site_fields = array();          if ($site_name) {            $site_fields[] = check_plain($site_name);          }          if ($site_slogan) {            $site_fields[] = check_plain($site_slogan);          }          $site_title = implode(' ', $site_fields);          if ($site_fields) {            $site_fields[0] = '<span>'. $site_fields[0] .'</span>';          }          $site_html = implode(' ', $site_fields);          if ($logo || $site_title) {            print '<h1><a href="'. check_url($front_page) .'" title="'. $site_title .'">';            if ($logo) {              print '<img src="'. check_url($logo) .'" alt="'. $site_title .'" id="logo" />';            }            print $site_html .'</a></h1>';          }        ?>        </div>        <?php if (isset($primary_links)) : ?>          <?php print theme('links', $primary_links, array('class' => 'links primary-links')) ?>        <?php endif; ?>        <?php if (isset($secondary_links)) : ?>          <?php print theme('links', $secondary_links, array('class' => 'links secondary-links')) ?>        <?php endif; ?>      </div> <!-- /header -->      <?php if ($left): ?>        <div id="sidebar-left" class="sidebar">          <?php if ($search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $left ?>        </div>      <?php endif; ?>      <div id="center"><div id="squeeze"><div class="right-corner"><div class="left-corner">          <?php print $breadcrumb; ?>          <?php if ($mission): print '<div id="mission">'. $mission .'</div>'; endif; ?>          <?php if ($tabs): print '<div id="tabs-wrapper" class="clear-block">'; endif; ?>          <?php if ($title): print '<h2'. ($tabs ? ' class="with-tabs"' : '') .'>'. $title .'</h2>'; endif; ?>          <?php if ($tabs): print '<ul class="tabs primary">'. $tabs .'</ul></div>'; endif; ?>          <?php if ($tabs2): print '<ul class="tabs secondary">'. $tabs2 .'</ul>'; endif; ?>          <?php if ($show_messages && $messages): print $messages; endif; ?>          <?php print $help; ?>          <div class="clear-block">            <?php print $content ?>          </div>          <?php print $feed_icons ?>          <div id="footer"><?php print $footer_message . $footer ?></div>      </div></div></div></div> <!-- /.left-corner, /.right-corner, /#squeeze, /#center -->      <?php if ($right): ?>        <div id="sidebar-right" class="sidebar">          <?php if (!$left && $search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $right ?>        </div>      <?php endif; ?>    </div> <!-- /container -->  </div><!-- /layout -->  <?php print $closure ?>  </body></html>
<?php// $Id$/** * Return data from the persistent cache. Data may be stored as either plain text or as serialized data. * cache_get will automatically return unserialized objects and arrays. * * @param $cid *   The cache ID of the data to retrieve. * @param $table *   The table $table to store the data in. Valid core values are 'cache_filter', *   'cache_menu', 'cache_page', or 'cache' for the default cache. */function cache_get($cid, $table = 'cache') {  global $user;  // Garbage collection necessary when enforcing a minimum cache lifetime  $cache_flush = variable_get('cache_flush_'. $table, 0);  if ($cache_flush && ($cache_flush + variable_get('cache_lifetime', 0) <= time())) {    // Reset the variable immediately to prevent a meltdown in heavy load situations.    variable_set('cache_flush_'. $table, 0);    // Time to flush old cache data    db_query("DELETE FROM {". $table ."} WHERE expire != %d AND expire <= %d", CACHE_PERMANENT, $cache_flush);  }  $cache = db_fetch_object(db_query("SELECT data, created, headers, expire, serialized FROM {". $table ."} WHERE cid = '%s'", $cid));  if (isset($cache->data)) {    // If the data is permanent or we're not enforcing a minimum cache lifetime    // always return the cached data.    if ($cache->expire == CACHE_PERMANENT || !variable_get('cache_lifetime', 0)) {      $cache->data = db_decode_blob($cache->data);      if ($cache->serialized) {        $cache->data = unserialize($cache->data);      }    }    // If enforcing a minimum cache lifetime, validate that the data is    // currently valid for this user before we return it by making sure the    // cache entry was created before the timestamp in the current session's    // cache timer. The cache variable is loaded into the $user object by    // sess_read() in session.inc.    else {      if ($user->cache > $cache->created) {        // This cache data is too old and thus not valid for us, ignore it.        return 0;      }      else {        $cache->data = db_decode_blob($cache->data);        if ($cache->serialized) {          $cache->data = unserialize($cache->data);        }      }    }    return $cache;  }  return 0;}/** * Store data in the persistent cache. * * The persistent cache is split up into four database * tables. Contributed modules can add additional tables. * * 'cache_page': This table stores generated pages for anonymous * users. This is the only table affected by the page cache setting on * the administrator panel. * * 'cache_menu': Stores the cachable part of the users' menus. * * 'cache_filter': Stores filtered pieces of content. This table is * periodically cleared of stale entries by cron. * * 'cache': Generic cache storage table. * * The reasons for having several tables are as follows: * * - smaller tables allow for faster selects and inserts * - we try to put fast changing cache items and rather static *   ones into different tables. The effect is that only the fast *   changing tables will need a lot of writes to disk. The more *   static tables will also be better cachable with MySQL's query cache * * @param $cid *   The cache ID of the data to store. * @param $data *   The data to store in the cache. Complex data types will be automatically serialized before insertion. *   Strings will be stored as plain text and not serialized. * @param $table *   The table $table to store the data in. Valid core values are 'cache_filter', *   'cache_menu', 'cache_page', or 'cache'. * @param $expire *   One of the following values: *   - CACHE_PERMANENT: Indicates that the item should never be removed unless *     explicitly told to using cache_clear_all() with a cache ID. *   - CACHE_TEMPORARY: Indicates that the item should be removed at the next *     general cache wipe. *   - A Unix timestamp: Indicates that the item should be kept at least until *     the given time, after which it behaves like CACHE_TEMPORARY. * @param $headers *   A string containing HTTP header information for cached pages. */function cache_set($cid, $data, $table = 'cache', $expire = CACHE_PERMANENT, $headers = NULL) {  $serialized = 0;  if (is_object($data) || is_array($data)) {    $data = serialize($data);    $serialized = 1;  }  $created = time();  db_query("UPDATE {". $table ."} SET data = %b, created = %d, expire = %d, headers = '%s', serialized = %d WHERE cid = '%s'", $data, $created, $expire, $headers, $serialized, $cid);  if (!db_affected_rows()) {    @db_query("INSERT INTO {". $table ."} (cid, data, created, expire, headers, serialized) VALUES ('%s', %b, %d, %d, '%s', %d)", $cid, $data, $created, $expire, $headers, $serialized);  }}/** * * Expire data from the cache. If called without arguments, expirable * entries will be cleared from the cache_page and cache_block tables. * * @param $cid *   If set, the cache ID to delete. Otherwise, all cache entries that can *   expire are deleted. * * @param $table *   If set, the table $table to delete from. Mandatory *   argument if $cid is set. * * @param $wildcard *   If $wildcard is TRUE, cache IDs starting with $cid are deleted in *   addition to the exact cache ID specified by $cid.  If $wildcard is *   TRUE and $cid is '*' then the entire table $table is emptied. */function cache_clear_all($cid = NULL, $table = NULL, $wildcard = FALSE) {  global $user;  if (!isset($cid) && !isset($table)) {    // Clear the block cache first, so stale data will    // not end up in the page cache.    cache_clear_all(NULL, 'cache_block');    cache_clear_all(NULL, 'cache_page');    return;  }  if (empty($cid)) {    if (variable_get('cache_lifetime', 0)) {      // We store the time in the current user's $user->cache variable which      // will be saved into the sessions table by sess_write(). We then      // simulate that the cache was flushed for this user by not returning      // cached data that was cached before the timestamp.      $user->cache = time();      $cache_flush = variable_get('cache_flush_'. $table, 0);      if ($cache_flush == 0) {        // This is the first request to clear the cache, start a timer.        variable_set('cache_flush_'. $table, time());      }      else if (time() > ($cache_flush + variable_get('cache_lifetime', 0))) {        // Clear the cache for everyone, cache_lifetime seconds have        // passed since the first request to clear the cache.        db_query("DELETE FROM {". $table ."} WHERE expire != %d AND expire < %d", CACHE_PERMANENT, time());        variable_set('cache_flush_'. $table, 0);      }    }    else {      // No minimum cache lifetime, flush all temporary cache entries now.      db_query("DELETE FROM {". $table ."} WHERE expire != %d AND expire < %d", CACHE_PERMANENT, time());    }  }  else {    if ($wildcard) {      if ($cid == '*') {        db_query("TRUNCATE TABLE {". $table ."}");      }      else {        db_query("DELETE FROM {". $table ."} WHERE cid LIKE '%s%%'", $cid);      }    }    else {      db_query("DELETE FROM {". $table ."} WHERE cid = '%s'", $cid);    }  }}
<?php// $Id$/** * @file * Admin page callbacks for the trigger module. *//** * Build the form that allows users to assign actions to hooks. * * @param $type *   Name of hook. * @return *   HTML form. */function trigger_assign($type = NULL) {  // If no type is specified we default to node actions, since they  // are the most common.  if (!isset($type)) {    drupal_goto('admin/build/trigger/node');  }  if ($type == 'node') {    $type = 'nodeapi';  }  $output = '';  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $hook) {    if (isset($hook[$type])) {      foreach ($hook[$type] as $op => $description) {        $form_id = 'trigger_'. $type .'_'. $op .'_assign_form';        $output .= drupal_get_form($form_id, $type, $op, $description['runs when']);      }    }  }  return $output;}/** * Confirm removal of an assigned action. * * @param $hook * @param $op * @param $aid *   The action ID. * @ingroup forms * @see trigger_unassign_submit() */function trigger_unassign($form_state, $hook = NULL, $op = NULL, $aid = NULL) {  if (!($hook && $op && $aid)) {    drupal_goto('admin/build/trigger/assign');  }  $form['hook'] = array(    '#type' => 'value',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'value',    '#value' => $op,  );  $form['aid'] = array(    '#type' => 'value',    '#value' => $aid,  );  $action = actions_function_lookup($aid);  $actions = actions_get_all_actions();  $destination = 'admin/build/trigger/'. ($hook == 'nodeapi' ? 'node' : $hook);  return confirm_form($form,    t('Are you sure you want to unassign the action %title?', array('%title' => $actions[$action]['description'])),    $destination,    t('You can assign it again later if you wish.'),    t('Unassign'), t('Cancel')  );}function trigger_unassign_submit($form, &$form_state) {  $form_values = $form_state['values'];  if ($form_values['confirm'] == 1) {    $aid = actions_function_lookup($form_values['aid']);    db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid);    $actions = actions_get_all_actions();    watchdog('actions', 'Action %action has been unassigned.',  array('%action' => check_plain($actions[$aid]['description'])));    drupal_set_message(t('Action %action has been unassigned.', array('%action' => $actions[$aid]['description'])));    $hook = $form_values['hook'] == 'nodeapi' ? 'node' : $form_values['hook'];    $form_state['redirect'] = 'admin/build/trigger/'. $hook;  }  else {    drupal_goto('admin/build/trigger');  }}/** * Create the form definition for assigning an action to a hook-op combination. * * @param $form_state *   Information about the current form. * @param $hook *   The name of the hook, e.g., 'nodeapi'. * @param $op *   The name of the hook operation, e.g., 'insert'. * @param $description *   A plain English description of what this hook operation does. * @return * * @ingoup forms * @see trigger_assign_form_validate() * @see trigger_assign_form_submit() */function trigger_assign_form($form_state, $hook, $op, $description) {  $form['hook'] = array(    '#type' => 'hidden',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'hidden',    '#value' => $op,  );  // All of these forms use the same validate and submit functions.  $form['#validate'][] = 'trigger_assign_form_validate';  $form['#submit'][] = 'trigger_assign_form_submit';  $options = array();  $functions = array();  // Restrict the options list to actions that declare support for this hook-op  // combination.  foreach (actions_list() as $func => $metadata) {    if (isset($metadata['hooks']['any']) || (isset($metadata['hooks'][$hook]) && is_array($metadata['hooks'][$hook]) && (in_array($op, $metadata['hooks'][$hook])))) {      $functions[] = $func;    }  }  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {    if (in_array($action['callback'], $functions)) {      $options[$action['type']][$aid] = $action['description'];    }  }  $form[$op] = array(    '#type' => 'fieldset',    '#title' => t('Trigger: ') . $description,    '#theme' => 'trigger_display'    );  // Retrieve actions that are already assigned to this hook-op combination.  $actions = _trigger_get_hook_actions($hook, $op);  $form[$op]['assigned']['#type'] = 'value';  $form[$op]['assigned']['#value'] = array();  foreach ($actions as $aid => $description) {    $form[$op]['assigned']['#value'][$aid] = array(      'description' => $description,      'link' => l(t('unassign'), "admin/build/trigger/unassign/$hook/$op/". md5($aid))    );  }  $form[$op]['parent'] = array(    '#prefix' => "<div class='container-inline'>",    '#suffix' => '</div>',  );  // List possible actions that may be assigned.  if (count($options) != 0) {    array_unshift($options, t('Choose an action'));    $form[$op]['parent']['aid'] = array(      '#type' => 'select',      '#options' => $options,    );    $form[$op]['parent']['submit'] = array(      '#type' => 'submit',      '#value' => t('Assign')    );  }  else {    $form[$op]['none'] = array(      '#value' => t('No available actions for this trigger.')    );  }  return $form;}/** * Validation function for trigger_assign_form(). * * Makes sure that the user is not re-assigning an action to an event. */function trigger_assign_form_validate($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    if (db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid))) {      form_set_error($form_values['operation'], t('The action you chose is already assigned to that trigger.'));    }  }}/** * Submit function for trigger_assign_form(). */function trigger_assign_form_submit($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    $weight = db_result(db_query("SELECT MAX(weight) FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s'", $form_values['hook'], $form_values['operation']));    db_query("INSERT INTO {trigger_assignments} values ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], $aid, $weight + 1);    // If this action changes a node property, we need to save the node    // so the change will persist.    $actions = actions_list();    if (isset($actions[$aid]['behavior']) && in_array('changes_node_property', $actions[$aid]['behavior']) && ($form_values['operation'] != 'presave')) {      // Delete previous node_save_action if it exists, and re-add a new one at a higher weight.      $save_post_action_assigned = db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']));      if ($save_post_action_assigned) {        db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']);      }      db_query("INSERT INTO {trigger_assignments} VALUES ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], 'node_save_action', $weight + 2);      if (!$save_post_action_assigned) {        drupal_set_message(t('You have added an action that changes a the property of a post. A Save post action has been added so that the property change will be saved.'));      }    }  }}/** * Display actions assigned to this hook-op combination in a table. * * @param array $element *   The fieldset including all assigned actions. * @return *   The rendered form with the table prepended. * * @ingroup themeable */function theme_trigger_display($element) {  $header = array();  $rows = array();  if (count($element['assigned']['#value'])) {    $header = array(array('data' => t('Name')), array('data' => t('Operation')));    $rows = array();    foreach ($element['assigned']['#value'] as $aid => $info) {      $rows[] = array(        $info['description'],        $info['link']      );    }  }  if (count($rows)) {    $output = theme('table', $header, $rows) . drupal_render($element);  }  else {    $output = drupal_render($element);  }  return $output;}/** * Get the actions that have already been defined for this * type-hook-op combination. * * @param $type *   One of 'node', 'user', 'comment'. * @param $hook *   The name of the hook for which actions have been assigned, *   e.g. 'nodeapi'. * @param $op *   The hook operation for which the actions have been assigned, *   e.g., 'view'. * @return *   An array of action descriptions keyed by action IDs. */function _trigger_get_hook_actions($hook, $op, $type = NULL) {  $actions = array();  if ($type) {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE a.type = '%s' AND h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $type, $hook, $op);  }  else {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $hook, $op);  }  while ($action = db_fetch_object($result)) {    $actions[$action->aid] = $action->description;  }  return $actions;}
<?php// $Id$/** * @file * Administrative page callbacks for the forum module. */function forum_form_main($type, $edit = array()) {  if ((isset($_POST['op']) && $_POST['op'] == t('Delete')) || !empty($_POST['confirm'])) {    return drupal_get_form('forum_confirm_delete', $edit['tid']);  }  switch ($type) {    case 'forum':      return drupal_get_form('forum_form_forum', $edit);      break;    case 'container':      return drupal_get_form('forum_form_container', $edit);      break;  }}/** * Returns a form for adding a forum to the forum vocabulary * * @param $edit Associative array containing a forum term to be added or edited. * @ingroup forms * @see forum_form_submit() */function forum_form_forum(&$form_state, $edit = array()) {  $edit += array(    'name' => '',    'description' => '',    'tid' => NULL,    'weight' => 0,  );  $form['name'] = array('#type' => 'textfield',    '#title' => t('Forum name'),    '#default_value' => $edit['name'],    '#maxlength' => 255,    '#description' => t('Short but meaningful name for this collection of threaded discussions.'),    '#required' => TRUE,  );  $form['description'] = array('#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],    '#description' => t('Description and guidelines for discussions within this forum.'),  );  $form['parent']['#tree'] = TRUE;  $form['parent'][0] = _forum_parent_select($edit['tid'], t('Parent'), 'forum');  $form['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('Forums are displayed in ascending order by weight (forums with equal weights are displayed alphabetically).'),  );  $form['vid'] = array('#type' => 'hidden', '#value' => variable_get('forum_nav_vocabulary', ''));  $form['submit' ] = array('#type' => 'submit', '#value' => t('Save'));  if ($edit['tid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['tid'] = array('#type' => 'hidden', '#value' => $edit['tid']);  }  $form['#submit'][] = 'forum_form_submit';  $form['#theme'] = 'forum_form';  return $form;}/** * Process forum form and container form submissions. */function forum_form_submit($form, &$form_state) {  if ($form['form_id']['#value'] == 'forum_form_container') {    $container = TRUE;    $type = t('forum container');  }  else {    $container = FALSE;    $type = t('forum');  }  $status = taxonomy_save_term($form_state['values']);  switch ($status) {    case SAVED_NEW:      if ($container) {        $containers = variable_get('forum_containers', array());        $containers[] = $form_state['values']['tid'];        variable_set('forum_containers', $containers);      }      drupal_set_message(t('Created new @type %term.', array('%term' => $form_state['values']['name'], '@type' => $type)));      break;    case SAVED_UPDATED:      drupal_set_message(t('The @type %term has been updated.', array('%term' => $form_state['values']['name'], '@type' => $type)));      break;  }  $form_state['redirect'] = 'admin/content/forum';  return;}/** * Returns a form for adding a container to the forum vocabulary * * @param $edit Associative array containing a container term to be added or edited. * @ingroup forms * @see forum_form_submit() */function forum_form_container(&$form_state, $edit = array()) {  $edit += array(    'name' => '',    'description' => '',    'tid' => NULL,    'weight' => 0,  );  // Handle a delete operation.  $form['name'] = array(    '#title' => t('Container name'),    '#type' => 'textfield',    '#default_value' => $edit['name'],    '#maxlength' => 255,    '#description' => t('Short but meaningful name for this collection of related forums.'),    '#required' => TRUE  );  $form['description'] = array(    '#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],    '#description' => t('Description and guidelines for forums within this container.')  );  $form['parent']['#tree'] = TRUE;  $form['parent'][0] = _forum_parent_select($edit['tid'], t('Parent'), 'container');  $form['weight'] = array(    '#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('Containers are displayed in ascending order by weight (containers with equal weights are displayed alphabetically).')  );  $form['vid'] = array(    '#type' => 'hidden',    '#value' => variable_get('forum_nav_vocabulary', ''),  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save')  );  if ($edit['tid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['tid'] = array('#type' => 'value', '#value' => $edit['tid']);  }  $form['#submit'][] = 'forum_form_submit';  $form['#theme'] = 'forum_form';  return $form;}/** * Returns a confirmation page for deleting a forum taxonomy term. * * @param $tid ID of the term to be deleted */function forum_confirm_delete(&$form_state, $tid) {  $term = taxonomy_get_term($tid);  $form['tid'] = array('#type' => 'value', '#value' => $tid);  $form['name'] = array('#type' => 'value', '#value' => $term->name);  return confirm_form($form, t('Are you sure you want to delete the forum %name?', array('%name' => $term->name)), 'admin/content/forum', t('Deleting a forum or container will also delete its sub-forums, if any. To delete posts in this forum, visit <a href="@content">content administration</a> first. This action cannot be undone.', array('@content' => url('admin/content/node'))), t('Delete'), t('Cancel'));}/** * Implementation of forms api _submit call. Deletes a forum after confirmation. */function forum_confirm_delete_submit($form, &$form_state) {  taxonomy_del_term($form_state['values']['tid']);  drupal_set_message(t('The forum %term and all sub-forums and associated posts have been deleted.', array('%term' => $form_state['values']['name'])));  watchdog('content', 'forum: deleted %term and all its sub-forums and associated posts.', array('%term' => $form_state['values']['name']));  $form_state['redirect'] = 'admin/content/forum';  return;}/** * Form builder for the forum settings page. * * @see system_settings_form() */function forum_admin_settings() {  $form = array();  $number = drupal_map_assoc(array(5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 80, 100, 150, 200, 250, 300, 350, 400, 500));  $form['forum_hot_topic'] = array('#type' => 'select',    '#title' => t('Hot topic threshold'),    '#default_value' => variable_get('forum_hot_topic', 15),    '#options' => $number,    '#description' => t('The number of posts a topic must have to be considered "hot".'),  );  $number = drupal_map_assoc(array(10, 25, 50, 75, 100));  $form['forum_per_page'] = array('#type' => 'select',    '#title' => t('Topics per page'),    '#default_value' => variable_get('forum_per_page', 25),    '#options' => $number,    '#description' => t('Default number of forum topics displayed per page.'),  );  $forder = array(1 => t('Date - newest first'), 2 => t('Date - oldest first'), 3 => t('Posts - most active first'), 4 => t('Posts - least active first'));  $form['forum_order'] = array('#type' => 'radios',    '#title' => t('Default order'),    '#default_value' => variable_get('forum_order', '1'),    '#options' => $forder,    '#description' => t('Default display order for topics.'),  );  return system_settings_form($form);}/** * Returns an overview list of existing forums and containers */function forum_overview(&$form_state) {  module_load_include('inc', 'taxonomy', 'taxonomy.admin');  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  $form = taxonomy_overview_terms($form_state, $vocabulary);  foreach (element_children($form) as $key) {    if (isset($form[$key]['#term'])) {      $term = $form[$key]['#term'];      $form[$key]['view']['#value'] = l($term['name'], 'forum/'. $term['tid']);      if (in_array($form[$key]['#term']['tid'], variable_get('forum_containers', array()))) {        $form[$key]['edit']['#value'] = l(t('edit container'), 'admin/content/forum/edit/container/'. $term['tid']);      }      else {        $form[$key]['edit']['#value'] = l(t('edit forum'), 'admin/content/forum/edit/forum/'. $term['tid']);      }    }  }  // Remove the alphabetical reset.  unset($form['reset_alphabetical']);  // The form needs to have submit and validate handlers set explicitly.  $form['#theme'] = 'taxonomy_overview_terms';  $form['#submit'] = array('taxonomy_overview_terms_submit'); // Use the existing taxonomy overview submit handler.  $form['#validate'] = array('taxonomy_overview_terms_validate');  $form['#empty_text'] = '<em>'. t('There are no existing containers or forums. Containers and forums may be added using the <a href="@container">add container</a> and <a href="@forum">add forum</a> pages.', array('@container' => url('admin/content/forum/add/container'), '@forum' => url('admin/content/forum/add/forum'))) .'</em>';  return $form;}/** * Returns a select box for available parent terms * * @param $tid ID of the term which is being added or edited * @param $title Title to display the select box with * @param $child_type Whether the child is forum or container */function _forum_parent_select($tid, $title, $child_type) {  $parents = taxonomy_get_parents($tid);  if ($parents) {    $parent = array_shift($parents);    $parent = $parent->tid;  }  else {    $parent = 0;  }  $vid = variable_get('forum_nav_vocabulary', '');  $children = taxonomy_get_tree($vid, $tid);  // A term can't be the child of itself, nor of its children.  foreach ($children as $child) {    $exclude[] = $child->tid;  }  $exclude[] = $tid;  $tree = taxonomy_get_tree($vid);  $options[0] = '<'. t('root') .'>';  if ($tree) {    foreach ($tree as $term) {      if (!in_array($term->tid, $exclude)) {        $options[$term->tid] = str_repeat(' -- ', $term->depth) . $term->name;      }    }  }  if ($child_type == 'container') {    $description = t('Containers are usually placed at the top (root) level, but may also be placed inside another container or forum.');  }  else if ($child_type == 'forum') {    $description = t('Forums may be placed at the top (root) level, or inside another container or forum.');  }  return array('#type' => 'select', '#title' => $title, '#default_value' => $parent, '#options' => $options, '#description' => $description, '#required' => TRUE);}
<?php// $Id$/** * The main entry point for XML-RPC requests. * * @param $callbacks *   Array of external XML-RPC method names with the callbacks they map to. */function xmlrpc_server($callbacks) {  $xmlrpc_server = new stdClass();  // Define built-in XML-RPC method names  $defaults = array(      'system.multicall' => 'xmlrpc_server_multicall',    array(      'system.methodSignature',      'xmlrpc_server_method_signature',      array('array', 'string'),      'Returns an array describing the return type and required parameters of a method.'    ),    array(      'system.getCapabilities',      'xmlrpc_server_get_capabilities',      array('struct'),      'Returns a struct describing the XML-RPC specifications supported by this server.'    ),    array(      'system.listMethods',      'xmlrpc_server_list_methods',      array('array'),      'Returns an array of available methods on this server.'),    array(      'system.methodHelp',      'xmlrpc_server_method_help',      array('string', 'string'),      'Returns a documentation string for the specified method.')  );  // We build an array of all method names by combining the built-ins  // with those defined by modules implementing the _xmlrpc hook.  // Built-in methods are overridable.  foreach (array_merge($defaults, (array)$callbacks) as $key => $callback) {    // we could check for is_array($callback)    if (is_int($key)) {      $method = $callback[0];      $xmlrpc_server->callbacks[$method] = $callback[1];      $xmlrpc_server->signatures[$method] = $callback[2];      $xmlrpc_server->help[$method] = $callback[3];    }    else {      $xmlrpc_server->callbacks[$key] = $callback;      $xmlrpc_server->signatures[$key] = '';      $xmlrpc_server->help[$key] = '';    }  }  $data = file_get_contents('php://input');  if (!$data) {    die('XML-RPC server accepts POST requests only.');  }  $xmlrpc_server->message = xmlrpc_message($data);  if (!xmlrpc_message_parse($xmlrpc_server->message)) {    xmlrpc_server_error(-32700, t('Parse error. Request not well formed.'));  }  if ($xmlrpc_server->message->messagetype != 'methodCall') {    xmlrpc_server_error(-32600, t('Server error. Invalid XML-RPC. Request must be a methodCall.'));  }  if (!isset($xmlrpc_server->message->params)) {    $xmlrpc_server->message->params = array();  }  xmlrpc_server_set($xmlrpc_server);  $result = xmlrpc_server_call($xmlrpc_server, $xmlrpc_server->message->methodname, $xmlrpc_server->message->params);  if (is_object($result) && !empty($result->is_error)) {    xmlrpc_server_error($result);  }  // Encode the result  $r = xmlrpc_value($result);  // Create the XML  $xml = '<methodResponse>  <params>  <param>    <value>'.    xmlrpc_value_get_xml($r)    .'</value>  </param>  </params></methodResponse>';  // Send it  xmlrpc_server_output($xml);}/** * Throw an XML-RPC error. * * @param $error *   an error object OR integer error code * @param $message *   description of error, used only if integer error code was passed */function xmlrpc_server_error($error, $message = FALSE) {  if ($message && !is_object($error)) {    $error = xmlrpc_error($error, $message);  }  xmlrpc_server_output(xmlrpc_error_get_xml($error));}function xmlrpc_server_output($xml) {  $xml = '<?xml version="1.0"?>'."\n". $xml;  header('Connection: close');  header('Content-Length: '. strlen($xml));  header('Content-Type: text/xml');  header('Date: '. date('r'));  echo $xml;  exit;}/** * Store a copy of the request temporarily. * * @param $xmlrpc_server *   Request object created by xmlrpc_server(). */function xmlrpc_server_set($xmlrpc_server = NULL) {  static $server;  if (!isset($server)) {    $server = $xmlrpc_server;  }  return $server;}// Retrieve the stored request.function xmlrpc_server_get() {  return xmlrpc_server_set();}/** * Dispatch the request and any parameters to the appropriate handler. * * @param $xmlrpc_server * @param $methodname *   The external XML-RPC method name, e.g. 'system.methodHelp' * @param $args *   Array containing any parameters that were sent along with the request. */function xmlrpc_server_call($xmlrpc_server, $methodname, $args) {  // Make sure parameters are in an array  if ($args && !is_array($args)) {    $args = array($args);  }  // Has this method been mapped to a Drupal function by us or by modules?  if (!isset($xmlrpc_server->callbacks[$methodname])) {    return xmlrpc_error(-32601, t('Server error. Requested method @methodname not specified.', array("@methodname" => $xmlrpc_server->message->methodname)));  }  $method = $xmlrpc_server->callbacks[$methodname];  $signature = $xmlrpc_server->signatures[$methodname];  // If the method has a signature, validate the request against the signature  if (is_array($signature)) {    $ok = TRUE;    $return_type = array_shift($signature);    // Check the number of arguments    if (count($args) != count($signature)) {      return xmlrpc_error(-32602, t('Server error. Wrong number of method parameters.'));    }    // Check the argument types    foreach ($signature as $key => $type) {      $arg = $args[$key];      switch ($type) {        case 'int':        case 'i4':          if (is_array($arg) || !is_int($arg)) {            $ok = FALSE;          }          break;        case 'base64':        case 'string':          if (!is_string($arg)) {            $ok = FALSE;          }          break;        case 'boolean':          if ($arg !== FALSE && $arg !== TRUE) {            $ok = FALSE;          }          break;        case 'float':        case 'double':          if (!is_float($arg)) {            $ok = FALSE;          }          break;        case 'date':        case 'dateTime.iso8601':          if (!$arg->is_date) {            $ok = FALSE;          }          break;      }      if (!$ok) {        return xmlrpc_error(-32602, t('Server error. Invalid method parameters.'));      }    }  }  if (!function_exists($method)) {    return xmlrpc_error(-32601, t('Server error. Requested function @method does not exist.', array("@method" => $method)));  }  // Call the mapped function  return call_user_func_array($method, $args);}function xmlrpc_server_multicall($methodcalls) {  // See http://www.xmlrpc.com/discuss/msgReader$1208  $return = array();  $xmlrpc_server = xmlrpc_server_get();  foreach ($methodcalls as $call) {    $ok = TRUE;    if (!isset($call['methodName']) || !isset($call['params'])) {      $result = xmlrpc_error(3, t('Invalid syntax for system.multicall.'));      $ok = FALSE;    }    $method = $call['methodName'];    $params = $call['params'];    if ($method == 'system.multicall') {      $result = xmlrpc_error(-32600, t('Recursive calls to system.multicall are forbidden.'));    }    elseif ($ok) {      $result = xmlrpc_server_call($xmlrpc_server, $method, $params);    }    if ($result->is_error) {      $return[] = array(        'faultCode' => $result->code,        'faultString' => $result->message      );    }    else {      $return[] = $result;    }  }  return $return;}/** * XML-RPC method system.listMethods maps to this function. */function xmlrpc_server_list_methods() {  $xmlrpc_server = xmlrpc_server_get();  return array_keys($xmlrpc_server->callbacks);}/** * XML-RPC method system.getCapabilities maps to this function. * See http://groups.yahoo.com/group/xml-rpc/message/2897 */function xmlrpc_server_get_capabilities() {  return array(    'xmlrpc' => array(      'specUrl' => 'http://www.xmlrpc.com/spec',      'specVersion' => 1    ),    'faults_interop' => array(      'specUrl' => 'http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php',      'specVersion' => 20010516    ),    'system.multicall' => array(      'specUrl' => 'http://www.xmlrpc.com/discuss/msgReader$1208',      'specVersion' => 1    ),    'introspection' => array(    'specUrl' => 'http://scripts.incutio.com/xmlrpc/introspection.html',    'specVersion' => 1    )  );}/** * XML-RPC method system.methodSignature maps to this function. * * @param $methodname *   Name of method for which we return a method signature. * @return array *   An array of types representing the method signature of the *   function that the methodname maps to. The methodSignature of *   this function is 'array', 'string' because it takes an array *   and returns a string. */function xmlrpc_server_method_signature($methodname) {  $xmlrpc_server = xmlrpc_server_get();  if (!isset($xmlrpc_server->callbacks[$methodname])) {    return xmlrpc_error(-32601, t('Server error. Requested method @methodname not specified.', array("@methodname" => $methodname)));  }  if (!is_array($xmlrpc_server->signatures[$methodname])) {    return xmlrpc_error(-32601, t('Server error. Requested method @methodname signature not specified.', array("@methodname" => $methodname)));  }  // We array of types  $return = array();  foreach ($xmlrpc_server->signatures[$methodname] as $type) {    $return[] = $type;  }  return $return;}/** * XML-RPC method system.methodHelp maps to this function. * * @param $method *   Name of method for which we return a help string. */function xmlrpc_server_method_help($method) {  $xmlrpc_server = xmlrpc_server_get();  return $xmlrpc_server->help[$method];}
<?php// $Id$/** * @file * Enables users to rename URLs. *//** * Implementation of hook_help(). */function path_help($path, $arg) {  switch ($path) {    case 'admin/help#path':      $output = '<p>'. t('The path module allows you to specify aliases for Drupal URLs. Such aliases improve readability of URLs for your users and may help internet search engines to index your content more effectively. More than one alias may be created for a given page.') .'</p>';      $output .= t('<p>Some examples of URL aliases are:</p><ul><li>user/login =&gt; login</li><li>image/tid/16 =&gt; store</li><li>taxonomy/term/7+19+20+21 =&gt; store/products/whirlygigs</li><li>node/3 =&gt; contact</li></ul>');      $output .= '<p>'. t('The path module enables appropriately permissioned users to specify an optional alias in all node input and editing forms, and provides an interface to view and edit all URL aliases. The two permissions related to URL aliasing are <em>administer url aliases</em> and <em>create url aliases</em>. ') .'</p>';      $output .= '<p>'. t('This module also provides user-defined mass URL aliasing capabilities, which is useful if you wish to uniformly use URLs different from the default. For example, you may want to have your URLs presented in a different language. Access to the Drupal source code on the web server is required to set up mass URL aliasing. ') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@path">Path module</a>.', array('@path' => 'http://drupal.org/handbook/modules/path/')) .'</p>';      return $output;    case 'admin/build/path':      return '<p>'. t("Drupal provides complete control over URLs through aliasing, which is often used to make URLs more readable or easy to remember. For example, the alias 'about' may be mapped onto the post at the system path 'node/1', creating a more meaningful URL. Each system path can have multiple aliases.") .'</p>';    case 'admin/build/path/add':      return '<p>'. t('Enter the path you wish to create the alias for, followed by the name of the new alias.') .'</p>';  }}/** * Implementation of hook_menu(). */function path_menu() {  $items['admin/build/path'] = array(    'title' => 'URL aliases',    'description' => "Change your site's URL paths by aliasing them.",    'page callback' => 'path_admin_overview',    'access arguments' => array('administer url aliases'),    'file' => 'path.admin.inc',  );  $items['admin/build/path/edit'] = array(    'title' => 'Edit alias',    'page callback' => 'path_admin_edit',    'access arguments' => array('administer url aliases'),    'type' => MENU_CALLBACK,    'file' => 'path.admin.inc',  );  $items['admin/build/path/delete'] = array(    'title' => 'Delete alias',    'page callback' => 'drupal_get_form',    'page arguments' => array('path_admin_delete_confirm'),    'access arguments' => array('administer url aliases'),    'type' => MENU_CALLBACK,    'file' => 'path.admin.inc',  );  $items['admin/build/path/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/build/path/add'] = array(    'title' => 'Add alias',    'page callback' => 'path_admin_edit',    'access arguments' => array('administer url aliases'),    'type' => MENU_LOCAL_TASK,    'file' => 'path.admin.inc',  );  return $items;}/** * Post-confirmation; delete an URL alias. */function path_admin_delete($pid = 0) {  db_query('DELETE FROM {url_alias} WHERE pid = %d', $pid);  drupal_set_message(t('The alias has been deleted.'));}/** * Set an aliased path for a given Drupal path, preventing duplicates. */function path_set_alias($path = NULL, $alias = NULL, $pid = NULL, $language = '') {  $path = urldecode($path);  $alias = urldecode($alias);  // First we check if we deal with an existing alias and delete or modify it based on pid.  if ($pid) {    // An existing alias.    if (!$path || !$alias) {      // Delete the alias based on pid.      db_query('DELETE FROM {url_alias} WHERE pid = %d', $pid);    }    else {      // Update the existing alias.      db_query("UPDATE {url_alias} SET src = '%s', dst = '%s', language = '%s' WHERE pid = %d", $path, $alias, $language, $pid);    }  }  else if ($path && $alias) {    // Check for existing aliases.    if ($alias == drupal_get_path_alias($path, $language)) {      // There is already such an alias, neutral or in this language.      // Update the alias based on alias; setting the language if not yet done.      db_query("UPDATE {url_alias} SET src = '%s', dst = '%s', language = '%s' WHERE dst = '%s'", $path, $alias, $language, $alias);    }    else {      // A new alias. Add it to the database.      db_query("INSERT INTO {url_alias} (src, dst, language) VALUES ('%s', '%s', '%s')", $path, $alias, $language);    }  }  else {    // Delete the alias.    if ($alias) {      db_query("DELETE FROM {url_alias} WHERE dst = '%s'", $alias);    }    else {      db_query("DELETE FROM {url_alias} WHERE src = '%s'", $path);    }  }  drupal_clear_path_cache();}/** * Implementation of hook_nodeapi(). * * Allows URL aliases for nodes to be specified at node edit time rather * than through the administrative interface. */function path_nodeapi(&$node, $op, $arg) {  // Permissions are required for everything except node loading.  if (user_access('create url aliases') || user_access('administer url aliases') || ($op == 'load')) {    $language = isset($node->language) ? $node->language : '';    switch ($op) {      case 'validate':        if (isset($node->path)) {          $node->path = trim($node->path);          if (db_result(db_query("SELECT COUNT(dst) FROM {url_alias} WHERE dst = '%s' AND src != '%s' AND language = '%s'", $node->path, "node/$node->nid", $language))) {            form_set_error('path', t('The path is already in use.'));          }        }        break;      case 'load':        $path = 'node/'. $node->nid;        $alias = drupal_get_path_alias($path, $language);        if ($path != $alias) {          $node->path = $alias;        }        break;      case 'insert':        // Don't try to insert if path is NULL. We may have already set        // the alias ahead of time.        if (isset($node->path)) {          path_set_alias('node/'. $node->nid, $node->path, NULL, $language);        }        break;      case 'update':        path_set_alias('node/'. $node->nid, isset($node->path) ? $node->path : NULL, isset($node->pid) ? $node->pid : NULL, $language);        break;      case 'delete':        $path = 'node/'. $node->nid;        if (drupal_get_path_alias($path) != $path) {          path_set_alias($path);        }        break;    }  }}/** * Implementation of hook_form_alter(). */function path_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {    $path = isset($form['#node']->path) ? $form['#node']->path : NULL;    $form['path'] = array(      '#type' => 'fieldset',      '#title' => t('URL path settings'),      '#collapsible' => TRUE,      '#collapsed' => empty($path),      '#access' => user_access('create url aliases'),      '#weight' => 30,    );    $form['path']['path'] = array(      '#type' => 'textfield',      '#default_value' => $path,      '#maxlength' => 128,      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#description' => t('Optionally specify an alternative URL by which this node can be accessed. For example, type "about" when writing an about page. Use a relative path and don\'t add a trailing slash or the URL alias won\'t work.'),    );    if ($path) {      $form['path']['pid'] = array(        '#type' => 'value',        '#value' => db_result(db_query("SELECT pid FROM {url_alias} WHERE dst = '%s' AND language = '%s'", $path, $form['#node']->language))      );    }  }}/** * Implementation of hook_perm(). */function path_perm() {  return array('create url aliases', 'administer url aliases');}/** * Fetch a specific URL alias from the database. */function path_load($pid) {  return db_fetch_array(db_query('SELECT * FROM {url_alias} WHERE pid = %d', $pid));}
<?php// $Id$/** * @file * Admin page callbacks for the contact module. *//** * Categories/list tab. */function contact_admin_categories() {  $result = db_query('SELECT cid, category, recipients, selected FROM {contact} ORDER BY weight, category');  $rows = array();  while ($category = db_fetch_object($result)) {    $rows[] = array(check_plain($category->category), check_plain($category->recipients), ($category->selected ? t('Yes') : t('No')), l(t('edit'), 'admin/build/contact/edit/'. $category->cid), l(t('delete'), 'admin/build/contact/delete/'. $category->cid));  }  $header = array(t('Category'), t('Recipients'), t('Selected'), array('data' => t('Operations'), 'colspan' => 2));  return theme('table', $header, $rows);}/** * Category edit page. */function contact_admin_edit($form_state = array(), $op, $contact = NULL) {  if (empty($contact) || $op == 'add') {    $contact = array(      'category' => '',      'recipients' => '',      'reply' => '',      'weight' => 0,      'selected' => 0,      'cid' => NULL,    );  }  $form['contact_op'] = array('#type' => 'value', '#value' => $op);  $form['category'] = array('#type' => 'textfield',    '#title' => t('Category'),    '#maxlength' => 255,    '#default_value' => $contact['category'],    '#description' => t("Example: 'website feedback' or 'product information'."),    '#required' => TRUE,  );  $form['recipients'] = array('#type' => 'textarea',    '#title' => t('Recipients'),    '#default_value' => $contact['recipients'],    '#description' => t("Example: 'webmaster@example.com' or 'sales@example.com,support@example.com'. To specify multiple recipients, separate each e-mail address with a comma."),    '#required' => TRUE,  );  $form['reply'] = array('#type' => 'textarea',    '#title' => t('Auto-reply'),    '#default_value' => $contact['reply'],    '#description' => t('Optional auto-reply. Leave empty if you do not want to send the user an auto-reply message.'),  );  $form['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $contact['weight'],    '#description' => t('When listing categories, those with lighter (smaller) weights get listed before categories with heavier (larger) weights. Categories with equal weights are sorted alphabetically.'),  );  $form['selected'] = array('#type' => 'select',    '#title' => t('Selected'),    '#options' => array('0' => t('No'), '1' => t('Yes')),    '#default_value' => $contact['selected'],    '#description' => t('Set this to <em>Yes</em> if you would like this category to be selected by default.'),  );  $form['cid'] = array('#type' => 'value',    '#value' => $contact['cid'],  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Save'),  );  return $form;}/** * Validate the contact category edit page form submission. */function contact_admin_edit_validate($form, &$form_state) {  if (empty($form_state['values']['category'])) {    form_set_error('category', t('You must enter a category.'));  }  if (empty($form_state['values']['recipients'])) {    form_set_error('recipients', t('You must enter one or more recipients.'));  }  else {    $recipients = explode(',', $form_state['values']['recipients']);    foreach ($recipients as $recipient) {      if (!valid_email_address(trim($recipient))) {        form_set_error('recipients', t('%recipient is an invalid e-mail address.', array('%recipient' => $recipient)));      }    }  }}/** * Process the contact category edit page form submission. */function contact_admin_edit_submit($form, &$form_state) {  if ($form_state['values']['selected']) {    // Unselect all other contact categories.    db_query('UPDATE {contact} SET selected = 0');  }  $recipients = explode(',', $form_state['values']['recipients']);  foreach ($recipients as $key => $recipient) {    // E-mail address validation has already been done in _validate.    $recipients[$key] = trim($recipient);  }  $form_state['values']['recipients'] = implode(',', $recipients);  if (empty($form_state['values']['cid']) || $form_state['values']['contact_op'] == 'add') {    drupal_write_record('contact', $form_state['values']);    drupal_set_message(t('Category %category has been added.', array('%category' => $form_state['values']['category'])));    watchdog('mail', 'Contact form: category %category added.', array('%category' => $form_state['values']['category']), WATCHDOG_NOTICE, l(t('view'), 'admin/build/contact'));  }  else {    drupal_write_record('contact', $form_state['values'], 'cid');    drupal_set_message(t('Category %category has been updated.', array('%category' => $form_state['values']['category'])));    watchdog('mail', 'Contact form: category %category updated.', array('%category' => $form_state['values']['category']), WATCHDOG_NOTICE, l(t('view'), 'admin/build/contact'));  }  $form_state['redirect'] = 'admin/build/contact';  return;}/** * Category delete page. */function contact_admin_delete(&$form_state, $contact) {  $form['contact'] = array(    '#type' => 'value',    '#value' => $contact,  );  return confirm_form($form, t('Are you sure you want to delete %category?', array('%category' => $contact['category'])), 'admin/build/contact', t('This action cannot be undone.'), t('Delete'), t('Cancel'));}/** * Process category delete form submission. */function contact_admin_delete_submit($form, &$form_state) {  $contact = $form_state['values']['contact'];  db_query("DELETE FROM {contact} WHERE cid = %d", $contact['cid']);  drupal_set_message(t('Category %category has been deleted.', array('%category' => $contact['category'])));  watchdog('mail', 'Contact form: category %category deleted.', array('%category' => $contact['category']), WATCHDOG_NOTICE);  $form_state['redirect'] = 'admin/build/contact';  return;}function contact_admin_settings() {  $form['contact_form_information'] = array('#type' => 'textarea',    '#title' => t('Additional information'),    '#default_value' => variable_get('contact_form_information', t('You can leave a message using the contact form below.')),    '#description' => t('Information to show on the <a href="@form">contact page</a>. Can be anything from submission guidelines to your postal address or telephone number.', array('@form' => url('contact'))),  );  $form['contact_hourly_threshold'] = array('#type' => 'select',    '#title' => t('Hourly threshold'),    '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50)),    '#default_value' => variable_get('contact_hourly_threshold', 3),    '#description' => t('The maximum number of contact form submissions a user can perform per hour.'),  );  $form['contact_default_status'] = array(    '#type' => 'checkbox',    '#title' => t('Enable personal contact form by default'),    '#default_value' => variable_get('contact_default_status', 1),    '#description' => t('Default status of the personal contact form for new users.'),  );  return system_settings_form($form);}
<?php// $Id$/** * @file * Implement OpenID Relying Party support for Drupal *//** * Implementation of hook_menu. */function openid_menu() {  $items['openid/authenticate'] = array(    'title' => 'OpenID Login',    'page callback' => 'openid_authentication_page',    'access callback' => 'user_is_anonymous',    'type' => MENU_CALLBACK,    'file' => 'openid.pages.inc',  );  $items['user/%user/openid'] = array(    'title' => 'OpenID identities',    'page callback' => 'openid_user_identities',    'page arguments' => array(1),    'access callback' => 'user_edit_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'file' => 'openid.pages.inc',  );  $items['user/%user/openid/delete'] = array(    'title' => 'Delete OpenID',    'page callback' => 'drupal_get_form',    'page arguments' => array('openid_user_delete_form', 1),    'access callback' => 'user_edit_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,    'file' => 'openid.pages.inc',  );  return $items;}/** * Implementation of hook_help(). */function openid_help($path, $arg) {  switch ($path) {    case 'user/%/openid':      $output = '<p>'. t('This site supports <a href="@openid-net">OpenID</a>, a secure way to log into many websites using a single username and password. OpenID can reduce the necessity of managing many usernames and passwords for many websites.', array('@openid-net' => 'http://openid.net')) .'</p>';      $output .= '<p>'. t('To use OpenID you must first establish an identity on a public or private OpenID server. If you do not have an OpenID and would like one, look into one of the <a href="@openid-providers">free public providers</a>. You can find out more about OpenID at <a href="@openid-net">this website</a>.', array('@openid-providers' => 'http://openid.net/get/', '@openid-net' => 'http://openid.net')) .'</p>';      $output .= '<p>'. t('If you already have an OpenID, enter the URL to your OpenID server below (e.g. myusername.openidprovider.com). Next time you login, you will be able to use this URL instead of a regular username and password. You can have multiple OpenID servers if you like; just keep adding them here.') .'</p>';      return $output;    case 'admin/help#openid':      $output = '<p>'. t('OpenID is a secure method for logging into many websites with a single username and password. It does not require special software, and it does not share passwords with any site to which it is associated; including your site.') .'</p>';      $output .= '<p>'. t('Users can create accounts using their OpenID, assign one or more OpenIDs to an existing account, and log in using an OpenID. This lowers the barrier to registration, which is good for the site, and offers convenience and security to the users. OpenID is not a trust system, so email verification is still necessary. The benefit stems from the fact that users can have a single password that they can use on many websites. This means they can easily update their single password from a centralized location, rather than having to change dozens of passwords individually.') .'</p>';      $output .= '<p>'. t('The basic concept is as follows: A user has an account on an OpenID server. This account provides them with a unique URL (such as myusername.openidprovider.com). When the user comes to your site, they are presented with the option of entering this URL. Your site then communicates with the OpenID server, asking it to verify the identity of the user. If the user is logged into their OpenID server, the server communicates back to your site, verifying the user. If they are not logged in, the OpenID server will ask the user for their password. At no point does your site record, or need to record the user\'s password.') .'</p>';      $output .= '<p>'. t('More information on OpenID is available at <a href="@openid-net">OpenID.net</a>.', array('@openid-net' => url('http://openid.net'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@handbook">OpenID module</a>.', array('@handbook' => 'http://drupal.org/handbook/modules/openid')) .'</p>';      return $output;  }}/** * Implementation of hook_user(). */function openid_user($op, &$edit, &$account, $category = NULL) {  if ($op == 'insert' && isset($_SESSION['openid']['values'])) {    // The user has registered after trying to login via OpenID.    if (variable_get('user_email_verification', TRUE)) {      drupal_set_message(t('Once you have verified your email address, you may log in via OpenID.'));    }    unset($_SESSION['openid']);  }}/** * Implementation of hook_form_alter : adds OpenID login to the login forms. */function openid_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'user_login_block' || $form_id == 'user_login') {    drupal_add_css(drupal_get_path('module', 'openid') .'/openid.css', 'module');    drupal_add_js(drupal_get_path('module', 'openid') .'/openid.js');    if (!empty($form_state['post']['openid_identifier'])) {      $form['name']['#required'] = FALSE;      $form['pass']['#required'] = FALSE;      unset($form['#submit']);      $form['#validate'] = array('openid_login_validate');    }    $items = array();    $items[] = array(      'data' => l(t('Log in using OpenID'), '#'),      'class' => 'openid-link',    );    $items[] = array(      'data' => l(t('Cancel OpenID login'), '#'),      'class' => 'user-link',    );        $form['openid_links'] = array(      '#value' => theme('item_list', $items),      '#weight' => 1,    );    $form['links']['#weight'] = 2;    $form['openid_identifier'] = array(      '#type' => 'textfield',      '#title' => t('Log in using OpenID'),      '#size' => ($form_id == 'user_login') ? 58 : 13,      '#maxlength' => 255,      '#weight' => -1,      '#description' => l(t('What is OpenID?'), 'http://openid.net/', array('external' => TRUE)),    );    $form['openid.return_to'] = array('#type' => 'hidden', '#value' => url('openid/authenticate', array('absolute' => TRUE, 'query' => drupal_get_destination())));  }  elseif ($form_id == 'user_register' && isset($_SESSION['openid']['values'])) {    // We were unable to auto-register a new user. Prefill the registration    // form with the values we have.    $form['name']['#default_value'] = $_SESSION['openid']['values']['name'];    $form['mail']['#default_value'] = $_SESSION['openid']['values']['mail'];    // If user_email_verification is off, hide the password field and just fill    // with random password to avoid confusion.    if (!variable_get('user_email_verification', TRUE)) {      $form['pass']['#type'] = 'hidden';      $form['pass']['#value'] = user_password();    }    $form['auth_openid'] = array('#type' => 'hidden', '#value' => $_SESSION['openid']['values']['auth_openid']);    $form['openid_display'] = array(      '#type' => 'item',      '#title' => t('Your OpenID'),      '#description' => t('This OpenID will be attached to your account after registration.'),      '#value' => check_plain($_SESSION['openid']['values']['auth_openid']),    );  }  return $form;}/** * Login form _validate hook */function openid_login_validate($form, &$form_state) {  $return_to = $form_state['values']['openid.return_to'];  if (empty($return_to)) {    $return_to = url('', array('absolute' => TRUE));  }  openid_begin($form_state['values']['openid_identifier'], $return_to, $form_state['values']);}/** * The initial step of OpenID authentication responsible for the following: *  - Perform discovery on the claimed OpenID. *  - If possible, create an association with the Provider's endpoint. *  - Create the authentication request. *  - Perform the appropriate redirect. * * @param $claimed_id The OpenID to authenticate * @param $return_to The endpoint to return to from the OpenID Provider */function openid_begin($claimed_id, $return_to = '', $form_values = array()) {  module_load_include('inc', 'openid');  $claimed_id = _openid_normalize($claimed_id);  $services = openid_discovery($claimed_id);  if (count($services) == 0) {    form_set_error('openid_identifier', t('Sorry, that is not a valid OpenID. Please ensure you have spelled your ID correctly.'));    return;  }  // Store discovered information in the users' session so we don't have to rediscover.  $_SESSION['openid']['service'] = $services[0];  // Store the claimed id  $_SESSION['openid']['claimed_id'] = $claimed_id;  // Store the login form values so we can pass them to  // user_exteral_login later.  $_SESSION['openid']['user_login_values'] = $form_values;  $op_endpoint = $services[0]['uri'];  // If bcmath is present, then create an association  $assoc_handle = '';  if (function_exists('bcadd')) {    $assoc_handle = openid_association($op_endpoint);  }  // Now that there is an association created, move on  // to request authentication from the IdP  // First check for LocalID. If not found, check for Delegate. Fall  // back to $claimed_id if neither is found.  if (!empty($services[0]['localid'])) {    $identity = $services[0]['localid'];  }  else if (!empty($services[0]['delegate'])) {    $identity = $services[0]['delegate'];  }  else {    $identity = $claimed_id;  }  if (isset($services[0]['types']) && is_array($services[0]['types']) && in_array(OPENID_NS_2_0 .'/server', $services[0]['types'])) {    $claimed_id = $identity = 'http://specs.openid.net/auth/2.0/identifier_select';  }  $authn_request = openid_authentication_request($claimed_id, $identity, $return_to, $assoc_handle, $services[0]['version']);  if ($services[0]['version'] == 2) {    openid_redirect($op_endpoint, $authn_request);  }  else {    openid_redirect_http($op_endpoint, $authn_request);  }}/** * Completes OpenID authentication by validating returned data from the OpenID * Provider. * * @param $response Array of returned values from the OpenID Provider. * * @return $response Response values for further processing with *   $response['status'] set to one of 'success', 'failed' or 'cancel'. */function openid_complete($response = array()) {  module_load_include('inc', 'openid');  if (count($response) == 0) {    $response = _openid_response();  }    // Default to failed response  $response['status'] = 'failed';  if (isset($_SESSION['openid']['service']['uri']) && isset($_SESSION['openid']['claimed_id'])) {    $service = $_SESSION['openid']['service'];    $claimed_id = $_SESSION['openid']['claimed_id'];    unset($_SESSION['openid']['service']);    unset($_SESSION['openid']['claimed_id']);    if (isset($response['openid.mode'])) {      if ($response['openid.mode'] == 'cancel') {        $response['status'] = 'cancel';      }      else {        if (openid_verify_assertion($service['uri'], $response)) {          // If the returned claimed_id is different from the session claimed_id,          // then we need to do discovery and make sure the op_endpoint matches.          if ($service['version'] == 2 && $response['openid.claimed_id'] != $claimed_id) {            $disco = openid_discovery($response['openid.claimed_id']);            if ($disco[0]['uri'] != $service['uri']) {              return $response;            }          }          else {            $response['openid.claimed_id'] = $claimed_id;          }          $response['status'] = 'success';        }      }    }  }  return $response;}/** * Perform discovery on a claimed ID to determine the OpenID provider endpoint. * * @param $claimed_id The OpenID URL to perform discovery on. * * @return Array of services discovered (including OpenID version, endpoint * URI, etc). */function openid_discovery($claimed_id) {  module_load_include('inc', 'openid');  module_load_include('inc', 'openid', 'xrds');  $services = array();  $xrds_url = $claimed_id;  if (_openid_is_xri($claimed_id)) {    $xrds_url = 'http://xri.net/'. $claimed_id;  }  $url = @parse_url($xrds_url);  if ($url['scheme'] == 'http' || $url['scheme'] == 'https') {    // For regular URLs, try Yadis resolution first, then HTML-based discovery    $headers = array('Accept' => 'application/xrds+xml');    $result = drupal_http_request($xrds_url, $headers);    if (!isset($result->error)) {      if (isset($result->headers['Content-Type']) && preg_match("/application\/xrds\+xml/", $result->headers['Content-Type'])) {        // Parse XML document to find URL        $services = xrds_parse($result->data);      }      else {        $xrds_url = NULL;        if (isset($result->headers['X-XRDS-Location'])) {          $xrds_url = $result->headers['X-XRDS-Location'];        }        else {          // Look for meta http-equiv link in HTML head          $xrds_url = _openid_meta_httpequiv('X-XRDS-Location', $result->data);        }        if (!empty($xrds_url)) {          $headers = array('Accept' => 'application/xrds+xml');          $xrds_result = drupal_http_request($xrds_url, $headers);          if (!isset($xrds_result->error)) {            $services = xrds_parse($xrds_result->data);          }        }      }      // Check for HTML delegation      if (count($services) == 0) {        // Look for 2.0 links        $uri = _openid_link_href('openid2.provider', $result->data);        $delegate = _openid_link_href('openid2.local_id', $result->data);        $version = 2;        // 1.0 links        if (empty($uri)) {          $uri = _openid_link_href('openid.server', $result->data);          $delegate = _openid_link_href('openid.delegate', $result->data);          $version = 1;        }        if (!empty($uri)) {          $services[] = array('uri' => $uri, 'delegate' => $delegate, 'version' => $version);        }      }    }  }  return $services;}/** * Attempt to create a shared secret with the OpenID Provider. * * @param $op_endpoint URL of the OpenID Provider endpoint. * * @return $assoc_handle The association handle. */function openid_association($op_endpoint) {  module_load_include('inc', 'openid');  // Remove Old Associations:  db_query("DELETE FROM {openid_association} WHERE created + expires_in < %d", time());  // Check to see if we have an association for this IdP already  $assoc_handle = db_result(db_query("SELECT assoc_handle FROM {openid_association} WHERE idp_endpoint_uri = '%s'", $op_endpoint));  if (empty($assoc_handle)) {    $mod = OPENID_DH_DEFAULT_MOD;    $gen = OPENID_DH_DEFAULT_GEN;    $r = _openid_dh_rand($mod);    $private = bcadd($r, 1);    $public = bcpowmod($gen, $private, $mod);    // If there is no existing association, then request one    $assoc_request = openid_association_request($public);    $assoc_message = _openid_encode_message(_openid_create_message($assoc_request));    $assoc_headers = array('Content-Type' => 'application/x-www-form-urlencoded; charset=utf-8');    $assoc_result = drupal_http_request($op_endpoint, $assoc_headers, 'POST', $assoc_message);    if (isset($assoc_result->error)) {      return FALSE;    }    $assoc_response = _openid_parse_message($assoc_result->data);    if (isset($assoc_response['mode']) && $assoc_response['mode'] == 'error') {      return FALSE;    }    if ($assoc_response['session_type'] == 'DH-SHA1') {      $spub = _openid_dh_base64_to_long($assoc_response['dh_server_public']);      $enc_mac_key = base64_decode($assoc_response['enc_mac_key']);      $shared = bcpowmod($spub, $private, $mod);      $assoc_response['mac_key'] = base64_encode(_openid_dh_xorsecret($shared, $enc_mac_key));    }    db_query("INSERT INTO {openid_association} (idp_endpoint_uri, session_type, assoc_handle, assoc_type, expires_in, mac_key, created) VALUES('%s', '%s', '%s', '%s', %d, '%s', %d)",             $op_endpoint, $assoc_response['session_type'], $assoc_response['assoc_handle'], $assoc_response['assoc_type'], $assoc_response['expires_in'], $assoc_response['mac_key'], time());    $assoc_handle = $assoc_response['assoc_handle'];  }  return $assoc_handle;}/** * Authenticate a user or attempt registration. * * @param $response Response values from the OpenID Provider. */function openid_authentication($response) {  module_load_include('inc', 'openid');  $identity = $response['openid.claimed_id'];  $account = user_external_load($identity);  if (isset($account->uid)) {    if (!variable_get('user_email_verification', TRUE) || $account->login) {      user_external_login($account, $_SESSION['openid']['user_login_values']);    }    else {      drupal_set_message(t('You must validate your email address for this account before logging in via OpenID'));    }  }  elseif (variable_get('user_register', 1)) {    // Register new user    $form_state['redirect'] = NULL;    $form_state['values']['name'] = (empty($response['openid.sreg.nickname'])) ? '' : $response['openid.sreg.nickname'];    $form_state['values']['mail'] = (empty($response['openid.sreg.email'])) ? '' : $response['openid.sreg.email'];    $form_state['values']['pass']  = user_password();    $form_state['values']['status'] = variable_get('user_register', 1) == 1;    $form_state['values']['response'] = $response;    $form_state['values']['auth_openid'] = $identity;    if (empty($response['openid.sreg.email']) && empty($response['openid.sreg.nickname'])) {      drupal_set_message(t('Please complete the registration by filling out the form below. If you already have an account, you can <a href="@login">log in</a> now and add your OpenID under "My account".', array('@login' => url('user/login'))), 'warning');      $success = FALSE;    }    else {      $form = drupal_retrieve_form('user_register', $form_state);      drupal_prepare_form('user_register', $form, $form_state);      drupal_validate_form('user_register', $form, $form_state);      $success = !form_get_errors();      if (!$success) {        drupal_set_message(t('Account registration using the information provided by your OpenID provider failed due to the reasons listed below. Please complete the registration by filling out the form below. If you already have an account, you can <a href="@login">log in</a> now and add your OpenID under "My account".', array('@login' => url('user/login'))), 'warning');        // Append form validation errors below the above warning.        $messages = drupal_get_messages('error');        foreach ($messages['error'] as $message) {          drupal_set_message( $message, 'error');        }      }    }    if (!$success) {      // We were unable to register a valid new user, redirect to standard      // user/register and prefill with the values we received.      $_SESSION['openid']['values'] = $form_state['values'];      // We'll want to redirect back to the same place.      $destination = drupal_get_destination();      unset($_REQUEST['destination']);      drupal_goto('user/register', $destination);    }    else {      unset($form_state['values']['response']);      $account = user_save('', $form_state['values']);      // Terminate if an error occured during user_save().      if (!$account) {        drupal_set_message(t("Error saving user account."), 'error');        drupal_goto();      }      user_external_login($account);    }    drupal_redirect_form($form, $form_state['redirect']);  }  else {    drupal_set_message(t('Only site administrators can create new user accounts.'), 'error');  }  drupal_goto();}function openid_association_request($public) {  module_load_include('inc', 'openid');  $request = array(    'openid.ns' => OPENID_NS_2_0,    'openid.mode' => 'associate',    'openid.session_type' => 'DH-SHA1',    'openid.assoc_type' => 'HMAC-SHA1'  );  if ($request['openid.session_type'] == 'DH-SHA1' || $request['openid.session_type'] == 'DH-SHA256') {    $cpub = _openid_dh_long_to_base64($public);    $request['openid.dh_consumer_public'] = $cpub;  }  return $request;}function openid_authentication_request($claimed_id, $identity, $return_to = '', $assoc_handle = '', $version = 2) {  module_load_include('inc', 'openid');  $ns = ($version == 2) ? OPENID_NS_2_0 : OPENID_NS_1_0;  $request =  array(    'openid.ns' => $ns,    'openid.mode' => 'checkid_setup',    'openid.identity' => $identity,    'openid.claimed_id' => $claimed_id,    'openid.assoc_handle' => $assoc_handle,    'openid.return_to' => $return_to,  );  if ($version == 2) {    $request['openid.realm'] = url('', array('absolute' => TRUE));  }  else {    $request['openid.trust_root'] = url('', array('absolute' => TRUE));  }  // Simple Registration  $request['openid.sreg.required'] = 'nickname,email';  $request['openid.ns.sreg'] = "http://openid.net/extensions/sreg/1.1";  $request = array_merge($request, module_invoke_all('openid', 'request', $request));  return $request;}/** * Attempt to verify the response received from the OpenID Provider. * * @param $op_endpoint The OpenID Provider URL. * @param $response Array of repsonse values from the provider. * * @return boolean */function openid_verify_assertion($op_endpoint, $response) {  module_load_include('inc', 'openid');  $valid = FALSE;  $association = db_fetch_object(db_query("SELECT * FROM {openid_association} WHERE assoc_handle = '%s'", $response['openid.assoc_handle']));  if ($association && isset($association->session_type)) {    $keys_to_sign = explode(',', $response['openid.signed']);    $self_sig = _openid_signature($association, $response, $keys_to_sign);    if ($self_sig == $response['openid.sig']) {      $valid = TRUE;    }    else {      $valid = FALSE;    }  }  else {    $request = $response;    $request['openid.mode'] = 'check_authentication';    $message = _openid_create_message($request);    $headers = array('Content-Type' => 'application/x-www-form-urlencoded; charset=utf-8');    $result = drupal_http_request($op_endpoint, $headers, 'POST', _openid_encode_message($message));    if (!isset($result->error)) {      $response = _openid_parse_message($result->data);      if (strtolower(trim($response['is_valid'])) == 'true') {        $valid = TRUE;      }      else {        $valid = FALSE;      }    }  }  return $valid;}
<?php// $Id$/** * @file * Admin page callbacks for the statistics module. *//** * Menu callback; presents the "recent hits" page. */function statistics_recent_hits() {  $header = array(    array('data' => t('Timestamp'), 'field' => 'a.timestamp', 'sort' => 'desc'),    array('data' => t('Page'), 'field' => 'a.path'),    array('data' => t('User'), 'field' => 'u.name'),    array('data' => t('Operations'))  );  $sql = 'SELECT a.aid, a.path, a.title, a.uid, u.name, a.timestamp FROM {accesslog} a LEFT JOIN {users} u ON u.uid = a.uid'. tablesort_sql($header);  $result = pager_query($sql, 30);  $rows = array();  while ($log = db_fetch_object($result)) {    $rows[] = array(      array('data' => format_date($log->timestamp, 'small'), 'class' => 'nowrap'),      _statistics_format_item($log->title, $log->path),      theme('username', $log),      l(t('details'), "admin/reports/access/$log->aid"));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "top pages" page. */function statistics_top_pages() {  // MAX(title) avoids having empty node titles which otherwise causes duplicates in the top pages list  $sql = "SELECT COUNT(path) AS hits, path, MAX(title) AS title, AVG(timer) AS average_time, SUM(timer) AS total_time FROM {accesslog} GROUP BY path";  $sql_cnt = "SELECT COUNT(DISTINCT(path)) FROM {accesslog}";  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Page'), 'field' => 'path'),    array('data' => t('Average page generation time'), 'field' => 'average_time'),    array('data' => t('Total page generation time'), 'field' => 'total_time')  );  $sql .= tablesort_sql($header);  $result = pager_query($sql, 30, 0, $sql_cnt);  $rows = array();  while ($page = db_fetch_object($result)) {    $rows[] = array($page->hits, _statistics_format_item($page->title, $page->path), t('%time ms', array('%time' => round($page->average_time))), format_interval(round($page->total_time / 1000)));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  drupal_set_title(t('Top pages in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "top visitors" page. */function statistics_top_visitors() {  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Visitor'), 'field' => 'u.name'),    array('data' => t('Total page generation time'), 'field' => 'total'),    array('data' => t('Operations'))  );  $sql = "SELECT COUNT(a.uid) AS hits, a.uid, u.name, a.hostname, SUM(a.timer) AS total, ac.aid FROM {accesslog} a LEFT JOIN {access} ac ON ac.type = 'host' AND LOWER(a.hostname) LIKE (ac.mask) LEFT JOIN {users} u ON a.uid = u.uid GROUP BY a.hostname, a.uid, u.name, ac.aid". tablesort_sql($header);  $sql_cnt = "SELECT COUNT(DISTINCT(CONCAT(uid, hostname))) FROM {accesslog}";  $result = pager_query($sql, 30, 0, $sql_cnt);  $rows = array();  while ($account = db_fetch_object($result)) {    $qs = drupal_get_destination();    $ban_link = $account->aid ? l(t('unban'), "admin/user/rules/delete/$account->aid", array('query' => $qs)) : l(t('ban'), "admin/user/rules/add/$account->hostname/host", array('query' => $qs));    $rows[] = array($account->hits, ($account->uid ? theme('username', $account) : $account->hostname), format_interval(round($account->total / 1000)), $ban_link);  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  drupal_set_title(t('Top visitors in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "referrer" page. */function statistics_top_referrers() {  $query = "SELECT url, COUNT(url) AS hits, MAX(timestamp) AS last FROM {accesslog} WHERE url NOT LIKE '%%%s%%' AND url <> '' GROUP BY url";  $query_cnt = "SELECT COUNT(DISTINCT(url)) FROM {accesslog} WHERE url <> '' AND url NOT LIKE '%%%s%%'";  drupal_set_title(t('Top referrers in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Url'), 'field' => 'url'),    array('data' => t('Last visit'), 'field' => 'last'),  );  $query .= tablesort_sql($header);  $result = pager_query($query, 30, 0, $query_cnt, $_SERVER['HTTP_HOST']);  $rows = array();  while ($referrer = db_fetch_object($result)) {    $rows[] = array($referrer->hits, _statistics_link($referrer->url), t('@time ago', array('@time' => format_interval(time() - $referrer->last))));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 3));  }  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; Displays recent page accesses. */function statistics_access_log($aid) {  $result = db_query('SELECT a.*, u.name FROM {accesslog} a LEFT JOIN {users} u ON a.uid = u.uid WHERE aid = %d', $aid);  if ($access = db_fetch_object($result)) {    $rows[] = array(      array('data' => t('URL'), 'header' => TRUE),      l(url($access->path, array('absolute' => TRUE)), $access->path)    );    // It is safe to avoid filtering $access->title through check_plain because    // it comes from drupal_get_title().    $rows[] = array(      array('data' => t('Title'), 'header' => TRUE),      $access->title    );    $rows[] = array(      array('data' => t('Referrer'), 'header' => TRUE),      ($access->url ? l($access->url, $access->url) : '')    );    $rows[] = array(      array('data' => t('Date'), 'header' => TRUE),      format_date($access->timestamp, 'large')    );    $rows[] = array(      array('data' => t('User'), 'header' => TRUE),      theme('username', $access)    );    $rows[] = array(      array('data' => t('Hostname'), 'header' => TRUE),      check_plain($access->hostname)    );    return theme('table', array(), $rows);  }  else {    drupal_not_found();  }}/** * Form builder; Configure access logging. * * @ingroup forms * @see system_settings_form() */function statistics_access_logging_settings() {  // Access log settings:  $options = array('1' => t('Enabled'), '0' => t('Disabled'));  $form['access'] = array(    '#type' => 'fieldset',    '#title' => t('Access log settings'));  $form['access']['statistics_enable_access_log'] = array(    '#type' => 'radios',    '#title' => t('Enable access log'),    '#default_value' => variable_get('statistics_enable_access_log', 0),    '#options' => $options,    '#description' => t('Log each page access. Required for referrer statistics.'));  $period = drupal_map_assoc(array(3600, 10800, 21600, 32400, 43200, 86400, 172800, 259200, 604800, 1209600, 2419200, 4838400, 9676800), 'format_interval');  $form['access']['statistics_flush_accesslog_timer'] = array(    '#type' => 'select',    '#title' => t('Discard access logs older than'),    '#default_value'   => variable_get('statistics_flush_accesslog_timer', 259200),    '#options' => $period,    '#description' => t('Older access log entries (including referrer statistics) will be automatically discarded. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status'))));  // count content views settings  $form['content'] = array(    '#type' => 'fieldset',    '#title' => t('Content viewing counter settings'));  $form['content']['statistics_count_content_views'] = array(    '#type' => 'radios',    '#title' => t('Count content views'),    '#default_value' => variable_get('statistics_count_content_views', 0),    '#options' => $options,    '#description' => t('Increment a counter each time content is viewed.'));  return system_settings_form($form);}
<?php// $Id$/** * @file * Admin page callbacks for the help module. *//** * Menu callback; prints a page listing a glossary of Drupal terminology. */function help_main() {  // Add CSS  drupal_add_css(drupal_get_path('module', 'help') .'/help.css', 'module', 'all', FALSE);  $output = '<h2>'. t('Help topics') .'</h2><p>'. t('Help is available on the following items:') .'</p>'. help_links_as_list();  return $output;}/** * Menu callback; prints a page listing general help for a module. */function help_page($name) {  $output = '';  if (module_hook($name, 'help')) {    $module = drupal_parse_info_file(drupal_get_path('module', $name) .'/'. $name .'.info');    drupal_set_title($module['name']);    $temp = module_invoke($name, 'help', "admin/help#$name", drupal_help_arg());    if (empty($temp)) {      $output .= t("No help is available for module %module.", array('%module' => $module['name']));    }    else {      $output .= $temp;    }    // Only print list of administration pages if the module in question has    // any such pages associated to it.    $admin_tasks = system_get_module_admin_tasks($name);    if (!empty($admin_tasks)) {      ksort($admin_tasks);      $output .= theme('item_list', $admin_tasks, t('@module administration pages', array('@module' => $module['name'])));    }  }  return $output;}function help_links_as_list() {  $empty_arg = drupal_help_arg();  $module_info = module_rebuild_cache();  $modules = array();  foreach (module_implements('help', TRUE) as $module) {    if (module_invoke($module, 'help', "admin/help#$module", $empty_arg)) {      $modules[$module] = $module_info[$module]->info['name'];    }  }  asort($modules);  // Output pretty four-column list  $count = count($modules);  $break = ceil($count / 4);  $output = '<div class="clear-block"><div class="help-items"><ul>';  $i = 0;  foreach ($modules as $module => $name) {    $output .= '<li>'. l($name, 'admin/help/'. $module) .'</li>';    if (($i + 1) % $break == 0 && ($i + 1) != $count) {      $output .= '</ul></div><div class="help-items'. ($i + 1 == $break * 3 ? ' help-items-last' : '') .'"><ul>';    }    $i++;  }  $output .= '</ul></div></div>';  return $output;}
<?php// $Id$/** * @defgroup forms Form builder functions * @{ * Functions that build an abstract representation of a HTML form. * * All modules should declare their form builder functions to be in this * group and each builder function should reference its validate and submit * functions using \@see. Conversely, validate and submit functions should * reference the form builder function using \@see. For examples, of this see * system_modules_uninstall() or user_pass(), the latter of which has the * following in its doxygen documentation: * * \@ingroup forms * \@see user_pass_validate(). * \@see user_pass_submit(). * * @} End of "defgroup forms". *//** * @defgroup form_api Form generation * @{ * Functions to enable the processing and display of HTML forms. * * Drupal uses these functions to achieve consistency in its form processing and * presentation, while simplifying code and reducing the amount of HTML that * must be explicitly generated by modules. * * The drupal_get_form() function handles retrieving, processing, and * displaying a rendered HTML form for modules automatically. For example: * * @code * // Display the user registration form. * $output = drupal_get_form('user_register'); * @endcode * * Forms can also be built and submitted programmatically without any user input * using the drupal_execute() function. * * For information on the format of the structured arrays used to define forms, * and more detailed explanations of the Form API workflow, see the * @link http://api.drupal.org/api/file/developer/topics/forms_api_reference.html reference @endlink * and the @link http://api.drupal.org/api/file/developer/topics/forms_api.html quickstart guide. @endlink *//** * Retrieves a form from a constructor function, or from the cache if * the form was built in a previous page-load. The form is then passed * on for processing, after and rendered for display if necessary. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param ... *   Any additional arguments are passed on to the functions called by *   drupal_get_form(), including the unique form constructor function. *   For example, the node_edit form requires that a node object be passed *   in here when it is called. * @return *   The rendered form. */function drupal_get_form($form_id) {  $form_state = array('storage' => NULL, 'submitted' => FALSE);  $args = func_get_args();  $cacheable = FALSE;  if (isset($_SESSION['batch_form_state'])) {    // We've been redirected here after a batch processing : the form has    // already been processed, so we grab the post-process $form_state value    // and move on to form display. See _batch_finished() function.    $form_state = $_SESSION['batch_form_state'];    unset($_SESSION['batch_form_state']);  }  else {    // If the incoming $_POST contains a form_build_id, we'll check the    // cache for a copy of the form in question. If it's there, we don't    // have to rebuild the form to proceed. In addition, if there is stored    // form_state data from a previous step, we'll retrieve it so it can    // be passed on to the form processing code.    if (isset($_POST['form_id']) && $_POST['form_id'] == $form_id && !empty($_POST['form_build_id'])) {      $form = form_get_cache($_POST['form_build_id'], $form_state);    }    // If the previous bit of code didn't result in a populated $form    // object, we're hitting the form for the first time and we need    // to build it from scratch.    if (!isset($form)) {      $form_state['post'] = $_POST;      // Use a copy of the function's arguments for manipulation      $args_temp = $args;      $args_temp[0] = &$form_state;      array_unshift($args_temp, $form_id);      $form = call_user_func_array('drupal_retrieve_form', $args_temp);      $form_build_id = 'form-'. md5(uniqid(mt_rand(), true));      $form['#build_id'] = $form_build_id;      drupal_prepare_form($form_id, $form, $form_state);      // Store a copy of the unprocessed form for caching and indicate that it      // is cacheable if #cache will be set.      $original_form = $form;      $cacheable = TRUE;      unset($form_state['post']);    }    $form['#post'] = $_POST;    // Now that we know we have a form, we'll process it (validating,    // submitting, and handling the results returned by its submission    // handlers. Submit handlers accumulate data in the form_state by    // altering the $form_state variable, which is passed into them by    // reference.    drupal_process_form($form_id, $form, $form_state);    if ($cacheable && !empty($form['#cache'])) {      // Caching is done past drupal_process_form so #process callbacks can      // set #cache.      form_set_cache($form_build_id, $original_form, $form_state);    }  }  // Most simple, single-step forms will be finished by this point --  // drupal_process_form() usually redirects to another page (or to  // a 'fresh' copy of the form) once processing is complete. If one  // of the form's handlers has set $form_state['redirect'] to FALSE,  // the form will simply be re-rendered with the values still in its  // fields.  //  // If $form_state['storage'] or $form_state['rebuild'] has been set  // and input has been processed, we know that we're in a complex  // multi-part process of some sort and the form's workflow is NOT  // complete. We need to construct a fresh copy of the form, passing  // in the latest $form_state in addition to any other variables passed  // into drupal_get_form().  if ((!empty($form_state['storage']) || !empty($form_state['rebuild'])) && !empty($form_state['process_input']) && !form_get_errors()) {    $form = drupal_rebuild_form($form_id, $form_state, $args);  }  // If we haven't redirected to a new location by now, we want to  // render whatever form array is currently in hand.  return drupal_render_form($form_id, $form);}/** * Retrieves a form, caches it and processes it with an empty $_POST. * * This function clears $_POST and passes the empty $_POST to the form_builder. * To preserve some parts from $_POST, pass them in $form_state. * * If your AHAH callback simulates the pressing of a button, then your AHAH * callback will need to do the same as what drupal_get_form would do when the * button is pressed: get the form from the cache, run drupal_process_form over * it and then if it needs rebuild, run drupal_rebuild_form over it. Then send * back a part of the returned form. * $form_state['clicked_button']['#array_parents'] will help you to find which * part. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param $form_state *   A keyed array containing the current state of the form. Most *   important is the $form_state['storage'] collection. * @param $args *   Any additional arguments are passed on to the functions called by *   drupal_get_form(), plus the original form_state in the beginning. If you *   are getting a form from the cache, use $form['#parameters'] to shift off *   the $form_id from its beginning then the resulting array can be used as *   $arg here. * @param $form_build_id *   If the AHAH callback calling this function only alters part of the form, *   then pass in the existing form_build_id so we can re-cache with the same *   csid. * @return *   The newly built form. */function drupal_rebuild_form($form_id, &$form_state, $args, $form_build_id = NULL) {  // Remove the first argument. This is $form_id.when called from  // drupal_get_form and the original $form_state when called from some AHAH  // callback. Neither is needed. After that, put in the current state.  $args[0] = &$form_state;  // And the form_id.  array_unshift($args, $form_id);  $form = call_user_func_array('drupal_retrieve_form', $args);  if (!isset($form_build_id)) {    // We need a new build_id for the new version of the form.    $form_build_id = 'form-'. md5(mt_rand());  }  $form['#build_id'] = $form_build_id;  drupal_prepare_form($form_id, $form, $form_state);  // Now, we cache the form structure so it can be retrieved later for  // validation. If $form_state['storage'] is populated, we'll also cache  // it so that it can be used to resume complex multi-step processes.  form_set_cache($form_build_id, $form, $form_state);  // Clear out all post data, as we don't want the previous step's  // data to pollute this one and trigger validate/submit handling,  // then process the form for rendering.  $_POST = array();  $form['#post'] = array();  drupal_process_form($form_id, $form, $form_state);  return $form;}/** * Store a form in the cache. */function form_set_cache($form_build_id, $form, $form_state) {  global $user;  // 6 hours cache life time for forms should be plenty.  $expire = 21600;  if ($user->uid) {    $form['#cache_token'] = drupal_get_token();  }  cache_set('form_'. $form_build_id, $form, 'cache_form', time() + $expire);  if (!empty($form_state['storage'])) {    cache_set('storage_'. $form_build_id, $form_state['storage'], 'cache_form', time() + $expire);  }}/** * Fetch a form from cache. */function form_get_cache($form_build_id, &$form_state) {  global $user;  if ($cached = cache_get('form_'. $form_build_id, 'cache_form')) {    $form = $cached->data;    if ((isset($form['#cache_token']) && drupal_valid_token($form['#cache_token'])) || (!isset($form['#cache_token']) && !$user->uid)) {      if ($cached = cache_get('storage_'. $form_build_id, 'cache_form')) {        $form_state['storage'] = $cached->data;      }      return $form;    }  }}/** * Retrieves a form using a form_id, populates it with $form_state['values'], * processes it, and returns any validation errors encountered. This * function is the programmatic counterpart to drupal_get_form(). * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param $form_state *   A keyed array containing the current state of the form. Most *   important is the $form_state['values'] collection, a tree of data *   used to simulate the incoming $_POST information from a user's *   form submission. * @param ... *   Any additional arguments are passed on to the functions called by *   drupal_execute(), including the unique form constructor function. *   For example, the node_edit form requires that a node object be passed *   in here when it is called. * For example: * * @code * // register a new user * $form_state = array(); * $form_state['values']['name'] = 'robo-user'; * $form_state['values']['mail'] = 'robouser@example.com'; * $form_state['values']['pass']['pass1'] = 'password'; * $form_state['values']['pass']['pass2'] = 'password'; * $form_state['values']['op'] = t('Create new account'); * drupal_execute('user_register', $form_state); * * // Create a new node * $form_state = array(); * module_load_include('inc', 'node', 'node.pages'); * $node = array('type' => 'story'); * $form_state['values']['title'] = 'My node'; * $form_state['values']['body'] = 'This is the body text!'; * $form_state['values']['name'] = 'robo-user'; * $form_state['values']['op'] = t('Save'); * drupal_execute('story_node_form', $form_state, (object)$node); * @endcode */function drupal_execute($form_id, &$form_state) {  $args = func_get_args();  // Make sure $form_state is passed around by reference.  $args[1] = &$form_state;    $form = call_user_func_array('drupal_retrieve_form', $args);  $form['#post'] = $form_state['values'];  drupal_prepare_form($form_id, $form, $form_state);  drupal_process_form($form_id, $form, $form_state);}/** * Retrieves the structured array that defines a given form. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. * @param $form_state *   A keyed array containing the current state of the form. * @param ... *   Any additional arguments needed by the unique form constructor *   function. Generally, these are any arguments passed into the *   drupal_get_form() or drupal_execute() functions after the first *   argument. If a module implements hook_forms(), it can examine *   these additional arguments and conditionally return different *   builder functions as well. */function drupal_retrieve_form($form_id, &$form_state) {  static $forms;  // We save two copies of the incoming arguments: one for modules to use  // when mapping form ids to constructor functions, and another to pass to  // the constructor function itself. We shift out the first argument -- the  // $form_id itself -- from the list to pass into the constructor function,  // since it's already known.  $args = func_get_args();  $saved_args = $args;  array_shift($args);  if (isset($form_state)) {    array_shift($args);  }  // We first check to see if there's a function named after the $form_id.  // If there is, we simply pass the arguments on to it to get the form.  if (!function_exists($form_id)) {    // In cases where many form_ids need to share a central constructor function,    // such as the node editing form, modules can implement hook_forms(). It    // maps one or more form_ids to the correct constructor functions.    //    // We cache the results of that hook to save time, but that only works    // for modules that know all their form_ids in advance. (A module that    // adds a small 'rate this comment' form to each comment in a list    // would need a unique form_id for each one, for example.)    //    // So, we call the hook if $forms isn't yet populated, OR if it doesn't    // yet have an entry for the requested form_id.    if (!isset($forms) || !isset($forms[$form_id])) {      $forms = module_invoke_all('forms', $form_id, $args);    }    $form_definition = $forms[$form_id];    if (isset($form_definition['callback arguments'])) {      $args = array_merge($form_definition['callback arguments'], $args);    }    if (isset($form_definition['callback'])) {      $callback = $form_definition['callback'];    }  }  array_unshift($args, NULL);  $args[0] = &$form_state;  // If $callback was returned by a hook_forms() implementation, call it.  // Otherwise, call the function named after the form id.  $form = call_user_func_array(isset($callback) ? $callback : $form_id, $args);  // We store the original function arguments, rather than the final $arg  // value, so that form_alter functions can see what was originally  // passed to drupal_retrieve_form(). This allows the contents of #parameters  // to be saved and passed in at a later date to recreate the form.  $form['#parameters'] = $saved_args;  return $form;}/** * This function is the heart of form API. The form gets built, validated and in * appropriate cases, submitted. * * @param $form_id *   The unique string identifying the current form. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. This *   includes the current persistent storage data for the form, and *   any data passed along by earlier steps when displaying a *   multi-step form. Additional information, like the sanitized $_POST *   data, is also accumulated here. */function drupal_process_form($form_id, &$form, &$form_state) {  $form_state['values'] = array();  $form = form_builder($form_id, $form, $form_state);  // Only process the form if it is programmed or the form_id coming  // from the POST data is set and matches the current form_id.  if ((!empty($form['#programmed'])) || (!empty($form['#post']) && (isset($form['#post']['form_id']) && ($form['#post']['form_id'] == $form_id)))) {    $form_state['process_input'] = TRUE;    drupal_validate_form($form_id, $form, $form_state);    // form_clean_id() maintains a cache of element IDs it has seen,    // so it can prevent duplicates. We want to be sure we reset that    // cache when a form is processed, so scenerios that result in    // the form being built behind the scenes and again for the    // browser don't increment all the element IDs needlessly.    form_clean_id(NULL, TRUE);    if ((!empty($form_state['submitted'])) && !form_get_errors() && empty($form_state['rebuild'])) {      $form_state['redirect'] = NULL;      form_execute_handlers('submit', $form, $form_state);      // We'll clear out the cached copies of the form and its stored data      // here, as we've finished with them. The in-memory copies are still      // here, though.      if (variable_get('cache', CACHE_DISABLED) == CACHE_DISABLED && !empty($form_state['values']['form_build_id'])) {        cache_clear_all('form_'. $form_state['values']['form_build_id'], 'cache_form');        cache_clear_all('storage_'. $form_state['values']['form_build_id'], 'cache_form');      }      // If batches were set in the submit handlers, we process them now,      // possibly ending execution. We make sure we do not react to the batch      // that is already being processed (if a batch operation performs a      // drupal_execute).      if ($batch =& batch_get() && !isset($batch['current_set'])) {        // The batch uses its own copies of $form and $form_state for        // late execution of submit handers and post-batch redirection.        $batch['form'] = $form;        $batch['form_state'] = $form_state;        $batch['progressive'] = !$form['#programmed'];        batch_process();        // Execution continues only for programmatic forms.        // For 'regular' forms, we get redirected to the batch processing        // page. Form redirection will be handled in _batch_finished(),        // after the batch is processed.      }      // If no submit handlers have populated the $form_state['storage']      // bundle, and the $form_state['rebuild'] flag has not been set,      // we're finished and should redirect to a new destination page      // if one has been set (and a fresh, unpopulated copy of the form      // if one hasn't). If the form was called by drupal_execute(),      // however, we'll skip this and let the calling function examine      // the resulting $form_state bundle itself.      if (!$form['#programmed'] && empty($form_state['rebuild']) && empty($form_state['storage'])) {        drupal_redirect_form($form, $form_state['redirect']);      }    }  }}/** * Prepares a structured form array by adding required elements, * executing any hook_form_alter functions, and optionally inserting * a validation token to prevent tampering. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. Passed *   in here so that hook_form_alter() calls can use it, as well. */function drupal_prepare_form($form_id, &$form, &$form_state) {  global $user;  $form['#type'] = 'form';  $form['#programmed'] = isset($form['#post']);  if (isset($form['#build_id'])) {    $form['form_build_id'] = array(      '#type' => 'hidden',      '#value' => $form['#build_id'],      '#id' => $form['#build_id'],      '#name' => 'form_build_id',    );  }  // Add a token, based on either #token or form_id, to any form displayed to  // authenticated users. This ensures that any submitted form was actually  // requested previously by the user and protects against cross site request  // forgeries.  if (isset($form['#token'])) {    if ($form['#token'] === FALSE || $user->uid == 0 || $form['#programmed']) {      unset($form['#token']);    }    else {      $form['form_token'] = array('#type' => 'token', '#default_value' => drupal_get_token($form['#token']));    }  }  else if (isset($user->uid) && $user->uid && !$form['#programmed']) {    $form['#token'] = $form_id;    $form['form_token'] = array(      '#id' => form_clean_id('edit-'. $form_id .'-form-token'),      '#type' => 'token',      '#default_value' => drupal_get_token($form['#token']),    );  }  if (isset($form_id)) {    $form['form_id'] = array(      '#type' => 'hidden',      '#value' => $form_id,      '#id' => form_clean_id("edit-$form_id"),    );  }  if (!isset($form['#id'])) {    $form['#id'] = form_clean_id($form_id);  }  $form += _element_info('form');  if (!isset($form['#validate'])) {    if (function_exists($form_id .'_validate')) {      $form['#validate'] = array($form_id .'_validate');    }  }  if (!isset($form['#submit'])) {    if (function_exists($form_id .'_submit')) {      // We set submit here so that it can be altered.      $form['#submit'] = array($form_id .'_submit');    }  }  // Normally, we would call drupal_alter($form_id, $form, $form_state).  // However, drupal_alter() normally supports just one byref parameter. Using  // the __drupal_alter_by_ref key, we can store any additional parameters  // that need to be altered, and they'll be split out into additional params  // for the hook_form_alter() implementations.  // @todo: Remove this in Drupal 7.  $data = &$form;  $data['__drupal_alter_by_ref'] = array(&$form_state);  drupal_alter('form_'. $form_id, $data);  // __drupal_alter_by_ref is unset in the drupal_alter() function, we need  // to repopulate it to ensure both calls get the data.  $data['__drupal_alter_by_ref'] = array(&$form_state);  drupal_alter('form', $data, $form_id);}/** * Validates user-submitted form data from the $form_state using * the validate functions defined in a structured form array. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. The current *   user-submitted data is stored in $form_state['values'], though *   form validation functions are passed an explicit copy of the *   values for the sake of simplicity. Validation handlers can also *   $form_state to pass information on to submit handlers. For example: *     $form_state['data_for_submision'] = $data; *   This technique is useful when validation requires file parsing, *   web service requests, or other expensive requests that should *   not be repeated in the submission step. */function drupal_validate_form($form_id, $form, &$form_state) {  static $validated_forms = array();  if (isset($validated_forms[$form_id])) {    return;  }  // If the session token was set by drupal_prepare_form(), ensure that it  // matches the current user's session.  if (isset($form['#token'])) {    if (!drupal_valid_token($form_state['values']['form_token'], $form['#token'])) {      // Setting this error will cause the form to fail validation.      form_set_error('form_token', t('Validation error, please try again. If this error persists, please contact the site administrator.'));    }  }  _form_validate($form, $form_state, $form_id);  $validated_forms[$form_id] = TRUE;}/** * Renders a structured form array into themed HTML. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @return *   A string containing the themed HTML. */function drupal_render_form($form_id, &$form) {  // Don't override #theme if someone already set it.  if (!isset($form['#theme'])) {    init_theme();    $registry = theme_get_registry();    if (isset($registry[$form_id])) {      $form['#theme'] = $form_id;    }  }  $output = drupal_render($form);  return $output;}/** * Redirect the user to a URL after a form has been processed. * * @param $form *   An associative array containing the structure of the form. * @param $redirect *   An optional value containing the destination path to redirect *   to if none is specified by the form. */function drupal_redirect_form($form, $redirect = NULL) {  $goto = NULL;  if (isset($redirect)) {    $goto = $redirect;  }  if ($goto !== FALSE && isset($form['#redirect'])) {    $goto = $form['#redirect'];  }  if (!isset($goto) || ($goto !== FALSE)) {    if (isset($goto)) {      if (is_array($goto)) {        call_user_func_array('drupal_goto', $goto);      }      else {        drupal_goto($goto);      }    }    drupal_goto($_GET['q']);  }}/** * Performs validation on form elements. First ensures required fields are * completed, #maxlength is not exceeded, and selected options were in the * list of options given to the user. Then calls user-defined validators. * * @param $elements *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. The current *   user-submitted data is stored in $form_state['values'], though *   form validation functions are passed an explicit copy of the *   values for the sake of simplicity. Validation handlers can also *   $form_state to pass information on to submit handlers. For example: *     $form_state['data_for_submision'] = $data; *   This technique is useful when validation requires file parsing, *   web service requests, or other expensive requests that should *   not be repeated in the submission step. * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. */function _form_validate($elements, &$form_state, $form_id = NULL) {  static $complete_form;  // Also used in the installer, pre-database setup.  $t = get_t();  // Recurse through all children.  foreach (element_children($elements) as $key) {    if (isset($elements[$key]) && $elements[$key]) {      _form_validate($elements[$key], $form_state);    }  }  // Validate the current input.  if (!isset($elements['#validated']) || !$elements['#validated']) {    if (isset($elements['#needs_validation'])) {      // Make sure a value is passed when the field is required.      // A simple call to empty() will not cut it here as some fields, like      // checkboxes, can return a valid value of '0'. Instead, check the      // length if it's a string, and the item count if it's an array.      if ($elements['#required'] && (!count($elements['#value']) || (is_string($elements['#value']) && strlen(trim($elements['#value'])) == 0))) {        form_error($elements, $t('!name field is required.', array('!name' => $elements['#title'])));      }      // Verify that the value is not longer than #maxlength.      if (isset($elements['#maxlength']) && drupal_strlen($elements['#value']) > $elements['#maxlength']) {        form_error($elements, $t('!name cannot be longer than %max characters but is currently %length characters long.', array('!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title'], '%max' => $elements['#maxlength'], '%length' => drupal_strlen($elements['#value']))));      }      if (isset($elements['#options']) && isset($elements['#value'])) {        if ($elements['#type'] == 'select') {          $options = form_options_flatten($elements['#options']);        }        else {          $options = $elements['#options'];        }        if (is_array($elements['#value'])) {          $value = $elements['#type'] == 'checkboxes' ? array_keys(array_filter($elements['#value'])) : $elements['#value'];          foreach ($value as $v) {            if (!isset($options[$v])) {              form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));              watchdog('form', 'Illegal choice %choice in !name element.', array('%choice' => $v, '!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);            }          }        }        elseif (!isset($options[$elements['#value']])) {          form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));          watchdog('form', 'Illegal choice %choice in %name element.', array('%choice' => $elements['#value'], '%name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);        }      }    }    // Call user-defined form level validators and store a copy of the full    // form so that element-specific validators can examine the entire structure    // if necessary.    if (isset($form_id)) {      form_execute_handlers('validate', $elements, $form_state);      $complete_form = $elements;    }    // Call any element-specific validators. These must act on the element    // #value data.    elseif (isset($elements['#element_validate'])) {      foreach ($elements['#element_validate'] as $function) {        if (function_exists($function))  {          $function($elements, $form_state, $complete_form);        }      }    }    $elements['#validated'] = TRUE;  }}/** * A helper function used to execute custom validation and submission * handlers for a given form. Button-specific handlers are checked * first. If none exist, the function falls back to form-level handlers. * * @param $type *   The type of handler to execute. 'validate' or 'submit' are the *   defaults used by Form API. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. If the user *   submitted the form by clicking a button with custom handler functions *   defined, those handlers will be stored here. */function form_execute_handlers($type, &$form, &$form_state) {  $return = FALSE;  if (isset($form_state[$type .'_handlers'])) {    $handlers = $form_state[$type .'_handlers'];  }  elseif (isset($form['#'. $type])) {    $handlers = $form['#'. $type];  }  else {    $handlers = array();  }  foreach ($handlers as $function) {    if (function_exists($function))  {      // Check to see if a previous _submit handler has set a batch, but       // make sure we do not react to a batch that is already being processed       // (for instance if a batch operation performs a drupal_execute()).      if ($type == 'submit' && ($batch =& batch_get()) && !isset($batch['current_set'])) {        // Some previous _submit handler has set a batch. We store the call        // in a special 'control' batch set, for execution at the correct        // time during the batch processing workflow.        $batch['sets'][] = array('form_submit' => $function);      }      else {        $function($form, $form_state);      }      $return = TRUE;    }  }  return $return;}/** * File an error against a form element. * * @param $name *   The name of the form element. If the #parents property of your form *   element is array('foo', 'bar', 'baz') then you may set an error on 'foo' *   or 'foo][bar][baz'. Setting an error on 'foo' sets an error for every *   element where the #parents array starts with 'foo'. * @param $message *   The error message to present to the user. * @param $reset *   Reset the form errors static cache. * @return *   Never use the return value of this function, use form_get_errors and *   form_get_error instead. */function form_set_error($name = NULL, $message = '', $reset = FALSE) {  static $form = array();  if ($reset) {    $form = array();  }  if (isset($name) && !isset($form[$name])) {    $form[$name] = $message;    if ($message) {      drupal_set_message($message, 'error');    }  }  return $form;}/** * Return an associative array of all errors. */function form_get_errors() {  $form = form_set_error();  if (!empty($form)) {    return $form;  }}/** * Return the error message filed against the form with the specified name. */function form_get_error($element) {  $form = form_set_error();  $key = $element['#parents'][0];  if (isset($form[$key])) {    return $form[$key];  }  $key = implode('][', $element['#parents']);  if (isset($form[$key])) {    return $form[$key];  }}/** * Flag an element as having an error. */function form_error(&$element, $message = '') {  form_set_error(implode('][', $element['#parents']), $message);}/** * Walk through the structured form array, adding any required * properties to each element and mapping the incoming $_POST * data to the proper elements. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. In this *   context, it is used to accumulate information about which button *   was clicked when the form was submitted, as well as the sanitized *   $_POST data. */function form_builder($form_id, $form, &$form_state) {  static $complete_form, $cache;  // Initialize as unprocessed.  $form['#processed'] = FALSE;  // Use element defaults.  if ((!empty($form['#type'])) && ($info = _element_info($form['#type']))) {    // Overlay $info onto $form, retaining preexisting keys in $form.    $form += $info;  }  if (isset($form['#type']) && $form['#type'] == 'form') {    $cache = NULL;    $complete_form = $form;    if (!empty($form['#programmed'])) {      $form_state['submitted'] = TRUE;    }  }  if (isset($form['#input']) && $form['#input']) {    _form_builder_handle_input_element($form_id, $form, $form_state, $complete_form);  }  $form['#defaults_loaded'] = TRUE;  // We start off assuming all form elements are in the correct order.  $form['#sorted'] = TRUE;  // Recurse through all child elements.  $count = 0;  foreach (element_children($form) as $key) {    $form[$key]['#post'] = $form['#post'];    $form[$key]['#programmed'] = $form['#programmed'];    // Don't squash an existing tree value.    if (!isset($form[$key]['#tree'])) {      $form[$key]['#tree'] = $form['#tree'];    }    // Deny access to child elements if parent is denied.    if (isset($form['#access']) && !$form['#access']) {      $form[$key]['#access'] = FALSE;    }    // Don't squash existing parents value.    if (!isset($form[$key]['#parents'])) {      // Check to see if a tree of child elements is present. If so,      // continue down the tree if required.      $form[$key]['#parents'] = $form[$key]['#tree'] && $form['#tree'] ? array_merge($form['#parents'], array($key)) : array($key);      $array_parents = isset($form['#array_parents']) ? $form['#array_parents'] : array();      $array_parents[] = $key;      $form[$key]['#array_parents'] = $array_parents;    }    // Assign a decimal placeholder weight to preserve original array order.    if (!isset($form[$key]['#weight'])) {      $form[$key]['#weight'] = $count/1000;    }    else {      // If one of the child elements has a weight then we will need to sort      // later.      unset($form['#sorted']);    }    $form[$key] = form_builder($form_id, $form[$key], $form_state);    $count++;  }  // The #after_build flag allows any piece of a form to be altered  // after normal input parsing has been completed.  if (isset($form['#after_build']) && !isset($form['#after_build_done'])) {    foreach ($form['#after_build'] as $function) {      $form = $function($form, $form_state);      $form['#after_build_done'] = TRUE;    }  }  // Now that we've processed everything, we can go back to handle the funky  // Internet Explorer button-click scenario.  _form_builder_ie_cleanup($form, $form_state);  // We shoud keep the buttons array until the IE clean up function  // has recognized the submit button so the form has been marked  // as submitted. If we already know which button was submitted,  // we don't need the array.  if (!empty($form_state['submitted'])) {    unset($form_state['buttons']);  }  // If some callback set #cache, we need to flip a static flag so later it  // can be found.  if (!empty($form['#cache'])) {    $cache = $form['#cache'];  }  // We are on the top form, we can copy back #cache if it's set.  if (isset($form['#type']) && $form['#type'] == 'form' && isset($cache)) {    $form['#cache'] = TRUE;  }  return $form;}/** * Populate the #value and #name properties of input elements so they * can be processed and rendered. Also, execute any #process handlers * attached to a specific element. */function _form_builder_handle_input_element($form_id, &$form, &$form_state, $complete_form) {  if (!isset($form['#name'])) {    $name = array_shift($form['#parents']);    $form['#name'] = $name;    if ($form['#type'] == 'file') {      // To make it easier to handle $_FILES in file.inc, we place all      // file fields in the 'files' array. Also, we do not support      // nested file names.      $form['#name'] = 'files['. $form['#name'] .']';    }    elseif (count($form['#parents'])) {      $form['#name'] .= '['. implode('][', $form['#parents']) .']';    }    array_unshift($form['#parents'], $name);  }  if (!isset($form['#id'])) {    $form['#id'] = form_clean_id('edit-'. implode('-', $form['#parents']));  }  if (!empty($form['#disabled'])) {    $form['#attributes']['disabled'] = 'disabled';  }  if (!isset($form['#value']) && !array_key_exists('#value', $form)) {    $function = !empty($form['#value_callback']) ? $form['#value_callback'] : 'form_type_'. $form['#type'] .'_value';    if (($form['#programmed']) || ((!isset($form['#access']) || $form['#access']) && isset($form['#post']) && (isset($form['#post']['form_id']) && $form['#post']['form_id'] == $form_id))) {      $edit = $form['#post'];      foreach ($form['#parents'] as $parent) {        $edit = isset($edit[$parent]) ? $edit[$parent] : NULL;      }      if (!$form['#programmed'] || isset($edit)) {        // Call #type_value to set the form value;        if (function_exists($function)) {          $form['#value'] = $function($form, $edit);        }        if (!isset($form['#value']) && isset($edit)) {          $form['#value'] = $edit;        }      }      // Mark all posted values for validation.      if (isset($form['#value']) || (isset($form['#required']) && $form['#required'])) {        $form['#needs_validation'] = TRUE;      }    }    // Load defaults.    if (!isset($form['#value'])) {      // Call #type_value without a second argument to request default_value handling.      if (function_exists($function)) {        $form['#value'] = $function($form);      }      // Final catch. If we haven't set a value yet, use the explicit default value.      // Avoid image buttons (which come with garbage value), so we only get value      // for the button actually clicked.      if (!isset($form['#value']) && empty($form['#has_garbage_value'])) {        $form['#value'] = isset($form['#default_value']) ? $form['#default_value'] : '';      }    }  }  // Determine which button (if any) was clicked to submit the form.  // We compare the incoming values with the buttons defined in the form,  // and flag the one that matches. We have to do some funky tricks to  // deal with Internet Explorer's handling of single-button forms, though.  if (!empty($form['#post']) && isset($form['#executes_submit_callback'])) {    // First, accumulate a collection of buttons, divided into two bins:    // those that execute full submit callbacks and those that only validate.    $button_type = $form['#executes_submit_callback'] ? 'submit' : 'button';    $form_state['buttons'][$button_type][] = $form;    if (_form_button_was_clicked($form)) {      $form_state['submitted'] = $form_state['submitted'] || $form['#executes_submit_callback'];      // In most cases, we want to use form_set_value() to manipulate      // the global variables. In this special case, we want to make sure that      // the value of this element is listed in $form_variables under 'op'.      $form_state['values'][$form['#name']] = $form['#value'];      $form_state['clicked_button'] = $form;      if (isset($form['#validate'])) {        $form_state['validate_handlers'] = $form['#validate'];      }      if (isset($form['#submit'])) {        $form_state['submit_handlers'] = $form['#submit'];      }    }  }  // Allow for elements to expand to multiple elements, e.g., radios,  // checkboxes and files.  if (isset($form['#process']) && !$form['#processed']) {    foreach ($form['#process'] as $process) {      if (function_exists($process)) {        $form = $process($form, isset($edit) ? $edit : NULL, $form_state, $complete_form);      }    }    $form['#processed'] = TRUE;  }  form_set_value($form, $form['#value'], $form_state);}/** * Helper function to handle the sometimes-convoluted logic of button * click detection. * * In Internet Explorer, if ONLY one submit button is present, AND the * enter key is used to submit the form, no form value is sent for it * and we'll never detect a match. That special case is handled by * _form_builder_ie_cleanup(). */function _form_button_was_clicked($form) {  // First detect normal 'vanilla' button clicks. Traditionally, all  // standard buttons on a form share the same name (usually 'op'),  // and the specific return value is used to determine which was  // clicked. This ONLY works as long as $form['#name'] puts the  // value at the top level of the tree of $_POST data.  if (isset($form['#post'][$form['#name']]) && $form['#post'][$form['#name']] == $form['#value']) {    return TRUE;  }  // When image buttons are clicked, browsers do NOT pass the form element  // value in $_POST. Instead they pass an integer representing the  // coordinates of the click on the button image. This means that image  // buttons MUST have unique $form['#name'] values, but the details of  // their $_POST data should be ignored.  elseif (!empty($form['#has_garbage_value']) && isset($form['#value']) && $form['#value'] !== '') {    return TRUE;  }  return FALSE;}/** * In IE, if only one submit button is present, AND the enter key is * used to submit the form, no form value is sent for it and our normal * button detection code will never detect a match. We call this * function after all other button-detection is complete to check * for the proper conditions, and treat the single button on the form * as 'clicked' if they are met. */function _form_builder_ie_cleanup($form, &$form_state) {  // Quick check to make sure we're always looking at the full form  // and not a sub-element.  if (!empty($form['#type']) && $form['#type'] == 'form') {    // If we haven't recognized a submission yet, and there's a single    // submit button, we know that we've hit the right conditions. Grab    // the first one and treat it as the clicked button.    if (empty($form_state['submitted']) && !empty($form_state['buttons']['submit']) && empty($form_state['buttons']['button'])) {      $button = $form_state['buttons']['submit'][0];      // Set up all the $form_state information that would have been      // populated had the button been recognized earlier.      $form_state['submitted'] = TRUE;      $form_state['submit_handlers'] = empty($button['#submit']) ? NULL : $button['#submit'];      $form_state['validate_handlers'] = empty($button['#validate']) ? NULL : $button['#validate'];      $form_state['values'][$button['#name']] = $button['#value'];      $form_state['clicked_button'] = $button;    }  }}/** * Helper function to determine the value for an image button form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_image_button_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (!empty($edit)) {      // If we're dealing with Mozilla or Opera, we're lucky. It will      // return a proper value, and we can get on with things.      return $form['#return_value'];    }    else {      // Unfortunately, in IE we never get back a proper value for THIS      // form element. Instead, we get back two split values: one for the      // X and one for the Y coordinates on which the user clicked the      // button. We'll find this element in the #post data, and search      // in the same spot for its name, with '_x'.      $post = $form['#post'];      foreach (split('\[', $form['#name']) as $element_name) {        // chop off the ] that may exist.        if (substr($element_name, -1) == ']') {          $element_name = substr($element_name, 0, -1);        }        if (!isset($post[$element_name])) {          if (isset($post[$element_name .'_x'])) {            return $form['#return_value'];          }          return NULL;        }        $post = $post[$element_name];      }      return $form['#return_value'];    }  }}/** * Helper function to determine the value for a checkbox form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_checkbox_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (empty($form['#disabled'])) {      return !empty($edit) ? $form['#return_value'] : 0;    }    else {      return $form['#default_value'];    }  }}/** * Helper function to determine the value for a checkboxes form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_checkboxes_value($form, $edit = FALSE) {  if ($edit === FALSE) {    $value = array();    $form += array('#default_value' => array());    foreach ($form['#default_value'] as $key) {      $value[$key] = 1;    }    return $value;  }  elseif (!isset($edit)) {    return array();  }}/** * Helper function to determine the value for a password_confirm form * element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_password_confirm_value($form, $edit = FALSE) {  if ($edit === FALSE) {    $form += array('#default_value' => array());    return $form['#default_value'] + array('pass1' => '', 'pass2' => '');  }}/** * Helper function to determine the value for a select form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_select_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (isset($form['#multiple']) && $form['#multiple']) {      return (is_array($edit)) ? drupal_map_assoc($edit) : array();    }    else {      return $edit;    }  }}/** * Helper function to determine the value for a textfield form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_textfield_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    // Equate $edit to the form value to ensure it's marked for    // validation.    return str_replace(array("\r", "\n"), '', $edit);  }}/** * Helper function to determine the value for form's token value. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_token_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    return (string)$edit;  }}/** * Change submitted form values during the form processing cycle. * * Use this function to change the submitted value of a form item in the * validation phase so that it persists in $form_state through to the * submission handlers in the submission phase. * * Since $form_state['values'] can either be a flat array of values, or a tree * of nested values, some care must be taken when using this function. * Specifically, $form_item['#parents'] is an array that describes the branch of * the tree whose value should be updated. For example, if we wanted to update * $form_state['values']['one']['two'] to 'new value', we'd pass in * $form_item['#parents'] = array('one', 'two') and $value = 'new value'. * * @param $form_item *   The form item that should have its value updated. Keys used: #parents, *   #value. In most cases you can just pass in the right element from the $form *   array. * @param $value *   The new value for the form item. * @param $form_state *   The array where the value change should be recorded. */function form_set_value($form_item, $value, &$form_state) {  _form_set_value($form_state['values'], $form_item, $form_item['#parents'], $value);}/** * Helper function for form_set_value(). * * We iterate over $parents and create nested arrays for them * in $form_state['values'] if needed. Then we insert the value into * the right array. */function _form_set_value(&$form_values, $form_item, $parents, $value) {  $parent = array_shift($parents);  if (empty($parents)) {    $form_values[$parent] = $value;  }  else {    if (!isset($form_values[$parent])) {      $form_values[$parent] = array();    }    _form_set_value($form_values[$parent], $form_item, $parents, $value);  }}/** * Retrieve the default properties for the defined element type. */function _element_info($type, $refresh = NULL) {  static $cache;  $basic_defaults = array(    '#description' => NULL,    '#attributes' => array(),    '#required' => FALSE,    '#tree' => FALSE,    '#parents' => array()  );  if (!isset($cache) || $refresh) {    $cache = array();    foreach (module_implements('elements') as $module) {      $elements = module_invoke($module, 'elements');      if (isset($elements) && is_array($elements)) {        $cache = array_merge_recursive($cache, $elements);      }    }    if (sizeof($cache)) {      foreach ($cache as $element_type => $info) {        $cache[$element_type] = array_merge_recursive($basic_defaults, $info);      }    }  }  return $cache[$type];}function form_options_flatten($array, $reset = TRUE) {  static $return;  if ($reset) {    $return = array();  }  foreach ($array as $key => $value) {    if (is_object($value)) {      form_options_flatten($value->option, FALSE);    }    else if (is_array($value)) {      form_options_flatten($value, FALSE);    }    else {      $return[$key] = 1;    }  }  return $return;}/** * Format a dropdown menu or scrolling selection box. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, extra, multiple, required * @return *   A themed HTML string representing the form element. * * @ingroup themeable * * It is possible to group options together; to do this, change the format of * $options to an associative array in which the keys are group labels, and the * values are associative arrays in the normal $options format. */function theme_select($element) {  $select = '';  $size = $element['#size'] ? ' size="'. $element['#size'] .'"' : '';  _form_set_class($element, array('form-select'));  $multiple = $element['#multiple'];  return theme('form_element', $element, '<select name="'. $element['#name'] .''. ($multiple ? '[]' : '') .'"'. ($multiple ? ' multiple="multiple" ' : '') . drupal_attributes($element['#attributes']) .' id="'. $element['#id'] .'" '. $size .'>'. form_select_options($element) .'</select>');}function form_select_options($element, $choices = NULL) {  if (!isset($choices)) {    $choices = $element['#options'];  }  // array_key_exists() accommodates the rare event where $element['#value'] is NULL.  // isset() fails in this situation.  $value_valid = isset($element['#value']) || array_key_exists('#value', $element);  $value_is_array = is_array($element['#value']);  $options = '';  foreach ($choices as $key => $choice) {    if (is_array($choice)) {      $options .= '<optgroup label="'. $key .'">';      $options .= form_select_options($element, $choice);      $options .= '</optgroup>';    }    elseif (is_object($choice)) {      $options .= form_select_options($element, $choice->option);    }    else {      $key = (string)$key;      if ($value_valid && (!$value_is_array && (string)$element['#value'] === $key || ($value_is_array && in_array($key, $element['#value'])))) {        $selected = ' selected="selected"';      }      else {        $selected = '';      }      $options .= '<option value="'. check_plain($key) .'"'. $selected .'>'. check_plain($choice) .'</option>';    }  }  return $options;}/** * Traverses a select element's #option array looking for any values * that hold the given key. Returns an array of indexes that match. * * This function is useful if you need to modify the options that are * already in a form element; for example, to remove choices which are * not valid because of additional filters imposed by another module. * One example might be altering the choices in a taxonomy selector. * To correctly handle the case of a multiple hierarchy taxonomy, * #options arrays can now hold an array of objects, instead of a * direct mapping of keys to labels, so that multiple choices in the * selector can have the same key (and label). This makes it difficult * to manipulate directly, which is why this helper function exists. * * This function does not support optgroups (when the elements of the * #options array are themselves arrays), and will return FALSE if * arrays are found. The caller must either flatten/restore or * manually do their manipulations in this case, since returning the * index is not sufficient, and supporting this would make the * "helper" too complicated and cumbersome to be of any help. * * As usual with functions that can return array() or FALSE, do not * forget to use === and !== if needed. * * @param $element *   The select element to search. * @param $key *   The key to look for. * @return *   An array of indexes that match the given $key. Array will be *   empty if no elements were found. FALSE if optgroups were found. */function form_get_options($element, $key) {  $keys = array();  foreach ($element['#options'] as $index => $choice) {    if (is_array($choice)) {      return FALSE;    }    else if (is_object($choice)) {      if (isset($choice->option[$key])) {        $keys[] = $index;      }    }    else if ($index == $key) {      $keys[] = $index;    }  }  return $keys;}/** * Format a group of form items. * * @param $element *   An associative array containing the properties of the element. *   Properties used: attributes, title, value, description, children, collapsible, collapsed * @return *   A themed HTML string representing the form item group. * * @ingroup themeable */function theme_fieldset($element) {  if (!empty($element['#collapsible'])) {    drupal_add_js('misc/collapse.js');    if (!isset($element['#attributes']['class'])) {      $element['#attributes']['class'] = '';    }    $element['#attributes']['class'] .= ' collapsible';    if (!empty($element['#collapsed'])) {      $element['#attributes']['class'] .= ' collapsed';    }  }  return '<fieldset'. drupal_attributes($element['#attributes']) .'>'. ($element['#title'] ? '<legend>'. $element['#title'] .'</legend>' : '') . (isset($element['#description']) && $element['#description'] ? '<div class="description">'. $element['#description'] .'</div>' : '') . (!empty($element['#children']) ? $element['#children'] : '') . (isset($element['#value']) ? $element['#value'] : '') ."</fieldset>\n";}/** * Format a radio button. * * @param $element *   An associative array containing the properties of the element. *   Properties used: required, return_value, value, attributes, title, description * @return *   A themed HTML string representing the form item group. * * @ingroup themeable */function theme_radio($element) {  _form_set_class($element, array('form-radio'));  $output = '<input type="radio" ';  $output .= 'id="'. $element['#id'] .'" ';  $output .= 'name="'. $element['#name'] .'" ';  $output .= 'value="'. $element['#return_value'] .'" ';  $output .= (check_plain($element['#value']) == $element['#return_value']) ? ' checked="checked" ' : ' ';  $output .= drupal_attributes($element['#attributes']) .' />';  if (!is_null($element['#title'])) {    $output = '<label class="option" for="'. $element['#id'] .'">'. $output .' '. $element['#title'] .'</label>';  }  unset($element['#title']);  return theme('form_element', $element, $output);}/** * Format a set of radio buttons. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, required and attributes. * @return *   A themed HTML string representing the radio button set. * * @ingroup themeable */function theme_radios($element) {  $class = 'form-radios';  if (isset($element['#attributes']['class'])) {    $class .= ' '. $element['#attributes']['class'];  }  $element['#children'] = '<div class="'. $class .'">'. (!empty($element['#children']) ? $element['#children'] : '') .'</div>';  if ($element['#title'] || $element['#description']) {    unset($element['#id']);    return theme('form_element', $element, $element['#children']);  }  else {    return $element['#children'];  }}/** * Format a password_confirm item. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, id, required, error. * @return *   A themed HTML string representing the form item. * * @ingroup themeable */function theme_password_confirm($element) {  return theme('form_element', $element, $element['#children']);}/** * Expand a password_confirm field into two text boxes. */function expand_password_confirm($element) {  $element['pass1'] =  array(    '#type' => 'password',    '#title' => t('Password'),    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass1'],    '#required' => $element['#required'],    '#attributes' => array('class' => 'password-field'),  );  $element['pass2'] =  array(    '#type' => 'password',    '#title' => t('Confirm password'),    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass2'],    '#required' => $element['#required'],    '#attributes' => array('class' => 'password-confirm'),  );  $element['#element_validate'] = array('password_confirm_validate');  $element['#tree'] = TRUE;  if (isset($element['#size'])) {    $element['pass1']['#size'] = $element['pass2']['#size'] = $element['#size'];  }  return $element;}/** * Validate password_confirm element. */function password_confirm_validate($form, &$form_state) {  $pass1 = trim($form['pass1']['#value']);  if (!empty($pass1)) {    $pass2 = trim($form['pass2']['#value']);    if (strcmp($pass1, $pass2)) {      form_error($form, t('The specified passwords do not match.'));    }  }  elseif ($form['#required'] && !empty($form['#post'])) {    form_error($form, t('Password field is required.'));  }  // Password field must be converted from a two-element array into a single  // string regardless of validation results.  form_set_value($form['pass1'], NULL, $form_state);  form_set_value($form['pass2'], NULL, $form_state);  form_set_value($form, $pass1, $form_state);  return $form;}/** * Format a date selection element. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, required and attributes. * @return *   A themed HTML string representing the date selection boxes. * * @ingroup themeable */function theme_date($element) {  return theme('form_element', $element, '<div class="container-inline">'. $element['#children'] .'</div>');}/** * Roll out a single date element. */function expand_date($element) {  // Default to current date  if (empty($element['#value'])) {    $element['#value'] = array('day' => format_date(time(), 'custom', 'j'),                            'month' => format_date(time(), 'custom', 'n'),                            'year' => format_date(time(), 'custom', 'Y'));  }  $element['#tree'] = TRUE;  // Determine the order of day, month, year in the site's chosen date format.  $format = variable_get('date_format_short', 'm/d/Y - H:i');  $sort = array();  $sort['day'] = max(strpos($format, 'd'), strpos($format, 'j'));  $sort['month'] = max(strpos($format, 'm'), strpos($format, 'M'));  $sort['year'] = strpos($format, 'Y');  asort($sort);  $order = array_keys($sort);  // Output multi-selector for date.  foreach ($order as $type) {    switch ($type) {      case 'day':        $options = drupal_map_assoc(range(1, 31));        break;      case 'month':        $options = drupal_map_assoc(range(1, 12), 'map_month');        break;      case 'year':        $options = drupal_map_assoc(range(1900, 2050));        break;    }    $parents = $element['#parents'];    $parents[] = $type;    $element[$type] = array(      '#type' => 'select',      '#value' => $element['#value'][$type],      '#attributes' => $element['#attributes'],      '#options' => $options,    );  }  return $element;}/** * Validates the date type to stop dates like February 30, 2006. */function date_validate($form) {  if (!checkdate($form['#value']['month'], $form['#value']['day'], $form['#value']['year'])) {    form_error($form, t('The specified date is invalid.'));  }}/** * Helper function for usage with drupal_map_assoc to display month names. */function map_month($month) {  return format_date(gmmktime(0, 0, 0, $month, 2, 1970), 'custom', 'M', 0);}/** * If no default value is set for weight select boxes, use 0. */function weight_value(&$form) {  if (isset($form['#default_value'])) {    $form['#value'] = $form['#default_value'];  }  else {    $form['#value'] = 0;  }}/** * Roll out a single radios element to a list of radios, * using the options array as index. */function expand_radios($element) {  if (count($element['#options']) > 0) {    foreach ($element['#options'] as $key => $choice) {      if (!isset($element[$key])) {        // Generate the parents as the autogenerator does, so we will have a        // unique id for each radio button.        $parents_for_id = array_merge($element['#parents'], array($key));        $element[$key] = array(          '#type' => 'radio',          '#title' => $choice,          '#return_value' => check_plain($key),          '#default_value' => isset($element['#default_value']) ? $element['#default_value'] : NULL,          '#attributes' => $element['#attributes'],          '#parents' => $element['#parents'],          '#id' => form_clean_id('edit-'. implode('-', $parents_for_id)),          '#ahah' => isset($element['#ahah']) ? $element['#ahah'] : NULL,        );      }    }  }  return $element;}/** * Add AHAH information about a form element to the page to communicate with * javascript. If #ahah[path] is set on an element, this additional javascript is * added to the page header to attach the AHAH behaviors. See ahah.js for more * information. * * @param $element *   An associative array containing the properties of the element. *   Properties used: ahah_event, ahah_path, ahah_wrapper, ahah_parameters, *   ahah_effect. * @return *   None. Additional code is added to the header of the page using *   drupal_add_js. */function form_expand_ahah($element) {  static $js_added = array();  // Add a reasonable default event handler if none specified.  if (isset($element['#ahah']['path']) && !isset($element['#ahah']['event'])) {    switch ($element['#type']) {      case 'submit':      case 'button':      case 'image_button':        // Use the mousedown instead of the click event because form        // submission via pressing the enter key triggers a click event on        // submit inputs, inappropriately triggering AHAH behaviors.        $element['#ahah']['event'] = 'mousedown';        // Attach an additional event handler so that AHAH behaviours        // can be triggered still via keyboard input.        $element['#ahah']['keypress'] = TRUE;        break;      case 'password':      case 'textfield':      case 'textarea':        $element['#ahah']['event'] = 'blur';        break;      case 'radio':      case 'checkbox':      case 'select':        $element['#ahah']['event'] = 'change';        break;    }  }  // Adding the same javascript settings twice will cause a recursion error,  // we avoid the problem by checking if the javascript has already been added.  if (isset($element['#ahah']['path']) && isset($element['#ahah']['event']) && !isset($js_added[$element['#id']])) {    drupal_add_js('misc/jquery.form.js');    drupal_add_js('misc/ahah.js');    $ahah_binding = array(      'url'      => url($element['#ahah']['path']),      'event'    => $element['#ahah']['event'],      'keypress' => empty($element['#ahah']['keypress']) ? NULL : $element['#ahah']['keypress'],      'wrapper'  => empty($element['#ahah']['wrapper']) ? NULL : $element['#ahah']['wrapper'],      'selector' => empty($element['#ahah']['selector']) ? '#'. $element['#id'] : $element['#ahah']['selector'],      'effect'   => empty($element['#ahah']['effect']) ? 'none' : $element['#ahah']['effect'],      'method'   => empty($element['#ahah']['method']) ? 'replace' : $element['#ahah']['method'],      'progress' => empty($element['#ahah']['progress']) ? array('type' => 'throbber') : $element['#ahah']['progress'],      'button'   => isset($element['#executes_submit_callback']) ? array($element['#name'] => $element['#value']) : FALSE,    );    // Convert a simple #ahah[progress] type string into an array.    if (is_string($ahah_binding['progress'])) {      $ahah_binding['progress'] = array('type' => $ahah_binding['progress']);    }    // Change progress path to a full url.    if (isset($ahah_binding['progress']['path'])) {      $ahah_binding['progress']['url'] = url($ahah_binding['progress']['path']);    }    // Add progress.js if we're doing a bar display.    if ($ahah_binding['progress']['type'] == 'bar') {      drupal_add_js('misc/progress.js');    }    drupal_add_js(array('ahah' => array($element['#id'] => $ahah_binding)), 'setting');    $js_added[$element['#id']] = TRUE;    $element['#cache'] = TRUE;  }  return $element;}/** * Format a form item. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, required, error * @return *   A themed HTML string representing the form item. * * @ingroup themeable */function theme_item($element) {  return theme('form_element', $element, $element['#value'] . (!empty($element['#children']) ? $element['#children'] : ''));}/** * Format a checkbox. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, return_value, description, required * @return *   A themed HTML string representing the checkbox. * * @ingroup themeable */function theme_checkbox($element) {  _form_set_class($element, array('form-checkbox'));  $checkbox = '<input ';  $checkbox .= 'type="checkbox" ';  $checkbox .= 'name="'. $element['#name'] .'" ';  $checkbox .= 'id="'. $element['#id'] .'" ' ;  $checkbox .= 'value="'. $element['#return_value'] .'" ';  $checkbox .= $element['#value'] ? ' checked="checked" ' : ' ';  $checkbox .= drupal_attributes($element['#attributes']) .' />';  if (!is_null($element['#title'])) {    $checkbox = '<label class="option" for="'. $element['#id'] .'">'. $checkbox .' '. $element['#title'] .'</label>';  }  unset($element['#title']);  return theme('form_element', $element, $checkbox);}/** * Format a set of checkboxes. * * @param $element *   An associative array containing the properties of the element. * @return *   A themed HTML string representing the checkbox set. * * @ingroup themeable */function theme_checkboxes($element) {  $class = 'form-checkboxes';  if (isset($element['#attributes']['class'])) {    $class .= ' '. $element['#attributes']['class'];  }  $element['#children'] = '<div class="'. $class .'">'. (!empty($element['#children']) ? $element['#children'] : '') .'</div>';  if ($element['#title'] || $element['#description']) {    unset($element['#id']);    return theme('form_element', $element, $element['#children']);  }  else {    return $element['#children'];  }}function expand_checkboxes($element) {  $value = is_array($element['#value']) ? $element['#value'] : array();  $element['#tree'] = TRUE;  if (count($element['#options']) > 0) {    if (!isset($element['#default_value']) || $element['#default_value'] == 0) {      $element['#default_value'] = array();    }    foreach ($element['#options'] as $key => $choice) {      if (!isset($element[$key])) {        $element[$key] = array(          '#type' => 'checkbox',          '#processed' => TRUE,          '#title' => $choice,          '#return_value' => $key,          '#default_value' => isset($value[$key]),          '#attributes' => $element['#attributes'],          '#ahah' => isset($element['#ahah']) ? $element['#ahah'] : NULL,        );      }    }  }  return $element;}/** * Theme a form submit button. * * @ingroup themeable */function theme_submit($element) {  return theme('button', $element);}/** * Theme a form button. * * @ingroup themeable */function theme_button($element) {  // Make sure not to overwrite classes.  if (isset($element['#attributes']['class'])) {    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];  }  else {    $element['#attributes']['class'] = 'form-'. $element['#button_type'];  }  return '<input type="submit" '. (empty($element['#name']) ? '' : 'name="'. $element['#name'] .'" ') .'id="'. $element['#id'] .'" value="'. check_plain($element['#value']) .'" '. drupal_attributes($element['#attributes']) ." />\n";}/** * Theme a form image button. * * @ingroup themeable */function theme_image_button($element) {  // Make sure not to overwrite classes.  if (isset($element['#attributes']['class'])) {    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];  }  else {    $element['#attributes']['class'] = 'form-'. $element['#button_type'];  }  return '<input type="image" name="'. $element['#name'] .'" '.    (!empty($element['#value']) ? ('value="'. check_plain($element['#value']) .'" ') : '') .    'id="'. $element['#id'] .'" '.    drupal_attributes($element['#attributes']) .    ' src="'. base_path() . $element['#src'] .'" '.    (!empty($element['#title']) ? 'alt="'. check_plain($element['#title']) .'" title="'. check_plain($element['#title']) .'" ' : '' ) .    "/>\n";}/** * Format a hidden form field. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  value, edit * @return *   A themed HTML string representing the hidden form field. * * @ingroup themeable */function theme_hidden($element) {  return '<input type="hidden" name="'. $element['#name'] .'" id="'. $element['#id'] .'" value="'. check_plain($element['#value']) ."\" ". drupal_attributes($element['#attributes']) ." />\n";}/** * Format a form token. * * @ingroup themeable */function theme_token($element) {  return theme('hidden', $element);}/** * Format a textfield. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, size, maxlength, required, attributes autocomplete_path * @return *   A themed HTML string representing the textfield. * * @ingroup themeable */function theme_textfield($element) {  $size = empty($element['#size']) ? '' : ' size="'. $element['#size'] .'"';  $maxlength = empty($element['#maxlength']) ? '' : ' maxlength="'. $element['#maxlength'] .'"';  $class = array('form-text');  $extra = '';  $output = '';  if ($element['#autocomplete_path'] && menu_valid_path(array('link_path' => $element['#autocomplete_path']))) {    drupal_add_js('misc/autocomplete.js');    $class[] = 'form-autocomplete';    $extra =  '<input class="autocomplete" type="hidden" id="'. $element['#id'] .'-autocomplete" value="'. check_url(url($element['#autocomplete_path'], array('absolute' => TRUE))) .'" disabled="disabled" />';  }  _form_set_class($element, $class);  if (isset($element['#field_prefix'])) {    $output .= '<span class="field-prefix">'. $element['#field_prefix'] .'</span> ';  }  $output .= '<input type="text"'. $maxlength .' name="'. $element['#name'] .'" id="'. $element['#id'] .'"'. $size .' value="'. check_plain($element['#value']) .'"'. drupal_attributes($element['#attributes']) .' />';  if (isset($element['#field_suffix'])) {    $output .= ' <span class="field-suffix">'. $element['#field_suffix'] .'</span>';  }  return theme('form_element', $element, $output) . $extra;}/** * Format a form. * * @param $element *   An associative array containing the properties of the element. *   Properties used: action, method, attributes, children * @return *   A themed HTML string representing the form. * * @ingroup themeable */function theme_form($element) {  // Anonymous div to satisfy XHTML compliance.  $action = $element['#action'] ? 'action="'. check_url($element['#action']) .'" ' : '';  return '<form '. $action .' accept-charset="UTF-8" method="'. $element['#method'] .'" id="'. $element['#id'] .'"'. drupal_attributes($element['#attributes']) .">\n<div>". $element['#children'] ."\n</div></form>\n";}/** * Format a textarea. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, description, rows, cols, required, attributes * @return *   A themed HTML string representing the textarea. * * @ingroup themeable */function theme_textarea($element) {  $class = array('form-textarea');  // Add teaser behavior (must come before resizable)  if (!empty($element['#teaser'])) {    drupal_add_js('misc/teaser.js');    // Note: arrays are merged in drupal_get_js().    drupal_add_js(array('teaserCheckbox' => array($element['#id'] => $element['#teaser_checkbox'])), 'setting');    drupal_add_js(array('teaser' => array($element['#id'] => $element['#teaser'])), 'setting');    $class[] = 'teaser';  }  // Add resizable behavior  if ($element['#resizable'] !== FALSE) {    drupal_add_js('misc/textarea.js');    $class[] = 'resizable';  }  _form_set_class($element, $class);  return theme('form_element', $element, '<textarea cols="'. $element['#cols'] .'" rows="'. $element['#rows'] .'" name="'. $element['#name'] .'" id="'. $element['#id'] .'" '. drupal_attributes($element['#attributes']) .'>'. check_plain($element['#value']) .'</textarea>');}/** * Format HTML markup for use in forms. * * This is used in more advanced forms, such as theme selection and filter format. * * @param $element *   An associative array containing the properties of the element. *   Properties used: value, children. * @return *   A themed HTML string representing the HTML markup. * * @ingroup themeable */function theme_markup($element) {  return (isset($element['#value']) ? $element['#value'] : '') . (isset($element['#children']) ? $element['#children'] : '');}/** * Format a password field. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, size, maxlength, required, attributes * @return *   A themed HTML string representing the form. * * @ingroup themeable */function theme_password($element) {  $size = $element['#size'] ? ' size="'. $element['#size'] .'" ' : '';  $maxlength = $element['#maxlength'] ? ' maxlength="'. $element['#maxlength'] .'" ' : '';  _form_set_class($element, array('form-text'));  $output = '<input type="password" name="'. $element['#name'] .'" id="'. $element['#id'] .'" '. $maxlength . $size . drupal_attributes($element['#attributes']) .' />';  return theme('form_element', $element, $output);}/** * Expand weight elements into selects. */function process_weight($element) {  for ($n = (-1 * $element['#delta']); $n <= $element['#delta']; $n++) {    $weights[$n] = $n;  }  $element['#options'] = $weights;  $element['#type'] = 'select';  $element['#is_weight'] = TRUE;  $element += _element_info('select');  return $element;}/** * Format a file upload field. * * @param $title *   The label for the file upload field. * @param $name *   The internal name used to refer to the field. * @param $size *   A measure of the visible size of the field (passed directly to HTML). * @param $description *   Explanatory text to display after the form item. * @param $required *   Whether the user must upload a file to the field. * @return *   A themed HTML string representing the field. * * @ingroup themeable * * For assistance with handling the uploaded file correctly, see the API * provided by file.inc. */function theme_file($element) {  _form_set_class($element, array('form-file'));  return theme('form_element', $element, '<input type="file" name="'. $element['#name'] .'"'. ($element['#attributes'] ? ' '. drupal_attributes($element['#attributes']) : '') .' id="'. $element['#id'] .'" size="'. $element['#size'] ."\" />\n");}/** * Return a themed form element. * * @param element *   An associative array containing the properties of the element. *   Properties used: title, description, id, required * @param $value *   The form element's data. * @return *   A string representing the form element. * * @ingroup themeable */function theme_form_element($element, $value) {  // This is also used in the installer, pre-database setup.  $t = get_t();  $output = '<div class="form-item"';  if (!empty($element['#id'])) {    $output .= ' id="'. $element['#id'] .'-wrapper"';  }  $output .= ">\n";  $required = !empty($element['#required']) ? '<span class="form-required" title="'. $t('This field is required.') .'">*</span>' : '';  if (!empty($element['#title'])) {    $title = $element['#title'];    if (!empty($element['#id'])) {      $output .= ' <label for="'. $element['#id'] .'">'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";    }    else {      $output .= ' <label>'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";    }  }  $output .= " $value\n";  if (!empty($element['#description'])) {    $output .= ' <div class="description">'. $element['#description'] ."</div>\n";  }  $output .= "</div>\n";  return $output;}/** * Sets a form element's class attribute. * * Adds 'required' and 'error' classes as needed. * * @param &$element *   The form element. * @param $name *   Array of new class names to be added. */function _form_set_class(&$element, $class = array()) {  if ($element['#required']) {    $class[] = 'required';  }  if (form_get_error($element)) {    $class[] = 'error';  }  if (isset($element['#attributes']['class'])) {    $class[] = $element['#attributes']['class'];  }  $element['#attributes']['class'] = implode(' ', $class);}/** * Prepare an HTML ID attribute string for a form item. * * Remove invalid characters and guarantee uniqueness. * * @param $id *   The ID to clean. * @param $flush *   If set to TRUE, the function will flush and reset the static array *   which is built to test the uniqueness of element IDs. This is only *   used if a form has completed the validation process. This parameter *   should never be set to TRUE if this function is being called to *   assign an ID to the #ID element. * @return *   The cleaned ID. */function form_clean_id($id = NULL, $flush = FALSE) {  static $seen_ids = array();  if ($flush) {    $seen_ids = array();    return;  }  $id = str_replace(array('][', '_', ' '), '-', $id);  // Ensure IDs are unique. The first occurrence is held but left alone.  // Subsequent occurrences get a number appended to them. This incrementing  // will almost certainly break code that relies on explicit HTML IDs in  // forms that appear more than once on the page, but the alternative is  // outputting duplicate IDs, which would break JS code and XHTML  // validity anyways. For now, it's an acceptable stopgap solution.  if (isset($seen_ids[$id])) {    $id = $id .'-'. $seen_ids[$id]++;  }  else {    $seen_ids[$id] = 1;  }  return $id;}/** * @} End of "defgroup form_api". *//** * @defgroup batch Batch operations * @{ * Functions allowing forms processing to be spread out over several page * requests, thus ensuring that the processing does not get interrupted * because of a PHP timeout, while allowing the user to receive feedback * on the progress of the ongoing operations. * * The API is primarily designed to integrate nicely with the Form API * workflow, but can also be used by non-FAPI scripts (like update.php) * or even simple page callbacks (which should probably be used sparingly). * * Example: * @code * $batch = array( *   'title' => t('Exporting'), *   'operations' => array( *     array('my_function_1', array($account->uid, 'story')), *     array('my_function_2', array()), *   ), *   'finished' => 'my_finished_callback', *   'file' => 'path_to_file_containing_myfunctions', * ); * batch_set($batch); * // only needed if not inside a form _submit handler : * batch_process(); * @endcode * * Note: if the batch 'title', 'init_message', 'progress_message', or * 'error_message' could contain any user input, it is the responsibility of * the code calling batch_set() to sanitize them first with a function like * check_plain() or filter_xss(). * * Sample batch operations: * @code * // Simple and artificial: load a node of a given type for a given user * function my_function_1($uid, $type, &$context) { *   // The $context array gathers batch context information about the execution (read), *   // as well as 'return values' for the current operation (write) *   // The following keys are provided : *   // 'results' (read / write): The array of results gathered so far by *   //   the batch processing, for the current operation to append its own. *   // 'message' (write): A text message displayed in the progress page. *   // The following keys allow for multi-step operations : *   // 'sandbox' (read / write): An array that can be freely used to *   //   store persistent data between iterations. It is recommended to *   //   use this instead of $_SESSION, which is unsafe if the user *   //   continues browsing in a separate window while the batch is processing. *   // 'finished' (write): A float number between 0 and 1 informing *   //   the processing engine of the completion level for the operation. *   //   1 (or no value explicitly set) means the operation is finished *   //   and the batch processing can continue to the next operation. * *   $node = node_load(array('uid' => $uid, 'type' => $type)); *   $context['results'][] = $node->nid .' : '. $node->title; *   $context['message'] = $node->title; * } * * // More advanced example: multi-step operation - load all nodes, five by five * function my_function_2(&$context) { *   if (empty($context['sandbox'])) { *     $context['sandbox']['progress'] = 0; *     $context['sandbox']['current_node'] = 0; *     $context['sandbox']['max'] = db_result(db_query('SELECT COUNT(DISTINCT nid) FROM {node}')); *   } *   $limit = 5; *   $result = db_query_range("SELECT nid FROM {node} WHERE nid > %d ORDER BY nid ASC", $context['sandbox']['current_node'], 0, $limit); *   while ($row = db_fetch_array($result)) { *     $node = node_load($row['nid'], NULL, TRUE); *     $context['results'][] = $node->nid .' : '. $node->title; *     $context['sandbox']['progress']++; *     $context['sandbox']['current_node'] = $node->nid; *     $context['message'] = $node->title; *   } *   if ($context['sandbox']['progress'] != $context['sandbox']['max']) { *     $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max']; *   } * } * @endcode * * Sample 'finished' callback: * @code * function batch_test_finished($success, $results, $operations) { *   if ($success) { *     $message = format_plural(count($results), 'One post processed.', '@count posts processed.'); *   } *   else { *     $message = t('Finished with an error.'); *   } *   drupal_set_message($message); *   // Providing data for the redirected page is done through $_SESSION. *   foreach ($results as $result) { *     $items[] = t('Loaded node %title.', array('%title' => $result)); *   } *   $_SESSION['my_batch_results'] = $items; * } * @endcode *//** * Opens a new batch. * * @param $batch *   An array defining the batch. The following keys can be used -- only *   'operations' is required, and batch_init() provides default values for *   the messages. *   - 'operations': Array of function calls to be performed. *     Example: *     @code *     array( *       array('my_function_1', array($arg1)), *       array('my_function_2', array($arg2_1, $arg2_2)), *     ) *     @endcode *   - 'title': Title for the progress page. Only safe strings should be passed. *     Defaults to t('Processing'). *   - 'init_message': Message displayed while the processing is initialized. *     Defaults to t('Initializing.'). *   - 'progress_message': Message displayed while processing the batch. *     Available placeholders are @current, @remaining, @total, @percentage, *     @estimate and @elapsed. Defaults to t('Completed @current of @total.'). *   - 'error_message': Message displayed if an error occurred while processing *     the batch. Defaults to t('An error has occurred.'). *   - 'finished': Name of a function to be executed after the batch has *     completed. This should be used to perform any result massaging that *     may be needed, and possibly save data in $_SESSION for display after *     final page redirection. *   - 'file': Path to the file containing the definitions of the *     'operations' and 'finished' functions, for instance if they don't *     reside in the main .module file. The path should be relative to *     base_path(), and thus should be built using drupal_get_path(). * * Operations are added as new batch sets. Batch sets are used to ensure * clean code independence, ensuring that several batches submitted by * different parts of the code (core / contrib modules) can be processed * correctly while not interfering or having to cope with each other. Each * batch set gets to specify his own UI messages, operates on its own set * of operations and results, and triggers its own 'finished' callback. * Batch sets are processed sequentially, with the progress bar starting * fresh for every new set. */function batch_set($batch_definition) {  if ($batch_definition) {    $batch =& batch_get();    // Initialize the batch    if (empty($batch)) {      $batch = array(        'sets' => array(),      );    }    $init = array(      'sandbox' => array(),      'results' => array(),      'success' => FALSE,    );    // Use get_t() to allow batches at install time.    $t = get_t();    $defaults = array(      'title' => $t('Processing'),      'init_message' => $t('Initializing.'),      'progress_message' => $t('Remaining @remaining of @total.'),      'error_message' => $t('An error has occurred.'),    );    $batch_set = $init + $batch_definition + $defaults;    // Tweak init_message to avoid the bottom of the page flickering down after init phase.    $batch_set['init_message'] .= '<br/>&nbsp;';    $batch_set['total'] = count($batch_set['operations']);    // If the batch is being processed (meaning we are executing a stored submit handler),    // insert the new set after the current one.    if (isset($batch['current_set'])) {      // array_insert does not exist...      $slice1 = array_slice($batch['sets'], 0, $batch['current_set'] + 1);      $slice2 = array_slice($batch['sets'], $batch['current_set'] + 1);      $batch['sets'] = array_merge($slice1, array($batch_set), $slice2);    }    else {      $batch['sets'][] = $batch_set;    }  }}/** * Processes the batch. * * Unless the batch has been marked with 'progressive' = FALSE, the function * issues a drupal_goto and thus ends page execution. * * This function is not needed in form submit handlers; Form API takes care * of batches that were set during form submission. * * @param $redirect *   (optional) Path to redirect to when the batch has finished processing. * @param $url *   (optional - should only be used for separate scripts like update.php) *   URL of the batch processing page. */function batch_process($redirect = NULL, $url = NULL) {  $batch =& batch_get();  if (isset($batch)) {    // Add process information    $url = isset($url) ? $url : 'batch';    $process_info = array(      'current_set' => 0,      'progressive' => TRUE,      'url' => isset($url) ? $url : 'batch',      'source_page' => $_GET['q'],      'redirect' => $redirect,    );    $batch += $process_info;    if ($batch['progressive']) {      // Clear the way for the drupal_goto redirection to the batch processing      // page, by saving and unsetting the 'destination' if any, on both places      // drupal_goto looks for it.      if (isset($_REQUEST['destination'])) {        $batch['destination'] = $_REQUEST['destination'];        unset($_REQUEST['destination']);      }      elseif (isset($_REQUEST['edit']['destination'])) {        $batch['destination'] = $_REQUEST['edit']['destination'];        unset($_REQUEST['edit']['destination']);      }      // Initiate db storage in order to get a batch id. We have to provide      // at least an empty string for the (not null) 'token' column.      db_query("INSERT INTO {batch} (token, timestamp) VALUES ('', %d)", time());      $batch['id'] = db_last_insert_id('batch', 'bid');      // Now that we have a batch id, we can generate the redirection link in      // the generic error message.      $t = get_t();      $batch['error_message'] = $t('Please continue to <a href="@error_url">the error page</a>', array('@error_url' => url($url, array('query' => array('id' => $batch['id'], 'op' => 'finished')))));      // Actually store the batch data and the token generated form the batch id.      db_query("UPDATE {batch} SET token = '%s', batch = '%s' WHERE bid = %d", drupal_get_token($batch['id']), serialize($batch), $batch['id']);      drupal_goto($batch['url'], 'op=start&id='. $batch['id']);    }    else {      // Non-progressive execution: bypass the whole progressbar workflow      // and execute the batch in one pass.      require_once './includes/batch.inc';      _batch_process();    }  }}/** * Retrieves the current batch. */function &batch_get() {  static $batch = array();  return $batch;}/** * @} End of "defgroup batch". */
<?php// $Id$require_once './includes/install.inc';define('MAINTENANCE_MODE', 'install');/** * The Drupal installation happens in a series of steps. We begin by verifying * that the current environment meets our minimum requirements. We then go * on to verify that settings.php is properly configured. From there we * connect to the configured database and verify that it meets our minimum * requirements. Finally we can allow the user to select an installation * profile and complete the installation process. * * @param $phase *   The installation phase we should proceed to. */function install_main() {  require_once './includes/bootstrap.inc';  drupal_bootstrap(DRUPAL_BOOTSTRAP_CONFIGURATION);  // This must go after drupal_bootstrap(), which unsets globals!  global $profile, $install_locale, $conf;  require_once './modules/system/system.install';  require_once './includes/file.inc';  // Ensure correct page headers are sent (e.g. caching)  drupal_page_header();  // Set up $language, so t() caller functions will still work.  drupal_init_language();  // Load module basics (needed for hook invokes).  include_once './includes/module.inc';  $module_list['system']['filename'] = 'modules/system/system.module';  $module_list['filter']['filename'] = 'modules/filter/filter.module';  module_list(TRUE, FALSE, FALSE, $module_list);  drupal_load('module', 'system');  drupal_load('module', 'filter');  // Install profile chosen, set the global immediately.  // This needs to be done before the theme cache gets   // initialized in drupal_maintenance_theme().  if (!empty($_GET['profile'])) {    $profile = preg_replace('/[^a-zA-Z_0-9]/', '', $_GET['profile']);  }  // Set up theme system for the maintenance page.  drupal_maintenance_theme();  // Check existing settings.php.  $verify = install_verify_settings();  if ($verify) {    // Since we have a database connection, we use the normal cache system.    // This is important, as the installer calls into the Drupal system for    // the clean URL checks, so we should maintain the cache properly.    require_once './includes/cache.inc';    $conf['cache_inc'] = './includes/cache.inc';    // Establish a connection to the database.    require_once './includes/database.inc';    db_set_active();    // Check if Drupal is installed.    $task = install_verify_drupal();    if ($task == 'done') {      install_already_done_error();    }  }  else {    // Since no persistent storage is available yet, and functions that check    // for cached data will fail, we temporarily replace the normal cache    // system with a stubbed-out version that short-circuits the actual    // caching process and avoids any errors.    require_once './includes/cache-install.inc';    $conf['cache_inc'] = './includes/cache-install.inc';    $task = NULL;  }  // No profile was passed in GET, ask the user.  if (empty($_GET['profile'])) {    if ($profile = install_select_profile()) {      install_goto("install.php?profile=$profile");    }    else {      install_no_profile_error();    }  }  // Load the profile.  require_once "./profiles/$profile/$profile.profile";  // Locale selection  if (!empty($_GET['locale'])) {    $install_locale = preg_replace('/[^a-zA-Z_0-9\-]/', '', $_GET['locale']);  }  elseif (($install_locale = install_select_locale($profile)) !== FALSE) {    install_goto("install.php?profile=$profile&locale=$install_locale");  }  // Tasks come after the database is set up  if (!$task) {    global $db_url;    if (!$verify && !empty($db_url)) {      // Do not install over a configured settings.php.      install_already_done_error();    }    // Check the installation requirements for Drupal and this profile.    install_check_requirements($profile, $verify);    // Verify existence of all required modules.    $modules = drupal_verify_profile($profile, $install_locale);    // If any error messages are set now, it means a requirement problem.    $messages = drupal_set_message();    if (!empty($messages['error'])) {      install_task_list('requirements');      drupal_set_title(st('Requirements problem'));      print theme('install_page', '');      exit;    }    // Change the settings.php information if verification failed earlier.    // Note: will trigger a redirect if database credentials change.    if (!$verify) {      install_change_settings($profile, $install_locale);    }    // Install system.module.    drupal_install_system();    // Save the list of other modules to install for the 'profile-install'    // task. variable_set() can be used now that system.module is installed    // and drupal is bootstrapped.    variable_set('install_profile_modules', array_diff($modules, array('system')));  }  // The database is set up, turn to further tasks.  install_tasks($profile, $task);}/** * Verify if Drupal is installed. */function install_verify_drupal() {  // Read the variable manually using the @ so we don't trigger an error if it fails.  $result = @db_query("SELECT value FROM {variable} WHERE name = '%s'", 'install_task');  if ($result) {    return unserialize(db_result($result));  }}/** * Verify existing settings.php */function install_verify_settings() {  global $db_prefix, $db_type, $db_url;  // Verify existing settings (if any).  if (!empty($db_url)) {    // We need this because we want to run form_get_errors.    include_once './includes/form.inc';    $url = parse_url(is_array($db_url) ? $db_url['default'] : $db_url);    $db_user = urldecode($url['user']);    $db_pass = isset($url['pass']) ? urldecode($url['pass']) : NULL;    $db_host = urldecode($url['host']);    $db_port = isset($url['port']) ? urldecode($url['port']) : '';    $db_path = ltrim(urldecode($url['path']), '/');    $settings_file = './'. conf_path(FALSE, TRUE) .'/settings.php';    $form_state = array();    _install_settings_form_validate($db_prefix, $db_type, $db_user, $db_pass, $db_host, $db_port, $db_path, $settings_file, $form_state);    if (!form_get_errors()) {      return TRUE;    }  }  return FALSE;}/** * Configure and rewrite settings.php. */function install_change_settings($profile = 'default', $install_locale = '') {  global $db_url, $db_type, $db_prefix;  $url = parse_url(is_array($db_url) ? $db_url['default'] : $db_url);  $db_user = isset($url['user']) ? urldecode($url['user']) : '';  $db_pass = isset($url['pass']) ? urldecode($url['pass']) : '';  $db_host = isset($url['host']) ? urldecode($url['host']) : '';  $db_port = isset($url['port']) ? urldecode($url['port']) : '';  $db_path = ltrim(urldecode($url['path']), '/');  $conf_path = './'. conf_path(FALSE, TRUE);  $settings_file = $conf_path .'/settings.php';  // We always need this because we want to run form_get_errors.  include_once './includes/form.inc';  install_task_list('database');  $output = drupal_get_form('install_settings_form', $profile, $install_locale, $settings_file, $db_url, $db_type, $db_prefix, $db_user, $db_pass, $db_host, $db_port, $db_path);  drupal_set_title(st('Database configuration'));  print theme('install_page', $output);  exit;}/** * Form API array definition for install_settings. */function install_settings_form(&$form_state, $profile, $install_locale, $settings_file, $db_url, $db_type, $db_prefix, $db_user, $db_pass, $db_host, $db_port, $db_path) {  if (empty($db_host)) {    $db_host = 'localhost';  }  $db_types = drupal_detect_database_types();  // If both 'mysql' and 'mysqli' are available, we disable 'mysql':  if (isset($db_types['mysqli'])) {    unset($db_types['mysql']);  }  if (count($db_types) == 0) {    $form['no_db_types'] = array(      '#value' => st('Your web server does not appear to support any common database types. Check with your hosting provider to see if they offer any databases that <a href="@drupal-databases">Drupal supports</a>.', array('@drupal-databases' => 'http://drupal.org/node/270#database')),    );  }  else {    $form['basic_options'] = array(      '#type' => 'fieldset',      '#title' => st('Basic options'),      '#description' => '<p>'. st('To set up your @drupal database, enter the following information.', array('@drupal' => drupal_install_profile_name())) .'</p>',    );    if (count($db_types) > 1) {      $form['basic_options']['db_type'] = array(        '#type' => 'radios',        '#title' => st('Database type'),        '#required' => TRUE,        '#options' => $db_types,        '#default_value' => ($db_type ? $db_type : current($db_types)),        '#description' => st('The type of database your @drupal data will be stored in.', array('@drupal' => drupal_install_profile_name())),      );      $db_path_description = st('The name of the database your @drupal data will be stored in. It must exist on your server before @drupal can be installed.', array('@drupal' => drupal_install_profile_name()));    }    else {      if (count($db_types) == 1) {        $db_types = array_values($db_types);        $form['basic_options']['db_type'] = array(          '#type' => 'hidden',          '#value' => $db_types[0],        );        $db_path_description = st('The name of the %db_type database your @drupal data will be stored in. It must exist on your server before @drupal can be installed.', array('%db_type' => $db_types[0], '@drupal' => drupal_install_profile_name()));      }    }    // Database name    $form['basic_options']['db_path'] = array(      '#type' => 'textfield',      '#title' => st('Database name'),      '#default_value' => $db_path,      '#size' => 45,      '#required' => TRUE,      '#description' => $db_path_description    );    // Database username    $form['basic_options']['db_user'] = array(      '#type' => 'textfield',      '#title' => st('Database username'),      '#default_value' => $db_user,      '#size' => 45,      '#required' => TRUE,    );    // Database username    $form['basic_options']['db_pass'] = array(      '#type' => 'password',      '#title' => st('Database password'),      '#default_value' => $db_pass,      '#size' => 45,    );    $form['advanced_options'] = array(      '#type' => 'fieldset',      '#title' => st('Advanced options'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#description' => st("These options are only necessary for some sites. If you're not sure what you should enter here, leave the default settings or check with your hosting provider.")    );    // Database host    $form['advanced_options']['db_host'] = array(      '#type' => 'textfield',      '#title' => st('Database host'),      '#default_value' => $db_host,      '#size' => 45,      // Hostnames can be 255 characters long.      '#maxlength' => 255,      '#required' => TRUE,      '#description' => st('If your database is located on a different server, change this.'),    );    // Database port    $form['advanced_options']['db_port'] = array(      '#type' => 'textfield',      '#title' => st('Database port'),      '#default_value' => $db_port,      '#size' => 45,      // The maximum port number is 65536, 5 digits.      '#maxlength' => 5,      '#description' => st('If your database server is listening to a non-standard port, enter its number.'),    );    // Table prefix    $prefix = ($profile == 'default') ? 'drupal_' : $profile .'_';    $form['advanced_options']['db_prefix'] = array(      '#type' => 'textfield',      '#title' => st('Table prefix'),      '#default_value' => $db_prefix,      '#size' => 45,      '#description' => st('If more than one application will be sharing this database, enter a table prefix such as %prefix for your @drupal site here.', array('@drupal' => drupal_install_profile_name(), '%prefix' => $prefix)),    );    $form['save'] = array(      '#type' => 'submit',      '#value' => st('Save and continue'),    );    $form['errors'] = array();    $form['settings_file'] = array('#type' => 'value', '#value' => $settings_file);    $form['_db_url'] = array('#type' => 'value');    $form['#action'] = "install.php?profile=$profile". ($install_locale ? "&locale=$install_locale" : '');    $form['#redirect'] = FALSE;  }  return $form;}/** * Form API validate for install_settings form. */function install_settings_form_validate($form, &$form_state) {  global $db_url;  _install_settings_form_validate($form_state['values']['db_prefix'], $form_state['values']['db_type'], $form_state['values']['db_user'], $form_state['values']['db_pass'], $form_state['values']['db_host'], $form_state['values']['db_port'], $form_state['values']['db_path'], $form_state['values']['settings_file'], $form_state, $form);}/** * Helper function for install_settings_validate. */function _install_settings_form_validate($db_prefix, $db_type, $db_user, $db_pass, $db_host, $db_port, $db_path, $settings_file, &$form_state, $form = NULL) {  global $db_url;  // Verify the table prefix  if (!empty($db_prefix) && is_string($db_prefix) && !preg_match('/^[A-Za-z0-9_.]+$/', $db_prefix)) {    form_set_error('db_prefix', st('The database table prefix you have entered, %db_prefix, is invalid. The table prefix can only contain alphanumeric characters, periods, or underscores.', array('%db_prefix' => $db_prefix)), 'error');  }  if (!empty($db_port) && !is_numeric($db_port)) {    form_set_error('db_port', st('Database port must be a number.'));  }  // Check database type  if (!isset($form)) {    $_db_url = is_array($db_url) ? $db_url['default'] : $db_url;    $db_type = substr($_db_url, 0, strpos($_db_url, '://'));  }  $databases = drupal_detect_database_types();  if (!in_array($db_type, $databases)) {    form_set_error('db_type', st("In your %settings_file file you have configured @drupal to use a %db_type server, however your PHP installation currently does not support this database type.", array('%settings_file' => $settings_file, '@drupal' => drupal_install_profile_name(), '%db_type' => $db_type)));  }  else {    // Verify    $db_url = $db_type .'://'. urlencode($db_user) . ($db_pass ? ':'. urlencode($db_pass) : '') .'@'. ($db_host ? urlencode($db_host) : 'localhost') . ($db_port ? ":$db_port" : '') .'/'. urlencode($db_path);    if (isset($form)) {      form_set_value($form['_db_url'], $db_url, $form_state);    }    $success = array();    $function = 'drupal_test_'. $db_type;    if (!$function($db_url, $success)) {      if (isset($success['CONNECT'])) {        form_set_error('db_type', st('In order for Drupal to work, and to continue with the installation process, you must resolve all permission issues reported above. We were able to verify that we have permission for the following commands: %commands. For more help with configuring your database server, see the <a href="http://drupal.org/node/258">Installation and upgrading handbook</a>. If you are unsure what any of this means you should probably contact your hosting provider.', array('%commands' => implode($success, ', '))));      }      else {        form_set_error('db_type', '');      }    }  }}/** * Form API submit for install_settings form. */function install_settings_form_submit($form, &$form_state) {  global $profile, $install_locale;  // Update global settings array and save  $settings['db_url'] = array(    'value'    => $form_state['values']['_db_url'],    'required' => TRUE,  );  $settings['db_prefix'] = array(    'value'    => $form_state['values']['db_prefix'],    'required' => TRUE,  );  drupal_rewrite_settings($settings);  // Continue to install profile step  install_goto("install.php?profile=$profile". ($install_locale ? "&locale=$install_locale" : ''));}/** * Find all .profile files. */function install_find_profiles() {  return file_scan_directory('./profiles', '\.profile$', array('.', '..', 'CVS'), 0, TRUE, 'name', 0);}/** * Allow admin to select which profile to install. * * @return *   The selected profile. */function install_select_profile() {  include_once './includes/form.inc';  $profiles = install_find_profiles();  // Don't need to choose profile if only one available.  if (sizeof($profiles) == 1) {    $profile = array_pop($profiles);    require_once $profile->filename;    return $profile->name;  }  elseif (sizeof($profiles) > 1) {    foreach ($profiles as $profile) {      if (!empty($_POST['profile']) && ($_POST['profile'] == $profile->name)) {        return $profile->name;      }    }    install_task_list('profile-select');    drupal_set_title(st('Select an installation profile'));    print theme('install_page', drupal_get_form('install_select_profile_form', $profiles));    exit;  }}/** * Form API array definition for the profile selection form. * * @param $form_state *   Array of metadata about state of form processing. * @param $profile_files *   Array of .profile files, as returned from file_scan_directory(). */function install_select_profile_form(&$form_state, $profile_files) {  $profiles = array();  $names = array();  foreach ($profile_files as $profile) {    include_once($profile->filename);    // Load profile details and store them for later retrieval.    $function = $profile->name .'_profile_details';    if (function_exists($function)) {      $details = $function();    }    $profiles[$profile->name] = $details;    // Determine the name of the profile; default to file name if defined name    // is unspecified.    $name = isset($details['name']) ? $details['name'] : $profile->name;    $names[$profile->name] = $name;  }  // Display radio buttons alphabetically by human-readable name.   natcasesort($names);  foreach ($names as $profile => $name) {    $form['profile'][$name] = array(      '#type' => 'radio',      '#value' => 'default',      '#return_value' => $profile,      '#title' => $name,      '#description' => isset($profiles[$profile]['description']) ? $profiles[$profile]['description'] : '',      '#parents' => array('profile'),    );  }  $form['submit'] =  array(    '#type' => 'submit',    '#value' => st('Save and continue'),  );  return $form;}/** * Find all .po files for the current profile. */function install_find_locales($profilename) {  $locales = file_scan_directory('./profiles/'. $profilename .'/translations', '\.po$', array('.', '..', 'CVS'), 0, FALSE);  array_unshift($locales, (object) array('name' => 'en'));  return $locales;}/** * Allow admin to select which locale to use for the current profile. * * @return *   The selected language. */function install_select_locale($profilename) {  include_once './includes/file.inc';  include_once './includes/form.inc';  // Find all available locales.  $locales = install_find_locales($profilename);  // If only the built-in (English) language is available,  // and we are using the default profile, inform the user  // that the installer can be localized. Otherwise we assume  // the user know what he is doing.  if (count($locales) == 1) {    if ($profilename == 'default') {      install_task_list('locale-select');      drupal_set_title(st('Choose language'));      if (!empty($_GET['localize'])) {        $output = '<p>'. st('With the addition of an appropriate translation package, this installer is capable of proceeding in another language of your choice. To install and use Drupal in a language other than English:') .'</p>';        $output .= '<ul><li>'. st('Determine if <a href="@translations" target="_blank">a translation of this Drupal version</a> is available in your language of choice. A translation is provided via a translation package; each translation package enables the display of a specific version of Drupal in a specific language. Not all languages are available for every version of Drupal.', array('@translations' => 'http://drupal.org/project/translations')) .'</li>';        $output .= '<li>'. st('If an alternative translation package of your choice is available, download and extract its contents to your Drupal root directory.') .'</li>';        $output .= '<li>'. st('Return to choose language using the second link below and select your desired language from the displayed list. Reloading the page allows the list to automatically adjust to the presence of new translation packages.') .'</li>';        $output .= '</ul><p>'. st('Alternatively, to install and use Drupal in English, or to defer the selection of an alternative language until after installation, select the first link below.') .'</p>';        $output .= '<p>'. st('How should the installation continue?') .'</p>';        $output .= '<ul><li><a href="install.php?profile='. $profilename .'&amp;locale=en">'. st('Continue installation in English') .'</a></li><li><a href="install.php?profile='. $profilename .'">'. st('Return to choose a language') .'</a></li></ul>';      }      else {        $output = '<ul><li><a href="install.php?profile='. $profilename .'&amp;locale=en">'. st('Install Drupal in English') .'</a></li><li><a href="install.php?profile='. $profilename .'&amp;localize=true">'. st('Learn how to install Drupal in other languages') .'</a></li></ul>';      }      print theme('install_page', $output);      exit;    }    // One language, but not the default profile, assume    // the user knows what he is doing.    return FALSE;  }  else {    // Allow profile to pre-select the language, skipping the selection.    $function = $profilename .'_profile_details';    if (function_exists($function)) {      $details = $function();      if (isset($details['language'])) {        foreach ($locales as $locale) {          if ($details['language'] == $locale->name) {            return $locale->name;          }        }      }    }    if (!empty($_POST['locale'])) {      foreach ($locales as $locale) {        if ($_POST['locale'] == $locale->name) {          return $locale->name;        }      }    }    install_task_list('locale-select');    drupal_set_title(st('Choose language'));    print theme('install_page', drupal_get_form('install_select_locale_form', $locales));    exit;  }}/** * Form API array definition for language selection. */function install_select_locale_form(&$form_state, $locales) {  include_once './includes/locale.inc';  $languages = _locale_get_predefined_list();  foreach ($locales as $locale) {    // Try to use verbose locale name    $name = $locale->name;    if (isset($languages[$name])) {      $name = $languages[$name][0] . (isset($languages[$name][1]) ? ' '. st('(@language)', array('@language' => $languages[$name][1])) : '');    }    $form['locale'][$locale->name] = array(      '#type' => 'radio',      '#return_value' => $locale->name,      '#default_value' => ($locale->name == 'en' ? TRUE : FALSE),      '#title' => $name . ($locale->name == 'en' ? ' '. st('(built-in)') : ''),      '#parents' => array('locale')    );  }  $form['submit'] =  array(    '#type' => 'submit',    '#value' => st('Select language'),  );  return $form;}/** * Show an error page when there are no profiles available. */function install_no_profile_error() {  install_task_list('profile-select');  drupal_set_title(st('No profiles available'));  print theme('install_page', '<p>'. st('We were unable to find any installer profiles. Installer profiles tell us what modules to enable and what schema to install in the database. A profile is necessary to continue with the installation process.') .'</p>');  exit;}/** * Show an error page when Drupal has already been installed. */function install_already_done_error() {  global $base_url;  drupal_set_title(st('Drupal already installed'));  print theme('install_page', st('<ul><li>To start over, you must empty your existing database.</li><li>To install to a different database, edit the appropriate <em>settings.php</em> file in the <em>sites</em> folder.</li><li>To upgrade an existing installation, proceed to the <a href="@base-url/update.php">update script</a>.</li><li>View your <a href="@base-url">existing site</a>.</li></ul>', array('@base-url' => $base_url)));  exit;}/** * Tasks performed after the database is initialized. */function install_tasks($profile, $task) {  global $base_url, $install_locale;  // Bootstrap newly installed Drupal, while preserving existing messages.  $messages = isset($_SESSION['messages']) ? $_SESSION['messages'] : '';  drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);  $_SESSION['messages'] = $messages;  // URL used to direct page requests.  $url = $base_url .'/install.php?locale='. $install_locale .'&profile='. $profile;  // Build a page for final tasks.  if (empty($task)) {    variable_set('install_task', 'profile-install');    $task = 'profile-install';  }  // We are using a list of if constructs here to allow for  // passing from one task to the other in the same request.  // Install profile modules.  if ($task == 'profile-install') {    $modules = variable_get('install_profile_modules', array());    $files = module_rebuild_cache();    variable_del('install_profile_modules');    $operations = array();    foreach ($modules as $module) {      $operations[] = array('_install_module_batch', array($module, $files[$module]->info['name']));    }    $batch = array(      'operations' => $operations,      'finished' => '_install_profile_batch_finished',      'title' => st('Installing @drupal', array('@drupal' => drupal_install_profile_name())),      'error_message' => st('The installation has encountered an error.'),    );    // Start a batch, switch to 'profile-install-batch' task. We need to    // set the variable here, because batch_process() redirects.    variable_set('install_task', 'profile-install-batch');    batch_set($batch);    batch_process($url, $url);  }  // We are running a batch install of the profile's modules.  // This might run in multiple HTTP requests, constantly redirecting  // to the same address, until the batch finished callback is invoked  // and the task advances to 'locale-initial-import'.  if ($task == 'profile-install-batch') {    include_once 'includes/batch.inc';    $output = _batch_page();  }  // Import interface translations for the enabled modules.  if ($task == 'locale-initial-import') {    if (!empty($install_locale) && ($install_locale != 'en')) {      include_once 'includes/locale.inc';      // Enable installation language as default site language.      locale_add_language($install_locale, NULL, NULL, NULL, NULL, NULL, 1, TRUE);      // Collect files to import for this language.      $batch = locale_batch_by_language($install_locale, '_install_locale_initial_batch_finished');      if (!empty($batch)) {        // Remember components we cover in this batch set.        variable_set('install_locale_batch_components', $batch['#components']);        // Start a batch, switch to 'locale-batch' task. We need to        // set the variable here, because batch_process() redirects.        variable_set('install_task', 'locale-initial-batch');        batch_set($batch);        batch_process($url, $url);      }    }    // Found nothing to import or not foreign language, go to next task.    $task = 'configure';  }  if ($task == 'locale-initial-batch') {    include_once 'includes/batch.inc';    include_once 'includes/locale.inc';    $output = _batch_page();  }  if ($task == 'configure') {    if (variable_get('site_name', FALSE) || variable_get('site_mail', FALSE)) {      // Site already configured: This should never happen, means re-running      // the installer, possibly by an attacker after the 'install_task' variable      // got accidentally blown somewhere. Stop it now.      install_already_done_error();    }    $form = drupal_get_form('install_configure_form', $url);    if (!variable_get('site_name', FALSE) && !variable_get('site_mail', FALSE)) {      // Not submitted yet: Prepare to display the form.      $output = $form;      drupal_set_title(st('Configure site'));      // Warn about settings.php permissions risk      $settings_dir = './'. conf_path();      $settings_file = $settings_dir .'/settings.php';      if (!drupal_verify_install_file($settings_file, FILE_EXIST|FILE_READABLE|FILE_NOT_WRITABLE) || !drupal_verify_install_file($settings_dir, FILE_NOT_WRITABLE, 'dir')) {        drupal_set_message(st('All necessary changes to %dir and %file have been made, so you should remove write permissions to them now in order to avoid security risks. If you are unsure how to do so, please consult the <a href="@handbook_url">on-line handbook</a>.', array('%dir' => $settings_dir, '%file' => $settings_file, '@handbook_url' => 'http://drupal.org/getting-started')), 'error');      }      else {        drupal_set_message(st('All necessary changes to %dir and %file have been made. They have been set to read-only for security.', array('%dir' => $settings_dir, '%file' => $settings_file)));      }      // Add JavaScript validation.      _user_password_dynamic_validation();      drupal_add_js(drupal_get_path('module', 'system') .'/system.js', 'module');      // We add these strings as settings because JavaScript translation does not      // work on install time.      drupal_add_js(array('copyFieldValue' => array('edit-site-mail' => array('edit-account-mail')), 'cleanURL' => array('success' => st('Your server has been successfully tested to support this feature.'), 'failure' => st('Your system configuration does not currently support this feature. The <a href="http://drupal.org/node/15365">handbook page on Clean URLs</a> has additional troubleshooting information.'), 'testing' => st('Testing clean URLs...'))), 'setting');      drupal_add_js('// Global Killswitchif (Drupal.jsEnabled) {  $(document).ready(function() {    Drupal.cleanURLsInstallCheck();    Drupal.setDefaultTimezone();  });}', 'inline');      // Build menu to allow clean URL check.      menu_rebuild();    }    else {      $task = 'profile';    }  }  // If found an unknown task or the 'profile' task, which is  // reserved for profiles, hand over the control to the profile,  // so it can run any number of custom tasks it defines.  if (!in_array($task, install_reserved_tasks())) {    $function = $profile .'_profile_tasks';    if (function_exists($function)) {      // The profile needs to run more code, maybe even more tasks.      // $task is sent through as a reference and may be changed!      $output = $function($task, $url);    }    // If the profile doesn't move on to a new task we assume    // that it is done.    if ($task == 'profile') {      $task = 'profile-finished';    }  }  // Profile custom tasks are done, so let the installer regain  // control and proceed with importing the remaining translations.  if ($task == 'profile-finished') {    if (!empty($install_locale) && ($install_locale != 'en')) {      include_once 'includes/locale.inc';      // Collect files to import for this language. Skip components      // already covered in the initial batch set.      $batch = locale_batch_by_language($install_locale, '_install_locale_remaining_batch_finished', variable_get('install_locale_batch_components', array()));      // Remove temporary variable.      variable_del('install_locale_batch_components');      if (!empty($batch)) {        // Start a batch, switch to 'locale-remaining-batch' task. We need to        // set the variable here, because batch_process() redirects.        variable_set('install_task', 'locale-remaining-batch');        batch_set($batch);        batch_process($url, $url);      }    }    // Found nothing to import or not foreign language, go to next task.    $task = 'finished';  }  if ($task == 'locale-remaining-batch') {    include_once 'includes/batch.inc';    include_once 'includes/locale.inc';    $output = _batch_page();  }  // Display a 'finished' page to user.  if ($task == 'finished') {    drupal_set_title(st('@drupal installation complete', array('@drupal' => drupal_install_profile_name())));    $messages = drupal_set_message();    $output = '<p>'. st('Congratulations, @drupal has been successfully installed.', array('@drupal' => drupal_install_profile_name())) .'</p>';    $output .= '<p>'. (isset($messages['error']) ? st('Please review the messages above before continuing on to <a href="@url">your new site</a>.', array('@url' => url(''))) : st('You may now visit <a href="@url">your new site</a>.', array('@url' => url('')))) .'</p>';    $task = 'done';  }  // The end of the install process. Remember profile used.  if ($task == 'done') {    // Rebuild menu to get content type links registered by the profile,    // and possibly any other menu items created through the tasks.    menu_rebuild();    // Register actions declared by any modules.    actions_synchronize();    // Randomize query-strings on css/js files, to hide the fact that    // this is a new install, not upgraded yet.    _drupal_flush_css_js();    variable_set('install_profile', $profile);  }  // Set task for user, and remember the task in the database.  install_task_list($task);  variable_set('install_task', $task);  // Output page, if some output was required. Otherwise it is possible  // that we are printing a JSON page and theme output should not be there.  if (isset($output)) {    print theme('maintenance_page', $output);  }}/** * Batch callback for batch installation of modules. */function _install_module_batch($module, $module_name, &$context) {  _drupal_install_module($module);  // We enable the installed module right away, so that the module will be  // loaded by drupal_bootstrap in subsequent batch requests, and other  // modules possibly depending on it can safely perform their installation  // steps.  module_enable(array($module));  $context['results'][] = $module;  $context['message'] = st('Installed %module module.', array('%module' => $module_name));}/** * Finished callback for the modules install batch. * * Advance installer task to language import. */function _install_profile_batch_finished($success, $results) {  variable_set('install_task', 'locale-initial-import');}/** * Finished callback for the first locale import batch. * * Advance installer task to the configure screen. */function _install_locale_initial_batch_finished($success, $results) {  variable_set('install_task', 'configure');}/** * Finished callback for the second locale import batch. * * Advance installer task to the finished screen. */function _install_locale_remaining_batch_finished($success, $results) {  variable_set('install_task', 'finished');}/** * The list of reserved tasks to run in the installer. */function install_reserved_tasks() {  return array('configure', 'profile-install', 'profile-install-batch', 'locale-initial-import', 'locale-initial-batch', 'profile-finished', 'locale-remaining-batch', 'finished', 'done');}/** * Check installation requirements and report any errors. */function install_check_requirements($profile, $verify) {  // If Drupal is not set up already, we need to create a settings file.  if (!$verify) {    $writable = FALSE;    $conf_path = './'. conf_path(FALSE, TRUE);    $settings_file = $conf_path .'/settings.php';    $file = $conf_path;    $exists = FALSE;    // Verify that the directory exists.    if (drupal_verify_install_file($conf_path, FILE_EXIST, 'dir')) {      // Check to make sure a settings.php already exists.      $file = $settings_file;      if (drupal_verify_install_file($settings_file, FILE_EXIST)) {        $exists = TRUE;        // If it does, make sure it is writable.        $writable = drupal_verify_install_file($settings_file, FILE_READABLE|FILE_WRITABLE);      }    }    if (!$exists) {      drupal_set_message(st('The @drupal installer requires that you create a settings file as part of the installation process.<ol><li>Copy the %default_file file to %file.</li><li>Change file permissions so that it is writable by the web server. If you are unsure how to grant file permissions, please consult the <a href="@handbook_url">on-line handbook</a>.</li></ol>More details about installing Drupal are available in INSTALL.txt.', array('@drupal' => drupal_install_profile_name(), '%file' => $file, '%default_file' => $conf_path .'/default.settings.php', '@handbook_url' => 'http://drupal.org/server-permissions')), 'error');    }    elseif (!$writable) {      drupal_set_message(st('The @drupal installer requires write permissions to %file during the installation process. If you are unsure how to grant file permissions, please consult the <a href="@handbook_url">on-line handbook</a>.', array('@drupal' => drupal_install_profile_name(), '%file' => $file, '@handbook_url' => 'http://drupal.org/server-permissions')), 'error');    }  }  // Check the other requirements.  $requirements = drupal_check_profile($profile);  $severity = drupal_requirements_severity($requirements);  // If there are issues, report them.  if ($severity == REQUIREMENT_ERROR) {    foreach ($requirements as $requirement) {      if (isset($requirement['severity']) && $requirement['severity'] == REQUIREMENT_ERROR) {        $message = $requirement['description'];        if (isset($requirement['value']) && $requirement['value']) {          $message .= ' ('. st('Currently using !item !version', array('!item' => $requirement['title'], '!version' => $requirement['value'])) .')';        }        drupal_set_message($message, 'error');      }    }  }  if ($severity == REQUIREMENT_WARNING) {    foreach ($requirements as $requirement) {      if (isset($requirement['severity']) && $requirement['severity'] == REQUIREMENT_WARNING) {        $message = $requirement['description'];        if (isset($requirement['value']) && $requirement['value']) {          $message .= ' ('. st('Currently using !item !version', array('!item' => $requirement['title'], '!version' => $requirement['value'])) .')';        }        drupal_set_message($message, 'warning');      }    }  } }/** * Add the installation task list to the current page. */function install_task_list($active = NULL) {  // Default list of tasks.  $tasks = array(    'profile-select'        => st('Choose profile'),    'locale-select'         => st('Choose language'),    'requirements'          => st('Verify requirements'),    'database'              => st('Set up database'),    'profile-install-batch' => st('Install profile'),    'locale-initial-batch'  => st('Set up translations'),    'configure'             => st('Configure site'),  );  $profiles = install_find_profiles();  $profile = isset($_GET['profile']) && isset($profiles[$_GET['profile']]) ? $_GET['profile'] : '.';  $locales = install_find_locales($profile);  // If we have only one profile, remove 'Choose profile'  // and rename 'Install profile'.  if (count($profiles) == 1) {    unset($tasks['profile-select']);    $tasks['profile-install-batch'] = st('Install site');  }  // Add tasks defined by the profile.  if ($profile) {    $function = $profile .'_profile_task_list';    if (function_exists($function)) {      $result = $function();      if (is_array($result)) {        $tasks += $result;      }    }  }  if (count($locales) < 2 || empty($_GET['locale']) || $_GET['locale'] == 'en') {    // If not required, remove translation import from the task list.    unset($tasks['locale-initial-batch']);  }  else {    // If required, add remaining translations import task.    $tasks += array('locale-remaining-batch' => st('Finish translations'));  }  // Add finished step as the last task.  $tasks += array(    'finished'     => st('Finished')  );  // Let the theming function know that 'finished' and 'done'  // include everything, so every step is completed.  if (in_array($active, array('finished', 'done'))) {    $active = NULL;  }  drupal_set_content('left', theme_task_list($tasks, $active));}/** * Form API array definition for site configuration. */function install_configure_form(&$form_state, $url) {  $form['intro'] = array(    '#value' => st('To configure your website, please provide the following information.'),    '#weight' => -10,  );  $form['site_information'] = array(    '#type' => 'fieldset',    '#title' => st('Site information'),    '#collapsible' => FALSE,  );  $form['site_information']['site_name'] = array(    '#type' => 'textfield',    '#title' => st('Site name'),    '#required' => TRUE,    '#weight' => -20,  );  $form['site_information']['site_mail'] = array(    '#type' => 'textfield',    '#title' => st('Site e-mail address'),    '#default_value' => ini_get('sendmail_from'),    '#description' => st("The <em>From</em> address in automated e-mails sent during registration and new password requests, and other notifications. (Use an address ending in your site's domain to help prevent this e-mail being flagged as spam.)"),    '#required' => TRUE,    '#weight' => -15,  );  $form['admin_account'] = array(    '#type' => 'fieldset',    '#title' => st('Administrator account'),    '#collapsible' => FALSE,  );  $form['admin_account']['account']['#tree'] = TRUE;  $form['admin_account']['markup'] = array(    '#value' => '<p class="description">'. st('The administrator account has complete access to the site; it will automatically be granted all permissions and can perform any administrative activity. This will be the only account that can perform certain activities, so keep its credentials safe.') .'</p>',    '#weight' => -10,  );  $form['admin_account']['account']['name'] = array('#type' => 'textfield',    '#title' => st('Username'),    '#maxlength' => USERNAME_MAX_LENGTH,    '#description' => st('Spaces are allowed; punctuation is not allowed except for periods, hyphens, and underscores.'),    '#required' => TRUE,    '#weight' => -10,  );  $form['admin_account']['account']['mail'] = array('#type' => 'textfield',    '#title' => st('E-mail address'),    '#maxlength' => EMAIL_MAX_LENGTH,    '#description' => st('All e-mails from the system will be sent to this address. The e-mail address is not made public and will only be used if you wish to receive a new password or wish to receive certain news or notifications by e-mail.'),    '#required' => TRUE,    '#weight' => -5,  );  $form['admin_account']['account']['pass'] = array(    '#type' => 'password_confirm',    '#required' => TRUE,    '#size' => 25,    '#weight' => 0,  );  $form['server_settings'] = array(    '#type' => 'fieldset',    '#title' => st('Server settings'),    '#collapsible' => FALSE,  );  $form['server_settings']['date_default_timezone'] = array(    '#type' => 'select',    '#title' => st('Default time zone'),    '#default_value' => 0,    '#options' => _system_zonelist(),    '#description' => st('By default, dates in this site will be displayed in the chosen time zone.'),    '#weight' => 5,  );  $form['server_settings']['clean_url'] = array(    '#type' => 'radios',    '#title' => st('Clean URLs'),    '#default_value' => 0,    '#options' => array(0 => st('Disabled'), 1 => st('Enabled')),    '#description' => st('This option makes Drupal emit "clean" URLs (i.e. without <code>?q=</code> in the URL).'),    '#disabled' => TRUE,    '#prefix' => '<div id="clean-url" class="install">',    '#suffix' => '</div>',    '#weight' => 10,  );  $form['server_settings']['update_status_module'] = array(    '#type' => 'checkboxes',    '#title' => st('Update notifications'),    '#options' => array(1 => st('Check for updates automatically')),    '#default_value' => array(1),    '#description' => st('With this option enabled, Drupal will notify you when new releases are available. This will significantly enhance your site\'s security and is <strong>highly recommended</strong>. This requires your site to periodically send anonymous information on its installed components to <a href="@drupal">drupal.org</a>. For more information please see the <a href="@update">update notification information</a>.', array('@drupal' => 'http://drupal.org', '@update' => 'http://drupal.org/handbook/modules/update')),    '#weight' => 15,  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => st('Save and continue'),    '#weight' => 15,  );  $form['#action'] = $url;  $form['#redirect'] = FALSE;  // Allow the profile to alter this form. $form_state isn't available  // here, but to conform to the hook_form_alter() signature, we pass  // an empty array.  $hook_form_alter = $_GET['profile'] .'_form_alter';  if (function_exists($hook_form_alter)) {    $hook_form_alter($form, array(), 'install_configure');  }  return $form;}/** * Form API validate for the site configuration form. */function install_configure_form_validate($form, &$form_state) {  if ($error = user_validate_name($form_state['values']['account']['name'])) {    form_error($form['admin_account']['account']['name'], $error);  }  if ($error = user_validate_mail($form_state['values']['account']['mail'])) {    form_error($form['admin_account']['account']['mail'], $error);  }  if ($error = user_validate_mail($form_state['values']['site_mail'])) {    form_error($form['site_information']['site_mail'], $error);  }}/** * Form API submit for the site configuration form. */function install_configure_form_submit($form, &$form_state) {  global $user;  variable_set('site_name', $form_state['values']['site_name']);  variable_set('site_mail', $form_state['values']['site_mail']);  variable_set('date_default_timezone', $form_state['values']['date_default_timezone']);  // Enable update.module if this option was selected.  if ($form_state['values']['update_status_module'][1]) {    drupal_install_modules(array('update'));  }  // Turn this off temporarily so that we can pass a password through.  variable_set('user_email_verification', FALSE);  $form_state['old_values'] = $form_state['values'];  $form_state['values'] = $form_state['values']['account'];  // We precreated user 1 with placeholder values. Let's save the real values.  $account = user_load(1);  $merge_data = array('init' => $form_state['values']['mail'], 'roles' => array(), 'status' => 1);  user_save($account, array_merge($form_state['values'], $merge_data));  // Log in the first user.  user_authenticate($form_state['values']);  $form_state['values'] = $form_state['old_values'];  unset($form_state['old_values']);  variable_set('user_email_verification', TRUE);  if (isset($form_state['values']['clean_url'])) {    variable_set('clean_url', $form_state['values']['clean_url']);  }  // The user is now logged in, but has no session ID yet, which  // would be required later in the request, so remember it.  $user->sid = session_id();  // Record when this install ran.  variable_set('install_time', time());}// Start the installer.install_main();
<?php// $Id$/** * @file * Admin page callback file for the user module. */function user_admin($callback_arg = '') {  $op = isset($_POST['op']) ? $_POST['op'] : $callback_arg;  switch ($op) {    case t('Create new account'):    case 'create':      $output = drupal_get_form('user_register');      break;    default:      if (!empty($_POST['accounts']) && isset($_POST['operation']) && ($_POST['operation'] == 'delete')) {        $output = drupal_get_form('user_multiple_delete_confirm');      }      else {        $output = drupal_get_form('user_filter_form');        $output .= drupal_get_form('user_admin_account');      }  }  return $output;}/** * Form builder; Return form for user administration filters. * * @ingroup forms * @see user_filter_form_submit() */function user_filter_form() {  $session = &$_SESSION['user_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = user_filters();  $i = 0;  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Show only users where'),    '#theme' => 'user_filters',  );  foreach ($session as $filter) {    list($type, $value) = $filter;    // Merge an array of arrays into one if necessary.    $options = $type == 'permission' ? call_user_func_array('array_merge', $filters[$type]['options']) : $filters[$type]['options'];    $params = array('%property' => $filters[$type]['title'] , '%value' => $options[$value]);    if ($i++ > 0) {      $form['filters']['current'][] = array('#value' => t('<em>and</em> where <strong>%property</strong> is <strong>%value</strong>', $params));    }    else {      $form['filters']['current'][] = array('#value' => t('<strong>%property</strong> is <strong>%value</strong>', $params));    }  }  foreach ($filters as $key => $filter) {    $names[$key] = $filter['title'];    $form['filters']['status'][$key] = array(      '#type' => 'select',      '#options' => $filter['options'],    );  }  $form['filters']['filter'] = array(    '#type' => 'radios',    '#options' => $names,  );  $form['filters']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => (count($session) ? t('Refine') : t('Filter')),  );  if (count($session)) {    $form['filters']['buttons']['undo'] = array(      '#type' => 'submit',      '#value' => t('Undo'),    );    $form['filters']['buttons']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset'),    );  }  drupal_add_js('misc/form.js', 'core');  return $form;}/** * Process result from user administration filter form. */function user_filter_form_submit($form, &$form_state) {  $op = $form_state['values']['op'];  $filters = user_filters();  switch ($op) {    case t('Filter'): case t('Refine'):      if (isset($form_state['values']['filter'])) {        $filter = $form_state['values']['filter'];        // Merge an array of arrays into one if necessary.        $options = $filter == 'permission' ? call_user_func_array('array_merge', $filters[$filter]['options']) : $filters[$filter]['options'];        if (isset($options[$form_state['values'][$filter]])) {          $_SESSION['user_overview_filter'][] = array($filter, $form_state['values'][$filter]);        }      }      break;    case t('Undo'):      array_pop($_SESSION['user_overview_filter']);      break;    case t('Reset'):      $_SESSION['user_overview_filter'] = array();      break;    case t('Update'):      return;  }  $form_state['redirect'] = 'admin/user/user';  return;}/** * Form builder; User administration page. * * @ingroup forms * @see user_admin_account_validate() * @see user_admin_account_submit() */function user_admin_account() {  $filter = user_build_filter_query();  $header = array(    array(),    array('data' => t('Username'), 'field' => 'u.name'),    array('data' => t('Status'), 'field' => 'u.status'),    t('Roles'),    array('data' => t('Member for'), 'field' => 'u.created', 'sort' => 'desc'),    array('data' => t('Last access'), 'field' => 'u.access'),    t('Operations')  );  if ($filter['join'] != "") {    $sql = 'SELECT DISTINCT u.uid, u.name, u.status, u.created, u.access FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid '. $filter['join'] .' WHERE u.uid != 0 '. $filter['where'];    $query_count = 'SELECT COUNT(DISTINCT u.uid) FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid '. $filter['join'] .' WHERE u.uid != 0 '. $filter['where'];  }  else {    $sql = 'SELECT u.uid, u.name, u.status, u.created, u.access FROM {users} u WHERE u.uid != 0 '. $filter['where'];    $query_count = 'SELECT COUNT(u.uid) FROM {users} u WHERE u.uid != 0 '. $filter['where'];  }    $sql .= tablesort_sql($header);  $result = pager_query($sql, 50, 0, $query_count, $filter['args']);  $form['options'] = array(    '#type' => 'fieldset',    '#title' => t('Update options'),    '#prefix' => '<div class="container-inline">',    '#suffix' => '</div>',  );  $options = array();  foreach (module_invoke_all('user_operations') as $operation => $array) {    $options[$operation] = $array['label'];  }  $form['options']['operation'] = array(    '#type' => 'select',    '#options' => $options,    '#default_value' => 'unblock',  );  $form['options']['submit'] = array(    '#type' => 'submit',    '#value' => t('Update'),  );  $destination = drupal_get_destination();  $status = array(t('blocked'), t('active'));  $roles = user_roles(TRUE);  $accounts = array();  while ($account = db_fetch_object($result)) {    $accounts[$account->uid] = '';    $form['name'][$account->uid] = array('#value' => theme('username', $account));    $form['status'][$account->uid] =  array('#value' => $status[$account->status]);    $users_roles = array();    $roles_result = db_query('SELECT rid FROM {users_roles} WHERE uid = %d', $account->uid);    while ($user_role = db_fetch_object($roles_result)) {      $users_roles[] = $roles[$user_role->rid];    }    asort($users_roles);    $form['roles'][$account->uid][0] = array('#value' => theme('item_list', $users_roles));    $form['member_for'][$account->uid] = array('#value' => format_interval(time() - $account->created));    $form['last_access'][$account->uid] =  array('#value' => $account->access ? t('@time ago', array('@time' => format_interval(time() - $account->access))) : t('never'));    $form['operations'][$account->uid] = array('#value' => l(t('edit'), "user/$account->uid/edit", array('query' => $destination)));  }  $form['accounts'] = array(    '#type' => 'checkboxes',    '#options' => $accounts  );  $form['pager'] = array('#value' => theme('pager', NULL, 50, 0));  return $form;}/** * Submit the user administration update form. */function user_admin_account_submit($form, &$form_state) {  $operations = module_invoke_all('user_operations', $form_state);  $operation = $operations[$form_state['values']['operation']];  // Filter out unchecked accounts.  $accounts = array_filter($form_state['values']['accounts']);  if ($function = $operation['callback']) {    // Add in callback arguments if present.    if (isset($operation['callback arguments'])) {      $args = array_merge(array($accounts), $operation['callback arguments']);    }    else {      $args = array($accounts);    }    call_user_func_array($function, $args);    drupal_set_message(t('The update has been performed.'));  }}function user_admin_account_validate($form, &$form_state) {  $form_state['values']['accounts'] = array_filter($form_state['values']['accounts']);  if (count($form_state['values']['accounts']) == 0) {    form_set_error('', t('No users selected.'));  }}/** * Form builder; Configure user settings for this site. * * @ingroup forms * @see system_settings_form() */function user_admin_settings() {  // User registration settings.  $form['registration'] = array('#type' => 'fieldset', '#title' => t('User registration settings'));  $form['registration']['user_register'] = array('#type' => 'radios', '#title' => t('Public registrations'), '#default_value' => variable_get('user_register', 1), '#options' => array(t('Only site administrators can create new user accounts.'), t('Visitors can create accounts and no administrator approval is required.'), t('Visitors can create accounts but administrator approval is required.')));  $form['registration']['user_email_verification'] = array('#type' => 'checkbox', '#title' => t('Require e-mail verification when a visitor creates an account'), '#default_value' => variable_get('user_email_verification', TRUE), '#description' => t('If this box is checked, new users will be required to validate their e-mail address prior to logging into the site, and will be assigned a system-generated password. With it unchecked, users will be logged in immediately upon registering, and may select their own passwords during registration.'));  $form['registration']['user_registration_help'] = array('#type' => 'textarea', '#title' => t('User registration guidelines'), '#default_value' => variable_get('user_registration_help', ''), '#description' => t('This text is displayed at the top of the user registration form and is useful for helping or instructing your users.'));  // User e-mail settings.  $form['email'] = array(    '#type' => 'fieldset',    '#title' => t('User e-mail settings'),    '#description' => t('Drupal sends emails whenever new users register on your site, and optionally, may also notify users after other account actions. Using a simple set of content templates, notification e-mails can be customized to fit the specific needs of your site.'),  );  // These email tokens are shared for all settings, so just define  // the list once to help ensure they stay in sync.  $email_token_help = t('Available variables are:') .' !username, !site, !password, !uri, !uri_brief, !mailto, !date, !login_uri, !edit_uri, !login_url.';  $form['email']['admin_created'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, new user created by administrator'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 0),    '#description' => t('Customize welcome e-mail messages sent to new member accounts created by an administrator.') .' '. $email_token_help,  );  $form['email']['admin_created']['user_mail_register_admin_created_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_admin_created_subject'),    '#maxlength' => 180,  );  $form['email']['admin_created']['user_mail_register_admin_created_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_admin_created_body'),    '#rows' => 15,  );  $form['email']['no_approval_required'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, no approval required'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 1),    '#description' => t('Customize welcome e-mail messages sent to new members upon registering, when no administrator approval is required.') .' '. $email_token_help  );  $form['email']['no_approval_required']['user_mail_register_no_approval_required_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_no_approval_required_subject'),    '#maxlength' => 180,  );  $form['email']['no_approval_required']['user_mail_register_no_approval_required_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_no_approval_required_body'),    '#rows' => 15,  );  $form['email']['pending_approval'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, awaiting administrator approval'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 2),    '#description' => t('Customize welcome e-mail messages sent to new members upon registering, when administrative approval is required.') .' '. $email_token_help,  );  $form['email']['pending_approval']['user_mail_register_pending_approval_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_pending_approval_subject'),    '#maxlength' => 180,  );  $form['email']['pending_approval']['user_mail_register_pending_approval_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_pending_approval_body'),    '#rows' => 8,  );  $form['email']['password_reset'] = array(    '#type' => 'fieldset',    '#title' => t('Password recovery email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Customize e-mail messages sent to users who request a new password.') .' '. $email_token_help,  );  $form['email']['password_reset']['user_mail_password_reset_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('password_reset_subject'),    '#maxlength' => 180,  );  $form['email']['password_reset']['user_mail_password_reset_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('password_reset_body'),    '#rows' => 12,  );  $form['email']['activated'] = array(    '#type' => 'fieldset',    '#title' => t('Account activation email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users upon account activation (when an administrator activates an account of a user who has already registered, on a site where administrative approval is required).') .' '. $email_token_help,  );  $form['email']['activated']['user_mail_status_activated_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is activated.'),    '#default_value' => variable_get('user_mail_status_activated_notify', TRUE),  );  $form['email']['activated']['user_mail_status_activated_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_activated_subject'),    '#maxlength' => 180,  );  $form['email']['activated']['user_mail_status_activated_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_activated_body'),    '#rows' => 15,  );  $form['email']['blocked'] = array(    '#type' => 'fieldset',    '#title' => t('Account blocked email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users when their accounts are blocked.') .' '. $email_token_help,  );  $form['email']['blocked']['user_mail_status_blocked_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is blocked.'),    '#default_value' => variable_get('user_mail_status_blocked_notify', FALSE),  );  $form['email']['blocked']['user_mail_status_blocked_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_blocked_subject'),    '#maxlength' => 180,  );  $form['email']['blocked']['user_mail_status_blocked_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_blocked_body'),    '#rows' => 3,  );  $form['email']['deleted'] = array(    '#type' => 'fieldset',    '#title' => t('Account deleted email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users when their accounts are deleted.') .' '. $email_token_help,  );  $form['email']['deleted']['user_mail_status_deleted_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is deleted.'),    '#default_value' => variable_get('user_mail_status_deleted_notify', FALSE),  );  $form['email']['deleted']['user_mail_status_deleted_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_deleted_subject'),    '#maxlength' => 180,  );  $form['email']['deleted']['user_mail_status_deleted_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_deleted_body'),    '#rows' => 3,  );  // User signatures.  $form['signatures'] = array(    '#type' => 'fieldset',    '#title' => t('Signatures'),  );  $form['signatures']['user_signatures'] = array(    '#type' => 'radios',    '#title' => t('Signature support'),    '#default_value' => variable_get('user_signatures', 0),    '#options' => array(t('Disabled'), t('Enabled')),  );  // If picture support is enabled, check whether the picture directory exists:  if (variable_get('user_pictures', 0)) {    $picture_path = file_create_path(variable_get('user_picture_path', 'pictures'));    file_check_directory($picture_path, 1, 'user_picture_path');  }  $form['pictures'] = array(    '#type' => 'fieldset',    '#title' => t('Pictures'),  );  $picture_support = variable_get('user_pictures', 0);  $form['pictures']['user_pictures'] = array(    '#type' => 'radios',    '#title' => t('Picture support'),    '#default_value' => $picture_support,    '#options' => array(t('Disabled'), t('Enabled')),    '#prefix' => '<div class="user-admin-picture-radios">',    '#suffix' => '</div>',  );  drupal_add_js(drupal_get_path('module', 'user') .'/user.js');  // If JS is enabled, and the radio is defaulting to off, hide all  // the settings on page load via .css using the js-hide class so  // that there's no flicker.  $css_class = 'user-admin-picture-settings';  if (!$picture_support) {    $css_class .= ' js-hide';  }  $form['pictures']['settings'] = array(    '#prefix' => '<div class="'. $css_class .'">',    '#suffix' => '</div>',  );  $form['pictures']['settings']['user_picture_path'] = array(    '#type' => 'textfield',    '#title' => t('Picture image path'),    '#default_value' => variable_get('user_picture_path', 'pictures'),    '#size' => 30,    '#maxlength' => 255,    '#description' => t('Subdirectory in the directory %dir where pictures will be stored.', array('%dir' => file_directory_path() .'/')),  );  $form['pictures']['settings']['user_picture_default'] = array(    '#type' => 'textfield',    '#title' => t('Default picture'),    '#default_value' => variable_get('user_picture_default', ''),    '#size' => 30,    '#maxlength' => 255,    '#description' => t('URL of picture to display for users with no custom picture selected. Leave blank for none.'),  );  $form['pictures']['settings']['user_picture_dimensions'] = array(    '#type' => 'textfield',    '#title' => t('Picture maximum dimensions'),    '#default_value' => variable_get('user_picture_dimensions', '85x85'),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('Maximum dimensions for pictures, in pixels.'),  );  $form['pictures']['settings']['user_picture_file_size'] = array(    '#type' => 'textfield',    '#title' => t('Picture maximum file size'),    '#default_value' => variable_get('user_picture_file_size', '30'),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('Maximum file size for pictures, in kB.'),  );  $form['pictures']['settings']['user_picture_guidelines'] = array(    '#type' => 'textarea',    '#title' => t('Picture guidelines'),    '#default_value' => variable_get('user_picture_guidelines', ''),    '#description' => t("This text is displayed at the picture upload form in addition to the default guidelines. It's useful for helping or instructing your users."),  );  return system_settings_form($form);}/** * Menu callback: administer permissions. * * @ingroup forms * @see user_admin_perm_submit() * @see theme_user_admin_perm() */function user_admin_perm($form_state, $rid = NULL) {  if (is_numeric($rid)) {    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid WHERE r.rid = %d', $rid);  }  else {    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid ORDER BY name');  }  // Compile role array:  // Add a comma at the end so when searching for a permission, we can  // always search for "$perm," to make sure we do not confuse  // permissions that are substrings of each other.  while ($role = db_fetch_object($result)) {    $role_permissions[$role->rid] = $role->perm .',';  }  // Retrieve role names for columns.  $role_names = user_roles();  if (is_numeric($rid)) {    $role_names = array($rid => $role_names[$rid]);  }  // Render role/permission overview:  $options = array();  foreach (module_list(FALSE, FALSE, TRUE) as $module) {    if ($permissions = module_invoke($module, 'perm')) {      $form['permission'][] = array(        '#value' => $module,      );      asort($permissions);      foreach ($permissions as $perm) {        $options[$perm] = '';        $form['permission'][$perm] = array('#value' => t($perm));        foreach ($role_names as $rid => $name) {          // Builds arrays for checked boxes for each role          if (strpos($role_permissions[$rid], $perm .',') !== FALSE) {            $status[$rid][] = $perm;          }        }      }    }  }  // Have to build checkboxes here after checkbox arrays are built  foreach ($role_names as $rid => $name) {    $form['checkboxes'][$rid] = array('#type' => 'checkboxes', '#options' => $options, '#default_value' => isset($status[$rid]) ? $status[$rid] : array());    $form['role_names'][$rid] = array('#value' => $name, '#tree' => TRUE);  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save permissions'));  return $form;}function user_admin_perm_submit($form, &$form_state) {  // Save permissions:  $result = db_query('SELECT * FROM {role}');  while ($role = db_fetch_object($result)) {    if (isset($form_state['values'][$role->rid])) {      // Delete, so if we clear every checkbox we reset that role;      // otherwise permissions are active and denied everywhere.      db_query('DELETE FROM {permission} WHERE rid = %d', $role->rid);      $form_state['values'][$role->rid] = array_filter($form_state['values'][$role->rid]);      if (count($form_state['values'][$role->rid])) {        db_query("INSERT INTO {permission} (rid, perm) VALUES (%d, '%s')", $role->rid, implode(', ', array_keys($form_state['values'][$role->rid])));      }    }  }  drupal_set_message(t('The changes have been saved.'));  // Clear the cached pages  cache_clear_all();}/** * Theme the administer permissions page. * * @ingroup themeable */function theme_user_admin_perm($form) {  $roles = user_roles();  foreach (element_children($form['permission']) as $key) {    // Don't take form control structures    if (is_array($form['permission'][$key])) {      $row = array();      // Module name      if (is_numeric($key)) {        $row[] = array('data' => t('@module module', array('@module' => drupal_render($form['permission'][$key]))), 'class' => 'module', 'id' => 'module-'. $form['permission'][$key]['#value'], 'colspan' => count($form['role_names']) + 1);      }      else {        $row[] = array('data' => drupal_render($form['permission'][$key]), 'class' => 'permission');        foreach (element_children($form['checkboxes']) as $rid) {          if (is_array($form['checkboxes'][$rid])) {            $row[] = array('data' => drupal_render($form['checkboxes'][$rid][$key]), 'class' => 'checkbox', 'title' => $roles[$rid] .' : '. t($key));          }        }      }      $rows[] = $row;    }  }  $header[] = (t('Permission'));  foreach (element_children($form['role_names']) as $rid) {    if (is_array($form['role_names'][$rid])) {      $header[] = array('data' => drupal_render($form['role_names'][$rid]), 'class' => 'checkbox');    }  }  $output = theme('table', $header, $rows, array('id' => 'permissions'));  $output .= drupal_render($form);  return $output;}/** * Menu callback: administer roles. * * @ingroup forms * @see user_admin_role_validate() * @see user_admin_role_submit() * @see theme_user_admin_new_role() */function user_admin_role() {  $rid = arg(4);  if ($rid) {    if ($rid == DRUPAL_ANONYMOUS_RID || $rid == DRUPAL_AUTHENTICATED_RID) {      drupal_goto('admin/user/roles');    }    // Display the edit role form.    $role = db_fetch_object(db_query('SELECT * FROM {role} WHERE rid = %d', $rid));    $form['name'] = array(      '#type' => 'textfield',      '#title' => t('Role name'),      '#default_value' => $role->name,      '#size' => 30,      '#required' => TRUE,      '#maxlength' => 64,      '#description' => t('The name for this role. Example: "moderator", "editorial board", "site architect".'),    );    $form['rid'] = array(      '#type' => 'value',      '#value' => $rid,    );    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Save role'),    );    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete role'),    );  }  else {    $form['name'] = array(      '#type' => 'textfield',      '#size' => 32,      '#maxlength' => 64,    );    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Add role'),    );    $form['#submit'][] = 'user_admin_role_submit';    $form['#validate'][] = 'user_admin_role_validate';  }  return $form;}function user_admin_role_validate($form, &$form_state) {  if ($form_state['values']['name']) {    if ($form_state['values']['op'] == t('Save role')) {      if (db_result(db_query("SELECT COUNT(*) FROM {role} WHERE name = '%s' AND rid != %d", $form_state['values']['name'], $form_state['values']['rid']))) {        form_set_error('name', t('The role name %name already exists. Please choose another role name.', array('%name' => $form_state['values']['name'])));      }    }    else if ($form_state['values']['op'] == t('Add role')) {      if (db_result(db_query("SELECT COUNT(*) FROM {role} WHERE name = '%s'", $form_state['values']['name']))) {        form_set_error('name', t('The role name %name already exists. Please choose another role name.', array('%name' => $form_state['values']['name'])));      }    }  }  else {    form_set_error('name', t('You must specify a valid role name.'));  }}function user_admin_role_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Save role')) {    db_query("UPDATE {role} SET name = '%s' WHERE rid = %d", $form_state['values']['name'], $form_state['values']['rid']);    drupal_set_message(t('The role has been renamed.'));  }  else if ($form_state['values']['op'] == t('Delete role')) {    db_query('DELETE FROM {role} WHERE rid = %d', $form_state['values']['rid']);    db_query('DELETE FROM {permission} WHERE rid = %d', $form_state['values']['rid']);    // Update the users who have this role set:    db_query('DELETE FROM {users_roles} WHERE rid = %d', $form_state['values']['rid']);    drupal_set_message(t('The role has been deleted.'));  }  else if ($form_state['values']['op'] == t('Add role')) {    db_query("INSERT INTO {role} (name) VALUES ('%s')", $form_state['values']['name']);    drupal_set_message(t('The role has been added.'));  }  $form_state['redirect'] = 'admin/user/roles';  return;}/** * Menu callback: list all access rules */function user_admin_access_check() {  $output = drupal_get_form('user_admin_check_user');  $output .= drupal_get_form('user_admin_check_mail');  $output .= drupal_get_form('user_admin_check_host');  return $output;}/** * Menu callback: add an access rule. */function user_admin_access_add($mask = NULL, $type = NULL) {  $edit = array();  $edit['aid'] = 0;  $edit['mask'] = $mask;  $edit['type'] = $type;  return drupal_get_form('user_admin_access_add_form', $edit, t('Add rule'));}/** * Menu callback: edit an access rule. */function user_admin_access_edit($aid = 0) {  $edit = db_fetch_array(db_query('SELECT aid, type, status, mask FROM {access} WHERE aid = %d', $aid));  return drupal_get_form('user_admin_access_edit_form', $edit, t('Save rule'));}/** * Form builder; Configure access rules. * * @ingroup forms */function user_admin_access_form(&$form_state, $edit, $submit) {  $form = array();  $form['aid'] = array(    '#type' => 'value',    '#value' => $edit['aid'],  );  $form['status'] = array(    '#type' => 'radios',    '#title' => t('Access type'),    '#default_value' => isset($edit['status']) ? $edit['status'] : 0,    '#options' => array('1' => t('Allow'), '0' => t('Deny')),  );  $type_options = array('user' => t('Username'), 'mail' => t('E-mail'), 'host' => t('Host'));  $form['type'] = array(    '#type' => 'radios',    '#title' => t('Rule type'),    '#default_value' => (isset($type_options[$edit['type']]) ? $edit['type'] : 'user'),    '#options' => $type_options,  );  $form['mask'] = array(    '#type' => 'textfield',    '#title' => t('Mask'),    '#size' => 30,    '#maxlength' => 64,    '#default_value' => $edit['mask'],    '#description' => '%: '. t('Matches any number of characters, even zero characters') .'.<br />_: '. t('Matches exactly one character.'),    '#required' => TRUE,  );  $form['submit'] = array('#type' => 'submit', '#value' => $submit);  $form['#submit'] = array('user_admin_access_form_submit');  return $form;}/** * Submit callback for user_admin_access_form(). */function user_admin_access_form_submit($form, &$form_state) {  $edit = $form_state['values'];  if ($edit['aid']) {    db_query("UPDATE {access} SET mask = '%s', type = '%s', status = '%s' WHERE aid = %d", $edit['mask'], $edit['type'], $edit['status'], $edit['aid']);    drupal_set_message(t('The access rule has been saved.'));  }  else {    db_query("INSERT INTO {access} (mask, type, status) VALUES ('%s', '%s', %d)", $edit['mask'], $edit['type'], $edit['status']);    drupal_set_message(t('The access rule has been added.'));  }  $form_state['redirect'] = 'admin/user/rules';}function user_admin_access_check_validate($form, &$form_state) {  if (empty($form_state['values']['test'])) {    form_set_error($form_state['values']['type'], t('No value entered. Please enter a test string and try again.'));  }}function user_admin_check_user() {  $form['user'] = array('#type' => 'fieldset', '#title' => t('Username'));  $form['user']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter a username to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => USERNAME_MAX_LENGTH);  $form['user']['type'] = array('#type' => 'hidden', '#value' => 'user');  $form['user']['submit'] = array('#type' => 'submit', '#value' => t('Check username'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_check_mail() {  $form['mail'] = array('#type' => 'fieldset', '#title' => t('E-mail'));  $form['mail']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter an e-mail address to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => EMAIL_MAX_LENGTH);  $form['mail']['type'] = array('#type' => 'hidden', '#value' => 'mail');  $form['mail']['submit'] = array('#type' => 'submit', '#value' => t('Check e-mail'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_check_host() {  $form['host'] = array('#type' => 'fieldset', '#title' => t('Hostname'));  $form['host']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter a hostname or IP address to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => 64);  $form['host']['type'] = array('#type' => 'hidden', '#value' => 'host');  $form['host']['submit'] = array('#type' => 'submit', '#value' => t('Check hostname'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_access_check_submit($form, &$form_state) {  switch ($form_state['values']['type']) {    case 'user':      if (drupal_is_denied('user', $form_state['values']['test'])) {        drupal_set_message(t('The username %name is not allowed.', array('%name' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The username %name is allowed.', array('%name' => $form_state['values']['test'])));      }      break;    case 'mail':      if (drupal_is_denied('mail', $form_state['values']['test'])) {        drupal_set_message(t('The e-mail address %mail is not allowed.', array('%mail' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The e-mail address %mail is allowed.', array('%mail' => $form_state['values']['test'])));      }      break;    case 'host':      if (drupal_is_denied('host', $form_state['values']['test'])) {        drupal_set_message(t('The hostname %host is not allowed.', array('%host' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The hostname %host is allowed.', array('%host' => $form_state['values']['test'])));      }      break;    default:      break;  }}/** * Menu callback: delete an access rule * * @ingroup forms * @see user_admin_access_delete_confirm_submit() */function user_admin_access_delete_confirm($form_state, $aid = 0) {  $access_types = array('user' => t('username'), 'mail' => t('e-mail'), 'host' => t('host'));  $edit = db_fetch_object(db_query('SELECT aid, type, status, mask FROM {access} WHERE aid = %d', $aid));  $form = array();  $form['aid'] = array('#type' => 'hidden', '#value' => $aid);  $output = confirm_form($form,                  t('Are you sure you want to delete the @type rule for %rule?', array('@type' => $access_types[$edit->type], '%rule' => $edit->mask)),                  'admin/user/rules',                  t('This action cannot be undone.'),                  t('Delete'),                  t('Cancel'));  return $output;}function user_admin_access_delete_confirm_submit($form, &$form_state) {  db_query('DELETE FROM {access} WHERE aid = %d', $form_state['values']['aid']);  drupal_set_message(t('The access rule has been deleted.'));  $form_state['redirect'] = 'admin/user/rules';  return;}/** * Menu callback: list all access rules */function user_admin_access() {  $header = array(array('data' => t('Access type'), 'field' => 'status'), array('data' => t('Rule type'), 'field' => 'type'), array('data' => t('Mask'), 'field' => 'mask'), array('data' => t('Operations'), 'colspan' => 2));  $result = db_query("SELECT aid, type, status, mask FROM {access}". tablesort_sql($header));  $access_types = array('user' => t('username'), 'mail' => t('e-mail'), 'host' => t('host'));  $rows = array();  while ($rule = db_fetch_object($result)) {    $rows[] = array($rule->status ? t('allow') : t('deny'), $access_types[$rule->type], $rule->mask, l(t('edit'), 'admin/user/rules/edit/'. $rule->aid), l(t('delete'), 'admin/user/rules/delete/'. $rule->aid));  }  if (empty($rows)) {    $rows[] = array(array('data' => '<em>'. t('There are currently no access rules.') .'</em>', 'colspan' => 5));  }  return theme('table', $header, $rows);}/** * Theme user administration overview. * * @ingroup themeable */function theme_user_admin_account($form) {  // Overview table:  $header = array(    theme('table_select_header_cell'),    array('data' => t('Username'), 'field' => 'u.name'),    array('data' => t('Status'), 'field' => 'u.status'),    t('Roles'),    array('data' => t('Member for'), 'field' => 'u.created', 'sort' => 'desc'),    array('data' => t('Last access'), 'field' => 'u.access'),    t('Operations')  );  $output = drupal_render($form['options']);  if (isset($form['name']) && is_array($form['name'])) {    foreach (element_children($form['name']) as $key) {      $rows[] = array(        drupal_render($form['accounts'][$key]),        drupal_render($form['name'][$key]),        drupal_render($form['status'][$key]),        drupal_render($form['roles'][$key]),        drupal_render($form['member_for'][$key]),        drupal_render($form['last_access'][$key]),        drupal_render($form['operations'][$key]),      );    }  }  else {    $rows[] = array(array('data' => t('No users available.'), 'colspan' => '7'));  }  $output .= theme('table', $header, $rows);  if ($form['pager']['#value']) {    $output .= drupal_render($form['pager']);  }  $output .= drupal_render($form);  return $output;}/** * Theme the new-role form. * * @ingroup themeable */function theme_user_admin_new_role($form) {  $header = array(t('Name'), array('data' => t('Operations'), 'colspan' => 2));  foreach (user_roles() as $rid => $name) {    $edit_permissions = l(t('edit permissions'), 'admin/user/permissions/'. $rid);    if (!in_array($rid, array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID))) {      $rows[] = array($name, l(t('edit role'), 'admin/user/roles/edit/'. $rid), $edit_permissions);    }    else {      $rows[] = array($name, t('locked'), $edit_permissions);    }  }  $rows[] = array(drupal_render($form['name']), array('data' => drupal_render($form['submit']), 'colspan' => 2));  $output = drupal_render($form);  $output .= theme('table', $header, $rows);  return $output;}/** * Theme user administration filter form. * * @ingroup themeable */function theme_user_filter_form($form) {  $output = '<div id="user-admin-filter">';  $output .= drupal_render($form['filters']);  $output .= '</div>';  $output .= drupal_render($form);  return $output;}/** * Theme user administration filter selector. * * @ingroup themeable */function theme_user_filters($form) {  $output = '<ul class="clear-block">';  if (!empty($form['current'])) {    foreach (element_children($form['current']) as $key) {      $output .= '<li>'. drupal_render($form['current'][$key]) .'</li>';    }  }  $output .= '<li><dl class="multiselect">'. (!empty($form['current']) ? '<dt><em>'. t('and') .'</em> '. t('where') .'</dt>' : '') .'<dd class="a">';  foreach (element_children($form['filter']) as $key) {    $output .= drupal_render($form['filter'][$key]);  }  $output .= '</dd>';  $output .= '<dt>'. t('is') .'</dt><dd class="b">';  foreach (element_children($form['status']) as $key) {    $output .= drupal_render($form['status'][$key]);  }  $output .= '</dd>';  $output .= '</dl>';  $output .= '<div class="container-inline" id="user-admin-buttons">'. drupal_render($form['buttons']) .'</div>';  $output .= '</li></ul>';  return $output;}
<?php// $Id$/** * @file * Code required only when comparing available updates to existing data. *//** * Fetch an array of installed and enabled projects. * * This is only responsible for generating an array of projects (taking into * account projects that include more than one module or theme). Other * information like the specific version and install type (official release, * dev snapshot, etc) is handled later in update_process_project_info() since * that logic is only required when preparing the status report, not for * fetching the available release data. * * This array is fairly expensive to construct, since it involves a lot of * disk I/O, so we cache the results into the {cache_update} table using the * 'update_project_projects' cache ID. However, since this is not the data * about available updates fetched from the network, it is ok to invalidate it * somewhat quickly. If we keep this data for very long, site administrators * are more likely to see incorrect results if they upgrade to a newer version * of a module or theme but do not visit certain pages that automatically * clear this cache. * * @see update_process_project_info() * @see update_calculate_project_data() * @see update_project_cache() */function update_get_projects() {  static $projects = array();  if (empty($projects)) {    // Retrieve the projects from cache, if present.    $projects = update_project_cache('update_project_projects');    if (empty($projects)) {      // Still empty, so we have to rebuild the cache.      _update_process_info_list($projects, module_rebuild_cache(), 'module');      _update_process_info_list($projects, system_theme_data(), 'theme');      // Allow other modules to alter projects before fetching and comparing.      drupal_alter('update_projects', $projects);      // Cache the site's project data for at most 1 hour.      _update_cache_set('update_project_projects', $projects, time() + 3600);    }  }  return $projects;}/** * Populate an array of project data. */function _update_process_info_list(&$projects, $list, $project_type) {  foreach ($list as $file) {    // A disabled base theme of an enabled sub-theme still has all of its code    // run by the sub-theme, so we include it in our "enabled" projects list.    if (!$file->status && !empty($file->sub_themes)) {      foreach ($file->sub_themes as $key => $name) {        // Build a list of enabled sub-themes.        if ($list[$key]->status) {          $file->enabled_sub_themes[$key] = $name;        }      }      // If there are no enabled subthemes, we should ingore this theme and go      // on to the next one.      if (empty($file->enabled_sub_themes)) {        continue;      }    }    elseif (empty($file->status)) {      // Skip disabled modules or themes.      continue;    }    // Skip if the .info file is broken.    if (empty($file->info)) {      continue;    }    // If the .info doesn't define the 'project', try to figure it out.    if (!isset($file->info['project'])) {      $file->info['project'] = update_get_project_name($file);    }    // If we still don't know the 'project', give up.    if (empty($file->info['project'])) {      continue;    }    // If we don't already know it, grab the change time on the .info file    // itself. Note: we need to use the ctime, not the mtime (modification    // time) since many (all?) tar implementations will go out of their way to    // set the mtime on the files it creates to the timestamps recorded in the    // tarball. We want to see the last time the file was changed on disk,    // which is left alone by tar and correctly set to the time the .info file    // was unpacked.    if (!isset($file->info['_info_file_ctime'])) {      $info_filename = dirname($file->filename) .'/'. $file->name .'.info';      $file->info['_info_file_ctime'] = filectime($info_filename);    }    if (!isset($file->info['datestamp'])) {      $file->info['datestamp'] = 0;    }    $project_name = $file->info['project'];    // Add a list of sub-themes that "depend on" the project and a list of base    // themes that are "required by" the project.    if ($project_name == 'drupal') {      // Drupal core is always required, so this extra info would be noise.      $sub_themes = array();      $base_themes = array();    }    else {      // Add list of enabled sub-themes.      $sub_themes = !empty($file->enabled_sub_themes) ? $file->enabled_sub_themes : array();      // Add list of base themes.      $base_themes = !empty($file->base_themes) ? $file->base_themes : array();    }    if (!isset($projects[$project_name])) {      // Only process this if we haven't done this project, since a single      // project can have multiple modules or themes.      $projects[$project_name] = array(        'name' => $project_name,        // Only save attributes from the .info file we care about so we do not        // bloat our RAM usage needlessly.        'info' => update_filter_project_info($file->info),        'datestamp' => $file->info['datestamp'],        'includes' => array($file->name => $file->info['name']),        'project_type' => $project_name == 'drupal' ? 'core' : $project_type,        'sub_themes' => $sub_themes,        'base_themes' => $base_themes,      );    }    else {      $projects[$project_name]['includes'][$file->name] = $file->info['name'];      $projects[$project_name]['info']['_info_file_ctime'] = max($projects[$project_name]['info']['_info_file_ctime'], $file->info['_info_file_ctime']);      $projects[$project_name]['datestamp'] = max($projects[$project_name]['datestamp'], $file->info['datestamp']);      $projects[$project_name]['sub_themes'] = array_merge($projects[$project_name]['sub_themes'], $sub_themes);      $projects[$project_name]['base_themes'] = array_merge($projects[$project_name]['base_themes'], $base_themes);    }  }}/** * Given a $file object (as returned by system_get_files_database()), figure * out what project it belongs to. * * @see system_get_files_database() */function update_get_project_name($file) {  $project_name = '';  if (isset($file->info['project'])) {    $project_name = $file->info['project'];  }  elseif (isset($file->info['package']) && (strpos($file->info['package'], 'Core -') !== FALSE)) {    $project_name = 'drupal';  }  elseif (in_array($file->name, array('bluemarine', 'chameleon', 'garland', 'marvin', 'minnelli', 'pushbutton'))) {    // Unfortunately, there's no way to tell if a theme is part of core,    // so we must hard-code a list here.    $project_name = 'drupal';  }  return $project_name;}/** * Process the list of projects on the system to figure out the currently * installed versions, and other information that is required before we can * compare against the available releases to produce the status report. * * @param $projects *   Array of project information from update_get_projects(). */function update_process_project_info(&$projects) {  foreach ($projects as $key => $project) {    // Assume an official release until we see otherwise.    $install_type = 'official';    $info = $project['info'];    if (isset($info['version'])) {      // Check for development snapshots      if (preg_match('@(dev|HEAD)@', $info['version'])) {        $install_type = 'dev';      }      // Figure out what the currently installed major version is. We need      // to handle both contribution (e.g. "5.x-1.3", major = 1) and core      // (e.g. "5.1", major = 5) version strings.      $matches = array();      if (preg_match('/^(\d+\.x-)?(\d+)\..*$/', $info['version'], $matches)) {        $info['major'] = $matches[2];      }      elseif (!isset($info['major'])) {        // This would only happen for version strings that don't follow the        // drupal.org convention. We let contribs define "major" in their        // .info in this case, and only if that's missing would we hit this.        $info['major'] = -1;      }    }    else {      // No version info available at all.      $install_type = 'unknown';      $info['version'] = t('Unknown');      $info['major'] = -1;    }    // Finally, save the results we care about into the $projects array.    $projects[$key]['existing_version'] = $info['version'];    $projects[$key]['existing_major'] = $info['major'];    $projects[$key]['install_type'] = $install_type;  }}/** * Given the installed projects and the available release data retrieved from * remote servers, calculate the current status. * * This function is the heart of the update status feature. It iterates over * every currently installed project. For each one, it first checks if the * project has been flagged with a special status like "unsupported" or * "insecure", or if the project node itself has been unpublished. In any of * those cases, the project is marked with an error and the next project is * considered. * * If the project itself is valid, the function decides what major release * series to consider. The project defines what the currently supported major * versions are for each version of core, so the first step is to make sure * the current version is still supported. If so, that's the target version. * If the current version is unsupported, the project maintainer's recommended * major version is used. There's also a check to make sure that this function * never recommends an earlier release than the currently installed major * version. * * Given a target major version, it scans the available releases looking for * the specific release to recommend (avoiding beta releases and development * snapshots if possible). This is complicated to describe, but an example * will help clarify. For the target major version, find the highest patch * level. If there is a release at that patch level with no extra ("beta", * etc), then we recommend the release at that patch level with the most * recent release date. If every release at that patch level has extra (only * betas), then recommend the latest release from the previous patch * level. For example: * * 1.6-bugfix <-- recommended version because 1.6 already exists. * 1.6 * * or * * 1.6-beta * 1.5 <-- recommended version because no 1.6 exists. * 1.4 * * It also looks for the latest release from the same major version, even a * beta release, to display to the user as the "Latest version" option. * Additionally, it finds the latest official release from any higher major * versions that have been released to provide a set of "Also available" * options. * * Finally, and most importantly, it keeps scanning the release history until * it gets to the currently installed release, searching for anything marked * as a security update. If any security updates have been found between the * recommended release and the installed version, all of the releases that * included a security fix are recorded so that the site administrator can be * warned their site is insecure, and links pointing to the release notes for * each security update can be included (which, in turn, will link to the * official security announcements for each vulnerability). * * This function relies on the fact that the .xml release history data comes * sorted based on major version and patch level, then finally by release date * if there are multiple releases such as betas from the same major.patch * version (e.g. 5.x-1.5-beta1, 5.x-1.5-beta2, and 5.x-1.5). Development * snapshots for a given major version are always listed last. * * The results of this function are expensive to compute, especially on sites * with lots of modules or themes, since it involves a lot of comparisons and * other operations. Therefore, we cache the results into the {cache_update} * table using the 'update_project_data' cache ID. However, since this is not * the data about available updates fetched from the network, it is ok to * invalidate it somewhat quickly. If we keep this data for very long, site * administrators are more likely to see incorrect results if they upgrade to * a newer version of a module or theme but do not visit certain pages that * automatically clear this cache. * * @param $available *  Array of data about available project releases. * * @see update_get_available() * @see update_get_projects() * @see update_process_project_info() * @see update_project_cache() */function update_calculate_project_data($available) {  // Retrieve the projects from cache, if present.  $projects = update_project_cache('update_project_data');  // If $projects is empty, then the cache must be rebuilt.  // Otherwise, return the cached data and skip the rest of the function.  if (!empty($projects)) {    return $projects;  }  $projects = update_get_projects();  update_process_project_info($projects);  foreach ($projects as $project => $project_info) {    if (isset($available[$project])) {      // If the project status is marked as something bad, there's nothing      // else to consider.      if (isset($available[$project]['project_status'])) {        switch ($available[$project]['project_status']) {          case 'insecure':            $projects[$project]['status'] = UPDATE_NOT_SECURE;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-not-secure',              'label' => t('Project not secure'),              'data' => t('This project has been labeled insecure by the Drupal security team, and is no longer available for download. Immediately disabling everything included by this project is strongly recommended!'),            );            break;          case 'unpublished':          case 'revoked':            $projects[$project]['status'] = UPDATE_REVOKED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-revoked',              'label' => t('Project revoked'),              'data' => t('This project has been revoked, and is no longer available for download. Disabling everything included by this project is strongly recommended!'),            );            break;          case 'unsupported':            $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-not-supported',              'label' => t('Project not supported'),              'data' => t('This project is no longer supported, and is no longer available for download. Disabling everything included by this project is strongly recommended!'),            );            break;          case 'not-fetched':            $projects[$project]['status'] = UPDATE_NOT_FETCHED;            $projects[$project]['reason'] = t('Failed to fetch available update data');            break;          default:            // Assume anything else (e.g. 'published') is valid and we should            // perform the rest of the logic in this function.            break;        }      }      if (!empty($projects[$project]['status'])) {        // We already know the status for this project, so there's nothing        // else to compute. Just record everything else we fetched from the        // XML file into our projects array and move to the next project.        $projects[$project] += $available[$project];        continue;      }      // Figure out the target major version.      $existing_major = $project_info['existing_major'];      $supported_majors = array();      if (isset($available[$project]['supported_majors'])) {        $supported_majors = explode(',', $available[$project]['supported_majors']);      }      elseif (isset($available[$project]['default_major'])) {        // Older release history XML file without supported or recommended.        $supported_majors[] = $available[$project]['default_major'];      }      if (in_array($existing_major, $supported_majors)) {        // Still supported, stay at the current major version.        $target_major = $existing_major;      }      elseif (isset($available[$project]['recommended_major'])) {        // Since 'recommended_major' is defined, we know this is the new XML        // format. Therefore, we know the current release is unsupported since        // its major version was not in the 'supported_majors' list. We should        // find the best release from the recommended major version.        $target_major = $available[$project]['recommended_major'];        $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;      }      elseif (isset($available[$project]['default_major'])) {        // Older release history XML file without recommended, so recommend        // the currently defined "default_major" version.        $target_major = $available[$project]['default_major'];      }      else {        // Malformed XML file? Stick with the current version.        $target_major = $existing_major;      }      // Make sure we never tell the admin to downgrade. If we recommended an      // earlier version than the one they're running, they'd face an      // impossible data migration problem, since Drupal never supports a DB      // downgrade path. In the unfortunate case that what they're running is      // unsupported, and there's nothing newer for them to upgrade to, we      // can't print out a "Recommended version", but just have to tell them      // what they have is unsupported and let them figure it out.      $target_major = max($existing_major, $target_major);      $version_patch_changed = '';      $patch = '';      // Defend ourselves from XML history files that contain no releases.      if (empty($available[$project]['releases'])) {        $projects[$project]['status'] = UPDATE_UNKNOWN;        $projects[$project]['reason'] = t('No available releases found');        continue;      }      foreach ($available[$project]['releases'] as $version => $release) {        // First, if this is the existing release, check a few conditions.        if ($projects[$project]['existing_version'] === $version) {          if (isset($release['terms']['Release type']) &&              in_array('Insecure', $release['terms']['Release type'])) {            $projects[$project]['status'] = UPDATE_NOT_SECURE;          }          elseif ($release['status'] == 'unpublished') {            $projects[$project]['status'] = UPDATE_REVOKED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'release-revoked',              'label' => t('Release revoked'),              'data' => t('Your currently installed release has been revoked, and is no longer available for download. Disabling everything included in this release or upgrading is strongly recommended!'),            );          }          elseif (isset($release['terms']['Release type']) &&                  in_array('Unsupported', $release['terms']['Release type'])) {            $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'release-not-supported',              'label' => t('Release not supported'),              'data' => t('Your currently installed release is now unsupported, and is no longer available for download. Disabling everything included in this release or upgrading is strongly recommended!'),            );          }        }        // Otherwise, ignore unpublished, insecure, or unsupported releases.        if ($release['status'] == 'unpublished' ||            (isset($release['terms']['Release type']) &&             (in_array('Insecure', $release['terms']['Release type']) ||              in_array('Unsupported', $release['terms']['Release type'])))) {          continue;        }        // See if this is a higher major version than our target and yet still        // supported. If so, record it as an "Also available" release.        if ($release['version_major'] > $target_major) {          if (in_array($release['version_major'], $supported_majors)) {            if (!isset($available[$project]['also'])) {              $available[$project]['also'] = array();            }            if (!isset($available[$project]['also'][$release['version_major']])) {              $available[$project]['also'][$release['version_major']] = $version;            }          }          // Otherwise, this release can't matter to us, since it's neither          // from the release series we're currently using nor the recommended          // release. We don't even care about security updates for this          // branch, since if a project maintainer puts out a security release          // at a higher major version and not at the lower major version,          // they must remove the lower version from the supported major          // versions at the same time, in which case we won't hit this code.          continue;        }        // Look for the 'latest version' if we haven't found it yet. Latest is        // defined as the most recent version for the target major version.        if (!isset($available[$project]['latest_version'])            && $release['version_major'] == $target_major) {          $available[$project]['latest_version'] = $version;        }        // Look for the development snapshot release for this branch.        if (!isset($available[$project]['dev_version'])            && $release['version_major'] == $target_major            && isset($release['version_extra'])            && $release['version_extra'] == 'dev') {          $available[$project]['dev_version'] = $version;        }        // Look for the 'recommended' version if we haven't found it yet (see        // phpdoc at the top of this function for the definition).        if (!isset($available[$project]['recommended'])            && $release['version_major'] == $target_major            && isset($release['version_patch'])) {          if ($patch != $release['version_patch']) {            $patch = $release['version_patch'];            $version_patch_changed = $release['version'];          }          if (empty($release['version_extra']) && $patch == $release['version_patch']) {            $available[$project]['recommended'] = $version_patch_changed;          }        }        // Stop searching once we hit the currently installed version.        if ($projects[$project]['existing_version'] === $version) {          break;        }        // If we're running a dev snapshot and have a timestamp, stop        // searching for security updates once we hit an official release        // older than what we've got. Allow 100 seconds of leeway to handle        // differences between the datestamp in the .info file and the        // timestamp of the tarball itself (which are usually off by 1 or 2        // seconds) so that we don't flag that as a new release.        if ($projects[$project]['install_type'] == 'dev') {          if (empty($projects[$project]['datestamp'])) {            // We don't have current timestamp info, so we can't know.            continue;          }          elseif (isset($release['date']) && ($projects[$project]['datestamp'] + 100 > $release['date'])) {            // We're newer than this, so we can skip it.            continue;          }        }        // See if this release is a security update.        if (isset($release['terms']['Release type'])            && in_array('Security update', $release['terms']['Release type'])) {          $projects[$project]['security updates'][] = $release;        }      }      // If we were unable to find a recommended version, then make the latest      // version the recommended version if possible.      if (!isset($available[$project]['recommended']) && isset($available[$project]['latest_version'])) {        $available[$project]['recommended'] = $available[$project]['latest_version'];      }      // Stash the info about available releases into our $projects array.      $projects[$project] += $available[$project];      //      // Check to see if we need an update or not.      //      if (!empty($projects[$project]['security updates'])) {        // If we found security updates, that always trumps any other status.        $projects[$project]['status'] = UPDATE_NOT_SECURE;      }      if (isset($projects[$project]['status'])) {        // If we already know the status, we're done.        continue;      }      // If we don't know what to recommend, there's nothing we can report.      // Bail out early.      if (!isset($projects[$project]['recommended'])) {        $projects[$project]['status'] = UPDATE_UNKNOWN;        $projects[$project]['reason'] = t('No available releases found');        continue;      }      // If we're running a dev snapshot, compare the date of the dev snapshot      // with the latest official version, and record the absolute latest in      // 'latest_dev' so we can correctly decide if there's a newer release      // than our current snapshot.      if ($projects[$project]['install_type'] == 'dev') {        if (isset($available[$project]['dev_version']) && $available[$project]['releases'][$available[$project]['dev_version']]['date'] > $available[$project]['releases'][$available[$project]['latest_version']]['date']) {          $projects[$project]['latest_dev'] = $available[$project]['dev_version'];        }        else {          $projects[$project]['latest_dev'] = $available[$project]['latest_version'];        }      }      // Figure out the status, based on what we've seen and the install type.      switch ($projects[$project]['install_type']) {        case 'official':          if ($projects[$project]['existing_version'] === $projects[$project]['recommended'] || $projects[$project]['existing_version'] === $projects[$project]['latest_version']) {            $projects[$project]['status'] = UPDATE_CURRENT;          }          else {            $projects[$project]['status'] = UPDATE_NOT_CURRENT;          }          break;        case 'dev':          $latest = $available[$project]['releases'][$projects[$project]['latest_dev']];          if (empty($projects[$project]['datestamp'])) {            $projects[$project]['status'] = UPDATE_NOT_CHECKED;            $projects[$project]['reason'] = t('Unknown release date');          }          elseif (($projects[$project]['datestamp'] + 100 > $latest['date'])) {            $projects[$project]['status'] = UPDATE_CURRENT;          }          else {            $projects[$project]['status'] = UPDATE_NOT_CURRENT;          }          break;        default:          $projects[$project]['status'] = UPDATE_UNKNOWN;          $projects[$project]['reason'] = t('Invalid info');      }    }    else {      $projects[$project]['status'] = UPDATE_UNKNOWN;      $projects[$project]['reason'] = t('No available releases found');    }  }  // Give other modules a chance to alter the status (for example, to allow a  // contrib module to provide fine-grained settings to ignore specific  // projects or releases).  drupal_alter('update_status', $projects);  // Cache the site's update status for at most 1 hour.  _update_cache_set('update_project_data', $projects, time() + 3600);  return $projects;}/** * Retrieve data from {cache_update} or empty the cache when necessary. * * Two very expensive arrays computed by this module are the list of all * installed modules and themes (and .info data, project associations, etc), * and the current status of the site relative to the currently available * releases. These two arrays are cached in the {cache_update} table and used * whenever possible. The cache is cleared whenever the administrator visits * the status report, available updates report, or the module or theme * administration pages, since we should always recompute the most current * values on any of those pages. * * Note: while both of these arrays are expensive to compute (in terms of disk * I/O and some fairly heavy CPU processing), neither of these is the actual * data about available updates that we have to fetch over the network from * updates.drupal.org. That information is stored with the * 'update_available_releases' cache ID -- it needs to persist longer than 1 * hour and never get invalidated just by visiting a page on the site. * * @param $cid *   The cache id of data to return from the cache. Valid options are *   'update_project_data' and 'update_project_projects'. * * @return *   The cached value of the $projects array generated by *   update_calculate_project_data() or update_get_projects(), or an empty *   array when the cache is cleared. */function update_project_cache($cid) {  $projects = array();  // On certain paths, we should clear the cache and recompute the projects or  // update status of the site to avoid presenting stale information.  $q = $_GET['q'];  $paths = array('admin/build/modules', 'admin/build/themes', 'admin/reports', 'admin/reports/updates', 'admin/reports/status', 'admin/reports/updates/check');  if (in_array($q, $paths)) {    _update_cache_clear($cid);  }  else {    $cache = _update_cache_get($cid);    if (!empty($cache->data) && $cache->expire > time()) {      $projects = $cache->data;    }  }  return $projects;}/** * Filter the project .info data to only save attributes we need. * * @param array $info *   Array of .info file data as returned by drupal_parse_info_file(). * * @return *   Array of .info file data we need for the Update manager. * * @see _update_process_info_list() */function update_filter_project_info($info) {  $whitelist = array(    '_info_file_ctime',    'datestamp',    'major',    'name',    'package',    'project',    'project status url',    'version',   );  return array_intersect_key($info, drupal_map_assoc($whitelist));}
<?php// $Id$/** * @file * API for handling file uploads and server file management. *//** * @defgroup file File interface * @{ * Common file handling functions. */define('FILE_DOWNLOADS_PUBLIC', 1);define('FILE_DOWNLOADS_PRIVATE', 2);define('FILE_CREATE_DIRECTORY', 1);define('FILE_MODIFY_PERMISSIONS', 2);define('FILE_EXISTS_RENAME', 0);define('FILE_EXISTS_REPLACE', 1);define('FILE_EXISTS_ERROR', 2);/** * A files status can be one of two values: temporary or permanent. The status * for each file Drupal manages is stored in the {files} tables. If the status * is temporary Drupal's file garbage collection will delete the file and * remove it from the files table after a set period of time. * * If you wish to add custom statuses for use by contrib modules please expand as * binary flags and consider the first 8 bits reserved. (0,1,2,4,8,16,32,64,128) */define('FILE_STATUS_TEMPORARY', 0);define('FILE_STATUS_PERMANENT', 1);/** * Create the download path to a file. * * @param $path A string containing the path of the file to generate URL for. * @return A string containing a URL that can be used to download the file. */function file_create_url($path) {  // Strip file_directory_path from $path. We only include relative paths in urls.  if (strpos($path, file_directory_path() .'/') === 0) {    $path = trim(substr($path, strlen(file_directory_path())), '\\/');  }  switch (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC)) {    case FILE_DOWNLOADS_PUBLIC:      return $GLOBALS['base_url'] .'/'. file_directory_path() .'/'. str_replace('\\', '/', $path);    case FILE_DOWNLOADS_PRIVATE:      return url('system/files/'. $path, array('absolute' => TRUE));  }}/** * Make sure the destination is a complete path and resides in the file system * directory, if it is not prepend the file system directory. * * @param $dest A string containing the path to verify. If this value is *   omitted, Drupal's 'files' directory will be used. * @return A string containing the path to file, with file system directory *   appended if necessary, or FALSE if the path is invalid (i.e. outside the *   configured 'files' or temp directories). */function file_create_path($dest = 0) {  $file_path = file_directory_path();  if (!$dest) {    return $file_path;  }  // file_check_location() checks whether the destination is inside the Drupal files directory.  if (file_check_location($dest, $file_path)) {    return $dest;  }  // check if the destination is instead inside the Drupal temporary files directory.  else if (file_check_location($dest, file_directory_temp())) {    return $dest;  }  // Not found, try again with prefixed directory path.  else if (file_check_location($file_path .'/'. $dest, $file_path)) {    return $file_path .'/'. $dest;  }  // File not found.  return FALSE;}/** * Check that the directory exists and is writable. Directories need to * have execute permissions to be considered a directory by FTP servers, etc. * * @param $directory A string containing the name of a directory path. * @param $mode A Boolean value to indicate if the directory should be created *   if it does not exist or made writable if it is read-only. * @param $form_item An optional string containing the name of a form item that *   any errors will be attached to. This is useful for settings forms that *   require the user to specify a writable directory. If it can't be made to *   work, a form error will be set preventing them from saving the settings. * @return FALSE when directory not found, or TRUE when directory exists. */function file_check_directory(&$directory, $mode = 0, $form_item = NULL) {  $directory = rtrim($directory, '/\\');  // Check if directory exists.  if (!is_dir($directory)) {    if (($mode & FILE_CREATE_DIRECTORY) && @mkdir($directory)) {      drupal_set_message(t('The directory %directory has been created.', array('%directory' => $directory)));      @chmod($directory, 0775); // Necessary for non-webserver users.    }    else {      if ($form_item) {        form_set_error($form_item, t('The directory %directory does not exist.', array('%directory' => $directory)));      }      return FALSE;    }  }  // Check to see if the directory is writable.  if (!is_writable($directory)) {    if (($mode & FILE_MODIFY_PERMISSIONS) && @chmod($directory, 0775)) {      drupal_set_message(t('The permissions of directory %directory have been changed to make it writable.', array('%directory' => $directory)));    }    else {      form_set_error($form_item, t('The directory %directory is not writable', array('%directory' => $directory)));      watchdog('file system', 'The directory %directory is not writable, because it does not have the correct permissions set.', array('%directory' => $directory), WATCHDOG_ERROR);      return FALSE;    }  }  if ((file_directory_path() == $directory || file_directory_temp() == $directory) && !is_file("$directory/.htaccess")) {    $htaccess_lines = "SetHandler Drupal_Security_Do_Not_Remove_See_SA_2006_006\nOptions None\nOptions +FollowSymLinks";    if (($fp = fopen("$directory/.htaccess", 'w')) && fputs($fp, $htaccess_lines)) {      fclose($fp);      chmod($directory .'/.htaccess', 0664);    }    else {      $variables = array('%directory' => $directory, '!htaccess' => '<br />'. nl2br(check_plain($htaccess_lines)));      form_set_error($form_item, t("Security warning: Couldn't write .htaccess file. Please create a .htaccess file in your %directory directory which contains the following lines: <code>!htaccess</code>", $variables));      watchdog('security', "Security warning: Couldn't write .htaccess file. Please create a .htaccess file in your %directory directory which contains the following lines: <code>!htaccess</code>", $variables, WATCHDOG_ERROR);    }  }  return TRUE;}/** * Checks path to see if it is a directory, or a dir/file. * * @param $path A string containing a file path. This will be set to the *   directory's path. * @return If the directory is not in a Drupal writable directory, FALSE is *   returned. Otherwise, the base name of the path is returned. */function file_check_path(&$path) {  // Check if path is a directory.  if (file_check_directory($path)) {    return '';  }  // Check if path is a possible dir/file.  $filename = basename($path);  $path = dirname($path);  if (file_check_directory($path)) {    return $filename;  }  return FALSE;}/** * Check if a file is really located inside $directory. Should be used to make * sure a file specified is really located within the directory to prevent * exploits. * * @code *   // Returns FALSE: *   file_check_location('/www/example.com/files/../../../etc/passwd', '/www/example.com/files'); * @endcode * * @param $source A string set to the file to check. * @param $directory A string where the file should be located. * @return 0 for invalid path or the real path of the source. */function file_check_location($source, $directory = '') {  $check = realpath($source);  if ($check) {    $source = $check;  }  else {    // This file does not yet exist    $source = realpath(dirname($source)) .'/'. basename($source);  }  $directory = realpath($directory);  if ($directory && strpos($source, $directory) !== 0) {    return 0;  }  return $source;}/** * Copies a file to a new location. This is a powerful function that in many ways * performs like an advanced version of copy(). * - Checks if $source and $dest are valid and readable/writable. * - Performs a file copy if $source is not equal to $dest. * - If file already exists in $dest either the call will error out, replace the *   file or rename the file based on the $replace parameter. * * @param $source A string specifying the file location of the original file. *   This parameter will contain the resulting destination filename in case of *   success. * @param $dest A string containing the directory $source should be copied to. *   If this value is omitted, Drupal's 'files' directory will be used. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return True for success, FALSE for failure. */function file_copy(&$source, $dest = 0, $replace = FILE_EXISTS_RENAME) {  $dest = file_create_path($dest);  $directory = $dest;  $basename = file_check_path($directory);  // Make sure we at least have a valid directory.  if ($basename === FALSE) {    $source = is_object($source) ? $source->filepath : $source;    drupal_set_message(t('The selected file %file could not be uploaded, because the destination %directory is not properly configured.', array('%file' => $source, '%directory' => $dest)), 'error');    watchdog('file system', 'The selected file %file could not be uploaded, because the destination %directory could not be found, or because its permissions do not allow the file to be written.', array('%file' => $source, '%directory' => $dest), WATCHDOG_ERROR);    return 0;  }  // Process a file upload object.  if (is_object($source)) {    $file = $source;    $source = $file->filepath;    if (!$basename) {      $basename = $file->filename;    }  }  $source = realpath($source);  if (!file_exists($source)) {    drupal_set_message(t('The selected file %file could not be copied, because no file by that name exists. Please check that you supplied the correct filename.', array('%file' => $source)), 'error');    return 0;  }  // If the destination file is not specified then use the filename of the source file.  $basename = $basename ? $basename : basename($source);  $dest = $directory .'/'. $basename;  // Make sure source and destination filenames are not the same, makes no sense  // to copy it if they are. In fact copying the file will most likely result in  // a 0 byte file. Which is bad. Real bad.  if ($source != realpath($dest)) {    if (!$dest = file_destination($dest, $replace)) {      drupal_set_message(t('The selected file %file could not be copied, because a file by that name already exists in the destination.', array('%file' => $source)), 'error');      return FALSE;    }    if (!@copy($source, $dest)) {      drupal_set_message(t('The selected file %file could not be copied.', array('%file' => $source)), 'error');      return 0;    }    // Give everyone read access so that FTP'd users or    // non-webserver users can see/read these files,    // and give group write permissions so group members    // can alter files uploaded by the webserver.    @chmod($dest, 0664);  }  if (isset($file) && is_object($file)) {    $file->filename = $basename;    $file->filepath = $dest;    $source = $file;  }  else {    $source = $dest;  }  return 1; // Everything went ok.}/** * Determines the destination path for a file depending on how replacement of * existing files should be handled. * * @param $destination A string specifying the desired path. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is *     unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return The destination file path or FALSE if the file already exists and *   FILE_EXISTS_ERROR was specified. */function file_destination($destination, $replace) {  if (file_exists($destination)) {    switch ($replace) {      case FILE_EXISTS_RENAME:        $basename = basename($destination);        $directory = dirname($destination);        $destination = file_create_filename($basename, $directory);        break;      case FILE_EXISTS_ERROR:        drupal_set_message(t('The selected file %file could not be copied, because a file by that name already exists in the destination.', array('%file' => $destination)), 'error');        return FALSE;    }  }  return $destination;}/** * Moves a file to a new location. * - Checks if $source and $dest are valid and readable/writable. * - Performs a file move if $source is not equal to $dest. * - If file already exists in $dest either the call will error out, replace the *   file or rename the file based on the $replace parameter. * * @param $source A string specifying the file location of the original file. *   This parameter will contain the resulting destination filename in case of *   success. * @param $dest A string containing the directory $source should be copied to. *   If this value is omitted, Drupal's 'files' directory will be used. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return True for success, FALSE for failure. */function file_move(&$source, $dest = 0, $replace = FILE_EXISTS_RENAME) {  $path_original = is_object($source) ? $source->filepath : $source;  if (file_copy($source, $dest, $replace)) {    $path_current = is_object($source) ? $source->filepath : $source;    if ($path_original == $path_current || file_delete($path_original)) {      return 1;    }    drupal_set_message(t('The removal of the original file %file has failed.', array('%file' => $path_original)), 'error');  }  return 0;}/** * Modify a filename as needed for security purposes. * * Dangerous file names will be altered; for instance, the file name * "exploit.php.pps" will become "exploit.php_.pps". All extensions that are * between 2 and 5 characters in length, internal to the file name, and not * included in $extensions will be altered by adding an underscore. If variable * 'allow_insecure_uploads' evaluates to TRUE, no alterations will be made. * * @param $filename *   File name to modify. * @param $extensions *   A space-separated list of extensions that should not be altered. * @param $alerts *   If TRUE, drupal_set_message() will be called to display a message if the *   file name was changed. * * @return *   The potentially modified $filename. */function file_munge_filename($filename, $extensions, $alerts = TRUE) {  $original = $filename;  // Allow potentially insecure uploads for very savvy users and admin  if (!variable_get('allow_insecure_uploads', 0)) {    $whitelist = array_unique(explode(' ', trim($extensions)));    // Split the filename up by periods. The first part becomes the basename    // the last part the final extension.    $filename_parts = explode('.', $filename);    $new_filename = array_shift($filename_parts); // Remove file basename.    $final_extension = array_pop($filename_parts); // Remove final extension.    // Loop through the middle parts of the name and add an underscore to the    // end of each section that could be a file extension but isn't in the list    // of allowed extensions.    foreach ($filename_parts as $filename_part) {      $new_filename .= '.'. $filename_part;      if (!in_array($filename_part, $whitelist) && preg_match("/^[a-zA-Z]{2,5}\d?$/", $filename_part)) {        $new_filename .= '_';      }    }    $filename = $new_filename .'.'. $final_extension;    if ($alerts && $original != $filename) {      drupal_set_message(t('For security reasons, your upload has been renamed to %filename.', array('%filename' => $filename)));    }  }  return $filename;}/** * Undo the effect of upload_munge_filename(). * * @param $filename string filename * @return string */function file_unmunge_filename($filename) {  return str_replace('_.', '.', $filename);}/** * Create a full file path from a directory and filename. If a file with the * specified name already exists, an alternative will be used. * * @param $basename string filename * @param $directory string directory * @return */function file_create_filename($basename, $directory) {  $dest = $directory .'/'. $basename;  if (file_exists($dest)) {    // Destination file already exists, generate an alternative.    if ($pos = strrpos($basename, '.')) {      $name = substr($basename, 0, $pos);      $ext = substr($basename, $pos);    }    else {      $name = $basename;    }    $counter = 0;    do {      $dest = $directory .'/'. $name .'_'. $counter++ . $ext;    } while (file_exists($dest));  }  return $dest;}/** * Delete a file. * * @param $path A string containing a file path. * @return TRUE for success, FALSE for failure. */function file_delete($path) {  if (is_file($path)) {    return unlink($path);  }}/** * Determine total disk space used by a single user or the whole filesystem. * * @param $uid *   An optional user id. A NULL value returns the total space used *   by all files. */function file_space_used($uid = NULL) {  if (isset($uid)) {    return (int) db_result(db_query('SELECT SUM(filesize) FROM {files} WHERE uid = %d', $uid));  }  return (int) db_result(db_query('SELECT SUM(filesize) FROM {files}'));}/** * Saves a file upload to a new location. The source file is validated as a * proper upload and handled as such. * * The file will be added to the files table as a temporary file. Temporary files * are periodically cleaned. To make the file permanent file call * file_set_status() to change its status. * * @param $source *   A string specifying the name of the upload field to save. * @param $validators *   An optional, associative array of callback functions used to validate the *   file. The keys are function names and the values arrays of callback *   parameters which will be passed in after the file object. The *   functions should return an array of error messages; an empty array *   indicates that the file passed validation. The functions will be called in *   the order specified. * @param $dest *   A string containing the directory $source should be copied to. If this is *   not provided or is not writable, the temporary directory will be used. * @param $replace *   A boolean indicating whether an existing file of the same name in the *   destination directory should overwritten. A false value will generate a *   new, unique filename in the destination directory. * @return *   An object containing the file information, or 0 in the event of an error. */function file_save_upload($source, $validators = array(), $dest = FALSE, $replace = FILE_EXISTS_RENAME) {  global $user;  static $upload_cache;  // Add in our check of the the file name length.  $validators['file_validate_name_length'] = array();  // Return cached objects without processing since the file will have  // already been processed and the paths in _FILES will be invalid.  if (isset($upload_cache[$source])) {    return $upload_cache[$source];  }  // If a file was uploaded, process it.  if (isset($_FILES['files']) && $_FILES['files']['name'][$source] && is_uploaded_file($_FILES['files']['tmp_name'][$source])) {    // Check for file upload errors and return FALSE if a    // lower level system error occurred.    switch ($_FILES['files']['error'][$source]) {      // @see http://php.net/manual/en/features.file-upload.errors.php      case UPLOAD_ERR_OK:        break;      case UPLOAD_ERR_INI_SIZE:      case UPLOAD_ERR_FORM_SIZE:        drupal_set_message(t('The file %file could not be saved, because it exceeds %maxsize, the maximum allowed size for uploads.', array('%file' => $source, '%maxsize' => format_size(file_upload_max_size()))), 'error');        return 0;      case UPLOAD_ERR_PARTIAL:      case UPLOAD_ERR_NO_FILE:        drupal_set_message(t('The file %file could not be saved, because the upload did not complete.', array('%file' => $source)), 'error');        return 0;        // Unknown error      default:        drupal_set_message(t('The file %file could not be saved. An unknown error has occurred.', array('%file' => $source)), 'error');        return 0;    }    // Build the list of non-munged extensions.    // @todo: this should not be here. we need to figure out the right place.    $extensions = '';    foreach ($user->roles as $rid => $name) {      $extensions .= ' '. variable_get("upload_extensions_$rid",      variable_get('upload_extensions_default', 'jpg jpeg gif png txt html doc xls pdf ppt pps odt ods odp'));    }    // Begin building file object.    $file = new stdClass();    $file->filename = file_munge_filename(trim(basename($_FILES['files']['name'][$source]), '.'), $extensions);    $file->filepath = $_FILES['files']['tmp_name'][$source];    $file->filemime = file_get_mimetype($file->filename);    // If the destination is not provided, or is not writable, then use the    // temporary directory.    if (empty($dest) || file_check_path($dest) === FALSE) {      $dest = file_directory_temp();    }    $file->source = $source;    $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), $replace);    $file->filesize = $_FILES['files']['size'][$source];    // Call the validation functions.    $errors = array();    foreach ($validators as $function => $args) {      array_unshift($args, $file);      // Make sure $file is passed around by reference.      $args[0] = &$file;      $errors = array_merge($errors, call_user_func_array($function, $args));    }    // Rename potentially executable files, to help prevent exploits.    if (preg_match('/\.(php|pl|py|cgi|asp|js)$/i', $file->filename) && (substr($file->filename, -4) != '.txt')) {            $file->filemime = 'text/plain';      $file->filepath .= '.txt';      $file->filename .= '.txt';      // As the file may be named example.php.txt, we need to munge again to      // convert to example.php_.txt, then create the correct destination.      $file->filename = file_munge_filename($file->filename, $extensions);      $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), $replace);    }    // Check for validation errors.    if (!empty($errors)) {      $message = t('The selected file %name could not be uploaded.', array('%name' => $file->filename));      if (count($errors) > 1) {        $message .= '<ul><li>'. implode('</li><li>', $errors) .'</li></ul>';      }      else {        $message .= ' '. array_pop($errors);      }      form_set_error($source, $message);      return 0;    }    // Move uploaded files from PHP's upload_tmp_dir to Drupal's temporary directory.    // This overcomes open_basedir restrictions for future file operations.    $file->filepath = $file->destination;    if (!move_uploaded_file($_FILES['files']['tmp_name'][$source], $file->filepath)) {      form_set_error($source, t('File upload error. Could not move uploaded file.'));      watchdog('file', 'Upload error. Could not move uploaded file %file to destination %destination.', array('%file' => $file->filename, '%destination' => $file->filepath));      return 0;    }    // If we made it this far it's safe to record this file in the database.    $file->uid = $user->uid;    $file->status = FILE_STATUS_TEMPORARY;    $file->timestamp = time();    drupal_write_record('files', $file);    // Add file to the cache.    $upload_cache[$source] = $file;    return $file;  }  return 0;}/** * Check for files with names longer than we can store in the database. * * @param $file *   A Drupal file object. * @return *   An array. If the file name is too long, it will contain an error message. */function file_validate_name_length($file) {  $errors = array();  if (strlen($file->filename) > 255) {    $errors[] = t('Its name exceeds the 255 characters limit. Please rename the file and try again.');  }  return $errors;}/** * Check that the filename ends with an allowed extension. This check is not * enforced for the user #1. * * @param $file *   A Drupal file object. * @param $extensions *   A string with a space separated * @return *   An array. If the file extension is not allowed, it will contain an error message. */function file_validate_extensions($file, $extensions) {  global $user;  $errors = array();  // Bypass validation for uid  = 1.  if ($user->uid != 1) {    $regex = '/\.('. ereg_replace(' +', '|', preg_quote($extensions)) .')$/i';    if (!preg_match($regex, $file->filename)) {      $errors[] = t('Only files with the following extensions are allowed: %files-allowed.', array('%files-allowed' => $extensions));    }  }  return $errors;}/** * Check that the file's size is below certain limits. This check is not * enforced for the user #1. * * @param $file *   A Drupal file object. * @param $file_limit *   An integer specifying the maximum file size in bytes. Zero indicates that *   no limit should be enforced. * @param $user_limit *   An integer specifying the maximum number of bytes the user is allowed. Zero *   indicates that no limit should be enforced. * @return *   An array. If the file size exceeds limits, it will contain an error message. */function file_validate_size($file, $file_limit = 0, $user_limit = 0) {  global $user;  $errors = array();  // Bypass validation for uid  = 1.  if ($user->uid != 1) {    if ($file_limit && $file->filesize > $file_limit) {      $errors[] = t('The file is %filesize exceeding the maximum file size of %maxsize.', array('%filesize' => format_size($file->filesize), '%maxsize' => format_size($file_limit)));    }    // Save a query by only calling file_space_used() when a limit is provided.    if ($user_limit && (file_space_used($user->uid) + $file->filesize) > $user_limit) {      $errors[] = t('The file is %filesize which would exceed your disk quota of %quota.', array('%filesize' => format_size($file->filesize), '%quota' => format_size($user_limit)));    }  }  return $errors;}/** * Check that the file is recognized by image_get_info() as an image. * * @param $file *   A Drupal file object. * @return *   An array. If the file is not an image, it will contain an error message. */function file_validate_is_image(&$file) {  $errors = array();  $info = image_get_info($file->filepath);  if (!$info || empty($info['extension'])) {    $errors[] = t('Only JPEG, PNG and GIF images are allowed.');  }  return $errors;}/** * If the file is an image verify that its dimensions are within the specified * maximum and minimum dimensions. Non-image files will be ignored. * * @param $file *   A Drupal file object. This function may resize the file affecting its size. * @param $maximum_dimensions *   An optional string in the form WIDTHxHEIGHT e.g. '640x480' or '85x85'. If *   an image toolkit is installed the image will be resized down to these *   dimensions. A value of 0 indicates no restriction on size, so resizing *   will be attempted. * @param $minimum_dimensions *   An optional string in the form WIDTHxHEIGHT. This will check that the image *   meets a minimum size. A value of 0 indicates no restriction. * @return *   An array. If the file is an image and did not meet the requirements, it *   will contain an error message. */function file_validate_image_resolution(&$file, $maximum_dimensions = 0, $minimum_dimensions = 0) {  $errors = array();  // Check first that the file is an image.  if ($info = image_get_info($file->filepath)) {    if ($maximum_dimensions) {      // Check that it is smaller than the given dimensions.      list($width, $height) = explode('x', $maximum_dimensions);      if ($info['width'] > $width || $info['height'] > $height) {        // Try to resize the image to fit the dimensions.        if (image_get_toolkit() && image_scale($file->filepath, $file->filepath, $width, $height)) {          drupal_set_message(t('The image was resized to fit within the maximum allowed dimensions of %dimensions pixels.', array('%dimensions' => $maximum_dimensions)));          // Clear the cached filesize and refresh the image information.          clearstatcache();          $info = image_get_info($file->filepath);          $file->filesize = $info['file_size'];        }        else {          $errors[] = t('The image is too large; the maximum dimensions are %dimensions pixels.', array('%dimensions' => $maximum_dimensions));        }      }    }    if ($minimum_dimensions) {      // Check that it is larger than the given dimensions.      list($width, $height) = explode('x', $minimum_dimensions);      if ($info['width'] < $width || $info['height'] < $height) {        $errors[] = t('The image is too small; the minimum dimensions are %dimensions pixels.', array('%dimensions' => $minimum_dimensions));      }    }  }  return $errors;}/** * Save a string to the specified destination. * * @param $data A string containing the contents of the file. * @param $dest A string containing the destination location. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * * @return A string containing the resulting filename or 0 on error */function file_save_data($data, $dest, $replace = FILE_EXISTS_RENAME) {  $temp = file_directory_temp();  // On Windows, tempnam() requires an absolute path, so we use realpath().  $file = tempnam(realpath($temp), 'file');  if (!$fp = fopen($file, 'wb')) {    drupal_set_message(t('The file could not be created.'), 'error');    return 0;  }  fwrite($fp, $data);  fclose($fp);  if (!file_move($file, $dest, $replace)) {    return 0;  }  return $file;}/** * Set the status of a file. * * @param file A Drupal file object * @param status A status value to set the file to. * @return FALSE on failure, TRUE on success and $file->status will contain the *     status. */function file_set_status(&$file, $status) {  if (db_query('UPDATE {files} SET status = %d WHERE fid = %d', $status, $file->fid)) {    $file->status = $status;    return TRUE;  }  return FALSE;}/** * Transfer file using http to client. Pipes a file through Drupal to the * client. * * @param $source File to transfer. * @param $headers An array of http headers to send along with file. */function file_transfer($source, $headers) {  if (ob_get_level()) {    ob_end_clean();  }  foreach ($headers as $header) {    // To prevent HTTP header injection, we delete new lines that are    // not followed by a space or a tab.    // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2    $header = preg_replace('/\r?\n(?!\t| )/', '', $header);    drupal_set_header($header);  }  $source = file_create_path($source);  // Transfer file in 1024 byte chunks to save memory usage.  if ($fd = fopen($source, 'rb')) {    while (!feof($fd)) {      print fread($fd, 1024);    }    fclose($fd);  }  else {    drupal_not_found();  }  exit();}/** * Call modules that implement hook_file_download() to find out if a file is * accessible and what headers it should be transferred with. If a module * returns -1 drupal_access_denied() will be returned. If one or more modules * returned headers the download will start with the returned headers. If no * modules respond drupal_not_found() will be returned. */function file_download() {  // Merge remainder of arguments from GET['q'], into relative file path.  $args = func_get_args();  $filepath = implode('/', $args);  // Maintain compatibility with old ?file=paths saved in node bodies.  if (isset($_GET['file'])) {    $filepath =  $_GET['file'];  }  if (file_exists(file_create_path($filepath))) {    $headers = module_invoke_all('file_download', $filepath);    if (in_array(-1, $headers)) {      return drupal_access_denied();    }    if (count($headers)) {      file_transfer($filepath, $headers);    }  }  return drupal_not_found();}/** * Finds all files that match a given mask in a given directory. * Directories and files beginning with a period are excluded; this * prevents hidden files and directories (such as SVN working directories) * from being scanned. * * @param $dir *   The base directory for the scan, without trailing slash. * @param $mask *   The regular expression of the files to find. * @param $nomask *   An array of files/directories to ignore. * @param $callback *   The callback function to call for each match. * @param $recurse *   When TRUE, the directory scan will recurse the entire tree *   starting at the provided directory. * @param $key *   The key to be used for the returned array of files. Possible *   values are "filename", for the path starting with $dir, *   "basename", for the basename of the file, and "name" for the name *   of the file without an extension. * @param $min_depth *   Minimum depth of directories to return files from. * @param $depth *   Current depth of recursion. This parameter is only used internally and should not be passed. * * @return *   An associative array (keyed on the provided key) of objects with *   "path", "basename", and "name" members corresponding to the *   matching files. */function file_scan_directory($dir, $mask, $nomask = array('.', '..', 'CVS'), $callback = 0, $recurse = TRUE, $key = 'filename', $min_depth = 0, $depth = 0) {  $key = (in_array($key, array('filename', 'basename', 'name')) ? $key : 'filename');  $files = array();  if (is_dir($dir) && $handle = opendir($dir)) {    while (FALSE !== ($file = readdir($handle))) {      if (!in_array($file, $nomask) && $file[0] != '.') {        if (is_dir("$dir/$file") && $recurse) {          // Give priority to files in this folder by merging them in after any subdirectory files.          $files = array_merge(file_scan_directory("$dir/$file", $mask, $nomask, $callback, $recurse, $key, $min_depth, $depth + 1), $files);        }        elseif ($depth >= $min_depth && ereg($mask, $file)) {          // Always use this match over anything already set in $files with the same $$key.          $filename = "$dir/$file";          $basename = basename($file);          $name = substr($basename, 0, strrpos($basename, '.'));          $files[$$key] = new stdClass();          $files[$$key]->filename = $filename;          $files[$$key]->basename = $basename;          $files[$$key]->name = $name;          if ($callback) {            $callback($filename);          }        }      }    }    closedir($handle);  }  return $files;}/** * Determine the default temporary directory. * * @return A string containing a temp directory. */function file_directory_temp() {  $temporary_directory = variable_get('file_directory_temp', NULL);  if (is_null($temporary_directory)) {    $directories = array();    // Has PHP been set with an upload_tmp_dir?    if (ini_get('upload_tmp_dir')) {      $directories[] = ini_get('upload_tmp_dir');    }    // Operating system specific dirs.    if (substr(PHP_OS, 0, 3) == 'WIN') {      $directories[] = 'c:\\windows\\temp';      $directories[] = 'c:\\winnt\\temp';      $path_delimiter = '\\';    }    else {      $directories[] = '/tmp';      $path_delimiter = '/';    }    foreach ($directories as $directory) {      if (!$temporary_directory && is_dir($directory)) {        $temporary_directory = $directory;      }    }    // if a directory has been found, use it, otherwise default to 'files/tmp' or 'files\\tmp';    $temporary_directory = $temporary_directory ? $temporary_directory : file_directory_path() . $path_delimiter .'tmp';    variable_set('file_directory_temp', $temporary_directory);  }  return $temporary_directory;}/** * Determine the default 'files' directory. * * @return A string containing the path to Drupal's 'files' directory. */function file_directory_path() {  return variable_get('file_directory_path', conf_path() .'/files');}/** * Determine the maximum file upload size by querying the PHP settings. * * @return *   A file size limit in bytes based on the PHP upload_max_filesize and post_max_size */function file_upload_max_size() {  static $max_size = -1;  if ($max_size < 0) {    $upload_max = parse_size(ini_get('upload_max_filesize'));    $post_max = parse_size(ini_get('post_max_size'));    $max_size = ($upload_max < $post_max) ? $upload_max : $post_max;  }  return $max_size;}/** * Determine an Internet Media Type, or MIME type from a filename. * * @param $filename *   Name of the file, including extension. * @param $mapping *   An optional array of extension to media type mappings in the form *   'extension1|extension2|...' => 'type'. * * @return *   The internet media type registered for the extension or application/octet-stream for unknown extensions. */function file_get_mimetype($filename, $mapping = NULL) {  if (!is_array($mapping)) {    $mapping = variable_get('mime_extension_mapping', array(      'ez' => 'application/andrew-inset',      'atom' => 'application/atom',      'atomcat' => 'application/atomcat+xml',      'atomsrv' => 'application/atomserv+xml',      'cap|pcap' => 'application/cap',      'cu' => 'application/cu-seeme',      'tsp' => 'application/dsptype',      'spl' => 'application/x-futuresplash',      'hta' => 'application/hta',      'jar' => 'application/java-archive',      'ser' => 'application/java-serialized-object',      'class' => 'application/java-vm',      'hqx' => 'application/mac-binhex40',      'cpt' => 'image/x-corelphotopaint',      'nb' => 'application/mathematica',      'mdb' => 'application/msaccess',      'doc|dot' => 'application/msword',      'bin' => 'application/octet-stream',      'oda' => 'application/oda',      'ogg|ogx' => 'application/ogg',      'pdf' => 'application/pdf',      'key' => 'application/pgp-keys',      'pgp' => 'application/pgp-signature',      'prf' => 'application/pics-rules',      'ps|ai|eps' => 'application/postscript',      'rar' => 'application/rar',      'rdf' => 'application/rdf+xml',      'rss' => 'application/rss+xml',      'rtf' => 'application/rtf',      'smi|smil' => 'application/smil',      'wpd' => 'application/wordperfect',      'wp5' => 'application/wordperfect5.1',      'xhtml|xht' => 'application/xhtml+xml',      'xml|xsl' => 'application/xml',      'zip' => 'application/zip',      'cdy' => 'application/vnd.cinderella',      'kml' => 'application/vnd.google-earth.kml+xml',      'kmz' => 'application/vnd.google-earth.kmz',      'xul' => 'application/vnd.mozilla.xul+xml',      'xls|xlb|xlt' => 'application/vnd.ms-excel',      'cat' => 'application/vnd.ms-pki.seccat',      'stl' => 'application/vnd.ms-pki.stl',      'ppt|pps' => 'application/vnd.ms-powerpoint',      'odc' => 'application/vnd.oasis.opendocument.chart',      'odb' => 'application/vnd.oasis.opendocument.database',      'odf' => 'application/vnd.oasis.opendocument.formula',      'odg' => 'application/vnd.oasis.opendocument.graphics',      'otg' => 'application/vnd.oasis.opendocument.graphics-template',      'odi' => 'application/vnd.oasis.opendocument.image',      'odp' => 'application/vnd.oasis.opendocument.presentation',      'otp' => 'application/vnd.oasis.opendocument.presentation-template',      'ods' => 'application/vnd.oasis.opendocument.spreadsheet',      'ots' => 'application/vnd.oasis.opendocument.spreadsheet-template',      'odt' => 'application/vnd.oasis.opendocument.text',      'odm' => 'application/vnd.oasis.opendocument.text-master',      'ott' => 'application/vnd.oasis.opendocument.text-template',      'oth' => 'application/vnd.oasis.opendocument.text-web',      'docm' => 'application/vnd.ms-word.document.macroEnabled.12',      'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',      'dotm' => 'application/vnd.ms-word.template.macroEnabled.12',      'dotx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',      'potm' => 'application/vnd.ms-powerpoint.template.macroEnabled.12',      'potx' => 'application/vnd.openxmlformats-officedocument.presentationml.template',      'ppam' => 'application/vnd.ms-powerpoint.addin.macroEnabled.12',      'ppsm' => 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',      'ppsx' => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',      'pptm' => 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',      'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',      'xlam' => 'application/vnd.ms-excel.addin.macroEnabled.12',      'xlsb' => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',      'xlsm' => 'application/vnd.ms-excel.sheet.macroEnabled.12',      'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',      'xltm' => 'application/vnd.ms-excel.template.macroEnabled.12',      'xltx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',      'cod' => 'application/vnd.rim.cod',      'mmf' => 'application/vnd.smaf',      'sdc' => 'application/vnd.stardivision.calc',      'sds' => 'application/vnd.stardivision.chart',      'sda' => 'application/vnd.stardivision.draw',      'sdd' => 'application/vnd.stardivision.impress',      'sdf' => 'application/vnd.stardivision.math',      'sdw' => 'application/vnd.stardivision.writer',      'sgl' => 'application/vnd.stardivision.writer-global',      'sxc' => 'application/vnd.sun.xml.calc',      'stc' => 'application/vnd.sun.xml.calc.template',      'sxd' => 'application/vnd.sun.xml.draw',      'std' => 'application/vnd.sun.xml.draw.template',      'sxi' => 'application/vnd.sun.xml.impress',      'sti' => 'application/vnd.sun.xml.impress.template',      'sxm' => 'application/vnd.sun.xml.math',      'sxw' => 'application/vnd.sun.xml.writer',      'sxg' => 'application/vnd.sun.xml.writer.global',      'stw' => 'application/vnd.sun.xml.writer.template',      'sis' => 'application/vnd.symbian.install',      'vsd' => 'application/vnd.visio',      'wbxml' => 'application/vnd.wap.wbxml',      'wmlc' => 'application/vnd.wap.wmlc',      'wmlsc' => 'application/vnd.wap.wmlscriptc',      'wk' => 'application/x-123',      '7z' => 'application/x-7z-compressed',      'abw' => 'application/x-abiword',      'dmg' => 'application/x-apple-diskimage',      'bcpio' => 'application/x-bcpio',      'torrent' => 'application/x-bittorrent',      'cab' => 'application/x-cab',      'cbr' => 'application/x-cbr',      'cbz' => 'application/x-cbz',      'cdf' => 'application/x-cdf',      'vcd' => 'application/x-cdlink',      'pgn' => 'application/x-chess-pgn',      'cpio' => 'application/x-cpio',      'csh' => 'text/x-csh',      'deb|udeb' => 'application/x-debian-package',      'dcr|dir|dxr' => 'application/x-director',      'dms' => 'application/x-dms',      'wad' => 'application/x-doom',      'dvi' => 'application/x-dvi',      'rhtml' => 'application/x-httpd-eruby',      'flac' => 'application/x-flac',      'pfa|pfb|gsf|pcf|pcf.Z' => 'application/x-font',      'mm' => 'application/x-freemind',      'gnumeric' => 'application/x-gnumeric',      'sgf' => 'application/x-go-sgf',      'gcf' => 'application/x-graphing-calculator',      'gtar|tgz|taz' => 'application/x-gtar',      'hdf' => 'application/x-hdf',      'phtml|pht|php' => 'application/x-httpd-php',      'phps' => 'application/x-httpd-php-source',      'php3' => 'application/x-httpd-php3',      'php3p' => 'application/x-httpd-php3-preprocessed',      'php4' => 'application/x-httpd-php4',      'ica' => 'application/x-ica',      'ins|isp' => 'application/x-internet-signup',      'iii' => 'application/x-iphone',      'iso' => 'application/x-iso9660-image',      'jnlp' => 'application/x-java-jnlp-file',      'js' => 'application/x-javascript',      'jmz' => 'application/x-jmol',      'chrt' => 'application/x-kchart',      'kil' => 'application/x-killustrator',      'skp|skd|skt|skm' => 'application/x-koan',      'kpr|kpt' => 'application/x-kpresenter',      'ksp' => 'application/x-kspread',      'kwd|kwt' => 'application/x-kword',      'latex' => 'application/x-latex',      'lha' => 'application/x-lha',      'lyx' => 'application/x-lyx',      'lzh' => 'application/x-lzh',      'lzx' => 'application/x-lzx',      'frm|maker|frame|fm|fb|book|fbdoc' => 'application/x-maker',      'mif' => 'application/x-mif',      'wmd' => 'application/x-ms-wmd',      'wmz' => 'application/x-ms-wmz',      'com|exe|bat|dll' => 'application/x-msdos-program',      'msi' => 'application/x-msi',      'nc' => 'application/x-netcdf',      'pac' => 'application/x-ns-proxy-autoconfig',      'nwc' => 'application/x-nwc',      'o' => 'application/x-object',      'oza' => 'application/x-oz-application',      'p7r' => 'application/x-pkcs7-certreqresp',      'crl' => 'application/x-pkcs7-crl',      'pyc|pyo' => 'application/x-python-code',      'qtl' => 'application/x-quicktimeplayer',      'rpm' => 'application/x-redhat-package-manager',      'sh' => 'text/x-sh',      'shar' => 'application/x-shar',      'swf|swfl' => 'application/x-shockwave-flash',      'sit|sitx' => 'application/x-stuffit',      'sv4cpio' => 'application/x-sv4cpio',      'sv4crc' => 'application/x-sv4crc',      'tar' => 'application/x-tar',      'tcl' => 'application/x-tcl',      'gf' => 'application/x-tex-gf',      'pk' => 'application/x-tex-pk',      'texinfo|texi' => 'application/x-texinfo',      '~|%|bak|old|sik' => 'application/x-trash',      't|tr|roff' => 'application/x-troff',      'man' => 'application/x-troff-man',      'me' => 'application/x-troff-me',      'ms' => 'application/x-troff-ms',      'ustar' => 'application/x-ustar',      'src' => 'application/x-wais-source',      'wz' => 'application/x-wingz',      'crt' => 'application/x-x509-ca-cert',      'xcf' => 'application/x-xcf',      'fig' => 'application/x-xfig',      'xpi' => 'application/x-xpinstall',      'au|snd' => 'audio/basic',      'mid|midi|kar' => 'audio/midi',      'mpga|mpega|mp2|mp3|m4a' => 'audio/mpeg',      'f4a|f4b' => 'audio/mp4',      'm3u' => 'audio/x-mpegurl',      'oga|spx' => 'audio/ogg',      'sid' => 'audio/prs.sid',      'aif|aiff|aifc' => 'audio/x-aiff',      'gsm' => 'audio/x-gsm',      'wma' => 'audio/x-ms-wma',      'wax' => 'audio/x-ms-wax',      'ra|rm|ram' => 'audio/x-pn-realaudio',      'ra' => 'audio/x-realaudio',      'pls' => 'audio/x-scpls',      'sd2' => 'audio/x-sd2',      'wav' => 'audio/x-wav',      'alc' => 'chemical/x-alchemy',      'cac|cache' => 'chemical/x-cache',      'csf' => 'chemical/x-cache-csf',      'cbin|cascii|ctab' => 'chemical/x-cactvs-binary',      'cdx' => 'chemical/x-cdx',      'cer' => 'chemical/x-cerius',      'c3d' => 'chemical/x-chem3d',      'chm' => 'chemical/x-chemdraw',      'cif' => 'chemical/x-cif',      'cmdf' => 'chemical/x-cmdf',      'cml' => 'chemical/x-cml',      'cpa' => 'chemical/x-compass',      'bsd' => 'chemical/x-crossfire',      'csml|csm' => 'chemical/x-csml',      'ctx' => 'chemical/x-ctx',      'cxf|cef' => 'chemical/x-cxf',      'emb|embl' => 'chemical/x-embl-dl-nucleotide',      'spc' => 'chemical/x-galactic-spc',      'inp|gam|gamin' => 'chemical/x-gamess-input',      'fch|fchk' => 'chemical/x-gaussian-checkpoint',      'cub' => 'chemical/x-gaussian-cube',      'gau|gjc|gjf' => 'chemical/x-gaussian-input',      'gal' => 'chemical/x-gaussian-log',      'gcg' => 'chemical/x-gcg8-sequence',      'gen' => 'chemical/x-genbank',      'hin' => 'chemical/x-hin',      'istr|ist' => 'chemical/x-isostar',      'jdx|dx' => 'chemical/x-jcamp-dx',      'kin' => 'chemical/x-kinemage',      'mcm' => 'chemical/x-macmolecule',      'mmd|mmod' => 'chemical/x-macromodel-input',      'mol' => 'chemical/x-mdl-molfile',      'rd' => 'chemical/x-mdl-rdfile',      'rxn' => 'chemical/x-mdl-rxnfile',      'sd|sdf' => 'chemical/x-mdl-sdfile',      'tgf' => 'chemical/x-mdl-tgf',      'mcif' => 'chemical/x-mmcif',      'mol2' => 'chemical/x-mol2',      'b' => 'chemical/x-molconn-Z',      'gpt' => 'chemical/x-mopac-graph',      'mop|mopcrt|mpc|dat|zmt' => 'chemical/x-mopac-input',      'moo' => 'chemical/x-mopac-out',      'mvb' => 'chemical/x-mopac-vib',      'asn' => 'chemical/x-ncbi-asn1-spec',      'prt|ent' => 'chemical/x-ncbi-asn1-ascii',      'val|aso' => 'chemical/x-ncbi-asn1-binary',      'pdb|ent' => 'chemical/x-pdb',      'ros' => 'chemical/x-rosdal',      'sw' => 'chemical/x-swissprot',      'vms' => 'chemical/x-vamas-iso14976',      'vmd' => 'chemical/x-vmd',      'xtel' => 'chemical/x-xtel',      'xyz' => 'chemical/x-xyz',      'gif' => 'image/gif',      'ief' => 'image/ief',      'jpeg|jpg|jpe' => 'image/jpeg',      'pcx' => 'image/pcx',      'png' => 'image/png',      'svg|svgz' => 'image/svg+xml',      'tiff|tif' => 'image/tiff',      'djvu|djv' => 'image/vnd.djvu',      'wbmp' => 'image/vnd.wap.wbmp',      'ras' => 'image/x-cmu-raster',      'cdr' => 'image/x-coreldraw',      'pat' => 'image/x-coreldrawpattern',      'cdt' => 'image/x-coreldrawtemplate',      'ico' => 'image/x-icon',      'art' => 'image/x-jg',      'jng' => 'image/x-jng',      'bmp' => 'image/x-ms-bmp',      'psd' => 'image/x-photoshop',      'pnm' => 'image/x-portable-anymap',      'pbm' => 'image/x-portable-bitmap',      'pgm' => 'image/x-portable-graymap',      'ppm' => 'image/x-portable-pixmap',      'rgb' => 'image/x-rgb',      'xbm' => 'image/x-xbitmap',      'xpm' => 'image/x-xpixmap',      'xwd' => 'image/x-xwindowdump',      'eml' => 'message/rfc822',      'igs|iges' => 'model/iges',      'msh|mesh|silo' => 'model/mesh',      'wrl|vrml' => 'model/vrml',      'ics|icz' => 'text/calendar',      'css' => 'text/css',      'csv' => 'text/csv',      '323' => 'text/h323',      'html|htm|shtml' => 'text/html',      'uls' => 'text/iuls',      'mml' => 'text/mathml',      'asc|txt|text|pot' => 'text/plain',      'rtx' => 'text/richtext',      'sct|wsc' => 'text/scriptlet',      'tm|ts' => 'text/texmacs',      'tsv' => 'text/tab-separated-values',      'jad' => 'text/vnd.sun.j2me.app-descriptor',      'wml' => 'text/vnd.wap.wml',      'wmls' => 'text/vnd.wap.wmlscript',      'bib' => 'text/x-bibtex',      'boo' => 'text/x-boo',      'h++|hpp|hxx|hh' => 'text/x-c++hdr',      'c++|cpp|cxx|cc' => 'text/x-c++src',      'h' => 'text/x-chdr',      'htc' => 'text/x-component',      'c' => 'text/x-csrc',      'd' => 'text/x-dsrc',      'diff|patch' => 'text/x-diff',      'hs' => 'text/x-haskell',      'java' => 'text/x-java',      'lhs' => 'text/x-literate-haskell',      'moc' => 'text/x-moc',      'p|pas' => 'text/x-pascal',      'gcd' => 'text/x-pcs-gcd',      'pl|pm' => 'text/x-perl',      'py' => 'text/x-python',      'etx' => 'text/x-setext',      'tcl|tk' => 'text/x-tcl',      'tex|ltx|sty|cls' => 'text/x-tex',      'vcs' => 'text/x-vcalendar',      'vcf' => 'text/x-vcard',      '3gp' => 'video/3gpp',      'dl' => 'video/dl',      'dif|dv' => 'video/dv',      'fli' => 'video/fli',      'gl' => 'video/gl',      'mpeg|mpg|mpe' => 'video/mpeg',      'mp4|f4v|f4p' => 'video/mp4',      'flv' => 'video/x-flv',      'ogv' => 'video/ogg',      'qt|mov' => 'video/quicktime',      'mxu' => 'video/vnd.mpegurl',      'lsf|lsx' => 'video/x-la-asf',      'mng' => 'video/x-mng',      'asf|asx' => 'video/x-ms-asf',      'wm' => 'video/x-ms-wm',      'wmv' => 'video/x-ms-wmv',      'wmx' => 'video/x-ms-wmx',      'wvx' => 'video/x-ms-wvx',      'avi' => 'video/x-msvideo',      'movie' => 'video/x-sgi-movie',      'ice' => 'x-conference/x-cooltalk',      'sisx' => 'x-epoc/x-sisx-app',      'vrm|vrml|wrl' => 'x-world/x-vrml',      'xps' => 'application/vnd.ms-xpsdocument',    ));  }  foreach ($mapping as $ext_preg => $mime_match) {    if (preg_match('!\.('. $ext_preg .')$!i', $filename)) {      return $mime_match;    }  }  return 'application/octet-stream';}/** * @} End of "defgroup file". */
<?php// $Id$/** * @file * Enable users to post using applications that support XML-RPC blog APIs. *//** * Implementation of hook_help(). */function blogapi_help($path, $arg) {  switch ($path) {    case 'admin/help#blogapi':      $output = '<p>'. t("The Blog API module allows your site's users to access and post to their blogs from external blogging clients. External blogging clients are available for a wide range of desktop operating systems, and generally provide a feature-rich graphical environment for creating and editing posts.") .'</p>';      $output .= '<p>'. t('<a href="@ecto-link">Ecto</a>, a blogging client available for both Mac OS X and Microsoft Windows, can be used with Blog API. Blog API also supports <a href="@blogger-api">Blogger API</a>, <a href="@metaweblog-api">MetaWeblog API</a>, and most of the <a href="@movabletype-api">Movable Type API</a>. Blogging clients and other services (e.g. <a href="@flickr">Flickr\'s</a> "post to blog") that support these APIs may also be compatible.', array('@ecto-link' => url('http://infinite-sushi.com/software/ecto/'), '@blogger-api' => url('http://www.blogger.com/developers/api/1_docs/'), '@metaweblog-api' => url('http://www.xmlrpc.com/metaWeblogApi'), '@movabletype-api' => url('http://www.movabletype.org/docs/mtmanual_programmatic.html'), '@flickr' => url('http://www.flickr.com'))) .'</p>';      $output .= '<p>'. t('Select the content types available to external clients on the <a href="@blogapi-settings">Blog API settings page</a>. If supported and available, each content type will be displayed as a separate "blog" by the external client.', array('@blogapi-settings' => url('admin/settings/blogapi'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@blogapi">Blog API module</a>.', array('@blogapi' => url('http://drupal.org/handbook/modules/blogapi/'))) .'</p>';      return $output;  }}/** * Implementation of hook_perm(). */function blogapi_perm() {  return array('administer content with blog api');}/** * Implementation of hook_xmlrpc(). */function blogapi_xmlrpc() {  return array(    array(      'blogger.getUsersBlogs',      'blogapi_blogger_get_users_blogs',      array('array', 'string', 'string', 'string'),      t('Returns a list of blogs to which an author has posting privileges.')),    array(      'blogger.getUserInfo',      'blogapi_blogger_get_user_info',      array('struct', 'string', 'string', 'string'),      t('Returns information about an author in the system.')),    array(      'blogger.newPost',      'blogapi_blogger_new_post',      array('string', 'string', 'string', 'string', 'string', 'string', 'boolean'),      t('Creates a new post, and optionally publishes it.')),    array(      'blogger.editPost',      'blogapi_blogger_edit_post',      array('boolean', 'string', 'string', 'string', 'string', 'string', 'boolean'),      t('Updates the information about an existing post.')),    array(      'blogger.getPost',      'blogapi_blogger_get_post',      array('struct', 'string', 'string', 'string', 'string'),      t('Returns information about a specific post.')),    array(      'blogger.deletePost',      'blogapi_blogger_delete_post',      array('boolean', 'string', 'string', 'string', 'string', 'boolean'),      t('Deletes a post.')),    array(      'blogger.getRecentPosts',      'blogapi_blogger_get_recent_posts',      array('array', 'string', 'string', 'string', 'string', 'int'),      t('Returns a list of the most recent posts in the system.')),    array(      'metaWeblog.newPost',      'blogapi_metaweblog_new_post',      array('string', 'string', 'string', 'string', 'struct', 'boolean'),      t('Creates a new post, and optionally publishes it.')),    array(      'metaWeblog.editPost',      'blogapi_metaweblog_edit_post',      array('boolean', 'string', 'string', 'string', 'struct', 'boolean'),      t('Updates information about an existing post.')),    array(      'metaWeblog.getPost',      'blogapi_metaweblog_get_post',      array('struct', 'string', 'string', 'string'),      t('Returns information about a specific post.')),    array(      'metaWeblog.newMediaObject',      'blogapi_metaweblog_new_media_object',      array('string', 'string', 'string', 'string', 'struct'),      t('Uploads a file to your webserver.')),    array(      'metaWeblog.getCategories',      'blogapi_metaweblog_get_category_list',      array('struct', 'string', 'string', 'string'),      t('Returns a list of all categories to which the post is assigned.')),    array(      'metaWeblog.getRecentPosts',      'blogapi_metaweblog_get_recent_posts',      array('array', 'string', 'string', 'string', 'int'),      t('Returns a list of the most recent posts in the system.')),    array(      'mt.getRecentPostTitles',      'blogapi_mt_get_recent_post_titles',      array('array', 'string', 'string', 'string', 'int'),      t('Returns a bandwidth-friendly list of the most recent posts in the system.')),    array(      'mt.getCategoryList',      'blogapi_mt_get_category_list',      array('array', 'string', 'string', 'string'),      t('Returns a list of all categories defined in the blog.')),    array(      'mt.getPostCategories',      'blogapi_mt_get_post_categories',      array('array', 'string', 'string', 'string'),      t('Returns a list of all categories to which the post is assigned.')),    array(      'mt.setPostCategories',      'blogapi_mt_set_post_categories',      array('boolean', 'string', 'string', 'string', 'array'),      t('Sets the categories for a post.')),    array(      'mt.supportedMethods',      'xmlrpc_server_list_methods',      array('array'),      t('Retrieve information about the XML-RPC methods supported by the server.')),    array(      'mt.supportedTextFilters',      'blogapi_mt_supported_text_filters',      array('array'),      t('Retrieve information about the text formatting plugins supported by the server.')),    array(      'mt.publishPost',      'blogapi_mt_publish_post',      array('boolean', 'string', 'string', 'string'),      t('Publish (rebuild) all of the static files related to an entry from your blog. Equivalent to saving an entry in the system (but without the ping).')));}/** * Blogging API callback. Finds the URL of a user's blog. */function blogapi_blogger_get_users_blogs($appid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if ($user->uid) {    $types = _blogapi_get_node_types();    $structs = array();    foreach ($types as $type) {      $structs[] = array('url' => url('blog/'. $user->uid, array('absolute' => TRUE)), 'blogid' => $type, 'blogName' => $user->name .": ". $type);    }    return $structs;  }  else {    return blogapi_error($user);  }}/** * Blogging API callback. Returns profile information about a user. */function blogapi_blogger_get_user_info($appkey, $username, $password) {  $user = blogapi_validate_user($username, $password);  if ($user->uid) {    $name = explode(' ', $user->realname ? $user->realname : $user->name, 2);    return array(      'userid' => $user->uid,      'lastname' => $name[1],      'firstname' => $name[0],      'nickname' => $user->name,      'email' => $user->mail,      'url' => url('blog/'. $user->uid, array('absolute' => TRUE)));  }  else {    return blogapi_error($user);  }}/** * Blogging API callback. Inserts a new blog post as a node. */function blogapi_blogger_new_post($appkey, $blogid, $username, $password, $content, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  $edit = array();  $edit['type'] = $blogid;  // get the node type defaults  $node_type_default = variable_get('node_options_'. $edit['type'], array('status', 'promote'));  $edit['uid'] = $user->uid;  $edit['name'] = $user->name;  $edit['promote'] = in_array('promote', $node_type_default);  $edit['comment'] = variable_get('comment_'. $edit['type'], 2);  $edit['revision'] = in_array('revision', $node_type_default);  $edit['format'] = FILTER_FORMAT_DEFAULT;  $edit['status'] = $publish;  // check for bloggerAPI vs. metaWeblogAPI  if (is_array($content)) {    $edit['title'] = $content['title'];    $edit['body'] = $content['description'];    _blogapi_mt_extra($edit, $content);  }  else {    $edit['title'] = blogapi_blogger_title($content);    $edit['body'] = $content;  }  if (!node_access('create', $edit['type'])) {    return blogapi_error(t('You do not have permission to create this type of post.'));  }  if (user_access('administer nodes') && !isset($edit['date'])) {    $edit['date'] = format_date(time(), 'custom', 'Y-m-d H:i:s O');  }  node_invoke_nodeapi($edit, 'blogapi new');  $valid = blogapi_status_error_check($edit, $publish);  if ($valid !== TRUE) {    return $valid;  }  node_validate($edit);  if ($errors = form_get_errors()) {    return blogapi_error(implode("\n", $errors));  }  $node = node_submit($edit);  node_save($node);  if ($node->nid) {    watchdog('content', '@type: added %title using blog API.', array('@type' => $node->type, '%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), "node/$node->nid"));    // blogger.newPost returns a string so we cast the nid to a string by putting it in double quotes:    return "$node->nid";  }  return blogapi_error(t('Error storing post.'));}/** * Blogging API callback. Modifies the specified blog node. */function blogapi_blogger_edit_post($appkey, $postid, $username, $password, $content, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  if (!$node) {    return blogapi_error(t('n/a'));  }  // Let the teaser be re-generated.  unset($node->teaser);  if (!node_access('update', $node)) {    return blogapi_error(t('You do not have permission to update this post.'));  }  // Save the original status for validation of permissions.  $original_status = $node->status;  $node->status = $publish;  // check for bloggerAPI vs. metaWeblogAPI  if (is_array($content)) {    $node->title = $content['title'];    $node->body = $content['description'];    _blogapi_mt_extra($node, $content);  }  else {    $node->title = blogapi_blogger_title($content);    $node->body = $content;  }  node_invoke_nodeapi($node, 'blogapi edit');  $valid = blogapi_status_error_check($node, $original_status);  if ($valid !== TRUE) {    return $valid;  }  node_validate($node);  if ($errors = form_get_errors()) {    return blogapi_error(implode("\n", $errors));  }  if (user_access('administer nodes') && !isset($edit['date'])) {    $node->date = format_date($node->created, 'custom', 'Y-m-d H:i:s O');  }  $node = node_submit($node);  node_save($node);  if ($node->nid) {    watchdog('content', '@type: updated %title using Blog API.', array('@type' => $node->type, '%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), "node/$node->nid"));    return TRUE;  }  return blogapi_error(t('Error storing post.'));}/** * Blogging API callback. Returns a specified blog node. */function blogapi_blogger_get_post($appkey, $postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  return _blogapi_get_post($node, TRUE);}/** * Check that the user has permission to save the node with the chosen status. * * @return *   TRUE if no error, or the blogapi_error(). */function blogapi_status_error_check($node, $original_status) {    $node = (object) $node;  $node_type_default = variable_get('node_options_'. $node->type, array('status', 'promote'));  // If we don't have the 'administer nodes' permission and the status is  // changing or for a new node the status is not the content type's default,  // then return an error.  if (!user_access('administer nodes') && (($node->status != $original_status) || (empty($node->nid) && $node->status != in_array('status', $node_type_default)))) {    if ($node->status) {      return blogapi_error(t('You do not have permission to publish this type of post. Please save it as a draft instead.'));    }    else {      return blogapi_error(t('You do not have permission to save this post as a draft. Please publish it instead.'));    }  }  return TRUE;}/** * Blogging API callback. Removes the specified blog node. */function blogapi_blogger_delete_post($appkey, $postid, $username, $password, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  node_delete($postid);  return TRUE;}/** * Blogging API callback. Returns the latest few postings in a user's blog. $bodies TRUE * <a href="http://movabletype.org/docs/mtmanual_programmatic.html#item_mt%2EgetRecentPostTitles"> * returns a bandwidth-friendly list</a>. */function blogapi_blogger_get_recent_posts($appkey, $blogid, $username, $password, $number_of_posts, $bodies = TRUE) {  // Remove unused appkey (from bloggerAPI).  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  if ($bodies) {    $result = db_query_range("SELECT n.nid, n.title, r.body, r.format, n.comment, n.created, u.name FROM {node} n, {node_revisions} r, {users} u WHERE n.uid = u.uid AND n.vid = r.vid AND n.type = '%s' AND n.uid = %d ORDER BY n.created DESC",  $blogid, $user->uid, 0, $number_of_posts);  }  else {    $result = db_query_range("SELECT n.nid, n.title, n.created, u.name FROM {node} n, {users} u WHERE n.uid = u.uid AND n.type = '%s' AND n.uid = %d ORDER BY n.created DESC", $blogid, $user->uid, 0, $number_of_posts);  }  $blogs = array();  while ($blog = db_fetch_object($result)) {    $blogs[] = _blogapi_get_post($blog, $bodies);  }  return $blogs;}function blogapi_metaweblog_new_post($blogid, $username, $password, $content, $publish) {  return blogapi_blogger_new_post('0123456789ABCDEF', $blogid, $username, $password, $content, $publish);}function blogapi_metaweblog_edit_post($postid, $username, $password, $content, $publish) {  return blogapi_blogger_edit_post('0123456789ABCDEF', $postid, $username, $password, $content, $publish);}function blogapi_metaweblog_get_post($postid, $username, $password) {  return blogapi_blogger_get_post('01234567890ABCDEF', $postid, $username, $password);}/** * Blogging API callback. Inserts a file into Drupal. */function blogapi_metaweblog_new_media_object($blogid, $username, $password, $file) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $usersize = 0;  $uploadsize = 0;  $roles = array_intersect(user_roles(FALSE, 'administer content with blog api'), $user->roles);  foreach ($roles as $rid => $name) {    $extensions .= ' '. strtolower(variable_get("blogapi_extensions_$rid", variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp')));    $usersize= max($usersize, variable_get("blogapi_usersize_$rid", variable_get('blogapi_usersize_default', 1)) * 1024 * 1024);    $uploadsize = max($uploadsize, variable_get("blogapi_uploadsize_$rid", variable_get('blogapi_uploadsize_default', 1)) * 1024 * 1024);  }  $filesize = strlen($file['bits']);  if ($filesize > $uploadsize) {    return blogapi_error(t('It is not possible to upload the file, because it exceeded the maximum filesize of @maxsize.', array('@maxsize' => format_size($uploadsize))));  }  if (_blogapi_space_used($user->uid) + $filesize > $usersize) {    return blogapi_error(t('The file can not be attached to this post, because the disk quota of @quota has been reached.', array('@quota' => format_size($usersize))));  }  // Only allow files with whitelisted extensions and convert remaining dots to  // underscores to prevent attacks via non-terminal executable extensions with  // files such as exploit.php.jpg.  $whitelist = array_unique(explode(' ', trim($extensions)));  $name = basename($file['name']);  if ($extension_position = strrpos($name, '.')) {    $filename = drupal_substr($name, 0, $extension_position);    $final_extension = drupal_substr($name, $extension_position + 1);    if (!in_array(strtolower($final_extension), $whitelist)) {      return blogapi_error(t('It is not possible to upload the file, because it is only possible to upload files with the following extensions: @extensions', array('@extensions' => implode(' ', $whitelist))));    }    $filename = str_replace('.', '_', $filename);    $filename .= '.'. $final_extension;  }  $data = $file['bits'];  if (!$data) {    return blogapi_error(t('No file sent.'));  }  if (!$file = file_save_data($data, $filename)) {    return blogapi_error(t('Error storing file.'));  }  $row = new stdClass();  $row->uid = $user->uid;  $row->filepath = $file;  $row->filesize = $filesize;  drupal_write_record('blogapi_files', $row);  // Return the successful result.  return array('url' => file_create_url($file), 'struct');}/** * Blogging API callback. Returns a list of the taxonomy terms that can be * associated with a blog node. */function blogapi_metaweblog_get_category_list($blogid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  $vocabularies = module_invoke('taxonomy', 'get_vocabularies', $blogid, 'vid');  $categories = array();  if ($vocabularies) {    foreach ($vocabularies as $vocabulary) {      $terms = module_invoke('taxonomy', 'get_tree', $vocabulary->vid, 0, -1);      foreach ($terms as $term) {        $term_name = $term->name;        foreach (module_invoke('taxonomy', 'get_parents', $term->tid, 'tid') as $parent) {          $term_name = $parent->name .'/'. $term_name;        }        $categories[] = array('categoryName' => $term_name, 'categoryId' => $term->tid);      }    }  }  return $categories;}function blogapi_metaweblog_get_recent_posts($blogid, $username, $password, $number_of_posts) {  return blogapi_blogger_get_recent_posts('0123456789ABCDEF', $blogid, $username, $password, $number_of_posts, TRUE);}function blogapi_mt_get_recent_post_titles($blogid, $username, $password, $number_of_posts) {  return blogapi_blogger_get_recent_posts('0123456789ABCDEF', $blogid, $username, $password, $number_of_posts, FALSE);}function blogapi_mt_get_category_list($blogid, $username, $password) {  return blogapi_metaweblog_get_category_list($blogid, $username, $password);}/** * Blogging API callback. Returns a list of the taxonomy terms that are * assigned to a particular node. */function blogapi_mt_get_post_categories($postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  $terms = module_invoke('taxonomy', 'node_get_terms', $node, 'tid');  $categories = array();  foreach ($terms as $term) {    $term_name = $term->name;    foreach (module_invoke('taxonomy', 'get_parents', $term->tid, 'tid') as $parent) {      $term_name = $parent->name .'/'. $term_name;    }    $categories[] = array('categoryName' => $term_name, 'categoryId' => $term->tid, 'isPrimary' => TRUE);  }  return $categories;}/** * Blogging API callback. Assigns taxonomy terms to a particular node. */function blogapi_mt_set_post_categories($postid, $username, $password, $categories) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  $node->taxonomy = array();  foreach ($categories as $category) {    $node->taxonomy[] = $category['categoryId'];  }  $validated = blogapi_mt_validate_terms($node);  if ($validated !== TRUE) {    return $validated;  }  node_save($node);  return TRUE;}/** * Blogging API helper - find allowed taxonomy terms for a node type. */function blogapi_mt_validate_terms($node) {  // We do a lot of heavy lifting here since taxonomy module doesn't have a  // stand-alone validation function.  if (module_exists('taxonomy')) {    $found_terms = array();    if (!empty($node->taxonomy)) {      $term_list = array_unique($node->taxonomy);      $params = $term_list;      $params[] = $node->type;      $result = db_query(db_rewrite_sql("SELECT t.tid, t.vid FROM {term_data} t INNER JOIN {vocabulary_node_types} n ON t.vid = n.vid WHERE t.tid IN (". db_placeholders($term_list) .") AND n.type = '%s'", 't', 'tid'), $params);      $found_terms = array();      $found_count = 0;      while ($term = db_fetch_object($result)) {        $found_terms[$term->vid][$term->tid] = $term->tid;        $found_count++;      }      // If the counts don't match, some terms are invalid or not accessible to this user.      if (count($term_list) != $found_count) {        return blogapi_error(t('Invalid categories submitted.'));      }    }    // Look up all the vocabularies for this node type.    $result2 = db_query(db_rewrite_sql("SELECT v.vid, v.name, v.required, v.multiple FROM {vocabulary} v INNER JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s'", 'v', 'vid'), $node->type);    // Check each vocabulary associated with this node type.    while ($vocabulary = db_fetch_object($result2)) {      // Required vocabularies must have at least one term.      if ($vocabulary->required && empty($found_terms[$vocabulary->vid])) {        return blogapi_error(t('A category from the @vocabulary_name vocabulary is required.', array('@vocabulary_name' => $vocabulary->name)));      }      // Vocabularies that don't allow multiple terms may have at most one.      if (!($vocabulary->multiple) && (isset($found_terms[$vocabulary->vid]) && count($found_terms[$vocabulary->vid]) > 1)) {        return blogapi_error(t('You may only choose one category from the @vocabulary_name vocabulary.'), array('@vocabulary_name' => $vocabulary->name));      }    }  }  elseif (!empty($node->taxonomy)) {    return blogapi_error(t('Error saving categories. This feature is not available.'));  }  return TRUE;}/** * Blogging API callback. Sends a list of available input formats. */function blogapi_mt_supported_text_filters() {  // NOTE: we're only using anonymous' formats because the MT spec  // does not allow for per-user formats.  $formats = filter_formats();  $filters = array();  foreach ($formats as $format) {    $filter['key'] = $format->format;    $filter['label'] = $format->name;    $filters[] = $filter;  }  return $filters;}/** * Blogging API callback. Publishes the given node */function blogapi_mt_publish_post($postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  if (!$node) {    return blogapi_error(t('Invalid post.'));  }  // Nothing needs to be done if already published.  if ($node->status) {    return;  }  if (!node_access('update', $node) || !user_access('administer nodes')) {    return blogapi_error(t('You do not have permission to update this post.'));  }  $node->status = 1;  node_save($node);  return TRUE;}/** * Prepare an error message for returning to the XMLRPC caller. */function blogapi_error($message) {  static $xmlrpcusererr;  if (!is_array($message)) {    $message = array($message);  }  $message = implode(' ', $message);  return xmlrpc_error($xmlrpcusererr + 1, strip_tags($message));}/** * Ensure that the given user has permission to edit a blog. */function blogapi_validate_user($username, $password) {  global $user;  $user = user_authenticate(array('name' => $username, 'pass' => $password));  if ($user->uid) {    if (user_access('administer content with blog api', $user)) {      return $user;    }    else {      return t('You do not have permission to edit this blog.');    }  }  else {    return t('Wrong username or password.');  }}/** * For the blogger API, extract the node title from the contents field. */function blogapi_blogger_title(&$contents) {  if (eregi('<title>([^<]*)</title>', $contents, $title)) {    $title = strip_tags($title[0]);    $contents = ereg_replace('<title>[^<]*</title>', '', $contents);  }  else {    list($title, $contents) = explode("\n", $contents, 2);  }  return $title;}function blogapi_admin_settings() {  $node_types = array_map('check_plain', node_get_types('names'));  $defaults = isset($node_types['blog']) ? array('blog' => 1) : array();  $form['blogapi_node_types'] = array(    '#type' => 'checkboxes',    '#title' => t('Enable for external blogging clients'),    '#required' => TRUE,    '#default_value' => variable_get('blogapi_node_types', $defaults),    '#options' => $node_types,    '#description' => t('Select the content types available to external blogging clients via Blog API. If supported, each enabled content type will be displayed as a separate "blog" by the external client.')  );  $blogapi_extensions_default = variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp');  $blogapi_uploadsize_default = variable_get('blogapi_uploadsize_default', 1);  $blogapi_usersize_default = variable_get('blogapi_usersize_default', 1);  $form['settings_general'] = array(    '#type' => 'fieldset',    '#title' => t('File settings'),    '#collapsible' => TRUE,  );  $form['settings_general']['blogapi_extensions_default'] = array(    '#type' => 'textfield',    '#title' => t('Default permitted file extensions'),    '#default_value' => $blogapi_extensions_default,    '#maxlength' => 255,    '#description' => t('Default extensions that users can upload. Separate extensions with a space and do not include the leading dot.'),  );  $form['settings_general']['blogapi_uploadsize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default maximum file size per upload'),    '#default_value' => $blogapi_uploadsize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum file size a user can upload.'),    '#field_suffix' => t('MB')  );  $form['settings_general']['blogapi_usersize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default total file size per user'),    '#default_value' => $blogapi_usersize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum size of all files a user can have on the site.'),    '#field_suffix' => t('MB')  );  $form['settings_general']['upload_max_size'] = array('#value' => '<p>'. t('Your PHP settings limit the maximum file size per upload to %size.', array('%size' => format_size(file_upload_max_size()))).'</p>');  $roles = user_roles(0, 'administer content with blog api');  $form['roles'] = array('#type' => 'value', '#value' => $roles);  foreach ($roles as $rid => $role) {    $form['settings_role_'. $rid] = array(      '#type' => 'fieldset',      '#title' => t('Settings for @role', array('@role' => $role)),      '#collapsible' => TRUE,      '#collapsed' => TRUE,    );    $form['settings_role_'. $rid]['blogapi_extensions_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Permitted file extensions'),      '#default_value' => variable_get('blogapi_extensions_'. $rid, $blogapi_extensions_default),      '#maxlength' => 255,      '#description' => t('Extensions that users in this role can upload. Separate extensions with a space and do not include the leading dot.'),    );    $form['settings_role_'. $rid]['blogapi_uploadsize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Maximum file size per upload'),      '#default_value' => variable_get('blogapi_uploadsize_'. $rid, $blogapi_uploadsize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of a file a user can upload (in megabytes).'),    );    $form['settings_role_'. $rid]['blogapi_usersize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Total file size per user'),      '#default_value' => variable_get('blogapi_usersize_'. $rid, $blogapi_usersize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of all files a user can have on the site (in megabytes).'),    );  }  return system_settings_form($form);}function blogapi_menu() {  $items['blogapi/rsd'] = array(    'title' => 'RSD',    'page callback' => 'blogapi_rsd',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/blogapi'] = array(    'title' => 'Blog API',    'description' => 'Configure the content types available to external blogging clients.',    'page callback' => 'drupal_get_form',    'page arguments' => array('blogapi_admin_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_NORMAL_ITEM,  );  return $items;}function blogapi_init() {  if (drupal_is_front_page()) {    drupal_add_link(array('rel' => 'EditURI',                          'type' => 'application/rsd+xml',                          'title' => t('RSD'),                          'href' => url('blogapi/rsd', array('absolute' => TRUE))));  }}function blogapi_rsd() {  global $base_url;  $xmlrpc = $base_url .'/xmlrpc.php';  $base = url('', array('absolute' => TRUE));  $blogid = 1; # until we figure out how to handle multiple bloggers  drupal_set_header('Content-Type: application/rsd+xml; charset=utf-8');  print <<<__RSD__<?xml version="1.0"?><rsd version="1.0" xmlns="http://archipelago.phrasewise.com/rsd">  <service>    <engineName>Drupal</engineName>    <engineLink>http://drupal.org/</engineLink>    <homePageLink>$base</homePageLink>    <apis>      <api name="MetaWeblog" preferred="false" apiLink="$xmlrpc" blogID="$blogid" />      <api name="Blogger" preferred="false" apiLink="$xmlrpc" blogID="$blogid" />      <api name="MovableType" preferred="true" apiLink="$xmlrpc" blogID="$blogid" />    </apis>  </service></rsd>__RSD__;}/** * Handles extra information sent by clients according to MovableType's spec. */function _blogapi_mt_extra(&$node, $struct) {  if (is_array($node)) {    $was_array = TRUE;    $node = (object)$node;  }  // mt_allow_comments  if (array_key_exists('mt_allow_comments', $struct)) {    switch ($struct['mt_allow_comments']) {      case 0:        $node->comment = COMMENT_NODE_DISABLED;        break;      case 1:        $node->comment = COMMENT_NODE_READ_WRITE;        break;      case 2:        $node->comment = COMMENT_NODE_READ_ONLY;        break;    }  }  // merge the 3 body sections (description, mt_excerpt, mt_text_more) into  // one body  if ($struct['mt_excerpt']) {    $node->body = $struct['mt_excerpt'] .'<!--break-->'. $node->body;  }  if ($struct['mt_text_more']) {    $node->body = $node->body .'<!--extended-->'. $struct['mt_text_more'];  }  // mt_convert_breaks  if ($struct['mt_convert_breaks']) {    $node->format = $struct['mt_convert_breaks'];  }  // dateCreated  if ($struct['dateCreated']) {    $node->date = format_date(mktime($struct['dateCreated']->hour, $struct['dateCreated']->minute, $struct['dateCreated']->second, $struct['dateCreated']->month, $struct['dateCreated']->day, $struct['dateCreated']->year), 'custom', 'Y-m-d H:i:s O');  }  if ($was_array) {    $node = (array)$node;  }}function _blogapi_get_post($node, $bodies = TRUE) {  $xmlrpcval = array(    'userid' => $node->name,    'dateCreated' => xmlrpc_date($node->created),    'title' => $node->title,    'postid' => $node->nid,    'link' => url('node/'. $node->nid, array('absolute' => TRUE)),    'permaLink' => url('node/'. $node->nid, array('absolute' => TRUE)),  );  if ($bodies) {    if ($node->comment == 1) {      $comment = 2;    }    else if ($node->comment == 2) {      $comment = 1;    }    $xmlrpcval['content'] = "<title>$node->title</title>$node->body";    $xmlrpcval['description'] = $node->body;    // Add MT specific fields    $xmlrpcval['mt_allow_comments'] = (int) $comment;    $xmlrpcval['mt_convert_breaks'] = $node->format;  }  return $xmlrpcval;}/** * Validate blog ID, which maps to a content type in Drupal. * * Only content types configured to work with Blog API are supported. * * @return *   TRUE if the content type is supported and the user has permission *   to post, or a blogapi_error() XML construct otherwise. */function _blogapi_validate_blogid($blogid) {  $types = _blogapi_get_node_types();  if (in_array($blogid, $types, TRUE)) {    return TRUE;  }  return blogapi_error(t("Blog API module is not configured to support the %type content type, or you don't have sufficient permissions to post this type of content.", array('%type' => $blogid)));}function _blogapi_get_node_types() {  $available_types = array_keys(array_filter(variable_get('blogapi_node_types', array('blog' => 1))));  $types = array();  foreach (node_get_types() as $type => $name) {    if (node_access('create', $type) && in_array($type, $available_types)) {      $types[] = $type;    }  }  return $types;}function _blogapi_space_used($uid) {  return db_result(db_query('SELECT SUM(filesize) FROM {blogapi_files} f WHERE f.uid = %d', $uid));}
<?php// $Id$/** * @file * Allows users to structure the pages of a site in a hierarchy or outline. *//** * Implementation of hook_theme() */function book_theme() {  return array(    'book_navigation' => array(      'arguments' => array('book_link' => NULL),      'template' => 'book-navigation',    ),    'book_export_html' => array(      'arguments' => array('title' => NULL, 'contents' => NULL, 'depth' => NULL),      'template' => 'book-export-html',    ),    'book_admin_table' => array(      'arguments' => array('form' => NULL),    ),    'book_title_link' => array(      'arguments' => array('link' => NULL),    ),    'book_all_books_block' => array(      'arguments' => array('book_menus' => array()),      'template' => 'book-all-books-block',    ),    'book_node_export_html' => array(      'arguments' => array('node' => NULL, 'children' => NULL),      'template' => 'book-node-export-html',    ),  );}/** * Implementation of hook_perm(). */function book_perm() {  return array('add content to books', 'administer book outlines', 'create new books', 'access printer-friendly version');}/** * Implementation of hook_link(). */function book_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && isset($node->book)) {    if (!$teaser) {      $child_type = variable_get('book_child_type', 'book');      if ((user_access('add content to books') || user_access('administer book outlines')) && node_access('create', $child_type) && $node->status == 1 && $node->book['depth'] < MENU_MAX_DEPTH) {        $links['book_add_child'] = array(          'title' => t('Add child page'),          'href' => "node/add/". str_replace('_', '-', $child_type),          'query' => "parent=". $node->book['mlid'],        );      }      if (user_access('access printer-friendly version')) {        $links['book_printer'] = array(          'title' => t('Printer-friendly version'),          'href' => 'book/export/html/'. $node->nid,          'attributes' => array('title' => t('Show a printer-friendly version of this book page and its sub-pages.'))        );      }    }  }  return $links;}/** * Implementation of hook_menu(). */function book_menu() {  $items['admin/content/book'] = array(    'title' => 'Books',    'description' => "Manage your site's book outlines.",    'page callback' => 'book_admin_overview',    'access arguments' => array('administer book outlines'),    'file' => 'book.admin.inc',  );  $items['admin/content/book/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/content/book/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_admin_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_LOCAL_TASK,    'weight' => 8,    'file' => 'book.admin.inc',  );  $items['admin/content/book/%node'] = array(    'title' => 'Re-order book pages and change titles',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_admin_edit', 3),    'access callback' => '_book_outline_access',    'access arguments' => array(3),    'type' => MENU_CALLBACK,    'file' => 'book.admin.inc',  );  $items['book'] = array(    'title' => 'Books',    'page callback' => 'book_render',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'book.pages.inc',  );  $items['book/export/%/%'] = array(    'page callback' => 'book_export',    'page arguments' => array(2, 3),    'access arguments' => array('access printer-friendly version'),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  $items['node/%node/outline'] = array(    'title' => 'Outline',    'page callback' => 'book_outline',    'page arguments' => array(1),    'access callback' => '_book_outline_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'book.pages.inc',  );  $items['node/%node/outline/remove'] = array(    'title' => 'Remove from outline',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_remove_form', 1),    'access callback' => '_book_outline_remove_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  $items['book/js/form'] = array(    'page callback' => 'book_form_update',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  return $items;}/** * Menu item access callback - determine if the outline tab is accessible. */function _book_outline_access($node) {  return user_access('administer book outlines') && node_access('view', $node);}/** * Menu item access callback - determine if the user can remove nodes from the outline. */function _book_outline_remove_access($node) {  return isset($node->book) && ($node->book['bid'] != $node->nid) && _book_outline_access($node);}/** * Implementation of hook_init(). Add's the book module's CSS. */function book_init() {  drupal_add_css(drupal_get_path('module', 'book') .'/book.css');}/** * Implementation of hook_block(). * * Displays the book table of contents in a block when the current page is a * single-node view of a book node. */function book_block($op = 'list', $delta = 0, $edit = array()) {  $block = array();  switch ($op) {    case 'list':      $block[0]['info'] = t('Book navigation');      $block[0]['cache'] = BLOCK_CACHE_PER_PAGE | BLOCK_CACHE_PER_ROLE;      return $block;    case 'view':      $current_bid = 0;      if ($node = menu_get_object()) {        $current_bid = empty($node->book['bid']) ? 0 : $node->book['bid'];      }      if (variable_get('book_block_mode', 'all pages') == 'all pages') {        $block['subject'] = t('Book navigation');        $book_menus = array();        $pseudo_tree = array(0 => array('below' => FALSE));        foreach (book_get_books() as $book_id => $book) {          if ($book['bid'] == $current_bid) {            // If the current page is a node associated with a book, the menu            // needs to be retrieved.            $book_menus[$book_id] = menu_tree_output(menu_tree_all_data($node->book['menu_name'], $node->book));          }          else {            // Since we know we will only display a link to the top node, there            // is no reason to run an additional menu tree query for each book.            $book['in_active_trail'] = FALSE;            $pseudo_tree[0]['link'] = $book;            $book_menus[$book_id] = menu_tree_output($pseudo_tree);          }        }        $block['content'] = theme('book_all_books_block', $book_menus);      }      elseif ($current_bid) {        // Only display this block when the user is browsing a book.        $title = db_result(db_query(db_rewrite_sql('SELECT n.title FROM {node} n WHERE n.nid = %d'), $node->book['bid']));        // Only show the block if the user has view access for the top-level node.        if ($title) {          $tree = menu_tree_all_data($node->book['menu_name'], $node->book);          // There should only be one element at the top level.          $data = array_shift($tree);          $block['subject'] = theme('book_title_link', $data['link']);          $block['content'] = ($data['below']) ? menu_tree_output($data['below']) : '';        }      }      return $block;    case 'configure':      $options = array(        'all pages' => t('Show block on all pages'),        'book pages' => t('Show block only on book pages'),      );      $form['book_block_mode'] = array(        '#type' => 'radios',        '#title' => t('Book navigation block display'),        '#options' => $options,        '#default_value' => variable_get('book_block_mode', 'all pages'),        '#description' => t("If <em>Show block on all pages</em> is selected, the block will contain the automatically generated menus for all of the site's books. If <em>Show block only on book pages</em> is selected, the block will contain only the one menu corresponding to the current page's book. In this case, if the current page is not in a book, no block will be displayed. The <em>Page specific visibility settings</em> or other visibility settings can be used in addition to selectively display this block."),        );      return $form;    case 'save':      variable_set('book_block_mode', $edit['book_block_mode']);      break;  }}/** * Generate the HTML output for a link to a book title when used as a block title. * * @ingroup themeable */function theme_book_title_link($link) {  $link['options']['attributes']['class'] =  'book-title';  return l($link['title'], $link['href'], $link['options']);}/** * Returns an array of all books. * * This list may be used for generating a list of all the books, or for building * the options for a form select. */function book_get_books() {  static $all_books;  if (!isset($all_books)) {    $all_books = array();    $result = db_query("SELECT DISTINCT(bid) FROM {book}");    $nids = array();    while ($book = db_fetch_array($result)) {      $nids[] = $book['bid'];    }    if ($nids) {      $result2 = db_query(db_rewrite_sql("SELECT n.type, n.title, b.*, ml.* FROM {book} b INNER JOIN {node} n on b.nid = n.nid INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE n.nid IN (". implode(',', $nids) .") AND n.status = 1 ORDER BY ml.weight, ml.link_title"));      while ($link = db_fetch_array($result2)) {        $link['href'] = $link['link_path'];        $link['options'] = unserialize($link['options']);        $all_books[$link['bid']] = $link;      }    }  }  return $all_books;}/** * Implementation of hook_form_alter(). Adds the book fieldset to the node form. * * @see book_pick_book_submit() * @see book_submit() */function book_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {    // Add elements to the node form    $node = $form['#node'];    $access = user_access('administer book outlines');    if (!$access) {      if (user_access('add content to books') && ((!empty($node->book['mlid']) && !empty($node->nid)) || book_type_is_allowed($node->type))) {        // Already in the book hierarchy or this node type is allowed        $access = TRUE;      }    }    if ($access) {      _book_add_form_elements($form, $node);      $form['book']['pick-book'] = array(        '#type' => 'submit',        '#value' => t('Change book (update list of parents)'),         // Submit the node form so the parent select options get updated.         // This is typically only used when JS is disabled.  Since the parent options         // won't be changed via AJAX, a button is provided in the node form to submit         // the form and generate options in the parent select corresponding to the         // selected book.  This is similar to what happens during a node preview.        '#submit' => array('node_form_submit_build_node'),        '#weight' => 20,      );    }  }}/** * Build the parent selection form element for the node form or outline tab * * This function is also called when generating a new set of options during the * AJAX callback, so an array is returned that can be used to replace an existing * form element. */function _book_parent_select($book_link) {  if (variable_get('menu_override_parent_selector', FALSE)) {    return array();  }  // Offer a message or a drop-down to choose a different parent page.  $form = array(    '#type' => 'hidden',    '#value' => -1,    '#prefix' => '<div id="edit-book-plid-wrapper">',    '#suffix' => '</div>',  );  if ($book_link['nid'] === $book_link['bid']) {    // This is a book - at the top level.    if ($book_link['original_bid'] === $book_link['bid']) {      $form['#prefix'] .= '<em>'. t('This is the top-level page in this book.') .'</em>';    }    else {      $form['#prefix'] .= '<em>'. t('This will be the top-level page in this book.') .'</em>';    }  }  elseif (!$book_link['bid']) {    $form['#prefix'] .= '<em>'. t('No book selected.') .'</em>';  }  else {    $form = array(      '#type' => 'select',      '#title' => t('Parent item'),      '#default_value' => $book_link['plid'],      '#description' => t('The parent page in the book. The maximum depth for a book and all child pages is !maxdepth. Some pages in the selected book may not be available as parents if selecting them would exceed this limit.', array('!maxdepth' => MENU_MAX_DEPTH)),      '#options' => book_toc($book_link['bid'], array($book_link['mlid']), $book_link['parent_depth_limit']),      '#attributes' => array('class' => 'book-title-select'),    );  }  return $form;}/** * Build the common elements of the book form for the node and outline forms. */function _book_add_form_elements(&$form, $node) {  // Need this for AJAX.  $form['#cache'] = TRUE;  drupal_add_js("if (Drupal.jsEnabled) { $(document).ready(function() { $('#edit-book-pick-book').css('display', 'none'); }); }", 'inline');  $form['book'] = array(    '#type' => 'fieldset',    '#title' => t('Book outline'),    '#weight' => 10,    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#tree' => TRUE,    '#attributes' => array('class' => 'book-outline-form'),  );  foreach (array('menu_name', 'mlid', 'nid', 'router_path', 'has_children', 'options', 'module', 'original_bid', 'parent_depth_limit') as $key) {    $form['book'][$key] = array(      '#type' => 'value',      '#value' => $node->book[$key],    );  }  $form['book']['plid'] = _book_parent_select($node->book);  $form['book']['weight'] = array(    '#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $node->book['weight'],    '#delta' => 15,    '#weight' => 5,    '#description' => t('Pages at a given level are ordered first by weight and then by title.'),  );  $options = array();  $nid = isset($node->nid) ? $node->nid : 'new';  if (isset($node->nid) && ($nid == $node->book['original_bid']) && ($node->book['parent_depth_limit'] == 0)) {    // This is the top level node in a maximum depth book and thus cannot be moved.    $options[$node->nid] = $node->title;  }  else {    foreach (book_get_books() as $book) {      $options[$book['nid']] = $book['title'];    }  }  if (user_access('create new books') && ($nid == 'new' || ($nid != $node->book['original_bid']))) {    // The node can become a new book, if it is not one already.    $options = array($nid => '<'. t('create a new book') .'>') + $options;  }  if (!$node->book['mlid']) {    // The node is not currently in a the hierarchy.    $options = array(0 => '<'. t('none') .'>') + $options;  }  // Add a drop-down to select the destination book.  $form['book']['bid'] = array(    '#type' => 'select',    '#title' => t('Book'),    '#default_value' => $node->book['bid'],    '#options' => $options,    '#access' => (bool)$options,    '#description' => t('Your page will be a part of the selected book.'),    '#weight' => -5,    '#attributes' => array('class' => 'book-title-select'),    '#ahah' => array(      'path' => 'book/js/form',      'wrapper' => 'edit-book-plid-wrapper',      'effect' => 'slide',    ),  );}/** * Common helper function to handles additions and updates to the book outline. * * Performs all additions and updates to the book outline through node addition, * node editing, node deletion, or the outline tab. */function _book_update_outline(&$node) {  if (empty($node->book['bid'])) {    return FALSE;  }  $new = empty($node->book['mlid']);  $node->book['link_path'] = 'node/'. $node->nid;  $node->book['link_title'] = $node->title;  $node->book['parent_mismatch'] = FALSE; // The normal case.  if ($node->book['bid'] == $node->nid) {    $node->book['plid'] = 0;    $node->book['menu_name'] = book_menu_name($node->nid);  }  else {    // Check in case the parent is not is this book; the book takes precedence.    if (!empty($node->book['plid'])) {      $parent = db_fetch_array(db_query("SELECT * FROM {book} WHERE mlid = %d", $node->book['plid']));    }    if (empty($node->book['plid']) || !$parent || $parent['bid'] != $node->book['bid']) {      $node->book['plid'] = db_result(db_query("SELECT mlid FROM {book} WHERE nid = %d", $node->book['bid']));      $node->book['parent_mismatch'] = TRUE; // Likely when JS is disabled.    }  }  if (menu_link_save($node->book)) {    if ($new) {      // Insert new.      db_query("INSERT INTO {book} (nid, mlid, bid) VALUES (%d, %d, %d)", $node->nid, $node->book['mlid'], $node->book['bid']);    }    else {      if ($node->book['bid'] != db_result(db_query("SELECT bid FROM {book} WHERE nid = %d", $node->nid))) {        // Update the bid for this page and all children.        book_update_bid($node->book);      }    }    return TRUE;  }  // Failed to save the menu link  return FALSE;}/** * Update the bid for a page and its children when it is moved to a new book. * * @param $book_link *   A fully loaded menu link that is part of the book hierarchy. */function book_update_bid($book_link) {  for ($i = 1; $i <= MENU_MAX_DEPTH && $book_link["p$i"]; $i++) {    $match[] = "p$i = %d";    $args[] = $book_link["p$i"];  }  $result = db_query("SELECT mlid FROM {menu_links} WHERE ". implode(' AND ', $match), $args);  $mlids = array();  while ($a = db_fetch_array($result)) {    $mlids[] = $a['mlid'];  }  if ($mlids) {    db_query("UPDATE {book} SET bid = %d WHERE mlid IN (". implode(',', $mlids) .")", $book_link['bid']);  }}/** * Get the book menu tree for a page, and return it as a linear array. * * @param $book_link *   A fully loaded menu link that is part of the book hierarchy. * @return *   A linear array of menu links in the order that the links are shown in the *   menu, so the previous and next pages are the elements before and after the *   element corresponding to $node.  The children of $node (if any) will come *   immediately after it in the array. */function book_get_flat_menu($book_link) {  static $flat = array();  if (!isset($flat[$book_link['mlid']])) {    // Call menu_tree_all_data() to take advantage of the menu system's caching.    $tree = menu_tree_all_data($book_link['menu_name'], $book_link);    $flat[$book_link['mlid']] = array();    _book_flatten_menu($tree, $flat[$book_link['mlid']]);  }  return $flat[$book_link['mlid']];}/** * Recursive helper function for book_get_flat_menu(). */function _book_flatten_menu($tree, &$flat) {  foreach ($tree as $data) {    if (!$data['link']['hidden']) {      $flat[$data['link']['mlid']] = $data['link'];      if ($data['below']) {        _book_flatten_menu($data['below'], $flat);      }    }  }}/** * Fetches the menu link for the previous page of the book. */function book_prev($book_link) {  // If the parent is zero, we are at the start of a book.  if ($book_link['plid'] == 0) {    return NULL;  }  $flat = book_get_flat_menu($book_link);  // Assigning the array to $flat resets the array pointer for use with each().  $curr = NULL;  do {    $prev = $curr;    list($key, $curr) = each($flat);  } while ($key && $key != $book_link['mlid']);  if ($key == $book_link['mlid']) {    // The previous page in the book may be a child of the previous visible link.    if ($prev['depth'] == $book_link['depth'] && $prev['has_children']) {      // The subtree will have only one link at the top level - get its data.      $data = array_shift(book_menu_subtree_data($prev));      // The link of interest is the last child - iterate to find the deepest one.      while ($data['below']) {        $data = end($data['below']);      }      return $data['link'];    }    else {      return $prev;    }  }}/** * Fetches the menu link for the next page of the book. */function book_next($book_link) {  $flat = book_get_flat_menu($book_link);  // Assigning the array to $flat resets the array pointer for use with each().  do {    list($key, $curr) = each($flat);  } while ($key && $key != $book_link['mlid']);  if ($key == $book_link['mlid']) {    return current($flat);  }}/** * Format the menu links for the child pages of the current page. */function book_children($book_link) {  $flat = book_get_flat_menu($book_link);  $children = array();  if ($book_link['has_children']) {    // Walk through the array until we find the current page.    do {      $link = array_shift($flat);    } while ($link && ($link['mlid'] != $book_link['mlid']));    // Continue though the array and collect the links whose parent is this page.    while (($link = array_shift($flat)) && $link['plid'] == $book_link['mlid']) {      $data['link'] = $link;      $data['below'] = '';      $children[] = $data;    }  }  return $children ? menu_tree_output($children) : '';}/** * Generate the corresponding menu name from a book ID. */function book_menu_name($bid) {  return 'book-toc-'. $bid;}/** * Build an active trail to show in the breadcrumb. */function book_build_active_trail($book_link) {  static $trail;  if (!isset($trail)) {    $trail = array();    $trail[] = array('title' => t('Home'), 'href' => '<front>', 'localized_options' => array());    $tree = menu_tree_all_data($book_link['menu_name'], $book_link);    $curr = array_shift($tree);    while ($curr) {      if ($curr['link']['href'] == $book_link['href']) {        $trail[] = $curr['link'];        $curr = FALSE;      }      else {        if ($curr['below'] && $curr['link']['in_active_trail']) {          $trail[] = $curr['link'];          $tree = $curr['below'];        }        $curr = array_shift($tree);      }    }  }  return $trail;}/** * Implementation of hook_nodeapi(). * * Appends book navigation to all nodes in the book, and handles book outline * insertions and updates via the node form. */function book_nodeapi(&$node, $op, $teaser, $page) {  switch ($op) {    case 'load':      // Note - we cannot use book_link_load() because it will call node_load()      $info['book'] = db_fetch_array(db_query('SELECT * FROM {book} b INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE b.nid = %d', $node->nid));      if ($info['book']) {        $info['book']['href'] = $info['book']['link_path'];        $info['book']['title'] = $info['book']['link_title'];        $info['book']['options'] = unserialize($info['book']['options']);        return $info;      }      break;    case 'view':    if (!$teaser) {        if (!empty($node->book['bid']) && $node->build_mode == NODE_BUILD_NORMAL) {          $node->content['book_navigation'] = array(            '#value' => theme('book_navigation', $node->book),            '#weight' => 100,          );          if ($page) {            menu_set_active_trail(book_build_active_trail($node->book));            menu_set_active_menu_name($node->book['menu_name']);          }        }      }      break;    case 'presave':      // Always save a revision for non-administrators.      if (!empty($node->book['bid']) && !user_access('administer nodes')) {        $node->revision = 1;      }      // Make sure a new node gets a new menu link.      if (empty($node->nid)) {        $node->book['mlid'] = NULL;      }      break;    case 'insert':    case 'update':      if (!empty($node->book['bid'])) {        if ($node->book['bid'] == 'new') {          // New nodes that are their own book.          $node->book['bid'] = $node->nid;        }        $node->book['nid'] = $node->nid;        $node->book['menu_name'] = book_menu_name($node->book['bid']);        _book_update_outline($node);      }      break;    case 'delete':      if (!empty($node->book['bid'])) {        if ($node->nid == $node->book['bid']) {          // Handle deletion of a top-level post.          $result = db_query("SELECT b.nid FROM {menu_links} ml INNER JOIN {book} b on b.mlid = ml.mlid WHERE ml.plid = %d", $node->book['mlid']);          while ($child = db_fetch_array($result)) {            $child_node = node_load($child['nid']);            $child_node->book['bid'] = $child_node->nid;            _book_update_outline($child_node);          }        }        menu_link_delete($node->book['mlid']);        db_query('DELETE FROM {book} WHERE mlid = %d', $node->book['mlid']);      }      break;    case 'prepare':      // Prepare defaults for the add/edit form.      if (empty($node->book) && (user_access('add content to books') || user_access('administer book outlines'))) {        $node->book = array();        if (empty($node->nid) && isset($_GET['parent']) && is_numeric($_GET['parent'])) {          // Handle "Add child page" links:          $parent = book_link_load($_GET['parent']);          if ($parent && $parent['access']) {            $node->book['bid'] = $parent['bid'];            $node->book['plid'] = $parent['mlid'];            $node->book['menu_name'] = $parent['menu_name'];          }        }        // Set defaults.        $node->book += _book_link_defaults(!empty($node->nid) ? $node->nid : 'new');      }      else {        if (isset($node->book['bid']) && !isset($node->book['original_bid'])) {          $node->book['original_bid'] = $node->book['bid'];        }      }      // Find the depth limit for the parent select.      if (isset($node->book['bid']) && !isset($node->book['parent_depth_limit'])) {        $node->book['parent_depth_limit'] = _book_parent_depth_limit($node->book);      }      break;  }}/** * Find the depth limit for items in the parent select. */function _book_parent_depth_limit($book_link) {  return MENU_MAX_DEPTH - 1 - (($book_link['mlid'] && $book_link['has_children']) ? menu_link_children_relative_depth($book_link) : 0);}/** * Form altering function for the confirm form for a single node deletion. */function book_form_node_delete_confirm_alter(&$form, $form_state) {  $node = node_load($form['nid']['#value']);  if (isset($node->book) && $node->book['has_children']) {    $form['book_warning'] = array(      '#value' => '<p>'. t('%title is part of a book outline, and has associated child pages. If you proceed with deletion, the child pages will be relocated automatically.', array('%title' => $node->title)) .'</p>',      '#weight' => -10,    );  }}/** * Return an array with default values for a book link. */function _book_link_defaults($nid) {  return array('original_bid' => 0, 'menu_name' => '', 'nid' => $nid, 'bid' => 0, 'router_path' => 'node/%', 'plid' => 0, 'mlid' => 0, 'has_children' => 0, 'weight' => 0, 'module' => 'book', 'options' => array());}/** * Process variables for book-navigation.tpl.php. * * The $variables array contains the following arguments: * - $book_link * * @see book-navigation.tpl.php */function template_preprocess_book_navigation(&$variables) {  $book_link = $variables['book_link'];  // Provide extra variables for themers. Not needed by default.  $variables['book_id'] = $book_link['bid'];  $variables['book_title'] = check_plain($book_link['link_title']);  $variables['book_url'] = 'node/'. $book_link['bid'];  $variables['current_depth'] = $book_link['depth'];  $variables['tree'] = '';  if ($book_link['mlid']) {    $variables['tree'] = book_children($book_link);    if ($prev = book_prev($book_link)) {      $prev_href = url($prev['href']);      drupal_add_link(array('rel' => 'prev', 'href' => $prev_href));      $variables['prev_url'] = $prev_href;      $variables['prev_title'] = check_plain($prev['title']);    }    if ($book_link['plid'] && $parent = book_link_load($book_link['plid'])) {      $parent_href = url($parent['href']);      drupal_add_link(array('rel' => 'up', 'href' => $parent_href));      $variables['parent_url'] = $parent_href;      $variables['parent_title'] = check_plain($parent['title']);    }    if ($next = book_next($book_link)) {      $next_href = url($next['href']);      drupal_add_link(array('rel' => 'next', 'href' => $next_href));      $variables['next_url'] = $next_href;      $variables['next_title'] = check_plain($next['title']);    }  }  $variables['has_links'] = FALSE;  // Link variables to filter for values and set state of the flag variable.  $links = array('prev_url', 'prev_title', 'parent_url', 'parent_title', 'next_url', 'next_title');  foreach ($links as $link) {    if (isset($variables[$link])) {      // Flag when there is a value.      $variables['has_links'] = TRUE;    }    else {      // Set empty to prevent notices.      $variables[$link] = '';    }  }}/** * A recursive helper function for book_toc(). */function _book_toc_recurse($tree, $indent, &$toc, $exclude, $depth_limit) {  foreach ($tree as $data) {    if ($data['link']['depth'] > $depth_limit) {      // Don't iterate through any links on this level.      break;    }    if (!in_array($data['link']['mlid'], $exclude)) {      $toc[$data['link']['mlid']] = $indent .' '. truncate_utf8($data['link']['title'], 30, TRUE, TRUE);      if ($data['below']) {        _book_toc_recurse($data['below'], $indent .'--', $toc, $exclude, $depth_limit);      }    }  }}/** * Returns an array of book pages in table of contents order. * * @param $bid *   The ID of the book whose pages are to be listed. * @param $exclude *   Optional array of mlid values.  Any link whose mlid is in this array *   will be excluded (along with its children). * @param $depth_limit *   Any link deeper than this value will be excluded (along with its children). * @return *   An array of mlid, title pairs for use as options for selecting a book page. */function book_toc($bid, $exclude = array(), $depth_limit) {  $tree = menu_tree_all_data(book_menu_name($bid));  $toc = array();  _book_toc_recurse($tree, '', $toc, $exclude, $depth_limit);  return $toc;}/** * Process variables for book-export-html.tpl.php. * * The $variables array contains the following arguments: * - $title * - $contents * - $depth * * @see book-export-html.tpl.php */function template_preprocess_book_export_html(&$variables) {  global $base_url, $language;  $variables['title'] = check_plain($variables['title']);  $variables['base_url'] = $base_url;  $variables['language'] = $language;  $variables['language_rtl'] = ($language->direction == LANGUAGE_RTL);  $variables['head'] = drupal_get_html_head();}/** * Traverse the book tree to build printable or exportable output. * * During the traversal, the $visit_func() callback is applied to each * node, and is called recursively for each child of the node (in weight, * title order). * * @param $tree *   A subtree of the book menu hierarchy, rooted at the current page. * @param $visit_func *   A function callback to be called upon visiting a node in the tree. * @return *   The output generated in visiting each node. */function book_export_traverse($tree, $visit_func) {  $output = '';  foreach ($tree as $data) {    // Note- access checking is already performed when building the tree.    if ($node = node_load($data['link']['nid'], FALSE)) {      $children = '';      if ($data['below']) {        $children = book_export_traverse($data['below'], $visit_func);      }      if (function_exists($visit_func)) {        $output .= call_user_func($visit_func, $node, $children);      }      else {        // Use the default function.        $output .= book_node_export($node, $children);      }    }  }  return $output;}/** * Generates printer-friendly HTML for a node. * * @see book_export_traverse() * * @param $node *   The node to generate output for. * @param $children *   All the rendered child nodes within the current node. * @return *   The HTML generated for the given node. */function book_node_export($node, $children = '') {  $node->build_mode = NODE_BUILD_PRINT;  $node = node_build_content($node, FALSE, FALSE);  $node->body = drupal_render($node->content);  return theme('book_node_export_html', $node, $children);}/** * Process variables for book-node-export-html.tpl.php. * * The $variables array contains the following arguments: * - $node * - $children * * @see book-node-export-html.tpl.php */function template_preprocess_book_node_export_html(&$variables) {  $variables['depth'] = $variables['node']->book['depth'];  $variables['title'] = check_plain($variables['node']->title);  $variables['content'] = $variables['node']->body;}/** * Determine if a given node type is in the list of types allowed for books. */function book_type_is_allowed($type) {  return in_array($type, variable_get('book_allowed_types', array('book')));}/** * Implementation of hook_node_type(). * * Update book module's persistent variables if the machine-readable name of a * node type is changed. */function book_node_type($op, $type) {  switch ($op) {    case 'update':      if (!empty($type->old_type) && $type->old_type != $type->type) {        // Update the list of node types that are allowed to be added to books.        $allowed_types = variable_get('book_allowed_types', array('book'));        $key = array_search($type->old_type, $allowed_types);        if ($key !== FALSE) {          $allowed_types[$type->type] = $allowed_types[$key] ? $type->type : 0;          unset($allowed_types[$key]);          variable_set('book_allowed_types', $allowed_types);        }        // Update the setting for the "Add child page" link.        if (variable_get('book_child_type', 'book') == $type->old_type) {          variable_set('book_child_type', $type->type);        }      }      break;  }}/** * Implementation of hook_help(). */function book_help($path, $arg) {  switch ($path) {    case 'admin/help#book':      $output = '<p>'. t('The book module is suited for creating structured, multi-page hypertexts such as site resource guides, manuals, and Frequently Asked Questions (FAQs). It permits a document to have chapters, sections, subsections, etc. Authors with suitable permissions can add pages to a collaborative book, placing them into the existing document by adding them to a table of contents menu.') .'</p>';      $output .= '<p>'. t('Pages in the book hierarchy have navigation elements at the bottom of the page for moving through the text. These links lead to the previous and next pages in the book, and to the level above the current page in the book\'s structure. More comprehensive navigation may be provided by enabling the <em>book navigation block</em> on the <a href="@admin-block">blocks administration page</a>.', array('@admin-block' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('Users can select the <em>printer-friendly version</em> link visible at the bottom of a book page to generate a printer-friendly display of the page and all of its subsections. ') .'</p>';      $output .= '<p>'. t("Users with the <em>administer book outlines</em> permission can add a post of any content type to a book, by selecting the appropriate book while editing the post or by using the interface available on the post's <em>outline</em> tab.") .'</p>';      $output .= '<p>'. t('Administrators can view a list of all books on the <a href="@admin-node-book">book administration page</a>. The <em>Outline</em> page for each book allows section titles to be edited or rearranged.', array('@admin-node-book' => url('admin/content/book'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@book">Book module</a>.', array('@book' => 'http://drupal.org/handbook/modules/book/')) .'</p>';      return $output;    case 'admin/content/book':      return '<p>'. t('The book module offers a means to organize a collection of related posts, collectively known as a book. When viewed, these posts automatically display links to adjacent book pages, providing a simple navigation system for creating and reviewing structured content.') .'</p>';    case 'node/%/outline':      return '<p>'. t('The outline feature allows you to include posts in the <a href="@book">book hierarchy</a>, as well as move them within the hierarchy or to <a href="@book-admin">reorder an entire book</a>.', array('@book' => url('book'), '@book-admin' => url('admin/content/book'))) .'</p>';  }}/** * Like menu_link_load(), but adds additional data from the {book} table. * * Do not call when loading a node, since this function may call node_load(). */function book_link_load($mlid) {  if ($item = db_fetch_array(db_query("SELECT * FROM {menu_links} ml INNER JOIN {book} b ON b.mlid = ml.mlid LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = %d", $mlid))) {    _menu_link_translate($item);    return $item;  }  return FALSE;}/** * Get the data representing a subtree of the book hierarchy. * * The root of the subtree will be the link passed as a parameter, so the * returned tree will contain this item and all its descendents in the menu tree. * * @param $item *   A fully loaded menu link. * @return *   An subtree of menu links in an array, in the order they should be rendered. */function book_menu_subtree_data($item) {  static $tree = array();  // Generate a cache ID (cid) specific for this $menu_name and $item.  $cid = 'links:'. $item['menu_name'] .':subtree-cid:'. $item['mlid'];  if (!isset($tree[$cid])) {    $cache = cache_get($cid, 'cache_menu');    if ($cache && isset($cache->data)) {      // If the cache entry exists, it will just be the cid for the actual data.      // This avoids duplication of large amounts of data.      $cache = cache_get($cache->data, 'cache_menu');      if ($cache && isset($cache->data)) {        $data = $cache->data;      }    }    // If the subtree data was not in the cache, $data will be NULL.    if (!isset($data)) {      $match = array("menu_name = '%s'");      $args = array($item['menu_name']);      $i = 1;      while ($i <= MENU_MAX_DEPTH && $item["p$i"]) {        $match[] = "p$i = %d";        $args[] = $item["p$i"];        $i++;      }      $sql = "        SELECT b.*, m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, ml.*        FROM {menu_links} ml INNER JOIN {menu_router} m ON m.path = ml.router_path        INNER JOIN {book} b ON ml.mlid = b.mlid        WHERE ". implode(' AND ', $match) ."        ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC";      $data['tree'] = menu_tree_data(db_query($sql, $args), array(), $item['depth']);      $data['node_links'] = array();      menu_tree_collect_node_links($data['tree'], $data['node_links']);      // Compute the real cid for book subtree data.      $tree_cid = 'links:'. $item['menu_name'] .':subtree-data:'. md5(serialize($data));      // Cache the data, if it is not already in the cache.      if (!cache_get($tree_cid, 'cache_menu')) {        cache_set($tree_cid, $data, 'cache_menu');      }      // Cache the cid of the (shared) data using the menu and item-specific cid.      cache_set($cid, $tree_cid, 'cache_menu');    }    // Check access for the current user to each item in the tree.    menu_tree_check_access($data['tree'], $data['node_links']);    $tree[$cid] = $data['tree'];  }  return $tree[$cid];}
<?php// $Id$/** * @file * Enables users to comment on published content. * * When enabled, the Drupal comment module creates a discussion * board for each Drupal node. Users can post comments to discuss * a forum topic, weblog post, story, collaborative book page, etc. *//** * Comment is published. */define('COMMENT_PUBLISHED', 0);/** * Comment is awaiting approval. */define('COMMENT_NOT_PUBLISHED', 1);/** * Comments are displayed in a flat list - collapsed. */define('COMMENT_MODE_FLAT_COLLAPSED', 1);/** * Comments are displayed in a flat list - expanded. */define('COMMENT_MODE_FLAT_EXPANDED', 2);/** * Comments are displayed as a threaded list - collapsed. */define('COMMENT_MODE_THREADED_COLLAPSED', 3);/** * Comments are displayed as a threaded list - expanded. */define('COMMENT_MODE_THREADED_EXPANDED', 4);/** * Comments are ordered by date - newest first. */define('COMMENT_ORDER_NEWEST_FIRST', 1);/** * Comments are ordered by date - oldest first. */define('COMMENT_ORDER_OLDEST_FIRST', 2);/** * Comment controls should be shown above the comment list. */define('COMMENT_CONTROLS_ABOVE', 0);/** * Comment controls should be shown below the comment list. */define('COMMENT_CONTROLS_BELOW', 1);/** * Comment controls should be shown both above and below the comment list. */define('COMMENT_CONTROLS_ABOVE_BELOW', 2);/** * Comment controls are hidden. */define('COMMENT_CONTROLS_HIDDEN', 3);/** * Anonymous posters may not enter their contact information. */define('COMMENT_ANONYMOUS_MAYNOT_CONTACT', 0);/** * Anonymous posters may leave their contact information. */define('COMMENT_ANONYMOUS_MAY_CONTACT', 1);/** * Anonymous posters must leave their contact information. */define('COMMENT_ANONYMOUS_MUST_CONTACT', 2);/** * Comment form should be displayed on a separate page. */define('COMMENT_FORM_SEPARATE_PAGE', 0);/** * Comment form should be shown below post or list of comments. */define('COMMENT_FORM_BELOW', 1);/** * Comments for this node are disabled. */define('COMMENT_NODE_DISABLED', 0);/** * Comments for this node are locked. */define('COMMENT_NODE_READ_ONLY', 1);/** * Comments are enabled on this node. */define('COMMENT_NODE_READ_WRITE', 2);/** * Comment preview is optional. */define('COMMENT_PREVIEW_OPTIONAL', 0);/** * Comment preview is required. */define('COMMENT_PREVIEW_REQUIRED', 1);/** * Implementation of hook_help(). */function comment_help($path, $arg) {  switch ($path) {    case 'admin/help#comment':      $output = '<p>'. t('The comment module allows visitors to comment on your posts, creating ad hoc discussion boards. Any <a href="@content-type">content type</a> may have its <em>Default comment setting</em> set to <em>Read/Write</em> to allow comments, or <em>Disabled</em>, to prevent comments. Comment display settings and other controls may also be customized for each content type (some display settings are customizable by individual users).', array('@content-type' => url('admin/content/types'))) .'</p>';      $output .= '<p>'. t('Comment permissions are assigned to user roles, and are used to determine whether anonymous users (or other roles) are allowed to comment on posts. If anonymous users are allowed to comment, their individual contact information may be retained in cookies stored on their local computer for use in later comment submissions. When a comment has no replies, it may be (optionally) edited by its author. The comment module uses the same input formats and HTML tags available when creating other forms of content.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@comment">Comment module</a>.', array('@comment' => 'http://drupal.org/handbook/modules/comment/')) .'</p>';      return $output;    case 'admin/content/comment':      return '<p>'. t("Below is a list of the latest comments posted to your site. Click on a subject to see the comment, the author's name to edit the author's user information, 'edit' to modify the text, and 'delete' to remove their submission.") .'</p>';    case 'admin/content/comment/approval':      return '<p>'. t("Below is a list of the comments posted to your site that need approval. To approve a comment, click on 'edit' and then change its 'moderation status' to Approved. Click on a subject to see the comment, the author's name to edit the author's user information, 'edit' to modify the text, and 'delete' to remove their submission.") .'</p>';  }}/** * Implementation of hook_theme(). */function comment_theme() {  return array(    'comment_block' => array(      'arguments' => array(),    ),    'comment_admin_overview' => array(      'arguments' => array('form' => NULL),    ),    'comment_preview' => array(      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array(), 'visible' => 1),    ),    'comment_view' => array(      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array(), 'visible' => 1),    ),    'comment_controls' => array(      'arguments' => array('form' => NULL),    ),    'comment' => array(      'template' => 'comment',      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array()),    ),    'comment_folded' => array(      'template' => 'comment-folded',      'arguments' => array('comment' => NULL),    ),    'comment_flat_collapsed' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_flat_expanded' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_thread_collapsed' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_thread_expanded' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_post_forbidden' => array(      'arguments' => array('nid' => NULL),    ),    'comment_wrapper' => array(      'template' => 'comment-wrapper',      'arguments' => array('content' => NULL, 'node' => NULL),    ),    'comment_submitted' => array(      'arguments' => array('comment' => NULL),    ),  );}/** * Implementation of hook_menu(). */function comment_menu() {  $items['admin/content/comment'] = array(    'title' => 'Comments',    'description' => 'List and edit site comments and the comment moderation queue.',    'page callback' => 'comment_admin',    'access arguments' => array('administer comments'),    'file' => 'comment.admin.inc',  );  // Tabs:  $items['admin/content/comment/new'] = array(    'title' => 'Published comments',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/comment/approval'] = array(    'title' => 'Approval queue',    'page arguments' => array('approval'),    'access arguments' => array('administer comments'),    'type' => MENU_LOCAL_TASK,    'file' => 'comment.admin.inc',  );  $items['comment/delete'] = array(    'title' => 'Delete comment',    'page callback' => 'comment_delete',    'access arguments' => array('administer comments'),    'type' => MENU_CALLBACK,    'file' => 'comment.admin.inc',  );  $items['comment/edit'] = array(    'title' => 'Edit comment',    'page callback' => 'comment_edit',    'access arguments' => array('post comments'),    'type' => MENU_CALLBACK,    'file' => 'comment.pages.inc',  );  $items['comment/reply/%node'] = array(    'title' => 'Reply to comment',    'page callback' => 'comment_reply',    'page arguments' => array(2),    'access callback' => 'node_access',    'access arguments' => array('view', 2),    'type' => MENU_CALLBACK,    'file' => 'comment.pages.inc',  );  return $items;}/** * Implementation of hook_node_type(). */function comment_node_type($op, $info) {  $settings = array(    'comment',    'comment_default_mode',    'comment_default_order',    'comment_default_per_page',    'comment_controls',    'comment_anonymous',    'comment_subject_field',    'comment_preview',    'comment_form_location',  );  switch ($op) {    case 'delete':      foreach ($settings as $setting) {        variable_del($setting .'_'. $info->type);      }      break;  }}/** * Implementation of hook_perm(). */function comment_perm() {  return array('access comments', 'post comments', 'administer comments', 'post comments without approval');}/** * Implementation of hook_block(). * * Generates a block with the most recent comments. */function comment_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Recent comments');    return $blocks;  }  else if ($op == 'view' && user_access('access comments')) {    $block['subject'] = t('Recent comments');    $block['content'] = theme('comment_block');    return $block;  }}/** * Find a number of recent comments. This is done in two steps. *   1. Find the n (specified by $number) nodes that have the most recent *      comments.  This is done by querying node_comment_statistics which has *      an index on last_comment_timestamp, and is thus a fast query. *   2. Loading the information from the comments table based on the nids found *      in step 1. * * @param $number *   (optional) The maximum number of comments to find. * @return *   An array of comment objects each containing a nid, *   subject, cid, and timestamp, or an empty array if there are no recent *   comments visible to the current user. */function comment_get_recent($number = 10) {  // Select the $number nodes (visible to the current user) with the most  // recent comments. This is efficient due to the index on  // last_comment_timestamp.  $result = db_query_range(db_rewrite_sql("SELECT nc.nid FROM {node_comment_statistics} nc WHERE nc.comment_count > 0 ORDER BY nc.last_comment_timestamp DESC", 'nc'), 0, $number);  $nids = array();  while ($row = db_fetch_object($result)) {    $nids[] = $row->nid;  }  $comments = array();  if (!empty($nids)) {    // From among the comments on the nodes selected in the first query,    // find the $number most recent comments.    $result = db_query_range('SELECT c.nid, c.subject, c.cid, c.timestamp FROM {comments} c INNER JOIN {node} n ON n.nid = c.nid WHERE c.nid IN ('. implode(',', $nids) .') AND n.status = 1 AND c.status = %d ORDER BY c.cid DESC', COMMENT_PUBLISHED, 0, $number);    while ($comment = db_fetch_object($result)) {      $comments[] = $comment;    }  }  return $comments;}/** * Calculate page number for first new comment. * * @param $num_comments *   Number of comments. * @param $new_replies *   Number of new replies. * @param $node *   The first new comment node. * @return *   "page=X" if the page number is greater than zero; empty string otherwise. */function comment_new_page_count($num_comments, $new_replies, $node) {  $comments_per_page = _comment_get_display_setting('comments_per_page', $node);  $mode = _comment_get_display_setting('mode', $node);  $order = _comment_get_display_setting('sort', $node);  $pagenum = NULL;  $flat = in_array($mode, array(COMMENT_MODE_FLAT_COLLAPSED, COMMENT_MODE_FLAT_EXPANDED));  if ($num_comments <= $comments_per_page || ($flat && $order == COMMENT_ORDER_NEWEST_FIRST)) {    // Only one page of comments or flat forum and newest first.    // First new comment will always be on first page.    $pageno = 0;  }  else {    if ($flat) {      // Flat comments and oldest first.      $count = $num_comments - $new_replies;    }    else {      // Threaded comments. See the documentation for comment_render().      if ($order == COMMENT_ORDER_NEWEST_FIRST) {        // Newest first: find the last thread with new comment        $result = db_query('SELECT thread FROM (SELECT thread FROM {comments} WHERE nid = %d AND status = 0 ORDER BY timestamp DESC LIMIT %d) AS thread ORDER BY thread DESC LIMIT 1', $node->nid, $new_replies);        $thread = db_result($result);        $result_count = db_query("SELECT COUNT(*) FROM {comments} WHERE nid = %d AND status = 0 AND thread > '". $thread ."'", $node->nid);      }      else {        // Oldest first: find the first thread with new comment        $result = db_query('SELECT thread FROM (SELECT thread FROM {comments} WHERE nid = %d AND status = 0 ORDER BY timestamp DESC LIMIT %d) AS thread ORDER BY SUBSTRING(thread, 1, (LENGTH(thread) - 1)) LIMIT 1', $node->nid, $new_replies);        $thread = substr(db_result($result), 0, -1);        $result_count = db_query("SELECT COUNT(*) FROM {comments} WHERE nid = %d AND status = 0 AND SUBSTRING(thread, 1, (LENGTH(thread) - 1)) < '". $thread ."'", $node->nid);      }      $count = db_result($result_count);    }    $pageno =  $count / $comments_per_page;  }  if ($pageno >= 1) {    $pagenum = "page=". intval($pageno);  }  return $pagenum;}/** * Returns a formatted list of recent comments to be displayed in the comment block. * * @return *   The comment list HTML. * @ingroup themeable */function theme_comment_block() {  $items = array();  foreach (comment_get_recent() as $comment) {    $items[] = l($comment->subject, 'node/'. $comment->nid, array('fragment' => 'comment-'. $comment->cid)) .'<br />'. t('@time ago', array('@time' => format_interval(time() - $comment->timestamp)));  }  if ($items) {    return theme('item_list', $items);  }}/** * Implementation of hook_link(). */function comment_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && $node->comment) {    if ($teaser) {      // Main page: display the number of comments that have been posted.      if (user_access('access comments')) {        $all = comment_num_all($node->nid);        if ($all) {          $links['comment_comments'] = array(            'title' => format_plural($all, '1 comment', '@count comments'),            'href' => "node/$node->nid",            'attributes' => array('title' => t('Jump to the first comment of this posting.')),            'fragment' => 'comments'          );          $new = comment_num_new($node->nid);          if ($new) {            $links['comment_new_comments'] = array(              'title' => format_plural($new, '1 new comment', '@count new comments'),              'href' => "node/$node->nid",              'query' => comment_new_page_count($all, $new, $node),              'attributes' => array('title' => t('Jump to the first new comment of this posting.')),              'fragment' => 'new'            );          }        }        else {          if ($node->comment == COMMENT_NODE_READ_WRITE) {            if (user_access('post comments')) {              $links['comment_add'] = array(                'title' => t('Add new comment'),                'href' => "comment/reply/$node->nid",                'attributes' => array('title' => t('Add a new comment to this page.')),                'fragment' => 'comment-form'              );            }            else {              $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);            }          }        }      }    }    else {      // Node page: add a "post comment" link if the user is allowed to      // post comments, if this node is not read-only, and if the comment form isn't already shown      if ($node->comment == COMMENT_NODE_READ_WRITE) {        if (user_access('post comments')) {          if (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_SEPARATE_PAGE) {            $links['comment_add'] = array(              'title' => t('Add new comment'),              'href' => "comment/reply/$node->nid",              'attributes' => array('title' => t('Share your thoughts and opinions related to this posting.')),              'fragment' => 'comment-form'            );          }        }        else {          $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);        }      }    }  }  if ($type == 'comment') {    $links = comment_links($node, $teaser);  }  if (isset($links['comment_forbidden'])) {    $links['comment_forbidden']['html'] = TRUE;  }  return $links;}/** * Implementation of hook_form_alter(). */function comment_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {    $form['comment'] = array(      '#type' => 'fieldset',      '#title' => t('Comment settings'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,    );    $form['comment']['comment'] = array(      '#type' => 'radios',      '#title' => t('Default comment setting'),      '#default_value' => variable_get('comment_'. $form['#node_type']->type, COMMENT_NODE_READ_WRITE),      '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),      '#description' => t('Users with the <em>administer comments</em> permission will be able to override this setting.'),    );    $form['comment']['comment_default_mode'] = array(      '#type' => 'radios',      '#title' => t('Default display mode'),      '#default_value' => variable_get('comment_default_mode_'. $form['#node_type']->type, COMMENT_MODE_THREADED_EXPANDED),      '#options' => _comment_get_modes(),      '#description' => t('The default view for comments. Expanded views display the body of the comment. Threaded views keep replies together.'),    );    $form['comment']['comment_default_order'] = array(      '#type' => 'radios',      '#title' => t('Default display order'),      '#default_value' => variable_get('comment_default_order_'. $form['#node_type']->type, COMMENT_ORDER_NEWEST_FIRST),      '#options' => _comment_get_orders(),      '#description' => t('The default sorting for new users and anonymous users while viewing comments. These users may change their view using the comment control panel. For registered users, this change is remembered as a persistent user preference.'),    );    $form['comment']['comment_default_per_page'] = array(      '#type' => 'select',      '#title' => t('Default comments per page'),      '#default_value' => variable_get('comment_default_per_page_'. $form['#node_type']->type, 50),      '#options' => _comment_per_page(),      '#description' => t('Default number of comments for each page: more comments are distributed in several pages.'),    );    $form['comment']['comment_controls'] = array(      '#type' => 'radios',      '#title' => t('Comment controls'),      '#default_value' => variable_get('comment_controls_'. $form['#node_type']->type, COMMENT_CONTROLS_HIDDEN),      '#options' => array(        t('Display above the comments'),        t('Display below the comments'),        t('Display above and below the comments'),        t('Do not display')),      '#description' => t('Position of the comment controls box. The comment controls let the user change the default display mode and display order of comments.'),    );    $form['comment']['comment_anonymous'] = array(      '#type' => 'radios',      '#title' => t('Anonymous commenting'),      '#default_value' => variable_get('comment_anonymous_'. $form['#node_type']->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT),      '#options' => array(        COMMENT_ANONYMOUS_MAYNOT_CONTACT => t('Anonymous posters may not enter their contact information'),        COMMENT_ANONYMOUS_MAY_CONTACT => t('Anonymous posters may leave their contact information'),        COMMENT_ANONYMOUS_MUST_CONTACT => t('Anonymous posters must leave their contact information')),      '#description' => t('This option is enabled when anonymous users have permission to post comments on the <a href="@url">permissions page</a>.', array('@url' => url('admin/user/permissions', array('fragment' => 'module-comment')))),    );    if (!user_access('post comments', drupal_anonymous_user())) {      $form['comment']['comment_anonymous']['#disabled'] = TRUE;    }    $form['comment']['comment_subject_field'] = array(      '#type' => 'radios',      '#title' => t('Comment subject field'),      '#default_value' => variable_get('comment_subject_field_'. $form['#node_type']->type, 1),      '#options' => array(t('Disabled'), t('Enabled')),      '#description' => t('Can users provide a unique subject for their comments?'),    );    $form['comment']['comment_preview'] = array(      '#type' => 'radios',      '#title' => t('Preview comment'),      '#default_value' => variable_get('comment_preview_'. $form['#node_type']->type, COMMENT_PREVIEW_REQUIRED),      '#options' => array(t('Optional'), t('Required')),      '#description' => t("Forces a user to look at their comment by clicking on a 'Preview' button before they can actually add the comment"),    );    $form['comment']['comment_form_location'] = array(      '#type' => 'radios',      '#title' => t('Location of comment submission form'),      '#default_value' => variable_get('comment_form_location_'. $form['#node_type']->type, COMMENT_FORM_SEPARATE_PAGE),      '#options' => array(t('Display on separate page'), t('Display below post or comments')),    );  }  elseif (isset($form['type']) && isset($form['#node'])) {    if ($form['type']['#value'] .'_node_form' == $form_id) {      $node = $form['#node'];      $form['comment_settings'] = array(        '#type' => 'fieldset',        '#access' => user_access('administer comments'),        '#title' => t('Comment settings'),        '#collapsible' => TRUE,        '#collapsed' => TRUE,        '#weight' => 30,      );      $form['comment_settings']['comment'] = array(        '#type' => 'radios',        '#parents' => array('comment'),        '#default_value' => $node->comment,        '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),      );    }  }}/** * Implementation of hook_nodeapi(). */function comment_nodeapi(&$node, $op, $arg = 0) {  switch ($op) {    case 'load':      return db_fetch_array(db_query("SELECT last_comment_timestamp, last_comment_name, comment_count FROM {node_comment_statistics} WHERE nid = %d", $node->nid));      break;    case 'prepare':      if (!isset($node->comment)) {        $node->comment = variable_get("comment_$node->type", COMMENT_NODE_READ_WRITE);      }      break;    case 'insert':      db_query('INSERT INTO {node_comment_statistics} (nid, last_comment_timestamp, last_comment_name, last_comment_uid, comment_count) VALUES (%d, %d, NULL, %d, 0)', $node->nid, $node->changed, $node->uid);      break;    case 'delete':      db_query('DELETE FROM {comments} WHERE nid = %d', $node->nid);      db_query('DELETE FROM {node_comment_statistics} WHERE nid = %d', $node->nid);      break;    case 'update index':      $text = '';      $comments = db_query('SELECT subject, comment, format FROM {comments} WHERE nid = %d AND status = %d', $node->nid, COMMENT_PUBLISHED);      while ($comment = db_fetch_object($comments)) {        $text .= '<h2>'. check_plain($comment->subject) .'</h2>'. check_markup($comment->comment, $comment->format, FALSE);      }      return $text;    case 'search result':      $comments = db_result(db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = %d', $node->nid));      return format_plural($comments, '1 comment', '@count comments');    case 'rss item':      if ($node->comment != COMMENT_NODE_DISABLED) {        return array(array('key' => 'comments', 'value' => url('node/'. $node->nid, array('fragment' => 'comments', 'absolute' => TRUE))));      }      else {        return array();      }  }}/** * Implementation of hook_user(). */function comment_user($type, $edit, &$user, $category = NULL) {  if ($type == 'delete') {    db_query('UPDATE {comments} SET uid = 0 WHERE uid = %d', $user->uid);    db_query('UPDATE {node_comment_statistics} SET last_comment_uid = 0 WHERE last_comment_uid = %d', $user->uid);  }}/** * This is *not* a hook_access() implementation. This function is called * to determine whether the current user has access to a particular comment. * * Authenticated users can edit their comments as long they have not been * replied to. This prevents people from changing or revising their * statements based on the replies to their posts. * * @param $op *   The operation that is to be performed on the comment. Only 'edit' is recognized now. * @param $comment *   The comment object. * @return *   TRUE if the current user has acces to the comment, FALSE otherwise. */function comment_access($op, $comment) {  global $user;  if ($op == 'edit') {    return ($user->uid && $user->uid == $comment->uid && comment_num_replies($comment->cid) == 0) || user_access('administer comments');  }}/** * A simple helper function. * * @return *   The 0th and the 1st path components joined by a slash. */function comment_node_url() {  return arg(0) .'/'. arg(1);}/** * Accepts a submission of new or changed comment content. * * @param $edit *   A comment array. * * @return *   If the comment is successfully saved the comment ID is returned. If the comment *   is not saved, FALSE is returned. */function comment_save($edit) {  global $user;  if (user_access('post comments') && (user_access('administer comments') || node_comment_mode($edit['nid']) == COMMENT_NODE_READ_WRITE)) {    if (!form_get_errors()) {      $edit += array(        'mail' => '',        'homepage' => '',        'name' => '',        'status' => user_access('post comments without approval') ? COMMENT_PUBLISHED : COMMENT_NOT_PUBLISHED,      );      if ($edit['cid']) {        // Update the comment in the database.        db_query("UPDATE {comments} SET status = %d, timestamp = %d, subject = '%s', comment = '%s', format = %d, uid = %d, name = '%s', mail = '%s', homepage = '%s' WHERE cid = %d", $edit['status'], $edit['timestamp'], $edit['subject'], $edit['comment'], $edit['format'], $edit['uid'], $edit['name'], $edit['mail'], $edit['homepage'], $edit['cid']);        // Allow modules to respond to the updating of a comment.        comment_invoke_comment($edit, 'update');        // Add an entry to the watchdog log.        watchdog('content', 'Comment: updated %subject.', array('%subject' => $edit['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $edit['nid'], array('fragment' => 'comment-'. $edit['cid'])));      }      else {        // Add the comment to database.        // Here we are building the thread field. See the documentation for        // comment_render().        if ($edit['pid'] == 0) {          // This is a comment with no parent comment (depth 0): we start          // by retrieving the maximum thread level.          $max = db_result(db_query('SELECT MAX(thread) FROM {comments} WHERE nid = %d', $edit['nid']));          // Strip the "/" from the end of the thread.          $max = rtrim($max, '/');          // Finally, build the thread field for this new comment.          $thread = int2vancode(vancode2int($max) + 1) .'/';        }        else {          // This is comment with a parent comment: we increase          // the part of the thread value at the proper depth.          // Get the parent comment:          $parent = _comment_load($edit['pid']);          // Strip the "/" from the end of the parent thread.          $parent->thread = (string) rtrim((string) $parent->thread, '/');          // Get the max value in _this_ thread.          $max = db_result(db_query("SELECT MAX(thread) FROM {comments} WHERE thread LIKE '%s.%%' AND nid = %d", $parent->thread, $edit['nid']));          if ($max == '') {            // First child of this parent.            $thread = $parent->thread .'.'. int2vancode(0) .'/';          }          else {            // Strip the "/" at the end of the thread.            $max = rtrim($max, '/');            // We need to get the value at the correct depth.            $parts = explode('.', $max);            $parent_depth = count(explode('.', $parent->thread));            $last = $parts[$parent_depth];            // Finally, build the thread field for this new comment.            $thread = $parent->thread .'.'. int2vancode(vancode2int($last) + 1) .'/';          }        }        if (empty($edit['timestamp'])) {          $edit['timestamp'] = time();        }        if ($edit['uid'] === $user->uid && isset($user->name)) { // '===' Need to modify anonymous users as well.          $edit['name'] = $user->name;        }        db_query("INSERT INTO {comments} (nid, pid, uid, subject, comment, format, hostname, timestamp, status, thread, name, mail, homepage) VALUES (%d, %d, %d, '%s', '%s', %d, '%s', %d, %d, '%s', '%s', '%s', '%s')", $edit['nid'], $edit['pid'], $edit['uid'], $edit['subject'], $edit['comment'], $edit['format'], ip_address(), $edit['timestamp'], $edit['status'], $thread, $edit['name'], $edit['mail'], $edit['homepage']);        $edit['cid'] = db_last_insert_id('comments', 'cid');        // Tell the other modules a new comment has been submitted.        comment_invoke_comment($edit, 'insert');        // Add an entry to the watchdog log.        watchdog('content', 'Comment: added %subject.', array('%subject' => $edit['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $edit['nid'], array('fragment' => 'comment-'. $edit['cid'])));      }      _comment_update_node_statistics($edit['nid']);      // Clear the cache so an anonymous user can see his comment being added.      cache_clear_all();      // Explain the approval queue if necessary, and then      // redirect the user to the node he's commenting on.      if ($edit['status'] == COMMENT_NOT_PUBLISHED) {        drupal_set_message(t('Your comment has been queued for moderation by site administrators and will be published after approval.'));      }      else {        comment_invoke_comment($edit, 'publish');      }      return $edit['cid'];    }    else {      return FALSE;    }  }  else {    watchdog('content', 'Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $edit['subject']), WATCHDOG_WARNING);    drupal_set_message(t('Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $edit['subject'])), 'error');    return FALSE;  }}/** * Build command links for a comment (e.g.\ edit, reply, delete) with respect to the current user's access permissions. * * @param $comment *   The comment to which the links will be related. * @param $return *   Not used. * @return *   An associative array containing the links. */function comment_links($comment, $return = 1) {  global $user;  $links = array();  // If we are viewing just this comment, we link back to the node.  if ($return) {    $links['comment_parent'] = array(      'title' => t('parent'),      'href' => comment_node_url(),      'fragment' => "comment-$comment->cid"    );  }  if (node_comment_mode($comment->nid) == COMMENT_NODE_READ_WRITE) {    if (user_access('administer comments') && user_access('post comments')) {      $links['comment_delete'] = array(        'title' => t('delete'),        'href' => "comment/delete/$comment->cid"      );      $links['comment_edit'] = array(        'title' => t('edit'),        'href' => "comment/edit/$comment->cid"      );      $links['comment_reply'] = array(        'title' => t('reply'),        'href' => "comment/reply/$comment->nid/$comment->cid"      );    }    else if (user_access('post comments')) {      if (comment_access('edit', $comment)) {        $links['comment_edit'] = array(          'title' => t('edit'),          'href' => "comment/edit/$comment->cid"        );      }      $links['comment_reply'] = array(        'title' => t('reply'),        'href' => "comment/reply/$comment->nid/$comment->cid"      );    }    else {      $node = node_load($comment->nid);      $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);    }  }  return $links;}/** * Renders comment(s). * * @param $node *   The node which comment(s) needs rendering. * @param $cid *   Optional, if given, only one comment is rendered. * * To display threaded comments in the correct order we keep a 'thread' field * and order by that value. This field keeps this data in * a way which is easy to update and convenient to use. * * A "thread" value starts at "1". If we add a child (A) to this comment, * we assign it a "thread" = "1.1". A child of (A) will have "1.1.1". Next * brother of (A) will get "1.2". Next brother of the parent of (A) will get * "2" and so on. * * First of all note that the thread field stores the depth of the comment: * depth 0 will be "X", depth 1 "X.X", depth 2 "X.X.X", etc. * * Now to get the ordering right, consider this example: * * 1 * 1.1 * 1.1.1 * 1.2 * 2 * * If we "ORDER BY thread ASC" we get the above result, and this is the * natural order sorted by time. However, if we "ORDER BY thread DESC" * we get: * * 2 * 1.2 * 1.1.1 * 1.1 * 1 * * Clearly, this is not a natural way to see a thread, and users will get * confused. The natural order to show a thread by time desc would be: * * 2 * 1 * 1.2 * 1.1 * 1.1.1 * * which is what we already did before the standard pager patch. To achieve * this we simply add a "/" at the end of each "thread" value. This way out * thread fields will look like depicted below: * * 1/ * 1.1/ * 1.1.1/ * 1.2/ * 2/ * * we add "/" since this char is, in ASCII, higher than every number, so if * now we "ORDER BY thread DESC" we get the correct order. However this would * spoil the reverse ordering, "ORDER BY thread ASC" -- here, we do not need * to consider the trailing "/" so we use a substring only. */function comment_render($node, $cid = 0) {  global $user;  $output = '';  if (user_access('access comments')) {    // Pre-process variables.    $nid = $node->nid;    if (empty($nid)) {      $nid = 0;    }    $mode = _comment_get_display_setting('mode', $node);    $order = _comment_get_display_setting('sort', $node);    $comments_per_page = _comment_get_display_setting('comments_per_page', $node);    if ($cid && is_numeric($cid)) {      // Single comment view.      $query = 'SELECT c.cid, c.pid, c.nid, c.subject, c.comment, c.format, c.timestamp, c.name, c.mail, c.homepage, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data, c.status FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d';      $query_args = array($cid);      if (!user_access('administer comments')) {        $query .= ' AND c.status = %d';        $query_args[] = COMMENT_PUBLISHED;      }      $query = db_rewrite_sql($query, 'c', 'cid');      $result = db_query($query, $query_args);      if ($comment = db_fetch_object($result)) {        $comment->name = $comment->uid ? $comment->registered_name : $comment->name;        $links = module_invoke_all('link', 'comment', $comment, 1);        drupal_alter('link', $links, $node);        $output .= theme('comment_view', $comment, $node, $links);      }    }    else {      // Multiple comment view      $query_count = 'SELECT COUNT(*) FROM {comments} c WHERE c.nid = %d';      $query = 'SELECT c.cid as cid, c.pid, c.nid, c.subject, c.comment, c.format, c.timestamp, c.name, c.mail, c.homepage, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data, c.thread, c.status FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.nid = %d';      $query_args = array($nid);      if (!user_access('administer comments')) {        $query .= ' AND c.status = %d';        $query_count .= ' AND c.status = %d';        $query_args[] = COMMENT_PUBLISHED;      }      if ($order == COMMENT_ORDER_NEWEST_FIRST) {        if ($mode == COMMENT_MODE_FLAT_COLLAPSED || $mode == COMMENT_MODE_FLAT_EXPANDED) {          $query .= ' ORDER BY c.cid DESC';        }        else {          $query .= ' ORDER BY c.thread DESC';        }      }      else if ($order == COMMENT_ORDER_OLDEST_FIRST) {        if ($mode == COMMENT_MODE_FLAT_COLLAPSED || $mode == COMMENT_MODE_FLAT_EXPANDED) {          $query .= ' ORDER BY c.cid';        }        else {          // See comment above. Analysis reveals that this doesn't cost too          // much. It scales much much better than having the whole comment          // structure.          $query .= ' ORDER BY SUBSTRING(c.thread, 1, (LENGTH(c.thread) - 1))';        }      }      $query = db_rewrite_sql($query, 'c', 'cid');      $query_count = db_rewrite_sql($query_count, 'c', 'cid');      // Start a form, for use with comment control.      $result = pager_query($query, $comments_per_page, 0, $query_count, $query_args);      $divs = 0;      $num_rows = FALSE;      $comments = '';      drupal_add_css(drupal_get_path('module', 'comment') .'/comment.css');      while ($comment = db_fetch_object($result)) {        $comment = drupal_unpack($comment);        $comment->name = $comment->uid ? $comment->registered_name : $comment->name;        $comment->depth = count(explode('.', $comment->thread)) - 1;        if ($mode == COMMENT_MODE_THREADED_COLLAPSED || $mode == COMMENT_MODE_THREADED_EXPANDED) {          if ($comment->depth > $divs) {            $divs++;            $comments .= '<div class="indented">';          }          else {            while ($comment->depth < $divs) {              $divs--;              $comments .= '</div>';            }          }        }        if ($mode == COMMENT_MODE_FLAT_COLLAPSED) {          $comments .= theme('comment_flat_collapsed', $comment, $node);        }        else if ($mode == COMMENT_MODE_FLAT_EXPANDED) {          $comments .= theme('comment_flat_expanded', $comment, $node);        }        else if ($mode == COMMENT_MODE_THREADED_COLLAPSED) {          $comments .= theme('comment_thread_collapsed', $comment, $node);        }        else if ($mode == COMMENT_MODE_THREADED_EXPANDED) {          $comments .= theme('comment_thread_expanded', $comment, $node);        }        $num_rows = TRUE;      }      while ($divs-- > 0) {        $comments .= '</div>';      }      $comment_controls = variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN);      if ($num_rows && ($comment_controls == COMMENT_CONTROLS_ABOVE || $comment_controls == COMMENT_CONTROLS_ABOVE_BELOW)) {        $output .= drupal_get_form('comment_controls', $mode, $order, $comments_per_page);      }      $output .= $comments;      $output .= theme('pager', NULL, $comments_per_page, 0);      if ($num_rows && ($comment_controls == COMMENT_CONTROLS_BELOW || $comment_controls == COMMENT_CONTROLS_ABOVE_BELOW)) {        $output .= drupal_get_form('comment_controls', $mode, $order, $comments_per_page);      }    }    // If enabled, show new comment form if it's not already being displayed.    $reply = arg(0) == 'comment' && arg(1) == 'reply';    if (user_access('post comments') && node_comment_mode($nid) == COMMENT_NODE_READ_WRITE && (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_BELOW) && !$reply) {      $output .= comment_form_box(array('nid' => $nid), t('Post new comment'));    }    if ($output) {      $output = theme('comment_wrapper', $output, $node);    }  }  return $output;}/** * Comment operations. We offer different update operations depending on * which comment administration page we're on. * * @param $action *   The comment administration page. * @return *   An associative array containing the offered operations. */function comment_operations($action = NULL) {  if ($action == 'publish') {    $operations = array(      'publish' => array(t('Publish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  else if ($action == 'unpublish') {    $operations = array(      'unpublish' => array(t('Unpublish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  else {    $operations = array(      'publish' => array(t('Publish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d'),      'unpublish' => array(t('Unpublish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  return $operations;}/** * Misc functions: helpers, privates, history *//** * Load the entire comment by cid. * * @param $cid *   The identifying comment id. * @return *   The comment object. */function _comment_load($cid) {  return db_fetch_object(db_query('SELECT * FROM {comments} WHERE cid = %d', $cid));}/** * Get comment count for a node. * * @param $nid *   The node id. * @return *   The comment count. */function comment_num_all($nid) {  static $cache;  if (!isset($cache[$nid])) {    $cache[$nid] = db_result(db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = %d', $nid));  }  return $cache[$nid];}/** * Get replies count for a comment. * * @param $pid *   The comment id. * @return *   The replies count. */function comment_num_replies($pid) {  static $cache;  if (!isset($cache[$pid])) {    $cache[$pid] = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE pid = %d AND status = %d', $pid, COMMENT_PUBLISHED));  }  return $cache[$pid];}/** * Get number of new comments for current user and specified node. * * @param $nid *   node-id to count comments for * @param $timestamp *   time to count from (defaults to time of last user access *   to node) */function comment_num_new($nid, $timestamp = 0) {  global $user;  if ($user->uid) {    // Retrieve the timestamp at which the current user last viewed the    // specified node.    if (!$timestamp) {      $timestamp = node_last_viewed($nid);    }    $timestamp = ($timestamp > NODE_NEW_LIMIT ? $timestamp : NODE_NEW_LIMIT);    // Use the timestamp to retrieve the number of new comments.    $result = db_result(db_query('SELECT COUNT(c.cid) FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid WHERE n.nid = %d AND timestamp > %d AND c.status = %d', $nid, $timestamp, COMMENT_PUBLISHED));    return $result;  }  else {    return 0;  }}/** * Validate comment data. * * @param $edit *   An associative array containig the comment data. * @return *   The original $edit. */function comment_validate($edit) {  global $user;  // Invoke other validation handlers  comment_invoke_comment($edit, 'validate');  if (isset($edit['date'])) {    // As of PHP 5.1.0, strtotime returns FALSE upon failure instead of -1.    if (strtotime($edit['date']) <= 0) {      form_set_error('date', t('You have to specify a valid date.'));    }  }  if (isset($edit['author']) && !$account = user_load(array('name' => $edit['author']))) {    form_set_error('author', t('You have to specify a valid author.'));  }  // Check validity of name, mail and homepage (if given)  if (!$user->uid || isset($edit['is_anonymous'])) {    $node = node_load($edit['nid']);    if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) > COMMENT_ANONYMOUS_MAYNOT_CONTACT) {      if ($edit['name']) {        $taken = db_result(db_query("SELECT COUNT(uid) FROM {users} WHERE LOWER(name) = '%s'", $edit['name']));        if ($taken != 0) {          form_set_error('name', t('The name you used belongs to a registered user.'));        }      }      else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {        form_set_error('name', t('You have to leave your name.'));      }      if ($edit['mail']) {        if (!valid_email_address($edit['mail'])) {          form_set_error('mail', t('The e-mail address you specified is not valid.'));        }      }      else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {        form_set_error('mail', t('You have to leave an e-mail address.'));      }      if ($edit['homepage']) {        if (!valid_url($edit['homepage'], TRUE)) {          form_set_error('homepage', t('The URL of your homepage is not valid. Remember that it must be fully qualified, i.e. of the form <code>http://example.com/directory</code>.'));        }      }    }  }  return $edit;}/** * Generate the basic commenting form, for appending to a node or display on a separate page. * * @param $title *   Not used. * @ingroup forms * @see comment_form_validate() * @see comment_form_submit() */function comment_form(&$form_state, $edit, $title = NULL) {  global $user;  $op = isset($_POST['op']) ? $_POST['op'] : '';  $node = node_load($edit['nid']);  if (!$user->uid && variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) != COMMENT_ANONYMOUS_MAYNOT_CONTACT) {    drupal_add_js(drupal_get_path('module', 'comment') .'/comment.js');  }  $edit += array('name' => '', 'mail' => '', 'homepage' => '');  if ($user->uid) {    if (!empty($edit['cid']) && user_access('administer comments')) {      if (!empty($edit['author'])) {        $author = $edit['author'];      }      elseif (!empty($edit['name'])) {        $author = $edit['name'];      }      else {        $author = $edit['registered_name'];      }      if (!empty($edit['status'])) {        $status = $edit['status'];      }      else {        $status = 0;      }      if (!empty($edit['date'])) {        $date = $edit['date'];      }      else {        $date = format_date($edit['timestamp'], 'custom', 'Y-m-d H:i O');      }      $form['admin'] = array(        '#type' => 'fieldset',        '#title' => t('Administration'),        '#collapsible' => TRUE,        '#collapsed' => TRUE,        '#weight' => -2,      );      if ($edit['registered_name'] != '') {        // The comment is by a registered user        $form['admin']['author'] = array(          '#type' => 'textfield',          '#title' => t('Authored by'),          '#size' => 30,          '#maxlength' => 60,          '#autocomplete_path' => 'user/autocomplete',          '#default_value' => $author,          '#weight' => -1,        );      }      else {        // The comment is by an anonymous user        $form['is_anonymous'] = array(          '#type' => 'value',          '#value' => TRUE,        );        $form['admin']['name'] = array(          '#type' => 'textfield',          '#title' => t('Authored by'),          '#size' => 30,          '#maxlength' => 60,          '#default_value' => $author,          '#weight' => -1,        );        $form['admin']['mail'] = array(          '#type' => 'textfield',          '#title' => t('E-mail'),          '#maxlength' => 64,          '#size' => 30,          '#default_value' => $edit['mail'],          '#description' => t('The content of this field is kept private and will not be shown publicly.'),        );        $form['admin']['homepage'] = array(          '#type' => 'textfield',          '#title' => t('Homepage'),          '#maxlength' => 255,          '#size' => 30,          '#default_value' => $edit['homepage'],        );      }      $form['admin']['date'] = array('#type' => 'textfield', '#parents' => array('date'), '#title' => t('Authored on'), '#size' => 20, '#maxlength' => 25, '#default_value' => $date, '#weight' => -1);      $form['admin']['status'] = array('#type' => 'radios', '#parents' => array('status'), '#title' => t('Status'), '#default_value' =>  $status, '#options' => array(t('Published'), t('Not published')), '#weight' => -1);    }    else {      $form['_author'] = array('#type' => 'item', '#title' => t('Your name'), '#value' => theme('username', $user)      );      $form['author'] = array('#type' => 'value', '#value' => $user->name);    }  }  else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MAY_CONTACT) {    $form['name'] = array('#type' => 'textfield', '#title' => t('Your name'), '#maxlength' => 60, '#size' => 30, '#default_value' => $edit['name'] ? $edit['name'] : variable_get('anonymous', t('Anonymous'))    );    $form['mail'] = array('#type' => 'textfield', '#title' => t('E-mail'), '#maxlength' => 64, '#size' => 30, '#default_value' => $edit['mail'], '#description' => t('The content of this field is kept private and will not be shown publicly.')    );    $form['homepage'] = array('#type' => 'textfield', '#title' => t('Homepage'), '#maxlength' => 255, '#size' => 30, '#default_value' => $edit['homepage']);  }  else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {    $form['name'] = array('#type' => 'textfield', '#title' => t('Your name'), '#maxlength' => 60, '#size' => 30, '#default_value' => $edit['name'] ? $edit['name'] : variable_get('anonymous', t('Anonymous')), '#required' => TRUE);    $form['mail'] = array('#type' => 'textfield', '#title' => t('E-mail'), '#maxlength' => 64, '#size' => 30, '#default_value' => $edit['mail'], '#description' => t('The content of this field is kept private and will not be shown publicly.'), '#required' => TRUE);    $form['homepage'] = array('#type' => 'textfield', '#title' => t('Homepage'), '#maxlength' => 255, '#size' => 30, '#default_value' => $edit['homepage']);  }  if (variable_get('comment_subject_field_'. $node->type, 1) == 1) {    $form['subject'] = array('#type' => 'textfield', '#title' => t('Subject'), '#maxlength' => 64, '#default_value' => !empty($edit['subject']) ? $edit['subject'] : '');  }  if (!empty($edit['comment'])) {    $default = $edit['comment'];  }  else {    $default = '';  }  $form['comment_filter']['comment'] = array(    '#type' => 'textarea',    '#title' => t('Comment'),    '#rows' => 15,    '#default_value' => $default,    '#required' => TRUE,  );  if (!isset($edit['format'])) {    $edit['format'] = FILTER_FORMAT_DEFAULT;  }  $form['comment_filter']['format'] = filter_form($edit['format']);  $form['cid'] = array('#type' => 'value', '#value' => !empty($edit['cid']) ? $edit['cid'] : NULL);  $form['pid'] = array('#type' => 'value', '#value' => !empty($edit['pid']) ? $edit['pid'] : NULL);  $form['nid'] = array('#type' => 'value', '#value' => $edit['nid']);  $form['uid'] = array('#type' => 'value', '#value' => !empty($edit['uid']) ? $edit['uid'] : 0);  // Only show save button if preview is optional or if we are in preview mode.  // We show the save button in preview mode even if there are form errors so that  // optional form elements (e.g., captcha) can be updated in preview mode.  if (!form_get_errors() && ((variable_get('comment_preview_'. $node->type, COMMENT_PREVIEW_REQUIRED) == COMMENT_PREVIEW_OPTIONAL) || ($op == t('Preview')) || ($op == t('Save')))) {    $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 19);  }  $form['preview'] = array('#type' => 'button', '#value' => t('Preview'), '#weight' => 20);  $form['#token'] = 'comment'. $edit['nid'] . (isset($edit['pid']) ? $edit['pid'] : '');  if ($op == t('Preview')) {    $form['#after_build'] = array('comment_form_add_preview');  }  if (empty($edit['cid']) && empty($edit['pid'])) {    $form['#action'] = url('comment/reply/'. $edit['nid']);  }  return $form;}/** * Theme the comment form box. * * @param $edit *   The form structure. * @param $title *   The form title. */function comment_form_box($edit, $title = NULL) {  return theme('box', $title, drupal_get_form('comment_form', $edit, $title));}/** * Form builder; Generate and validate a comment preview form. * * @ingroup forms */function comment_form_add_preview($form, &$form_state) {  global $user;  $edit = $form_state['values'];  drupal_set_title(t('Preview comment'));  $output = '';  $node = node_load($edit['nid']);  // Invoke full validation for the form, to protect against cross site  // request forgeries (CSRF) and setting arbitrary values for fields such as  // the input format. Preview the comment only when form validation does not  // set any errors.  drupal_validate_form($form['form_id']['#value'], $form, $form_state);  if (!form_get_errors()) {    _comment_form_submit($edit);    $comment = (object)$edit;    // Attach the user and time information.    if (!empty($edit['author'])) {      $account = user_load(array('name' => $edit['author']));    }    elseif ($user->uid && !isset($edit['is_anonymous'])) {      $account = $user;    }    if (!empty($account)) {      $comment->uid = $account->uid;      $comment->name = check_plain($account->name);    }    elseif (empty($comment->name)) {      $comment->name = variable_get('anonymous', t('Anonymous'));    }    $comment->timestamp = !empty($edit['timestamp']) ? $edit['timestamp'] : time();    $output .= theme('comment_view', $comment, $node);  }  $form['comment_preview'] = array(    '#value' => $output,    '#weight' => -100,    '#prefix' => '<div class="preview">',    '#suffix' => '</div>',  );  $output = '';  if ($edit['pid']) {    $comment = db_fetch_object(db_query('SELECT c.*, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status = %d', $edit['pid'], COMMENT_PUBLISHED));    $comment = drupal_unpack($comment);    $comment->name = $comment->uid ? $comment->registered_name : $comment->name;    $output .= theme('comment_view', $comment, $node);  }  else {    $suffix = empty($form['#suffix']) ? '' : $form['#suffix'];    $form['#suffix'] = $suffix . node_view($node);    $edit['pid'] = 0;  }  $form['comment_preview_below'] = array('#value' => $output, '#weight' => 100);  return $form;}/** * Validate comment form submissions. */function comment_form_validate($form, &$form_state) {  global $user;  if ($user->uid === 0) {    foreach (array('name', 'homepage', 'mail') as $field) {      // Set cookie for 365 days.      if (isset($form_state['values'][$field])) {        setcookie('comment_info_'. $field, $form_state['values'][$field], time() + 31536000, '/');      }    }  }  comment_validate($form_state['values']);}/** * Prepare a comment for submission. * * @param $comment_values *   An associative array containing the comment data. */function _comment_form_submit(&$comment_values) {  $comment_values += array('subject' => '');  if (!isset($comment_values['date'])) {    $comment_values['date'] = 'now';  }  $comment_values['timestamp'] = strtotime($comment_values['date']);  if (isset($comment_values['author'])) {    $account = user_load(array('name' => $comment_values['author']));    $comment_values['uid'] = $account->uid;    $comment_values['name'] = $comment_values['author'];  }  // Validate the comment's subject. If not specified, extract  // one from the comment's body.  if (trim($comment_values['subject']) == '') {    // The body may be in any format, so we:    // 1) Filter it into HTML    // 2) Strip out all HTML tags    // 3) Convert entities back to plain-text.    // Note: format is checked by check_markup().    $comment_values['subject'] = truncate_utf8(trim(decode_entities(strip_tags(check_markup($comment_values['comment'], $comment_values['format'])))), 29, TRUE);    // Edge cases where the comment body is populated only by HTML tags will    // require a default subject.    if ($comment_values['subject'] == '') {      $comment_values['subject'] = t('(No subject)');    }  }}/** * Process comment form submissions; prepare the comment, store it, and set a redirection target. */function comment_form_submit($form, &$form_state) {  _comment_form_submit($form_state['values']);  if ($cid = comment_save($form_state['values'])) {    $node = node_load($form_state['values']['nid']);    // Add 1 to existing $node->comment count to include new comment being added.    $comment_count = $node->comment_count + 1;    $page = comment_new_page_count($comment_count, 1, $node);    $form_state['redirect'] = array('node/'. $node->nid, $page, "comment-$cid");    return;  }}/** * Themes a single comment and related items. * * @param $comment *   The comment object. * @param $node *   The comment node. * @param $links *   An associative array containing control links suitable for passing into *   theme_links(). These are generated by modules implementing hook_link() with *   $type='comment'. Typical examples are links for editing and deleting *   comments. * @param $visible *   Switches between folded/unfolded view. If TRUE the comments are visible, if *   FALSE the comments are folded. * @ingroup themeable */function theme_comment_view($comment, $node, $links = array(), $visible = TRUE) {  static $first_new = TRUE;  $output = '';  $comment->new = node_mark($comment->nid, $comment->timestamp);  if ($first_new && $comment->new != MARK_READ) {    // Assign the anchor only for the first new comment. This avoids duplicate    // id attributes on a page.    $first_new = FALSE;    $output .= "<a id=\"new\"></a>\n";  }  $output .= "<a id=\"comment-$comment->cid\"></a>\n";  // Switch to folded/unfolded view of the comment  if ($visible) {    $comment->comment = check_markup($comment->comment, $comment->format, FALSE);    // Comment API hook    comment_invoke_comment($comment, 'view');    $output .= theme('comment', $comment, $node, $links);  }  else {    $output .= theme('comment_folded', $comment);  }  return $output;}/** * Build a comment control form. * * @param $mode *   Comment display mode. * @param $order *   Comment order mode. * @param $comments_per_page *   Comments per page. * @ingroup forms */function comment_controls(&$form_state, $mode = COMMENT_MODE_THREADED_EXPANDED, $order = COMMENT_ORDER_NEWEST_FIRST, $comments_per_page = 50) {  $form['mode'] = array('#type' => 'select',    '#default_value' => $mode,    '#options' => _comment_get_modes(),    '#weight' => 1,  );  $form['order'] = array(    '#type' => 'select',    '#default_value' => $order,    '#options' => _comment_get_orders(),    '#weight' => 2,  );  foreach (_comment_per_page() as $i) {    $options[$i] = t('!a comments per page', array('!a' => $i));  }  $form['comments_per_page'] = array('#type' => 'select',    '#default_value' => $comments_per_page,    '#options' => $options,    '#weight' => 3,  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Save settings'),    '#weight' => 20,  );  return $form;}/** * Theme comment controls box where the user can change the default display mode and display order of comments. * * @param $form *   The form structure. * @ingroup themeable */function theme_comment_controls($form) {  $output = '<div class="container-inline">';  $output .=  drupal_render($form);  $output .= '</div>';  $output .= '<div class="description">'. t('Select your preferred way to display the comments and click "Save settings" to activate your changes.') .'</div>';  return theme('box', t('Comment viewing options'), $output);}/** * Process comment_controls form submissions. */function comment_controls_submit($form, &$form_state) {  global $user;  $mode = $form_state['values']['mode'];  $order = $form_state['values']['order'];  $comments_per_page = $form_state['values']['comments_per_page'];  if ($user->uid) {    $account = user_save($user, array('mode' => $mode, 'sort' => $order, 'comments_per_page' => $comments_per_page));    // Terminate if an error occured during user_save().    if (!$account) {      drupal_set_message(t("Error saving user account."), 'error');      return;    }    $user = $account;  }  else {    $_SESSION['comment_mode'] = $mode;    $_SESSION['comment_sort'] = $order;    $_SESSION['comment_comments_per_page'] = $comments_per_page;  }}/** * Process variables for comment.tpl.php. * * @see comment.tpl.php * @see theme_comment() */function template_preprocess_comment(&$variables) {  $comment = $variables['comment'];  $node = $variables['node'];  $variables['author']    = theme('username', $comment);  $variables['content']   = $comment->comment;  $variables['date']      = format_date($comment->timestamp);  $variables['links']     = isset($variables['links']) ? theme('links', $variables['links']) : '';  $variables['new']       = $comment->new ? t('new') : '';  $variables['picture']   = theme_get_setting('toggle_comment_user_picture') ? theme('user_picture', $comment) : '';  $variables['signature'] = $comment->signature;  $variables['submitted'] = theme('comment_submitted', $comment);  $variables['title']     = l($comment->subject, $_GET['q'], array('fragment' => "comment-$comment->cid"));  $variables['template_files'][] = 'comment-'. $node->type;  // set status to a string representation of comment->status.  if (isset($comment->preview)) {    $variables['status']  = 'comment-preview';  }  else {    $variables['status']  = ($comment->status == COMMENT_NOT_PUBLISHED) ? 'comment-unpublished' : 'comment-published';  }}/** * Process variables for comment-folded.tpl.php. * * @see comment-folded.tpl.php * @see theme_comment_folded() */function template_preprocess_comment_folded(&$variables) {  $comment = $variables['comment'];  $variables['author'] = theme('username', $comment);  $variables['date']   = format_date($comment->timestamp);  $variables['new']    = $comment->new ? t('new') : '';  $variables['title']  = l($comment->subject, comment_node_url() .'/'. $comment->cid, array('fragment' => "comment-$comment->cid"));}/** * Theme comment flat collapsed view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_flat_collapsed($comment, $node) {  return theme('comment_view', $comment, $node, '', 0);}/** * Theme comment flat expanded view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_flat_expanded($comment, $node) {  $links = module_invoke_all('link', 'comment', $comment, 0);  drupal_alter('link', $links, $node);  return theme('comment_view', $comment, $node, $links);}/** * Theme comment thread collapsed view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_thread_collapsed($comment, $node) {  return theme('comment_view', $comment, $node, '', 0);}/** * Theme comment thread expanded view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_thread_expanded($comment, $node) {  $links = module_invoke_all('link', 'comment', $comment, 0);  drupal_alter('link', $links, $node);  return theme('comment_view', $comment, $node, $links);}/** * Theme a "you can't post comments" notice. * * @param $node *   The comment node. * @ingroup themeable */function theme_comment_post_forbidden($node) {  global $user;  static $authenticated_post_comments;  if (!$user->uid) {    if (!isset($authenticated_post_comments)) {      // We only output any link if we are certain, that users get permission      // to post comments by logging in. We also locally cache this information.      $authenticated_post_comments = array_key_exists(DRUPAL_AUTHENTICATED_RID, user_roles(TRUE, 'post comments') + user_roles(TRUE, 'post comments without approval'));    }    if ($authenticated_post_comments) {      // We cannot use drupal_get_destination() because these links      // sometimes appear on /node and taxonomy listing pages.      if (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_SEPARATE_PAGE) {        $destination = 'destination='. rawurlencode("comment/reply/$node->nid#comment-form");      }      else {        $destination = 'destination='. rawurlencode("node/$node->nid#comment-form");      }      if (variable_get('user_register', 1)) {        // Users can register themselves.        return t('<a href="@login">Login</a> or <a href="@register">register</a> to post comments', array('@login' => url('user/login', array('query' => $destination)), '@register' => url('user/register', array('query' => $destination))));      }      else {        // Only admins can add new users, no public registration.        return t('<a href="@login">Login</a> to post comments', array('@login' => url('user/login', array('query' => $destination))));      }    }  }}/** * Process variables for comment-wrapper.tpl.php. * * @see comment-wrapper.tpl.php * @see theme_comment_wrapper() */function template_preprocess_comment_wrapper(&$variables) {  // Provide contextual information.  $variables['display_mode']  = _comment_get_display_setting('mode', $variables['node']);  $variables['display_order'] = _comment_get_display_setting('sort', $variables['node']);  $variables['comment_controls_state'] = variable_get('comment_controls_'. $variables['node']->type, COMMENT_CONTROLS_HIDDEN);  $variables['template_files'][] = 'comment-wrapper-'. $variables['node']->type;}/** * Theme a "Submitted by ..." notice. * * @param $comment *   The comment. * @ingroup themeable */function theme_comment_submitted($comment) {  return t('Submitted by !username on @datetime.',    array(      '!username' => theme('username', $comment),      '@datetime' => format_date($comment->timestamp)    ));}/** * Return an array of viewing modes for comment listings. * * We can't use a global variable array because the locale system * is not initialized yet when the comment module is loaded. */function _comment_get_modes() {  return array(    COMMENT_MODE_FLAT_COLLAPSED => t('Flat list - collapsed'),    COMMENT_MODE_FLAT_EXPANDED => t('Flat list - expanded'),    COMMENT_MODE_THREADED_COLLAPSED => t('Threaded list - collapsed'),    COMMENT_MODE_THREADED_EXPANDED => t('Threaded list - expanded')  );}/** * Return an array of viewing orders for comment listings. * * We can't use a global variable array because the locale system * is not initialized yet when the comment module is loaded. */function _comment_get_orders() {  return array(    COMMENT_ORDER_NEWEST_FIRST => t('Date - newest first'),    COMMENT_ORDER_OLDEST_FIRST => t('Date - oldest first')  );}/** * Return an array of "comments per page" settings from which the user * can choose. */function _comment_per_page() {  return drupal_map_assoc(array(10, 30, 50, 70, 90, 150, 200, 250, 300));}/** * Return a current comment display setting * * @param $setting *   can be one of these: 'mode', 'sort', 'comments_per_page' * @param $node *   The comment node in question. */function _comment_get_display_setting($setting, $node) {  global $user;  if (isset($_GET[$setting])) {    $value = $_GET[$setting];  }  else {    // get the setting's site default    switch ($setting) {      case 'mode':        $default = variable_get('comment_default_mode_'. $node->type, COMMENT_MODE_THREADED_EXPANDED);        break;      case 'sort':        $default = variable_get('comment_default_order_'. $node->type, COMMENT_ORDER_NEWEST_FIRST);        break;      case 'comments_per_page':        $default = variable_get('comment_default_per_page_'. $node->type, 50);    }    if (variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN) == COMMENT_CONTROLS_HIDDEN) {      // if comment controls are disabled use site default      $value = $default;    }    else {      // otherwise use the user's setting if set      if (isset($user->$setting) && $user->$setting) {        $value = $user->$setting;      }      else if (isset($_SESSION['comment_'. $setting]) && $_SESSION['comment_'. $setting]) {        $value = $_SESSION['comment_'. $setting];      }      else {        $value = $default;      }    }  }  return $value;}/** * Updates the comment statistics for a given node. This should be called any * time a comment is added, deleted, or updated. * * The following fields are contained in the node_comment_statistics table. * - last_comment_timestamp: the timestamp of the last comment for this node or the node create stamp if no comments exist for the node. * - last_comment_name: the name of the anonymous poster for the last comment * - last_comment_uid: the uid of the poster for the last comment for this node or the node authors uid if no comments exists for the node. * - comment_count: the total number of approved/published comments on this node. */function _comment_update_node_statistics($nid) {  $count = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE nid = %d AND status = %d', $nid, COMMENT_PUBLISHED));  // comments exist  if ($count > 0) {    $last_reply = db_fetch_object(db_query_range('SELECT cid, name, timestamp, uid FROM {comments} WHERE nid = %d AND status = %d ORDER BY cid DESC', $nid, COMMENT_PUBLISHED, 0, 1));    db_query("UPDATE {node_comment_statistics} SET comment_count = %d, last_comment_timestamp = %d, last_comment_name = '%s', last_comment_uid = %d WHERE nid = %d", $count, $last_reply->timestamp, $last_reply->uid ? '' : $last_reply->name, $last_reply->uid, $nid);  }  // no comments  else {    $node = db_fetch_object(db_query("SELECT uid, created FROM {node} WHERE nid = %d", $nid));    db_query("UPDATE {node_comment_statistics} SET comment_count = 0, last_comment_timestamp = %d, last_comment_name = '', last_comment_uid = %d WHERE nid = %d", $node->created, $node->uid, $nid);  }}/** * Invoke a hook_comment() operation in all modules. * * @param &$comment *   A comment object. * @param $op *   A string containing the name of the comment operation. * @return *   The returned value of the invoked hooks. */function comment_invoke_comment(&$comment, $op) {  $return = array();  foreach (module_implements('comment') as $name) {    $function = $name .'_comment';    $result = $function($comment, $op);    if (isset($result) && is_array($result)) {      $return = array_merge($return, $result);    }    else if (isset($result)) {      $return[] = $result;    }  }  return $return;}/** * Generate vancode. * * Consists of a leading character indicating length, followed by N digits * with a numerical value in base 36. Vancodes can be sorted as strings * without messing up numerical order. * * It goes: * 00, 01, 02, ..., 0y, 0z, * 110, 111, ... , 1zy, 1zz, * 2100, 2101, ..., 2zzy, 2zzz, * 31000, 31001, ... */function int2vancode($i = 0) {  $num = base_convert((int)$i, 10, 36);  $length = strlen($num);  return chr($length + ord('0') - 1) . $num;}/** * Decode vancode back to an integer. */function vancode2int($c = '00') {  return base_convert(substr($c, 1), 36, 10);}/** * Implementation of hook_hook_info(). */function comment_hook_info() {  return array(    'comment' => array(      'comment' => array(        'insert' => array(          'runs when' => t('After saving a new comment'),        ),        'update' => array(          'runs when' => t('After saving an updated comment'),        ),        'delete' => array(          'runs when' => t('After deleting a comment')        ),        'view' => array(          'runs when' => t('When a comment is being viewed by an authenticated user')        ),      ),    ),  );}/** * Implementation of hook_action_info(). */function comment_action_info() {  return array(    'comment_unpublish_action' => array(      'description' => t('Unpublish comment'),      'type' => 'comment',      'configurable' => FALSE,      'hooks' => array(        'comment' => array('insert', 'update'),      )    ),    'comment_unpublish_by_keyword_action' => array(      'description' => t('Unpublish comment containing keyword(s)'),      'type' => 'comment',      'configurable' => TRUE,      'hooks' => array(        'comment' => array('insert', 'update'),      )    )  );}/** * Drupal action to unpublish a comment. * * @param $context *   Keyed array. Must contain the id of the comment if $comment is not passed. * @param $comment *   An optional comment object. */function comment_unpublish_action($comment, $context = array()) {  if (isset($comment->cid)) {    $cid = $comment->cid;    $subject = $comment->subject;  }  else {    $cid = $context['cid'];    $subject = db_result(db_query("SELECT subject FROM {comments} WHERE cid = %d", $cid));  }  db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_NOT_PUBLISHED, $cid);  watchdog('action', 'Unpublished comment %subject.', array('%subject' => $subject));}/** * Form builder; Prepare a form for blacklisted keywords. * * @ingroup forms */function comment_unpublish_by_keyword_action_form($context) {  $form['keywords'] = array(    '#title' => t('Keywords'),    '#type' => 'textarea',    '#description' => t('The comment will be unpublished if it contains any of the character sequences above. Use a comma-separated list of character sequences. Example: funny, bungee jumping, "Company, Inc.". Character sequences are case-sensitive.'),    '#default_value' => isset($context['keywords']) ? drupal_implode_tags($context['keywords']) : '',  );  return $form;}/** * Process comment_unpublish_by_keyword_action_form form submissions. */function comment_unpublish_by_keyword_action_submit($form, $form_state) {  return array('keywords' => drupal_explode_tags($form_state['values']['keywords']));}/** * Implementation of a configurable Drupal action. * Unpublish a comment if it contains a certain string. * * @param $context *   An array providing more information about the context of the call to this action. *   Unused here since this action currently only supports the insert and update ops of *   the comment hook, both of which provide a complete $comment object. * @param $comment *   A comment object. */function comment_unpublish_by_keyword_action($comment, $context) {  foreach ($context['keywords'] as $keyword) {    if (strstr($comment->comment, $keyword) || strstr($comment->subject, $keyword)) {      db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_NOT_PUBLISHED, $comment->cid);      watchdog('action', 'Unpublished comment %subject.', array('%subject' => $comment->subject));      break;    }  }}
<?php// $Id$/** * Implementation of hook_schema(). */function block_schema() {  $schema['blocks'] = array(    'description' => 'Stores block settings, such as region and visibility settings.',    'fields' => array(      'bid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique block ID.',      ),      'module' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => "The module from which the block originates; for example, 'user' for the Who's Online block, and 'block' for any custom blocks.",      ),      'delta' => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '0',        'description' => 'Unique ID for block within a module.',      ),      'theme' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'The theme under which the block settings apply.',      ),      'status' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Block enabled status. (1 = enabled, 0 = disabled)',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Block weight within region.',      ),      'region' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Theme region within which the block is set.',      ),      'custom' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate how users may control visibility of the block. (0 = Users cannot control, 1 = On by default, but can be hidden, 2 = Hidden by default, but can be shown)',      ),      'throttle' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate whether or not to remove block when website traffic is high. (1 = throttle, 0 = do not throttle)',      ),      'visibility' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate how to show blocks on pages. (0 = Show on all pages except listed pages, 1 = Show only on listed pages, 2 = Use custom PHP code to determine visibility)',      ),      'pages' => array(        'type' => 'text',        'not null' => TRUE,        'description' => 'Contents of the "Pages" block; contains either a list of paths on which to include/exclude the block or PHP code, depending on "visibility" setting.',      ),      'title' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Custom title for the block. (Empty string will use block default title, &lt;none&gt; will remove the title, text will cause block to use specified title.)',      ),      'cache' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 1,        'size' => 'tiny',        'description' => 'Binary flag to indicate block cache mode. (-1: Do not cache, 1: Cache per role, 2: Cache per user, 4: Cache per page, 8: Block cache global) See BLOCK_CACHE_* constants in block.module for more detailed information.',      ),    ),    'primary key' => array('bid'),    'unique keys' => array(      'tmd' => array('theme', 'module', 'delta'),    ),    'indexes' => array(      'list' => array('theme', 'status', 'region', 'weight', 'module'),    ),  );  $schema['blocks_roles'] = array(    'description' => 'Sets up access permissions for blocks based on user roles',    'fields' => array(      'module' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'description' => "The block's origin module, from {blocks}.module.",      ),      'delta'  => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'description' => "The block's unique delta within module, from {blocks}.delta.",      ),      'rid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => "The user's role ID from {users_roles}.rid.",      ),    ),    'primary key' => array(      'module',      'delta',      'rid'    ),    'indexes' => array(      'rid' => array('rid'),    ),  );  $schema['boxes'] = array(    'description' => 'Stores contents of custom-made blocks.',    'fields' => array(      'bid' => array(        'type' => 'serial',  'unsigned' => TRUE,        'not null' => TRUE,        'description' => "The block's {blocks}.bid.",      ),      'body' => array(        'type' => 'text',        'not null' => FALSE,        'size' => 'big',        'description' => 'Block contents.',      ),      'info' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Block description.',      ),      'format' => array(        'type' => 'int',        'size' => 'small',        'not null' => TRUE,        'default' => 0,        'description' => "Block body's {filter_formats}.format; for example, 1 = Filtered HTML.",      )    ),    'unique keys' => array('info' => array('info')),    'primary key' => array('bid'),  );  $schema['cache_block'] = drupal_get_schema_unprocessed('system', 'cache');  $schema['cache_block']['description'] = 'Cache table for the Block module to store already built blocks, identified by module, delta, and various contexts which may change the block, such as theme, locale, and caching mode defined for the block.';  return $schema;}
<?php// $Id$/** * @file * Enable threaded discussions about general topics. *//** * Implementation of hook_help(). */function forum_help($path, $arg) {  switch ($path) {    case 'admin/help#forum':      $output = '<p>'. t('The forum module lets you create threaded discussion forums with functionality similar to other message board systems. Forums are useful because they allow community members to discuss topics with one another while ensuring those conversations are archived for later reference. The <a href="@create-topic">forum topic</a> menu item (under <em>Create content</em> on the Navigation menu) creates the initial post of a new threaded discussion, or thread.', array('@create-topic' => url('node/add/forum'))) .'</p>';      $output .= '<p>'. t('A threaded discussion occurs as people leave comments on a forum topic (or on other comments within that topic). A forum topic is contained within a forum, which may hold many similar or related forum topics. Forums are (optionally) nested within a container, which may hold many similar or related forums. Both containers and forums may be nested within other containers and forums, and provide structure for your message board. By carefully planning this structure, you make it easier for users to find and comment on a specific forum topic.') .'</p>';      $output .= '<p>'. t('When administering a forum, note that:') .'</p>';      $output .= '<ul><li>'. t('a forum topic (and all of its comments) may be moved between forums by selecting a different forum while editing a forum topic.') .'</li>';      $output .= '<li>'. t('when moving a forum topic between forums, the <em>Leave shadow copy</em> option creates a link in the original forum pointing to the new location.') .'</li>';      $output .= '<li>'. t('selecting <em>Read only</em> under <em>Comment settings</em> while editing a forum topic will lock (prevent new comments) on the thread.') .'</li>';      $output .= '<li>'. t('selecting <em>Disabled</em> under <em>Comment settings</em> while editing a forum topic will hide all existing comments on the thread, and prevent new ones.') .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@forum">Forum module</a>.', array('@forum' => 'http://drupal.org/handbook/modules/forum/')) .'</p>';      return $output;    case 'admin/content/forum':      return '<p>'. t('This page displays a list of existing forums and containers. Containers (optionally) hold forums, and forums hold forum topics (a forum topic is the initial post to a threaded discussion). To provide structure, both containers and forums may be placed inside other containers and forums. To rearrange forums and containers, grab a drag-and-drop handle under the <em>Name</em> column and drag the forum or container to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save</em> button at the bottom of the page.') .'</p>';    case 'admin/content/forum/add/container':      return '<p>'. t('By grouping related or similar forums, containers help organize forums. For example, a container named "Food" may hold two forums named "Fruit" and "Vegetables", respectively.') .'</p>';    case 'admin/content/forum/add/forum':      return '<p>'. t('A forum holds related or similar forum topics (a forum topic is the initial post to a threaded discussion). For example, a forum named "Fruit" may contain forum topics titled "Apples" and "Bananas", respectively.') .'</p>';    case 'admin/content/forum/settings':      return '<p>'. t('These settings allow you to adjust the display of your forum topics. The content types available for use within a forum may be selected by editing the <em>Content types</em> on the <a href="@forum-vocabulary">forum vocabulary page</a>.', array('@forum-vocabulary' => url('admin/content/taxonomy/edit/vocabulary/'. variable_get('forum_nav_vocabulary', '')))) .'</p>';  }}/** * Implementation of hook_theme() */function forum_theme() {  return array(    'forums' => array(      'template' => 'forums',      'arguments' => array('forums' => NULL, 'topics' => NULL, 'parents' => NULL, 'tid' => NULL, 'sortby' => NULL, 'forum_per_page' => NULL),    ),    'forum_list' => array(      'template' => 'forum-list',      'arguments' => array('forums' => NULL, 'parents' => NULL, 'tid' => NULL),    ),    'forum_topic_list' => array(      'template' => 'forum-topic-list',      'arguments' => array('tid' => NULL, 'topics' => NULL, 'sortby' => NULL, 'forum_per_page' => NULL),    ),    'forum_icon' => array(      'template' => 'forum-icon',      'arguments' => array('new_posts' => NULL, 'num_posts' => 0, 'comment_mode' => 0, 'sticky' => 0),    ),    'forum_topic_navigation' => array(      'template' => 'forum-topic-navigation',      'arguments' => array('node' => NULL),    ),    'forum_submitted' => array(      'template' => 'forum-submitted',      'arguments' => array('topic' => NULL),    ),  );}/** * Fetch a forum term. * * @param $tid *   The ID of the term which should be loaded. * * @return *   An associative array containing the term data or FALSE if the term cannot be loaded, or is not part of the forum vocabulary. */function forum_term_load($tid) {  $result = db_query(db_rewrite_sql('SELECT t.tid, t.vid, t.name, t.description, t.weight FROM {term_data} t WHERE t.tid = %d AND t.vid = %d', 't', 'tid'), $tid, variable_get('forum_nav_vocabulary', ''));  return db_fetch_array($result);}/** * Implementation of hook_menu(). */function forum_menu() {  $items['forum'] = array(    'title' => 'Forums',    'page callback' => 'forum_page',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'forum.pages.inc',  );  $items['admin/content/forum'] = array(    'title' => 'Forums',    'description' => 'Control forums and their hierarchy and change forum settings.',    'page callback' => 'drupal_get_form',    'page arguments' => array('forum_overview'),    'access arguments' => array('administer forums'),    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/forum/add/container'] = array(    'title' => 'Add container',    'page callback' => 'forum_form_main',    'page arguments' => array('container'),    'access arguments' => array('administer forums'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/add/forum'] = array(    'title' => 'Add forum',    'page callback' => 'forum_form_main',    'page arguments' => array('forum'),    'access arguments' => array('administer forums'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('forum_admin_settings'),    'access arguments' => array('administer forums'),    'weight' => 5,    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/%forum_term'] = array(    'page callback' => 'forum_form_main',    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/container/%forum_term'] = array(    'title' => 'Edit container',    'page callback' => 'forum_form_main',    'page arguments' => array('container', 5),    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/forum/%forum_term'] = array(    'title' => 'Edit forum',    'page callback' => 'forum_form_main',    'page arguments' => array('forum', 5),    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  return $items;}/** * Implementation of hook_init(). */function forum_init() {  drupal_add_css(drupal_get_path('module', 'forum') .'/forum.css');}/** * Implementation of hook_nodeapi(). */function forum_nodeapi(&$node, $op, $teaser, $page) {  // We are going to return if $node->type is not one of the node  // types assigned to the forum vocabulary.  If forum_nav_vocabulary  // is undefined or the vocabulary does not exist, it clearly cannot  // be assigned to $node->type, so return to avoid E_ALL warnings.  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  if (empty($vocabulary)) {    return;  }  // Operate only on node types assigned for the forum vocabulary.  if (!in_array($node->type, $vocabulary->nodes)) {    return;  }  switch ($op) {    case 'view':      if ($page && taxonomy_node_get_terms_by_vocabulary($node, $vid) && $tree = taxonomy_get_tree($vid)) {        // Get the forum terms from the (cached) tree        foreach ($tree as $term) {          $forum_terms[] = $term->tid;        }        foreach ($node->taxonomy as $term_id => $term) {          if (in_array($term_id, $forum_terms)) {            $node->tid = $term_id;          }        }        // Breadcrumb navigation        $breadcrumb[] = l(t('Home'), NULL);        $breadcrumb[] = l($vocabulary->name, 'forum');        if ($parents = taxonomy_get_parents_all($node->tid)) {          $parents = array_reverse($parents);          foreach ($parents as $p) {            $breadcrumb[] = l($p->name, 'forum/'. $p->tid);          }        }        drupal_set_breadcrumb($breadcrumb);        if (!$teaser) {          $node->content['forum_navigation'] = array(            '#value' => theme('forum_topic_navigation', $node),            '#weight' => 100,          );        }      }      break;    case 'prepare':      if (empty($node->nid)) {        // New topic        $node->taxonomy[arg(3)]->vid = $vid;        $node->taxonomy[arg(3)]->tid = arg(3);      }      break;    // Check in particular that only a "leaf" term in the associated taxonomy    // vocabulary is selected, not a "container" term.    case 'validate':      if ($node->taxonomy) {        // Extract the node's proper topic ID.        $vocabulary = $vid;        $containers = variable_get('forum_containers', array());        foreach ($node->taxonomy as $term) {          if (db_result(db_query('SELECT COUNT(*) FROM {term_data} WHERE tid = %d AND vid = %d', $term, $vocabulary))) {            if (in_array($term, $containers)) {              $term = taxonomy_get_term($term);              form_set_error('taxonomy', t('The item %forum is only a container for forums. Please select one of the forums below it.', array('%forum' => $term->name)));            }          }        }      }      break;    // Assign forum taxonomy when adding a topic from within a forum.    case 'presave':      // Make sure all fields are set properly:      $node->icon = !empty($node->icon) ? $node->icon : '';      if ($node->taxonomy && $tree = taxonomy_get_tree($vid)) {        // Get the forum terms from the (cached) tree if we have a taxonomy.        foreach ($tree as $term) {          $forum_terms[] = $term->tid;        }        foreach ($node->taxonomy as $term_id) {          if (in_array($term_id, $forum_terms)) {            $node->tid = $term_id;          }        }        $old_tid = db_result(db_query_range("SELECT t.tid FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.nid = %d ORDER BY t.vid DESC", $node->nid, 0, 1));        if ($old_tid && isset($node->tid) && ($node->tid != $old_tid) && !empty($node->shadow)) {          // A shadow copy needs to be created. Retain new term and add old term.          $node->taxonomy[] = $old_tid;        }      }      break;    case 'update':      if (empty($node->revision) && db_result(db_query('SELECT tid FROM {forum} WHERE nid=%d', $node->nid))) {        if (!empty($node->tid)) {          db_query('UPDATE {forum} SET tid = %d WHERE vid = %d', $node->tid, $node->vid);        }        // The node is removed from the forum.        else {          db_query('DELETE FROM {forum} WHERE nid = %d', $node->nid);        }        break;      }      // Deliberate no break -- for new revisions and for previously unassigned terms we need an insert.    case 'insert':      if (!empty($node->tid)) {        db_query('INSERT INTO {forum} (tid, vid, nid) VALUES (%d, %d, %d)', $node->tid, $node->vid, $node->nid);      }      break;    case 'delete':      db_query('DELETE FROM {forum} WHERE nid = %d', $node->nid);      break;    case 'load':      return db_fetch_array(db_query('SELECT tid AS forum_tid FROM {forum} WHERE vid = %d', $node->vid));  }  return;}/** * Implementation of hook_node_info(). */function forum_node_info() {  return array(    'forum' => array(      'name' => t('Forum topic'),      'module' => 'forum',      'description' => t('A <em>forum topic</em> is the initial post to a new discussion thread within a forum.'),      'title_label' => t('Subject'),    )  );}/** * Implementation of hook_access(). */function forum_access($op, $node, $account) {  switch ($op) {    case 'create':      return user_access('create forum topics', $account) ? TRUE : NULL;    case 'update':      return user_access('edit any forum topic', $account) || (user_access('edit own forum topics', $account) && ($account->uid == $node->uid)) ? TRUE : NULL;    case 'delete':      return user_access('delete any forum topic', $account) || (user_access('delete own forum topics', $account) && ($account->uid == $node->uid)) ? TRUE : NULL;  }}/** * Implementation of hook_perm(). */function forum_perm() {  return array('create forum topics', 'delete own forum topics', 'delete any forum topic', 'edit own forum topics', 'edit any forum topic', 'administer forums');}/** * Implementation of hook_taxonomy(). */function forum_taxonomy($op, $type, $term = NULL) {  if ($op == 'delete' && $term['vid'] == variable_get('forum_nav_vocabulary', '')) {    switch ($type) {      case 'term':        $results = db_query('SELECT tn.nid FROM {term_node} tn WHERE tn.tid = %d', $term['tid']);        while ($node = db_fetch_object($results)) {          // node_delete will also remove any association with non-forum vocabularies.          node_delete($node->nid);        }        // For containers, remove the tid from the forum_containers variable.        $containers = variable_get('forum_containers', array());        $key = array_search($term['tid'], $containers);        if ($key !== FALSE) {          unset($containers[$key]);        }        variable_set('forum_containers', $containers);        break;      case 'vocabulary':        variable_del('forum_nav_vocabulary');    }  }}/** * Implementation of hook_form_alter(). */function forum_form_alter(&$form, $form_state, $form_id) {  $vid = variable_get('forum_nav_vocabulary', '');  if (isset($form['vid']) && $form['vid']['#value'] == $vid) {    // Hide critical options from forum vocabulary.    if ($form_id == 'taxonomy_form_vocabulary') {      $form['help_forum_vocab'] = array(        '#value' => t('This is the designated forum vocabulary. Some of the normal vocabulary options have been removed.'),        '#weight' => -1,      );      $form['content_types']['nodes']['#required'] = TRUE;      $form['hierarchy'] = array('#type' => 'value', '#value' => 1);      $form['settings']['required'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['relations'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['tags'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['multiple'] = array('#type' => 'value', '#value' => FALSE);      unset($form['delete']);    }    // Hide multiple parents select from forum terms.    elseif ($form_id == 'taxonomy_form_term') {      $form['advanced']['parent']['#access'] = FALSE;    }  }  if ($form_id == 'forum_node_form') {    // Make the vocabulary required for 'real' forum-nodes.    $vid = variable_get('forum_nav_vocabulary', '');    $form['taxonomy'][$vid]['#required'] = TRUE;    $form['taxonomy'][$vid]['#options'][''] = t('- Please choose -');  }}/** * Implementation of hook_load(). */function forum_load($node) {  $forum = db_fetch_object(db_query('SELECT * FROM {forum} WHERE vid = %d', $node->vid));  return $forum;}/** * Implementation of hook_block(). * * Generates a block containing the currently active forum topics and the * most recently added forum topics. */function forum_block($op = 'list', $delta = 0, $edit = array()) {  switch ($op) {    case 'list':      $blocks[0]['info'] = t('Active forum topics');      $blocks[1]['info'] = t('New forum topics');      return $blocks;    case 'configure':      $form['forum_block_num_'. $delta] = array('#type' => 'select', '#title' => t('Number of topics'), '#default_value' => variable_get('forum_block_num_'. $delta, '5'), '#options' => drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)));      return $form;    case 'save':      variable_set('forum_block_num_'. $delta, $edit['forum_block_num_'. $delta]);      break;    case 'view':      if (user_access('access content')) {        switch ($delta) {          case 0:            $title = t('Active forum topics');            $sql = db_rewrite_sql("SELECT n.nid, n.title, l.comment_count, l.last_comment_timestamp FROM {node} n INNER JOIN {term_node} tn ON tn.vid = n.vid INNER JOIN {term_data} td ON td.tid = tn.tid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 AND td.vid = %d ORDER BY l.last_comment_timestamp DESC");            $result = db_query_range($sql, variable_get('forum_nav_vocabulary', ''), 0, variable_get('forum_block_num_0', '5'));            $content = node_title_list($result);            break;          case 1:            $title = t('New forum topics');            $sql = db_rewrite_sql("SELECT n.nid, n.title, l.comment_count FROM {node} n INNER JOIN {term_node} tn ON tn.vid = n.vid INNER JOIN {term_data} td ON td.tid = tn.tid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 AND td.vid = %d ORDER BY n.nid DESC");            $result = db_query_range($sql, variable_get('forum_nav_vocabulary', ''), 0, variable_get('forum_block_num_1', '5'));            $content = node_title_list($result);            break;        }        if (!empty($content)) {          $block['subject'] = $title;          $block['content'] = $content . theme('more_link', url('forum'), t('Read the latest forum topics.'));          return $block;        }      }  }}/** * Implementation of hook_form(). */function forum_form(&$node, $form_state) {  $type = node_get_types('type', $node);  $form['title'] = array('#type' => 'textfield', '#title' => check_plain($type->title_label), '#default_value' => !empty($node->title) ? $node->title : '', '#required' => TRUE, '#weight' => -5);  if (!empty($node->nid)) {    $vid = variable_get('forum_nav_vocabulary', '');    $forum_terms = taxonomy_node_get_terms_by_vocabulary($node, $vid);    // if editing, give option to leave shadows    $shadow = (count($forum_terms) > 1);    $form['shadow'] = array('#type' => 'checkbox', '#title' => t('Leave shadow copy'), '#default_value' => $shadow, '#description' => t('If you move this topic, you can leave a link in the old forum to the new forum.'));  }  $form['body_field'] = node_body_field($node, $type->body_label, 1);  $form['#submit'][] = 'forum_submit';  // Assign the forum topic submit handler.  return $form;}/** * Implementation of hook_term_path(). */function forum_term_path($term) {  return 'forum/'. $term->tid;}/** * Returns a list of all forums for a given taxonomy id * * Forum objects contain the following fields * -num_topics Number of topics in the forum * -num_posts Total number of posts in all topics * -last_post Most recent post for the forum * * @param $tid *   Taxonomy ID of the vocabulary that holds the forum list. * @return *   Array of object containing the forum information. */function forum_get_forums($tid = 0) {  $forums = array();  $vid = variable_get('forum_nav_vocabulary', '');  $_forums = taxonomy_get_tree($vid, $tid);  if (count($_forums)) {    $counts = array();    $sql = "SELECT r.tid, COUNT(n.nid) AS topic_count, SUM(l.comment_count) AS comment_count FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {term_node} r ON n.vid = r.vid WHERE n.status = 1 GROUP BY r.tid";    $sql = db_rewrite_sql($sql);    $_counts = db_query($sql);    while ($count = db_fetch_object($_counts)) {      $counts[$count->tid] = $count;    }  }  foreach ($_forums as $forum) {    if (in_array($forum->tid, variable_get('forum_containers', array()))) {      $forum->container = 1;    }    if (!empty($counts[$forum->tid])) {      $forum->num_topics = $counts[$forum->tid]->topic_count;      $forum->num_posts = $counts[$forum->tid]->topic_count + $counts[$forum->tid]->comment_count;    }    else {      $forum->num_topics = 0;      $forum->num_posts = 0;    }    // This query does not use full ANSI syntax since MySQL 3.x does not support    // table1 INNER JOIN table2 INNER JOIN table3 ON table2_criteria ON table3_criteria    // used to join node_comment_statistics to users.    $sql = "SELECT ncs.last_comment_timestamp, IF (ncs.last_comment_uid != 0, u2.name, ncs.last_comment_name) AS last_comment_name, ncs.last_comment_uid FROM {node} n INNER JOIN {users} u1 ON n.uid = u1.uid INNER JOIN {term_node} tn ON n.vid = tn.vid INNER JOIN {node_comment_statistics} ncs ON n.nid = ncs.nid INNER JOIN {users} u2 ON ncs.last_comment_uid=u2.uid WHERE n.status = 1 AND tn.tid = %d ORDER BY ncs.last_comment_timestamp DESC";    $sql = db_rewrite_sql($sql);    $topic = db_fetch_object(db_query_range($sql, $forum->tid, 0, 1));    $last_post = new stdClass();    if (!empty($topic->last_comment_timestamp)) {      $last_post->timestamp = $topic->last_comment_timestamp;      $last_post->name = $topic->last_comment_name;      $last_post->uid = $topic->last_comment_uid;    }    $forum->last_post = $last_post;    $forums[$forum->tid] = $forum;  }  return $forums;}/** * Calculate the number of nodes the user has not yet read and are newer * than NODE_NEW_LIMIT. */function _forum_topics_unread($term, $uid) {  $sql = "SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid AND tn.tid = %d LEFT JOIN {history} h ON n.nid = h.nid AND h.uid = %d WHERE n.status = 1 AND n.created > %d AND h.nid IS NULL";  $sql = db_rewrite_sql($sql);  return db_result(db_query($sql, $term, $uid, NODE_NEW_LIMIT));}function forum_get_topics($tid, $sortby, $forum_per_page) {  global $user, $forum_topic_list_header;  $forum_topic_list_header = array(    NULL,    array('data' => t('Topic'), 'field' => 'n.title'),    array('data' => t('Replies'), 'field' => 'l.comment_count'),    array('data' => t('Created'), 'field' => 'n.created'),    array('data' => t('Last reply'), 'field' => 'l.last_comment_timestamp'),  );  $order = _forum_get_topic_order($sortby);  for ($i = 0; $i < count($forum_topic_list_header); $i++) {    if ($forum_topic_list_header[$i]['field'] == $order['field']) {      $forum_topic_list_header[$i]['sort'] = $order['sort'];    }  }  $term = taxonomy_get_term($tid);  $sql = db_rewrite_sql("SELECT n.nid, r.tid, n.title, n.type, n.sticky, u.name, u.uid, n.created AS timestamp, n.comment AS comment_mode, l.last_comment_timestamp, IF(l.last_comment_uid != 0, cu.name, l.last_comment_name) AS last_comment_name, l.last_comment_uid, l.comment_count AS num_comments, f.tid AS forum_tid FROM {node_comment_statistics} l INNER JOIN {node} n ON n.nid = l.nid INNER JOIN {users} cu ON l.last_comment_uid = cu.uid INNER JOIN {term_node} r ON n.vid = r.vid INNER JOIN {users} u ON n.uid = u.uid INNER JOIN {forum} f ON n.vid = f.vid WHERE n.status = 1 AND r.tid = %d");  $sql .= tablesort_sql($forum_topic_list_header, 'n.sticky DESC,');  $sql .= ', n.created DESC';  // Always add a secondary sort order so that the news forum topics are on top.  $sql_count = db_rewrite_sql("SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} r ON n.vid = r.vid AND r.tid = %d WHERE n.status = 1");  $result = pager_query($sql, $forum_per_page, 0, $sql_count, $tid);  $topics = array();  while ($topic = db_fetch_object($result)) {    if ($user->uid) {      // folder is new if topic is new or there are new comments since last visit      if ($topic->tid != $tid) {        $topic->new = 0;      }      else {        $history = _forum_user_last_visit($topic->nid);        $topic->new_replies = comment_num_new($topic->nid, $history);        $topic->new = $topic->new_replies || ($topic->timestamp > $history);      }    }    else {      // Do not track "new replies" status for topics if the user is anonymous.      $topic->new_replies = 0;      $topic->new = 0;    }    if ($topic->num_comments > 0) {      $last_reply = new stdClass();      $last_reply->timestamp = $topic->last_comment_timestamp;      $last_reply->name = $topic->last_comment_name;      $last_reply->uid = $topic->last_comment_uid;      $topic->last_reply = $last_reply;    }    $topics[] = $topic;  }  return $topics;}/** * Finds the first unread node for a given forum. */function _forum_new($tid) {  global $user;  $sql = "SELECT n.nid FROM {node} n LEFT JOIN {history} h ON n.nid = h.nid AND h.uid = %d INNER JOIN {term_node} r ON n.nid = r.nid AND r.tid = %d WHERE n.status = 1 AND h.nid IS NULL AND n.created > %d ORDER BY created";  $sql = db_rewrite_sql($sql);  $nid = db_result(db_query_range($sql, $user->uid, $tid, NODE_NEW_LIMIT, 0, 1));  return $nid ? $nid : 0;}/** * Process variables for forums.tpl.php * * The $variables array contains the following arguments: * - $forums * - $topics * - $parents * - $tid * - $sortby * - $forum_per_page * * @see forums.tpl.php */function template_preprocess_forums(&$variables) {  global $user;  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  $title = !empty($vocabulary->name) ? $vocabulary->name : '';  // Breadcrumb navigation:  $breadcrumb[] = l(t('Home'), NULL);  if ($variables['tid']) {    $breadcrumb[] = l($vocabulary->name, 'forum');  }  if ($variables['parents']) {    $variables['parents'] = array_reverse($variables['parents']);    foreach ($variables['parents'] as $p) {      if ($p->tid == $variables['tid']) {        $title = $p->name;      }      else {        $breadcrumb[] = l($p->name, 'forum/'. $p->tid);      }    }  }  drupal_set_breadcrumb($breadcrumb);  drupal_set_title(check_plain($title));  if ($variables['forums_defined'] = count($variables['forums']) || count($variables['parents'])) {    // Format the "post new content" links listing.    $forum_types = array();    // Loop through all node types for forum vocabulary.    foreach ($vocabulary->nodes as $type) {      // Check if the current user has the 'create' permission for this node type.      if (node_access('create', $type)) {        // Fetch the "General" name of the content type;        // Push the link with title and url to the array.        $forum_types[$type] = array('title' => t('Post new @node_type', array('@node_type' => node_get_types('name', $type))), 'href' => 'node/add/'. str_replace('_', '-', $type) .'/'. $variables['tid']);      }    }    if (empty($forum_types)) {      // The user is logged-in; but denied access to create any new forum content type.      if ($user->uid) {        $forum_types['disallowed'] = array('title' => t('You are not allowed to post new content in the forum.'));      }      // The user is not logged-in; and denied access to create any new forum content type.      else {        $forum_types['login'] = array('title' => t('<a href="@login">Login</a> to post new content in the forum.', array('@login' => url('user/login', array('query' => drupal_get_destination())))), 'html' => TRUE);      }    }    $variables['links'] = $forum_types;    if (!empty($variables['forums'])) {      $variables['forums'] = theme('forum_list', $variables['forums'], $variables['parents'], $variables['tid']);    }    else {      $variables['forums'] = '';    }    if ($variables['tid'] && !in_array($variables['tid'], variable_get('forum_containers', array()))) {      $variables['topics'] = theme('forum_topic_list', $variables['tid'], $variables['topics'], $variables['sortby'], $variables['forum_per_page']);      drupal_add_feed(url('taxonomy/term/'. $variables['tid'] .'/0/feed'), 'RSS - '. $title);    }    else {      $variables['topics'] = '';    }    // Provide separate template suggestions based on what's being output. Topic id is also accounted for.    // Check both variables to be safe then the inverse. Forums with topic ID's take precedence.    if ($variables['forums'] && !$variables['topics']) {      $variables['template_files'][] = 'forums-containers';      $variables['template_files'][] = 'forums-'. $variables['tid'];      $variables['template_files'][] = 'forums-containers-'. $variables['tid'];    }    elseif (!$variables['forums'] && $variables['topics']) {      $variables['template_files'][] = 'forums-topics';      $variables['template_files'][] = 'forums-'. $variables['tid'];      $variables['template_files'][] = 'forums-topics-'. $variables['tid'];    }    else {      $variables['template_files'][] = 'forums-'. $variables['tid'];    }  }  else {    drupal_set_title(t('No forums defined'));    $variables['links'] = array();    $variables['forums'] = '';    $variables['topics'] = '';  }}/** * Process variables to format a forum listing. * * $variables contains the following information: * - $forums * - $parents * - $tid * * @see forum-list.tpl.php * @see theme_forum_list() */function template_preprocess_forum_list(&$variables) {  global $user;  $row = 0;  // Sanitize each forum so that the template can safely print the data.  foreach ($variables['forums'] as $id => $forum) {    $variables['forums'][$id]->description = !empty($forum->description) ? filter_xss_admin($forum->description) : '';    $variables['forums'][$id]->link = url("forum/$forum->tid");    $variables['forums'][$id]->name = check_plain($forum->name);    $variables['forums'][$id]->is_container = !empty($forum->container);    $variables['forums'][$id]->zebra = $row % 2 == 0 ? 'odd' : 'even';    $row++;    $variables['forums'][$id]->new_text = '';    $variables['forums'][$id]->new_url = '';    $variables['forums'][$id]->new_topics = 0;    $variables['forums'][$id]->old_topics = $forum->num_topics;    if ($user->uid) {      $variables['forums'][$id]->new_topics = _forum_topics_unread($forum->tid, $user->uid);      if ($variables['forums'][$id]->new_topics) {        $variables['forums'][$id]->new_text = format_plural($variables['forums'][$id]->new_topics, '1 new', '@count new');        $variables['forums'][$id]->new_url = url("forum/$forum->tid", array('fragment' => 'new'));      }      $variables['forums'][$id]->old_topics = $forum->num_topics - $variables['forums'][$id]->new_topics;    }    $variables['forums'][$id]->last_reply = theme('forum_submitted', $forum->last_post);  }  // Give meaning to $tid for themers. $tid actually stands for term id.  $variables['forum_id'] = $variables['tid'];  unset($variables['tid']);}/** * Preprocess variables to format the topic listing. * * $variables contains the following data: * - $tid * - $topics * - $sortby * - $forum_per_page * * @see forum-topic-list.tpl.php * @see theme_forum_topic_list() */function template_preprocess_forum_topic_list(&$variables) {  global $forum_topic_list_header;  // Create the tablesorting header.  $ts = tablesort_init($forum_topic_list_header);  $header = '';  foreach ($forum_topic_list_header as $cell) {    $cell = tablesort_header($cell, $forum_topic_list_header, $ts);    $header .= _theme_table_cell($cell, TRUE);  }  $variables['header'] = $header;  if (!empty($variables['topics'])) {    $row = 0;    foreach ($variables['topics'] as $id => $topic) {      $variables['topics'][$id]->icon = theme('forum_icon', $topic->new, $topic->num_comments, $topic->comment_mode, $topic->sticky);      $variables['topics'][$id]->zebra = $row % 2 == 0 ? 'odd' : 'even';      $row++;      // We keep the actual tid in forum table, if it's different from the      // current tid then it means the topic appears in two forums, one of      // them is a shadow copy.      if ($topic->forum_tid != $variables['tid']) {        $variables['topics'][$id]->moved = TRUE;        $variables['topics'][$id]->title = check_plain($topic->title);        $variables['topics'][$id]->message = l(t('This topic has been moved'), "forum/$topic->forum_tid");      }      else {        $variables['topics'][$id]->moved = FALSE;        $variables['topics'][$id]->title = l($topic->title, "node/$topic->nid");        $variables['topics'][$id]->message = '';      }      $variables['topics'][$id]->created = theme('forum_submitted', $topic);      $variables['topics'][$id]->last_reply = theme('forum_submitted', isset($topic->last_reply) ? $topic->last_reply : NULL);      $variables['topics'][$id]->new_text = '';      $variables['topics'][$id]->new_url = '';      if ($topic->new_replies) {        $variables['topics'][$id]->new_text = format_plural($topic->new_replies, '1 new', '@count new');        $variables['topics'][$id]->new_url = url("node/$topic->nid", array('query' => comment_new_page_count($topic->num_comments, $topic->new_replies, $topic), 'fragment' => 'new'));      }    }  }  else {    // Make this safe for the template    $variables['topics'] = array();  }  // Give meaning to $tid for themers. $tid actually stands for term id.  $variables['topic_id'] = $variables['tid'];  unset($variables['tid']);  $variables['pager'] = theme('pager', NULL, $variables['forum_per_page'], 0);}/** * Process variables to format the icon for each individual topic. * * $variables contains the following data: * - $new_posts * - $num_posts = 0 * - $comment_mode = 0 * - $sticky = 0 * * @see forum-icon.tpl.php * @see theme_forum_icon() */function template_preprocess_forum_icon(&$variables) {  $variables['hot_threshold'] = variable_get('forum_hot_topic', 15);  if ($variables['num_posts'] > $variables['hot_threshold']) {    $variables['icon'] = $variables['new_posts'] ? 'hot-new' : 'hot';  }  else {    $variables['icon'] = $variables['new_posts'] ? 'new' : 'default';  }  if ($variables['comment_mode'] == COMMENT_NODE_READ_ONLY || $variables['comment_mode'] == COMMENT_NODE_DISABLED) {    $variables['icon'] = 'closed';  }  if ($variables['sticky'] == 1) {    $variables['icon'] = 'sticky';  }}/** * Preprocess variables to format the next/previous forum topic navigation links. * * $variables contains $node. * * @see forum-topic-navigation.tpl.php * @see theme_forum_topic_navigation() */function template_preprocess_forum_topic_navigation(&$variables) {  $output = '';  // get previous and next topic  $sql = "SELECT n.nid, n.title, n.sticky, l.comment_count, l.last_comment_timestamp FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {term_node} r ON n.nid = r.nid AND r.tid = %d WHERE n.status = 1 ORDER BY n.sticky DESC, ". _forum_get_topic_order_sql(variable_get('forum_order', 1));  $result = db_query(db_rewrite_sql($sql), isset($variables['node']->tid) ? $variables['node']->tid : 0);  $stop = $variables['prev'] = $variables['next'] = 0;  while ($topic = db_fetch_object($result)) {    if ($stop == 1) {      $variables['next'] = $topic->nid;      $variables['next_title'] = check_plain($topic->title);      $variables['next_url'] = url("node/$topic->nid");      break;    }    if ($topic->nid == $variables['node']->nid) {      $stop = 1;    }    else {      $variables['prev'] = $topic->nid;      $variables['prev_title'] = check_plain($topic->title);      $variables['prev_url'] = url("node/$topic->nid");    }  }}/** * Process variables to format submission info for display in the forum list and topic list. * * $variables will contain: $topic * * @see forum-submitted.tpl.php * @see theme_forum_submitted() */function template_preprocess_forum_submitted(&$variables) {  $variables['author'] = isset($variables['topic']->uid) ? theme('username', $variables['topic']) : '';  $variables['time'] = isset($variables['topic']->timestamp) ? format_interval(time() - $variables['topic']->timestamp) : '';}function _forum_user_last_visit($nid) {  global $user;  static $history = array();  if (empty($history)) {    $result = db_query('SELECT nid, timestamp FROM {history} WHERE uid = %d', $user->uid);    while ($t = db_fetch_object($result)) {      $history[$t->nid] = $t->timestamp > NODE_NEW_LIMIT ? $t->timestamp : NODE_NEW_LIMIT;    }  }  return isset($history[$nid]) ? $history[$nid] : NODE_NEW_LIMIT;}function _forum_get_topic_order($sortby) {  switch ($sortby) {    case 1:      return array('field' => 'l.last_comment_timestamp', 'sort' => 'desc');      break;    case 2:      return array('field' => 'l.last_comment_timestamp', 'sort' => 'asc');      break;    case 3:      return array('field' => 'l.comment_count', 'sort' => 'desc');      break;    case 4:      return array('field' => 'l.comment_count', 'sort' => 'asc');      break;  }}function _forum_get_topic_order_sql($sortby) {  $order = _forum_get_topic_order($sortby);  return $order['field'] .' '. strtoupper($order['sort']);}
<?php// $Id$/** * @file * OpenID utility functions. */// Diffie-Hellman Key Exchange Default Value.define('OPENID_DH_DEFAULT_MOD', '155172898181473697471232257763715539915724801'.       '966915404479707795314057629378541917580651227423698188993727816152646631'.       '438561595825688188889951272158842675419950341258706556549803580104870537'.       '681476726513255747040765857479291291572334510643245094715007229621094194'.       '349783925984760375594985848253359305585439638443');// Constants for Diffie-Hellman key exchange computations.define('OPENID_DH_DEFAULT_GEN', '2');define('OPENID_SHA1_BLOCKSIZE', 64);define('OPENID_RAND_SOURCE', '/dev/urandom');// OpenID namespace URLsdefine('OPENID_NS_2_0', 'http://specs.openid.net/auth/2.0');define('OPENID_NS_1_1', 'http://openid.net/signon/1.1');define('OPENID_NS_1_0', 'http://openid.net/signon/1.0');/** * Performs an HTTP 302 redirect (for the 1.x protocol). */function openid_redirect_http($url, $message) {  $query = array();  foreach ($message as $key => $val) {    $query[] = $key .'='. urlencode($val);  }  $sep = (strpos($url, '?') === FALSE) ? '?' : '&';  header('Location: '. $url . $sep . implode('&', $query), TRUE, 302);  exit;}/** * Creates a js auto-submit redirect for (for the 2.x protocol) */function openid_redirect($url, $message) {  $output = '<html><head><title>'. t('OpenID redirect') ."</title></head>\n<body>";  $output .= drupal_get_form('openid_redirect_form', $url, $message);  $output .= '<script type="text/javascript">document.getElementById("openid-redirect-form").submit();</script>';  $output .= "</body></html>\n";  print $output;  exit;}function openid_redirect_form(&$form_state, $url, $message) {  $form = array();  $form['#action'] = $url;  $form['#method'] = "post";  foreach ($message as $key => $value) {    $form[$key] = array(      '#type' => 'hidden',      '#name' => $key,      '#value' => $value,    );  }  $form['submit'] = array(    '#type' => 'submit',    '#prefix' => '<noscript>',    '#suffix' => '</noscript>',    '#value' => t('Send'),  );  return $form;}/** * Determine if the given identifier is an XRI ID. */function _openid_is_xri($identifier) {  // Strip the xri:// scheme from the identifier if present.  if (strpos(strtolower($identifier), 'xri://') !== FALSE) {    $identifier = substr($identifier, 6);  }  // Test whether the identifier starts with an XRI global context symbol or (.  $firstchar = substr($identifier, 0, 1);  if (strpos("=@+$!(", $firstchar) !== FALSE) {    return TRUE;  }  return FALSE;}/** * Normalize the given identifier as per spec. */function _openid_normalize($identifier) {  if (_openid_is_xri($identifier)) {    return _openid_normalize_xri($identifier);  }  else {    return _openid_normalize_url($identifier);  }}function _openid_normalize_xri($xri) {  $normalized_xri = $xri;  if (stristr($xri, 'xri://') !== FALSE) {    $normalized_xri = substr($xri, 6);  }  return $normalized_xri;}function _openid_normalize_url($url) {  $normalized_url = $url;  if (stristr($url, '://') === FALSE) {    $normalized_url = 'http://'. $url;  }  // Strip the fragment and fragment delimiter if present.  $normalized_url = strtok($normalized_url, '#');  if (substr_count($normalized_url, '/') < 3) {    $normalized_url .= '/';  }  return $normalized_url;}/** * Create a serialized message packet as per spec: $key:$value\n . */function _openid_create_message($data) {  $serialized = '';  foreach ($data as $key => $value) {    if ((strpos($key, ':') !== FALSE) || (strpos($key, "\n") !== FALSE) || (strpos($value, "\n") !== FALSE)) {      return null;    }    $serialized .= "$key:$value\n";  }  return $serialized;}/** * Encode a message from _openid_create_message for HTTP Post */function _openid_encode_message($message) {  $encoded_message = '';  $items = explode("\n", $message);  foreach ($items as $item) {    $parts = explode(':', $item, 2);    if (count($parts) == 2) {      if ($encoded_message != '') {        $encoded_message .= '&';      }      $encoded_message .= rawurlencode(trim($parts[0])) .'='. rawurlencode(trim($parts[1]));    }  }  return $encoded_message;}/** * Convert a direct communication message * into an associative array. */function _openid_parse_message($message) {  $parsed_message = array();  $items = explode("\n", $message);  foreach ($items as $item) {    $parts = explode(':', $item, 2);    if (count($parts) == 2) {      $parsed_message[$parts[0]] = $parts[1];    }  }  return $parsed_message;}/** * Return a nonce value - formatted per OpenID spec. */function _openid_nonce() {  // YYYY-MM-DDThh:mm:ssTZD UTC, plus some optional extra unique chars  return gmstrftime('%Y-%m-%dT%H:%M:%S%Z') .    chr(mt_rand(0, 25) + 65) .    chr(mt_rand(0, 25) + 65) .    chr(mt_rand(0, 25) + 65) .    chr(mt_rand(0, 25) + 65);}/** * Pull the href attribute out of an html link element. */function _openid_link_href($rel, $html) {  $rel = preg_quote($rel);  preg_match('|<link\s+rel=["\'](.*)'. $rel .'(.*)["\'](.*)/?>|iUs', $html, $matches);  if (isset($matches[3])) {    preg_match('|href=["\']([^"]+)["\']|iU', $matches[3], $href);    return trim($href[1]);  }  return FALSE;}/** * Pull the http-equiv attribute out of an html meta element */function _openid_meta_httpequiv($equiv, $html) {  preg_match('|<meta\s+http-equiv=["\']'. $equiv .'["\'](.*)/?>|iUs', $html, $matches);  if (isset($matches[1])) {    preg_match('|content=["\']([^"]+)["\']|iUs', $matches[1], $content);    if (isset($content[1])) {      return $content[1];    }  }  return FALSE;}/** * Sign certain keys in a message * @param $association - object loaded from openid_association or openid_server_association table *              - important fields are ->assoc_type and ->mac_key * @param $message_array - array of entire message about to be sent * @param $keys_to_sign - keys in the message to include in signature (without *  'openid.' appended) */function _openid_signature($association, $message_array, $keys_to_sign) {  $signature = '';  $sign_data = array();  foreach ($keys_to_sign as $key) {    if (isset($message_array['openid.'. $key])) {      $sign_data[$key] = $message_array['openid.'. $key];    }  }  $message = _openid_create_message($sign_data);  $secret = base64_decode($association->mac_key);  $signature = _openid_hmac($secret, $message);  return base64_encode($signature);}function _openid_hmac($key, $text) {  if (strlen($key) > OPENID_SHA1_BLOCKSIZE) {    $key = _openid_sha1($key, true);  }  $key = str_pad($key, OPENID_SHA1_BLOCKSIZE, chr(0x00));  $ipad = str_repeat(chr(0x36), OPENID_SHA1_BLOCKSIZE);  $opad = str_repeat(chr(0x5c), OPENID_SHA1_BLOCKSIZE);  $hash1 = _openid_sha1(($key ^ $ipad) . $text, true);  $hmac = _openid_sha1(($key ^ $opad) . $hash1, true);  return $hmac;}function _openid_sha1($text) {  $hex = sha1($text);  $raw = '';  for ($i = 0; $i < 40; $i += 2) {    $hexcode = substr($hex, $i, 2);    $charcode = (int)base_convert($hexcode, 16, 10);    $raw .= chr($charcode);  }  return $raw;}function _openid_dh_base64_to_long($str) {  $b64 = base64_decode($str);  return _openid_dh_binary_to_long($b64);}function _openid_dh_long_to_base64($str) {  return base64_encode(_openid_dh_long_to_binary($str));}function _openid_dh_binary_to_long($str) {  $bytes = array_merge(unpack('C*', $str));  $n = 0;  foreach ($bytes as $byte) {    $n = bcmul($n, pow(2, 8));    $n = bcadd($n, $byte);  }  return $n;}function _openid_dh_long_to_binary($long) {  $cmp = bccomp($long, 0);  if ($cmp < 0) {    return FALSE;  }  if ($cmp == 0) {    return "\x00";  }  $bytes = array();  while (bccomp($long, 0) > 0) {    array_unshift($bytes, bcmod($long, 256));    $long = bcdiv($long, pow(2, 8));  }  if ($bytes && ($bytes[0] > 127)) {    array_unshift($bytes, 0);  }  $string = '';  foreach ($bytes as $byte) {    $string .= pack('C', $byte);  }  return $string;}function _openid_dh_xorsecret($shared, $secret) {  $dh_shared_str = _openid_dh_long_to_binary($shared);  $sha1_dh_shared = _openid_sha1($dh_shared_str);  $xsecret = "";  for ($i = 0; $i < strlen($secret); $i++) {    $xsecret .= chr(ord($secret[$i]) ^ ord($sha1_dh_shared[$i]));  }  return $xsecret;}function _openid_dh_rand($stop) {  static $duplicate_cache = array();  // Used as the key for the duplicate cache  $rbytes = _openid_dh_long_to_binary($stop);  if (array_key_exists($rbytes, $duplicate_cache)) {    list($duplicate, $nbytes) = $duplicate_cache[$rbytes];  }  else {    if ($rbytes[0] == "\x00") {      $nbytes = strlen($rbytes) - 1;    }    else {      $nbytes = strlen($rbytes);    }    $mxrand = bcpow(256, $nbytes);    // If we get a number less than this, then it is in the    // duplicated range.    $duplicate = bcmod($mxrand, $stop);    if (count($duplicate_cache) > 10) {      $duplicate_cache = array();    }    $duplicate_cache[$rbytes] = array($duplicate, $nbytes);  }  do {    $bytes = "\x00". _openid_get_bytes($nbytes);    $n = _openid_dh_binary_to_long($bytes);    // Keep looping if this value is in the low duplicated range.  } while (bccomp($n, $duplicate) < 0);  return bcmod($n, $stop);}function _openid_get_bytes($num_bytes) {  static $f = null;  $bytes = '';  if (!isset($f)) {    $f = @fopen(OPENID_RAND_SOURCE, "r");  }  if (!$f) {    // pseudorandom used    $bytes = '';    for ($i = 0; $i < $num_bytes; $i += 4) {      $bytes .= pack('L', mt_rand());    }    $bytes = substr($bytes, 0, $num_bytes);  }  else {    $bytes = fread($f, $num_bytes);  }  return $bytes;}function _openid_response($str = NULL) {  $data = array();    if (isset($_SERVER['REQUEST_METHOD'])) {    $data = _openid_get_params($_SERVER['QUERY_STRING']);    if ($_SERVER['REQUEST_METHOD'] == 'POST') {      $str = file_get_contents('php://input');      $post = array();      if ($str !== false) {        $post = _openid_get_params($str);      }      $data = array_merge($data, $post);    }  }  return $data;}function _openid_get_params($str) {  $chunks = explode("&", $str);  $data = array();  foreach ($chunks as $chunk) {    $parts = explode("=", $chunk, 2);    if (count($parts) == 2) {      list($k, $v) = $parts;      $data[$k] = urldecode($v);    }  }  return $data;}/** * Provide bcpowmod support for PHP4. */if (!function_exists('bcpowmod')) {  function bcpowmod($base, $exp, $mod) {    $square = bcmod($base, $mod);    $result = 1;    while (bccomp($exp, 0) > 0) {      if (bcmod($exp, 2)) {        $result = bcmod(bcmul($result, $square), $mod);      }      $square = bcmod(bcmul($square, $square), $mod);      $exp = bcdiv($exp, 2);    }    return $result;  }}
<?php// $Id$?><div class="comment<?php print ($comment->new) ? ' comment-new' : ''; print ' '. $status; print ' '. $zebra; ?>">  <div class="clear-block">  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted; ?></span>  <?php endif; ?>  <?php if ($comment->new) : ?>    <span class="new"><?php print drupal_ucfirst($new) ?></span>  <?php endif; ?>  <?php print $picture ?>    <h3><?php print $title ?></h3>    <div class="content">      <?php print $content ?>      <?php if ($signature): ?>      <div class="clear-block">        <div></div>        <?php print $signature ?>      </div>      <?php endif; ?>    </div>  </div>  <?php if ($links): ?>    <div class="links"><?php print $links ?></div>  <?php endif; ?></div>
<?php// $Id$/** * @file * Administrative page callbacks for the dblog module. *//** * dblog module settings form. * * @ingroup forms * @see system_settings_form() */function dblog_admin_settings() {  $form['dblog_row_limit'] = array(    '#type' => 'select',    '#title' => t('Discard log entries above the following row limit'),    '#default_value' => variable_get('dblog_row_limit', 1000),    '#options' => drupal_map_assoc(array(100, 1000, 10000, 100000, 1000000)),    '#description' => t('The maximum number of rows to keep in the database log. Older entries will be automatically discarded. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status')))  );  return system_settings_form($form);}/** * Menu callback; displays a listing of log messages. */function dblog_overview() {  $filter = dblog_build_filter_query();  $rows = array();  $icons = array(    WATCHDOG_DEBUG    => '',    WATCHDOG_INFO     => '',    WATCHDOG_NOTICE   => '',    WATCHDOG_WARNING  => theme('image', 'misc/watchdog-warning.png', t('warning'), t('warning')),    WATCHDOG_ERROR    => theme('image', 'misc/watchdog-error.png', t('error'), t('error')),    WATCHDOG_CRITICAL => theme('image', 'misc/watchdog-error.png', t('critical'), t('critical')),    WATCHDOG_ALERT    => theme('image', 'misc/watchdog-error.png', t('alert'), t('alert')),    WATCHDOG_EMERG    => theme('image', 'misc/watchdog-error.png', t('emergency'), t('emergency')),  );  $classes = array(    WATCHDOG_DEBUG    => 'dblog-debug',    WATCHDOG_INFO     => 'dblog-info',    WATCHDOG_NOTICE   => 'dblog-notice',    WATCHDOG_WARNING  => 'dblog-warning',    WATCHDOG_ERROR    => 'dblog-error',    WATCHDOG_CRITICAL => 'dblog-critical',    WATCHDOG_ALERT    => 'dblog-alert',    WATCHDOG_EMERG    => 'dblog-emerg',  );  $output = drupal_get_form('dblog_filter_form');  $header = array(    ' ',    array('data' => t('Type'), 'field' => 'w.type'),    array('data' => t('Date'), 'field' => 'w.wid', 'sort' => 'desc'),    t('Message'),    array('data' => t('User'), 'field' => 'u.name'),    array('data' => t('Operations')),  );  $sql = "SELECT w.wid, w.uid, w.severity, w.type, w.timestamp, w.message, w.variables, w.link, u.name FROM {watchdog} w INNER JOIN {users} u ON w.uid = u.uid";  $tablesort = tablesort_sql($header);  if (!empty($filter['where'])) {    $result = pager_query($sql ." WHERE ". $filter['where'] . $tablesort, 50, 0, NULL, $filter['args']);  }  else {    $result = pager_query($sql . $tablesort, 50);  }  while ($dblog = db_fetch_object($result)) {    $rows[] = array('data' =>      array(        // Cells        $icons[$dblog->severity],        t($dblog->type),        format_date($dblog->timestamp, 'small'),        l(truncate_utf8(_dblog_format_message($dblog), 56, TRUE, TRUE), 'admin/reports/event/'. $dblog->wid, array('html' => TRUE)),        theme('username', $dblog),        $dblog->link,      ),      // Attributes for tr      'class' => "dblog-". preg_replace('/[^a-z]/i', '-', $dblog->type) .' '. $classes[$dblog->severity]    );  }  if (!$rows) {    $rows[] = array(array('data' => t('No log messages available.'), 'colspan' => 6));  }  $output .= theme('table', $header, $rows, array('id' => 'admin-dblog'));  $output .= theme('pager', NULL, 50, 0);  return $output;}/** * Menu callback; generic function to display a page of the most frequent * dblog events of a specified type. */function dblog_top($type) {  $header = array(    array('data' => t('Count'), 'field' => 'count', 'sort' => 'desc'),    array('data' => t('Message'), 'field' => 'message')  );  $result = pager_query("SELECT COUNT(wid) AS count, message, variables FROM {watchdog} WHERE type = '%s' GROUP BY message, variables ". tablesort_sql($header), 30, 0, "SELECT COUNT(DISTINCT(message)) FROM {watchdog} WHERE type = '%s'", $type);  $rows = array();  while ($dblog = db_fetch_object($result)) {    $rows[] = array($dblog->count, truncate_utf8(_dblog_format_message($dblog), 56, TRUE, TRUE));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No log messages available.'), 'colspan' => 2));  }  $output  = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; displays details about a log message. */function dblog_event($id) {  $severity = watchdog_severity_levels();  $output = '';  $result = db_query('SELECT w.*, u.name, u.uid FROM {watchdog} w INNER JOIN {users} u ON w.uid = u.uid WHERE w.wid = %d', $id);  if ($dblog = db_fetch_object($result)) {    $rows = array(      array(        array('data' => t('Type'), 'header' => TRUE),        t($dblog->type),      ),      array(        array('data' => t('Date'), 'header' => TRUE),        format_date($dblog->timestamp, 'large'),      ),      array(        array('data' => t('User'), 'header' => TRUE),        theme('username', $dblog),      ),      array(        array('data' => t('Location'), 'header' => TRUE),        l($dblog->location, $dblog->location),      ),      array(        array('data' => t('Referrer'), 'header' => TRUE),        l($dblog->referer, $dblog->referer),      ),      array(        array('data' => t('Message'), 'header' => TRUE),        _dblog_format_message($dblog),      ),      array(        array('data' => t('Severity'), 'header' => TRUE),        $severity[$dblog->severity],      ),      array(        array('data' => t('Hostname'), 'header' => TRUE),        check_plain($dblog->hostname),      ),      array(        array('data' => t('Operations'), 'header' => TRUE),        $dblog->link,      ),    );    $attributes = array('class' => 'dblog-event');    $output = theme('table', array(), $rows, $attributes);  }  return $output;}/** * Build query for dblog administration filters based on session. */function dblog_build_filter_query() {  if (empty($_SESSION['dblog_overview_filter'])) {    return;  }  $filters = dblog_filters();  // Build query  $where = $args = array();  foreach ($_SESSION['dblog_overview_filter'] as $key => $filter) {    $filter_where = array();    foreach ($filter as $value) {      $filter_where[] = $filters[$key]['where'];      $args[] = $value;    }    if (!empty($filter_where)) {      $where[] = '('. implode(' OR ', $filter_where) .')';    }  }  $where = !empty($where) ? implode(' AND ', $where) : '';  return array(    'where' => $where,    'args' => $args,  );}/** * List dblog administration filters that can be applied. */function dblog_filters() {  $filters = array();  foreach (_dblog_get_message_types() as $type) {    $types[$type] = $type;  }  if (!empty($types)) {    $filters['type'] = array(      'title' => t('Type'),      'where' => "w.type = '%s'",      'options' => $types,    );  }  $filters['severity'] = array(    'title' => t('Severity'),    'where' => 'w.severity = %d',    'options' => watchdog_severity_levels(),  );  return $filters;}/** * Formats a log message for display. * * @param $dblog *   An object with at least the message and variables properties */function _dblog_format_message($dblog) {  // Legacy messages and user specified text  if ($dblog->variables === 'N;') {    return $dblog->message;  }  // Message to translate with injected variables  else {    return t($dblog->message, unserialize($dblog->variables));  }}/** * Return form for dblog administration filters. * * @ingroup forms * @see dblog_filter_form_submit() * @see dblog_filter_form_validate() */function dblog_filter_form() {  $session = &$_SESSION['dblog_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = dblog_filters();  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Filter log messages'),    '#theme' => 'dblog_filters',    '#collapsible' => TRUE,    '#collapsed' => empty($session),  );  foreach ($filters as $key => $filter) {    $form['filters']['status'][$key] = array(      '#title' => $filter['title'],      '#type' => 'select',      '#multiple' => TRUE,      '#size' => 8,      '#options' => $filter['options'],    );    if (!empty($session[$key])) {      $form['filters']['status'][$key]['#default_value'] = $session[$key];    }  }  $form['filters']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Filter'),  );  if (!empty($session)) {    $form['filters']['buttons']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset')    );  }  return $form;}/** * Validate result from dblog administration filter form. */function dblog_filter_form_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Filter') && empty($form_state['values']['type']) && empty($form_state['values']['severity'])) {    form_set_error('type', t('You must select something to filter by.'));  }}/** * Process result from dblog administration filter form. */function dblog_filter_form_submit($form, &$form_state) {  $op = $form_state['values']['op'];  $filters = dblog_filters();  switch ($op) {    case t('Filter'):      foreach ($filters as $name => $filter) {        if (isset($form_state['values'][$name])) {          $_SESSION['dblog_overview_filter'][$name] = $form_state['values'][$name];        }      }      break;    case t('Reset'):      $_SESSION['dblog_overview_filter'] = array();      break;  }  return 'admin/reports/dblog';}
