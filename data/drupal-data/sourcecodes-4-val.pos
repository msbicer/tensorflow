<?php// $Id$/** * @file * Administrative page callbacks for the forum module. */function forum_form_main($type, $edit = array()) {  if ((isset($_POST['op']) && $_POST['op'] == t('Delete')) || !empty($_POST['confirm'])) {    return drupal_get_form('forum_confirm_delete', $edit['tid']);  }  switch ($type) {    case 'forum':      return drupal_get_form('forum_form_forum', $edit);      break;    case 'container':      return drupal_get_form('forum_form_container', $edit);      break;  }}/** * Returns a form for adding a forum to the forum vocabulary * * @param $edit Associative array containing a forum term to be added or edited. * @ingroup forms * @see forum_form_submit() */function forum_form_forum(&$form_state, $edit = array()) {  $edit += array(    'name' => '',    'description' => '',    'tid' => NULL,    'weight' => 0,  );  $form['name'] = array('#type' => 'textfield',    '#title' => t('Forum name'),    '#default_value' => $edit['name'],    '#maxlength' => 255,    '#description' => t('Short but meaningful name for this collection of threaded discussions.'),    '#required' => TRUE,  );  $form['description'] = array('#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],    '#description' => t('Description and guidelines for discussions within this forum.'),  );  $form['parent']['#tree'] = TRUE;  $form['parent'][0] = _forum_parent_select($edit['tid'], t('Parent'), 'forum');  $form['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('Forums are displayed in ascending order by weight (forums with equal weights are displayed alphabetically).'),  );  $form['vid'] = array('#type' => 'hidden', '#value' => variable_get('forum_nav_vocabulary', ''));  $form['submit' ] = array('#type' => 'submit', '#value' => t('Save'));  if ($edit['tid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['tid'] = array('#type' => 'hidden', '#value' => $edit['tid']);  }  $form['#submit'][] = 'forum_form_submit';  $form['#theme'] = 'forum_form';  return $form;}/** * Process forum form and container form submissions. */function forum_form_submit($form, &$form_state) {  if ($form['form_id']['#value'] == 'forum_form_container') {    $container = TRUE;    $type = t('forum container');  }  else {    $container = FALSE;    $type = t('forum');  }  $status = taxonomy_save_term($form_state['values']);  switch ($status) {    case SAVED_NEW:      if ($container) {        $containers = variable_get('forum_containers', array());        $containers[] = $form_state['values']['tid'];        variable_set('forum_containers', $containers);      }      drupal_set_message(t('Created new @type %term.', array('%term' => $form_state['values']['name'], '@type' => $type)));      break;    case SAVED_UPDATED:      drupal_set_message(t('The @type %term has been updated.', array('%term' => $form_state['values']['name'], '@type' => $type)));      break;  }  $form_state['redirect'] = 'admin/content/forum';  return;}/** * Returns a form for adding a container to the forum vocabulary * * @param $edit Associative array containing a container term to be added or edited. * @ingroup forms * @see forum_form_submit() */function forum_form_container(&$form_state, $edit = array()) {  $edit += array(    'name' => '',    'description' => '',    'tid' => NULL,    'weight' => 0,  );  // Handle a delete operation.  $form['name'] = array(    '#title' => t('Container name'),    '#type' => 'textfield',    '#default_value' => $edit['name'],    '#maxlength' => 255,    '#description' => t('Short but meaningful name for this collection of related forums.'),    '#required' => TRUE  );  $form['description'] = array(    '#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],    '#description' => t('Description and guidelines for forums within this container.')  );  $form['parent']['#tree'] = TRUE;  $form['parent'][0] = _forum_parent_select($edit['tid'], t('Parent'), 'container');  $form['weight'] = array(    '#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('Containers are displayed in ascending order by weight (containers with equal weights are displayed alphabetically).')  );  $form['vid'] = array(    '#type' => 'hidden',    '#value' => variable_get('forum_nav_vocabulary', ''),  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save')  );  if ($edit['tid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['tid'] = array('#type' => 'value', '#value' => $edit['tid']);  }  $form['#submit'][] = 'forum_form_submit';  $form['#theme'] = 'forum_form';  return $form;}/** * Returns a confirmation page for deleting a forum taxonomy term. * * @param $tid ID of the term to be deleted */function forum_confirm_delete(&$form_state, $tid) {  $term = taxonomy_get_term($tid);  $form['tid'] = array('#type' => 'value', '#value' => $tid);  $form['name'] = array('#type' => 'value', '#value' => $term->name);  return confirm_form($form, t('Are you sure you want to delete the forum %name?', array('%name' => $term->name)), 'admin/content/forum', t('Deleting a forum or container will also delete its sub-forums, if any. To delete posts in this forum, visit <a href="@content">content administration</a> first. This action cannot be undone.', array('@content' => url('admin/content/node'))), t('Delete'), t('Cancel'));}/** * Implementation of forms api _submit call. Deletes a forum after confirmation. */function forum_confirm_delete_submit($form, &$form_state) {  taxonomy_del_term($form_state['values']['tid']);  drupal_set_message(t('The forum %term and all sub-forums and associated posts have been deleted.', array('%term' => $form_state['values']['name'])));  watchdog('content', 'forum: deleted %term and all its sub-forums and associated posts.', array('%term' => $form_state['values']['name']));  $form_state['redirect'] = 'admin/content/forum';  return;}/** * Form builder for the forum settings page. * * @see system_settings_form() */function forum_admin_settings() {  $form = array();  $number = drupal_map_assoc(array(5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 80, 100, 150, 200, 250, 300, 350, 400, 500));  $form['forum_hot_topic'] = array('#type' => 'select',    '#title' => t('Hot topic threshold'),    '#default_value' => variable_get('forum_hot_topic', 15),    '#options' => $number,    '#description' => t('The number of posts a topic must have to be considered "hot".'),  );  $number = drupal_map_assoc(array(10, 25, 50, 75, 100));  $form['forum_per_page'] = array('#type' => 'select',    '#title' => t('Topics per page'),    '#default_value' => variable_get('forum_per_page', 25),    '#options' => $number,    '#description' => t('Default number of forum topics displayed per page.'),  );  $forder = array(1 => t('Date - newest first'), 2 => t('Date - oldest first'), 3 => t('Posts - most active first'), 4 => t('Posts - least active first'));  $form['forum_order'] = array('#type' => 'radios',    '#title' => t('Default order'),    '#default_value' => variable_get('forum_order', '1'),    '#options' => $forder,    '#description' => t('Default display order for topics.'),  );  return system_settings_form($form);}/** * Returns an overview list of existing forums and containers */function forum_overview(&$form_state) {  module_load_include('inc', 'taxonomy', 'taxonomy.admin');  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  $form = taxonomy_overview_terms($form_state, $vocabulary);  foreach (element_children($form) as $key) {    if (isset($form[$key]['#term'])) {      $term = $form[$key]['#term'];      $form[$key]['view']['#value'] = l($term['name'], 'forum/'. $term['tid']);      if (in_array($form[$key]['#term']['tid'], variable_get('forum_containers', array()))) {        $form[$key]['edit']['#value'] = l(t('edit container'), 'admin/content/forum/edit/container/'. $term['tid']);      }      else {        $form[$key]['edit']['#value'] = l(t('edit forum'), 'admin/content/forum/edit/forum/'. $term['tid']);      }    }  }  // Remove the alphabetical reset.  unset($form['reset_alphabetical']);  // The form needs to have submit and validate handlers set explicitly.  $form['#theme'] = 'taxonomy_overview_terms';  $form['#submit'] = array('taxonomy_overview_terms_submit'); // Use the existing taxonomy overview submit handler.  $form['#validate'] = array('taxonomy_overview_terms_validate');  $form['#empty_text'] = '<em>'. t('There are no existing containers or forums. Containers and forums may be added using the <a href="@container">add container</a> and <a href="@forum">add forum</a> pages.', array('@container' => url('admin/content/forum/add/container'), '@forum' => url('admin/content/forum/add/forum'))) .'</em>';  return $form;}/** * Returns a select box for available parent terms * * @param $tid ID of the term which is being added or edited * @param $title Title to display the select box with * @param $child_type Whether the child is forum or container */function _forum_parent_select($tid, $title, $child_type) {  $parents = taxonomy_get_parents($tid);  if ($parents) {    $parent = array_shift($parents);    $parent = $parent->tid;  }  else {    $parent = 0;  }  $vid = variable_get('forum_nav_vocabulary', '');  $children = taxonomy_get_tree($vid, $tid);  // A term can't be the child of itself, nor of its children.  foreach ($children as $child) {    $exclude[] = $child->tid;  }  $exclude[] = $tid;  $tree = taxonomy_get_tree($vid);  $options[0] = '<'. t('root') .'>';  if ($tree) {    foreach ($tree as $term) {      if (!in_array($term->tid, $exclude)) {        $options[$term->tid] = str_repeat(' -- ', $term->depth) . $term->name;      }    }  }  if ($child_type == 'container') {    $description = t('Containers are usually placed at the top (root) level, but may also be placed inside another container or forum.');  }  else if ($child_type == 'forum') {    $description = t('Forums may be placed at the top (root) level, or inside another container or forum.');  }  return array('#type' => 'select', '#title' => $title, '#default_value' => $parent, '#options' => $options, '#description' => $description, '#required' => TRUE);}
<?php// $Id$/** * @file * Allows administrators to customize the site navigation menu. *//** * Maximum length of menu name as entered by the user. Database length is 32 * and we add a menu- prefix. */define('MENU_MAX_MENU_NAME_LENGTH_UI', 27);/** * Implementation of hook_help(). */function menu_help($path, $arg) {  switch ($path) {    case 'admin/help#menu':      $output = '<p>'. t("The menu module provides an interface to control and customize Drupal's powerful menu system. Menus are a hierarchical collection of links, or menu items, used to navigate a website, and are positioned and displayed using Drupal's flexible block system. By default, three menus are created during installation: <em>Navigation</em>, <em>Primary links</em>, and <em>Secondary links</em>. The <em>Navigation</em> menu contains most links necessary for working with and navigating your site, and is often displayed in either the left or right sidebar. Most Drupal themes also provide support for <em>Primary links</em> and <em>Secondary links</em>, by displaying them in either the header or footer of each page. By default, <em>Primary links</em> and <em>Secondary links</em> contain no menu items but may be configured to contain custom menu items specific to your site.") .'</p>';      $output .= '<p>'. t('The <a href="@menu">menus page</a> displays all menus currently available on your site. Select a menu from this list to add or edit a menu item, or to rearrange items within the menu. Create new menus using the <a href="@add-menu">add menu page</a> (the block containing a new menu must also be enabled on the <a href="@blocks">blocks administration page</a>).', array('@menu' => url('admin/build/menu'), '@add-menu' => url('admin/build/menu/add'), '@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@menu">Menu module</a>.', array('@menu' => 'http://drupal.org/handbook/modules/menu/')) .'</p>';      return $output;    case 'admin/build/menu':      return '<p>'. t('Menus are a collection of links (menu items) used to navigate a website. The menus currently available on your site are displayed below. Select a menu from this list to manage its menu items.') .'</p>';    case 'admin/build/menu/add':      return '<p>'. t('Enter the name for your new menu. Remember to enable the newly created block in the <a href="@blocks">blocks administration page</a>.', array('@blocks' => url('admin/build/block'))) .'</p>';    case 'admin/build/menu-customize/%':      return '<p>'. t('To rearrange menu items, grab a drag-and-drop handle under the <em>Menu item</em> column and drag the items (or group of items) to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save configuration</em> button at the bottom of the page.') .'</p>';    case 'admin/build/menu/item/add':      return '<p>'. t('Enter the title and path for your new menu item.') .'</p>';  }}/** * Implementation of hook_perm(). */function menu_perm() {  return array('administer menu');}/** * Implementation of hook_menu(). */function menu_menu() {  $items['admin/build/menu'] = array(    'title' => 'Menus',    'description' => "Control your site's navigation menu, primary links and secondary links. as well as rename and reorganize menu items.",    'page callback' => 'menu_overview_page',    'access callback' => 'user_access',    'access arguments' => array('administer menu'),    'file' => 'menu.admin.inc',  );  $items['admin/build/menu/list'] = array(    'title' => 'List menus',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,    'file' => 'menu.admin.inc',  );  $items['admin/build/menu/add'] = array(    'title' => 'Add menu',    'page callback' => 'drupal_get_form',    'page arguments' => array('menu_edit_menu', 'add'),    'access arguments' => array('administer menu'),    'type' => MENU_LOCAL_TASK,    'file' => 'menu.admin.inc',  );  $items['admin/build/menu/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('menu_configure'),    'access arguments' => array('administer menu'),    'type' => MENU_LOCAL_TASK,    'weight' => 5,    'file' => 'menu.admin.inc',  );  $items['admin/build/menu-customize/%menu'] = array(    'title' => 'Customize menu',    'page callback' => 'drupal_get_form',    'page arguments' => array('menu_overview_form', 3),    'title callback' => 'menu_overview_title',    'title arguments' => array(3),    'access arguments' => array('administer menu'),    'type' => MENU_CALLBACK,    'file' => 'menu.admin.inc',  );  $items['admin/build/menu-customize/%menu/list'] = array(    'title' => 'List items',    'weight' => -10,    'type' => MENU_DEFAULT_LOCAL_TASK,    'file' => 'menu.admin.inc',  );  $items['admin/build/menu-customize/%menu/add'] = array(    'title' => 'Add item',    'page callback' => 'drupal_get_form',    'page arguments' => array('menu_edit_item', 'add', NULL, 3),    'access arguments' => array('administer menu'),    'type' => MENU_LOCAL_TASK,    'file' => 'menu.admin.inc',  );  $items['admin/build/menu-customize/%menu/edit'] = array(    'title' => 'Edit menu',    'page callback' => 'drupal_get_form',    'page arguments' => array('menu_edit_menu', 'edit', 3),    'access arguments' => array('administer menu'),    'type' => MENU_LOCAL_TASK,    'file' => 'menu.admin.inc',  );  $items['admin/build/menu-customize/%menu/delete'] = array(    'title' => 'Delete menu',    'page callback' => 'menu_delete_menu_page',    'page arguments' => array(3),    'access arguments' => array('administer menu'),    'type' => MENU_CALLBACK,    'file' => 'menu.admin.inc',  );  $items['admin/build/menu/item/%menu_link/edit'] = array(    'title' => 'Edit menu item',    'page callback' => 'drupal_get_form',    'page arguments' => array('menu_edit_item', 'edit', 4, NULL),    'access arguments' => array('administer menu'),    'type' => MENU_CALLBACK,    'file' => 'menu.admin.inc',  );  $items['admin/build/menu/item/%menu_link/reset'] = array(    'title' => 'Reset menu item',    'page callback' => 'drupal_get_form',    'page arguments' => array('menu_reset_item_confirm', 4),    'access arguments' => array('administer menu'),    'type' => MENU_CALLBACK,    'file' => 'menu.admin.inc',  );  $items['admin/build/menu/item/%menu_link/delete'] = array(    'title' => 'Delete menu item',    'page callback' => 'menu_item_delete_page',    'page arguments' => array(4),    'access arguments' => array('administer menu'),    'type' => MENU_CALLBACK,    'file' => 'menu.admin.inc',  );  return $items;}/** * Implemenation of hook_theme(). */function menu_theme() {  return array(    'menu_overview_form' => array(      'file' => 'menu.admin.inc',      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_enable() * *  Add a link for each custom menu. */function menu_enable() {  menu_rebuild();  $base_link = db_fetch_array(db_query("SELECT mlid AS plid, menu_name from {menu_links} WHERE link_path = 'admin/build/menu' AND module = 'system'"));  $base_link['router_path'] = 'admin/build/menu-customize/%';  $base_link['module'] = 'menu';  $result = db_query("SELECT * FROM {menu_custom}");  while ($menu = db_fetch_array($result)) {    // $link is passed by reference to menu_link_save(), so we make a copy of $base_link.    $link = $base_link;    $link['mlid'] = 0;    $link['link_title'] = $menu['title'];    $link['link_path'] = 'admin/build/menu-customize/'. $menu['menu_name'];    if (!db_result(db_query("SELECT mlid FROM {menu_links} WHERE link_path = '%s' AND plid = %d", $link['link_path'], $link['plid']))) {      menu_link_save($link);    }  }  menu_cache_clear_all();}/** * Title callback for the menu overview page and links. */function menu_overview_title($menu) {  return $menu['title'];}/** * Load the data for a single custom menu. */function menu_load($menu_name) {  return db_fetch_array(db_query("SELECT * FROM {menu_custom} WHERE menu_name = '%s'", $menu_name));}/** * Return a list of menu items that are valid possible parents for the given menu item. * * @param $menus *   An array of menu names and titles, such as from menu_get_menus(). * @param $item *   The menu item for which to generate a list of parents. *   If $item['mlid'] == 0 then the complete tree is returned. * @return *   An array of menu link titles keyed on the a string containing the menu name *   and mlid. The list excludes the given item and its children. */function menu_parent_options($menus, $item) {  // The menu_links table can be practically any size and we need a way to  // allow contrib modules to provide more scalable pattern choosers.  // hook_form_alter is too late in itself because all the possible parents are  // retrieved here, unless menu_override_parent_selector is set to TRUE.  if (variable_get('menu_override_parent_selector', FALSE)) {    return array();  }  // If the item has children, there is an added limit to the depth of valid parents.  if (isset($item['parent_depth_limit'])) {    $limit = $item['parent_depth_limit'];  }  else {    $limit = _menu_parent_depth_limit($item);  }  foreach ($menus as $menu_name => $title) {    $tree = menu_tree_all_data($menu_name, NULL);    $options[$menu_name .':0'] = '<'. $title .'>';    _menu_parents_recurse($tree, $menu_name, '--', $options, $item['mlid'], $limit);  }  return $options;}/** * Recursive helper function for menu_parent_options(). */function _menu_parents_recurse($tree, $menu_name, $indent, &$options, $exclude, $depth_limit) {  foreach ($tree as $data) {    if ($data['link']['depth'] > $depth_limit) {      // Don't iterate through any links on this level.      break;    }    if ($data['link']['mlid'] != $exclude && $data['link']['hidden'] >= 0) {      $title = $indent .' '. truncate_utf8($data['link']['title'], 30, TRUE, FALSE);      if ($data['link']['hidden']) {        $title .= ' ('. t('disabled') .')';      }      $options[$menu_name .':'. $data['link']['mlid']] = $title;      if ($data['below']) {        _menu_parents_recurse($data['below'], $menu_name, $indent .'--', $options, $exclude, $depth_limit);      }    }  }}/** * Reset a system-defined menu item. */function menu_reset_item($item) {  $new_item = _menu_link_build(menu_get_item($item['router_path']));  foreach (array('mlid', 'has_children') as $key) {    $new_item[$key] = $item[$key];  }  menu_link_save($new_item);  return $new_item;}/** * Implementation of hook_block(). */function menu_block($op = 'list', $delta = 0) {  $menus = menu_get_menus();  // The Navigation menu is handled by the user module.  unset($menus['navigation']);  if ($op == 'list') {    $blocks = array();    foreach ($menus as $name => $title) {      // Default "Navigation" block is handled by user.module.      $blocks[$name]['info'] = check_plain($title);      // Menu blocks can't be cached because each menu item can have      // a custom access callback. menu.inc manages its own caching.      $blocks[$name]['cache'] = BLOCK_NO_CACHE;    }    return $blocks;  }  else if ($op == 'view') {    $data['subject'] = check_plain($menus[$delta]);    $data['content'] = menu_tree($delta);    return $data;  }}/** * Implementation of hook_nodeapi(). */function menu_nodeapi(&$node, $op) {  switch ($op) {    case 'insert':    case 'update':      if (isset($node->menu)) {        $item = &$node->menu;        if (!empty($item['delete'])) {          menu_link_delete($item['mlid']);        }        elseif (trim($item['link_title'])) {          $item['link_title'] = trim($item['link_title']);          $item['link_path'] = "node/$node->nid";          if (!$item['customized']) {            $item['options']['attributes']['title'] = trim($node->title);          }          if (!menu_link_save($item)) {            drupal_set_message(t('There was an error saving the menu link.'), 'error');          }        }      }      break;    case 'delete':      // Delete all menu module links that point to this node.      $result = db_query("SELECT mlid FROM {menu_links} WHERE link_path = 'node/%d' AND module = 'menu'", $node->nid);      while ($m = db_fetch_array($result)) {        menu_link_delete($m['mlid']);      }      break;    case 'prepare':      if (empty($node->menu)) {        // Prepare the node for the edit form so that $node->menu always exists.        $menu_name = variable_get('menu_default_node_menu', 'primary-links');        $item = array();        if (isset($node->nid)) {          // Give priority to the default menu          $mlid = db_result(db_query_range("SELECT mlid FROM {menu_links} WHERE link_path = 'node/%d' AND menu_name = '%s' AND module = 'menu' ORDER BY mlid ASC", $node->nid, $menu_name, 0, 1));          // Check all menus if a link does not exist in the default menu.          if (!$mlid) {            $mlid = db_result(db_query_range("SELECT mlid FROM {menu_links} WHERE link_path = 'node/%d' AND module = 'menu' ORDER BY mlid ASC", $node->nid, 0, 1));          }          if ($mlid) {            $item = menu_link_load($mlid);          }        }        // Set default values.        $node->menu = $item + array('link_title' => '', 'mlid' => 0, 'plid' => 0, 'menu_name' => $menu_name, 'weight' => 0, 'options' => array(), 'module' => 'menu', 'expanded' => 0, 'hidden' => 0, 'has_children' => 0, 'customized' => 0);      }      // Find the depth limit for the parent select.      if (!isset($node->menu['parent_depth_limit'])) {        $node->menu['parent_depth_limit'] = _menu_parent_depth_limit($node->menu);      }      break;  }}/** * Find the depth limit for items in the parent select. */function _menu_parent_depth_limit($item) {  return MENU_MAX_DEPTH - 1 - (($item['mlid'] && $item['has_children']) ? menu_link_children_relative_depth($item) : 0);}/** * Implementation of hook_form_alter(). Adds menu item fields to the node form. */function menu_form_alter(&$form, $form_state, $form_id) {  if (isset($form['#node']) && $form['#node']->type .'_node_form' == $form_id) {    // Note - doing this to make sure the delete checkbox stays in the form.    $form['#cache'] = TRUE;    $form['menu'] = array(      '#type' => 'fieldset',      '#title' => t('Menu settings'),      '#access' => user_access('administer menu'),      '#collapsible' => TRUE,      '#collapsed' => FALSE,      '#tree' => TRUE,      '#weight' => -2,      '#attributes' => array('class' => 'menu-item-form'),    );    $item = $form['#node']->menu;    if ($item['mlid']) {      // There is an existing link.      $form['menu']['delete'] = array(        '#type' => 'checkbox',        '#title' => t('Delete this menu item.'),      );    }    if (!$item['link_title']) {      $form['menu']['#collapsed'] = TRUE;    }    foreach (array('mlid', 'module', 'hidden', 'has_children', 'customized', 'options', 'expanded', 'hidden', 'parent_depth_limit') as $key) {      $form['menu'][$key] = array('#type' => 'value', '#value' => $item[$key]);    }    $form['menu']['#item'] = $item;    $form['menu']['link_title'] = array('#type' => 'textfield',      '#title' => t('Menu link title'),      '#default_value' => $item['link_title'],      '#description' => t('The link text corresponding to this item that should appear in the menu. Leave blank if you do not wish to add this post to the menu.'),      '#required' => FALSE,    );    // Generate a list of possible parents (not including this item or descendants).    $options = menu_parent_options(menu_get_menus(), $item);    $default = $item['menu_name'] .':'. $item['plid'];    if (!isset($options[$default])) {      $default = 'primary-links:0';    }    $form['menu']['parent'] = array(      '#type' => 'select',      '#title' => t('Parent item'),      '#default_value' => $default,      '#options' => $options,      '#description' => t('The maximum depth for an item and all its children is fixed at !maxdepth. Some menu items may not be available as parents if selecting them would exceed this limit.', array('!maxdepth' => MENU_MAX_DEPTH)),      '#attributes' => array('class' => 'menu-title-select'),    );    $form['#submit'][] = 'menu_node_form_submit';    $form['menu']['weight'] = array(      '#type' => 'weight',      '#title' => t('Weight'),      '#delta' => 50,      '#default_value' => $item['weight'],      '#description' => t('Optional. In the menu, the heavier items will sink and the lighter items will be positioned nearer the top.'),    );  }}/** * Decompose the selected menu parent option into the menu_name and plid. */function menu_node_form_submit($form, &$form_state) {  list($form_state['values']['menu']['menu_name'], $form_state['values']['menu']['plid']) = explode(':', $form_state['values']['menu']['parent']);}/** * Return an associative array of the custom menus names. * * @param $all *   If FALSE return only user-added menus, or if TRUE also include *   the menus defined by the system. * @return *   An array with the machine-readable names as the keys, and human-readable *   titles as the values. */function menu_get_menus($all = TRUE) {  $system_menus = menu_list_system_menus();  $sql = 'SELECT * FROM {menu_custom}';  if (!$all) {    $sql .= ' WHERE menu_name NOT IN ('. implode(',', array_fill(0, count($system_menus), "'%s'")) .')';  }  $sql .= ' ORDER BY title';  $result = db_query($sql, $system_menus);  $rows = array();  while ($r = db_fetch_array($result)) {    $rows[$r['menu_name']] = $r['title'];  }  return $rows;}
<?php// $Id$/** * @file * Code required only when rendering the available updates report. *//** * Menu callback. Generate a page about the update status of projects. */function update_status() {  if ($available = update_get_available(TRUE)) {    module_load_include('inc', 'update', 'update.compare');    $data = update_calculate_project_data($available);    return theme('update_report', $data);  }  else {    return theme('update_report', _update_no_data());  }}/** * Theme project status report. * * @ingroup themeable */function theme_update_report($data) {  $last = variable_get('update_last_check', 0);  $output = '<div class="update checked">'. ($last ? t('Last checked: @time ago', array('@time' => format_interval(time() - $last))) : t('Last checked: never'));  $output .= ' <span class="check-manually">('. l(t('Check manually'), 'admin/reports/updates/check') .')</span>';  $output .= "</div>\n";  if (!is_array($data)) {    $output .= '<p>'. $data .'</p>';    return $output;  }  $header = array();  $rows = array();  $notification_level = variable_get('update_notification_threshold', 'all');  foreach ($data as $project) {    switch ($project['status']) {      case UPDATE_CURRENT:        $class = 'ok';        $icon = theme('image', 'misc/watchdog-ok.png', t('ok'), t('ok'));        break;      case UPDATE_UNKNOWN:      case UPDATE_NOT_FETCHED:        $class = 'unknown';        $icon = theme('image', 'misc/watchdog-warning.png', t('warning'), t('warning'));        break;      case UPDATE_NOT_SECURE:      case UPDATE_REVOKED:      case UPDATE_NOT_SUPPORTED:        $class = 'error';        $icon = theme('image', 'misc/watchdog-error.png', t('error'), t('error'));        break;      case UPDATE_NOT_CHECKED:      case UPDATE_NOT_CURRENT:      default:        $class = 'warning';        $icon = theme('image', 'misc/watchdog-warning.png', t('warning'), t('warning'));        break;    }    $row = '<div class="version-status">';    switch ($project['status']) {      case UPDATE_NOT_SECURE:        $row .= '<span class="security-error">'. t('Security update required!') .'</span>';        break;      case UPDATE_REVOKED:        $row .= '<span class="revoked">'. t('Revoked!') .'</span>';        break;      case UPDATE_NOT_SUPPORTED:        $row .= '<span class="not-supported">'. t('Not supported!') .'</span>';        break;      case UPDATE_NOT_CURRENT:        $row .= '<span class="not-current">'. t('Update available') .'</span>';        break;      case UPDATE_CURRENT:        $row .= '<span class="current">'. t('Up to date') .'</span>';        break;      default:        $row .= check_plain($project['reason']);        break;    }    $row .= '<span class="icon">'. $icon .'</span>';    $row .= "</div>\n";    $row .= '<div class="project">';    if (isset($project['title'])) {      if (isset($project['link'])) {        $row .= l($project['title'], $project['link']);      }      else {        $row .= check_plain($project['title']);      }    }    else {      $row .= check_plain($project['name']);    }    $row .= ' '. check_plain($project['existing_version']);    if ($project['install_type'] == 'dev' && !empty($project['datestamp'])) {      $row .= ' <span class="version-date">('. format_date($project['datestamp'], 'custom', 'Y-M-d') .')</span>';    }    $row .= "</div>\n";    $row .= "<div class=\"versions\">\n";    if (isset($project['recommended'])) {      if ($project['status'] != UPDATE_CURRENT || $project['existing_version'] !== $project['recommended']) {        // First, figure out what to recommend.        // If there's only 1 security update and it has the same version we're        // recommending, give it the same CSS class as if it was recommended,        // but don't print out a separate "Recommended" line for this project.        if (!empty($project['security updates']) && count($project['security updates']) == 1 && $project['security updates'][0]['version'] === $project['recommended']) {          $security_class = ' version-recommended version-recommended-strong';        }        else {          $security_class = '';          $version_class = 'version-recommended';          // Apply an extra class if we're displaying both a recommended          // version and anything else for an extra visual hint.          if ($project['recommended'] !== $project['latest_version']              || !empty($project['also'])              || ($project['install_type'] == 'dev'                 && isset($project['dev_version'])                 && $project['latest_version'] !== $project['dev_version']                 && $project['recommended'] !== $project['dev_version'])              || (isset($project['security updates'][0])                 && $project['recommended'] !== $project['security updates'][0])              ) {            $version_class .= ' version-recommended-strong';          }          $row .= theme('update_version', $project['releases'][$project['recommended']], t('Recommended version:'), $version_class);        }        // Now, print any security updates.        if (!empty($project['security updates'])) {          foreach ($project['security updates'] as $security_update) {            $row .= theme('update_version', $security_update, t('Security update:'), 'version-security'. $security_class);          }        }      }      if ($project['recommended'] !== $project['latest_version']) {        $row .= theme('update_version', $project['releases'][$project['latest_version']], t('Latest version:'), 'version-latest');      }      if ($project['install_type'] == 'dev'          && $project['status'] != UPDATE_CURRENT          && isset($project['dev_version'])          && $project['recommended'] !== $project['dev_version']) {        $row .= theme('update_version', $project['releases'][$project['dev_version']], t('Development version:'), 'version-latest');      }    }    if (isset($project['also'])) {      foreach ($project['also'] as $also) {        $row .= theme('update_version', $project['releases'][$also], t('Also available:'), 'version-also-available');      }    }    $row .= "</div>\n"; // versions div.    $row .= "<div class=\"info\">\n";    if (!empty($project['extra'])) {      $row .= '<div class="extra">'."\n";      foreach ($project['extra'] as $key => $value) {        $row .= '<div class="'. $value['class'] .'">';        $row .= check_plain($value['label']) .': ';        $row .= theme('placeholder', $value['data']);        $row .= "</div>\n";      }      $row .= "</div>\n";  // extra div.    }    $row .= '<div class="includes">';    sort($project['includes']);    $row .= t('Includes: %includes', array('%includes' => implode(', ', $project['includes'])));    $row .= "</div>\n";    if (!empty($project['base_themes'])) {      $row .= '<div class="basethemes">';      sort($project['base_themes']);      // We use !dependencies and manually call theme('placeholder') here to      // avoid breakding the D6 string freeze. This identical string is      // already in modules/system/system.admin.inc.      $row .= t('Depends on: !dependencies', array('!dependencies' => theme('placeholder', implode(', ', $project['base_themes']))));      $row .= "</div>\n";    }    if (!empty($project['sub_themes'])) {      $row .= '<div class="subthemes">';      sort($project['sub_themes']);      // We use !required and manually call theme('placeholder') here to avoid      // breakding the D6 string freeze. This identical string is already in      // modules/system/system.admin.inc.      $row .= t('Required by: !required', array('!required' => theme('placeholder', implode(', ', $project['sub_themes']))));      $row .= "</div>\n";    }    $row .= "</div>\n"; // info div.    if (!isset($rows[$project['project_type']])) {      $rows[$project['project_type']] = array();    }    $row_key = isset($project['title']) ? drupal_strtolower($project['title']) : drupal_strtolower($project['name']);    $rows[$project['project_type']][$row_key] = array(      'class' => $class,      'data' => array($row),    );  }  $project_types = array(    'core' => t('Drupal core'),    'module' => t('Modules'),    'theme' => t('Themes'),    'disabled-module' => t('Disabled modules'),    'disabled-theme' => t('Disabled themes'),  );  foreach ($project_types as $type_name => $type_label) {    if (!empty($rows[$type_name])) {      ksort($rows[$type_name]);      $output .= "\n<h3>". $type_label ."</h3>\n";      $output .= theme('table', $header, $rows[$type_name], array('class' => 'update'));    }  }  drupal_add_css(drupal_get_path('module', 'update') .'/update.css');  return $output;}/** * Theme the version display of a project. * * @ingroup themeable */function theme_update_version($version, $tag, $class) {  $output = '';  $output .= '<table class="version '. $class .'">';  $output .= '<tr>';  $output .= '<td class="version-title">'. $tag ."</td>\n";  $output .= '<td class="version-details">';  $output .= l($version['version'], $version['release_link']);  $output .= ' <span class="version-date">('. format_date($version['date'], 'custom', 'Y-M-d') .')</span>';  $output .= "</td>\n";  $output .= '<td class="version-links">';  $links = array();  $links['update-download'] = array(    'title' => t('Download'),    'href' => $version['download_link'],  );  $links['update-release-notes'] = array(    'title' => t('Release notes'),    'href' => $version['release_link'],  );  $output .= theme('links', $links);  $output .= '</td>';  $output .= '</tr>';  $output .= "</table>\n";  return $output;}
<?php// $Id$/** * @file * Admin page callbacks for the search module. *//** * Menu callback: confirm wiping of the index. */function search_wipe_confirm() {  return confirm_form(array(), t('Are you sure you want to re-index the site?'),                  'admin/settings/search', t(' The search index is not cleared but systematically updated to reflect the new settings. Searching will continue to work but new content won\'t be indexed until all existing content has been re-indexed. This action cannot be undone.'), t('Re-index site'), t('Cancel'));}/** * Handler for wipe confirmation */function search_wipe_confirm_submit(&$form, &$form_state) {  if ($form['confirm']) {    search_wipe();    drupal_set_message(t('The index will be rebuilt.'));    $form_state['redirect'] = 'admin/settings/search';    return;  }}/** * Menu callback; displays the search module settings page. * * @ingroup forms * @see system_settings_form() * @see search_admin_settings_validate() */function search_admin_settings() {  // Collect some stats  $remaining = 0;  $total = 0;  foreach (module_list() as $module) {    if (module_hook($module, 'search')) {      $status = module_invoke($module, 'search', 'status');      $remaining += $status['remaining'];      $total += $status['total'];    }  }  $count = format_plural($remaining, 'There is 1 item left to index.', 'There are @count items left to index.');  $percentage = ((int)min(100, 100 * ($total - $remaining) / max(1, $total))) .'%';  $status = '<p><strong>'. t('%percentage of the site has been indexed.', array('%percentage' => $percentage)) .' '. $count .'</strong></p>';  $form['status'] = array('#type' => 'fieldset', '#title' => t('Indexing status'));  $form['status']['status'] = array('#value' => $status);  $form['status']['wipe'] = array('#type' => 'submit', '#value' => t('Re-index site'));  $items = drupal_map_assoc(array(10, 20, 50, 100, 200, 500));  // Indexing throttle:  $form['indexing_throttle'] = array('#type' => 'fieldset', '#title' => t('Indexing throttle'));  $form['indexing_throttle']['search_cron_limit'] = array('#type' => 'select', '#title' => t('Number of items to index per cron run'), '#default_value' => variable_get('search_cron_limit', 100), '#options' => $items, '#description' => t('The maximum number of items indexed in each pass of a <a href="@cron">cron maintenance task</a>. If necessary, reduce the number of items to prevent timeouts and memory errors while indexing.', array('@cron' => url('admin/reports/status'))));  // Indexing settings:  $form['indexing_settings'] = array('#type' => 'fieldset', '#title' => t('Indexing settings'));  $form['indexing_settings']['info'] = array('#value' => t('<p><em>Changing the settings below will cause the site index to be rebuilt. The search index is not cleared but systematically updated to reflect the new settings. Searching will continue to work but new content won\'t be indexed until all existing content has been re-indexed.</em></p><p><em>The default settings should be appropriate for the majority of sites.</em></p>'));  $form['indexing_settings']['minimum_word_size'] = array('#type' => 'textfield', '#title' => t('Minimum word length to index'), '#default_value' => variable_get('minimum_word_size', 3), '#size' => 5, '#maxlength' => 3, '#description' => t('The number of characters a word has to be to be indexed. A lower setting means better search result ranking, but also a larger database. Each search query must contain at least one keyword that is this size (or longer).'));  $form['indexing_settings']['overlap_cjk'] = array('#type' => 'checkbox', '#title' => t('Simple CJK handling'), '#default_value' => variable_get('overlap_cjk', TRUE), '#description' => t('Whether to apply a simple Chinese/Japanese/Korean tokenizer based on overlapping sequences. Turn this off if you want to use an external preprocessor for this instead. Does not affect other languages.'));  $form['#validate'] = array('search_admin_settings_validate');  // Per module settings  $form = array_merge($form, module_invoke_all('search', 'admin'));  return system_settings_form($form);}/** * Validate callback. */function search_admin_settings_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Re-index site')) {    drupal_goto('admin/settings/search/wipe');  }  // If these settings change, the index needs to be rebuilt.  if ((variable_get('minimum_word_size', 3) != $form_state['values']['minimum_word_size']) ||      (variable_get('overlap_cjk', TRUE) != $form_state['values']['overlap_cjk'])) {    drupal_set_message(t('The index will be rebuilt.'));    search_wipe();  }}
<?php// $Id$/** * @file * This is the actions engine for executing stored actions. *//** * Perform a given list of actions by executing their callback functions. * * Given the IDs of actions to perform, find out what the callbacks * for the actions are by querying the database. Then call each callback * using the function call $function($object, $context, $a1, $a2) * where $function is the name of a function written in compliance with * the action specification; that is, foo($object, $context). * * @param $action_ids *   The ID of the action to perform. Can be a single action ID or an array *   of IDs. IDs of instances will be numeric; IDs of singletons will be *   function names. * @param $object *   Parameter that will be passed along to the callback. Typically the *   object that the action will act on; a node, user or comment object. *   If the action does not act on an object, pass a dummy object. This *   is necessary to support PHP 4 object referencing. * @param $context *   Parameter that will be passed along to the callback. $context is a *   keyed array containing extra information about what is currently *   happening at the time of the call. Typically $context['hook'] and *   $context['op'] will tell which hook-op combination resulted in this *   call to actions_do(). * @param $a1 *   Parameter that will be passed along to the callback. * @param $a2 *   Parameter that will be passed along to the callback. * * @return *   An associative array containing the result of the function that *   performs the action, keyed on action ID. */function actions_do($action_ids, &$object, $context = NULL, $a1 = NULL, $a2 = NULL) {  // $stack tracks the number of recursive calls.  static $stack;  $stack++;  if ($stack > variable_get('actions_max_stack', 35)) {    watchdog('actions', 'Stack overflow: too many calls to actions_do(). Aborting to prevent infinite recursion.', array(), WATCHDOG_ERROR);    return;  }  $actions = array();  $available_actions = actions_list();  $result = array();  if (is_array($action_ids)) {    $where = array();    $where_values = array();    foreach ($action_ids as $action_id) {      if (is_numeric($action_id)) {        $where[] = "OR aid = '%s'";        $where_values[] = $action_id;      }      elseif (isset($available_actions[$action_id])) {        $actions[$action_id] = $available_actions[$action_id];      }    }    // When we have action instances we must go to the database to    // retrieve instance data.    if ($where) {      $where_clause = implode(' ', $where);      // Strip off leading 'OR '.      $where_clause = '('. strstr($where_clause, " ") .')';      $result_db = db_query('SELECT * FROM {actions} WHERE '. $where_clause, $where_values);      while ($action = db_fetch_object($result_db)) {        $actions[$action->aid] = $action->parameters ? unserialize($action->parameters) : array();        $actions[$action->aid]['callback'] = $action->callback;        $actions[$action->aid]['type'] = $action->type;      }    }    // Fire actions, in no particular order.    foreach ($actions as $action_id => $params) {      if (is_numeric($action_id)) { // Configurable actions need parameters.        $function = $params['callback'];        $context = array_merge($context, $params);        $result[$action_id] = $function($object, $context, $a1, $a2);      }      // Singleton action; $action_id is the function name.      else {        $result[$action_id] = $action_id($object, $context, $a1, $a2);      }    }  }  // Optimized execution of single action.  else {    // If it's a configurable action, retrieve stored parameters.    if (is_numeric($action_ids)) {      $action = db_fetch_object(db_query("SELECT * FROM {actions} WHERE aid = '%s'", $action_ids));      $function = $action->callback;      $context = array_merge($context, unserialize($action->parameters));      $result[$action_ids] = $function($object, $context, $a1, $a2);    }    // Singleton action; $action_ids is the function name.    else {      $result[$action_ids] = $action_ids($object, $context, $a1, $a2);    }  }  $stack--;  return $result;}/** * Discover all action functions by invoking hook_action_info(). * * @code * mymodule_action_info() { *   return array( *     'mymodule_functiondescription_action' => array( *       'type' => 'node', *       'description' => t('Save node'), *       'configurable' => FALSE, *       'hooks' => array( *         'nodeapi' => array('delete', 'insert', 'update', 'view'), *         'comment' => array('delete', 'insert', 'update', 'view'), *       ) *     ) *   ); * } * @endcode * * The description is used in presenting possible actions to the user for * configuration. The type is used to present these actions in a logical * grouping and to denote context. Some types are 'node', 'user', 'comment', * and 'system'. If an action is configurable it will provide form, * validation and submission functions. The hooks the action supports * are declared in the 'hooks' array. * * @param $reset *   Reset the action info static cache. * * @return *   An associative array keyed on function name. The value of each key is *   an array containing information about the action, such as type of *   action and description of the action, e.g., * *   @code *   $actions['node_publish_action'] = array( *     'type' => 'node', *     'description' => t('Publish post'), *     'configurable' => FALSE, *     'hooks' => array( *       'nodeapi' => array('presave', 'insert', 'update', 'view'), *       'comment' => array('delete', 'insert', 'update', 'view'), *     ), *   ); *   @endcode */function actions_list($reset = FALSE) {  static $actions;  if (!isset($actions) || $reset) {    $actions = module_invoke_all('action_info');    drupal_alter('action_info', $actions);  }  // See module_implements for explanations of this cast.  return (array)$actions;}/** * Retrieves all action instances from the database. * * Compare with actions_list(), which gathers actions by invoking * hook_action_info(). The actions returned by this function and the actions * returned by actions_list() are partially synchronized. Non-configurable * actions from hook_action_info() implementations are put into the database * when actions_synchronize() is called, which happens when * admin/settings/actions is visited. Configurable actions are not added to * the database until they are configured in the user interface, in which case * a database row is created for each configuration of each action. * * @return *   Associative array keyed by action ID. Each value is an *   associative array with keys 'callback', 'description', 'type' and *   'configurable'. */function actions_get_all_actions() {  $actions = array();  $result = db_query("SELECT * FROM {actions}");  while ($action = db_fetch_object($result)) {    $actions[$action->aid] = array(      'callback' => $action->callback,      'description' => $action->description,      'type' => $action->type,      'configurable' => (bool) $action->parameters,    );  }  return $actions;}/** * Create an associative array keyed by md5 hashes of function names. * * Hashes are used to prevent actual function names from going out into * HTML forms and coming back. * * @param $actions *   An associative array with function names as keys and associative *   arrays with keys 'description', 'type', etc. as values. Generally *   the output of actions_list() or actions_get_all_actions() is given *   as input to this function. * * @return *   An associative array keyed on md5 hash of function name. The value of *   each key is an associative array of function, description, and type *   for the action. */function actions_actions_map($actions) {  $actions_map = array();  foreach ($actions as $callback => $array) {    $key = md5($callback);    $actions_map[$key]['callback']     = isset($array['callback']) ? $array['callback'] : $callback;    $actions_map[$key]['description']  = $array['description'];    $actions_map[$key]['type']         = $array['type'];    $actions_map[$key]['configurable'] = $array['configurable'];  }  return $actions_map;}/** * Given an md5 hash of a function name, return the function name. * * Faster than actions_actions_map() when you only need the function name. * * @param $hash *   MD5 hash of a function name * * @return *   Function name */function actions_function_lookup($hash) {  $actions_list = actions_list();  foreach ($actions_list as $function => $array) {    if (md5($function) == $hash) {      return $function;    }  }  // Must be an instance; must check database.  $aid = db_result(db_query("SELECT aid FROM {actions} WHERE MD5(aid) = '%s' AND parameters <> ''", $hash));  return $aid;}/** * Synchronize actions that are provided by modules. * * They are synchronized with actions that are stored in the actions table. * This is necessary so that actions that do not require configuration can * receive action IDs. This is not necessarily the best approach, * but it is the most straightforward. */function actions_synchronize($actions_in_code = array(), $delete_orphans = FALSE) {  if (!$actions_in_code) {    $actions_in_code = actions_list(TRUE);  }  $actions_in_db = array();  $result = db_query("SELECT * FROM {actions} WHERE parameters = ''");  while ($action = db_fetch_object($result)) {    $actions_in_db[$action->callback] = array('aid' => $action->aid, 'description' => $action->description);  }  // Go through all the actions provided by modules.  foreach ($actions_in_code as $callback => $array) {    // Ignore configurable actions since their instances get put in    // when the user adds the action.    if (!$array['configurable']) {      // If we already have an action ID for this action, no need to assign aid.      if (array_key_exists($callback, $actions_in_db)) {        unset($actions_in_db[$callback]);      }      else {        // This is a new singleton that we don't have an aid for; assign one.        db_query("INSERT INTO {actions} (aid, type, callback, parameters, description) VALUES ('%s', '%s', '%s', '%s', '%s')", $callback, $array['type'], $callback, '', $array['description']);        watchdog('actions', "Action '%action' added.", array('%action' => filter_xss_admin($array['description'])));      }    }  }  // Any actions that we have left in $actions_in_db are orphaned.  if ($actions_in_db) {    $orphaned = array();    $placeholder = array();    foreach ($actions_in_db as $callback => $array) {      $orphaned[] = $callback;      $placeholder[] = "'%s'";    }    $orphans = implode(', ', $orphaned);    if ($delete_orphans) {      $placeholders = implode(', ', $placeholder);      $results = db_query("SELECT a.aid, a.description FROM {actions} a WHERE callback IN ($placeholders)", $orphaned);      while ($action = db_fetch_object($results)) {        actions_delete($action->aid);        watchdog('actions', "Removed orphaned action '%action' from database.", array('%action' => filter_xss_admin($action->description)));      }    }    else {      $link = l(t('Remove orphaned actions'), 'admin/settings/actions/orphan');      $count = count($actions_in_db);      watchdog('actions', format_plural($count, 'One orphaned action (%orphans) exists in the actions table. !link', '@count orphaned actions (%orphans) exist in the actions table. !link'), array('@count' => $count, '%orphans' => $orphans, '!link' => $link), WATCHDOG_WARNING);    }  }}/** * Save an action and its associated user-supplied parameter values to the database. * * @param $function *   The name of the function to be called when this action is performed. * @param $type *   The type of action, to describe grouping and/or context, e.g., 'node', *   'user', 'comment', or 'system'. * @param $params *   An associative array with parameter names as keys and parameter values *   as values. * @param $desc *   A user-supplied description of this particular action, e.g., 'Send *   e-mail to Jim'. * @param $aid *   The ID of this action. If omitted, a new action is created. * * @return *   The ID of the action. */function actions_save($function, $type, $params, $desc, $aid = NULL) {  $serialized = serialize($params);  if ($aid) {    db_query("UPDATE {actions} SET callback = '%s', type = '%s', parameters = '%s', description = '%s' WHERE aid = '%s'", $function, $type, $serialized, $desc, $aid);    watchdog('actions', 'Action %action saved.', array('%action' => $desc));  }  else {    // aid is the callback for singleton actions so we need to keep a    // separate table for numeric aids.    db_query('INSERT INTO {actions_aid} VALUES (default)');    $aid = db_last_insert_id('actions_aid', 'aid');    db_query("INSERT INTO {actions} (aid, callback, type, parameters, description) VALUES ('%s', '%s', '%s', '%s', '%s')", $aid, $function, $type, $serialized, $desc);    watchdog('actions', 'Action %action created.', array('%action' => $desc));  }  return $aid;}/** * Retrieve a single action from the database. * * @param $aid *   integer The ID of the action to retrieve. * * @return *   The appropriate action row from the database as an object. */function actions_load($aid) {  return db_fetch_object(db_query("SELECT * FROM {actions} WHERE aid = '%s'", $aid));}/** * Delete a single action from the database. * * @param $aid *   integer The ID of the action to delete. */function actions_delete($aid) {  db_query("DELETE FROM {actions} WHERE aid = '%s'", $aid);  module_invoke_all('actions_delete', $aid);}
<?php// $Id$/** * @file * Admin page callbacks for the statistics module. *//** * Menu callback; presents the "recent hits" page. */function statistics_recent_hits() {  $header = array(    array('data' => t('Timestamp'), 'field' => 'a.timestamp', 'sort' => 'desc'),    array('data' => t('Page'), 'field' => 'a.path'),    array('data' => t('User'), 'field' => 'u.name'),    array('data' => t('Operations'))  );  $sql = 'SELECT a.aid, a.path, a.title, a.uid, u.name, a.timestamp FROM {accesslog} a LEFT JOIN {users} u ON u.uid = a.uid'. tablesort_sql($header);  $result = pager_query($sql, 30);  $rows = array();  while ($log = db_fetch_object($result)) {    $rows[] = array(      array('data' => format_date($log->timestamp, 'small'), 'class' => 'nowrap'),      _statistics_format_item($log->title, $log->path),      theme('username', $log),      l(t('details'), "admin/reports/access/$log->aid"));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "top pages" page. */function statistics_top_pages() {  // MAX(title) avoids having empty node titles which otherwise causes duplicates in the top pages list  $sql = "SELECT COUNT(path) AS hits, path, MAX(title) AS title, AVG(timer) AS average_time, SUM(timer) AS total_time FROM {accesslog} GROUP BY path";  $sql_cnt = "SELECT COUNT(DISTINCT(path)) FROM {accesslog}";  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Page'), 'field' => 'path'),    array('data' => t('Average page generation time'), 'field' => 'average_time'),    array('data' => t('Total page generation time'), 'field' => 'total_time')  );  $sql .= tablesort_sql($header);  $result = pager_query($sql, 30, 0, $sql_cnt);  $rows = array();  while ($page = db_fetch_object($result)) {    $rows[] = array($page->hits, _statistics_format_item($page->title, $page->path), t('%time ms', array('%time' => round($page->average_time))), format_interval(round($page->total_time / 1000)));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  drupal_set_title(t('Top pages in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "top visitors" page. */function statistics_top_visitors() {  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Visitor'), 'field' => 'u.name'),    array('data' => t('Total page generation time'), 'field' => 'total'),    array('data' => t('Operations'))  );  $sql = "SELECT COUNT(a.uid) AS hits, a.uid, u.name, a.hostname, SUM(a.timer) AS total, ac.aid FROM {accesslog} a LEFT JOIN {access} ac ON ac.type = 'host' AND LOWER(a.hostname) LIKE (ac.mask) LEFT JOIN {users} u ON a.uid = u.uid GROUP BY a.hostname, a.uid, u.name, ac.aid". tablesort_sql($header);  $sql_cnt = "SELECT COUNT(DISTINCT(CONCAT(uid, hostname))) FROM {accesslog}";  $result = pager_query($sql, 30, 0, $sql_cnt);  $rows = array();  while ($account = db_fetch_object($result)) {    $qs = drupal_get_destination();    $ban_link = $account->aid ? l(t('unban'), "admin/user/rules/delete/$account->aid", array('query' => $qs)) : l(t('ban'), "admin/user/rules/add/$account->hostname/host", array('query' => $qs));    $rows[] = array($account->hits, ($account->uid ? theme('username', $account) : $account->hostname), format_interval(round($account->total / 1000)), $ban_link);  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  drupal_set_title(t('Top visitors in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "referrer" page. */function statistics_top_referrers() {  $query = "SELECT url, COUNT(url) AS hits, MAX(timestamp) AS last FROM {accesslog} WHERE url NOT LIKE '%%%s%%' AND url <> '' GROUP BY url";  $query_cnt = "SELECT COUNT(DISTINCT(url)) FROM {accesslog} WHERE url <> '' AND url NOT LIKE '%%%s%%'";  drupal_set_title(t('Top referrers in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Url'), 'field' => 'url'),    array('data' => t('Last visit'), 'field' => 'last'),  );  $query .= tablesort_sql($header);  $result = pager_query($query, 30, 0, $query_cnt, $_SERVER['HTTP_HOST']);  $rows = array();  while ($referrer = db_fetch_object($result)) {    $rows[] = array($referrer->hits, _statistics_link($referrer->url), t('@time ago', array('@time' => format_interval(time() - $referrer->last))));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 3));  }  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; Displays recent page accesses. */function statistics_access_log($aid) {  $result = db_query('SELECT a.*, u.name FROM {accesslog} a LEFT JOIN {users} u ON a.uid = u.uid WHERE aid = %d', $aid);  if ($access = db_fetch_object($result)) {    $rows[] = array(      array('data' => t('URL'), 'header' => TRUE),      l(url($access->path, array('absolute' => TRUE)), $access->path)    );    // It is safe to avoid filtering $access->title through check_plain because    // it comes from drupal_get_title().    $rows[] = array(      array('data' => t('Title'), 'header' => TRUE),      $access->title    );    $rows[] = array(      array('data' => t('Referrer'), 'header' => TRUE),      ($access->url ? l($access->url, $access->url) : '')    );    $rows[] = array(      array('data' => t('Date'), 'header' => TRUE),      format_date($access->timestamp, 'large')    );    $rows[] = array(      array('data' => t('User'), 'header' => TRUE),      theme('username', $access)    );    $rows[] = array(      array('data' => t('Hostname'), 'header' => TRUE),      check_plain($access->hostname)    );    return theme('table', array(), $rows);  }  else {    drupal_not_found();  }}/** * Form builder; Configure access logging. * * @ingroup forms * @see system_settings_form() */function statistics_access_logging_settings() {  // Access log settings:  $options = array('1' => t('Enabled'), '0' => t('Disabled'));  $form['access'] = array(    '#type' => 'fieldset',    '#title' => t('Access log settings'));  $form['access']['statistics_enable_access_log'] = array(    '#type' => 'radios',    '#title' => t('Enable access log'),    '#default_value' => variable_get('statistics_enable_access_log', 0),    '#options' => $options,    '#description' => t('Log each page access. Required for referrer statistics.'));  $period = drupal_map_assoc(array(3600, 10800, 21600, 32400, 43200, 86400, 172800, 259200, 604800, 1209600, 2419200, 4838400, 9676800), 'format_interval');  $form['access']['statistics_flush_accesslog_timer'] = array(    '#type' => 'select',    '#title' => t('Discard access logs older than'),    '#default_value'   => variable_get('statistics_flush_accesslog_timer', 259200),    '#options' => $period,    '#description' => t('Older access log entries (including referrer statistics) will be automatically discarded. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status'))));  // count content views settings  $form['content'] = array(    '#type' => 'fieldset',    '#title' => t('Content viewing counter settings'));  $form['content']['statistics_count_content_views'] = array(    '#type' => 'radios',    '#title' => t('Count content views'),    '#default_value' => variable_get('statistics_count_content_views', 0),    '#options' => $options,    '#description' => t('Increment a counter each time content is viewed.'));  return system_settings_form($form);}
<?php// $Id$/** * @file * Administrative page callbacks for the path module. *//** * Return a listing of all defined URL aliases. * When filter key passed, perform a standard search on the given key, * and return the list of matching URL aliases. */function path_admin_overview($keys = NULL) {  // Add the filter form above the overview table.  $output = drupal_get_form('path_admin_filter_form', $keys);  // Enable language column if locale is enabled or if we have any alias with language  $count = db_result(db_query("SELECT COUNT(*) FROM {url_alias} WHERE language != ''"));  $multilanguage = (module_exists('locale') || $count);  if ($keys) {    // Replace wildcards with MySQL/PostgreSQL wildcards.    $keys = preg_replace('!\*+!', '%', $keys);    $sql = "SELECT * FROM {url_alias} WHERE dst LIKE '%%%s%%'";  }  else {    $sql = 'SELECT * FROM {url_alias}';  }  $header = array(    array('data' => t('Alias'), 'field' => 'dst', 'sort' => 'asc'),    array('data' => t('System'), 'field' => 'src'),    array('data' => t('Operations'), 'colspan' => '2')  );  if ($multilanguage) {    $header[3] = $header[2];    $header[2] = array('data' => t('Language'), 'field' => 'language');  }  $sql .= tablesort_sql($header);  $result = pager_query($sql, 50, 0 , NULL, $keys);  $rows = array();  $destination = drupal_get_destination();  while ($data = db_fetch_object($result)) {    $row = array(check_plain($data->dst), check_plain($data->src), l(t('edit'), "admin/build/path/edit/$data->pid", array('query' => $destination)), l(t('delete'), "admin/build/path/delete/$data->pid", array('query' => $destination)));    if ($multilanguage) {      $row[4] = $row[3];      $row[3] = $row[2];      $row[2] = module_invoke('locale', 'language_name', $data->language);    }    $rows[] = $row;  }  if (empty($rows)) {    $empty_message = $keys ? t('No URL aliases found.') : t('No URL aliases available.') ;    $rows[] = array(array('data' => $empty_message, 'colspan' => ($multilanguage ? 5 : 4)));  }  $output .= theme('table', $header, $rows);  $output .= theme('pager', NULL, 50, 0);  return $output;}/** * Menu callback; handles pages for creating and editing URL aliases. */function path_admin_edit($pid = 0) {  if ($pid) {    $alias = path_load($pid);    drupal_set_title(check_plain($alias['dst']));    $output = drupal_get_form('path_admin_form', $alias);  }  else {    $output = drupal_get_form('path_admin_form');  }  return $output;}/** * Return a form for editing or creating an individual URL alias. * * @ingroup forms * @see path_admin_form_validate() * @see path_admin_form_submit() */function path_admin_form(&$form_state, $edit = array('src' => '', 'dst' => '', 'language' => '', 'pid' => NULL)) {  $form['#alias'] = $edit;  $form['src'] = array(    '#type' => 'textfield',    '#title' => t('Existing system path'),    '#default_value' => $edit['src'],    '#maxlength' => 128,    '#size' => 45,    '#description' => t('Specify the existing path you wish to alias. For example: node/28, forum/1, taxonomy/term/1+2.'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q='),    '#required' => TRUE,  );  $form['dst'] = array(    '#type' => 'textfield',    '#title' => t('Path alias'),    '#default_value' => $edit['dst'],    '#maxlength' => 128,    '#size' => 45,    '#description' => t('Specify an alternative path by which this data can be accessed. For example, type "about" when writing an about page. Use a relative path and don\'t add a trailing slash or the URL alias won\'t work.'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q='),    '#required' => TRUE,  );  // This will be a hidden value unless locale module is enabled  $form['language'] = array(    '#type' => 'value',    '#value' => $edit['language']  );  if ($edit['pid']) {    $form['pid'] = array('#type' => 'hidden', '#value' => $edit['pid']);    $form['submit'] = array('#type' => 'submit', '#value' => t('Update alias'));  }  else {    $form['submit'] = array('#type' => 'submit', '#value' => t('Create new alias'));  }  return $form;}/** * Verify that a new URL alias is valid */function path_admin_form_validate($form, &$form_state) {  $src = $form_state['values']['src'];  $dst = $form_state['values']['dst'];  $pid = isset($form_state['values']['pid']) ? $form_state['values']['pid'] : 0;  // Language is only set if locale module is enabled, otherwise save for all languages.  $language = isset($form_state['values']['language']) ? $form_state['values']['language'] : '';  if (db_result(db_query("SELECT COUNT(dst) FROM {url_alias} WHERE pid != %d AND dst = '%s' AND language = '%s'", $pid, $dst, $language))) {    form_set_error('dst', t('The alias %alias is already in use in this language.', array('%alias' => $dst)));  }  $item = menu_get_item($src);  if (!$item || !$item['access']) {    form_set_error('src', t("The path '@link_path' is either invalid or you do not have access to it.", array('@link_path' => $src)));  }}/** * Save a new URL alias to the database. */function path_admin_form_submit($form, &$form_state) {  // Language is only set if locale module is enabled  path_set_alias($form_state['values']['src'], $form_state['values']['dst'], isset($form_state['values']['pid']) ? $form_state['values']['pid'] : 0, isset($form_state['values']['language']) ? $form_state['values']['language'] : '');  drupal_set_message(t('The alias has been saved.'));  $form_state['redirect'] = 'admin/build/path';  return;}/** * Menu callback; confirms deleting an URL alias */function path_admin_delete_confirm($form_state, $pid) {  $path = path_load($pid);  if (user_access('administer url aliases')) {    $form['pid'] = array('#type' => 'value', '#value' => $pid);    $output = confirm_form($form,      t('Are you sure you want to delete path alias %title?', array('%title' => $path['dst'])),      isset($_GET['destination']) ? $_GET['destination'] : 'admin/build/path');  }  return $output;}/** * Execute URL alias deletion */function path_admin_delete_confirm_submit($form, &$form_state) {  if ($form_state['values']['confirm']) {    path_admin_delete($form_state['values']['pid']);    $form_state['redirect'] = 'admin/build/path';    return;  }}/** * Return a form to filter URL aliases. * * @ingroup forms * @see path_admin_filter_form_submit() */function path_admin_filter_form(&$form_state, $keys = '') {  $form['#attributes'] = array('class' => 'search-form');  $form['basic'] = array('#type' => 'fieldset',    '#title' => t('Filter aliases')  );  $form['basic']['inline'] = array('#prefix' => '<div class="container-inline">', '#suffix' => '</div>');  $form['basic']['inline']['filter'] = array(    '#type' => 'textfield',    '#title' => '',    '#default_value' => $keys,    '#maxlength' => 128,    '#size' => 25,  );  $form['basic']['inline']['submit'] = array(    '#type' => 'submit',    '#value' => t('Filter'),    '#submit' => array('path_admin_filter_form_submit_filter'),    );  if ($keys) {    $form['basic']['inline']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset'),      '#submit' => array('path_admin_filter_form_submit_reset'),    );  }  return $form;}/** * Process filter form submission when the Filter button is pressed. */function path_admin_filter_form_submit_filter($form, &$form_state) {  $form_state['redirect'] = 'admin/build/path/list/'. trim($form_state['values']['filter']);}/** * Process filter form submission when the Reset button is pressed. */function path_admin_filter_form_submit_reset($form, &$form_state) {  $form_state['redirect'] = 'admin/build/path/list';}/** * Helper function for grabbing filter keys. */function path_admin_filter_get_keys() {  // Extract keys as remainder of path  $path = explode('/', $_GET['q'], 5);  return count($path) == 5 ? $path[4] : '';}
<?php// $Id$/** * @file * Enables functions to be stored and executed at a later time when * triggered by other modules or by one of Drupal's core API hooks. *//** * Implementation of hook_help(). */function trigger_help($path, $arg) {  $explanation = '<p>'. t('Triggers are system events, such as when new content is added or when a user logs in. Trigger module combines these triggers with actions (functional tasks), such as unpublishing content or e-mailing an administrator. The <a href="@url">Actions settings page</a> contains a list of existing actions and provides the ability to create and configure additional actions.', array('@url' => url('admin/settings/actions'))) .'</p>';  switch ($path) {    case 'admin/build/trigger/comment':      return $explanation .'<p>'. t('Below you can assign actions to run when certain comment-related triggers happen. For example, you could promote a post to the front page when a comment is added.') .'</p>';    case 'admin/build/trigger/node':      return $explanation .'<p>'. t('Below you can assign actions to run when certain content-related triggers happen. For example, you could send an e-mail to an administrator when a post is created or updated.') .'</p>';    case 'admin/build/trigger/cron':      return $explanation .'<p>'. t('Below you can assign actions to run during each pass of a <a href="@cron">cron maintenance task</a>.', array('@cron' => url('admin/reports/status'))) .'</p>';    case 'admin/build/trigger/taxonomy':      return $explanation .'<p>'. t('Below you can assign actions to run when certain taxonomy-related triggers happen. For example, you could send an e-mail to an administrator when a term is deleted.') .'</p>';    case 'admin/build/trigger/user':      return $explanation .'<p>'. t("Below you can assign actions to run when certain user-related triggers happen. For example, you could send an e-mail to an administrator when a user account is deleted.") .'</p>';    case 'admin/help#trigger':      $output = '<p>'. t('The Trigger module provides the ability to trigger <a href="@actions">actions</a> upon system events, such as when new content is added or when a user logs in.', array('@actions' => url('admin/settings/actions'))) .'</p>';      $output .= '<p>'. t('The combination of actions and triggers can perform many useful tasks, such as e-mailing an administrator if a user account is deleted, or automatically unpublishing comments that contain certain words. By default, there are five "contexts" of events (Comments, Content, Cron, Taxonomy, and Users), but more may be added by additional modules.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@trigger">Trigger module</a>.', array('@trigger' => 'http://drupal.org/handbook/modules/trigger/')) .'</p>';      return $output;  }}/** * Implementation of hook_menu(). */function trigger_menu() {  $items['admin/build/trigger'] = array(    'title' => 'Triggers',    'description' => 'Tell Drupal when to execute actions.',    'page callback' => 'trigger_assign',    'access callback' => 'trigger_access_check',    'access arguments' => array('node'),    'file' => 'trigger.admin.inc',  );  // We don't use a menu wildcard here because these are tabs,  // not invisible items.  $items['admin/build/trigger/node'] = array(    'title' => 'Content',    'page callback' => 'trigger_assign',    'page arguments' => array('node'),    'access callback' => 'trigger_access_check',    'access arguments' => array('node'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/user'] = array(    'title' => 'Users',    'page callback' => 'trigger_assign',    'page arguments' => array('user'),    'access callback' => 'trigger_access_check',    'access arguments' => array('user'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/comment'] = array(    'title' => 'Comments',    'page callback' => 'trigger_assign',    'page arguments' => array('comment'),    'access callback' => 'trigger_access_check',    'access arguments' => array('comment'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/taxonomy'] = array(    'title' => 'Taxonomy',    'page callback' => 'trigger_assign',    'page arguments' => array('taxonomy'),    'access callback' => 'trigger_access_check',    'access arguments' => array('taxonomy'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/cron'] = array(    'title' => 'Cron',    'page callback' => 'trigger_assign',    'page arguments' => array('cron'),    'access arguments' => array('administer actions'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  // We want contributed modules to be able to describe  // their hooks and have actions assignable to them.  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $hook) {    // We've already done these.    if (in_array($module, array('node', 'comment', 'user', 'system', 'taxonomy'))) {      continue;    }    $info = db_result(db_query("SELECT info FROM {system} WHERE name = '%s'", $module));    $info = unserialize($info);    $nice_name = $info['name'];    $items["admin/build/trigger/$module"] = array(      'title' => $nice_name,      'page callback' => 'trigger_assign',      'page arguments' => array($module),      'access arguments' => array($module),      'type' => MENU_LOCAL_TASK,      'file' => 'trigger.admin.inc',    );  }  $items['admin/build/trigger/unassign'] = array(    'title' => 'Unassign',    'description' => 'Unassign an action from a trigger.',    'page callback' => 'drupal_get_form',    'page arguments' => array('trigger_unassign'),    'access arguments' => array('administer actions'),    'type' => MENU_CALLBACK,    'file' => 'trigger.admin.inc',  );  return $items;}/** * Access callback for menu system. */function trigger_access_check($module) {  return (module_exists($module) && user_access('administer actions'));}/** * Get the aids of actions to be executed for a hook-op combination. * * @param $hook *   The name of the hook being fired. * @param $op *   The name of the operation being executed. Defaults to an empty string *   because some hooks (e.g., hook_cron()) do not have operations. * @return *   An array of action IDs. */function _trigger_get_hook_aids($hook, $op = '') {  $aids = array();  $result = db_query("SELECT aa.aid, a.type FROM {trigger_assignments} aa LEFT JOIN {actions} a ON aa.aid = a.aid WHERE aa.hook = '%s' AND aa.op = '%s' ORDER BY weight", $hook, $op);  while ($action = db_fetch_object($result)) {    $aids[$action->aid]['type'] = $action->type;  }  return $aids;}/** * Implementation of hook_theme(). */function trigger_theme() {  return array(    'trigger_display' => array(      'arguments' => array('element'),      'file' => 'trigger.admin.inc',    ),  );}/** * Implementation of hook_forms(). We reuse code by using the * same assignment form definition for each node-op combination. */function trigger_forms() {  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $info) {    foreach ($hooks[$module] as $hook => $ops) {      foreach ($ops as $op => $description) {        $forms['trigger_'. $hook .'_'. $op .'_assign_form'] = array('callback' => 'trigger_assign_form');      }    }  }  return $forms;}/** * When an action is called in a context that does not match its type, * the object that the action expects must be retrieved. For example, when * an action that works on users is called during the node hook, the * user object is not available since the node hook doesn't pass it. * So here we load the object the action expects. * * @param $type *   The type of action that is about to be called. * @param $node *   The node that was passed via the nodeapi hook. * @return *   The object expected by the action that is about to be called. */function _trigger_normalize_node_context($type, $node) {  switch ($type) {    // If an action that works on comments is being called in a node context,    // the action is expecting a comment object. But we do not know which comment    // to give it. The first? The most recent? All of them? So comment actions    // in a node context are not supported.    // An action that works on users is being called in a node context.    // Load the user object of the node's author.    case 'user':      return user_load(array('uid' => $node->uid));  }}/** * Implementation of hook_nodeapi(). */function trigger_nodeapi(&$node, $op, $a3, $a4) {  // Keep objects for reuse so that changes actions make to objects can persist.  static $objects;  // Prevent recursion by tracking which operations have already been called.  static $recursion;  // Support a subset of operations.  if (!in_array($op, array('view', 'update', 'presave', 'insert', 'delete')) || isset($recursion[$op])) {    return;  }  $recursion[$op] = TRUE;  $aids = _trigger_get_hook_aids('nodeapi', $op);  if (!$aids) {    return;  }  $context = array(    'hook' => 'nodeapi',    'op' => $op,  );  // We need to get the expected object if the action's type is not 'node'.  // We keep the object in $objects so we can reuse it if we have multiple actions  // that make changes to an object.  foreach ($aids as $aid => $action_info) {    if ($action_info['type'] != 'node') {      if (!isset($objects[$action_info['type']])) {        $objects[$action_info['type']] = _trigger_normalize_node_context($action_info['type'], $node);      }      // Since we know about the node, we pass that info along to the action.      $context['node'] = $node;      $result = actions_do($aid, $objects[$action_info['type']], $context, $a3, $a4);    }    else {      actions_do($aid, $node, $context, $a3, $a4);    }  }}/** * When an action is called in a context that does not match its type, * the object that the action expects must be retrieved. For example, when * an action that works on nodes is called during the comment hook, the * node object is not available since the comment hook doesn't pass it. * So here we load the object the action expects. * * @param $type *   The type of action that is about to be called. * @param $comment *   The comment that was passed via the comment hook. * @return *   The object expected by the action that is about to be called. */function _trigger_normalize_comment_context($type, $comment) {  switch ($type) {    // An action that works with nodes is being called in a comment context.    case 'node':      return node_load(is_array($comment) ? $comment['nid'] : $comment->nid);    // An action that works on users is being called in a comment context.    case 'user':      return user_load(array('uid' => is_array($comment) ? $comment['uid'] : $comment->uid));  }}/** * Implementation of hook_comment(). */function trigger_comment($a1, $op) {  // Keep objects for reuse so that changes actions make to objects can persist.  static $objects;  // We support a subset of operations.  if (!in_array($op, array('insert', 'update', 'delete', 'view'))) {    return;  }  $aids = _trigger_get_hook_aids('comment', $op);  $context = array(    'hook' => 'comment',    'op' => $op,  );  // We need to get the expected object if the action's type is not 'comment'.  // We keep the object in $objects so we can reuse it if we have multiple actions  // that make changes to an object.  foreach ($aids as $aid => $action_info) {    if ($action_info['type'] != 'comment') {      if (!isset($objects[$action_info['type']])) {        $objects[$action_info['type']] = _trigger_normalize_comment_context($action_info['type'], $a1);      }      // Since we know about the comment, we pass it along to the action      // in case it wants to peek at it.      $context['comment'] = (object) $a1;      actions_do($aid, $objects[$action_info['type']], $context);    }    else {      $comment = (object) $a1;      actions_do($aid, $comment, $context);    }  }}/** * Implementation of hook_cron(). */function trigger_cron() {  $aids = _trigger_get_hook_aids('cron', 'run');  $context = array(    'hook' => 'cron',    'op' => 'run',  );  // Cron does not act on any specific object.  $object = NULL;  actions_do(array_keys($aids), $object, $context);}/** * When an action is called in a context that does not match its type, * the object that the action expects must be retrieved. For example, when * an action that works on nodes is called during the user hook, the * node object is not available since the user hook doesn't pass it. * So here we load the object the action expects. * * @param $type *   The type of action that is about to be called. * @param $account *   The account object that was passed via the user hook. * @return *   The object expected by the action that is about to be called. */function _trigger_normalize_user_context($type, $account) {  switch ($type) {    // If an action that works on comments is being called in a user context,    // the action is expecting a comment object. But we have no way of    // determining the appropriate comment object to pass. So comment    // actions in a user context are not supported.    // An action that works with nodes is being called in a user context.    // If a single node is being viewed, return the node.    case 'node':      // If we are viewing an individual node, return the node.      if ((arg(0) == 'node') && is_numeric(arg(1)) && (arg(2) == NULL)) {        return node_load(array('nid' => arg(1)));      }  }}/** * Implementation of hook_user(). */function trigger_user($op, &$edit, &$account, $category = NULL) {  // Keep objects for reuse so that changes actions make to objects can persist.  static $objects;  // We support a subset of operations.  if (!in_array($op, array('login', 'logout', 'insert', 'update', 'delete', 'view'))) {    return;  }  $aids = _trigger_get_hook_aids('user', $op);  $context = array(    'hook' => 'user',    'op' => $op,    'form_values' => &$edit,  );  foreach ($aids as $aid => $action_info) {    if ($action_info['type'] != 'user') {      if (!isset($objects[$action_info['type']])) {        $objects[$action_info['type']] = _trigger_normalize_user_context($action_info['type'], $account);      }      $context['account'] = $account;      actions_do($aid, $objects[$action_info['type']], $context);    }    else {      actions_do($aid, $account, $context, $category);    }  }}/** * Implementation of hook_taxonomy(). */function trigger_taxonomy($op, $type, $array) {  if ($type != 'term') {    return;  }  $aids = _trigger_get_hook_aids('taxonomy', $op);  $context = array(    'hook' => 'taxonomy',    'op' => $op  );  foreach ($aids as $aid => $action_info) {    $taxonomy_object = (object) $array;    actions_do($aid, $taxonomy_object, $context);  }}/** * Often we generate a select field of all actions. This function * generates the options for that select. * * @param $type *   One of 'node', 'user', 'comment'. * @return *   Array keyed by action ID. */function trigger_options($type = 'all') {  $options = array(t('Choose an action'));  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {    $options[$action['type']][$aid] = $action['description'];  }  if ($type == 'all') {    return $options;  }  else {    return $options[$type];  }}/** * Implementation of hook_actions_delete(). * * Remove all trigger entries for the given action, when deleted. */function trigger_actions_delete($aid) {  db_query("DELETE FROM {trigger_assignments} WHERE aid = '%s'", $aid);}
<?php// $Id$/** * Sets the body-tag class attribute. * * Adds 'sidebar-left', 'sidebar-right' or 'sidebars' classes as needed. */function phptemplate_body_class($left, $right) {  if ($left != '' && $right != '') {    $class = 'sidebars';  }  else {    if ($left != '') {      $class = 'sidebar-left';    }    if ($right != '') {      $class = 'sidebar-right';    }  }  if (isset($class)) {    print ' class="'. $class .'"';  }}/** * Return a themed breadcrumb trail. * * @param $breadcrumb *   An array containing the breadcrumb links. * @return a string containing the breadcrumb output. */function phptemplate_breadcrumb($breadcrumb) {  if (!empty($breadcrumb)) {    return '<div class="breadcrumb">'. implode('  ', $breadcrumb) .'</div>';  }}/** * Override or insert PHPTemplate variables into the templates. */function phptemplate_preprocess_page(&$vars) {  $vars['tabs2'] = menu_secondary_local_tasks();  // Hook into color.module  if (module_exists('color')) {    _color_page_alter($vars);  }}/** * Add a "Comments" heading above comments except on forum pages. */function garland_preprocess_comment_wrapper(&$vars) {  if ($vars['content'] && $vars['node']->type != 'forum') {    $vars['content'] = '<h2 class="comments">'. t('Comments') .'</h2>'.  $vars['content'];  }}/** * Returns the rendered local tasks. The default implementation renders * them as tabs. Overridden to split the secondary tasks. * * @ingroup themeable */function phptemplate_menu_local_tasks() {  return menu_primary_local_tasks();}function phptemplate_comment_submitted($comment) {  return t('!datetime  !username',    array(      '!username' => theme('username', $comment),      '!datetime' => format_date($comment->timestamp)    ));}function phptemplate_node_submitted($node) {  return t('!datetime  !username',    array(      '!username' => theme('username', $node),      '!datetime' => format_date($node->created),    ));}/** * Generates IE CSS links for LTR and RTL languages. */function phptemplate_get_ie_styles() {  global $language;  $iecss = '<link type="text/css" rel="stylesheet" media="all" href="'. base_path() . path_to_theme() .'/fix-ie.css" />';  if ($language->direction == LANGUAGE_RTL) {    $iecss .= '<style type="text/css" media="all">@import "'. base_path() . path_to_theme() .'/fix-ie-rtl.css";</style>';  }  return $iecss;}
<?php// $Id$/** * @file book-navigation.tpl.php * Default theme implementation to navigate books. Presented under nodes that * are a part of book outlines. * * Available variables: * - $tree: The immediate children of the current node rendered as an *   unordered list. * - $current_depth: Depth of the current node within the book outline. *   Provided for context. * - $prev_url: URL to the previous node. * - $prev_title: Title of the previous node. * - $parent_url: URL to the parent node. * - $parent_title: Title of the parent node. Not printed by default. Provided *   as an option. * - $next_url: URL to the next node. * - $next_title: Title of the next node. * - $has_links: Flags TRUE whenever the previous, parent or next data has a *   value. * - $book_id: The book ID of the current outline being viewed. Same as the *   node ID containing the entire outline. Provided for context. * - $book_url: The book/node URL of the current outline being viewed. *   Provided as an option. Not used by default. * - $book_title: The book/node title of the current outline being viewed. *   Provided as an option. Not used by default. * * @see template_preprocess_book_navigation() */?><?php if ($tree || $has_links): ?>  <div id="book-navigation-<?php print $book_id; ?>" class="book-navigation">    <?php print $tree; ?>    <?php if ($has_links): ?>    <div class="page-links clear-block">      <?php if ($prev_url) : ?>        <a href="<?php print $prev_url; ?>" class="page-previous" title="<?php print t('Go to previous page'); ?>"><?php print t(' ') . $prev_title; ?></a>      <?php endif; ?>      <?php if ($parent_url) : ?>        <a href="<?php print $parent_url; ?>" class="page-up" title="<?php print t('Go to parent page'); ?>"><?php print t('up'); ?></a>      <?php endif; ?>      <?php if ($next_url) : ?>        <a href="<?php print $next_url; ?>" class="page-next" title="<?php print t('Go to next page'); ?>"><?php print $next_title . t(' '); ?></a>      <?php endif; ?>    </div>    <?php endif; ?>  </div><?php endif; ?>
<?php// $Id$/** * @file * Admin page callbacks for the help module. *//** * Menu callback; prints a page listing a glossary of Drupal terminology. */function help_main() {  // Add CSS  drupal_add_css(drupal_get_path('module', 'help') .'/help.css', 'module', 'all', FALSE);  $output = '<h2>'. t('Help topics') .'</h2><p>'. t('Help is available on the following items:') .'</p>'. help_links_as_list();  return $output;}/** * Menu callback; prints a page listing general help for a module. */function help_page($name) {  $output = '';  if (module_hook($name, 'help')) {    $module = drupal_parse_info_file(drupal_get_path('module', $name) .'/'. $name .'.info');    drupal_set_title($module['name']);    $temp = module_invoke($name, 'help', "admin/help#$name", drupal_help_arg());    if (empty($temp)) {      $output .= t("No help is available for module %module.", array('%module' => $module['name']));    }    else {      $output .= $temp;    }    // Only print list of administration pages if the module in question has    // any such pages associated to it.    $admin_tasks = system_get_module_admin_tasks($name);    if (!empty($admin_tasks)) {      ksort($admin_tasks);      $output .= theme('item_list', $admin_tasks, t('@module administration pages', array('@module' => $module['name'])));    }  }  return $output;}function help_links_as_list() {  $empty_arg = drupal_help_arg();  $module_info = module_rebuild_cache();  $modules = array();  foreach (module_implements('help', TRUE) as $module) {    if (module_invoke($module, 'help', "admin/help#$module", $empty_arg)) {      $modules[$module] = $module_info[$module]->info['name'];    }  }  asort($modules);  // Output pretty four-column list  $count = count($modules);  $break = ceil($count / 4);  $output = '<div class="clear-block"><div class="help-items"><ul>';  $i = 0;  foreach ($modules as $module => $name) {    $output .= '<li>'. l($name, 'admin/help/'. $module) .'</li>';    if (($i + 1) % $break == 0 && ($i + 1) != $count) {      $output .= '</ul></div><div class="help-items'. ($i + 1 == $break * 3 ? ' help-items-last' : '') .'"><ul>';    }    $i++;  }  $output .= '</ul></div></div>';  return $output;}
<?php// $Id$/** * @file * Enables tracking of recent posts for users. *//** * Implementation of hook_help(). */function tracker_help($path, $arg) {  switch ($path) {    case 'admin/help#tracker':      $output = '<p>'. t('The tracker module displays the most recently added or updated content on your site, and provides user-level tracking to follow the contributions of particular authors.') .'</p>';      $output .= '<p>'. t("The <em>Recent posts</em> page is available via a link in the navigation menu block and displays new and recently-updated content (including the content type, the title, the author's name, number of comments, and time of last update) in reverse chronological order. Posts are marked updated when changes occur in the text, or when new comments are added. To use the tracker module to follow a specific user's contributions, select the <em>Track</em> tab from the user's profile page.") .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@tracker">Tracker module</a>.', array('@tracker' => 'http://drupal.org/handbook/modules/tracker/')) .'</p>';      return $output;  }}/** * Implementation of hook_menu(). */function tracker_menu() {  $items['tracker'] = array(    'title' => 'Recent posts',    'page callback' => 'tracker_page',    'access arguments' => array('access content'),    'weight' => 1,    'file' => 'tracker.pages.inc',  );  $items['tracker/all'] = array(    'title' => 'All recent posts',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['tracker/%user_uid_optional'] = array(    'title' => 'My recent posts',    'access callback' => '_tracker_myrecent_access',    'access arguments' => array(1),    'page arguments' => array(1),    'type' => MENU_LOCAL_TASK,  );  $items['user/%user/track'] = array(    'title' => 'Track',    'page callback' => 'tracker_page',    'page arguments' => array(1, TRUE),    'access callback' => '_tracker_user_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'file' => 'tracker.pages.inc',  );  $items['user/%user/track/posts'] = array(    'title' => 'Track posts',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  return $items;}/** * Access callback for tracker/%user_uid_optional */function _tracker_myrecent_access($account) {  // This path is only allowed for authenticated users looking at their own posts.  return $account->uid && ($GLOBALS['user']->uid == $account->uid) && user_access('access content');}/** * Access callback for user/%user/track */function _tracker_user_access($account) {  return user_view_access($account) && user_access('access content');}
<?php// $Id$/** * @file * Administrative page callbacks for the profile module. *//** * Form builder to display a listing of all editable profile fields. * * @ingroup forms * @see profile_admin_overview_submit() */function profile_admin_overview() {  $result = db_query('SELECT title, name, type, category, fid, weight FROM {profile_fields} ORDER BY category, weight');  $form = array();  $categories = array();  while ($field = db_fetch_object($result)) {    // Collect all category information    $categories[] = $field->category;    // Save all field information    $form[$field->fid]['name'] = array('#value' => check_plain($field->name));    $form[$field->fid]['title'] = array('#value' => check_plain($field->title));    $form[$field->fid]['type'] = array('#value' => $field->type);    $form[$field->fid]['category'] = array('#type' => 'select', '#default_value' => $field->category, '#options' => array());    $form[$field->fid]['weight'] = array('#type' => 'weight', '#default_value' => $field->weight);    $form[$field->fid]['edit'] = array('#value' => l(t('edit'), "admin/user/profile/edit/$field->fid"));    $form[$field->fid]['delete'] = array('#value' => l(t('delete'), "admin/user/profile/delete/$field->fid"));  }  // Add the cateogory combo boxes  $categories = array_unique($categories);  foreach ($form as $fid => $field) {    foreach ($categories as $cat => $category) {      $form[$fid]['category']['#options'][$category] = $category;    }  }  // Display the submit button only when there's more than one field  if (count($form) > 1) {    $form['submit'] = array('#type' => 'submit', '#value' => t('Save configuration'));  }  else {    // Disable combo boxes when there isn't a submit button    foreach ($form as $fid => $field) {      unset($form[$fid]['weight']);      $form[$fid]['category']['#type'] = 'value';    }  }  $form['#tree'] = TRUE;  $addnewfields = '<h2>'. t('Add new field') .'</h2>';  $addnewfields .= '<ul>';  foreach (_profile_field_types() as $key => $value) {    $addnewfields .= '<li>'. l($value, "admin/user/profile/add/$key") .'</li>';  }  $addnewfields .= '</ul>';  $form['addnewfields'] = array('#value' => $addnewfields);  return $form;}/** * Submit handler to update changed profile field weights and categories. * * @see profile_admin_overview() */function profile_admin_overview_submit($form, &$form_state) {  foreach (element_children($form_state['values']) as $fid) {    if (is_numeric($fid)) {      $weight = $form_state['values'][$fid]['weight'];      $category = $form_state['values'][$fid]['category'];      if ($weight != $form[$fid]['weight']['#default_value'] || $category != $form[$fid]['category']['#default_value']) {        db_query("UPDATE {profile_fields} SET weight = %d, category = '%s' WHERE fid = %d", $weight, $category, $fid);      }    }  }  drupal_set_message(t('Profile fields have been updated.'));  cache_clear_all();  menu_rebuild();}/** * Theme the profile field overview into a drag and drop enabled table. * * @ingroup themeable * @see profile_admin_overview() */function theme_profile_admin_overview($form) {  drupal_add_css(drupal_get_path('module', 'profile') .'/profile.css');  // Add javascript if there's more than one field.  if (isset($form['submit'])) {    drupal_add_js(drupal_get_path('module', 'profile') .'/profile.js');  }  $rows = array();  $categories = array();  $category_number = 0;  foreach (element_children($form) as $key) {    // Don't take form control structures.    if (array_key_exists('category', $form[$key])) {      $field = &$form[$key];      $category = $field['category']['#default_value'];      if (!isset($categories[$category])) {        // Category classes are given numeric IDs because there's no guarantee        // class names won't contain invalid characters.        $categories[$category] = $category_number;        $category_field['#attributes']['class'] = 'profile-category profile-category-'. $category_number;        $rows[] = array(array('data' => $category, 'colspan' => 7, 'class' => 'category'));        $rows[] = array('data' => array(array('data' => '<em>'. t('No fields in this category. If this category remains empty when saved, it will be removed.') .'</em>', 'colspan' => 7)), 'class' => 'category-'. $category_number .'-message category-message category-populated');        // Make it dragable only if there is more than one field        if (isset($form['submit'])) {          drupal_add_tabledrag('profile-fields', 'order', 'sibling', 'profile-weight', 'profile-weight-'. $category_number);          drupal_add_tabledrag('profile-fields', 'match', 'sibling', 'profile-category', 'profile-category-'. $category_number);        }        $category_number++;      }      // Add special drag and drop classes that group fields together.      $field['weight']['#attributes']['class'] = 'profile-weight profile-weight-'. $categories[$category];      $field['category']['#attributes']['class'] = 'profile-category profile-category-'. $categories[$category];      // Add the row      $row = array();      $row[] = drupal_render($field['title']);      $row[] = drupal_render($field['name']);      $row[] = drupal_render($field['type']);      if (isset($form['submit'])) {        $row[] = drupal_render($field['category']);        $row[] = drupal_render($field['weight']);      }      $row[] = drupal_render($field['edit']);      $row[] = drupal_render($field['delete']);      $rows[] = array('data' => $row, 'class' => 'draggable');    }  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No fields available.'), 'colspan' => 7));  }  $header = array(t('Title'), t('Name'), t('Type'));  if (isset($form['submit'])) {    $header[] = t('Category');    $header[] = t('Weight');  }  $header[] = array('data' => t('Operations'), 'colspan' => 2);  $output = theme('table', $header, $rows, array('id' => 'profile-fields'));  $output .= drupal_render($form);  return $output;}/** * Menu callback: Generate a form to add/edit a user profile field. * * @ingroup forms * @see profile_field_form_validate() * @see profile_field_form_submit() */function profile_field_form(&$form_state, $arg = NULL) {  if (arg(3) == 'edit') {    if (is_numeric($arg)) {      $fid = $arg;      $edit = db_fetch_array(db_query('SELECT * FROM {profile_fields} WHERE fid = %d', $fid));      if (!$edit) {        drupal_not_found();        return;      }      drupal_set_title(t('edit %title', array('%title' => $edit['title'])));      $form['fid'] = array('#type' => 'value',        '#value' => $fid,      );      $type = $edit['type'];    }    else {      drupal_not_found();      return;    }  }  else {    $types = _profile_field_types();    if (!isset($types[$arg])) {      drupal_not_found();      return;    }    $type = $arg;    drupal_set_title(t('add new %type', array('%type' => $types[$type])));    $edit = array('name' => 'profile_');    $form['type'] = array('#type' => 'value', '#value' => $type);  }  $edit += array(    'category' => '',    'title' => '',    'explanation' => '',    'weight' => 0,    'page' => '',    'autocomplete' => '',    'required' => '',    'register' => '',  );  $form['fields'] = array('#type' => 'fieldset',    '#title' => t('Field settings'),  );  $form['fields']['category'] = array('#type' => 'textfield',    '#title' => t('Category'),    '#default_value' => $edit['category'],    '#autocomplete_path' => 'admin/user/profile/autocomplete',    '#description' => t('The category the new field should be part of. Categories are used to group fields logically. An example category is "Personal information".'),    '#required' => TRUE,  );  $form['fields']['title'] = array('#type' => 'textfield',    '#title' => t('Title'),    '#default_value' => $edit['title'],    '#description' => t('The title of the new field. The title will be shown to the user. An example title is "Favorite color".'),    '#required' => TRUE,  );  $form['fields']['name'] = array('#type' => 'textfield',    '#title' => t('Form name'),    '#default_value' => $edit['name'],    '#description' => t('The name of the field. The form name is not shown to the user but used internally in the HTML code and URLs.Unless you know what you are doing, it is highly recommended that you prefix the form name with <code>profile_</code> to avoid name clashes with other fields. Spaces or any other special characters except dash (-) and underscore (_) are not allowed. An example name is "profile_favorite_color" or perhaps just "profile_color".'),    '#required' => TRUE,  );  $form['fields']['explanation'] = array('#type' => 'textarea',    '#title' => t('Explanation'),    '#default_value' => $edit['explanation'],    '#description' => t('An optional explanation to go with the new field. The explanation will be shown to the user.'),  );  if ($type == 'selection') {    $form['fields']['options'] = array('#type' => 'textarea',      '#title' => t('Selection options'),      '#default_value' => isset($edit['options']) ? $edit['options'] : '',      '#description' => t('A list of all options. Put each option on a separate line. Example options are "red", "blue", "green", etc.'),    );  }  $form['fields']['visibility'] = array('#type' => 'radios',    '#title' => t('Visibility'),    '#default_value' => isset($edit['visibility']) ? $edit['visibility'] : PROFILE_PUBLIC,    '#options' => array(PROFILE_HIDDEN => t('Hidden profile field, only accessible by administrators, modules and themes.'), PROFILE_PRIVATE => t('Private field, content only available to privileged users.'), PROFILE_PUBLIC => t('Public field, content shown on profile page but not used on member list pages.'), PROFILE_PUBLIC_LISTINGS => t('Public field, content shown on profile page and on member list pages.')),  );  if ($type == 'selection' || $type == 'list' || $type == 'textfield') {    $form['fields']['page'] = array('#type' => 'textfield',      '#title' => t('Page title'),      '#default_value' => $edit['page'],      '#description' => t('To enable browsing this field by value, enter a title for the resulting page. The word <code>%value</code> will be substituted with the corresponding value. An example page title is "People whose favorite color is %value". This is only applicable for a public field.'),    );  }  else if ($type == 'checkbox') {    $form['fields']['page'] = array('#type' => 'textfield',      '#title' => t('Page title'),      '#default_value' => $edit['page'],      '#description' => t('To enable browsing this field by value, enter a title for the resulting page. An example page title is "People who are employed". This is only applicable for a public field.'),    );  }  $form['fields']['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('The weights define the order in which the form fields are shown. Lighter fields "float up" towards the top of the category.'),  );  $form['fields']['autocomplete'] = array('#type' => 'checkbox',    '#title' => t('Form will auto-complete while user is typing.'),    '#default_value' => $edit['autocomplete'],    '#description' => t('For security, auto-complete will be disabled if the user does not have access to user profiles.'),  );  $form['fields']['required'] = array('#type' => 'checkbox',    '#title' => t('The user must enter a value.'),    '#default_value' => $edit['required'],  );  $form['fields']['register'] = array('#type' => 'checkbox',    '#title' => t('Visible in user registration form.'),    '#default_value' => $edit['register'],  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Save field'),  );  return $form;}/** * Validate profile_field_form submissions. */function profile_field_form_validate($form, &$form_state) {  // Validate the 'field name':  if (preg_match('/[^a-zA-Z0-9_-]/', $form_state['values']['name'])) {    form_set_error('name', t('The specified form name contains one or more illegal characters. Spaces or any other special characters except dash (-) and underscore (_) are not allowed.'));  }  if (in_array($form_state['values']['name'], user_fields())) {    form_set_error('name', t('The specified form name is reserved for use by Drupal.'));  }  // Validate the category:  if (!$form_state['values']['category']) {    form_set_error('category', t('You must enter a category.'));  }  if (strtolower($form_state['values']['category']) == 'account') {    form_set_error('category', t('The specified category name is reserved for use by Drupal.'));  }  $args1 = array($form_state['values']['title'], $form_state['values']['category']);  $args2 = array($form_state['values']['name']);  $query_suffix = '';  if (isset($form_state['values']['fid'])) {    $args1[] = $args2[] = $form_state['values']['fid'];    $query_suffix = ' AND fid != %d';  }  if (db_result(db_query("SELECT fid FROM {profile_fields} WHERE title = '%s' AND category = '%s'". $query_suffix, $args1))) {    form_set_error('title', t('The specified title is already in use.'));  }  if (db_result(db_query("SELECT fid FROM {profile_fields} WHERE name = '%s'". $query_suffix, $args2))) {    form_set_error('name', t('The specified name is already in use.'));  }  if ($form_state['values']['visibility'] == PROFILE_HIDDEN) {    if ($form_state['values']['required']) {      form_set_error('required', t('A hidden field cannot be required.'));    }    if ($form_state['values']['register']) {      form_set_error('register', t('A hidden field cannot be set to visible on the user registration form.'));    }  }}/** * Process profile_field_form submissions. */function profile_field_form_submit($form, &$form_state) {  if (!isset($form_state['values']['options'])) {    $form_state['values']['options'] = '';  }  if (!isset($form_state['values']['page'])) {    $form_state['values']['page'] = '';  }  if (!isset($form_state['values']['fid'])) {    db_query("INSERT INTO {profile_fields} (title, name, explanation, category, type, weight, required, register, visibility, autocomplete, options, page) VALUES ('%s', '%s', '%s', '%s', '%s', %d, %d, %d, %d, %d, '%s', '%s')", $form_state['values']['title'], $form_state['values']['name'], $form_state['values']['explanation'], $form_state['values']['category'], $form_state['values']['type'], $form_state['values']['weight'], $form_state['values']['required'], $form_state['values']['register'], $form_state['values']['visibility'], $form_state['values']['autocomplete'], $form_state['values']['options'], $form_state['values']['page']);    drupal_set_message(t('The field has been created.'));    watchdog('profile', 'Profile field %field added under category %category.', array('%field' => $form_state['values']['title'], '%category' => $form_state['values']['category']), WATCHDOG_NOTICE, l(t('view'), 'admin/user/profile'));  }  else {    db_query("UPDATE {profile_fields} SET title = '%s', name = '%s', explanation = '%s', category = '%s', weight = %d, required = %d, register = %d, visibility = %d, autocomplete = %d, options = '%s', page = '%s' WHERE fid = %d", $form_state['values']['title'], $form_state['values']['name'], $form_state['values']['explanation'], $form_state['values']['category'], $form_state['values']['weight'], $form_state['values']['required'], $form_state['values']['register'], $form_state['values']['visibility'], $form_state['values']['autocomplete'], $form_state['values']['options'], $form_state['values']['page'], $form_state['values']['fid']);    drupal_set_message(t('The field has been updated.'));  }  cache_clear_all();  menu_rebuild();  $form_state['redirect'] = 'admin/user/profile';  return;}/** * Menu callback; deletes a field from all user profiles. */function profile_field_delete(&$form_state, $fid) {  $field = db_fetch_object(db_query("SELECT title FROM {profile_fields} WHERE fid = %d", $fid));  if (!$field) {    drupal_not_found();    return;  }  $form['fid'] = array('#type' => 'value', '#value' => $fid);  $form['title'] = array('#type' => 'value', '#value' => $field->title);  return confirm_form($form,    t('Are you sure you want to delete the field %field?', array('%field' => $field->title)), 'admin/user/profile',    t('This action cannot be undone. If users have entered values into this field in their profile, these entries will also be deleted. If you want to keep the user-entered data, instead of deleting the field you may wish to <a href="@edit-field">edit this field</a> and change it to a hidden profile field so that it may only be accessed by administrators.', array('@edit-field' => url('admin/user/profile/edit/'. $fid))),    t('Delete'), t('Cancel'));}/** * Process a field delete form submission. */function profile_field_delete_submit($form, &$form_state) {  db_query('DELETE FROM {profile_fields} WHERE fid = %d', $form_state['values']['fid']);  db_query('DELETE FROM {profile_values} WHERE fid = %d', $form_state['values']['fid']);  cache_clear_all();  drupal_set_message(t('The field %field has been deleted.', array('%field' => $form_state['values']['title'])));  watchdog('profile', 'Profile field %field deleted.', array('%field' => $form_state['values']['title']), WATCHDOG_NOTICE, l(t('view'), 'admin/user/profile'));  $form_state['redirect'] = 'admin/user/profile';  return;}/** * Retrieve a pipe delimited string of autocomplete suggestions for profile categories */function profile_admin_settings_autocomplete($string) {  $matches = array();  $result = db_query_range("SELECT category FROM {profile_fields} WHERE LOWER(category) LIKE LOWER('%s%%')", $string, 0, 10);  while ($data = db_fetch_object($result)) {    $matches[$data->category] = check_plain($data->category);  }  drupal_json($matches);}
<?php// $Id$/** * @file * Wrapper for database interface code. *//** * A hash value to check when outputting database errors, md5('DB_ERROR'). * * @see drupal_error_handler() */define('DB_ERROR', 'a515ac9c2796ca0e23adbe92c68fc9fc');/** * @defgroup database Database abstraction layer * @{ * Allow the use of different database servers using the same code base. * * Drupal provides a slim database abstraction layer to provide developers with * the ability to support multiple database servers easily. The intent of this * layer is to preserve the syntax and power of SQL as much as possible, while * letting Drupal control the pieces of queries that need to be written * differently for different servers and provide basic security checks. * * Most Drupal database queries are performed by a call to db_query() or * db_query_range(). Module authors should also consider using pager_query() for * queries that return results that need to be presented on multiple pages, and * tablesort_sql() for generating appropriate queries for sortable tables. * * For example, one might wish to return a list of the most recent 10 nodes * authored by a given user. Instead of directly issuing the SQL query * @code *   SELECT n.nid, n.title, n.created FROM node n WHERE n.uid = $uid LIMIT 0, 10; * @endcode * one would instead call the Drupal functions: * @code *   $result = db_query_range('SELECT n.nid, n.title, n.created *     FROM {node} n WHERE n.uid = %d', $uid, 0, 10); *   while ($node = db_fetch_object($result)) { *     // Perform operations on $node->body, etc. here. *   } * @endcode * Curly braces are used around "node" to provide table prefixing via * db_prefix_tables(). The explicit use of a user ID is pulled out into an * argument passed to db_query() so that SQL injection attacks from user input * can be caught and nullified. The LIMIT syntax varies between database servers, * so that is abstracted into db_query_range() arguments. Finally, note the * common pattern of iterating over the result set using db_fetch_object(). *//** * Perform an SQL query and return success or failure. * * @param $sql *   A string containing a complete SQL query.  %-substitution *   parameters are not supported. * @return *   An array containing the keys: *      success: a boolean indicating whether the query succeeded *      query: the SQL query executed, passed through check_plain() */function update_sql($sql) {  $result = db_query($sql, true);  return array('success' => $result !== FALSE, 'query' => check_plain($sql));}/** * Append a database prefix to all tables in a query. * * Queries sent to Drupal should wrap all table names in curly brackets. This * function searches for this syntax and adds Drupal's table prefix to all * tables, allowing Drupal to coexist with other systems in the same database if * necessary. * * @param $sql *   A string containing a partial or entire SQL query. * @return *   The properly-prefixed string. */function db_prefix_tables($sql) {  global $db_prefix;  if (is_array($db_prefix)) {    if (array_key_exists('default', $db_prefix)) {      $tmp = $db_prefix;      unset($tmp['default']);      foreach ($tmp as $key => $val) {        $sql = strtr($sql, array('{'. $key .'}' => $val . $key));      }      return strtr($sql, array('{' => $db_prefix['default'], '}' => ''));    }    else {      foreach ($db_prefix as $key => $val) {        $sql = strtr($sql, array('{'. $key .'}' => $val . $key));      }      return strtr($sql, array('{' => '', '}' => ''));    }  }  else {    return strtr($sql, array('{' => $db_prefix, '}' => ''));  }}/** * Activate a database for future queries. * * If it is necessary to use external databases in a project, this function can * be used to change where database queries are sent. If the database has not * yet been used, it is initialized using the URL specified for that name in * Drupal's configuration file. If this name is not defined, a duplicate of the * default connection is made instead. * * Be sure to change the connection back to the default when done with custom * code. * * @param $name *   The name assigned to the newly active database connection. If omitted, the *   default connection will be made active. * * @return the name of the previously active database or FALSE if non was found. */function db_set_active($name = 'default') {  global $db_url, $db_type, $active_db;  static $db_conns, $active_name = FALSE;  if (empty($db_url)) {    include_once 'includes/install.inc';    install_goto('install.php');  }  if (!isset($db_conns[$name])) {    // Initiate a new connection, using the named DB URL specified.    if (is_array($db_url)) {      $connect_url = array_key_exists($name, $db_url) ? $db_url[$name] : $db_url['default'];    }    else {      $connect_url = $db_url;    }    $db_type = substr($connect_url, 0, strpos($connect_url, '://'));    $handler = "./includes/database.$db_type.inc";    if (is_file($handler)) {      include_once $handler;    }    else {      _db_error_page("The database type '". $db_type ."' is unsupported. Please use either 'mysql' or 'mysqli' for MySQL, or 'pgsql' for PostgreSQL databases.");    }    $db_conns[$name] = db_connect($connect_url);  }  $previous_name = $active_name;  // Set the active connection.  $active_name = $name;  $active_db = $db_conns[$name];  return $previous_name;}/** * Helper function to show fatal database errors. * * Prints a themed maintenance page with the 'Site off-line' text, * adding the provided error message in the case of 'display_errors' * set to on. Ends the page request; no return. * * @param $error *   The error message to be appended if 'display_errors' is on. */function _db_error_page($error = '') {  global $db_type;  drupal_init_language();  drupal_maintenance_theme();  drupal_set_header('HTTP/1.1 503 Service Unavailable');  drupal_set_title('Site off-line');  $message = '<p>The site is currently not available due to technical problems. Please try again later. Thank you for your understanding.</p>';  $message .= '<hr /><p><small>If you are the maintainer of this site, please check your database settings in the <code>settings.php</code> file and ensure that your hosting provider\'s database server is running. For more help, see the <a href="http://drupal.org/node/258">handbook</a>, or contact your hosting provider.</small></p>';  if ($error && ini_get('display_errors')) {    $message .= '<p><small>The '. theme('placeholder', $db_type) .' error was: '. theme('placeholder', $error) .'.</small></p>';  }  print theme('maintenance_page', $message);  exit;}/** * Returns a boolean depending on the availability of the database. */function db_is_active() {  global $active_db;  return !empty($active_db);}/** * Helper function for db_query(). */function _db_query_callback($match, $init = FALSE) {  static $args = NULL;  if ($init) {    $args = $match;    return;  }  switch ($match[1]) {    case '%d': // We must use type casting to int to convert FALSE/NULL/(TRUE?)      $value = array_shift($args);      // Do we need special bigint handling?      if ($value > PHP_INT_MAX) {        $precision = ini_get('precision');        @ini_set('precision', 16);        $value = sprintf('%.0f', $value);        @ini_set('precision', $precision);      }      else {        $value = (int) $value;      }      // We don't need db_escape_string as numbers are db-safe.      return $value;    case '%s':      return db_escape_string(array_shift($args));    case '%n':      // Numeric values have arbitrary precision, so can't be treated as float.      // is_numeric() allows hex values (0xFF), but they are not valid.      $value = trim(array_shift($args));      return is_numeric($value) && !preg_match('/x/i', $value) ? $value : '0';    case '%%':      return '%';    case '%f':      return (float) array_shift($args);    case '%b': // binary data      return db_encode_blob(array_shift($args));  }}/** * Generate placeholders for an array of query arguments of a single type. * * Given a Schema API field type, return correct %-placeholders to * embed in a query * * @param $arguments *  An array with at least one element. * @param $type *   The Schema API type of a field (e.g. 'int', 'text', or 'varchar'). */function db_placeholders($arguments, $type = 'int') {  $placeholder = db_type_placeholder($type);  return implode(',', array_fill(0, count($arguments), $placeholder));}/** * Indicates the place holders that should be replaced in _db_query_callback(). */define('DB_QUERY_REGEXP', '/(%d|%s|%%|%f|%b|%n)/');/** * Helper function for db_rewrite_sql. * * Collects JOIN and WHERE statements via hook_db_rewrite_sql() * Decides whether to select primary_key or DISTINCT(primary_key) * * @param $query *   Query to be rewritten. * @param $primary_table *   Name or alias of the table which has the primary key field for this query. *   Typical table names would be: {blocks}, {comments}, {forum}, {node}, *   {menu}, {term_data} or {vocabulary}. However, in most cases the usual *   table alias (b, c, f, n, m, t or v) is used instead of the table name. * @param $primary_field *   Name of the primary field. * @param $args *   Array of additional arguments. * @return *   An array: join statements, where statements, field or DISTINCT(field). */function _db_rewrite_sql($query = '', $primary_table = 'n', $primary_field = 'nid', $args = array()) {  $where = array();  $join = array();  $distinct = FALSE;  foreach (module_implements('db_rewrite_sql') as $module) {    $result = module_invoke($module, 'db_rewrite_sql', $query, $primary_table, $primary_field, $args);    if (isset($result) && is_array($result)) {      if (isset($result['where'])) {        $where[] = $result['where'];      }      if (isset($result['join'])) {        $join[] = $result['join'];      }      if (isset($result['distinct']) && $result['distinct']) {        $distinct = TRUE;      }    }    elseif (isset($result)) {      $where[] = $result;    }  }  $where = empty($where) ? '' : '('. implode(') AND (', $where) .')';  $join = empty($join) ? '' : implode(' ', $join);  return array($join, $where, $distinct);}/** * Rewrites node, taxonomy and comment queries. Use it for listing queries. Do not * use FROM table1, table2 syntax, use JOIN instead. * * @param $query *   Query to be rewritten. * @param $primary_table *   Name or alias of the table which has the primary key field for this query. *   Typical table names would be: {blocks}, {comments}, {forum}, {node}, *   {menu}, {term_data} or {vocabulary}. However, it is more common to use the *   the usual table aliases: b, c, f, n, m, t or v. * @param $primary_field *   Name of the primary field. * @param $args *   An array of arguments, passed to the implementations of hook_db_rewrite_sql. * @return *   The original query with JOIN and WHERE statements inserted from *   hook_db_rewrite_sql implementations. nid is rewritten if needed. */function db_rewrite_sql($query, $primary_table = 'n', $primary_field = 'nid',  $args = array()) {  list($join, $where, $distinct) = _db_rewrite_sql($query, $primary_table, $primary_field, $args);  if ($distinct) {    $query = db_distinct_field($primary_table, $primary_field, $query);  }  if (!empty($where) || !empty($join)) {    $pattern = '{      # Beginning of the string      ^      ((?P<anonymous_view>        # Everything within this set of parentheses is named "anonymous view"        (?:          [^()]++                   # anything not parentheses        |          \( (?P>anonymous_view) \)          # an open parenthesis, more "anonymous view" and finally a close parenthesis.        )*      )[^()]+WHERE)    }x';    preg_match($pattern, $query, $matches);    if (!$where) {      $where = '1 = 1';    }    if ($matches) {      $n = strlen($matches[1]);      $second_part = substr($query, $n);      $first_part = substr($matches[1], 0, $n - 5) ." $join WHERE $where AND ( ";      // PHP 4 does not support strrpos for strings. We emulate it.      $haystack_reverse = strrev($second_part);    }    else {      $haystack_reverse = strrev($query);    }    // No need to use strrev on the needle, we supply GROUP, ORDER, LIMIT    // reversed.    foreach (array('PUORG', 'REDRO', 'TIMIL') as $needle_reverse) {      $pos = strpos($haystack_reverse, $needle_reverse);      if ($pos !== FALSE) {        // All needles are five characters long.        $pos += 5;        break;      }    }    if ($matches) {      if ($pos === FALSE) {        $query = $first_part . $second_part .')';      }      else {        $query = $first_part . substr($second_part, 0, -$pos) .')'. substr($second_part, -$pos);      }    }    elseif ($pos === FALSE) {      $query .= " $join WHERE $where";    }    else {      $query = substr($query, 0, -$pos) . " $join WHERE $where " . substr($query, -$pos);    }  }  return $query;}/** * Adds the DISTINCT flag to the supplied query if a DISTINCT doesn't already * exist in the query. Returns the altered query. * * This will not, and never did guarantee that you will obtain distinct  * values of $table.$field. * * @param $table Unused. Kept to remain API compatibility. * @param $field Unused. Kept to remain API compatibility. * @param $query Query to which the DISTINCT flag should be applied. * @return SQL query with the DISTINCT flag set. */function db_distinct_field($table, $field, $query) {  $matches = array();  if (!preg_match('/^SELECT\s*DISTINCT/i', $query, $matches)) {    // Only add distinct to the outer SELECT to avoid messing up subqueries.    $query = preg_replace('/^SELECT/i', 'SELECT DISTINCT', $query);  }  return $query;}/** * Restrict a dynamic table, column or constraint name to safe characters. * * Only keeps alphanumeric and underscores. */function db_escape_table($string) {  return preg_replace('/[^A-Za-z0-9_]+/', '', $string);}/** * @} End of "defgroup database". *//** * @defgroup schemaapi Schema API * @{ * * A Drupal schema definition is an array structure representing one or * more tables and their related keys and indexes. A schema is defined by * hook_schema(), which usually lives in a modulename.install file. * * By implementing hook_schema() and specifying the tables your module * declares, you can easily create and drop these tables on all * supported database engines. You don't have to deal with the * different SQL dialects for table creation and alteration of the * supported database engines. * * hook_schema() should return an array with a key for each table that * the module defines. * * The following keys are defined: * *   - 'description': A string describing this table and its purpose. *     References to other tables should be enclosed in *     curly-brackets.  For example, the node_revisions table *     description field might contain "Stores per-revision title and *     body data for each {node}." *   - 'fields': An associative array ('fieldname' => specification) *     that describes the table's database columns.  The specification *     is also an array.  The following specification parameters are defined: * *     - 'description': A string describing this field and its purpose. *       References to other tables should be enclosed in *       curly-brackets.  For example, the node table vid field *       description might contain "Always holds the largest (most *       recent) {node_revisions}.vid value for this nid." *     - 'type': The generic datatype: 'varchar', 'int', 'serial' *       'float', 'numeric', 'text', 'blob' or 'datetime'.  Most types *       just map to the according database engine specific *       datatypes.  Use 'serial' for auto incrementing fields. This *       will expand to 'int auto_increment' on mysql. *     - 'serialize': A boolean indicating whether the field will be stored         as a serialized string. *     - 'size': The data size: 'tiny', 'small', 'medium', 'normal', *       'big'.  This is a hint about the largest value the field will *       store and determines which of the database engine specific *       datatypes will be used (e.g. on MySQL, TINYINT vs. INT vs. BIGINT). *       'normal', the default, selects the base type (e.g. on MySQL, *       INT, VARCHAR, BLOB, etc.). * *       Not all sizes are available for all data types. See *       db_type_map() for possible combinations. *     - 'not null': If true, no NULL values will be allowed in this *       database column.  Defaults to false. *     - 'default': The field's default value.  The PHP type of the *       value matters: '', '0', and 0 are all different.  If you *       specify '0' as the default value for a type 'int' field it *       will not work because '0' is a string containing the *       character "zero", not an integer. *     - 'length': The maximal length of a type 'char', 'varchar' or 'text' *       field.  Ignored for other field types. *     - 'unsigned': A boolean indicating whether a type 'int', 'float' *       and 'numeric' only is signed or unsigned.  Defaults to *       FALSE.  Ignored for other field types. *     - 'precision', 'scale': For type 'numeric' fields, indicates *       the precision (total number of significant digits) and scale *       (decimal digits right of the decimal point).  Both values are *       mandatory.  Ignored for other field types. * *     All parameters apart from 'type' are optional except that type *     'numeric' columns must specify 'precision' and 'scale'. * *  - 'primary key': An array of one or more key column specifiers (see below) *    that form the primary key. *  - 'unique keys': An associative array of unique keys ('keyname' => *    specification).  Each specification is an array of one or more *    key column specifiers (see below) that form a unique key on the table. *  - 'indexes':  An associative array of indexes ('indexame' => *    specification).  Each specification is an array of one or more *    key column specifiers (see below) that form an index on the *    table. * * A key column specifier is either a string naming a column or an * array of two elements, column name and length, specifying a prefix * of the named column. * * As an example, here is a SUBSET of the schema definition for * Drupal's 'node' table.  It show four fields (nid, vid, type, and * title), the primary key on field 'nid', a unique key named 'vid' on * field 'vid', and two indexes, one named 'nid' on field 'nid' and * one named 'node_title_type' on the field 'title' and the first four * bytes of the field 'type': * * @code * $schema['node'] = array( *   'fields' => array( *     'nid'      => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), *     'vid'      => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0), *     'type'     => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''), *     'title'    => array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''), *   ), *   'primary key' => array('nid'), *   'unique keys' => array( *     'vid'     => array('vid') *   ), *   'indexes' => array( *     'nid'                 => array('nid'), *     'node_title_type'     => array('title', array('type', 4)), *   ), * ); * @endcode * * @see drupal_install_schema() */ /** * Create a new table from a Drupal table definition. * * @param $ret *   Array to which query results will be added. * @param $name *   The name of the table to create. * @param $table *   A Schema API table definition array. */function db_create_table(&$ret, $name, $table) {  $statements = db_create_table_sql($name, $table);  foreach ($statements as $statement) {    $ret[] = update_sql($statement);  }}/** * Return an array of field names from an array of key/index column specifiers. * * This is usually an identity function but if a key/index uses a column prefix * specification, this function extracts just the name. * * @param $fields *   An array of key/index column specifiers. * @return *   An array of field names. */function db_field_names($fields) {  $ret = array();  foreach ($fields as $field) {    if (is_array($field)) {      $ret[] = $field[0];    }    else {      $ret[] = $field;    }  }  return $ret;}/** * Given a Schema API field type, return the correct %-placeholder. * * Embed the placeholder in a query to be passed to db_query and and pass as an * argument to db_query a value of the specified type. * * @param $type *   The Schema API type of a field. * @return *   The placeholder string to embed in a query for that type. */function db_type_placeholder($type) {  switch ($type) {    case 'varchar':    case 'char':    case 'text':    case 'datetime':      return "'%s'";    case 'numeric':      // Numeric values are arbitrary precision numbers.  Syntacically, numerics      // should be specified directly in SQL. However, without single quotes      // the %s placeholder does not protect against non-numeric characters such      // as spaces which would expose us to SQL injection.      return '%n';    case 'serial':    case 'int':      return '%d';    case 'float':      return '%f';    case 'blob':      return '%b';  }  // There is no safe value to return here, so return something that  // will cause the query to fail.  return 'unsupported type '. $type .'for db_type_placeholder';}/** * @} End of "defgroup schemaapi". */
<?php// $Id$/** * @file forum-topic-navigation.tpl.php * Default theme implementation to display the topic navigation string at the * bottom of all forum topics. * * Available variables: * * - $prev: The node ID of the previous post. * - $prev_url: The URL of the previous post. * - $prev_title: The title of the previous post. * * - $next: The node ID of the next post. * - $next_url: The URL of the next post. * - $next_title: The title of the next post. * * - $node: The raw node currently being viewed. Contains unsafe data *   and any data in this must be cleaned before presenting. * * @see template_preprocess_forum_topic_navigation() * @see theme_forum_topic_navigation() */?><?php if ($prev || $next): ?>  <div class="forum-topic-navigation clear-block">    <?php if ($prev): ?>      <a href="<?php print $prev_url; ?>" class="topic-previous" title="<?php print t('Go to previous forum topic') ?>"> <?php print $prev_title ?></a>    <?php endif; ?>    <?php if ($next): ?>      <a href="<?php print $next_url; ?>" class="topic-next" title="<?php print t('Go to next forum topic') ?>"><?php print $next_title ?> </a>    <?php endif; ?>  </div><?php endif; ?>
<?php// $Id$/** * @file *   Manages content translations. * *   Translations are managed in sets of posts, which represent the same *   information in different languages. Only content types for which the *   administrator explicitly enabled translations could have translations *   associated. Translations are managed in sets with exactly one source *   post per set. The source post is used to translate to different *   languages, so if the source post is significantly updated, the *   editor can decide to mark all translations outdated. * *   The node table stores the values used by this module: *    - 'tnid' is the translation set id, which equals the node id *      of the source post. *    - 'translate' is a flag, either indicating that the translation *      is up to date (0) or needs to be updated (1). *//** * Identifies a content type which has translation support enabled. */define('TRANSLATION_ENABLED', 2);/** * Implementation of hook_help(). */function translation_help($path, $arg) {  switch ($path) {    case 'admin/help#translation':      $output = '<p>'. t('The content translation module allows content to be translated into different languages. Working with the <a href="@locale">locale module</a> (which manages enabled languages and provides translation for the site interface), the content translation module is key to creating and maintaining translated site content.', array('@locale' => url('admin/help/locale'))) .'</p>';      $output .= '<p>'. t('Configuring content translation and translation-enabled content types:') .'</p>';      $output .= '<ul><li>'. t('Assign the <em>translate content</em> permission to the appropriate user roles at the <a href="@permissions">Permissions configuration page</a>.', array('@permissions' => url('admin/user/permissions'))) .'</li>';      $output .= '<li>'. t('Add and enable desired languages at the <a href="@languages">Languages configuration page</a>.', array('@languages' => url('admin/settings/language'))) .'</li>';      $output .= '<li>'. t('Determine which <a href="@content-types">content types</a> should support translation features. To enable translation support for a content type, edit the type and at the <em>Multilingual support</em> drop down, select <em>Enabled, with translation</em>. (<em>Multilingual support</em> is located within <em>Workflow settings</em>.) Be sure to save each content type after enabling multilingual support.', array('@content-types' => url('admin/content/types'))) .'</li></ul>';      $output .= '<p>'. t('Working with translation-enabled content types:') .'</p>';      $output .= '<ul><li>'. t('Use the <em>Language</em> drop down to select the appropriate language when creating or editing posts.') .'</li>';      $output .= '<li>'. t('Provide new or edit current translations for existing posts via the <em>Translation</em> tab. Only visible while viewing a post as a user with the <em>translate content</em> permission, this tab allows translations to be added or edited using a specialized editing form that also displays the content being translated.') .'</li>';      $output .= '<li>'. t('Update translations as needed, so that they accurately reflect changes in the content of the original post. The translation status flag provides a simple method for tracking outdated translations. After editing a post, for example, select the <em>Flag translations as outdated</em> check box to mark all of its translations as outdated and in need of revision. Individual translations may be marked for revision by selecting the <em>This translation needs to be updated</em> check box on the translation editing form.') .'</li>';      $output .= '<li>'. t('The <a href="@content-node">Content management administration page</a> displays the language of each post, and also allows filtering by language or translation status.', array('@content-node' => url('admin/content/node'))) .'</li></ul>';      $output .= '<p>'. t('Use the <a href="@blocks">language switcher block</a> provided by locale module to allow users to select a language. If available, both the site interface and site content are presented in the language selected.', array('@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@translation">Translation module</a>.', array('@translation' => 'http://drupal.org/handbook/modules/translation/')) .'</p>';      return $output;    case 'node/%/translate':      $output = '<p>'. t('Translations of a piece of content are managed with translation sets. Each translation set has one source post and any number of translations in any of the <a href="!languages">enabled languages</a>. All translations are tracked to be up to date or outdated based on whether the source post was modified significantly.', array('!languages' => url('admin/settings/language'))) .'</p>';      return $output;  }}/** * Implementation of hook_menu(). */function translation_menu() {  $items = array();  $items['node/%node/translate'] = array(    'title' => 'Translate',    'page callback' => 'translation_node_overview',    'page arguments' => array(1),    'access callback' => '_translation_tab_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'translation.pages.inc',  );  return $items;}/** * Menu access callback. * * Only display translation tab for node types, which have translation enabled * and where the current node is not language neutral (which should span * all languages). */function _translation_tab_access($node) {  return !empty($node->language) && translation_supported_type($node->type) && node_access('view', $node) && user_access('translate content');}/** * Implementation of hook_perm(). */function translation_perm() {  return array('translate content');}/** * Implementation of hook_form_alter(). * * - Add translation option to content type form. * - Alters language fields on node forms when a translation *   is about to be created. */function translation_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'node_type_form') {    // Add translation option to content type form.    $form['workflow']['language_content_type']['#options'][TRANSLATION_ENABLED] = t('Enabled, with translation');    // Description based on text from locale.module.    $form['workflow']['language_content_type']['#description'] = t('Enable multilingual support for this content type. If enabled, a language selection field will be added to the editing form, allowing you to select from one of the <a href="!languages">enabled languages</a>. You can also turn on translation for this content type, which lets you have content translated to any of the enabled languages. If disabled, new posts are saved with the default language. Existing content will not be affected by changing this option.', array('!languages' => url('admin/settings/language')));  }  elseif (isset($form['#id']) && $form['#id'] == 'node-form' && translation_supported_type($form['#node']->type)) {    $node = $form['#node'];    if (!empty($node->translation_source)) {      // We are creating a translation. Add values and lock language field.      $form['translation_source'] = array('#type' => 'value', '#value' => $node->translation_source);      $form['language']['#disabled'] = TRUE;    }    elseif (!empty($node->nid) && !empty($node->tnid)) {      // Disable languages for existing translations, so it is not possible to switch this      // node to some language which is already in the translation set. Also remove the      // language neutral option.      unset($form['language']['#options']['']);      foreach (translation_node_get_translations($node->tnid) as $translation) {        if ($translation->nid != $node->nid) {          unset($form['language']['#options'][$translation->language]);        }      }      // Add translation values and workflow options.      $form['tnid'] = array('#type' => 'value', '#value' => $node->tnid);      $form['translation'] = array(        '#type' => 'fieldset',        '#title' => t('Translation settings'),        '#access' => user_access('translate content'),        '#collapsible' => TRUE,        '#collapsed' => !$node->translate,        '#tree' => TRUE,        '#weight' => 30,      );      if ($node->tnid == $node->nid) {        // This is the source node of the translation        $form['translation']['retranslate'] = array(          '#type' => 'checkbox',          '#title' => t('Flag translations as outdated'),          '#default_value' => 0,          '#description' => t('If you made a significant change, which means translations should be updated, you can flag all translations of this post as outdated. This will not change any other property of those posts, like whether they are published or not.'),        );        $form['translation']['status'] = array('#type' => 'value', '#value' => 0);      }      else {        $form['translation']['status'] = array(          '#type' => 'checkbox',          '#title' => t('This translation needs to be updated'),          '#default_value' => $node->translate,          '#description' => t('When this option is checked, this translation needs to be updated because the source post has changed. Uncheck when the translation is up to date again.'),        );      }    }  }}/** * Implementation of hook_link(). * * Display translation links with native language names, if this node * is part of a translation set. */function translation_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && ($node->tnid) && $translations = translation_node_get_translations($node->tnid)) {    // Do not show link to the same node.    unset($translations[$node->language]);    $languages = language_list();    foreach ($languages as $langcode => $language) {      if (isset($translations[$langcode])) {        $links["node_translation_$langcode"] = array(          'title' => $language->native,          'href' => 'node/'. $translations[$langcode]->nid,          'language' => $language,          'attributes' => array('title' => $translations[$langcode]->title, 'class' => 'translation-link')        );      }    }  }  return $links;}/** * Implementation of hook_nodeapi(). * * Manages translation information for nodes. */function translation_nodeapi(&$node, $op, $teaser, $page) {  // Only act if we are dealing with a content type supporting translations.  if (!translation_supported_type($node->type)) {    return;  }  switch ($op) {    case 'prepare':      if (empty($node->nid) && user_access('translate content') && isset($_GET['translation']) && isset($_GET['language']) && is_numeric($_GET['translation'])) {        $translation_source = node_load($_GET['translation']);        if (empty($translation_source) || !node_access('view', $translation_source)) {          // Source node not found or no access to view. We should not check          // for edit access, since the translator might not have permissions          // to edit the source node but should still be able to translate.          return;        }        $language_list = language_list();        if (!isset($language_list[$_GET['language']]) || ($translation_source->language == $_GET['language'])) {          // If not supported language, or same language as source node, break.          return;        }        // Populate fields based on source node.        $node->language = $_GET['language'];        $node->translation_source = $translation_source;        $node->title = $translation_source->title;        // If user has no access to the filter used for the body, Drupal core        // does not let the edit form to appear, so we should avoid exposing        // the source text here too.        $node->body = filter_access($translation_source->format) ? $translation_source->body : '';        // Let every module add custom translated fields.        node_invoke_nodeapi($node, 'prepare translation');      }      break;    case 'insert':      if (!empty($node->translation_source)) {        if ($node->translation_source->tnid) {          // Add node to existing translation set.          $tnid = $node->translation_source->tnid;        }        else {          // Create new translation set, using nid from the source node.          $tnid = $node->translation_source->nid;          db_query("UPDATE {node} SET tnid = %d, translate = %d WHERE nid = %d", $tnid, 0, $node->translation_source->nid);        }        db_query("UPDATE {node} SET tnid = %d, translate = %d WHERE nid = %d", $tnid, 0, $node->nid);      }      break;    case 'update':      if (isset($node->translation) && $node->translation && !empty($node->language) && $node->tnid) {        // Update translation information.        db_query("UPDATE {node} SET tnid = %d, translate = %d WHERE nid = %d", $node->tnid, $node->translation['status'], $node->nid);        if (!empty($node->translation['retranslate'])) {          // This is the source node, asking to mark all translations outdated.          db_query("UPDATE {node} SET translate = 1 WHERE tnid = %d AND nid != %d", $node->tnid, $node->nid);        }      }      break;    case 'delete':      translation_remove_from_set($node);      break;  }}/** * Remove a node from its translation set (if any) * and update the set accordingly. */function translation_remove_from_set($node) {  if (isset($node->tnid)) {    if (db_result(db_query('SELECT COUNT(*) FROM {node} WHERE tnid = %d', $node->tnid)) == 1) {      // There is only one node left in the set: remove the set altogether.      db_query('UPDATE {node} SET tnid = 0, translate = 0 WHERE tnid = %d', $node->tnid);    }    else {      db_query('UPDATE {node} SET tnid = 0, translate = 0 WHERE nid = %d', $node->nid);      // If the node being removed was the source of the translation set,      // we pick a new source - preferably one that is up to date.      if ($node->tnid == $node->nid) {        $new_tnid = db_result(db_query('SELECT nid FROM {node} WHERE tnid = %d ORDER BY translate ASC, nid ASC', $node->tnid));        db_query('UPDATE {node} SET tnid = %d WHERE tnid = %d', $new_tnid, $node->tnid);      }    }  }}/** * Get all nodes in a translation set, represented by $tnid. * * @param $tnid *   The translation source nid of the translation set, the identifier *   of the node used to derive all translations in the set. * @return *   Array of partial node objects (nid, title, language) representing *   all nodes in the translation set, in effect all translations *   of node $tnid, including node $tnid itself. Because these are *   partial nodes, you need to node_load() the full node, if you *   need more properties. The array is indexed by language code. */function translation_node_get_translations($tnid) {  static $translations = array();  if (is_numeric($tnid) && $tnid) {    if (!isset($translations[$tnid])) {      $translations[$tnid] = array();      $result = db_query(db_rewrite_sql('SELECT n.nid, n.title, n.language FROM {node} n WHERE n.tnid = %d'), $tnid);      while ($node = db_fetch_object($result)) {        $translations[$tnid][$node->language] = $node;      }    }    return $translations[$tnid];  }}/** * Returns whether the given content type has support for translations. * * @return *   Boolean value. */function translation_supported_type($type) {  return variable_get('language_content_type_'. $type, 0) == TRANSLATION_ENABLED;}/** * Return paths of all translations of a node, based on * its Drupal path. * * @param $path *   A Drupal path, for example node/432. * @return *   An array of paths of translations of the node accessible *   to the current user keyed with language codes. */function translation_path_get_translations($path) {  $paths = array();  // Check for a node related path, and for its translations.  if ((preg_match("!^node/([0-9]+)(/.+|)$!", $path, $matches)) && ($node = node_load((int)$matches[1])) && !empty($node->tnid)) {    foreach (translation_node_get_translations($node->tnid) as $language => $translation_node) {      $paths[$language] = 'node/'. $translation_node->nid . $matches[2];    }  }  return $paths;}/** * Implementation of hook_translation_link_alter(). * * Replaces links with pointers to translated versions of the content. */function translation_translation_link_alter(&$links, $path) {  if ($paths = translation_path_get_translations($path)) {    foreach ($links as $langcode => $link) {      if (isset($paths[$langcode])) {        // Translation in a different node.        $links[$langcode]['href'] = $paths[$langcode];      }      else {        // No translation in this language, or no permission to view.        unset($links[$langcode]);      }    }  }}
<?php// $Id$/** * @file * Admin page callbacks for the block module. *//** * Menu callback for admin/build/block. */function block_admin_display($theme = NULL) {  global $custom_theme;  // If non-default theme configuration has been selected, set the custom theme.  $custom_theme = isset($theme) ? $theme : variable_get('theme_default', 'garland');  // Fetch and sort blocks  $blocks = _block_rehash();  usort($blocks, '_block_compare');  return drupal_get_form('block_admin_display_form', $blocks, $theme);}/** * Generate main blocks administration form. */function block_admin_display_form(&$form_state, $blocks, $theme = NULL) {  global $theme_key, $custom_theme;  // Add CSS  drupal_add_css(drupal_get_path('module', 'block') .'/block.css', 'module', 'all', FALSE);  // If non-default theme configuration has been selected, set the custom theme.  $custom_theme = isset($theme) ? $theme : variable_get('theme_default', 'garland');  init_theme();  $throttle = module_exists('throttle');  $block_regions = system_region_list($theme_key) + array(BLOCK_REGION_NONE => '<'. t('none') .'>');  // Weights range from -delta to +delta, so delta should be at least half  // of the amount of blocks present. This makes sure all blocks in the same  // region get an unique weight.  $weight_delta = round(count($blocks) / 2);  // Build form tree  $form = array(    '#action' => arg(4) ? url('admin/build/block/list/'. $theme_key) : url('admin/build/block'),    '#tree' => TRUE,  );  foreach ($blocks as $i => $block) {    $key = $block['module'] .'_'. $block['delta'];    $form[$key]['module'] = array(      '#type' => 'value',      '#value' => $block['module'],    );    $form[$key]['delta'] = array(      '#type' => 'value',      '#value' => $block['delta'],    );    $form[$key]['info'] = array(      '#value' => check_plain($block['info'])    );    $form[$key]['theme'] = array(      '#type' => 'hidden',      '#value' => $theme_key    );    $form[$key]['weight'] = array(      '#type' => 'weight',      '#default_value' => $block['weight'],      '#delta' => $weight_delta,    );    $form[$key]['region'] = array(      '#type' => 'select',      '#default_value' => $block['region'],      '#options' => $block_regions,    );    if ($throttle) {      $form[$key]['throttle'] = array('#type' => 'checkbox', '#default_value' => isset($block['throttle']) ? $block['throttle'] : FALSE);    }    $form[$key]['configure'] = array('#value' => l(t('configure'), 'admin/build/block/configure/'. $block['module'] .'/'. $block['delta']));    if ($block['module'] == 'block') {      $form[$key]['delete'] = array('#value' => l(t('delete'), 'admin/build/block/delete/'. $block['delta']));    }  }  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save blocks'),  );  return $form;}/** * Process main blocks administration form submission. */function block_admin_display_form_submit($form, &$form_state) {  foreach ($form_state['values'] as $block) {    $block['status'] = $block['region'] != BLOCK_REGION_NONE;    $block['region'] = $block['status'] ? $block['region'] : '';    db_query("UPDATE {blocks} SET status = %d, weight = %d, region = '%s', throttle = %d WHERE module = '%s' AND delta = '%s' AND theme = '%s'", $block['status'], $block['weight'], $block['region'], isset($block['throttle']) ? $block['throttle'] : 0, $block['module'], $block['delta'], $block['theme']);  }  drupal_set_message(t('The block settings have been updated.'));  cache_clear_all();}/** * Helper function for sorting blocks on admin/build/block. * * Active blocks are sorted by region, then by weight. * Disabled blocks are sorted by name. */function _block_compare($a, $b) {  global $theme_key;  static $regions;  // We need the region list to correctly order by region.  if (!isset($regions)) {    $regions = array_flip(array_keys(system_region_list($theme_key)));    $regions[BLOCK_REGION_NONE] = count($regions);  }  // Separate enabled from disabled.  $status = $b['status'] - $a['status'];  if ($status) {    return $status;  }  // Sort by region (in the order defined by theme .info file).  if ((!empty($a['region']) && !empty($b['region'])) && ($place = ($regions[$a['region']] - $regions[$b['region']]))) {    return $place;  }  // Sort by weight.  $weight = $a['weight'] - $b['weight'];  if ($weight) {    return $weight;  }  // Sort by title.  return strcmp($a['info'], $b['info']);}/** * Menu callback; displays the block configuration form. */function block_admin_configure(&$form_state, $module = NULL, $delta = 0) {  $form['module'] = array('#type' => 'value', '#value' => $module);  $form['delta'] = array('#type' => 'value', '#value' => $delta);  $edit = db_fetch_array(db_query("SELECT pages, visibility, custom, title FROM {blocks} WHERE module = '%s' AND delta = '%s'", $module, $delta));  $form['block_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Block specific settings'),    '#collapsible' => TRUE,  );  $form['block_settings']['title'] = array(    '#type' => 'textfield',    '#title' => t('Block title'),    '#maxlength' => 64,    '#description' => $module == 'block' ? t('The title of the block as shown to the user.') : t('Override the default title for the block. Use <em>&lt;none&gt;</em> to display no title, or leave blank to use the default block title.'),    '#default_value' => $edit['title'],    '#weight' => -18,  );  // Module-specific block configurations.  if ($settings = module_invoke($module, 'block', 'configure', $delta)) {    foreach ($settings as $k => $v) {      $form['block_settings'][$k] = $v;    }  }  // Get the block subject for the page title.  $info = module_invoke($module, 'block', 'list');  if (isset($info[$delta])) {    drupal_set_title(t("'%name' block", array('%name' => $info[$delta]['info'])));  }  // Standard block configurations.  $form['user_vis_settings'] = array(    '#type' => 'fieldset',    '#title' => t('User specific visibility settings'),    '#collapsible' => TRUE,  );  $form['user_vis_settings']['custom'] = array(    '#type' => 'radios',    '#title' => t('Custom visibility settings'),    '#options' => array(      t('Users cannot control whether or not they see this block.'),      t('Show this block by default, but let individual users hide it.'),      t('Hide this block by default but let individual users show it.')    ),    '#description' => t('Allow individual users to customize the visibility of this block in their account settings.'),    '#default_value' => $edit['custom'],  );  // Role-based visibility settings  $default_role_options = array();  $result = db_query("SELECT rid FROM {blocks_roles} WHERE module = '%s' AND delta = '%s'", $module, $delta);  while ($role = db_fetch_object($result)) {    $default_role_options[] = $role->rid;  }  $result = db_query('SELECT rid, name FROM {role} ORDER BY name');  $role_options = array();  while ($role = db_fetch_object($result)) {    $role_options[$role->rid] = $role->name;  }  $form['role_vis_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Role specific visibility settings'),    '#collapsible' => TRUE,  );  $form['role_vis_settings']['roles'] = array(    '#type' => 'checkboxes',    '#title' => t('Show block for specific roles'),    '#default_value' => $default_role_options,    '#options' => $role_options,    '#description' => t('Show this block only for the selected role(s). If you select no roles, the block will be visible to all users.'),  );  $form['page_vis_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Page specific visibility settings'),    '#collapsible' => TRUE,  );  $access = user_access('use PHP for block visibility');  if ($edit['visibility'] == 2 && !$access) {    $form['page_vis_settings'] = array();    $form['page_vis_settings']['visibility'] = array('#type' => 'value', '#value' => 2);    $form['page_vis_settings']['pages'] = array('#type' => 'value', '#value' => $edit['pages']);  }  else {    $options = array(t('Show on every page except the listed pages.'), t('Show on only the listed pages.'));    $description = t("Enter one page per line as Drupal paths. The '*' character is a wildcard. Example paths are %blog for the blog page and %blog-wildcard for every personal blog. %front is the front page.", array('%blog' => 'blog', '%blog-wildcard' => 'blog/*', '%front' => '<front>'));    if ($access) {      $options[] = t('Show if the following PHP code returns <code>TRUE</code> (PHP-mode, experts only).');      $description .= ' '. t('If the PHP-mode is chosen, enter PHP code between %php. Note that executing incorrect PHP-code can break your Drupal site.', array('%php' => '<?php ?>'));    }    $form['page_vis_settings']['visibility'] = array(      '#type' => 'radios',      '#title' => t('Show block on specific pages'),      '#options' => $options,      '#default_value' => $edit['visibility'],    );    $form['page_vis_settings']['pages'] = array(      '#type' => 'textarea',      '#title' => t('Pages'),      '#default_value' => $edit['pages'],      '#description' => $description,    );  }  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save block'),  );  return $form;}function block_admin_configure_validate($form, &$form_state) {  if ($form_state['values']['module'] == 'block') {    if (empty($form_state['values']['info']) || db_result(db_query("SELECT COUNT(*) FROM {boxes} WHERE bid != %d AND info = '%s'", $form_state['values']['delta'], $form_state['values']['info']))) {      form_set_error('info', t('Please ensure that each block description is unique.'));    }  }}function block_admin_configure_submit($form, &$form_state) {  if (!form_get_errors()) {    db_query("UPDATE {blocks} SET visibility = %d, pages = '%s', custom = %d, title = '%s' WHERE module = '%s' AND delta = '%s'", $form_state['values']['visibility'], trim($form_state['values']['pages']), $form_state['values']['custom'], $form_state['values']['title'], $form_state['values']['module'], $form_state['values']['delta']);    db_query("DELETE FROM {blocks_roles} WHERE module = '%s' AND delta = '%s'", $form_state['values']['module'], $form_state['values']['delta']);    foreach (array_filter($form_state['values']['roles']) as $rid) {      db_query("INSERT INTO {blocks_roles} (rid, module, delta) VALUES (%d, '%s', '%s')", $rid, $form_state['values']['module'], $form_state['values']['delta']);    }    module_invoke($form_state['values']['module'], 'block', 'save', $form_state['values']['delta'], $form_state['values']);    drupal_set_message(t('The block configuration has been saved.'));    cache_clear_all();    $form_state['redirect'] = 'admin/build/block';    return;  }}/** * Menu callback: display the custom block addition form. */function block_add_block_form(&$form_state) {  return block_admin_configure($form_state, 'block', NULL);}function block_add_block_form_validate($form, &$form_state) {  if (empty($form_state['values']['info']) || db_result(db_query("SELECT COUNT(*) FROM {boxes} WHERE info = '%s'", $form_state['values']['info']))) {    form_set_error('info', t('Please ensure that each block description is unique.'));  }}/** * Save the new custom block. */function block_add_block_form_submit($form, &$form_state) {  db_query("INSERT INTO {boxes} (body, info, format) VALUES ('%s', '%s', %d)", $form_state['values']['body'], $form_state['values']['info'], $form_state['values']['format']);  $delta = db_last_insert_id('boxes', 'bid');  foreach (list_themes() as $key => $theme) {    if ($theme->status) {      db_query("INSERT INTO {blocks} (visibility, pages, custom, title, module, theme, status, weight, delta, cache) VALUES(%d, '%s', %d, '%s', '%s', '%s', %d, %d, '%s', %d)", $form_state['values']['visibility'], trim($form_state['values']['pages']), $form_state['values']['custom'], $form_state['values']['title'], $form_state['values']['module'], $theme->name, 0, 0, $delta, BLOCK_NO_CACHE);    }  }  foreach (array_filter($form_state['values']['roles']) as $rid) {    db_query("INSERT INTO {blocks_roles} (rid, module, delta) VALUES (%d, '%s', '%s')", $rid, $form_state['values']['module'], $delta);  }  drupal_set_message(t('The block has been created.'));  cache_clear_all();  $form_state['redirect'] = 'admin/build/block';  return;}/** * Menu callback; confirm deletion of custom blocks. */function block_box_delete(&$form_state, $bid = 0) {  $box = block_box_get($bid);  $form['info'] = array('#type' => 'hidden', '#value' => $box['info']);  $form['bid'] = array('#type' => 'hidden', '#value' => $bid);  return confirm_form($form, t('Are you sure you want to delete the block %name?', array('%name' => $box['info'])), 'admin/build/block', '', t('Delete'), t('Cancel'));}/** * Deletion of custom blocks. */function block_box_delete_submit($form, &$form_state) {  db_query('DELETE FROM {boxes} WHERE bid = %d', $form_state['values']['bid']);  db_query("DELETE FROM {blocks} WHERE module = 'block' AND delta = '%s'", $form_state['values']['bid']);  drupal_set_message(t('The block %name has been removed.', array('%name' => $form_state['values']['info'])));  cache_clear_all();  $form_state['redirect'] = 'admin/build/block';  return;}/** * Process variables for block-admin-display.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see block-admin-display.tpl.php * @see theme_block_admin_display() */function template_preprocess_block_admin_display_form(&$variables) {  global $theme_key;  $block_regions = system_region_list($theme_key);  $variables['throttle'] = module_exists('throttle');  $variables['block_regions'] = $block_regions + array(BLOCK_REGION_NONE => t('Disabled'));  foreach ($block_regions as $key => $value) {    // Highlight regions on page to provide visual reference.    drupal_set_content($key, '<div class="block-region">'. $value .'</div>');    // Initialize an empty array for the region.    $variables['block_listing'][$key] = array();  }  // Initialize disabled blocks array.  $variables['block_listing'][BLOCK_REGION_NONE] = array();  // Set up to track previous region in loop.  $last_region = '';  foreach (element_children($variables['form']) as $i) {    $block = &$variables['form'][$i];    // Only take form elements that are blocks.    if (isset($block['info'])) {      // Fetch region for current block.      $region = $block['region']['#default_value'];      // Set special classes needed for table drag and drop.      $variables['form'][$i]['region']['#attributes']['class'] = 'block-region-select block-region-'. $region;      $variables['form'][$i]['weight']['#attributes']['class'] = 'block-weight block-weight-'. $region;      $variables['block_listing'][$region][$i]->row_class = isset($block['#attributes']['class']) ? $block['#attributes']['class'] : '';      $variables['block_listing'][$region][$i]->block_modified = isset($block['#attributes']['class']) && strpos($block['#attributes']['class'], 'block-modified') !== FALSE ? TRUE : FALSE;      $variables['block_listing'][$region][$i]->block_title =  drupal_render($block['info']);      $variables['block_listing'][$region][$i]->region_select = drupal_render($block['region']) . drupal_render($block['theme']);      $variables['block_listing'][$region][$i]->weight_select = drupal_render($block['weight']);      $variables['block_listing'][$region][$i]->throttle_check = $variables['throttle'] ? drupal_render($block['throttle']) : '';      $variables['block_listing'][$region][$i]->configure_link = drupal_render($block['configure']);      $variables['block_listing'][$region][$i]->delete_link = !empty($block['delete']) ? drupal_render($block['delete']) : '';      $variables['block_listing'][$region][$i]->printed = FALSE;      $last_region = $region;    }  }  $variables['form_submit'] = drupal_render($variables['form']);}
<?php// $Id$/** * @file * Controls the boxes that are displayed around the main content. *//** * Denotes that a block is not enabled in any region and should not * be shown. */define('BLOCK_REGION_NONE', -1);/** * Constants defining cache granularity for blocks. * * Modules specify the caching patterns for their blocks using binary * combinations of these constants in their hook_block(op 'list'): *   $block[delta]['cache'] = BLOCK_CACHE_PER_ROLE | BLOCK_CACHE_PER_PAGE; * BLOCK_CACHE_PER_ROLE is used as a default when no caching pattern is * specified. * * The block cache is cleared in cache_clear_all(), and uses the same clearing * policy than page cache (node, comment, user, taxonomy added or updated...). * Blocks requiring more fine-grained clearing might consider disabling the * built-in block cache (BLOCK_NO_CACHE) and roll their own. * * Note that user 1 is excluded from block caching. *//** * The block should not get cached. This setting should be used: * - for simple blocks (notably those that do not perform any db query), * where querying the db cache would be more expensive than directly generating * the content. * - for blocks that change too frequently. */define('BLOCK_NO_CACHE', -1);/** * The block can change depending on the roles the user viewing the page belongs to. * This is the default setting, used when the block does not specify anything. */define('BLOCK_CACHE_PER_ROLE', 0x0001);/** * The block can change depending on the user viewing the page. * This setting can be resource-consuming for sites with large number of users, * and thus should only be used when BLOCK_CACHE_PER_ROLE is not sufficient. */define('BLOCK_CACHE_PER_USER', 0x0002);/** * The block can change depending on the page being viewed. */define('BLOCK_CACHE_PER_PAGE', 0x0004);/** * The block is the same for every user on every page where it is visible. */define('BLOCK_CACHE_GLOBAL', 0x0008);/** * Implementation of hook_help(). */function block_help($path, $arg) {  switch ($path) {    case 'admin/help#block':      $output = '<p>'. t('Blocks are boxes of content rendered into an area, or region, of a web page. The default theme Garland, for example, implements the regions "left sidebar", "right sidebar", "content", "header", and "footer", and a block may appear in any one of these areas. The <a href="@blocks">blocks administration page</a> provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions.', array('@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('Although blocks are usually generated automatically by modules (like the <em>User login</em> block, for example), administrators can also define custom blocks. Custom blocks have a title, description, and body. The body of the block can be as long as necessary, and can contain content supported by any available <a href="@input-format">input format</a>.', array('@input-format' => url('admin/settings/filters'))) .'</p>';      $output .= '<p>'. t('When working with blocks, remember that:') .'</p>';      $output .= '<ul><li>'. t('since not all themes implement the same regions, or display regions in the same way, blocks are positioned on a per-theme basis.') .'</li>';      $output .= '<li>'. t('disabled blocks, or blocks not in a region, are never shown.') .'</li>';      $output .= '<li>'. t('when throttle module is enabled, throttled blocks (blocks with the <em>Throttle</em> checkbox selected) are hidden during high server loads.') .'</li>';      $output .= '<li>'. t('blocks can be configured to be visible only on certain pages.') .'</li>';      $output .= '<li>'. t('blocks can be configured to be visible only when specific conditions are true.') .'</li>';      $output .= '<li>'. t('blocks can be configured to be visible only for certain user roles.') .'</li>';      $output .= '<li>'. t('when allowed by an administrator, specific blocks may be enabled or disabled on a per-user basis using the <em>My account</em> page.') .'</li>';      $output .= '<li>'. t('some dynamic blocks, such as those generated by modules, will be displayed only on certain pages.') .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@block">Block module</a>.', array('@block' => 'http://drupal.org/handbook/modules/block/')) .'</p>';      return $output;    case 'admin/build/block':      $throttle = module_exists('throttle');      $output = '<p>'. t('This page provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions. To change the region or order of a block, grab a drag-and-drop handle under the <em>Block</em> column and drag the block to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Since not all themes implement the same regions, or display regions in the same way, blocks are positioned on a per-theme basis. Remember that your changes will not be saved until you click the <em>Save blocks</em> button at the bottom of the page.') .'</p>';      if ($throttle) {        $output .= '<p>'. t('To reduce CPU usage, database traffic or bandwidth, blocks may be automatically disabled during high server loads by selecting their <em>Throttle</em> checkbox. Adjust throttle thresholds on the <a href="@throttleconfig">throttle configuration page</a>.', array('@throttleconfig' => url('admin/settings/throttle'))) .'</p>';      }      $output .= '<p>'. t('Click the <em>configure</em> link next to each block to configure its specific title and visibility settings. Use the <a href="@add-block">add block page</a> to create a custom block.', array('@add-block' => url('admin/build/block/add'))) .'</p>';      return $output;    case 'admin/build/block/add':      return '<p>'. t('Use this page to create a new custom block. New blocks are disabled by default, and must be moved to a region on the <a href="@blocks">blocks administration page</a> to be visible.', array('@blocks' => url('admin/build/block'))) .'</p>';  }}/** * Implementation of hook_theme() */function block_theme() {  return array(    'block_admin_display_form' => array(      'template' => 'block-admin-display-form',      'file' => 'block.admin.inc',      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_perm(). */function block_perm() {  return array('administer blocks', 'use PHP for block visibility');}/** * Implementation of hook_menu(). */function block_menu() {  $items['admin/build/block'] = array(    'title' => 'Blocks',    'description' => 'Configure what block content appears in your site\'s sidebars and other regions.',    'page callback' => 'block_admin_display',    'access arguments' => array('administer blocks'),    'file' => 'block.admin.inc',  );  $items['admin/build/block/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/build/block/list/js'] = array(    'title' => 'JavaScript List Form',    'page callback' => 'block_admin_display_js',    'access arguments' => array('administer blocks'),    'type' => MENU_CALLBACK,    'file' => 'block.admin.inc',  );  $items['admin/build/block/configure'] = array(    'title' => 'Configure block',    'page callback' => 'drupal_get_form',    'page arguments' => array('block_admin_configure'),    'access arguments' => array('administer blocks'),    'type' => MENU_CALLBACK,    'file' => 'block.admin.inc',  );  $items['admin/build/block/delete'] = array(    'title' => 'Delete block',    'page callback' => 'drupal_get_form',    'page arguments' => array('block_box_delete'),    'access arguments' => array('administer blocks'),    'type' => MENU_CALLBACK,    'file' => 'block.admin.inc',  );  $items['admin/build/block/add'] = array(    'title' => 'Add block',    'page callback' => 'drupal_get_form',    'page arguments' => array('block_add_block_form'),    'access arguments' => array('administer blocks'),    'type' => MENU_LOCAL_TASK,    'file' => 'block.admin.inc',  );  $default = variable_get('theme_default', 'garland');  foreach (list_themes() as $key => $theme) {    $items['admin/build/block/list/'. $key] = array(      'title' => check_plain($theme->info['name']),      'page arguments' => array($key),      'type' => $key == $default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,      'weight' => $key == $default ? -10 : 0,      'file' => 'block.admin.inc',      'access callback' => '_block_themes_access',      'access arguments' => array($theme),    );  }  return $items;}/** * Menu item access callback - only admin or enabled themes can be accessed */function _block_themes_access($theme) {  return user_access('administer blocks') && ($theme->status || $theme->name == variable_get('admin_theme', '0'));}/** * Implementation of hook_block(). * * Generates the administrator-defined blocks for display. */function block_block($op = 'list', $delta = 0, $edit = array()) {  switch ($op) {    case 'list':      $blocks = array();      $result = db_query('SELECT bid, info FROM {boxes} ORDER BY info');      while ($block = db_fetch_object($result)) {        $blocks[$block->bid]['info'] = $block->info;        // Not worth caching.        $blocks[$block->bid]['cache'] = BLOCK_NO_CACHE;      }      return $blocks;    case 'configure':      $box = array('format' => FILTER_FORMAT_DEFAULT);      if ($delta) {        $box = block_box_get($delta);      }      if (filter_access($box['format'])) {        return block_box_form($box);      }      break;    case 'save':      block_box_save($edit, $delta);      break;    case 'view':      $block = db_fetch_object(db_query('SELECT body, format FROM {boxes} WHERE bid = %d', $delta));      $data['content'] = check_markup($block->body, $block->format, FALSE);      return $data;  }}/** * Update the 'blocks' DB table with the blocks currently exported by modules. * * @return *   Blocks currently exported by modules. */function _block_rehash() {  global $theme_key;  init_theme();  $result = db_query("SELECT * FROM {blocks} WHERE theme = '%s'", $theme_key);  $old_blocks = array();  while ($old_block = db_fetch_array($result)) {    $old_blocks[$old_block['module']][$old_block['delta']] = $old_block;  }  $blocks = array();  // Valid region names for the theme.  $regions = system_region_list($theme_key);  foreach (module_list() as $module) {    $module_blocks = module_invoke($module, 'block', 'list');    if ($module_blocks) {      foreach ($module_blocks as $delta => $block) {        if (empty($old_blocks[$module][$delta])) {          // If it's a new block, add identifiers.          $block['module'] = $module;          $block['delta']  = $delta;          $block['theme']  = $theme_key;          if (!isset($block['pages'])) {            // {block}.pages is type 'text', so it cannot have a            // default value, and not null, so we need to provide            // value if the module did not.            $block['pages']  = '';          }          // Add defaults and save it into the database.          drupal_write_record('blocks', $block);          // Set region to none if not enabled.          $block['region'] = $block['status'] ? $block['region'] : BLOCK_REGION_NONE;          // Add to the list of blocks we return.          $blocks[] = $block;        }        else {          // If it's an existing block, database settings should overwrite          // the code. But aside from 'info' everything that's definable in          // code is stored in the database and we do not store 'info', so we          // do not need to update the database here.          // Add 'info' to this block.          $old_blocks[$module][$delta]['info'] = $block['info'];          // If the region name does not exist, disable the block and assign it to none.          if (!empty($old_blocks[$module][$delta]['region']) && !isset($regions[$old_blocks[$module][$delta]['region']])) {            drupal_set_message(t('The block %info was assigned to the invalid region %region and has been disabled.', array('%info' => $old_blocks[$module][$delta]['info'], '%region' => $old_blocks[$module][$delta]['region'])), 'warning');            $old_blocks[$module][$delta]['status'] = 0;            $old_blocks[$module][$delta]['region'] = BLOCK_REGION_NONE;          }          else {            $old_blocks[$module][$delta]['region'] = $old_blocks[$module][$delta]['status'] ? $old_blocks[$module][$delta]['region'] : BLOCK_REGION_NONE;          }          // Add this block to the list of blocks we return.          $blocks[] = $old_blocks[$module][$delta];          // Remove this block from the list of blocks to be deleted.          unset($old_blocks[$module][$delta]);        }      }    }  }  // Remove blocks that are no longer defined by the code from the database.  foreach ($old_blocks as $module => $old_module_blocks) {    foreach ($old_module_blocks as $delta => $block) {      db_query("DELETE FROM {blocks} WHERE module = '%s' AND delta = '%s' AND theme = '%s'", $module, $delta, $theme_key);    }  }  return $blocks;}/** * Returns information from database about a user-created (custom) block. * * @param $bid *   ID of the block to get information for. * @return *   Associative array of information stored in the database for this block. *   Array keys: *   - bid: Block ID. *   - info: Block description. *   - body: Block contents. *   - format: Filter ID of the filter format for the body. */function block_box_get($bid) {  return db_fetch_array(db_query("SELECT * FROM {boxes} WHERE bid = %d", $bid));}/** * Define the custom block form. */function block_box_form($edit = array()) {  $edit += array(    'info' => '',    'body' => '',  );  $form['info'] = array(    '#type' => 'textfield',    '#title' => t('Block description'),    '#default_value' => $edit['info'],    '#maxlength' => 64,    '#description' => t('A brief description of your block. Used on the <a href="@overview">block overview page</a>.', array('@overview' => url('admin/build/block'))),    '#required' => TRUE,    '#weight' => -19,  );  $form['body_field']['#weight'] = -17;  $form['body_field']['body'] = array(    '#type' => 'textarea',    '#title' => t('Block body'),    '#default_value' => $edit['body'],    '#rows' => 15,    '#description' => t('The content of the block as shown to the user.'),    '#weight' => -17,  );  if (!isset($edit['format'])) {    $edit['format'] = FILTER_FORMAT_DEFAULT;  }  $form['body_field']['format'] = filter_form($edit['format'], -16);  return $form;}/** * Saves a user-created block in the database. * * @param $edit *   Associative array of fields to save. Array keys: *   - info: Block description. *   - body: Block contents. *   - format: Filter ID of the filter format for the body. * @param $delta *   Block ID of the block to save. * @return *   Always returns TRUE. */function block_box_save($edit, $delta) {  if (!filter_access($edit['format'])) {    $edit['format'] = FILTER_FORMAT_DEFAULT;  }  db_query("UPDATE {boxes} SET body = '%s', info = '%s', format = %d WHERE bid = %d", $edit['body'], $edit['info'], $edit['format'], $delta);  return TRUE;}/** * Implementation of hook_user(). * * Allow users to decide which custom blocks to display when they visit * the site. */function block_user($type, $edit, &$account, $category = NULL) {  switch ($type) {    case 'form':      if ($category == 'account') {        $rids = array_keys($account->roles);        $result = db_query("SELECT DISTINCT b.* FROM {blocks} b LEFT JOIN {blocks_roles} r ON b.module = r.module AND b.delta = r.delta WHERE b.status = 1 AND b.custom != 0 AND (r.rid IN (". db_placeholders($rids) .") OR r.rid IS NULL) ORDER BY b.weight, b.module", $rids);        $form['block'] = array('#type' => 'fieldset', '#title' => t('Block configuration'), '#weight' => 3, '#collapsible' => TRUE, '#tree' => TRUE);        while ($block = db_fetch_object($result)) {          $data = module_invoke($block->module, 'block', 'list');          if ($data[$block->delta]['info']) {            $return = TRUE;            $form['block'][$block->module][$block->delta] = array('#type' => 'checkbox', '#title' => check_plain($data[$block->delta]['info']), '#default_value' => isset($account->block[$block->module][$block->delta]) ? $account->block[$block->module][$block->delta] : ($block->custom == 1));          }        }        if (!empty($return)) {          return $form;        }      }      break;    case 'validate':      if (empty($edit['block'])) {        $edit['block'] = array();      }      return $edit;  }}/** * Return all blocks in the specified region for the current user. * * @param $region *   The name of a region. * * @return *   An array of block objects, indexed with <i>module</i>_<i>delta</i>. *   If you are displaying your blocks in one or two sidebars, you may check *   whether this array is empty to see how many columns are going to be *   displayed. * * @todo *   Now that the blocks table has a primary key, we should use that as the *   array key instead of <i>module</i>_<i>delta</i>. */function block_list($region) {  global $user, $theme_key;  static $blocks = array();  if (!count($blocks)) {    $rids = array_keys($user->roles);    $result = db_query(db_rewrite_sql("SELECT DISTINCT b.* FROM {blocks} b LEFT JOIN {blocks_roles} r ON b.module = r.module AND b.delta = r.delta WHERE b.theme = '%s' AND b.status = 1 AND (r.rid IN (". db_placeholders($rids) .") OR r.rid IS NULL) ORDER BY b.region, b.weight, b.module", 'b', 'bid'), array_merge(array($theme_key), $rids));    while ($block = db_fetch_object($result)) {      if (!isset($blocks[$block->region])) {        $blocks[$block->region] = array();      }      // Use the user's block visibility setting, if necessary      if ($block->custom != 0) {        if ($user->uid && isset($user->block[$block->module][$block->delta])) {          $enabled = $user->block[$block->module][$block->delta];        }        else {          $enabled = ($block->custom == 1);        }      }      else {        $enabled = TRUE;      }      // Match path if necessary      if ($block->pages) {        if ($block->visibility < 2) {          $path = drupal_get_path_alias($_GET['q']);          // Compare with the internal and path alias (if any).          $page_match = drupal_match_path($path, $block->pages);          if ($path != $_GET['q']) {            $page_match = $page_match || drupal_match_path($_GET['q'], $block->pages);          }          // When $block->visibility has a value of 0, the block is displayed on          // all pages except those listed in $block->pages. When set to 1, it          // is displayed only on those pages listed in $block->pages.          $page_match = !($block->visibility xor $page_match);        }        else {          $page_match = drupal_eval($block->pages);        }      }      else {        $page_match = TRUE;      }      $block->enabled = $enabled;      $block->page_match = $page_match;      $blocks[$block->region]["{$block->module}_{$block->delta}"] = $block;    }  }  // Create an empty array if there were no entries  if (!isset($blocks[$region])) {    $blocks[$region] = array();  }  foreach ($blocks[$region] as $key => $block) {    // Render the block content if it has not been created already.    if (!isset($block->content)) {      // Erase the block from the static array - we'll put it back if it has content.      unset($blocks[$region][$key]);      if ($block->enabled && $block->page_match) {        // Check the current throttle status and see if block should be displayed        // based on server load.        if (!($block->throttle && (module_invoke('throttle', 'status') > 0))) {          // Try fetching the block from cache. Block caching is not compatible with          // node_access modules. We also preserve the submission of forms in blocks,          // by fetching from cache only if the request method is 'GET'.          if (!count(module_implements('node_grants')) && $_SERVER['REQUEST_METHOD'] == 'GET' && ($cid = _block_get_cache_id($block)) && ($cache = cache_get($cid, 'cache_block'))) {            $array = $cache->data;          }          else {            $array = module_invoke($block->module, 'block', 'view', $block->delta);            if (isset($cid)) {              cache_set($cid, $array, 'cache_block', CACHE_TEMPORARY);            }          }          if (isset($array) && is_array($array)) {            foreach ($array as $k => $v) {              $block->$k = $v;            }          }        }        if (isset($block->content) && $block->content) {          // Override default block title if a custom display title is present.          if ($block->title) {            // Check plain here to allow module generated titles to keep any markup.            $block->subject = $block->title == '<none>' ? '' : check_plain($block->title);          }          if (!isset($block->subject)) {            $block->subject = '';          }          $blocks[$block->region]["{$block->module}_{$block->delta}"] = $block;        }      }    }  }  return $blocks[$region];}/** * Assemble the cache_id to use for a given block. * * The cache_id string reflects the viewing context for the current block * instance, obtained by concatenating the relevant context information * (user, page, ...) according to the block's cache settings (BLOCK_CACHE_* * constants). Two block instances can use the same cached content when * they share the same cache_id. * * Theme and language contexts are automatically differenciated. * * @param $block * @return *   The string used as cache_id for the block. */function _block_get_cache_id($block) {  global $theme, $base_root, $user;  // User 1 being out of the regular 'roles define permissions' schema,  // it brings too many chances of having unwanted output get in the cache  // and later be served to other users. We therefore exclude user 1 from  // block caching.  if (variable_get('block_cache', 0) && $block->cache != BLOCK_NO_CACHE && $user->uid != 1) {    $cid_parts = array();    // Start with common sub-patterns: block identification, theme, language.    $cid_parts[] = $block->module;    $cid_parts[] = $block->delta;    $cid_parts[] = $theme;    if (module_exists('locale')) {      global $language;      $cid_parts[] = $language->language;    }    // 'PER_ROLE' and 'PER_USER' are mutually exclusive. 'PER_USER' can be a    // resource drag for sites with many users, so when a module is being    // equivocal, we favor the less expensive 'PER_ROLE' pattern.    if ($block->cache & BLOCK_CACHE_PER_ROLE) {      $cid_parts[] = 'r.'. implode(',', array_keys($user->roles));    }    elseif ($block->cache & BLOCK_CACHE_PER_USER) {      $cid_parts[] = "u.$user->uid";    }    if ($block->cache & BLOCK_CACHE_PER_PAGE) {      $cid_parts[] = $base_root . request_uri();    }    return implode(':', $cid_parts);  }}
<?php// $Id$/** * Implementation of hook_install(). */function locale_install() {  // locales_source.source and locales_target.target are not used as binary  // fields; non-MySQL database servers need to ensure the field type is text  // and that LIKE produces a case-sensitive comparison.  // Create tables.  drupal_install_schema('locale');  db_query("INSERT INTO {languages} (language, name, native, direction, enabled, weight, javascript) VALUES ('en', 'English', 'English', '0', '1', '0', '')");}/** * @defgroup updates-5.x-to-6.x Locale updates from 5.x to 6.x * @{ *//** * {locales_meta} table became {languages}. */function locale_update_6000() {  $ret = array();  $schema['languages'] = array(    'fields' => array(      'language' => array(        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => '',      ),      'name' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',      ),      'native' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',      ),      'direction' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,      ),      'enabled' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,      ),      'plurals' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,      ),      'formula' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',      ),      'domain' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',      ),      'prefix' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,      ),      'javascript' => array( //Adds a column to store the filename of the JavaScript translation file.        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '',      ),    ),    'primary key' => array('language'),    'indexes' => array(      'list' => array('weight', 'name'),    ),  );  db_create_table($ret, 'languages', $schema['languages']);  // Save the languages  $ret[] = update_sql("INSERT INTO {languages} (language, name, native, direction, enabled, plurals, formula, domain, prefix, weight) SELECT locale, name, name, 0, enabled, plurals, formula, '', locale, 0 FROM {locales_meta}");  // Save the language count in the variable table  $count = db_result(db_query('SELECT COUNT(*) FROM {languages} WHERE enabled = 1'));  variable_set('language_count', $count);  // Save the default language in the variable table  $default = db_fetch_object(db_query('SELECT * FROM {locales_meta} WHERE isdefault = 1'));  variable_set('language_default', (object) array('language' => $default->locale, 'name' => $default->name, 'native' => '', 'direction' => 0, 'enabled' => 1, 'plurals' => $default->plurals, 'formula' => $default->formula, 'domain' => '', 'prefix' => $default->locale, 'weight' => 0));  $ret[] = update_sql("DROP TABLE {locales_meta}");  return $ret;}/** * Change locale column to language. The language column is added by * update_fix_d6_requirements() in update.php to avoid a large number * of error messages from update.php.  All we need to do here is copy * locale to language and then drop locale. */function locale_update_6001() {  $ret = array();  $ret[] = update_sql('UPDATE {locales_target} SET language = locale');  db_drop_field($ret, 'locales_target', 'locale');  return $ret;}/** * Remove empty translations, we don't need these anymore. */function locale_update_6002() {  $ret = array();  $ret[] = update_sql("DELETE FROM {locales_target} WHERE translation = ''");  return $ret;}/** * Prune strings with no translations (will be automatically re-registered if still in use) */function locale_update_6003() {  $ret = array();  $ret[] = update_sql("DELETE FROM {locales_source} WHERE lid NOT IN (SELECT lid FROM {locales_target})");  return $ret;}/** * Fix remaining inconsistent indexes. */function locale_update_6004() {  $ret = array();  db_add_index($ret, 'locales_target', 'language', array('language'));  switch ($GLOBALS['db_type']) {    case 'pgsql':      db_drop_index($ret, 'locales_source', 'source');      db_add_index($ret, 'locales_source', 'source', array(array('source', 30)));      break;  }  return $ret;}/** * Change language setting variable of content types. * * Use language_content_type_<content_type> instead of language_<content_type> * so content types such as 'default', 'count' or 'negotiation' will not * interfere with language variables. */function locale_update_6005() {  foreach (node_get_types() as $type => $content_type) {    // Default to NULL, so we can skip dealing with non-existent settings.    $setting = variable_get('language_'. $type, NULL);    if ($type == 'default' && is_numeric($setting)) {      // language_default was overwritten with the content type setting,      // so reset the default language and save the content type setting.      variable_set('language_content_type_default', $setting);      variable_del('language_default');      drupal_set_message('The default language setting has been reset to its default value. Check the '. l('language configuration page', 'admin/settings/language') .' to configure it correctly.');    }    elseif ($type == 'negotiation') {      // language_content_type_negotiation is an integer either if it is      // the negotiation setting or the content type setting.      // The language_negotiation setting is not reset, but      // the user is alerted that this setting possibly was overwritten      variable_set('language_content_type_negotiation', $setting);      drupal_set_message('The language negotiation setting was possibly overwritten by a content type of the same name. Check the '. l('language configuration page', 'admin/settings/language/configure') .' and the '. l('<em>'. $content_type->name ."</em> content type's multilingual support settings", 'admin/content/types/negotiation', array('html' => TRUE)) .' to configure them correctly.');    }    elseif (!is_null($setting)) {      // Change the language setting variable for any other content type.      // Do not worry about language_count, it will be updated below.      variable_set('language_content_type_'. $type, $setting);      variable_del('language_'. $type);    }  }  // Update language count variable that might be overwritten.  $count = db_result(db_query('SELECT COUNT(*) FROM {languages} WHERE enabled = 1'));  variable_set('language_count', $count);  return array();}/** * Neutralize unsafe language names in the database. */function locale_update_6006() {  $ret = array();  $matches = db_result(db_query("SELECT 1 FROM {languages} WHERE native LIKE '%<%' OR native LIKE '%>%' OR name LIKE '%<%' OR name LIKE '%>%'"));  if ($matches) {    $ret[] = update_sql("UPDATE {languages} SET name = REPLACE(name, '<', ''), native = REPLACE(native, '<', '')");    $ret[] = update_sql("UPDATE {languages} SET name = REPLACE(name, '>', ''), native = REPLACE(native, '>', '')");    drupal_set_message('The language name in English and the native language name values of all the existing custom languages of your site have been sanitized for security purposes. Visit the <a href="'. url('admin/settings/language') .'">Languages</a> page to check these and fix them if necessary.', 'warning');  }  // Check if some langcode values contain potentially dangerous characters and  // warn the user if so. These are not fixed since they are referenced in other  // tables (e.g. {node}).  if (db_result(db_query("SELECT 1 FROM {languages} WHERE language LIKE '%<%' OR language LIKE '%>%' OR language LIKE '%\"%' OR language LIKE '%\\\\\%'"))) {    drupal_set_message('Some of your custom language code values contain invalid characters. You should examine the <a href="'. url('admin/settings/language') .'">Languages</a> page. These must be fixed manually.', 'error');  }  return $ret;}/** * @} End of "defgroup updates-5.x-to-6.x" *//** * Implementation of hook_uninstall(). */function locale_uninstall() {  // Delete all JavaScript translation files  $files = db_query('SELECT javascript FROM {languages}');  while ($file = db_fetch_object($files)) {    if (!empty($file)) {      file_delete(file_create_path($file->javascript));    }  }  // Clear variables.  variable_del('language_default');  variable_del('language_count');  variable_del('language_content_type_default');  variable_del('language_content_type_negotiation');  variable_del('locale_cache_strings');  variable_del('locale_js_directory');  variable_del('javascript_parsed');  variable_del('language_negotiation');  foreach (node_get_types() as $type => $content_type) {    variable_del("language_content_type_$type");  }  // Switch back to English: with a $language->language value different from  // 'en' successive calls of t() might result in calling locale(), which in  // turn might try to query the unexisting {locales_source} and  // {locales_target} tables.  drupal_init_language();  // Remove tables.  drupal_uninstall_schema('locale');}/** * Implementation of hook_schema(). */function locale_schema() {  $schema['languages'] = array(    'description' => 'List of all available languages in the system.',    'fields' => array(      'language' => array(        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => '',        'description' => "Language code, e.g. 'de' or 'en-US'.",      ),      'name' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Language name in English.',      ),      'native' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Native language name.',      ),      'direction' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Direction of language (Left-to-Right = 0, Right-to-Left = 1).',      ),      'enabled' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Enabled flag (1 = Enabled, 0 = Disabled).',      ),      'plurals' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Number of plural indexes in this language.',      ),      'formula' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Plural formula in PHP code to evaluate to get plural indexes.',      ),      'domain' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Domain to use for this language.',      ),      'prefix' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Path prefix to use for this language.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Weight, used in lists of languages.',      ),      'javascript' => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '',        'description' => 'Location of JavaScript translation file.',      ),    ),    'primary key' => array('language'),    'indexes' => array(      'list' => array('weight', 'name'),    ),  );  $schema['locales_source'] = array(    'description' => 'List of English source strings.',    'fields' => array(      'lid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Unique identifier of this string.',      ),      'location' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Drupal path in case of online discovered translations or file path in case of imported strings.',      ),      'textgroup' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => 'default',        'description' => 'A module defined group of translations, see hook_locale().',      ),      'source' => array(        'type' => 'text',        'mysql_type' => 'blob',        'not null' => TRUE,        'description' => 'The original string in English.',      ),      'version' => array(        'type' => 'varchar',        'length' => 20,        'not null' => TRUE,        'default' => 'none',        'description' => 'Version of Drupal, where the string was last used (for locales optimization).',      ),    ),    'primary key' => array('lid'),    'indexes' => array(      'source' => array(array('source', 30)),    ),  );  $schema['locales_target'] = array(    'description' => 'Stores translated versions of strings.',    'fields' => array(      'lid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Source string ID. References {locales_source}.lid.',      ),      'translation' => array(        'type' => 'text',        'mysql_type' => 'blob',        'not null' => TRUE,        'description' => 'Translation string value in this language.',      ),      'language' => array(        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => '',        'description' => 'Language code. References {languages}.language.',      ),      'plid' => array(        'type' => 'int',        'not null' => TRUE, // This should be NULL for no referenced string, not zero.        'default' => 0,        'description' => 'Parent lid (lid of the previous string in the plural chain) in case of plural strings. References {locales_source}.lid.',      ),      'plural' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Plural index number in case of plural strings.',      ),    ),    'primary key' => array('language', 'lid', 'plural'),    'indexes' => array(      'lid'      => array('lid'),      'plid'     => array('plid'),      'plural'   => array('plural'),    ),  );  return $schema;}
<?php// $Id$/** * @file * Administrative page callbacks for the taxonomy module. *//** * Form builder to list and manage vocabularies. * * @ingroup forms * @see taxonomy_overview_vocabularies_submit() * @see theme_taxonomy_overview_vocabularies() */function taxonomy_overview_vocabularies() {  $vocabularies = taxonomy_get_vocabularies();  $form = array('#tree' => TRUE);  foreach ($vocabularies as $vocabulary) {    $types = array();    foreach ($vocabulary->nodes as $type) {      $node_type = node_get_types('name', $type);      $types[] = $node_type ? check_plain($node_type) : check_plain($type);    }    $form[$vocabulary->vid]['#vocabulary'] = (array)$vocabulary;    $form[$vocabulary->vid]['name'] = array('#value' => check_plain($vocabulary->name));    $form[$vocabulary->vid]['types'] = array('#value' => implode(', ', $types));    $form[$vocabulary->vid]['weight'] = array('#type' => 'weight', '#delta' => 10, '#default_value' => $vocabulary->weight);    $form[$vocabulary->vid]['edit'] = array('#value' => l(t('edit vocabulary'), "admin/content/taxonomy/edit/vocabulary/$vocabulary->vid"));    $form[$vocabulary->vid]['list'] = array('#value' => l(t('list terms'), "admin/content/taxonomy/$vocabulary->vid"));    $form[$vocabulary->vid]['add'] = array('#value' => l(t('add terms'), "admin/content/taxonomy/$vocabulary->vid/add/term"));  }  // Only make this form include a submit button and weight if more than one  // vocabulary exists.  if (count($vocabularies) > 1) {    $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));  }  elseif (isset($vocabulary)) {    unset($form[$vocabulary->vid]['weight']);  }  return $form;}/** * Submit handler for vocabularies overview. Updates changed vocabulary weights. * * @see taxonomy_overview_vocabularies() */function taxonomy_overview_vocabularies_submit($form, &$form_state) {  foreach ($form_state['values'] as $vid => $vocabulary) {    if (is_numeric($vid) && $form[$vid]['#vocabulary']['weight'] != $form_state['values'][$vid]['weight']) {      $form[$vid]['#vocabulary']['weight'] = $form_state['values'][$vid]['weight'];      taxonomy_save_vocabulary($form[$vid]['#vocabulary']);    }  }}/** * Theme the vocabulary overview as a sortable list of vocabularies. * * @ingroup themeable * @see taxonomy_overview_vocabularies() */function theme_taxonomy_overview_vocabularies($form) {  $rows = array();  foreach (element_children($form) as $key) {    if (isset($form[$key]['name'])) {      $vocabulary = &$form[$key];      $row = array();      $row[] = drupal_render($vocabulary['name']);      $row[] = drupal_render($vocabulary['types']);      if (isset($vocabulary['weight'])) {        $vocabulary['weight']['#attributes']['class'] = 'vocabulary-weight';        $row[] = drupal_render($vocabulary['weight']);      }      $row[] = drupal_render($vocabulary['edit']);      $row[] = drupal_render($vocabulary['list']);      $row[] = drupal_render($vocabulary['add']);      $rows[] = array('data' => $row, 'class' => 'draggable');    }  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No vocabularies available.'), 'colspan' => '5'));  }  $header = array(t('Name'), t('Type'));  if (isset($form['submit'])) {    $header[] = t('Weight');    drupal_add_tabledrag('taxonomy', 'order', 'sibling', 'vocabulary-weight');  }  $header[] = array('data' => t('Operations'), 'colspan' => '3');  return theme('table', $header, $rows, array('id' => 'taxonomy')) . drupal_render($form);}/** * Display form for adding and editing vocabularies. * * @ingroup forms * @see taxonomy_form_vocabulary_submit() */function taxonomy_form_vocabulary(&$form_state, $edit = array()) {  $edit += array(    'name' => '',    'description' => '',    'help' => '',    'nodes' => array(),    'hierarchy' => 0,    'relations' => 0,    'tags' => 0,    'multiple' => 0,    'required' => 0,    'weight' => 0,  );  $form['identification'] = array(    '#type' => 'fieldset',    '#title' => t('Identification'),    '#collapsible' => TRUE,  );  $form['identification']['name'] = array('#type' => 'textfield',    '#title' => t('Vocabulary name'),    '#default_value' => $edit['name'],    '#maxlength' => 255,    '#description' => t('The name for this vocabulary, e.g., <em>"Tags"</em>.'),    '#required' => TRUE,  );  $form['identification']['description'] = array('#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],    '#description' => t('Description of the vocabulary; can be used by modules.'),  );  $form['identification']['help'] = array('#type' => 'textfield',    '#title' => t('Help text'),    '#maxlength' => 255,    '#default_value' => $edit['help'],    '#description' => t('Instructions to present to the user when selecting terms, e.g., <em>"Enter a comma separated list of words"</em>.'),  );  $form['content_types'] = array(    '#type' => 'fieldset',    '#title' => t('Content types'),    '#collapsible' => TRUE,  );  $form['content_types']['nodes'] = array('#type' => 'checkboxes',    '#title' => t('Content types'),    '#default_value' => $edit['nodes'],    '#options' => array_map('check_plain', node_get_types('names')),    '#description' => t('Select content types to categorize using this vocabulary.'),  );  $form['settings'] = array(    '#type' => 'fieldset',    '#title' => t('Settings'),    '#collapsible' => TRUE,  );  $form['settings']['tags'] = array('#type' => 'checkbox',    '#title' => t('Tags'),    '#default_value' => $edit['tags'],    '#description' => t('Terms are created by users when submitting posts by typing a comma separated list.'),  );  $form['settings']['multiple'] = array('#type' => 'checkbox',    '#title' => t('Multiple select'),    '#default_value' => $edit['multiple'],    '#description' => t('Allows posts to have more than one term from this vocabulary (always true for tags).'),  );  $form['settings']['required'] = array('#type' => 'checkbox',    '#title' => t('Required'),    '#default_value' => $edit['required'],    '#description' => t('At least one term in this vocabulary must be selected when submitting a post.'),  );  $form['settings']['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('Vocabularies are displayed in ascending order by weight.'),  );  // Set the hierarchy to "multiple parents" by default. This simplifies the  // vocabulary form and standardizes the term form.  $form['hierarchy'] = array('#type' => 'value',    '#value' => '0',  );  // Enable "related terms" by default.  $form['relations'] = array('#type' => 'value',    '#value' => '1',  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));  if (isset($edit['vid'])) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['vid'] = array('#type' => 'value', '#value' => $edit['vid']);    $form['module'] = array('#type' => 'value', '#value' => $edit['module']);  }  return $form;}/** * Accept the form submission for a vocabulary and save the results. */function taxonomy_form_vocabulary_submit($form, &$form_state) {  // Fix up the nodes array to remove unchecked nodes.  $form_state['values']['nodes'] = array_filter($form_state['values']['nodes']);  switch (taxonomy_save_vocabulary($form_state['values'])) {    case SAVED_NEW:      drupal_set_message(t('Created new vocabulary %name.', array('%name' => $form_state['values']['name'])));      watchdog('taxonomy', 'Created new vocabulary %name.', array('%name' => $form_state['values']['name']), WATCHDOG_NOTICE, l(t('edit'), 'admin/content/taxonomy/edit/vocabulary/'. $form_state['values']['vid']));      break;    case SAVED_UPDATED:      drupal_set_message(t('Updated vocabulary %name.', array('%name' => $form_state['values']['name'])));      watchdog('taxonomy', 'Updated vocabulary %name.', array('%name' => $form_state['values']['name']), WATCHDOG_NOTICE, l(t('edit'), 'admin/content/taxonomy/edit/vocabulary/'. $form_state['values']['vid']));      break;  }  $form_state['vid'] = $form_state['values']['vid'];  $form_state['redirect'] = 'admin/content/taxonomy';  return;}/** * Page to edit a vocabulary. */function taxonomy_admin_vocabulary_edit($vocabulary) {  if ((isset($_POST['op']) && $_POST['op'] == t('Delete')) || isset($_POST['confirm'])) {    return drupal_get_form('taxonomy_vocabulary_confirm_delete', $vocabulary->vid);  }  return drupal_get_form('taxonomy_form_vocabulary', (array)$vocabulary);}/** * Page to edit a vocabulary term. */function taxonomy_admin_term_edit($tid) {  if ($term = (array)taxonomy_get_term($tid)) {    return drupal_get_form('taxonomy_form_term', taxonomy_vocabulary_load($term['vid']), $term);  }  return drupal_not_found();}/** * Form builder for the taxonomy terms overview. * * Display a tree of all the terms in a vocabulary, with options to edit * each one. The form is made drag and drop by the theme function. * * @ingroup forms * @see taxonomy_overview_terms_submit() * @see theme_taxonomy_overview_terms() */function taxonomy_overview_terms(&$form_state, $vocabulary) {  global $pager_page_array, $pager_total, $pager_total_items;  // Check for confirmation forms.  if (isset($form_state['confirm_reset_alphabetical'])) {    return taxonomy_vocabulary_confirm_reset_alphabetical($form_state, $vocabulary->vid);  }  drupal_set_title(t('Terms in %vocabulary', array('%vocabulary' => $vocabulary->name)));  $form = array(    '#vocabulary' => (array)$vocabulary,    '#tree' => TRUE,    '#parent_fields' => FALSE,  );  $page            = isset($_GET['page']) ? $_GET['page'] : 0;  $page_increment  = variable_get('taxonomy_terms_per_page_admin', 100);  // Number of terms per page.  $page_entries    = 0;   // Elements shown on this page.  $before_entries  = 0;   // Elements at the root level before this page.  $after_entries   = 0;   // Elements at the root level after this page.  $root_entries    = 0;   // Elements at the root level on this page.  // Terms from previous and next pages are shown if the term tree would have  // been cut in the middle. Keep track of how many extra terms we show on each  // page of terms.  $back_peddle    = NULL;  $forward_peddle = 0;  // An array of the terms to be displayed on this page.  $current_page = array();  // Case for free tagging.  if ($vocabulary->tags) {    // We are not calling taxonomy_get_tree because that might fail with a big    // number of tags in the freetagging vocabulary.    $results = pager_query(db_rewrite_sql('SELECT t.*, h.parent FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE t.vid = %d ORDER BY weight, name', 't', 'tid'), $page_increment, 0, NULL, $vocabulary->vid);    $total_entries = db_query(db_rewrite_sql('SELECT count(*) FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE t.vid = %d', 't', 'tid'), $page_increment, 0, NULL, $vocabulary->vid);    while ($term = db_fetch_object($results)) {      $key = 'tid:'. $term->tid .':0';      $current_page[$key] = $term;      $page_entries++;    }  }  // Case for restricted vocabulary.  else {    $term_deltas = array();    $tree = taxonomy_get_tree($vocabulary->vid);    $term = current($tree);    do {      // In case this tree is completely empty.      if (empty($term)) {        break;      }      // Count entries before the current page.      if ($page && ($page * $page_increment) > $before_entries && !isset($back_peddle)) {        $before_entries++;        continue;      }      // Count entries after the current page.      elseif ($page_entries > $page_increment && isset($complete_tree)) {        $after_entries++;        continue;      }      // Do not let a term start the page that is not at the root.      if (isset($term->depth) && ($term->depth > 0) && !isset($back_peddle)) {        $back_peddle = 0;        while ($pterm = prev($tree)) {          $before_entries--;          $back_peddle++;          if ($pterm->depth == 0) {            prev($tree);            continue 2; // Jump back to the start of the root level parent.          }        }      }      $back_peddle = isset($back_peddle) ? $back_peddle : 0;      // Continue rendering the tree until we reach the a new root item.      if ($page_entries >= $page_increment + $back_peddle + 1 && $term->depth == 0 && $root_entries > 1) {        $complete_tree = TRUE;        // This new item at the root level is the first item on the next page.        $after_entries++;        continue;      }      if ($page_entries >= $page_increment + $back_peddle) {        $forward_peddle++;      }      // Finally, if we've gotten down this far, we're rendering a term on this page.      $page_entries++;      $term_deltas[$term->tid] = isset($term_deltas[$term->tid]) ? $term_deltas[$term->tid] + 1 : 0;      $key = 'tid:'. $term->tid .':'. $term_deltas[$term->tid];      // Keep track of the first term displayed on this page.      if ($page_entries == 1) {        $form['#first_tid'] = $term->tid;      }      // Keep a variable to make sure at least 2 root elements are displayed.      if ($term->parents[0] == 0) {        $root_entries++;      }      $current_page[$key] = $term;    } while ($term = next($tree));    // Because we didn't use a pager query, set the necessary pager variables.    $total_entries = $before_entries + $page_entries + $after_entries;    $pager_total_items[0] = $total_entries;    $pager_page_array[0] = $page;    $pager_total[0] = ceil($total_entries / $page_increment);  }  // If this form was already submitted once, it's probably hit a validation  // error. Ensure the form is rebuilt in the same order as the user submitted.  if (!empty($form_state['post'])) {    $order = array_flip(array_keys($form_state['post'])); // Get the $_POST order.    $current_page = array_merge($order, $current_page); // Update our form with the new order.    foreach ($current_page as $key => $term) {      // Verify this is a term for the current page and set at the current depth.      if (is_array($form_state['post'][$key]) && is_numeric($form_state['post'][$key]['tid'])) {        $current_page[$key]->depth = $form_state['post'][$key]['depth'];      }      else {        unset($current_page[$key]);      }    }  }  // Build the actual form.  foreach ($current_page as $key => $term) {    // Save the term for the current page so we don't have to load it a second time.    $form[$key]['#term'] = (array)$term;    if (isset($term->parents)) {      $form[$key]['#term']['parent'] = $term->parent = $term->parents[0];      unset($form[$key]['#term']['parents'], $term->parents);    }    $form[$key]['view'] = array('#value' => l($term->name, "taxonomy/term/$term->tid"));    if (!$vocabulary->tags && $vocabulary->hierarchy < 2 && count($tree) > 1) {      $form['#parent_fields'] = TRUE;      $form[$key]['tid'] = array(        '#type' => 'hidden',        '#value' => $term->tid      );      $form[$key]['parent'] = array(        '#type' => 'hidden',        // Yes, default_value on a hidden. It needs to be changeable by the javascript.        '#default_value' => $term->parent,      );      $form[$key]['depth'] = array(        '#type' => 'hidden',        // Same as above, the depth is modified by javascript, so it's a default_value.        '#default_value' => $term->depth,      );    }    $form[$key]['edit'] = array('#value' => l(t('edit'), "admin/content/taxonomy/edit/term/$term->tid", array('query' => drupal_get_destination())));  }  $form['#total_entries'] = $total_entries;  $form['#page_increment'] = $page_increment;  $form['#page_entries'] = $page_entries;  $form['#back_peddle'] = $back_peddle;  $form['#forward_peddle'] = $forward_peddle;  $form['#empty_text'] = t('No terms available.');  if (!$vocabulary->tags && $vocabulary->hierarchy < 2 && count($tree) > 1) {    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Save')    );    $form['reset_alphabetical'] = array(      '#type' => 'submit',      '#value' => t('Reset to alphabetical')    );    $form['destination'] = array(      '#type' => 'hidden',      '#value' => $_GET['q'] . (isset($_GET['page']) ? '?page='. $_GET['page'] : '')    );  }  return $form;}/** * Submit handler for terms overview form. * * Rather than using a textfield or weight field, this form depends entirely * upon the order of form elements on the page to determine new weights. * * Because there might be hundreds or thousands of taxonomy terms that need to * be ordered, terms are weighted from 0 to the number of terms in the * vocabulary, rather than the standard -10 to 10 scale. Numbers are sorted * lowest to highest, but are not necessarily sequential. Numbers may be skipped * when a term has children so that reordering is minimal when a child is * added or removed from a term. * * @see taxonomy_overview_terms() */function taxonomy_overview_terms_submit($form, &$form_state) {  if ($form_state['clicked_button']['#value'] == t('Reset to alphabetical')) {    // Execute the reset action.    if ($form_state['values']['reset_alphabetical'] === TRUE) {      return taxonomy_vocabulary_confirm_reset_alphabetical_submit($form, $form_state);    }    // Rebuild the form to confirm the reset action.    $form_state['rebuild'] = TRUE;    $form_state['confirm_reset_alphabetical'] = TRUE;    return;  }  $order = array_flip(array_keys($form['#post'])); // Get the $_POST order.  $form_state['values'] = array_merge($order, $form_state['values']); // Update our original form with the new order.  $vocabulary = $form['#vocabulary'];  $hierarchy = 0; // Update the current hierarchy type as we go.  $changed_terms = array();  $tree = taxonomy_get_tree($vocabulary['vid']);  if (empty($tree)) {    return;  }  // Build a list of all terms that need to be updated on previous pages.  $weight = 0;  $term = (array)$tree[0];  while ($term['tid'] != $form['#first_tid']) {    if ($term['parents'][0] == 0 && $term['weight'] != $weight) {      $term['parent'] = $term['parents'][0];      $term['weight'] = $weight;      $changed_terms[$term['tid']] = $term;    }    $weight++;    $hierarchy = $term['parents'][0] != 0 ? 1 : $hierarchy;    $term = (array)$tree[$weight];  }  // Renumber the current page weights and assign any new parents.  $level_weights = array();  foreach ($form_state['values'] as $tid => $values) {    if (isset($form[$tid]['#term'])) {      $term = $form[$tid]['#term'];      // Give terms at the root level a weight in sequence with terms on previous pages.      if ($values['parent'] == 0 && $term['weight'] != $weight) {        $term['weight'] = $weight;        $changed_terms[$term['tid']] = $term;      }      // Terms not at the root level can safely start from 0 because they're all on this page.      elseif ($values['parent'] > 0) {        $level_weights[$values['parent']] = isset($level_weights[$values['parent']]) ? $level_weights[$values['parent']] + 1 : 0;        if ($level_weights[$values['parent']] != $term['weight']) {          $term['weight'] = $level_weights[$values['parent']];          $changed_terms[$term['tid']] = $term;        }      }      // Update any changed parents.      if ($values['parent'] != $term['parent']) {        $term['parent'] = $values['parent'];        $changed_terms[$term['tid']] = $term;      }      $hierarchy = $term['parent'] != 0 ? 1 : $hierarchy;      $weight++;    }  }  // Build a list of all terms that need to be updated on following pages.  for ($weight; $weight < count($tree); $weight++) {    $term = (array)$tree[$weight];    if ($term['parents'][0] == 0 && $term['weight'] != $weight) {      $term['parent'] = $term['parents'][0];      $term['weight'] = $weight;      $changed_terms[$term['tid']] = $term;    }    $hierarchy = $term['parents'][0] != 0 ? 1 : $hierarchy;  }  // Save all updated terms.  foreach ($changed_terms as $term) {    taxonomy_save_term($term);  }  // Update the vocabulary hierarchy to flat or single hierarchy.  if ($vocabulary['hierarchy'] != $hierarchy) {    $vocabulary['hierarchy'] = $hierarchy;    taxonomy_save_vocabulary($vocabulary);  }}/** * Theme the terms overview as a sortable list of terms. * * @ingroup themeable * @see taxonomy_overview_terms() */function theme_taxonomy_overview_terms($form) {  $page_increment  = $form['#page_increment'];  $page_entries    = $form['#page_entries'];  $back_peddle     = $form['#back_peddle'];  $forward_peddle  = $form['#forward_peddle'];  // Add drag and drop if parent fields are present in the form.  if ($form['#parent_fields']) {    drupal_add_tabledrag('taxonomy', 'match', 'parent', 'term-parent', 'term-parent', 'term-id', FALSE);    drupal_add_tabledrag('taxonomy', 'depth', 'group', 'term-depth', NULL, NULL, FALSE);    drupal_add_js(drupal_get_path('module', 'taxonomy') .'/taxonomy.js');    drupal_add_js(array('taxonomy' => array('backPeddle' => $back_peddle, 'forwardPeddle' => $forward_peddle)), 'setting');    drupal_add_css(drupal_get_path('module', 'taxonomy') .'/taxonomy.css');  }  $errors = form_get_errors() != FALSE ? form_get_errors() : array();  $rows = array();  foreach (element_children($form) as $key) {    if (isset($form[$key]['#term'])) {      $term = &$form[$key];      $row = array();      $row[] = (isset($term['#term']['depth']) && $term['#term']['depth'] > 0 ? theme('indentation', $term['#term']['depth']) : '') . drupal_render($term['view']);      if ($form['#parent_fields']) {        $term['tid']['#attributes']['class'] = 'term-id';        $term['parent']['#attributes']['class'] = 'term-parent';        $term['depth']['#attributes']['class'] = 'term-depth';        $row[0] .= drupal_render($term['parent']) . drupal_render($term['tid']) . drupal_render($term['depth']);      }      $row[] = drupal_render($term['edit']);      $row = array('data' => $row);      $rows[$key] = $row;    }  }  // Add necessary classes to rows.  $row_position = 0;  foreach ($rows as $key => $row) {    $classes = array();    if (isset($form['#parent_fields'])) {      $classes[] = 'draggable';    }    // Add classes that mark which terms belong to previous and next pages.    if ($row_position < $back_peddle || $row_position >= $page_entries - $forward_peddle) {      $classes[] = 'taxonomy-term-preview';    }    if ($row_position !== 0 && $row_position !== count($rows) - 1) {      if ($row_position == $back_peddle - 1 || $row_position == $page_entries - $forward_peddle - 1) {        $classes[] = 'taxonomy-term-divider-top';      }      elseif ($row_position == $back_peddle || $row_position == $page_entries - $forward_peddle) {        $classes[] = 'taxonomy-term-divider-bottom';      }    }    // Add an error class if this row contains a form error.    foreach ($errors as $error_key => $error) {      if (strpos($error_key, $key) === 0) {        $classes[] = 'error';      }    }    $rows[$key]['class'] = implode(' ', $classes);    $row_position++;  }  if (empty($rows)) {    $rows[] = array(array('data' => $form['#empty_text'], 'colspan' => '2'));  }  $header = array(t('Name'), t('Operations'));  $output = theme('table', $header, $rows, array('id' => 'taxonomy'));  $output .= drupal_render($form);  $output .= theme('pager', NULL, $page_increment);  return $output;}/** * Menu callback; return the edit form for a new term after setting the title. */function taxonomy_add_term_page($vocabulary) {  drupal_set_title(t('Add term to %vocabulary', array('%vocabulary' => $vocabulary->name)));  return drupal_get_form('taxonomy_form_term' , $vocabulary);}/** * Form function for the term edit form. * * @ingroup forms * @see taxonomy_form_term_submit() */function taxonomy_form_term(&$form_state, $vocabulary, $edit = array()) {  $edit += array(    'name' => '',    'description' => '',    'tid' => NULL,    'weight' => 0,  );  $parent = array_keys(taxonomy_get_parents($edit['tid']));  $form['#term'] = $edit;  $form['#term']['parent'] = $parent;  $form['#vocabulary'] = (array)$vocabulary;  $form['#vocabulary']['nodes'] = drupal_map_assoc($vocabulary->nodes);;  // Check for confirmation forms.  if (isset($form_state['confirm_delete'])) {    return array_merge($form, taxonomy_term_confirm_delete($form_state, $edit['tid']));  }  elseif (isset($form_state['confirm_parents'])) {    return array_merge($form, taxonomy_term_confirm_parents($form_state, $vocabulary));  }  $form['identification'] = array(    '#type' => 'fieldset',    '#title' => t('Identification'),    '#collapsible' => TRUE,  );  $form['identification']['name'] = array(    '#type' => 'textfield',    '#title' => t('Term name'),    '#default_value' => $edit['name'],    '#maxlength' => 255,    '#description' => t('The name of this term.'),    '#required' => TRUE);  $form['identification']['description'] = array(    '#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],    '#description' => t('A description of the term. To be displayed on taxonomy/term pages and RSS feeds.'));  $form['advanced'] = array(    '#type' => 'fieldset',    '#title' => t('Advanced options'),    '#collapsible' => TRUE,    '#collapsed' => $vocabulary->hierarchy > 1 ? FALSE : TRUE,  );  // taxonomy_get_tree and taxonomy_get_parents may contain large numbers of  // items so we check for taxonomy_override_selector before loading the  // full vocabulary. Contrib modules can then intercept before  // hook_form_alter to provide scalable alternatives.  if (!variable_get('taxonomy_override_selector', FALSE)) {    $parent = array_keys(taxonomy_get_parents($edit['tid']));    $children = taxonomy_get_tree($vocabulary->vid, $edit['tid']);    // A term can't be the child of itself, nor of its children.    foreach ($children as $child) {      $exclude[] = $child->tid;    }    $exclude[] = $edit['tid'];    $form['advanced']['parent'] = _taxonomy_term_select(t('Parents'), 'parent', $parent, $vocabulary->vid, t('Parent terms') .'.', 1, '<'. t('root') .'>', $exclude);    $form['advanced']['relations'] = _taxonomy_term_select(t('Related terms'), 'relations', array_keys(taxonomy_get_related($edit['tid'])), $vocabulary->vid, NULL, 1, '<'. t('none') .'>', array($edit['tid']));  }  $form['advanced']['synonyms'] = array(    '#type' => 'textarea',    '#title' => t('Synonyms'),    '#default_value' => implode("\n", taxonomy_get_synonyms($edit['tid'])),    '#description' => t('Synonyms of this term, one synonym per line.'));  $form['advanced']['weight'] = array(    '#type' => 'textfield',    '#title' => t('Weight'),    '#size' => 6,    '#default_value' => $edit['weight'],    '#description' => t('Terms are displayed in ascending order by weight.'),    '#required' => TRUE);  $form['vid'] = array(    '#type' => 'value',    '#value' => $vocabulary->vid);  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save'));  if ($edit['tid']) {    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete'));    $form['tid'] = array(      '#type' => 'value',      '#value' => $edit['tid']);  }  else {    $form['destination'] = array('#type' => 'hidden', '#value' => $_GET['q']);  }  return $form;}/** * Validation handler for the term edit form. Ensure numeric weight values. * * @see taxonomy_form_term() */function taxonomy_form_term_validate($form, &$form_state) {  if (isset($form_state['values']['weight']) && !is_numeric($form_state['values']['weight'])) {    form_set_error('weight', t('Weight value must be numeric.'));  }}/** * Submit handler to insert or update a term. * * @see taxonomy_form_term() */function taxonomy_form_term_submit($form, &$form_state) {  if ($form_state['clicked_button']['#value'] == t('Delete')) {    // Execute the term deletion.    if ($form_state['values']['delete'] === TRUE) {      return taxonomy_term_confirm_delete_submit($form, $form_state);    }    // Rebuild the form to confirm term deletion.    $form_state['rebuild'] = TRUE;    $form_state['confirm_delete'] = TRUE;    return;  }  // Rebuild the form to confirm enabling multiple parents.  elseif ($form_state['clicked_button']['#value'] == t('Save') && !$form['#vocabulary']['tags'] && count($form_state['values']['parent']) > 1 && $form['#vocabulary']['hierarchy'] < 2) {    $form_state['rebuild'] = TRUE;    $form_state['confirm_parents'] = TRUE;    return;  }  switch (taxonomy_save_term($form_state['values'])) {    case SAVED_NEW:      drupal_set_message(t('Created new term %term.', array('%term' => $form_state['values']['name'])));      watchdog('taxonomy', 'Created new term %term.', array('%term' => $form_state['values']['name']), WATCHDOG_NOTICE, l(t('edit'), 'admin/content/taxonomy/edit/term/'. $form_state['values']['tid']));      break;    case SAVED_UPDATED:      drupal_set_message(t('Updated term %term.', array('%term' => $form_state['values']['name'])));      watchdog('taxonomy', 'Updated term %term.', array('%term' => $form_state['values']['name']), WATCHDOG_NOTICE, l(t('edit'), 'admin/content/taxonomy/edit/term/'. $form_state['values']['tid']));      break;  }  if (!$form['#vocabulary']['tags']) {    $current_parent_count = count($form_state['values']['parent']);    $previous_parent_count = count($form['#term']['parent']);    // Root doesn't count if it's the only parent.    if ($current_parent_count == 1 && isset($form_state['values']['parent'][''])) {      $current_parent_count = 0;      $form_state['values']['parent'] = array();    }    // If the number of parents has been reduced to one or none, do a check on the    // parents of every term in the vocabulary value.    if ($current_parent_count < $previous_parent_count && $current_parent_count < 2) {      taxonomy_check_vocabulary_hierarchy($form['#vocabulary'], $form_state['values']);    }    // If we've increased the number of parents and this is a single or flat    // hierarchy, update the vocabulary immediately.    elseif ($current_parent_count > $previous_parent_count && $form['#vocabulary']['hierarchy'] < 2) {      $form['#vocabulary']['hierarchy'] = $current_parent_count == 1 ? 1 : 2;      taxonomy_save_vocabulary($form['#vocabulary']);    }  }  $form_state['tid'] = $form_state['values']['tid'];  $form_state['redirect'] = 'admin/content/taxonomy';  return;}/** * Form builder for the confirmation of multiple term parents. * * @ingroup forms * @see taxonomy_form_term() */function taxonomy_term_confirm_parents(&$form_state, $vocabulary) {  $form = array();  foreach (element_children($form_state['values']) as $key) {    $form[$key] = array(      '#type' => 'value',      '#value' => $form_state['values'][$key],    );  }  $question = t('Set multiple term parents?');  $description = '<p>'. t("Adding multiple parents to a term will cause the %vocabulary vocabulary to look for multiple parents on every term. Because multiple parents are not supported when using the drag and drop outline interface, drag and drop will be disabled if you enable this option. If you choose to have multiple parents, you will only be able to set parents by using the term edit form.", array('%vocabulary' => $vocabulary->name)) .'</p>';  $description .= '<p>'. t("You may re-enable the drag and drop interface at any time by reducing multiple parents to a single parent for the terms in this vocabulary.") .'</p>';  return confirm_form($form, $question, drupal_get_destination(), $description, t('Set multiple parents'));}/** * Form builder for the term delete form. * * @ingroup forms * @see taxonomy_term_confirm_delete_submit() */function taxonomy_term_confirm_delete(&$form_state, $tid) {  $term = taxonomy_get_term($tid);  $form['type'] = array('#type' => 'value', '#value' => 'term');  $form['name'] = array('#type' => 'value', '#value' => $term->name);  $form['tid'] = array('#type' => 'value', '#value' => $tid);  $form['delete'] = array('#type' => 'value', '#value' => TRUE);  return confirm_form($form,                  t('Are you sure you want to delete the term %title?',                  array('%title' => $term->name)),                  'admin/content/taxonomy',                  t('Deleting a term will delete all its children if there are any. This action cannot be undone.'),                  t('Delete'),                  t('Cancel'));}/** * Submit handler to delete a term after confirmation. * * @see taxonomy_term_confirm_delete() */function taxonomy_term_confirm_delete_submit($form, &$form_state) {  taxonomy_del_term($form_state['values']['tid']);  taxonomy_check_vocabulary_hierarchy($form['#vocabulary'], $form_state['values']);  drupal_set_message(t('Deleted term %name.', array('%name' => $form_state['values']['name'])));  watchdog('taxonomy', 'Deleted term %name.', array('%name' => $form_state['values']['name']), WATCHDOG_NOTICE);  $form_state['redirect'] = 'admin/content/taxonomy';  return;}/** * Form builder for the vocabulary delete confirmation form. * * @ingroup forms * @see taxonomy_vocabulary_confirm_delete_submit() */function taxonomy_vocabulary_confirm_delete(&$form_state, $vid) {  $vocabulary = taxonomy_vocabulary_load($vid);  $form['type'] = array('#type' => 'value', '#value' => 'vocabulary');  $form['vid'] = array('#type' => 'value', '#value' => $vid);  $form['name'] = array('#type' => 'value', '#value' => $vocabulary->name);  return confirm_form($form,                  t('Are you sure you want to delete the vocabulary %title?',                  array('%title' => $vocabulary->name)),                  'admin/content/taxonomy',                  t('Deleting a vocabulary will delete all the terms in it. This action cannot be undone.'),                  t('Delete'),                  t('Cancel'));}/** * Submit handler to delete a vocabulary after confirmation. * * @see taxonomy_vocabulary_confirm_delete() */function taxonomy_vocabulary_confirm_delete_submit($form, &$form_state) {  $status = taxonomy_del_vocabulary($form_state['values']['vid']);  drupal_set_message(t('Deleted vocabulary %name.', array('%name' => $form_state['values']['name'])));  watchdog('taxonomy', 'Deleted vocabulary %name.', array('%name' => $form_state['values']['name']), WATCHDOG_NOTICE);  $form_state['redirect'] = 'admin/content/taxonomy';  return;}/** * Form builder to confirm reseting a vocabulary to alphabetical order. * * @ingroup forms * @see taxonomy_vocabulary_confirm_reset_alphabetical_submit() */function taxonomy_vocabulary_confirm_reset_alphabetical(&$form_state, $vid) {  $vocabulary = taxonomy_vocabulary_load($vid);  $form['type'] = array('#type' => 'value', '#value' => 'vocabulary');  $form['vid'] = array('#type' => 'value', '#value' => $vid);  $form['name'] = array('#type' => 'value', '#value' => $vocabulary->name);  $form['reset_alphabetical'] = array('#type' => 'value', '#value' => TRUE);  return confirm_form($form,                  t('Are you sure you want to reset the vocabulary %title to alphabetical order?',                  array('%title' => $vocabulary->name)),                  'admin/content/taxonomy/'. $vid,                  t('Resetting a vocabulary will discard all custom ordering and sort items alphabetically.'),                  t('Reset to alphabetical'),                  t('Cancel'));}/** * Submit handler to reset a vocabulary to alphabetical order after confirmation. * * @see taxonomy_vocabulary_confirm_reset_alphabetical() */function taxonomy_vocabulary_confirm_reset_alphabetical_submit($form, &$form_state) {  db_query('UPDATE {term_data} t SET weight = 0 WHERE vid = %d', $form_state['values']['vid']);  drupal_set_message(t('Reset vocabulary %name to alphabetical order.', array('%name' => $form_state['values']['name'])));  watchdog('taxonomy', 'Reset vocabulary %name to alphabetical order.', array('%name' => $form_state['values']['name']), WATCHDOG_NOTICE);  $form_state['redirect'] = 'admin/content/taxonomy/'. $form_state['values']['vid'];}
<?php// $Id$/** * @file * API for the Drupal menu system. *//** * @defgroup menu Menu system * @{ * Define the navigation menus, and route page requests to code based on URLs. * * The Drupal menu system drives both the navigation system from a user * perspective and the callback system that Drupal uses to respond to URLs * passed from the browser. For this reason, a good understanding of the * menu system is fundamental to the creation of complex modules. * * Drupal's menu system follows a simple hierarchy defined by paths. * Implementations of hook_menu() define menu items and assign them to * paths (which should be unique). The menu system aggregates these items * and determines the menu hierarchy from the paths. For example, if the * paths defined were a, a/b, e, a/b/c/d, f/g, and a/b/h, the menu system * would form the structure: * - a *   - a/b *     - a/b/c/d *     - a/b/h * - e * - f/g * Note that the number of elements in the path does not necessarily * determine the depth of the menu item in the tree. * * When responding to a page request, the menu system looks to see if the * path requested by the browser is registered as a menu item with a * callback. If not, the system searches up the menu tree for the most * complete match with a callback it can find. If the path a/b/i is * requested in the tree above, the callback for a/b would be used. * * The found callback function is called with any arguments specified * in the "page arguments" attribute of its menu item. The * attribute must be an array. After these arguments, any remaining * components of the path are appended as further arguments. In this * way, the callback for a/b above could respond to a request for * a/b/i differently than a request for a/b/j. * * For an illustration of this process, see page_example.module. * * Access to the callback functions is also protected by the menu system. * The "access callback" with an optional "access arguments" of each menu * item is called before the page callback proceeds. If this returns TRUE, * then access is granted; if FALSE, then access is denied. Menu items may * omit this attribute to use the value provided by an ancestor item. * * In the default Drupal interface, you will notice many links rendered as * tabs. These are known in the menu system as "local tasks", and they are * rendered as tabs by default, though other presentations are possible. * Local tasks function just as other menu items in most respects. It is * convention that the names of these tasks should be short verbs if * possible. In addition, a "default" local task should be provided for * each set. When visiting a local task's parent menu item, the default * local task will be rendered as if it is selected; this provides for a * normal tab user experience. This default task is special in that it * links not to its provided path, but to its parent item's path instead. * The default task's path is only used to place it appropriately in the * menu hierarchy. * * Everything described so far is stored in the menu_router table. The * menu_links table holds the visible menu links. By default these are * derived from the same hook_menu definitions, however you are free to * add more with menu_link_save(). *//** * @name Menu flags * @{ * Flags for use in the "type" attribute of menu items. */define('MENU_IS_ROOT', 0x0001);define('MENU_VISIBLE_IN_TREE', 0x0002);define('MENU_VISIBLE_IN_BREADCRUMB', 0x0004);define('MENU_LINKS_TO_PARENT', 0x0008);define('MENU_MODIFIED_BY_ADMIN', 0x0020);define('MENU_CREATED_BY_ADMIN', 0x0040);define('MENU_IS_LOCAL_TASK', 0x0080);/** * @} End of "Menu flags". *//** * @name Menu item types * @{ * Menu item definitions provide one of these constants, which are shortcuts for * combinations of the above flags. *//** * Normal menu items show up in the menu tree and can be moved/hidden by * the administrator. Use this for most menu items. It is the default value if * no menu item type is specified. */define('MENU_NORMAL_ITEM', MENU_VISIBLE_IN_TREE | MENU_VISIBLE_IN_BREADCRUMB);/** * Callbacks simply register a path so that the correct function is fired * when the URL is accessed. They are not shown in the menu. */define('MENU_CALLBACK', MENU_VISIBLE_IN_BREADCRUMB);/** * Modules may "suggest" menu items that the administrator may enable. They act * just as callbacks do until enabled, at which time they act like normal items. * Note for the value: 0x0010 was a flag which is no longer used, but this way * the values of MENU_CALLBACK and MENU_SUGGESTED_ITEM are separate. */define('MENU_SUGGESTED_ITEM', MENU_VISIBLE_IN_BREADCRUMB | 0x0010);/** * Local tasks are rendered as tabs by default. Use this for menu items that * describe actions to be performed on their parent item. An example is the path * "node/52/edit", which performs the "edit" task on "node/52". */define('MENU_LOCAL_TASK', MENU_IS_LOCAL_TASK);/** * Every set of local tasks should provide one "default" task, that links to the * same path as its parent when clicked. */define('MENU_DEFAULT_LOCAL_TASK', MENU_IS_LOCAL_TASK | MENU_LINKS_TO_PARENT);/** * @} End of "Menu item types". *//** * @name Menu status codes * @{ * Status codes for menu callbacks. */define('MENU_FOUND', 1);define('MENU_NOT_FOUND', 2);define('MENU_ACCESS_DENIED', 3);define('MENU_SITE_OFFLINE', 4);/** * @} End of "Menu status codes". *//** * @Name Menu tree parameters * @{ * Menu tree */ /** * The maximum number of path elements for a menu callback */define('MENU_MAX_PARTS', 7);/** * The maximum depth of a menu links tree - matches the number of p columns. */define('MENU_MAX_DEPTH', 9);/** * @} End of "Menu tree parameters". *//** * Returns the ancestors (and relevant placeholders) for any given path. * * For example, the ancestors of node/12345/edit are: * - node/12345/edit * - node/12345/% * - node/%/edit * - node/%/% * - node/12345 * - node/% * - node * * To generate these, we will use binary numbers. Each bit represents a * part of the path. If the bit is 1, then it represents the original * value while 0 means wildcard. If the path is node/12/edit/foo * then the 1011 bitstring represents node/%/edit/foo where % means that * any argument matches that part.  We limit ourselves to using binary * numbers that correspond the patterns of wildcards of router items that * actually exists.  This list of 'masks' is built in menu_rebuild(). * * @param $parts *   An array of path parts, for the above example *   array('node', '12345', 'edit'). * @return *   An array which contains the ancestors and placeholders. Placeholders *   simply contain as many '%s' as the ancestors. */function menu_get_ancestors($parts) {  $number_parts = count($parts);  $placeholders = array();  $ancestors = array();  $length =  $number_parts - 1;  $end = (1 << $number_parts) - 1;  $masks = variable_get('menu_masks', array());  // Only examine patterns that actually exist as router items (the masks).  foreach ($masks as $i) {    if ($i > $end) {      // Only look at masks that are not longer than the path of interest.      continue;    }    elseif ($i < (1 << $length)) {      // We have exhausted the masks of a given length, so decrease the length.      --$length;    }    $current = '';    for ($j = $length; $j >= 0; $j--) {      if ($i & (1 << $j)) {        $current .= $parts[$length - $j];      }      else {        $current .= '%';      }      if ($j) {        $current .= '/';      }    }    $placeholders[] = "'%s'";    $ancestors[] = $current;  }  return array($ancestors, $placeholders);}/** * The menu system uses serialized arrays stored in the database for * arguments. However, often these need to change according to the * current path. This function unserializes such an array and does the * necessary change. * * Integer values are mapped according to the $map parameter. For * example, if unserialize($data) is array('view', 1) and $map is * array('node', '12345') then 'view' will not be changed because * it is not an integer, but 1 will as it is an integer. As $map[1] * is '12345', 1 will be replaced with '12345'. So the result will * be array('node_load', '12345'). * * @param @data *   A serialized array. * @param @map *   An array of potential replacements. * @return *   The $data array unserialized and mapped. */function menu_unserialize($data, $map) {  if ($data = unserialize($data)) {    foreach ($data as $k => $v) {      if (is_int($v)) {        $data[$k] = isset($map[$v]) ? $map[$v] : '';      }    }    return $data;  }  else {    return array();  }}/** * Replaces the statically cached item for a given path. * * @param $path *   The path. * @param $router_item *   The router item. Usually you take a router entry from menu_get_item and *   set it back either modified or to a different path. This lets you modify the *   navigation block, the page title, the breadcrumb and the page help in one *   call. */function menu_set_item($path, $router_item) {  menu_get_item($path, $router_item);}/** * Get a router item. * * @param $path *   The path, for example node/5. The function will find the corresponding *   node/% item and return that. * @param $router_item *   Internal use only. * @return *   The router item, an associate array corresponding to one row in the *   menu_router table. The value of key map holds the loaded objects. The *   value of key access is TRUE if the current user can access this page. *   The values for key title, page_arguments, access_arguments will be *   filled in based on the database values and the objects loaded. */function menu_get_item($path = NULL, $router_item = NULL) {  static $router_items;  if (!isset($path)) {    $path = $_GET['q'];  }  if (isset($router_item)) {    $router_items[$path] = $router_item;  }  if (!isset($router_items[$path])) {    $original_map = arg(NULL, $path);    $parts = array_slice($original_map, 0, MENU_MAX_PARTS);    list($ancestors, $placeholders) = menu_get_ancestors($parts);    if ($router_item = db_fetch_array(db_query_range('SELECT * FROM {menu_router} WHERE path IN ('. implode (',', $placeholders) .') ORDER BY fit DESC', $ancestors, 0, 1))) {      $map = _menu_translate($router_item, $original_map);      if ($map === FALSE) {        $router_items[$path] = FALSE;        return FALSE;      }      if ($router_item['access']) {        $router_item['map'] = $map;        $router_item['page_arguments'] = array_merge(menu_unserialize($router_item['page_arguments'], $map), array_slice($map, $router_item['number_parts']));      }    }    $router_items[$path] = $router_item;  }  return $router_items[$path];}/** * Execute the page callback associated with the current path */function menu_execute_active_handler($path = NULL) {  if (_menu_site_is_offline()) {    return MENU_SITE_OFFLINE;  }  // Rebuild if we know it's needed, or if the menu masks are missing which  // occurs rarely, likely due to a race condition of multiple rebuilds.  if (variable_get('menu_rebuild_needed', FALSE) || !variable_get('menu_masks', array())) {    menu_rebuild();  }  if ($router_item = menu_get_item($path)) {    if ($router_item['access']) {      if ($router_item['file']) {        require_once($router_item['file']);      }      return call_user_func_array($router_item['page_callback'], $router_item['page_arguments']);    }    else {      return MENU_ACCESS_DENIED;    }  }  return MENU_NOT_FOUND;}/** * Loads objects into the map as defined in the $item['load_functions']. * * @param $item *   A menu router or menu link item * @param $map *   An array of path arguments (ex: array('node', '5')) * @return *   Returns TRUE for success, FALSE if an object cannot be loaded. *   Names of object loading functions are placed in $item['load_functions']. *   Loaded objects are placed in $map[]; keys are the same as keys in the *   $item['load_functions'] array. *   $item['access'] is set to FALSE if an object cannot be loaded. */function _menu_load_objects(&$item, &$map) {  if ($load_functions = $item['load_functions']) {    // If someone calls this function twice, then unserialize will fail.    if ($load_functions_unserialized = unserialize($load_functions)) {      $load_functions = $load_functions_unserialized;    }    $path_map = $map;    foreach ($load_functions as $index => $function) {      if ($function) {        $value = isset($path_map[$index]) ? $path_map[$index] : '';        if (is_array($function)) {          // Set up arguments for the load function. These were pulled from          // 'load arguments' in the hook_menu() entry, but they need          // some processing. In this case the $function is the key to the          // load_function array, and the value is the list of arguments.          list($function, $args) = each($function);          $load_functions[$index] = $function;          // Some arguments are placeholders for dynamic items to process.          foreach ($args as $i => $arg) {            if ($arg === '%index') {              // Pass on argument index to the load function, so multiple              // occurances of the same placeholder can be identified.              $args[$i] = $index;            }            if ($arg === '%map') {              // Pass on menu map by reference. The accepting function must              // also declare this as a reference if it wants to modify              // the map.              $args[$i] = &$map;            }            if (is_int($arg)) {              $args[$i] = isset($path_map[$arg]) ? $path_map[$arg] : '';            }          }          array_unshift($args, $value);          $return = call_user_func_array($function, $args);        }        else {          $return = $function($value);        }        // If callback returned an error or there is no callback, trigger 404.        if ($return === FALSE) {          $item['access'] = FALSE;          $map = FALSE;          return FALSE;        }        $map[$index] = $return;      }    }    $item['load_functions'] = $load_functions;  }  return TRUE;}/** * Check access to a menu item using the access callback * * @param $item *   A menu router or menu link item * @param $map *   An array of path arguments (ex: array('node', '5')) * @return *   $item['access'] becomes TRUE if the item is accessible, FALSE otherwise. */function _menu_check_access(&$item, $map) {  // Determine access callback, which will decide whether or not the current  // user has access to this path.  $callback = empty($item['access_callback']) ? 0 : trim($item['access_callback']);  // Check for a TRUE or FALSE value.  if (is_numeric($callback)) {    $item['access'] = (bool)$callback;  }  else {    $arguments = menu_unserialize($item['access_arguments'], $map);    // As call_user_func_array is quite slow and user_access is a very common    // callback, it is worth making a special case for it.    if ($callback == 'user_access') {      $item['access'] = (count($arguments) == 1) ? user_access($arguments[0]) : user_access($arguments[0], $arguments[1]);    }    else {      $item['access'] = call_user_func_array($callback, $arguments);    }  }}/** * Localize the router item title using t() or another callback. * * Translate the title and description to allow storage of English title * strings in the database, yet display of them in the language required * by the current user. * * @param $item *   A menu router item or a menu link item. * @param $map *   The path as an array with objects already replaced. E.g., for path *   node/123 $map would be array('node', $node) where $node is the node *   object for node 123. * @param $link_translate *   TRUE if we are translating a menu link item; FALSE if we are *   translating a menu router item. * @return *   No return value. *   $item['title'] is localized according to $item['title_callback']. *   If an item's callback is check_plain(), $item['options']['html'] becomes *   TRUE. *   $item['description'] is translated using t(). *   When doing link translation and the $item['options']['attributes']['title'] *   (link title attribute) matches the description, it is translated as well. */function _menu_item_localize(&$item, $map, $link_translate = FALSE) {  $callback = $item['title_callback'];  $item['localized_options'] = $item['options'];  // If we are translating the title of a menu link, and its title is the same  // as the corresponding router item, then we can use the title information  // from the router. If it's customized, then we need to use the link title  // itself; can't localize.  // If we are translating a router item (tabs, page, breadcrumb), then we  // can always use the information from the router item.  if (!$link_translate || ($item['title'] == $item['link_title'])) {    // t() is a special case. Since it is used very close to all the time,    // we handle it directly instead of using indirect, slower methods.    if ($callback == 't') {      if (empty($item['title_arguments'])) {        $item['title'] = t($item['title']);      }      else {        $item['title'] = t($item['title'], menu_unserialize($item['title_arguments'], $map));      }    }    elseif ($callback) {      if (empty($item['title_arguments'])) {        $item['title'] = $callback($item['title']);      }      else {        $item['title'] = call_user_func_array($callback, menu_unserialize($item['title_arguments'], $map));      }      // Avoid calling check_plain again on l() function.      if ($callback == 'check_plain') {        $item['localized_options']['html'] = TRUE;      }    }  }  elseif ($link_translate) {    $item['title'] = $item['link_title'];  }  // Translate description, see the motivation above.  if (!empty($item['description'])) {    $original_description = $item['description'];    $item['description'] = t($item['description']);    if ($link_translate && isset($item['options']['attributes']['title']) && $item['options']['attributes']['title'] == $original_description) {      $item['localized_options']['attributes']['title'] = $item['description'];    }  }}/** * Handles dynamic path translation and menu access control. * * When a user arrives on a page such as node/5, this function determines * what "5" corresponds to, by inspecting the page's menu path definition, * node/%node. This will call node_load(5) to load the corresponding node * object. * * It also works in reverse, to allow the display of tabs and menu items which * contain these dynamic arguments, translating node/%node to node/5. * * Translation of menu item titles and descriptions are done here to * allow for storage of English strings in the database, and translation * to the language required to generate the current page * * @param $router_item *   A menu router item * @param $map *   An array of path arguments (ex: array('node', '5')) * @param $to_arg *   Execute $item['to_arg_functions'] or not. Use only if you want to render a *   path from the menu table, for example tabs. * @return *   Returns the map with objects loaded as defined in the *   $item['load_functions. $item['access'] becomes TRUE if the item is *   accessible, FALSE otherwise. $item['href'] is set according to the map. *   If an error occurs during calling the load_functions (like trying to load *   a non existing node) then this function return FALSE. */function _menu_translate(&$router_item, $map, $to_arg = FALSE) {  if ($to_arg) {    // Fill in missing path elements, such as the current uid.    _menu_link_map_translate($map, $router_item['to_arg_functions']);  }  // The $path_map saves the pieces of the path as strings, while elements in  // $map may be replaced with loaded objects.  $path_map = $map;  if (!_menu_load_objects($router_item, $map)) {    // An error occurred loading an object.    $router_item['access'] = FALSE;    return FALSE;  }  // Generate the link path for the page request or local tasks.  $link_map = explode('/', $router_item['path']);  for ($i = 0; $i < $router_item['number_parts']; $i++) {    if ($link_map[$i] == '%') {      $link_map[$i] = $path_map[$i];    }  }  $router_item['href'] = implode('/', $link_map);  $router_item['options'] = array();  _menu_check_access($router_item, $map);    // For performance, don't localize an item the user can't access.  if ($router_item['access']) {    _menu_item_localize($router_item, $map);  }  return $map;}/** * This function translates the path elements in the map using any to_arg * helper function. These functions take an argument and return an object. * See http://drupal.org/node/109153 for more information. * * @param map *   An array of path arguments (ex: array('node', '5')) * @param $to_arg_functions *   An array of helper function (ex: array(2 => 'menu_tail_to_arg')) */function _menu_link_map_translate(&$map, $to_arg_functions) {  if ($to_arg_functions) {    $to_arg_functions = unserialize($to_arg_functions);    foreach ($to_arg_functions as $index => $function) {      // Translate place-holders into real values.      $arg = $function(!empty($map[$index]) ? $map[$index] : '', $map, $index);      if (!empty($map[$index]) || isset($arg)) {        $map[$index] = $arg;      }      else {        unset($map[$index]);      }    }  }}function menu_tail_to_arg($arg, $map, $index) {  return implode('/', array_slice($map, $index));}/** * This function is similar to _menu_translate() but does link-specific * preparation such as always calling to_arg functions. * * @param $item *   A menu link * @return *   Returns the map of path arguments with objects loaded as defined in the *   $item['load_functions']: *   - $item['access'] becomes TRUE if the item is accessible, FALSE otherwise. *   - $item['href'] is generated from link_path, possibly by to_arg functions. *   - $item['title'] is generated from link_title, and may be localized. *   - $item['options'] is unserialized; it is also changed within the call *     here to $item['localized_options'] by _menu_item_localize(). */function _menu_link_translate(&$item) {  $item['options'] = unserialize($item['options']);  if ($item['external']) {    $item['access'] = 1;    $map = array();    $item['href'] = $item['link_path'];    $item['title'] = $item['link_title'];    $item['localized_options'] = $item['options'];  }  else {    $map = explode('/', $item['link_path']);    _menu_link_map_translate($map, $item['to_arg_functions']);    $item['href'] = implode('/', $map);    // Note - skip callbacks without real values for their arguments.    if (strpos($item['href'], '%') !== FALSE) {      $item['access'] = FALSE;      return FALSE;    }    // menu_tree_check_access() may set this ahead of time for links to nodes.    if (!isset($item['access'])) {      if (!_menu_load_objects($item, $map)) {        // An error occurred loading an object.        $item['access'] = FALSE;        return FALSE;      }      _menu_check_access($item, $map);    }    // For performance, don't localize a link the user can't access.    if ($item['access']) {      _menu_item_localize($item, $map, TRUE);    }  }  // Allow other customizations - e.g. adding a page-specific query string to the  // options array. For performance reasons we only invoke this hook if the link  // has the 'alter' flag set in the options array.  if (!empty($item['options']['alter'])) {    drupal_alter('translated_menu_link', $item, $map);  }  return $map;}/** * Get a loaded object from a router item. * * menu_get_object() will provide you the current node on paths like node/5, * node/5/revisions/48 etc. menu_get_object('user') will give you the user * account on user/5 etc. Note - this function should never be called within a * _to_arg function (like user_current_to_arg()) since this may result in an * infinite recursion. * * @param $type *   Type of the object. These appear in hook_menu definitons as %type. Core *   provides aggregator_feed, aggregator_category, contact, filter_format, *   forum_term, menu, menu_link, node, taxonomy_vocabulary, user. See the *   relevant {$type}_load function for more on each. Defaults to node. * @param $position *   The expected position for $type object. For node/%node this is 1, for *   comment/reply/%node this is 2. Defaults to 1. * @param $path *   See menu_get_item() for more on this. Defaults to the current path. */function menu_get_object($type = 'node', $position = 1, $path = NULL) {  $router_item = menu_get_item($path);  if (isset($router_item['load_functions'][$position]) && !empty($router_item['map'][$position]) && $router_item['load_functions'][$position] == $type .'_load') {    return $router_item['map'][$position];  }}/** * Render a menu tree based on the current path. * * The tree is expanded based on the current path and dynamic paths are also * changed according to the defined to_arg functions (for example the 'My account' * link is changed from user/% to a link with the current user's uid). * * @param $menu_name *   The name of the menu. * @return *   The rendered HTML of that menu on the current page. */function menu_tree($menu_name = 'navigation') {  static $menu_output = array();  if (!isset($menu_output[$menu_name])) {    $tree = menu_tree_page_data($menu_name);    $menu_output[$menu_name] = menu_tree_output($tree);  }  return $menu_output[$menu_name];}/** * Returns a rendered menu tree. * * @param $tree *   A data structure representing the tree as returned from menu_tree_data. * @return *   The rendered HTML of that data structure. */function menu_tree_output($tree) {  $output = '';  $items = array();  // Pull out just the menu items we are going to render so that we  // get an accurate count for the first/last classes.  foreach ($tree as $data) {    if (!$data['link']['hidden']) {      $items[] = $data;    }  }  $num_items = count($items);  foreach ($items as $i => $data) {    $extra_class = array();    if ($i == 0) {      $extra_class[] = 'first';    }    if ($i == $num_items - 1) {      $extra_class[] = 'last';    }    $extra_class = implode(' ', $extra_class);    $link = theme('menu_item_link', $data['link']);    if ($data['below']) {      $output .= theme('menu_item', $link, $data['link']['has_children'], menu_tree_output($data['below']), $data['link']['in_active_trail'], $extra_class);    }    else {      $output .= theme('menu_item', $link, $data['link']['has_children'], '', $data['link']['in_active_trail'], $extra_class);    }  }  return $output ? theme('menu_tree', $output) : '';}/** * Get the data structure representing a named menu tree. * * Since this can be the full tree including hidden items, the data returned * may be used for generating an an admin interface or a select. * * @param $menu_name *   The named menu links to return * @param $item *   A fully loaded menu link, or NULL.  If a link is supplied, only the *   path to root will be included in the returned tree- as if this link *   represented the current page in a visible menu. * @return *   An tree of menu links in an array, in the order they should be rendered. */function menu_tree_all_data($menu_name = 'navigation', $item = NULL) {  static $tree = array();  // Use $mlid as a flag for whether the data being loaded is for the whole tree.  $mlid = isset($item['mlid']) ? $item['mlid'] : 0;  // Generate a cache ID (cid) specific for this $menu_name and $item.  $cid = 'links:'. $menu_name .':all-cid:'. $mlid;  if (!isset($tree[$cid])) {    // If the static variable doesn't have the data, check {cache_menu}.    $cache = cache_get($cid, 'cache_menu');    if ($cache && isset($cache->data)) {      // If the cache entry exists, it will just be the cid for the actual data.      // This avoids duplication of large amounts of data.      $cache = cache_get($cache->data, 'cache_menu');      if ($cache && isset($cache->data)) {        $data = $cache->data;      }    }    // If the tree data was not in the cache, $data will be NULL.    if (!isset($data)) {      // Build and run the query, and build the tree.      if ($mlid) {        // The tree is for a single item, so we need to match the values in its        // p columns and 0 (the top level) with the plid values of other links.        $args = array(0);        for ($i = 1; $i < MENU_MAX_DEPTH; $i++) {          $args[] = $item["p$i"];        }        $args = array_unique($args);        $placeholders = implode(', ', array_fill(0, count($args), '%d'));        $where = ' AND ml.plid IN ('. $placeholders .')';        $parents = $args;        $parents[] = $item['mlid'];      }      else {        // Get all links in this menu.        $where = '';        $args = array();        $parents = array();      }      array_unshift($args, $menu_name);      // Select the links from the table, and recursively build the tree.  We      // LEFT JOIN since there is no match in {menu_router} for an external      // link.      $data['tree'] = menu_tree_data(db_query("        SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*        FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path        WHERE ml.menu_name = '%s'". $where ."        ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", $args), $parents);      $data['node_links'] = array();      menu_tree_collect_node_links($data['tree'], $data['node_links']);      // Cache the data, if it is not already in the cache.      $tree_cid = _menu_tree_cid($menu_name, $data);      if (!cache_get($tree_cid, 'cache_menu')) {        cache_set($tree_cid, $data, 'cache_menu');      }      // Cache the cid of the (shared) data using the menu and item-specific cid.      cache_set($cid, $tree_cid, 'cache_menu');    }    // Check access for the current user to each item in the tree.    menu_tree_check_access($data['tree'], $data['node_links']);    $tree[$cid] = $data['tree'];  }  return $tree[$cid];}/** * Get the data structure representing a named menu tree, based on the current page. * * The tree order is maintained by storing each parent in an individual * field, see http://drupal.org/node/141866 for more. * * @param $menu_name *   The named menu links to return * @return *   An array of menu links, in the order they should be rendered. The array *   is a list of associative arrays -- these have two keys, link and below. *   link is a menu item, ready for theming as a link. Below represents the *   submenu below the link if there is one, and it is a subtree that has the *   same structure described for the top-level array. */function menu_tree_page_data($menu_name = 'navigation') {  static $tree = array();  // Load the menu item corresponding to the current page.  if ($item = menu_get_item()) {    // Generate a cache ID (cid) specific for this page.    $cid = 'links:'. $menu_name .':page-cid:'. $item['href'] .':'. (int)$item['access'];    if (!isset($tree[$cid])) {      // If the static variable doesn't have the data, check {cache_menu}.      $cache = cache_get($cid, 'cache_menu');      if ($cache && isset($cache->data)) {        // If the cache entry exists, it will just be the cid for the actual data.        // This avoids duplication of large amounts of data.        $cache = cache_get($cache->data, 'cache_menu');        if ($cache && isset($cache->data)) {          $data = $cache->data;        }      }      // If the tree data was not in the cache, $data will be NULL.      if (!isset($data)) {        // Build and run the query, and build the tree.        if ($item['access']) {          // Check whether a menu link exists that corresponds to the current path.          $args = array($menu_name, $item['href']);          $placeholders = "'%s'";          if (drupal_is_front_page()) {            $args[] = '<front>';            $placeholders .= ", '%s'";          }          $parents = db_fetch_array(db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links} WHERE menu_name = '%s' AND link_path IN (". $placeholders .")", $args));          if (empty($parents)) {            // If no link exists, we may be on a local task that's not in the links.            // TODO: Handle the case like a local task on a specific node in the menu.            $parents = db_fetch_array(db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links} WHERE menu_name = '%s' AND link_path = '%s'", $menu_name, $item['tab_root']));          }          // We always want all the top-level links with plid == 0.          $parents[] = '0';          // Use array_values() so that the indices are numeric for array_merge().          $args = $parents = array_unique(array_values($parents));          $placeholders = implode(', ', array_fill(0, count($args), '%d'));          $expanded = variable_get('menu_expanded', array());          // Check whether the current menu has any links set to be expanded.          if (in_array($menu_name, $expanded)) {            // Collect all the links set to be expanded, and then add all of            // their children to the list as well.            do {              $result = db_query("SELECT mlid FROM {menu_links} WHERE menu_name = '%s' AND expanded = 1 AND has_children = 1 AND plid IN (". $placeholders .') AND mlid NOT IN ('. $placeholders .')', array_merge(array($menu_name), $args, $args));              $num_rows = FALSE;              while ($item = db_fetch_array($result)) {                $args[] = $item['mlid'];                $num_rows = TRUE;              }              $placeholders = implode(', ', array_fill(0, count($args), '%d'));            } while ($num_rows);          }          array_unshift($args, $menu_name);        }        else {          // Show only the top-level menu items when access is denied.          $args = array($menu_name, '0');          $placeholders = '%d';          $parents = array();        }        // Select the links from the table, and recursively build the tree. We        // LEFT JOIN since there is no match in {menu_router} for an external        // link.        $data['tree'] = menu_tree_data(db_query("          SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*          FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path          WHERE ml.menu_name = '%s' AND ml.plid IN (". $placeholders .")          ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", $args), $parents);        $data['node_links'] = array();        menu_tree_collect_node_links($data['tree'], $data['node_links']);        // Cache the data, if it is not already in the cache.        $tree_cid = _menu_tree_cid($menu_name, $data);        if (!cache_get($tree_cid, 'cache_menu')) {          cache_set($tree_cid, $data, 'cache_menu');        }        // Cache the cid of the (shared) data using the page-specific cid.        cache_set($cid, $tree_cid, 'cache_menu');      }      // Check access for the current user to each item in the tree.      menu_tree_check_access($data['tree'], $data['node_links']);      $tree[$cid] = $data['tree'];    }    return $tree[$cid];  }  return array();}/** * Helper function - compute the real cache ID for menu tree data. */function _menu_tree_cid($menu_name, $data) {  return 'links:'. $menu_name .':tree-data:'. md5(serialize($data));}/** * Recursive helper function - collect node links. * * @param $tree *   The menu tree you wish to collect node links from. * @param $node_links *   An array in which to store the collected node links. */function menu_tree_collect_node_links(&$tree, &$node_links) {  foreach ($tree as $key => $v) {    if ($tree[$key]['link']['router_path'] == 'node/%') {      $nid = substr($tree[$key]['link']['link_path'], 5);      if (is_numeric($nid)) {        $node_links[$nid][$tree[$key]['link']['mlid']] = &$tree[$key]['link'];        $tree[$key]['link']['access'] = FALSE;      }    }    if ($tree[$key]['below']) {      menu_tree_collect_node_links($tree[$key]['below'], $node_links);    }  }}/** * Check access and perform other dynamic operations for each link in the tree. * * @param $tree *   The menu tree you wish to operate on. * @param $node_links *   A collection of node link references generated from $tree by *   menu_tree_collect_node_links(). */function menu_tree_check_access(&$tree, $node_links = array()) {  if ($node_links) {    // Use db_rewrite_sql to evaluate view access without loading each full node.    $nids = array_keys($node_links);    $placeholders = '%d'. str_repeat(', %d', count($nids) - 1);    $result = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.status = 1 AND n.nid IN (". $placeholders .")"), $nids);    while ($node = db_fetch_array($result)) {      $nid = $node['nid'];      foreach ($node_links[$nid] as $mlid => $link) {        $node_links[$nid][$mlid]['access'] = TRUE;      }    }  }  _menu_tree_check_access($tree);  return;}/** * Recursive helper function for menu_tree_check_access() */function _menu_tree_check_access(&$tree) {  $new_tree = array();  foreach ($tree as $key => $v) {    $item = &$tree[$key]['link'];    _menu_link_translate($item);    if ($item['access']) {      if ($tree[$key]['below']) {        _menu_tree_check_access($tree[$key]['below']);      }      // The weights are made a uniform 5 digits by adding 50000 as an offset.      // After _menu_link_translate(), $item['title'] has the localized link title.      // Adding the mlid to the end of the index insures that it is unique.      $new_tree[(50000 + $item['weight']) .' '. $item['title'] .' '. $item['mlid']] = $tree[$key];    }  }  // Sort siblings in the tree based on the weights and localized titles.  ksort($new_tree);  $tree = $new_tree;}/** * Build the data representing a menu tree. * * @param $result *   The database result. * @param $parents *   An array of the plid values that represent the path from the current page *   to the root of the menu tree. * @param $depth *   The depth of the current menu tree. * @return *   See menu_tree_page_data for a description of the data structure. */function menu_tree_data($result = NULL, $parents = array(), $depth = 1) {  list(, $tree) = _menu_tree_data($result, $parents, $depth);  return $tree;}/** * Recursive helper function to build the data representing a menu tree. * * The function is a bit complex because the rendering of an item depends on * the next menu item. So we are always rendering the element previously * processed not the current one. */function _menu_tree_data($result, $parents, $depth, $previous_element = '') {  $remnant = NULL;  $tree = array();  while ($item = db_fetch_array($result)) {    // We need to determine if we're on the path to root so we can later build    // the correct active trail and breadcrumb.    $item['in_active_trail'] = in_array($item['mlid'], $parents);    // The current item is the first in a new submenu.    if ($item['depth'] > $depth) {      // _menu_tree returns an item and the menu tree structure.      list($item, $below) = _menu_tree_data($result, $parents, $item['depth'], $item);      if ($previous_element) {        $tree[$previous_element['mlid']] = array(          'link' => $previous_element,          'below' => $below,        );      }      else {        $tree = $below;      }      // We need to fall back one level.      if (!isset($item) || $item['depth'] < $depth) {        return array($item, $tree);      }      // This will be the link to be output in the next iteration.      $previous_element = $item;    }    // We are at the same depth, so we use the previous element.    elseif ($item['depth'] == $depth) {      if ($previous_element) {        // Only the first time.        $tree[$previous_element['mlid']] = array(          'link' => $previous_element,          'below' => FALSE,        );      }      // This will be the link to be output in the next iteration.      $previous_element = $item;    }    // The submenu ended with the previous item, so pass back the current item.    else {      $remnant = $item;      break;    }  }  if ($previous_element) {    // We have one more link dangling.    $tree[$previous_element['mlid']] = array(      'link' => $previous_element,      'below' => FALSE,    );  }  return array($remnant, $tree);}/** * Generate the HTML output for a single menu link. * * @ingroup themeable */function theme_menu_item_link($link) {  if (empty($link['localized_options'])) {    $link['localized_options'] = array();  }  return l($link['title'], $link['href'], $link['localized_options']);}/** * Generate the HTML output for a menu tree * * @ingroup themeable */function theme_menu_tree($tree) {  return '<ul class="menu">'. $tree .'</ul>';}/** * Generate the HTML output for a menu item and submenu. * * @ingroup themeable */function theme_menu_item($link, $has_children, $menu = '', $in_active_trail = FALSE, $extra_class = NULL) {  $class = ($menu ? 'expanded' : ($has_children ? 'collapsed' : 'leaf'));  if (!empty($extra_class)) {    $class .= ' '. $extra_class;  }  if ($in_active_trail) {    $class .= ' active-trail';  }  return '<li class="'. $class .'">'. $link . $menu ."</li>\n";}/** * Generate the HTML output for a single local task link. * * @ingroup themeable */function theme_menu_local_task($link, $active = FALSE) {  return '<li '. ($active ? 'class="active" ' : '') .'>'. $link ."</li>\n";}/** * Generates elements for the $arg array in the help hook. */function drupal_help_arg($arg = array()) {  // Note - the number of empty elements should be > MENU_MAX_PARTS.  return $arg + array('', '', '', '', '', '', '', '', '', '', '', '');}/** * Returns the help associated with the active menu item. */function menu_get_active_help() {  $output = '';  $router_path = menu_tab_root_path();  // We will always have a path unless we are on a 403 or 404.  if (!$router_path) {    return '';  }  $arg = drupal_help_arg(arg(NULL));  $empty_arg = drupal_help_arg();  foreach (module_list() as $name) {    if (module_hook($name, 'help')) {      // Lookup help for this path.      if ($help = module_invoke($name, 'help', $router_path, $arg)) {        $output .= $help ."\n";      }      // Add "more help" link on admin pages if the module provides a      // standalone help page.      if ($arg[0] == "admin" && module_exists('help') && module_invoke($name, 'help', 'admin/help#'. $arg[2], $empty_arg) && $help) {        $output .= theme("more_help_link", url('admin/help/'. $arg[2]));      }    }  }  return $output;}/** * Build a list of named menus. */function menu_get_names($reset = FALSE) {  static $names;  if ($reset || empty($names)) {    $names = array();    $result = db_query("SELECT DISTINCT(menu_name) FROM {menu_links} ORDER BY menu_name");    while ($name = db_fetch_array($result)) {      $names[] = $name['menu_name'];    }  }  return $names;}/** * Return an array containing the names of system-defined (default) menus. */function menu_list_system_menus() {  return array('navigation', 'primary-links', 'secondary-links');}/** * Return an array of links to be rendered as the Primary links. */function menu_primary_links() {  return menu_navigation_links(variable_get('menu_primary_links_source', 'primary-links'));}/** * Return an array of links to be rendered as the Secondary links. */function menu_secondary_links() {  // If the secondary menu source is set as the primary menu, we display the  // second level of the primary menu.  if (variable_get('menu_secondary_links_source', 'secondary-links') == variable_get('menu_primary_links_source', 'primary-links')) {    return menu_navigation_links(variable_get('menu_primary_links_source', 'primary-links'), 1);  }  else {    return menu_navigation_links(variable_get('menu_secondary_links_source', 'secondary-links'), 0);  }}/** * Return an array of links for a navigation menu. * * @param $menu_name *   The name of the menu. * @param $level *   Optional, the depth of the menu to be returned. * @return *   An array of links of the specified menu and level. */function menu_navigation_links($menu_name, $level = 0) {  // Don't even bother querying the menu table if no menu is specified.  if (empty($menu_name)) {    return array();  }  // Get the menu hierarchy for the current page.  $tree = menu_tree_page_data($menu_name);  // Go down the active trail until the right level is reached.  while ($level-- > 0 && $tree) {    // Loop through the current level's items until we find one that is in trail.    while ($item = array_shift($tree)) {      if ($item['link']['in_active_trail']) {        // If the item is in the active trail, we continue in the subtree.        $tree = empty($item['below']) ? array() : $item['below'];        break;      }    }  }  // Create a single level of links.  $links = array();  foreach ($tree as $item) {    if (!$item['link']['hidden']) {      $class = '';      $l = $item['link']['localized_options'];      $l['href'] = $item['link']['href'];      $l['title'] = $item['link']['title'];      if ($item['link']['in_active_trail']) {        $class = ' active-trail';      }      // Keyed with the unique mlid to generate classes in theme_links().      $links['menu-'. $item['link']['mlid'] . $class] = $l;    }  }  return $links;}/** * Collects the local tasks (tabs) for a given level. * * @param $level *   The level of tasks you ask for. Primary tasks are 0, secondary are 1. * @param $return_root *   Whether to return the root path for the current page. * @return *   Themed output corresponding to the tabs of the requested level, or *   router path if $return_root == TRUE. This router path corresponds to *   a parent tab, if the current page is a default local task. */function menu_local_tasks($level = 0, $return_root = FALSE) {  static $tabs;  static $root_path;  if (!isset($tabs)) {    $tabs = array();    $router_item = menu_get_item();    if (!$router_item || !$router_item['access']) {      return '';    }    // Get all tabs and the root page.    $result = db_query("SELECT * FROM {menu_router} WHERE tab_root = '%s' ORDER BY weight, title", $router_item['tab_root']);    $map = arg();    $children = array();    $tasks = array();    $root_path = $router_item['path'];    while ($item = db_fetch_array($result)) {      _menu_translate($item, $map, TRUE);      if ($item['tab_parent']) {        // All tabs, but not the root page.        $children[$item['tab_parent']][$item['path']] = $item;      }      // Store the translated item for later use.      $tasks[$item['path']] = $item;    }    // Find all tabs below the current path.    $path = $router_item['path'];    // Tab parenting may skip levels, so the number of parts in the path may not    // equal the depth. Thus we use the $depth counter (offset by 1000 for ksort).    $depth = 1001;    while (isset($children[$path])) {      $tabs_current = '';      $next_path = '';      $count = 0;      foreach ($children[$path] as $item) {        if ($item['access']) {          $count++;          // The default task is always active.          if ($item['type'] == MENU_DEFAULT_LOCAL_TASK) {            // Find the first parent which is not a default local task.            for ($p = $item['tab_parent']; $tasks[$p]['type'] == MENU_DEFAULT_LOCAL_TASK; $p = $tasks[$p]['tab_parent']);            $link = theme('menu_item_link', array('href' => $tasks[$p]['href']) + $item);            $tabs_current .= theme('menu_local_task', $link, TRUE);            $next_path = $item['path'];          }          else {            $link = theme('menu_item_link', $item);            $tabs_current .= theme('menu_local_task', $link);          }        }      }      $path = $next_path;      $tabs[$depth]['count'] = $count;      $tabs[$depth]['output'] = $tabs_current;      $depth++;    }    // Find all tabs at the same level or above the current one.    $parent = $router_item['tab_parent'];    $path = $router_item['path'];    $current = $router_item;    $depth = 1000;    while (isset($children[$parent])) {      $tabs_current = '';      $next_path = '';      $next_parent = '';      $count = 0;      foreach ($children[$parent] as $item) {        if ($item['access']) {          $count++;          if ($item['type'] == MENU_DEFAULT_LOCAL_TASK) {            // Find the first parent which is not a default local task.            for ($p = $item['tab_parent']; $tasks[$p]['type'] == MENU_DEFAULT_LOCAL_TASK; $p = $tasks[$p]['tab_parent']);            $link = theme('menu_item_link', array('href' => $tasks[$p]['href']) + $item);            if ($item['path'] == $router_item['path']) {              $root_path = $tasks[$p]['path'];            }          }          else {            $link = theme('menu_item_link', $item);          }          // We check for the active tab.          if ($item['path'] == $path) {            $tabs_current .= theme('menu_local_task', $link, TRUE);            $next_path = $item['tab_parent'];            if (isset($tasks[$next_path])) {              $next_parent = $tasks[$next_path]['tab_parent'];            }          }          else {            $tabs_current .= theme('menu_local_task', $link);          }        }      }      $path = $next_path;      $parent = $next_parent;      $tabs[$depth]['count'] = $count;      $tabs[$depth]['output'] = $tabs_current;      $depth--;    }    // Sort by depth.    ksort($tabs);    // Remove the depth, we are interested only in their relative placement.    $tabs = array_values($tabs);  }  if ($return_root) {    return $root_path;  }  else {    // We do not display single tabs.    return (isset($tabs[$level]) && $tabs[$level]['count'] > 1) ? $tabs[$level]['output'] : '';  }}/** * Returns the rendered local tasks at the top level. */function menu_primary_local_tasks() {  return menu_local_tasks(0);}/** * Returns the rendered local tasks at the second level. */function menu_secondary_local_tasks() {  return menu_local_tasks(1);}/** * Returns the router path, or the path of the parent tab of a default local task. */function menu_tab_root_path() {  return menu_local_tasks(0, TRUE);}/** * Returns the rendered local tasks. The default implementation renders them as tabs. * * @ingroup themeable */function theme_menu_local_tasks() {  $output = '';  if ($primary = menu_primary_local_tasks()) {    $output .= "<ul class=\"tabs primary\">\n". $primary ."</ul>\n";  }  if ($secondary = menu_secondary_local_tasks()) {    $output .= "<ul class=\"tabs secondary\">\n". $secondary ."</ul>\n";  }  return $output;}/** * Set (or get) the active menu for the current page - determines the active trail. */function menu_set_active_menu_name($menu_name = NULL) {  static $active;  if (isset($menu_name)) {    $active = $menu_name;  }  elseif (!isset($active)) {    $active = 'navigation';  }  return $active;}/** * Get the active menu for the current page - determines the active trail. */function menu_get_active_menu_name() {  return menu_set_active_menu_name();}/** * Set the active path, which determines which page is loaded. * * @param $path *   A Drupal path - not a path alias. * * Note that this may not have the desired effect unless invoked very early * in the page load, such as during hook_boot, or unless you call * menu_execute_active_handler() to generate your page output. */function menu_set_active_item($path) {  $_GET['q'] = $path;}/** * Sets or gets the active trail (path to root menu root) of the current page. * * @param $new_trail *   Menu trail to set, or NULL to use previously-set or calculated trail. If *   supplying a trail, use the same format as the return value (see below). * @return *   Path to menu root of the current page, as an array of menu link items, *   starting with the site's home page. Each link item is an associative array *   with the following components: *   - 'title': Title of the item. *   - 'href': Drupal path of the item. *   - 'localized_options': Options for passing into the l() function. *   - 'type': A menu type constant, such as MENU_DEFAULT_LOCAL_TASK, or 0 to *     indicate it's not really in the menu (used for the home page item). *   If $new_trail is supplied, the value is saved in a static variable and *   returned. If $new_trail is not supplied, and there is a saved value from *   a previous call, the saved value is returned. If $new_trail is not supplied *   and there is no saved value, the path to the current page is calculated, *   saved as the static value, and returned. */function menu_set_active_trail($new_trail = NULL) {  static $trail;  if (isset($new_trail)) {    $trail = $new_trail;  }  elseif (!isset($trail)) {    $trail = array();    $trail[] = array('title' => t('Home'), 'href' => '<front>', 'localized_options' => array(), 'type' => 0);    $item = menu_get_item();    // Check whether the current item is a local task (displayed as a tab).    if ($item['tab_parent']) {      // The title of a local task is used for the tab, never the page title.      // Thus, replace it with the item corresponding to the root path to get      // the relevant href and title.  For example, the menu item corresponding      // to 'admin' is used when on the 'By module' tab at 'admin/by-module'.      $parts = explode('/', $item['tab_root']);      $args = arg();      // Replace wildcards in the root path using the current path.      foreach ($parts as $index => $part) {        if ($part == '%') {          $parts[$index] = $args[$index];        }      }      // Retrieve the menu item using the root path after wildcard replacement.      $root_item = menu_get_item(implode('/', $parts));      if ($root_item && $root_item['access']) {        $item = $root_item;      }    }    $tree = menu_tree_page_data(menu_get_active_menu_name());    list($key, $curr) = each($tree);    while ($curr) {      // Terminate the loop when we find the current path in the active trail.      if ($curr['link']['href'] == $item['href']) {        $trail[] = $curr['link'];        $curr = FALSE;      }      else {        // Add the link if it's in the active trail, then move to the link below.        if ($curr['link']['in_active_trail']) {          $trail[] = $curr['link'];          $tree = $curr['below'] ? $curr['below'] : array();        }        list($key, $curr) = each($tree);      }    }    // Make sure the current page is in the trail (needed for the page title),    // but exclude tabs and the front page.    $last = count($trail) - 1;    if ($trail[$last]['href'] != $item['href'] && !(bool)($item['type'] & MENU_IS_LOCAL_TASK) && !drupal_is_front_page()) {      $trail[] = $item;    }  }  return $trail;}/** * Gets the active trail (path to root menu root) of the current page. * * See menu_set_active_trail() for details of return value. */function menu_get_active_trail() {  return menu_set_active_trail();}/** * Get the breadcrumb for the current page, as determined by the active trail. */function menu_get_active_breadcrumb() {  $breadcrumb = array();  // No breadcrumb for the front page.  if (drupal_is_front_page()) {    return $breadcrumb;  }  $item = menu_get_item();  if ($item && $item['access']) {    $active_trail = menu_get_active_trail();    foreach ($active_trail as $parent) {      $breadcrumb[] = l($parent['title'], $parent['href'], $parent['localized_options']);    }    $end = end($active_trail);    // Don't show a link to the current page in the breadcrumb trail.    if ($item['href'] == $end['href'] || ($item['type'] == MENU_DEFAULT_LOCAL_TASK && $end['href'] != '<front>')) {      array_pop($breadcrumb);    }  }  return $breadcrumb;}/** * Get the title of the current page, as determined by the active trail. */function menu_get_active_title() {  $active_trail = menu_get_active_trail();  foreach (array_reverse($active_trail) as $item) {    if (!(bool)($item['type'] & MENU_IS_LOCAL_TASK)) {      return $item['title'];    }  }}/** * Get a menu link by its mlid, access checked and link translated for rendering. * * This function should never be called from within node_load() or any other * function used as a menu object load function since an infinite recursion may * occur. * * @param $mlid *   The mlid of the menu item. * @return *   A menu link, with $item['access'] filled and link translated for *   rendering. */function menu_link_load($mlid) {  if (is_numeric($mlid) && $item = db_fetch_array(db_query("SELECT m.*, ml.* FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = %d", $mlid))) {    _menu_link_translate($item);    return $item;  }  return FALSE;}/** * Clears the cached cached data for a single named menu. */function menu_cache_clear($menu_name = 'navigation') {  static $cache_cleared = array();  if (empty($cache_cleared[$menu_name])) {    cache_clear_all('links:'. $menu_name .':', 'cache_menu', TRUE);    $cache_cleared[$menu_name] = 1;  }  elseif ($cache_cleared[$menu_name] == 1) {    register_shutdown_function('cache_clear_all', 'links:'. $menu_name .':', 'cache_menu', TRUE);    $cache_cleared[$menu_name] = 2;  }}/** * Clears all cached menu data.  This should be called any time broad changes * might have been made to the router items or menu links. */function menu_cache_clear_all() {  cache_clear_all('*', 'cache_menu', TRUE);}/** * (Re)populate the database tables used by various menu functions. * * This function will clear and populate the {menu_router} table, add entries * to {menu_links} for new router items, then remove stale items from * {menu_links}. If called from update.php or install.php, it will also * schedule a call to itself on the first real page load from * menu_execute_active_handler(), because the maintenance page environment * is different and leaves stale data in the menu tables. */function menu_rebuild() {  if (!lock_acquire('menu_rebuild')) {    // Wait for another request that is already doing this work.    // We choose to block here since otherwise the router item may not     // be avaiable in menu_execute_active_handler() resulting in a 404.    lock_wait('menu_rebuild');    return FALSE;  }  $menu = menu_router_build(TRUE);  _menu_navigation_links_rebuild($menu);  // Clear the menu, page and block caches.  menu_cache_clear_all();  _menu_clear_page_cache();    if (defined('MAINTENANCE_MODE')) {    variable_set('menu_rebuild_needed', TRUE);  }  else {    variable_del('menu_rebuild_needed');  }  lock_release('menu_rebuild');  return TRUE;}/** * Collect, alter and store the menu definitions. */function menu_router_build($reset = FALSE) {  static $menu;  if (!isset($menu) || $reset) {    // We need to manually call each module so that we can know which module    // a given item came from.    $callbacks = array();    foreach (module_implements('menu') as $module) {      $router_items = call_user_func($module .'_menu');      if (isset($router_items) && is_array($router_items)) {        foreach (array_keys($router_items) as $path) {          $router_items[$path]['module'] = $module;        }        $callbacks = array_merge($callbacks, $router_items);      }    }    // Alter the menu as defined in modules, keys are like user/%user.    drupal_alter('menu', $callbacks);    $menu = _menu_router_build($callbacks);    _menu_router_cache($menu);  }  return $menu;}/** * Helper function to store the menu router if we have it in memory. */function _menu_router_cache($new_menu = NULL) {  static $menu = NULL;  if (isset($new_menu)) {    $menu = $new_menu;  }  return $menu;}/** * Builds a link from a router item. */function _menu_link_build($item) {  if ($item['type'] == MENU_CALLBACK) {    $item['hidden'] = -1;  }  elseif ($item['type'] == MENU_SUGGESTED_ITEM) {    $item['hidden'] = 1;  }  // Note, we set this as 'system', so that we can be sure to distinguish all  // the menu links generated automatically from entries in {menu_router}.  $item['module'] = 'system';  $item += array(    'menu_name' => 'navigation',    'link_title' => $item['title'],    'link_path' => $item['path'],    'hidden' => 0,    'options' => empty($item['description']) ? array() : array('attributes' => array('title' => $item['description'])),  );  return $item;}/** * Helper function to build menu links for the items in the menu router. */function _menu_navigation_links_rebuild($menu) {  // Add normal and suggested items as links.  $menu_links = array();  foreach ($menu as $path => $item) {    if ($item['_visible']) {      $item = _menu_link_build($item);      $menu_links[$path] = $item;      $sort[$path] = $item['_number_parts'];    }  }  if ($menu_links) {    // Make sure no child comes before its parent.    array_multisort($sort, SORT_NUMERIC, $menu_links);    foreach ($menu_links as $item) {      $existing_item = db_fetch_array(db_query("SELECT mlid, menu_name, plid, customized, has_children, updated FROM {menu_links} WHERE link_path = '%s' AND module = '%s'", $item['link_path'], 'system'));      if ($existing_item) {        $item['mlid'] = $existing_item['mlid'];        // A change in hook_menu may move the link to a different menu        if (empty($item['menu_name']) || ($item['menu_name'] == $existing_item['menu_name'])) {          $item['menu_name'] = $existing_item['menu_name'];          $item['plid'] = $existing_item['plid'];        }        $item['has_children'] = $existing_item['has_children'];        $item['updated'] = $existing_item['updated'];      }      if (!$existing_item || !$existing_item['customized']) {        menu_link_save($item);      }    }  }  $placeholders = db_placeholders($menu, 'varchar');  $paths = array_keys($menu);  // Updated and customized items whose router paths are gone need new ones.  $result = db_query("SELECT ml.link_path, ml.mlid, ml.router_path, ml.updated FROM {menu_links} ml WHERE ml.updated = 1 OR (router_path NOT IN ($placeholders) AND external = 0 AND customized = 1)", $paths);  while ($item = db_fetch_array($result)) {    $router_path = _menu_find_router_path($item['link_path']);    if (!empty($router_path) && ($router_path != $item['router_path'] || $item['updated'])) {      // If the router path and the link path matches, it's surely a working      // item, so we clear the updated flag.      $updated = $item['updated'] && $router_path != $item['link_path'];      db_query("UPDATE {menu_links} SET router_path = '%s', updated = %d WHERE mlid = %d", $router_path, $updated, $item['mlid']);    }  }  // Find any item whose router path does not exist any more.  $result = db_query("SELECT * FROM {menu_links} WHERE router_path NOT IN ($placeholders) AND external = 0 AND updated = 0 AND customized = 0 ORDER BY depth DESC", $paths);  // Remove all such items. Starting from those with the greatest depth will  // minimize the amount of re-parenting done by menu_link_delete().  while ($item = db_fetch_array($result)) {    _menu_delete_item($item, TRUE);  }}/** * Delete one or several menu links. * * @param $mlid *   A valid menu link mlid or NULL. If NULL, $path is used. * @param $path *   The path to the menu items to be deleted. $mlid must be NULL. */function menu_link_delete($mlid, $path = NULL) {  if (isset($mlid)) {    _menu_delete_item(db_fetch_array(db_query("SELECT * FROM {menu_links} WHERE mlid = %d", $mlid)));  }  else {    $result = db_query("SELECT * FROM {menu_links} WHERE link_path = '%s'", $path);    while ($link = db_fetch_array($result)) {      _menu_delete_item($link);    }  }}/** * Helper function for menu_link_delete; deletes a single menu link. * * @param $item *   Item to be deleted. * @param $force *   Forces deletion. Internal use only, setting to TRUE is discouraged. */function _menu_delete_item($item, $force = FALSE) {  if ($item && ($item['module'] != 'system' || $item['updated'] || $force)) {    // Children get re-attached to the item's parent.    if ($item['has_children']) {      $result = db_query("SELECT mlid FROM {menu_links} WHERE plid = %d", $item['mlid']);      while ($m = db_fetch_array($result)) {        $child = menu_link_load($m['mlid']);        $child['plid'] = $item['plid'];        menu_link_save($child);      }    }    db_query('DELETE FROM {menu_links} WHERE mlid = %d', $item['mlid']);    // Update the has_children status of the parent.    _menu_update_parental_status($item);    menu_cache_clear($item['menu_name']);    _menu_clear_page_cache();  }}/** * Save a menu link. * * @param $item *   An array representing a menu link item. The only mandatory keys are *   link_path and link_title. Possible keys are: *   - menu_name   default is navigation *   - weight      default is 0 *   - expanded    whether the item is expanded. *   - options     An array of options, @see l for more. *   - mlid        Set to an existing value, or 0 or NULL to insert a new link. *   - plid        The mlid of the parent. *   - router_path The path of the relevant router item. * @return *   The mlid of the saved menu link, or FALSE if the menu link could not be  *   saved. */function menu_link_save(&$item) {  // Get the router if it's already in memory. $menu will be NULL, unless this  // is during a menu rebuild  $menu = _menu_router_cache();  drupal_alter('menu_link', $item, $menu);  // This is the easiest way to handle the unique internal path '<front>',  // since a path marked as external does not need to match a router path.  $item['_external'] = menu_path_is_external($item['link_path'])  || $item['link_path'] == '<front>';  // Load defaults.  $item += array(    'menu_name' => 'navigation',    'weight' => 0,    'link_title' => '',    'hidden' => 0,    'has_children' => 0,    'expanded' => 0,    'options' => array(),    'module' => 'menu',    'customized' => 0,    'updated' => 0,  );  $existing_item = FALSE;  if (isset($item['mlid'])) {    $existing_item = db_fetch_array(db_query("SELECT * FROM {menu_links} WHERE mlid = %d", $item['mlid']));  }  if (isset($item['plid'])) {    $parent = db_fetch_array(db_query("SELECT * FROM {menu_links} WHERE mlid = %d", $item['plid']));  }  else {    // Find the parent - it must be unique.    $parent_path = $item['link_path'];    $where = "WHERE link_path = '%s'";    // Only links derived from router items should have module == 'system', and    // we want to find the parent even if it's in a different menu.    if ($item['module'] == 'system') {      $where .= " AND module = '%s'";      $arg2 = 'system';    }    else {      // If not derived from a router item, we respect the specified menu name.      $where .= " AND menu_name = '%s'";      $arg2 = $item['menu_name'];    }    do {      $parent = FALSE;      $parent_path = substr($parent_path, 0, strrpos($parent_path, '/'));      $result = db_query("SELECT COUNT(*) FROM {menu_links} ". $where, $parent_path, $arg2);      // Only valid if we get a unique result.      if (db_result($result) == 1) {        $parent = db_fetch_array(db_query("SELECT * FROM {menu_links} ". $where, $parent_path, $arg2));      }    } while ($parent === FALSE && $parent_path);  }  if ($parent !== FALSE) {    $item['menu_name'] = $parent['menu_name'];  }  $menu_name = $item['menu_name'];  // Menu callbacks need to be in the links table for breadcrumbs, but can't  // be parents if they are generated directly from a router item.  if (empty($parent['mlid']) || $parent['hidden'] < 0) {    $item['plid'] =  0;  }  else {    $item['plid'] = $parent['mlid'];  }  if (!$existing_item) {    db_query("INSERT INTO {menu_links} (       menu_name, plid, link_path,      hidden, external, has_children,      expanded, weight,      module, link_title, options,      customized, updated) VALUES (      '%s', %d, '%s',      %d, %d, %d,      %d, %d,      '%s', '%s', '%s', %d, %d)",      $item['menu_name'], $item['plid'], $item['link_path'],      $item['hidden'], $item['_external'], $item['has_children'],      $item['expanded'], $item['weight'],      $item['module'],  $item['link_title'], serialize($item['options']),      $item['customized'], $item['updated']);    $item['mlid'] = db_last_insert_id('menu_links', 'mlid');  }  if (!$item['plid']) {    $item['p1'] = $item['mlid'];    for ($i = 2; $i <= MENU_MAX_DEPTH; $i++) {      $item["p$i"] = 0;    }    $item['depth'] = 1;  }  else {    // Cannot add beyond the maximum depth.    if ($item['has_children'] && $existing_item) {      $limit = MENU_MAX_DEPTH - menu_link_children_relative_depth($existing_item) - 1;    }    else {      $limit = MENU_MAX_DEPTH - 1;    }    if ($parent['depth'] > $limit) {      return FALSE;    }    $item['depth'] = $parent['depth'] + 1;    _menu_link_parents_set($item, $parent);  }  // Need to check both plid and menu_name, since plid can be 0 in any menu.  if ($existing_item && ($item['plid'] != $existing_item['plid'] || $menu_name != $existing_item['menu_name'])) {    _menu_link_move_children($item, $existing_item);  }  // Find the callback. During the menu update we store empty paths to be  // fixed later, so we skip this.  if (!isset($_SESSION['system_update_6021']) && (empty($item['router_path'])  || !$existing_item || ($existing_item['link_path'] != $item['link_path']))) {    if ($item['_external']) {      $item['router_path'] = '';    }    else {      // Find the router path which will serve this path.      $item['parts'] = explode('/', $item['link_path'], MENU_MAX_PARTS);      $item['router_path'] = _menu_find_router_path($item['link_path']);    }  }  db_query("UPDATE {menu_links} SET menu_name = '%s', plid = %d, link_path = '%s',    router_path = '%s', hidden = %d, external = %d, has_children = %d,    expanded = %d, weight = %d, depth = %d,    p1 = %d, p2 = %d, p3 = %d, p4 = %d, p5 = %d, p6 = %d, p7 = %d, p8 = %d, p9 = %d,    module = '%s', link_title = '%s', options = '%s', customized = %d WHERE mlid = %d",    $item['menu_name'], $item['plid'], $item['link_path'],    $item['router_path'], $item['hidden'], $item['_external'], $item['has_children'],    $item['expanded'], $item['weight'],  $item['depth'],    $item['p1'], $item['p2'], $item['p3'], $item['p4'], $item['p5'], $item['p6'], $item['p7'], $item['p8'], $item['p9'],    $item['module'],  $item['link_title'], serialize($item['options']), $item['customized'], $item['mlid']);  // Check the has_children status of the parent.  _menu_update_parental_status($item);  menu_cache_clear($menu_name);  if ($existing_item && $menu_name != $existing_item['menu_name']) {    menu_cache_clear($existing_item['menu_name']);  }  _menu_clear_page_cache();  return $item['mlid'];}/** * Helper function to clear the page and block caches at most twice per page load. */function _menu_clear_page_cache() {  static $cache_cleared = 0;  // Clear the page and block caches, but at most twice, including at  //  the end of the page load when there are multple links saved or deleted.  if (empty($cache_cleared)) {    cache_clear_all();    // Keep track of which menus have expanded items.    _menu_set_expanded_menus();    $cache_cleared = 1;  }  elseif ($cache_cleared == 1) {    register_shutdown_function('cache_clear_all');    // Keep track of which menus have expanded items.    register_shutdown_function('_menu_set_expanded_menus');    $cache_cleared = 2;  }}/** * Helper function to update a list of menus with expanded items */function _menu_set_expanded_menus() {  $names = array();  $result = db_query("SELECT menu_name FROM {menu_links} WHERE expanded != 0 GROUP BY menu_name");  while ($n = db_fetch_array($result)) {    $names[] = $n['menu_name'];  }  variable_set('menu_expanded', $names);}/** * Find the router path which will serve this path. * * @param $link_path *  The path for we are looking up its router path. * @return *  A path from $menu keys or empty if $link_path points to a nonexisting *  place. */function _menu_find_router_path($link_path) {  // $menu will only have data during a menu rebuild.  $menu = _menu_router_cache();  $router_path = $link_path;  $parts = explode('/', $link_path, MENU_MAX_PARTS);  list($ancestors, $placeholders) = menu_get_ancestors($parts);  if (empty($menu)) {    // Not during a menu rebuild, so look up in the database.    $router_path = (string)db_result(db_query_range('SELECT path FROM {menu_router} WHERE path IN ('. implode (',', $placeholders) .') ORDER BY fit DESC', $ancestors, 0, 1));  }  elseif (!isset($menu[$router_path])) {    // Add an empty path as a fallback.    $ancestors[] = '';    foreach ($ancestors as $key => $router_path) {      if (isset($menu[$router_path])) {        // Exit the loop leaving $router_path as the first match.        break;      }    }    // If we did not find the path, $router_path will be the empty string    // at the end of $ancestors.  }  return $router_path;}/** * Insert, update or delete an uncustomized menu link related to a module. * * @param $module *   The name of the module. * @param $op *   Operation to perform: insert, update or delete. * @param $link_path *   The path this link points to. * @param $link_title *   Title of the link to insert or new title to update the link to. *   Unused for delete. * @return *   The insert op returns the mlid of the new item. Others op return NULL. */function menu_link_maintain($module, $op, $link_path, $link_title) {  switch ($op) {    case 'insert':      $menu_link = array(        'link_title' => $link_title,        'link_path' => $link_path,        'module' => $module,      );      return menu_link_save($menu_link);      break;    case 'update':      db_query("UPDATE {menu_links} SET link_title = '%s' WHERE link_path = '%s' AND customized = 0 AND module = '%s'", $link_title, $link_path, $module);      $result = db_query("SELECT menu_name FROM {menu_links} WHERE link_path = '%s' AND customized = 0 AND module = '%s'", $link_path, $module);      while ($item = db_fetch_array($result)) {        menu_cache_clear($item['menu_name']);      }      break;    case 'delete':      menu_link_delete(NULL, $link_path);      break;  }}/** * Find the depth of an item's children relative to its depth. * * For example, if the item has a depth of 2, and the maximum of any child in * the menu link tree is 5, the relative depth is 3. * * @param $item *   An array representing a menu link item. * @return *   The relative depth, or zero. * */function menu_link_children_relative_depth($item) {  $i = 1;  $match = '';  $args[] = $item['menu_name'];  $p = 'p1';  while ($i <= MENU_MAX_DEPTH && $item[$p]) {    $match .= " AND $p = %d";    $args[] = $item[$p];    $p = 'p'. ++$i;  }  $max_depth = db_result(db_query_range("SELECT depth FROM {menu_links} WHERE menu_name = '%s'". $match ." ORDER BY depth DESC", $args, 0, 1));  return ($max_depth > $item['depth']) ? $max_depth - $item['depth'] : 0;}/** * Update the children of a menu link that's being moved. * * The menu name, parents (p1 - p6), and depth are updated for all children of * the link, and the has_children status of the previous parent is updated. */function _menu_link_move_children($item, $existing_item) {  $args[] = $item['menu_name'];  $set[] = "menu_name = '%s'";  $i = 1;  while ($i <= $item['depth']) {    $p = 'p'. $i++;    $set[] = "$p = %d";    $args[] = $item[$p];  }  $j = $existing_item['depth'] + 1;  while ($i <= MENU_MAX_DEPTH && $j <= MENU_MAX_DEPTH) {    $set[] = 'p'. $i++ .' = p'. $j++;  }  while ($i <= MENU_MAX_DEPTH) {    $set[] = 'p'. $i++ .' = 0';  }  $shift = $item['depth'] - $existing_item['depth'];  if ($shift < 0) {    $args[] = -$shift;    $set[] = 'depth = depth - %d';  }  elseif ($shift > 0) {    // The order of $set must be reversed so the new values don't overwrite the    // old ones before they can be used because "Single-table UPDATE    // assignments are generally evaluated from left to right"    // see: http://dev.mysql.com/doc/refman/5.0/en/update.html    $set = array_reverse($set);    $args = array_reverse($args);    $args[] = $shift;    $set[] = 'depth = depth + %d';  }  $where[] = "menu_name = '%s'";  $args[] = $existing_item['menu_name'];  $p = 'p1';  for ($i = 1; $i <= MENU_MAX_DEPTH && $existing_item[$p]; $p = 'p'. ++$i) {    $where[] = "$p = %d";    $args[] = $existing_item[$p];  }  db_query("UPDATE {menu_links} SET ". implode(', ', $set) ." WHERE ". implode(' AND ', $where), $args);  // Check the has_children status of the parent, while excluding this item.  _menu_update_parental_status($existing_item, TRUE);}/** * Check and update the has_children status for the parent of a link. */function _menu_update_parental_status($item, $exclude = FALSE) {  // If plid == 0, there is nothing to update.  if ($item['plid']) {    // We may want to exclude the passed link as a possible child.    $where = $exclude ? " AND mlid != %d" : '';    // Check if at least one visible child exists in the table.    $parent_has_children = (bool)db_result(db_query_range("SELECT mlid FROM {menu_links} WHERE menu_name = '%s' AND plid = %d AND hidden = 0". $where, $item['menu_name'], $item['plid'], $item['mlid'], 0, 1));    db_query("UPDATE {menu_links} SET has_children = %d WHERE mlid = %d", $parent_has_children, $item['plid']);  }}/** * Helper function that sets the p1..p9 values for a menu link being saved. */function _menu_link_parents_set(&$item, $parent) {  $i = 1;  while ($i < $item['depth']) {    $p = 'p'. $i++;    $item[$p] = $parent[$p];  }  $p = 'p'. $i++;  // The parent (p1 - p9) corresponding to the depth always equals the mlid.  $item[$p] = $item['mlid'];  while ($i <= MENU_MAX_DEPTH) {    $p = 'p'. $i++;    $item[$p] = 0;  }}/** * Helper function to build the router table based on the data from hook_menu. */function _menu_router_build($callbacks) {  // First pass: separate callbacks from paths, making paths ready for  // matching. Calculate fitness, and fill some default values.  $menu = array();  foreach ($callbacks as $path => $item) {    $load_functions = array();    $to_arg_functions = array();    $fit = 0;    $move = FALSE;    $parts = explode('/', $path, MENU_MAX_PARTS);    $number_parts = count($parts);    // We store the highest index of parts here to save some work in the fit    // calculation loop.    $slashes = $number_parts - 1;    // Extract load and to_arg functions.    foreach ($parts as $k => $part) {      $match = FALSE;      // Look for wildcards in the form allowed to be used in PHP functions,      // because we are using these to construct the load function names.      // See http://php.net/manual/en/language.functions.php for reference.      if (preg_match('/^%(|[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)$/', $part, $matches)) {        if (empty($matches[1])) {          $match = TRUE;          $load_functions[$k] = NULL;        }        else {          if (function_exists($matches[1] .'_to_arg')) {            $to_arg_functions[$k] = $matches[1] .'_to_arg';            $load_functions[$k] = NULL;            $match = TRUE;          }          if (function_exists($matches[1] .'_load')) {            $function = $matches[1] .'_load';            // Create an array of arguments that will be passed to the _load            // function when this menu path is checked, if 'load arguments'            // exists.            $load_functions[$k] = isset($item['load arguments']) ? array($function => $item['load arguments']) : $function;            $match = TRUE;          }        }      }      if ($match) {        $parts[$k] = '%';      }      else {        $fit |=  1 << ($slashes - $k);      }    }    if ($fit) {      $move = TRUE;    }    else {      // If there is no %, it fits maximally.      $fit = (1 << $number_parts) - 1;    }    $masks[$fit] = 1;    $item['load_functions'] = empty($load_functions) ? '' : serialize($load_functions);    $item['to_arg_functions'] = empty($to_arg_functions) ? '' : serialize($to_arg_functions);    $item += array(      'title' => '',      'weight' => 0,      'type' => MENU_NORMAL_ITEM,      '_number_parts' => $number_parts,      '_parts' => $parts,      '_fit' => $fit,    );    $item += array(      '_visible' => (bool)($item['type'] & MENU_VISIBLE_IN_BREADCRUMB),      '_tab' => (bool)($item['type'] & MENU_IS_LOCAL_TASK),    );    if ($move) {      $new_path = implode('/', $item['_parts']);      $menu[$new_path] = $item;      $sort[$new_path] = $number_parts;    }    else {      $menu[$path] = $item;      $sort[$path] = $number_parts;    }  }  array_multisort($sort, SORT_NUMERIC, $menu);  if (!$menu) {    // We must have a serious error - there is no data to save.    watchdog('php', 'Menu router rebuild failed - some paths may not work correctly.', array(), WATCHDOG_ERROR);    return array();  }  // Delete the existing router since we have some data to replace it.  db_query('DELETE FROM {menu_router}');  // Apply inheritance rules.  foreach ($menu as $path => $v) {    $item = &$menu[$path];    if (!$item['_tab']) {      // Non-tab items.      $item['tab_parent'] = '';      $item['tab_root'] = $path;    }    for ($i = $item['_number_parts'] - 1; $i; $i--) {      $parent_path = implode('/', array_slice($item['_parts'], 0, $i));      if (isset($menu[$parent_path])) {        $parent = $menu[$parent_path];        if (!isset($item['tab_parent'])) {          // Parent stores the parent of the path.          $item['tab_parent'] = $parent_path;        }        if (!isset($item['tab_root']) && !$parent['_tab']) {          $item['tab_root'] = $parent_path;        }        // If an access callback is not found for a default local task we use        // the callback from the parent, since we expect them to be identical.        // In all other cases, the access parameters must be specified.        if (($item['type'] == MENU_DEFAULT_LOCAL_TASK) && !isset($item['access callback']) && isset($parent['access callback'])) {          $item['access callback'] = $parent['access callback'];          if (!isset($item['access arguments']) && isset($parent['access arguments'])) {            $item['access arguments'] = $parent['access arguments'];          }        }        // Same for page callbacks.        if (!isset($item['page callback']) && isset($parent['page callback'])) {          $item['page callback'] = $parent['page callback'];          if (!isset($item['page arguments']) && isset($parent['page arguments'])) {            $item['page arguments'] = $parent['page arguments'];          }          if (!isset($item['file']) && isset($parent['file'])) {            $item['file'] = $parent['file'];          }          if (!isset($item['file path']) && isset($parent['file path'])) {            $item['file path'] = $parent['file path'];          }        }      }    }    if (!isset($item['access callback']) && isset($item['access arguments'])) {      // Default callback.      $item['access callback'] = 'user_access';    }    if (!isset($item['access callback']) || empty($item['page callback'])) {      $item['access callback'] = 0;    }    if (is_bool($item['access callback'])) {      $item['access callback'] = intval($item['access callback']);    }    $item += array(      'access arguments' => array(),      'access callback' => '',      'page arguments' => array(),      'page callback' => '',      'block callback' => '',      'title arguments' => array(),      'title callback' => 't',      'description' => '',      'position' => '',      'tab_parent' => '',      'tab_root' => $path,      'path' => $path,      'file' => '',      'file path' => '',      'include file' => '',    );    // Calculate out the file to be included for each callback, if any.    if ($item['file']) {      $file_path = $item['file path'] ? $item['file path'] : drupal_get_path('module', $item['module']);      $item['include file'] = $file_path .'/'. $item['file'];    }    $title_arguments = $item['title arguments'] ? serialize($item['title arguments']) : '';    db_query("INSERT INTO {menu_router}      (path, load_functions, to_arg_functions, access_callback,      access_arguments, page_callback, page_arguments, fit,      number_parts, tab_parent, tab_root,      title, title_callback, title_arguments,      type, block_callback, description, position, weight, file)      VALUES ('%s', '%s', '%s', '%s',      '%s', '%s', '%s', %d,      %d, '%s', '%s',      '%s', '%s', '%s',      %d, '%s', '%s', '%s', %d, '%s')",      $path, $item['load_functions'], $item['to_arg_functions'], $item['access callback'],      serialize($item['access arguments']), $item['page callback'], serialize($item['page arguments']), $item['_fit'],      $item['_number_parts'], $item['tab_parent'], $item['tab_root'],      $item['title'], $item['title callback'], $title_arguments,      $item['type'], $item['block callback'], $item['description'], $item['position'], $item['weight'], $item['include file']);  }  // Sort the masks so they are in order of descending fit, and store them.  $masks = array_keys($masks);  rsort($masks);  variable_set('menu_masks', $masks);  return $menu;}/** * Returns TRUE if a path is external (e.g. http://example.com). */function menu_path_is_external($path) {  $colonpos = strpos($path, ':');  return $colonpos !== FALSE && !preg_match('![/?#]!', substr($path, 0, $colonpos)) && filter_xss_bad_protocol($path, FALSE) == check_plain($path);}/** * Checks whether the site is off-line for maintenance. * * This function will log the current user out and redirect to front page * if the current user has no 'administer site configuration' permission. * * @return *   FALSE if the site is not off-line or its the login page or the user has *     'administer site configuration' permission. *   TRUE for anonymous users not on the login page if the site is off-line. */function _menu_site_is_offline() {  // Check if site is set to off-line mode.  if (variable_get('site_offline', 0)) {    // Check if the user has administration privileges.    if (user_access('administer site configuration')) {      // Ensure that the off-line message is displayed only once [allowing for      // page redirects], and specifically suppress its display on the site      // maintenance page.      if (drupal_get_normal_path($_GET['q']) != 'admin/settings/site-maintenance') {        drupal_set_message(l(t('Operating in off-line mode.'), 'admin/settings/site-maintenance'), 'status', FALSE);      }    }    else {      // Anonymous users get a FALSE at the login prompt, TRUE otherwise.      if (user_is_anonymous()) {        return $_GET['q'] != 'user' && $_GET['q'] != 'user/login';      }      // Logged in users are unprivileged here, so they are logged out.      require_once drupal_get_path('module', 'user') .'/user.pages.inc';      user_logout();    }  }  return FALSE;}/** * Validates the path of a menu link being created or edited. * * @return *   TRUE if it is a valid path AND the current user has access permission, *   FALSE otherwise. */function menu_valid_path($form_item) {  global $menu_admin;  $item = array();  $path = $form_item['link_path'];  // We indicate that a menu administrator is running the menu access check.  $menu_admin = TRUE;  if ($path == '<front>' || menu_path_is_external($path)) {    $item = array('access' => TRUE);  }  elseif (preg_match('/\/\%/', $path)) {    // Path is dynamic (ie 'user/%'), so check directly against menu_router table.    if ($item = db_fetch_array(db_query("SELECT * FROM {menu_router} where path = '%s' ", $path))) {      $item['link_path']  = $form_item['link_path'];      $item['link_title'] = $form_item['link_title'];      $item['external']   = FALSE;      $item['options'] = '';      _menu_link_translate($item);    }  }  else {    $item = menu_get_item($path);  }  $menu_admin = FALSE;  return $item && $item['access'];}/** * @} End of "defgroup menu". */
<?php// $Id$/** * @file * Admin page callbacks for the aggregator module. *//** * Menu callback; displays the aggregator administration page. */function aggregator_admin_overview() {  return aggregator_view();}/** * Displays the aggregator administration page. * * @return *   The page HTML. */function aggregator_view() {  $result = db_query('SELECT f.*, COUNT(i.iid) AS items FROM {aggregator_feed} f LEFT JOIN {aggregator_item} i ON f.fid = i.fid GROUP BY f.fid, f.title, f.url, f.refresh, f.checked, f.link, f.description, f.etag, f.modified, f.image, f.block ORDER BY f.title');  $output = '<h3>'. t('Feed overview') .'</h3>';  $header = array(t('Title'), t('Items'), t('Last update'), t('Next update'), array('data' => t('Operations'), 'colspan' => '3'));  $rows = array();  while ($feed = db_fetch_object($result)) {    $rows[] = array(l($feed->title, "aggregator/sources/$feed->fid"), format_plural($feed->items, '1 item', '@count items'), ($feed->checked ? t('@time ago', array('@time' => format_interval(time() - $feed->checked))) : t('never')), ($feed->checked ? t('%time left', array('%time' => format_interval($feed->checked + $feed->refresh - time()))) : t('never')), l(t('edit'), "admin/content/aggregator/edit/feed/$feed->fid"), l(t('remove items'), "admin/content/aggregator/remove/$feed->fid"), l(t('update items'), "admin/content/aggregator/update/$feed->fid"));  }  $output .= theme('table', $header, $rows);  $result = db_query('SELECT c.cid, c.title, count(ci.iid) as items FROM {aggregator_category} c LEFT JOIN {aggregator_category_item} ci ON c.cid = ci.cid GROUP BY c.cid, c.title ORDER BY title');  $output .= '<h3>'. t('Category overview') .'</h3>';  $header = array(t('Title'), t('Items'), t('Operations'));  $rows = array();  while ($category = db_fetch_object($result)) {    $rows[] = array(l($category->title, "aggregator/categories/$category->cid"), format_plural($category->items, '1 item', '@count items'), l(t('edit'), "admin/content/aggregator/edit/category/$category->cid"));  }  $output .= theme('table', $header, $rows);  return $output;}/** * Form builder; Generate a form to add/edit feed sources. * * @ingroup forms * @see aggregator_form_feed_validate() * @see aggregator_form_feed_submit() */function aggregator_form_feed(&$form_state, $edit = array('refresh' => 900, 'title' => '', 'url' => '', 'fid' => NULL)) {  $period = drupal_map_assoc(array(900, 1800, 3600, 7200, 10800, 21600, 32400, 43200, 64800, 86400, 172800, 259200, 604800, 1209600, 2419200), 'format_interval');  if ($edit['refresh'] == '') {    $edit['refresh'] = 3600;  }  $form['title'] = array('#type' => 'textfield',    '#title' => t('Title'),    '#default_value' => $edit['title'],    '#maxlength' => 255,    '#description' => t('The name of the feed (or the name of the website providing the feed).'),    '#required' => TRUE,  );  $form['url'] = array('#type' => 'textfield',    '#title' => t('URL'),    '#default_value' => $edit['url'],    '#maxlength' => 255,    '#description' => t('The fully-qualified URL of the feed.'),    '#required' => TRUE,  );  $form['refresh'] = array('#type' => 'select',    '#title' => t('Update interval'),    '#default_value' => $edit['refresh'],    '#options' => $period,    '#description' => t('The length of time between feed updates. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status'))),  );  // Handling of categories:  $options = array();  $values = array();  $categories = db_query('SELECT c.cid, c.title, f.fid FROM {aggregator_category} c LEFT JOIN {aggregator_category_feed} f ON c.cid = f.cid AND f.fid = %d ORDER BY title', $edit['fid']);  while ($category = db_fetch_object($categories)) {    $options[$category->cid] = check_plain($category->title);    if ($category->fid) $values[] = $category->cid;  }  if ($options) {    $form['category'] = array('#type' => 'checkboxes',      '#title' => t('Categorize news items'),      '#default_value' => $values,      '#options' => $options,      '#description' => t('New feed items are automatically filed in the checked categories.'),    );  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));  if ($edit['fid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['fid'] = array('#type' => 'hidden', '#value' => $edit['fid']);  }  return $form;}/** * Validate aggregator_form_feed form submissions. */function aggregator_form_feed_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Save')) {    // Ensure URL is valid.    if (!valid_url($form_state['values']['url'], TRUE)) {      form_set_error('url', t('The URL %url is invalid. Please enter a fully-qualified URL, such as http://www.example.com/feed.xml.', array('%url' => $form_state['values']['url'])));    }    // Check for duplicate titles.    if (isset($form_state['values']['fid'])) {      $result = db_query("SELECT title, url FROM {aggregator_feed} WHERE (title = '%s' OR url = '%s') AND fid <> %d", $form_state['values']['title'], $form_state['values']['url'], $form_state['values']['fid']);    }    else {      $result = db_query("SELECT title, url FROM {aggregator_feed} WHERE title = '%s' OR url = '%s'", $form_state['values']['title'], $form_state['values']['url']);    }    while ($feed = db_fetch_object($result)) {      if (strcasecmp($feed->title, $form_state['values']['title']) == 0) {        form_set_error('title', t('A feed named %feed already exists. Please enter a unique title.', array('%feed' => $form_state['values']['title'])));      }      if (strcasecmp($feed->url, $form_state['values']['url']) == 0) {        form_set_error('url', t('A feed with this URL %url already exists. Please enter a unique URL.', array('%url' => $form_state['values']['url'])));      }    }  }}/** * Process aggregator_form_feed form submissions. * * @todo Add delete confirmation dialog. */function aggregator_form_feed_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Delete')) {    $title = $form_state['values']['title'];    // Unset the title:    unset($form_state['values']['title']);  }  aggregator_save_feed($form_state['values']);  if (isset($form_state['values']['fid'])) {    if (isset($form_state['values']['title'])) {      drupal_set_message(t('The feed %feed has been updated.', array('%feed' => $form_state['values']['title'])));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/sources/'. $form_state['values']['fid'];        return;      }    }    else {      watchdog('aggregator', 'Feed %feed deleted.', array('%feed' => $title));      drupal_set_message(t('The feed %feed has been deleted.', array('%feed' => $title)));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/sources/';        return;      }    }  }  else {    watchdog('aggregator', 'Feed %feed added.', array('%feed' => $form_state['values']['title']), WATCHDOG_NOTICE, l(t('view'), 'admin/content/aggregator'));    drupal_set_message(t('The feed %feed has been added.', array('%feed' => $form_state['values']['title'])));  }}function aggregator_admin_remove_feed($form_state, $feed) {  return confirm_form(    array(      'feed' => array(        '#type' => 'value',        '#value' => $feed,      ),    ),    t('Are you sure you want to remove all items from the feed %feed?', array('%feed' => $feed['title'])),    'admin/content/aggregator',    t('This action cannot be undone.'),    t('Remove items'),    t('Cancel')  );}/** * Remove all items from a feed and redirect to the overview page. * * @param $feed *   An associative array describing the feed to be cleared. */function aggregator_admin_remove_feed_submit($form, &$form_state) {  aggregator_remove($form_state['values']['feed']);  $form_state['redirect'] = 'admin/content/aggregator';}/** * Menu callback; refreshes a feed, then redirects to the overview page. * * @param $feed *   An associative array describing the feed to be refreshed. */function aggregator_admin_refresh_feed($feed) {  aggregator_refresh($feed);  drupal_goto('admin/content/aggregator');}/** * Form builder; Configure the aggregator system. * * @ingroup forms * @see system_settings_form() */function aggregator_admin_settings() {  $items = array(0 => t('none')) + drupal_map_assoc(array(3, 5, 10, 15, 20, 25), '_aggregator_items');  $period = drupal_map_assoc(array(3600, 10800, 21600, 32400, 43200, 86400, 172800, 259200, 604800, 1209600, 2419200, 4838400, 9676800), 'format_interval');  $form['aggregator_allowed_html_tags'] = array(    '#type' => 'textfield', '#title' => t('Allowed HTML tags'), '#size' => 80, '#maxlength' => 255,    '#default_value' => variable_get('aggregator_allowed_html_tags', '<a> <b> <br> <dd> <dl> <dt> <em> <i> <li> <ol> <p> <strong> <u> <ul>'),    '#description' => t('A space-separated list of HTML tags allowed in the content of feed items. (Tags in this list are not removed by Drupal.)')  );  $form['aggregator_summary_items'] = array(    '#type' => 'select', '#title' => t('Items shown in sources and categories pages') ,    '#default_value' => variable_get('aggregator_summary_items', 3), '#options' => $items,    '#description' => t('Number of feed items displayed in feed and category summary pages.')  );  $form['aggregator_clear'] = array(    '#type' => 'select', '#title' => t('Discard items older than'),    '#default_value' => variable_get('aggregator_clear', 9676800), '#options' => $period,    '#description' => t('The length of time to retain feed items before discarding. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status')))  );  $form['aggregator_category_selector'] = array(    '#type' => 'radios', '#title' => t('Category selection type'), '#default_value' => variable_get('aggregator_category_selector', 'checkboxes'),    '#options' => array('checkboxes' => t('checkboxes'), 'select' => t('multiple selector')),    '#description' => t('The type of category selection widget displayed on categorization pages. (For a small number of categories, checkboxes are easier to use, while a multiple selector work well with large numbers of categories.)')  );  return system_settings_form($form);}/** * Form builder; Generate a form to add/edit/delete aggregator categories. * * @ingroup forms * @see aggregator_form_category_validate() * @see aggregator_form_category_submit() */function aggregator_form_category(&$form_state, $edit = array('title' => '', 'description' => '', 'cid' => NULL)) {  $form['title'] = array('#type' => 'textfield',    '#title' => t('Title'),    '#default_value' => $edit['title'],    '#maxlength' => 64,    '#required' => TRUE,  );  $form['description'] = array('#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));  if ($edit['cid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['cid'] = array('#type' => 'hidden', '#value' => $edit['cid']);  }  return $form;}/** * Validate aggregator_form_feed form submissions. */function aggregator_form_category_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Save')) {    // Check for duplicate titles    if (isset($form_state['values']['cid'])) {      $category = db_fetch_object(db_query("SELECT cid FROM {aggregator_category} WHERE title = '%s' AND cid <> %d", $form_state['values']['title'], $form_state['values']['cid']));    }    else {      $category = db_fetch_object(db_query("SELECT cid FROM {aggregator_category} WHERE title = '%s'", $form_state['values']['title']));    }    if ($category) {      form_set_error('title', t('A category named %category already exists. Please enter a unique title.', array('%category' => $form_state['values']['title'])));    }  }}/** * Process aggregator_form_category form submissions. * * @todo Add delete confirmation dialog. */function aggregator_form_category_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Delete')) {    $title = $form_state['values']['title'];    // Unset the title:    unset($form_state['values']['title']);  }  aggregator_save_category($form_state['values']);  if (isset($form_state['values']['cid'])) {    if (isset($form_state['values']['title'])) {      drupal_set_message(t('The category %category has been updated.', array('%category' => $form_state['values']['title'])));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/categories/'. $form_state['values']['cid'];        return;      }    }    else {      watchdog('aggregator', 'Category %category deleted.', array('%category' => $title));      drupal_set_message(t('The category %category has been deleted.', array('%category' => $title)));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/categories/';        return;      }    }  }  else {    watchdog('aggregator', 'Category %category added.', array('%category' => $form_state['values']['title']), WATCHDOG_NOTICE, l(t('view'), 'admin/content/aggregator'));    drupal_set_message(t('The category %category has been added.', array('%category' => $form_state['values']['title'])));  }}
<?php// $Id$/** * @file profile-listing.tpl.php * Default theme implementation for displaying a user and their profile data * for member listing pages. * * @see profile-wrapper.tpl.php *      where all the data is collected and printed out. * * Available variables: * - $picture: Image configured for the account linking to the users page. * - $name: User's account name linking to the users page. * - $profile: Keyed array of all profile fields that are set as visible *   in member list pages (configured by site administrators). It also needs *   to have a value in order to be present. * * Each $field in $profile contains: * - $field->title: Title of the profile field. * - $field->value: Value of the profile field. * - $field->type: Type of the profile field, i.e., checkbox, textfield, *   textarea, selection, list, url or date. * * Since $profile is keyed, a direct print of the field is possible. Not * all accounts may have a value for a profile so do a check first. If a field * of "last_name" was set for the site, the following can be used. * *  <?php if (isset($profile['last_name'])): ?> *    <div class="field last-name"> *      <?php print $profile['last_name']->title; ?>:<br /> *      <?php print $profile['last_name']->value; ?> *    </div> *  <?php endif; ?> * * @see template_preprocess_profile_listing() */?><div class="profile">  <?php print $picture; ?>  <div class="name">    <?php print $name; ?>  </div>  <?php foreach ($profile as $field) : ?>    <div class="field">      <?php print $field->value; ?>    </div>  <?php endforeach; ?></div>
<?php// $Id$/** * @file * Functions to aid in the creation of sortable tables. * * All tables created with a call to theme('table') have the option of having * column headers that the user can click on to sort the table by that column. *//** * Initialize the table sort context. */function tablesort_init($header) {  $ts = tablesort_get_order($header);  $ts['sort'] = tablesort_get_sort($header);  $ts['query_string'] = tablesort_get_querystring();  return $ts;}/** * Create an SQL sort clause. * * This function produces the ORDER BY clause to insert in your SQL queries, * assuring that the returned database table rows match the sort order chosen * by the user. * * @param $header *   An array of column headers in the format described in theme_table(). * @param $before *   An SQL string to insert after ORDER BY and before the table sorting code. *   Useful for sorting by important attributes like "sticky" first. * @return *   An SQL string to append to the end of a query. * * @ingroup database */function tablesort_sql($header, $before = '') {  $ts = tablesort_init($header);  if ($ts['sql']) {    // Based on code from db_escape_table(), but this can also contain a dot.    $field = preg_replace('/[^A-Za-z0-9_.]+/', '', $ts['sql']);    // Sort order can only be ASC or DESC.    $sort = drupal_strtoupper($ts['sort']);    $sort = in_array($sort, array('ASC', 'DESC')) ? $sort : '';    return " ORDER BY $before $field $sort";  }}/** * Format a column header. * * If the cell in question is the column header for the current sort criterion, * it gets special formatting. All possible sort criteria become links. * * @param $cell *   The cell to format. * @param $header *   An array of column headers in the format described in theme_table(). * @param $ts *   The current table sort context as returned from tablesort_init(). * @return *   A properly formatted cell, ready for _theme_table_cell(). */function tablesort_header($cell, $header, $ts) {  // Special formatting for the currently sorted column header.  if (is_array($cell) && isset($cell['field'])) {    $title = t('sort by @s', array('@s' => $cell['data']));    if ($cell['data'] == $ts['name']) {      $ts['sort'] = (($ts['sort'] == 'asc') ? 'desc' : 'asc');      if (isset($cell['class'])) {        $cell['class'] .= ' active';      }      else {        $cell['class'] = 'active';      }      $image = theme('tablesort_indicator', $ts['sort']);    }    else {      // If the user clicks a different header, we want to sort ascending initially.      $ts['sort'] = 'asc';      $image = '';    }    if (!empty($ts['query_string'])) {      $ts['query_string'] = '&'. $ts['query_string'];    }    $cell['data'] = l($cell['data'] . $image, $_GET['q'], array('attributes' => array('title' => $title), 'query' => 'sort='. $ts['sort'] .'&order='. urlencode($cell['data']) . $ts['query_string'], 'html' => TRUE));    unset($cell['field'], $cell['sort']);  }  return $cell;}/** * Format a table cell. * * Adds a class attribute to all cells in the currently active column. * * @param $cell *   The cell to format. * @param $header *   An array of column headers in the format described in theme_table(). * @param $ts *   The current table sort context as returned from tablesort_init(). * @param $i *   The index of the cell's table column. * @return *   A properly formatted cell, ready for _theme_table_cell(). */function tablesort_cell($cell, $header, $ts, $i) {  if (isset($header[$i]['data']) && $header[$i]['data'] == $ts['name'] && !empty($header[$i]['field'])) {    if (is_array($cell)) {      if (isset($cell['class'])) {        $cell['class'] .= ' active';      }      else {        $cell['class'] = 'active';      }    }    else {      $cell = array('data' => $cell, 'class' => 'active');    }  }  return $cell;}/** * Compose a query string to append to table sorting requests. * * @return *   A query string that consists of all components of the current page request *   except for those pertaining to table sorting. */function tablesort_get_querystring() {  return drupal_query_string_encode($_REQUEST, array_merge(array('q', 'sort', 'order', 'pass'), array_keys($_COOKIE)));}/** * Determine the current sort criterion. * * @param $headers *   An array of column headers in the format described in theme_table(). * @return *   An associative array describing the criterion, containing the keys: *   - "name": The localized title of the table column. *   - "sql": The name of the database field to sort on. */function tablesort_get_order($headers) {  $order = isset($_GET['order']) ? $_GET['order'] : '';  foreach ($headers as $header) {    if (isset($header['data']) && $order == $header['data']) {      return array('name' => $header['data'], 'sql' => isset($header['field']) ? $header['field'] : '');    }    if (isset($header['sort']) && ($header['sort'] == 'asc' || $header['sort'] == 'desc')) {      $default = array('name' => $header['data'], 'sql' => isset($header['field']) ? $header['field'] : '');    }  }  if (isset($default)) {    return $default;  }  else {    // The first column specified is initial 'order by' field unless otherwise specified    if (is_array($headers[0])) {      $headers[0] += array('data' => NULL, 'field' => NULL);      return array('name' => $headers[0]['data'], 'sql' => $headers[0]['field']);    }    else {      return array('name' => $headers[0]);    }  }}/** * Determine the current sort direction. * * @param $headers *   An array of column headers in the format described in theme_table(). * @return *   The current sort direction ("asc" or "desc"). */function tablesort_get_sort($headers) {  if (isset($_GET['sort'])) {    return ($_GET['sort'] == 'desc') ? 'desc' : 'asc';  }  // User has not specified a sort. Use default if specified; otherwise use "asc".  else {    foreach ($headers as $header) {      if (is_array($header) && array_key_exists('sort', $header)) {        return $header['sort'];      }    }  }  return 'asc';}
<?php// $Id$/** * @file * Manages displaying online help. *//** * Implementation of hook_menu(). */function help_menu() {  $items['admin/help'] = array(    'title' => 'Help',    'page callback' => 'help_main',    'access arguments' => array('access administration pages'),    'weight' => 9,    'file' => 'help.admin.inc',  );  foreach (module_implements('help', TRUE) as $module) {    $items['admin/help/'. $module] = array(      'title' => $module,      'page callback' => 'help_page',      'page arguments' => array(2),      'access arguments' => array('access administration pages'),      'type' => MENU_CALLBACK,      'file' => 'help.admin.inc',    );  }  return $items;}/** * Implementation of hook_help(). */function help_help($path, $arg) {  switch ($path) {    case 'admin/help':      $output = '<p>'. t('This guide provides context sensitive help on the use and configuration of <a href="@drupal">Drupal</a> and its modules, and is a supplement to the more extensive online <a href="@handbook">Drupal handbook</a>. The online handbook may contain more up-to-date information, is annotated with helpful user-contributed comments, and serves as the definitive reference point for all Drupal documentation.', array('@drupal' => 'http://drupal.org', '@handbook' => 'http://drupal.org/handbook')) .'</p>';      return $output;    case 'admin/help#help':      $output = '<p>'. t('The help module provides context sensitive help on the use and configuration of <a href="@drupal">Drupal</a> and its modules, and is a supplement to the more extensive online <a href="@handbook">Drupal handbook</a>. The online handbook may contain more up-to-date information, is annotated with helpful user-contributed comments, and serves as the definitive reference point for all Drupal documentation.', array('@drupal' => 'http://drupal.org', '@handbook' => 'http://drupal.org/handbook')) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@help">Help module</a>.', array('@help' => 'http://drupal.org/handbook/modules/help/')) .'</p>';      return $output;  }}
<?php// $Id$/** * Implementation of hook_install(). */function php_install() {  $format_exists = db_result(db_query("SELECT COUNT(*) FROM {filter_formats} WHERE name = 'PHP code'"));  // Add a PHP code input format, if it does not exist. Do this only for the  // first install (or if the format has been manually deleted) as there is no  // reliable method to identify the format in an uninstall hook or in  // subsequent clean installs.  if (!$format_exists) {    db_query("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('PHP code', '', 0)");    $format = db_result(db_query("SELECT MAX(format) FROM {filter_formats}"));    // Enable the PHP evaluator filter.    db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, 'php', 0, 0)", $format);    drupal_set_message(t('A !php-code input format has been created.', array('!php-code' => l('PHP code', 'admin/settings/filters/'. $format))));  }}/** * Implementation of hook_disable(). */function php_disable() {  drupal_set_message(t('The PHP module has been disabled. Please note that any existing content that was using the PHP filter will now be visible in plain text. This might pose a security risk by exposing sensitive information, if any, used in the PHP code.'));}
<?php// $Id$/** * Implementation of hook_schema(). */function block_schema() {  $schema['blocks'] = array(    'description' => 'Stores block settings, such as region and visibility settings.',    'fields' => array(      'bid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique block ID.',      ),      'module' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => "The module from which the block originates; for example, 'user' for the Who's Online block, and 'block' for any custom blocks.",      ),      'delta' => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '0',        'description' => 'Unique ID for block within a module.',      ),      'theme' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'The theme under which the block settings apply.',      ),      'status' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Block enabled status. (1 = enabled, 0 = disabled)',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Block weight within region.',      ),      'region' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Theme region within which the block is set.',      ),      'custom' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate how users may control visibility of the block. (0 = Users cannot control, 1 = On by default, but can be hidden, 2 = Hidden by default, but can be shown)',      ),      'throttle' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate whether or not to remove block when website traffic is high. (1 = throttle, 0 = do not throttle)',      ),      'visibility' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate how to show blocks on pages. (0 = Show on all pages except listed pages, 1 = Show only on listed pages, 2 = Use custom PHP code to determine visibility)',      ),      'pages' => array(        'type' => 'text',        'not null' => TRUE,        'description' => 'Contents of the "Pages" block; contains either a list of paths on which to include/exclude the block or PHP code, depending on "visibility" setting.',      ),      'title' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Custom title for the block. (Empty string will use block default title, &lt;none&gt; will remove the title, text will cause block to use specified title.)',      ),      'cache' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 1,        'size' => 'tiny',        'description' => 'Binary flag to indicate block cache mode. (-1: Do not cache, 1: Cache per role, 2: Cache per user, 4: Cache per page, 8: Block cache global) See BLOCK_CACHE_* constants in block.module for more detailed information.',      ),    ),    'primary key' => array('bid'),    'unique keys' => array(      'tmd' => array('theme', 'module', 'delta'),    ),    'indexes' => array(      'list' => array('theme', 'status', 'region', 'weight', 'module'),    ),  );  $schema['blocks_roles'] = array(    'description' => 'Sets up access permissions for blocks based on user roles',    'fields' => array(      'module' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'description' => "The block's origin module, from {blocks}.module.",      ),      'delta'  => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'description' => "The block's unique delta within module, from {blocks}.delta.",      ),      'rid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => "The user's role ID from {users_roles}.rid.",      ),    ),    'primary key' => array(      'module',      'delta',      'rid'    ),    'indexes' => array(      'rid' => array('rid'),    ),  );  $schema['boxes'] = array(    'description' => 'Stores contents of custom-made blocks.',    'fields' => array(      'bid' => array(        'type' => 'serial',  'unsigned' => TRUE,        'not null' => TRUE,        'description' => "The block's {blocks}.bid.",      ),      'body' => array(        'type' => 'text',        'not null' => FALSE,        'size' => 'big',        'description' => 'Block contents.',      ),      'info' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Block description.',      ),      'format' => array(        'type' => 'int',        'size' => 'small',        'not null' => TRUE,        'default' => 0,        'description' => "Block body's {filter_formats}.format; for example, 1 = Filtered HTML.",      )    ),    'unique keys' => array('info' => array('info')),    'primary key' => array('bid'),  );  $schema['cache_block'] = drupal_get_schema_unprocessed('system', 'cache');  $schema['cache_block']['description'] = 'Cache table for the Block module to store already built blocks, identified by module, delta, and various contexts which may change the block, such as theme, locale, and caching mode defined for the block.';  return $schema;}
<?php// $Id$?><div class="comment<?php print ($comment->new) ? ' comment-new' : ''; print ' '. $status; print ' '. $zebra; ?>">  <div class="clear-block">  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted; ?></span>  <?php endif; ?>  <?php if ($comment->new) : ?>    <span class="new"><?php print drupal_ucfirst($new) ?></span>  <?php endif; ?>  <?php print $picture ?>    <h3><?php print $title ?></h3>    <div class="content">      <?php print $content ?>      <?php if ($signature): ?>      <div class="clear-block">        <div></div>        <?php print $signature ?>      </div>      <?php endif; ?>    </div>  </div>  <?php if ($links): ?>    <div class="links"><?php print $links ?></div>  <?php endif; ?></div>
<?php// $Id$/** * @file * Functions that need to be loaded on every Drupal request. *//** * Indicates that the item should never be removed unless explicitly told to * using cache_clear_all() with a cache ID. */define('CACHE_PERMANENT', 0);/** * Indicates that the item should be removed at the next general cache wipe. */define('CACHE_TEMPORARY', -1);/** * Indicates that page caching is disabled. */define('CACHE_DISABLED', 0);/** * Indicates that page caching is enabled, using "normal" mode. */define('CACHE_NORMAL', 1);/** * Indicates that page caching is using "aggressive" mode. This bypasses * loading any modules for additional speed, which may break functionality in * modules that expect to be run on each page load. */define('CACHE_AGGRESSIVE', 2);/** * * Severity levels, as defined in RFC 3164 http://www.faqs.org/rfcs/rfc3164.html * @see watchdog() * @see watchdog_severity_levels() */define('WATCHDOG_EMERG',    0); // Emergency: system is unusabledefine('WATCHDOG_ALERT',    1); // Alert: action must be taken immediatelydefine('WATCHDOG_CRITICAL', 2); // Critical: critical conditionsdefine('WATCHDOG_ERROR',    3); // Error: error conditionsdefine('WATCHDOG_WARNING',  4); // Warning: warning conditionsdefine('WATCHDOG_NOTICE',   5); // Notice: normal but significant conditiondefine('WATCHDOG_INFO',     6); // Informational: informational messagesdefine('WATCHDOG_DEBUG',    7); // Debug: debug-level messages/** * First bootstrap phase: initialize configuration. */define('DRUPAL_BOOTSTRAP_CONFIGURATION', 0);/** * Second bootstrap phase: try to call a non-database cache * fetch routine. */define('DRUPAL_BOOTSTRAP_EARLY_PAGE_CACHE', 1);/** * Third bootstrap phase: initialize database layer. */define('DRUPAL_BOOTSTRAP_DATABASE', 2);/** * Fourth bootstrap phase: identify and reject banned hosts. */define('DRUPAL_BOOTSTRAP_ACCESS', 3);/** * Fifth bootstrap phase: initialize session handling. */define('DRUPAL_BOOTSTRAP_SESSION', 4);/** * Sixth bootstrap phase: load bootstrap.inc and module.inc, start * the variable system and try to serve a page from the cache. */define('DRUPAL_BOOTSTRAP_LATE_PAGE_CACHE', 5);/** * Seventh bootstrap phase: find out language of the page. */define('DRUPAL_BOOTSTRAP_LANGUAGE', 6);/** * Eighth bootstrap phase: set $_GET['q'] to Drupal path of request. */define('DRUPAL_BOOTSTRAP_PATH', 7);/** * Final bootstrap phase: Drupal is fully loaded; validate and fix * input data. */define('DRUPAL_BOOTSTRAP_FULL', 8);/** * Role ID for anonymous users; should match what's in the "role" table. */define('DRUPAL_ANONYMOUS_RID', 1);/** * Role ID for authenticated users; should match what's in the "role" table. */define('DRUPAL_AUTHENTICATED_RID', 2);/** * No language negotiation. The default language is used. */define('LANGUAGE_NEGOTIATION_NONE', 0);/** * Path based negotiation with fallback to default language * if no defined path prefix identified. */define('LANGUAGE_NEGOTIATION_PATH_DEFAULT', 1);/** * Path based negotiation with fallback to user preferences * and browser language detection if no defined path prefix * identified. */define('LANGUAGE_NEGOTIATION_PATH', 2);/** * Domain based negotiation with fallback to default language * if no language identified by domain. */define('LANGUAGE_NEGOTIATION_DOMAIN', 3);/** * Language written left to right. Possible value of $language->direction. */define('LANGUAGE_LTR', 0);/** * Language written right to left. Possible value of $language->direction. */define('LANGUAGE_RTL', 1);/** * Start the timer with the specified name. If you start and stop * the same timer multiple times, the measured intervals will be * accumulated. * * @param name *   The name of the timer. */function timer_start($name) {  global $timers;  list($usec, $sec) = explode(' ', microtime());  $timers[$name]['start'] = (float)$usec + (float)$sec;  $timers[$name]['count'] = isset($timers[$name]['count']) ? ++$timers[$name]['count'] : 1;}/** * Read the current timer value without stopping the timer. * * @param name *   The name of the timer. * @return *   The current timer value in ms. */function timer_read($name) {  global $timers;  if (isset($timers[$name]['start'])) {    list($usec, $sec) = explode(' ', microtime());    $stop = (float)$usec + (float)$sec;    $diff = round(($stop - $timers[$name]['start']) * 1000, 2);    if (isset($timers[$name]['time'])) {      $diff += $timers[$name]['time'];    }    return $diff;  }}/** * Stop the timer with the specified name. * * @param name *   The name of the timer. * @return *   A timer array. The array contains the number of times the *   timer has been started and stopped (count) and the accumulated *   timer value in ms (time). */function timer_stop($name) {  global $timers;  $timers[$name]['time'] = timer_read($name);  unset($timers[$name]['start']);  return $timers[$name];}/** * Find the appropriate configuration directory. * * Try finding a matching configuration directory by stripping the website's * hostname from left to right and pathname from right to left. The first * configuration file found will be used; the remaining will ignored. If no * configuration file is found, return a default value '$confdir/default'. * * Example for a fictitious site installed at * http://www.drupal.org:8080/mysite/test/ the 'settings.php' is searched in * the following directories: * *  1. $confdir/8080.www.drupal.org.mysite.test *  2. $confdir/www.drupal.org.mysite.test *  3. $confdir/drupal.org.mysite.test *  4. $confdir/org.mysite.test * *  5. $confdir/8080.www.drupal.org.mysite *  6. $confdir/www.drupal.org.mysite *  7. $confdir/drupal.org.mysite *  8. $confdir/org.mysite * *  9. $confdir/8080.www.drupal.org * 10. $confdir/www.drupal.org * 11. $confdir/drupal.org * 12. $confdir/org * * 13. $confdir/default * * @param $require_settings *   Only configuration directories with an existing settings.php file *   will be recognized. Defaults to TRUE. During initial installation, *   this is set to FALSE so that Drupal can detect a matching directory, *   then create a new settings.php file in it. * @param reset *   Force a full search for matching directories even if one had been *   found previously. * @return *   The path of the matching directory. */function conf_path($require_settings = TRUE, $reset = FALSE) {  static $conf = '';  if ($conf && !$reset) {    return $conf;  }  $confdir = 'sites';  $uri = explode('/', $_SERVER['SCRIPT_NAME'] ? $_SERVER['SCRIPT_NAME'] : $_SERVER['SCRIPT_FILENAME']);  $server = explode('.', implode('.', array_reverse(explode(':', rtrim($_SERVER['HTTP_HOST'], '.')))));  for ($i = count($uri) - 1; $i > 0; $i--) {    for ($j = count($server); $j > 0; $j--) {      $dir = implode('.', array_slice($server, -$j)) . implode('.', array_slice($uri, 0, $i));      if (file_exists("$confdir/$dir/settings.php") || (!$require_settings && file_exists("$confdir/$dir"))) {        $conf = "$confdir/$dir";        return $conf;      }    }  }  $conf = "$confdir/default";  return $conf;}/** * Unsets all disallowed global variables. See $allowed for what's allowed. */function drupal_unset_globals() {  if (ini_get('register_globals')) {    $allowed = array('_ENV' => 1, '_GET' => 1, '_POST' => 1, '_COOKIE' => 1, '_FILES' => 1, '_SERVER' => 1, '_REQUEST' => 1, 'GLOBALS' => 1);    foreach ($GLOBALS as $key => $value) {      if (!isset($allowed[$key])) {        unset($GLOBALS[$key]);      }    }  }}/** * Validate that a hostname (for example $_SERVER['HTTP_HOST']) is safe. * * As $_SERVER['HTTP_HOST'] is user input, ensure it only contains characters * allowed in hostnames.  See RFC 952 (and RFC 2181). $_SERVER['HTTP_HOST'] is * lowercased. * * @return *  TRUE if only containing valid characters, or FALSE otherwise. */function drupal_valid_http_host($host) {  return preg_match('/^\[?(?:[a-z0-9-:\]_]+\.?)+$/', $host);}/** * Loads the configuration and sets the base URL, cookie domain, and * session name correctly. */function conf_init() {  global $base_url, $base_path, $base_root;  // Export the following settings.php variables to the global namespace  global $db_url, $db_prefix, $cookie_domain, $conf, $installed_profile, $update_free_access;  $conf = array();  if (isset($_SERVER['HTTP_HOST'])) {    // As HTTP_HOST is user input, ensure it only contains characters allowed    // in hostnames. See RFC 952 (and RFC 2181).    // $_SERVER['HTTP_HOST'] is lowercased here per specifications.    $_SERVER['HTTP_HOST'] = strtolower($_SERVER['HTTP_HOST']);    if (!drupal_valid_http_host($_SERVER['HTTP_HOST'])) {      // HTTP_HOST is invalid, e.g. if containing slashes it may be an attack.      header('HTTP/1.1 400 Bad Request');      exit;    }  }  else {    // Some pre-HTTP/1.1 clients will not send a Host header. Ensure the key is    // defined for E_ALL compliance.    $_SERVER['HTTP_HOST'] = '';  }  if (file_exists('./'. conf_path() .'/settings.php')) {    include_once './'. conf_path() .'/settings.php';  }  // Ignore the placeholder url from default.settings.php.  if (isset($db_url) && $db_url == 'mysql://username:password@localhost/databasename') {    $db_url = '';  }  if (isset($base_url)) {    // Parse fixed base URL from settings.php.    $parts = parse_url($base_url);    if (!isset($parts['path'])) {      $parts['path'] = '';    }    $base_path = $parts['path'] .'/';    // Build $base_root (everything until first slash after "scheme://").    $base_root = substr($base_url, 0, strlen($base_url) - strlen($parts['path']));  }  else {    // Create base URL    $base_root = (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on') ? 'https' : 'http';    $base_url = $base_root .= '://'. $_SERVER['HTTP_HOST'];    // $_SERVER['SCRIPT_NAME'] can, in contrast to $_SERVER['PHP_SELF'], not    // be modified by a visitor.    if ($dir = trim(dirname($_SERVER['SCRIPT_NAME']), '\,/')) {      $base_path = "/$dir";      $base_url .= $base_path;      $base_path .= '/';    }    else {      $base_path = '/';    }  }  if ($cookie_domain) {    // If the user specifies the cookie domain, also use it for session name.    $session_name = $cookie_domain;  }  else {    // Otherwise use $base_url as session name, without the protocol    // to use the same session identifiers across http and https.    list( , $session_name) = explode('://', $base_url, 2);    // We escape the hostname because it can be modified by a visitor.    if (!empty($_SERVER['HTTP_HOST'])) {      $cookie_domain = check_plain($_SERVER['HTTP_HOST']);    }  }  // To prevent session cookies from being hijacked, a user can configure the  // SSL version of their website to only transfer session cookies via SSL by  // using PHP's session.cookie_secure setting. The browser will then use two  // separate session cookies for the HTTPS and HTTP versions of the site. So we  // must use different session identifiers for HTTPS and HTTP to prevent a  // cookie collision.  if (ini_get('session.cookie_secure')) {    $session_name .= 'SSL';  }  // Strip leading periods, www., and port numbers from cookie domain.  $cookie_domain = ltrim($cookie_domain, '.');  if (strpos($cookie_domain, 'www.') === 0) {    $cookie_domain = substr($cookie_domain, 4);  }  $cookie_domain = explode(':', $cookie_domain);  $cookie_domain = '.'. $cookie_domain[0];  // Per RFC 2109, cookie domains must contain at least one dot other than the  // first. For hosts such as 'localhost' or IP Addresses we don't set a cookie domain.  if (count(explode('.', $cookie_domain)) > 2 && !is_numeric(str_replace('.', '', $cookie_domain))) {    ini_set('session.cookie_domain', $cookie_domain);  }  session_name('SESS'. md5($session_name));}/** * Returns and optionally sets the filename for a system item (module, * theme, etc.). The filename, whether provided, cached, or retrieved * from the database, is only returned if the file exists. * * This function plays a key role in allowing Drupal's resources (modules * and themes) to be located in different places depending on a site's * configuration. For example, a module 'foo' may legally be be located * in any of these three places: * * modules/foo/foo.module * sites/all/modules/foo/foo.module * sites/example.com/modules/foo/foo.module * * Calling drupal_get_filename('module', 'foo') will give you one of * the above, depending on where the module is located. * * @param $type *   The type of the item (i.e. theme, theme_engine, module). * @param $name *   The name of the item for which the filename is requested. * @param $filename *   The filename of the item if it is to be set explicitly rather *   than by consulting the database. * * @return *   The filename of the requested item. */function drupal_get_filename($type, $name, $filename = NULL) {  static $files = array();  if (!isset($files[$type])) {    $files[$type] = array();  }  if (!empty($filename) && file_exists($filename)) {    $files[$type][$name] = $filename;  }  elseif (isset($files[$type][$name])) {    // nothing  }  // Verify that we have an active database connection, before querying  // the database.  This is required because this function is called both  // before we have a database connection (i.e. during installation) and  // when a database connection fails.  elseif (db_is_active() && (($file = db_result(db_query("SELECT filename FROM {system} WHERE name = '%s' AND type = '%s'", $name, $type))) && file_exists($file))) {    $files[$type][$name] = $file;  }  else {    // Fallback to searching the filesystem if the database connection is    // not established or the requested file is not found.    $config = conf_path();    $dir = (($type == 'theme_engine') ? 'themes/engines' : "${type}s");    $file = (($type == 'theme_engine') ? "$name.engine" : "$name.$type");    foreach (array("$config/$dir/$file", "$config/$dir/$name/$file", "$dir/$file", "$dir/$name/$file") as $file) {      if (file_exists($file)) {        $files[$type][$name] = $file;        break;      }    }  }  if (isset($files[$type][$name])) {    return $files[$type][$name];  }}/** * Load the persistent variable table. * * The variable table is composed of values that have been saved in the table * with variable_set() as well as those explicitly specified in the configuration * file. */function variable_init($conf = array()) {  // NOTE: caching the variables improves performance by 20% when serving cached pages.  if ($cached = cache_get('variables', 'cache')) {    $variables = $cached->data;  }  else {    $result = db_query('SELECT * FROM {variable}');    while ($variable = db_fetch_object($result)) {      $variables[$variable->name] = unserialize($variable->value);    }    cache_set('variables', $variables);  }  foreach ($conf as $name => $value) {    $variables[$name] = $value;  }  return $variables;}/** * Return a persistent variable. * * @param $name *   The name of the variable to return. * @param $default *   The default value to use if this variable has never been set. * @return *   The value of the variable. * * @see variable_del(), variable_set() */function variable_get($name, $default) {  global $conf;  return isset($conf[$name]) ? $conf[$name] : $default;}/** * Set a persistent variable. * * @param $name *   The name of the variable to set. * @param $value *   The value to set. This can be any PHP data type; these functions take care *   of serialization as necessary. * * @see variable_del(), variable_get() */function variable_set($name, $value) {  global $conf;  $serialized_value = serialize($value);  db_query("UPDATE {variable} SET value = '%s' WHERE name = '%s'", $serialized_value, $name);  if (!db_affected_rows()) {    @db_query("INSERT INTO {variable} (name, value) VALUES ('%s', '%s')", $name, $serialized_value);  }  cache_clear_all('variables', 'cache');  $conf[$name] = $value;}/** * Unset a persistent variable. * * @param $name *   The name of the variable to undefine. * * @see variable_get(), variable_set() */function variable_del($name) {  global $conf;  db_query("DELETE FROM {variable} WHERE name = '%s'", $name);  cache_clear_all('variables', 'cache');  unset($conf[$name]);}/** * Retrieve the current page from the cache. * * Note: we do not serve cached pages when status messages are waiting (from * a redirected form submission which was completed). * * @param $status_only *   When set to TRUE, retrieve the status of the page cache only *   (whether it was started in this request or not). */function page_get_cache($status_only = FALSE) {  static $status = FALSE;  global $user, $base_root;  if ($status_only) {    return $status;  }  $cache = NULL;  if (!$user->uid && $_SERVER['REQUEST_METHOD'] == 'GET' && count(drupal_set_message()) == 0 && $_SERVER['SERVER_SOFTWARE'] !== 'PHP CLI') {    $cache = cache_get($base_root . request_uri(), 'cache_page');    if (empty($cache)) {      ob_start();      $status = TRUE;    }  }  return $cache;}/** * Call all init or exit hooks without including all modules. * * @param $hook *   The name of the bootstrap hook we wish to invoke. */function bootstrap_invoke_all($hook) {  foreach (module_list(TRUE, TRUE) as $module) {    drupal_load('module', $module);    module_invoke($module, $hook);  }}/** * Includes a file with the provided type and name. This prevents * including a theme, engine, module, etc., more than once. * * @param $type *   The type of item to load (i.e. theme, theme_engine, module). * @param $name *   The name of the item to load. * * @return *   TRUE if the item is loaded or has already been loaded. */function drupal_load($type, $name) {  static $files = array();  if (isset($files[$type][$name])) {    return TRUE;  }  $filename = drupal_get_filename($type, $name);  if ($filename) {    include_once "./$filename";    $files[$type][$name] = TRUE;    return TRUE;  }  return FALSE;}/** * Set HTTP headers in preparation for a page response. * * Authenticated users are always given a 'no-cache' header, and will * fetch a fresh page on every request.  This prevents authenticated * users seeing locally cached pages that show them as logged out. * * @see page_set_cache() */function drupal_page_header() {  header("Expires: Sun, 19 Nov 1978 05:00:00 GMT");  header("Last-Modified: ". gmdate("D, d M Y H:i:s") ." GMT");  header("Cache-Control: store, no-cache, must-revalidate");  header("Cache-Control: post-check=0, pre-check=0", FALSE);}/** * Set HTTP headers in preparation for a cached page response. * * The general approach here is that anonymous users can keep a local * cache of the page, but must revalidate it on every request.  Then, * they are given a '304 Not Modified' response as long as they stay * logged out and the page has not been modified. * */function drupal_page_cache_header($cache) {  // Set default values:  $last_modified = gmdate('D, d M Y H:i:s', $cache->created) .' GMT';  $etag = '"'. md5($last_modified) .'"';  // See if the client has provided the required HTTP headers:  $if_modified_since = isset($_SERVER['HTTP_IF_MODIFIED_SINCE']) ? stripslashes($_SERVER['HTTP_IF_MODIFIED_SINCE']) : FALSE;  $if_none_match = isset($_SERVER['HTTP_IF_NONE_MATCH']) ? stripslashes($_SERVER['HTTP_IF_NONE_MATCH']) : FALSE;  if ($if_modified_since && $if_none_match      && $if_none_match == $etag // etag must match      && $if_modified_since == $last_modified) {  // if-modified-since must match    header('HTTP/1.1 304 Not Modified');    // All 304 responses must send an etag if the 200 response for the same object contained an etag    header("Etag: $etag");    return;  }  // Send appropriate response:  header("Last-Modified: $last_modified");  header("ETag: $etag");  // The following headers force validation of cache:  header("Expires: Sun, 19 Nov 1978 05:00:00 GMT");  header("Cache-Control: must-revalidate");  if (variable_get('page_compression', TRUE)) {    // Determine if the browser accepts gzipped data.    if (@strpos($_SERVER['HTTP_ACCEPT_ENCODING'], 'gzip') === FALSE && function_exists('gzencode')) {      // Strip the gzip header and run uncompress.      $cache->data = gzinflate(substr(substr($cache->data, 10), 0, -8));    }    elseif (function_exists('gzencode')) {      header('Content-Encoding: gzip');    }  }  // Send the original request's headers. We send them one after  // another so PHP's header() function can deal with duplicate  // headers.  $headers = explode("\n", $cache->headers);  foreach ($headers as $header) {    header($header);  }  print $cache->data;}/** * Define the critical hooks that force modules to always be loaded. */function bootstrap_hooks() {  return array('boot', 'exit');}/** * Unserializes and appends elements from a serialized string. * * @param $obj *   The object to which the elements are appended. * @param $field *   The attribute of $obj whose value should be unserialized. */function drupal_unpack($obj, $field = 'data') {  if ($obj->$field && $data = unserialize($obj->$field)) {    foreach ($data as $key => $value) {      if (!isset($obj->$key)) {        $obj->$key = $value;      }    }  }  return $obj;}/** * Return the URI of the referring page. */function referer_uri() {  if (isset($_SERVER['HTTP_REFERER'])) {    return $_SERVER['HTTP_REFERER'];  }}/** * Encode special characters in a plain-text string for display as HTML. * * Uses drupal_validate_utf8 to prevent cross site scripting attacks on * Internet Explorer 6. */function check_plain($text) {  return drupal_validate_utf8($text) ? htmlspecialchars($text, ENT_QUOTES) : '';}/** * Checks whether a string is valid UTF-8. * * All functions designed to filter input should use drupal_validate_utf8 * to ensure they operate on valid UTF-8 strings to prevent bypass of the * filter. * * When text containing an invalid UTF-8 lead byte (0xC0 - 0xFF) is presented * as UTF-8 to Internet Explorer 6, the program may misinterpret subsequent * bytes. When these subsequent bytes are HTML control characters such as * quotes or angle brackets, parts of the text that were deemed safe by filters * end up in locations that are potentially unsafe; An onerror attribute that * is outside of a tag, and thus deemed safe by a filter, can be interpreted * by the browser as if it were inside the tag. * * This function exploits preg_match behaviour (since PHP 4.3.5) when used * with the u modifier, as a fast way to find invalid UTF-8. When the matched * string contains an invalid byte sequence, it will fail silently. * * preg_match may not fail on 4 and 5 octet sequences, even though they * are not supported by the specification. * * The specific preg_match behaviour is present since PHP 4.3.5. * * @param $text *   The text to check. * @return *   TRUE if the text is valid UTF-8, FALSE if not. */function drupal_validate_utf8($text) {  if (strlen($text) == 0) {    return TRUE;  }  return (preg_match('/^./us', $text) == 1);}/** * Since $_SERVER['REQUEST_URI'] is only available on Apache, we * generate an equivalent using other environment variables. */function request_uri() {  if (isset($_SERVER['REQUEST_URI'])) {    $uri = $_SERVER['REQUEST_URI'];  }  else {    if (isset($_SERVER['argv'])) {      $uri = $_SERVER['SCRIPT_NAME'] .'?'. $_SERVER['argv'][0];    }    elseif (isset($_SERVER['QUERY_STRING'])) {      $uri = $_SERVER['SCRIPT_NAME'] .'?'. $_SERVER['QUERY_STRING'];    }    else {      $uri = $_SERVER['SCRIPT_NAME'];    }  }  // Prevent multiple slashes to avoid cross site requests via the FAPI.  $uri = '/'. ltrim($uri, '/');  return $uri;}/** * Log a system message. * * @param $type *   The category to which this message belongs. * @param $message *   The message to store in the log. See t() for documentation *   on how $message and $variables interact. Keep $message *   translatable by not concatenating dynamic values into it! * @param $variables *   Array of variables to replace in the message on display or *   NULL if message is already translated or not possible to *   translate. * @param $severity *   The severity of the message, as per RFC 3164 * @param $link *   A link to associate with the message. * * @see watchdog_severity_levels() */function watchdog($type, $message, $variables = array(), $severity = WATCHDOG_NOTICE, $link = NULL) {  global $user, $base_root;  // Prepare the fields to be logged  $log_message = array(    'type'        => $type,    'message'     => $message,    'variables'   => $variables,    'severity'    => $severity,    'link'        => $link,    'user'        => $user,    'request_uri' => $base_root . request_uri(),    'referer'     => referer_uri(),    'ip'          => ip_address(),    'timestamp'   => time(),    );  // Call the logging hooks to log/process the message  foreach (module_implements('watchdog', TRUE) as $module) {    module_invoke($module, 'watchdog', $log_message);  }}/** * Set a message which reflects the status of the performed operation. * * If the function is called with no arguments, this function returns all set * messages without clearing them. * * @param $message *   The message should begin with a capital letter and always ends with a *   period '.'. * @param $type *   The type of the message. One of the following values are possible: *   - 'status' *   - 'warning' *   - 'error' * @param $repeat *   If this is FALSE and the message is already set, then the message won't *   be repeated. */function drupal_set_message($message = NULL, $type = 'status', $repeat = TRUE) {  if ($message) {    if (!isset($_SESSION['messages'])) {      $_SESSION['messages'] = array();    }    if (!isset($_SESSION['messages'][$type])) {      $_SESSION['messages'][$type] = array();    }    if ($repeat || !in_array($message, $_SESSION['messages'][$type])) {      $_SESSION['messages'][$type][] = $message;    }  }  // messages not set when DB connection fails  return isset($_SESSION['messages']) ? $_SESSION['messages'] : NULL;}/** * Return all messages that have been set. * * @param $type *   (optional) Only return messages of this type. * @param $clear_queue *   (optional) Set to FALSE if you do not want to clear the messages queue * @return *   An associative array, the key is the message type, the value an array *   of messages. If the $type parameter is passed, you get only that type, *   or an empty array if there are no such messages. If $type is not passed, *   all message types are returned, or an empty array if none exist. */function drupal_get_messages($type = NULL, $clear_queue = TRUE) {  if ($messages = drupal_set_message()) {    if ($type) {      if ($clear_queue) {        unset($_SESSION['messages'][$type]);      }      if (isset($messages[$type])) {        return array($type => $messages[$type]);      }    }    else {      if ($clear_queue) {        unset($_SESSION['messages']);      }      return $messages;    }  }  return array();}/** * Perform an access check for a given mask and rule type. Rules are usually * created via admin/user/rules page. * * If any allow rule matches, access is allowed. Otherwise, if any deny rule * matches, access is denied.  If no rule matches, access is allowed. * * @param $type string *   Type of access to check: Allowed values are: *     - 'host': host name or IP address *     - 'mail': e-mail address *     - 'user': username * @param $mask string *   String or mask to test: '_' matches any character, '%' matches any *   number of characters. * @return bool *   TRUE if access is denied, FALSE if access is allowed. */function drupal_is_denied($type, $mask) {  // Because this function is called for every page request, both cached  // and non-cached pages, we tried to optimize it as much as possible.  // We deny access if the only matching records in the {access} table have  // status 0 (deny). If any have status 1 (allow), or if there are no  // matching records, we allow access.  $sql = "SELECT 1 FROM {access} WHERE type = '%s' AND LOWER('%s') LIKE LOWER(mask) AND status = %d";  return db_result(db_query_range($sql, $type, $mask, 0, 0, 1)) && !db_result(db_query_range($sql, $type, $mask, 1, 0, 1));}/** * Generates a default anonymous $user object. * * @return Object - the user object. */function drupal_anonymous_user($session = '') {  $user = new stdClass();  $user->uid = 0;  $user->hostname = ip_address();  $user->roles = array();  $user->roles[DRUPAL_ANONYMOUS_RID] = 'anonymous user';  $user->session = $session;  $user->cache = 0;  return $user;}/** * A string describing a phase of Drupal to load. Each phase adds to the * previous one, so invoking a later phase automatically runs the earlier * phases too. The most important usage is that if you want to access the * Drupal database from a script without loading anything else, you can * include bootstrap.inc, and call drupal_bootstrap(DRUPAL_BOOTSTRAP_DATABASE). * * @param $phase *   A constant. Allowed values are: *     DRUPAL_BOOTSTRAP_CONFIGURATION: initialize configuration. *     DRUPAL_BOOTSTRAP_EARLY_PAGE_CACHE: try to call a non-database cache fetch routine. *     DRUPAL_BOOTSTRAP_DATABASE: initialize database layer. *     DRUPAL_BOOTSTRAP_ACCESS: identify and reject banned hosts. *     DRUPAL_BOOTSTRAP_SESSION: initialize session handling. *     DRUPAL_BOOTSTRAP_LATE_PAGE_CACHE: load bootstrap.inc and module.inc, start *       the variable system and try to serve a page from the cache. *     DRUPAL_BOOTSTRAP_LANGUAGE: identify the language used on the page. *     DRUPAL_BOOTSTRAP_PATH: set $_GET['q'] to Drupal path of request. *     DRUPAL_BOOTSTRAP_FULL: Drupal is fully loaded, validate and fix input data. */function drupal_bootstrap($phase) {  static $phases = array(DRUPAL_BOOTSTRAP_CONFIGURATION, DRUPAL_BOOTSTRAP_EARLY_PAGE_CACHE, DRUPAL_BOOTSTRAP_DATABASE, DRUPAL_BOOTSTRAP_ACCESS, DRUPAL_BOOTSTRAP_SESSION, DRUPAL_BOOTSTRAP_LATE_PAGE_CACHE, DRUPAL_BOOTSTRAP_LANGUAGE, DRUPAL_BOOTSTRAP_PATH, DRUPAL_BOOTSTRAP_FULL), $phase_index = 0;  while ($phase >= $phase_index && isset($phases[$phase_index])) {    $current_phase = $phases[$phase_index];    unset($phases[$phase_index++]);    _drupal_bootstrap($current_phase);  }}function _drupal_bootstrap($phase) {  global $conf;  switch ($phase) {    case DRUPAL_BOOTSTRAP_CONFIGURATION:      drupal_unset_globals();      // Start a page timer:      timer_start('page');      // Initialize the configuration      conf_init();      break;    case DRUPAL_BOOTSTRAP_EARLY_PAGE_CACHE:      // Allow specifying special cache handlers in settings.php, like      // using memcached or files for storing cache information.      require_once variable_get('cache_inc', './includes/cache.inc');      // If the page_cache_fastpath is set to TRUE in settings.php and      // page_cache_fastpath (implemented in the special implementation of      // cache.inc) printed the page and indicated this with a returned TRUE      // then we are done.      if (variable_get('page_cache_fastpath', FALSE) && page_cache_fastpath()) {        exit;      }      break;    case DRUPAL_BOOTSTRAP_DATABASE:      // Initialize the default database.      require_once './includes/database.inc';      db_set_active();      break;    case DRUPAL_BOOTSTRAP_ACCESS:      // Deny access to hosts which were banned - t() is not yet available.      if (drupal_is_denied('host', ip_address())) {        header('HTTP/1.1 403 Forbidden');        print 'Sorry, '. check_plain(ip_address()) .' has been banned.';        exit();      }      break;    case DRUPAL_BOOTSTRAP_SESSION:      require_once variable_get('session_inc', './includes/session.inc');      session_set_save_handler('sess_open', 'sess_close', 'sess_read', 'sess_write', 'sess_destroy_sid', 'sess_gc');      session_start();      break;    case DRUPAL_BOOTSTRAP_LATE_PAGE_CACHE:      // Initialize configuration variables, using values from settings.php if available.      $conf = variable_init(isset($conf) ? $conf : array());      $cache_mode = variable_get('cache', CACHE_DISABLED);      // Get the page from the cache.      $cache = $cache_mode == CACHE_DISABLED ? '' : page_get_cache();      // If the skipping of the bootstrap hooks is not enforced, call hook_boot.      if (!$cache || $cache_mode != CACHE_AGGRESSIVE) {        // Load module handling.        require_once './includes/module.inc';        bootstrap_invoke_all('boot');      }      // If there is a cached page, display it.      if ($cache) {        drupal_page_cache_header($cache);        // If the skipping of the bootstrap hooks is not enforced, call hook_exit.        if ($cache_mode != CACHE_AGGRESSIVE) {          bootstrap_invoke_all('exit');        }        // We are done.        exit;      }      // Prepare for non-cached page workflow.      require_once variable_get('lock_inc', './includes/lock.inc');      lock_init();      drupal_page_header();      break;    case DRUPAL_BOOTSTRAP_LANGUAGE:      drupal_init_language();      break;    case DRUPAL_BOOTSTRAP_PATH:      require_once './includes/path.inc';      // Initialize $_GET['q'] prior to loading modules and invoking hook_init().      drupal_init_path();      break;    case DRUPAL_BOOTSTRAP_FULL:      require_once './includes/common.inc';      _drupal_bootstrap_full();      break;  }}/** * Enables use of the theme system without requiring database access. * * Loads and initializes the theme system for site installs, updates and when * the site is in off-line mode. This also applies when the database fails. * * @see _drupal_maintenance_theme() */function drupal_maintenance_theme() {  require_once './includes/theme.maintenance.inc';  _drupal_maintenance_theme();}/** * Return the name of the localisation function. Use in code that needs to * run both during installation and normal operation. */function get_t() {  static $t;  if (is_null($t)) {    $t = function_exists('install_main') ? 'st' : 't';  }  return $t;}/** *  Choose a language for the current page, based on site and user preferences. */function drupal_init_language() {  global $language, $user;  // Ensure the language is correctly returned, even without multilanguage support.  // Useful for eg. XML/HTML 'lang' attributes.  if (variable_get('language_count', 1) == 1) {    $language = language_default();  }  else {    include_once './includes/language.inc';    $language = language_initialize();  }}/** * Get a list of languages set up indexed by the specified key * * @param $field The field to index the list with. * @param $reset Boolean to request a reset of the list. */function language_list($field = 'language', $reset = FALSE) {  static $languages = NULL;  // Reset language list  if ($reset) {    $languages = NULL;  }  // Init language list  if (!isset($languages)) {    if (variable_get('language_count', 1) > 1 || module_exists('locale')) {      $result = db_query('SELECT * FROM {languages} ORDER BY weight ASC, name ASC');      while ($row = db_fetch_object($result)) {        $languages['language'][$row->language] = $row;      }    }    else {      // No locale module, so use the default language only.      $default = language_default();      $languages['language'][$default->language] = $default;    }  }  // Return the array indexed by the right field  if (!isset($languages[$field])) {    $languages[$field] = array();    foreach ($languages['language'] as $lang) {      // Some values should be collected into an array      if (in_array($field, array('enabled', 'weight'))) {        $languages[$field][$lang->$field][$lang->language] = $lang;      }      else {        $languages[$field][$lang->$field] = $lang;      }    }  }  return $languages[$field];}/** * Default language used on the site * * @param $property *   Optional property of the language object to return */function language_default($property = NULL) {  $language = variable_get('language_default', (object) array('language' => 'en', 'name' => 'English', 'native' => 'English', 'direction' => 0, 'enabled' => 1, 'plurals' => 0, 'formula' => '', 'domain' => '', 'prefix' => '', 'weight' => 0, 'javascript' => ''));  return $property ? $language->$property : $language;}/** * If Drupal is behind a reverse proxy, we use the X-Forwarded-For header * instead of $_SERVER['REMOTE_ADDR'], which would be the IP address * of the proxy server, and not the client's. * * @return *   IP address of client machine, adjusted for reverse proxy. */function ip_address() {  static $ip_address = NULL;  if (!isset($ip_address)) {    $ip_address = $_SERVER['REMOTE_ADDR'];    if (variable_get('reverse_proxy', 0) && array_key_exists('HTTP_X_FORWARDED_FOR', $_SERVER)) {      // If an array of known reverse proxy IPs is provided, then trust      // the XFF header if request really comes from one of them.      $reverse_proxy_addresses = variable_get('reverse_proxy_addresses', array());      if (!empty($reverse_proxy_addresses) && in_array($ip_address, $reverse_proxy_addresses, TRUE)) {        // If there are several arguments, we need to check the most        // recently added one, i.e. the last one.        $ip_address = array_pop(explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']));      }    }  }  return $ip_address;}
<?php// $Id$/** * @file * Page callbacks for adding, editing, deleting, and revisions management for content. *//** * Menu callback; presents the node editing form, or redirects to delete confirmation. */function node_page_edit($node) {  drupal_set_title(check_plain($node->title));  return drupal_get_form($node->type .'_node_form', $node);}function node_add_page() {  $item = menu_get_item();  $content = system_admin_menu_block($item);  return theme('node_add_list', $content);}/** * Display the list of available node types for node creation. * * @ingroup themeable */function theme_node_add_list($content) {  $output = '';  if ($content) {    $output = '<dl class="node-type-list">';    foreach ($content as $item) {      $output .= '<dt>'. l($item['title'], $item['href'], $item['localized_options']) .'</dt>';            $output .= '<dd>'. filter_xss_admin($item['description']) .'</dd>';    }    $output .= '</dl>';  }  return $output;}/** * Present a node submission form or a set of links to such forms. */function node_add($type) {  global $user;  $types = node_get_types();  $type = isset($type) ? str_replace('-', '_', $type) : NULL;  // If a node type has been specified, validate its existence.  if (isset($types[$type]) && node_access('create', $type)) {    // Initialize settings:    $node = array('uid' => $user->uid, 'name' => (isset($user->name) ? $user->name : ''), 'type' => $type, 'language' => '');    drupal_set_title(t('Create @name', array('@name' => $types[$type]->name)));    $output = drupal_get_form($type .'_node_form', $node);  }  return $output;}function node_form_validate($form, &$form_state) {  node_validate($form_state['values'], $form);}function node_object_prepare(&$node) {  // Set up default values, if required.  $node_options = variable_get('node_options_'. $node->type, array('status', 'promote'));  // If this is a new node, fill in the default values.  if (!isset($node->nid)) {    foreach (array('status', 'promote', 'sticky') as $key) {      $node->$key = in_array($key, $node_options);    }    global $user;    $node->uid = $user->uid;    $node->created = time();  }  else {    $node->date = format_date($node->created, 'custom', 'Y-m-d H:i:s O');    // Remove the log message from the original node object.    $node->log = NULL;  }  // Always use the default revision setting.  $node->revision = in_array('revision', $node_options);  node_invoke($node, 'prepare');  node_invoke_nodeapi($node, 'prepare');}/** * Generate the node add/edit form array. */function node_form(&$form_state, $node) {  global $user;  if (isset($form_state['node'])) {    $node = $form_state['node'] + (array)$node;  }  if (isset($form_state['node_preview'])) {    $form['#prefix'] = $form_state['node_preview'];  }  $node = (object)$node;  foreach (array('body', 'title', 'format') as $key) {    if (!isset($node->$key)) {      $node->$key = NULL;    }  }  if (!isset($form_state['node_preview'])) {    node_object_prepare($node);  }  else {    $node->build_mode = NODE_BUILD_PREVIEW;  }  // Set the id of the top-level form tag  $form['#id'] = 'node-form';  // Basic node information.  // These elements are just values so they are not even sent to the client.  foreach (array('nid', 'vid', 'uid', 'created', 'type', 'language') as $key) {    $form[$key] = array(      '#type' => 'value',      '#value' => isset($node->$key) ? $node->$key : NULL,    );  }  // Changed must be sent to the client, for later overwrite error checking.  $form['changed'] = array(    '#type' => 'hidden',    '#default_value' => isset($node->changed) ? $node->changed : NULL,  );  // Get the node-specific bits.  if ($extra = node_invoke($node, 'form', $form_state)) {    $form = array_merge_recursive($form, $extra);  }  if (!isset($form['title']['#weight'])) {    $form['title']['#weight'] = -5;  }  $form['#node'] = $node;  // Add a log field if the "Create new revision" option is checked, or if the  // current user has the ability to check that option.  if (!empty($node->revision) || user_access('administer nodes')) {    $form['revision_information'] = array(      '#type' => 'fieldset',      '#title' => t('Revision information'),      '#collapsible' => TRUE,      // Collapsed by default when "Create new revision" is unchecked      '#collapsed' => !$node->revision,      '#weight' => 20,    );    $form['revision_information']['revision'] = array(      '#access' => user_access('administer nodes'),      '#type' => 'checkbox',      '#title' => t('Create new revision'),      '#default_value' => $node->revision,    );    $form['revision_information']['log'] = array(      '#type' => 'textarea',      '#title' => t('Log message'),      '#default_value' => (isset($node->log) ? $node->log : ''),      '#rows' => 2,      '#description' => t('An explanation of the additions or updates being made to help other authors understand your motivations.'),    );  }  // Node author information for administrators  $form['author'] = array(    '#type' => 'fieldset',    '#access' => user_access('administer nodes'),    '#title' => t('Authoring information'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#weight' => 20,  );  $form['author']['name'] = array(    '#type' => 'textfield',    '#title' => t('Authored by'),    '#maxlength' => 60,    '#autocomplete_path' => 'user/autocomplete',    '#default_value' => $node->name ? $node->name : '',    '#weight' => -1,    '#description' => t('Leave blank for %anonymous.', array('%anonymous' => variable_get('anonymous', t('Anonymous')))),  );  $form['author']['date'] = array(    '#type' => 'textfield',    '#title' => t('Authored on'),    '#maxlength' => 25,    '#description' => t('Format: %time. Leave blank to use the time of form submission.', array('%time' => !empty($node->date) ? $node->date : format_date($node->created, 'custom', 'Y-m-d H:i:s O'))),  );  if (isset($node->date)) {    $form['author']['date']['#default_value'] = $node->date;  }  // Node options for administrators  $form['options'] = array(    '#type' => 'fieldset',    '#access' => user_access('administer nodes'),    '#title' => t('Publishing options'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#weight' => 25,  );  $form['options']['status'] = array(    '#type' => 'checkbox',    '#title' => t('Published'),    '#default_value' => $node->status,  );  $form['options']['promote'] = array(    '#type' => 'checkbox',    '#title' => t('Promoted to front page'),    '#default_value' => $node->promote,  );  $form['options']['sticky'] = array(    '#type' => 'checkbox',    '#title' => t('Sticky at top of lists'),    '#default_value' => $node->sticky,  );  // These values are used when the user has no administrator access.  foreach (array('uid', 'created') as $key) {    $form[$key] = array(      '#type' => 'value',      '#value' => $node->$key,    );  }  // Add the buttons.  $form['buttons'] = array();  $form['buttons']['submit'] = array(    '#type' => 'submit',    '#access' => !variable_get('node_preview', 0) || (!form_get_errors() && isset($form_state['node_preview'])),    '#value' => t('Save'),    '#weight' => 5,    '#submit' => array('node_form_submit'),  );  $form['buttons']['preview'] = array(    '#type' => 'submit',    '#value' => t('Preview'),    '#weight' => 10,    '#submit' => array('node_form_build_preview'),  );  if (!empty($node->nid) && node_access('delete', $node)) {    $form['buttons']['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete'),      '#weight' => 15,      '#submit' => array('node_form_delete_submit'),    );  }  $form['#validate'][] = 'node_form_validate';  $form['#theme'] = array($node->type .'_node_form', 'node_form');  return $form;}/** * Return a node body field, with format and teaser. */function node_body_field(&$node, $label, $word_count) {  // Check if we need to restore the teaser at the beginning of the body.  $include = !isset($node->teaser) || ($node->teaser == substr($node->body, 0, strlen($node->teaser)));  $form = array(    '#after_build' => array('node_teaser_js', 'node_teaser_include_verify'));  $form['#prefix'] = '<div class="body-field-wrapper">';  $form['#suffix'] = '</div>';  $form['teaser_js'] = array(    '#type' => 'textarea',    '#rows' => 10,    '#teaser' => 'edit-body',    '#teaser_checkbox' => 'edit-teaser-include',    '#disabled' => TRUE,  );  $form['teaser_include'] = array(    '#type' => 'checkbox',    '#title' => t('Show summary in full view'),    '#default_value' => $include,    '#prefix' => '<div class="teaser-checkbox">',    '#suffix' => '</div>',  );  $form['body'] = array(    '#type' => 'textarea',    '#title' => check_plain($label),    '#default_value' => $include ? $node->body : ($node->teaser . $node->body),    '#rows' => 20,    '#required' => ($word_count > 0),  );  $form['format'] = filter_form($node->format);  return $form;}/** * Button sumit function: handle the 'Delete' button on the node form. */function node_form_delete_submit($form, &$form_state) {  $destination = '';  if (isset($_REQUEST['destination'])) {    $destination = drupal_get_destination();    unset($_REQUEST['destination']);  }  $node = $form['#node'];  $form_state['redirect'] = array('node/'. $node->nid .'/delete', $destination);}function node_form_build_preview($form, &$form_state) {  $node = node_form_submit_build_node($form, $form_state);  $form_state['node_preview'] = node_preview($node);}/** * Present a node submission form. * * @ingroup themeable */function theme_node_form($form) {  $output = "\n<div class=\"node-form\">\n";  // Admin form fields and submit buttons must be rendered first, because  // they need to go to the bottom of the form, and so should not be part of  // the catch-all call to drupal_render().  $admin = '';  if (isset($form['author'])) {    $admin .= "    <div class=\"authored\">\n";    $admin .= drupal_render($form['author']);    $admin .= "    </div>\n";  }  if (isset($form['options'])) {    $admin .= "    <div class=\"options\">\n";    $admin .= drupal_render($form['options']);    $admin .= "    </div>\n";  }  $buttons = drupal_render($form['buttons']);  // Everything else gets rendered here, and is displayed before the admin form  // field and the submit buttons.  $output .= "  <div class=\"standard\">\n";  $output .= drupal_render($form);  $output .= "  </div>\n";  if (!empty($admin)) {    $output .= "  <div class=\"admin\">\n";    $output .= $admin;    $output .= "  </div>\n";  }  $output .= $buttons;  $output .= "</div>\n";  return $output;}/** * Generate a node preview. */function node_preview($node) {  if (node_access('create', $node) || node_access('update', $node)) {    // Load the user's name when needed.    if (isset($node->name)) {      // The use of isset() is mandatory in the context of user IDs, because      // user ID 0 denotes the anonymous user.      if ($user = user_load(array('name' => $node->name))) {        $node->uid = $user->uid;        $node->picture = $user->picture;      }      else {        $node->uid = 0; // anonymous user      }    }    else if ($node->uid) {      $user = user_load(array('uid' => $node->uid));      $node->name = $user->name;      $node->picture = $user->picture;    }    $node->changed = time();    // Extract a teaser, if it hasn't been set (e.g. by a module-provided    // 'teaser' form item).    if (!isset($node->teaser)) {      $node->teaser = empty($node->body) ? '' : node_teaser($node->body, $node->format);      // Chop off the teaser from the body if needed.      if (!$node->teaser_include && $node->teaser == substr($node->body, 0, strlen($node->teaser))) {        $node->body = substr($node->body, strlen($node->teaser));      }    }    // Display a preview of the node.    // Previewing alters $node so it needs to be cloned.    if (!form_get_errors()) {      $cloned_node = drupal_clone($node);      $cloned_node->build_mode = NODE_BUILD_PREVIEW;      $output = theme('node_preview', $cloned_node);    }    drupal_set_title(t('Preview'));    return $output;  }}/** * Display a node preview for display during node creation and editing. * * @param $node *   The node object which is being previewed. * * @ingroup themeable */function theme_node_preview($node) {  $output = '<div class="preview">';  $preview_trimmed_version = FALSE;  // Do we need to preview trimmed version of post as well as full version?  if (isset($node->teaser) && isset($node->body)) {    $teaser = trim($node->teaser);    $body = trim(str_replace('<!--break-->', '', $node->body));    // Preview trimmed version if teaser and body will appear different;    // also (edge case) if both teaser and body have been specified by the user    // and are actually the same.    if ($teaser != $body || ($body && strpos($node->body, '<!--break-->') === 0)) {      $preview_trimmed_version = TRUE;    }  }  if ($preview_trimmed_version) {    drupal_set_message(t('The trimmed version of your post shows what your post looks like when promoted to the main page or when exported for syndication.<span class="no-js"> You can insert the delimiter "&lt;!--break--&gt;" (without the quotes) to fine-tune where your post gets split.</span>'));    $output .= '<h3>'. t('Preview trimmed version') .'</h3>';    $output .= node_view(drupal_clone($node), 1, FALSE, 0);    $output .= '<h3>'. t('Preview full version') .'</h3>';    $output .= node_view($node, 0, FALSE, 0);  }  else {    $output .= node_view($node, 0, FALSE, 0);  }  $output .= "</div>\n";  return $output;}function node_form_submit($form, &$form_state) {  global $user;  $node = node_form_submit_build_node($form, $form_state);  $insert = empty($node->nid);  node_save($node);  $node_link = l(t('view'), 'node/'. $node->nid);  $watchdog_args = array('@type' => $node->type, '%title' => $node->title);  $t_args = array('@type' => node_get_types('name', $node), '%title' => $node->title);  if ($insert) {    watchdog('content', '@type: added %title.', $watchdog_args, WATCHDOG_NOTICE, $node_link);    drupal_set_message(t('@type %title has been created.', $t_args));  }  else {    watchdog('content', '@type: updated %title.', $watchdog_args, WATCHDOG_NOTICE, $node_link);    drupal_set_message(t('@type %title has been updated.', $t_args));  }  if ($node->nid) {    unset($form_state['rebuild']);    $form_state['nid'] = $node->nid;    $form_state['redirect'] = 'node/'. $node->nid;  }  else {    // In the unlikely case something went wrong on save, the node will be    // rebuilt and node form redisplayed the same way as in preview.    drupal_set_message(t('The post could not be saved.'), 'error');  }}/** * Build a node by processing submitted form values and prepare for a form rebuild. */function node_form_submit_build_node($form, &$form_state) {  // Unset any button-level handlers, execute all the form-level submit  // functions to process the form values into an updated node.  unset($form_state['submit_handlers']);  form_execute_handlers('submit', $form, $form_state);  $node = node_submit($form_state['values']);  $form_state['node'] = (array)$node;  $form_state['rebuild'] = TRUE;  return $node;}/** * Menu callback -- ask for confirmation of node deletion */function node_delete_confirm(&$form_state, $node) {  $form['nid'] = array(    '#type' => 'value',    '#value' => $node->nid,  );  return confirm_form($form,    t('Are you sure you want to delete %title?', array('%title' => $node->title)),    isset($_GET['destination']) ? $_GET['destination'] : 'node/'. $node->nid,    t('This action cannot be undone.'),    t('Delete'),    t('Cancel')  );}/** * Execute node deletion */function node_delete_confirm_submit($form, &$form_state) {  if ($form_state['values']['confirm']) {    node_delete($form_state['values']['nid']);  }  $form_state['redirect'] = '<front>';}/** * Generate an overview table of older revisions of a node. */function node_revision_overview($node) {  drupal_set_title(t('Revisions for %title', array('%title' => $node->title)));  $header = array(t('Revision'), array('data' => t('Operations'), 'colspan' => 2));  $revisions = node_revision_list($node);  $rows = array();  $revert_permission = FALSE;  if ((user_access('revert revisions') || user_access('administer nodes')) && node_access('update', $node)) {    $revert_permission = TRUE;  }  $delete_permission = FALSE;  if ((user_access('delete revisions') || user_access('administer nodes')) && node_access('delete', $node)) {    $delete_permission = TRUE;  }  foreach ($revisions as $revision) {    $row = array();    $operations = array();    if ($revision->current_vid > 0) {      $row[] = array('data' => t('!date by !username', array('!date' => l(format_date($revision->timestamp, 'small'), "node/$node->nid"), '!username' => theme('username', $revision)))                               . (($revision->log != '') ? '<p class="revision-log">'. filter_xss($revision->log) .'</p>' : ''),                     'class' => 'revision-current');      $operations[] = array('data' => theme('placeholder', t('current revision')), 'class' => 'revision-current', 'colspan' => 2);    }    else {      $row[] = t('!date by !username', array('!date' => l(format_date($revision->timestamp, 'small'), "node/$node->nid/revisions/$revision->vid/view"), '!username' => theme('username', $revision)))               . (($revision->log != '') ? '<p class="revision-log">'. filter_xss($revision->log) .'</p>' : '');      if ($revert_permission) {        $operations[] = l(t('revert'), "node/$node->nid/revisions/$revision->vid/revert");      }      if ($delete_permission) {        $operations[] = l(t('delete'), "node/$node->nid/revisions/$revision->vid/delete");      }    }    $rows[] = array_merge($row, $operations);  }  return theme('table', $header, $rows);}/** * Ask for confirmation of the reversion to prevent against CSRF attacks. */function node_revision_revert_confirm($form_state, $node_revision) {  $form['#node_revision'] = $node_revision;  return confirm_form($form, t('Are you sure you want to revert to the revision from %revision-date?', array('%revision-date' => format_date($node_revision->revision_timestamp))), 'node/'. $node_revision->nid .'/revisions', '', t('Revert'), t('Cancel'));}function node_revision_revert_confirm_submit($form, &$form_state) {  $node_revision = $form['#node_revision'];  $node_revision->revision = 1;  $node_revision->log = t('Copy of the revision from %date.', array('%date' => format_date($node_revision->revision_timestamp)));  if (module_exists('taxonomy')) {    $node_revision->taxonomy = array_keys($node_revision->taxonomy);  }  node_save($node_revision);  watchdog('content', '@type: reverted %title revision %revision.', array('@type' => $node_revision->type, '%title' => $node_revision->title, '%revision' => $node_revision->vid));  drupal_set_message(t('@type %title has been reverted back to the revision from %revision-date.', array('@type' => node_get_types('name', $node_revision), '%title' => $node_revision->title, '%revision-date' => format_date($node_revision->revision_timestamp))));  $form_state['redirect'] = 'node/'. $node_revision->nid .'/revisions';}function node_revision_delete_confirm($form_state, $node_revision) {  $form['#node_revision'] = $node_revision;  return confirm_form($form, t('Are you sure you want to delete the revision from %revision-date?', array('%revision-date' => format_date($node_revision->revision_timestamp))), 'node/'. $node_revision->nid .'/revisions', t('This action cannot be undone.'), t('Delete'), t('Cancel'));}function node_revision_delete_confirm_submit($form, &$form_state) {  $node_revision = $form['#node_revision'];  db_query("DELETE FROM {node_revisions} WHERE nid = %d AND vid = %d", $node_revision->nid, $node_revision->vid);  node_invoke_nodeapi($node_revision, 'delete revision');  watchdog('content', '@type: deleted %title revision %revision.', array('@type' => $node_revision->type, '%title' => $node_revision->title, '%revision' => $node_revision->vid));  drupal_set_message(t('Revision from %revision-date of @type %title has been deleted.', array('%revision-date' => format_date($node_revision->revision_timestamp), '@type' => node_get_types('name', $node_revision), '%title' => $node_revision->title)));  $form_state['redirect'] = 'node/'. $node_revision->nid;  if (db_result(db_query('SELECT COUNT(vid) FROM {node_revisions} WHERE nid = %d', $node_revision->nid)) > 1) {    $form_state['redirect'] .= '/revisions';  }}
<?php// $Id$/** * @file aggregator-summary-items.tpl.php * Default theme implementation to present feeds as list items. * * Each iteration generates a single feed source or category. * * Available variables: * - $title: Title of the feed or category. * - $summary_list: Unordered list of linked feed items generated through *   theme_item_list(). * - $source_url: URL to the local source or category. * * @see template_preprocess() * @see template_preprocess_aggregator_summary-items() */?><h2><?php print $title; ?></h2><?php print $summary_list; ?><div class="links">  <a href="<?php print $source_url; ?>"><?php print t('More'); ?></a></div>
<?php// $Id$/** * @file * Support for configurable user profiles. *//** * Private field, content only available to privileged users. */define('PROFILE_PRIVATE', 1);/** * Public field, content shown on profile page but not used on member list pages. */define('PROFILE_PUBLIC', 2);/** * Public field, content shown on profile page and on member list pages. */define('PROFILE_PUBLIC_LISTINGS', 3);/** * Hidden profile field, only accessible by administrators, modules and themes. */define('PROFILE_HIDDEN', 4);/** * Implementation of hook_help(). */function profile_help($path, $arg) {  switch ($path) {    case 'admin/help#profile':      $output = '<p>'. t('The profile module allows custom fields (such as country, full name, or age) to be defined and displayed in the <em>My Account</em> section. This permits users of a site to share more information about themselves, and can help community-based sites organize users around specific information.') .'</p>';      $output .= '<p>'. t('The following types of fields can be added to a user profile:') .'</p>';      $output .= '<ul><li>'. t('single-line textfield') .'</li>';      $output .= '<li>'. t('multi-line textfield') .'</li>';      $output .= '<li>'. t('checkbox') .'</li>';      $output .= '<li>'. t('list selection') .'</li>';      $output .= '<li>'. t('freeform list') .'</li>';      $output .= '<li>'. t('URL') .'</li>';      $output .= '<li>'. t('date') .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@profile">Profile module</a>.', array('@profile' => 'http://drupal.org/handbook/modules/profile/')) .'</p>';      return $output;    case 'admin/user/profile':      return '<p>'. t("This page displays a list of the existing custom profile fields to be displayed on a user's <em>My Account</em> page. To provide structure, similar or related fields may be placed inside a category. To add a new category (or edit an existing one), edit a profile field and provide a new category name. To change the category of a field or the order of fields within a category, grab a drag-and-drop handle under the Title column and drag the field to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save configuration</em> button at the bottom of the page.") .'</p>';  }}/** * Implementation of hook_theme() */function profile_theme() {  return array(    'profile_block' => array(      'arguments' => array('account' => NULL, 'fields' => array()),      'template' => 'profile-block',    ),    'profile_listing' => array(      'arguments' => array('account' => NULL, 'fields' => array()),      'template' => 'profile-listing',    ),    'profile_wrapper' => array(      'arguments' => array('content' => NULL),      'template' => 'profile-wrapper',    ),    'profile_admin_overview' => array(      'arguments' => array('form' => NULL),      'file' => 'profile.admin.inc',    )  );}/** * Implementation of hook_menu(). */function profile_menu() {  $items['profile'] = array(    'title' => 'User list',    'page callback' => 'profile_browse',    'access arguments' => array('access user profiles'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'profile.pages.inc',  );  $items['admin/user/profile'] = array(    'title' => 'Profiles',    'description' => 'Create customizable fields for your users.',    'page callback' => 'drupal_get_form',    'page arguments' => array('profile_admin_overview'),    'access arguments' => array('administer users'),    'file' => 'profile.admin.inc',  );  $items['admin/user/profile/add'] = array(    'title' => 'Add field',    'page callback' => 'drupal_get_form',    'page arguments' => array('profile_field_form'),    'access arguments' => array('administer users'),    'type' => MENU_CALLBACK,    'file' => 'profile.admin.inc',  );  $items['admin/user/profile/autocomplete'] = array(    'title' => 'Profile category autocomplete',    'page callback' => 'profile_admin_settings_autocomplete',    'access arguments' => array('administer users'),    'type' => MENU_CALLBACK,    'file' => 'profile.admin.inc',  );  $items['admin/user/profile/edit'] = array(    'title' => 'Edit field',    'page callback' => 'drupal_get_form',    'page arguments' => array('profile_field_form'),    'access arguments' => array('administer users'),    'type' => MENU_CALLBACK,    'file' => 'profile.admin.inc',  );  $items['admin/user/profile/delete'] = array(    'title' => 'Delete field',    'page callback' => 'drupal_get_form',    'page arguments' => array('profile_field_delete'),    'access arguments' => array('administer users'),    'type' => MENU_CALLBACK,    'file' => 'profile.admin.inc',  );  $items['profile/autocomplete'] = array(    'title' => 'Profile autocomplete',    'page callback' => 'profile_autocomplete',    'access arguments' => array('access user profiles'),    'type' => MENU_CALLBACK,    'file' => 'profile.pages.inc',  );  return $items;}/** * Implementation of hook_block(). */function profile_block($op = 'list', $delta = 0, $edit = array()) {  if ($op == 'list') {    $blocks[0]['info'] = t('Author information');    $blocks[0]['cache'] = BLOCK_CACHE_PER_PAGE | BLOCK_CACHE_PER_ROLE;    return $blocks;  }  else if ($op == 'configure' && $delta == 0) {    // Compile a list of fields to show    $fields = array();    $result = db_query('SELECT name, title, weight, visibility FROM {profile_fields} WHERE visibility IN (%d, %d) ORDER BY weight', PROFILE_PUBLIC, PROFILE_PUBLIC_LISTINGS);    while ($record = db_fetch_object($result)) {      $fields[$record->name] = check_plain($record->title);    }    $fields['user_profile'] = t('Link to full user profile');    $form['profile_block_author_fields'] = array('#type' => 'checkboxes',      '#title' => t('Profile fields to display'),      '#default_value' => variable_get('profile_block_author_fields', array()),      '#options' => $fields,      '#description' => t('Select which profile fields you wish to display in the block. Only fields designated as public in the <a href="@profile-admin">profile field configuration</a> are available.', array('@profile-admin' => url('admin/user/profile'))),    );    return $form;  }  else if ($op == 'save' && $delta == 0) {    variable_set('profile_block_author_fields', $edit['profile_block_author_fields']);  }  else if ($op == 'view') {    if (user_access('access user profiles')) {      $output = '';      if ((arg(0) == 'node') && is_numeric(arg(1)) && (arg(2) == NULL)) {        $node = node_load(arg(1));        $account = user_load(array('uid' => $node->uid));        if ($use_fields = variable_get('profile_block_author_fields', array())) {          // Compile a list of fields to show.          $fields = array();          $result = db_query('SELECT name, title, type, visibility, weight FROM {profile_fields} WHERE visibility IN (%d, %d) ORDER BY weight', PROFILE_PUBLIC, PROFILE_PUBLIC_LISTINGS);          while ($record = db_fetch_object($result)) {            // Ensure that field is displayed only if it is among the defined block fields and, if it is private, the user has appropriate permissions.            if (isset($use_fields[$record->name]) && $use_fields[$record->name]) {              $fields[] = $record;            }          }        }        if (!empty($fields)) {          $profile = _profile_update_user_fields($fields, $account);          $output .= theme('profile_block', $account, $profile, TRUE);        }        if (isset($use_fields['user_profile']) && $use_fields['user_profile']) {          $output .= '<div>'. l(t('View full user profile'), 'user/'. $account->uid) .'</div>';        }      }      if ($output) {        $block['subject'] = t('About %name', array('%name' => $account->name));        $block['content'] = $output;        return $block;      }    }  }}/** * Implementation of hook_user(). */function profile_user($type, &$edit, &$user, $category = NULL) {  switch ($type) {    case 'load':      return profile_load_profile($user);    case 'register':      return profile_form_profile($edit, $user, $category, TRUE);    case 'update':    return profile_save_profile($edit, $user, $category);    case 'insert':      return profile_save_profile($edit, $user, $category, TRUE);    case 'view':      return profile_view_profile($user);    case 'form':      return profile_form_profile($edit, $user, $category);    case 'validate':      return profile_validate_profile($edit, $category);    case 'categories':      return profile_categories();    case 'delete':      db_query('DELETE FROM {profile_values} WHERE uid = %d', $user->uid);  }}function profile_load_profile(&$user) {  $result = db_query('SELECT f.name, f.type, v.value FROM {profile_fields} f INNER JOIN {profile_values} v ON f.fid = v.fid WHERE uid = %d', $user->uid);  while ($field = db_fetch_object($result)) {    if (empty($user->{$field->name})) {      $user->{$field->name} = _profile_field_serialize($field->type) ? unserialize($field->value) : $field->value;    }  }}function profile_save_profile(&$edit, &$user, $category, $register = FALSE) {  $result = _profile_get_fields($category, $register);  while ($field = db_fetch_object($result)) {    if (_profile_field_serialize($field->type)) {      $edit[$field->name] = serialize($edit[$field->name]);    }    db_query("DELETE FROM {profile_values} WHERE fid = %d AND uid = %d", $field->fid, $user->uid);    db_query("INSERT INTO {profile_values} (fid, uid, value) VALUES (%d, %d, '%s')", $field->fid, $user->uid, $edit[$field->name]);    // Mark field as handled (prevents saving to user->data).    $edit[$field->name] = NULL;  }}function profile_view_field($user, $field) {  // Only allow browsing of private fields for admins, if browsing is enabled,  // and if a user has permission to view profiles. Note that this check is  // necessary because a user may always see their own profile.  $browse = user_access('access user profiles')         && (user_access('administer users') || $field->visibility != PROFILE_PRIVATE)         && !empty($field->page);  if (isset($user->{$field->name}) && $value = $user->{$field->name}) {    switch ($field->type) {      case 'textarea':        return check_markup($value);      case 'textfield':      case 'selection':        return $browse ? l($value, 'profile/'. $field->name .'/'. $value) : check_plain($value);      case 'checkbox':        return $browse ? l($field->title, 'profile/'. $field->name) : check_plain($field->title);      case 'url':        return '<a href="'. check_url($value) .'">'. check_plain($value) .'</a>';      case 'date':        $format = substr(variable_get('date_format_short', 'm/d/Y - H:i'), 0, 5);        // Note: Avoid PHP's date() because it does not handle dates before        // 1970 on Windows. This would make the date field useless for e.g.        // birthdays.        $replace = array(          'd' => sprintf('%02d', $value['day']),          'j' => $value['day'],          'm' => sprintf('%02d', $value['month']),          'M' => map_month($value['month']),          'Y' => $value['year'],          'H:i' => NULL,          'g:ia' => NULL,        );        return strtr($format, $replace);      case 'list':        $values = split("[,\n\r]", $value);        $fields = array();        foreach ($values as $value) {          if ($value = trim($value)) {            $fields[] = $browse ? l($value, 'profile/'. $field->name .'/'. $value) : check_plain($value);          }        }        return implode(', ', $fields);    }  }}function profile_view_profile(&$user) {  profile_load_profile($user);  // Show private fields to administrators and people viewing their own account.  if (user_access('administer users') || $GLOBALS['user']->uid == $user->uid) {    $result = db_query('SELECT * FROM {profile_fields} WHERE visibility != %d ORDER BY category, weight', PROFILE_HIDDEN);  }  else {    $result = db_query('SELECT * FROM {profile_fields} WHERE visibility != %d AND visibility != %d ORDER BY category, weight', PROFILE_PRIVATE, PROFILE_HIDDEN);  }  $fields = array();  while ($field = db_fetch_object($result)) {    if ($value = profile_view_field($user, $field)) {      $title = ($field->type != 'checkbox') ? check_plain($field->title) : NULL;      // Create a single fieldset for each category.      if (!isset($user->content[$field->category])) {        $user->content[$field->category] = array(          '#type' => 'user_profile_category',          '#title' => $field->category,        );      }      $user->content[$field->category][$field->name] = array(        '#type' => 'user_profile_item',        '#title' => $title,        '#value' => $value,        '#weight' => $field->weight,        '#attributes' => array('class' => 'profile-'. $field->name),      );    }  }}function _profile_form_explanation($field) {  $output = $field->explanation;  if ($field->type == 'list') {    $output .= ' '. t('Put each item on a separate line or separate them by commas. No HTML allowed.');  }  if ($field->visibility == PROFILE_PRIVATE) {    $output .= ' '. t('The content of this field is kept private and will not be shown publicly.');  }  return $output;}function profile_form_profile($edit, $user, $category, $register = FALSE) {  $result = _profile_get_fields($category, $register);  $weight = 1;  $fields = array();  while ($field = db_fetch_object($result)) {    $category = $field->category;    if (!isset($fields[$category])) {      $fields[$category] = array('#type' => 'fieldset', '#title' => check_plain($category), '#weight' => $weight++);    }    switch ($field->type) {      case 'textfield':      case 'url':        $fields[$category][$field->name] = array('#type' => 'textfield',          '#title' => check_plain($field->title),          '#default_value' => isset($edit[$field->name]) ? $edit[$field->name] : '',          '#maxlength' => 255,          '#description' => _profile_form_explanation($field),          '#required' => $field->required,        );        if ($field->autocomplete) {          $fields[$category][$field->name]['#autocomplete_path'] = "profile/autocomplete/". $field->fid;        }        break;      case 'textarea':        $fields[$category][$field->name] = array('#type' => 'textarea',          '#title' => check_plain($field->title),          '#default_value' => isset($edit[$field->name]) ? $edit[$field->name] : '',          '#description' => _profile_form_explanation($field),          '#required' => $field->required,        );        break;      case 'list':        $fields[$category][$field->name] = array('#type' => 'textarea',          '#title' => check_plain($field->title),          '#default_value' => isset($edit[$field->name]) ? $edit[$field->name] : '',          '#description' => _profile_form_explanation($field),          '#required' => $field->required,        );        break;      case 'checkbox':        $fields[$category][$field->name] = array('#type' => 'checkbox',          '#title' => check_plain($field->title),          '#default_value' => isset($edit[$field->name]) ? $edit[$field->name] : '',          '#description' => _profile_form_explanation($field),          '#required' => $field->required,        );        break;      case 'selection':        $options = $field->required ? array() : array('--');        $lines = split("[\n\r]", $field->options);        foreach ($lines as $line) {          if ($line = trim($line)) {            $options[$line] = $line;          }        }        $fields[$category][$field->name] = array('#type' => 'select',          '#title' => check_plain($field->title),          '#default_value' => isset($edit[$field->name]) ? $edit[$field->name] : '',          '#options' => $options,          '#description' => _profile_form_explanation($field),          '#required' => $field->required,        );        break;      case 'date':        $fields[$category][$field->name] = array('#type' => 'date',          '#title' => check_plain($field->title),          '#default_value' => isset($edit[$field->name]) ? $edit[$field->name] : '',          '#description' => _profile_form_explanation($field),          '#required' => $field->required,        );        break;    }  }  return $fields;}/** * Helper function: update an array of user fields by calling profile_view_field */function _profile_update_user_fields($fields, $account) {  foreach ($fields as $key => $field) {    $fields[$key]->value = profile_view_field($account, $field);  }  return $fields;}function profile_validate_profile($edit, $category) {  $result = _profile_get_fields($category);  while ($field = db_fetch_object($result)) {    if ($edit[$field->name]) {      if ($field->type == 'url') {        if (!valid_url($edit[$field->name], TRUE)) {          form_set_error($field->name, t('The value provided for %field is not a valid URL.', array('%field' => $field->title)));        }      }    }    else if ($field->required && !user_access('administer users')) {      form_set_error($field->name, t('The field %field is required.', array('%field' => $field->title)));    }  }  return $edit;}function profile_categories() {  $result = db_query("SELECT DISTINCT(category) FROM {profile_fields}");  $data = array();  while ($category = db_fetch_object($result)) {    $data[] = array(      'name' => $category->category,      'title' => $category->category,      'weight' => 3,      'access callback' => 'profile_category_access',      'access arguments' => array(1, $category->category)    );  }  return $data;}/** * Menu item access callback - check if a user has access to a profile category. */function profile_category_access($account, $category) {  if (user_access('administer users') && $account->uid > 0) {    return TRUE;  }  else {    return user_edit_access($account) && db_result(db_query("SELECT COUNT(*) FROM {profile_fields} WHERE category = '%s' AND visibility <> %d", $category, PROFILE_HIDDEN));  }}/** * Process variables for profile-block.tpl.php. * * The $variables array contains the following arguments: * - $account * - $fields * * @see profile-block.tpl.php */function template_preprocess_profile_block(&$variables) {  $variables['picture'] = theme('user_picture', $variables['account']);  $variables['profile'] = array();  // Supply filtered version of $fields that have values.  foreach ($variables['fields'] as $field) {    if ($field->value) {      $variables['profile'][$field->name]->title = check_plain($field->title);      $variables['profile'][$field->name]->value = $field->value;      $variables['profile'][$field->name]->type = $field->type;    }  }}/** * Process variables for profile-listing.tpl.php. * * The $variables array contains the following arguments: * - $account * - $fields * * @see profile-listing.tpl.php */function template_preprocess_profile_listing(&$variables) {  $variables['picture'] = theme('user_picture', $variables['account']);  $variables['name'] = theme('username', $variables['account']);  $variables['profile'] = array();  // Supply filtered version of $fields that have values.  foreach ($variables['fields'] as $field) {    if ($field->value) {      $variables['profile'][$field->name]->title = $field->title;      $variables['profile'][$field->name]->value = $field->value;      $variables['profile'][$field->name]->type = $field->type;    }  }}/** * Process variables for profile-wrapper.tpl.php. * * The $variables array contains the following arguments: * - $content * * @see profile-wrapper.tpl.php */function template_preprocess_profile_wrapper(&$variables) {  $variables['current_field'] = '';  if ($field = arg(1)) {    $variables['current_field'] = $field;    // Supply an alternate template suggestion based on the browsable field.    $variables['template_files'][] = 'profile-wrapper-'. $field;  }}function _profile_field_types($type = NULL) {  $types = array('textfield' => t('single-line textfield'),                 'textarea' => t('multi-line textfield'),                 'checkbox' => t('checkbox'),                 'selection' => t('list selection'),                 'list' => t('freeform list'),                 'url' => t('URL'),                 'date' => t('date'));  return isset($type) ? $types[$type] : $types;}function _profile_field_serialize($type = NULL) {  return $type == 'date';}function _profile_get_fields($category, $register = FALSE) {  $args = array();  $sql = 'SELECT * FROM {profile_fields} WHERE ';  $filters = array();  if ($register) {    $filters[] = 'register = 1';  }  else {    // Use LOWER('%s') instead of PHP's strtolower() to avoid UTF-8 conversion issues.    $filters[] = "LOWER(category) = LOWER('%s')";    $args[] = $category;  }  if (!user_access('administer users')) {    $filters[] = 'visibility != %d';    $args[] = PROFILE_HIDDEN;  }  $sql .= implode(' AND ', $filters);  $sql .= ' ORDER BY category, weight';  return db_query($sql, $args);}
<?php// $Id$?><div id="node-<?php print $node->nid; ?>" class="node<?php if ($sticky) { print ' sticky'; } ?><?php if (!$status) { print ' node-unpublished'; } ?>"><?php print $picture ?><?php if ($page == 0): ?>  <h2><a href="<?php print $node_url ?>" title="<?php print $title ?>"><?php print $title ?></a></h2><?php endif; ?>  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted; ?></span>  <?php endif; ?>  <div class="content clear-block">    <?php print $content ?>  </div>  <div class="clear-block">    <div class="meta">    <?php if ($taxonomy): ?>      <div class="terms"><?php print $terms ?></div>    <?php endif;?>    </div>    <?php if ($links): ?>      <div class="links"><?php print $links; ?></div>    <?php endif; ?>  </div></div>
<?php// $Id$/** * @file * User session handling functions. */function sess_open($save_path, $session_name) {  return TRUE;}function sess_close() {  return TRUE;}function sess_read($key) {  global $user;  // Write and Close handlers are called after destructing objects since PHP 5.0.5  // Thus destructors can use sessions but session handler can't use objects.  // So we are moving session closure before destructing objects.  register_shutdown_function('session_write_close');  // Handle the case of first time visitors and clients that don't store cookies (eg. web crawlers).  if (!isset($_COOKIE[session_name()])) {    $user = drupal_anonymous_user();    return '';  }  // Otherwise, if the session is still active, we have a record of the client's session in the database.  $user = db_fetch_object(db_query("SELECT u.*, s.* FROM {users} u INNER JOIN {sessions} s ON u.uid = s.uid WHERE s.sid = '%s'", $key));  // We found the client's session record and they are an authenticated,  // active user.  if ($user && $user->uid > 0 && $user->status == 1) {    // This is done to unserialize the data member of $user    $user = drupal_unpack($user);    // Add roles element to $user    $user->roles = array();    $user->roles[DRUPAL_AUTHENTICATED_RID] = 'authenticated user';    $result = db_query("SELECT r.rid, r.name FROM {role} r INNER JOIN {users_roles} ur ON ur.rid = r.rid WHERE ur.uid = %d", $user->uid);    while ($role = db_fetch_object($result)) {      $user->roles[$role->rid] = $role->name;    }  }  // We didn't find the client's record (session has expired), or they are  // blocked, or they are an anonymous user.  else {    $session = isset($user->session) ? $user->session : '';    $user = drupal_anonymous_user($session);  }  return $user->session;}function sess_write($key, $value) {  global $user;  // If saving of session data is disabled or if the client doesn't have a session,  // and one isn't being created ($value), do nothing. This keeps crawlers out of  // the session table. This reduces memory and server load, and gives more useful  // statistics. We can't eliminate anonymous session table rows without breaking  // the throttle module and the "Who's Online" block.  if (!session_save_session() || ($user->uid == 0 && empty($_COOKIE[session_name()]) && empty($value))) {    return TRUE;  }  db_query("UPDATE {sessions} SET uid = %d, cache = %d, hostname = '%s', session = '%s', timestamp = %d WHERE sid = '%s'", $user->uid, isset($user->cache) ? $user->cache : '', ip_address(), $value, time(), $key);  if (db_affected_rows()) {    // Last access time is updated no more frequently than once every 180 seconds.    // This reduces contention in the users table.    if ($user->uid && time() - $user->access > variable_get('session_write_interval', 180)) {      db_query("UPDATE {users} SET access = %d WHERE uid = %d", time(), $user->uid);    }  }  else {    // If this query fails, another parallel request probably got here first.    // In that case, any session data generated in this request is discarded.    @db_query("INSERT INTO {sessions} (sid, uid, cache, hostname, session, timestamp) VALUES ('%s', %d, %d, '%s', '%s', %d)", $key, $user->uid, isset($user->cache) ? $user->cache : '', ip_address(), $value, time());  }  return TRUE;}/** * Called when an anonymous user becomes authenticated or vice-versa. */function sess_regenerate() {  $old_session_id = session_id();  // We code around http://bugs.php.net/bug.php?id=32802 by destroying  // the session cookie by setting expiration in the past (a negative  // value).  This issue only arises in PHP versions before 4.4.0,  // regardless of the Drupal configuration.  // TODO: remove this when we require at least PHP 4.4.0  if (isset($_COOKIE[session_name()])) {    setcookie(session_name(), '', time() - 42000, '/');  }  session_regenerate_id();  db_query("UPDATE {sessions} SET sid = '%s' WHERE sid = '%s'", session_id(), $old_session_id);}/** * Counts how many users have sessions. Can count either anonymous sessions or authenticated sessions. * * @param int $timestamp *   A Unix timestamp representing a point of time in the past. *   The default is 0, which counts all existing sessions. * @param boolean $anonymous *   TRUE counts only anonymous users. *   FALSE counts only authenticated users. * @return  int *   The number of users with sessions. */function sess_count($timestamp = 0, $anonymous = true) {  $query = $anonymous ? ' AND uid = 0' : ' AND uid > 0';  return db_result(db_query('SELECT COUNT(sid) AS count FROM {sessions} WHERE timestamp >= %d'. $query, $timestamp));}/** * Called by PHP session handling with the PHP session ID to end a user's session. * * @param  string $sid *   the session id */function sess_destroy_sid($sid) {  db_query("DELETE FROM {sessions} WHERE sid = '%s'", $sid);}/** * End a specific user's session * * @param  string $uid *   the user id */function sess_destroy_uid($uid) {  db_query('DELETE FROM {sessions} WHERE uid = %d', $uid);}function sess_gc($lifetime) {  // Be sure to adjust 'php_value session.gc_maxlifetime' to a large enough  // value. For example, if you want user sessions to stay in your database  // for three weeks before deleting them, you need to set gc_maxlifetime  // to '1814400'. At that value, only after a user doesn't log in after  // three weeks (1814400 seconds) will his/her session be removed.  db_query("DELETE FROM {sessions} WHERE timestamp < %d", time() - $lifetime);  return TRUE;}/** * Determine whether to save session data of the current request. * * This function allows the caller to temporarily disable writing of session data, * should the request end while performing potentially dangerous operations, such as * manipulating the global $user object.  See http://drupal.org/node/218104 for usage * * @param $status *   Disables writing of session data when FALSE, (re-)enables writing when TRUE. * @return *   FALSE if writing session data has been disabled. Otherwise, TRUE. */function session_save_session($status = NULL) {  static $save_session = TRUE;  if (isset($status)) {    $save_session = $status;  }  return ($save_session);}
<?php// $Id$/** * Implementation of hook_install(). */function update_install() {  // Create cache table.  drupal_install_schema('update');  // Remove stale variables from update_status 5.x contrib, if any.  _update_remove_update_status_variables();}/** * Implementation of hook_uninstall(). */function update_uninstall() {  // Remove cache table.  drupal_uninstall_schema('update');  // Clear any variables that might be in use  $variables = array(    'update_check_frequency',    'update_fetch_url',    'update_last_check',    'update_notification_threshold',    'update_notify_emails',  );  foreach ($variables as $variable) {    variable_del($variable);  }  menu_rebuild();}/** * Implementation of hook_schema(). */function update_schema() {  $schema['cache_update'] = drupal_get_schema_unprocessed('system', 'cache');  $schema['cache_update']['description'] = 'Cache table for the Update module to store information about available releases, fetched from central server.';  return $schema;}/** * Private helper to clear out stale variables from update_status 5.x contrib. * * @see update_install() * @see update_update_6000() */function _update_remove_update_status_variables() {  variable_del('update_status_settings');  variable_del('update_status_notify_emails');  variable_del('update_status_check_frequency');  variable_del('update_status_notification_threshold');  variable_del('update_status_last');  variable_del('update_status_fetch_url');}/** * Clear out stale variables from update_status. */function update_update_6000() {  _update_remove_update_status_variables();  return array();}
<?php// $Id$/** * @file * API for manipulating images. *//** * @defgroup image Image toolkits * @{ * Drupal's image toolkits provide an abstraction layer for common image file * manipulations like scaling, cropping, and rotating. The abstraction frees * module authors from the need to support multiple image libraries, and it * allows site administrators to choose the library that's best for them. * * PHP includes the GD library by default so a GD toolkit is installed with * Drupal. Other toolkits like ImageMagic are available from contrib modules. * GD works well for small images, but using it with larger files may cause PHP * to run out of memory. In contrast the ImageMagick library does not suffer * from this problem, but it requires the ISP to have installed additional * software. * * Image toolkits are installed by copying the image.ToolkitName.inc file into * Drupal's includes directory. The toolkit must then be enabled using the * admin/settings/image-toolkit form. * * Only one toolkit maybe selected at a time. If a module author wishes to call * a specific toolkit they can check that it is installed by calling * image_get_available_toolkits(), and then calling its functions directly. *//** * Return a list of available toolkits. * * @return *   An array of toolkit name => descriptive title. */function image_get_available_toolkits() {  $toolkits = file_scan_directory('includes', 'image\..*\.inc$');  $output = array();  foreach ($toolkits as $file => $toolkit) {    include_once "./$file";    $function = str_replace('.', '_', $toolkit->name) .'_info';    if (function_exists($function)) {      $info = $function();      $output[$info['name']] = $info['title'];    }  }  return $output;}/** * Retrieve the name of the currently used toolkit. * * @return *   String containing the name of the selected toolkit, or FALSE on error. */function image_get_toolkit() {  static $toolkit;  if (!$toolkit) {    $toolkit = variable_get('image_toolkit', 'gd');    $toolkit_file = './includes/image.'. $toolkit .'.inc';    if (isset($toolkit) && file_exists($toolkit_file)) {      include_once $toolkit_file;    }    elseif (!image_gd_check_settings()) {      $toolkit = FALSE;    }  }  return $toolkit;}/** * Invokes the given method using the currently selected toolkit. * * @param $method *   A string containing the method to invoke. * @param $params *   An optional array of parameters to pass to the toolkit method. * @return *   Mixed values (typically Boolean indicating successful operation). */function image_toolkit_invoke($method, $params = array()) {  if ($toolkit = image_get_toolkit()) {    $function = 'image_'. $toolkit .'_'. $method;    if (function_exists($function)) {      return call_user_func_array($function, $params);    }    else {      watchdog('php', 'The selected image handling toolkit %toolkit can not correctly process %function.', array('%toolkit' => $toolkit, '%function' => $function), WATCHDOG_ERROR);      return FALSE;    }  }}/** * Get details about an image. * * Drupal only supports GIF, JPG and PNG file formats. * * @return *   FALSE, if the file could not be found or is not an image. Otherwise, a *   keyed array containing information about the image: *    'width'     - Width in pixels. *    'height'    - Height in pixels. *    'extension' - Commonly used file extension for the image. *    'mime_type' - MIME type ('image/jpeg', 'image/gif', 'image/png'). *    'file_size' - File size in bytes. */function image_get_info($file) {  if (!is_file($file)) {    return FALSE;  }  $details = FALSE;  $data = @getimagesize($file);  $file_size = @filesize($file);  if (isset($data) && is_array($data)) {    $extensions = array('1' => 'gif', '2' => 'jpg', '3' => 'png');    $extension = array_key_exists($data[2], $extensions) ?  $extensions[$data[2]] : '';    $details = array('width'     => $data[0],                     'height'    => $data[1],                     'extension' => $extension,                     'file_size' => $file_size,                     'mime_type' => $data['mime']);  }  return $details;}/** * Scales an image to the exact width and height given. Achieves the * target aspect ratio by cropping the original image equally on both * sides, or equally on the top and bottom.  This function is, for * example, useful to create uniform sized avatars from larger images. * * The resulting image always has the exact target dimensions. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels. * @return *   TRUE or FALSE, based on success. */function image_scale_and_crop($source, $destination, $width, $height) {  $info = image_get_info($source);  $scale = max($width / $info['width'], $height / $info['height']);  $x = round(($info['width'] * $scale - $width) / 2);  $y = round(($info['height'] * $scale - $height) / 2);  if (image_toolkit_invoke('resize', array($source, $destination, $info['width'] * $scale, $info['height'] * $scale))) {    return image_toolkit_invoke('crop', array($destination, $destination, $x, $y, $width, $height));  }  return FALSE;}/** * Scales an image to the given width and height while maintaining aspect * ratio. * * The resulting image can be smaller for one or both target dimensions. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels. * @return *   TRUE or FALSE, based on success. */function image_scale($source, $destination, $width, $height) {  $info = image_get_info($source);  // Don't scale up.  if ($width >= $info['width'] && $height >= $info['height']) {    return FALSE;  }  $aspect = $info['height'] / $info['width'];  if ($aspect < $height / $width) {    $width = (int)min($width, $info['width']);    $height = (int)round($width * $aspect);  }  else {    $height = (int)min($height, $info['height']);    $width = (int)round($height / $aspect);  }  return image_toolkit_invoke('resize', array($source, $destination, $width, $height));}/** * Resize an image to the given dimensions (ignoring aspect ratio). * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels.  * @return *   TRUE or FALSE, based on success. */function image_resize($source, $destination, $width, $height) {  return image_toolkit_invoke('resize', array($source, $destination, $width, $height));}/** * Rotate an image by the given number of degrees. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $degrees *   The number of (clockwise) degrees to rotate the image. * @param $background *   An hexidecimal integer specifying the background color to use for the *   uncovered area of the image after the rotation. E.g. 0x000000 for black, *   0xff00ff for magenta, and 0xffffff for white. * @return *   TRUE or FALSE, based on success. */function image_rotate($source, $destination, $degrees, $background = 0x000000) {  return image_toolkit_invoke('rotate', array($source, $destination, $degrees, $background));}/** * Crop an image to the rectangle specified by the given rectangle. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $x *   The top left co-ordinate, in pixels, of the crop area (x axis value). * @param $y *   The top left co-ordinate, in pixels, of the crop area (y axis value). * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels. * @return *   TRUE or FALSE, based on success. */function image_crop($source, $destination, $x, $y, $width, $height) {  return image_toolkit_invoke('crop', array($source, $destination, $x, $y, $width, $height));}/** * @} End of "defgroup image". */
<?php// $Id$/** * Return data from the persistent cache. Data may be stored as either plain text or as serialized data. * cache_get will automatically return unserialized objects and arrays. * * @param $cid *   The cache ID of the data to retrieve. * @param $table *   The table $table to store the data in. Valid core values are 'cache_filter', *   'cache_menu', 'cache_page', or 'cache' for the default cache. */function cache_get($cid, $table = 'cache') {  global $user;  // Garbage collection necessary when enforcing a minimum cache lifetime  $cache_flush = variable_get('cache_flush_'. $table, 0);  if ($cache_flush && ($cache_flush + variable_get('cache_lifetime', 0) <= time())) {    // Reset the variable immediately to prevent a meltdown in heavy load situations.    variable_set('cache_flush_'. $table, 0);    // Time to flush old cache data    db_query("DELETE FROM {". $table ."} WHERE expire != %d AND expire <= %d", CACHE_PERMANENT, $cache_flush);  }  $cache = db_fetch_object(db_query("SELECT data, created, headers, expire, serialized FROM {". $table ."} WHERE cid = '%s'", $cid));  if (isset($cache->data)) {    // If the data is permanent or we're not enforcing a minimum cache lifetime    // always return the cached data.    if ($cache->expire == CACHE_PERMANENT || !variable_get('cache_lifetime', 0)) {      $cache->data = db_decode_blob($cache->data);      if ($cache->serialized) {        $cache->data = unserialize($cache->data);      }    }    // If enforcing a minimum cache lifetime, validate that the data is    // currently valid for this user before we return it by making sure the    // cache entry was created before the timestamp in the current session's    // cache timer. The cache variable is loaded into the $user object by    // sess_read() in session.inc.    else {      if ($user->cache > $cache->created) {        // This cache data is too old and thus not valid for us, ignore it.        return 0;      }      else {        $cache->data = db_decode_blob($cache->data);        if ($cache->serialized) {          $cache->data = unserialize($cache->data);        }      }    }    return $cache;  }  return 0;}/** * Store data in the persistent cache. * * The persistent cache is split up into four database * tables. Contributed modules can add additional tables. * * 'cache_page': This table stores generated pages for anonymous * users. This is the only table affected by the page cache setting on * the administrator panel. * * 'cache_menu': Stores the cachable part of the users' menus. * * 'cache_filter': Stores filtered pieces of content. This table is * periodically cleared of stale entries by cron. * * 'cache': Generic cache storage table. * * The reasons for having several tables are as follows: * * - smaller tables allow for faster selects and inserts * - we try to put fast changing cache items and rather static *   ones into different tables. The effect is that only the fast *   changing tables will need a lot of writes to disk. The more *   static tables will also be better cachable with MySQL's query cache * * @param $cid *   The cache ID of the data to store. * @param $data *   The data to store in the cache. Complex data types will be automatically serialized before insertion. *   Strings will be stored as plain text and not serialized. * @param $table *   The table $table to store the data in. Valid core values are 'cache_filter', *   'cache_menu', 'cache_page', or 'cache'. * @param $expire *   One of the following values: *   - CACHE_PERMANENT: Indicates that the item should never be removed unless *     explicitly told to using cache_clear_all() with a cache ID. *   - CACHE_TEMPORARY: Indicates that the item should be removed at the next *     general cache wipe. *   - A Unix timestamp: Indicates that the item should be kept at least until *     the given time, after which it behaves like CACHE_TEMPORARY. * @param $headers *   A string containing HTTP header information for cached pages. */function cache_set($cid, $data, $table = 'cache', $expire = CACHE_PERMANENT, $headers = NULL) {  $serialized = 0;  if (is_object($data) || is_array($data)) {    $data = serialize($data);    $serialized = 1;  }  $created = time();  db_query("UPDATE {". $table ."} SET data = %b, created = %d, expire = %d, headers = '%s', serialized = %d WHERE cid = '%s'", $data, $created, $expire, $headers, $serialized, $cid);  if (!db_affected_rows()) {    @db_query("INSERT INTO {". $table ."} (cid, data, created, expire, headers, serialized) VALUES ('%s', %b, %d, %d, '%s', %d)", $cid, $data, $created, $expire, $headers, $serialized);  }}/** * * Expire data from the cache. If called without arguments, expirable * entries will be cleared from the cache_page and cache_block tables. * * @param $cid *   If set, the cache ID to delete. Otherwise, all cache entries that can *   expire are deleted. * * @param $table *   If set, the table $table to delete from. Mandatory *   argument if $cid is set. * * @param $wildcard *   If $wildcard is TRUE, cache IDs starting with $cid are deleted in *   addition to the exact cache ID specified by $cid.  If $wildcard is *   TRUE and $cid is '*' then the entire table $table is emptied. */function cache_clear_all($cid = NULL, $table = NULL, $wildcard = FALSE) {  global $user;  if (!isset($cid) && !isset($table)) {    // Clear the block cache first, so stale data will    // not end up in the page cache.    cache_clear_all(NULL, 'cache_block');    cache_clear_all(NULL, 'cache_page');    return;  }  if (empty($cid)) {    if (variable_get('cache_lifetime', 0)) {      // We store the time in the current user's $user->cache variable which      // will be saved into the sessions table by sess_write(). We then      // simulate that the cache was flushed for this user by not returning      // cached data that was cached before the timestamp.      $user->cache = time();      $cache_flush = variable_get('cache_flush_'. $table, 0);      if ($cache_flush == 0) {        // This is the first request to clear the cache, start a timer.        variable_set('cache_flush_'. $table, time());      }      else if (time() > ($cache_flush + variable_get('cache_lifetime', 0))) {        // Clear the cache for everyone, cache_lifetime seconds have        // passed since the first request to clear the cache.        db_query("DELETE FROM {". $table ."} WHERE expire != %d AND expire < %d", CACHE_PERMANENT, time());        variable_set('cache_flush_'. $table, 0);      }    }    else {      // No minimum cache lifetime, flush all temporary cache entries now.      db_query("DELETE FROM {". $table ."} WHERE expire != %d AND expire < %d", CACHE_PERMANENT, time());    }  }  else {    if ($wildcard) {      if ($cid == '*') {        db_query("TRUNCATE TABLE {". $table ."}");      }      else {        db_query("DELETE FROM {". $table ."} WHERE cid LIKE '%s%%'", $cid);      }    }    else {      db_query("DELETE FROM {". $table ."} WHERE cid = '%s'", $cid);    }  }}
<?php// $Id$/** * @file * Framework for handling filtering of content. */// This is a special format ID which means "use the default format". This value// can be passed to the filter APIs as a format ID: this is equivalent to not// passing an explicit format at all.define('FILTER_FORMAT_DEFAULT', 0);define('FILTER_HTML_STRIP', 1);define('FILTER_HTML_ESCAPE', 2);/** * Implementation of hook_help(). */function filter_help($path, $arg) {  switch ($path) {    case 'admin/help#filter':      $output = '<p>'. t("The filter module allows administrators to configure text input formats for use on your site. An input format defines the HTML tags, codes, and other input allowed in both content and comments, and is a key feature in guarding against potentially damaging input from malicious users. Two input formats included by default are <em>Filtered HTML</em> (which allows only an administrator-approved subset of HTML tags) and <em>Full HTML</em> (which allows the full set of HTML tags). Additional input formats may be created by an administrator.") .'</p>';      $output .= '<p>'. t('Each input format uses filters to manipulate text, and most input formats apply several different filters to text in a specific order. Each filter is designed for a specific purpose, and generally either adds, removes or transforms elements within user-entered text before it is displayed. A filter does not change the actual content of a post, but instead, modifies it temporarily before it is displayed. A filter may remove unapproved HTML tags, for instance, while another automatically adds HTML to make links referenced in text clickable.') .'</p>';      $output .= '<p>'. t('Users can choose between the available input formats when creating or editing content. Administrators can configure which input formats are available to which user roles, as well as choose a default input format.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@filter">Filter module</a>.', array('@filter' => 'http://drupal.org/handbook/modules/filter/')) .'</p>';      return $output;    case 'admin/settings/filters':      $output = '<p>'. t('<em>Input formats</em> define a way of processing user-supplied text in Drupal. Each input format uses filters to manipulate text, and most input formats apply several different filters to text, in a specific order. Each filter is designed to accomplish a specific purpose, and generally either removes elements from or adds elements to text before it is displayed. Users can choose between the available input formats when submitting content.') .'</p>';      $output .= '<p>'. t('Use the list below to configure which input formats are available to which roles, as well as choose a default input format (used for imported content, for example). The default format is always available to users. All input formats are available to users in a role with the "administer filters" permission.') .'</p>';      return $output;    case 'admin/settings/filters/%':      return '<p>'. t('Every <em>filter</em> performs one particular change on the user input, for example stripping out malicious HTML or making URLs clickable. Choose which filters you want to apply to text in this input format. If you notice some filters are causing conflicts in the output, you can <a href="@rearrange">rearrange them</a>.', array('@rearrange' => url('admin/settings/filters/'. $arg[3] .'/order'))) .'</p>';    case 'admin/settings/filters/%/configure':      return '<p>'. t('If you cannot find the settings for a certain filter, make sure you have enabled it on the <a href="@url">view tab</a> first.', array('@url' => url('admin/settings/filters/'. $arg[3]))) .'</p>';    case 'admin/settings/filters/%/order':      $output = '<p>'. t('Because of the flexible filtering system, you might encounter a situation where one filter prevents another from doing its job. For example: a word in an URL gets converted into a glossary term, before the URL can be converted to a clickable link. When this happens, rearrange the order of the filters.') .'</p>';      $output .= '<p>'. t("Filters are executed from top-to-bottom. To change the order of the filters, modify the values in the <em>Weight</em> column or grab a drag-and-drop handle under the <em>Name</em> column and drag filters to new locations in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save configuration</em> button at the bottom of the page.") .'</p>';      return $output;  }}/** * Implementation of hook_theme() */function filter_theme() {  return array(    'filter_admin_overview' => array(      'arguments' => array('form' => NULL),      'file' => 'filter.admin.inc',    ),    'filter_admin_order' => array(      'arguments' => array('form' => NULL),      'file' => 'filter.admin.inc',    ),    'filter_tips' => array(      'arguments' => array('tips' => NULL, 'long' => FALSE, 'extra' => ''),      'file' => 'filter.pages.inc',    ),    'filter_tips_more_info' => array(      'arguments' => array(),    ),  );}/** * Implementation of hook_menu(). */function filter_menu() {  $items['admin/settings/filters'] = array(    'title' => 'Input formats',    'description' => 'Configure how content input by users is filtered, including allowed HTML tags. Also allows enabling of module-provided filters.',    'page callback' => 'drupal_get_form',    'page arguments' => array('filter_admin_overview'),    'access arguments' => array('administer filters'),    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/settings/filters/add'] = array(    'title' => 'Add input format',    'page callback' => 'filter_admin_format_page',    'access arguments' => array('administer filters'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/delete'] = array(    'title' => 'Delete input format',    'page callback' => 'drupal_get_form',    'page arguments' => array('filter_admin_delete'),    'access arguments' => array('administer filters'),    'type' => MENU_CALLBACK,    'file' => 'filter.admin.inc',  );  $items['filter/tips'] = array(    'title' => 'Compose tips',    'page callback' => 'filter_tips_long',    'access callback' => TRUE,    'type' => MENU_SUGGESTED_ITEM,    'file' => 'filter.pages.inc',  );  $items['admin/settings/filters/%filter_format'] = array(    'type' => MENU_CALLBACK,    'title callback' => 'filter_admin_format_title',    'title arguments' => array(3),    'page callback' => 'filter_admin_format_page',    'page arguments' => array(3),    'access arguments' => array('administer filters'),    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/%filter_format/edit'] = array(    'title' => 'Edit',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => 0,    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/%filter_format/configure'] = array(    'title' => 'Configure',    'page callback' => 'filter_admin_configure_page',    'page arguments' => array(3),    'access arguments' => array('administer filters'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/%filter_format/order'] = array(    'title' => 'Rearrange',    'page callback' => 'filter_admin_order_page',    'page arguments' => array(3),    'access arguments' => array('administer filters'),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'filter.admin.inc',  );  return $items;}function filter_format_load($arg) {  return filter_formats($arg);}/** * Display a filter format form title. */function filter_admin_format_title($format) {  return $format->name;}/** * Implementation of hook_perm(). */function filter_perm() {  return array('administer filters');}/** * Implementation of hook_cron(). * * Expire outdated filter cache entries */function filter_cron() {  cache_clear_all(NULL, 'cache_filter');}/** * Implementation of hook_filter_tips(). */function filter_filter_tips($delta, $format, $long = FALSE) {  global $base_url;  switch ($delta) {    case 0:      if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_STRIP) {        if ($allowed_html = variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>')) {          switch ($long) {            case 0:              return t('Allowed HTML tags: @tags', array('@tags' => $allowed_html));            case 1:              $output = '<p>'. t('Allowed HTML tags: @tags', array('@tags' => $allowed_html)) .'</p>';              if (!variable_get("filter_html_help_$format", 1)) {                return $output;              }              $output .= t('<p>This site allows HTML content. While learning all of HTML may feel intimidating, learning how to use a very small number of the most basic HTML "tags" is very easy. This table provides examples for each tag that is enabled on this site.</p><p>For more information see W3C\'s <a href="http://www.w3.org/TR/html/">HTML Specifications</a> or use your favorite search engine to find other sites that explain HTML.</p>');              $tips = array(                'a' => array( t('Anchors are used to make links to other pages.'), '<a href="'. $base_url .'">'. variable_get('site_name', 'Drupal') .'</a>'),                'br' => array( t('By default line break tags are automatically added, so use this tag to add additional ones. Use of this tag is different because it is not used with an open/close pair like all the others. Use the extra " /" inside the tag to maintain XHTML 1.0 compatibility'), t('Text with <br />line break')),                'p' => array( t('By default paragraph tags are automatically added, so use this tag to add additional ones.'), '<p>'. t('Paragraph one.') .'</p> <p>'. t('Paragraph two.') .'</p>'),                'strong' => array( t('Strong'), '<strong>'. t('Strong') .'</strong>'),                'em' => array( t('Emphasized'), '<em>'. t('Emphasized') .'</em>'),                'cite' => array( t('Cited'), '<cite>'. t('Cited') .'</cite>'),                'code' => array( t('Coded text used to show programming source code'), '<code>'. t('Coded') .'</code>'),                'b' => array( t('Bolded'), '<b>'. t('Bolded') .'</b>'),                'u' => array( t('Underlined'), '<u>'. t('Underlined') .'</u>'),                'i' => array( t('Italicized'), '<i>'. t('Italicized') .'</i>'),                'sup' => array( t('Superscripted'), t('<sup>Super</sup>scripted')),                'sub' => array( t('Subscripted'), t('<sub>Sub</sub>scripted')),                'pre' => array( t('Preformatted'), '<pre>'. t('Preformatted') .'</pre>'),                'abbr' => array( t('Abbreviation'), t('<abbr title="Abbreviation">Abbrev.</abbr>')),                'acronym' => array( t('Acronym'), t('<acronym title="Three-Letter Acronym">TLA</acronym>')),                'blockquote' => array( t('Block quoted'), '<blockquote>'. t('Block quoted') .'</blockquote>'),                'q' => array( t('Quoted inline'), '<q>'. t('Quoted inline') .'</q>'),                // Assumes and describes tr, td, th.                'table' => array( t('Table'), '<table> <tr><th>'. t('Table header') .'</th></tr> <tr><td>'. t('Table cell') .'</td></tr> </table>'),                'tr' => NULL, 'td' => NULL, 'th' => NULL,                'del' => array( t('Deleted'), '<del>'. t('Deleted') .'</del>'),                'ins' => array( t('Inserted'), '<ins>'. t('Inserted') .'</ins>'),                 // Assumes and describes li.                'ol' => array( t('Ordered list - use the &lt;li&gt; to begin each list item'), '<ol> <li>'. t('First item') .'</li> <li>'. t('Second item') .'</li> </ol>'),                'ul' => array( t('Unordered list - use the &lt;li&gt; to begin each list item'), '<ul> <li>'. t('First item') .'</li> <li>'. t('Second item') .'</li> </ul>'),                'li' => NULL,                // Assumes and describes dt and dd.                'dl' => array( t('Definition lists are similar to other HTML lists. &lt;dl&gt; begins the definition list, &lt;dt&gt; begins the definition term and &lt;dd&gt; begins the definition description.'), '<dl> <dt>'. t('First term') .'</dt> <dd>'. t('First definition') .'</dd> <dt>'. t('Second term') .'</dt> <dd>'. t('Second definition') .'</dd> </dl>'),                'dt' => NULL, 'dd' => NULL,                'h1' => array( t('Header'), '<h1>'. t('Title') .'</h1>'),                'h2' => array( t('Header'), '<h2>'. t('Subtitle') .'</h2>'),                'h3' => array( t('Header'), '<h3>'. t('Subtitle three') .'</h3>'),                'h4' => array( t('Header'), '<h4>'. t('Subtitle four') .'</h4>'),                'h5' => array( t('Header'), '<h5>'. t('Subtitle five') .'</h5>'),                'h6' => array( t('Header'), '<h6>'. t('Subtitle six') .'</h6>')              );              $header = array(t('Tag Description'), t('You Type'), t('You Get'));              preg_match_all('/<([a-z0-9]+)[^a-z0-9]/i', $allowed_html, $out);              foreach ($out[1] as $tag) {                if (array_key_exists($tag, $tips)) {                  if ($tips[$tag]) {                    $rows[] = array(                      array('data' => $tips[$tag][0], 'class' => 'description'),                      array('data' => '<code>'. check_plain($tips[$tag][1]) .'</code>', 'class' => 'type'),                      array('data' => $tips[$tag][1], 'class' => 'get')                    );                  }                }                else {                  $rows[] = array(                    array('data' => t('No help provided for tag %tag.', array('%tag' => $tag)), 'class' => 'description', 'colspan' => 3),                  );                }              }              $output .= theme('table', $header, $rows);              $output .= t('<p>Most unusual characters can be directly entered without any problems.</p><p>If you do encounter problems, try using HTML character entities. A common example looks like &amp;amp; for an ampersand &amp; character. For a full list of entities see HTML\'s <a href="http://www.w3.org/TR/html4/sgml/entities.html">entities</a> page. Some of the available characters include:</p>');              $entities = array(                array( t('Ampersand'), '&amp;'),                array( t('Greater than'), '&gt;'),                array( t('Less than'), '&lt;'),                array( t('Quotation mark'), '&quot;'),              );              $header = array(t('Character Description'), t('You Type'), t('You Get'));              unset($rows);              foreach ($entities as $entity) {                $rows[] = array(                  array('data' => $entity[0], 'class' => 'description'),                  array('data' => '<code>'. check_plain($entity[1]) .'</code>', 'class' => 'type'),                  array('data' => $entity[1], 'class' => 'get')                );              }              $output .= theme('table', $header, $rows);              return $output;          }        }        else {          return t('No HTML tags allowed');        }      }      break;    case 1:      switch ($long) {        case 0:          return t('Lines and paragraphs break automatically.');        case 1:          return t('Lines and paragraphs are automatically recognized. The &lt;br /&gt; line break, &lt;p&gt; paragraph and &lt;/p&gt; close paragraph tags are inserted automatically. If paragraphs are not recognized simply add a couple blank lines.');      }      break;    case 2:      return t('Web page addresses and e-mail addresses turn into links automatically.');  }}/** * Retrieve a list of input formats. */function filter_formats($index = NULL) {  global $user;  static $formats;  // Administrators can always use all input formats.  $all = user_access('administer filters');  if (!isset($formats)) {    $formats = array();    $query = 'SELECT * FROM {filter_formats}';    // Build query for selecting the format(s) based on the user's roles.    $args = array();    if (!$all) {      $where = array();      foreach ($user->roles as $rid => $role) {        $where[] = "roles LIKE '%%,%d,%%'";        $args[] = $rid;      }      $query .= ' WHERE '. implode(' OR ', $where) .' OR format = %d';      $args[] = variable_get('filter_default_format', 1);    }    $result = db_query($query, $args);    while ($format = db_fetch_object($result)) {      $formats[$format->format] = $format;    }  }  if (isset($index)) {    return isset($formats[$index]) ? $formats[$index] : FALSE;  }  return $formats;}/** * Build a list of all filters. */function filter_list_all() {  $filters = array();  foreach (module_list() as $module) {    $list = module_invoke($module, 'filter', 'list');    if (isset($list) && is_array($list)) {      foreach ($list as $delta => $name) {        $filters[$module .'/'. $delta] = (object)array('module' => $module, 'delta' => $delta, 'name' => $name);      }    }  }  uasort($filters, '_filter_list_cmp');  return $filters;}/** * Helper function for sorting the filter list by filter name. */function _filter_list_cmp($a, $b) {  return strcmp($a->name, $b->name);}/** * Resolve a format id, including the default format. */function filter_resolve_format($format) {  return $format == FILTER_FORMAT_DEFAULT ? variable_get('filter_default_format', 1) : $format;}/** * Check if text in a certain input format is allowed to be cached. */function filter_format_allowcache($format) {  static $cache = array();  $format = filter_resolve_format($format);  if (!isset($cache[$format])) {    $cache[$format] = db_result(db_query('SELECT cache FROM {filter_formats} WHERE format = %d', $format));  }  return $cache[$format];}/** * Retrieve a list of filters for a certain format. */function filter_list_format($format) {  static $filters = array();  if (!isset($filters[$format])) {    $result = db_query("SELECT * FROM {filters} WHERE format = %d ORDER BY weight, module, delta", $format);    if (db_affected_rows($result) == 0 && !db_result(db_query("SELECT 1 FROM {filter_formats} WHERE format = %d", $format))) {      // The format has no filters and does not exist, use the default input      // format.      $filters[$format] = filter_list_format(variable_get('filter_default_format', 1));    }    else {      $filters[$format] = array();      while ($filter = db_fetch_object($result)) {        $list = module_invoke($filter->module, 'filter', 'list');        if (isset($list) && is_array($list) && isset($list[$filter->delta])) {          $filter->name = $list[$filter->delta];          $filters[$format][$filter->module .'/'. $filter->delta] = $filter;        }      }    }  }  return $filters[$format];}/** * @name Filtering functions * @{ * Modules which need to have content filtered can use these functions to * interact with the filter system. * * For more info, see the hook_filter() documentation. * * Note: because filters can inject JavaScript or execute PHP code, security is * vital here. When a user supplies a $format, you should validate it with * filter_access($format) before accepting/using it. This is normally done in * the validation stage of the node system. You should for example never make a * preview of content in a disallowed format. *//** * Run all the enabled filters on a piece of text. * * @param $text *    The text to be filtered. * @param $format *    The format of the text to be filtered. Specify FILTER_FORMAT_DEFAULT for *    the default format. * @param $check *    Whether to check the $format with filter_access() first. Defaults to TRUE. *    Note that this will check the permissions of the current user, so you *    should specify $check = FALSE when viewing other people's content. When *    showing content that is not (yet) stored in the database (eg. upon preview), *    set to TRUE so the user's permissions are checked. */function check_markup($text, $format = FILTER_FORMAT_DEFAULT, $check = TRUE) {  // When $check = TRUE, do an access check on $format.  if (isset($text) && (!$check || filter_access($format))) {    $format = filter_resolve_format($format);    // Check for a cached version of this piece of text.    $cache_id = $format .':'. md5($text);    if ($cached = cache_get($cache_id, 'cache_filter')) {      return $cached->data;    }    // See if caching is allowed for this format.    $cache = filter_format_allowcache($format);    // Convert all Windows and Mac newlines to a single newline,    // so filters only need to deal with one possibility.    $text = str_replace(array("\r\n", "\r"), "\n", $text);    // Get a complete list of filters, ordered properly.    $filters = filter_list_format($format);    // Give filters the chance to escape HTML-like data such as code or formulas.    foreach ($filters as $filter) {      $text = module_invoke($filter->module, 'filter', 'prepare', $filter->delta, $format, $text, $cache_id);    }    // Perform filtering.    foreach ($filters as $filter) {      $text = module_invoke($filter->module, 'filter', 'process', $filter->delta, $format, $text, $cache_id);    }    // Store in cache with a minimum expiration time of 1 day.    if ($cache) {      cache_set($cache_id, $text, 'cache_filter', time() + (60 * 60 * 24));    }  }  else {    $text = t('n/a');  }  return $text;}/** * Generate a selector for choosing a format in a form. * * @ingroup forms * @see filter_form_validate() * @param $value *   The ID of the format that is currently selected. * @param $weight *   The weight of the input format. * @param $parents *   Required when defining multiple input formats on a single node or having a different parent than 'format'. * @return *   HTML for the form element. */function filter_form($value = FILTER_FORMAT_DEFAULT, $weight = NULL, $parents = array('format')) {  $value = filter_resolve_format($value);  $formats = filter_formats();  $extra = theme('filter_tips_more_info');  if (count($formats) > 1) {    $form = array(      '#type' => 'fieldset',      '#title' => t('Input format'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#weight' => $weight,      '#element_validate' => array('filter_form_validate'),    );    // Multiple formats available: display radio buttons with tips.    foreach ($formats as $format) {      // Generate the parents as the autogenerator does, so we will have a      // unique id for each radio button.      $parents_for_id = array_merge($parents, array($format->format));      $form[$format->format] = array(        '#type' => 'radio',        '#title' => $format->name,        '#default_value' => $value,        '#return_value' => $format->format,        '#parents' => $parents,        '#description' => theme('filter_tips', _filter_tips($format->format, FALSE)),        '#id' => form_clean_id('edit-'. implode('-', $parents_for_id)),      );    }  }  else {    // Only one format available: use a hidden form item and only show tips.    $format = array_shift($formats);    $form[$format->format] = array('#type' => 'value', '#value' => $format->format, '#parents' => $parents);    $tips = _filter_tips(variable_get('filter_default_format', 1), FALSE);    $form['format']['guidelines'] = array(      '#title' => t('Formatting guidelines'),      '#value' => theme('filter_tips', $tips, FALSE, $extra),    );  }  $form[] = array('#value' => $extra);  return $form;}function filter_form_validate($form) {  foreach (element_children($form) as $key) {    if ($form[$key]['#value'] == $form[$key]['#return_value']) {      return;    }  }  form_error($form, t('An illegal choice has been detected. Please contact the site administrator.'));  watchdog('form', 'Illegal choice %choice in %name element.', array('%choice' => $form[$key]['#value'], '%name' => empty($form['#title']) ? $form['#parents'][0] : $form['#title']), WATCHDOG_ERROR);}/** * Returns TRUE if the user is allowed to access this format. */function filter_access($format) {  $format = filter_resolve_format($format);  if (user_access('administer filters') || ($format == variable_get('filter_default_format', 1))) {    return TRUE;  }  else {    $formats = filter_formats();    return isset($formats[$format]);  }}/** * @} End of "Filtering functions". *//** * Helper function for fetching filter tips. */function _filter_tips($format, $long = FALSE) {  if ($format == -1) {    $formats = filter_formats();  }  else {    $formats = array(db_fetch_object(db_query("SELECT * FROM {filter_formats} WHERE format = %d", $format)));  }  $tips = array();  foreach ($formats as $format) {    $filters = filter_list_format($format->format);    $tips[$format->name] = array();    foreach ($filters as $id => $filter) {      if ($tip = module_invoke($filter->module, 'filter_tips', $filter->delta, $format->format, $long)) {        $tips[$format->name][] = array('tip' => $tip, 'id' => $id);      }    }  }  return $tips;}/** * Format a link to the more extensive filter tips. * * @ingroup themeable */function theme_filter_tips_more_info() {  return '<p>'. l(t('More information about formatting options'), 'filter/tips') .'</p>';}/** * @name Standard filters * @{ * Filters implemented by the filter.module. *//** * Implementation of hook_filter(). Contains a basic set of essential filters. * - HTML filter: *     Validates user-supplied HTML, transforming it as necessary. * - Line break converter: *     Converts newlines into paragraph and break tags. * - URL and e-mail address filter: *     Converts newlines into paragraph and break tags. */function filter_filter($op, $delta = 0, $format = -1, $text = '') {  switch ($op) {    case 'list':      return array(0 => t('HTML filter'), 1 => t('Line break converter'), 2 => t('URL filter'), 3 => t('HTML corrector'));    case 'description':      switch ($delta) {        case 0:          return t('Allows you to restrict whether users can post HTML and which tags to filter out. It will also remove harmful content such as JavaScript events, JavaScript URLs and CSS styles from those tags that are not removed.');        case 1:          return t('Converts line breaks into HTML (i.e. &lt;br&gt; and &lt;p&gt; tags).');        case 2:          return t('Turns web and e-mail addresses into clickable links.');        case 3:          return t('Corrects faulty and chopped off HTML in postings.');        default:          return;      }    case 'process':      switch ($delta) {        case 0:          return _filter_html($text, $format);        case 1:          return _filter_autop($text);        case 2:          return _filter_url($text, $format);        case 3:          return _filter_htmlcorrector($text);        default:          return $text;      }    case 'settings':      switch ($delta) {        case 0:          return _filter_html_settings($format);        case 2:          return _filter_url_settings($format);        default:          return;      }    default:      return $text;  }}/** * Settings for the HTML filter. */function _filter_html_settings($format) {  $form['filter_html'] = array(    '#type' => 'fieldset',    '#title' => t('HTML filter'),    '#collapsible' => TRUE,  );  $form['filter_html']["filter_html_$format"] = array(    '#type' => 'radios',    '#title' => t('Filter HTML tags'),    '#default_value' => variable_get("filter_html_$format", FILTER_HTML_STRIP),    '#options' => array(FILTER_HTML_STRIP => t('Strip disallowed tags'), FILTER_HTML_ESCAPE => t('Escape all tags')),    '#description' => t('How to deal with HTML tags in user-contributed content. If set to "Strip disallowed tags", dangerous tags are removed (see below). If set to "Escape tags", all HTML is escaped and presented as it was typed.'),  );  $form['filter_html']["allowed_html_$format"] = array(    '#type' => 'textfield',    '#title' => t('Allowed HTML tags'),    '#default_value' => variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>'),    '#size' => 64,    '#maxlength' => 1024,    '#description' => t('If "Strip disallowed tags" is selected, optionally specify tags which should not be stripped. JavaScript event attributes are always stripped.'),  );  $form['filter_html']["filter_html_help_$format"] = array(    '#type' => 'checkbox',    '#title' => t('Display HTML help'),    '#default_value' => variable_get("filter_html_help_$format", 1),    '#description' => t('If enabled, Drupal will display some basic HTML help in the long filter tips.'),  );  $form['filter_html']["filter_html_nofollow_$format"] = array(    '#type' => 'checkbox',    '#title' => t('Spam link deterrent'),    '#default_value' => variable_get("filter_html_nofollow_$format", FALSE),    '#description' => t('If enabled, Drupal will add rel="nofollow" to all links, as a measure to reduce the effectiveness of spam links. Note: this will also prevent valid links from being followed by search engines, therefore it is likely most effective when enabled for anonymous users.'),  );  return $form;}/** * HTML filter. Provides filtering of input into accepted HTML. */function _filter_html($text, $format) {  if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_STRIP) {    $allowed_tags = preg_split('/\s+|<|>/', variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>'), -1, PREG_SPLIT_NO_EMPTY);    $text = filter_xss($text, $allowed_tags);  }  if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_ESCAPE) {    // Escape HTML    $text = check_plain($text);  }  if (variable_get("filter_html_nofollow_$format", FALSE)) {    $text = preg_replace('/<a([^>]+)>/i', '<a\\1 rel="nofollow">', $text);  }  return trim($text);}/** * Settings for URL filter. */function _filter_url_settings($format) {  $form['filter_urlfilter'] = array(    '#type' => 'fieldset',    '#title' => t('URL filter'),    '#collapsible' => TRUE,  );  $form['filter_urlfilter']['filter_url_length_'. $format] = array(    '#type' => 'textfield',    '#title' => t('Maximum link text length'),    '#default_value' => variable_get('filter_url_length_'. $format, 72),    '#maxlength' => 4,    '#description' => t('URLs longer than this number of characters will be truncated to prevent long strings that break formatting. The link itself will be retained; just the text portion of the link will be truncated.'),  );  return $form;}/** * URL filter. Automatically converts text web addresses (URLs, e-mail addresses, * ftp links, etc.) into hyperlinks. */function _filter_url($text, $format) {  // Pass length to regexp callback  _filter_url_trim(NULL, variable_get('filter_url_length_'. $format, 72));  $text = ' '. $text .' ';  // Match absolute URLs.  $text = preg_replace_callback("`(<p>|<li>|<br\s*/?>|[ \n\r\t\(])((http://|https://|ftp://|mailto:|smb://|afp://|file://|gopher://|news://|ssl://|sslv2://|sslv3://|tls://|tcp://|udp://)([a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+*~#&=/;-]))([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '_filter_url_parse_full_links', $text);  // Match e-mail addresses.  $text = preg_replace("`(<p>|<li>|<br\s*/?>|[ \n\r\t\(])([A-Za-z0-9._-]+@[A-Za-z0-9._+-]+\.[A-Za-z]{2,4})([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '\1<a href="mailto:\2">\2</a>\3', $text);  // Match www domains/addresses.  $text = preg_replace_callback("`(<p>|<li>|[ \n\r\t\(])(www\.[a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+~#\&=/;-])([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '_filter_url_parse_partial_links', $text);  $text = substr($text, 1, -1);  return $text;}/** * Scan input and make sure that all HTML tags are properly closed and nested. */function _filter_htmlcorrector($text) {  // Prepare tag lists.  static $no_nesting, $single_use;  if (!isset($no_nesting)) {    // Tags which cannot be nested but are typically left unclosed.    $no_nesting = drupal_map_assoc(array('li', 'p'));    // Single use tags in HTML4    $single_use = drupal_map_assoc(array('base', 'meta', 'link', 'hr', 'br', 'param', 'img', 'area', 'input', 'col', 'frame'));  }  // Properly entify angles.  $text = preg_replace('!<([^a-zA-Z/])!', '&lt;\1', $text);  // Split tags from text.  $split = preg_split('/<([^>]+?)>/', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting $null as required).  $tag = false; // Odd/even counter. Tag or no tag.  $stack = array();  $output = '';  foreach ($split as $value) {    // Process HTML tags.    if ($tag) {      list($tagname) = explode(' ', strtolower($value), 2);      // Closing tag      if ($tagname{0} == '/') {        $tagname = substr($tagname, 1);        // Discard XHTML closing tags for single use tags.        if (!isset($single_use[$tagname])) {          // See if we possibly have a matching opening tag on the stack.          if (in_array($tagname, $stack)) {            // Close other tags lingering first.            do {              $output .= '</'. $stack[0] .'>';            } while (array_shift($stack) != $tagname);          }          // Otherwise, discard it.        }      }      // Opening tag      else {        // See if we have an identical 'no nesting' tag already open and close it if found.        if (count($stack) && ($stack[0] == $tagname) && isset($no_nesting[$stack[0]])) {          $output .= '</'. array_shift($stack) .'>';        }        // Push non-single-use tags onto the stack        if (!isset($single_use[$tagname])) {          array_unshift($stack, $tagname);        }        // Add trailing slash to single-use tags as per X(HT)ML.        else {          $value = rtrim($value, ' /') .' /';        }        $output .= '<'. $value .'>';      }    }    else {      // Passthrough all text.      $output .= $value;    }    $tag = !$tag;  }  // Close remaining tags.  while (count($stack) > 0) {    $output .= '</'. array_shift($stack) .'>';  }  return $output;}/** * Make links out of absolute URLs. */function _filter_url_parse_full_links($match) {  $match[2] = decode_entities($match[2]);  $caption = check_plain(_filter_url_trim($match[2]));  $match[2] = check_url($match[2]);  return $match[1] .'<a href="'. $match[2] .'" title="'. $match[2] .'">'. $caption .'</a>'. $match[5];}/** * Make links out of domain names starting with "www." */function _filter_url_parse_partial_links($match) {  $match[2] = decode_entities($match[2]);  $caption = check_plain(_filter_url_trim($match[2]));  $match[2] = check_plain($match[2]);  return $match[1] .'<a href="http://'. $match[2] .'" title="'. $match[2] .'">'. $caption .'</a>'. $match[3];}/** * Shortens long URLs to http://www.example.com/long/url... */function _filter_url_trim($text, $length = NULL) {  static $_length;  if ($length !== NULL) {    $_length = $length;  }  // Use +3 for '...' string length.  if (strlen($text) > $_length + 3) {    $text = substr($text, 0, $_length) .'...';  }  return $text;}/** * Convert line breaks into <p> and <br> in an intelligent fashion. * Based on: http://photomatt.net/scripts/autop */function _filter_autop($text) {  // All block level tags  $block = '(?:table|thead|tfoot|caption|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|select|form|blockquote|address|p|h[1-6]|hr)';  // Split at <pre>, <script>, <style> and </pre>, </script>, </style> tags.  // We don't apply any processing to the contents of these tags to avoid messing  // up code. We look for matched pairs and allow basic nesting. For example:  // "processed <pre> ignored <script> ignored </script> ignored </pre> processed"  $chunks = preg_split('@(</?(?:pre|script|style|object)[^>]*>)@i', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting NULL as required).  $ignore = FALSE;  $ignoretag = '';  $output = '';  foreach ($chunks as $i => $chunk) {    if ($i % 2) {      // Opening or closing tag?      $open = ($chunk[1] != '/');      list($tag) = split('[ >]', substr($chunk, 2 - $open), 2);      if (!$ignore) {        if ($open) {          $ignore = TRUE;          $ignoretag = $tag;        }      }      // Only allow a matching tag to close it.      else if (!$open && $ignoretag == $tag) {        $ignore = FALSE;        $ignoretag = '';      }    }    else if (!$ignore) {      $chunk = preg_replace('|\n*$|', '', $chunk) ."\n\n"; // just to make things a little easier, pad the end      $chunk = preg_replace('|<br />\s*<br />|', "\n\n", $chunk);      $chunk = preg_replace('!(<'. $block .'[^>]*>)!', "\n$1", $chunk); // Space things out a little      $chunk = preg_replace('!(</'. $block .'>)!', "$1\n\n", $chunk); // Space things out a little      $chunk = preg_replace("/\n\n+/", "\n\n", $chunk); // take care of duplicates      $chunk = preg_replace('/\n?(.+?)(?:\n\s*\n|\z)/s', "<p>$1</p>\n", $chunk); // make paragraphs, including one at the end      $chunk = preg_replace("|<p>(<li.+?)</p>|", "$1", $chunk); // problem with nested lists      $chunk = preg_replace('|<p><blockquote([^>]*)>|i', "<blockquote$1><p>", $chunk);      $chunk = str_replace('</blockquote></p>', '</p></blockquote>', $chunk);      $chunk = preg_replace('|<p>\s*</p>\n?|', '', $chunk); // under certain strange conditions it could create a P of entirely whitespace      $chunk = preg_replace('!<p>\s*(</?'. $block .'[^>]*>)!', "$1", $chunk);      $chunk = preg_replace('!(</?'. $block .'[^>]*>)\s*</p>!', "$1", $chunk);      $chunk = preg_replace('|(?<!<br />)\s*\n|', "<br />\n", $chunk); // make line breaks      $chunk = preg_replace('!(</?'. $block .'[^>]*>)\s*<br />!', "$1", $chunk);      $chunk = preg_replace('!<br />(\s*</?(?:p|li|div|th|pre|td|ul|ol)>)!', '$1', $chunk);      $chunk = preg_replace('/&([^#])(?![A-Za-z0-9]{1,8};)/', '&amp;$1', $chunk);    }    $output .= $chunk;  }  return $output;}/** * Very permissive XSS/HTML filter for admin-only use. * * Use only for fields where it is impractical to use the * whole filter system, but where some (mainly inline) mark-up * is desired (so check_plain() is not acceptable). * * Allows all tags that can be used inside an HTML body, save * for scripts and styles. */function filter_xss_admin($string) {  return filter_xss($string, array('a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big', 'blockquote', 'br', 'caption', 'cite', 'code', 'col', 'colgroup', 'dd', 'del', 'dfn', 'div', 'dl', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'ol', 'p', 'pre', 'q', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'ul', 'var'));}/** * Filters XSS. Based on kses by Ulf Harnhammar, see * http://sourceforge.net/projects/kses * * For examples of various XSS attacks, see: * http://ha.ckers.org/xss.html * * This code does four things: * - Removes characters and constructs that can trick browsers * - Makes sure all HTML entities are well-formed * - Makes sure all HTML tags and attributes are well-formed * - Makes sure no HTML tags contain URLs with a disallowed protocol (e.g. javascript:) * * @param $string *   The string with raw HTML in it. It will be stripped of everything that can cause *   an XSS attack. * @param $allowed_tags *   An array of allowed tags. */function filter_xss($string, $allowed_tags = array('a', 'em', 'strong', 'cite', 'code', 'ul', 'ol', 'li', 'dl', 'dt', 'dd')) {  // Only operate on valid UTF-8 strings. This is necessary to prevent cross  // site scripting issues on Internet Explorer 6.  if (!drupal_validate_utf8($string)) {    return '';  }  // Store the input format  _filter_xss_split($allowed_tags, TRUE);  // Remove NUL characters (ignored by some browsers)  $string = str_replace(chr(0), '', $string);  // Remove Netscape 4 JS entities  $string = preg_replace('%&\s*\{[^}]*(\}\s*;?|$)%', '', $string);  // Defuse all HTML entities  $string = str_replace('&', '&amp;', $string);  // Change back only well-formed entities in our whitelist  // Decimal numeric entities  $string = preg_replace('/&amp;#([0-9]+;)/', '&#\1', $string);  // Hexadecimal numeric entities  $string = preg_replace('/&amp;#[Xx]0*((?:[0-9A-Fa-f]{2})+;)/', '&#x\1', $string);  // Named entities  $string = preg_replace('/&amp;([A-Za-z][A-Za-z0-9]*;)/', '&\1', $string);  return preg_replace_callback('%    (    <(?=[^a-zA-Z!/])  # a lone <    |                 # or    <[^>]*(>|$)       # a string that starts with a <, up until the > or the end of the string    |                 # or    >                 # just a >    )%x', '_filter_xss_split', $string);}/** * Processes an HTML tag. * * @param @m *   An array with various meaning depending on the value of $store. *   If $store is TRUE then the array contains the allowed tags. *   If $store is FALSE then the array has one element, the HTML tag to process. * @param $store *   Whether to store $m. * @return *   If the element isn't allowed, an empty string. Otherwise, the cleaned up *   version of the HTML element. */function _filter_xss_split($m, $store = FALSE) {  static $allowed_html;  if ($store) {    $allowed_html = array_flip($m);    return;  }  $string = $m[1];  if (substr($string, 0, 1) != '<') {    // We matched a lone ">" character    return '&gt;';  }  else if (strlen($string) == 1) {    // We matched a lone "<" character    return '&lt;';  }  if (!preg_match('%^<\s*(/\s*)?([a-zA-Z0-9]+)([^>]*)>?$%', $string, $matches)) {    // Seriously malformed    return '';  }  $slash = trim($matches[1]);  $elem = &$matches[2];  $attrlist = &$matches[3];  if (!isset($allowed_html[strtolower($elem)])) {    // Disallowed HTML element    return '';  }  if ($slash != '') {    return "</$elem>";  }  // Is there a closing XHTML slash at the end of the attributes?  // In PHP 5.1.0+ we could count the changes, currently we need a separate match  $xhtml_slash = preg_match('%\s?/\s*$%', $attrlist) ? ' /' : '';  $attrlist = preg_replace('%(\s?)/\s*$%', '\1', $attrlist);  // Clean up attributes  $attr2 = implode(' ', _filter_xss_attributes($attrlist));  $attr2 = preg_replace('/[<>]/', '', $attr2);  $attr2 = strlen($attr2) ? ' '. $attr2 : '';  return "<$elem$attr2$xhtml_slash>";}/** * Processes a string of HTML attributes. * * @return *   Cleaned up version of the HTML attributes. */function _filter_xss_attributes($attr) {  $attrarr = array();  $mode = 0;  $attrname = '';  while (strlen($attr) != 0) {    // Was the last operation successful?    $working = 0;    switch ($mode) {      case 0:        // Attribute name, href for instance        if (preg_match('/^([-a-zA-Z]+)/', $attr, $match)) {          $attrname = strtolower($match[1]);          $skip = ($attrname == 'style' || substr($attrname, 0, 2) == 'on');          $working = $mode = 1;          $attr = preg_replace('/^[-a-zA-Z]+/', '', $attr);        }        break;      case 1:        // Equals sign or valueless ("selected")        if (preg_match('/^\s*=\s*/', $attr)) {          $working = 1; $mode = 2;          $attr = preg_replace('/^\s*=\s*/', '', $attr);          break;        }        if (preg_match('/^\s+/', $attr)) {          $working = 1; $mode = 0;          if (!$skip) {            $attrarr[] = $attrname;          }          $attr = preg_replace('/^\s+/', '', $attr);        }        break;      case 2:        // Attribute value, a URL after href= for instance        if (preg_match('/^"([^"]*)"(\s+|$)/', $attr, $match)) {          $thisval = filter_xss_bad_protocol($match[1]);          if (!$skip) {            $attrarr[] = "$attrname=\"$thisval\"";          }          $working = 1;          $mode = 0;          $attr = preg_replace('/^"[^"]*"(\s+|$)/', '', $attr);          break;        }        if (preg_match("/^'([^']*)'(\s+|$)/", $attr, $match)) {          $thisval = filter_xss_bad_protocol($match[1]);          if (!$skip) {            $attrarr[] = "$attrname='$thisval'";;          }          $working = 1; $mode = 0;          $attr = preg_replace("/^'[^']*'(\s+|$)/", '', $attr);          break;        }        if (preg_match("%^([^\s\"']+)(\s+|$)%", $attr, $match)) {          $thisval = filter_xss_bad_protocol($match[1]);          if (!$skip) {            $attrarr[] = "$attrname=\"$thisval\"";          }          $working = 1; $mode = 0;          $attr = preg_replace("%^[^\s\"']+(\s+|$)%", '', $attr);        }        break;    }    if ($working == 0) {      // not well formed, remove and try again      $attr = preg_replace('/        ^        (        "[^"]*("|$)     # - a string that starts with a double quote, up until the next double quote or the end of the string        |               # or        \'[^\']*(\'|$)| # - a string that starts with a quote, up until the next quote or the end of the string        |               # or        \S              # - a non-whitespace character        )*              # any number of the above three        \s*             # any number of whitespaces        /x', '', $attr);      $mode = 0;    }  }  // the attribute list ends with a valueless attribute like "selected"  if ($mode == 1) {    $attrarr[] = $attrname;  }  return $attrarr;}/** * Processes an HTML attribute value and ensures it does not contain an URL * with a disallowed protocol (e.g. javascript:) * * @param $string *   The string with the attribute value. * @param $decode *   Whether to decode entities in the $string. Set to FALSE if the $string *   is in plain text, TRUE otherwise. Defaults to TRUE. * @return *   Cleaned up and HTML-escaped version of $string. */function filter_xss_bad_protocol($string, $decode = TRUE) {  static $allowed_protocols;  if (!isset($allowed_protocols)) {    $allowed_protocols = array_flip(variable_get('filter_allowed_protocols', array('http', 'https', 'ftp', 'news', 'nntp', 'telnet', 'mailto', 'irc', 'ssh', 'sftp', 'webcal', 'rtsp')));  }  // Get the plain text representation of the attribute value (i.e. its meaning).  if ($decode) {    $string = decode_entities($string);  }  // Iteratively remove any invalid protocol found.  do {    $before = $string;    $colonpos = strpos($string, ':');    if ($colonpos > 0) {      // We found a colon, possibly a protocol. Verify.      $protocol = substr($string, 0, $colonpos);      // If a colon is preceded by a slash, question mark or hash, it cannot      // possibly be part of the URL scheme. This must be a relative URL,      // which inherits the (safe) protocol of the base document.      if (preg_match('![/?#]!', $protocol)) {        break;      }      // Per RFC2616, section 3.2.3 (URI Comparison) scheme comparison must be case-insensitive      // Check if this is a disallowed protocol.      if (!isset($allowed_protocols[strtolower($protocol)])) {        $string = substr($string, $colonpos + 1);      }    }  } while ($before != $string);  return check_plain($string);}/** * @} End of "Standard filters". */
<?php// $Id$/** * @file * User page callbacks for the comment module. *//** * Form builder; generate a comment editing form. * * @param $cid *   ID of the comment to be edited. * @ingroup forms */function comment_edit($cid) {  global $user;  $comment = db_fetch_object(db_query('SELECT c.*, u.uid, u.name AS registered_name, u.data FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d', $cid));  $comment = drupal_unpack($comment);  $comment->name = $comment->uid ? $comment->registered_name : $comment->name;  if (comment_access('edit', $comment)) {    return comment_form_box((array)$comment);  }  else {    drupal_access_denied();  }}/** * This function is responsible for generating a comment reply form. * There are several cases that have to be handled, including: *   - replies to comments *   - replies to nodes *   - attempts to reply to nodes that can no longer accept comments *   - respecting access permissions ('access comments', 'post comments', etc.) * * The node or comment that is being replied to must appear above the comment * form to provide the user context while authoring the comment. * * @param $node *   Every comment belongs to a node. This is that node. * * @param $pid *   Some comments are replies to other comments. In those cases, $pid is the parent *   comment's cid. * * @return *   The rendered parent node or comment plus the new comment form. */function comment_reply($node, $pid = NULL) {  // Set the breadcrumb trail.  drupal_set_breadcrumb(array(l(t('Home'), NULL), l($node->title, 'node/'. $node->nid)));  $op = isset($_POST['op']) ? $_POST['op'] : '';  $output = '';  if (user_access('access comments')) {    // The user is previewing a comment prior to submitting it.    if ($op == t('Preview')) {      if (user_access('post comments')) {        $output .= comment_form_box(array('pid' => $pid, 'nid' => $node->nid), NULL);      }      else {        drupal_set_message(t('You are not authorized to post comments.'), 'error');        drupal_goto("node/$node->nid");      }    }    else {      // $pid indicates that this is a reply to a comment.      if ($pid) {        // load the comment whose cid = $pid        if ($comment = db_fetch_object(db_query('SELECT c.*, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status = %d', $pid, COMMENT_PUBLISHED))) {          // If that comment exists, make sure that the current comment and the parent comment both          // belong to the same parent node.          if ($comment->nid != $node->nid) {            // Attempting to reply to a comment not belonging to the current nid.            drupal_set_message(t('The comment you are replying to does not exist.'), 'error');            drupal_goto("node/$node->nid");          }          // Display the parent comment          $comment = drupal_unpack($comment);          $comment->name = $comment->uid ? $comment->registered_name : $comment->name;          $output .= theme('comment_view', $comment, $node);        }        else {          drupal_set_message(t('The comment you are replying to does not exist.'), 'error');          drupal_goto("node/$node->nid");        }      }      // This is the case where the comment is in response to a node. Display the node.      else if (user_access('access content')) {        $output .= node_view($node);      }      // Should we show the reply box?      if (node_comment_mode($node->nid) != COMMENT_NODE_READ_WRITE) {        drupal_set_message(t("This discussion is closed: you can't post new comments."), 'error');        drupal_goto("node/$node->nid");      }      else if (user_access('post comments')) {        $output .= comment_form_box(array('pid' => $pid, 'nid' => $node->nid), t('Reply'));      }      else {        drupal_set_message(t('You are not authorized to post comments.'), 'error');        drupal_goto("node/$node->nid");      }    }  }  else {    drupal_set_message(t('You are not authorized to view comments.'), 'error');    drupal_goto("node/$node->nid");  }  return $output;}
<?php// $Id$/** * The main entry point for XML-RPC requests. * * @param $callbacks *   Array of external XML-RPC method names with the callbacks they map to. */function xmlrpc_server($callbacks) {  $xmlrpc_server = new stdClass();  // Define built-in XML-RPC method names  $defaults = array(      'system.multicall' => 'xmlrpc_server_multicall',    array(      'system.methodSignature',      'xmlrpc_server_method_signature',      array('array', 'string'),      'Returns an array describing the return type and required parameters of a method.'    ),    array(      'system.getCapabilities',      'xmlrpc_server_get_capabilities',      array('struct'),      'Returns a struct describing the XML-RPC specifications supported by this server.'    ),    array(      'system.listMethods',      'xmlrpc_server_list_methods',      array('array'),      'Returns an array of available methods on this server.'),    array(      'system.methodHelp',      'xmlrpc_server_method_help',      array('string', 'string'),      'Returns a documentation string for the specified method.')  );  // We build an array of all method names by combining the built-ins  // with those defined by modules implementing the _xmlrpc hook.  // Built-in methods are overridable.  foreach (array_merge($defaults, (array)$callbacks) as $key => $callback) {    // we could check for is_array($callback)    if (is_int($key)) {      $method = $callback[0];      $xmlrpc_server->callbacks[$method] = $callback[1];      $xmlrpc_server->signatures[$method] = $callback[2];      $xmlrpc_server->help[$method] = $callback[3];    }    else {      $xmlrpc_server->callbacks[$key] = $callback;      $xmlrpc_server->signatures[$key] = '';      $xmlrpc_server->help[$key] = '';    }  }  $data = file_get_contents('php://input');  if (!$data) {    die('XML-RPC server accepts POST requests only.');  }  $xmlrpc_server->message = xmlrpc_message($data);  if (!xmlrpc_message_parse($xmlrpc_server->message)) {    xmlrpc_server_error(-32700, t('Parse error. Request not well formed.'));  }  if ($xmlrpc_server->message->messagetype != 'methodCall') {    xmlrpc_server_error(-32600, t('Server error. Invalid XML-RPC. Request must be a methodCall.'));  }  if (!isset($xmlrpc_server->message->params)) {    $xmlrpc_server->message->params = array();  }  xmlrpc_server_set($xmlrpc_server);  $result = xmlrpc_server_call($xmlrpc_server, $xmlrpc_server->message->methodname, $xmlrpc_server->message->params);  if (is_object($result) && !empty($result->is_error)) {    xmlrpc_server_error($result);  }  // Encode the result  $r = xmlrpc_value($result);  // Create the XML  $xml = '<methodResponse>  <params>  <param>    <value>'.    xmlrpc_value_get_xml($r)    .'</value>  </param>  </params></methodResponse>';  // Send it  xmlrpc_server_output($xml);}/** * Throw an XML-RPC error. * * @param $error *   an error object OR integer error code * @param $message *   description of error, used only if integer error code was passed */function xmlrpc_server_error($error, $message = FALSE) {  if ($message && !is_object($error)) {    $error = xmlrpc_error($error, $message);  }  xmlrpc_server_output(xmlrpc_error_get_xml($error));}function xmlrpc_server_output($xml) {  $xml = '<?xml version="1.0"?>'."\n". $xml;  header('Connection: close');  header('Content-Length: '. strlen($xml));  header('Content-Type: text/xml');  header('Date: '. date('r'));  echo $xml;  exit;}/** * Store a copy of the request temporarily. * * @param $xmlrpc_server *   Request object created by xmlrpc_server(). */function xmlrpc_server_set($xmlrpc_server = NULL) {  static $server;  if (!isset($server)) {    $server = $xmlrpc_server;  }  return $server;}// Retrieve the stored request.function xmlrpc_server_get() {  return xmlrpc_server_set();}/** * Dispatch the request and any parameters to the appropriate handler. * * @param $xmlrpc_server * @param $methodname *   The external XML-RPC method name, e.g. 'system.methodHelp' * @param $args *   Array containing any parameters that were sent along with the request. */function xmlrpc_server_call($xmlrpc_server, $methodname, $args) {  // Make sure parameters are in an array  if ($args && !is_array($args)) {    $args = array($args);  }  // Has this method been mapped to a Drupal function by us or by modules?  if (!isset($xmlrpc_server->callbacks[$methodname])) {    return xmlrpc_error(-32601, t('Server error. Requested method @methodname not specified.', array("@methodname" => $xmlrpc_server->message->methodname)));  }  $method = $xmlrpc_server->callbacks[$methodname];  $signature = $xmlrpc_server->signatures[$methodname];  // If the method has a signature, validate the request against the signature  if (is_array($signature)) {    $ok = TRUE;    $return_type = array_shift($signature);    // Check the number of arguments    if (count($args) != count($signature)) {      return xmlrpc_error(-32602, t('Server error. Wrong number of method parameters.'));    }    // Check the argument types    foreach ($signature as $key => $type) {      $arg = $args[$key];      switch ($type) {        case 'int':        case 'i4':          if (is_array($arg) || !is_int($arg)) {            $ok = FALSE;          }          break;        case 'base64':        case 'string':          if (!is_string($arg)) {            $ok = FALSE;          }          break;        case 'boolean':          if ($arg !== FALSE && $arg !== TRUE) {            $ok = FALSE;          }          break;        case 'float':        case 'double':          if (!is_float($arg)) {            $ok = FALSE;          }          break;        case 'date':        case 'dateTime.iso8601':          if (!$arg->is_date) {            $ok = FALSE;          }          break;      }      if (!$ok) {        return xmlrpc_error(-32602, t('Server error. Invalid method parameters.'));      }    }  }  if (!function_exists($method)) {    return xmlrpc_error(-32601, t('Server error. Requested function @method does not exist.', array("@method" => $method)));  }  // Call the mapped function  return call_user_func_array($method, $args);}function xmlrpc_server_multicall($methodcalls) {  // See http://www.xmlrpc.com/discuss/msgReader$1208  $return = array();  $xmlrpc_server = xmlrpc_server_get();  foreach ($methodcalls as $call) {    $ok = TRUE;    if (!isset($call['methodName']) || !isset($call['params'])) {      $result = xmlrpc_error(3, t('Invalid syntax for system.multicall.'));      $ok = FALSE;    }    $method = $call['methodName'];    $params = $call['params'];    if ($method == 'system.multicall') {      $result = xmlrpc_error(-32600, t('Recursive calls to system.multicall are forbidden.'));    }    elseif ($ok) {      $result = xmlrpc_server_call($xmlrpc_server, $method, $params);    }    if ($result->is_error) {      $return[] = array(        'faultCode' => $result->code,        'faultString' => $result->message      );    }    else {      $return[] = $result;    }  }  return $return;}/** * XML-RPC method system.listMethods maps to this function. */function xmlrpc_server_list_methods() {  $xmlrpc_server = xmlrpc_server_get();  return array_keys($xmlrpc_server->callbacks);}/** * XML-RPC method system.getCapabilities maps to this function. * See http://groups.yahoo.com/group/xml-rpc/message/2897 */function xmlrpc_server_get_capabilities() {  return array(    'xmlrpc' => array(      'specUrl' => 'http://www.xmlrpc.com/spec',      'specVersion' => 1    ),    'faults_interop' => array(      'specUrl' => 'http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php',      'specVersion' => 20010516    ),    'system.multicall' => array(      'specUrl' => 'http://www.xmlrpc.com/discuss/msgReader$1208',      'specVersion' => 1    ),    'introspection' => array(    'specUrl' => 'http://scripts.incutio.com/xmlrpc/introspection.html',    'specVersion' => 1    )  );}/** * XML-RPC method system.methodSignature maps to this function. * * @param $methodname *   Name of method for which we return a method signature. * @return array *   An array of types representing the method signature of the *   function that the methodname maps to. The methodSignature of *   this function is 'array', 'string' because it takes an array *   and returns a string. */function xmlrpc_server_method_signature($methodname) {  $xmlrpc_server = xmlrpc_server_get();  if (!isset($xmlrpc_server->callbacks[$methodname])) {    return xmlrpc_error(-32601, t('Server error. Requested method @methodname not specified.', array("@methodname" => $methodname)));  }  if (!is_array($xmlrpc_server->signatures[$methodname])) {    return xmlrpc_error(-32601, t('Server error. Requested method @methodname signature not specified.', array("@methodname" => $methodname)));  }  // We array of types  $return = array();  foreach ($xmlrpc_server->signatures[$methodname] as $type) {    $return[] = $type;  }  return $return;}/** * XML-RPC method system.methodHelp maps to this function. * * @param $method *   Name of method for which we return a help string. */function xmlrpc_server_method_help($method) {  $xmlrpc_server = xmlrpc_server_get();  return $xmlrpc_server->help[$method];}
