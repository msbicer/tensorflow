<?php// $Id$/** * @file * Admin page callbacks for the trigger module. *//** * Build the form that allows users to assign actions to hooks. * * @param $type *   Name of hook. * @return *   HTML form. */function trigger_assign($type = NULL) {  // If no type is specified we default to node actions, since they  // are the most common.  if (!isset($type)) {    drupal_goto('admin/build/trigger/node');  }  if ($type == 'node') {    $type = 'nodeapi';  }  $output = '';  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $hook) {    if (isset($hook[$type])) {      foreach ($hook[$type] as $op => $description) {        $form_id = 'trigger_'. $type .'_'. $op .'_assign_form';        $output .= drupal_get_form($form_id, $type, $op, $description['runs when']);      }    }  }  return $output;}/** * Confirm removal of an assigned action. * * @param $hook * @param $op * @param $aid *   The action ID. * @ingroup forms * @see trigger_unassign_submit() */function trigger_unassign($form_state, $hook = NULL, $op = NULL, $aid = NULL) {  if (!($hook && $op && $aid)) {    drupal_goto('admin/build/trigger/assign');  }  $form['hook'] = array(    '#type' => 'value',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'value',    '#value' => $op,  );  $form['aid'] = array(    '#type' => 'value',    '#value' => $aid,  );  $action = actions_function_lookup($aid);  $actions = actions_get_all_actions();  $destination = 'admin/build/trigger/'. ($hook == 'nodeapi' ? 'node' : $hook);  return confirm_form($form,    t('Are you sure you want to unassign the action %title?', array('%title' => $actions[$action]['description'])),    $destination,    t('You can assign it again later if you wish.'),    t('Unassign'), t('Cancel')  );}function trigger_unassign_submit($form, &$form_state) {  $form_values = $form_state['values'];  if ($form_values['confirm'] == 1) {    $aid = actions_function_lookup($form_values['aid']);    db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid);    $actions = actions_get_all_actions();    watchdog('actions', 'Action %action has been unassigned.',  array('%action' => check_plain($actions[$aid]['description'])));    drupal_set_message(t('Action %action has been unassigned.', array('%action' => $actions[$aid]['description'])));    $hook = $form_values['hook'] == 'nodeapi' ? 'node' : $form_values['hook'];    $form_state['redirect'] = 'admin/build/trigger/'. $hook;  }  else {    drupal_goto('admin/build/trigger');  }}/** * Create the form definition for assigning an action to a hook-op combination. * * @param $form_state *   Information about the current form. * @param $hook *   The name of the hook, e.g., 'nodeapi'. * @param $op *   The name of the hook operation, e.g., 'insert'. * @param $description *   A plain English description of what this hook operation does. * @return * * @ingoup forms * @see trigger_assign_form_validate() * @see trigger_assign_form_submit() */function trigger_assign_form($form_state, $hook, $op, $description) {  $form['hook'] = array(    '#type' => 'hidden',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'hidden',    '#value' => $op,  );  // All of these forms use the same validate and submit functions.  $form['#validate'][] = 'trigger_assign_form_validate';  $form['#submit'][] = 'trigger_assign_form_submit';  $options = array();  $functions = array();  // Restrict the options list to actions that declare support for this hook-op  // combination.  foreach (actions_list() as $func => $metadata) {    if (isset($metadata['hooks']['any']) || (isset($metadata['hooks'][$hook]) && is_array($metadata['hooks'][$hook]) && (in_array($op, $metadata['hooks'][$hook])))) {      $functions[] = $func;    }  }  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {    if (in_array($action['callback'], $functions)) {      $options[$action['type']][$aid] = $action['description'];    }  }  $form[$op] = array(    '#type' => 'fieldset',    '#title' => t('Trigger: ') . $description,    '#theme' => 'trigger_display'    );  // Retrieve actions that are already assigned to this hook-op combination.  $actions = _trigger_get_hook_actions($hook, $op);  $form[$op]['assigned']['#type'] = 'value';  $form[$op]['assigned']['#value'] = array();  foreach ($actions as $aid => $description) {    $form[$op]['assigned']['#value'][$aid] = array(      'description' => $description,      'link' => l(t('unassign'), "admin/build/trigger/unassign/$hook/$op/". md5($aid))    );  }  $form[$op]['parent'] = array(    '#prefix' => "<div class='container-inline'>",    '#suffix' => '</div>',  );  // List possible actions that may be assigned.  if (count($options) != 0) {    array_unshift($options, t('Choose an action'));    $form[$op]['parent']['aid'] = array(      '#type' => 'select',      '#options' => $options,    );    $form[$op]['parent']['submit'] = array(      '#type' => 'submit',      '#value' => t('Assign')    );  }  else {    $form[$op]['none'] = array(      '#value' => t('No available actions for this trigger.')    );  }  return $form;}/** * Validation function for trigger_assign_form(). * * Makes sure that the user is not re-assigning an action to an event. */function trigger_assign_form_validate($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    if (db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid))) {      form_set_error($form_values['operation'], t('The action you chose is already assigned to that trigger.'));    }  }}/** * Submit function for trigger_assign_form(). */function trigger_assign_form_submit($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    $weight = db_result(db_query("SELECT MAX(weight) FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s'", $form_values['hook'], $form_values['operation']));    db_query("INSERT INTO {trigger_assignments} values ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], $aid, $weight + 1);    // If this action changes a node property, we need to save the node    // so the change will persist.    $actions = actions_list();    if (isset($actions[$aid]['behavior']) && in_array('changes_node_property', $actions[$aid]['behavior']) && ($form_values['operation'] != 'presave')) {      // Delete previous node_save_action if it exists, and re-add a new one at a higher weight.      $save_post_action_assigned = db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']));      if ($save_post_action_assigned) {        db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']);      }      db_query("INSERT INTO {trigger_assignments} VALUES ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], 'node_save_action', $weight + 2);      if (!$save_post_action_assigned) {        drupal_set_message(t('You have added an action that changes a the property of a post. A Save post action has been added so that the property change will be saved.'));      }    }  }}/** * Display actions assigned to this hook-op combination in a table. * * @param array $element *   The fieldset including all assigned actions. * @return *   The rendered form with the table prepended. * * @ingroup themeable */function theme_trigger_display($element) {  $header = array();  $rows = array();  if (count($element['assigned']['#value'])) {    $header = array(array('data' => t('Name')), array('data' => t('Operation')));    $rows = array();    foreach ($element['assigned']['#value'] as $aid => $info) {      $rows[] = array(        $info['description'],        $info['link']      );    }  }  if (count($rows)) {    $output = theme('table', $header, $rows) . drupal_render($element);  }  else {    $output = drupal_render($element);  }  return $output;}/** * Get the actions that have already been defined for this * type-hook-op combination. * * @param $type *   One of 'node', 'user', 'comment'. * @param $hook *   The name of the hook for which actions have been assigned, *   e.g. 'nodeapi'. * @param $op *   The hook operation for which the actions have been assigned, *   e.g., 'view'. * @return *   An array of action descriptions keyed by action IDs. */function _trigger_get_hook_actions($hook, $op, $type = NULL) {  $actions = array();  if ($type) {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE a.type = '%s' AND h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $type, $hook, $op);  }  else {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $hook, $op);  }  while ($action = db_fetch_object($result)) {    $actions[$action->aid] = $action->description;  }  return $actions;}
<?php// $Id$/** * Implementation of hook_install(). */function menu_install() {  // Create tables.  drupal_install_schema('menu');    $t = get_t();  db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", 'navigation', $t('Navigation'), $t('The navigation menu is provided by Drupal and is the main interactive menu for any site. It is usually the only menu that contains personalized links for authenticated users, and is often not even visible to anonymous users.'));  db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", 'primary-links', $t('Primary links'), $t('Primary links are often used at the theme layer to show the major sections of a site. A typical representation for primary links would be tabs along the top.'));  db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", 'secondary-links', $t('Secondary links'), $t('Secondary links are often used for pages like legal notices, contact details, and other secondary navigation items that play a lesser role than primary links'));}/** * Implementation of hook_uninstall(). */function menu_uninstall() {  // Remove tables.  drupal_uninstall_schema('menu');  menu_rebuild();}/** * Implementation of hook_schema(). */function menu_schema() {  $schema['menu_custom'] = array(    'description' => 'Holds definitions for top-level custom menus (for example, Primary Links).',    'fields' => array(      'menu_name' => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '',        'description' => 'Primary Key: Unique key for menu. This is used as a block delta so length is 32.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Menu title; displayed at top of block.',      ),      'description' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'Menu description.',      ),    ),    'primary key' => array('menu_name'),  );  return $schema;}
<?php// $Id$?><div id="node-<?php print $node->nid; ?>" class="node<?php if ($sticky) { print ' sticky'; } ?><?php if (!$status) { print ' node-unpublished'; } ?>"><?php print $picture ?><?php if ($page == 0): ?>  <h2><a href="<?php print $node_url ?>" title="<?php print $title ?>"><?php print $title ?></a></h2><?php endif; ?>  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted; ?></span>  <?php endif; ?>  <div class="content clear-block">    <?php print $content ?>  </div>  <div class="clear-block">    <div class="meta">    <?php if ($taxonomy): ?>      <div class="terms"><?php print $terms ?></div>    <?php endif;?>    </div>    <?php if ($links): ?>      <div class="links"><?php print $links; ?></div>    <?php endif; ?>  </div></div>
<?php// $Id$/** * Implementation of hook_schema(). */function filter_schema() {  $schema['filters'] = array(    'description' => 'Table that maps filters (HTML corrector) to input formats (Filtered HTML).',    'fields' => array(      'fid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Auto-incrementing filter ID.',      ),      'format' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Foreign key: The {filter_formats}.format to which this filter is assigned.',      ),      'module' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'The origin module of the filter.',      ),      'delta' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'ID to identify which filter within module is being referenced.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Weight of filter within format.',      )    ),    'primary key' => array('fid'),    'unique keys' => array(      'fmd' => array('format', 'module', 'delta'),    ),    'indexes' => array(      'list' => array('format', 'weight', 'module', 'delta'),    ),  );  $schema['filter_formats'] = array(    'description' => 'Stores input formats: custom groupings of filters, such as Filtered HTML.',    'fields' => array(      'format' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique ID for format.',      ),      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Name of the input format (Filtered HTML).',      ),      'roles' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'A comma-separated string of roles; references {role}.rid.', // This is bad since you can't use joins, nor index.      ),      'cache' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate whether format is cachable. (1 = cachable, 0 = not cachable)',      ),    ),    'primary key' => array('format'),    'unique keys' => array('name' => array('name')),  );  $schema['cache_filter'] = drupal_get_schema_unprocessed('system', 'cache');  $schema['cache_filter']['description'] = 'Cache table for the Filter module to store already filtered pieces of text, identified by input format and md5 hash of the text.';  return $schema;}
<?php// $Id$/** * @file * Admin page callbacks for the help module. *//** * Menu callback; prints a page listing a glossary of Drupal terminology. */function help_main() {  // Add CSS  drupal_add_css(drupal_get_path('module', 'help') .'/help.css', 'module', 'all', FALSE);  $output = '<h2>'. t('Help topics') .'</h2><p>'. t('Help is available on the following items:') .'</p>'. help_links_as_list();  return $output;}/** * Menu callback; prints a page listing general help for a module. */function help_page($name) {  $output = '';  if (module_hook($name, 'help')) {    $module = drupal_parse_info_file(drupal_get_path('module', $name) .'/'. $name .'.info');    drupal_set_title($module['name']);    $temp = module_invoke($name, 'help', "admin/help#$name", drupal_help_arg());    if (empty($temp)) {      $output .= t("No help is available for module %module.", array('%module' => $module['name']));    }    else {      $output .= $temp;    }    // Only print list of administration pages if the module in question has    // any such pages associated to it.    $admin_tasks = system_get_module_admin_tasks($name);    if (!empty($admin_tasks)) {      ksort($admin_tasks);      $output .= theme('item_list', $admin_tasks, t('@module administration pages', array('@module' => $module['name'])));    }  }  return $output;}function help_links_as_list() {  $empty_arg = drupal_help_arg();  $module_info = module_rebuild_cache();  $modules = array();  foreach (module_implements('help', TRUE) as $module) {    if (module_invoke($module, 'help', "admin/help#$module", $empty_arg)) {      $modules[$module] = $module_info[$module]->info['name'];    }  }  asort($modules);  // Output pretty four-column list  $count = count($modules);  $break = ceil($count / 4);  $output = '<div class="clear-block"><div class="help-items"><ul>';  $i = 0;  foreach ($modules as $module => $name) {    $output .= '<li>'. l($name, 'admin/help/'. $module) .'</li>';    if (($i + 1) % $break == 0 && ($i + 1) != $count) {      $output .= '</ul></div><div class="help-items'. ($i + 1 == $break * 3 ? ' help-items-last' : '') .'"><ul>';    }    $i++;  }  $output .= '</ul></div></div>';  return $output;}
<?php// $Id$/** * @file * Admin page callbacks for the statistics module. *//** * Menu callback; presents the "recent hits" page. */function statistics_recent_hits() {  $header = array(    array('data' => t('Timestamp'), 'field' => 'a.timestamp', 'sort' => 'desc'),    array('data' => t('Page'), 'field' => 'a.path'),    array('data' => t('User'), 'field' => 'u.name'),    array('data' => t('Operations'))  );  $sql = 'SELECT a.aid, a.path, a.title, a.uid, u.name, a.timestamp FROM {accesslog} a LEFT JOIN {users} u ON u.uid = a.uid'. tablesort_sql($header);  $result = pager_query($sql, 30);  $rows = array();  while ($log = db_fetch_object($result)) {    $rows[] = array(      array('data' => format_date($log->timestamp, 'small'), 'class' => 'nowrap'),      _statistics_format_item($log->title, $log->path),      theme('username', $log),      l(t('details'), "admin/reports/access/$log->aid"));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "top pages" page. */function statistics_top_pages() {  // MAX(title) avoids having empty node titles which otherwise causes duplicates in the top pages list  $sql = "SELECT COUNT(path) AS hits, path, MAX(title) AS title, AVG(timer) AS average_time, SUM(timer) AS total_time FROM {accesslog} GROUP BY path";  $sql_cnt = "SELECT COUNT(DISTINCT(path)) FROM {accesslog}";  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Page'), 'field' => 'path'),    array('data' => t('Average page generation time'), 'field' => 'average_time'),    array('data' => t('Total page generation time'), 'field' => 'total_time')  );  $sql .= tablesort_sql($header);  $result = pager_query($sql, 30, 0, $sql_cnt);  $rows = array();  while ($page = db_fetch_object($result)) {    $rows[] = array($page->hits, _statistics_format_item($page->title, $page->path), t('%time ms', array('%time' => round($page->average_time))), format_interval(round($page->total_time / 1000)));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  drupal_set_title(t('Top pages in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "top visitors" page. */function statistics_top_visitors() {  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Visitor'), 'field' => 'u.name'),    array('data' => t('Total page generation time'), 'field' => 'total'),    array('data' => t('Operations'))  );  $sql = "SELECT COUNT(a.uid) AS hits, a.uid, u.name, a.hostname, SUM(a.timer) AS total, ac.aid FROM {accesslog} a LEFT JOIN {access} ac ON ac.type = 'host' AND LOWER(a.hostname) LIKE (ac.mask) LEFT JOIN {users} u ON a.uid = u.uid GROUP BY a.hostname, a.uid, u.name, ac.aid". tablesort_sql($header);  $sql_cnt = "SELECT COUNT(DISTINCT(CONCAT(uid, hostname))) FROM {accesslog}";  $result = pager_query($sql, 30, 0, $sql_cnt);  $rows = array();  while ($account = db_fetch_object($result)) {    $qs = drupal_get_destination();    $ban_link = $account->aid ? l(t('unban'), "admin/user/rules/delete/$account->aid", array('query' => $qs)) : l(t('ban'), "admin/user/rules/add/$account->hostname/host", array('query' => $qs));    $rows[] = array($account->hits, ($account->uid ? theme('username', $account) : $account->hostname), format_interval(round($account->total / 1000)), $ban_link);  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  drupal_set_title(t('Top visitors in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "referrer" page. */function statistics_top_referrers() {  $query = "SELECT url, COUNT(url) AS hits, MAX(timestamp) AS last FROM {accesslog} WHERE url NOT LIKE '%%%s%%' AND url <> '' GROUP BY url";  $query_cnt = "SELECT COUNT(DISTINCT(url)) FROM {accesslog} WHERE url <> '' AND url NOT LIKE '%%%s%%'";  drupal_set_title(t('Top referrers in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Url'), 'field' => 'url'),    array('data' => t('Last visit'), 'field' => 'last'),  );  $query .= tablesort_sql($header);  $result = pager_query($query, 30, 0, $query_cnt, $_SERVER['HTTP_HOST']);  $rows = array();  while ($referrer = db_fetch_object($result)) {    $rows[] = array($referrer->hits, _statistics_link($referrer->url), t('@time ago', array('@time' => format_interval(time() - $referrer->last))));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 3));  }  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; Displays recent page accesses. */function statistics_access_log($aid) {  $result = db_query('SELECT a.*, u.name FROM {accesslog} a LEFT JOIN {users} u ON a.uid = u.uid WHERE aid = %d', $aid);  if ($access = db_fetch_object($result)) {    $rows[] = array(      array('data' => t('URL'), 'header' => TRUE),      l(url($access->path, array('absolute' => TRUE)), $access->path)    );    // It is safe to avoid filtering $access->title through check_plain because    // it comes from drupal_get_title().    $rows[] = array(      array('data' => t('Title'), 'header' => TRUE),      $access->title    );    $rows[] = array(      array('data' => t('Referrer'), 'header' => TRUE),      ($access->url ? l($access->url, $access->url) : '')    );    $rows[] = array(      array('data' => t('Date'), 'header' => TRUE),      format_date($access->timestamp, 'large')    );    $rows[] = array(      array('data' => t('User'), 'header' => TRUE),      theme('username', $access)    );    $rows[] = array(      array('data' => t('Hostname'), 'header' => TRUE),      check_plain($access->hostname)    );    return theme('table', array(), $rows);  }  else {    drupal_not_found();  }}/** * Form builder; Configure access logging. * * @ingroup forms * @see system_settings_form() */function statistics_access_logging_settings() {  // Access log settings:  $options = array('1' => t('Enabled'), '0' => t('Disabled'));  $form['access'] = array(    '#type' => 'fieldset',    '#title' => t('Access log settings'));  $form['access']['statistics_enable_access_log'] = array(    '#type' => 'radios',    '#title' => t('Enable access log'),    '#default_value' => variable_get('statistics_enable_access_log', 0),    '#options' => $options,    '#description' => t('Log each page access. Required for referrer statistics.'));  $period = drupal_map_assoc(array(3600, 10800, 21600, 32400, 43200, 86400, 172800, 259200, 604800, 1209600, 2419200, 4838400, 9676800), 'format_interval');  $form['access']['statistics_flush_accesslog_timer'] = array(    '#type' => 'select',    '#title' => t('Discard access logs older than'),    '#default_value'   => variable_get('statistics_flush_accesslog_timer', 259200),    '#options' => $period,    '#description' => t('Older access log entries (including referrer statistics) will be automatically discarded. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status'))));  // count content views settings  $form['content'] = array(    '#type' => 'fieldset',    '#title' => t('Content viewing counter settings'));  $form['content']['statistics_count_content_views'] = array(    '#type' => 'radios',    '#title' => t('Count content views'),    '#default_value' => variable_get('statistics_count_content_views', 0),    '#options' => $options,    '#description' => t('Increment a counter each time content is viewed.'));  return system_settings_form($form);}
<?php// $Id$/** * @file * Administrative page callbacks for the path module. *//** * Return a listing of all defined URL aliases. * When filter key passed, perform a standard search on the given key, * and return the list of matching URL aliases. */function path_admin_overview($keys = NULL) {  // Add the filter form above the overview table.  $output = drupal_get_form('path_admin_filter_form', $keys);  // Enable language column if locale is enabled or if we have any alias with language  $count = db_result(db_query("SELECT COUNT(*) FROM {url_alias} WHERE language != ''"));  $multilanguage = (module_exists('locale') || $count);  if ($keys) {    // Replace wildcards with MySQL/PostgreSQL wildcards.    $keys = preg_replace('!\*+!', '%', $keys);    $sql = "SELECT * FROM {url_alias} WHERE dst LIKE '%%%s%%'";  }  else {    $sql = 'SELECT * FROM {url_alias}';  }  $header = array(    array('data' => t('Alias'), 'field' => 'dst', 'sort' => 'asc'),    array('data' => t('System'), 'field' => 'src'),    array('data' => t('Operations'), 'colspan' => '2')  );  if ($multilanguage) {    $header[3] = $header[2];    $header[2] = array('data' => t('Language'), 'field' => 'language');  }  $sql .= tablesort_sql($header);  $result = pager_query($sql, 50, 0 , NULL, $keys);  $rows = array();  $destination = drupal_get_destination();  while ($data = db_fetch_object($result)) {    $row = array(check_plain($data->dst), check_plain($data->src), l(t('edit'), "admin/build/path/edit/$data->pid", array('query' => $destination)), l(t('delete'), "admin/build/path/delete/$data->pid", array('query' => $destination)));    if ($multilanguage) {      $row[4] = $row[3];      $row[3] = $row[2];      $row[2] = module_invoke('locale', 'language_name', $data->language);    }    $rows[] = $row;  }  if (empty($rows)) {    $empty_message = $keys ? t('No URL aliases found.') : t('No URL aliases available.') ;    $rows[] = array(array('data' => $empty_message, 'colspan' => ($multilanguage ? 5 : 4)));  }  $output .= theme('table', $header, $rows);  $output .= theme('pager', NULL, 50, 0);  return $output;}/** * Menu callback; handles pages for creating and editing URL aliases. */function path_admin_edit($pid = 0) {  if ($pid) {    $alias = path_load($pid);    drupal_set_title(check_plain($alias['dst']));    $output = drupal_get_form('path_admin_form', $alias);  }  else {    $output = drupal_get_form('path_admin_form');  }  return $output;}/** * Return a form for editing or creating an individual URL alias. * * @ingroup forms * @see path_admin_form_validate() * @see path_admin_form_submit() */function path_admin_form(&$form_state, $edit = array('src' => '', 'dst' => '', 'language' => '', 'pid' => NULL)) {  $form['#alias'] = $edit;  $form['src'] = array(    '#type' => 'textfield',    '#title' => t('Existing system path'),    '#default_value' => $edit['src'],    '#maxlength' => 128,    '#size' => 45,    '#description' => t('Specify the existing path you wish to alias. For example: node/28, forum/1, taxonomy/term/1+2.'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q='),    '#required' => TRUE,  );  $form['dst'] = array(    '#type' => 'textfield',    '#title' => t('Path alias'),    '#default_value' => $edit['dst'],    '#maxlength' => 128,    '#size' => 45,    '#description' => t('Specify an alternative path by which this data can be accessed. For example, type "about" when writing an about page. Use a relative path and don\'t add a trailing slash or the URL alias won\'t work.'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q='),    '#required' => TRUE,  );  // This will be a hidden value unless locale module is enabled  $form['language'] = array(    '#type' => 'value',    '#value' => $edit['language']  );  if ($edit['pid']) {    $form['pid'] = array('#type' => 'hidden', '#value' => $edit['pid']);    $form['submit'] = array('#type' => 'submit', '#value' => t('Update alias'));  }  else {    $form['submit'] = array('#type' => 'submit', '#value' => t('Create new alias'));  }  return $form;}/** * Verify that a new URL alias is valid */function path_admin_form_validate($form, &$form_state) {  $src = $form_state['values']['src'];  $dst = $form_state['values']['dst'];  $pid = isset($form_state['values']['pid']) ? $form_state['values']['pid'] : 0;  // Language is only set if locale module is enabled, otherwise save for all languages.  $language = isset($form_state['values']['language']) ? $form_state['values']['language'] : '';  if (db_result(db_query("SELECT COUNT(dst) FROM {url_alias} WHERE pid != %d AND dst = '%s' AND language = '%s'", $pid, $dst, $language))) {    form_set_error('dst', t('The alias %alias is already in use in this language.', array('%alias' => $dst)));  }  $item = menu_get_item($src);  if (!$item || !$item['access']) {    form_set_error('src', t("The path '@link_path' is either invalid or you do not have access to it.", array('@link_path' => $src)));  }}/** * Save a new URL alias to the database. */function path_admin_form_submit($form, &$form_state) {  // Language is only set if locale module is enabled  path_set_alias($form_state['values']['src'], $form_state['values']['dst'], isset($form_state['values']['pid']) ? $form_state['values']['pid'] : 0, isset($form_state['values']['language']) ? $form_state['values']['language'] : '');  drupal_set_message(t('The alias has been saved.'));  $form_state['redirect'] = 'admin/build/path';  return;}/** * Menu callback; confirms deleting an URL alias */function path_admin_delete_confirm($form_state, $pid) {  $path = path_load($pid);  if (user_access('administer url aliases')) {    $form['pid'] = array('#type' => 'value', '#value' => $pid);    $output = confirm_form($form,      t('Are you sure you want to delete path alias %title?', array('%title' => $path['dst'])),      isset($_GET['destination']) ? $_GET['destination'] : 'admin/build/path');  }  return $output;}/** * Execute URL alias deletion */function path_admin_delete_confirm_submit($form, &$form_state) {  if ($form_state['values']['confirm']) {    path_admin_delete($form_state['values']['pid']);    $form_state['redirect'] = 'admin/build/path';    return;  }}/** * Return a form to filter URL aliases. * * @ingroup forms * @see path_admin_filter_form_submit() */function path_admin_filter_form(&$form_state, $keys = '') {  $form['#attributes'] = array('class' => 'search-form');  $form['basic'] = array('#type' => 'fieldset',    '#title' => t('Filter aliases')  );  $form['basic']['inline'] = array('#prefix' => '<div class="container-inline">', '#suffix' => '</div>');  $form['basic']['inline']['filter'] = array(    '#type' => 'textfield',    '#title' => '',    '#default_value' => $keys,    '#maxlength' => 128,    '#size' => 25,  );  $form['basic']['inline']['submit'] = array(    '#type' => 'submit',    '#value' => t('Filter'),    '#submit' => array('path_admin_filter_form_submit_filter'),    );  if ($keys) {    $form['basic']['inline']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset'),      '#submit' => array('path_admin_filter_form_submit_reset'),    );  }  return $form;}/** * Process filter form submission when the Filter button is pressed. */function path_admin_filter_form_submit_filter($form, &$form_state) {  $form_state['redirect'] = 'admin/build/path/list/'. trim($form_state['values']['filter']);}/** * Process filter form submission when the Reset button is pressed. */function path_admin_filter_form_submit_reset($form, &$form_state) {  $form_state['redirect'] = 'admin/build/path/list';}/** * Helper function for grabbing filter keys. */function path_admin_filter_get_keys() {  // Extract keys as remainder of path  $path = explode('/', $_GET['q'], 5);  return count($path) == 5 ? $path[4] : '';}
<?php// $Id$/** * @file * Admin page callbacks for the search module. *//** * Menu callback: confirm wiping of the index. */function search_wipe_confirm() {  return confirm_form(array(), t('Are you sure you want to re-index the site?'),                  'admin/settings/search', t(' The search index is not cleared but systematically updated to reflect the new settings. Searching will continue to work but new content won\'t be indexed until all existing content has been re-indexed. This action cannot be undone.'), t('Re-index site'), t('Cancel'));}/** * Handler for wipe confirmation */function search_wipe_confirm_submit(&$form, &$form_state) {  if ($form['confirm']) {    search_wipe();    drupal_set_message(t('The index will be rebuilt.'));    $form_state['redirect'] = 'admin/settings/search';    return;  }}/** * Menu callback; displays the search module settings page. * * @ingroup forms * @see system_settings_form() * @see search_admin_settings_validate() */function search_admin_settings() {  // Collect some stats  $remaining = 0;  $total = 0;  foreach (module_list() as $module) {    if (module_hook($module, 'search')) {      $status = module_invoke($module, 'search', 'status');      $remaining += $status['remaining'];      $total += $status['total'];    }  }  $count = format_plural($remaining, 'There is 1 item left to index.', 'There are @count items left to index.');  $percentage = ((int)min(100, 100 * ($total - $remaining) / max(1, $total))) .'%';  $status = '<p><strong>'. t('%percentage of the site has been indexed.', array('%percentage' => $percentage)) .' '. $count .'</strong></p>';  $form['status'] = array('#type' => 'fieldset', '#title' => t('Indexing status'));  $form['status']['status'] = array('#value' => $status);  $form['status']['wipe'] = array('#type' => 'submit', '#value' => t('Re-index site'));  $items = drupal_map_assoc(array(10, 20, 50, 100, 200, 500));  // Indexing throttle:  $form['indexing_throttle'] = array('#type' => 'fieldset', '#title' => t('Indexing throttle'));  $form['indexing_throttle']['search_cron_limit'] = array('#type' => 'select', '#title' => t('Number of items to index per cron run'), '#default_value' => variable_get('search_cron_limit', 100), '#options' => $items, '#description' => t('The maximum number of items indexed in each pass of a <a href="@cron">cron maintenance task</a>. If necessary, reduce the number of items to prevent timeouts and memory errors while indexing.', array('@cron' => url('admin/reports/status'))));  // Indexing settings:  $form['indexing_settings'] = array('#type' => 'fieldset', '#title' => t('Indexing settings'));  $form['indexing_settings']['info'] = array('#value' => t('<p><em>Changing the settings below will cause the site index to be rebuilt. The search index is not cleared but systematically updated to reflect the new settings. Searching will continue to work but new content won\'t be indexed until all existing content has been re-indexed.</em></p><p><em>The default settings should be appropriate for the majority of sites.</em></p>'));  $form['indexing_settings']['minimum_word_size'] = array('#type' => 'textfield', '#title' => t('Minimum word length to index'), '#default_value' => variable_get('minimum_word_size', 3), '#size' => 5, '#maxlength' => 3, '#description' => t('The number of characters a word has to be to be indexed. A lower setting means better search result ranking, but also a larger database. Each search query must contain at least one keyword that is this size (or longer).'));  $form['indexing_settings']['overlap_cjk'] = array('#type' => 'checkbox', '#title' => t('Simple CJK handling'), '#default_value' => variable_get('overlap_cjk', TRUE), '#description' => t('Whether to apply a simple Chinese/Japanese/Korean tokenizer based on overlapping sequences. Turn this off if you want to use an external preprocessor for this instead. Does not affect other languages.'));  $form['#validate'] = array('search_admin_settings_validate');  // Per module settings  $form = array_merge($form, module_invoke_all('search', 'admin'));  return system_settings_form($form);}/** * Validate callback. */function search_admin_settings_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Re-index site')) {    drupal_goto('admin/settings/search/wipe');  }  // If these settings change, the index needs to be rebuilt.  if ((variable_get('minimum_word_size', 3) != $form_state['values']['minimum_word_size']) ||      (variable_get('overlap_cjk', TRUE) != $form_state['values']['overlap_cjk'])) {    drupal_set_message(t('The index will be rebuilt.'));    search_wipe();  }}
<?php// $Id$/** * @file * Additional filter for PHP input. *//** * Implementation of hook_help(). */function php_help($path, $arg) {  switch ($path) {    case 'admin/help#php':      $output = '<p>'. t('The PHP filter adds the ability to include PHP code in posts. PHP is a general-purpose scripting language widely-used for web development; the content management system used by this website has been developed using PHP.') .'</p>';      $output .= '<p>'. t('Through the PHP filter, users with the proper permission may include custom PHP code within a page of the site. While this is a powerful and flexible feature if used by a trusted user with PHP experience, it is a significant and dangerous security risk in the hands of a malicious user. Even a trusted user may accidentally compromise the site by entering malformed or incorrect PHP code. Only the most trusted users should be granted permission to use the PHP filter, and all PHP code added through the PHP filter should be carefully examined before use.') .'</p>';      $output .= '<p>'. t('<a href="@drupal">Drupal.org</a> offers <a href="@php-snippets">some example PHP snippets</a>, or you can create your own with some PHP experience and knowledge of the Drupal system.', array('@drupal' => url('http://drupal.org'), '@php-snippets' => url('http://drupal.org/handbook/customization/php-snippets'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@php">PHP module</a>.', array('@php' => 'http://drupal.org/handbook/modules/php/')) .'</p>';      return $output;  }}/** * Implementation of hook_filter_tips(). */function php_filter_tips($delta, $format, $long = false) {  global $base_url;  if ($delta == 0) {    switch ($long) {      case 0:        return t('You may post PHP code. You should include &lt;?php ?&gt; tags.');      case 1:        $output = '<h4>'. t('Using custom PHP code') .'</h4>';        $output .= '<p>'. t('Custom PHP code may be embedded in some types of site content, including posts and blocks. While embedding PHP code inside a post or block is a powerful and flexible feature when used by a trusted user with PHP experience, it is a significant and dangerous security risk when used improperly. Even a small mistake when posting PHP code may accidentally compromise your site.') .'</p>';        $output .= '<p>'. t('If you are unfamiliar with PHP, SQL, or Drupal, avoid using custom PHP code within posts. Experimenting with PHP may corrupt your database, render your site inoperable, or significantly compromise security.') .'</p>';        $output .= '<p>'. t('Notes:') .'</p>';        $output .= '<ul><li>'. t('Remember to double-check each line for syntax and logic errors <strong>before</strong> saving.') .'</li>';        $output .= '<li>'. t('Statements must be correctly terminated with semicolons.') .'</li>';        $output .= '<li>'. t('Global variables used within your PHP code retain their values after your script executes.') .'</li>';        $output .= '<li>'. t('<code>register_globals</code> is <strong>turned off</strong>. If you need to use forms, understand and use the functions in <a href="@formapi">the Drupal Form API</a>.', array('@formapi' => url('http://api.drupal.org/api/group/form_api/6'))) .'</li>';        $output .= '<li>'. t('Use a <code>print</code> or <code>return</code> statement in your code to output content.') .'</li>';        $output .= '<li>'. t('Develop and test your PHP code using a separate test script and sample database before deploying on a production site.') .'</li>';        $output .= '<li>'. t('Consider including your custom PHP code within a site-specific module or <code>template.php</code> file rather than embedding it directly into a post or block.') .'</li>';        $output .= '<li>'. t('Be aware that the ability to embed PHP code within content is provided by the PHP Filter module. If this module is disabled or deleted, then blocks and posts with embedded PHP may display, rather than execute, the PHP code.') .'</li></ul>';        $output .= '<p>'. t('A basic example: <em>Creating a "Welcome" block that greets visitors with a simple message.</em>') .'</p>';        $output .= '<ul><li>'. t('<p>Add a custom block to your site, named "Welcome". With its input format set to "PHP code" (or another format supporting PHP input), add the following in the Block body:</p><pre>print t(\'Welcome visitor! Thank you for visiting.\');</pre>') .'</li>';        $output .= '<li>'. t('<p>To display the name of a registered user, use this instead:</p><pre>global $user;if ($user->uid) {  print t(\'Welcome @name! Thank you for visiting.\', array(\'@name\' => $user->name));}else {  print t(\'Welcome visitor! Thank you for visiting.\');}</pre>') .'</li></ul>';        $output .= '<p>'. t('<a href="@drupal">Drupal.org</a> offers <a href="@php-snippets">some example PHP snippets</a>, or you can create your own with some PHP experience and knowledge of the Drupal system.', array('@drupal' => url('http://drupal.org'), '@php-snippets' => url('http://drupal.org/handbook/customization/php-snippets'))) .'</p>';        return $output;    }  }}/** * Implementation of hook_filter(). Contains a basic PHP evaluator. * * Executes PHP code. Use with care. */function php_filter($op, $delta = 0, $format = -1, $text = '') {  switch ($op) {    case 'list':      return array(0 => t('PHP evaluator'));    case 'no cache':      // No caching for the PHP evaluator.      return $delta == 0;    case 'description':      return t('Executes a piece of PHP code. The usage of this filter should be restricted to administrators only!');    case 'process':      return drupal_eval($text);    default:      return $text;  }}
<?php// $Id$/** * Implementation of hook_install(). */function openid_install() {  // Create table.  drupal_install_schema('openid');}/** * Implementation of hook_uninstall(). */function openid_uninstall() {  // Remove table.  drupal_uninstall_schema('openid');}/** * Implementation of hook_schema(). */function openid_schema() {  $schema['openid_association'] = array(    'description' => 'Stores temporary shared key association information for OpenID authentication.',    'fields' => array(      'idp_endpoint_uri' => array(        'type' => 'varchar',        'length' => 255,        'description' => 'URI of the OpenID Provider endpoint.',      ),      'assoc_handle' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'description' => 'Primary Key: Used to refer to this association in subsequent messages.',      ),      'assoc_type' => array(        'type' => 'varchar',        'length' => 32,        'description' => 'The signature algorithm used: one of HMAC-SHA1 or HMAC-SHA256.',      ),      'session_type' => array(        'type' => 'varchar',        'length' => 32,        'description' => 'Valid association session types: "no-encryption", "DH-SHA1", and "DH-SHA256".',      ),      'mac_key' => array(        'type' => 'varchar',        'length' => 255,        'description' => 'The MAC key (shared secret) for this association.',      ),      'created' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'UNIX timestamp for when the association was created.',      ),      'expires_in' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The lifetime, in seconds, of this association.',      ),    ),    'primary key' => array('assoc_handle'),  );  return $schema;}
<?php// $Id$require_once './includes/install.inc';define('MAINTENANCE_MODE', 'install');/** * The Drupal installation happens in a series of steps. We begin by verifying * that the current environment meets our minimum requirements. We then go * on to verify that settings.php is properly configured. From there we * connect to the configured database and verify that it meets our minimum * requirements. Finally we can allow the user to select an installation * profile and complete the installation process. * * @param $phase *   The installation phase we should proceed to. */function install_main() {  require_once './includes/bootstrap.inc';  drupal_bootstrap(DRUPAL_BOOTSTRAP_CONFIGURATION);  // This must go after drupal_bootstrap(), which unsets globals!  global $profile, $install_locale, $conf;  require_once './modules/system/system.install';  require_once './includes/file.inc';  // Ensure correct page headers are sent (e.g. caching)  drupal_page_header();  // Set up $language, so t() caller functions will still work.  drupal_init_language();  // Load module basics (needed for hook invokes).  include_once './includes/module.inc';  $module_list['system']['filename'] = 'modules/system/system.module';  $module_list['filter']['filename'] = 'modules/filter/filter.module';  module_list(TRUE, FALSE, FALSE, $module_list);  drupal_load('module', 'system');  drupal_load('module', 'filter');  // Install profile chosen, set the global immediately.  // This needs to be done before the theme cache gets   // initialized in drupal_maintenance_theme().  if (!empty($_GET['profile'])) {    $profile = preg_replace('/[^a-zA-Z_0-9]/', '', $_GET['profile']);  }  // Set up theme system for the maintenance page.  drupal_maintenance_theme();  // Check existing settings.php.  $verify = install_verify_settings();  if ($verify) {    // Since we have a database connection, we use the normal cache system.    // This is important, as the installer calls into the Drupal system for    // the clean URL checks, so we should maintain the cache properly.    require_once './includes/cache.inc';    $conf['cache_inc'] = './includes/cache.inc';    // Establish a connection to the database.    require_once './includes/database.inc';    db_set_active();    // Check if Drupal is installed.    $task = install_verify_drupal();    if ($task == 'done') {      install_already_done_error();    }  }  else {    // Since no persistent storage is available yet, and functions that check    // for cached data will fail, we temporarily replace the normal cache    // system with a stubbed-out version that short-circuits the actual    // caching process and avoids any errors.    require_once './includes/cache-install.inc';    $conf['cache_inc'] = './includes/cache-install.inc';    $task = NULL;  }  // No profile was passed in GET, ask the user.  if (empty($_GET['profile'])) {    if ($profile = install_select_profile()) {      install_goto("install.php?profile=$profile");    }    else {      install_no_profile_error();    }  }  // Load the profile.  require_once "./profiles/$profile/$profile.profile";  // Locale selection  if (!empty($_GET['locale'])) {    $install_locale = preg_replace('/[^a-zA-Z_0-9\-]/', '', $_GET['locale']);  }  elseif (($install_locale = install_select_locale($profile)) !== FALSE) {    install_goto("install.php?profile=$profile&locale=$install_locale");  }  // Tasks come after the database is set up  if (!$task) {    global $db_url;    if (!$verify && !empty($db_url)) {      // Do not install over a configured settings.php.      install_already_done_error();    }    // Check the installation requirements for Drupal and this profile.    install_check_requirements($profile, $verify);    // Verify existence of all required modules.    $modules = drupal_verify_profile($profile, $install_locale);    // If any error messages are set now, it means a requirement problem.    $messages = drupal_set_message();    if (!empty($messages['error'])) {      install_task_list('requirements');      drupal_set_title(st('Requirements problem'));      print theme('install_page', '');      exit;    }    // Change the settings.php information if verification failed earlier.    // Note: will trigger a redirect if database credentials change.    if (!$verify) {      install_change_settings($profile, $install_locale);    }    // Install system.module.    drupal_install_system();    // Save the list of other modules to install for the 'profile-install'    // task. variable_set() can be used now that system.module is installed    // and drupal is bootstrapped.    variable_set('install_profile_modules', array_diff($modules, array('system')));  }  // The database is set up, turn to further tasks.  install_tasks($profile, $task);}/** * Verify if Drupal is installed. */function install_verify_drupal() {  // Read the variable manually using the @ so we don't trigger an error if it fails.  $result = @db_query("SELECT value FROM {variable} WHERE name = '%s'", 'install_task');  if ($result) {    return unserialize(db_result($result));  }}/** * Verify existing settings.php */function install_verify_settings() {  global $db_prefix, $db_type, $db_url;  // Verify existing settings (if any).  if (!empty($db_url)) {    // We need this because we want to run form_get_errors.    include_once './includes/form.inc';    $url = parse_url(is_array($db_url) ? $db_url['default'] : $db_url);    $db_user = urldecode($url['user']);    $db_pass = isset($url['pass']) ? urldecode($url['pass']) : NULL;    $db_host = urldecode($url['host']);    $db_port = isset($url['port']) ? urldecode($url['port']) : '';    $db_path = ltrim(urldecode($url['path']), '/');    $settings_file = './'. conf_path(FALSE, TRUE) .'/settings.php';    $form_state = array();    _install_settings_form_validate($db_prefix, $db_type, $db_user, $db_pass, $db_host, $db_port, $db_path, $settings_file, $form_state);    if (!form_get_errors()) {      return TRUE;    }  }  return FALSE;}/** * Configure and rewrite settings.php. */function install_change_settings($profile = 'default', $install_locale = '') {  global $db_url, $db_type, $db_prefix;  $url = parse_url(is_array($db_url) ? $db_url['default'] : $db_url);  $db_user = isset($url['user']) ? urldecode($url['user']) : '';  $db_pass = isset($url['pass']) ? urldecode($url['pass']) : '';  $db_host = isset($url['host']) ? urldecode($url['host']) : '';  $db_port = isset($url['port']) ? urldecode($url['port']) : '';  $db_path = ltrim(urldecode($url['path']), '/');  $conf_path = './'. conf_path(FALSE, TRUE);  $settings_file = $conf_path .'/settings.php';  // We always need this because we want to run form_get_errors.  include_once './includes/form.inc';  install_task_list('database');  $output = drupal_get_form('install_settings_form', $profile, $install_locale, $settings_file, $db_url, $db_type, $db_prefix, $db_user, $db_pass, $db_host, $db_port, $db_path);  drupal_set_title(st('Database configuration'));  print theme('install_page', $output);  exit;}/** * Form API array definition for install_settings. */function install_settings_form(&$form_state, $profile, $install_locale, $settings_file, $db_url, $db_type, $db_prefix, $db_user, $db_pass, $db_host, $db_port, $db_path) {  if (empty($db_host)) {    $db_host = 'localhost';  }  $db_types = drupal_detect_database_types();  // If both 'mysql' and 'mysqli' are available, we disable 'mysql':  if (isset($db_types['mysqli'])) {    unset($db_types['mysql']);  }  if (count($db_types) == 0) {    $form['no_db_types'] = array(      '#value' => st('Your web server does not appear to support any common database types. Check with your hosting provider to see if they offer any databases that <a href="@drupal-databases">Drupal supports</a>.', array('@drupal-databases' => 'http://drupal.org/node/270#database')),    );  }  else {    $form['basic_options'] = array(      '#type' => 'fieldset',      '#title' => st('Basic options'),      '#description' => '<p>'. st('To set up your @drupal database, enter the following information.', array('@drupal' => drupal_install_profile_name())) .'</p>',    );    if (count($db_types) > 1) {      $form['basic_options']['db_type'] = array(        '#type' => 'radios',        '#title' => st('Database type'),        '#required' => TRUE,        '#options' => $db_types,        '#default_value' => ($db_type ? $db_type : current($db_types)),        '#description' => st('The type of database your @drupal data will be stored in.', array('@drupal' => drupal_install_profile_name())),      );      $db_path_description = st('The name of the database your @drupal data will be stored in. It must exist on your server before @drupal can be installed.', array('@drupal' => drupal_install_profile_name()));    }    else {      if (count($db_types) == 1) {        $db_types = array_values($db_types);        $form['basic_options']['db_type'] = array(          '#type' => 'hidden',          '#value' => $db_types[0],        );        $db_path_description = st('The name of the %db_type database your @drupal data will be stored in. It must exist on your server before @drupal can be installed.', array('%db_type' => $db_types[0], '@drupal' => drupal_install_profile_name()));      }    }    // Database name    $form['basic_options']['db_path'] = array(      '#type' => 'textfield',      '#title' => st('Database name'),      '#default_value' => $db_path,      '#size' => 45,      '#required' => TRUE,      '#description' => $db_path_description    );    // Database username    $form['basic_options']['db_user'] = array(      '#type' => 'textfield',      '#title' => st('Database username'),      '#default_value' => $db_user,      '#size' => 45,      '#required' => TRUE,    );    // Database username    $form['basic_options']['db_pass'] = array(      '#type' => 'password',      '#title' => st('Database password'),      '#default_value' => $db_pass,      '#size' => 45,    );    $form['advanced_options'] = array(      '#type' => 'fieldset',      '#title' => st('Advanced options'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#description' => st("These options are only necessary for some sites. If you're not sure what you should enter here, leave the default settings or check with your hosting provider.")    );    // Database host    $form['advanced_options']['db_host'] = array(      '#type' => 'textfield',      '#title' => st('Database host'),      '#default_value' => $db_host,      '#size' => 45,      // Hostnames can be 255 characters long.      '#maxlength' => 255,      '#required' => TRUE,      '#description' => st('If your database is located on a different server, change this.'),    );    // Database port    $form['advanced_options']['db_port'] = array(      '#type' => 'textfield',      '#title' => st('Database port'),      '#default_value' => $db_port,      '#size' => 45,      // The maximum port number is 65536, 5 digits.      '#maxlength' => 5,      '#description' => st('If your database server is listening to a non-standard port, enter its number.'),    );    // Table prefix    $prefix = ($profile == 'default') ? 'drupal_' : $profile .'_';    $form['advanced_options']['db_prefix'] = array(      '#type' => 'textfield',      '#title' => st('Table prefix'),      '#default_value' => $db_prefix,      '#size' => 45,      '#description' => st('If more than one application will be sharing this database, enter a table prefix such as %prefix for your @drupal site here.', array('@drupal' => drupal_install_profile_name(), '%prefix' => $prefix)),    );    $form['save'] = array(      '#type' => 'submit',      '#value' => st('Save and continue'),    );    $form['errors'] = array();    $form['settings_file'] = array('#type' => 'value', '#value' => $settings_file);    $form['_db_url'] = array('#type' => 'value');    $form['#action'] = "install.php?profile=$profile". ($install_locale ? "&locale=$install_locale" : '');    $form['#redirect'] = FALSE;  }  return $form;}/** * Form API validate for install_settings form. */function install_settings_form_validate($form, &$form_state) {  global $db_url;  _install_settings_form_validate($form_state['values']['db_prefix'], $form_state['values']['db_type'], $form_state['values']['db_user'], $form_state['values']['db_pass'], $form_state['values']['db_host'], $form_state['values']['db_port'], $form_state['values']['db_path'], $form_state['values']['settings_file'], $form_state, $form);}/** * Helper function for install_settings_validate. */function _install_settings_form_validate($db_prefix, $db_type, $db_user, $db_pass, $db_host, $db_port, $db_path, $settings_file, &$form_state, $form = NULL) {  global $db_url;  // Verify the table prefix  if (!empty($db_prefix) && is_string($db_prefix) && !preg_match('/^[A-Za-z0-9_.]+$/', $db_prefix)) {    form_set_error('db_prefix', st('The database table prefix you have entered, %db_prefix, is invalid. The table prefix can only contain alphanumeric characters, periods, or underscores.', array('%db_prefix' => $db_prefix)), 'error');  }  if (!empty($db_port) && !is_numeric($db_port)) {    form_set_error('db_port', st('Database port must be a number.'));  }  // Check database type  if (!isset($form)) {    $_db_url = is_array($db_url) ? $db_url['default'] : $db_url;    $db_type = substr($_db_url, 0, strpos($_db_url, '://'));  }  $databases = drupal_detect_database_types();  if (!in_array($db_type, $databases)) {    form_set_error('db_type', st("In your %settings_file file you have configured @drupal to use a %db_type server, however your PHP installation currently does not support this database type.", array('%settings_file' => $settings_file, '@drupal' => drupal_install_profile_name(), '%db_type' => $db_type)));  }  else {    // Verify    $db_url = $db_type .'://'. urlencode($db_user) . ($db_pass ? ':'. urlencode($db_pass) : '') .'@'. ($db_host ? urlencode($db_host) : 'localhost') . ($db_port ? ":$db_port" : '') .'/'. urlencode($db_path);    if (isset($form)) {      form_set_value($form['_db_url'], $db_url, $form_state);    }    $success = array();    $function = 'drupal_test_'. $db_type;    if (!$function($db_url, $success)) {      if (isset($success['CONNECT'])) {        form_set_error('db_type', st('In order for Drupal to work, and to continue with the installation process, you must resolve all permission issues reported above. We were able to verify that we have permission for the following commands: %commands. For more help with configuring your database server, see the <a href="http://drupal.org/node/258">Installation and upgrading handbook</a>. If you are unsure what any of this means you should probably contact your hosting provider.', array('%commands' => implode($success, ', '))));      }      else {        form_set_error('db_type', '');      }    }  }}/** * Form API submit for install_settings form. */function install_settings_form_submit($form, &$form_state) {  global $profile, $install_locale;  // Update global settings array and save  $settings['db_url'] = array(    'value'    => $form_state['values']['_db_url'],    'required' => TRUE,  );  $settings['db_prefix'] = array(    'value'    => $form_state['values']['db_prefix'],    'required' => TRUE,  );  drupal_rewrite_settings($settings);  // Continue to install profile step  install_goto("install.php?profile=$profile". ($install_locale ? "&locale=$install_locale" : ''));}/** * Find all .profile files. */function install_find_profiles() {  return file_scan_directory('./profiles', '\.profile$', array('.', '..', 'CVS'), 0, TRUE, 'name', 0);}/** * Allow admin to select which profile to install. * * @return *   The selected profile. */function install_select_profile() {  include_once './includes/form.inc';  $profiles = install_find_profiles();  // Don't need to choose profile if only one available.  if (sizeof($profiles) == 1) {    $profile = array_pop($profiles);    require_once $profile->filename;    return $profile->name;  }  elseif (sizeof($profiles) > 1) {    foreach ($profiles as $profile) {      if (!empty($_POST['profile']) && ($_POST['profile'] == $profile->name)) {        return $profile->name;      }    }    install_task_list('profile-select');    drupal_set_title(st('Select an installation profile'));    print theme('install_page', drupal_get_form('install_select_profile_form', $profiles));    exit;  }}/** * Form API array definition for the profile selection form. * * @param $form_state *   Array of metadata about state of form processing. * @param $profile_files *   Array of .profile files, as returned from file_scan_directory(). */function install_select_profile_form(&$form_state, $profile_files) {  $profiles = array();  $names = array();  foreach ($profile_files as $profile) {    include_once($profile->filename);    // Load profile details and store them for later retrieval.    $function = $profile->name .'_profile_details';    if (function_exists($function)) {      $details = $function();    }    $profiles[$profile->name] = $details;    // Determine the name of the profile; default to file name if defined name    // is unspecified.    $name = isset($details['name']) ? $details['name'] : $profile->name;    $names[$profile->name] = $name;  }  // Display radio buttons alphabetically by human-readable name.   natcasesort($names);  foreach ($names as $profile => $name) {    $form['profile'][$name] = array(      '#type' => 'radio',      '#value' => 'default',      '#return_value' => $profile,      '#title' => $name,      '#description' => isset($profiles[$profile]['description']) ? $profiles[$profile]['description'] : '',      '#parents' => array('profile'),    );  }  $form['submit'] =  array(    '#type' => 'submit',    '#value' => st('Save and continue'),  );  return $form;}/** * Find all .po files for the current profile. */function install_find_locales($profilename) {  $locales = file_scan_directory('./profiles/'. $profilename .'/translations', '\.po$', array('.', '..', 'CVS'), 0, FALSE);  array_unshift($locales, (object) array('name' => 'en'));  return $locales;}/** * Allow admin to select which locale to use for the current profile. * * @return *   The selected language. */function install_select_locale($profilename) {  include_once './includes/file.inc';  include_once './includes/form.inc';  // Find all available locales.  $locales = install_find_locales($profilename);  // If only the built-in (English) language is available,  // and we are using the default profile, inform the user  // that the installer can be localized. Otherwise we assume  // the user know what he is doing.  if (count($locales) == 1) {    if ($profilename == 'default') {      install_task_list('locale-select');      drupal_set_title(st('Choose language'));      if (!empty($_GET['localize'])) {        $output = '<p>'. st('With the addition of an appropriate translation package, this installer is capable of proceeding in another language of your choice. To install and use Drupal in a language other than English:') .'</p>';        $output .= '<ul><li>'. st('Determine if <a href="@translations" target="_blank">a translation of this Drupal version</a> is available in your language of choice. A translation is provided via a translation package; each translation package enables the display of a specific version of Drupal in a specific language. Not all languages are available for every version of Drupal.', array('@translations' => 'http://drupal.org/project/translations')) .'</li>';        $output .= '<li>'. st('If an alternative translation package of your choice is available, download and extract its contents to your Drupal root directory.') .'</li>';        $output .= '<li>'. st('Return to choose language using the second link below and select your desired language from the displayed list. Reloading the page allows the list to automatically adjust to the presence of new translation packages.') .'</li>';        $output .= '</ul><p>'. st('Alternatively, to install and use Drupal in English, or to defer the selection of an alternative language until after installation, select the first link below.') .'</p>';        $output .= '<p>'. st('How should the installation continue?') .'</p>';        $output .= '<ul><li><a href="install.php?profile='. $profilename .'&amp;locale=en">'. st('Continue installation in English') .'</a></li><li><a href="install.php?profile='. $profilename .'">'. st('Return to choose a language') .'</a></li></ul>';      }      else {        $output = '<ul><li><a href="install.php?profile='. $profilename .'&amp;locale=en">'. st('Install Drupal in English') .'</a></li><li><a href="install.php?profile='. $profilename .'&amp;localize=true">'. st('Learn how to install Drupal in other languages') .'</a></li></ul>';      }      print theme('install_page', $output);      exit;    }    // One language, but not the default profile, assume    // the user knows what he is doing.    return FALSE;  }  else {    // Allow profile to pre-select the language, skipping the selection.    $function = $profilename .'_profile_details';    if (function_exists($function)) {      $details = $function();      if (isset($details['language'])) {        foreach ($locales as $locale) {          if ($details['language'] == $locale->name) {            return $locale->name;          }        }      }    }    if (!empty($_POST['locale'])) {      foreach ($locales as $locale) {        if ($_POST['locale'] == $locale->name) {          return $locale->name;        }      }    }    install_task_list('locale-select');    drupal_set_title(st('Choose language'));    print theme('install_page', drupal_get_form('install_select_locale_form', $locales));    exit;  }}/** * Form API array definition for language selection. */function install_select_locale_form(&$form_state, $locales) {  include_once './includes/locale.inc';  $languages = _locale_get_predefined_list();  foreach ($locales as $locale) {    // Try to use verbose locale name    $name = $locale->name;    if (isset($languages[$name])) {      $name = $languages[$name][0] . (isset($languages[$name][1]) ? ' '. st('(@language)', array('@language' => $languages[$name][1])) : '');    }    $form['locale'][$locale->name] = array(      '#type' => 'radio',      '#return_value' => $locale->name,      '#default_value' => ($locale->name == 'en' ? TRUE : FALSE),      '#title' => $name . ($locale->name == 'en' ? ' '. st('(built-in)') : ''),      '#parents' => array('locale')    );  }  $form['submit'] =  array(    '#type' => 'submit',    '#value' => st('Select language'),  );  return $form;}/** * Show an error page when there are no profiles available. */function install_no_profile_error() {  install_task_list('profile-select');  drupal_set_title(st('No profiles available'));  print theme('install_page', '<p>'. st('We were unable to find any installer profiles. Installer profiles tell us what modules to enable and what schema to install in the database. A profile is necessary to continue with the installation process.') .'</p>');  exit;}/** * Show an error page when Drupal has already been installed. */function install_already_done_error() {  global $base_url;  drupal_set_title(st('Drupal already installed'));  print theme('install_page', st('<ul><li>To start over, you must empty your existing database.</li><li>To install to a different database, edit the appropriate <em>settings.php</em> file in the <em>sites</em> folder.</li><li>To upgrade an existing installation, proceed to the <a href="@base-url/update.php">update script</a>.</li><li>View your <a href="@base-url">existing site</a>.</li></ul>', array('@base-url' => $base_url)));  exit;}/** * Tasks performed after the database is initialized. */function install_tasks($profile, $task) {  global $base_url, $install_locale;  // Bootstrap newly installed Drupal, while preserving existing messages.  $messages = isset($_SESSION['messages']) ? $_SESSION['messages'] : '';  drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);  $_SESSION['messages'] = $messages;  // URL used to direct page requests.  $url = $base_url .'/install.php?locale='. $install_locale .'&profile='. $profile;  // Build a page for final tasks.  if (empty($task)) {    variable_set('install_task', 'profile-install');    $task = 'profile-install';  }  // We are using a list of if constructs here to allow for  // passing from one task to the other in the same request.  // Install profile modules.  if ($task == 'profile-install') {    $modules = variable_get('install_profile_modules', array());    $files = module_rebuild_cache();    variable_del('install_profile_modules');    $operations = array();    foreach ($modules as $module) {      $operations[] = array('_install_module_batch', array($module, $files[$module]->info['name']));    }    $batch = array(      'operations' => $operations,      'finished' => '_install_profile_batch_finished',      'title' => st('Installing @drupal', array('@drupal' => drupal_install_profile_name())),      'error_message' => st('The installation has encountered an error.'),    );    // Start a batch, switch to 'profile-install-batch' task. We need to    // set the variable here, because batch_process() redirects.    variable_set('install_task', 'profile-install-batch');    batch_set($batch);    batch_process($url, $url);  }  // We are running a batch install of the profile's modules.  // This might run in multiple HTTP requests, constantly redirecting  // to the same address, until the batch finished callback is invoked  // and the task advances to 'locale-initial-import'.  if ($task == 'profile-install-batch') {    include_once 'includes/batch.inc';    $output = _batch_page();  }  // Import interface translations for the enabled modules.  if ($task == 'locale-initial-import') {    if (!empty($install_locale) && ($install_locale != 'en')) {      include_once 'includes/locale.inc';      // Enable installation language as default site language.      locale_add_language($install_locale, NULL, NULL, NULL, NULL, NULL, 1, TRUE);      // Collect files to import for this language.      $batch = locale_batch_by_language($install_locale, '_install_locale_initial_batch_finished');      if (!empty($batch)) {        // Remember components we cover in this batch set.        variable_set('install_locale_batch_components', $batch['#components']);        // Start a batch, switch to 'locale-batch' task. We need to        // set the variable here, because batch_process() redirects.        variable_set('install_task', 'locale-initial-batch');        batch_set($batch);        batch_process($url, $url);      }    }    // Found nothing to import or not foreign language, go to next task.    $task = 'configure';  }  if ($task == 'locale-initial-batch') {    include_once 'includes/batch.inc';    include_once 'includes/locale.inc';    $output = _batch_page();  }  if ($task == 'configure') {    if (variable_get('site_name', FALSE) || variable_get('site_mail', FALSE)) {      // Site already configured: This should never happen, means re-running      // the installer, possibly by an attacker after the 'install_task' variable      // got accidentally blown somewhere. Stop it now.      install_already_done_error();    }    $form = drupal_get_form('install_configure_form', $url);    if (!variable_get('site_name', FALSE) && !variable_get('site_mail', FALSE)) {      // Not submitted yet: Prepare to display the form.      $output = $form;      drupal_set_title(st('Configure site'));      // Warn about settings.php permissions risk      $settings_dir = './'. conf_path();      $settings_file = $settings_dir .'/settings.php';      if (!drupal_verify_install_file($settings_file, FILE_EXIST|FILE_READABLE|FILE_NOT_WRITABLE) || !drupal_verify_install_file($settings_dir, FILE_NOT_WRITABLE, 'dir')) {        drupal_set_message(st('All necessary changes to %dir and %file have been made, so you should remove write permissions to them now in order to avoid security risks. If you are unsure how to do so, please consult the <a href="@handbook_url">on-line handbook</a>.', array('%dir' => $settings_dir, '%file' => $settings_file, '@handbook_url' => 'http://drupal.org/getting-started')), 'error');      }      else {        drupal_set_message(st('All necessary changes to %dir and %file have been made. They have been set to read-only for security.', array('%dir' => $settings_dir, '%file' => $settings_file)));      }      // Add JavaScript validation.      _user_password_dynamic_validation();      drupal_add_js(drupal_get_path('module', 'system') .'/system.js', 'module');      // We add these strings as settings because JavaScript translation does not      // work on install time.      drupal_add_js(array('copyFieldValue' => array('edit-site-mail' => array('edit-account-mail')), 'cleanURL' => array('success' => st('Your server has been successfully tested to support this feature.'), 'failure' => st('Your system configuration does not currently support this feature. The <a href="http://drupal.org/node/15365">handbook page on Clean URLs</a> has additional troubleshooting information.'), 'testing' => st('Testing clean URLs...'))), 'setting');      drupal_add_js('// Global Killswitchif (Drupal.jsEnabled) {  $(document).ready(function() {    Drupal.cleanURLsInstallCheck();    Drupal.setDefaultTimezone();  });}', 'inline');      // Build menu to allow clean URL check.      menu_rebuild();    }    else {      $task = 'profile';    }  }  // If found an unknown task or the 'profile' task, which is  // reserved for profiles, hand over the control to the profile,  // so it can run any number of custom tasks it defines.  if (!in_array($task, install_reserved_tasks())) {    $function = $profile .'_profile_tasks';    if (function_exists($function)) {      // The profile needs to run more code, maybe even more tasks.      // $task is sent through as a reference and may be changed!      $output = $function($task, $url);    }    // If the profile doesn't move on to a new task we assume    // that it is done.    if ($task == 'profile') {      $task = 'profile-finished';    }  }  // Profile custom tasks are done, so let the installer regain  // control and proceed with importing the remaining translations.  if ($task == 'profile-finished') {    if (!empty($install_locale) && ($install_locale != 'en')) {      include_once 'includes/locale.inc';      // Collect files to import for this language. Skip components      // already covered in the initial batch set.      $batch = locale_batch_by_language($install_locale, '_install_locale_remaining_batch_finished', variable_get('install_locale_batch_components', array()));      // Remove temporary variable.      variable_del('install_locale_batch_components');      if (!empty($batch)) {        // Start a batch, switch to 'locale-remaining-batch' task. We need to        // set the variable here, because batch_process() redirects.        variable_set('install_task', 'locale-remaining-batch');        batch_set($batch);        batch_process($url, $url);      }    }    // Found nothing to import or not foreign language, go to next task.    $task = 'finished';  }  if ($task == 'locale-remaining-batch') {    include_once 'includes/batch.inc';    include_once 'includes/locale.inc';    $output = _batch_page();  }  // Display a 'finished' page to user.  if ($task == 'finished') {    drupal_set_title(st('@drupal installation complete', array('@drupal' => drupal_install_profile_name())));    $messages = drupal_set_message();    $output = '<p>'. st('Congratulations, @drupal has been successfully installed.', array('@drupal' => drupal_install_profile_name())) .'</p>';    $output .= '<p>'. (isset($messages['error']) ? st('Please review the messages above before continuing on to <a href="@url">your new site</a>.', array('@url' => url(''))) : st('You may now visit <a href="@url">your new site</a>.', array('@url' => url('')))) .'</p>';    $task = 'done';  }  // The end of the install process. Remember profile used.  if ($task == 'done') {    // Rebuild menu to get content type links registered by the profile,    // and possibly any other menu items created through the tasks.    menu_rebuild();    // Register actions declared by any modules.    actions_synchronize();    // Randomize query-strings on css/js files, to hide the fact that    // this is a new install, not upgraded yet.    _drupal_flush_css_js();    variable_set('install_profile', $profile);  }  // Set task for user, and remember the task in the database.  install_task_list($task);  variable_set('install_task', $task);  // Output page, if some output was required. Otherwise it is possible  // that we are printing a JSON page and theme output should not be there.  if (isset($output)) {    print theme('maintenance_page', $output);  }}/** * Batch callback for batch installation of modules. */function _install_module_batch($module, $module_name, &$context) {  _drupal_install_module($module);  // We enable the installed module right away, so that the module will be  // loaded by drupal_bootstrap in subsequent batch requests, and other  // modules possibly depending on it can safely perform their installation  // steps.  module_enable(array($module));  $context['results'][] = $module;  $context['message'] = st('Installed %module module.', array('%module' => $module_name));}/** * Finished callback for the modules install batch. * * Advance installer task to language import. */function _install_profile_batch_finished($success, $results) {  variable_set('install_task', 'locale-initial-import');}/** * Finished callback for the first locale import batch. * * Advance installer task to the configure screen. */function _install_locale_initial_batch_finished($success, $results) {  variable_set('install_task', 'configure');}/** * Finished callback for the second locale import batch. * * Advance installer task to the finished screen. */function _install_locale_remaining_batch_finished($success, $results) {  variable_set('install_task', 'finished');}/** * The list of reserved tasks to run in the installer. */function install_reserved_tasks() {  return array('configure', 'profile-install', 'profile-install-batch', 'locale-initial-import', 'locale-initial-batch', 'profile-finished', 'locale-remaining-batch', 'finished', 'done');}/** * Check installation requirements and report any errors. */function install_check_requirements($profile, $verify) {  // If Drupal is not set up already, we need to create a settings file.  if (!$verify) {    $writable = FALSE;    $conf_path = './'. conf_path(FALSE, TRUE);    $settings_file = $conf_path .'/settings.php';    $file = $conf_path;    $exists = FALSE;    // Verify that the directory exists.    if (drupal_verify_install_file($conf_path, FILE_EXIST, 'dir')) {      // Check to make sure a settings.php already exists.      $file = $settings_file;      if (drupal_verify_install_file($settings_file, FILE_EXIST)) {        $exists = TRUE;        // If it does, make sure it is writable.        $writable = drupal_verify_install_file($settings_file, FILE_READABLE|FILE_WRITABLE);      }    }    if (!$exists) {      drupal_set_message(st('The @drupal installer requires that you create a settings file as part of the installation process.<ol><li>Copy the %default_file file to %file.</li><li>Change file permissions so that it is writable by the web server. If you are unsure how to grant file permissions, please consult the <a href="@handbook_url">on-line handbook</a>.</li></ol>More details about installing Drupal are available in INSTALL.txt.', array('@drupal' => drupal_install_profile_name(), '%file' => $file, '%default_file' => $conf_path .'/default.settings.php', '@handbook_url' => 'http://drupal.org/server-permissions')), 'error');    }    elseif (!$writable) {      drupal_set_message(st('The @drupal installer requires write permissions to %file during the installation process. If you are unsure how to grant file permissions, please consult the <a href="@handbook_url">on-line handbook</a>.', array('@drupal' => drupal_install_profile_name(), '%file' => $file, '@handbook_url' => 'http://drupal.org/server-permissions')), 'error');    }  }  // Check the other requirements.  $requirements = drupal_check_profile($profile);  $severity = drupal_requirements_severity($requirements);  // If there are issues, report them.  if ($severity == REQUIREMENT_ERROR) {    foreach ($requirements as $requirement) {      if (isset($requirement['severity']) && $requirement['severity'] == REQUIREMENT_ERROR) {        $message = $requirement['description'];        if (isset($requirement['value']) && $requirement['value']) {          $message .= ' ('. st('Currently using !item !version', array('!item' => $requirement['title'], '!version' => $requirement['value'])) .')';        }        drupal_set_message($message, 'error');      }    }  }  if ($severity == REQUIREMENT_WARNING) {    foreach ($requirements as $requirement) {      if (isset($requirement['severity']) && $requirement['severity'] == REQUIREMENT_WARNING) {        $message = $requirement['description'];        if (isset($requirement['value']) && $requirement['value']) {          $message .= ' ('. st('Currently using !item !version', array('!item' => $requirement['title'], '!version' => $requirement['value'])) .')';        }        drupal_set_message($message, 'warning');      }    }  } }/** * Add the installation task list to the current page. */function install_task_list($active = NULL) {  // Default list of tasks.  $tasks = array(    'profile-select'        => st('Choose profile'),    'locale-select'         => st('Choose language'),    'requirements'          => st('Verify requirements'),    'database'              => st('Set up database'),    'profile-install-batch' => st('Install profile'),    'locale-initial-batch'  => st('Set up translations'),    'configure'             => st('Configure site'),  );  $profiles = install_find_profiles();  $profile = isset($_GET['profile']) && isset($profiles[$_GET['profile']]) ? $_GET['profile'] : '.';  $locales = install_find_locales($profile);  // If we have only one profile, remove 'Choose profile'  // and rename 'Install profile'.  if (count($profiles) == 1) {    unset($tasks['profile-select']);    $tasks['profile-install-batch'] = st('Install site');  }  // Add tasks defined by the profile.  if ($profile) {    $function = $profile .'_profile_task_list';    if (function_exists($function)) {      $result = $function();      if (is_array($result)) {        $tasks += $result;      }    }  }  if (count($locales) < 2 || empty($_GET['locale']) || $_GET['locale'] == 'en') {    // If not required, remove translation import from the task list.    unset($tasks['locale-initial-batch']);  }  else {    // If required, add remaining translations import task.    $tasks += array('locale-remaining-batch' => st('Finish translations'));  }  // Add finished step as the last task.  $tasks += array(    'finished'     => st('Finished')  );  // Let the theming function know that 'finished' and 'done'  // include everything, so every step is completed.  if (in_array($active, array('finished', 'done'))) {    $active = NULL;  }  drupal_set_content('left', theme_task_list($tasks, $active));}/** * Form API array definition for site configuration. */function install_configure_form(&$form_state, $url) {  $form['intro'] = array(    '#value' => st('To configure your website, please provide the following information.'),    '#weight' => -10,  );  $form['site_information'] = array(    '#type' => 'fieldset',    '#title' => st('Site information'),    '#collapsible' => FALSE,  );  $form['site_information']['site_name'] = array(    '#type' => 'textfield',    '#title' => st('Site name'),    '#required' => TRUE,    '#weight' => -20,  );  $form['site_information']['site_mail'] = array(    '#type' => 'textfield',    '#title' => st('Site e-mail address'),    '#default_value' => ini_get('sendmail_from'),    '#description' => st("The <em>From</em> address in automated e-mails sent during registration and new password requests, and other notifications. (Use an address ending in your site's domain to help prevent this e-mail being flagged as spam.)"),    '#required' => TRUE,    '#weight' => -15,  );  $form['admin_account'] = array(    '#type' => 'fieldset',    '#title' => st('Administrator account'),    '#collapsible' => FALSE,  );  $form['admin_account']['account']['#tree'] = TRUE;  $form['admin_account']['markup'] = array(    '#value' => '<p class="description">'. st('The administrator account has complete access to the site; it will automatically be granted all permissions and can perform any administrative activity. This will be the only account that can perform certain activities, so keep its credentials safe.') .'</p>',    '#weight' => -10,  );  $form['admin_account']['account']['name'] = array('#type' => 'textfield',    '#title' => st('Username'),    '#maxlength' => USERNAME_MAX_LENGTH,    '#description' => st('Spaces are allowed; punctuation is not allowed except for periods, hyphens, and underscores.'),    '#required' => TRUE,    '#weight' => -10,  );  $form['admin_account']['account']['mail'] = array('#type' => 'textfield',    '#title' => st('E-mail address'),    '#maxlength' => EMAIL_MAX_LENGTH,    '#description' => st('All e-mails from the system will be sent to this address. The e-mail address is not made public and will only be used if you wish to receive a new password or wish to receive certain news or notifications by e-mail.'),    '#required' => TRUE,    '#weight' => -5,  );  $form['admin_account']['account']['pass'] = array(    '#type' => 'password_confirm',    '#required' => TRUE,    '#size' => 25,    '#weight' => 0,  );  $form['server_settings'] = array(    '#type' => 'fieldset',    '#title' => st('Server settings'),    '#collapsible' => FALSE,  );  $form['server_settings']['date_default_timezone'] = array(    '#type' => 'select',    '#title' => st('Default time zone'),    '#default_value' => 0,    '#options' => _system_zonelist(),    '#description' => st('By default, dates in this site will be displayed in the chosen time zone.'),    '#weight' => 5,  );  $form['server_settings']['clean_url'] = array(    '#type' => 'radios',    '#title' => st('Clean URLs'),    '#default_value' => 0,    '#options' => array(0 => st('Disabled'), 1 => st('Enabled')),    '#description' => st('This option makes Drupal emit "clean" URLs (i.e. without <code>?q=</code> in the URL).'),    '#disabled' => TRUE,    '#prefix' => '<div id="clean-url" class="install">',    '#suffix' => '</div>',    '#weight' => 10,  );  $form['server_settings']['update_status_module'] = array(    '#type' => 'checkboxes',    '#title' => st('Update notifications'),    '#options' => array(1 => st('Check for updates automatically')),    '#default_value' => array(1),    '#description' => st('With this option enabled, Drupal will notify you when new releases are available. This will significantly enhance your site\'s security and is <strong>highly recommended</strong>. This requires your site to periodically send anonymous information on its installed components to <a href="@drupal">drupal.org</a>. For more information please see the <a href="@update">update notification information</a>.', array('@drupal' => 'http://drupal.org', '@update' => 'http://drupal.org/handbook/modules/update')),    '#weight' => 15,  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => st('Save and continue'),    '#weight' => 15,  );  $form['#action'] = $url;  $form['#redirect'] = FALSE;  // Allow the profile to alter this form. $form_state isn't available  // here, but to conform to the hook_form_alter() signature, we pass  // an empty array.  $hook_form_alter = $_GET['profile'] .'_form_alter';  if (function_exists($hook_form_alter)) {    $hook_form_alter($form, array(), 'install_configure');  }  return $form;}/** * Form API validate for the site configuration form. */function install_configure_form_validate($form, &$form_state) {  if ($error = user_validate_name($form_state['values']['account']['name'])) {    form_error($form['admin_account']['account']['name'], $error);  }  if ($error = user_validate_mail($form_state['values']['account']['mail'])) {    form_error($form['admin_account']['account']['mail'], $error);  }  if ($error = user_validate_mail($form_state['values']['site_mail'])) {    form_error($form['site_information']['site_mail'], $error);  }}/** * Form API submit for the site configuration form. */function install_configure_form_submit($form, &$form_state) {  global $user;  variable_set('site_name', $form_state['values']['site_name']);  variable_set('site_mail', $form_state['values']['site_mail']);  variable_set('date_default_timezone', $form_state['values']['date_default_timezone']);  // Enable update.module if this option was selected.  if ($form_state['values']['update_status_module'][1]) {    drupal_install_modules(array('update'));  }  // Turn this off temporarily so that we can pass a password through.  variable_set('user_email_verification', FALSE);  $form_state['old_values'] = $form_state['values'];  $form_state['values'] = $form_state['values']['account'];  // We precreated user 1 with placeholder values. Let's save the real values.  $account = user_load(1);  $merge_data = array('init' => $form_state['values']['mail'], 'roles' => array(), 'status' => 1);  user_save($account, array_merge($form_state['values'], $merge_data));  // Log in the first user.  user_authenticate($form_state['values']);  $form_state['values'] = $form_state['old_values'];  unset($form_state['old_values']);  variable_set('user_email_verification', TRUE);  if (isset($form_state['values']['clean_url'])) {    variable_set('clean_url', $form_state['values']['clean_url']);  }  // The user is now logged in, but has no session ID yet, which  // would be required later in the request, so remember it.  $user->sid = session_id();  // Record when this install ran.  variable_set('install_time', time());}// Start the installer.install_main();
<?php// $Id$/** * @file * Page callbacks for the taxonomy module. *//** * Menu callback; displays all nodes associated with a term. */function taxonomy_term_page($str_tids = '', $depth = 0, $op = 'page') {  $terms = taxonomy_terms_parse_string($str_tids);  if ($terms['operator'] != 'and' && $terms['operator'] != 'or') {    drupal_not_found();  }  if ($terms['tids']) {    $result = db_query(db_rewrite_sql('SELECT t.tid, t.name FROM {term_data} t WHERE t.tid IN ('. db_placeholders($terms['tids']) .')', 't', 'tid'), $terms['tids']);    $tids = array(); // we rebuild the $tids-array so it only contains terms the user has access to.    $names = array();    while ($term = db_fetch_object($result)) {      $tids[] = $term->tid;      $names[] = $term->name;    }    if ($names) {      $title = implode(', ', $names);      drupal_set_title(check_plain($title));      switch ($op) {        case 'page':          // Build breadcrumb based on first hierarchy of first term:          $current->tid = $tids[0];          $breadcrumb = array();          while ($parents = taxonomy_get_parents($current->tid)) {            $current = array_shift($parents);            $breadcrumb[] = l($current->name, 'taxonomy/term/'. $current->tid);          }          $breadcrumb[] = l(t('Home'), NULL);          $breadcrumb = array_reverse($breadcrumb);          drupal_set_breadcrumb($breadcrumb);          $output = theme('taxonomy_term_page', $tids, taxonomy_select_nodes($tids, $terms['operator'], $depth, TRUE));          drupal_add_feed(url('taxonomy/term/'. $str_tids .'/'. $depth .'/feed'), 'RSS - '. $title);          return $output;          break;        case 'feed':          $channel['link'] = url('taxonomy/term/'. $str_tids .'/'. $depth, array('absolute' => TRUE));          $channel['title'] = variable_get('site_name', 'Drupal') .' - '. $title;          // Only display the description if we have a single term, to avoid clutter and confusion.          if (count($tids) == 1) {            $term = taxonomy_get_term($tids[0]);            // HTML will be removed from feed description, so no need to filter here.            $channel['description'] = $term->description;          }          $result = taxonomy_select_nodes($tids, $terms['operator'], $depth, FALSE);          $items = array();           while ($row = db_fetch_object($result)) {            $items[] = $row->nid;          }          node_feed($items, $channel);          break;        default:          drupal_not_found();      }    }    else {      drupal_not_found();    }  }}/** * Render a taxonomy term page HTML output. * * @param $tids *   An array of term ids. * @param $result *   A pager_query() result, such as that performed by taxonomy_select_nodes(). * * @ingroup themeable */function theme_taxonomy_term_page($tids, $result) {  drupal_add_css(drupal_get_path('module', 'taxonomy') .'/taxonomy.css');  $output = '';  // Only display the description if we have a single term, to avoid clutter and confusion.  if (count($tids) == 1) {    $term = taxonomy_get_term($tids[0]);    $description = $term->description;    // Check that a description is set.    if (!empty($description)) {      $output .= '<div class="taxonomy-term-description">';      $output .= filter_xss_admin($description);      $output .= '</div>';    }  }  $output .= taxonomy_render_nodes($result);  return $output;}/** * Helper function for autocompletion */function taxonomy_autocomplete($vid, $string = '') {  // The user enters a comma-separated list of tags. We only autocomplete the last tag.  $array = drupal_explode_tags($string);  // Fetch last tag  $last_string = trim(array_pop($array));  $matches = array();  if ($last_string != '') {    $result = db_query_range(db_rewrite_sql("SELECT t.tid, t.name FROM {term_data} t WHERE t.vid = %d AND LOWER(t.name) LIKE LOWER('%%%s%%')", 't', 'tid'), $vid, $last_string, 0, 10);    $prefix = count($array) ? implode(', ', $array) .', ' : '';    while ($tag = db_fetch_object($result)) {      $n = $tag->name;      // Commas and quotes in terms are special cases, so encode 'em.      if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {        $n = '"'. str_replace('"', '""', $tag->name) .'"';      }      $matches[$prefix . $n] = check_plain($tag->name);    }  }  drupal_json($matches);}
<?php// $Id$/** * Implementation of hook_schema(). */function taxonomy_schema() {  $schema['term_data'] = array(    'description' => 'Stores term information.',    'fields' => array(      'tid' => array(        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'Primary Key: Unique term ID.',      ),      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {vocabulary}.vid of the vocabulary to which the term is assigned.',      ),      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'The term name.',      ),      'description' => array(        'type' => 'text',        'not null' => FALSE,        'size' => 'big',        'description' => 'A description of the term.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The weight of this term in relation to other terms.',      ),    ),    'primary key' => array('tid'),    'indexes' => array(      'taxonomy_tree' => array('vid', 'weight', 'name'),      'vid_name' => array('vid', 'name'),    ),  );  $schema['term_hierarchy'] = array(    'description' => 'Stores the hierarchical relationship between terms.',    'fields' => array(      'tid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {term_data}.tid of the term.',      ),      'parent' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "Primary Key: The {term_data}.tid of the term's parent. 0 indicates no parent.",      ),    ),    'indexes' => array(      'parent' => array('parent'),    ),    'primary key' => array('tid', 'parent'),  );  $schema['term_node'] = array(    'description' => 'Stores the relationship of terms to nodes.',    'fields' => array(      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {node}.nid of the node.',      ),      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {node}.vid of the node.',      ),      'tid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {term_data}.tid of a term assigned to the node.',      ),    ),    'indexes' => array(      'vid' => array('vid'),      'nid' => array('nid'),    ),    'primary key' => array('tid', 'vid'),  );  $schema['term_relation'] = array(    'description' => 'Stores non-hierarchical relationships between terms.',    'fields' => array(      'trid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique term relation ID.',      ),      'tid1' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {term_data}.tid of the first term in a relationship.',      ),      'tid2' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {term_data}.tid of the second term in a relationship.',      ),    ),    'unique keys' => array(      'tid1_tid2' => array('tid1', 'tid2'),    ),    'indexes' => array(      'tid2' => array('tid2'),    ),    'primary key' => array('trid'),  );  $schema['term_synonym'] = array(    'description' => 'Stores term synonyms.',    'fields' => array(      'tsid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique term synonym ID.',      ),      'tid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {term_data}.tid of the term.',      ),      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'The name of the synonym.',      ),    ),    'indexes' => array(      'tid' => array('tid'),      'name_tid' => array('name', 'tid'),    ),    'primary key' => array('tsid'),  );  $schema['vocabulary'] = array(    'description' => 'Stores vocabulary information.',    'fields' => array(      'vid' => array(        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'Primary Key: Unique vocabulary ID.',      ),      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Name of the vocabulary.',      ),      'description' => array(        'type' => 'text',        'not null' => FALSE,        'size' => 'big',        'description' => 'Description of the vocabulary.',      ),      'help' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Help text to display for the vocabulary.',      ),      'relations' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether or not related terms are enabled within the vocabulary. (0 = disabled, 1 = enabled)',      ),      'hierarchy' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The type of hierarchy allowed within the vocabulary. (0 = disabled, 1 = single, 2 = multiple)',      ),      'multiple' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether or not multiple terms from this vocabulary may be assigned to a node. (0 = disabled, 1 = enabled)',      ),      'required' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether or not terms are required for nodes using this vocabulary. (0 = disabled, 1 = enabled)',      ),      'tags' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether or not free tagging is enabled for the vocabulary. (0 = disabled, 1 = enabled)',      ),      'module' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'The module which created the vocabulary.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The weight of the vocabulary in relation to other vocabularies.',      ),    ),    'primary key' => array('vid'),    'indexes' => array(      'list' => array('weight', 'name'),    ),  );  $schema['vocabulary_node_types'] = array(    'description' => 'Stores which node types vocabularies may be used with.',    'fields' => array(      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: the {vocabulary}.vid of the vocabulary.',      ),      'type' => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '',        'description' => 'The {node}.type of the node type for which the vocabulary may be used.',      ),    ),    'primary key' => array('type', 'vid'),    'indexes' => array(      'vid' => array('vid'),    ),  );  return $schema;}
<?php// $Id$/** * Sets the body-tag class attribute. * * Adds 'sidebar-left', 'sidebar-right' or 'sidebars' classes as needed. */function phptemplate_body_class($left, $right) {  if ($left != '' && $right != '') {    $class = 'sidebars';  }  else {    if ($left != '') {      $class = 'sidebar-left';    }    if ($right != '') {      $class = 'sidebar-right';    }  }  if (isset($class)) {    print ' class="'. $class .'"';  }}/** * Return a themed breadcrumb trail. * * @param $breadcrumb *   An array containing the breadcrumb links. * @return a string containing the breadcrumb output. */function phptemplate_breadcrumb($breadcrumb) {  if (!empty($breadcrumb)) {    return '<div class="breadcrumb">'. implode('  ', $breadcrumb) .'</div>';  }}/** * Override or insert PHPTemplate variables into the templates. */function phptemplate_preprocess_page(&$vars) {  $vars['tabs2'] = menu_secondary_local_tasks();  // Hook into color.module  if (module_exists('color')) {    _color_page_alter($vars);  }}/** * Add a "Comments" heading above comments except on forum pages. */function garland_preprocess_comment_wrapper(&$vars) {  if ($vars['content'] && $vars['node']->type != 'forum') {    $vars['content'] = '<h2 class="comments">'. t('Comments') .'</h2>'.  $vars['content'];  }}/** * Returns the rendered local tasks. The default implementation renders * them as tabs. Overridden to split the secondary tasks. * * @ingroup themeable */function phptemplate_menu_local_tasks() {  return menu_primary_local_tasks();}function phptemplate_comment_submitted($comment) {  return t('!datetime  !username',    array(      '!username' => theme('username', $comment),      '!datetime' => format_date($comment->timestamp)    ));}function phptemplate_node_submitted($node) {  return t('!datetime  !username',    array(      '!username' => theme('username', $node),      '!datetime' => format_date($node->created),    ));}/** * Generates IE CSS links for LTR and RTL languages. */function phptemplate_get_ie_styles() {  global $language;  $iecss = '<link type="text/css" rel="stylesheet" media="all" href="'. base_path() . path_to_theme() .'/fix-ie.css" />';  if ($language->direction == LANGUAGE_RTL) {    $iecss .= '<style type="text/css" media="all">@import "'. base_path() . path_to_theme() .'/fix-ie-rtl.css";</style>';  }  return $iecss;}
<?php// $Id$/** * @file * Allows users to structure the pages of a site in a hierarchy or outline. *//** * Implementation of hook_theme() */function book_theme() {  return array(    'book_navigation' => array(      'arguments' => array('book_link' => NULL),      'template' => 'book-navigation',    ),    'book_export_html' => array(      'arguments' => array('title' => NULL, 'contents' => NULL, 'depth' => NULL),      'template' => 'book-export-html',    ),    'book_admin_table' => array(      'arguments' => array('form' => NULL),    ),    'book_title_link' => array(      'arguments' => array('link' => NULL),    ),    'book_all_books_block' => array(      'arguments' => array('book_menus' => array()),      'template' => 'book-all-books-block',    ),    'book_node_export_html' => array(      'arguments' => array('node' => NULL, 'children' => NULL),      'template' => 'book-node-export-html',    ),  );}/** * Implementation of hook_perm(). */function book_perm() {  return array('add content to books', 'administer book outlines', 'create new books', 'access printer-friendly version');}/** * Implementation of hook_link(). */function book_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && isset($node->book)) {    if (!$teaser) {      $child_type = variable_get('book_child_type', 'book');      if ((user_access('add content to books') || user_access('administer book outlines')) && node_access('create', $child_type) && $node->status == 1 && $node->book['depth'] < MENU_MAX_DEPTH) {        $links['book_add_child'] = array(          'title' => t('Add child page'),          'href' => "node/add/". str_replace('_', '-', $child_type),          'query' => "parent=". $node->book['mlid'],        );      }      if (user_access('access printer-friendly version')) {        $links['book_printer'] = array(          'title' => t('Printer-friendly version'),          'href' => 'book/export/html/'. $node->nid,          'attributes' => array('title' => t('Show a printer-friendly version of this book page and its sub-pages.'))        );      }    }  }  return $links;}/** * Implementation of hook_menu(). */function book_menu() {  $items['admin/content/book'] = array(    'title' => 'Books',    'description' => "Manage your site's book outlines.",    'page callback' => 'book_admin_overview',    'access arguments' => array('administer book outlines'),    'file' => 'book.admin.inc',  );  $items['admin/content/book/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/content/book/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_admin_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_LOCAL_TASK,    'weight' => 8,    'file' => 'book.admin.inc',  );  $items['admin/content/book/%node'] = array(    'title' => 'Re-order book pages and change titles',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_admin_edit', 3),    'access callback' => '_book_outline_access',    'access arguments' => array(3),    'type' => MENU_CALLBACK,    'file' => 'book.admin.inc',  );  $items['book'] = array(    'title' => 'Books',    'page callback' => 'book_render',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'book.pages.inc',  );  $items['book/export/%/%'] = array(    'page callback' => 'book_export',    'page arguments' => array(2, 3),    'access arguments' => array('access printer-friendly version'),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  $items['node/%node/outline'] = array(    'title' => 'Outline',    'page callback' => 'book_outline',    'page arguments' => array(1),    'access callback' => '_book_outline_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'book.pages.inc',  );  $items['node/%node/outline/remove'] = array(    'title' => 'Remove from outline',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_remove_form', 1),    'access callback' => '_book_outline_remove_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  $items['book/js/form'] = array(    'page callback' => 'book_form_update',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  return $items;}/** * Menu item access callback - determine if the outline tab is accessible. */function _book_outline_access($node) {  return user_access('administer book outlines') && node_access('view', $node);}/** * Menu item access callback - determine if the user can remove nodes from the outline. */function _book_outline_remove_access($node) {  return isset($node->book) && ($node->book['bid'] != $node->nid) && _book_outline_access($node);}/** * Implementation of hook_init(). Add's the book module's CSS. */function book_init() {  drupal_add_css(drupal_get_path('module', 'book') .'/book.css');}/** * Implementation of hook_block(). * * Displays the book table of contents in a block when the current page is a * single-node view of a book node. */function book_block($op = 'list', $delta = 0, $edit = array()) {  $block = array();  switch ($op) {    case 'list':      $block[0]['info'] = t('Book navigation');      $block[0]['cache'] = BLOCK_CACHE_PER_PAGE | BLOCK_CACHE_PER_ROLE;      return $block;    case 'view':      $current_bid = 0;      if ($node = menu_get_object()) {        $current_bid = empty($node->book['bid']) ? 0 : $node->book['bid'];      }      if (variable_get('book_block_mode', 'all pages') == 'all pages') {        $block['subject'] = t('Book navigation');        $book_menus = array();        $pseudo_tree = array(0 => array('below' => FALSE));        foreach (book_get_books() as $book_id => $book) {          if ($book['bid'] == $current_bid) {            // If the current page is a node associated with a book, the menu            // needs to be retrieved.            $book_menus[$book_id] = menu_tree_output(menu_tree_all_data($node->book['menu_name'], $node->book));          }          else {            // Since we know we will only display a link to the top node, there            // is no reason to run an additional menu tree query for each book.            $book['in_active_trail'] = FALSE;            $pseudo_tree[0]['link'] = $book;            $book_menus[$book_id] = menu_tree_output($pseudo_tree);          }        }        $block['content'] = theme('book_all_books_block', $book_menus);      }      elseif ($current_bid) {        // Only display this block when the user is browsing a book.        $title = db_result(db_query(db_rewrite_sql('SELECT n.title FROM {node} n WHERE n.nid = %d'), $node->book['bid']));        // Only show the block if the user has view access for the top-level node.        if ($title) {          $tree = menu_tree_all_data($node->book['menu_name'], $node->book);          // There should only be one element at the top level.          $data = array_shift($tree);          $block['subject'] = theme('book_title_link', $data['link']);          $block['content'] = ($data['below']) ? menu_tree_output($data['below']) : '';        }      }      return $block;    case 'configure':      $options = array(        'all pages' => t('Show block on all pages'),        'book pages' => t('Show block only on book pages'),      );      $form['book_block_mode'] = array(        '#type' => 'radios',        '#title' => t('Book navigation block display'),        '#options' => $options,        '#default_value' => variable_get('book_block_mode', 'all pages'),        '#description' => t("If <em>Show block on all pages</em> is selected, the block will contain the automatically generated menus for all of the site's books. If <em>Show block only on book pages</em> is selected, the block will contain only the one menu corresponding to the current page's book. In this case, if the current page is not in a book, no block will be displayed. The <em>Page specific visibility settings</em> or other visibility settings can be used in addition to selectively display this block."),        );      return $form;    case 'save':      variable_set('book_block_mode', $edit['book_block_mode']);      break;  }}/** * Generate the HTML output for a link to a book title when used as a block title. * * @ingroup themeable */function theme_book_title_link($link) {  $link['options']['attributes']['class'] =  'book-title';  return l($link['title'], $link['href'], $link['options']);}/** * Returns an array of all books. * * This list may be used for generating a list of all the books, or for building * the options for a form select. */function book_get_books() {  static $all_books;  if (!isset($all_books)) {    $all_books = array();    $result = db_query("SELECT DISTINCT(bid) FROM {book}");    $nids = array();    while ($book = db_fetch_array($result)) {      $nids[] = $book['bid'];    }    if ($nids) {      $result2 = db_query(db_rewrite_sql("SELECT n.type, n.title, b.*, ml.* FROM {book} b INNER JOIN {node} n on b.nid = n.nid INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE n.nid IN (". implode(',', $nids) .") AND n.status = 1 ORDER BY ml.weight, ml.link_title"));      while ($link = db_fetch_array($result2)) {        $link['href'] = $link['link_path'];        $link['options'] = unserialize($link['options']);        $all_books[$link['bid']] = $link;      }    }  }  return $all_books;}/** * Implementation of hook_form_alter(). Adds the book fieldset to the node form. * * @see book_pick_book_submit() * @see book_submit() */function book_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {    // Add elements to the node form    $node = $form['#node'];    $access = user_access('administer book outlines');    if (!$access) {      if (user_access('add content to books') && ((!empty($node->book['mlid']) && !empty($node->nid)) || book_type_is_allowed($node->type))) {        // Already in the book hierarchy or this node type is allowed        $access = TRUE;      }    }    if ($access) {      _book_add_form_elements($form, $node);      $form['book']['pick-book'] = array(        '#type' => 'submit',        '#value' => t('Change book (update list of parents)'),         // Submit the node form so the parent select options get updated.         // This is typically only used when JS is disabled.  Since the parent options         // won't be changed via AJAX, a button is provided in the node form to submit         // the form and generate options in the parent select corresponding to the         // selected book.  This is similar to what happens during a node preview.        '#submit' => array('node_form_submit_build_node'),        '#weight' => 20,      );    }  }}/** * Build the parent selection form element for the node form or outline tab * * This function is also called when generating a new set of options during the * AJAX callback, so an array is returned that can be used to replace an existing * form element. */function _book_parent_select($book_link) {  if (variable_get('menu_override_parent_selector', FALSE)) {    return array();  }  // Offer a message or a drop-down to choose a different parent page.  $form = array(    '#type' => 'hidden',    '#value' => -1,    '#prefix' => '<div id="edit-book-plid-wrapper">',    '#suffix' => '</div>',  );  if ($book_link['nid'] === $book_link['bid']) {    // This is a book - at the top level.    if ($book_link['original_bid'] === $book_link['bid']) {      $form['#prefix'] .= '<em>'. t('This is the top-level page in this book.') .'</em>';    }    else {      $form['#prefix'] .= '<em>'. t('This will be the top-level page in this book.') .'</em>';    }  }  elseif (!$book_link['bid']) {    $form['#prefix'] .= '<em>'. t('No book selected.') .'</em>';  }  else {    $form = array(      '#type' => 'select',      '#title' => t('Parent item'),      '#default_value' => $book_link['plid'],      '#description' => t('The parent page in the book. The maximum depth for a book and all child pages is !maxdepth. Some pages in the selected book may not be available as parents if selecting them would exceed this limit.', array('!maxdepth' => MENU_MAX_DEPTH)),      '#options' => book_toc($book_link['bid'], array($book_link['mlid']), $book_link['parent_depth_limit']),      '#attributes' => array('class' => 'book-title-select'),    );  }  return $form;}/** * Build the common elements of the book form for the node and outline forms. */function _book_add_form_elements(&$form, $node) {  // Need this for AJAX.  $form['#cache'] = TRUE;  drupal_add_js("if (Drupal.jsEnabled) { $(document).ready(function() { $('#edit-book-pick-book').css('display', 'none'); }); }", 'inline');  $form['book'] = array(    '#type' => 'fieldset',    '#title' => t('Book outline'),    '#weight' => 10,    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#tree' => TRUE,    '#attributes' => array('class' => 'book-outline-form'),  );  foreach (array('menu_name', 'mlid', 'nid', 'router_path', 'has_children', 'options', 'module', 'original_bid', 'parent_depth_limit') as $key) {    $form['book'][$key] = array(      '#type' => 'value',      '#value' => $node->book[$key],    );  }  $form['book']['plid'] = _book_parent_select($node->book);  $form['book']['weight'] = array(    '#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $node->book['weight'],    '#delta' => 15,    '#weight' => 5,    '#description' => t('Pages at a given level are ordered first by weight and then by title.'),  );  $options = array();  $nid = isset($node->nid) ? $node->nid : 'new';  if (isset($node->nid) && ($nid == $node->book['original_bid']) && ($node->book['parent_depth_limit'] == 0)) {    // This is the top level node in a maximum depth book and thus cannot be moved.    $options[$node->nid] = $node->title;  }  else {    foreach (book_get_books() as $book) {      $options[$book['nid']] = $book['title'];    }  }  if (user_access('create new books') && ($nid == 'new' || ($nid != $node->book['original_bid']))) {    // The node can become a new book, if it is not one already.    $options = array($nid => '<'. t('create a new book') .'>') + $options;  }  if (!$node->book['mlid']) {    // The node is not currently in a the hierarchy.    $options = array(0 => '<'. t('none') .'>') + $options;  }  // Add a drop-down to select the destination book.  $form['book']['bid'] = array(    '#type' => 'select',    '#title' => t('Book'),    '#default_value' => $node->book['bid'],    '#options' => $options,    '#access' => (bool)$options,    '#description' => t('Your page will be a part of the selected book.'),    '#weight' => -5,    '#attributes' => array('class' => 'book-title-select'),    '#ahah' => array(      'path' => 'book/js/form',      'wrapper' => 'edit-book-plid-wrapper',      'effect' => 'slide',    ),  );}/** * Common helper function to handles additions and updates to the book outline. * * Performs all additions and updates to the book outline through node addition, * node editing, node deletion, or the outline tab. */function _book_update_outline(&$node) {  if (empty($node->book['bid'])) {    return FALSE;  }  $new = empty($node->book['mlid']);  $node->book['link_path'] = 'node/'. $node->nid;  $node->book['link_title'] = $node->title;  $node->book['parent_mismatch'] = FALSE; // The normal case.  if ($node->book['bid'] == $node->nid) {    $node->book['plid'] = 0;    $node->book['menu_name'] = book_menu_name($node->nid);  }  else {    // Check in case the parent is not is this book; the book takes precedence.    if (!empty($node->book['plid'])) {      $parent = db_fetch_array(db_query("SELECT * FROM {book} WHERE mlid = %d", $node->book['plid']));    }    if (empty($node->book['plid']) || !$parent || $parent['bid'] != $node->book['bid']) {      $node->book['plid'] = db_result(db_query("SELECT mlid FROM {book} WHERE nid = %d", $node->book['bid']));      $node->book['parent_mismatch'] = TRUE; // Likely when JS is disabled.    }  }  if (menu_link_save($node->book)) {    if ($new) {      // Insert new.      db_query("INSERT INTO {book} (nid, mlid, bid) VALUES (%d, %d, %d)", $node->nid, $node->book['mlid'], $node->book['bid']);    }    else {      if ($node->book['bid'] != db_result(db_query("SELECT bid FROM {book} WHERE nid = %d", $node->nid))) {        // Update the bid for this page and all children.        book_update_bid($node->book);      }    }    return TRUE;  }  // Failed to save the menu link  return FALSE;}/** * Update the bid for a page and its children when it is moved to a new book. * * @param $book_link *   A fully loaded menu link that is part of the book hierarchy. */function book_update_bid($book_link) {  for ($i = 1; $i <= MENU_MAX_DEPTH && $book_link["p$i"]; $i++) {    $match[] = "p$i = %d";    $args[] = $book_link["p$i"];  }  $result = db_query("SELECT mlid FROM {menu_links} WHERE ". implode(' AND ', $match), $args);  $mlids = array();  while ($a = db_fetch_array($result)) {    $mlids[] = $a['mlid'];  }  if ($mlids) {    db_query("UPDATE {book} SET bid = %d WHERE mlid IN (". implode(',', $mlids) .")", $book_link['bid']);  }}/** * Get the book menu tree for a page, and return it as a linear array. * * @param $book_link *   A fully loaded menu link that is part of the book hierarchy. * @return *   A linear array of menu links in the order that the links are shown in the *   menu, so the previous and next pages are the elements before and after the *   element corresponding to $node.  The children of $node (if any) will come *   immediately after it in the array. */function book_get_flat_menu($book_link) {  static $flat = array();  if (!isset($flat[$book_link['mlid']])) {    // Call menu_tree_all_data() to take advantage of the menu system's caching.    $tree = menu_tree_all_data($book_link['menu_name'], $book_link);    $flat[$book_link['mlid']] = array();    _book_flatten_menu($tree, $flat[$book_link['mlid']]);  }  return $flat[$book_link['mlid']];}/** * Recursive helper function for book_get_flat_menu(). */function _book_flatten_menu($tree, &$flat) {  foreach ($tree as $data) {    if (!$data['link']['hidden']) {      $flat[$data['link']['mlid']] = $data['link'];      if ($data['below']) {        _book_flatten_menu($data['below'], $flat);      }    }  }}/** * Fetches the menu link for the previous page of the book. */function book_prev($book_link) {  // If the parent is zero, we are at the start of a book.  if ($book_link['plid'] == 0) {    return NULL;  }  $flat = book_get_flat_menu($book_link);  // Assigning the array to $flat resets the array pointer for use with each().  $curr = NULL;  do {    $prev = $curr;    list($key, $curr) = each($flat);  } while ($key && $key != $book_link['mlid']);  if ($key == $book_link['mlid']) {    // The previous page in the book may be a child of the previous visible link.    if ($prev['depth'] == $book_link['depth'] && $prev['has_children']) {      // The subtree will have only one link at the top level - get its data.      $data = array_shift(book_menu_subtree_data($prev));      // The link of interest is the last child - iterate to find the deepest one.      while ($data['below']) {        $data = end($data['below']);      }      return $data['link'];    }    else {      return $prev;    }  }}/** * Fetches the menu link for the next page of the book. */function book_next($book_link) {  $flat = book_get_flat_menu($book_link);  // Assigning the array to $flat resets the array pointer for use with each().  do {    list($key, $curr) = each($flat);  } while ($key && $key != $book_link['mlid']);  if ($key == $book_link['mlid']) {    return current($flat);  }}/** * Format the menu links for the child pages of the current page. */function book_children($book_link) {  $flat = book_get_flat_menu($book_link);  $children = array();  if ($book_link['has_children']) {    // Walk through the array until we find the current page.    do {      $link = array_shift($flat);    } while ($link && ($link['mlid'] != $book_link['mlid']));    // Continue though the array and collect the links whose parent is this page.    while (($link = array_shift($flat)) && $link['plid'] == $book_link['mlid']) {      $data['link'] = $link;      $data['below'] = '';      $children[] = $data;    }  }  return $children ? menu_tree_output($children) : '';}/** * Generate the corresponding menu name from a book ID. */function book_menu_name($bid) {  return 'book-toc-'. $bid;}/** * Build an active trail to show in the breadcrumb. */function book_build_active_trail($book_link) {  static $trail;  if (!isset($trail)) {    $trail = array();    $trail[] = array('title' => t('Home'), 'href' => '<front>', 'localized_options' => array());    $tree = menu_tree_all_data($book_link['menu_name'], $book_link);    $curr = array_shift($tree);    while ($curr) {      if ($curr['link']['href'] == $book_link['href']) {        $trail[] = $curr['link'];        $curr = FALSE;      }      else {        if ($curr['below'] && $curr['link']['in_active_trail']) {          $trail[] = $curr['link'];          $tree = $curr['below'];        }        $curr = array_shift($tree);      }    }  }  return $trail;}/** * Implementation of hook_nodeapi(). * * Appends book navigation to all nodes in the book, and handles book outline * insertions and updates via the node form. */function book_nodeapi(&$node, $op, $teaser, $page) {  switch ($op) {    case 'load':      // Note - we cannot use book_link_load() because it will call node_load()      $info['book'] = db_fetch_array(db_query('SELECT * FROM {book} b INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE b.nid = %d', $node->nid));      if ($info['book']) {        $info['book']['href'] = $info['book']['link_path'];        $info['book']['title'] = $info['book']['link_title'];        $info['book']['options'] = unserialize($info['book']['options']);        return $info;      }      break;    case 'view':    if (!$teaser) {        if (!empty($node->book['bid']) && $node->build_mode == NODE_BUILD_NORMAL) {          $node->content['book_navigation'] = array(            '#value' => theme('book_navigation', $node->book),            '#weight' => 100,          );          if ($page) {            menu_set_active_trail(book_build_active_trail($node->book));            menu_set_active_menu_name($node->book['menu_name']);          }        }      }      break;    case 'presave':      // Always save a revision for non-administrators.      if (!empty($node->book['bid']) && !user_access('administer nodes')) {        $node->revision = 1;      }      // Make sure a new node gets a new menu link.      if (empty($node->nid)) {        $node->book['mlid'] = NULL;      }      break;    case 'insert':    case 'update':      if (!empty($node->book['bid'])) {        if ($node->book['bid'] == 'new') {          // New nodes that are their own book.          $node->book['bid'] = $node->nid;        }        $node->book['nid'] = $node->nid;        $node->book['menu_name'] = book_menu_name($node->book['bid']);        _book_update_outline($node);      }      break;    case 'delete':      if (!empty($node->book['bid'])) {        if ($node->nid == $node->book['bid']) {          // Handle deletion of a top-level post.          $result = db_query("SELECT b.nid FROM {menu_links} ml INNER JOIN {book} b on b.mlid = ml.mlid WHERE ml.plid = %d", $node->book['mlid']);          while ($child = db_fetch_array($result)) {            $child_node = node_load($child['nid']);            $child_node->book['bid'] = $child_node->nid;            _book_update_outline($child_node);          }        }        menu_link_delete($node->book['mlid']);        db_query('DELETE FROM {book} WHERE mlid = %d', $node->book['mlid']);      }      break;    case 'prepare':      // Prepare defaults for the add/edit form.      if (empty($node->book) && (user_access('add content to books') || user_access('administer book outlines'))) {        $node->book = array();        if (empty($node->nid) && isset($_GET['parent']) && is_numeric($_GET['parent'])) {          // Handle "Add child page" links:          $parent = book_link_load($_GET['parent']);          if ($parent && $parent['access']) {            $node->book['bid'] = $parent['bid'];            $node->book['plid'] = $parent['mlid'];            $node->book['menu_name'] = $parent['menu_name'];          }        }        // Set defaults.        $node->book += _book_link_defaults(!empty($node->nid) ? $node->nid : 'new');      }      else {        if (isset($node->book['bid']) && !isset($node->book['original_bid'])) {          $node->book['original_bid'] = $node->book['bid'];        }      }      // Find the depth limit for the parent select.      if (isset($node->book['bid']) && !isset($node->book['parent_depth_limit'])) {        $node->book['parent_depth_limit'] = _book_parent_depth_limit($node->book);      }      break;  }}/** * Find the depth limit for items in the parent select. */function _book_parent_depth_limit($book_link) {  return MENU_MAX_DEPTH - 1 - (($book_link['mlid'] && $book_link['has_children']) ? menu_link_children_relative_depth($book_link) : 0);}/** * Form altering function for the confirm form for a single node deletion. */function book_form_node_delete_confirm_alter(&$form, $form_state) {  $node = node_load($form['nid']['#value']);  if (isset($node->book) && $node->book['has_children']) {    $form['book_warning'] = array(      '#value' => '<p>'. t('%title is part of a book outline, and has associated child pages. If you proceed with deletion, the child pages will be relocated automatically.', array('%title' => $node->title)) .'</p>',      '#weight' => -10,    );  }}/** * Return an array with default values for a book link. */function _book_link_defaults($nid) {  return array('original_bid' => 0, 'menu_name' => '', 'nid' => $nid, 'bid' => 0, 'router_path' => 'node/%', 'plid' => 0, 'mlid' => 0, 'has_children' => 0, 'weight' => 0, 'module' => 'book', 'options' => array());}/** * Process variables for book-navigation.tpl.php. * * The $variables array contains the following arguments: * - $book_link * * @see book-navigation.tpl.php */function template_preprocess_book_navigation(&$variables) {  $book_link = $variables['book_link'];  // Provide extra variables for themers. Not needed by default.  $variables['book_id'] = $book_link['bid'];  $variables['book_title'] = check_plain($book_link['link_title']);  $variables['book_url'] = 'node/'. $book_link['bid'];  $variables['current_depth'] = $book_link['depth'];  $variables['tree'] = '';  if ($book_link['mlid']) {    $variables['tree'] = book_children($book_link);    if ($prev = book_prev($book_link)) {      $prev_href = url($prev['href']);      drupal_add_link(array('rel' => 'prev', 'href' => $prev_href));      $variables['prev_url'] = $prev_href;      $variables['prev_title'] = check_plain($prev['title']);    }    if ($book_link['plid'] && $parent = book_link_load($book_link['plid'])) {      $parent_href = url($parent['href']);      drupal_add_link(array('rel' => 'up', 'href' => $parent_href));      $variables['parent_url'] = $parent_href;      $variables['parent_title'] = check_plain($parent['title']);    }    if ($next = book_next($book_link)) {      $next_href = url($next['href']);      drupal_add_link(array('rel' => 'next', 'href' => $next_href));      $variables['next_url'] = $next_href;      $variables['next_title'] = check_plain($next['title']);    }  }  $variables['has_links'] = FALSE;  // Link variables to filter for values and set state of the flag variable.  $links = array('prev_url', 'prev_title', 'parent_url', 'parent_title', 'next_url', 'next_title');  foreach ($links as $link) {    if (isset($variables[$link])) {      // Flag when there is a value.      $variables['has_links'] = TRUE;    }    else {      // Set empty to prevent notices.      $variables[$link] = '';    }  }}/** * A recursive helper function for book_toc(). */function _book_toc_recurse($tree, $indent, &$toc, $exclude, $depth_limit) {  foreach ($tree as $data) {    if ($data['link']['depth'] > $depth_limit) {      // Don't iterate through any links on this level.      break;    }    if (!in_array($data['link']['mlid'], $exclude)) {      $toc[$data['link']['mlid']] = $indent .' '. truncate_utf8($data['link']['title'], 30, TRUE, TRUE);      if ($data['below']) {        _book_toc_recurse($data['below'], $indent .'--', $toc, $exclude, $depth_limit);      }    }  }}/** * Returns an array of book pages in table of contents order. * * @param $bid *   The ID of the book whose pages are to be listed. * @param $exclude *   Optional array of mlid values.  Any link whose mlid is in this array *   will be excluded (along with its children). * @param $depth_limit *   Any link deeper than this value will be excluded (along with its children). * @return *   An array of mlid, title pairs for use as options for selecting a book page. */function book_toc($bid, $exclude = array(), $depth_limit) {  $tree = menu_tree_all_data(book_menu_name($bid));  $toc = array();  _book_toc_recurse($tree, '', $toc, $exclude, $depth_limit);  return $toc;}/** * Process variables for book-export-html.tpl.php. * * The $variables array contains the following arguments: * - $title * - $contents * - $depth * * @see book-export-html.tpl.php */function template_preprocess_book_export_html(&$variables) {  global $base_url, $language;  $variables['title'] = check_plain($variables['title']);  $variables['base_url'] = $base_url;  $variables['language'] = $language;  $variables['language_rtl'] = ($language->direction == LANGUAGE_RTL);  $variables['head'] = drupal_get_html_head();}/** * Traverse the book tree to build printable or exportable output. * * During the traversal, the $visit_func() callback is applied to each * node, and is called recursively for each child of the node (in weight, * title order). * * @param $tree *   A subtree of the book menu hierarchy, rooted at the current page. * @param $visit_func *   A function callback to be called upon visiting a node in the tree. * @return *   The output generated in visiting each node. */function book_export_traverse($tree, $visit_func) {  $output = '';  foreach ($tree as $data) {    // Note- access checking is already performed when building the tree.    if ($node = node_load($data['link']['nid'], FALSE)) {      $children = '';      if ($data['below']) {        $children = book_export_traverse($data['below'], $visit_func);      }      if (function_exists($visit_func)) {        $output .= call_user_func($visit_func, $node, $children);      }      else {        // Use the default function.        $output .= book_node_export($node, $children);      }    }  }  return $output;}/** * Generates printer-friendly HTML for a node. * * @see book_export_traverse() * * @param $node *   The node to generate output for. * @param $children *   All the rendered child nodes within the current node. * @return *   The HTML generated for the given node. */function book_node_export($node, $children = '') {  $node->build_mode = NODE_BUILD_PRINT;  $node = node_build_content($node, FALSE, FALSE);  $node->body = drupal_render($node->content);  return theme('book_node_export_html', $node, $children);}/** * Process variables for book-node-export-html.tpl.php. * * The $variables array contains the following arguments: * - $node * - $children * * @see book-node-export-html.tpl.php */function template_preprocess_book_node_export_html(&$variables) {  $variables['depth'] = $variables['node']->book['depth'];  $variables['title'] = check_plain($variables['node']->title);  $variables['content'] = $variables['node']->body;}/** * Determine if a given node type is in the list of types allowed for books. */function book_type_is_allowed($type) {  return in_array($type, variable_get('book_allowed_types', array('book')));}/** * Implementation of hook_node_type(). * * Update book module's persistent variables if the machine-readable name of a * node type is changed. */function book_node_type($op, $type) {  switch ($op) {    case 'update':      if (!empty($type->old_type) && $type->old_type != $type->type) {        // Update the list of node types that are allowed to be added to books.        $allowed_types = variable_get('book_allowed_types', array('book'));        $key = array_search($type->old_type, $allowed_types);        if ($key !== FALSE) {          $allowed_types[$type->type] = $allowed_types[$key] ? $type->type : 0;          unset($allowed_types[$key]);          variable_set('book_allowed_types', $allowed_types);        }        // Update the setting for the "Add child page" link.        if (variable_get('book_child_type', 'book') == $type->old_type) {          variable_set('book_child_type', $type->type);        }      }      break;  }}/** * Implementation of hook_help(). */function book_help($path, $arg) {  switch ($path) {    case 'admin/help#book':      $output = '<p>'. t('The book module is suited for creating structured, multi-page hypertexts such as site resource guides, manuals, and Frequently Asked Questions (FAQs). It permits a document to have chapters, sections, subsections, etc. Authors with suitable permissions can add pages to a collaborative book, placing them into the existing document by adding them to a table of contents menu.') .'</p>';      $output .= '<p>'. t('Pages in the book hierarchy have navigation elements at the bottom of the page for moving through the text. These links lead to the previous and next pages in the book, and to the level above the current page in the book\'s structure. More comprehensive navigation may be provided by enabling the <em>book navigation block</em> on the <a href="@admin-block">blocks administration page</a>.', array('@admin-block' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('Users can select the <em>printer-friendly version</em> link visible at the bottom of a book page to generate a printer-friendly display of the page and all of its subsections. ') .'</p>';      $output .= '<p>'. t("Users with the <em>administer book outlines</em> permission can add a post of any content type to a book, by selecting the appropriate book while editing the post or by using the interface available on the post's <em>outline</em> tab.") .'</p>';      $output .= '<p>'. t('Administrators can view a list of all books on the <a href="@admin-node-book">book administration page</a>. The <em>Outline</em> page for each book allows section titles to be edited or rearranged.', array('@admin-node-book' => url('admin/content/book'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@book">Book module</a>.', array('@book' => 'http://drupal.org/handbook/modules/book/')) .'</p>';      return $output;    case 'admin/content/book':      return '<p>'. t('The book module offers a means to organize a collection of related posts, collectively known as a book. When viewed, these posts automatically display links to adjacent book pages, providing a simple navigation system for creating and reviewing structured content.') .'</p>';    case 'node/%/outline':      return '<p>'. t('The outline feature allows you to include posts in the <a href="@book">book hierarchy</a>, as well as move them within the hierarchy or to <a href="@book-admin">reorder an entire book</a>.', array('@book' => url('book'), '@book-admin' => url('admin/content/book'))) .'</p>';  }}/** * Like menu_link_load(), but adds additional data from the {book} table. * * Do not call when loading a node, since this function may call node_load(). */function book_link_load($mlid) {  if ($item = db_fetch_array(db_query("SELECT * FROM {menu_links} ml INNER JOIN {book} b ON b.mlid = ml.mlid LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = %d", $mlid))) {    _menu_link_translate($item);    return $item;  }  return FALSE;}/** * Get the data representing a subtree of the book hierarchy. * * The root of the subtree will be the link passed as a parameter, so the * returned tree will contain this item and all its descendents in the menu tree. * * @param $item *   A fully loaded menu link. * @return *   An subtree of menu links in an array, in the order they should be rendered. */function book_menu_subtree_data($item) {  static $tree = array();  // Generate a cache ID (cid) specific for this $menu_name and $item.  $cid = 'links:'. $item['menu_name'] .':subtree-cid:'. $item['mlid'];  if (!isset($tree[$cid])) {    $cache = cache_get($cid, 'cache_menu');    if ($cache && isset($cache->data)) {      // If the cache entry exists, it will just be the cid for the actual data.      // This avoids duplication of large amounts of data.      $cache = cache_get($cache->data, 'cache_menu');      if ($cache && isset($cache->data)) {        $data = $cache->data;      }    }    // If the subtree data was not in the cache, $data will be NULL.    if (!isset($data)) {      $match = array("menu_name = '%s'");      $args = array($item['menu_name']);      $i = 1;      while ($i <= MENU_MAX_DEPTH && $item["p$i"]) {        $match[] = "p$i = %d";        $args[] = $item["p$i"];        $i++;      }      $sql = "        SELECT b.*, m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, ml.*        FROM {menu_links} ml INNER JOIN {menu_router} m ON m.path = ml.router_path        INNER JOIN {book} b ON ml.mlid = b.mlid        WHERE ". implode(' AND ', $match) ."        ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC";      $data['tree'] = menu_tree_data(db_query($sql, $args), array(), $item['depth']);      $data['node_links'] = array();      menu_tree_collect_node_links($data['tree'], $data['node_links']);      // Compute the real cid for book subtree data.      $tree_cid = 'links:'. $item['menu_name'] .':subtree-data:'. md5(serialize($data));      // Cache the data, if it is not already in the cache.      if (!cache_get($tree_cid, 'cache_menu')) {        cache_set($tree_cid, $data, 'cache_menu');      }      // Cache the cid of the (shared) data using the menu and item-specific cid.      cache_set($cid, $tree_cid, 'cache_menu');    }    // Check access for the current user to each item in the tree.    menu_tree_check_access($data['tree'], $data['node_links']);    $tree[$cid] = $data['tree'];  }  return $tree[$cid];}
<?php// $Id$/** * Compose and optionally send an e-mail message. * * Sending an e-mail works with defining an e-mail template (subject, text * and possibly e-mail headers) and the replacement values to use in the * appropriate places in the template. Processed e-mail templates are * requested from hook_mail() from the module sending the e-mail. Any module * can modify the composed e-mail message array using hook_mail_alter(). * Finally drupal_mail_send() sends the e-mail, which can be reused * if the exact same composed e-mail is to be sent to multiple recipients. * * Finding out what language to send the e-mail with needs some consideration. * If you send e-mail to a user, her preferred language should be fine, so * use user_preferred_language(). If you send email based on form values * filled on the page, there are two additional choices if you are not * sending the e-mail to a user on the site. You can either use the language * used to generate the page ($language global variable) or the site default * language. See language_default(). The former is good if sending e-mail to * the person filling the form, the later is good if you send e-mail to an * address previously set up (like contact addresses in a contact form). * * Taking care of always using the proper language is even more important * when sending e-mails in a row to multiple users. Hook_mail() abstracts * whether the mail text comes from an administrator setting or is * static in the source code. It should also deal with common mail tokens, * only receiving $params which are unique to the actual e-mail at hand. * * An example: * * @code *   function example_notify($accounts) { *     foreach ($accounts as $account) { *       $params['account'] = $account; *       // example_mail() will be called based on the first drupal_mail() parameter. *       drupal_mail('example', 'notice', $account->mail, user_preferred_language($account), $params); *     } *   } * *   function example_mail($key, &$message, $params) { *     $language = $message['language']; *     $variables = user_mail_tokens($params['account'], $language); *     switch($key) { *       case 'notice': *         $message['subject'] = t('Notification from !site', $variables, $language->language); *         $message['body'][] = t("Dear !username\n\nThere is new content available on the site.", $variables, $language->language); *         break; *     } *   } * @endcode * * @param $module *   A module name to invoke hook_mail() on. The {$module}_mail() hook will be *   called to complete the $message structure which will already contain common *   defaults. * @param $key *   A key to identify the e-mail sent. The final e-mail id for e-mail altering *   will be {$module}_{$key}. * @param $to *   The e-mail address or addresses where the message will be sent to. The *   formatting of this string must comply with RFC 2822. Some examples are: *    user@example.com *    user@example.com, anotheruser@example.com *    User <user@example.com> *    User <user@example.com>, Another User <anotheruser@example.com> * @param $language *   Language object to use to compose the e-mail. * @param $params *   Optional parameters to build the e-mail. * @param $from *   Sets From to this value, if given. * @param $send *   Send the message directly, without calling drupal_mail_send() manually. * @return *   The $message array structure containing all details of the *   message. If already sent ($send = TRUE), then the 'result' element *   will contain the success indicator of the e-mail, failure being already *   written to the watchdog. (Success means nothing more than the message being *   accepted at php-level, which still doesn't guarantee it to be delivered.) */function drupal_mail($module, $key, $to, $language, $params = array(), $from = NULL, $send = TRUE) {  $default_from = variable_get('site_mail', ini_get('sendmail_from'));  // Bundle up the variables into a structured array for altering.  $message = array(    'id'       => $module .'_'. $key,    'to'       => $to,    'from'     => isset($from) ? $from : $default_from,    'language' => $language,    'params'   => $params,    'subject'  => '',    'body'     => array()  );  // Build the default headers  $headers = array(    'MIME-Version'              => '1.0',    'Content-Type'              => 'text/plain; charset=UTF-8; format=flowed; delsp=yes',    'Content-Transfer-Encoding' => '8Bit',    'X-Mailer'                  => 'Drupal'  );  if ($default_from) {    // To prevent e-mail from looking like spam, the addresses in the Sender and    // Return-Path headers should have a domain authorized to use the originating    // SMTP server. Errors-To is redundant, but shouldn't hurt.    $headers['From'] = $headers['Sender'] = $headers['Return-Path'] = $headers['Errors-To'] = $default_from;  }  if ($from) {    $headers['From'] = $from;  }  $message['headers'] = $headers;  // Build the e-mail (get subject and body, allow additional headers) by  // invoking hook_mail() on this module. We cannot use module_invoke() as  // we need to have $message by reference in hook_mail().  if (function_exists($function = $module .'_mail')) {    $function($key, $message, $params);  }  // Invoke hook_mail_alter() to allow all modules to alter the resulting e-mail.  drupal_alter('mail', $message);  // Concatenate and wrap the e-mail body.  $message['body'] = is_array($message['body']) ? drupal_wrap_mail(implode("\n\n", $message['body'])) : drupal_wrap_mail($message['body']);  // Optionally send e-mail.  if ($send) {    $message['result'] = drupal_mail_send($message);    // Log errors    if (!$message['result']) {      watchdog('mail', 'Error sending e-mail (from %from to %to).', array('%from' => $message['from'], '%to' => $message['to']), WATCHDOG_ERROR);      drupal_set_message(t('Unable to send e-mail. Please contact the site administrator if the problem persists.'), 'error');    }  }  return $message;}/** * Send an e-mail message, using Drupal variables and default settings. * More information in the <a href="http://php.net/manual/en/function.mail.php"> * PHP function reference for mail()</a>. See drupal_mail() for information on * how $message is composed. * * @param $message *  Message array with at least the following elements: *   - id *      A unique identifier of the e-mail type. Examples: 'contact_user_copy', *      'user_password_reset'. *   - to *      The mail address or addresses where the message will be sent to. The *      formatting of this string must comply with RFC 2822. Some examples are: *       user@example.com *       user@example.com, anotheruser@example.com *       User <user@example.com> *       User <user@example.com>, Another User <anotheruser@example.com> *   - subject *      Subject of the e-mail to be sent. This must not contain any newline *      characters, or the mail may not be sent properly. *   - body *      Message to be sent. Accepts both CRLF and LF line-endings. *      E-mail bodies must be wrapped. You can use drupal_wrap_mail() for *      smart plain text wrapping. *   - headers *      Associative array containing all mail headers. * @return *   Returns TRUE if the mail was successfully accepted for delivery, *   FALSE otherwise. */function drupal_mail_send($message) {  // Allow for a custom mail backend.  if (variable_get('smtp_library', '') && file_exists(variable_get('smtp_library', ''))) {    include_once './'. variable_get('smtp_library', '');    return drupal_mail_wrapper($message);  }  else {    $mimeheaders = array();    foreach ($message['headers'] as $name => $value) {      $mimeheaders[] = $name .': '. mime_header_encode($value);    }    return mail(      $message['to'],      mime_header_encode($message['subject']),      // Note: e-mail uses CRLF for line-endings, but PHP's API requires LF.      // They will appear correctly in the actual e-mail that is sent.      str_replace("\r", '', $message['body']),      // For headers, PHP's API suggests that we use CRLF normally,      // but some MTAs incorrecly replace LF with CRLF. See #234403.      join("\n", $mimeheaders)    );  }}/** * Perform format=flowed soft wrapping for mail (RFC 3676). * * We use delsp=yes wrapping, but only break non-spaced languages when * absolutely necessary to avoid compatibility issues. * * We deliberately use LF rather than CRLF, see drupal_mail(). * * @param $text *   The plain text to process. * @param $indent (optional) *   A string to indent the text with. Only '>' characters are repeated on *   subsequent wrapped lines. Others are replaced by spaces. */function drupal_wrap_mail($text, $indent = '') {  // Convert CRLF into LF.  $text = str_replace("\r", '', $text);  // See if soft-wrapping is allowed.  $clean_indent = _drupal_html_to_text_clean($indent);  $soft = strpos($clean_indent, ' ') === FALSE;  // Check if the string has line breaks.  if (strpos($text, "\n") !== FALSE) {    // Remove trailing spaces to make existing breaks hard.    $text = preg_replace('/ +\n/m', "\n", $text);    // Wrap each line at the needed width.    $lines = explode("\n", $text);    array_walk($lines, '_drupal_wrap_mail_line', array('soft' => $soft, 'length' => strlen($indent)));    $text = implode("\n", $lines);  }  else {    // Wrap this line.    _drupal_wrap_mail_line($text, 0, array('soft' => $soft, 'length' => strlen($indent)));  }  // Empty lines with nothing but spaces.  $text = preg_replace('/^ +\n/m', "\n", $text);  // Space-stuff special lines.  $text = preg_replace('/^(>| |From)/m', ' $1', $text);  // Apply indentation. We only include non-'>' indentation on the first line.  $text = $indent . substr(preg_replace('/^/m', $clean_indent, $text), strlen($indent));  return $text;}/** * Transform an HTML string into plain text, preserving the structure of the * markup. Useful for preparing the body of a node to be sent by e-mail. * * The output will be suitable for use as 'format=flowed; delsp=yes' text * (RFC 3676) and can be passed directly to drupal_mail() for sending. * * We deliberately use LF rather than CRLF, see drupal_mail(). * * This function provides suitable alternatives for the following tags: * <a> <em> <i> <strong> <b> <br> <p> <blockquote> <ul> <ol> <li> <dl> <dt> * <dd> <h1> <h2> <h3> <h4> <h5> <h6> <hr> * * @param $string *   The string to be transformed. * @param $allowed_tags (optional) *   If supplied, a list of tags that will be transformed. If omitted, all *   all supported tags are transformed. * @return *   The transformed string. */function drupal_html_to_text($string, $allowed_tags = NULL) {  // Cache list of supported tags.  static $supported_tags;  if (empty($supported_tags)) {    $supported_tags = array('a', 'em', 'i', 'strong', 'b', 'br', 'p', 'blockquote', 'ul', 'ol', 'li', 'dl', 'dt', 'dd', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr');  }  // Make sure only supported tags are kept.  $allowed_tags = isset($allowed_tags) ? array_intersect($supported_tags, $allowed_tags) : $supported_tags;  // Make sure tags, entities and attributes are well-formed and properly nested.  $string = _filter_htmlcorrector(filter_xss($string, $allowed_tags));  // Apply inline styles.  $string = preg_replace('!</?(em|i)((?> +)[^>]*)?>!i', '/', $string);  $string = preg_replace('!</?(strong|b)((?> +)[^>]*)?>!i', '*', $string);  // Replace inline <a> tags with the text of link and a footnote.  // 'See <a href="http://drupal.org">the Drupal site</a>' becomes  // 'See the Drupal site [1]' with the URL included as a footnote.  _drupal_html_to_mail_urls(NULL, TRUE);  $pattern = '@(<a[^>]+?href="([^"]*)"[^>]*?>(.+?)</a>)@i';  $string = preg_replace_callback($pattern, '_drupal_html_to_mail_urls', $string);  $urls = _drupal_html_to_mail_urls();  $footnotes = '';  if (count($urls)) {    $footnotes .= "\n";    for ($i = 0, $max = count($urls); $i < $max; $i++) {      $footnotes .= '['. ($i + 1) .'] '. $urls[$i] ."\n";    }  }  // Split tags from text.  $split = preg_split('/<([^>]+?)>/', $string, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting $null as required).  $tag = FALSE; // Odd/even counter (tag or no tag)  $casing = NULL; // Case conversion function  $output = '';  $indent = array(); // All current indentation string chunks  $lists = array(); // Array of counters for opened lists  foreach ($split as $value) {    $chunk = NULL; // Holds a string ready to be formatted and output.    // Process HTML tags (but don't output any literally).    if ($tag) {      list($tagname) = explode(' ', strtolower($value), 2);      switch ($tagname) {        // List counters        case 'ul':          array_unshift($lists, '*');          break;        case 'ol':          array_unshift($lists, 1);          break;        case '/ul':        case '/ol':          array_shift($lists);          $chunk = ''; // Ensure blank new-line.          break;        // Quotation/list markers, non-fancy headers        case 'blockquote':          // Format=flowed indentation cannot be mixed with lists.          $indent[] = count($lists) ? ' "' : '>';          break;        case 'li':          $indent[] = is_numeric($lists[0]) ? ' '. $lists[0]++ .') ' : ' * ';          break;        case 'dd':          $indent[] = '    ';          break;        case 'h3':          $indent[] = '.... ';          break;        case 'h4':          $indent[] = '.. ';          break;        case '/blockquote':          if (count($lists)) {            // Append closing quote for inline quotes (immediately).            $output = rtrim($output, "> \n") ."\"\n";            $chunk = ''; // Ensure blank new-line.          }          // Fall-through        case '/li':        case '/dd':          array_pop($indent);          break;        case '/h3':        case '/h4':          array_pop($indent);        case '/h5':        case '/h6':          $chunk = ''; // Ensure blank new-line.          break;        // Fancy headers        case 'h1':          $indent[] = '======== ';          $casing = 'drupal_strtoupper';          break;        case 'h2':          $indent[] = '-------- ';          $casing = 'drupal_strtoupper';          break;        case '/h1':        case '/h2':          $casing = NULL;          // Pad the line with dashes.          $output = _drupal_html_to_text_pad($output, ($tagname == '/h1') ? '=' : '-', ' ');          array_pop($indent);          $chunk = ''; // Ensure blank new-line.          break;        // Horizontal rulers        case 'hr':          // Insert immediately.          $output .= drupal_wrap_mail('', implode('', $indent)) ."\n";          $output = _drupal_html_to_text_pad($output, '-');          break;        // Paragraphs and definition lists        case '/p':        case '/dl':          $chunk = ''; // Ensure blank new-line.          break;      }    }    // Process blocks of text.    else {      // Convert inline HTML text to plain text.      $value = trim(preg_replace('/\s+/', ' ', decode_entities($value)));      if (strlen($value)) {        $chunk = $value;      }    }    // See if there is something waiting to be output.    if (isset($chunk)) {      // Apply any necessary case conversion.      if (isset($casing)) {        $chunk = $casing($chunk);      }      // Format it and apply the current indentation.      $output .= drupal_wrap_mail($chunk, implode('', $indent)) ."\n";      // Remove non-quotation markers from indentation.      $indent = array_map('_drupal_html_to_text_clean', $indent);    }    $tag = !$tag;  }  return $output . $footnotes;}/** * Helper function for array_walk in drupal_wrap_mail(). * * Wraps words on a single line. */function _drupal_wrap_mail_line(&$line, $key, $values) {  // Use soft-breaks only for purely quoted or unindented text.  $line = wordwrap($line, 77 - $values['length'], $values['soft'] ? "  \n" : "\n");  // Break really long words at the maximum width allowed.  $line = wordwrap($line, 996 - $values['length'], $values['soft'] ? " \n" : "\n");}/** * Helper function for drupal_html_to_text(). * * Keeps track of URLs and replaces them with placeholder tokens. */function _drupal_html_to_mail_urls($match = NULL, $reset = FALSE) {  global $base_url, $base_path;  static $urls = array(), $regexp;  if ($reset) {    // Reset internal URL list.    $urls = array();  }  else {    if (empty($regexp)) {      $regexp = '@^'. preg_quote($base_path, '@') .'@';    }    if ($match) {      list(, , $url, $label) = $match;      // Ensure all URLs are absolute.      $urls[] = strpos($url, '://') ? $url : preg_replace($regexp, $base_url .'/', $url);      return $label .' ['. count($urls) .']';    }  }  return $urls;}/** * Helper function for drupal_wrap_mail() and drupal_html_to_text(). * * Replace all non-quotation markers from a given piece of indentation with spaces. */function _drupal_html_to_text_clean($indent) {  return preg_replace('/[^>]/', ' ', $indent);}/** * Helper function for drupal_html_to_text(). * * Pad the last line with the given character. */function _drupal_html_to_text_pad($text, $pad, $prefix = '') {  // Remove last line break.  $text = substr($text, 0, -1);  // Calculate needed padding space and add it.  if (($p = strrpos($text, "\n")) === FALSE) {    $p = -1;  }  $n = max(0, 79 - (strlen($text) - $p));  // Add prefix and padding, and restore linebreak.  return $text . $prefix . str_repeat($pad, $n - strlen($prefix)) ."\n";}
<?php// $Id$/** * @file * Admin page callbacks for the aggregator module. *//** * Menu callback; displays the aggregator administration page. */function aggregator_admin_overview() {  return aggregator_view();}/** * Displays the aggregator administration page. * * @return *   The page HTML. */function aggregator_view() {  $result = db_query('SELECT f.*, COUNT(i.iid) AS items FROM {aggregator_feed} f LEFT JOIN {aggregator_item} i ON f.fid = i.fid GROUP BY f.fid, f.title, f.url, f.refresh, f.checked, f.link, f.description, f.etag, f.modified, f.image, f.block ORDER BY f.title');  $output = '<h3>'. t('Feed overview') .'</h3>';  $header = array(t('Title'), t('Items'), t('Last update'), t('Next update'), array('data' => t('Operations'), 'colspan' => '3'));  $rows = array();  while ($feed = db_fetch_object($result)) {    $rows[] = array(l($feed->title, "aggregator/sources/$feed->fid"), format_plural($feed->items, '1 item', '@count items'), ($feed->checked ? t('@time ago', array('@time' => format_interval(time() - $feed->checked))) : t('never')), ($feed->checked ? t('%time left', array('%time' => format_interval($feed->checked + $feed->refresh - time()))) : t('never')), l(t('edit'), "admin/content/aggregator/edit/feed/$feed->fid"), l(t('remove items'), "admin/content/aggregator/remove/$feed->fid"), l(t('update items'), "admin/content/aggregator/update/$feed->fid"));  }  $output .= theme('table', $header, $rows);  $result = db_query('SELECT c.cid, c.title, count(ci.iid) as items FROM {aggregator_category} c LEFT JOIN {aggregator_category_item} ci ON c.cid = ci.cid GROUP BY c.cid, c.title ORDER BY title');  $output .= '<h3>'. t('Category overview') .'</h3>';  $header = array(t('Title'), t('Items'), t('Operations'));  $rows = array();  while ($category = db_fetch_object($result)) {    $rows[] = array(l($category->title, "aggregator/categories/$category->cid"), format_plural($category->items, '1 item', '@count items'), l(t('edit'), "admin/content/aggregator/edit/category/$category->cid"));  }  $output .= theme('table', $header, $rows);  return $output;}/** * Form builder; Generate a form to add/edit feed sources. * * @ingroup forms * @see aggregator_form_feed_validate() * @see aggregator_form_feed_submit() */function aggregator_form_feed(&$form_state, $edit = array('refresh' => 900, 'title' => '', 'url' => '', 'fid' => NULL)) {  $period = drupal_map_assoc(array(900, 1800, 3600, 7200, 10800, 21600, 32400, 43200, 64800, 86400, 172800, 259200, 604800, 1209600, 2419200), 'format_interval');  if ($edit['refresh'] == '') {    $edit['refresh'] = 3600;  }  $form['title'] = array('#type' => 'textfield',    '#title' => t('Title'),    '#default_value' => $edit['title'],    '#maxlength' => 255,    '#description' => t('The name of the feed (or the name of the website providing the feed).'),    '#required' => TRUE,  );  $form['url'] = array('#type' => 'textfield',    '#title' => t('URL'),    '#default_value' => $edit['url'],    '#maxlength' => 255,    '#description' => t('The fully-qualified URL of the feed.'),    '#required' => TRUE,  );  $form['refresh'] = array('#type' => 'select',    '#title' => t('Update interval'),    '#default_value' => $edit['refresh'],    '#options' => $period,    '#description' => t('The length of time between feed updates. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status'))),  );  // Handling of categories:  $options = array();  $values = array();  $categories = db_query('SELECT c.cid, c.title, f.fid FROM {aggregator_category} c LEFT JOIN {aggregator_category_feed} f ON c.cid = f.cid AND f.fid = %d ORDER BY title', $edit['fid']);  while ($category = db_fetch_object($categories)) {    $options[$category->cid] = check_plain($category->title);    if ($category->fid) $values[] = $category->cid;  }  if ($options) {    $form['category'] = array('#type' => 'checkboxes',      '#title' => t('Categorize news items'),      '#default_value' => $values,      '#options' => $options,      '#description' => t('New feed items are automatically filed in the checked categories.'),    );  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));  if ($edit['fid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['fid'] = array('#type' => 'hidden', '#value' => $edit['fid']);  }  return $form;}/** * Validate aggregator_form_feed form submissions. */function aggregator_form_feed_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Save')) {    // Ensure URL is valid.    if (!valid_url($form_state['values']['url'], TRUE)) {      form_set_error('url', t('The URL %url is invalid. Please enter a fully-qualified URL, such as http://www.example.com/feed.xml.', array('%url' => $form_state['values']['url'])));    }    // Check for duplicate titles.    if (isset($form_state['values']['fid'])) {      $result = db_query("SELECT title, url FROM {aggregator_feed} WHERE (title = '%s' OR url = '%s') AND fid <> %d", $form_state['values']['title'], $form_state['values']['url'], $form_state['values']['fid']);    }    else {      $result = db_query("SELECT title, url FROM {aggregator_feed} WHERE title = '%s' OR url = '%s'", $form_state['values']['title'], $form_state['values']['url']);    }    while ($feed = db_fetch_object($result)) {      if (strcasecmp($feed->title, $form_state['values']['title']) == 0) {        form_set_error('title', t('A feed named %feed already exists. Please enter a unique title.', array('%feed' => $form_state['values']['title'])));      }      if (strcasecmp($feed->url, $form_state['values']['url']) == 0) {        form_set_error('url', t('A feed with this URL %url already exists. Please enter a unique URL.', array('%url' => $form_state['values']['url'])));      }    }  }}/** * Process aggregator_form_feed form submissions. * * @todo Add delete confirmation dialog. */function aggregator_form_feed_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Delete')) {    $title = $form_state['values']['title'];    // Unset the title:    unset($form_state['values']['title']);  }  aggregator_save_feed($form_state['values']);  if (isset($form_state['values']['fid'])) {    if (isset($form_state['values']['title'])) {      drupal_set_message(t('The feed %feed has been updated.', array('%feed' => $form_state['values']['title'])));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/sources/'. $form_state['values']['fid'];        return;      }    }    else {      watchdog('aggregator', 'Feed %feed deleted.', array('%feed' => $title));      drupal_set_message(t('The feed %feed has been deleted.', array('%feed' => $title)));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/sources/';        return;      }    }  }  else {    watchdog('aggregator', 'Feed %feed added.', array('%feed' => $form_state['values']['title']), WATCHDOG_NOTICE, l(t('view'), 'admin/content/aggregator'));    drupal_set_message(t('The feed %feed has been added.', array('%feed' => $form_state['values']['title'])));  }}function aggregator_admin_remove_feed($form_state, $feed) {  return confirm_form(    array(      'feed' => array(        '#type' => 'value',        '#value' => $feed,      ),    ),    t('Are you sure you want to remove all items from the feed %feed?', array('%feed' => $feed['title'])),    'admin/content/aggregator',    t('This action cannot be undone.'),    t('Remove items'),    t('Cancel')  );}/** * Remove all items from a feed and redirect to the overview page. * * @param $feed *   An associative array describing the feed to be cleared. */function aggregator_admin_remove_feed_submit($form, &$form_state) {  aggregator_remove($form_state['values']['feed']);  $form_state['redirect'] = 'admin/content/aggregator';}/** * Menu callback; refreshes a feed, then redirects to the overview page. * * @param $feed *   An associative array describing the feed to be refreshed. */function aggregator_admin_refresh_feed($feed) {  aggregator_refresh($feed);  drupal_goto('admin/content/aggregator');}/** * Form builder; Configure the aggregator system. * * @ingroup forms * @see system_settings_form() */function aggregator_admin_settings() {  $items = array(0 => t('none')) + drupal_map_assoc(array(3, 5, 10, 15, 20, 25), '_aggregator_items');  $period = drupal_map_assoc(array(3600, 10800, 21600, 32400, 43200, 86400, 172800, 259200, 604800, 1209600, 2419200, 4838400, 9676800), 'format_interval');  $form['aggregator_allowed_html_tags'] = array(    '#type' => 'textfield', '#title' => t('Allowed HTML tags'), '#size' => 80, '#maxlength' => 255,    '#default_value' => variable_get('aggregator_allowed_html_tags', '<a> <b> <br> <dd> <dl> <dt> <em> <i> <li> <ol> <p> <strong> <u> <ul>'),    '#description' => t('A space-separated list of HTML tags allowed in the content of feed items. (Tags in this list are not removed by Drupal.)')  );  $form['aggregator_summary_items'] = array(    '#type' => 'select', '#title' => t('Items shown in sources and categories pages') ,    '#default_value' => variable_get('aggregator_summary_items', 3), '#options' => $items,    '#description' => t('Number of feed items displayed in feed and category summary pages.')  );  $form['aggregator_clear'] = array(    '#type' => 'select', '#title' => t('Discard items older than'),    '#default_value' => variable_get('aggregator_clear', 9676800), '#options' => $period,    '#description' => t('The length of time to retain feed items before discarding. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status')))  );  $form['aggregator_category_selector'] = array(    '#type' => 'radios', '#title' => t('Category selection type'), '#default_value' => variable_get('aggregator_category_selector', 'checkboxes'),    '#options' => array('checkboxes' => t('checkboxes'), 'select' => t('multiple selector')),    '#description' => t('The type of category selection widget displayed on categorization pages. (For a small number of categories, checkboxes are easier to use, while a multiple selector work well with large numbers of categories.)')  );  return system_settings_form($form);}/** * Form builder; Generate a form to add/edit/delete aggregator categories. * * @ingroup forms * @see aggregator_form_category_validate() * @see aggregator_form_category_submit() */function aggregator_form_category(&$form_state, $edit = array('title' => '', 'description' => '', 'cid' => NULL)) {  $form['title'] = array('#type' => 'textfield',    '#title' => t('Title'),    '#default_value' => $edit['title'],    '#maxlength' => 64,    '#required' => TRUE,  );  $form['description'] = array('#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));  if ($edit['cid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['cid'] = array('#type' => 'hidden', '#value' => $edit['cid']);  }  return $form;}/** * Validate aggregator_form_feed form submissions. */function aggregator_form_category_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Save')) {    // Check for duplicate titles    if (isset($form_state['values']['cid'])) {      $category = db_fetch_object(db_query("SELECT cid FROM {aggregator_category} WHERE title = '%s' AND cid <> %d", $form_state['values']['title'], $form_state['values']['cid']));    }    else {      $category = db_fetch_object(db_query("SELECT cid FROM {aggregator_category} WHERE title = '%s'", $form_state['values']['title']));    }    if ($category) {      form_set_error('title', t('A category named %category already exists. Please enter a unique title.', array('%category' => $form_state['values']['title'])));    }  }}/** * Process aggregator_form_category form submissions. * * @todo Add delete confirmation dialog. */function aggregator_form_category_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Delete')) {    $title = $form_state['values']['title'];    // Unset the title:    unset($form_state['values']['title']);  }  aggregator_save_category($form_state['values']);  if (isset($form_state['values']['cid'])) {    if (isset($form_state['values']['title'])) {      drupal_set_message(t('The category %category has been updated.', array('%category' => $form_state['values']['title'])));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/categories/'. $form_state['values']['cid'];        return;      }    }    else {      watchdog('aggregator', 'Category %category deleted.', array('%category' => $title));      drupal_set_message(t('The category %category has been deleted.', array('%category' => $title)));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/categories/';        return;      }    }  }  else {    watchdog('aggregator', 'Category %category added.', array('%category' => $form_state['values']['title']), WATCHDOG_NOTICE, l(t('view'), 'admin/content/aggregator'));    drupal_set_message(t('The category %category has been added.', array('%category' => $form_state['values']['title'])));  }}
<?php// $Id$/** * @file * Controls the boxes that are displayed around the main content. *//** * Denotes that a block is not enabled in any region and should not * be shown. */define('BLOCK_REGION_NONE', -1);/** * Constants defining cache granularity for blocks. * * Modules specify the caching patterns for their blocks using binary * combinations of these constants in their hook_block(op 'list'): *   $block[delta]['cache'] = BLOCK_CACHE_PER_ROLE | BLOCK_CACHE_PER_PAGE; * BLOCK_CACHE_PER_ROLE is used as a default when no caching pattern is * specified. * * The block cache is cleared in cache_clear_all(), and uses the same clearing * policy than page cache (node, comment, user, taxonomy added or updated...). * Blocks requiring more fine-grained clearing might consider disabling the * built-in block cache (BLOCK_NO_CACHE) and roll their own. * * Note that user 1 is excluded from block caching. *//** * The block should not get cached. This setting should be used: * - for simple blocks (notably those that do not perform any db query), * where querying the db cache would be more expensive than directly generating * the content. * - for blocks that change too frequently. */define('BLOCK_NO_CACHE', -1);/** * The block can change depending on the roles the user viewing the page belongs to. * This is the default setting, used when the block does not specify anything. */define('BLOCK_CACHE_PER_ROLE', 0x0001);/** * The block can change depending on the user viewing the page. * This setting can be resource-consuming for sites with large number of users, * and thus should only be used when BLOCK_CACHE_PER_ROLE is not sufficient. */define('BLOCK_CACHE_PER_USER', 0x0002);/** * The block can change depending on the page being viewed. */define('BLOCK_CACHE_PER_PAGE', 0x0004);/** * The block is the same for every user on every page where it is visible. */define('BLOCK_CACHE_GLOBAL', 0x0008);/** * Implementation of hook_help(). */function block_help($path, $arg) {  switch ($path) {    case 'admin/help#block':      $output = '<p>'. t('Blocks are boxes of content rendered into an area, or region, of a web page. The default theme Garland, for example, implements the regions "left sidebar", "right sidebar", "content", "header", and "footer", and a block may appear in any one of these areas. The <a href="@blocks">blocks administration page</a> provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions.', array('@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('Although blocks are usually generated automatically by modules (like the <em>User login</em> block, for example), administrators can also define custom blocks. Custom blocks have a title, description, and body. The body of the block can be as long as necessary, and can contain content supported by any available <a href="@input-format">input format</a>.', array('@input-format' => url('admin/settings/filters'))) .'</p>';      $output .= '<p>'. t('When working with blocks, remember that:') .'</p>';      $output .= '<ul><li>'. t('since not all themes implement the same regions, or display regions in the same way, blocks are positioned on a per-theme basis.') .'</li>';      $output .= '<li>'. t('disabled blocks, or blocks not in a region, are never shown.') .'</li>';      $output .= '<li>'. t('when throttle module is enabled, throttled blocks (blocks with the <em>Throttle</em> checkbox selected) are hidden during high server loads.') .'</li>';      $output .= '<li>'. t('blocks can be configured to be visible only on certain pages.') .'</li>';      $output .= '<li>'. t('blocks can be configured to be visible only when specific conditions are true.') .'</li>';      $output .= '<li>'. t('blocks can be configured to be visible only for certain user roles.') .'</li>';      $output .= '<li>'. t('when allowed by an administrator, specific blocks may be enabled or disabled on a per-user basis using the <em>My account</em> page.') .'</li>';      $output .= '<li>'. t('some dynamic blocks, such as those generated by modules, will be displayed only on certain pages.') .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@block">Block module</a>.', array('@block' => 'http://drupal.org/handbook/modules/block/')) .'</p>';      return $output;    case 'admin/build/block':      $throttle = module_exists('throttle');      $output = '<p>'. t('This page provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions. To change the region or order of a block, grab a drag-and-drop handle under the <em>Block</em> column and drag the block to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Since not all themes implement the same regions, or display regions in the same way, blocks are positioned on a per-theme basis. Remember that your changes will not be saved until you click the <em>Save blocks</em> button at the bottom of the page.') .'</p>';      if ($throttle) {        $output .= '<p>'. t('To reduce CPU usage, database traffic or bandwidth, blocks may be automatically disabled during high server loads by selecting their <em>Throttle</em> checkbox. Adjust throttle thresholds on the <a href="@throttleconfig">throttle configuration page</a>.', array('@throttleconfig' => url('admin/settings/throttle'))) .'</p>';      }      $output .= '<p>'. t('Click the <em>configure</em> link next to each block to configure its specific title and visibility settings. Use the <a href="@add-block">add block page</a> to create a custom block.', array('@add-block' => url('admin/build/block/add'))) .'</p>';      return $output;    case 'admin/build/block/add':      return '<p>'. t('Use this page to create a new custom block. New blocks are disabled by default, and must be moved to a region on the <a href="@blocks">blocks administration page</a> to be visible.', array('@blocks' => url('admin/build/block'))) .'</p>';  }}/** * Implementation of hook_theme() */function block_theme() {  return array(    'block_admin_display_form' => array(      'template' => 'block-admin-display-form',      'file' => 'block.admin.inc',      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_perm(). */function block_perm() {  return array('administer blocks', 'use PHP for block visibility');}/** * Implementation of hook_menu(). */function block_menu() {  $items['admin/build/block'] = array(    'title' => 'Blocks',    'description' => 'Configure what block content appears in your site\'s sidebars and other regions.',    'page callback' => 'block_admin_display',    'access arguments' => array('administer blocks'),    'file' => 'block.admin.inc',  );  $items['admin/build/block/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/build/block/list/js'] = array(    'title' => 'JavaScript List Form',    'page callback' => 'block_admin_display_js',    'access arguments' => array('administer blocks'),    'type' => MENU_CALLBACK,    'file' => 'block.admin.inc',  );  $items['admin/build/block/configure'] = array(    'title' => 'Configure block',    'page callback' => 'drupal_get_form',    'page arguments' => array('block_admin_configure'),    'access arguments' => array('administer blocks'),    'type' => MENU_CALLBACK,    'file' => 'block.admin.inc',  );  $items['admin/build/block/delete'] = array(    'title' => 'Delete block',    'page callback' => 'drupal_get_form',    'page arguments' => array('block_box_delete'),    'access arguments' => array('administer blocks'),    'type' => MENU_CALLBACK,    'file' => 'block.admin.inc',  );  $items['admin/build/block/add'] = array(    'title' => 'Add block',    'page callback' => 'drupal_get_form',    'page arguments' => array('block_add_block_form'),    'access arguments' => array('administer blocks'),    'type' => MENU_LOCAL_TASK,    'file' => 'block.admin.inc',  );  $default = variable_get('theme_default', 'garland');  foreach (list_themes() as $key => $theme) {    $items['admin/build/block/list/'. $key] = array(      'title' => check_plain($theme->info['name']),      'page arguments' => array($key),      'type' => $key == $default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,      'weight' => $key == $default ? -10 : 0,      'file' => 'block.admin.inc',      'access callback' => '_block_themes_access',      'access arguments' => array($theme),    );  }  return $items;}/** * Menu item access callback - only admin or enabled themes can be accessed */function _block_themes_access($theme) {  return user_access('administer blocks') && ($theme->status || $theme->name == variable_get('admin_theme', '0'));}/** * Implementation of hook_block(). * * Generates the administrator-defined blocks for display. */function block_block($op = 'list', $delta = 0, $edit = array()) {  switch ($op) {    case 'list':      $blocks = array();      $result = db_query('SELECT bid, info FROM {boxes} ORDER BY info');      while ($block = db_fetch_object($result)) {        $blocks[$block->bid]['info'] = $block->info;        // Not worth caching.        $blocks[$block->bid]['cache'] = BLOCK_NO_CACHE;      }      return $blocks;    case 'configure':      $box = array('format' => FILTER_FORMAT_DEFAULT);      if ($delta) {        $box = block_box_get($delta);      }      if (filter_access($box['format'])) {        return block_box_form($box);      }      break;    case 'save':      block_box_save($edit, $delta);      break;    case 'view':      $block = db_fetch_object(db_query('SELECT body, format FROM {boxes} WHERE bid = %d', $delta));      $data['content'] = check_markup($block->body, $block->format, FALSE);      return $data;  }}/** * Update the 'blocks' DB table with the blocks currently exported by modules. * * @return *   Blocks currently exported by modules. */function _block_rehash() {  global $theme_key;  init_theme();  $result = db_query("SELECT * FROM {blocks} WHERE theme = '%s'", $theme_key);  $old_blocks = array();  while ($old_block = db_fetch_array($result)) {    $old_blocks[$old_block['module']][$old_block['delta']] = $old_block;  }  $blocks = array();  // Valid region names for the theme.  $regions = system_region_list($theme_key);  foreach (module_list() as $module) {    $module_blocks = module_invoke($module, 'block', 'list');    if ($module_blocks) {      foreach ($module_blocks as $delta => $block) {        if (empty($old_blocks[$module][$delta])) {          // If it's a new block, add identifiers.          $block['module'] = $module;          $block['delta']  = $delta;          $block['theme']  = $theme_key;          if (!isset($block['pages'])) {            // {block}.pages is type 'text', so it cannot have a            // default value, and not null, so we need to provide            // value if the module did not.            $block['pages']  = '';          }          // Add defaults and save it into the database.          drupal_write_record('blocks', $block);          // Set region to none if not enabled.          $block['region'] = $block['status'] ? $block['region'] : BLOCK_REGION_NONE;          // Add to the list of blocks we return.          $blocks[] = $block;        }        else {          // If it's an existing block, database settings should overwrite          // the code. But aside from 'info' everything that's definable in          // code is stored in the database and we do not store 'info', so we          // do not need to update the database here.          // Add 'info' to this block.          $old_blocks[$module][$delta]['info'] = $block['info'];          // If the region name does not exist, disable the block and assign it to none.          if (!empty($old_blocks[$module][$delta]['region']) && !isset($regions[$old_blocks[$module][$delta]['region']])) {            drupal_set_message(t('The block %info was assigned to the invalid region %region and has been disabled.', array('%info' => $old_blocks[$module][$delta]['info'], '%region' => $old_blocks[$module][$delta]['region'])), 'warning');            $old_blocks[$module][$delta]['status'] = 0;            $old_blocks[$module][$delta]['region'] = BLOCK_REGION_NONE;          }          else {            $old_blocks[$module][$delta]['region'] = $old_blocks[$module][$delta]['status'] ? $old_blocks[$module][$delta]['region'] : BLOCK_REGION_NONE;          }          // Add this block to the list of blocks we return.          $blocks[] = $old_blocks[$module][$delta];          // Remove this block from the list of blocks to be deleted.          unset($old_blocks[$module][$delta]);        }      }    }  }  // Remove blocks that are no longer defined by the code from the database.  foreach ($old_blocks as $module => $old_module_blocks) {    foreach ($old_module_blocks as $delta => $block) {      db_query("DELETE FROM {blocks} WHERE module = '%s' AND delta = '%s' AND theme = '%s'", $module, $delta, $theme_key);    }  }  return $blocks;}/** * Returns information from database about a user-created (custom) block. * * @param $bid *   ID of the block to get information for. * @return *   Associative array of information stored in the database for this block. *   Array keys: *   - bid: Block ID. *   - info: Block description. *   - body: Block contents. *   - format: Filter ID of the filter format for the body. */function block_box_get($bid) {  return db_fetch_array(db_query("SELECT * FROM {boxes} WHERE bid = %d", $bid));}/** * Define the custom block form. */function block_box_form($edit = array()) {  $edit += array(    'info' => '',    'body' => '',  );  $form['info'] = array(    '#type' => 'textfield',    '#title' => t('Block description'),    '#default_value' => $edit['info'],    '#maxlength' => 64,    '#description' => t('A brief description of your block. Used on the <a href="@overview">block overview page</a>.', array('@overview' => url('admin/build/block'))),    '#required' => TRUE,    '#weight' => -19,  );  $form['body_field']['#weight'] = -17;  $form['body_field']['body'] = array(    '#type' => 'textarea',    '#title' => t('Block body'),    '#default_value' => $edit['body'],    '#rows' => 15,    '#description' => t('The content of the block as shown to the user.'),    '#weight' => -17,  );  if (!isset($edit['format'])) {    $edit['format'] = FILTER_FORMAT_DEFAULT;  }  $form['body_field']['format'] = filter_form($edit['format'], -16);  return $form;}/** * Saves a user-created block in the database. * * @param $edit *   Associative array of fields to save. Array keys: *   - info: Block description. *   - body: Block contents. *   - format: Filter ID of the filter format for the body. * @param $delta *   Block ID of the block to save. * @return *   Always returns TRUE. */function block_box_save($edit, $delta) {  if (!filter_access($edit['format'])) {    $edit['format'] = FILTER_FORMAT_DEFAULT;  }  db_query("UPDATE {boxes} SET body = '%s', info = '%s', format = %d WHERE bid = %d", $edit['body'], $edit['info'], $edit['format'], $delta);  return TRUE;}/** * Implementation of hook_user(). * * Allow users to decide which custom blocks to display when they visit * the site. */function block_user($type, $edit, &$account, $category = NULL) {  switch ($type) {    case 'form':      if ($category == 'account') {        $rids = array_keys($account->roles);        $result = db_query("SELECT DISTINCT b.* FROM {blocks} b LEFT JOIN {blocks_roles} r ON b.module = r.module AND b.delta = r.delta WHERE b.status = 1 AND b.custom != 0 AND (r.rid IN (". db_placeholders($rids) .") OR r.rid IS NULL) ORDER BY b.weight, b.module", $rids);        $form['block'] = array('#type' => 'fieldset', '#title' => t('Block configuration'), '#weight' => 3, '#collapsible' => TRUE, '#tree' => TRUE);        while ($block = db_fetch_object($result)) {          $data = module_invoke($block->module, 'block', 'list');          if ($data[$block->delta]['info']) {            $return = TRUE;            $form['block'][$block->module][$block->delta] = array('#type' => 'checkbox', '#title' => check_plain($data[$block->delta]['info']), '#default_value' => isset($account->block[$block->module][$block->delta]) ? $account->block[$block->module][$block->delta] : ($block->custom == 1));          }        }        if (!empty($return)) {          return $form;        }      }      break;    case 'validate':      if (empty($edit['block'])) {        $edit['block'] = array();      }      return $edit;  }}/** * Return all blocks in the specified region for the current user. * * @param $region *   The name of a region. * * @return *   An array of block objects, indexed with <i>module</i>_<i>delta</i>. *   If you are displaying your blocks in one or two sidebars, you may check *   whether this array is empty to see how many columns are going to be *   displayed. * * @todo *   Now that the blocks table has a primary key, we should use that as the *   array key instead of <i>module</i>_<i>delta</i>. */function block_list($region) {  global $user, $theme_key;  static $blocks = array();  if (!count($blocks)) {    $rids = array_keys($user->roles);    $result = db_query(db_rewrite_sql("SELECT DISTINCT b.* FROM {blocks} b LEFT JOIN {blocks_roles} r ON b.module = r.module AND b.delta = r.delta WHERE b.theme = '%s' AND b.status = 1 AND (r.rid IN (". db_placeholders($rids) .") OR r.rid IS NULL) ORDER BY b.region, b.weight, b.module", 'b', 'bid'), array_merge(array($theme_key), $rids));    while ($block = db_fetch_object($result)) {      if (!isset($blocks[$block->region])) {        $blocks[$block->region] = array();      }      // Use the user's block visibility setting, if necessary      if ($block->custom != 0) {        if ($user->uid && isset($user->block[$block->module][$block->delta])) {          $enabled = $user->block[$block->module][$block->delta];        }        else {          $enabled = ($block->custom == 1);        }      }      else {        $enabled = TRUE;      }      // Match path if necessary      if ($block->pages) {        if ($block->visibility < 2) {          $path = drupal_get_path_alias($_GET['q']);          // Compare with the internal and path alias (if any).          $page_match = drupal_match_path($path, $block->pages);          if ($path != $_GET['q']) {            $page_match = $page_match || drupal_match_path($_GET['q'], $block->pages);          }          // When $block->visibility has a value of 0, the block is displayed on          // all pages except those listed in $block->pages. When set to 1, it          // is displayed only on those pages listed in $block->pages.          $page_match = !($block->visibility xor $page_match);        }        else {          $page_match = drupal_eval($block->pages);        }      }      else {        $page_match = TRUE;      }      $block->enabled = $enabled;      $block->page_match = $page_match;      $blocks[$block->region]["{$block->module}_{$block->delta}"] = $block;    }  }  // Create an empty array if there were no entries  if (!isset($blocks[$region])) {    $blocks[$region] = array();  }  foreach ($blocks[$region] as $key => $block) {    // Render the block content if it has not been created already.    if (!isset($block->content)) {      // Erase the block from the static array - we'll put it back if it has content.      unset($blocks[$region][$key]);      if ($block->enabled && $block->page_match) {        // Check the current throttle status and see if block should be displayed        // based on server load.        if (!($block->throttle && (module_invoke('throttle', 'status') > 0))) {          // Try fetching the block from cache. Block caching is not compatible with          // node_access modules. We also preserve the submission of forms in blocks,          // by fetching from cache only if the request method is 'GET'.          if (!count(module_implements('node_grants')) && $_SERVER['REQUEST_METHOD'] == 'GET' && ($cid = _block_get_cache_id($block)) && ($cache = cache_get($cid, 'cache_block'))) {            $array = $cache->data;          }          else {            $array = module_invoke($block->module, 'block', 'view', $block->delta);            if (isset($cid)) {              cache_set($cid, $array, 'cache_block', CACHE_TEMPORARY);            }          }          if (isset($array) && is_array($array)) {            foreach ($array as $k => $v) {              $block->$k = $v;            }          }        }        if (isset($block->content) && $block->content) {          // Override default block title if a custom display title is present.          if ($block->title) {            // Check plain here to allow module generated titles to keep any markup.            $block->subject = $block->title == '<none>' ? '' : check_plain($block->title);          }          if (!isset($block->subject)) {            $block->subject = '';          }          $blocks[$block->region]["{$block->module}_{$block->delta}"] = $block;        }      }    }  }  return $blocks[$region];}/** * Assemble the cache_id to use for a given block. * * The cache_id string reflects the viewing context for the current block * instance, obtained by concatenating the relevant context information * (user, page, ...) according to the block's cache settings (BLOCK_CACHE_* * constants). Two block instances can use the same cached content when * they share the same cache_id. * * Theme and language contexts are automatically differenciated. * * @param $block * @return *   The string used as cache_id for the block. */function _block_get_cache_id($block) {  global $theme, $base_root, $user;  // User 1 being out of the regular 'roles define permissions' schema,  // it brings too many chances of having unwanted output get in the cache  // and later be served to other users. We therefore exclude user 1 from  // block caching.  if (variable_get('block_cache', 0) && $block->cache != BLOCK_NO_CACHE && $user->uid != 1) {    $cid_parts = array();    // Start with common sub-patterns: block identification, theme, language.    $cid_parts[] = $block->module;    $cid_parts[] = $block->delta;    $cid_parts[] = $theme;    if (module_exists('locale')) {      global $language;      $cid_parts[] = $language->language;    }    // 'PER_ROLE' and 'PER_USER' are mutually exclusive. 'PER_USER' can be a    // resource drag for sites with many users, so when a module is being    // equivocal, we favor the less expensive 'PER_ROLE' pattern.    if ($block->cache & BLOCK_CACHE_PER_ROLE) {      $cid_parts[] = 'r.'. implode(',', array_keys($user->roles));    }    elseif ($block->cache & BLOCK_CACHE_PER_USER) {      $cid_parts[] = "u.$user->uid";    }    if ($block->cache & BLOCK_CACHE_PER_PAGE) {      $cid_parts[] = $base_root . request_uri();    }    return implode(':', $cid_parts);  }}
<?php// $Id$/** * @file * The "Update status" module checks for available updates of Drupal core and * any installed contributed modules and themes. It warns site administrators * if newer releases are available via the system status report * (admin/reports/status), the module and theme pages, and optionally via email. *//** * URL to check for updates, if a given project doesn't define its own. */define('UPDATE_DEFAULT_URL', 'http://updates.drupal.org/release-history');// These are internally used constants for this code, do not modify./** * Project is missing security update(s). */define('UPDATE_NOT_SECURE', 1);/** * Current release has been unpublished and is no longer available. */define('UPDATE_REVOKED', 2);/** * Current release is no longer supported by the project maintainer. */define('UPDATE_NOT_SUPPORTED', 3);/** * Project has a new release available, but it is not a security release. */define('UPDATE_NOT_CURRENT', 4);/** * Project is up to date. */define('UPDATE_CURRENT', 5);/** * Project's status cannot be checked. */define('UPDATE_NOT_CHECKED', -1);/** * No available update data was found for project. */define('UPDATE_UNKNOWN', -2);/** * There was a failure fetching available update data for this project. */define('UPDATE_NOT_FETCHED', -3);/** * Maximum number of attempts to fetch available update data from a given host. */define('UPDATE_MAX_FETCH_ATTEMPTS', 2);/** * Implementation of hook_help(). */function update_help($path, $arg) {  switch ($path) {    case 'admin/reports/updates':      $output = '<p>'. t('Here you can find information about available updates for your installed modules and themes. Note that each module or theme is part of a "project", which may or may not have the same name, and might include multiple modules or themes within it.') .'</p>';      $output .= '<p>'. t('To extend the functionality or to change the look of your site, a number of contributed <a href="@modules">modules</a> and <a href="@themes">themes</a> are available.', array('@modules' => 'http://drupal.org/project/modules', '@themes' => 'http://drupal.org/project/themes')) .'</p>';      return $output;    case 'admin/build/themes':    case 'admin/build/modules':      include_once './includes/install.inc';      $status = update_requirements('runtime');      foreach (array('core', 'contrib') as $report_type) {        $type = 'update_'. $report_type;        if (isset($status[$type]['severity'])) {          if ($status[$type]['severity'] == REQUIREMENT_ERROR) {            drupal_set_message($status[$type]['description'], 'error');          }          elseif ($status[$type]['severity'] == REQUIREMENT_WARNING) {            drupal_set_message($status[$type]['description'], 'warning');          }        }      }      return '<p>'. t('See the <a href="@available_updates">available updates</a> page for information on installed modules and themes with new versions released.', array('@available_updates' => url('admin/reports/updates'))) .'</p>';    case 'admin/reports/updates/settings':    case 'admin/reports/status':      // These two pages don't need additional nagging.      break;    case 'admin/help#update':      $output = '<p>'. t("The Update status module periodically checks for new versions of your site's software (including contributed modules and themes), and alerts you to available updates.") .'</p>';      $output .= '<p>'. t('The <a href="@update-report">report of available updates</a> will alert you when new releases are available for download. You may configure options for update checking frequency and notifications at the <a href="@update-settings">Update status module settings page</a>.', array('@update-report' => url('admin/reports/updates'), '@update-settings' => url('admin/reports/updates/settings'))) .'</p>';      $output .= '<p>'. t('Please note that in order to provide this information, anonymous usage statistics are sent to drupal.org. If desired, you may disable the Update status module from the <a href="@modules">module administration page</a>.', array('@modules' => url('admin/build/modules'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@update">Update status module</a>.', array('@update' => 'http://drupal.org/handbook/modules/update')) .'</p>';      return $output;    default:      // Otherwise, if we're on *any* admin page and there's a security      // update missing, print an error message about it.      if (arg(0) == 'admin' && strpos($path, '#') === FALSE          && user_access('administer site configuration')) {        include_once './includes/install.inc';        $status = update_requirements('runtime');        foreach (array('core', 'contrib') as $report_type) {          $type = 'update_'. $report_type;          if (isset($status[$type])              && isset($status[$type]['reason'])              && $status[$type]['reason'] === UPDATE_NOT_SECURE) {            drupal_set_message($status[$type]['description'], 'error');          }        }      }  }}/** * Implementation of hook_menu(). */function update_menu() {  $items = array();  $items['admin/reports/updates'] = array(    'title' => 'Available updates',    'description' => 'Get a status report about available updates for your installed modules and themes.',    'page callback' => 'update_status',    'access arguments' => array('administer site configuration'),    'file' => 'update.report.inc',    'weight' => 10,  );  $items['admin/reports/updates/list'] = array(    'title' => 'List',    'page callback' => 'update_status',    'access arguments' => array('administer site configuration'),    'file' => 'update.report.inc',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/reports/updates/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('update_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'update.settings.inc',    'type' => MENU_LOCAL_TASK,  );  $items['admin/reports/updates/check'] = array(    'title' => 'Manual update check',    'page callback' => 'update_manual_status',    'access arguments' => array('administer site configuration'),    'file' => 'update.fetch.inc',    'type' => MENU_CALLBACK,  );  return $items;}/** * Implementation of the hook_theme() registry. */function update_theme() {  return array(    'update_settings' => array(      'arguments' => array('form' => NULL),    ),    'update_report' => array(      'arguments' => array('data' => NULL),    ),    'update_version' => array(      'arguments' => array('version' => NULL, 'tag' => NULL, 'class' => NULL),    ),  );}/** * Implementation of hook_requirements(). * * @return *   An array describing the status of the site regarding available updates. *   If there is no update data, only one record will be returned, indicating *   that the status of core can't be determined. If data is available, there *   will be two records: one for core, and another for all of contrib *   (assuming there are any contributed modules or themes enabled on the *   site). In addition to the fields expected by hook_requirements ('value', *   'severity', and optionally 'description'), this array will contain a *   'reason' attribute, which is an integer constant to indicate why the *   given status is being returned (UPDATE_NOT_SECURE, UPDATE_NOT_CURRENT, or *   UPDATE_UNKNOWN). This is used for generating the appropriate e-mail *   notification messages during update_cron(), and might be useful for other *   modules that invoke update_requirements() to find out if the site is up *   to date or not. * * @see _update_message_text() * @see _update_cron_notify() */function update_requirements($phase) {  if ($phase == 'runtime') {    if ($available = update_get_available(FALSE)) {      module_load_include('inc', 'update', 'update.compare');      $data = update_calculate_project_data($available);      // First, populate the requirements for core:      $requirements['update_core'] = _update_requirement_check($data['drupal'], 'core');      // We don't want to check drupal a second time.      unset($data['drupal']);      if (!empty($data)) {        // Now, sort our $data array based on each project's status. The        // status constants are numbered in the right order of precedence, so        // we just need to make sure the projects are sorted in ascending        // order of status, and we can look at the first project we find.        uasort($data, '_update_project_status_sort');        $first_project = reset($data);        $requirements['update_contrib'] = _update_requirement_check($first_project, 'contrib');      }    }    else {      $requirements['update_core']['title'] = t('Drupal core update status');      $requirements['update_core']['value'] = t('No update data available');      $requirements['update_core']['severity'] = REQUIREMENT_WARNING;      $requirements['update_core']['reason'] = UPDATE_UNKNOWN;      $requirements['update_core']['description'] = _update_no_data();    }    return $requirements;  }}/** * Private helper method to fill in the requirements array. * * This is shared for both core and contrib to generate the right elements in * the array for hook_requirements(). * * @param $project *  Array of information about the project we're testing as returned by *  update_calculate_project_data(). * @param $type *  What kind of project is this ('core' or 'contrib'). * * @return *  An array to be included in the nested $requirements array. * * @see hook_requirements() * @see update_requirements() * @see update_calculate_project_data() */function _update_requirement_check($project, $type) {  $requirement = array();  if ($type == 'core') {    $requirement['title'] = t('Drupal core update status');  }  else {    $requirement['title'] = t('Module and theme update status');  }  $status = $project['status'];  if ($status != UPDATE_CURRENT) {    $requirement['reason'] = $status;    $requirement['description'] = _update_message_text($type, $status, TRUE);    $requirement['severity'] = REQUIREMENT_ERROR;  }  switch ($status) {    case UPDATE_NOT_SECURE:      $requirement_label = t('Not secure!');      break;    case UPDATE_REVOKED:      $requirement_label = t('Revoked!');      break;    case UPDATE_NOT_SUPPORTED:      $requirement_label = t('Unsupported release');      break;    case UPDATE_NOT_CURRENT:      $requirement_label = t('Out of date');      $requirement['severity'] = REQUIREMENT_WARNING;      break;    case UPDATE_UNKNOWN:    case UPDATE_NOT_CHECKED:    case UPDATE_NOT_FETCHED:      $requirement_label = isset($project['reason']) ? $project['reason'] : t('Can not determine status');      $requirement['severity'] = REQUIREMENT_WARNING;      break;    default:      $requirement_label = t('Up to date');  }  if ($status != UPDATE_CURRENT && $type == 'core' && isset($project['recommended'])) {    $requirement_label .= ' '. t('(version @version available)', array('@version' => $project['recommended']));  }  $requirement['value'] = l($requirement_label, 'admin/reports/updates');  return $requirement;}/** * Implementation of hook_cron(). */function update_cron() {  $frequency = variable_get('update_check_frequency', 1);  $interval = 60 * 60 * 24 * $frequency;  // Cron should check for updates if there is no update data cached or if the  // configured update interval has elapsed.  if (!_update_cache_get('update_available_releases') || ((time() - variable_get('update_last_check', 0)) > $interval)) {    update_refresh();    _update_cron_notify();  }}/** * Implementation of hook_form_alter(). * * Adds a submit handler to the system modules and themes forms, so that if a * site admin saves either form, we invalidate the cache of available updates. * * @see update_invalidate_cache() */function update_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'system_modules' || $form_id == 'system_themes_form' ) {    $form['#submit'][] = 'update_invalidate_cache';  }}/** * Prints a warning message when there is no data about available updates. */function _update_no_data() {  $destination = drupal_get_destination();  return t('No information is available about potential new releases for currently installed modules and themes. To check for updates, you may need to <a href="@run_cron">run cron</a> or you can <a href="@check_manually">check manually</a>. Please note that checking for available updates can take a long time, so please be patient.', array(    '@run_cron' => url('admin/reports/status/run-cron', array('query' => $destination)),    '@check_manually' => url('admin/reports/updates/check', array('query' => $destination)),  ));}/** * Internal helper to try to get the update information from the cache * if possible, and to refresh the cache when necessary. * * In addition to checking the cache lifetime, this function also ensures that * there are no .info files for enabled modules or themes that have a newer * modification timestamp than the last time we checked for available update * data. If any .info file was modified, it almost certainly means a new * version of something was installed. Without fresh available update data, * the logic in update_calculate_project_data() will be wrong and produce * confusing, bogus results. * * @param $refresh *   Boolean to indicate if this method should refresh the cache automatically *   if there's no data. * * @see update_refresh() * @see update_get_projects() */function update_get_available($refresh = FALSE) {  module_load_include('inc', 'update', 'update.compare');  $available = array();  // First, make sure that none of the .info files have a change time  // newer than the last time we checked for available updates.  $needs_refresh = FALSE;  $last_check = variable_get('update_last_check', 0);  $projects = update_get_projects();  foreach ($projects as $key => $project) {    if ($project['info']['_info_file_ctime'] > $last_check) {      $needs_refresh = TRUE;      break;    }  }  if (!$needs_refresh && ($cache = _update_cache_get('update_available_releases')) && $cache->expire > time()) {    $available = $cache->data;  }  elseif ($needs_refresh || $refresh) {    // If we need to refresh due to a newer .info file, ignore the argument    // and force the refresh (e.g., even for update_requirements()) to prevent    // bogus results.    $available = update_refresh();  }  return $available;}/** * Wrapper to load the include file and then refresh the release data. */function update_refresh() {  module_load_include('inc', 'update', 'update.fetch');  return _update_refresh();}/** * Implementation of hook_mail(). * * Constructs the email notification message when the site is out of date. * * @param $key *   Unique key to indicate what message to build, always 'status_notify'. * @param $message *   Reference to the message array being built. * @param $params *   Array of parameters to indicate what kind of text to include in the *   message body. This is a keyed array of message type ('core' or 'contrib') *   as the keys, and the status reason constant (UPDATE_NOT_SECURE, etc) for *   the values. * * @see drupal_mail() * @see _update_cron_notify() * @see _update_message_text() */function update_mail($key, &$message, $params) {  $language = $message['language'];  $langcode = $language->language;  $message['subject'] .= t('New release(s) available for !site_name', array('!site_name' => variable_get('site_name', 'Drupal')), $langcode);  foreach ($params as $msg_type => $msg_reason) {    $message['body'][] = _update_message_text($msg_type, $msg_reason, FALSE, $language);  }  $message['body'][] = t('See the available updates page for more information:', array(), $langcode) ."\n". url('admin/reports/updates', array('absolute' => TRUE, 'language' => $language));}/** * Helper function to return the appropriate message text when the site is out * of date or missing a security update. * * These error messages are shared by both update_requirements() for the * site-wide status report at admin/reports/status and in the body of the * notification emails generated by update_cron(). * * @param $msg_type *   String to indicate what kind of message to generate. Can be either *   'core' or 'contrib'. * @param $msg_reason *   Integer constant specifying why message is generated. * @param $report_link *   Boolean that controls if a link to the updates report should be added. * @param $language *   An optional language object to use. * @return *   The properly translated error message for the given key. */function _update_message_text($msg_type, $msg_reason, $report_link = FALSE, $language = NULL) {  $langcode = isset($language) ? $language->language : NULL;  $text = '';  switch ($msg_reason) {    case UPDATE_NOT_SECURE:      if ($msg_type == 'core') {        $text = t('There is a security update available for your version of Drupal. To ensure the security of your server, you should update immediately!', array(), $langcode);      }      else {        $text = t('There are security updates available for one or more of your modules or themes. To ensure the security of your server, you should update immediately!', array(), $langcode);      }      break;    case UPDATE_REVOKED:      if ($msg_type == 'core') {        $text = t('Your version of Drupal has been revoked and is no longer available for download. Upgrading is strongly recommended!', array(), $langcode);      }      else {        $text = t('The installed version of at least one of your modules or themes has been revoked and is no longer available for download. Upgrading or disabling is strongly recommended!', array(), $langcode);      }      break;    case UPDATE_NOT_SUPPORTED:      if ($msg_type == 'core') {        $text = t('Your version of Drupal is no longer supported. Upgrading is strongly recommended!', array(), $langcode);      }      else {        $text = t('The installed version of at least one of your modules or themes is no longer supported. Upgrading or disabling is strongly recommended! Please see the project homepage for more details.', array(), $langcode);      }      break;    case UPDATE_NOT_CURRENT:      if ($msg_type == 'core') {        $text = t('There are updates available for your version of Drupal. To ensure the proper functioning of your site, you should update as soon as possible.', array(), $langcode);      }      else {        $text = t('There are updates available for one or more of your modules or themes. To ensure the proper functioning of your site, you should update as soon as possible.', array(), $langcode);      }      break;    case UPDATE_UNKNOWN:    case UPDATE_NOT_CHECKED:    case UPDATE_NOT_FETCHED:      if ($msg_type == 'core') {        $text = t('There was a problem determining the status of available updates for your version of Drupal.', array(), $langcode);      }      else {        $text = t('There was a problem determining the status of available updates for one or more of your modules or themes.', array(), $langcode);      }      break;  }  if ($report_link) {    $text .= ' '. t('See the <a href="@available_updates">available updates</a> page for more information.', array('@available_updates' => url('admin/reports/updates', array('language' => $language))), $langcode);  }  return $text;}/** * Private sort function to order projects based on their status. * * @see update_requirements() * @see uasort() */function _update_project_status_sort($a, $b) {  // The status constants are numerically in the right order, so we can  // usually subtract the two to compare in the order we want. However,  // negative status values should be treated as if they are huge, since we  // always want them at the bottom of the list.  $a_status = $a['status'] > 0 ? $a['status'] : (-10 * $a['status']);  $b_status = $b['status'] > 0 ? $b['status'] : (-10 * $b['status']);  return $a_status - $b_status;}/** * @defgroup update_status_cache Private update status cache system * @{ * * We specifically do NOT use the core cache API for saving the fetched data * about available updates. It is vitally important that this cache is only * cleared when we're populating it after successfully fetching new available * update data. Usage of the core cache API results in all sorts of potential * problems that would result in attempting to fetch available update data all * the time, including if a site has a "minimum cache lifetime" (which is both * a minimum and a maximum) defined, or if a site uses memcache or another * plug-able cache system that assumes volatile caches. * * Update module still uses the {cache_update} table, but instead of using * cache_set(), cache_get(), and cache_clear_all(), there are private helper * functions that implement these same basic tasks but ensure that the cache * is not prematurely cleared, and that the data is always stored in the * database, even if memcache or another cache backend is in use. *//** * Store data in the private update status cache table. * * Note: this function completely ignores the {cache_update}.headers field * since that is meaningless for the kinds of data we're caching. * * @param $cid *   The cache ID to save the data with. * @param $data *   The data to store. * @param $expire *   One of the following values: *   - CACHE_PERMANENT: Indicates that the item should never be removed except *     by explicitly using _update_cache_clear() or update_invalidate_cache(). *   - A Unix timestamp: Indicates that the item should be kept at least until *     the given time, after which it will be invalidated. */function _update_cache_set($cid, $data, $expire) {  $serialized = 0;  if (is_object($data) || is_array($data)) {    $data = serialize($data);    $serialized = 1;  }  $created = time();  db_query("UPDATE {cache_update} SET data = %b, created = %d, expire = %d, serialized = %d WHERE cid = '%s'", $data, $created, $expire, $serialized, $cid);  if (!db_affected_rows()) {    @db_query("INSERT INTO {cache_update} (cid, data, created, expire, serialized) VALUES ('%s', %b, %d, %d, %d)", $cid, $data, $created, $expire, $serialized);  }}/** * Retrieve data from the private update status cache table. * * @param $cid *   The cache ID to retrieve. * @return *   The data for the given cache ID, or NULL if the ID was not found. */function _update_cache_get($cid) {  $cache = db_fetch_object(db_query("SELECT data, created, expire, serialized FROM {cache_update} WHERE cid = '%s'", $cid));  if (isset($cache->data)) {    $cache->data = db_decode_blob($cache->data);    if ($cache->serialized) {      $cache->data = unserialize($cache->data);    }  }  return $cache;}/** * Invalidates specific cached data relating to update status. * * @param $cid *   Optional cache ID of the record to clear from the private update module *   cache. If empty, all records will be cleared from the table. */function _update_cache_clear($cid = NULL) {  if (empty($cid)) {    db_query("TRUNCATE TABLE {cache_update}");  }  else {    db_query("DELETE FROM {cache_update} WHERE cid = '%s'", $cid);  }}/** * Implementation of hook_flush_caches(). * * Called from update.php (among others) to flush the caches. * Since we're running update.php, we are likely to install a new version of * something, in which case, we want to check for available update data again. * However, because we have our own caching system, we need to directly clear * the database table ourselves at this point and return nothing, for example, * on sites that use memcache where cache_clear_all() won't know how to purge * this data. * * However, we only want to do this from update.php, since otherwise, we'd * lose all the available update data on every cron run. So, we specifically * check if the site is in MAINTENANCE_MODE == 'update' (which indicates * update.php is running, not update module... alas for overloaded names). */function update_flush_caches() {  if (defined('MAINTENANCE_MODE') && MAINTENANCE_MODE == 'update') {    _update_cache_clear();  }  return array();}/** * Invalidates all cached data relating to update status. */function update_invalidate_cache() {  _update_cache_clear();}/** * @} End of "defgroup update_status_cache". */
<?php// $Id$/** * @file * Admin page callbacks for the book module. *//** * Returns an administrative overview of all books. */function book_admin_overview() {  $rows = array();  foreach (book_get_books() as $book) {    $rows[] = array(l($book['title'], $book['href'], $book['options']), l(t('edit order and titles'), "admin/content/book/". $book['nid']));  }  $headers = array(t('Book'), t('Operations'));  return theme('table', $headers, $rows);}/** * Builds and returns the book settings form. * * @see book_admin_settings_validate() * * @ingroup forms */function book_admin_settings() {  $types = node_get_types('names');  $form['book_allowed_types'] = array(    '#type' => 'checkboxes',    '#title' => t('Allowed book outline types'),    '#default_value' => variable_get('book_allowed_types', array('book')),    '#options' => $types,    '#description' => t('Select content types which users with the %add-perm permission will be allowed to add to the book hierarchy. Users with the %outline-perm permission can add all content types.', array('%add-perm' => t('add content to books'),  '%outline-perm' => t('administer book outlines'))),    '#required' => TRUE,  );  $form['book_child_type'] = array(    '#type' => 'radios',    '#title' => t('Default child page type'),    '#default_value' => variable_get('book_child_type', 'book'),    '#options' => $types,    '#description' => t('The content type for the %add-child link must be one of those selected as an allowed book outline type.', array('%add-child' => t('Add child page'))),    '#required' => TRUE,  );  $form['array_filter'] = array('#type' => 'value', '#value' => TRUE);  $form['#validate'][] = 'book_admin_settings_validate';  return system_settings_form($form);}/** * Validate the book settings form. * * @see book_admin_settings() */function book_admin_settings_validate($form, &$form_state) {  $child_type = $form_state['values']['book_child_type'];  if (empty($form_state['values']['book_allowed_types'][$child_type])) {    form_set_error('book_child_type', t('The content type for the %add-child link must be one of those selected as an allowed book outline type.', array('%add-child' => t('Add child page'))));  }}/** * Build the form to administrate the hierarchy of a single book. * * @see book_admin_edit_submit() * * @ingroup forms. */function book_admin_edit($form_state, $node) {  drupal_set_title(check_plain($node->title));  $form = array();  $form['#node'] = $node;  _book_admin_table($node, $form);  $form['save'] = array(    '#type' => 'submit',    '#value' => t('Save book pages'),  );  return $form;}/** * Check that the book has not been changed while using the form. * * @see book_admin_edit() */function book_admin_edit_validate($form, &$form_state) {  if ($form_state['values']['tree_hash'] != $form_state['values']['tree_current_hash']) {    form_set_error('', t('This book has been modified by another user, the changes could not be saved.'));    $form_state['rebuild'] = TRUE;  }}/** * Handle submission of the book administrative page form. * * This function takes care to save parent menu items before their children. * Saving menu items in the incorrect order can break the menu tree. * * @see book_admin_edit() * @see menu_overview_form_submit() */function book_admin_edit_submit($form, &$form_state) {  // Save elements in the same order as defined in post rather than the form.  // This ensures parents are updated before their children, preventing orphans.  $order = array_flip(array_keys($form['#post']['table']));  $form['table'] = array_merge($order, $form['table']);  foreach (element_children($form['table']) as $key) {    if ($form['table'][$key]['#item']) {      $row = $form['table'][$key];      $values = $form_state['values']['table'][$key];      // Update menu item if moved.      if ($row['plid']['#default_value'] != $values['plid'] || $row['weight']['#default_value'] != $values['weight']) {        $row['#item']['plid'] = $values['plid'];        $row['#item']['weight'] = $values['weight'];        menu_link_save($row['#item']);      }      // Update the title if changed.      if ($row['title']['#default_value'] != $values['title']) {        $node = node_load($values['nid'], FALSE);        $node->title = $values['title'];        $node->book['link_title'] = $values['title'];        $node->revision = 1;        $node->log = t('Title changed from %original to %current.', array('%original' => $node->title, '%current' => $values['title']));        node_save($node);        watchdog('content', 'book: updated %title.', array('%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), 'node/'. $node->nid));      }    }  }  drupal_set_message(t('Updated book %title.', array('%title' => $form['#node']->title)));}/** * Build the table portion of the form for the book administration page. * * @see book_admin_edit() */function _book_admin_table($node, &$form) {  $form['table'] = array(    '#theme' => 'book_admin_table',    '#tree' => TRUE,  );  $tree = book_menu_subtree_data($node->book);  $tree = array_shift($tree); // Do not include the book item itself.  if ($tree['below']) {    $hash = sha1(serialize($tree['below']));    // Store the hash value as a hidden form element so that we can detect    // if another user changed the book hierarchy.    $form['tree_hash'] = array(      '#type' => 'hidden',      '#default_value' => $hash,    );    $form['tree_current_hash'] = array(      '#type' => 'value',      '#value' => $hash,    );    _book_admin_table_tree($tree['below'], $form['table']);  }}/** * Recursive helper to build the main table in the book administration page form. * * @see book_admin_edit() */function _book_admin_table_tree($tree, &$form) {  foreach ($tree as $data) {    $form['book-admin-'. $data['link']['nid']] = array(      '#item' => $data['link'],      'nid' => array('#type' => 'value', '#value' => $data['link']['nid']),      'depth' => array('#type' => 'value', '#value' => $data['link']['depth']),      'href' => array('#type' => 'value', '#value' => $data['link']['href']),      'title' => array(        '#type' => 'textfield',        '#default_value' => $data['link']['link_title'],        '#maxlength' => 255,        '#size' => 40,      ),      'weight' => array(        '#type' => 'weight',        '#default_value' => $data['link']['weight'],        '#delta' => 15,      ),      'plid' => array(        '#type' => 'textfield',        '#default_value' => $data['link']['plid'],        '#size' => 6,      ),      'mlid' => array(        '#type' => 'hidden',        '#default_value' => $data['link']['mlid'],      ),    );    if ($data['below']) {      _book_admin_table_tree($data['below'], $form);    }  }  return $form;}/** * Theme function for the book administration page form. * * @ingroup themeable * @see book_admin_table() */function theme_book_admin_table($form) {  drupal_add_tabledrag('book-outline', 'match', 'parent', 'book-plid', 'book-plid', 'book-mlid', TRUE, MENU_MAX_DEPTH - 2);  drupal_add_tabledrag('book-outline', 'order', 'sibling', 'book-weight');  $header = array(t('Title'), t('Weight'), t('Parent'), array('data' => t('Operations'), 'colspan' => '3'));  $rows = array();  $destination = drupal_get_destination();  $access = user_access('administer nodes');  foreach (element_children($form) as $key) {    $nid = $form[$key]['nid']['#value'];    $href = $form[$key]['href']['#value'];    // Add special classes to be used with tabledrag.js.    $form[$key]['plid']['#attributes']['class'] = 'book-plid';    $form[$key]['mlid']['#attributes']['class'] = 'book-mlid';    $form[$key]['weight']['#attributes']['class'] = 'book-weight';    $data = array(      theme('indentation', $form[$key]['depth']['#value'] - 2) . drupal_render($form[$key]['title']),      drupal_render($form[$key]['weight']),      drupal_render($form[$key]['plid']) . drupal_render($form[$key]['mlid']),      l(t('view'), $href),      $access ? l(t('edit'), 'node/'. $nid .'/edit', array('query' => $destination)) : '&nbsp',      $access ? l(t('delete'), 'node/'. $nid .'/delete', array('query' => $destination) )  : '&nbsp',    );    $row = array('data' => $data);    if (isset($form[$key]['#attributes'])) {      $row = array_merge($row, $form[$key]['#attributes']);    }    $row['class'] = empty($row['class']) ? 'draggable' : $row['class'] .' draggable';    $rows[] = $row;  }  return theme('table', $header, $rows, array('id' => 'book-outline'));}
<?php// $Id$/** * @file * User session handling functions. */function sess_open($save_path, $session_name) {  return TRUE;}function sess_close() {  return TRUE;}function sess_read($key) {  global $user;  // Write and Close handlers are called after destructing objects since PHP 5.0.5  // Thus destructors can use sessions but session handler can't use objects.  // So we are moving session closure before destructing objects.  register_shutdown_function('session_write_close');  // Handle the case of first time visitors and clients that don't store cookies (eg. web crawlers).  if (!isset($_COOKIE[session_name()])) {    $user = drupal_anonymous_user();    return '';  }  // Otherwise, if the session is still active, we have a record of the client's session in the database.  $user = db_fetch_object(db_query("SELECT u.*, s.* FROM {users} u INNER JOIN {sessions} s ON u.uid = s.uid WHERE s.sid = '%s'", $key));  // We found the client's session record and they are an authenticated,  // active user.  if ($user && $user->uid > 0 && $user->status == 1) {    // This is done to unserialize the data member of $user    $user = drupal_unpack($user);    // Add roles element to $user    $user->roles = array();    $user->roles[DRUPAL_AUTHENTICATED_RID] = 'authenticated user';    $result = db_query("SELECT r.rid, r.name FROM {role} r INNER JOIN {users_roles} ur ON ur.rid = r.rid WHERE ur.uid = %d", $user->uid);    while ($role = db_fetch_object($result)) {      $user->roles[$role->rid] = $role->name;    }  }  // We didn't find the client's record (session has expired), or they are  // blocked, or they are an anonymous user.  else {    $session = isset($user->session) ? $user->session : '';    $user = drupal_anonymous_user($session);  }  return $user->session;}function sess_write($key, $value) {  global $user;  // If saving of session data is disabled or if the client doesn't have a session,  // and one isn't being created ($value), do nothing. This keeps crawlers out of  // the session table. This reduces memory and server load, and gives more useful  // statistics. We can't eliminate anonymous session table rows without breaking  // the throttle module and the "Who's Online" block.  if (!session_save_session() || ($user->uid == 0 && empty($_COOKIE[session_name()]) && empty($value))) {    return TRUE;  }  db_query("UPDATE {sessions} SET uid = %d, cache = %d, hostname = '%s', session = '%s', timestamp = %d WHERE sid = '%s'", $user->uid, isset($user->cache) ? $user->cache : '', ip_address(), $value, time(), $key);  if (db_affected_rows()) {    // Last access time is updated no more frequently than once every 180 seconds.    // This reduces contention in the users table.    if ($user->uid && time() - $user->access > variable_get('session_write_interval', 180)) {      db_query("UPDATE {users} SET access = %d WHERE uid = %d", time(), $user->uid);    }  }  else {    // If this query fails, another parallel request probably got here first.    // In that case, any session data generated in this request is discarded.    @db_query("INSERT INTO {sessions} (sid, uid, cache, hostname, session, timestamp) VALUES ('%s', %d, %d, '%s', '%s', %d)", $key, $user->uid, isset($user->cache) ? $user->cache : '', ip_address(), $value, time());  }  return TRUE;}/** * Called when an anonymous user becomes authenticated or vice-versa. */function sess_regenerate() {  $old_session_id = session_id();  // We code around http://bugs.php.net/bug.php?id=32802 by destroying  // the session cookie by setting expiration in the past (a negative  // value).  This issue only arises in PHP versions before 4.4.0,  // regardless of the Drupal configuration.  // TODO: remove this when we require at least PHP 4.4.0  if (isset($_COOKIE[session_name()])) {    setcookie(session_name(), '', time() - 42000, '/');  }  session_regenerate_id();  db_query("UPDATE {sessions} SET sid = '%s' WHERE sid = '%s'", session_id(), $old_session_id);}/** * Counts how many users have sessions. Can count either anonymous sessions or authenticated sessions. * * @param int $timestamp *   A Unix timestamp representing a point of time in the past. *   The default is 0, which counts all existing sessions. * @param boolean $anonymous *   TRUE counts only anonymous users. *   FALSE counts only authenticated users. * @return  int *   The number of users with sessions. */function sess_count($timestamp = 0, $anonymous = true) {  $query = $anonymous ? ' AND uid = 0' : ' AND uid > 0';  return db_result(db_query('SELECT COUNT(sid) AS count FROM {sessions} WHERE timestamp >= %d'. $query, $timestamp));}/** * Called by PHP session handling with the PHP session ID to end a user's session. * * @param  string $sid *   the session id */function sess_destroy_sid($sid) {  db_query("DELETE FROM {sessions} WHERE sid = '%s'", $sid);}/** * End a specific user's session * * @param  string $uid *   the user id */function sess_destroy_uid($uid) {  db_query('DELETE FROM {sessions} WHERE uid = %d', $uid);}function sess_gc($lifetime) {  // Be sure to adjust 'php_value session.gc_maxlifetime' to a large enough  // value. For example, if you want user sessions to stay in your database  // for three weeks before deleting them, you need to set gc_maxlifetime  // to '1814400'. At that value, only after a user doesn't log in after  // three weeks (1814400 seconds) will his/her session be removed.  db_query("DELETE FROM {sessions} WHERE timestamp < %d", time() - $lifetime);  return TRUE;}/** * Determine whether to save session data of the current request. * * This function allows the caller to temporarily disable writing of session data, * should the request end while performing potentially dangerous operations, such as * manipulating the global $user object.  See http://drupal.org/node/218104 for usage * * @param $status *   Disables writing of session data when FALSE, (re-)enables writing when TRUE. * @return *   FALSE if writing session data has been disabled. Otherwise, TRUE. */function session_save_session($status = NULL) {  static $save_session = TRUE;  if (isset($status)) {    $save_session = $status;  }  return ($save_session);}
<?php// $Id$/** * @file * User page callbacks for the book module. *//** * Menu callback; prints a listing of all books. */function book_render() {  $book_list = array();  foreach (book_get_books() as $book) {    $book_list[] = l($book['title'], $book['href'], $book['options']);  }  return theme('item_list', $book_list);}/** * Menu callback; Generates various representation of a book page and its children. * * The function delegates the generation of output to helper functions. * The function name is derived by prepending 'book_export_' to the * given output type. So, e.g., a type of 'html' results in a call to * the function book_export_html(). * * @param $type *   A string encoding the type of output requested. The following *   types are currently supported in book module: * *   - html: HTML (printer friendly output) * *   Other types may be supported in contributed modules. * @param $nid *   An integer representing the node id (nid) of the node to export * @return *   A string representing the node and its children in the book hierarchy *   in a format determined by the $type parameter. */function book_export($type, $nid) {  $type = drupal_strtolower($type);  $export_function = 'book_export_'. $type;  if (function_exists($export_function)) {    print call_user_func($export_function, $nid);  }  else {    drupal_set_message(t('Unknown export format.'));    drupal_not_found();  }}/** * This function is called by book_export() to generate HTML for export. * * The given node is /embedded to its absolute depth in a top level * section/. For example, a child node with depth 2 in the hierarchy * is contained in (otherwise empty) &lt;div&gt; elements * corresponding to depth 0 and depth 1. This is intended to support * WYSIWYG output - e.g., level 3 sections always look like level 3 * sections, no matter their depth relative to the node selected to be * exported as printer-friendly HTML. * * @param $nid *   An integer representing the node id (nid) of the node to export. * @return *   A string containing HTML representing the node and its children in *   the book hierarchy. */function book_export_html($nid) {  if (user_access('access printer-friendly version')) {    $export_data = array();    $node = node_load($nid);    if (isset($node->book)) {      $tree = book_menu_subtree_data($node->book);      $contents = book_export_traverse($tree, 'book_node_export');    }    return theme('book_export_html', $node->title, $contents, $node->book['depth']);  }  else {    drupal_access_denied();  }}/** * Menu callback; show the outline form for a single node. */function book_outline($node) {  drupal_set_title(check_plain($node->title));  return drupal_get_form('book_outline_form', $node);}/** * Build the form to handle all book outline operations via the outline tab. * * @see book_outline_form_submit() * @see book_remove_button_submit() * * @ingroup forms */function book_outline_form(&$form_state, $node) {  if (!isset($node->book)) {    // The node is not part of any book yet - set default options.    $node->book = _book_link_defaults($node->nid);  }  else {    $node->book['original_bid'] = $node->book['bid'];  }  // Find the depth limit for the parent select.  if (!isset($node->book['parent_depth_limit'])) {    $node->book['parent_depth_limit'] = _book_parent_depth_limit($node->book);  }  $form['#node'] = $node;  $form['#id'] = 'book-outline';  _book_add_form_elements($form, $node);  $form['book']['#collapsible'] = FALSE;  $form['update'] = array(    '#type' => 'submit',    '#value' => $node->book['original_bid'] ? t('Update book outline') : t('Add to book outline'),    '#weight' => 15,  );  $form['remove'] = array(    '#type' => 'submit',    '#value' => t('Remove from book outline'),    '#access' => $node->nid != $node->book['bid'] && $node->book['bid'],    '#weight' => 20,    '#submit' => array('book_remove_button_submit'),  );  return $form;}/** * Button submit function to redirect to removal confirm form. * * @see book_outline_form() */function book_remove_button_submit($form, &$form_state) {  $form_state['redirect'] = 'node/'. $form['#node']->nid .'/outline/remove';}/** * Handles book outline form submissions from the outline tab. * * @see book_outline_form() */function book_outline_form_submit($form, &$form_state) {  $node = $form['#node'];  $form_state['redirect'] = "node/". $node->nid;  $book_link = $form_state['values']['book'];  if (!$book_link['bid']) {    drupal_set_message(t('No changes were made'));    return;  }  $book_link['menu_name'] = book_menu_name($book_link['bid']);  $node->book = $book_link;  if (_book_update_outline($node)) {    if ($node->book['parent_mismatch']) {      // This will usually only happen when JS is disabled.      drupal_set_message(t('The post has been added to the selected book. You may now position it relative to other pages.'));      $form_state['redirect'] = "node/". $node->nid ."/outline";    }    else {      drupal_set_message(t('The book outline has been updated.'));    }  }  else {    drupal_set_message(t('There was an error adding the post to the book.'), 'error');  }}/** * Menu callback; builds a form to confirm removal of a node from the book. * * @see book_remove_form_submit() * * @ingroup forms */function book_remove_form(&$form_state, $node) {  $form['#node'] = $node;  $title = array('%title' => $node->title);  if ($node->book['has_children']) {    $description = t('%title has associated child pages, which will be relocated automatically to maintain their connection to the book. To recreate the hierarchy (as it was before removing this page), %title may be added again using the Outline tab, and each of its former child pages will need to be relocated manually.', $title);  }  else {    $description = t('%title may be added to hierarchy again using the Outline tab.', $title);  }  return confirm_form($form, t('Are you sure you want to remove %title from the book hierarchy?', $title), 'node/'. $node->nid, $description, t('Remove'));}/** * Confirm form submit function to remove a node from the book. * * @see book_remove_form() */function book_remove_form_submit($form, &$form_state) {  $node = $form['#node'];  if ($node->nid != $node->book['bid']) {    // Only allowed when this is not a book (top-level page).    menu_link_delete($node->book['mlid']);    db_query('DELETE FROM {book} WHERE nid = %d', $node->nid);    drupal_set_message(t('The post has been removed from the book.'));  }  $form_state['redirect'] = 'node/'. $node->nid;}/** * AJAX callback to replace the book parent select options. * * This function is called when the selected book is changed.  It updates the * cached form (either the node form or the book outline form) and returns * rendered output to be used to replace the select containing the possible * parent pages in the newly selected book. * * @param $build_id *   The form's build_id. * @param $bid *   A bid from from among those in the form's book select. * @return *   Prints the replacement HTML in JSON format. */function book_form_update() {  $bid = $_POST['book']['bid'];  if ($form = form_get_cache($_POST['form_build_id'], $form_state)) {    // Validate the bid.    if (isset($form['book']['bid']['#options'][$bid])) {      $book_link = $form['#node']->book;      $book_link['bid'] = $bid;      // Get the new options and update the cache.      $form['book']['plid'] = _book_parent_select($book_link);      form_set_cache($_POST['form_build_id'], $form, $form_state);      // Build and render the new select element, then return it in JSON format.      $form_state = array();      $form['#post'] = array();      $form = form_builder($form['form_id']['#value'] , $form, $form_state);      $output = drupal_render($form['book']['plid']);      drupal_json(array('status' => TRUE, 'data' => $output));    }    else {      drupal_json(array('status' => FALSE, 'data' => ''));    }  }  else {    drupal_json(array('status' => FALSE, 'data' => ''));  }  exit();}
<?php// $Id$/** * @file forum-icon.tpl.php * Display an appropriate icon for a forum post. * * Available variables: * - $new_posts: Indicates whether or not the topic contains new posts. * - $icon: The icon to display. May be one of 'hot', 'hot-new', 'new', *   'default', 'closed', or 'sticky'. * * @see template_preprocess_forum_icon() * @see theme_forum_icon() */?><?php if ($new_posts): ?>  <a name="new"><?php endif; ?><?php print theme('image', "misc/forum-$icon.png") ?><?php if ($new_posts): ?>  </a><?php endif; ?>
<?php// $Id$/** * @file * Administrative page callbacks for the dblog module. *//** * dblog module settings form. * * @ingroup forms * @see system_settings_form() */function dblog_admin_settings() {  $form['dblog_row_limit'] = array(    '#type' => 'select',    '#title' => t('Discard log entries above the following row limit'),    '#default_value' => variable_get('dblog_row_limit', 1000),    '#options' => drupal_map_assoc(array(100, 1000, 10000, 100000, 1000000)),    '#description' => t('The maximum number of rows to keep in the database log. Older entries will be automatically discarded. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status')))  );  return system_settings_form($form);}/** * Menu callback; displays a listing of log messages. */function dblog_overview() {  $filter = dblog_build_filter_query();  $rows = array();  $icons = array(    WATCHDOG_DEBUG    => '',    WATCHDOG_INFO     => '',    WATCHDOG_NOTICE   => '',    WATCHDOG_WARNING  => theme('image', 'misc/watchdog-warning.png', t('warning'), t('warning')),    WATCHDOG_ERROR    => theme('image', 'misc/watchdog-error.png', t('error'), t('error')),    WATCHDOG_CRITICAL => theme('image', 'misc/watchdog-error.png', t('critical'), t('critical')),    WATCHDOG_ALERT    => theme('image', 'misc/watchdog-error.png', t('alert'), t('alert')),    WATCHDOG_EMERG    => theme('image', 'misc/watchdog-error.png', t('emergency'), t('emergency')),  );  $classes = array(    WATCHDOG_DEBUG    => 'dblog-debug',    WATCHDOG_INFO     => 'dblog-info',    WATCHDOG_NOTICE   => 'dblog-notice',    WATCHDOG_WARNING  => 'dblog-warning',    WATCHDOG_ERROR    => 'dblog-error',    WATCHDOG_CRITICAL => 'dblog-critical',    WATCHDOG_ALERT    => 'dblog-alert',    WATCHDOG_EMERG    => 'dblog-emerg',  );  $output = drupal_get_form('dblog_filter_form');  $header = array(    ' ',    array('data' => t('Type'), 'field' => 'w.type'),    array('data' => t('Date'), 'field' => 'w.wid', 'sort' => 'desc'),    t('Message'),    array('data' => t('User'), 'field' => 'u.name'),    array('data' => t('Operations')),  );  $sql = "SELECT w.wid, w.uid, w.severity, w.type, w.timestamp, w.message, w.variables, w.link, u.name FROM {watchdog} w INNER JOIN {users} u ON w.uid = u.uid";  $tablesort = tablesort_sql($header);  if (!empty($filter['where'])) {    $result = pager_query($sql ." WHERE ". $filter['where'] . $tablesort, 50, 0, NULL, $filter['args']);  }  else {    $result = pager_query($sql . $tablesort, 50);  }  while ($dblog = db_fetch_object($result)) {    $rows[] = array('data' =>      array(        // Cells        $icons[$dblog->severity],        t($dblog->type),        format_date($dblog->timestamp, 'small'),        l(truncate_utf8(_dblog_format_message($dblog), 56, TRUE, TRUE), 'admin/reports/event/'. $dblog->wid, array('html' => TRUE)),        theme('username', $dblog),        $dblog->link,      ),      // Attributes for tr      'class' => "dblog-". preg_replace('/[^a-z]/i', '-', $dblog->type) .' '. $classes[$dblog->severity]    );  }  if (!$rows) {    $rows[] = array(array('data' => t('No log messages available.'), 'colspan' => 6));  }  $output .= theme('table', $header, $rows, array('id' => 'admin-dblog'));  $output .= theme('pager', NULL, 50, 0);  return $output;}/** * Menu callback; generic function to display a page of the most frequent * dblog events of a specified type. */function dblog_top($type) {  $header = array(    array('data' => t('Count'), 'field' => 'count', 'sort' => 'desc'),    array('data' => t('Message'), 'field' => 'message')  );  $result = pager_query("SELECT COUNT(wid) AS count, message, variables FROM {watchdog} WHERE type = '%s' GROUP BY message, variables ". tablesort_sql($header), 30, 0, "SELECT COUNT(DISTINCT(message)) FROM {watchdog} WHERE type = '%s'", $type);  $rows = array();  while ($dblog = db_fetch_object($result)) {    $rows[] = array($dblog->count, truncate_utf8(_dblog_format_message($dblog), 56, TRUE, TRUE));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No log messages available.'), 'colspan' => 2));  }  $output  = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; displays details about a log message. */function dblog_event($id) {  $severity = watchdog_severity_levels();  $output = '';  $result = db_query('SELECT w.*, u.name, u.uid FROM {watchdog} w INNER JOIN {users} u ON w.uid = u.uid WHERE w.wid = %d', $id);  if ($dblog = db_fetch_object($result)) {    $rows = array(      array(        array('data' => t('Type'), 'header' => TRUE),        t($dblog->type),      ),      array(        array('data' => t('Date'), 'header' => TRUE),        format_date($dblog->timestamp, 'large'),      ),      array(        array('data' => t('User'), 'header' => TRUE),        theme('username', $dblog),      ),      array(        array('data' => t('Location'), 'header' => TRUE),        l($dblog->location, $dblog->location),      ),      array(        array('data' => t('Referrer'), 'header' => TRUE),        l($dblog->referer, $dblog->referer),      ),      array(        array('data' => t('Message'), 'header' => TRUE),        _dblog_format_message($dblog),      ),      array(        array('data' => t('Severity'), 'header' => TRUE),        $severity[$dblog->severity],      ),      array(        array('data' => t('Hostname'), 'header' => TRUE),        check_plain($dblog->hostname),      ),      array(        array('data' => t('Operations'), 'header' => TRUE),        $dblog->link,      ),    );    $attributes = array('class' => 'dblog-event');    $output = theme('table', array(), $rows, $attributes);  }  return $output;}/** * Build query for dblog administration filters based on session. */function dblog_build_filter_query() {  if (empty($_SESSION['dblog_overview_filter'])) {    return;  }  $filters = dblog_filters();  // Build query  $where = $args = array();  foreach ($_SESSION['dblog_overview_filter'] as $key => $filter) {    $filter_where = array();    foreach ($filter as $value) {      $filter_where[] = $filters[$key]['where'];      $args[] = $value;    }    if (!empty($filter_where)) {      $where[] = '('. implode(' OR ', $filter_where) .')';    }  }  $where = !empty($where) ? implode(' AND ', $where) : '';  return array(    'where' => $where,    'args' => $args,  );}/** * List dblog administration filters that can be applied. */function dblog_filters() {  $filters = array();  foreach (_dblog_get_message_types() as $type) {    $types[$type] = $type;  }  if (!empty($types)) {    $filters['type'] = array(      'title' => t('Type'),      'where' => "w.type = '%s'",      'options' => $types,    );  }  $filters['severity'] = array(    'title' => t('Severity'),    'where' => 'w.severity = %d',    'options' => watchdog_severity_levels(),  );  return $filters;}/** * Formats a log message for display. * * @param $dblog *   An object with at least the message and variables properties */function _dblog_format_message($dblog) {  // Legacy messages and user specified text  if ($dblog->variables === 'N;') {    return $dblog->message;  }  // Message to translate with injected variables  else {    return t($dblog->message, unserialize($dblog->variables));  }}/** * Return form for dblog administration filters. * * @ingroup forms * @see dblog_filter_form_submit() * @see dblog_filter_form_validate() */function dblog_filter_form() {  $session = &$_SESSION['dblog_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = dblog_filters();  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Filter log messages'),    '#theme' => 'dblog_filters',    '#collapsible' => TRUE,    '#collapsed' => empty($session),  );  foreach ($filters as $key => $filter) {    $form['filters']['status'][$key] = array(      '#title' => $filter['title'],      '#type' => 'select',      '#multiple' => TRUE,      '#size' => 8,      '#options' => $filter['options'],    );    if (!empty($session[$key])) {      $form['filters']['status'][$key]['#default_value'] = $session[$key];    }  }  $form['filters']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Filter'),  );  if (!empty($session)) {    $form['filters']['buttons']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset')    );  }  return $form;}/** * Validate result from dblog administration filter form. */function dblog_filter_form_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Filter') && empty($form_state['values']['type']) && empty($form_state['values']['severity'])) {    form_set_error('type', t('You must select something to filter by.'));  }}/** * Process result from dblog administration filter form. */function dblog_filter_form_submit($form, &$form_state) {  $op = $form_state['values']['op'];  $filters = dblog_filters();  switch ($op) {    case t('Filter'):      foreach ($filters as $name => $filter) {        if (isset($form_state['values'][$name])) {          $_SESSION['dblog_overview_filter'][$name] = $form_state['values'][$name];        }      }      break;    case t('Reset'):      $_SESSION['dblog_overview_filter'] = array();      break;  }  return 'admin/reports/dblog';}
<?php// $Id$/** * @file * Enables site-wide keyword searching. *//** * Matches Unicode character classes to exclude from the search index. * * See: http://www.unicode.org/Public/UNIDATA/UCD.html#General_Category_Values * * The index only contains the following character classes: * Lu     Letter, Uppercase * Ll     Letter, Lowercase * Lt     Letter, Titlecase * Lo     Letter, Other * Nd     Number, Decimal Digit * No     Number, Other */define('PREG_CLASS_SEARCH_EXCLUDE','\x{0}-\x{2f}\x{3a}-\x{40}\x{5b}-\x{60}\x{7b}-\x{bf}\x{d7}\x{f7}\x{2b0}-'.'\x{385}\x{387}\x{3f6}\x{482}-\x{489}\x{559}-\x{55f}\x{589}-\x{5c7}\x{5f3}-'.'\x{61f}\x{640}\x{64b}-\x{65e}\x{66a}-\x{66d}\x{670}\x{6d4}\x{6d6}-\x{6ed}'.'\x{6fd}\x{6fe}\x{700}-\x{70f}\x{711}\x{730}-\x{74a}\x{7a6}-\x{7b0}\x{901}-'.'\x{903}\x{93c}\x{93e}-\x{94d}\x{951}-\x{954}\x{962}-\x{965}\x{970}\x{981}-'.'\x{983}\x{9bc}\x{9be}-\x{9cd}\x{9d7}\x{9e2}\x{9e3}\x{9f2}-\x{a03}\x{a3c}-'.'\x{a4d}\x{a70}\x{a71}\x{a81}-\x{a83}\x{abc}\x{abe}-\x{acd}\x{ae2}\x{ae3}'.'\x{af1}-\x{b03}\x{b3c}\x{b3e}-\x{b57}\x{b70}\x{b82}\x{bbe}-\x{bd7}\x{bf0}-'.'\x{c03}\x{c3e}-\x{c56}\x{c82}\x{c83}\x{cbc}\x{cbe}-\x{cd6}\x{d02}\x{d03}'.'\x{d3e}-\x{d57}\x{d82}\x{d83}\x{dca}-\x{df4}\x{e31}\x{e34}-\x{e3f}\x{e46}-'.'\x{e4f}\x{e5a}\x{e5b}\x{eb1}\x{eb4}-\x{ebc}\x{ec6}-\x{ecd}\x{f01}-\x{f1f}'.'\x{f2a}-\x{f3f}\x{f71}-\x{f87}\x{f90}-\x{fd1}\x{102c}-\x{1039}\x{104a}-'.'\x{104f}\x{1056}-\x{1059}\x{10fb}\x{10fc}\x{135f}-\x{137c}\x{1390}-\x{1399}'.'\x{166d}\x{166e}\x{1680}\x{169b}\x{169c}\x{16eb}-\x{16f0}\x{1712}-\x{1714}'.'\x{1732}-\x{1736}\x{1752}\x{1753}\x{1772}\x{1773}\x{17b4}-\x{17db}\x{17dd}'.'\x{17f0}-\x{180e}\x{1843}\x{18a9}\x{1920}-\x{1945}\x{19b0}-\x{19c0}\x{19c8}'.'\x{19c9}\x{19de}-\x{19ff}\x{1a17}-\x{1a1f}\x{1d2c}-\x{1d61}\x{1d78}\x{1d9b}-'.'\x{1dc3}\x{1fbd}\x{1fbf}-\x{1fc1}\x{1fcd}-\x{1fcf}\x{1fdd}-\x{1fdf}\x{1fed}-'.'\x{1fef}\x{1ffd}-\x{2070}\x{2074}-\x{207e}\x{2080}-\x{2101}\x{2103}-\x{2106}'.'\x{2108}\x{2109}\x{2114}\x{2116}-\x{2118}\x{211e}-\x{2123}\x{2125}\x{2127}'.'\x{2129}\x{212e}\x{2132}\x{213a}\x{213b}\x{2140}-\x{2144}\x{214a}-\x{2b13}'.'\x{2ce5}-\x{2cff}\x{2d6f}\x{2e00}-\x{3005}\x{3007}-\x{303b}\x{303d}-\x{303f}'.'\x{3099}-\x{309e}\x{30a0}\x{30fb}-\x{30fe}\x{3190}-\x{319f}\x{31c0}-\x{31cf}'.'\x{3200}-\x{33ff}\x{4dc0}-\x{4dff}\x{a015}\x{a490}-\x{a716}\x{a802}\x{a806}'.'\x{a80b}\x{a823}-\x{a82b}\x{d800}-\x{f8ff}\x{fb1e}\x{fb29}\x{fd3e}\x{fd3f}'.'\x{fdfc}-\x{fe6b}\x{feff}-\x{ff0f}\x{ff1a}-\x{ff20}\x{ff3b}-\x{ff40}\x{ff5b}-'.'\x{ff65}\x{ff70}\x{ff9e}\x{ff9f}\x{ffe0}-\x{fffd}');/** * Matches all 'N' Unicode character classes (numbers) */define('PREG_CLASS_NUMBERS','\x{30}-\x{39}\x{b2}\x{b3}\x{b9}\x{bc}-\x{be}\x{660}-\x{669}\x{6f0}-\x{6f9}'.'\x{966}-\x{96f}\x{9e6}-\x{9ef}\x{9f4}-\x{9f9}\x{a66}-\x{a6f}\x{ae6}-\x{aef}'.'\x{b66}-\x{b6f}\x{be7}-\x{bf2}\x{c66}-\x{c6f}\x{ce6}-\x{cef}\x{d66}-\x{d6f}'.'\x{e50}-\x{e59}\x{ed0}-\x{ed9}\x{f20}-\x{f33}\x{1040}-\x{1049}\x{1369}-'.'\x{137c}\x{16ee}-\x{16f0}\x{17e0}-\x{17e9}\x{17f0}-\x{17f9}\x{1810}-\x{1819}'.'\x{1946}-\x{194f}\x{2070}\x{2074}-\x{2079}\x{2080}-\x{2089}\x{2153}-\x{2183}'.'\x{2460}-\x{249b}\x{24ea}-\x{24ff}\x{2776}-\x{2793}\x{3007}\x{3021}-\x{3029}'.'\x{3038}-\x{303a}\x{3192}-\x{3195}\x{3220}-\x{3229}\x{3251}-\x{325f}\x{3280}-'.'\x{3289}\x{32b1}-\x{32bf}\x{ff10}-\x{ff19}');/** * Matches all 'P' Unicode character classes (punctuation) */define('PREG_CLASS_PUNCTUATION','\x{21}-\x{23}\x{25}-\x{2a}\x{2c}-\x{2f}\x{3a}\x{3b}\x{3f}\x{40}\x{5b}-\x{5d}'.'\x{5f}\x{7b}\x{7d}\x{a1}\x{ab}\x{b7}\x{bb}\x{bf}\x{37e}\x{387}\x{55a}-\x{55f}'.'\x{589}\x{58a}\x{5be}\x{5c0}\x{5c3}\x{5f3}\x{5f4}\x{60c}\x{60d}\x{61b}\x{61f}'.'\x{66a}-\x{66d}\x{6d4}\x{700}-\x{70d}\x{964}\x{965}\x{970}\x{df4}\x{e4f}'.'\x{e5a}\x{e5b}\x{f04}-\x{f12}\x{f3a}-\x{f3d}\x{f85}\x{104a}-\x{104f}\x{10fb}'.'\x{1361}-\x{1368}\x{166d}\x{166e}\x{169b}\x{169c}\x{16eb}-\x{16ed}\x{1735}'.'\x{1736}\x{17d4}-\x{17d6}\x{17d8}-\x{17da}\x{1800}-\x{180a}\x{1944}\x{1945}'.'\x{2010}-\x{2027}\x{2030}-\x{2043}\x{2045}-\x{2051}\x{2053}\x{2054}\x{2057}'.'\x{207d}\x{207e}\x{208d}\x{208e}\x{2329}\x{232a}\x{23b4}-\x{23b6}\x{2768}-'.'\x{2775}\x{27e6}-\x{27eb}\x{2983}-\x{2998}\x{29d8}-\x{29db}\x{29fc}\x{29fd}'.'\x{3001}-\x{3003}\x{3008}-\x{3011}\x{3014}-\x{301f}\x{3030}\x{303d}\x{30a0}'.'\x{30fb}\x{fd3e}\x{fd3f}\x{fe30}-\x{fe52}\x{fe54}-\x{fe61}\x{fe63}\x{fe68}'.'\x{fe6a}\x{fe6b}\x{ff01}-\x{ff03}\x{ff05}-\x{ff0a}\x{ff0c}-\x{ff0f}\x{ff1a}'.'\x{ff1b}\x{ff1f}\x{ff20}\x{ff3b}-\x{ff3d}\x{ff3f}\x{ff5b}\x{ff5d}\x{ff5f}-'.'\x{ff65}');/** * Matches all CJK characters that are candidates for auto-splitting * (Chinese, Japanese, Korean). * Contains kana and BMP ideographs. */define('PREG_CLASS_CJK', '\x{3041}-\x{30ff}\x{31f0}-\x{31ff}\x{3400}-\x{4db5}'.'\x{4e00}-\x{9fbb}\x{f900}-\x{fad9}');/** * Implementation of hook_help(). */function search_help($path, $arg) {  switch ($path) {    case 'admin/help#search':      $output = '<p>'. t('The search module adds the ability to search for content by keywords. Search is often the only practical way to find content on a large site, and is useful for finding both users and posts.') .'</p>';      $output .= '<p>'. t('To provide keyword searching, the search engine maintains an index of words found in your site\'s content. To build and maintain this index, a correctly configured <a href="@cron">cron maintenance task</a> is required. Indexing behavior can be adjusted using the <a href="@searchsettings">search settings page</a>; for example, the <em>Number of items to index per cron run</em> sets the maximum number of items indexed in each pass of a <a href="@cron">cron maintenance task</a>. If necessary, reduce this number to prevent timeouts and memory errors when indexing.', array('@cron' => url('admin/reports/status'), '@searchsettings' => url('admin/settings/search'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@search">Search module</a>.', array('@search' => 'http://drupal.org/handbook/modules/search/')) .'</p>';      return $output;    case 'admin/settings/search':      return '<p>'. t('The search engine maintains an index of words found in your site\'s content. To build and maintain this index, a correctly configured <a href="@cron">cron maintenance task</a> is required. Indexing behavior can be adjusted using the settings below.', array('@cron' => url('admin/reports/status'))) .'</p>';    case 'search#noresults':      return t('<ul><li>Check if your spelling is correct.</li><li>Remove quotes around phrases to match each word individually: <em>"blue smurf"</em> will match less than <em>blue smurf</em>.</li><li>Consider loosening your query with <em>OR</em>: <em>blue smurf</em> will match less than <em>blue OR smurf</em>.</li></ul>');  }}/** * Implementation of hook_theme() */function search_theme() {  return array(    'search_theme_form' => array(      'arguments' => array('form' => NULL),      'template' => 'search-theme-form',    ),    'search_block_form' => array(      'arguments' => array('form' => NULL),      'template' => 'search-block-form',    ),    'search_result' => array(      'arguments' => array('result' => NULL, 'type' => NULL),      'file' => 'search.pages.inc',      'template' => 'search-result',    ),    'search_results' => array(      'arguments' => array('results' => NULL, 'type' => NULL),      'file' => 'search.pages.inc',      'template' => 'search-results',    ),  );}/** * Implementation of hook_perm(). */function search_perm() {  return array('search content', 'use advanced search', 'administer search');}/** * Implementation of hook_block(). */function search_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Search form');    // Not worth caching.    $blocks[0]['cache'] = BLOCK_NO_CACHE;    return $blocks;  }  else if ($op == 'view' && user_access('search content')) {    $block['content'] = drupal_get_form('search_block_form');    $block['subject'] = t('Search');    return $block;  }}/** * Implementation of hook_menu(). */function search_menu() {  $items['search'] = array(    'title' => 'Search',    'page callback' => 'search_view',    'access arguments' => array('search content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'search.pages.inc',  );  $items['admin/settings/search'] = array(    'title' => 'Search settings',    'description' => 'Configure relevance settings for search and other indexing options',    'page callback' => 'drupal_get_form',    'page arguments' => array('search_admin_settings'),    'access arguments' => array('administer search'),    'type' => MENU_NORMAL_ITEM,    'file' => 'search.admin.inc',  );  $items['admin/settings/search/wipe'] = array(    'title' => 'Clear index',    'page callback' => 'drupal_get_form',    'page arguments' => array('search_wipe_confirm'),    'access arguments' => array('administer search'),    'type' => MENU_CALLBACK,    'file' => 'search.admin.inc',  );  $items['admin/reports/search'] = array(    'title' => 'Top search phrases',    'description' => 'View most popular search phrases.',    'page callback' => 'dblog_top',    'page arguments' => array('search'),    'access arguments' => array('access site reports'),    'file' => 'dblog.admin.inc',    'file path' => drupal_get_path('module', 'dblog'),  );  foreach (module_implements('search') as $name) {    $items['search/'. $name .'/%menu_tail'] = array(      'title callback' => 'module_invoke',      'title arguments' => array($name, 'search', 'name', TRUE),      'page callback' => 'search_view',      'page arguments' => array($name),      'access callback' => '_search_menu',      'access arguments' => array($name),      'type' => MENU_LOCAL_TASK,      'parent' => 'search',      'file' => 'search.pages.inc',    );  }  return $items;}function _search_menu($name) {  return user_access('search content') && module_invoke($name, 'search', 'name');}/** * Wipes a part of or the entire search index. * * @param $sid *  (optional) The SID of the item to wipe. If specified, $type must be passed *  too. * @param $type *  (optional) The type of item to wipe. */function search_wipe($sid = NULL, $type = NULL, $reindex = FALSE) {  if ($type == NULL && $sid == NULL) {    module_invoke_all('search', 'reset');  }  else {    db_query("DELETE FROM {search_dataset} WHERE sid = %d AND type = '%s'", $sid, $type);    db_query("DELETE FROM {search_index} WHERE sid = %d AND type = '%s'", $sid, $type);    // Don't remove links if re-indexing.    if (!$reindex) {      db_query("DELETE FROM {search_node_links} WHERE sid = %d AND type = '%s'", $sid, $type);    }  }}/** * Marks a word as dirty (or retrieves the list of dirty words). This is used * during indexing (cron). Words which are dirty have outdated total counts in * the search_total table, and need to be recounted. */function search_dirty($word = NULL) {  static $dirty = array();  if ($word !== NULL) {    $dirty[$word] = TRUE;  }  else {    return $dirty;  }}/** * Implementation of hook_cron(). * * Fires hook_update_index() in all modules and cleans up dirty words (see * search_dirty). */function search_cron() {  // We register a shutdown function to ensure that search_total is always up  // to date.  register_shutdown_function('search_update_totals');  // Update word index  foreach (module_list() as $module) {    module_invoke($module, 'update_index');  }}/** * This function is called on shutdown to ensure that search_total is always * up to date (even if cron times out or otherwise fails). */function search_update_totals() {  // Update word IDF (Inverse Document Frequency) counts for new/changed words  foreach (search_dirty() as $word => $dummy) {    // Get total count    $total = db_result(db_query("SELECT SUM(score) FROM {search_index} WHERE word = '%s'", $word));    // Apply Zipf's law to equalize the probability distribution    $total = log10(1 + 1/(max(1, $total)));    db_query("UPDATE {search_total} SET count = %f WHERE word = '%s'", $total, $word);    if (!db_affected_rows()) {      db_query("INSERT INTO {search_total} (word, count) VALUES ('%s', %f)", $word, $total);    }  }  // Find words that were deleted from search_index, but are still in  // search_total. We use a LEFT JOIN between the two tables and keep only the  // rows which fail to join.  $result = db_query("SELECT t.word AS realword, i.word FROM {search_total} t LEFT JOIN {search_index} i ON t.word = i.word WHERE i.word IS NULL");  while ($word = db_fetch_object($result)) {    db_query("DELETE FROM {search_total} WHERE word = '%s'", $word->realword);  }}/** * Simplifies a string according to indexing rules. */function search_simplify($text) {  // Decode entities to UTF-8  $text = decode_entities($text);  // Lowercase  $text = drupal_strtolower($text);  // Call an external processor for word handling.  search_invoke_preprocess($text);  // Simple CJK handling  if (variable_get('overlap_cjk', TRUE)) {    $text = preg_replace_callback('/['. PREG_CLASS_CJK .']+/u', 'search_expand_cjk', $text);  }  // To improve searching for numerical data such as dates, IP addresses  // or version numbers, we consider a group of numerical characters  // separated only by punctuation characters to be one piece.  // This also means that searching for e.g. '20/03/1984' also returns  // results with '20-03-1984' in them.  // Readable regexp: ([number]+)[punctuation]+(?=[number])  $text = preg_replace('/(['. PREG_CLASS_NUMBERS .']+)['. PREG_CLASS_PUNCTUATION .']+(?=['. PREG_CLASS_NUMBERS .'])/u', '\1', $text);  // The dot, underscore and dash are simply removed. This allows meaningful  // search behavior with acronyms and URLs.  $text = preg_replace('/[._-]+/', '', $text);  // With the exception of the rules above, we consider all punctuation,  // marks, spacers, etc, to be a word boundary.  $text = preg_replace('/['. PREG_CLASS_SEARCH_EXCLUDE .']+/u', ' ', $text);  return $text;}/** * Basic CJK tokenizer. Simply splits a string into consecutive, overlapping * sequences of characters ('minimum_word_size' long). */function search_expand_cjk($matches) {  $min = variable_get('minimum_word_size', 3);  $str = $matches[0];  $l = drupal_strlen($str);  // Passthrough short words  if ($l <= $min) {    return ' '. $str .' ';  }  $tokens = ' ';  // FIFO queue of characters  $chars = array();  // Begin loop  for ($i = 0; $i < $l; ++$i) {    // Grab next character    $current = drupal_substr($str, 0, 1);    $str = substr($str, strlen($current));    $chars[] = $current;    if ($i >= $min - 1) {      $tokens .= implode('', $chars) .' ';      array_shift($chars);    }  }  return $tokens;}/** * Splits a string into tokens for indexing. */function search_index_split($text) {  static $last = NULL;  static $lastsplit = NULL;  if ($last == $text) {    return $lastsplit;  }  // Process words  $text = search_simplify($text);  $words = explode(' ', $text);  array_walk($words, '_search_index_truncate');  // Save last keyword result  $last = $text;  $lastsplit = $words;  return $words;}/** * Helper function for array_walk in search_index_split. */function _search_index_truncate(&$text) {  $text = truncate_utf8($text, 50);}/** * Invokes hook_search_preprocess() in modules. */function search_invoke_preprocess(&$text) {  foreach (module_implements('search_preprocess') as $module) {    $text = module_invoke($module, 'search_preprocess', $text);  }}/** * Update the full-text search index for a particular item. * * @param $sid *   A number identifying this particular item (e.g. node id). * * @param $type *   A string defining this type of item (e.g. 'node') * * @param $text *   The content of this item. Must be a piece of HTML text. * * @ingroup search */function search_index($sid, $type, $text) {  $minimum_word_size = variable_get('minimum_word_size', 3);  // Link matching  global $base_url;  $node_regexp = '@href=[\'"]?(?:'. preg_quote($base_url, '@') .'/|'. preg_quote(base_path(), '@') .')(?:\?q=)?/?((?![a-z]+:)[^\'">]+)[\'">]@i';  // Multipliers for scores of words inside certain HTML tags.  // Note: 'a' must be included for link ranking to work.  $tags = array('h1' => 25,                'h2' => 18,                'h3' => 15,                'h4' => 12,                'h5' => 9,                'h6' => 6,                'u' => 3,                'b' => 3,                'i' => 3,                'strong' => 3,                'em' => 3,                'a' => 10);  // Strip off all ignored tags to speed up processing, but insert space before/after  // them to keep word boundaries.  $text = str_replace(array('<', '>'), array(' <', '> '), $text);  $text = strip_tags($text, '<'. implode('><', array_keys($tags)) .'>');  // Split HTML tags from plain text.  $split = preg_split('/\s*<([^>]+?)>\s*/', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting $null as required).  $tag = FALSE; // Odd/even counter. Tag or no tag.  $link = FALSE; // State variable for link analyser  $score = 1; // Starting score per word  $accum = ' '; // Accumulator for cleaned up data  $tagstack = array(); // Stack with open tags  $tagwords = 0; // Counter for consecutive words  $focus = 1; // Focus state  $results = array(0 => array()); // Accumulator for words for index  foreach ($split as $value) {    if ($tag) {      // Increase or decrease score per word based on tag      list($tagname) = explode(' ', $value, 2);      $tagname = drupal_strtolower($tagname);      // Closing or opening tag?      if ($tagname[0] == '/') {        $tagname = substr($tagname, 1);        // If we encounter unexpected tags, reset score to avoid incorrect boosting.        if (!count($tagstack) || $tagstack[0] != $tagname) {          $tagstack = array();          $score = 1;        }        else {          // Remove from tag stack and decrement score          $score = max(1, $score - $tags[array_shift($tagstack)]);        }        if ($tagname == 'a') {          $link = FALSE;        }      }      else {        if (isset($tagstack[0]) && $tagstack[0] == $tagname) {          // None of the tags we look for make sense when nested identically.          // If they are, it's probably broken HTML.          $tagstack = array();          $score = 1;        }        else {          // Add to open tag stack and increment score          array_unshift($tagstack, $tagname);          $score += $tags[$tagname];        }        if ($tagname == 'a') {          // Check if link points to a node on this site          if (preg_match($node_regexp, $value, $match)) {            $path = drupal_get_normal_path($match[1]);            if (preg_match('!(?:node|book)/(?:view/)?([0-9]+)!i', $path, $match)) {              $linknid = $match[1];              if ($linknid > 0) {                // Note: ignore links to uncachable nodes to avoid redirect bugs.                $node = db_fetch_object(db_query('SELECT n.title, n.nid, n.vid, r.format FROM {node} n INNER JOIN {node_revisions} r ON n.vid = r.vid WHERE n.nid = %d', $linknid));                if (filter_format_allowcache($node->format)) {                  $link = TRUE;                  $linktitle = $node->title;                }              }            }          }        }      }      // A tag change occurred, reset counter.      $tagwords = 0;    }    else {      // Note: use of PREG_SPLIT_DELIM_CAPTURE above will introduce empty values      if ($value != '') {        if ($link) {          // Check to see if the node link text is its URL. If so, we use the target node title instead.          if (preg_match('!^https?://!i', $value)) {            $value = $linktitle;          }        }        $words = search_index_split($value);        foreach ($words as $word) {          // Add word to accumulator          $accum .= $word .' ';          $num = is_numeric($word);          // Check wordlength          if ($num || drupal_strlen($word) >= $minimum_word_size) {            // Normalize numbers            if ($num) {              $word = (int)ltrim($word, '-0');            }            // Links score mainly for the target.            if ($link) {              if (!isset($results[$linknid])) {                $results[$linknid] = array();              }              $results[$linknid][] = $word;              // Reduce score of the link caption in the source.              $focus *= 0.2;            }            // Fall-through            if (!isset($results[0][$word])) {              $results[0][$word] = 0;            }            $results[0][$word] += $score * $focus;            // Focus is a decaying value in terms of the amount of unique words up to this point.            // From 100 words and more, it decays, to e.g. 0.5 at 500 words and 0.3 at 1000 words.            $focus = min(1, .01 + 3.5 / (2 + count($results[0]) * .015));          }          $tagwords++;          // Too many words inside a single tag probably mean a tag was accidentally left open.          if (count($tagstack) && $tagwords >= 15) {            $tagstack = array();            $score = 1;          }        }      }    }    $tag = !$tag;  }  search_wipe($sid, $type, TRUE);  // Insert cleaned up data into dataset  db_query("INSERT INTO {search_dataset} (sid, type, data, reindex) VALUES (%d, '%s', '%s', %d)", $sid, $type, $accum, 0);  // Insert results into search index  foreach ($results[0] as $word => $score) {    // Try inserting first because this will succeed most times, but because    // the database collates similar words (accented and non-accented), the    // insert can fail, in which case we need to add the word scores together.    @db_query("INSERT INTO {search_index} (word, sid, type, score) VALUES ('%s', %d, '%s', %f)", $word, $sid, $type, $score);    if (!db_affected_rows()) {      db_query("UPDATE {search_index} SET score = score + %f WHERE word = '%s' AND sid = %d AND type = '%s'", $score, $word, $sid, $type);    }    search_dirty($word);  }  unset($results[0]);  // Get all previous links from this item.  $result = db_query("SELECT nid, caption FROM {search_node_links} WHERE sid = %d AND type = '%s'", $sid, $type);  $links = array();  while ($link = db_fetch_object($result)) {    $links[$link->nid] = $link->caption;  }  // Now store links to nodes.  foreach ($results as $nid => $words) {    $caption = implode(' ', $words);    if (isset($links[$nid])) {      if ($links[$nid] != $caption) {        // Update the existing link and mark the node for reindexing.        db_query("UPDATE {search_node_links} SET caption = '%s' WHERE sid = %d AND type = '%s' AND nid = %d", $caption, $sid, $type, $nid);        search_touch_node($nid);      }      // Unset the link to mark it as processed.      unset($links[$nid]);    }    else {      // Insert the existing link and mark the node for reindexing.      db_query("INSERT INTO {search_node_links} (caption, sid, type, nid) VALUES ('%s', %d, '%s', %d)", $caption, $sid, $type, $nid);      search_touch_node($nid);    }  }  // Any left-over links in $links no longer exist. Delete them and mark the nodes for reindexing.  foreach ($links as $nid => $caption) {    db_query("DELETE FROM {search_node_links} WHERE sid = %d AND type = '%s' AND nid = %d", $sid, $type, $nid);    search_touch_node($nid);  }}/** * Change a node's changed timestamp to 'now' to force reindexing. * * @param $nid *   The nid of the node that needs reindexing. */function search_touch_node($nid) {  db_query("UPDATE {search_dataset} SET reindex = %d WHERE sid = %d AND type = 'node'", time(), $nid);}/** * Implementation of hook_nodeapi(). */function search_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {  switch ($op) {    // Transplant links to a node into the target node.    case 'update index':      $result = db_query("SELECT caption FROM {search_node_links} WHERE nid = %d", $node->nid);      $output = array();      while ($link = db_fetch_object($result)) {        $output[] = $link->caption;      }      if (count($output)) {        return '<a>('. implode(', ', $output) .')</a>';      }      break;    // Reindex the node when it is updated.  The node is automatically indexed    // when it is added, simply by being added to the node table.    case 'update':      search_touch_node($node->nid);      break;  }}/** * Implementation of hook_comment(). */function search_comment($a1, $op) {  switch ($op) {    // Reindex the node when comments are added or changed    case 'insert':    case 'update':    case 'delete':    case 'publish':    case 'unpublish':      search_touch_node(is_array($a1) ? $a1['nid'] : $a1->nid);      break;  }}/** * Extract a module-specific search option from a search query. e.g. 'type:book' */function search_query_extract($keys, $option) {  if (preg_match('/(^| )'. $option .':([^ ]*)( |$)/i', $keys, $matches)) {    return $matches[2];  }}/** * Return a query with the given module-specific search option inserted in. * e.g. 'type:book'. */function search_query_insert($keys, $option, $value = '') {  if (search_query_extract($keys, $option)) {    $keys = trim(preg_replace('/(^| )'. $option .':[^ ]*/i', '', $keys));  }  if ($value != '') {    $keys .= ' '. $option .':'. $value;  }  return $keys;}/** * Parse a search query into SQL conditions. * * We build two queries that matches the dataset bodies. @See do_search for * more about these. * * @param $text *   The search keys. * @return *   A list of six elements. *    * A series of statements AND'd together which will be used to provide all *      possible matches. *    * Arguments for this query part. *    * A series of exact word matches OR'd together. *    * Arguments for this query part. *    * A bool indicating whether this is a simple query or not. Negative *      terms, presence of both AND / OR make this FALSE. *    * A bool indicating the presence of a lowercase or. Maybe the user *      wanted to use OR. */function search_parse_query($text) {  $keys = array('positive' => array(), 'negative' => array());  // Tokenize query string  preg_match_all('/ (-?)("[^"]+"|[^" ]+)/i', ' '. $text, $matches, PREG_SET_ORDER);  if (count($matches) < 1) {    return NULL;  }  // Classify tokens  $or = FALSE;  $warning = '';  $simple = TRUE;  foreach ($matches as $match) {    $phrase = FALSE;    // Strip off phrase quotes    if ($match[2]{0} == '"') {      $match[2] = substr($match[2], 1, -1);      $phrase = TRUE;      $simple = FALSE;    }    // Simplify keyword according to indexing rules and external preprocessors    $words = search_simplify($match[2]);    // Re-explode in case simplification added more words, except when matching a phrase    $words = $phrase ? array($words) : preg_split('/ /', $words, -1, PREG_SPLIT_NO_EMPTY);    // Negative matches    if ($match[1] == '-') {      $keys['negative'] = array_merge($keys['negative'], $words);    }    // OR operator: instead of a single keyword, we store an array of all    // OR'd keywords.    elseif ($match[2] == 'OR' && count($keys['positive'])) {      $last = array_pop($keys['positive']);      // Starting a new OR?      if (!is_array($last)) {        $last = array($last);      }      $keys['positive'][] = $last;      $or = TRUE;      continue;    }    // AND operator: implied, so just ignore it    elseif ($match[2] == 'AND' || $match[2] == 'and') {      $warning = $match[2];      continue;    }    // Plain keyword    else {      if ($match[2] == 'or') {        $warning = $match[2];      }      if ($or) {        // Add to last element (which is an array)        $keys['positive'][count($keys['positive']) - 1] = array_merge($keys['positive'][count($keys['positive']) - 1], $words);      }      else {        $keys['positive'] = array_merge($keys['positive'], $words);      }    }    $or = FALSE;  }  // Convert keywords into SQL statements.  $query = array();  $query2 = array();  $arguments = array();  $arguments2 = array();  $matches = 0;  $simple_and = FALSE;  $simple_or = FALSE;  // Positive matches  foreach ($keys['positive'] as $key) {    // Group of ORed terms    if (is_array($key) && count($key)) {      $simple_or = TRUE;      $queryor = array();      $any = FALSE;      foreach ($key as $or) {        list($q, $num_new_scores) = _search_parse_query($or, $arguments2);        $any |= $num_new_scores;        if ($q) {          $queryor[] = $q;          $arguments[] = $or;        }      }      if (count($queryor)) {        $query[] = '('. implode(' OR ', $queryor) .')';        // A group of OR keywords only needs to match once        $matches += ($any > 0);      }    }    // Single ANDed term    else {      $simple_and = TRUE;      list($q, $num_new_scores, $num_valid_words) = _search_parse_query($key, $arguments2);      if ($q) {        $query[] = $q;        $arguments[] = $key;        if (!$num_valid_words) {          $simple = FALSE;        }        // Each AND keyword needs to match at least once        $matches += $num_new_scores;      }    }  }  if ($simple_and && $simple_or) {    $simple = FALSE;  }  // Negative matches  foreach ($keys['negative'] as $key) {    list($q) = _search_parse_query($key, $arguments2, TRUE);    if ($q) {      $query[] = $q;      $arguments[] = $key;      $simple = FALSE;    }  }  $query = implode(' AND ', $query);  // Build word-index conditions for the first pass  $query2 = substr(str_repeat("i.word = '%s' OR ", count($arguments2)), 0, -4);  return array($query, $arguments, $query2, $arguments2, $matches, $simple, $warning);}/** * Helper function for search_parse_query(); */function _search_parse_query(&$word, &$scores, $not = FALSE) {  $num_new_scores = 0;  $num_valid_words = 0;  // Determine the scorewords of this word/phrase  if (!$not) {    $split = explode(' ', $word);    foreach ($split as $s) {      $num = is_numeric($s);      if ($num || drupal_strlen($s) >= variable_get('minimum_word_size', 3)) {        $s = $num ? ((int)ltrim($s, '-0')) : $s;        if (!isset($scores[$s])) {          $scores[$s] = $s;          $num_new_scores++;        }        $num_valid_words++;      }    }  }  // Return matching snippet and number of added words  return array("d.data ". ($not ? 'NOT ' : '') ."LIKE '%% %s %%'", $num_new_scores, $num_valid_words);}/** * Do a query on the full-text search index for a word or words. * * This function is normally only called by each module that support the * indexed search (and thus, implements hook_update_index()). * * Results are retrieved in two logical passes. However, the two passes are * joined together into a single query.  And in the case of most simple * queries the second pass is not even used. * * The first pass selects a set of all possible matches, which has the benefit * of also providing the exact result set for simple "AND" or "OR" searches. * * The second portion of the query further refines this set by verifying * advanced text conditions (such negative or phrase matches) * * @param $keywords *   A search string as entered by the user. * * @param $type *   A string identifying the calling module. * * @param $join1 *   (optional) Inserted into the JOIN part of the first SQL query. *   For example "INNER JOIN {node} n ON n.nid = i.sid". * * @param $where1 *   (optional) Inserted into the WHERE part of the first SQL query. *   For example "(n.status > %d)". * * @param $arguments1 *   (optional) Extra SQL arguments belonging to the first query. * * @param $columns2 *   (optional) Inserted into the SELECT pat of the second query. Must contain *   a column selected as 'score'. *   defaults to 'i.relevance AS score' * * @param $join2 *   (optional) Inserted into the JOIN par of the second SQL query. *   For example "INNER JOIN {node_comment_statistics} n ON n.nid = i.sid" * * @param $arguments2 *   (optional) Extra SQL arguments belonging to the second query parameter. * * @param $sort_parameters *   (optional) SQL arguments for sorting the final results. *              Default: 'ORDER BY score DESC' * * @return *   An array of SIDs for the search results. * * @ingroup search */function do_search($keywords, $type, $join1 = '', $where1 = '1 = 1', $arguments1 = array(), $columns2 = 'i.relevance AS score', $join2 = '', $arguments2 = array(), $sort_parameters = 'ORDER BY score DESC') {  $query = search_parse_query($keywords);  if ($query[2] == '') {    form_set_error('keys', t('You must include at least one positive keyword with @count characters or more.', array('@count' => variable_get('minimum_word_size', 3))));  }  if ($query[6]) {    if ($query[6] == 'or') {      drupal_set_message(t('Search for either of the two terms with uppercase <strong>OR</strong>. For example, <strong>cats OR dogs</strong>.'));    }  }  if ($query === NULL || $query[0] == '' || $query[2] == '') {    return array();  }  // Build query for keyword normalization.  $conditions = "$where1 AND ($query[2]) AND i.type = '%s'";  $arguments1 = array_merge($arguments1, $query[3], array($type));  $join = "INNER JOIN {search_total} t ON i.word = t.word $join1";  if (!$query[5]) {    $conditions .= " AND ($query[0])";    $arguments1 = array_merge($arguments1, $query[1]);    $join .= " INNER JOIN {search_dataset} d ON i.sid = d.sid AND i.type = d.type";  }  // Calculate maximum keyword relevance, to normalize it.  $select = "SELECT SUM(i.score * t.count) AS score FROM {search_index} i $join WHERE $conditions GROUP BY i.type, i.sid HAVING COUNT(*) >= %d ORDER BY score DESC";  $arguments = array_merge($arguments1, array($query[4]));  $normalize = db_result(db_query_range($select, $arguments, 0, 1));  if (!$normalize) {    return array();  }  $columns2 = str_replace('i.relevance', '('. (1.0 / $normalize) .' * SUM(i.score * t.count))', $columns2);  // Build query to retrieve results.  $select = "SELECT i.type, i.sid, $columns2 FROM {search_index} i $join $join2 WHERE $conditions GROUP BY i.type, i.sid HAVING COUNT(*) >= %d";  $count_select =  "SELECT COUNT(*) FROM ($select) n1";  $arguments = array_merge($arguments2, $arguments1, array($query[4]));  // Do actual search query  $result = pager_query("$select $sort_parameters", 10, 0, $count_select, $arguments);  $results = array();  while ($item = db_fetch_object($result)) {    $results[] = $item;  }  return $results;}/** * Helper function for grabbing search keys. */function search_get_keys() {  static $return;  if (!isset($return)) {    // Extract keys as remainder of path    // Note: support old GET format of searches for existing links.    $path = explode('/', $_GET['q'], 3);    $keys = empty($_REQUEST['keys']) ? '' : $_REQUEST['keys'];    $return = count($path) == 3 ? $path[2] : $keys;  }  return $return;}/** * @defgroup search Search interface * @{ * The Drupal search interface manages a global search mechanism. * * Modules may plug into this system to provide searches of different types of * data. Most of the system is handled by search.module, so this must be enabled * for all of the search features to work. * * There are three ways to interact with the search system: * - Specifically for searching nodes, you can implement nodeapi('update index') *   and nodeapi('search result'). However, note that the search system already *   indexes all visible output of a node, i.e. everything displayed normally *   by hook_view() and hook_nodeapi('view'). This is usually sufficient. *   You should only use this mechanism if you want additional, non-visible data *   to be indexed. * - Implement hook_search(). This will create a search tab for your module on *   the /search page with a simple keyword search form. You may optionally *   implement hook_search_item() to customize the display of your results. * - Implement hook_update_index(). This allows your module to use Drupal's *   HTML indexing mechanism for searching full text efficiently. * * If your module needs to provide a more complicated search form, then you need * to implement it yourself without hook_search(). In that case, you should * define it as a local task (tab) under the /search page (e.g. /search/mymodule) * so that users can easily find it. *//** * Render a search form. * * @param $action *   Form action. Defaults to "search". * @param $keys *   The search string entered by the user, containing keywords for the search. * @param $type *   The type of search to render the node for. Must be the name of module *   which implements hook_search(). Defaults to 'node'. * @param $prompt *   A piece of text to put before the form (e.g. "Enter your keywords") * @return *   An HTML string containing the search form. */function search_form(&$form_state, $action = '', $keys = '', $type = NULL, $prompt = NULL) {  // Add CSS  drupal_add_css(drupal_get_path('module', 'search') .'/search.css', 'module', 'all', FALSE);  if (!$action) {    $action = url('search/'. $type);  }  if (is_null($prompt)) {    $prompt = t('Enter your keywords');  }  $form = array(    '#action' => $action,    '#attributes' => array('class' => 'search-form'),  );  $form['module'] = array('#type' => 'value', '#value' => $type);  $form['basic'] = array('#type' => 'item', '#title' => $prompt);  $form['basic']['inline'] = array('#prefix' => '<div class="container-inline">', '#suffix' => '</div>');  $form['basic']['inline']['keys'] = array(    '#type' => 'textfield',    '#title' => '',    '#default_value' => $keys,    '#size' => $prompt ? 40 : 20,    '#maxlength' => 255,  );  // processed_keys is used to coordinate keyword passing between other forms  // that hook into the basic search form.  $form['basic']['inline']['processed_keys'] = array('#type' => 'value', '#value' => array());  $form['basic']['inline']['submit'] = array('#type' => 'submit', '#value' => t('Search'));  return $form;}/** * Form builder; Output a search form for the search block and the theme's search box. * * @ingroup forms * @see search_box_form_submit() * @see theme_search_box_form() */function search_box(&$form_state, $form_id) {  $form[$form_id] = array(    '#title' => t('Search this site'),    '#type' => 'textfield',    '#size' => 15,    '#default_value' => '',    '#attributes' => array('title' => t('Enter the terms you wish to search for.')),  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Search'));  $form['#submit'][] = 'search_box_form_submit';  return $form;}/** * Process a block search form submission. */function search_box_form_submit($form, &$form_state) {  // The search form relies on control of the redirect destination for its  // functionality, so we override any static destination set in the request,  // for example by drupal_access_denied() or drupal_not_found()  // (see http://drupal.org/node/292565).  if (isset($_REQUEST['destination'])) {    unset($_REQUEST['destination']);  }  if (isset($_REQUEST['edit']['destination'])) {    unset($_REQUEST['edit']['destination']);  }  $form_id = $form['form_id']['#value'];  $form_state['redirect'] = 'search/node/'. trim($form_state['values'][$form_id]);}/** * Process variables for search-theme-form.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see search-theme-form.tpl.php */function template_preprocess_search_theme_form(&$variables) {  $variables['search'] = array();  $hidden = array();  // Provide variables named after form keys so themers can print each element independently.  foreach (element_children($variables['form']) as $key) {    $type = $variables['form'][$key]['#type'];    if ($type == 'hidden' || $type == 'token') {      $hidden[] = drupal_render($variables['form'][$key]);    }    else {      $variables['search'][$key] = drupal_render($variables['form'][$key]);    }  }  // Hidden form elements have no value to themers. No need for separation.  $variables['search']['hidden'] = implode($hidden);  // Collect all form elements to make it easier to print the whole form.  $variables['search_form'] = implode($variables['search']);}/** * Process variables for search-block-form.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see search-block-form.tpl.php */function template_preprocess_search_block_form(&$variables) {  $variables['search'] = array();  $hidden = array();  // Provide variables named after form keys so themers can print each element independently.  foreach (element_children($variables['form']) as $key) {    $type = $variables['form'][$key]['#type'];    if ($type == 'hidden' || $type == 'token') {      $hidden[] = drupal_render($variables['form'][$key]);    }    else {      $variables['search'][$key] = drupal_render($variables['form'][$key]);    }  }  // Hidden form elements have no value to themers. No need for separation.  $variables['search']['hidden'] = implode($hidden);  // Collect all form elements to make it easier to print the whole form.  $variables['search_form'] = implode($variables['search']);}/** * Perform a standard search on the given keys, and return the formatted results. */function search_data($keys = NULL, $type = 'node') {  if (isset($keys)) {    if (module_hook($type, 'search')) {      $results = module_invoke($type, 'search', 'search', $keys);      if (isset($results) && is_array($results) && count($results)) {        if (module_hook($type, 'search_page')) {          return module_invoke($type, 'search_page', $results);        }        else {          return theme('search_results', $results, $type);        }      }    }  }}/** * Returns snippets from a piece of text, with certain keywords highlighted. * Used for formatting search results. * * @param $keys *   A string containing a search query. * * @param $text *   The text to extract fragments from. * * @return *   A string containing HTML for the excerpt. */function search_excerpt($keys, $text) {  // We highlight around non-indexable or CJK characters.  $boundary = '(?:(?<=['. PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK .'])|(?=['. PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK .']))';  // Extract positive keywords and phrases  preg_match_all('/ ("([^"]+)"|(?!OR)([^" ]+))/', ' '. $keys, $matches);  $keys = array_merge($matches[2], $matches[3]);  // Prepare text  $text = ' '. strip_tags(str_replace(array('<', '>'), array(' <', '> '), $text)) .' ';  array_walk($keys, '_search_excerpt_replace');  $workkeys = $keys;  // Extract a fragment per keyword for at most 4 keywords.  // First we collect ranges of text around each keyword, starting/ending  // at spaces.  // If the sum of all fragments is too short, we look for second occurrences.  $ranges = array();  $included = array();  $length = 0;  while ($length < 256 && count($workkeys)) {    foreach ($workkeys as $k => $key) {      if (strlen($key) == 0) {        unset($workkeys[$k]);        unset($keys[$k]);        continue;      }      if ($length >= 256) {        break;      }      // Remember occurrence of key so we can skip over it if more occurrences      // are desired.      if (!isset($included[$key])) {        $included[$key] = 0;      }      // Locate a keyword (position $p), then locate a space in front (position      // $q) and behind it (position $s)      if (preg_match('/'. $boundary . $key . $boundary .'/iu', $text, $match, PREG_OFFSET_CAPTURE, $included[$key])) {        $p = $match[0][1];        if (($q = strpos($text, ' ', max(0, $p - 60))) !== FALSE) {          $end = substr($text, $p, 80);          if (($s = strrpos($end, ' ')) !== FALSE) {            $ranges[$q] = $p + $s;            $length += $p + $s - $q;            $included[$key] = $p + 1;          }          else {            unset($workkeys[$k]);          }        }        else {          unset($workkeys[$k]);        }      }      else {        unset($workkeys[$k]);      }    }  }  // If we didn't find anything, return the beginning.  if (count($ranges) == 0) {    return truncate_utf8($text, 256) .' ...';  }  // Sort the text ranges by starting position.  ksort($ranges);  // Now we collapse overlapping text ranges into one. The sorting makes it O(n).  $newranges = array();  foreach ($ranges as $from2 => $to2) {    if (!isset($from1)) {      $from1 = $from2;      $to1 = $to2;      continue;    }    if ($from2 <= $to1) {      $to1 = max($to1, $to2);    }    else {      $newranges[$from1] = $to1;      $from1 = $from2;      $to1 = $to2;    }  }  $newranges[$from1] = $to1;  // Fetch text  $out = array();  foreach ($newranges as $from => $to) {    $out[] = substr($text, $from, $to - $from);  }  $text = (isset($newranges[0]) ? '' : '... ') . implode(' ... ', $out) .' ...';  // Highlight keywords. Must be done at once to prevent conflicts ('strong' and '<strong>').  $text = preg_replace('/'. $boundary .'('. implode('|', $keys) .')'. $boundary .'/iu', '<strong>\0</strong>', $text);  return $text;}/** * @} End of "defgroup search". *//** * Helper function for array_walk in search_except. */function _search_excerpt_replace(&$text) {  $text = preg_quote($text, '/');}function search_forms() {  $forms['search_theme_form']= array(    'callback' => 'search_box',    'callback arguments' => array('search_theme_form'),  );  $forms['search_block_form']= array(    'callback' => 'search_box',    'callback arguments' => array('search_block_form'),  );  return $forms;}
<?php// $Id$/** * @file forum-topic-list.tpl.php * Theme implementation to display a list of forum topics. * * Available variables: * - $header: The table header. This is pre-generated with click-sorting *   information. If you need to change this, @see template_preprocess_forum_topic_list(). * - $pager: The pager to display beneath the table. * - $topics: An array of topics to be displayed. * - $topic_id: Numeric id for the current forum topic. * * Each $topic in $topics contains: * - $topic->icon: The icon to display. * - $topic->moved: A flag to indicate whether the topic has been moved to *   another forum. * - $topic->title: The title of the topic. Safe to output. * - $topic->message: If the topic has been moved, this contains an *   explanation and a link. * - $topic->zebra: 'even' or 'odd' string used for row class. * - $topic->num_comments: The number of replies on this topic. * - $topic->new_replies: A flag to indicate whether there are unread comments. * - $topic->new_url: If there are unread replies, this is a link to them. * - $topic->new_text: Text containing the translated, properly pluralized count. * - $topic->created: An outputtable string represented when the topic was posted. * - $topic->last_reply: An outputtable string representing when the topic was *   last replied to. * - $topic->timestamp: The raw timestamp this topic was posted. * * @see template_preprocess_forum_topic_list() * @see theme_forum_topic_list() */?><table id="forum-topic-<?php print $topic_id; ?>">  <thead>    <tr><?php print $header; ?></tr>  </thead>  <tbody>  <?php foreach ($topics as $topic): ?>    <tr class="<?php print $topic->zebra;?>">      <td class="icon"><?php print $topic->icon; ?></td>      <td class="title"><?php print $topic->title; ?></td>    <?php if ($topic->moved): ?>      <td colspan="3"><?php print $topic->message; ?></td>    <?php else: ?>      <td class="replies">        <?php print $topic->num_comments; ?>        <?php if ($topic->new_replies): ?>          <br />          <a href="<?php print $topic->new_url; ?>"><?php print $topic->new_text; ?></a>        <?php endif; ?>      </td>      <td class="created"><?php print $topic->created; ?></td>      <td class="last-reply"><?php print $topic->last_reply; ?></td>    <?php endif; ?>    </tr>  <?php endforeach; ?>  </tbody></table><?php print $pager; ?>
<?php// $Id$/** * Implementation of hook_install(). */function dblog_install() {  // Create tables.  drupal_install_schema('dblog');}/** * Implementation of hook_uninstall(). */function dblog_uninstall() {  // Remove tables.  drupal_uninstall_schema('dblog');}/** * Implementation of hook_schema(). */function dblog_schema() {  $schema['watchdog'] = array(    'description' => 'Table that contains logs of all system events.',    'fields' => array(      'wid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique watchdog event ID.',      ),      'uid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {users}.uid of the user who triggered the event.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => TRUE,        'default' => '',        'description' => 'Type of log message, for example "user" or "page not found."',      ),      'message' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Text of log message to be passed into the t() function.',      ),      'variables' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Serialized array of variables that match the message string and that is passed into the t() function.',      ),      'severity' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The severity level of the event; ranges from 0 (Emergency) to 7 (Debug)',      ),      'link' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Link to view the result of the event.',      ),      'location'  => array(        'type' => 'text',        'not null' => TRUE,        'description' => 'URL of the origin of the event.',      ),      'referer' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'URL of referring page.',      ),      'hostname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Hostname of the user who triggered the event.',      ),      'timestamp' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Unix timestamp of when event occurred.',      ),    ),    'primary key' => array('wid'),    'indexes' => array('type' => array('type')),  );  return $schema;}/** * @defgroup updates-6.x-extra Extra database logging updates for 6.x * @{ *//** * Allow longer referrers. */function dblog_update_6000() {  $ret = array();  db_change_field($ret, 'watchdog', 'referer', 'referer', array('type' => 'text', 'not null' => FALSE));  return $ret;}/** * @} End of "defgroup updates-6.x-extra" * The next series of updates should start at 7000. */
<?php// $Id$/** * @file * User page callbacks for the contact module. *//** * Site-wide contact page. */function contact_site_page() {  global $user;  if (!flood_is_allowed('contact', variable_get('contact_hourly_threshold', 3))) {    $output = t("You cannot send more than %number messages per hour. Please try again later.", array('%number' => variable_get('contact_hourly_threshold', 3)));  }  else {    $output = drupal_get_form('contact_mail_page');  }  return $output;}function contact_mail_page() {  global $user;  $form = $categories = array();  $result = db_query('SELECT cid, category, selected FROM {contact} ORDER BY weight, category');  while ($category = db_fetch_object($result)) {    $categories[$category->cid] = $category->category;    if ($category->selected) {      $default_category = $category->cid;    }  }  if (count($categories) > 0) {    $form['#token'] = $user->uid ? $user->name . $user->mail : '';    $form['contact_information'] = array('#value' => filter_xss_admin(variable_get('contact_form_information', t('You can leave a message using the contact form below.'))));    $form['name'] = array('#type' => 'textfield',      '#title' => t('Your name'),      '#maxlength' => 255,      '#default_value' => $user->uid ? $user->name : '',      '#required' => TRUE,    );    $form['mail'] = array('#type' => 'textfield',      '#title' => t('Your e-mail address'),      '#maxlength' => 255,      '#default_value' => $user->uid ? $user->mail : '',      '#required' => TRUE,    );    $form['subject'] = array('#type' => 'textfield',      '#title' => t('Subject'),      '#maxlength' => 255,      '#required' => TRUE,    );    if (count($categories) > 1) {      // If there is more than one category available and no default category has been selected,      // prepend a default placeholder value.      if (!isset($default_category)) {        $default_category = t('- Please choose -');        $categories = array($default_category) + $categories;      }      $form['cid'] = array('#type' => 'select',        '#title' => t('Category'),        '#default_value' => $default_category,        '#options' => $categories,        '#required' => TRUE,      );    }    else {      // If there is only one category, store its cid.      $category_keys = array_keys($categories);      $form['cid'] = array('#type' => 'value',        '#value' => array_shift($category_keys),      );    }    $form['message'] = array('#type' => 'textarea',      '#title' => t('Message'),      '#required' => TRUE,    );    // We do not allow anonymous users to send themselves a copy    // because it can be abused to spam people.    if ($user->uid) {      $form['copy'] = array('#type' => 'checkbox',        '#title' => t('Send yourself a copy.'),      );    }    else {      $form['copy'] = array('#type' => 'value', '#value' => FALSE);    }    $form['submit'] = array('#type' => 'submit',      '#value' => t('Send e-mail'),    );  }  else {    drupal_set_message(t('The contact form has not been configured. <a href="@add">Add one or more categories</a> to the form.', array('@add' => url('admin/build/contact/add'))), 'error');  }  return $form;}/** * Validate the site-wide contact page form submission. */function contact_mail_page_validate($form, &$form_state) {  if (!$form_state['values']['cid']) {    form_set_error('cid', t('You must select a valid category.'));  }  if (!valid_email_address($form_state['values']['mail'])) {    form_set_error('mail', t('You must enter a valid e-mail address.'));  }}/** * Process the site-wide contact page form submission. */function contact_mail_page_submit($form, &$form_state) {  global $language;  $values = $form_state['values'];  // E-mail address of the sender: as the form field is a text field,  // all instances of \r and \n have been automatically stripped from it.  $from = $values['mail'];  // Load category properties and save form values for email composition.  $contact = contact_load($values['cid']);  $values['contact'] = $contact;  // Send the e-mail to the recipients using the site default language.  drupal_mail('contact', 'page_mail', $contact['recipients'], language_default(), $values, $from);  // If the user requests it, send a copy using the current language.  if ($values['copy']) {    drupal_mail('contact', 'page_copy', $from, $language, $values, $from);  }  // Send an auto-reply if necessary using the current language.  if ($contact['reply']) {    drupal_mail('contact', 'page_autoreply', $from, $language, $values, $contact['recipients']);  }  flood_register_event('contact');  watchdog('mail', '%name-from sent an e-mail regarding %category.', array('%name-from' => $values['name'] ." [$from]", '%category' => $contact['category']));  drupal_set_message(t('Your message has been sent.'));  // Jump to home page rather than back to contact page to avoid  // contradictory messages if flood control has been activated.  $form_state['redirect'] = '';}/** * Personal contact page. */function contact_user_page($account) {  global $user;  if (!valid_email_address($user->mail)) {    $output = t('You need to provide a valid e-mail address to contact other users. Please update your <a href="@url">user information</a> and try again.', array('@url' => url("user/$user->uid/edit")));  }  else if (!flood_is_allowed('contact', variable_get('contact_hourly_threshold', 3))) {    $output = t('You cannot contact more than %number users per hour. Please try again later.', array('%number' => variable_get('contact_hourly_threshold', 3)));  }  else {    drupal_set_title(check_plain($account->name));    $output = drupal_get_form('contact_mail_user', $account);  }  return $output;}function contact_mail_user(&$form_state, $recipient) {  global $user;  $form['#token'] = $user->name . $user->mail;  $form['recipient'] = array('#type' => 'value', '#value' => $recipient);  $form['from'] = array('#type' => 'item',    '#title' => t('From'),    '#value' => theme('username', $user) .' &lt;'. check_plain($user->mail) .'&gt;',  );  $form['to'] = array('#type' => 'item',    '#title' => t('To'),    '#value' => theme('username', $recipient),  );  $form['subject'] = array('#type' => 'textfield',    '#title' => t('Subject'),    '#maxlength' => 50,    '#required' => TRUE,  );  $form['message'] = array('#type' => 'textarea',    '#title' => t('Message'),    '#rows' => 15,    '#required' => TRUE,  );  $form['copy'] = array('#type' => 'checkbox',    '#title' => t('Send yourself a copy.'),  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Send e-mail'),  );  return $form;}/** * Process the personal contact page form submission. */function contact_mail_user_submit($form, &$form_state) {  global $user, $language;  $account = $form_state['values']['recipient'];  // Send from the current user to the requested user.  $to = $account->mail;  $from = $user->mail;  // Save both users and all form values for email composition.  $values = $form_state['values'];  $values['account'] = $account;  $values['user'] = $user;  // Send the e-mail in the requested user language.  drupal_mail('contact', 'user_mail', $to, user_preferred_language($account), $values, $from);  // Send a copy if requested, using current page language.  if ($form_state['values']['copy']) {    drupal_mail('contact', 'user_copy', $from, $language, $values, $from);  }  flood_register_event('contact');  watchdog('mail', '%name-from sent %name-to an e-mail.', array('%name-from' => $user->name, '%name-to' => $account->name));  drupal_set_message(t('The message has been sent.'));  // Back to the requested users profile page.  $form_state['redirect'] = "user/$account->uid";}
<?php// $Id$/** * @file * Common functions that many Drupal modules will need to reference. * * The functions that are critical and need to be available even when serving * a cached page are instead located in bootstrap.inc. *//** * Return status for saving which involved creating a new item. */define('SAVED_NEW', 1);/** * Return status for saving which involved an update to an existing item. */define('SAVED_UPDATED', 2);/** * Return status for saving which deleted an existing item. */define('SAVED_DELETED', 3);/** * Create E_DEPRECATED constant for older PHP versions (<5.3). */if (!defined('E_DEPRECATED')) {  define('E_DEPRECATED', 8192);}/** * Set content for a specified region. * * @param $region *   Page region the content is assigned to. * @param $data *   Content to be set. */function drupal_set_content($region = NULL, $data = NULL) {  static $content = array();  if (!is_null($region) && !is_null($data)) {    $content[$region][] = $data;  }  return $content;}/** * Get assigned content. * * @param $region *   A specified region to fetch content for. If NULL, all regions will be *   returned. * @param $delimiter *   Content to be inserted between imploded array elements. */function drupal_get_content($region = NULL, $delimiter = ' ') {  $content = drupal_set_content();  if (isset($region)) {    if (isset($content[$region]) && is_array($content[$region])) {      return implode($delimiter, $content[$region]);    }  }  else {    foreach (array_keys($content) as $region) {      if (is_array($content[$region])) {        $content[$region] = implode($delimiter, $content[$region]);      }    }    return $content;  }}/** * Set the breadcrumb trail for the current page. * * @param $breadcrumb *   Array of links, starting with "home" and proceeding up to but not including *   the current page. */function drupal_set_breadcrumb($breadcrumb = NULL) {  static $stored_breadcrumb;  if (!is_null($breadcrumb)) {    $stored_breadcrumb = $breadcrumb;  }  return $stored_breadcrumb;}/** * Get the breadcrumb trail for the current page. */function drupal_get_breadcrumb() {  $breadcrumb = drupal_set_breadcrumb();  if (is_null($breadcrumb)) {    $breadcrumb = menu_get_active_breadcrumb();  }  return $breadcrumb;}/** * Add output to the head tag of the HTML page. * * This function can be called as long the headers aren't sent. */function drupal_set_html_head($data = NULL) {  static $stored_head = '';  if (!is_null($data)) {    $stored_head .= $data ."\n";  }  return $stored_head;}/** * Retrieve output to be displayed in the head tag of the HTML page. */function drupal_get_html_head() {  $output = "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n";  return $output . drupal_set_html_head();}/** * Reset the static variable which holds the aliases mapped for this request. */function drupal_clear_path_cache() {  drupal_lookup_path('wipe');}/** * Set an HTTP response header for the current page. * * Note: When sending a Content-Type header, always include a 'charset' type, * too. This is necessary to avoid security bugs (e.g. UTF-7 XSS). */function drupal_set_header($header = NULL) {  // We use an array to guarantee there are no leading or trailing delimiters.  // Otherwise, header('') could get called when serving the page later, which  // ends HTTP headers prematurely on some PHP versions.  static $stored_headers = array();  if (strlen($header)) {    header($header);    $stored_headers[] = $header;  }  return implode("\n", $stored_headers);}/** * Get the HTTP response headers for the current page. */function drupal_get_headers() {  return drupal_set_header();}/** * Make any final alterations to the rendered xhtml. */function drupal_final_markup($content) {  // Make sure that the charset is always specified as the first element of the  // head region to prevent encoding-based attacks.  return preg_replace('/<head[^>]*>/i', "\$0\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />", $content, 1);}/** * Add a feed URL for the current page. * * @param $url *   A url for the feed. * @param $title *   The title of the feed. */function drupal_add_feed($url = NULL, $title = '') {  static $stored_feed_links = array();  if (!is_null($url) && !isset($stored_feed_links[$url])) {    $stored_feed_links[$url] = theme('feed_icon', $url, $title);    drupal_add_link(array('rel' => 'alternate',                          'type' => 'application/rss+xml',                          'title' => $title,                          'href' => $url));  }  return $stored_feed_links;}/** * Get the feed URLs for the current page. * * @param $delimiter *   A delimiter to split feeds by. */function drupal_get_feeds($delimiter = "\n") {  $feeds = drupal_add_feed();  return implode($feeds, $delimiter);}/** * @name HTTP handling * @{ * Functions to properly handle HTTP responses. *//** * Parse an array into a valid urlencoded query string. * * @param $query *   The array to be processed e.g. $_GET. * @param $exclude *   The array filled with keys to be excluded. Use parent[child] to exclude *   nested items. * @param $parent *   Should not be passed, only used in recursive calls. * @return *   An urlencoded string which can be appended to/as the URL query string. */function drupal_query_string_encode($query, $exclude = array(), $parent = '') {  $params = array();  foreach ($query as $key => $value) {    $key = rawurlencode($key);    if ($parent) {      $key = $parent .'['. $key .']';    }    if (in_array($key, $exclude)) {      continue;    }    if (is_array($value)) {      $params[] = drupal_query_string_encode($value, $exclude, $key);    }    else {      $params[] = $key .'='. rawurlencode($value);    }  }  return implode('&', $params);}/** * Prepare a destination query string for use in combination with drupal_goto(). * * Used to direct the user back to the referring page after completing a form. * By default the current URL is returned. If a destination exists in the * previous request, that destination is returned. As such, a destination can * persist across multiple pages. * * @see drupal_goto() */function drupal_get_destination() {  if (isset($_REQUEST['destination'])) {    return 'destination='. urlencode($_REQUEST['destination']);  }  else {    // Use $_GET here to retrieve the original path in source form.    $path = isset($_GET['q']) ? $_GET['q'] : '';    $query = drupal_query_string_encode($_GET, array('q'));    if ($query != '') {      $path .= '?'. $query;    }    return 'destination='. urlencode($path);  }}/** * Send the user to a different Drupal page. * * This issues an on-site HTTP redirect. The function makes sure the redirected * URL is formatted correctly. * * Usually the redirected URL is constructed from this function's input * parameters. However you may override that behavior by setting a * destination in either the $_REQUEST-array (i.e. by using * the query string of an URI) or the $_REQUEST['edit']-array (i.e. by * using a hidden form field). This is used to direct the user back to * the proper page after completing a form. For example, after editing * a post on the 'admin/content/node'-page or after having logged on using the * 'user login'-block in a sidebar. The function drupal_get_destination() * can be used to help set the destination URL. * * Drupal will ensure that messages set by drupal_set_message() and other * session data are written to the database before the user is redirected. * * This function ends the request; use it rather than a print theme('page') * statement in your menu callback. * * @param $path *   A Drupal path or a full URL. * @param $query *   A query string component, if any. * @param $fragment *   A destination fragment identifier (named anchor). * @param $http_response_code *   Valid values for an actual "goto" as per RFC 2616 section 10.3 are: *   - 301 Moved Permanently (the recommended value for most redirects) *   - 302 Found (default in Drupal and PHP, sometimes used for spamming search *         engines) *   - 303 See Other *   - 304 Not Modified *   - 305 Use Proxy *   - 307 Temporary Redirect (alternative to "503 Site Down for Maintenance") *   Note: Other values are defined by RFC 2616, but are rarely used and poorly *   supported. * @see drupal_get_destination() */function drupal_goto($path = '', $query = NULL, $fragment = NULL, $http_response_code = 302) {  $destination = FALSE;  if (isset($_REQUEST['destination'])) {    $destination = $_REQUEST['destination'];  }  else if (isset($_REQUEST['edit']['destination'])) {    $destination = $_REQUEST['edit']['destination'];  }  if ($destination) {    // Do not redirect to an absolute URL originating from user input.    $colonpos = strpos($destination, ':');    $absolute = ($colonpos !== FALSE && !preg_match('![/?#]!', substr($destination, 0, $colonpos)));    if (!$absolute) {      extract(parse_url(urldecode($destination)));    }  }  $url = url($path, array('query' => $query, 'fragment' => $fragment, 'absolute' => TRUE));  // Remove newlines from the URL to avoid header injection attacks.  $url = str_replace(array("\n", "\r"), '', $url);  // Allow modules to react to the end of the page request before redirecting.  // We do not want this while running update.php.  if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {    module_invoke_all('exit', $url);  }  // Even though session_write_close() is registered as a shutdown function, we  // need all session data written to the database before redirecting.  session_write_close();  header('Location: '. $url, TRUE, $http_response_code);  // The "Location" header sends a redirect status code to the HTTP daemon. In  // some cases this can be wrong, so we make sure none of the code below the  // drupal_goto() call gets executed upon redirection.  exit();}/** * Generates a site off-line message. */function drupal_site_offline() {  drupal_maintenance_theme();  drupal_set_header('HTTP/1.1 503 Service unavailable');  drupal_set_title(t('Site off-line'));  print theme('maintenance_page', filter_xss_admin(variable_get('site_offline_message',    t('@site is currently under maintenance. We should be back shortly. Thank you for your patience.', array('@site' => variable_get('site_name', 'Drupal'))))));}/** * Generates a 404 error if the request can not be handled. */function drupal_not_found() {  drupal_set_header('HTTP/1.1 404 Not Found');  watchdog('page not found', check_plain($_GET['q']), NULL, WATCHDOG_WARNING);  // Keep old path for reference, and to allow forms to redirect to it.  if (!isset($_REQUEST['destination'])) {    $_REQUEST['destination'] = $_GET['q'];  }  $path = drupal_get_normal_path(variable_get('site_404', ''));  if ($path && $path != $_GET['q']) {    // Set the active item in case there are tabs to display, or other    // dependencies on the path.    menu_set_active_item($path);    $return = menu_execute_active_handler($path);  }  if (empty($return) || $return == MENU_NOT_FOUND || $return == MENU_ACCESS_DENIED) {    drupal_set_title(t('Page not found'));    $return = t('The requested page could not be found.');  }  // To conserve CPU and bandwidth, omit the blocks.  print theme('page', $return, FALSE);}/** * Generates a 403 error if the request is not allowed. */function drupal_access_denied() {  drupal_set_header('HTTP/1.1 403 Forbidden');  watchdog('access denied', check_plain($_GET['q']), NULL, WATCHDOG_WARNING);  // Keep old path for reference, and to allow forms to redirect to it.  if (!isset($_REQUEST['destination'])) {    $_REQUEST['destination'] = $_GET['q'];  }  $path = drupal_get_normal_path(variable_get('site_403', ''));  if ($path && $path != $_GET['q']) {    // Set the active item in case there are tabs to display or other    // dependencies on the path.    menu_set_active_item($path);    $return = menu_execute_active_handler($path);  }  if (empty($return) || $return == MENU_NOT_FOUND || $return == MENU_ACCESS_DENIED) {    drupal_set_title(t('Access denied'));    $return = t('You are not authorized to access this page.');  }  print theme('page', $return);}/** * Perform an HTTP request. * * This is a flexible and powerful HTTP client implementation. Correctly handles * GET, POST, PUT or any other HTTP requests. Handles redirects. * * @param $url *   A string containing a fully qualified URI. * @param $headers *   An array containing an HTTP header => value pair. * @param $method *   A string defining the HTTP request to use. * @param $data *   A string containing data to include in the request. * @param $retry *   An integer representing how many times to retry the request in case of a *   redirect. * @return *   An object containing the HTTP request headers, response code, headers, *   data and redirect status. */function drupal_http_request($url, $headers = array(), $method = 'GET', $data = NULL, $retry = 3) {  global $db_prefix;  $result = new stdClass();  // Parse the URL and make sure we can handle the schema.  $uri = parse_url($url);  if ($uri == FALSE) {    $result->error = 'unable to parse URL';    $result->code = -1001;    return $result;  }  if (!isset($uri['scheme'])) {    $result->error = 'missing schema';    $result->code = -1002;    return $result;  }  switch ($uri['scheme']) {    case 'http':      $port = isset($uri['port']) ? $uri['port'] : 80;      $host = $uri['host'] . ($port != 80 ? ':'. $port : '');      $fp = @fsockopen($uri['host'], $port, $errno, $errstr, 15);      break;    case 'https':      // Note: Only works for PHP 4.3 compiled with OpenSSL.      $port = isset($uri['port']) ? $uri['port'] : 443;      $host = $uri['host'] . ($port != 443 ? ':'. $port : '');      $fp = @fsockopen('ssl://'. $uri['host'], $port, $errno, $errstr, 20);      break;    default:      $result->error = 'invalid schema '. $uri['scheme'];      $result->code = -1003;      return $result;  }  // Make sure the socket opened properly.  if (!$fp) {    // When a network error occurs, we use a negative number so it does not    // clash with the HTTP status codes.    $result->code = -$errno;    $result->error = trim($errstr);    // Mark that this request failed. This will trigger a check of the web    // server's ability to make outgoing HTTP requests the next time that    // requirements checking is performed.    // @see system_requirements()    variable_set('drupal_http_request_fails', TRUE);    return $result;  }  // Construct the path to act on.  $path = isset($uri['path']) ? $uri['path'] : '/';  if (isset($uri['query'])) {    $path .= '?'. $uri['query'];  }  // Create HTTP request.  $defaults = array(    // RFC 2616: "non-standard ports MUST, default ports MAY be included".    // We don't add the port to prevent from breaking rewrite rules checking the    // host that do not take into account the port number.    'Host' => "Host: $host",    'User-Agent' => 'User-Agent: Drupal (+http://drupal.org/)',  );  // Only add Content-Length if we actually have any content or if it is a POST  // or PUT request. Some non-standard servers get confused by Content-Length in  // at least HEAD/GET requests, and Squid always requires Content-Length in  // POST/PUT requests.  $content_length = strlen($data);  if ($content_length > 0 || $method == 'POST' || $method == 'PUT') {    $defaults['Content-Length'] = 'Content-Length: '. $content_length;  }  // If the server url has a user then attempt to use basic authentication  if (isset($uri['user'])) {    $defaults['Authorization'] = 'Authorization: Basic '. base64_encode($uri['user'] . (!empty($uri['pass']) ? ":". $uri['pass'] : ''));  }  // If the database prefix is being used by SimpleTest to run the tests in a copied  // database then set the user-agent header to the database prefix so that any  // calls to other Drupal pages will run the SimpleTest prefixed database. The  // user-agent is used to ensure that multiple testing sessions running at the  // same time won't interfere with each other as they would if the database  // prefix were stored statically in a file or database variable.  if (is_string($db_prefix) && preg_match("/^simpletest\d+$/", $db_prefix, $matches)) {    $defaults['User-Agent'] = 'User-Agent: ' . $matches[0];  }  foreach ($headers as $header => $value) {    $defaults[$header] = $header .': '. $value;  }  $request = $method .' '. $path ." HTTP/1.0\r\n";  $request .= implode("\r\n", $defaults);  $request .= "\r\n\r\n";  $request .= $data;  $result->request = $request;  fwrite($fp, $request);  // Fetch response.  $response = '';  while (!feof($fp) && $chunk = fread($fp, 1024)) {    $response .= $chunk;  }  fclose($fp);  // Parse response.  list($split, $result->data) = explode("\r\n\r\n", $response, 2);  $split = preg_split("/\r\n|\n|\r/", $split);  list($protocol, $code, $text) = explode(' ', trim(array_shift($split)), 3);  $result->headers = array();  // Parse headers.  while ($line = trim(array_shift($split))) {    list($header, $value) = explode(':', $line, 2);    if (isset($result->headers[$header]) && $header == 'Set-Cookie') {      // RFC 2109: the Set-Cookie response header comprises the token Set-      // Cookie:, followed by a comma-separated list of one or more cookies.      $result->headers[$header] .= ','. trim($value);    }    else {      $result->headers[$header] = trim($value);    }  }  $responses = array(    100 => 'Continue', 101 => 'Switching Protocols',    200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content',    300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 307 => 'Temporary Redirect',    400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Time-out', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Large', 415 => 'Unsupported Media Type', 416 => 'Requested range not satisfiable', 417 => 'Expectation Failed',    500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Time-out', 505 => 'HTTP Version not supported'  );  // RFC 2616 states that all unknown HTTP codes must be treated the same as the  // base code in their class.  if (!isset($responses[$code])) {    $code = floor($code / 100) * 100;  }  switch ($code) {    case 200: // OK    case 304: // Not modified      break;    case 301: // Moved permanently    case 302: // Moved temporarily    case 307: // Moved temporarily      $location = $result->headers['Location'];      if ($retry) {        $result = drupal_http_request($result->headers['Location'], $headers, $method, $data, --$retry);        $result->redirect_code = $result->code;      }      $result->redirect_url = $location;      break;    default:      $result->error = $text;  }  $result->code = $code;  return $result;}/** * @} End of "HTTP handling". *//** * Log errors as defined by administrator. * * Error levels: * - 0 = Log errors to database. * - 1 = Log errors to database and to screen. */function drupal_error_handler($errno, $message, $filename, $line, $context) {  // If the @ error suppression operator was used, error_reporting will have  // been temporarily set to 0.  if (error_reporting() == 0) {    return;  }  if ($errno & (E_ALL ^ E_DEPRECATED ^ E_NOTICE)) {    $types = array(1 => 'error', 2 => 'warning', 4 => 'parse error', 8 => 'notice', 16 => 'core error', 32 => 'core warning', 64 => 'compile error', 128 => 'compile warning', 256 => 'user error', 512 => 'user warning', 1024 => 'user notice', 2048 => 'strict warning', 4096 => 'recoverable fatal error');    // For database errors, we want the line number/file name of the place that    // the query was originally called, not _db_query().    if (isset($context[DB_ERROR])) {      $backtrace = array_reverse(debug_backtrace());      // List of functions where SQL queries can originate.      $query_functions = array('db_query', 'pager_query', 'db_query_range', 'db_query_temporary', 'update_sql');      // Determine where query function was called, and adjust line/file      // accordingly.      foreach ($backtrace as $index => $function) {        if (in_array($function['function'], $query_functions)) {          $line = $backtrace[$index]['line'];          $filename = $backtrace[$index]['file'];          break;        }      }    }    $entry = $types[$errno] .': '. $message .' in '. $filename .' on line '. $line .'.';    // Force display of error messages in update.php.    if (variable_get('error_level', 1) == 1 || strstr($_SERVER['SCRIPT_NAME'], 'update.php')) {      drupal_set_message($entry, 'error');    }    watchdog('php', '%message in %file on line %line.', array('%error' => $types[$errno], '%message' => $message, '%file' => $filename, '%line' => $line), WATCHDOG_ERROR);  }}function _fix_gpc_magic(&$item) {  if (is_array($item)) {    array_walk($item, '_fix_gpc_magic');  }  else {    $item = stripslashes($item);  }}/** * Helper function to strip slashes from $_FILES skipping over the tmp_name keys * since PHP generates single backslashes for file paths on Windows systems. * * tmp_name does not have backslashes added see * http://php.net/manual/en/features.file-upload.php#42280 */function _fix_gpc_magic_files(&$item, $key) {  if ($key != 'tmp_name') {    if (is_array($item)) {      array_walk($item, '_fix_gpc_magic_files');    }    else {      $item = stripslashes($item);    }  }}/** * Fix double-escaping problems caused by "magic quotes" in some PHP installations. */function fix_gpc_magic() {  static $fixed = FALSE;  if (!$fixed && ini_get('magic_quotes_gpc')) {    array_walk($_GET, '_fix_gpc_magic');    array_walk($_POST, '_fix_gpc_magic');    array_walk($_COOKIE, '_fix_gpc_magic');    array_walk($_REQUEST, '_fix_gpc_magic');    array_walk($_FILES, '_fix_gpc_magic_files');    $fixed = TRUE;  }}/** * Translate strings to the page language or a given language. * * Human-readable text that will be displayed somewhere within a page should * be run through the t() function. * * Examples: * @code *   if (!$info || !$info['extension']) { *     form_set_error('picture_upload', t('The uploaded file was not an image.')); *   } * *   $form['submit'] = array( *     '#type' => 'submit', *     '#value' => t('Log in'), *   ); * @endcode * * Any text within t() can be extracted by translators and changed into * the equivalent text in their native language. * * Special variables called "placeholders" are used to signal dynamic * information in a string which should not be translated. Placeholders * can also be used for text that may change from time to time (such as * link paths) to be changed without requiring updates to translations. * * For example: * @code *   $output = t('There are currently %members and %visitors online.', array( *     '%members' => format_plural($total_users, '1 user', '@count users'), *     '%visitors' => format_plural($guests->count, '1 guest', '@count guests'))); * @endcode * * There are three styles of placeholders: * - !variable, which indicates that the text should be inserted as-is. This is *   useful for inserting variables into things like e-mail. *   @code *     $message[] = t("If you don't want to receive such e-mails, you can change your settings at !url.", array('!url' => url("user/$account->uid", array('absolute' => TRUE)))); *   @endcode * * - @variable, which indicates that the text should be run through *   check_plain, to escape HTML characters. Use this for any output that's *   displayed within a Drupal page. *   @code *     drupal_set_title($title = t("@name's blog", array('@name' => $account->name))); *   @endcode * * - %variable, which indicates that the string should be HTML escaped and *   highlighted with theme_placeholder() which shows up by default as *   <em>emphasized</em>. *   @code *     $message = t('%name-from sent %name-to an e-mail.', array('%name-from' => $user->name, '%name-to' => $account->name)); *   @endcode * * When using t(), try to put entire sentences and strings in one t() call. * This makes it easier for translators, as it provides context as to what * each word refers to. HTML markup within translation strings is allowed, but * should be avoided if possible. The exception are embedded links; link * titles add a context for translators, so should be kept in the main string. * * Here is an example of incorrect usage of t(): * @code *   $output .= t('<p>Go to the @contact-page.</p>', array('@contact-page' => l(t('contact page'), 'contact'))); * @endcode * * Here is an example of t() used correctly: * @code *   $output .= '<p>'. t('Go to the <a href="@contact-page">contact page</a>.', array('@contact-page' => url('contact'))) .'</p>'; * @endcode * * Avoid escaping quotation marks wherever possible. * * Incorrect: * @code *   $output .= t('Don\'t click me.'); * @endcode * * Correct: * @code *   $output .= t("Don't click me."); * @endcode * * Because t() is designed for handling code-based strings, in almost all * cases, the actual string and not a variable must be passed through t(). * * Extraction of translations is done based on the strings contained in t() * calls. If a variable is passed through t(), the content of the variable * cannot be extracted from the file for translation. * * Incorrect: * @code *   $message = 'An error occurred.'; *   drupal_set_message(t($message), 'error'); *   $output .= t($message); * @endcode * * Correct: * @code *   $message = t('An error occurred.'); *   drupal_set_message($message, 'error'); *   $output .= $message; * @endcode * * The only case in which variables can be passed safely through t() is when * code-based versions of the same strings will be passed through t() (or * otherwise extracted) elsewhere. * * In some cases, modules may include strings in code that can't use t() * calls. For example, a module may use an external PHP application that * produces strings that are loaded into variables in Drupal for output. * In these cases, module authors may include a dummy file that passes the * relevant strings through t(). This approach will allow the strings to be * extracted. * * Sample external (non-Drupal) code: * @code *   class Time { *     public $yesterday = 'Yesterday'; *     public $today = 'Today'; *     public $tomorrow = 'Tomorrow'; *   } * @endcode * * Sample dummy file. * @code *   // Dummy function included in example.potx.inc. *   function example_potx() { *     $strings = array( *       t('Yesterday'), *       t('Today'), *       t('Tomorrow'), *     ); *     // No return value needed, since this is a dummy function. *   } * @endcode * * Having passed strings through t() in a dummy function, it is then * okay to pass variables through t(). * * Correct (if a dummy file was used): * @code *   $time = new Time(); *   $output .= t($time->today); * @endcode * * However tempting it is, custom data from user input or other non-code * sources should not be passed through t(). Doing so leads to the following * problems and errors: *  - The t() system doesn't support updates to existing strings. When user *    data is updated, the next time it's passed through t() a new record is *    created instead of an update. The database bloats over time and any *    existing translations are orphaned with each update. *  - The t() system assumes any data it receives is in English. User data may *    be in another language, producing translation errors. *  - The "Built-in interface" text group in the locale system is used to *    produce translations for storage in .po files. When non-code strings are *    passed through t(), they are added to this text group, which is rendered *    inaccurate since it is a mix of actual interface strings and various user *    input strings of uncertain origin. * * Incorrect: * @code *   $item = item_load(); *   $output .= check_plain(t($item['title'])); * @endcode * * Instead, translation of these data can be done through the locale system, * either directly or through helper functions provided by contributed * modules. * @see hook_locale() * * During installation, st() is used in place of t(). Code that may be called * during installation or during normal operation should use the get_t() * helper function. * @see st() * @see get_t() * * @param $string *   A string containing the English string to translate. * @param $args *   An associative array of replacements to make after translation. Incidences *   of any key in this array are replaced with the corresponding value. Based *   on the first character of the key, the value is escaped and/or themed: *    - !variable: inserted as is *    - @variable: escape plain text to HTML (check_plain) *    - %variable: escape text and theme as a placeholder for user-submitted *      content (check_plain + theme_placeholder) * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   The translated string. */function t($string, $args = array(), $langcode = NULL) {  global $language;  static $custom_strings;  $langcode = isset($langcode) ? $langcode : $language->language;  // First, check for an array of customized strings. If present, use the array  // *instead of* database lookups. This is a high performance way to provide a  // handful of string replacements. See settings.php for examples.  // Cache the $custom_strings variable to improve performance.  if (!isset($custom_strings[$langcode])) {    $custom_strings[$langcode] = variable_get('locale_custom_strings_'. $langcode, array());  }  // Custom strings work for English too, even if locale module is disabled.  if (isset($custom_strings[$langcode][$string])) {    $string = $custom_strings[$langcode][$string];  }  // Translate with locale module if enabled.  elseif (function_exists('locale') && $langcode != 'en') {    $string = locale($string, $langcode);  }  if (empty($args)) {    return $string;  }  else {    // Transform arguments before inserting them.    foreach ($args as $key => $value) {      switch ($key[0]) {        case '@':          // Escaped only.          $args[$key] = check_plain($value);          break;        case '%':        default:          // Escaped and placeholder.          $args[$key] = theme('placeholder', $value);          break;        case '!':          // Pass-through.      }    }    return strtr($string, $args);  }}/** * @defgroup validation Input validation * @{ * Functions to validate user input. *//** * Verify the syntax of the given e-mail address. * * Empty e-mail addresses are allowed. See RFC 2822 for details. * * @param $mail *   A string containing an e-mail address. * @return *   TRUE if the address is in a valid format. */function valid_email_address($mail) {  $user = '[a-zA-Z0-9_\-\.\+\^!#\$%&*+\/\=\?\`\|\{\}~\']+';  $domain = '(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.?)+';  $ipv4 = '[0-9]{1,3}(\.[0-9]{1,3}){3}';  $ipv6 = '[0-9a-fA-F]{1,4}(\:[0-9a-fA-F]{1,4}){7}';  return preg_match("/^$user@($domain|(\[($ipv4|$ipv6)\]))$/", $mail);}/** * Verify the syntax of the given URL. * * This function should only be used on actual URLs. It should not be used for * Drupal menu paths, which can contain arbitrary characters. * Valid values per RFC 3986. * * @param $url *   The URL to verify. * @param $absolute *   Whether the URL is absolute (beginning with a scheme such as "http:"). * @return *   TRUE if the URL is in a valid format. */function valid_url($url, $absolute = FALSE) {  if ($absolute) {    return (bool)preg_match("      /^                                                      # Start at the beginning of the text      (?:ftp|https?):\/\/                                     # Look for ftp, http, or https schemes      (?:                                                     # Userinfo (optional) which is typically        (?:(?:[\w\.\-\+!$&'\(\)*\+,;=]|%[0-9a-f]{2})+:)*      # a username or a username and password        (?:[\w\.\-\+%!$&'\(\)*\+,;=]|%[0-9a-f]{2})+@          # combination      )?      (?:        (?:[a-z0-9\-\.]|%[0-9a-f]{2})+                        # A domain name or a IPv4 address        |(?:\[(?:[0-9a-f]{0,4}:)*(?:[0-9a-f]{0,4})\])         # or a well formed IPv6 address      )      (?::[0-9]+)?                                            # Server port number (optional)      (?:[\/|\?]        (?:[\w#!:\.\?\+=&@$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})   # The path and query (optional)      *)?    $/xi", $url);  }  else {    return (bool)preg_match("/^(?:[\w#!:\.\?\+=&@$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})+$/i", $url);  }}/** * @} End of "defgroup validation". *//** * Register an event for the current visitor (hostname/IP) to the flood control mechanism. * * @param $name *   The name of an event. */function flood_register_event($name) {  db_query("INSERT INTO {flood} (event, hostname, timestamp) VALUES ('%s', '%s', %d)", $name, ip_address(), time());}/** * Check if the current visitor (hostname/IP) is allowed to proceed with the specified event. * * The user is allowed to proceed if he did not trigger the specified event more * than $threshold times per hour. * * @param $name *   The name of the event. * @param $threshold *   The maximum number of the specified event per hour (per visitor). * @return *   True if the user did not exceed the hourly threshold. False otherwise. */function flood_is_allowed($name, $threshold) {  $number = db_result(db_query("SELECT COUNT(*) FROM {flood} WHERE event = '%s' AND hostname = '%s' AND timestamp > %d", $name, ip_address(), time() - 3600));  return ($number < $threshold ? TRUE : FALSE);}function check_file($filename) {  return is_uploaded_file($filename);}/** * Prepare a URL for use in an HTML attribute. Strips harmful protocols. */function check_url($uri) {  return filter_xss_bad_protocol($uri, FALSE);}/** * @defgroup format Formatting * @{ * Functions to format numbers, strings, dates, etc. *//** * Formats an RSS channel. * * Arbitrary elements may be added using the $args associative array. */function format_rss_channel($title, $link, $description, $items, $langcode = NULL, $args = array()) {  global $language;  $langcode = $langcode ? $langcode : $language->language;  $output = "<channel>\n";  $output .= ' <title>'. check_plain($title) ."</title>\n";  $output .= ' <link>'. check_url($link) ."</link>\n";  // The RSS 2.0 "spec" doesn't indicate HTML can be used in the description.  // We strip all HTML tags, but need to prevent double encoding from properly  // escaped source data (such as &amp becoming &amp;amp;).  $output .= ' <description>'. check_plain(decode_entities(strip_tags($description))) ."</description>\n";  $output .= ' <language>'. check_plain($langcode) ."</language>\n";  $output .= format_xml_elements($args);  $output .= $items;  $output .= "</channel>\n";  return $output;}/** * Format a single RSS item. * * Arbitrary elements may be added using the $args associative array. */function format_rss_item($title, $link, $description, $args = array()) {  $output = "<item>\n";  $output .= ' <title>'. check_plain($title) ."</title>\n";  $output .= ' <link>'. check_url($link) ."</link>\n";  $output .= ' <description>'. check_plain($description) ."</description>\n";  $output .= format_xml_elements($args);  $output .= "</item>\n";  return $output;}/** * Format XML elements. * * @param $array *   An array where each item represent an element and is either a: *   - (key => value) pair (<key>value</key>) *   - Associative array with fields: *     - 'key': element name *     - 'value': element contents *     - 'attributes': associative array of element attributes * * In both cases, 'value' can be a simple string, or it can be another array * with the same format as $array itself for nesting. */function format_xml_elements($array) {  $output = '';  foreach ($array as $key => $value) {    if (is_numeric($key)) {      if ($value['key']) {        $output .= ' <'. $value['key'];        if (isset($value['attributes']) && is_array($value['attributes'])) {          $output .= drupal_attributes($value['attributes']);        }        if (isset($value['value']) && $value['value'] != '') {          $output .= '>'. (is_array($value['value']) ? format_xml_elements($value['value']) : check_plain($value['value'])) .'</'. $value['key'] .">\n";        }        else {          $output .= " />\n";        }      }    }    else {      $output .= ' <'. $key .'>'. (is_array($value) ? format_xml_elements($value) : check_plain($value)) ."</$key>\n";    }  }  return $output;}/** * Format a string containing a count of items. * * This function ensures that the string is pluralized correctly. Since t() is * called by this function, make sure not to pass already-localized strings to * it. * * For example: * @code *   $output = format_plural($node->comment_count, '1 comment', '@count comments'); * @endcode * * Example with additional replacements: * @code *   $output = format_plural($update_count, *     'Changed the content type of 1 post from %old-type to %new-type.', *     'Changed the content type of @count posts from %old-type to %new-type.', *     array('%old-type' => $info->old_type, '%new-type' => $info->new_type))); * @endcode * * @param $count *   The item count to display. * @param $singular *   The string for the singular case. Please make sure it is clear this is *   singular, to ease translation (e.g. use "1 new comment" instead of "1 new"). *   Do not use @count in the singular string. * @param $plural *   The string for the plural case. Please make sure it is clear this is plural, *   to ease translation. Use @count in place of the item count, as in "@count *   new comments". * @param $args *   An associative array of replacements to make after translation. Incidences *   of any key in this array are replaced with the corresponding value. *   Based on the first character of the key, the value is escaped and/or themed: *    - !variable: inserted as is *    - @variable: escape plain text to HTML (check_plain) *    - %variable: escape text and theme as a placeholder for user-submitted *      content (check_plain + theme_placeholder) *   Note that you do not need to include @count in this array. *   This replacement is done automatically for the plural case. * @param $langcode *   Optional language code to translate to a language other than *   what is used to display the page. * @return *   A translated string. */function format_plural($count, $singular, $plural, $args = array(), $langcode = NULL) {  $args['@count'] = $count;  if ($count == 1) {    return t($singular, $args, $langcode);  }  // Get the plural index through the gettext formula.  $index = (function_exists('locale_get_plural')) ? locale_get_plural($count, $langcode) : -1;  // Backwards compatibility.  if ($index < 0) {    return t($plural, $args, $langcode);  }  else {    switch ($index) {      case "0":        return t($singular, $args, $langcode);      case "1":        return t($plural, $args, $langcode);      default:        unset($args['@count']);        $args['@count['. $index .']'] = $count;        return t(strtr($plural, array('@count' => '@count['. $index .']')), $args, $langcode);    }  }}/** * Parse a given byte count. * * @param $size *   A size expressed as a number of bytes with optional SI size and unit *   suffix (e.g. 2, 3K, 5MB, 10G). * @return *   An integer representation of the size. */function parse_size($size) {  $suffixes = array(    '' => 1,    'k' => 1024,    'm' => 1048576, // 1024 * 1024    'g' => 1073741824, // 1024 * 1024 * 1024  );  if (preg_match('/([0-9]+)\s*(k|m|g)?(b?(ytes?)?)/i', $size, $match)) {    return $match[1] * $suffixes[drupal_strtolower($match[2])];  }}/** * Generate a string representation for the given byte count. * * @param $size *   A size in bytes. * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   A translated string representation of the size. */function format_size($size, $langcode = NULL) {  if ($size < 1024) {    return format_plural($size, '1 byte', '@count bytes', array(), $langcode);  }  else {    $size = round($size / 1024, 2);    $suffix = t('KB', array(), $langcode);    if ($size >= 1024) {      $size = round($size / 1024, 2);      $suffix = t('MB', array(), $langcode);    }    return t('@size @suffix', array('@size' => $size, '@suffix' => $suffix), $langcode);  }}/** * Format a time interval with the requested granularity. * * @param $timestamp *   The length of the interval in seconds. * @param $granularity *   How many different units to display in the string. * @param $langcode *   Optional language code to translate to a language other than *   what is used to display the page. * @return *   A translated string representation of the interval. */function format_interval($timestamp, $granularity = 2, $langcode = NULL) {  $units = array('1 year|@count years' => 31536000, '1 week|@count weeks' => 604800, '1 day|@count days' => 86400, '1 hour|@count hours' => 3600, '1 min|@count min' => 60, '1 sec|@count sec' => 1);  $output = '';  foreach ($units as $key => $value) {    $key = explode('|', $key);    if ($timestamp >= $value) {      $output .= ($output ? ' ' : '') . format_plural(floor($timestamp / $value), $key[0], $key[1], array(), $langcode);      $timestamp %= $value;      $granularity--;    }    if ($granularity == 0) {      break;    }  }  return $output ? $output : t('0 sec', array(), $langcode);}/** * Format a date with the given configured format or a custom format string. * * Drupal allows administrators to select formatting strings for 'small', * 'medium' and 'large' date formats. This function can handle these formats, * as well as any custom format. * * @param $timestamp *   The exact date to format, as a UNIX timestamp. * @param $type *   The format to use. Can be "small", "medium" or "large" for the preconfigured *   date formats. If "custom" is specified, then $format is required as well. * @param $format *   A PHP date format string as required by date(). A backslash should be used *   before a character to avoid interpreting the character as part of a date *   format. * @param $timezone *   Time zone offset in seconds; if omitted, the user's time zone is used. * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   A translated date string in the requested format. */function format_date($timestamp, $type = 'medium', $format = '', $timezone = NULL, $langcode = NULL) {  if (!isset($timezone)) {    global $user;    if (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone)) {      $timezone = $user->timezone;    }    else {      $timezone = variable_get('date_default_timezone', 0);    }  }  $timestamp += $timezone;  switch ($type) {    case 'small':      $format = variable_get('date_format_short', 'm/d/Y - H:i');      break;    case 'large':      $format = variable_get('date_format_long', 'l, F j, Y - H:i');      break;    case 'custom':      // No change to format.      break;    case 'medium':    default:      $format = variable_get('date_format_medium', 'D, m/d/Y - H:i');  }  $max = strlen($format);  $date = '';  for ($i = 0; $i < $max; $i++) {    $c = $format[$i];    if (strpos('AaDlM', $c) !== FALSE) {      $date .= t(gmdate($c, $timestamp), array(), $langcode);    }    else if ($c == 'F') {      // Special treatment for long month names: May is both an abbreviation      // and a full month name in English, but other languages have      // different abbreviations.      $date .= trim(t('!long-month-name '. gmdate($c, $timestamp), array('!long-month-name' => ''), $langcode));    }    else if (strpos('BdgGhHiIjLmnsStTUwWYyz', $c) !== FALSE) {      $date .= gmdate($c, $timestamp);    }    else if ($c == 'r') {      $date .= format_date($timestamp - $timezone, 'custom', 'D, d M Y H:i:s O', $timezone, $langcode);    }    else if ($c == 'O') {      $date .= sprintf('%s%02d%02d', ($timezone < 0 ? '-' : '+'), abs($timezone / 3600), abs($timezone % 3600) / 60);    }    else if ($c == 'Z') {      $date .= $timezone;    }    else if ($c == '\\') {      $date .= $format[++$i];    }    else {      $date .= $c;    }  }  return $date;}/** * @} End of "defgroup format". *//** * Generate a URL from a Drupal menu path. Will also pass-through existing URLs. * * @param $path *   The Drupal path being linked to, such as "admin/content/node", or an *   existing URL like "http://drupal.org/".  The special path *   '<front>' may also be given and will generate the site's base URL. * @param $options *   An associative array of additional options, with the following keys: *   - 'query' *       A URL-encoded query string to append to the link, or an array of query *       key/value-pairs without any URL-encoding. *   - 'fragment' *       A fragment identifier (or named anchor) to append to the link. *       Do not include the '#' character. *   - 'absolute' (default FALSE) *       Whether to force the output to be an absolute link (beginning with *       http:). Useful for links that will be displayed outside the site, such *       as in an RSS feed. *   - 'alias' (default FALSE) *       Whether the given path is an alias already. *   - 'external' *       Whether the given path is an external URL. *   - 'language' *       An optional language object. Used to build the URL to link to and *       look up the proper alias for the link. *   - 'base_url' *       Only used internally, to modify the base URL when a language dependent *       URL requires so. *   - 'prefix' *       Only used internally, to modify the path when a language dependent URL *       requires so. * @return *   A string containing a URL to the given path. * * When creating links in modules, consider whether l() could be a better * alternative than url(). */function url($path = NULL, $options = array()) {  // Merge in defaults.  $options += array(    'fragment' => '',    'query' => '',    'absolute' => FALSE,    'alias' => FALSE,    'prefix' => ''  );  if (!isset($options['external'])) {    // Return an external link if $path contains an allowed absolute URL.    // Only call the slow filter_xss_bad_protocol if $path contains a ':' before    // any / ? or #.    $colonpos = strpos($path, ':');    $options['external'] = ($colonpos !== FALSE && !preg_match('![/?#]!', substr($path, 0, $colonpos)) && filter_xss_bad_protocol($path, FALSE) == check_plain($path));  }  // May need language dependent rewriting if language.inc is present.  if (function_exists('language_url_rewrite')) {    language_url_rewrite($path, $options);  }  if ($options['fragment']) {    $options['fragment'] = '#'. $options['fragment'];  }  if (is_array($options['query'])) {    $options['query'] = drupal_query_string_encode($options['query']);  }  if ($options['external']) {    // Split off the fragment.    if (strpos($path, '#') !== FALSE) {      list($path, $old_fragment) = explode('#', $path, 2);      if (isset($old_fragment) && !$options['fragment']) {        $options['fragment'] = '#'. $old_fragment;      }    }    // Append the query.    if ($options['query']) {      $path .= (strpos($path, '?') !== FALSE ? '&' : '?') . $options['query'];    }    // Reassemble.    return $path . $options['fragment'];  }  global $base_url;  static $script;  if (!isset($script)) {    // On some web servers, such as IIS, we can't omit "index.php". So, we    // generate "index.php?q=foo" instead of "?q=foo" on anything that is not    // Apache.    $script = (strpos($_SERVER['SERVER_SOFTWARE'], 'Apache') === FALSE) ? 'index.php' : '';  }  if (!isset($options['base_url'])) {    // The base_url might be rewritten from the language rewrite in domain mode.    $options['base_url'] = $base_url;  }  // Preserve the original path before aliasing.  $original_path = $path;  // The special path '<front>' links to the default front page.  if ($path == '<front>') {    $path = '';  }  elseif (!empty($path) && !$options['alias']) {    $path = drupal_get_path_alias($path, isset($options['language']) ? $options['language']->language : '');  }  if (function_exists('custom_url_rewrite_outbound')) {    // Modules may alter outbound links by reference.    custom_url_rewrite_outbound($path, $options, $original_path);  }  $base = $options['absolute'] ? $options['base_url'] .'/' : base_path();  $prefix = empty($path) ? rtrim($options['prefix'], '/') : $options['prefix'];  $path = drupal_urlencode($prefix . $path);  if (variable_get('clean_url', '0')) {    // With Clean URLs.    if ($options['query']) {      return $base . $path .'?'. $options['query'] . $options['fragment'];    }    else {      return $base . $path . $options['fragment'];    }  }  else {    // Without Clean URLs.    $variables = array();    if (!empty($path)) {      $variables[] = 'q='. $path;    }    if (!empty($options['query'])) {      $variables[] = $options['query'];    }    if ($query = join('&', $variables)) {      return $base . $script .'?'. $query . $options['fragment'];    }    else {      return $base . $options['fragment'];    }  }}/** * Format an attribute string to insert in a tag. * * @param $attributes *   An associative array of HTML attributes. * @return *   An HTML string ready for insertion in a tag. */function drupal_attributes($attributes = array()) {  if (is_array($attributes)) {    $t = '';    foreach ($attributes as $key => $value) {      $t .= " $key=".'"'. check_plain($value) .'"';    }    return $t;  }}/** * Format an internal Drupal link. * * This function correctly handles aliased paths, and allows themes to highlight * links to the current page correctly, so all internal links output by modules * should be generated by this function if possible. * * @param $text *   The text to be enclosed with the anchor tag. * @param $path *   The Drupal path being linked to, such as "admin/content/node". Can be an *   external or internal URL. *     - If you provide the full URL, it will be considered an external URL. *     - If you provide only the path (e.g. "admin/content/node"), it is *       considered an internal link. In this case, it must be a system URL *       as the url() function will generate the alias. *     - If you provide '<front>', it generates a link to the site's *       base URL (again via the url() function). *     - If you provide a path, and 'alias' is set to TRUE (see below), it is *       used as is. * @param $options *   An associative array of additional options, with the following keys: *     - 'attributes' *       An associative array of HTML attributes to apply to the anchor tag. *     - 'query' *       A query string to append to the link, or an array of query key/value *       properties. *     - 'fragment' *       A fragment identifier (named anchor) to append to the link. *       Do not include the '#' character. *     - 'absolute' (default FALSE) *       Whether to force the output to be an absolute link (beginning with *       http:). Useful for links that will be displayed outside the site, such *       as in an RSS feed. *     - 'html' (default FALSE) *       Whether the title is HTML, or just plain-text. For example for making *       an image a link, this must be set to TRUE, or else you will see the *       escaped HTML. *     - 'alias' (default FALSE) *       Whether the given path is an alias already. * @return *   an HTML string containing a link to the given path. */function l($text, $path, $options = array()) {  global $language;  // Merge in defaults.  $options += array(      'attributes' => array(),      'html' => FALSE,    );  // Append active class.  if (($path == $_GET['q'] || ($path == '<front>' && drupal_is_front_page())) &&      (empty($options['language']) || $options['language']->language == $language->language)) {    if (isset($options['attributes']['class'])) {      $options['attributes']['class'] .= ' active';    }    else {      $options['attributes']['class'] = 'active';    }  }  // Remove all HTML and PHP tags from a tooltip. For best performance, we act only  // if a quick strpos() pre-check gave a suspicion (because strip_tags() is expensive).  if (isset($options['attributes']['title']) && strpos($options['attributes']['title'], '<') !== FALSE) {    $options['attributes']['title'] = strip_tags($options['attributes']['title']);  }  return '<a href="'. check_url(url($path, $options)) .'"'. drupal_attributes($options['attributes']) .'>'. ($options['html'] ? $text : check_plain($text)) .'</a>';}/** * Perform end-of-request tasks. * * This function sets the page cache if appropriate, and allows modules to * react to the closing of the page by calling hook_exit(). */function drupal_page_footer() {  if (variable_get('cache', CACHE_DISABLED) != CACHE_DISABLED) {    page_set_cache();  }  module_invoke_all('exit');}/** * Form an associative array from a linear array. * * This function walks through the provided array and constructs an associative * array out of it. The keys of the resulting array will be the values of the * input array. The values will be the same as the keys unless a function is * specified, in which case the output of the function is used for the values * instead. * * @param $array *   A linear array. * @param $function *   A name of a function to apply to all values before output. * @result *   An associative array. */function drupal_map_assoc($array, $function = NULL) {  if (!isset($function)) {    $result = array();    foreach ($array as $value) {      $result[$value] = $value;    }    return $result;  }  elseif (function_exists($function)) {    $result = array();    foreach ($array as $value) {      $result[$value] = $function($value);    }    return $result;  }}/** * Evaluate a string of PHP code. * * This is a wrapper around PHP's eval(). It uses output buffering to capture both * returned and printed text. Unlike eval(), we require code to be surrounded by * <?php ?> tags; in other words, we evaluate the code as if it were a stand-alone * PHP file. * * Using this wrapper also ensures that the PHP code which is evaluated can not * overwrite any variables in the calling code, unlike a regular eval() call. * * @param $code *   The code to evaluate. * @return *   A string containing the printed output of the code, followed by the returned *   output of the code. */function drupal_eval($code) {  global $theme_path, $theme_info, $conf;  // Store current theme path.  $old_theme_path = $theme_path;  // Restore theme_path to the theme, as long as drupal_eval() executes,  // so code evaluted will not see the caller module as the current theme.  // If theme info is not initialized get the path from theme_default.  if (!isset($theme_info)) {    $theme_path = drupal_get_path('theme', $conf['theme_default']);  }  else {    $theme_path = dirname($theme_info->filename);  }  ob_start();  print eval('?>'. $code);  $output = ob_get_contents();  ob_end_clean();  // Recover original theme path.  $theme_path = $old_theme_path;  return $output;}/** * Returns the path to a system item (module, theme, etc.). * * @param $type *   The type of the item (i.e. theme, theme_engine, module). * @param $name *   The name of the item for which the path is requested. * * @return *   The path to the requested item. */function drupal_get_path($type, $name) {  return dirname(drupal_get_filename($type, $name));}/** * Returns the base URL path of the Drupal installation. * At the very least, this will always default to /. */function base_path() {  return $GLOBALS['base_path'];}/** * Provide a substitute clone() function for PHP4. */function drupal_clone($object) {  return version_compare(phpversion(), '5.0') < 0 ? $object : clone($object);}/** * Add a <link> tag to the page's HEAD. */function drupal_add_link($attributes) {  drupal_set_html_head('<link'. drupal_attributes($attributes) .' />');}/** * Adds a CSS file to the stylesheet queue. * * @param $path *   (optional) The path to the CSS file relative to the base_path(), e.g., *   /modules/devel/devel.css. * *   Modules should always prefix the names of their CSS files with the module *   name, for example: system-menus.css rather than simply menus.css. Themes *   can override module-supplied CSS files based on their filenames, and this *   prefixing helps prevent confusing name collisions for theme developers. *   See drupal_get_css where the overrides are performed. * *   If the direction of the current language is right-to-left (Hebrew, *   Arabic, etc.), the function will also look for an RTL CSS file and append *   it to the list. The name of this file should have an '-rtl.css' suffix. *   For example a CSS file called 'name.css' will have a 'name-rtl.css' *   file added to the list, if exists in the same directory. This CSS file *   should contain overrides for properties which should be reversed or *   otherwise different in a right-to-left display. * @param $type *   (optional) The type of stylesheet that is being added. Types are: module *   or theme. * @param $media *   (optional) The media type for the stylesheet, e.g., all, print, screen. * @param $preprocess *   (optional) Should this CSS file be aggregated and compressed if this *   feature has been turned on under the performance section? * *   What does this actually mean? *   CSS preprocessing is the process of aggregating a bunch of separate CSS *   files into one file that is then compressed by removing all extraneous *   white space. * *   The reason for merging the CSS files is outlined quite thoroughly here: *   http://www.die.net/musings/page_load_time/ *   "Load fewer external objects. Due to request overhead, one bigger file *   just loads faster than two smaller ones half its size." * *   However, you should *not* preprocess every file as this can lead to *   redundant caches. You should set $preprocess = FALSE when: * *     - Your styles are only used rarely on the site. This could be a special *       admin page, the homepage, or a handful of pages that does not represent *       the majority of the pages on your site. * *   Typical candidates for caching are for example styles for nodes across *   the site, or used in the theme. * @return *   An array of CSS files. */function drupal_add_css($path = NULL, $type = 'module', $media = 'all', $preprocess = TRUE) {  static $css = array();  global $language;  // Create an array of CSS files for each media type first, since each type needs to be served  // to the browser differently.  if (isset($path)) {    // This check is necessary to ensure proper cascading of styles and is faster than an asort().    if (!isset($css[$media])) {      $css[$media] = array('module' => array(), 'theme' => array());    }    $css[$media][$type][$path] = $preprocess;    // If the current language is RTL, add the CSS file with RTL overrides.    if ($language->direction == LANGUAGE_RTL) {      $rtl_path = str_replace('.css', '-rtl.css', $path);      if (file_exists($rtl_path)) {        $css[$media][$type][$rtl_path] = $preprocess;      }    }  }  return $css;}/** * Returns a themed representation of all stylesheets that should be attached to the page. * * It loads the CSS in order, with 'module' first, then 'theme' afterwards. * This ensures proper cascading of styles so themes can easily override * module styles through CSS selectors. * * Themes may replace module-defined CSS files by adding a stylesheet with the * same filename. For example, themes/garland/system-menus.css would replace * modules/system/system-menus.css. This allows themes to override complete * CSS files, rather than specific selectors, when necessary. * * If the original CSS file is being overridden by a theme, the theme is * responsible for supplying an accompanying RTL CSS file to replace the * module's. * * @param $css *   (optional) An array of CSS files. If no array is provided, the default *   stylesheets array is used instead. * @return *   A string of XHTML CSS tags. */function drupal_get_css($css = NULL) {  $output = '';  if (!isset($css)) {    $css = drupal_add_css();  }  $no_module_preprocess = '';  $no_theme_preprocess = '';  $preprocess_css = (variable_get('preprocess_css', FALSE) && (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update'));  $directory = file_directory_path();  $is_writable = is_dir($directory) && is_writable($directory) && (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC);  // A dummy query-string is added to filenames, to gain control over  // browser-caching. The string changes on every update or full cache  // flush, forcing browsers to load a new copy of the files, as the  // URL changed.  $query_string = '?'. substr(variable_get('css_js_query_string', '0'), 0, 1);  foreach ($css as $media => $types) {    // If CSS preprocessing is off, we still need to output the styles.    // Additionally, go through any remaining styles if CSS preprocessing is on and output the non-cached ones.    foreach ($types as $type => $files) {      if ($type == 'module') {        // Setup theme overrides for module styles.        $theme_styles = array();        foreach (array_keys($css[$media]['theme']) as $theme_style) {          $theme_styles[] = basename($theme_style);        }      }      foreach ($types[$type] as $file => $preprocess) {        // If the theme supplies its own style using the name of the module style, skip its inclusion.        // This includes any RTL styles associated with its main LTR counterpart.        if ($type == 'module' && in_array(str_replace('-rtl.css', '.css', basename($file)), $theme_styles)) {          // Unset the file to prevent its inclusion when CSS aggregation is enabled.          unset($types[$type][$file]);          continue;        }        // Only include the stylesheet if it exists.        if (file_exists($file)) {          if (!$preprocess || !($is_writable && $preprocess_css)) {            // If a CSS file is not to be preprocessed and it's a module CSS file, it needs to *always* appear at the *top*,            // regardless of whether preprocessing is on or off.            if (!$preprocess && $type == 'module') {              $no_module_preprocess .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }            // If a CSS file is not to be preprocessed and it's a theme CSS file, it needs to *always* appear at the *bottom*,            // regardless of whether preprocessing is on or off.            else if (!$preprocess && $type == 'theme') {              $no_theme_preprocess .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }            else {              $output .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }          }        }      }    }    if ($is_writable && $preprocess_css) {      // Prefix filename to prevent blocking by firewalls which reject files      // starting with "ad*".      $filename = 'css_'. md5(serialize($types) . $query_string) .'.css';      $preprocess_file = drupal_build_css_cache($types, $filename);      $output .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $preprocess_file .'" />'."\n";    }  }  return $no_module_preprocess . $output . $no_theme_preprocess;}/** * Aggregate and optimize CSS files, putting them in the files directory. * * @param $types *   An array of types of CSS files (e.g., screen, print) to aggregate and *   compress into one file. * @param $filename *   The name of the aggregate CSS file. * @return *   The name of the CSS file. */function drupal_build_css_cache($types, $filename) {  $data = '';  // Create the css/ within the files folder.  $csspath = file_create_path('css');  file_check_directory($csspath, FILE_CREATE_DIRECTORY);  if (!file_exists($csspath .'/'. $filename)) {    // Build aggregate CSS file.    foreach ($types as $type) {      foreach ($type as $file => $cache) {        if ($cache) {          $contents = drupal_load_stylesheet($file, TRUE);          // Return the path to where this CSS file originated from.          $base = base_path() . dirname($file) .'/';          _drupal_build_css_path(NULL, $base);          // Prefix all paths within this CSS file, ignoring external and absolute paths.          $data .= preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $contents);        }      }    }    // Per the W3C specification at http://www.w3.org/TR/REC-CSS2/cascade.html#at-import,    // @import rules must proceed any other style, so we move those to the top.    $regexp = '/@import[^;]+;/i';    preg_match_all($regexp, $data, $matches);    $data = preg_replace($regexp, '', $data);    $data = implode('', $matches[0]) . $data;    // Create the CSS file.    file_save_data($data, $csspath .'/'. $filename, FILE_EXISTS_REPLACE);  }  return $csspath .'/'. $filename;}/** * Helper function for drupal_build_css_cache(). * * This function will prefix all paths within a CSS file. */function _drupal_build_css_path($matches, $base = NULL) {  static $_base;  // Store base path for preg_replace_callback.  if (isset($base)) {    $_base = $base;  }  // Prefix with base and remove '../' segments where possible.  $path = $_base . $matches[1];  $last = '';  while ($path != $last) {    $last = $path;    $path = preg_replace('`(^|/)(?!\.\./)([^/]+)/\.\./`', '$1', $path);  }  return 'url('. $path .')';}/** * Loads the stylesheet and resolves all @import commands. * * Loads a stylesheet and replaces @import commands with the contents of the * imported file. Use this instead of file_get_contents when processing * stylesheets. * * The returned contents are compressed removing white space and comments only * when CSS aggregation is enabled. This optimization will not apply for * color.module enabled themes with CSS aggregation turned off. * * @param $file *   Name of the stylesheet to be processed. * @param $optimize *   Defines if CSS contents should be compressed or not. * @return *   Contents of the stylesheet including the imported stylesheets. */function drupal_load_stylesheet($file, $optimize = NULL) {  static $_optimize;  // Store optimization parameter for preg_replace_callback with nested @import loops.  if (isset($optimize)) {    $_optimize = $optimize;  }  $contents = '';  if (file_exists($file)) {    // Load the local CSS stylesheet.    $contents = file_get_contents($file);    // Change to the current stylesheet's directory.    $cwd = getcwd();    chdir(dirname($file));    // Replaces @import commands with the actual stylesheet content.    // This happens recursively but omits external files.    $contents = preg_replace_callback('/@import\s*(?:url\()?[\'"]?(?![a-z]+:)([^\'"\()]+)[\'"]?\)?;/', '_drupal_load_stylesheet', $contents);    // Remove multiple charset declarations for standards compliance (and fixing Safari problems).    $contents = preg_replace('/^@charset\s+[\'"](\S*)\b[\'"];/i', '', $contents);    if ($_optimize) {      // Perform some safe CSS optimizations.      $contents = preg_replace('<        \s*([@{}:;,]|\)\s|\s\()\s* |  # Remove whitespace around separators, but keep space around parentheses.        /\*([^*\\\\]|\*(?!/))+\*/     # Remove comments that are not CSS hacks.        >x', '\1', $contents);    }    // Change back directory.    chdir($cwd);  }  return $contents;}/** * Loads stylesheets recursively and returns contents with corrected paths. * * This function is used for recursive loading of stylesheets and * returns the stylesheet content with all url() paths corrected. */function _drupal_load_stylesheet($matches) {  $filename = $matches[1];  // Load the imported stylesheet and replace @import commands in there as well.  $file = drupal_load_stylesheet($filename);  // Alter all url() paths, but not external.  return preg_replace('/url\(([\'"]?)(?![a-z]+:)([^\'")]+)[\'"]?\)?;/i', 'url(\1'. dirname($filename) .'/', $file);}/** * Delete all cached CSS files. */function drupal_clear_css_cache() {  file_scan_directory(file_create_path('css'), '.*', array('.', '..', 'CVS'), 'file_delete', TRUE);}/** * Add a JavaScript file, setting or inline code to the page. * * The behavior of this function depends on the parameters it is called with. * Generally, it handles the addition of JavaScript to the page, either as * reference to an existing file or as inline code. The following actions can be * performed using this function: * * - Add a file ('core', 'module' and 'theme'): *   Adds a reference to a JavaScript file to the page. JavaScript files *   are placed in a certain order, from 'core' first, to 'module' and finally *   'theme' so that files, that are added later, can override previously added *   files with ease. * * - Add inline JavaScript code ('inline'): *   Executes a piece of JavaScript code on the current page by placing the code *   directly in the page. This can, for example, be useful to tell the user that *   a new message arrived, by opening a pop up, alert box etc. * * - Add settings ('setting'): *   Adds a setting to Drupal's global storage of JavaScript settings. Per-page *   settings are required by some modules to function properly. The settings *   will be accessible at Drupal.settings. * * @param $data *   (optional) If given, the value depends on the $type parameter: *   - 'core', 'module' or 'theme': Path to the file relative to base_path(). *   - 'inline': The JavaScript code that should be placed in the given scope. *   - 'setting': An array with configuration options as associative array. The *       array is directly placed in Drupal.settings. You might want to wrap your *       actual configuration settings in another variable to prevent the pollution *       of the Drupal.settings namespace. * @param $type *   (optional) The type of JavaScript that should be added to the page. Allowed *   values are 'core', 'module', 'theme', 'inline' and 'setting'. You *   can, however, specify any value. It is treated as a reference to a JavaScript *   file. Defaults to 'module'. * @param $scope *   (optional) The location in which you want to place the script. Possible *   values are 'header' and 'footer' by default. If your theme implements *   different locations, however, you can also use these. * @param $defer *   (optional) If set to TRUE, the defer attribute is set on the <script> tag. *   Defaults to FALSE. This parameter is not used with $type == 'setting'. * @param $cache *   (optional) If set to FALSE, the JavaScript file is loaded anew on every page *   call, that means, it is not cached. Defaults to TRUE. Used only when $type *   references a JavaScript file. * @param $preprocess *   (optional) Should this JS file be aggregated if this *   feature has been turned on under the performance section? * @return *   If the first parameter is NULL, the JavaScript array that has been built so *   far for $scope is returned. If the first three parameters are NULL, *   an array with all scopes is returned. */function drupal_add_js($data = NULL, $type = 'module', $scope = 'header', $defer = FALSE, $cache = TRUE, $preprocess = TRUE) {  static $javascript = array();  if (isset($data)) {    // Add jquery.js and drupal.js, as well as the basePath setting, the    // first time a Javascript file is added.    if (empty($javascript)) {      $javascript['header'] = array(        'core' => array(          'misc/jquery.js' => array('cache' => TRUE, 'defer' => FALSE, 'preprocess' => TRUE),          'misc/drupal.js' => array('cache' => TRUE, 'defer' => FALSE, 'preprocess' => TRUE),        ),        'module' => array(),        'theme' => array(),        'setting' => array(          array('basePath' => base_path()),        ),        'inline' => array(),      );    }    if (isset($scope) && !isset($javascript[$scope])) {      $javascript[$scope] = array('core' => array(), 'module' => array(), 'theme' => array(), 'setting' => array(), 'inline' => array());    }    if (isset($type) && isset($scope) && !isset($javascript[$scope][$type])) {      $javascript[$scope][$type] = array();    }    switch ($type) {      case 'setting':        $javascript[$scope][$type][] = $data;        break;      case 'inline':        $javascript[$scope][$type][] = array('code' => $data, 'defer' => $defer);        break;      default:        // If cache is FALSE, don't preprocess the JS file.        $javascript[$scope][$type][$data] = array('cache' => $cache, 'defer' => $defer, 'preprocess' => (!$cache ? FALSE : $preprocess));    }  }  if (isset($scope)) {    if (isset($javascript[$scope])) {      return $javascript[$scope];    }    else {      return array();    }  }  else {    return $javascript;  }}/** * Returns a themed presentation of all JavaScript code for the current page. * * References to JavaScript files are placed in a certain order: first, all * 'core' files, then all 'module' and finally all 'theme' JavaScript files * are added to the page. Then, all settings are output, followed by 'inline' * JavaScript code. If running update.php, all preprocessing is disabled. * * @param $scope *   (optional) The scope for which the JavaScript rules should be returned. *   Defaults to 'header'. * @param $javascript *   (optional) An array with all JavaScript code. Defaults to the default *   JavaScript array for the given scope. * @return *   All JavaScript code segments and includes for the scope as HTML tags. */function drupal_get_js($scope = 'header', $javascript = NULL) {  if ((!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') && function_exists('locale_update_js_files')) {    locale_update_js_files();  }  if (!isset($javascript)) {    $javascript = drupal_add_js(NULL, NULL, $scope);  }  if (empty($javascript)) {    return '';  }  $output = '';  $preprocessed = '';  $no_preprocess = array('core' => '', 'module' => '', 'theme' => '');  $files = array();  $preprocess_js = (variable_get('preprocess_js', FALSE) && (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update'));  $directory = file_directory_path();  $is_writable = is_dir($directory) && is_writable($directory) && (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC);  // A dummy query-string is added to filenames, to gain control over  // browser-caching. The string changes on every update or full cache  // flush, forcing browsers to load a new copy of the files, as the  // URL changed. Files that should not be cached (see drupal_add_js())  // get time() as query-string instead, to enforce reload on every  // page request.  $query_string = '?'. substr(variable_get('css_js_query_string', '0'), 0, 1);  // For inline Javascript to validate as XHTML, all Javascript containing  // XHTML needs to be wrapped in CDATA. To make that backwards compatible  // with HTML 4, we need to comment out the CDATA-tag.  $embed_prefix = "\n<!--//--><![CDATA[//><!--\n";  $embed_suffix = "\n//--><!]]>\n";  foreach ($javascript as $type => $data) {    if (!$data) continue;    switch ($type) {      case 'setting':        $output .= '<script type="text/javascript">' . $embed_prefix . 'jQuery.extend(Drupal.settings, ' . drupal_to_js(call_user_func_array('array_merge_recursive', $data)) . ");" . $embed_suffix . "</script>\n";        break;      case 'inline':        foreach ($data as $info) {          $output .= '<script type="text/javascript"' . ($info['defer'] ? ' defer="defer"' : '') . '>' . $embed_prefix . $info['code'] . $embed_suffix . "</script>\n";        }        break;      default:        // If JS preprocessing is off, we still need to output the scripts.        // Additionally, go through any remaining scripts if JS preprocessing is on and output the non-cached ones.        foreach ($data as $path => $info) {          if (!$info['preprocess'] || !$is_writable || !$preprocess_js) {            $no_preprocess[$type] .= '<script type="text/javascript"'. ($info['defer'] ? ' defer="defer"' : '') .' src="'. base_path() . $path . ($info['cache'] ? $query_string : '?'. time()) ."\"></script>\n";          }          else {            $files[$path] = $info;          }        }    }  }  // Aggregate any remaining JS files that haven't already been output.  if ($is_writable && $preprocess_js && count($files) > 0) {    // Prefix filename to prevent blocking by firewalls which reject files    // starting with "ad*".    $filename = 'js_'. md5(serialize($files) . $query_string) .'.js';    $preprocess_file = drupal_build_js_cache($files, $filename);    $preprocessed .= '<script type="text/javascript" src="'. base_path() . $preprocess_file .'"></script>'."\n";  }  // Keep the order of JS files consistent as some are preprocessed and others are not.  // Make sure any inline or JS setting variables appear last after libraries have loaded.  $output = $preprocessed . implode('', $no_preprocess) . $output;  return $output;}/** * Assist in adding the tableDrag JavaScript behavior to a themed table. * * Draggable tables should be used wherever an outline or list of sortable items * needs to be arranged by an end-user. Draggable tables are very flexible and * can manipulate the value of form elements placed within individual columns. * * To set up a table to use drag and drop in place of weight select-lists or * in place of a form that contains parent relationships, the form must be * themed into a table. The table must have an id attribute set. If using * theme_table(), the id may be set as such: * @code * $output = theme('table', $header, $rows, array('id' => 'my-module-table')); * return $output; * @endcode * * In the theme function for the form, a special class must be added to each * form element within the same column, "grouping" them together. * * In a situation where a single weight column is being sorted in the table, the * classes could be added like this (in the theme function): * @code * $form['my_elements'][$delta]['weight']['#attributes']['class'] = "my-elements-weight"; * @endcode * * Each row of the table must also have a class of "draggable" in order to enable the * drag handles: * @code * $row = array(...); * $rows[] = array( *   'data' => $row, *   'class' => 'draggable', * ); * @endcode * * When tree relationships are present, the two additional classes * 'tabledrag-leaf' and 'tabledrag-root' can be used to refine the behavior: * - Rows with the 'tabledrag-leaf' class cannot have child rows. * - Rows with the 'tabledrag-root' class cannot be nested under a parent row. * * Calling drupal_add_tabledrag() would then be written as such: * @code * drupal_add_tabledrag('my-module-table', 'order', 'sibling', 'my-elements-weight'); * @endcode * * In a more complex case where there are several groups in one column (such as * the block regions on the admin/build/block page), a separate subgroup class * must also be added to differentiate the groups. * @code * $form['my_elements'][$region][$delta]['weight']['#attributes']['class'] = "my-elements-weight my-elements-weight-". $region; * @endcode * * $group is still 'my-element-weight', and the additional $subgroup variable * will be passed in as 'my-elements-weight-'. $region. This also means that * you'll need to call drupal_add_tabledrag() once for every region added. * * @code * foreach ($regions as $region) { *   drupal_add_tabledrag('my-module-table', 'order', 'sibling', 'my-elements-weight', 'my-elements-weight-'. $region); * } * @endcode * * In a situation where tree relationships are present, adding multiple * subgroups is not necessary, because the table will contain indentations that * provide enough information about the sibling and parent relationships. * See theme_menu_overview_form() for an example creating a table containing * parent relationships. * * Please note that this function should be called from the theme layer, such as * in a .tpl.php file, theme_ function, or in a template_preprocess function, * not in a form declartion. Though the same JavaScript could be added to the * page using drupal_add_js() directly, this function helps keep template files * clean and readable. It also prevents tabledrag.js from being added twice * accidentally. * * @param $table_id *   String containing the target table's id attribute. If the table does not *   have an id, one will need to be set, such as <table id="my-module-table">. * @param $action *   String describing the action to be done on the form item. Either 'match' *   'depth', or 'order'. Match is typically used for parent relationships. *   Order is typically used to set weights on other form elements with the same *   group. Depth updates the target element with the current indentation. * @param $relationship *   String describing where the $action variable should be performed. Either *   'parent', 'sibling', 'group', or 'self'. Parent will only look for fields *   up the tree. Sibling will look for fields in the same group in rows above *   and below it. Self affects the dragged row itself. Group affects the *   dragged row, plus any children below it (the entire dragged group). * @param $group *   A class name applied on all related form elements for this action. * @param $subgroup *   (optional) If the group has several subgroups within it, this string should *   contain the class name identifying fields in the same subgroup. * @param $source *   (optional) If the $action is 'match', this string should contain the class *   name identifying what field will be used as the source value when matching *   the value in $subgroup. * @param $hidden *   (optional) The column containing the field elements may be entirely hidden *   from view dynamically when the JavaScript is loaded. Set to FALSE if the *   column should not be hidden. * @param $limit *   (optional) Limit the maximum amount of parenting in this table. * @see block-admin-display-form.tpl.php * @see theme_menu_overview_form() */function drupal_add_tabledrag($table_id, $action, $relationship, $group, $subgroup = NULL, $source = NULL, $hidden = TRUE, $limit = 0) {  static $js_added = FALSE;  if (!$js_added) {    drupal_add_js('misc/tabledrag.js', 'core');    $js_added = TRUE;  }  // If a subgroup or source isn't set, assume it is the same as the group.  $target = isset($subgroup) ? $subgroup : $group;  $source = isset($source) ? $source : $target;  $settings['tableDrag'][$table_id][$group][] = array(    'target' => $target,    'source' => $source,    'relationship' => $relationship,    'action' => $action,    'hidden' => $hidden,    'limit' => $limit,  );  drupal_add_js($settings, 'setting');}/** * Aggregate JS files, putting them in the files directory. * * @param $files *   An array of JS files to aggregate and compress into one file. * @param $filename *   The name of the aggregate JS file. * @return *   The name of the JS file. */function drupal_build_js_cache($files, $filename) {  $contents = '';  // Create the js/ within the files folder.  $jspath = file_create_path('js');  file_check_directory($jspath, FILE_CREATE_DIRECTORY);  if (!file_exists($jspath .'/'. $filename)) {    // Build aggregate JS file.    foreach ($files as $path => $info) {      if ($info['preprocess']) {        // Append a ';' after each JS file to prevent them from running together.        $contents .= file_get_contents($path) .';';      }    }    // Create the JS file.    file_save_data($contents, $jspath .'/'. $filename, FILE_EXISTS_REPLACE);  }  return $jspath .'/'. $filename;}/** * Delete all cached JS files. */function drupal_clear_js_cache() {  file_scan_directory(file_create_path('js'), '.*', array('.', '..', 'CVS'), 'file_delete', TRUE);  variable_set('javascript_parsed', array());}/** * Converts a PHP variable into its Javascript equivalent. * * We use HTML-safe strings, i.e. with <, > and & escaped. */function drupal_to_js($var) {  switch (gettype($var)) {    case 'boolean':      return $var ? 'true' : 'false'; // Lowercase necessary!    case 'integer':    case 'double':      return $var;    case 'resource':    case 'string':      return '"'. str_replace(array("\r", "\n", "<", ">", "&"),                              array('\r', '\n', '\x3c', '\x3e', '\x26'),                              addslashes($var)) .'"';    case 'array':      // Arrays in JSON can't be associative. If the array is empty or if it      // has sequential whole number keys starting with 0, it's not associative      // so we can go ahead and convert it as an array.      if (empty ($var) || array_keys($var) === range(0, sizeof($var) - 1)) {        $output = array();        foreach ($var as $v) {          $output[] = drupal_to_js($v);        }        return '[ '. implode(', ', $output) .' ]';      }      // Otherwise, fall through to convert the array as an object.    case 'object':      $output = array();      foreach ($var as $k => $v) {        $output[] = drupal_to_js(strval($k)) .': '. drupal_to_js($v);      }      return '{ '. implode(', ', $output) .' }';    default:      return 'null';  }}/** * Return data in JSON format. * * This function should be used for JavaScript callback functions returning * data in JSON format. It sets the header for JavaScript output. * * @param $var *   (optional) If set, the variable will be converted to JSON and output. */function drupal_json($var = NULL) {  // We are returning JavaScript, so tell the browser.  drupal_set_header('Content-Type: text/javascript; charset=utf-8');  if (isset($var)) {    echo drupal_to_js($var);  }}/** * Wrapper around urlencode() which avoids Apache quirks. * * Should be used when placing arbitrary data in an URL. Note that Drupal paths * are urlencoded() when passed through url() and do not require urlencoding() * of individual components. * * Notes: * - For esthetic reasons, we do not escape slashes. This also avoids a 'feature' *   in Apache where it 404s on any path containing '%2F'. * - mod_rewrite unescapes %-encoded ampersands, hashes, and slashes when clean *   URLs are used, which are interpreted as delimiters by PHP. These *   characters are double escaped so PHP will still see the encoded version. * - With clean URLs, Apache changes '//' to '/', so every second slash is *   double escaped. * - This function should only be used on paths, not on query string arguments, *   otherwise unwanted double encoding will occur. * * @param $text *   String to encode */function drupal_urlencode($text) {  if (variable_get('clean_url', '0')) {    return str_replace(array('%2F', '%26', '%23', '//'),                       array('/', '%2526', '%2523', '/%252F'),                       rawurlencode($text));  }  else {    return str_replace('%2F', '/', rawurlencode($text));  }}/** * Ensure the private key variable used to generate tokens is set. * * @return *   The private key. */function drupal_get_private_key() {  if (!($key = variable_get('drupal_private_key', 0))) {    $key = md5(uniqid(mt_rand(), true)) . md5(uniqid(mt_rand(), true));    variable_set('drupal_private_key', $key);  }  return $key;}/** * Generate a token based on $value, the current user session and private key. * * @param $value *   An additional value to base the token on. */function drupal_get_token($value = '') {  $private_key = drupal_get_private_key();  return md5(session_id() . $value . $private_key);}/** * Validate a token based on $value, the current user session and private key. * * @param $token *   The token to be validated. * @param $value *   An additional value to base the token on. * @param $skip_anonymous *   Set to true to skip token validation for anonymous users. * @return *   True for a valid token, false for an invalid token. When $skip_anonymous *   is true, the return value will always be true for anonymous users. */function drupal_valid_token($token, $value = '', $skip_anonymous = FALSE) {  global $user;  return (($skip_anonymous && $user->uid == 0) || ($token == md5(session_id() . $value . variable_get('drupal_private_key', ''))));}/** * Performs one or more XML-RPC request(s). * * @param $url *   An absolute URL of the XML-RPC endpoint. *     Example: *     http://www.example.com/xmlrpc.php * @param ... *   For one request: *     The method name followed by a variable number of arguments to the method. *   For multiple requests (system.multicall): *     An array of call arrays. Each call array follows the pattern of the single *     request: method name followed by the arguments to the method. * @return *   For one request: *     Either the return value of the method on success, or FALSE. *     If FALSE is returned, see xmlrpc_errno() and xmlrpc_error_msg(). *   For multiple requests: *     An array of results. Each result will either be the result *     returned by the method called, or an xmlrpc_error object if the call *     failed. See xmlrpc_error(). */function xmlrpc($url) {  require_once './includes/xmlrpc.inc';  $args = func_get_args();  return call_user_func_array('_xmlrpc', $args);}function _drupal_bootstrap_full() {  static $called;  if ($called) {    return;  }  $called = 1;  require_once './includes/theme.inc';  require_once './includes/pager.inc';  require_once './includes/menu.inc';  require_once './includes/tablesort.inc';  require_once './includes/file.inc';  require_once './includes/unicode.inc';  require_once './includes/image.inc';  require_once './includes/form.inc';  require_once './includes/mail.inc';  require_once './includes/actions.inc';  // Set the Drupal custom error handler.  set_error_handler('drupal_error_handler');  // Emit the correct charset HTTP header.  drupal_set_header('Content-Type: text/html; charset=utf-8');  // Detect string handling method  unicode_check();  // Undo magic quotes  fix_gpc_magic();  // Load all enabled modules  module_load_all();  // Let all modules take action before menu system handles the request  // We do not want this while running update.php.  if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {    module_invoke_all('init');  }}/** * Store the current page in the cache. * * We try to store a gzipped version of the cache. This requires the * PHP zlib extension (http://php.net/manual/en/ref.zlib.php). * Presence of the extension is checked by testing for the function * gzencode. There are two compression algorithms: gzip and deflate. * The majority of all modern browsers support gzip or both of them. * We thus only deal with the gzip variant and unzip the cache in case * the browser does not accept gzip encoding. * * @see drupal_page_header */function page_set_cache() {  global $user, $base_root;  if (!$user->uid && $_SERVER['REQUEST_METHOD'] == 'GET' && page_get_cache(TRUE)) {    // This will fail in some cases, see page_get_cache() for the explanation.    if ($data = ob_get_contents()) {      $cache = TRUE;      if (variable_get('page_compression', TRUE) && function_exists('gzencode')) {        // We do not store the data in case the zlib mode is deflate.        // This should be rarely happening.        if (zlib_get_coding_type() == 'deflate') {          $cache = FALSE;        }        else if (zlib_get_coding_type() == FALSE) {          $data = gzencode($data, 9, FORCE_GZIP);        }        // The remaining case is 'gzip' which means the data is        // already compressed and nothing left to do but to store it.      }      ob_end_flush();      if ($cache && $data) {        cache_set($base_root . request_uri(), $data, 'cache_page', CACHE_TEMPORARY, drupal_get_headers());      }    }  }}/** * Executes a cron run when called * @return * Returns TRUE if ran successfully */function drupal_cron_run() {  // Try to allocate enough time to run all the hook_cron implementations.  if (function_exists('set_time_limit')) {    @set_time_limit(240);  }  // Fetch the cron semaphore  $semaphore = variable_get('cron_semaphore', FALSE);  if ($semaphore) {    if (time() - $semaphore > 3600) {      // Either cron has been running for more than an hour or the semaphore      // was not reset due to a database error.      watchdog('cron', 'Cron has been running for more than an hour and is most likely stuck.', array(), WATCHDOG_ERROR);      // Release cron semaphore      variable_del('cron_semaphore');    }    else {      // Cron is still running normally.      watchdog('cron', 'Attempting to re-run cron while it is already running.', array(), WATCHDOG_WARNING);    }  }  else {    // Register shutdown callback    register_shutdown_function('drupal_cron_cleanup');    // Lock cron semaphore    variable_set('cron_semaphore', time());    // Iterate through the modules calling their cron handlers (if any):    module_invoke_all('cron');    // Record cron time    variable_set('cron_last', time());    watchdog('cron', 'Cron run completed.', array(), WATCHDOG_NOTICE);    // Release cron semaphore    variable_del('cron_semaphore');    // Return TRUE so other functions can check if it did run successfully    return TRUE;  }}/** * Shutdown function for cron cleanup. */function drupal_cron_cleanup() {  // See if the semaphore is still locked.  if (variable_get('cron_semaphore', FALSE)) {    watchdog('cron', 'Cron run exceeded the time limit and was aborted.', array(), WATCHDOG_WARNING);    // Release cron semaphore    variable_del('cron_semaphore');  }}/** * Return an array of system file objects. * * Returns an array of file objects of the given type from the site-wide * directory (i.e. modules/), the all-sites directory (i.e. * sites/all/modules/), the profiles directory, and site-specific directory * (i.e. sites/somesite/modules/). The returned array will be keyed using the * key specified (name, basename, filename). Using name or basename will cause * site-specific files to be prioritized over similar files in the default * directories. That is, if a file with the same name appears in both the * site-wide directory and site-specific directory, only the site-specific * version will be included. * * @param $mask *   The regular expression of the files to find. * @param $directory *   The subdirectory name in which the files are found. For example, *   'modules' will search in both modules/ and *   sites/somesite/modules/. * @param $key *   The key to be passed to file_scan_directory(). * @param $min_depth *   Minimum depth of directories to return files from. * * @return *   An array of file objects of the specified type. */function drupal_system_listing($mask, $directory, $key = 'name', $min_depth = 1) {  global $profile;  $config = conf_path();  // When this function is called during Drupal's initial installation process,  // the name of the profile that's about to be installed is stored in the global  // $profile variable. At all other times, the standard Drupal systems variable  // table contains the name of the current profile, and we can call variable_get()  // to determine what one is active.  if (!isset($profile)) {    $profile = variable_get('install_profile', 'default');  }  $searchdir = array($directory);  $files = array();  // The 'profiles' directory contains pristine collections of modules and  // themes as organized by a distribution.  It is pristine in the same way  // that /modules is pristine for core; users should avoid changing anything  // there in favor of sites/all or sites/<domain> directories.  if (file_exists("profiles/$profile/$directory")) {    $searchdir[] = "profiles/$profile/$directory";  }  // Always search sites/all/* as well as the global directories  $searchdir[] = 'sites/all/'. $directory;  if (file_exists("$config/$directory")) {    $searchdir[] = "$config/$directory";  }  // Get current list of items  foreach ($searchdir as $dir) {    $files = array_merge($files, file_scan_directory($dir, $mask, array('.', '..', 'CVS'), 0, TRUE, $key, $min_depth));  }  return $files;}/** * This dispatch function hands off structured Drupal arrays to type-specific * *_alter implementations. It ensures a consistent interface for all altering * operations. * * @param $type *   The data type of the structured array. 'form', 'links', *   'node_content', and so on are several examples. * @param $data *   The structured array to be altered. * @param ... *   Any additional params will be passed on to the called *   hook_$type_alter functions. */function drupal_alter($type, &$data) {  // PHP's func_get_args() always returns copies of params, not references, so  // drupal_alter() can only manipulate data that comes in via the required first  // param. For the edge case functions that must pass in an arbitrary number of  // alterable parameters (hook_form_alter() being the best example), an array of  // those params can be placed in the __drupal_alter_by_ref key of the $data  // array. This is somewhat ugly, but is an unavoidable consequence of a flexible  // drupal_alter() function, and the limitations of func_get_args().  // @todo: Remove this in Drupal 7.  if (is_array($data) && isset($data['__drupal_alter_by_ref'])) {    $by_ref_parameters = $data['__drupal_alter_by_ref'];    unset($data['__drupal_alter_by_ref']);  }  // Hang onto a reference to the data array so that it isn't blown away later.  // Also, merge in any parameters that need to be passed by reference.  $args = array(&$data);  if (isset($by_ref_parameters)) {    $args = array_merge($args, $by_ref_parameters);  }  // Now, use func_get_args() to pull in any additional parameters passed into  // the drupal_alter() call.  $additional_args = func_get_args();  array_shift($additional_args);  array_shift($additional_args);  $args = array_merge($args, $additional_args);  foreach (module_implements($type .'_alter') as $module) {    $function = $module .'_'. $type .'_alter';    call_user_func_array($function, $args);  }}/** * Renders HTML given a structured array tree. * * Recursively iterates over each of the array elements, generating HTML code. * This function is usually called from within a another function, like * drupal_get_form() or node_view(). * * @param $elements *   The structured array describing the data to be rendered. * @return *   The rendered HTML. */function drupal_render(&$elements) {  if (!isset($elements) || (isset($elements['#access']) && !$elements['#access'])) {    return NULL;  }  // If the default values for this element haven't been loaded yet, populate  // them.  if (!isset($elements['#defaults_loaded']) || !$elements['#defaults_loaded']) {    if ((!empty($elements['#type'])) && ($info = _element_info($elements['#type']))) {      $elements += $info;    }  }  // Make any final changes to the element before it is rendered. This means  // that the $element or the children can be altered or corrected before the  // element is rendered into the final text.  if (isset($elements['#pre_render'])) {    foreach ($elements['#pre_render'] as $function) {      if (function_exists($function)) {        $elements = $function($elements);      }    }  }  $content = '';  // Either the elements did not go through form_builder or one of the children  // has a #weight.  if (!isset($elements['#sorted'])) {    uasort($elements, "element_sort");  }  $elements += array('#title' => NULL, '#description' => NULL);  if (!isset($elements['#children'])) {    $children = element_children($elements);    // Render all the children that use a theme function.    if (isset($elements['#theme']) && empty($elements['#theme_used'])) {      $elements['#theme_used'] = TRUE;      $previous = array();      foreach (array('#value', '#type', '#prefix', '#suffix') as $key) {        $previous[$key] = isset($elements[$key]) ? $elements[$key] : NULL;      }      // If we rendered a single element, then we will skip the renderer.      if (empty($children)) {        $elements['#printed'] = TRUE;      }      else {        $elements['#value'] = '';      }      $elements['#type'] = 'markup';      unset($elements['#prefix'], $elements['#suffix']);      $content = theme($elements['#theme'], $elements);      foreach (array('#value', '#type', '#prefix', '#suffix') as $key) {        $elements[$key] = isset($previous[$key]) ? $previous[$key] : NULL;      }    }    // Render each of the children using drupal_render and concatenate them.    if (!isset($content) || $content === '') {      foreach ($children as $key) {        $content .= drupal_render($elements[$key]);      }    }  }  if (isset($content) && $content !== '') {    $elements['#children'] = $content;  }  // Until now, we rendered the children, here we render the element itself  if (!isset($elements['#printed'])) {    $content = theme(!empty($elements['#type']) ? $elements['#type'] : 'markup', $elements);    $elements['#printed'] = TRUE;  }  if (isset($content) && $content !== '') {    // Filter the outputted content and make any last changes before the    // content is sent to the browser. The changes are made on $content    // which allows the output'ed text to be filtered.    if (isset($elements['#post_render'])) {      foreach ($elements['#post_render'] as $function) {        if (function_exists($function)) {          $content = $function($content, $elements);        }      }    }    $prefix = isset($elements['#prefix']) ? $elements['#prefix'] : '';    $suffix = isset($elements['#suffix']) ? $elements['#suffix'] : '';    return $prefix . $content . $suffix;  }}/** * Function used by uasort to sort structured arrays by weight. */function element_sort($a, $b) {  $a_weight = (is_array($a) && isset($a['#weight'])) ? $a['#weight'] : 0;  $b_weight = (is_array($b) && isset($b['#weight'])) ? $b['#weight'] : 0;  if ($a_weight == $b_weight) {    return 0;  }  return ($a_weight < $b_weight) ? -1 : 1;}/** * Check if the key is a property. */function element_property($key) {  return $key[0] == '#';}/** * Get properties of a structured array element. Properties begin with '#'. */function element_properties($element) {  return array_filter(array_keys((array) $element), 'element_property');}/** * Check if the key is a child. */function element_child($key) {  return !isset($key[0]) || $key[0] != '#';}/** * Get keys of a structured array tree element that are not properties (i.e., do not begin with '#'). */function element_children($element) {  return array_filter(array_keys((array) $element), 'element_child');}/** * Provide theme registration for themes across .inc files. */function drupal_common_theme() {  return array(    // theme.inc    'placeholder' => array(      'arguments' => array('text' => NULL)    ),    'page' => array(      'arguments' => array('content' => NULL, 'show_blocks' => TRUE, 'show_messages' => TRUE),      'template' => 'page',    ),    'maintenance_page' => array(      'arguments' => array('content' => NULL, 'show_blocks' => TRUE, 'show_messages' => TRUE),      'template' => 'maintenance-page',    ),    'update_page' => array(      'arguments' => array('content' => NULL, 'show_messages' => TRUE),    ),    'install_page' => array(      'arguments' => array('content' => NULL),    ),    'task_list' => array(      'arguments' => array('items' => NULL, 'active' => NULL),    ),    'status_messages' => array(      'arguments' => array('display' => NULL),    ),    'links' => array(      'arguments' => array('links' => NULL, 'attributes' => array('class' => 'links')),    ),    'image' => array(      'arguments' => array('path' => NULL, 'alt' => '', 'title' => '', 'attributes' => NULL, 'getsize' => TRUE),    ),    'breadcrumb' => array(      'arguments' => array('breadcrumb' => NULL),    ),    'help' => array(      'arguments' => array(),    ),    'submenu' => array(      'arguments' => array('links' => NULL),    ),    'table' => array(      'arguments' => array('header' => NULL, 'rows' => NULL, 'attributes' => array(), 'caption' => NULL),    ),    'table_select_header_cell' => array(      'arguments' => array(),    ),    'tablesort_indicator' => array(      'arguments' => array('style' => NULL),    ),    'box' => array(      'arguments' => array('title' => NULL, 'content' => NULL, 'region' => 'main'),      'template' => 'box',    ),    'block' => array(      'arguments' => array('block' => NULL),      'template' => 'block',    ),    'mark' => array(      'arguments' => array('type' => MARK_NEW),    ),    'item_list' => array(      'arguments' => array('items' => array(), 'title' => NULL, 'type' => 'ul', 'attributes' => NULL),    ),    'more_help_link' => array(      'arguments' => array('url' => NULL),    ),    'xml_icon' => array(      'arguments' => array('url' => NULL),    ),    'feed_icon' => array(      'arguments' => array('url' => NULL, 'title' => NULL),    ),    'more_link' => array(      'arguments' => array('url' => NULL, 'title' => NULL)    ),    'closure' => array(      'arguments' => array('main' => 0),    ),    'blocks' => array(      'arguments' => array('region' => NULL),    ),    'username' => array(      'arguments' => array('object' => NULL),    ),    'progress_bar' => array(      'arguments' => array('percent' => NULL, 'message' => NULL),    ),    'indentation' => array(      'arguments' => array('size' => 1),    ),    // from pager.inc    'pager' => array(      'arguments' => array('tags' => array(), 'limit' => 10, 'element' => 0, 'parameters' => array()),    ),    'pager_first' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'parameters' => array()),    ),    'pager_previous' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'interval' => 1, 'parameters' => array()),    ),    'pager_next' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'interval' => 1, 'parameters' => array()),    ),    'pager_last' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'parameters' => array()),    ),    'pager_link' => array(      'arguments' => array('text' => NULL, 'page_new' => NULL, 'element' => NULL, 'parameters' => array(), 'attributes' => array()),    ),    // from locale.inc    'locale_admin_manage_screen' => array(      'arguments' => array('form' => NULL),    ),    // from menu.inc    'menu_item_link' => array(      'arguments' => array('item' => NULL),    ),    'menu_tree' => array(      'arguments' => array('tree' => NULL),    ),    'menu_item' => array(      'arguments' => array('link' => NULL, 'has_children' => NULL, 'menu' => ''),    ),    'menu_local_task' => array(      'arguments' => array('link' => NULL, 'active' => FALSE),    ),    'menu_local_tasks' => array(      'arguments' => array(),    ),    // from form.inc    'select' => array(      'arguments' => array('element' => NULL),    ),    'fieldset' => array(      'arguments' => array('element' => NULL),    ),    'radio' => array(      'arguments' => array('element' => NULL),    ),    'radios' => array(      'arguments' => array('element' => NULL),    ),    'password_confirm' => array(      'arguments' => array('element' => NULL),    ),    'date' => array(      'arguments' => array('element' => NULL),    ),    'item' => array(      'arguments' => array('element' => NULL),    ),    'checkbox' => array(      'arguments' => array('element' => NULL),    ),    'checkboxes' => array(      'arguments' => array('element' => NULL),    ),    'submit' => array(      'arguments' => array('element' => NULL),    ),    'button' => array(      'arguments' => array('element' => NULL),    ),    'image_button' => array(      'arguments' => array('element' => NULL),    ),    'hidden' => array(      'arguments' => array('element' => NULL),    ),    'token' => array(      'arguments' => array('element' => NULL),    ),    'textfield' => array(      'arguments' => array('element' => NULL),    ),    'form' => array(      'arguments' => array('element' => NULL),    ),    'textarea' => array(      'arguments' => array('element' => NULL),    ),    'markup' => array(      'arguments' => array('element' => NULL),    ),    'password' => array(      'arguments' => array('element' => NULL),    ),    'file' => array(      'arguments' => array('element' => NULL),    ),    'form_element' => array(      'arguments' => array('element' => NULL, 'value' => NULL),    ),  );}/** * @ingroup schemaapi * @{ *//** * Get the schema definition of a table, or the whole database schema. * * The returned schema will include any modifications made by any * module that implements hook_schema_alter(). * * @param $table *   The name of the table. If not given, the schema of all tables is returned. * @param $rebuild *   If true, the schema will be rebuilt instead of retrieved from the cache. */function drupal_get_schema($table = NULL, $rebuild = FALSE) {  static $schema = array();  if (empty($schema) || $rebuild) {    // Try to load the schema from cache.    if (!$rebuild && $cached = cache_get('schema')) {      $schema = $cached->data;    }    // Otherwise, rebuild the schema cache.    else {      $schema = array();      // Load the .install files to get hook_schema.      module_load_all_includes('install');      // Invoke hook_schema for all modules.      foreach (module_implements('schema') as $module) {        $current = module_invoke($module, 'schema');        _drupal_initialize_schema($module, $current);        $schema = array_merge($schema, $current);      }      drupal_alter('schema', $schema);      cache_set('schema', $schema);    }  }  if (!isset($table)) {    return $schema;  }  elseif (isset($schema[$table])) {    return $schema[$table];  }  else {    return FALSE;  }}/** * Create all tables that a module defines in its hook_schema(). * * Note: This function does not pass the module's schema through * hook_schema_alter(). The module's tables will be created exactly as the * module defines them. * * @param $module *   The module for which the tables will be created. * @return *   An array of arrays with the following key/value pairs: *    - success: a boolean indicating whether the query succeeded. *    - query: the SQL query(s) executed, passed through check_plain(). */function drupal_install_schema($module) {  $schema = drupal_get_schema_unprocessed($module);  _drupal_initialize_schema($module, $schema);  $ret = array();  foreach ($schema as $name => $table) {    db_create_table($ret, $name, $table);  }  return $ret;}/** * Remove all tables that a module defines in its hook_schema(). * * Note: This function does not pass the module's schema through * hook_schema_alter(). The module's tables will be created exactly as the * module defines them. * * @param $module *   The module for which the tables will be removed. * @return *   An array of arrays with the following key/value pairs: *    - success: a boolean indicating whether the query succeeded. *    - query: the SQL query(s) executed, passed through check_plain(). */function drupal_uninstall_schema($module) {  $schema = drupal_get_schema_unprocessed($module);  _drupal_initialize_schema($module, $schema);  $ret = array();  foreach ($schema as $table) {    db_drop_table($ret, $table['name']);  }  return $ret;}/** * Returns the unprocessed and unaltered version of a module's schema. * * Use this function only if you explicitly need the original * specification of a schema, as it was defined in a module's * hook_schema(). No additional default values will be set, * hook_schema_alter() is not invoked and these unprocessed * definitions won't be cached. * * This function can be used to retrieve a schema specification in * hook_schema(), so it allows you to derive your tables from existing * specifications. * * It is also used by drupal_install_schema() and * drupal_uninstall_schema() to ensure that a module's tables are * created exactly as specified without any changes introduced by a * module that implements hook_schema_alter(). * * @param $module *   The module to which the table belongs. * @param $table *   The name of the table. If not given, the module's complete schema *   is returned. */function drupal_get_schema_unprocessed($module, $table = NULL) {  // Load the .install file to get hook_schema.  module_load_include('install', $module);  $schema = module_invoke($module, 'schema');  if (!is_null($table) && isset($schema[$table])) {    return $schema[$table];  }  else {    return $schema;  }}/** * Fill in required default values for table definitions returned by hook_schema(). * * @param $module *   The module for which hook_schema() was invoked. * @param $schema *   The schema definition array as it was returned by the module's *   hook_schema(). */function _drupal_initialize_schema($module, &$schema) {  // Set the name and module key for all tables.  foreach ($schema as $name => $table) {    if (empty($table['module'])) {      $schema[$name]['module'] = $module;    }    if (!isset($table['name'])) {      $schema[$name]['name'] = $name;    }  }}/** * Retrieve a list of fields from a table schema. The list is suitable for use in a SQL query. * * @param $table *   The name of the table from which to retrieve fields. * @param *   An optional prefix to to all fields. * * @return An array of fields. **/function drupal_schema_fields_sql($table, $prefix = NULL) {  $schema = drupal_get_schema($table);  $fields = array_keys($schema['fields']);  if ($prefix) {    $columns = array();    foreach ($fields as $field) {      $columns[] = "$prefix.$field";    }    return $columns;  }  else {    return $fields;  }}/** * Save a record to the database based upon the schema. * * Default values are filled in for missing items, and 'serial' (auto increment) * types are filled in with IDs. * * @param $table *   The name of the table; this must exist in schema API. * @param $object *   The object to write. This is a reference, as defaults according to *   the schema may be filled in on the object, as well as ID on the serial *   type(s). Both array an object types may be passed. * @param $update *   If this is an update, specify the primary keys' field names. It is the *   caller's responsibility to know if a record for this object already *   exists in the database. If there is only 1 key, you may pass a simple string. * @return *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or *   SAVED_UPDATED is returned depending on the operation performed. The *   $object parameter contains values for any serial fields defined by *   the $table. For example, $object->nid will be populated after inserting *   a new node. */function drupal_write_record($table, &$object, $update = array()) {  // Standardize $update to an array.  if (is_string($update)) {    $update = array($update);  }  $schema = drupal_get_schema($table);  if (empty($schema)) {    return FALSE;  }  // Convert to an object if needed.  if (is_array($object)) {    $object = (object) $object;    $array = TRUE;  }  else {    $array = FALSE;  }  $fields = $defs = $values = $serials = $placeholders = array();  // Go through our schema, build SQL, and when inserting, fill in defaults for  // fields that are not set.  foreach ($schema['fields'] as $field => $info) {    // Special case -- skip serial types if we are updating.    if ($info['type'] == 'serial' && count($update)) {      continue;    }    // For inserts, populate defaults from Schema if not already provided    if (!isset($object->$field) && !count($update) && isset($info['default'])) {      $object->$field = $info['default'];    }    // Track serial fields so we can helpfully populate them after the query.    if ($info['type'] == 'serial') {      $serials[] = $field;      // Ignore values for serials when inserting data. Unsupported.      unset($object->$field);    }    // Build arrays for the fields, placeholders, and values in our query.    if (isset($object->$field)) {      $fields[] = $field;      $placeholders[] = db_type_placeholder($info['type']);      if (empty($info['serialize'])) {        $values[] = $object->$field;      }      else {        $values[] = serialize($object->$field);      }    }  }  // Build the SQL.  $query = '';  if (!count($update)) {    $query = "INSERT INTO {". $table ."} (". implode(', ', $fields) .') VALUES ('. implode(', ', $placeholders) .')';    $return = SAVED_NEW;  }  else {    $query = '';    foreach ($fields as $id => $field) {      if ($query) {        $query .= ', ';      }      $query .= $field .' = '. $placeholders[$id];    }    foreach ($update as $key){      $conditions[] = "$key = ". db_type_placeholder($schema['fields'][$key]['type']);      $values[] = $object->$key;    }    $query = "UPDATE {". $table ."} SET $query WHERE ". implode(' AND ', $conditions);    $return = SAVED_UPDATED;  }  // Execute the SQL.  if (db_query($query, $values)) {    if ($serials) {      // Get last insert ids and fill them in.      foreach ($serials as $field) {        $object->$field = db_last_insert_id($table, $field);      }    }  }  else {    $return = FALSE;  }  // If we began with an array, convert back so we don't surprise the caller.  if ($array) {    $object = (array) $object;  }  return $return;}/** * @} End of "ingroup schemaapi". *//** * Parse Drupal info file format. * * Files should use an ini-like format to specify values. * White-space generally doesn't matter, except inside values. * e.g. * * @code *   key = value *   key = "value" *   key = 'value' *   key = "multi-line * *   value" *   key = 'multi-line * *   value' *   key *   = *   'value' * @endcode * * Arrays are created using a GET-like syntax: * * @code *   key[] = "numeric array" *   key[index] = "associative array" *   key[index][] = "nested numeric array" *   key[index][index] = "nested associative array" * @endcode * * PHP constants are substituted in, but only when used as the entire value: * * Comments should start with a semi-colon at the beginning of a line. * * This function is NOT for placing arbitrary module-specific settings. Use * variable_get() and variable_set() for that. * * Information stored in the module.info file: * - name: The real name of the module for display purposes. * - description: A brief description of the module. * - dependencies: An array of shortnames of other modules this module depends on. * - package: The name of the package of modules this module belongs to. * * Example of .info file: * @code *   name = Forum *   description = Enables threaded discussions about general topics. *   dependencies[] = taxonomy *   dependencies[] = comment *   package = Core - optional *   version = VERSION * @endcode * * @param $filename *   The file we are parsing. Accepts file with relative or absolute path. * @return *   The info array. */function drupal_parse_info_file($filename) {  $info = array();  $constants = get_defined_constants();  if (!file_exists($filename)) {    return $info;  }  $data = file_get_contents($filename);  if (preg_match_all('    @^\s*                           # Start at the beginning of a line, ignoring leading whitespace    ((?:      [^=;\[\]]|                    # Key names cannot contain equal signs, semi-colons or square brackets,      \[[^\[\]]*\]                  # unless they are balanced and not nested    )+?)    \s*=\s*                         # Key/value pairs are separated by equal signs (ignoring white-space)    (?:      ("(?:[^"]|(?<=\\\\)")*")|     # Double-quoted string, which may contain slash-escaped quotes/slashes      (\'(?:[^\']|(?<=\\\\)\')*\')| # Single-quoted string, which may contain slash-escaped quotes/slashes      ([^\r\n]*?)                   # Non-quoted string    )\s*$                           # Stop at the next end of a line, ignoring trailing whitespace    @msx', $data, $matches, PREG_SET_ORDER)) {    foreach ($matches as $match) {      // Fetch the key and value string      $i = 0;      foreach (array('key', 'value1', 'value2', 'value3') as $var) {        $$var = isset($match[++$i]) ? $match[$i] : '';      }      $value = stripslashes(substr($value1, 1, -1)) . stripslashes(substr($value2, 1, -1)) . $value3;      // Parse array syntax      $keys = preg_split('/\]?\[/', rtrim($key, ']'));      $last = array_pop($keys);      $parent = &$info;      // Create nested arrays      foreach ($keys as $key) {        if ($key == '') {          $key = count($parent);        }        if (!isset($parent[$key]) || !is_array($parent[$key])) {          $parent[$key] = array();        }        $parent = &$parent[$key];      }      // Handle PHP constants.      if (isset($constants[$value])) {        $value = $constants[$value];      }      // Insert actual value      if ($last == '') {        $last = count($parent);      }      $parent[$last] = $value;    }  }  return $info;}/** * @return *   Array of the possible severity levels for log messages. * * @see watchdog */function watchdog_severity_levels() {  return array(    WATCHDOG_EMERG    => t('emergency'),    WATCHDOG_ALERT    => t('alert'),    WATCHDOG_CRITICAL => t('critical'),    WATCHDOG_ERROR    => t('error'),    WATCHDOG_WARNING  => t('warning'),    WATCHDOG_NOTICE   => t('notice'),    WATCHDOG_INFO     => t('info'),    WATCHDOG_DEBUG    => t('debug'),  );}/** * Explode a string of given tags into an array. */function drupal_explode_tags($tags) {  // This regexp allows the following types of user input:  // this, "somecompany, llc", "and ""this"" w,o.rks", foo bar  $regexp = '%(?:^|,\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^",]*))%x';  preg_match_all($regexp, $tags, $matches);  $typed_tags = array_unique($matches[1]);  $tags = array();  foreach ($typed_tags as $tag) {    // If a user has escaped a term (to demonstrate that it is a group,    // or includes a comma or quote character), we remove the escape    // formatting so to save the term into the database as the user intends.    $tag = trim(str_replace('""', '"', preg_replace('/^"(.*)"$/', '\1', $tag)));    if ($tag != "") {      $tags[] = $tag;    }  }  return $tags;}/** * Implode an array of tags into a string. */function drupal_implode_tags($tags) {  $encoded_tags = array();  foreach ($tags as $tag) {    // Commas and quotes in tag names are special cases, so encode them.    if (strpos($tag, ',') !== FALSE || strpos($tag, '"') !== FALSE) {      $tag = '"'. str_replace('"', '""', $tag) .'"';    }    $encoded_tags[] = $tag;  }  return implode(', ', $encoded_tags);}/** * Flush all cached data on the site. * * Empties cache tables, rebuilds the menu cache and theme registries, and * invokes a hook so that other modules' cache data can be cleared as well. */function drupal_flush_all_caches() {  // Change query-strings on css/js files to enforce reload for all users.  _drupal_flush_css_js();  drupal_clear_css_cache();  drupal_clear_js_cache();  // If invoked from update.php, we must not update the theme information in the  // database, or this will result in all themes being disabled.  if (defined('MAINTENANCE_MODE') && MAINTENANCE_MODE == 'update') {    _system_theme_data();  }  else {    system_theme_data();  }  drupal_rebuild_theme_registry();  menu_rebuild();  node_types_rebuild();  // Don't clear cache_form - in-progress form submissions may break.  // Ordered so clearing the page cache will always be the last action.  $core = array('cache', 'cache_block', 'cache_filter', 'cache_page');  $cache_tables = array_merge(module_invoke_all('flush_caches'), $core);  foreach ($cache_tables as $table) {    cache_clear_all('*', $table, TRUE);  }}/** * Helper function to change query-strings on css/js files. * * Changes the character added to all css/js files as dummy query-string, * so that all browsers are forced to reload fresh files. We keep * 20 characters history (FIFO) to avoid repeats, but only the first * (newest) character is actually used on urls, to keep them short. * This is also called from update.php. */function _drupal_flush_css_js() {  $string_history = variable_get('css_js_query_string', '00000000000000000000');  $new_character = $string_history[0];  // Not including 'q' to allow certain JavaScripts to re-use query string.  $characters = 'abcdefghijklmnoprstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';  while (strpos($string_history, $new_character) !== FALSE) {    $new_character = $characters[mt_rand(0, strlen($characters) - 1)];  }  variable_set('css_js_query_string', $new_character . substr($string_history, 0, 19));}
<?php// $Id$/** * Implementation of hook_install(). */function book_install() {  // Create tables.  drupal_install_schema('book');  // Add the node type.  _book_install_type_create();}/** * Implementation of hook_uninstall(). */function book_uninstall() {  // Delete menu links.  db_query("DELETE FROM {menu_links} WHERE module = 'book'");  menu_cache_clear_all();  // Remove tables.  drupal_uninstall_schema('book');}function _book_install_type_create() {  // Create an additional node type  $book_node_type = array(    'type' => 'book',    'name' => t('Book page'),    'module' => 'node',    'description' => t('A <em>book page</em> is a page of content, organized into a collection of related entries collectively known as a <em>book</em>. A <em>book page</em> automatically displays links to adjacent pages, providing a simple navigation system for organizing and reviewing structured content.'),    'custom' => TRUE,    'modified' => TRUE,    'locked' => FALSE,  );  $book_node_type = (object)_node_type_set_defaults($book_node_type);  node_type_save($book_node_type);  // Default to not promoted.  variable_set('node_options_book', array('status'));  // Use this default type for adding content to books.  variable_set('book_allowed_types', array('book'));  variable_set('book_child_type', 'book');}/** * Drupal 5.x to 6.x update. * * This function moves any existing book hierarchy into the new structure used * in the 6.x module.  Rather than storing the hierarchy in the {book} table, * the menu API is used to store the hierarchy in the {menu_links} table and the * {book} table serves to uniquely connect a node to a menu link. * * In order to accomplish this, the current hierarchy is processed using a stack. * The stack insures that each parent is processed before any of its children * in the book hierarchy, and is compatible with batched update processing. * */function book_update_6000() {  $ret = array();  // Set up for a multi-part update.  if (!isset($_SESSION['book_update_6000'])) {    $schema['book'] = array(      'fields' => array(        'mlid'    => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'nid'     => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'bid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      ),      'primary key' => array('mlid'),      'unique keys' => array(        'nid' => array('nid'),      ),      'indexes' => array(        'bid' => array('bid'),      ),    );    // Add the node type.    _book_install_type_create();    // Fix role permissions to account for the changed names    // Setup the array holding strings to match and the corresponding    // strings to replace them with.    $replace = array(      'outline posts in books' => 'administer book outlines',      'create book pages' => 'create book content',      'edit book pages' => 'edit any book content',      'edit own book pages' => 'edit own book content',      'see printer-friendly version' => 'access printer-friendly version',    );    // Loop over all the roles, and do the necessary transformations.    $query = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");    while ($role = db_fetch_object($query)) {      // Replace all the old permissions with the corresponding new permissions.      $fixed_perm = strtr($role->perm, $replace);      // If the user could previously create book pages, they should get the new      // 'add content to books' permission.      if (strpos($role->perm, 'create book pages') !== FALSE) {        $fixed_perm .= ', add content to books';      }      // Only save if the permissions have changed.      if ($fixed_perm != $role->perm) {        $ret[] = update_sql("UPDATE {permission} SET perm = '$fixed_perm' WHERE rid = $role->rid");      }    }    // Determine whether there are any existing nodes in the book hierarchy.    if (db_result(db_query("SELECT COUNT(*) FROM {book}"))) {      // Temporary table for the old book hierarchy; we'll discard revision info.      $schema['book_temp'] = array(        'fields' => array(          'nid'    => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),          'parent' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),          'weight' => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'tiny')        ),        'indexes' => array(          'parent' => array('parent')        ),        'primary key' => array('nid'),      );      db_create_table($ret, 'book_temp', $schema['book_temp']);      // Insert each node in the old table into the temporary table.      $ret[] = update_sql("INSERT INTO {book_temp} (nid, parent, weight) SELECT b.nid, b.parent, b.weight FROM {book} b INNER JOIN {node} n on b.vid = n.vid");      $ret[] = update_sql("DROP TABLE {book}");      db_create_table($ret, 'book', $schema['book']);      $_SESSION['book_update_6000_orphans']['from'] = 0;      $_SESSION['book_update_6000'] = array();      $result = db_query("SELECT * from {book_temp} WHERE parent = 0");      // Collect all books - top-level nodes.      while ($a = db_fetch_array($result)) {        $_SESSION['book_update_6000'][] = $a;      }      $ret['#finished'] = FALSE;      return $ret;    }    else {      // No exising nodes in the hierarchy, so drop the table and re-create it.      $ret[] = update_sql("DROP TABLE {book}");      db_create_table($ret, 'book', $schema['book']);      return $ret;    }  }  elseif ($_SESSION['book_update_6000_orphans']) {    // Do the first batched part of the update - collect orphans.    $update_count = 400; // Update this many at a time    $result = db_query_range("SELECT * FROM {book_temp}", $_SESSION['book_update_6000_orphans']['from'], $update_count);    $has_rows = FALSE;    // Go through the next $update_count book pages and locate the orphans.    while ($book = db_fetch_array($result)) {      $has_rows = TRUE;      // Orphans are defined as nodes whose parent does not exist in the table.      if ($book['parent'] && !db_result(db_query("SELECT COUNT(*) FROM {book_temp} WHERE nid = %d", $book['parent']))) {        if (empty($_SESSION['book_update_6000_orphans']['book'])) {          // The first orphan becomes the parent for all other orphans.          $book['parent'] = 0;          $_SESSION['book_update_6000_orphans']['book'] = $book;          $ret[] = array('success' => TRUE, 'query' => 'Relocated orphan book pages.');        }        else {          // Re-assign the parent value of the book, and add it to the stack.          $book['parent'] = $_SESSION['book_update_6000_orphans']['book']['nid'];          $_SESSION['book_update_6000'][] = $book;        }      }    }    if ($has_rows) {      $_SESSION['book_update_6000_orphans']['from'] += $update_count;    }    else {      // Done with this part      if (!empty($_SESSION['book_update_6000_orphans']['book'])) {        // The orphans' parent is added last, so it will be processed first.        $_SESSION['book_update_6000'][] = $_SESSION['book_update_6000_orphans']['book'];      }      $_SESSION['book_update_6000_orphans'] = FALSE;    }    $ret['#finished'] = FALSE;    return $ret;  }  else {    // Do the next batched part of the update    $update_count = 100; // Update this many at a time    while ($update_count && $_SESSION['book_update_6000']) {      // Get the last node off the stack.      $book = array_pop($_SESSION['book_update_6000']);      // Add all of this node's children to the stack      $result = db_query("SELECT * FROM {book_temp} WHERE parent = %d", $book['nid']);      while ($a = db_fetch_array($result)) {        $_SESSION['book_update_6000'][] = $a;      }      if ($book['parent']) {        // If its not a top level page, get its parent's mlid.        $parent = db_fetch_array(db_query("SELECT b.mlid AS plid, b.bid FROM {book} b WHERE b.nid = %d", $book['parent']));        $book = array_merge($book, $parent);      }      else {        // There is not a parent - this is a new book.        $book['plid'] = 0;        $book['bid'] = $book['nid'];      }      $book += array(        'module' => 'book',        'link_path' => 'node/'. $book['nid'],        'router_path' => 'node/%',        'menu_name' => 'book-toc-'. $book['bid'],      );      $book = array_merge($book, db_fetch_array(db_query("SELECT title AS link_title FROM {node} WHERE nid = %d", $book['nid'])));      // Items with depth > MENU_MAX_DEPTH cannot be saved.      if (menu_link_save($book)) {        db_query("INSERT INTO {book} (mlid, nid, bid) VALUES (%d, %d, %d)", $book['mlid'], $book['nid'], $book['bid']);      }      else {        // The depth was greater then MENU_MAX_DEPTH, so attach it to the        // closest valid parent.        $book['plid'] = db_result(db_query("SELECT plid FROM {menu_links} WHERE mlid = %d", $book['plid']));        if (menu_link_save($book)) {          db_query("INSERT INTO {book} (mlid, nid, bid) VALUES (%d, %d, %d)", $book['mlid'], $book['nid'], $book['bid']);        }      }      $update_count--;    }    $ret['#finished'] = FALSE;  }  if (empty($_SESSION['book_update_6000'])) {    $ret['#finished'] = TRUE;    $ret[] = array('success' => TRUE, 'query' => 'Relocated existing book pages.');    $ret[] = update_sql("DROP TABLE {book_temp}");    unset($_SESSION['book_update_6000']);    unset($_SESSION['book_update_6000_orphans']);  }  return $ret;}/** * Implementation of hook_schema(). */function book_schema() {  $schema['book'] = array(  'description' => 'Stores book outline information. Uniquely connects each node in the outline to a link in {menu_links}',    'fields' => array(      'mlid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book page's {menu_links}.mlid.",      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book page's {node}.nid.",      ),      'bid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book ID is the {book}.nid of the top-level page.",      ),    ),    'primary key' => array('mlid'),    'unique keys' => array(      'nid' => array('nid'),    ),    'indexes' => array(      'bid' => array('bid'),    ),  );  return $schema;}
<?php// $Id$/** * @file * Enables the organization of content into categories. *//** * Implementation of hook_perm(). */function taxonomy_perm() {  return array('administer taxonomy');}/** * Implementation of hook_theme() */function taxonomy_theme() {  return array(    'taxonomy_term_select' => array(      'arguments' => array('element' => NULL),    ),    'taxonomy_term_page' => array(      'arguments' => array('tids' => array(), 'result' => NULL),    ),    'taxonomy_overview_vocabularies' => array(      'arguments' => array('form' => array()),    ),    'taxonomy_overview_terms' => array(      'arguments' => array('form' => array()),    ),  );}/** * Implementation of hook_link(). * * This hook is extended with $type = 'taxonomy terms' to allow themes to * print lists of terms associated with a node. Themes can print taxonomy * links with: * * if (module_exists('taxonomy')) { *   $terms = taxonomy_link('taxonomy terms', $node); *   print theme('links', $terms); * } */function taxonomy_link($type, $node = NULL) {  if ($type == 'taxonomy terms' && $node != NULL) {    $links = array();    // If previewing, the terms must be converted to objects first.    if (isset($node->build_mode) && $node->build_mode == NODE_BUILD_PREVIEW) {      $node->taxonomy = taxonomy_preview_terms($node);    }    if (!empty($node->taxonomy)) {      foreach ($node->taxonomy as $term) {        // During preview the free tagging terms are in an array unlike the        // other terms which are objects. So we have to check if a $term        // is an object or not.        if (is_object($term)) {          $links['taxonomy_term_'. $term->tid] = array(            'title' => $term->name,            'href' => taxonomy_term_path($term),            'attributes' => array('rel' => 'tag', 'title' => strip_tags($term->description))          );        }        // Previewing free tagging terms; we don't link them because the        // term-page might not exist yet.        else {          foreach ($term as $free_typed) {            $typed_terms = drupal_explode_tags($free_typed);            foreach ($typed_terms as $typed_term) {              $links['taxonomy_preview_term_'. $typed_term] = array(                'title' => $typed_term,              );            }          }        }      }    }    // We call this hook again because some modules and themes    // call taxonomy_link('taxonomy terms') directly.    drupal_alter('link', $links, $node);    return $links;  }}/** * For vocabularies not maintained by taxonomy.module, give the maintaining * module a chance to provide a path for terms in that vocabulary. * * @param $term *   A term object. * @return *   An internal Drupal path. */function taxonomy_term_path($term) {  $vocabulary = taxonomy_vocabulary_load($term->vid);  if ($vocabulary->module != 'taxonomy' && $path = module_invoke($vocabulary->module, 'term_path', $term)) {    return $path;  }  return 'taxonomy/term/'. $term->tid;}/** * Implementation of hook_menu(). */function taxonomy_menu() {  $items['admin/content/taxonomy'] = array(    'title' => 'Taxonomy',    'description' => 'Manage tagging, categorization, and classification of your content.',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_overview_vocabularies'),    'access arguments' => array('administer taxonomy'),    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/taxonomy/add/vocabulary'] = array(    'title' => 'Add vocabulary',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_form_vocabulary'),    'access arguments' => array('administer taxonomy'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/taxonomy',    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/edit/vocabulary/%taxonomy_vocabulary'] = array(    'title' => 'Edit vocabulary',    'page callback' => 'taxonomy_admin_vocabulary_edit',    'page arguments' => array(5),    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/edit/term'] = array(    'title' => 'Edit term',    'page callback' => 'taxonomy_admin_term_edit',    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['taxonomy/term/%'] = array(    'title' => 'Taxonomy term',    'page callback' => 'taxonomy_term_page',    'page arguments' => array(2),    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.pages.inc',  );  $items['taxonomy/autocomplete'] = array(    'title' => 'Autocomplete taxonomy',    'page callback' => 'taxonomy_autocomplete',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.pages.inc',  );  $items['admin/content/taxonomy/%taxonomy_vocabulary'] = array(    'title' => 'List terms',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_overview_terms', 3),    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/%taxonomy_vocabulary/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/taxonomy/%taxonomy_vocabulary/add/term'] = array(    'title' => 'Add term',    'page callback' => 'taxonomy_add_term_page',    'page arguments' => array(3),    'access arguments' => array('administer taxonomy'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/taxonomy/%taxonomy_vocabulary',    'file' => 'taxonomy.admin.inc',  );  return $items;}function taxonomy_save_vocabulary(&$edit) {  $edit['nodes'] = empty($edit['nodes']) ? array() : $edit['nodes'];  if (!isset($edit['module'])) {    $edit['module'] = 'taxonomy';  }  if (!empty($edit['vid']) && !empty($edit['name'])) {    drupal_write_record('vocabulary', $edit, 'vid');    db_query("DELETE FROM {vocabulary_node_types} WHERE vid = %d", $edit['vid']);    foreach ($edit['nodes'] as $type => $selected) {      db_query("INSERT INTO {vocabulary_node_types} (vid, type) VALUES (%d, '%s')", $edit['vid'], $type);    }    module_invoke_all('taxonomy', 'update', 'vocabulary', $edit);    $status = SAVED_UPDATED;  }  else if (!empty($edit['vid'])) {    $status = taxonomy_del_vocabulary($edit['vid']);  }  else {    drupal_write_record('vocabulary', $edit);    foreach ($edit['nodes'] as $type => $selected) {      db_query("INSERT INTO {vocabulary_node_types} (vid, type) VALUES (%d, '%s')", $edit['vid'], $type);    }    module_invoke_all('taxonomy', 'insert', 'vocabulary', $edit);    $status = SAVED_NEW;  }  cache_clear_all();  return $status;}/** * Delete a vocabulary. * * @param $vid *   A vocabulary ID. * @return *   Constant indicating items were deleted. */function taxonomy_del_vocabulary($vid) {  $vocabulary = (array) taxonomy_vocabulary_load($vid);  db_query('DELETE FROM {vocabulary} WHERE vid = %d', $vid);  db_query('DELETE FROM {vocabulary_node_types} WHERE vid = %d', $vid);  $result = db_query('SELECT tid FROM {term_data} WHERE vid = %d', $vid);  while ($term = db_fetch_object($result)) {    taxonomy_del_term($term->tid);  }  module_invoke_all('taxonomy', 'delete', 'vocabulary', $vocabulary);  cache_clear_all();  return SAVED_DELETED;}/** * Dynamically check and update the hierarachy flag of a vocabulary. * * Checks the current parents of all terms in a vocabulary and updates the * vocabularies hierarchy setting to the lowest possible level. A hierarchy with * no parents in any of its terms will be given a hierarchy of 0. If terms * contain at most a single parent, the vocabulary will be given a hierarchy of * 1. If any term contain multiple parents, the vocabulary will be given a * hieararchy of 2. * * @param $vocabulary *   An array of the vocabulary structure. * @param $changed_term *   An array of the term structure that was updated. */function taxonomy_check_vocabulary_hierarchy($vocabulary, $changed_term) {  $tree = taxonomy_get_tree($vocabulary['vid']);  $hierarchy = 0;  foreach ($tree as $term) {    // Update the changed term with the new parent value before comparision.    if ($term->tid == $changed_term['tid']) {      $term = (object)$changed_term;      $term->parents = $term->parent;    }    // Check this term's parent count.    if (count($term->parents) > 1) {      $hierarchy = 2;      break;    }    elseif (count($term->parents) == 1 && 0 !== array_shift($term->parents)) {      $hierarchy = 1;    }  }  if ($hierarchy != $vocabulary['hierarchy']) {    $vocabulary['hierarchy'] = $hierarchy;    taxonomy_save_vocabulary($vocabulary);  }  return $hierarchy;}/** * Helper function for taxonomy_form_term_submit(). * * @param $form_state['values'] * @return *   Status constant indicating if term was inserted or updated. */function taxonomy_save_term(&$form_values) {  $form_values += array(    'description' => '',    'weight' => 0  );  if (!empty($form_values['tid']) && $form_values['name']) {    drupal_write_record('term_data', $form_values, 'tid');    $hook = 'update';    $status = SAVED_UPDATED;  }  else if (!empty($form_values['tid'])) {    return taxonomy_del_term($form_values['tid']);  }  else {    drupal_write_record('term_data', $form_values);    $hook = 'insert';    $status = SAVED_NEW;  }  db_query('DELETE FROM {term_relation} WHERE tid1 = %d OR tid2 = %d', $form_values['tid'], $form_values['tid']);  if (!empty($form_values['relations'])) {    foreach ($form_values['relations'] as $related_id) {      if ($related_id != 0) {        db_query('INSERT INTO {term_relation} (tid1, tid2) VALUES (%d, %d)', $form_values['tid'], $related_id);      }    }  }  db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $form_values['tid']);  if (!isset($form_values['parent']) || empty($form_values['parent'])) {    $form_values['parent'] = array(0);  }  if (is_array($form_values['parent'])) {    foreach ($form_values['parent'] as $parent) {      if (is_array($parent)) {        foreach ($parent as $tid) {          db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $tid);        }      }      else {        db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $parent);      }    }  }  else {    db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $form_values['parent']);  }  db_query('DELETE FROM {term_synonym} WHERE tid = %d', $form_values['tid']);  if (!empty($form_values['synonyms'])) {    foreach (explode ("\n", str_replace("\r", '', $form_values['synonyms'])) as $synonym) {      if ($synonym) {        db_query("INSERT INTO {term_synonym} (tid, name) VALUES (%d, '%s')", $form_values['tid'], chop($synonym));      }    }  }  if (isset($hook)) {    module_invoke_all('taxonomy', $hook, 'term', $form_values);  }  cache_clear_all();  return $status;}/** * Delete a term. * * @param $tid *   The term ID. * @return *   Status constant indicating deletion. */function taxonomy_del_term($tid) {  $tids = array($tid);  while ($tids) {    $children_tids = $orphans = array();    foreach ($tids as $tid) {      // See if any of the term's children are about to be become orphans:      if ($children = taxonomy_get_children($tid)) {        foreach ($children as $child) {          // If the term has multiple parents, we don't delete it.          $parents = taxonomy_get_parents($child->tid);          if (count($parents) == 1) {            $orphans[] = $child->tid;          }        }      }      $term = (array) taxonomy_get_term($tid);      db_query('DELETE FROM {term_data} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_relation} WHERE tid1 = %d OR tid2 = %d', $tid, $tid);      db_query('DELETE FROM {term_synonym} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_node} WHERE tid = %d', $tid);      module_invoke_all('taxonomy', 'delete', 'term', $term);    }    $tids = $orphans;  }  cache_clear_all();  return SAVED_DELETED;}/** * Generate a form element for selecting terms from a vocabulary. */function taxonomy_form($vid, $value = 0, $help = NULL, $name = 'taxonomy') {  $vocabulary = taxonomy_vocabulary_load($vid);  $help = ($help) ? $help : filter_xss_admin($vocabulary->help);  if (!$vocabulary->multiple) {    $blank = ($vocabulary->required) ? t('- Please choose -') : t('- None selected -');  }  else {    $blank = ($vocabulary->required) ? 0 : t('- None -');  }  return _taxonomy_term_select(check_plain($vocabulary->name), $name, $value, $vid, $help, intval($vocabulary->multiple), $blank);}/** * Generate a set of options for selecting a term from all vocabularies. */function taxonomy_form_all($free_tags = 0) {  $vocabularies = taxonomy_get_vocabularies();  $options = array();  foreach ($vocabularies as $vid => $vocabulary) {    if ($vocabulary->tags && !$free_tags) { continue; }    $tree = taxonomy_get_tree($vid);    if ($tree && (count($tree) > 0)) {      $options[$vocabulary->name] = array();      foreach ($tree as $term) {        $options[$vocabulary->name][$term->tid] = str_repeat('-', $term->depth) . $term->name;      }    }  }  return $options;}/** * Return an array of all vocabulary objects. * * @param $type *   If set, return only those vocabularies associated with this node type. */function taxonomy_get_vocabularies($type = NULL) {  if ($type) {    $result = db_query(db_rewrite_sql("SELECT v.vid, v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s' ORDER BY v.weight, v.name", 'v', 'vid'), $type);  }  else {    $result = db_query(db_rewrite_sql('SELECT v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid ORDER BY v.weight, v.name', 'v', 'vid'));  }  $vocabularies = array();  $node_types = array();  while ($voc = db_fetch_object($result)) {    // If no node types are associated with a vocabulary, the LEFT JOIN will    // return a NULL value for type.    if (isset($voc->type)) {      $node_types[$voc->vid][$voc->type] = $voc->type;      unset($voc->type);      $voc->nodes = $node_types[$voc->vid];    }    elseif (!isset($voc->nodes)) {      $voc->nodes = array();    }    $vocabularies[$voc->vid] = $voc;  }  return $vocabularies;}/** * Implementation of hook_form_alter(). * Generate a form for selecting terms to associate with a node. * We check for taxonomy_override_selector before loading the full * vocabulary, so contrib modules can intercept before hook_form_alter *  and provide scalable alternatives. */function taxonomy_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && (!variable_get('taxonomy_override_selector', FALSE)) && $form['type']['#value'] .'_node_form' == $form_id) {    $node = $form['#node'];    if (!isset($node->taxonomy)) {      $terms = empty($node->nid) ? array() : taxonomy_node_get_terms($node);    }    else {      // After preview the terms must be converted to objects.      if (isset($form_state['node_preview'])) {        $node->taxonomy = taxonomy_preview_terms($node);      }      $terms = $node->taxonomy;    }    $c = db_query(db_rewrite_sql("SELECT v.* FROM {vocabulary} v INNER JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s' ORDER BY v.weight, v.name", 'v', 'vid'), $node->type);    while ($vocabulary = db_fetch_object($c)) {      if ($vocabulary->tags) {        if (isset($form_state['node_preview'])) {          // Typed string can be changed by the user before preview,          // so we just insert the tags directly as provided in the form.          $typed_string = $node->taxonomy['tags'][$vocabulary->vid];        }        else {          $typed_string = taxonomy_implode_tags($terms, $vocabulary->vid) . (array_key_exists('tags', $terms) ? $terms['tags'][$vocabulary->vid] : NULL);        }        if ($vocabulary->help) {          $help = filter_xss_admin($vocabulary->help);        }        else {          $help = t('A comma-separated list of terms describing this content. Example: funny, bungee jumping, "Company, Inc.".');        }        $form['taxonomy']['tags'][$vocabulary->vid] = array('#type' => 'textfield',          '#title' => $vocabulary->name,          '#description' => $help,          '#required' => $vocabulary->required,          '#default_value' => $typed_string,          '#autocomplete_path' => 'taxonomy/autocomplete/'. $vocabulary->vid,          '#weight' => $vocabulary->weight,          '#maxlength' => 1024,        );      }      else {        // Extract terms belonging to the vocabulary in question.        $default_terms = array();        foreach ($terms as $term) {          // Free tagging has no default terms and also no vid after preview.          if (isset($term->vid) && $term->vid == $vocabulary->vid) {            $default_terms[$term->tid] = $term;          }        }        $form['taxonomy'][$vocabulary->vid] = taxonomy_form($vocabulary->vid, array_keys($default_terms), filter_xss_admin($vocabulary->help));        $form['taxonomy'][$vocabulary->vid]['#weight'] = $vocabulary->weight;        $form['taxonomy'][$vocabulary->vid]['#required'] = $vocabulary->required;      }    }    if (!empty($form['taxonomy']) && is_array($form['taxonomy'])) {      if (count($form['taxonomy']) > 1) {        // Add fieldset only if form has more than 1 element.        $form['taxonomy'] += array(          '#type' => 'fieldset',          '#title' => t('Vocabularies'),          '#collapsible' => TRUE,          '#collapsed' => FALSE,        );      }      $form['taxonomy']['#weight'] = -3;      $form['taxonomy']['#tree'] = TRUE;    }  }}/** * Helper function to convert terms after a preview. * * After preview the tags are an array instead of proper objects. This function * converts them back to objects with the exception of 'free tagging' terms, * because new tags can be added by the user before preview and those do not * yet exist in the database. We therefore save those tags as a string so * we can fill the form again after the preview. */function taxonomy_preview_terms($node) {  $taxonomy = array();  if (isset($node->taxonomy)) {    foreach ($node->taxonomy as $key => $term) {      unset($node->taxonomy[$key]);      // A 'Multiple select' and a 'Free tagging' field returns an array.      if (is_array($term)) {        foreach ($term as $tid) {          if ($key == 'tags') {            // Free tagging; the values will be saved for later as strings            // instead of objects to fill the form again.            $taxonomy['tags'] = $term;          }          else {            $taxonomy[$tid] = taxonomy_get_term($tid);          }        }      }      // A 'Single select' field returns the term id.      elseif ($term) {        $taxonomy[$term] = taxonomy_get_term($term);      }    }  }  return $taxonomy;}/** * Find all terms associated with the given node, within one vocabulary. */function taxonomy_node_get_terms_by_vocabulary($node, $vid, $key = 'tid') {  $result = db_query(db_rewrite_sql('SELECT t.tid, t.* FROM {term_data} t INNER JOIN {term_node} r ON r.tid = t.tid WHERE t.vid = %d AND r.vid = %d ORDER BY weight', 't', 'tid'), $vid, $node->vid);  $terms = array();  while ($term = db_fetch_object($result)) {    $terms[$term->$key] = $term;  }  return $terms;}/** * Find all terms associated with the given node, ordered by vocabulary and term weight. */function taxonomy_node_get_terms($node, $key = 'tid') {  static $terms;  if (!isset($terms[$node->vid][$key])) {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_node} r INNER JOIN {term_data} t ON r.tid = t.tid INNER JOIN {vocabulary} v ON t.vid = v.vid WHERE r.vid = %d ORDER BY v.weight, t.weight, t.name', 't', 'tid'), $node->vid);    $terms[$node->vid][$key] = array();    while ($term = db_fetch_object($result)) {      $terms[$node->vid][$key][$term->$key] = $term;    }  }  return $terms[$node->vid][$key];}/** * Make sure incoming vids are free tagging enabled. */function taxonomy_node_validate(&$node) {  if (!empty($node->taxonomy)) {    $terms = $node->taxonomy;    if (!empty($terms['tags'])) {      foreach ($terms['tags'] as $vid => $vid_value) {        $vocabulary = taxonomy_vocabulary_load($vid);        if (empty($vocabulary->tags)) {          // see form_get_error $key = implode('][', $element['#parents']);          // on why this is the key          form_set_error("taxonomy][tags][$vid", t('The %name vocabulary can not be modified in this way.', array('%name' => $vocabulary->name)));        }      }    }  }}/** * Save term associations for a given node. */function taxonomy_node_save($node, $terms) {  taxonomy_node_delete_revision($node);  // Free tagging vocabularies do not send their tids in the form,  // so we'll detect them here and process them independently.  if (isset($terms['tags'])) {    $typed_input = $terms['tags'];    unset($terms['tags']);    foreach ($typed_input as $vid => $vid_value) {      $typed_terms = drupal_explode_tags($vid_value);      $inserted = array();      foreach ($typed_terms as $typed_term) {        // See if the term exists in the chosen vocabulary        // and return the tid; otherwise, add a new record.        $possibilities = taxonomy_get_term_by_name($typed_term);        $typed_term_tid = NULL; // tid match, if any.        foreach ($possibilities as $possibility) {          if ($possibility->vid == $vid) {            $typed_term_tid = $possibility->tid;          }        }        if (!$typed_term_tid) {          $edit = array('vid' => $vid, 'name' => $typed_term);          $status = taxonomy_save_term($edit);          $typed_term_tid = $edit['tid'];        }        // Defend against duplicate, differently cased tags        if (!isset($inserted[$typed_term_tid])) {          db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $typed_term_tid);          $inserted[$typed_term_tid] = TRUE;        }      }    }  }  if (is_array($terms)) {    foreach ($terms as $term) {      if (is_array($term)) {        foreach ($term as $tid) {          if ($tid) {            db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $tid);          }        }      }      else if (is_object($term)) {        db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $term->tid);      }      else if ($term) {        db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $term);      }    }  }}/** * Remove associations of a node to its terms. */function taxonomy_node_delete($node) {  db_query('DELETE FROM {term_node} WHERE nid = %d', $node->nid);}/** * Remove associations of a node to its terms. */function taxonomy_node_delete_revision($node) {  db_query('DELETE FROM {term_node} WHERE vid = %d', $node->vid);}/** * Implementation of hook_node_type(). */function taxonomy_node_type($op, $info) {  if ($op == 'update' && !empty($info->old_type) && $info->type != $info->old_type) {    db_query("UPDATE {vocabulary_node_types} SET type = '%s' WHERE type = '%s'", $info->type, $info->old_type);  }  elseif ($op == 'delete') {    db_query("DELETE FROM {vocabulary_node_types} WHERE type = '%s'", $info->type);  }}/** * Find all term objects related to a given term ID. */function taxonomy_get_related($tid, $key = 'tid') {  if ($tid) {    $result = db_query('SELECT t.*, tid1, tid2 FROM {term_relation}, {term_data} t WHERE (t.tid = tid1 OR t.tid = tid2) AND (tid1 = %d OR tid2 = %d) AND t.tid != %d ORDER BY weight, name', $tid, $tid, $tid);    $related = array();    while ($term = db_fetch_object($result)) {      $related[$term->$key] = $term;    }    return $related;  }  else {    return array();  }}/** * Find all parents of a given term ID. */function taxonomy_get_parents($tid, $key = 'tid') {  if ($tid) {    $result = db_query(db_rewrite_sql('SELECT t.tid, t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.parent = t.tid WHERE h.tid = %d ORDER BY weight, name', 't', 'tid'), $tid);    $parents = array();    while ($parent = db_fetch_object($result)) {      $parents[$parent->$key] = $parent;    }    return $parents;  }  else {    return array();  }}/** * Find all ancestors of a given term ID. */function taxonomy_get_parents_all($tid) {  $parents = array();  if ($tid) {    $parents[] = taxonomy_get_term($tid);    $n = 0;    while ($parent = taxonomy_get_parents($parents[$n]->tid)) {      $parents = array_merge($parents, $parent);      $n++;    }  }  return $parents;}/** * Find all children of a term ID. */function taxonomy_get_children($tid, $vid = 0, $key = 'tid') {  if ($vid) {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.tid = t.tid WHERE t.vid = %d AND h.parent = %d ORDER BY weight, name', 't', 'tid'), $vid, $tid);  }  else {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.tid = t.tid WHERE parent = %d ORDER BY weight, name', 't', 'tid'), $tid);  }  $children = array();  while ($term = db_fetch_object($result)) {    $children[$term->$key] = $term;  }  return $children;}/** * Create a hierarchical representation of a vocabulary. * * @param $vid *   Which vocabulary to generate the tree for. * * @param $parent *   The term ID under which to generate the tree. If 0, generate the tree *   for the entire vocabulary. * * @param $depth *   Internal use only. * * @param $max_depth *   The number of levels of the tree to return. Leave NULL to return all levels. * * @return *   An array of all term objects in the tree. Each term object is extended *   to have "depth" and "parents" attributes in addition to its normal ones. *   Results are statically cached. */function taxonomy_get_tree($vid, $parent = 0, $depth = -1, $max_depth = NULL) {  static $children, $parents, $terms;  $depth++;  // We cache trees, so it's not CPU-intensive to call get_tree() on a term  // and its children, too.  if (!isset($children[$vid])) {    $children[$vid] = array();    $result = db_query(db_rewrite_sql('SELECT t.tid, t.*, parent FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE t.vid = %d ORDER BY weight, name', 't', 'tid'), $vid);    while ($term = db_fetch_object($result)) {      $children[$vid][$term->parent][] = $term->tid;      $parents[$vid][$term->tid][] = $term->parent;      $terms[$vid][$term->tid] = $term;    }  }  $max_depth = (is_null($max_depth)) ? count($children[$vid]) : $max_depth;  $tree = array();  if ($max_depth > $depth && !empty($children[$vid][$parent])) {    foreach ($children[$vid][$parent] as $child) {      $term = drupal_clone($terms[$vid][$child]);      $term->depth = $depth;      // The "parent" attribute is not useful, as it would show one parent only.      unset($term->parent);      $term->parents = $parents[$vid][$child];      $tree[] = $term;      if (!empty($children[$vid][$child])) {        $tree = array_merge($tree, taxonomy_get_tree($vid, $child, $depth, $max_depth));      }    }  }  return $tree;}/** * Return an array of synonyms of the given term ID. */function taxonomy_get_synonyms($tid) {  if ($tid) {    $synonyms = array();    $result = db_query('SELECT name FROM {term_synonym} WHERE tid = %d', $tid);    while ($synonym = db_fetch_array($result)) {      $synonyms[] = $synonym['name'];    }    return $synonyms;  }  else {    return array();  }}/** * Return the term object that has the given string as a synonym. */function taxonomy_get_synonym_root($synonym) {  return db_fetch_object(db_query("SELECT * FROM {term_synonym} s, {term_data} t WHERE t.tid = s.tid AND s.name = '%s'", $synonym));}/** * Count the number of published nodes classified by a term. * * @param $tid *   The term's ID * * @param $type *   The $node->type. If given, taxonomy_term_count_nodes only counts *   nodes of $type that are classified with the term $tid. * * @return int *   An integer representing a number of nodes. *   Results are statically cached. */function taxonomy_term_count_nodes($tid, $type = 0) {  static $count;  if (!isset($count[$type])) {    // $type == 0 always evaluates TRUE if $type is a string    if (is_numeric($type)) {      $result = db_query(db_rewrite_sql('SELECT t.tid, COUNT(n.nid) AS c FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.status = 1 GROUP BY t.tid'));    }    else {      $result = db_query(db_rewrite_sql("SELECT t.tid, COUNT(n.nid) AS c FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.status = 1 AND n.type = '%s' GROUP BY t.tid"), $type);    }    $count[$type] = array();    while ($term = db_fetch_object($result)) {      $count[$type][$term->tid] = $term->c;    }  }  $children_count = 0;  foreach (_taxonomy_term_children($tid) as $c) {    $children_count += taxonomy_term_count_nodes($c, $type);  }  return $children_count + (isset($count[$type][$tid]) ? $count[$type][$tid] : 0);}/** * Helper for taxonomy_term_count_nodes(). Used to find out * which terms are children of a parent term. * * @param $tid *   The parent term's ID * * @return array *   An array of term IDs representing the children of $tid. *   Results are statically cached. * */function _taxonomy_term_children($tid) {  static $children;  if (!isset($children)) {    $result = db_query('SELECT tid, parent FROM {term_hierarchy}');    while ($term = db_fetch_object($result)) {      $children[$term->parent][] = $term->tid;    }  }  return isset($children[$tid]) ? $children[$tid] : array();}/** * Try to map a string to an existing term, as for glossary use. * * Provides a case-insensitive and trimmed mapping, to maximize the * likelihood of a successful match. * * @param name *   Name of the term to search for. * * @return *   An array of matching term objects. */function taxonomy_get_term_by_name($name) {  $db_result = db_query(db_rewrite_sql("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s')", 't', 'tid'), trim($name));  $result = array();  while ($term = db_fetch_object($db_result)) {    $result[] = $term;  }  return $result;}/** * Return the vocabulary object matching a vocabulary ID. * * @param $vid *   The vocabulary's ID * @param $reset *   Whether to reset the internal taxonomy_vocabulary_load cache. * * @return *   The vocabulary object with all of its metadata, if exists, FALSE otherwise. *   Results are statically cached. */function taxonomy_vocabulary_load($vid, $reset = FALSE) {  static $vocabularies = array();  if ($reset) {    $vocabularies = array();  }  if (!isset($vocabularies[$vid])) {    // Initialize so if this vocabulary does not exist, we have    // that cached, and we will not try to load this later.    $vocabularies[$vid] = FALSE;    // Try to load the data and fill up the object.    $result = db_query('SELECT v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE v.vid = %d', $vid);    $node_types = array();    while ($voc = db_fetch_object($result)) {      if (!empty($voc->type)) {        $node_types[$voc->type] = $voc->type;      }      unset($voc->type);      $voc->nodes = $node_types;      $vocabularies[$vid] = $voc;    }  }  // Return FALSE if this vocabulary does not exist.  return !empty($vocabularies[$vid]) ? $vocabularies[$vid] : FALSE;}/** * Return the term object matching a term ID. * * @param $tid *   A term's ID * @param $reset *   Whether to reset the internal taxonomy_get_term cache. * * @return Object *   A term object. Results are statically cached. */function taxonomy_get_term($tid, $reset = FALSE) {  static $terms = array();  if ($reset) {    $terms = array();  }  if (!isset($terms[$tid])) {    $terms[$tid] = db_fetch_object(db_query('SELECT * FROM {term_data} WHERE tid = %d', $tid));  }  return $terms[$tid];}/** * Create a select form element for a given taxonomy vocabulary. * * NOTE: This function expects input that has already been sanitized and is * safe for display. Callers must properly sanitize the $title and * $description arguments to prevent XSS vulnerabilities. * * @param $title *   The title of the vocabulary. This MUST be sanitized by the caller. * @param $name *   Ignored. * @param $value *   The currently selected terms from this vocabulary, if any. * @param $vocabulary_id *   The vocabulary ID to build the form element for. * @param $description *   Help text for the form element. This MUST be sanitized by the caller. * @param $multiple *   Boolean to control if the form should use a single or multiple select. * @param $blank *   Optional form choice to use when no value has been selected. * @param $exclude *   Optional array of term ids to exclude in the selector. * @return *   A FAPI form array to select terms from the given vocabulary. * * @see taxonomy_form() * @see taxonomy_form_term() */function _taxonomy_term_select($title, $name, $value, $vocabulary_id, $description, $multiple, $blank, $exclude = array()) {  $tree = taxonomy_get_tree($vocabulary_id);  $options = array();  if ($blank) {    $options[''] = $blank;  }  if ($tree) {    foreach ($tree as $term) {      if (!in_array($term->tid, $exclude)) {        $choice = new stdClass();        $choice->option = array($term->tid => str_repeat('-', $term->depth) . $term->name);        $options[] = $choice;      }    }  }  return array('#type' => 'select',    '#title' => $title,    '#default_value' => $value,    '#options' => $options,    '#description' => $description,    '#multiple' => $multiple,    '#size' => $multiple ? min(9, count($options)) : 0,    '#weight' => -15,    '#theme' => 'taxonomy_term_select',  );}/** * Format the selection field for choosing terms * (by deafult the default selection field is used). * * @ingroup themeable */function theme_taxonomy_term_select($element) {  return theme('select', $element);}/** * Finds all nodes that match selected taxonomy conditions. * * @param $tids *   An array of term IDs to match. * @param $operator *   How to interpret multiple IDs in the array. Can be "or" or "and". * @param $depth *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative *   integer or "all". * @param $pager *   Whether the nodes are to be used with a pager (the case on most Drupal *   pages) or not (in an XML feed, for example). * @param $order *   The order clause for the query that retrieve the nodes. * @return *   A resource identifier pointing to the query results. */function taxonomy_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC') {  if (count($tids) > 0) {    // For each term ID, generate an array of descendant term IDs to the right depth.    $descendant_tids = array();    if ($depth === 'all') {      $depth = NULL;    }    foreach ($tids as $index => $tid) {      $term = taxonomy_get_term($tid);      $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);      $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));    }    if ($operator == 'or') {      $args = call_user_func_array('array_merge', $descendant_tids);      $placeholders = db_placeholders($args, 'int');      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN ('. $placeholders .') AND n.status = 1 ORDER BY '. $order;      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN ('. $placeholders .') AND n.status = 1';    }    else {      $joins = '';      $wheres = '';      $args = array();      foreach ($descendant_tids as $index => $tids) {        $joins .= ' INNER JOIN {term_node} tn'. $index .' ON n.vid = tn'. $index .'.vid';        $wheres .= ' AND tn'. $index .'.tid IN ('. db_placeholders($tids, 'int') .')';        $args = array_merge($args, $tids);      }      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres .' ORDER BY '. $order;      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres;    }    $sql = db_rewrite_sql($sql);    $sql_count = db_rewrite_sql($sql_count);    if ($pager) {      $result = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);    }    else {      $result = db_query_range($sql, $args, 0, variable_get('feed_default_items', 10));    }  }  return $result;}/** * Accepts the result of a pager_query() call, such as that performed by * taxonomy_select_nodes(), and formats each node along with a pager. */function taxonomy_render_nodes($result) {  $output = '';  $has_rows = FALSE;  while ($node = db_fetch_object($result)) {    $output .= node_view(node_load($node->nid), 1);    $has_rows = TRUE;  }  if ($has_rows) {    $output .= theme('pager', NULL, variable_get('default_nodes_main', 10), 0);  }  else {    $output .= '<p>'. t('There are currently no posts in this category.') .'</p>';  }  return $output;}/** * Implementation of hook_nodeapi(). */function taxonomy_nodeapi($node, $op, $arg = 0) {  switch ($op) {    case 'load':      $output['taxonomy'] = taxonomy_node_get_terms($node);      return $output;    case 'insert':      if (!empty($node->taxonomy)) {        taxonomy_node_save($node, $node->taxonomy);      }      break;    case 'update':      if (!empty($node->taxonomy)) {        taxonomy_node_save($node, $node->taxonomy);      }      break;    case 'delete':      taxonomy_node_delete($node);      break;    case 'delete revision':      taxonomy_node_delete_revision($node);      break;    case 'validate':      taxonomy_node_validate($node);      break;    case 'rss item':      return taxonomy_rss_item($node);    case 'update index':      return taxonomy_node_update_index($node);  }}/** * Implementation of hook_nodeapi('update_index'). */function taxonomy_node_update_index(&$node) {  $output = array();  foreach ($node->taxonomy as $term) {    $output[] = $term->name;  }  if (count($output)) {    return '<strong>('. implode(', ', $output) .')</strong>';  }}/** * Parses a comma or plus separated string of term IDs. * * @param $str_tids *   A string of term IDs, separated by plus or comma. *   comma (,) means AND *   plus (+) means OR * * @return an associative array with an operator key (either 'and' *   or 'or') and a tid key containing an array of the term ids. */function taxonomy_terms_parse_string($str_tids) {  $terms = array('operator' => '', 'tids' => array());  if (preg_match('/^([0-9]+[+ ])+[0-9]+$/', $str_tids)) {    $terms['operator'] = 'or';    // The '+' character in a query string may be parsed as ' '.    $terms['tids'] = preg_split('/[+ ]/', $str_tids);  }  else if (preg_match('/^([0-9]+,)*[0-9]+$/', $str_tids)) {    $terms['operator'] = 'and';    $terms['tids'] = explode(',', $str_tids);  }  return $terms;}/** * Provides category information for RSS feeds. */function taxonomy_rss_item($node) {  $output = array();  foreach ($node->taxonomy as $term) {    $output[] = array('key'   => 'category',                      'value' => $term->name,                      'attributes' => array('domain' => url('taxonomy/term/'. $term->tid, array('absolute' => TRUE))));  }  return $output;}/** * Implementation of hook_help(). */function taxonomy_help($path, $arg) {  switch ($path) {    case 'admin/help#taxonomy':      $output = '<p>'. t('The taxonomy module allows you to categorize content using various systems of classification. Free-tagging vocabularies are created by users on the fly when they submit posts (as commonly found in blogs and social bookmarking applications). Controlled vocabularies allow for administrator-defined short lists of terms as well as complex hierarchies with multiple relationships between different terms. These methods can be applied to different content types and combined together to create a powerful and flexible method of classifying and presenting your content.') .'</p>';      $output .= '<p>'. t('For example, when creating a recipe site, you might want to classify posts by both the type of meal and preparation time. A vocabulary for each allows you to categorize using each criteria independently instead of creating a tag for every possible combination.') .'</p>';      $output .= '<p>'. t('Type of Meal: <em>Appetizer, Main Course, Salad, Dessert</em>') .'</p>';      $output .= '<p>'. t('Preparation Time: <em>0-30mins, 30-60mins, 1-2 hrs, 2hrs+</em>') .'</p>';      $output .= '<p>'. t("Each taxonomy term (often called a 'category' or 'tag' in other systems) automatically provides lists of posts and a corresponding RSS feed. These taxonomy/term URLs can be manipulated to generate AND and OR lists of posts classified with terms. In our recipe site example, it then becomes easy to create pages displaying 'Main courses', '30 minute recipes', or '30 minute main courses and appetizers' by using terms on their own or in combination with others. There are a significant number of contributed modules which you to alter and extend the behavior of the core module for both display and organization of terms.") .'</p>';      $output .= '<p>'. t("Terms can also be organized in parent/child relationships from the admin interface. An example would be a vocabulary grouping countries under their parent geo-political regions. The taxonomy module also enables advanced implementations of hierarchy, for example placing Turkey in both the 'Middle East' and 'Europe'.") .'</p>';      $output .= '<p>'. t('The taxonomy module supports the use of both synonyms and related terms, but does not directly use this functionality. However, optional contributed or custom modules may make full use of these advanced features.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@taxonomy">Taxonomy module</a>.', array('@taxonomy' => 'http://drupal.org/handbook/modules/taxonomy/')) .'</p>';      return $output;    case 'admin/content/taxonomy':      $output = '<p>'. t("The taxonomy module allows you to categorize your content using both tags and administrator defined terms. It is a flexible tool for classifying content with many advanced features. To begin, create a 'Vocabulary' to hold one set of terms or tags. You can create one free-tagging vocabulary for everything, or separate controlled vocabularies to define the various properties of your content, for example 'Countries' or 'Colors'.") .'</p>';      $output .= '<p>'. t('Use the list below to configure and review the vocabularies defined on your site, or to list and manage the terms (tags) they contain. A vocabulary may (optionally) be tied to specific content types as shown in the <em>Type</em> column and, if so, will be displayed when creating or editing posts of that type. Multiple vocabularies tied to the same content type will be displayed in the order shown below. To change the order of a vocabulary, grab a drag-and-drop handle under the <em>Name</em> column and drag it to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save</em> button at the bottom of the page.') .'</p>';      return $output;    case 'admin/content/taxonomy/%':      $vocabulary = taxonomy_vocabulary_load($arg[3]);      if ($vocabulary->tags) {        return '<p>'. t('%capital_name is a free-tagging vocabulary. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name))) .'</p>';      }      switch ($vocabulary->hierarchy) {        case 0:          return '<p>'. t('%capital_name is a flat vocabulary. You may organize the terms in the %name vocabulary by using the handles on the left side of the table. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name)) .'</p>';        case 1:          return '<p>'. t('%capital_name is a single hierarchy vocabulary. You may organize the terms in the %name vocabulary by using the handles on the left side of the table. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name)) .'</p>';        case 2:          return '<p>'. t('%capital_name is a multiple hierarchy vocabulary. To change the name or description of a term, click the <em>edit</em> link next to the term. Drag and drop of multiple hierarchies is not supported, but you can re-enable drag and drop support by editing each term to include only a single parent.', array('%capital_name' => drupal_ucfirst($vocabulary->name))) .'</p>';      }    case 'admin/content/taxonomy/add/vocabulary':      return '<p>'. t('Define how your vocabulary will be presented to administrators and users, and which content types to categorize with it. Tags allows users to create terms when submitting posts by typing a comma separated list. Otherwise terms are chosen from a select list and can only be created by users with the "administer taxonomy" permission.') .'</p>';  }}/** * Helper function for array_map purposes. */function _taxonomy_get_tid_from_term($term) {  return $term->tid;}/** * Implode a list of tags of a certain vocabulary into a string. */function taxonomy_implode_tags($tags, $vid = NULL) {  $typed_tags = array();  foreach ($tags as $tag) {    // Extract terms belonging to the vocabulary in question.    if (is_null($vid) || $tag->vid == $vid) {      // Commas and quotes in tag names are special cases, so encode 'em.      if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {        $tag->name = '"'. str_replace('"', '""', $tag->name) .'"';      }      $typed_tags[] = $tag->name;    }  }  return implode(', ', $typed_tags);}/** * Implementation of hook_hook_info(). */function taxonomy_hook_info() {  return array(    'taxonomy' => array(      'taxonomy' => array(        'insert' => array(          'runs when' => t('After saving a new term to the database'),        ),        'update' => array(          'runs when' => t('After saving an updated term to the database'),        ),        'delete' => array(          'runs when' => t('After deleting a term')        ),      ),    ),  );}
<?php// $Id$/** * @file * Manages displaying online help. *//** * Implementation of hook_menu(). */function help_menu() {  $items['admin/help'] = array(    'title' => 'Help',    'page callback' => 'help_main',    'access arguments' => array('access administration pages'),    'weight' => 9,    'file' => 'help.admin.inc',  );  foreach (module_implements('help', TRUE) as $module) {    $items['admin/help/'. $module] = array(      'title' => $module,      'page callback' => 'help_page',      'page arguments' => array(2),      'access arguments' => array('access administration pages'),      'type' => MENU_CALLBACK,      'file' => 'help.admin.inc',    );  }  return $items;}/** * Implementation of hook_help(). */function help_help($path, $arg) {  switch ($path) {    case 'admin/help':      $output = '<p>'. t('This guide provides context sensitive help on the use and configuration of <a href="@drupal">Drupal</a> and its modules, and is a supplement to the more extensive online <a href="@handbook">Drupal handbook</a>. The online handbook may contain more up-to-date information, is annotated with helpful user-contributed comments, and serves as the definitive reference point for all Drupal documentation.', array('@drupal' => 'http://drupal.org', '@handbook' => 'http://drupal.org/handbook')) .'</p>';      return $output;    case 'admin/help#help':      $output = '<p>'. t('The help module provides context sensitive help on the use and configuration of <a href="@drupal">Drupal</a> and its modules, and is a supplement to the more extensive online <a href="@handbook">Drupal handbook</a>. The online handbook may contain more up-to-date information, is annotated with helpful user-contributed comments, and serves as the definitive reference point for all Drupal documentation.', array('@drupal' => 'http://drupal.org', '@handbook' => 'http://drupal.org/handbook')) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@help">Help module</a>.', array('@help' => 'http://drupal.org/handbook/modules/help/')) .'</p>';      return $output;  }}
<?php// $Id$/** * @file * Multiple language handling functionality. *//** *  Choose a language for the page, based on language negotiation settings. */function language_initialize() {  global $user;  // Configured presentation language mode.  $mode = variable_get('language_negotiation', LANGUAGE_NEGOTIATION_NONE);  // Get a list of enabled languages.  $languages = language_list('enabled');  $languages = $languages[1];    switch ($mode) {    case LANGUAGE_NEGOTIATION_NONE:      return language_default();    case LANGUAGE_NEGOTIATION_DOMAIN:      foreach ($languages as $language) {        $parts = parse_url($language->domain);        if (!empty($parts['host']) && ($_SERVER['HTTP_HOST'] == $parts['host'])) {          return $language;        }      }      return language_default();    case LANGUAGE_NEGOTIATION_PATH_DEFAULT:    case LANGUAGE_NEGOTIATION_PATH:      // $_GET['q'] might not be available at this time, because      // path initialization runs after the language bootstrap phase.      $args = isset($_GET['q']) ? explode('/', $_GET['q']) : array();      $prefix = array_shift($args);      // Search prefix within enabled languages.      foreach ($languages as $language) {        if (!empty($language->prefix) && $language->prefix == $prefix) {          // Rebuild $GET['q'] with the language removed.          $_GET['q'] = implode('/', $args);          return $language;        }      }      if ($mode == LANGUAGE_NEGOTIATION_PATH_DEFAULT) {        // If we did not found the language by prefix, choose the default.        return language_default();      }      break;  }  // User language.  if ($user->uid && isset($languages[$user->language])) {    return $languages[$user->language];  }  // Browser accept-language parsing.  if ($language = language_from_browser()) {    return $language;  }  // Fall back on the default if everything else fails.  return language_default();}/** * Identify language from the Accept-language HTTP header we got. */function language_from_browser() {  // Specified by the user via the browser's Accept Language setting  // Samples: "hu, en-us;q=0.66, en;q=0.33", "hu,en-us;q=0.5"  $browser_langs = array();  if (isset($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {    $browser_accept = explode(",", $_SERVER['HTTP_ACCEPT_LANGUAGE']);    for ($i = 0; $i < count($browser_accept); $i++) {      // The language part is either a code or a code with a quality.      // We cannot do anything with a * code, so it is skipped.      // If the quality is missing, it is assumed to be 1 according to the RFC.      if (preg_match("!([a-z-]+)(;q=([0-9\\.]+))?!", trim($browser_accept[$i]), $found)) {        $browser_langs[$found[1]] = (isset($found[3]) ? (float) $found[3] : 1.0);      }    }  }  // Order the codes by quality  arsort($browser_langs);  // Try to find the first preferred language we have  $languages = language_list('enabled');  foreach ($browser_langs as $langcode => $q) {    if (isset($languages['1'][$langcode])) {      return $languages['1'][$langcode];    }  }}/** * Rewrite URL's with language based prefix. Parameters are the same * as those of the url() function. */function language_url_rewrite(&$path, &$options) {  global $language;  // Only modify relative (insite) URLs.  if (!$options['external']) {    // Language can be passed as an option, or we go for current language.    if (!isset($options['language'])) {      $options['language'] = $language;    }    switch (variable_get('language_negotiation', LANGUAGE_NEGOTIATION_NONE)) {      case LANGUAGE_NEGOTIATION_NONE:        // No language dependent path allowed in this mode.        unset($options['language']);        break;      case LANGUAGE_NEGOTIATION_DOMAIN:        if ($options['language']->domain) {          // Ask for an absolute URL with our modified base_url.          $options['absolute'] = TRUE;          $options['base_url'] = $options['language']->domain;        }        break;      case LANGUAGE_NEGOTIATION_PATH_DEFAULT:        $default = language_default();        if ($options['language']->language == $default->language) {          break;        }        // Intentionally no break here.      case LANGUAGE_NEGOTIATION_PATH:        if (!empty($options['language']->prefix)) {          $options['prefix'] = $options['language']->prefix .'/';        }        break;    }  }}
<?php// $Id$/** * @file * Administrative page callbacks for the forum module. */function forum_form_main($type, $edit = array()) {  if ((isset($_POST['op']) && $_POST['op'] == t('Delete')) || !empty($_POST['confirm'])) {    return drupal_get_form('forum_confirm_delete', $edit['tid']);  }  switch ($type) {    case 'forum':      return drupal_get_form('forum_form_forum', $edit);      break;    case 'container':      return drupal_get_form('forum_form_container', $edit);      break;  }}/** * Returns a form for adding a forum to the forum vocabulary * * @param $edit Associative array containing a forum term to be added or edited. * @ingroup forms * @see forum_form_submit() */function forum_form_forum(&$form_state, $edit = array()) {  $edit += array(    'name' => '',    'description' => '',    'tid' => NULL,    'weight' => 0,  );  $form['name'] = array('#type' => 'textfield',    '#title' => t('Forum name'),    '#default_value' => $edit['name'],    '#maxlength' => 255,    '#description' => t('Short but meaningful name for this collection of threaded discussions.'),    '#required' => TRUE,  );  $form['description'] = array('#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],    '#description' => t('Description and guidelines for discussions within this forum.'),  );  $form['parent']['#tree'] = TRUE;  $form['parent'][0] = _forum_parent_select($edit['tid'], t('Parent'), 'forum');  $form['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('Forums are displayed in ascending order by weight (forums with equal weights are displayed alphabetically).'),  );  $form['vid'] = array('#type' => 'hidden', '#value' => variable_get('forum_nav_vocabulary', ''));  $form['submit' ] = array('#type' => 'submit', '#value' => t('Save'));  if ($edit['tid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['tid'] = array('#type' => 'hidden', '#value' => $edit['tid']);  }  $form['#submit'][] = 'forum_form_submit';  $form['#theme'] = 'forum_form';  return $form;}/** * Process forum form and container form submissions. */function forum_form_submit($form, &$form_state) {  if ($form['form_id']['#value'] == 'forum_form_container') {    $container = TRUE;    $type = t('forum container');  }  else {    $container = FALSE;    $type = t('forum');  }  $status = taxonomy_save_term($form_state['values']);  switch ($status) {    case SAVED_NEW:      if ($container) {        $containers = variable_get('forum_containers', array());        $containers[] = $form_state['values']['tid'];        variable_set('forum_containers', $containers);      }      drupal_set_message(t('Created new @type %term.', array('%term' => $form_state['values']['name'], '@type' => $type)));      break;    case SAVED_UPDATED:      drupal_set_message(t('The @type %term has been updated.', array('%term' => $form_state['values']['name'], '@type' => $type)));      break;  }  $form_state['redirect'] = 'admin/content/forum';  return;}/** * Returns a form for adding a container to the forum vocabulary * * @param $edit Associative array containing a container term to be added or edited. * @ingroup forms * @see forum_form_submit() */function forum_form_container(&$form_state, $edit = array()) {  $edit += array(    'name' => '',    'description' => '',    'tid' => NULL,    'weight' => 0,  );  // Handle a delete operation.  $form['name'] = array(    '#title' => t('Container name'),    '#type' => 'textfield',    '#default_value' => $edit['name'],    '#maxlength' => 255,    '#description' => t('Short but meaningful name for this collection of related forums.'),    '#required' => TRUE  );  $form['description'] = array(    '#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],    '#description' => t('Description and guidelines for forums within this container.')  );  $form['parent']['#tree'] = TRUE;  $form['parent'][0] = _forum_parent_select($edit['tid'], t('Parent'), 'container');  $form['weight'] = array(    '#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('Containers are displayed in ascending order by weight (containers with equal weights are displayed alphabetically).')  );  $form['vid'] = array(    '#type' => 'hidden',    '#value' => variable_get('forum_nav_vocabulary', ''),  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save')  );  if ($edit['tid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['tid'] = array('#type' => 'value', '#value' => $edit['tid']);  }  $form['#submit'][] = 'forum_form_submit';  $form['#theme'] = 'forum_form';  return $form;}/** * Returns a confirmation page for deleting a forum taxonomy term. * * @param $tid ID of the term to be deleted */function forum_confirm_delete(&$form_state, $tid) {  $term = taxonomy_get_term($tid);  $form['tid'] = array('#type' => 'value', '#value' => $tid);  $form['name'] = array('#type' => 'value', '#value' => $term->name);  return confirm_form($form, t('Are you sure you want to delete the forum %name?', array('%name' => $term->name)), 'admin/content/forum', t('Deleting a forum or container will also delete its sub-forums, if any. To delete posts in this forum, visit <a href="@content">content administration</a> first. This action cannot be undone.', array('@content' => url('admin/content/node'))), t('Delete'), t('Cancel'));}/** * Implementation of forms api _submit call. Deletes a forum after confirmation. */function forum_confirm_delete_submit($form, &$form_state) {  taxonomy_del_term($form_state['values']['tid']);  drupal_set_message(t('The forum %term and all sub-forums and associated posts have been deleted.', array('%term' => $form_state['values']['name'])));  watchdog('content', 'forum: deleted %term and all its sub-forums and associated posts.', array('%term' => $form_state['values']['name']));  $form_state['redirect'] = 'admin/content/forum';  return;}/** * Form builder for the forum settings page. * * @see system_settings_form() */function forum_admin_settings() {  $form = array();  $number = drupal_map_assoc(array(5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 80, 100, 150, 200, 250, 300, 350, 400, 500));  $form['forum_hot_topic'] = array('#type' => 'select',    '#title' => t('Hot topic threshold'),    '#default_value' => variable_get('forum_hot_topic', 15),    '#options' => $number,    '#description' => t('The number of posts a topic must have to be considered "hot".'),  );  $number = drupal_map_assoc(array(10, 25, 50, 75, 100));  $form['forum_per_page'] = array('#type' => 'select',    '#title' => t('Topics per page'),    '#default_value' => variable_get('forum_per_page', 25),    '#options' => $number,    '#description' => t('Default number of forum topics displayed per page.'),  );  $forder = array(1 => t('Date - newest first'), 2 => t('Date - oldest first'), 3 => t('Posts - most active first'), 4 => t('Posts - least active first'));  $form['forum_order'] = array('#type' => 'radios',    '#title' => t('Default order'),    '#default_value' => variable_get('forum_order', '1'),    '#options' => $forder,    '#description' => t('Default display order for topics.'),  );  return system_settings_form($form);}/** * Returns an overview list of existing forums and containers */function forum_overview(&$form_state) {  module_load_include('inc', 'taxonomy', 'taxonomy.admin');  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  $form = taxonomy_overview_terms($form_state, $vocabulary);  foreach (element_children($form) as $key) {    if (isset($form[$key]['#term'])) {      $term = $form[$key]['#term'];      $form[$key]['view']['#value'] = l($term['name'], 'forum/'. $term['tid']);      if (in_array($form[$key]['#term']['tid'], variable_get('forum_containers', array()))) {        $form[$key]['edit']['#value'] = l(t('edit container'), 'admin/content/forum/edit/container/'. $term['tid']);      }      else {        $form[$key]['edit']['#value'] = l(t('edit forum'), 'admin/content/forum/edit/forum/'. $term['tid']);      }    }  }  // Remove the alphabetical reset.  unset($form['reset_alphabetical']);  // The form needs to have submit and validate handlers set explicitly.  $form['#theme'] = 'taxonomy_overview_terms';  $form['#submit'] = array('taxonomy_overview_terms_submit'); // Use the existing taxonomy overview submit handler.  $form['#validate'] = array('taxonomy_overview_terms_validate');  $form['#empty_text'] = '<em>'. t('There are no existing containers or forums. Containers and forums may be added using the <a href="@container">add container</a> and <a href="@forum">add forum</a> pages.', array('@container' => url('admin/content/forum/add/container'), '@forum' => url('admin/content/forum/add/forum'))) .'</em>';  return $form;}/** * Returns a select box for available parent terms * * @param $tid ID of the term which is being added or edited * @param $title Title to display the select box with * @param $child_type Whether the child is forum or container */function _forum_parent_select($tid, $title, $child_type) {  $parents = taxonomy_get_parents($tid);  if ($parents) {    $parent = array_shift($parents);    $parent = $parent->tid;  }  else {    $parent = 0;  }  $vid = variable_get('forum_nav_vocabulary', '');  $children = taxonomy_get_tree($vid, $tid);  // A term can't be the child of itself, nor of its children.  foreach ($children as $child) {    $exclude[] = $child->tid;  }  $exclude[] = $tid;  $tree = taxonomy_get_tree($vid);  $options[0] = '<'. t('root') .'>';  if ($tree) {    foreach ($tree as $term) {      if (!in_array($term->tid, $exclude)) {        $options[$term->tid] = str_repeat(' -- ', $term->depth) . $term->name;      }    }  }  if ($child_type == 'container') {    $description = t('Containers are usually placed at the top (root) level, but may also be placed inside another container or forum.');  }  else if ($child_type == 'forum') {    $description = t('Forums may be placed at the top (root) level, or inside another container or forum.');  }  return array('#type' => 'select', '#title' => $title, '#default_value' => $parent, '#options' => $options, '#description' => $description, '#required' => TRUE);}
<?php// $Id$/** * @file * Enable users to post using applications that support XML-RPC blog APIs. *//** * Implementation of hook_help(). */function blogapi_help($path, $arg) {  switch ($path) {    case 'admin/help#blogapi':      $output = '<p>'. t("The Blog API module allows your site's users to access and post to their blogs from external blogging clients. External blogging clients are available for a wide range of desktop operating systems, and generally provide a feature-rich graphical environment for creating and editing posts.") .'</p>';      $output .= '<p>'. t('<a href="@ecto-link">Ecto</a>, a blogging client available for both Mac OS X and Microsoft Windows, can be used with Blog API. Blog API also supports <a href="@blogger-api">Blogger API</a>, <a href="@metaweblog-api">MetaWeblog API</a>, and most of the <a href="@movabletype-api">Movable Type API</a>. Blogging clients and other services (e.g. <a href="@flickr">Flickr\'s</a> "post to blog") that support these APIs may also be compatible.', array('@ecto-link' => url('http://infinite-sushi.com/software/ecto/'), '@blogger-api' => url('http://www.blogger.com/developers/api/1_docs/'), '@metaweblog-api' => url('http://www.xmlrpc.com/metaWeblogApi'), '@movabletype-api' => url('http://www.movabletype.org/docs/mtmanual_programmatic.html'), '@flickr' => url('http://www.flickr.com'))) .'</p>';      $output .= '<p>'. t('Select the content types available to external clients on the <a href="@blogapi-settings">Blog API settings page</a>. If supported and available, each content type will be displayed as a separate "blog" by the external client.', array('@blogapi-settings' => url('admin/settings/blogapi'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@blogapi">Blog API module</a>.', array('@blogapi' => url('http://drupal.org/handbook/modules/blogapi/'))) .'</p>';      return $output;  }}/** * Implementation of hook_perm(). */function blogapi_perm() {  return array('administer content with blog api');}/** * Implementation of hook_xmlrpc(). */function blogapi_xmlrpc() {  return array(    array(      'blogger.getUsersBlogs',      'blogapi_blogger_get_users_blogs',      array('array', 'string', 'string', 'string'),      t('Returns a list of blogs to which an author has posting privileges.')),    array(      'blogger.getUserInfo',      'blogapi_blogger_get_user_info',      array('struct', 'string', 'string', 'string'),      t('Returns information about an author in the system.')),    array(      'blogger.newPost',      'blogapi_blogger_new_post',      array('string', 'string', 'string', 'string', 'string', 'string', 'boolean'),      t('Creates a new post, and optionally publishes it.')),    array(      'blogger.editPost',      'blogapi_blogger_edit_post',      array('boolean', 'string', 'string', 'string', 'string', 'string', 'boolean'),      t('Updates the information about an existing post.')),    array(      'blogger.getPost',      'blogapi_blogger_get_post',      array('struct', 'string', 'string', 'string', 'string'),      t('Returns information about a specific post.')),    array(      'blogger.deletePost',      'blogapi_blogger_delete_post',      array('boolean', 'string', 'string', 'string', 'string', 'boolean'),      t('Deletes a post.')),    array(      'blogger.getRecentPosts',      'blogapi_blogger_get_recent_posts',      array('array', 'string', 'string', 'string', 'string', 'int'),      t('Returns a list of the most recent posts in the system.')),    array(      'metaWeblog.newPost',      'blogapi_metaweblog_new_post',      array('string', 'string', 'string', 'string', 'struct', 'boolean'),      t('Creates a new post, and optionally publishes it.')),    array(      'metaWeblog.editPost',      'blogapi_metaweblog_edit_post',      array('boolean', 'string', 'string', 'string', 'struct', 'boolean'),      t('Updates information about an existing post.')),    array(      'metaWeblog.getPost',      'blogapi_metaweblog_get_post',      array('struct', 'string', 'string', 'string'),      t('Returns information about a specific post.')),    array(      'metaWeblog.newMediaObject',      'blogapi_metaweblog_new_media_object',      array('string', 'string', 'string', 'string', 'struct'),      t('Uploads a file to your webserver.')),    array(      'metaWeblog.getCategories',      'blogapi_metaweblog_get_category_list',      array('struct', 'string', 'string', 'string'),      t('Returns a list of all categories to which the post is assigned.')),    array(      'metaWeblog.getRecentPosts',      'blogapi_metaweblog_get_recent_posts',      array('array', 'string', 'string', 'string', 'int'),      t('Returns a list of the most recent posts in the system.')),    array(      'mt.getRecentPostTitles',      'blogapi_mt_get_recent_post_titles',      array('array', 'string', 'string', 'string', 'int'),      t('Returns a bandwidth-friendly list of the most recent posts in the system.')),    array(      'mt.getCategoryList',      'blogapi_mt_get_category_list',      array('array', 'string', 'string', 'string'),      t('Returns a list of all categories defined in the blog.')),    array(      'mt.getPostCategories',      'blogapi_mt_get_post_categories',      array('array', 'string', 'string', 'string'),      t('Returns a list of all categories to which the post is assigned.')),    array(      'mt.setPostCategories',      'blogapi_mt_set_post_categories',      array('boolean', 'string', 'string', 'string', 'array'),      t('Sets the categories for a post.')),    array(      'mt.supportedMethods',      'xmlrpc_server_list_methods',      array('array'),      t('Retrieve information about the XML-RPC methods supported by the server.')),    array(      'mt.supportedTextFilters',      'blogapi_mt_supported_text_filters',      array('array'),      t('Retrieve information about the text formatting plugins supported by the server.')),    array(      'mt.publishPost',      'blogapi_mt_publish_post',      array('boolean', 'string', 'string', 'string'),      t('Publish (rebuild) all of the static files related to an entry from your blog. Equivalent to saving an entry in the system (but without the ping).')));}/** * Blogging API callback. Finds the URL of a user's blog. */function blogapi_blogger_get_users_blogs($appid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if ($user->uid) {    $types = _blogapi_get_node_types();    $structs = array();    foreach ($types as $type) {      $structs[] = array('url' => url('blog/'. $user->uid, array('absolute' => TRUE)), 'blogid' => $type, 'blogName' => $user->name .": ". $type);    }    return $structs;  }  else {    return blogapi_error($user);  }}/** * Blogging API callback. Returns profile information about a user. */function blogapi_blogger_get_user_info($appkey, $username, $password) {  $user = blogapi_validate_user($username, $password);  if ($user->uid) {    $name = explode(' ', $user->realname ? $user->realname : $user->name, 2);    return array(      'userid' => $user->uid,      'lastname' => $name[1],      'firstname' => $name[0],      'nickname' => $user->name,      'email' => $user->mail,      'url' => url('blog/'. $user->uid, array('absolute' => TRUE)));  }  else {    return blogapi_error($user);  }}/** * Blogging API callback. Inserts a new blog post as a node. */function blogapi_blogger_new_post($appkey, $blogid, $username, $password, $content, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  $edit = array();  $edit['type'] = $blogid;  // get the node type defaults  $node_type_default = variable_get('node_options_'. $edit['type'], array('status', 'promote'));  $edit['uid'] = $user->uid;  $edit['name'] = $user->name;  $edit['promote'] = in_array('promote', $node_type_default);  $edit['comment'] = variable_get('comment_'. $edit['type'], 2);  $edit['revision'] = in_array('revision', $node_type_default);  $edit['format'] = FILTER_FORMAT_DEFAULT;  $edit['status'] = $publish;  // check for bloggerAPI vs. metaWeblogAPI  if (is_array($content)) {    $edit['title'] = $content['title'];    $edit['body'] = $content['description'];    _blogapi_mt_extra($edit, $content);  }  else {    $edit['title'] = blogapi_blogger_title($content);    $edit['body'] = $content;  }  if (!node_access('create', $edit['type'])) {    return blogapi_error(t('You do not have permission to create this type of post.'));  }  if (user_access('administer nodes') && !isset($edit['date'])) {    $edit['date'] = format_date(time(), 'custom', 'Y-m-d H:i:s O');  }  node_invoke_nodeapi($edit, 'blogapi new');  $valid = blogapi_status_error_check($edit, $publish);  if ($valid !== TRUE) {    return $valid;  }  node_validate($edit);  if ($errors = form_get_errors()) {    return blogapi_error(implode("\n", $errors));  }  $node = node_submit($edit);  node_save($node);  if ($node->nid) {    watchdog('content', '@type: added %title using blog API.', array('@type' => $node->type, '%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), "node/$node->nid"));    // blogger.newPost returns a string so we cast the nid to a string by putting it in double quotes:    return "$node->nid";  }  return blogapi_error(t('Error storing post.'));}/** * Blogging API callback. Modifies the specified blog node. */function blogapi_blogger_edit_post($appkey, $postid, $username, $password, $content, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  if (!$node) {    return blogapi_error(t('n/a'));  }  // Let the teaser be re-generated.  unset($node->teaser);  if (!node_access('update', $node)) {    return blogapi_error(t('You do not have permission to update this post.'));  }  // Save the original status for validation of permissions.  $original_status = $node->status;  $node->status = $publish;  // check for bloggerAPI vs. metaWeblogAPI  if (is_array($content)) {    $node->title = $content['title'];    $node->body = $content['description'];    _blogapi_mt_extra($node, $content);  }  else {    $node->title = blogapi_blogger_title($content);    $node->body = $content;  }  node_invoke_nodeapi($node, 'blogapi edit');  $valid = blogapi_status_error_check($node, $original_status);  if ($valid !== TRUE) {    return $valid;  }  node_validate($node);  if ($errors = form_get_errors()) {    return blogapi_error(implode("\n", $errors));  }  if (user_access('administer nodes') && !isset($edit['date'])) {    $node->date = format_date($node->created, 'custom', 'Y-m-d H:i:s O');  }  $node = node_submit($node);  node_save($node);  if ($node->nid) {    watchdog('content', '@type: updated %title using Blog API.', array('@type' => $node->type, '%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), "node/$node->nid"));    return TRUE;  }  return blogapi_error(t('Error storing post.'));}/** * Blogging API callback. Returns a specified blog node. */function blogapi_blogger_get_post($appkey, $postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  return _blogapi_get_post($node, TRUE);}/** * Check that the user has permission to save the node with the chosen status. * * @return *   TRUE if no error, or the blogapi_error(). */function blogapi_status_error_check($node, $original_status) {    $node = (object) $node;  $node_type_default = variable_get('node_options_'. $node->type, array('status', 'promote'));  // If we don't have the 'administer nodes' permission and the status is  // changing or for a new node the status is not the content type's default,  // then return an error.  if (!user_access('administer nodes') && (($node->status != $original_status) || (empty($node->nid) && $node->status != in_array('status', $node_type_default)))) {    if ($node->status) {      return blogapi_error(t('You do not have permission to publish this type of post. Please save it as a draft instead.'));    }    else {      return blogapi_error(t('You do not have permission to save this post as a draft. Please publish it instead.'));    }  }  return TRUE;}/** * Blogging API callback. Removes the specified blog node. */function blogapi_blogger_delete_post($appkey, $postid, $username, $password, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  node_delete($postid);  return TRUE;}/** * Blogging API callback. Returns the latest few postings in a user's blog. $bodies TRUE * <a href="http://movabletype.org/docs/mtmanual_programmatic.html#item_mt%2EgetRecentPostTitles"> * returns a bandwidth-friendly list</a>. */function blogapi_blogger_get_recent_posts($appkey, $blogid, $username, $password, $number_of_posts, $bodies = TRUE) {  // Remove unused appkey (from bloggerAPI).  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  if ($bodies) {    $result = db_query_range("SELECT n.nid, n.title, r.body, r.format, n.comment, n.created, u.name FROM {node} n, {node_revisions} r, {users} u WHERE n.uid = u.uid AND n.vid = r.vid AND n.type = '%s' AND n.uid = %d ORDER BY n.created DESC",  $blogid, $user->uid, 0, $number_of_posts);  }  else {    $result = db_query_range("SELECT n.nid, n.title, n.created, u.name FROM {node} n, {users} u WHERE n.uid = u.uid AND n.type = '%s' AND n.uid = %d ORDER BY n.created DESC", $blogid, $user->uid, 0, $number_of_posts);  }  $blogs = array();  while ($blog = db_fetch_object($result)) {    $blogs[] = _blogapi_get_post($blog, $bodies);  }  return $blogs;}function blogapi_metaweblog_new_post($blogid, $username, $password, $content, $publish) {  return blogapi_blogger_new_post('0123456789ABCDEF', $blogid, $username, $password, $content, $publish);}function blogapi_metaweblog_edit_post($postid, $username, $password, $content, $publish) {  return blogapi_blogger_edit_post('0123456789ABCDEF', $postid, $username, $password, $content, $publish);}function blogapi_metaweblog_get_post($postid, $username, $password) {  return blogapi_blogger_get_post('01234567890ABCDEF', $postid, $username, $password);}/** * Blogging API callback. Inserts a file into Drupal. */function blogapi_metaweblog_new_media_object($blogid, $username, $password, $file) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $usersize = 0;  $uploadsize = 0;  $roles = array_intersect(user_roles(FALSE, 'administer content with blog api'), $user->roles);  foreach ($roles as $rid => $name) {    $extensions .= ' '. strtolower(variable_get("blogapi_extensions_$rid", variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp')));    $usersize= max($usersize, variable_get("blogapi_usersize_$rid", variable_get('blogapi_usersize_default', 1)) * 1024 * 1024);    $uploadsize = max($uploadsize, variable_get("blogapi_uploadsize_$rid", variable_get('blogapi_uploadsize_default', 1)) * 1024 * 1024);  }  $filesize = strlen($file['bits']);  if ($filesize > $uploadsize) {    return blogapi_error(t('It is not possible to upload the file, because it exceeded the maximum filesize of @maxsize.', array('@maxsize' => format_size($uploadsize))));  }  if (_blogapi_space_used($user->uid) + $filesize > $usersize) {    return blogapi_error(t('The file can not be attached to this post, because the disk quota of @quota has been reached.', array('@quota' => format_size($usersize))));  }  // Only allow files with whitelisted extensions and convert remaining dots to  // underscores to prevent attacks via non-terminal executable extensions with  // files such as exploit.php.jpg.  $whitelist = array_unique(explode(' ', trim($extensions)));  $name = basename($file['name']);  if ($extension_position = strrpos($name, '.')) {    $filename = drupal_substr($name, 0, $extension_position);    $final_extension = drupal_substr($name, $extension_position + 1);    if (!in_array(strtolower($final_extension), $whitelist)) {      return blogapi_error(t('It is not possible to upload the file, because it is only possible to upload files with the following extensions: @extensions', array('@extensions' => implode(' ', $whitelist))));    }    $filename = str_replace('.', '_', $filename);    $filename .= '.'. $final_extension;  }  $data = $file['bits'];  if (!$data) {    return blogapi_error(t('No file sent.'));  }  if (!$file = file_save_data($data, $filename)) {    return blogapi_error(t('Error storing file.'));  }  $row = new stdClass();  $row->uid = $user->uid;  $row->filepath = $file;  $row->filesize = $filesize;  drupal_write_record('blogapi_files', $row);  // Return the successful result.  return array('url' => file_create_url($file), 'struct');}/** * Blogging API callback. Returns a list of the taxonomy terms that can be * associated with a blog node. */function blogapi_metaweblog_get_category_list($blogid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  $vocabularies = module_invoke('taxonomy', 'get_vocabularies', $blogid, 'vid');  $categories = array();  if ($vocabularies) {    foreach ($vocabularies as $vocabulary) {      $terms = module_invoke('taxonomy', 'get_tree', $vocabulary->vid, 0, -1);      foreach ($terms as $term) {        $term_name = $term->name;        foreach (module_invoke('taxonomy', 'get_parents', $term->tid, 'tid') as $parent) {          $term_name = $parent->name .'/'. $term_name;        }        $categories[] = array('categoryName' => $term_name, 'categoryId' => $term->tid);      }    }  }  return $categories;}function blogapi_metaweblog_get_recent_posts($blogid, $username, $password, $number_of_posts) {  return blogapi_blogger_get_recent_posts('0123456789ABCDEF', $blogid, $username, $password, $number_of_posts, TRUE);}function blogapi_mt_get_recent_post_titles($blogid, $username, $password, $number_of_posts) {  return blogapi_blogger_get_recent_posts('0123456789ABCDEF', $blogid, $username, $password, $number_of_posts, FALSE);}function blogapi_mt_get_category_list($blogid, $username, $password) {  return blogapi_metaweblog_get_category_list($blogid, $username, $password);}/** * Blogging API callback. Returns a list of the taxonomy terms that are * assigned to a particular node. */function blogapi_mt_get_post_categories($postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  $terms = module_invoke('taxonomy', 'node_get_terms', $node, 'tid');  $categories = array();  foreach ($terms as $term) {    $term_name = $term->name;    foreach (module_invoke('taxonomy', 'get_parents', $term->tid, 'tid') as $parent) {      $term_name = $parent->name .'/'. $term_name;    }    $categories[] = array('categoryName' => $term_name, 'categoryId' => $term->tid, 'isPrimary' => TRUE);  }  return $categories;}/** * Blogging API callback. Assigns taxonomy terms to a particular node. */function blogapi_mt_set_post_categories($postid, $username, $password, $categories) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  $node->taxonomy = array();  foreach ($categories as $category) {    $node->taxonomy[] = $category['categoryId'];  }  $validated = blogapi_mt_validate_terms($node);  if ($validated !== TRUE) {    return $validated;  }  node_save($node);  return TRUE;}/** * Blogging API helper - find allowed taxonomy terms for a node type. */function blogapi_mt_validate_terms($node) {  // We do a lot of heavy lifting here since taxonomy module doesn't have a  // stand-alone validation function.  if (module_exists('taxonomy')) {    $found_terms = array();    if (!empty($node->taxonomy)) {      $term_list = array_unique($node->taxonomy);      $params = $term_list;      $params[] = $node->type;      $result = db_query(db_rewrite_sql("SELECT t.tid, t.vid FROM {term_data} t INNER JOIN {vocabulary_node_types} n ON t.vid = n.vid WHERE t.tid IN (". db_placeholders($term_list) .") AND n.type = '%s'", 't', 'tid'), $params);      $found_terms = array();      $found_count = 0;      while ($term = db_fetch_object($result)) {        $found_terms[$term->vid][$term->tid] = $term->tid;        $found_count++;      }      // If the counts don't match, some terms are invalid or not accessible to this user.      if (count($term_list) != $found_count) {        return blogapi_error(t('Invalid categories submitted.'));      }    }    // Look up all the vocabularies for this node type.    $result2 = db_query(db_rewrite_sql("SELECT v.vid, v.name, v.required, v.multiple FROM {vocabulary} v INNER JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s'", 'v', 'vid'), $node->type);    // Check each vocabulary associated with this node type.    while ($vocabulary = db_fetch_object($result2)) {      // Required vocabularies must have at least one term.      if ($vocabulary->required && empty($found_terms[$vocabulary->vid])) {        return blogapi_error(t('A category from the @vocabulary_name vocabulary is required.', array('@vocabulary_name' => $vocabulary->name)));      }      // Vocabularies that don't allow multiple terms may have at most one.      if (!($vocabulary->multiple) && (isset($found_terms[$vocabulary->vid]) && count($found_terms[$vocabulary->vid]) > 1)) {        return blogapi_error(t('You may only choose one category from the @vocabulary_name vocabulary.'), array('@vocabulary_name' => $vocabulary->name));      }    }  }  elseif (!empty($node->taxonomy)) {    return blogapi_error(t('Error saving categories. This feature is not available.'));  }  return TRUE;}/** * Blogging API callback. Sends a list of available input formats. */function blogapi_mt_supported_text_filters() {  // NOTE: we're only using anonymous' formats because the MT spec  // does not allow for per-user formats.  $formats = filter_formats();  $filters = array();  foreach ($formats as $format) {    $filter['key'] = $format->format;    $filter['label'] = $format->name;    $filters[] = $filter;  }  return $filters;}/** * Blogging API callback. Publishes the given node */function blogapi_mt_publish_post($postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  if (!$node) {    return blogapi_error(t('Invalid post.'));  }  // Nothing needs to be done if already published.  if ($node->status) {    return;  }  if (!node_access('update', $node) || !user_access('administer nodes')) {    return blogapi_error(t('You do not have permission to update this post.'));  }  $node->status = 1;  node_save($node);  return TRUE;}/** * Prepare an error message for returning to the XMLRPC caller. */function blogapi_error($message) {  static $xmlrpcusererr;  if (!is_array($message)) {    $message = array($message);  }  $message = implode(' ', $message);  return xmlrpc_error($xmlrpcusererr + 1, strip_tags($message));}/** * Ensure that the given user has permission to edit a blog. */function blogapi_validate_user($username, $password) {  global $user;  $user = user_authenticate(array('name' => $username, 'pass' => $password));  if ($user->uid) {    if (user_access('administer content with blog api', $user)) {      return $user;    }    else {      return t('You do not have permission to edit this blog.');    }  }  else {    return t('Wrong username or password.');  }}/** * For the blogger API, extract the node title from the contents field. */function blogapi_blogger_title(&$contents) {  if (eregi('<title>([^<]*)</title>', $contents, $title)) {    $title = strip_tags($title[0]);    $contents = ereg_replace('<title>[^<]*</title>', '', $contents);  }  else {    list($title, $contents) = explode("\n", $contents, 2);  }  return $title;}function blogapi_admin_settings() {  $node_types = array_map('check_plain', node_get_types('names'));  $defaults = isset($node_types['blog']) ? array('blog' => 1) : array();  $form['blogapi_node_types'] = array(    '#type' => 'checkboxes',    '#title' => t('Enable for external blogging clients'),    '#required' => TRUE,    '#default_value' => variable_get('blogapi_node_types', $defaults),    '#options' => $node_types,    '#description' => t('Select the content types available to external blogging clients via Blog API. If supported, each enabled content type will be displayed as a separate "blog" by the external client.')  );  $blogapi_extensions_default = variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp');  $blogapi_uploadsize_default = variable_get('blogapi_uploadsize_default', 1);  $blogapi_usersize_default = variable_get('blogapi_usersize_default', 1);  $form['settings_general'] = array(    '#type' => 'fieldset',    '#title' => t('File settings'),    '#collapsible' => TRUE,  );  $form['settings_general']['blogapi_extensions_default'] = array(    '#type' => 'textfield',    '#title' => t('Default permitted file extensions'),    '#default_value' => $blogapi_extensions_default,    '#maxlength' => 255,    '#description' => t('Default extensions that users can upload. Separate extensions with a space and do not include the leading dot.'),  );  $form['settings_general']['blogapi_uploadsize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default maximum file size per upload'),    '#default_value' => $blogapi_uploadsize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum file size a user can upload.'),    '#field_suffix' => t('MB')  );  $form['settings_general']['blogapi_usersize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default total file size per user'),    '#default_value' => $blogapi_usersize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum size of all files a user can have on the site.'),    '#field_suffix' => t('MB')  );  $form['settings_general']['upload_max_size'] = array('#value' => '<p>'. t('Your PHP settings limit the maximum file size per upload to %size.', array('%size' => format_size(file_upload_max_size()))).'</p>');  $roles = user_roles(0, 'administer content with blog api');  $form['roles'] = array('#type' => 'value', '#value' => $roles);  foreach ($roles as $rid => $role) {    $form['settings_role_'. $rid] = array(      '#type' => 'fieldset',      '#title' => t('Settings for @role', array('@role' => $role)),      '#collapsible' => TRUE,      '#collapsed' => TRUE,    );    $form['settings_role_'. $rid]['blogapi_extensions_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Permitted file extensions'),      '#default_value' => variable_get('blogapi_extensions_'. $rid, $blogapi_extensions_default),      '#maxlength' => 255,      '#description' => t('Extensions that users in this role can upload. Separate extensions with a space and do not include the leading dot.'),    );    $form['settings_role_'. $rid]['blogapi_uploadsize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Maximum file size per upload'),      '#default_value' => variable_get('blogapi_uploadsize_'. $rid, $blogapi_uploadsize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of a file a user can upload (in megabytes).'),    );    $form['settings_role_'. $rid]['blogapi_usersize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Total file size per user'),      '#default_value' => variable_get('blogapi_usersize_'. $rid, $blogapi_usersize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of all files a user can have on the site (in megabytes).'),    );  }  return system_settings_form($form);}function blogapi_menu() {  $items['blogapi/rsd'] = array(    'title' => 'RSD',    'page callback' => 'blogapi_rsd',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/blogapi'] = array(    'title' => 'Blog API',    'description' => 'Configure the content types available to external blogging clients.',    'page callback' => 'drupal_get_form',    'page arguments' => array('blogapi_admin_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_NORMAL_ITEM,  );  return $items;}function blogapi_init() {  if (drupal_is_front_page()) {    drupal_add_link(array('rel' => 'EditURI',                          'type' => 'application/rsd+xml',                          'title' => t('RSD'),                          'href' => url('blogapi/rsd', array('absolute' => TRUE))));  }}function blogapi_rsd() {  global $base_url;  $xmlrpc = $base_url .'/xmlrpc.php';  $base = url('', array('absolute' => TRUE));  $blogid = 1; # until we figure out how to handle multiple bloggers  drupal_set_header('Content-Type: application/rsd+xml; charset=utf-8');  print <<<__RSD__<?xml version="1.0"?><rsd version="1.0" xmlns="http://archipelago.phrasewise.com/rsd">  <service>    <engineName>Drupal</engineName>    <engineLink>http://drupal.org/</engineLink>    <homePageLink>$base</homePageLink>    <apis>      <api name="MetaWeblog" preferred="false" apiLink="$xmlrpc" blogID="$blogid" />      <api name="Blogger" preferred="false" apiLink="$xmlrpc" blogID="$blogid" />      <api name="MovableType" preferred="true" apiLink="$xmlrpc" blogID="$blogid" />    </apis>  </service></rsd>__RSD__;}/** * Handles extra information sent by clients according to MovableType's spec. */function _blogapi_mt_extra(&$node, $struct) {  if (is_array($node)) {    $was_array = TRUE;    $node = (object)$node;  }  // mt_allow_comments  if (array_key_exists('mt_allow_comments', $struct)) {    switch ($struct['mt_allow_comments']) {      case 0:        $node->comment = COMMENT_NODE_DISABLED;        break;      case 1:        $node->comment = COMMENT_NODE_READ_WRITE;        break;      case 2:        $node->comment = COMMENT_NODE_READ_ONLY;        break;    }  }  // merge the 3 body sections (description, mt_excerpt, mt_text_more) into  // one body  if ($struct['mt_excerpt']) {    $node->body = $struct['mt_excerpt'] .'<!--break-->'. $node->body;  }  if ($struct['mt_text_more']) {    $node->body = $node->body .'<!--extended-->'. $struct['mt_text_more'];  }  // mt_convert_breaks  if ($struct['mt_convert_breaks']) {    $node->format = $struct['mt_convert_breaks'];  }  // dateCreated  if ($struct['dateCreated']) {    $node->date = format_date(mktime($struct['dateCreated']->hour, $struct['dateCreated']->minute, $struct['dateCreated']->second, $struct['dateCreated']->month, $struct['dateCreated']->day, $struct['dateCreated']->year), 'custom', 'Y-m-d H:i:s O');  }  if ($was_array) {    $node = (array)$node;  }}function _blogapi_get_post($node, $bodies = TRUE) {  $xmlrpcval = array(    'userid' => $node->name,    'dateCreated' => xmlrpc_date($node->created),    'title' => $node->title,    'postid' => $node->nid,    'link' => url('node/'. $node->nid, array('absolute' => TRUE)),    'permaLink' => url('node/'. $node->nid, array('absolute' => TRUE)),  );  if ($bodies) {    if ($node->comment == 1) {      $comment = 2;    }    else if ($node->comment == 2) {      $comment = 1;    }    $xmlrpcval['content'] = "<title>$node->title</title>$node->body";    $xmlrpcval['description'] = $node->body;    // Add MT specific fields    $xmlrpcval['mt_allow_comments'] = (int) $comment;    $xmlrpcval['mt_convert_breaks'] = $node->format;  }  return $xmlrpcval;}/** * Validate blog ID, which maps to a content type in Drupal. * * Only content types configured to work with Blog API are supported. * * @return *   TRUE if the content type is supported and the user has permission *   to post, or a blogapi_error() XML construct otherwise. */function _blogapi_validate_blogid($blogid) {  $types = _blogapi_get_node_types();  if (in_array($blogid, $types, TRUE)) {    return TRUE;  }  return blogapi_error(t("Blog API module is not configured to support the %type content type, or you don't have sufficient permissions to post this type of content.", array('%type' => $blogid)));}function _blogapi_get_node_types() {  $available_types = array_keys(array_filter(variable_get('blogapi_node_types', array('blog' => 1))));  $types = array();  foreach (node_get_types() as $type => $name) {    if (node_access('create', $type) && in_array($type, $available_types)) {      $types[] = $type;    }  }  return $types;}function _blogapi_space_used($uid) {  return db_result(db_query('SELECT SUM(filesize) FROM {blogapi_files} f WHERE f.uid = %d', $uid));}
<?php// $Id$?><div class="comment<?php print ($comment->new) ? ' comment-new' : ''; print ' '. $status; print ' '. $zebra; ?>">  <div class="clear-block">  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted; ?></span>  <?php endif; ?>  <?php if ($comment->new) : ?>    <span class="new"><?php print drupal_ucfirst($new) ?></span>  <?php endif; ?>  <?php print $picture ?>    <h3><?php print $title ?></h3>    <div class="content">      <?php print $content ?>      <?php if ($signature): ?>      <div class="clear-block">        <div></div>        <?php print $signature ?>      </div>      <?php endif; ?>    </div>  </div>  <?php if ($links): ?>    <div class="links"><?php print $links ?></div>  <?php endif; ?></div>
<?php// $Id$/** * @file *   Add language handling functionality and enables the translation of the *   user interface to languages other than English. * *   When enabled, multiple languages can be set up. The site interface *   can be displayed in different languages, as well as nodes can have languages *   assigned. The setup of languages and translations is completely web based. *   Gettext portable object files are supported. */// ---------------------------------------------------------------------------------// Hook implementations/** * Implementation of hook_help(). */function locale_help($path, $arg) {  switch ($path) {    case 'admin/help#locale':      $output = '<p>'. t('The locale module allows your Drupal site to be presented in languages other than the default English, a defining feature of multi-lingual websites. The locale module works by examining text as it is about to be displayed: when a translation of the text is available in the language to be displayed, the translation is displayed rather than the original text. When a translation is unavailable, the original text is displayed, and then stored for later review by a translator.') .'</p>';      $output .= '<p>'. t('Beyond translation of the Drupal interface, the locale module provides a feature set tailored to the needs of a multi-lingual site. Language negotiation allows your site to automatically change language based on the domain or path used for each request. Users may (optionally) select their preferred language on their <em>My account</em> page, and your site can be configured to honor a web browser\'s preferred language settings. Your site content can be created in (and translated to) any enabled language, and each post may have a language-appropriate alias for each of its translations. The locale module works in concert with the <a href="@content-help">content translation module</a> to manage translated content.', array('@content-help' => url('admin/help/translation'))) .'</p>';      $output .= '<p>'. t('Translations may be provided by:') .'</p>';      $output .= '<ul><li>'. t("translating the original text via the locale module's integrated web interface, or") .'</li>';      $output .= '<li>'. t('importing files from a set of existing translations, known as a translation package. A translation package enables the display of a specific version of Drupal in a specific language, and contain files in the Gettext Portable Object (<em>.po</em>) format. Although not all languages are available for every version of Drupal, translation packages for many languages are available for download from the <a href="@translations">Drupal translation page</a>.', array('@translations' => 'http://drupal.org/project/translations')) .'</li></ul>';      $output .= '<p>'. t('If an existing translation package does not meet your needs, the Gettext Portable Object (<em>.po</em>) files within a package may be modified, or new <em>.po</em> files may be created, using a desktop Gettext editor. The locale module\'s <a href="@import">import</a> feature allows the translated strings from a new or modified <em>.po</em> file to be added to your site. The locale module\'s <a href="@export">export</a> feature generates files from your site\'s translated strings, that can either be shared with others or edited offline by a Gettext translation editor.', array('@import' => url('admin/build/translate/import'), '@export' => url('admin/build/translate/export'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@locale">Locale module</a>.', array('@locale' => 'http://drupal.org/handbook/modules/locale/')) .'</p>';      return $output;    case 'admin/settings/language':      $output = '<p>'. t("This page provides an overview of your site's enabled languages. If multiple languages are available and enabled, the text on your site interface may be translated, registered users may select their preferred language on the <em>My account</em> page, and site authors may indicate a specific language when creating posts. The site's default language is used for anonymous visitors and for users who have not selected a preferred language.") .'</p>';      $output .= '<p>'. t('For each language available on the site, use the <em>edit</em> link to configure language details, including name, an optional language-specific path or domain, and whether the language is natively presented either left-to-right or right-to-left. These languages also appear in the <em>Language</em> selection when creating a post of a content type with multilingual support.') .'</p>';      $output .= '<p>'. t('Use the <a href="@add-language">add language page</a> to enable additional languages (and automatically import files from a translation package, if available), the <a href="@search">translate interface page</a> to locate strings for manual translation, or the <a href="@import">import page</a> to add translations from individual <em>.po</em> files. A number of contributed translation packages containing <em>.po</em> files are available on the <a href="@translations">Drupal.org translations page</a>.', array('@add-language' => url('admin/settings/language/add'), '@search' => url('admin/build/translate/search'), '@import' => url('admin/build/translate/import'), '@translations' => 'http://drupal.org/project/translations')) .'</p>';      return $output;    case 'admin/settings/language/add':      return '<p>'. t('Add all languages to be supported by your site. If your desired language is not available in the <em>Language name</em> drop-down, click <em>Custom language</em> and provide a language code and other details manually. When providing a language code manually, be sure to enter a standardized language code, since this code may be used by browsers to determine an appropriate display language.') .'</p>';    case 'admin/settings/language/configure':      $output = '<p>'. t("Language negotiation settings determine the site's presentation language. Available options include:") .'</p>';      $output .= '<ul><li>'. t('<strong>None.</strong> The default language is used for site presentation, though users may (optionally) select a preferred language on the <em>My Account</em> page. (User language preferences will be used for site e-mails, if available.)') .'</li>';      $output .= '<li>'. t('<strong>Path prefix only.</strong> The presentation language is determined by examining the path for a language code or other custom string that matches the path prefix (if any) specified for each language. If a suitable prefix is not identified, the default language is used. <em>Example: "example.com/de/contact" sets presentation language to German based on the use of "de" within the path.</em>') .'</li>';      $output .= '<li>'. t("<strong>Path prefix with language fallback.</strong> The presentation language is determined by examining the path for a language code or other custom string that matches the path prefix (if any) specified for each language. If a suitable prefix is not identified, the display language is determined by the user's language preferences from the <em>My Account</em> page, or by the browser's language settings. If a presentation language cannot be determined, the default language is used.") .'</li>';      $output .= '<li>'. t('<strong>Domain name only.</strong> The presentation language is determined by examining the domain used to access the site, and comparing it to the language domain (if any) specified for each language. If a match is not identified, the default language is used. <em>Example: "http://de.example.com/contact" sets presentation language to German based on the use of "http://de.example.com" in the domain.</em>') .'</li></ul>';      $output .= '<p>'. t('The path prefix or domain name for a language may be set by editing the <a href="@languages">available languages</a>. In the absence of an appropriate match, the site is displayed in the <a href="@languages">default language</a>.', array('@languages' => url('admin/settings/language'))) .'</p>';      return $output;    case 'admin/build/translate':      $output = '<p>'. t('This page provides an overview of available translatable strings. Drupal displays translatable strings in text groups; modules may define additional text groups containing other translatable strings. Because text groups provide a method of grouping related strings, they are often used to focus translation efforts on specific areas of the Drupal interface.') .'</p>';      $output .= '<p>'. t('Review the <a href="@languages">languages page</a> for more information on adding support for additional languages.', array('@languages' => url('admin/settings/language'))) .'</p>';      return $output;    case 'admin/build/translate/import':      $output = '<p>'. t('This page imports the translated strings contained in an individual Gettext Portable Object (<em>.po</em>) file. Normally distributed as part of a translation package (each translation package may contain several <em>.po</em> files), a <em>.po</em> file may need to be imported after off-line editing in a Gettext translation editor. Importing an individual <em>.po</em> file may be a lengthy process.') .'</p>';      $output .= '<p>'. t('Note that the <em>.po</em> files within a translation package are imported automatically (if available) when new modules or themes are enabled, or as new languages are added. Since this page only allows the import of one <em>.po</em> file at a time, it may be simpler to download and extract a translation package into your Drupal installation directory and <a href="@language-add">add the language</a> (which automatically imports all <em>.po</em> files within the package). Translation packages are available for download on the <a href="@translations">Drupal translation page</a>.', array('@language-add' => url('admin/settings/language/add'), '@translations' => 'http://drupal.org/project/translations')) .'</p>';      return $output;    case 'admin/build/translate/export':      return '<p>'. t('This page exports the translated strings used by your site. An export file may be in Gettext Portable Object (<em>.po</em>) form, which includes both the original string and the translation (used to share translations with others), or in Gettext Portable Object Template (<em>.pot</em>) form, which includes the original strings only (used to create new translations with a Gettext translation editor).') .'</p>';    case 'admin/build/translate/search':      return '<p>'. t('This page allows a translator to search for specific translated and untranslated strings, and is used when creating or editing translations. (Note: For translation tasks involving many strings, it may be more convenient to <a href="@export">export</a> strings for off-line editing in a desktop Gettext translation editor.) Searches may be limited to strings found within a specific text group or in a specific language.', array('@export' => url('admin/build/translate/export'))) .'</p>';    case 'admin/build/block/configure':      if ($arg[4] == 'locale' && $arg[5] == 0) {        return '<p>'. t('This block is only shown if <a href="@languages">at least two languages are enabled</a> and <a href="@configuration">language negotiation</a> is set to something other than <em>None</em>.', array('@languages' => url('admin/settings/language'), '@configuration' => url('admin/settings/language/configure'))) .'</p>';      }      break;  }}/** * Implementation of hook_menu(). * * Locale module only provides administrative menu items, so all * menu items are invoked through locale_inc_callback(). */function locale_menu() {  // Manage languages  $items['admin/settings/language'] = array(    'title' => 'Languages',    'description' => 'Configure languages for content and the user interface.',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_languages_overview_form'),    'access arguments' => array('administer languages'),  );  $items['admin/settings/language/overview'] = array(    'title' => 'List',    'weight' => 0,    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/settings/language/add'] = array(    'title' => 'Add language',    'page callback' => 'locale_inc_callback',    'page arguments' => array('locale_languages_add_screen'), // two forms concatenated    'access arguments' => array('administer languages'),    'weight' => 5,    'type' => MENU_LOCAL_TASK,  );  $items['admin/settings/language/configure'] = array(    'title' => 'Configure',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_languages_configure_form'),    'access arguments' => array('administer languages'),    'weight' => 10,    'type' => MENU_LOCAL_TASK,  );  $items['admin/settings/language/edit/%'] = array(    'title' => 'Edit language',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_languages_edit_form', 4),    'access arguments' => array('administer languages'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/language/delete/%'] = array(    'title' => 'Confirm',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_languages_delete_form', 4),    'access arguments' => array('administer languages'),    'type' => MENU_CALLBACK,  );  // Translation functionality  $items['admin/build/translate'] = array(    'title' => 'Translate interface',    'description' => 'Translate the built in interface and optionally other text.',    'page callback' => 'locale_inc_callback',    'page arguments' => array('locale_translate_overview_screen'), // not a form, just a table    'access arguments' => array('translate interface'),  );  $items['admin/build/translate/overview'] = array(    'title' => 'Overview',    'weight' => 0,    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/build/translate/search'] = array(    'title' => 'Search',    'weight' => 10,    'type' => MENU_LOCAL_TASK,    'page callback' => 'locale_inc_callback',    'page arguments' => array('locale_translate_seek_screen'), // search results and form concatenated    'access arguments' => array('translate interface'),  );  $items['admin/build/translate/import'] = array(    'title' => 'Import',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_translate_import_form'),    'access arguments' => array('translate interface'),    'weight' => 20,    'type' => MENU_LOCAL_TASK,  );  $items['admin/build/translate/export'] = array(    'title' => 'Export',    'page callback' => 'locale_inc_callback',    'page arguments' => array('locale_translate_export_screen'), // possibly multiple forms concatenated    'access arguments' => array('translate interface'),    'weight' => 30,    'type' => MENU_LOCAL_TASK,  );  $items['admin/build/translate/edit/%'] = array(    'title' => 'Edit string',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_translate_edit_form', 4),    'access arguments' => array('translate interface'),    'type' => MENU_CALLBACK,  );  $items['admin/build/translate/delete/%'] = array(    'title' => 'Delete string',    'page callback' => 'locale_inc_callback',    'page arguments' => array('locale_translate_delete_page', 4),    'access arguments' => array('translate interface'),    'type' => MENU_CALLBACK,  );  return $items;}/** * Wrapper function to be able to set callbacks in locale.inc */function locale_inc_callback() {  $args = func_get_args();  $function = array_shift($args);  include_once './includes/locale.inc';  return call_user_func_array($function, $args);}/** * Implementation of hook_perm(). */function locale_perm() {  return array('administer languages', 'translate interface');}/** * Implementation of hook_locale(). */function locale_locale($op = 'groups') {  switch ($op) {    case 'groups':      return array('default' => t('Built-in interface'));  }}/** * Implementation of hook_user(). */function locale_user($type, $edit, &$user, $category = NULL) {  global $language;  // If we have more then one language and either creating a user on the  // admin interface or edit the user, show the language selector.  if (variable_get('language_count', 1) > 1 && ($type == 'register' && user_access('administer users') || $type == 'form' && $category == 'account' )) {    $languages = language_list('enabled');    $languages = $languages[1];    // If the user is being created, we set the user language to the page language.    $user_preferred_language = $user ? user_preferred_language($user) : $language;    $names = array();    foreach ($languages as $langcode => $item) {      $name = t($item->name);      $names[check_plain($langcode)] = check_plain($name . ($item->native != $name ? ' ('. $item->native .')' : ''));    }    $form['locale'] = array(      '#type' => 'fieldset',      '#title' => t('Language settings'),      '#weight' => 1,    );    // Get language negotiation settings.    $mode = variable_get('language_negotiation', LANGUAGE_NEGOTIATION_NONE);    $form['locale']['language'] = array(      '#type' => (count($names) <= 5 ? 'radios' : 'select'),      '#title' => t('Language'),      '#default_value' => check_plain($user_preferred_language->language),      '#options' => $names,      '#description' => ($mode == LANGUAGE_NEGOTIATION_PATH) ? t("This account's default language for e-mails, and preferred language for site presentation.") : t("This account's default language for e-mails."),    );    return $form;  }}/** * Implementation of hook_form_alter(). Adds language fields to forms. */function locale_form_alter(&$form, $form_state, $form_id) {  switch ($form_id) {    // Language field for paths    case 'path_admin_form':      $form['language'] = array(        '#type' => 'select',        '#title' => t('Language'),        '#options' => array('' => t('All languages')) + locale_language_list('name'),        '#default_value' => $form['language']['#value'],        '#weight' => -10,        '#description' => t('A path alias set for a specific language will always be used when displaying this page in that language, and takes precedence over path aliases set for <em>All languages</em>.'),      );      break;    // Language setting for content types    case 'node_type_form':      if (isset($form['identity']['type'])) {        $form['workflow']['language_content_type'] = array(          '#type' => 'radios',          '#title' => t('Multilingual support'),          '#default_value' => variable_get('language_content_type_'. $form['#node_type']->type, 0),          '#options' => array(t('Disabled'), t('Enabled')),          '#description' => t('Enable multilingual support for this content type. If enabled, a language selection field will be added to the editing form, allowing you to select from one of the <a href="!languages">enabled languages</a>. If disabled, new posts are saved with the default language. Existing content will not be affected by changing this option.', array('!languages' => url('admin/settings/language'))),        );      }      break;    // Language field for nodes    default:      if (isset($form['#id']) && $form['#id'] == 'node-form') {        if (isset($form['#node']->type) && variable_get('language_content_type_'. $form['#node']->type, 0)) {          $form['language'] = array(            '#type' => 'select',            '#title' => t('Language'),            '#default_value' => (isset($form['#node']->language) ? $form['#node']->language : ''),            '#options' => array('' => t('Language neutral')) + locale_language_list('name'),          );        }        // Node type without language selector: assign the default for new nodes        elseif (!isset($form['#node']->nid)) {          $default = language_default();          $form['language'] = array(            '#type' => 'value',            '#value' => $default->language          );        }      }  }}/** * Implementation of hook_theme() */function locale_theme() {  return array(    'locale_languages_overview_form' => array(      'arguments' => array('form' => array()),    ),  );}/** * Implementation of hook_node_type(). */function locale_node_type($op, $info) {  if ($op == 'delete') {    variable_del('language_content_type_'. $info->type);  }}// ---------------------------------------------------------------------------------// Locale core functionality/** * Provides interface translation services. * * This function is called from t() to translate a string if needed. * * @param $string *   A string to look up translation for. If omitted, all the *   cached strings will be returned in all languages already *   used on the page. * @param $langcode *   Language code to use for the lookup. * @param $reset *   Set to TRUE to reset the in-memory cache. */function locale($string = NULL, $langcode = NULL, $reset = FALSE) {  global $language;  static $locale_t;  if ($reset) {    // Reset in-memory cache.    $locale_t = NULL;  }  if (!isset($string)) {    // Return all cached strings if no string was specified    return $locale_t;  }  $langcode = isset($langcode) ? $langcode : $language->language;  // Store database cached translations in a static var.  if (!isset($locale_t[$langcode])) {    $locale_t[$langcode] = array();    // Disabling the usage of string caching allows a module to watch for    // the exact list of strings used on a page. From a performance    // perspective that is a really bad idea, so we have no user    // interface for this. Be careful when turning this option off!    if (variable_get('locale_cache_strings', 1) == 1) {      if ($cache = cache_get('locale:'. $langcode, 'cache')) {        $locale_t[$langcode] = $cache->data;      }      elseif (lock_acquire('locale_cache_' . $langcode)) {        // Refresh database stored cache of translations for given language.        // We only store short strings used in current version, to improve        // performance and consume less memory.        $result = db_query("SELECT s.source, t.translation, t.language FROM {locales_source} s LEFT JOIN {locales_target} t ON s.lid = t.lid AND t.language = '%s' WHERE s.textgroup = 'default' AND s.version = '%s' AND LENGTH(s.source) < 75", $langcode, VERSION);        while ($data = db_fetch_object($result)) {          $locale_t[$langcode][$data->source] = (empty($data->translation) ? TRUE : $data->translation);        }        cache_set('locale:'. $langcode, $locale_t[$langcode]);        lock_release('locale_cache_' . $langcode);      }    }  }  // If we have the translation cached, skip checking the database  if (!isset($locale_t[$langcode][$string])) {    // We do not have this translation cached, so get it from the DB.    $translation = db_fetch_object(db_query("SELECT s.lid, t.translation, s.version FROM {locales_source} s LEFT JOIN {locales_target} t ON s.lid = t.lid AND t.language = '%s' WHERE s.source = '%s' AND s.textgroup = 'default'", $langcode, $string));    if ($translation) {      // We have the source string at least.      // Cache translation string or TRUE if no translation exists.      $locale_t[$langcode][$string] = (empty($translation->translation) ? TRUE : $translation->translation);      if ($translation->version != VERSION) {        // This is the first use of this string under current Drupal version. Save version        // and clear cache, to include the string into caching next time. Saved version is        // also a string-history information for later pruning of the tables.        db_query("UPDATE {locales_source} SET version = '%s' WHERE lid = %d", VERSION, $translation->lid);        cache_clear_all('locale:', 'cache', TRUE);      }    }    else {      // We don't have the source string, cache this as untranslated.      db_query("INSERT INTO {locales_source} (location, source, textgroup, version) VALUES ('%s', '%s', 'default', '%s')", request_uri(), $string, VERSION);      $locale_t[$langcode][$string] = TRUE;      // Clear locale cache so this string can be added in a later request.      cache_clear_all('locale:', 'cache', TRUE);    }  }  return ($locale_t[$langcode][$string] === TRUE ? $string : $locale_t[$langcode][$string]);}/** * Returns plural form index for a specific number. * * The index is computed from the formula of this language. * * @param $count *   Number to return plural for. * @param $langcode *   Optional language code to translate to a language other than *   what is used to display the page. */function locale_get_plural($count, $langcode = NULL) {  global $language;  static $locale_formula, $plurals = array();  $langcode = $langcode ? $langcode : $language->language;  if (!isset($plurals[$langcode][$count])) {    if (!isset($locale_formula)) {      $language_list = language_list();      $locale_formula[$langcode] = $language_list[$langcode]->formula;    }    if ($locale_formula[$langcode]) {      $n = $count;      $plurals[$langcode][$count] = @eval('return intval('. $locale_formula[$langcode] .');');      return $plurals[$langcode][$count];    }    else {      $plurals[$langcode][$count] = -1;      return -1;    }  }  return $plurals[$langcode][$count];}/** * Returns a language name */function locale_language_name($lang) {  static $list = NULL;  if (!isset($list)) {    $list = locale_language_list();  }  return ($lang && isset($list[$lang])) ? $list[$lang] : t('All');}/** * Returns array of language names * * @param $field *   'name' => names in current language, localized *   'native' => native names * @param $all *   Boolean to return all languages or only enabled ones */function locale_language_list($field = 'name', $all = FALSE) {  if ($all) {    $languages = language_list();  }  else {    $languages = language_list('enabled');    $languages = $languages[1];  }  $list = array();  foreach ($languages as $language) {    $list[$language->language] = ($field == 'name') ? t($language->name) : $language->$field;  }  return $list;}/** * Imports translations when new modules or themes are installed or enabled. * * This function will either import translation for the component change * right away, or start a batch if more files need to be imported. * * @param $components *   An array of component (theme and/or module) names to import *   translations for. */function locale_system_update($components) {  include_once 'includes/locale.inc';  if ($batch = locale_batch_by_component($components)) {    batch_set($batch);  }}/** * Update JavaScript translation file, if required, and add it to the page. * * This function checks all JavaScript files currently added via drupal_add_js() * and invokes parsing if they have not yet been parsed for Drupal.t() * and Drupal.formatPlural() calls. Also refreshes the JavaScript translation * file if necessary, and adds it to the page. */function locale_update_js_files() {  global $language;  $dir = file_create_path(variable_get('locale_js_directory', 'languages'));  $parsed = variable_get('javascript_parsed', array());  // The first three parameters are NULL in order to get an array with all  // scopes. This is necessary to prevent recreation of JS translation files  // when new files are added for example in the footer.  $javascript = drupal_add_js(NULL, NULL, NULL);  $files = $new_files = FALSE;  foreach ($javascript as $scope) {    foreach ($scope as $type => $data) {      if ($type != 'setting' && $type != 'inline') {        foreach ($data as $filepath => $info) {          $files = TRUE;          if (!in_array($filepath, $parsed)) {            // Don't parse our own translations files.            if (substr($filepath, 0, strlen($dir)) != $dir) {              locale_inc_callback('_locale_parse_js_file', $filepath);              $parsed[] = $filepath;              $new_files = TRUE;            }          }        }      }    }  }  // If there are any new source files we parsed, invalidate existing  // JavaScript translation files for all languages, adding the refresh  // flags into the existing array.  if ($new_files) {    $parsed += locale_inc_callback('_locale_invalidate_js');  }  // If necessary, rebuild the translation file for the current language.  if (!empty($parsed['refresh:'. $language->language])) {    // Don't clear the refresh flag on failure, so that another try will    // be performed later.    if (locale_inc_callback('_locale_rebuild_js')) {      unset($parsed['refresh:'. $language->language]);    }    // Store any changes after refresh was attempted.    variable_set('javascript_parsed', $parsed);  }  // If no refresh was attempted, but we have new source files, we need  // to store them too. This occurs if current page is in English.  else if ($new_files) {    variable_set('javascript_parsed', $parsed);  }  // Add the translation JavaScript file to the page.  if ($files && !empty($language->javascript)) {    drupal_add_js($dir .'/'. $language->language .'_'. $language->javascript .'.js', 'core');  }}// ---------------------------------------------------------------------------------// Language switcher block/** * Implementation of hook_block(). * Displays a language switcher. Translation links may be provided by other modules. */function locale_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $block[0]['info'] = t('Language switcher');    // Not worth caching.    $block[0]['cache'] = BLOCK_NO_CACHE;    return $block;  }  // Only show if we have at least two languages and language dependent  // web addresses, so we can actually link to other language versions.  elseif ($op == 'view' && variable_get('language_count', 1) > 1 && variable_get('language_negotiation', LANGUAGE_NEGOTIATION_NONE) != LANGUAGE_NEGOTIATION_NONE) {    $path = drupal_is_front_page() ? '<front>' : $_GET['q'];    $languages = language_list('enabled');    $links = array();    foreach ($languages[1] as $language) {      $links[$language->language] = array(        'href'       => $path,        'title'      => $language->native,        'language'   => $language,        'attributes' => array('class' => 'language-link'),      );    }    // Allow modules to provide translations for specific links.    // A translation link may need to point to a different path or use    // a translated link text before going through l(), which will just    // handle the path aliases.    drupal_alter('translation_link', $links, $path);    $block['subject'] = t('Languages');    $block['content'] = theme('links', $links, array());    return $block;  }}
<?php// $Id$/** * @file * User page callback file for the user module. *//** * Menu callback; Retrieve a JSON object containing autocomplete suggestions for existing users. */function user_autocomplete($string = '') {  $matches = array();  if ($string) {    $result = db_query_range("SELECT name FROM {users} WHERE LOWER(name) LIKE LOWER('%s%%')", $string, 0, 10);    while ($user = db_fetch_object($result)) {      $matches[$user->name] = check_plain($user->name);    }  }  drupal_json($matches);}/** * Form builder; Request a password reset. * * @ingroup forms * @see user_pass_validate() * @see user_pass_submit() */function user_pass() {  $form['name'] = array(    '#type' => 'textfield',    '#title' => t('Username or e-mail address'),    '#size' => 60,    '#maxlength' => max(USERNAME_MAX_LENGTH, EMAIL_MAX_LENGTH),    '#required' => TRUE,  );  $form['submit'] = array('#type' => 'submit', '#value' => t('E-mail new password'));  return $form;}function user_pass_validate($form, &$form_state) {  $name = trim($form_state['values']['name']);    // Blocked accounts cannot request a new password,  // check provided username and email against access rules.  if (drupal_is_denied('user', $name) || drupal_is_denied('mail', $name)) {    form_set_error('name', t('%name is not allowed to request a new password.', array('%name' => $name)));  }  // Try to load by email.  $account = user_load(array('mail' => $name, 'status' => 1));  if (!$account) {    // No success, try to load by name.    $account = user_load(array('name' => $name, 'status' => 1));  }  if (isset($account->uid)) {    form_set_value(array('#parents' => array('account')), $account, $form_state);  }  else {    form_set_error('name', t('Sorry, %name is not recognized as a user name or an e-mail address.', array('%name' => $name)));  }}function user_pass_submit($form, &$form_state) {  global $language;  $account = $form_state['values']['account'];  // Mail one time login URL and instructions using current language.  _user_mail_notify('password_reset', $account, $language);  watchdog('user', 'Password reset instructions mailed to %name at %email.', array('%name' => $account->name, '%email' => $account->mail));  drupal_set_message(t('Further instructions have been sent to your e-mail address.'));  $form_state['redirect'] = 'user';  return;}/** * Menu callback; process one time login link and redirects to the user page on success. */function user_pass_reset(&$form_state, $uid, $timestamp, $hashed_pass, $action = NULL) {  global $user;  // Check if the user is already logged in. The back button is often the culprit here.  if ($user->uid) {    drupal_set_message(t('You have already used this one-time login link. It is not necessary to use this link to login anymore. You are already logged in.'));    drupal_goto();  }  else {    // Time out, in seconds, until login URL expires. 24 hours = 86400 seconds.    $timeout = 86400;    $current = time();    // Some redundant checks for extra security ?    if ($timestamp < $current && $account = user_load(array('uid' => $uid, 'status' => 1)) ) {      // Deny one-time login to blocked accounts.      if (drupal_is_denied('user', $account->name) || drupal_is_denied('mail', $account->mail)) {        drupal_set_message(t('You have tried to use a one-time login for an account which has been blocked.'), 'error');        drupal_goto();      }      // No time out for first time login.      if ($account->login && $current - $timestamp > $timeout) {        drupal_set_message(t('You have tried to use a one-time login link that has expired. Please request a new one using the form below.'));        drupal_goto('user/password');      }      else if ($account->uid && $timestamp > $account->login && $timestamp < $current && $hashed_pass == user_pass_rehash($account->pass, $timestamp, $account->login)) {        // First stage is a confirmation form, then login        if ($action == 'login') {          watchdog('user', 'User %name used one-time login link at time %timestamp.', array('%name' => $account->name, '%timestamp' => $timestamp));          // Set the new user.          $user = $account;          // user_authenticate_finalize() also updates the login timestamp of the          // user, which invalidates further use of the one-time login link.          user_authenticate_finalize($form_state['values']);          drupal_set_message(t('You have just used your one-time login link. It is no longer necessary to use this link to login. Please change your password.'));          drupal_goto('user/'. $user->uid .'/edit');        }        else {          $form['message'] = array('#value' => t('<p>This is a one-time login for %user_name and will expire on %expiration_date.</p><p>Click on this button to login to the site and change your password.</p>', array('%user_name' => $account->name, '%expiration_date' => format_date($timestamp + $timeout))));          $form['help'] = array('#value' => '<p>'. t('This login can be used only once.') .'</p>');          $form['submit'] = array('#type' => 'submit', '#value' => t('Log in'));          $form['#action'] = url("user/reset/$uid/$timestamp/$hashed_pass/login");          return $form;        }      }      else {        drupal_set_message(t('You have tried to use a one-time login link which has either been used or is no longer valid. Please request a new one using the form below.'));        drupal_goto('user/password');      }    }    else {      // Deny access, no more clues.      // Everything will be in the watchdog's URL for the administrator to check.      drupal_access_denied();    }  }}/** * Menu callback; logs the current user out, and redirects to the home page. */function user_logout() {  global $user;  watchdog('user', 'Session closed for %name.', array('%name' => $user->name));  // Destroy the current session:  session_destroy();  // Only variables can be passed by reference workaround.  $null = NULL;  user_module_invoke('logout', $null, $user);  // Load the anonymous user  $user = drupal_anonymous_user();  drupal_goto();}/** * Menu callback; Displays a user or user profile page. */function user_view($account) {  drupal_set_title(check_plain($account->name));  // Retrieve all profile fields and attach to $account->content.  user_build_content($account);  // To theme user profiles, copy modules/user/user_profile.tpl.php  // to your theme directory, and edit it as instructed in that file's comments.  return theme('user_profile', $account);}/** * Process variables for user-profile.tpl.php. * * The $variables array contains the following arguments: * - $account * * @see user-picture.tpl.php */function template_preprocess_user_profile(&$variables) {  $variables['profile'] = array();  // Sort sections by weight  uasort($variables['account']->content, 'element_sort');  // Provide keyed variables so themers can print each section independantly.  foreach (element_children($variables['account']->content) as $key) {    $variables['profile'][$key] = drupal_render($variables['account']->content[$key]);  }  // Collect all profiles to make it easier to print all items at once.  $variables['user_profile'] = implode($variables['profile']);}/** * Process variables for user-profile-item.tpl.php. * * The $variables array contains the following arguments: * - $element * * @see user-profile-item.tpl.php */function template_preprocess_user_profile_item(&$variables) {  $variables['title'] = $variables['element']['#title'];  $variables['value'] = $variables['element']['#value'];  $variables['attributes'] = '';  if (isset($variables['element']['#attributes'])) {    $variables['attributes'] = drupal_attributes($variables['element']['#attributes']);  }}/** * Process variables for user-profile-category.tpl.php. * * The $variables array contains the following arguments: * - $element * * @see user-profile-category.tpl.php */function template_preprocess_user_profile_category(&$variables) {  $variables['title'] = check_plain($variables['element']['#title']);  $variables['profile_items'] = $variables['element']['#children'];  $variables['attributes'] = '';  if (isset($variables['element']['#attributes'])) {    $variables['attributes'] = drupal_attributes($variables['element']['#attributes']);  }}/** * Form builder; Present the form to edit a given user or profile category. * * @ingroup forms * @see user_edit_validate() * @see user_edit_submit() */function user_edit($account, $category = 'account') {  drupal_set_title(check_plain($account->name));  return drupal_get_form('user_profile_form', $account, $category);}/** * Form builder; edit a user account or one of their profile categories. * * @ingroup forms * @see user_profile_form_validate() * @see user_profile_form_submit() * @see user_edit_delete_submit() */function user_profile_form($form_state, $account, $category = 'account') {  $edit = (empty($form_state['values'])) ? (array)$account : $form_state['values'];  $form = _user_forms($edit, $account, $category);  $form['_category'] = array('#type' => 'value', '#value' => $category);  $form['_account'] = array('#type' => 'value', '#value' => $account);  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 30);  if (user_access('administer users')) {    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete'),      '#weight' => 31,      '#submit' => array('user_edit_delete_submit'),    );  }  $form['#attributes']['enctype'] = 'multipart/form-data';  return $form;}/** * Validation function for the user account and profile editing form. */function user_profile_form_validate($form, &$form_state) {  user_module_invoke('validate', $form_state['values'], $form_state['values']['_account'], $form_state['values']['_category']);  // Validate input to ensure that non-privileged users can't alter protected data.  if ((!user_access('administer users') && array_intersect(array_keys($form_state['values']), array('uid', 'init', 'session'))) || (!user_access('administer permissions') && isset($form_state['values']['roles']))) {    watchdog('security', 'Detected malicious attempt to alter protected user fields.', array(), WATCHDOG_WARNING);    // set this to a value type field    form_set_error('category', t('Detected malicious attempt to alter protected user fields.'));  }}/** * Submit function for the user account and profile editing form. */function user_profile_form_submit($form, &$form_state) {  $account = $form_state['values']['_account'];  $category = $form_state['values']['_category'];  unset($form_state['values']['_account'], $form_state['values']['op'], $form_state['values']['submit'], $form_state['values']['delete'], $form_state['values']['form_token'], $form_state['values']['form_id'], $form_state['values']['_category']);  user_module_invoke('submit', $form_state['values'], $account, $category);  user_save($account, $form_state['values'], $category);  // Clear the page cache because pages can contain usernames and/or profile information:  cache_clear_all();  drupal_set_message(t('The changes have been saved.'));  return;}/** * Submit function for the 'Delete' button on the user edit form. */function user_edit_delete_submit($form, &$form_state) {  $destination = '';  if (isset($_REQUEST['destination'])) {    $destination = drupal_get_destination();    unset($_REQUEST['destination']);  }  // Note: We redirect from user/uid/edit to user/uid/delete to make the tabs disappear.  $form_state['redirect'] = array("user/". $form_state['values']['_account']->uid ."/delete", $destination);}/** * Form builder; confirm form for user deletion. * * @ingroup forms * @see user_confirm_delete_submit() */function user_confirm_delete(&$form_state, $account) {  $form['_account'] = array('#type' => 'value', '#value' => $account);  return confirm_form($form,    t('Are you sure you want to delete the account %name?', array('%name' => $account->name)),    'user/'. $account->uid,    t('All submissions made by this user will be attributed to the anonymous account. This action cannot be undone.'),    t('Delete'), t('Cancel'));}/** * Submit function for the confirm form for user deletion. */function user_confirm_delete_submit($form, &$form_state) {  user_delete($form_state['values'], $form_state['values']['_account']->uid);  drupal_set_message(t('%name has been deleted.', array('%name' => $form_state['values']['_account']->name)));  if (!isset($_REQUEST['destination'])) {    $form_state['redirect'] = 'admin/user/user';  }}function user_edit_validate($form, &$form_state) {  user_module_invoke('validate', $form_state['values'], $form_state['values']['_account'], $form_state['values']['_category']);  // Validate input to ensure that non-privileged users can't alter protected data.  if ((!user_access('administer users') && array_intersect(array_keys($form_state['values']), array('uid', 'init', 'session'))) || (!user_access('administer permissions') && isset($form_state['values']['roles']))) {    watchdog('security', 'Detected malicious attempt to alter protected user fields.', array(), WATCHDOG_WARNING);    // set this to a value type field    form_set_error('category', t('Detected malicious attempt to alter protected user fields.'));  }}function user_edit_submit($form, &$form_state) {  $account = $form_state['values']['_account'];  $category = $form_state['values']['_category'];  unset($form_state['values']['_account'], $form_state['values']['op'], $form_state['values']['submit'], $form_state['values']['delete'], $form_state['values']['form_token'], $form_state['values']['form_id'], $form_state['values']['_category']);  user_module_invoke('submit', $form_state['values'], $account, $category);  user_save($account, $form_state['values'], $category);  // Clear the page cache because pages can contain usernames and/or profile information:  cache_clear_all();  drupal_set_message(t('The changes have been saved.'));  return;}/** * Access callback for path /user. * * Displays user profile if user is logged in, or login form for anonymous * users. */function user_page() {  global $user;  if ($user->uid) {    menu_set_active_item('user/'. $user->uid);    return menu_execute_active_handler();  }  else {    return drupal_get_form('user_login');  }}
<?php// $Id$/** * @file * Admin page callbacks for the block module. *//** * Menu callback for admin/build/block. */function block_admin_display($theme = NULL) {  global $custom_theme;  // If non-default theme configuration has been selected, set the custom theme.  $custom_theme = isset($theme) ? $theme : variable_get('theme_default', 'garland');  // Fetch and sort blocks  $blocks = _block_rehash();  usort($blocks, '_block_compare');  return drupal_get_form('block_admin_display_form', $blocks, $theme);}/** * Generate main blocks administration form. */function block_admin_display_form(&$form_state, $blocks, $theme = NULL) {  global $theme_key, $custom_theme;  // Add CSS  drupal_add_css(drupal_get_path('module', 'block') .'/block.css', 'module', 'all', FALSE);  // If non-default theme configuration has been selected, set the custom theme.  $custom_theme = isset($theme) ? $theme : variable_get('theme_default', 'garland');  init_theme();  $throttle = module_exists('throttle');  $block_regions = system_region_list($theme_key) + array(BLOCK_REGION_NONE => '<'. t('none') .'>');  // Weights range from -delta to +delta, so delta should be at least half  // of the amount of blocks present. This makes sure all blocks in the same  // region get an unique weight.  $weight_delta = round(count($blocks) / 2);  // Build form tree  $form = array(    '#action' => arg(4) ? url('admin/build/block/list/'. $theme_key) : url('admin/build/block'),    '#tree' => TRUE,  );  foreach ($blocks as $i => $block) {    $key = $block['module'] .'_'. $block['delta'];    $form[$key]['module'] = array(      '#type' => 'value',      '#value' => $block['module'],    );    $form[$key]['delta'] = array(      '#type' => 'value',      '#value' => $block['delta'],    );    $form[$key]['info'] = array(      '#value' => check_plain($block['info'])    );    $form[$key]['theme'] = array(      '#type' => 'hidden',      '#value' => $theme_key    );    $form[$key]['weight'] = array(      '#type' => 'weight',      '#default_value' => $block['weight'],      '#delta' => $weight_delta,    );    $form[$key]['region'] = array(      '#type' => 'select',      '#default_value' => $block['region'],      '#options' => $block_regions,    );    if ($throttle) {      $form[$key]['throttle'] = array('#type' => 'checkbox', '#default_value' => isset($block['throttle']) ? $block['throttle'] : FALSE);    }    $form[$key]['configure'] = array('#value' => l(t('configure'), 'admin/build/block/configure/'. $block['module'] .'/'. $block['delta']));    if ($block['module'] == 'block') {      $form[$key]['delete'] = array('#value' => l(t('delete'), 'admin/build/block/delete/'. $block['delta']));    }  }  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save blocks'),  );  return $form;}/** * Process main blocks administration form submission. */function block_admin_display_form_submit($form, &$form_state) {  foreach ($form_state['values'] as $block) {    $block['status'] = $block['region'] != BLOCK_REGION_NONE;    $block['region'] = $block['status'] ? $block['region'] : '';    db_query("UPDATE {blocks} SET status = %d, weight = %d, region = '%s', throttle = %d WHERE module = '%s' AND delta = '%s' AND theme = '%s'", $block['status'], $block['weight'], $block['region'], isset($block['throttle']) ? $block['throttle'] : 0, $block['module'], $block['delta'], $block['theme']);  }  drupal_set_message(t('The block settings have been updated.'));  cache_clear_all();}/** * Helper function for sorting blocks on admin/build/block. * * Active blocks are sorted by region, then by weight. * Disabled blocks are sorted by name. */function _block_compare($a, $b) {  global $theme_key;  static $regions;  // We need the region list to correctly order by region.  if (!isset($regions)) {    $regions = array_flip(array_keys(system_region_list($theme_key)));    $regions[BLOCK_REGION_NONE] = count($regions);  }  // Separate enabled from disabled.  $status = $b['status'] - $a['status'];  if ($status) {    return $status;  }  // Sort by region (in the order defined by theme .info file).  if ((!empty($a['region']) && !empty($b['region'])) && ($place = ($regions[$a['region']] - $regions[$b['region']]))) {    return $place;  }  // Sort by weight.  $weight = $a['weight'] - $b['weight'];  if ($weight) {    return $weight;  }  // Sort by title.  return strcmp($a['info'], $b['info']);}/** * Menu callback; displays the block configuration form. */function block_admin_configure(&$form_state, $module = NULL, $delta = 0) {  $form['module'] = array('#type' => 'value', '#value' => $module);  $form['delta'] = array('#type' => 'value', '#value' => $delta);  $edit = db_fetch_array(db_query("SELECT pages, visibility, custom, title FROM {blocks} WHERE module = '%s' AND delta = '%s'", $module, $delta));  $form['block_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Block specific settings'),    '#collapsible' => TRUE,  );  $form['block_settings']['title'] = array(    '#type' => 'textfield',    '#title' => t('Block title'),    '#maxlength' => 64,    '#description' => $module == 'block' ? t('The title of the block as shown to the user.') : t('Override the default title for the block. Use <em>&lt;none&gt;</em> to display no title, or leave blank to use the default block title.'),    '#default_value' => $edit['title'],    '#weight' => -18,  );  // Module-specific block configurations.  if ($settings = module_invoke($module, 'block', 'configure', $delta)) {    foreach ($settings as $k => $v) {      $form['block_settings'][$k] = $v;    }  }  // Get the block subject for the page title.  $info = module_invoke($module, 'block', 'list');  if (isset($info[$delta])) {    drupal_set_title(t("'%name' block", array('%name' => $info[$delta]['info'])));  }  // Standard block configurations.  $form['user_vis_settings'] = array(    '#type' => 'fieldset',    '#title' => t('User specific visibility settings'),    '#collapsible' => TRUE,  );  $form['user_vis_settings']['custom'] = array(    '#type' => 'radios',    '#title' => t('Custom visibility settings'),    '#options' => array(      t('Users cannot control whether or not they see this block.'),      t('Show this block by default, but let individual users hide it.'),      t('Hide this block by default but let individual users show it.')    ),    '#description' => t('Allow individual users to customize the visibility of this block in their account settings.'),    '#default_value' => $edit['custom'],  );  // Role-based visibility settings  $default_role_options = array();  $result = db_query("SELECT rid FROM {blocks_roles} WHERE module = '%s' AND delta = '%s'", $module, $delta);  while ($role = db_fetch_object($result)) {    $default_role_options[] = $role->rid;  }  $result = db_query('SELECT rid, name FROM {role} ORDER BY name');  $role_options = array();  while ($role = db_fetch_object($result)) {    $role_options[$role->rid] = $role->name;  }  $form['role_vis_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Role specific visibility settings'),    '#collapsible' => TRUE,  );  $form['role_vis_settings']['roles'] = array(    '#type' => 'checkboxes',    '#title' => t('Show block for specific roles'),    '#default_value' => $default_role_options,    '#options' => $role_options,    '#description' => t('Show this block only for the selected role(s). If you select no roles, the block will be visible to all users.'),  );  $form['page_vis_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Page specific visibility settings'),    '#collapsible' => TRUE,  );  $access = user_access('use PHP for block visibility');  if ($edit['visibility'] == 2 && !$access) {    $form['page_vis_settings'] = array();    $form['page_vis_settings']['visibility'] = array('#type' => 'value', '#value' => 2);    $form['page_vis_settings']['pages'] = array('#type' => 'value', '#value' => $edit['pages']);  }  else {    $options = array(t('Show on every page except the listed pages.'), t('Show on only the listed pages.'));    $description = t("Enter one page per line as Drupal paths. The '*' character is a wildcard. Example paths are %blog for the blog page and %blog-wildcard for every personal blog. %front is the front page.", array('%blog' => 'blog', '%blog-wildcard' => 'blog/*', '%front' => '<front>'));    if ($access) {      $options[] = t('Show if the following PHP code returns <code>TRUE</code> (PHP-mode, experts only).');      $description .= ' '. t('If the PHP-mode is chosen, enter PHP code between %php. Note that executing incorrect PHP-code can break your Drupal site.', array('%php' => '<?php ?>'));    }    $form['page_vis_settings']['visibility'] = array(      '#type' => 'radios',      '#title' => t('Show block on specific pages'),      '#options' => $options,      '#default_value' => $edit['visibility'],    );    $form['page_vis_settings']['pages'] = array(      '#type' => 'textarea',      '#title' => t('Pages'),      '#default_value' => $edit['pages'],      '#description' => $description,    );  }  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save block'),  );  return $form;}function block_admin_configure_validate($form, &$form_state) {  if ($form_state['values']['module'] == 'block') {    if (empty($form_state['values']['info']) || db_result(db_query("SELECT COUNT(*) FROM {boxes} WHERE bid != %d AND info = '%s'", $form_state['values']['delta'], $form_state['values']['info']))) {      form_set_error('info', t('Please ensure that each block description is unique.'));    }  }}function block_admin_configure_submit($form, &$form_state) {  if (!form_get_errors()) {    db_query("UPDATE {blocks} SET visibility = %d, pages = '%s', custom = %d, title = '%s' WHERE module = '%s' AND delta = '%s'", $form_state['values']['visibility'], trim($form_state['values']['pages']), $form_state['values']['custom'], $form_state['values']['title'], $form_state['values']['module'], $form_state['values']['delta']);    db_query("DELETE FROM {blocks_roles} WHERE module = '%s' AND delta = '%s'", $form_state['values']['module'], $form_state['values']['delta']);    foreach (array_filter($form_state['values']['roles']) as $rid) {      db_query("INSERT INTO {blocks_roles} (rid, module, delta) VALUES (%d, '%s', '%s')", $rid, $form_state['values']['module'], $form_state['values']['delta']);    }    module_invoke($form_state['values']['module'], 'block', 'save', $form_state['values']['delta'], $form_state['values']);    drupal_set_message(t('The block configuration has been saved.'));    cache_clear_all();    $form_state['redirect'] = 'admin/build/block';    return;  }}/** * Menu callback: display the custom block addition form. */function block_add_block_form(&$form_state) {  return block_admin_configure($form_state, 'block', NULL);}function block_add_block_form_validate($form, &$form_state) {  if (empty($form_state['values']['info']) || db_result(db_query("SELECT COUNT(*) FROM {boxes} WHERE info = '%s'", $form_state['values']['info']))) {    form_set_error('info', t('Please ensure that each block description is unique.'));  }}/** * Save the new custom block. */function block_add_block_form_submit($form, &$form_state) {  db_query("INSERT INTO {boxes} (body, info, format) VALUES ('%s', '%s', %d)", $form_state['values']['body'], $form_state['values']['info'], $form_state['values']['format']);  $delta = db_last_insert_id('boxes', 'bid');  foreach (list_themes() as $key => $theme) {    if ($theme->status) {      db_query("INSERT INTO {blocks} (visibility, pages, custom, title, module, theme, status, weight, delta, cache) VALUES(%d, '%s', %d, '%s', '%s', '%s', %d, %d, '%s', %d)", $form_state['values']['visibility'], trim($form_state['values']['pages']), $form_state['values']['custom'], $form_state['values']['title'], $form_state['values']['module'], $theme->name, 0, 0, $delta, BLOCK_NO_CACHE);    }  }  foreach (array_filter($form_state['values']['roles']) as $rid) {    db_query("INSERT INTO {blocks_roles} (rid, module, delta) VALUES (%d, '%s', '%s')", $rid, $form_state['values']['module'], $delta);  }  drupal_set_message(t('The block has been created.'));  cache_clear_all();  $form_state['redirect'] = 'admin/build/block';  return;}/** * Menu callback; confirm deletion of custom blocks. */function block_box_delete(&$form_state, $bid = 0) {  $box = block_box_get($bid);  $form['info'] = array('#type' => 'hidden', '#value' => $box['info']);  $form['bid'] = array('#type' => 'hidden', '#value' => $bid);  return confirm_form($form, t('Are you sure you want to delete the block %name?', array('%name' => $box['info'])), 'admin/build/block', '', t('Delete'), t('Cancel'));}/** * Deletion of custom blocks. */function block_box_delete_submit($form, &$form_state) {  db_query('DELETE FROM {boxes} WHERE bid = %d', $form_state['values']['bid']);  db_query("DELETE FROM {blocks} WHERE module = 'block' AND delta = '%s'", $form_state['values']['bid']);  drupal_set_message(t('The block %name has been removed.', array('%name' => $form_state['values']['info'])));  cache_clear_all();  $form_state['redirect'] = 'admin/build/block';  return;}/** * Process variables for block-admin-display.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see block-admin-display.tpl.php * @see theme_block_admin_display() */function template_preprocess_block_admin_display_form(&$variables) {  global $theme_key;  $block_regions = system_region_list($theme_key);  $variables['throttle'] = module_exists('throttle');  $variables['block_regions'] = $block_regions + array(BLOCK_REGION_NONE => t('Disabled'));  foreach ($block_regions as $key => $value) {    // Highlight regions on page to provide visual reference.    drupal_set_content($key, '<div class="block-region">'. $value .'</div>');    // Initialize an empty array for the region.    $variables['block_listing'][$key] = array();  }  // Initialize disabled blocks array.  $variables['block_listing'][BLOCK_REGION_NONE] = array();  // Set up to track previous region in loop.  $last_region = '';  foreach (element_children($variables['form']) as $i) {    $block = &$variables['form'][$i];    // Only take form elements that are blocks.    if (isset($block['info'])) {      // Fetch region for current block.      $region = $block['region']['#default_value'];      // Set special classes needed for table drag and drop.      $variables['form'][$i]['region']['#attributes']['class'] = 'block-region-select block-region-'. $region;      $variables['form'][$i]['weight']['#attributes']['class'] = 'block-weight block-weight-'. $region;      $variables['block_listing'][$region][$i]->row_class = isset($block['#attributes']['class']) ? $block['#attributes']['class'] : '';      $variables['block_listing'][$region][$i]->block_modified = isset($block['#attributes']['class']) && strpos($block['#attributes']['class'], 'block-modified') !== FALSE ? TRUE : FALSE;      $variables['block_listing'][$region][$i]->block_title =  drupal_render($block['info']);      $variables['block_listing'][$region][$i]->region_select = drupal_render($block['region']) . drupal_render($block['theme']);      $variables['block_listing'][$region][$i]->weight_select = drupal_render($block['weight']);      $variables['block_listing'][$region][$i]->throttle_check = $variables['throttle'] ? drupal_render($block['throttle']) : '';      $variables['block_listing'][$region][$i]->configure_link = drupal_render($block['configure']);      $variables['block_listing'][$region][$i]->delete_link = !empty($block['delete']) ? drupal_render($block['delete']) : '';      $variables['block_listing'][$region][$i]->printed = FALSE;      $last_region = $region;    }  }  $variables['form_submit'] = drupal_render($variables['form']);}
<?php// $Id$/** * @file * API for the Drupal menu system. *//** * @defgroup menu Menu system * @{ * Define the navigation menus, and route page requests to code based on URLs. * * The Drupal menu system drives both the navigation system from a user * perspective and the callback system that Drupal uses to respond to URLs * passed from the browser. For this reason, a good understanding of the * menu system is fundamental to the creation of complex modules. * * Drupal's menu system follows a simple hierarchy defined by paths. * Implementations of hook_menu() define menu items and assign them to * paths (which should be unique). The menu system aggregates these items * and determines the menu hierarchy from the paths. For example, if the * paths defined were a, a/b, e, a/b/c/d, f/g, and a/b/h, the menu system * would form the structure: * - a *   - a/b *     - a/b/c/d *     - a/b/h * - e * - f/g * Note that the number of elements in the path does not necessarily * determine the depth of the menu item in the tree. * * When responding to a page request, the menu system looks to see if the * path requested by the browser is registered as a menu item with a * callback. If not, the system searches up the menu tree for the most * complete match with a callback it can find. If the path a/b/i is * requested in the tree above, the callback for a/b would be used. * * The found callback function is called with any arguments specified * in the "page arguments" attribute of its menu item. The * attribute must be an array. After these arguments, any remaining * components of the path are appended as further arguments. In this * way, the callback for a/b above could respond to a request for * a/b/i differently than a request for a/b/j. * * For an illustration of this process, see page_example.module. * * Access to the callback functions is also protected by the menu system. * The "access callback" with an optional "access arguments" of each menu * item is called before the page callback proceeds. If this returns TRUE, * then access is granted; if FALSE, then access is denied. Menu items may * omit this attribute to use the value provided by an ancestor item. * * In the default Drupal interface, you will notice many links rendered as * tabs. These are known in the menu system as "local tasks", and they are * rendered as tabs by default, though other presentations are possible. * Local tasks function just as other menu items in most respects. It is * convention that the names of these tasks should be short verbs if * possible. In addition, a "default" local task should be provided for * each set. When visiting a local task's parent menu item, the default * local task will be rendered as if it is selected; this provides for a * normal tab user experience. This default task is special in that it * links not to its provided path, but to its parent item's path instead. * The default task's path is only used to place it appropriately in the * menu hierarchy. * * Everything described so far is stored in the menu_router table. The * menu_links table holds the visible menu links. By default these are * derived from the same hook_menu definitions, however you are free to * add more with menu_link_save(). *//** * @name Menu flags * @{ * Flags for use in the "type" attribute of menu items. */define('MENU_IS_ROOT', 0x0001);define('MENU_VISIBLE_IN_TREE', 0x0002);define('MENU_VISIBLE_IN_BREADCRUMB', 0x0004);define('MENU_LINKS_TO_PARENT', 0x0008);define('MENU_MODIFIED_BY_ADMIN', 0x0020);define('MENU_CREATED_BY_ADMIN', 0x0040);define('MENU_IS_LOCAL_TASK', 0x0080);/** * @} End of "Menu flags". *//** * @name Menu item types * @{ * Menu item definitions provide one of these constants, which are shortcuts for * combinations of the above flags. *//** * Normal menu items show up in the menu tree and can be moved/hidden by * the administrator. Use this for most menu items. It is the default value if * no menu item type is specified. */define('MENU_NORMAL_ITEM', MENU_VISIBLE_IN_TREE | MENU_VISIBLE_IN_BREADCRUMB);/** * Callbacks simply register a path so that the correct function is fired * when the URL is accessed. They are not shown in the menu. */define('MENU_CALLBACK', MENU_VISIBLE_IN_BREADCRUMB);/** * Modules may "suggest" menu items that the administrator may enable. They act * just as callbacks do until enabled, at which time they act like normal items. * Note for the value: 0x0010 was a flag which is no longer used, but this way * the values of MENU_CALLBACK and MENU_SUGGESTED_ITEM are separate. */define('MENU_SUGGESTED_ITEM', MENU_VISIBLE_IN_BREADCRUMB | 0x0010);/** * Local tasks are rendered as tabs by default. Use this for menu items that * describe actions to be performed on their parent item. An example is the path * "node/52/edit", which performs the "edit" task on "node/52". */define('MENU_LOCAL_TASK', MENU_IS_LOCAL_TASK);/** * Every set of local tasks should provide one "default" task, that links to the * same path as its parent when clicked. */define('MENU_DEFAULT_LOCAL_TASK', MENU_IS_LOCAL_TASK | MENU_LINKS_TO_PARENT);/** * @} End of "Menu item types". *//** * @name Menu status codes * @{ * Status codes for menu callbacks. */define('MENU_FOUND', 1);define('MENU_NOT_FOUND', 2);define('MENU_ACCESS_DENIED', 3);define('MENU_SITE_OFFLINE', 4);/** * @} End of "Menu status codes". *//** * @Name Menu tree parameters * @{ * Menu tree */ /** * The maximum number of path elements for a menu callback */define('MENU_MAX_PARTS', 7);/** * The maximum depth of a menu links tree - matches the number of p columns. */define('MENU_MAX_DEPTH', 9);/** * @} End of "Menu tree parameters". *//** * Returns the ancestors (and relevant placeholders) for any given path. * * For example, the ancestors of node/12345/edit are: * - node/12345/edit * - node/12345/% * - node/%/edit * - node/%/% * - node/12345 * - node/% * - node * * To generate these, we will use binary numbers. Each bit represents a * part of the path. If the bit is 1, then it represents the original * value while 0 means wildcard. If the path is node/12/edit/foo * then the 1011 bitstring represents node/%/edit/foo where % means that * any argument matches that part.  We limit ourselves to using binary * numbers that correspond the patterns of wildcards of router items that * actually exists.  This list of 'masks' is built in menu_rebuild(). * * @param $parts *   An array of path parts, for the above example *   array('node', '12345', 'edit'). * @return *   An array which contains the ancestors and placeholders. Placeholders *   simply contain as many '%s' as the ancestors. */function menu_get_ancestors($parts) {  $number_parts = count($parts);  $placeholders = array();  $ancestors = array();  $length =  $number_parts - 1;  $end = (1 << $number_parts) - 1;  $masks = variable_get('menu_masks', array());  // Only examine patterns that actually exist as router items (the masks).  foreach ($masks as $i) {    if ($i > $end) {      // Only look at masks that are not longer than the path of interest.      continue;    }    elseif ($i < (1 << $length)) {      // We have exhausted the masks of a given length, so decrease the length.      --$length;    }    $current = '';    for ($j = $length; $j >= 0; $j--) {      if ($i & (1 << $j)) {        $current .= $parts[$length - $j];      }      else {        $current .= '%';      }      if ($j) {        $current .= '/';      }    }    $placeholders[] = "'%s'";    $ancestors[] = $current;  }  return array($ancestors, $placeholders);}/** * The menu system uses serialized arrays stored in the database for * arguments. However, often these need to change according to the * current path. This function unserializes such an array and does the * necessary change. * * Integer values are mapped according to the $map parameter. For * example, if unserialize($data) is array('view', 1) and $map is * array('node', '12345') then 'view' will not be changed because * it is not an integer, but 1 will as it is an integer. As $map[1] * is '12345', 1 will be replaced with '12345'. So the result will * be array('node_load', '12345'). * * @param @data *   A serialized array. * @param @map *   An array of potential replacements. * @return *   The $data array unserialized and mapped. */function menu_unserialize($data, $map) {  if ($data = unserialize($data)) {    foreach ($data as $k => $v) {      if (is_int($v)) {        $data[$k] = isset($map[$v]) ? $map[$v] : '';      }    }    return $data;  }  else {    return array();  }}/** * Replaces the statically cached item for a given path. * * @param $path *   The path. * @param $router_item *   The router item. Usually you take a router entry from menu_get_item and *   set it back either modified or to a different path. This lets you modify the *   navigation block, the page title, the breadcrumb and the page help in one *   call. */function menu_set_item($path, $router_item) {  menu_get_item($path, $router_item);}/** * Get a router item. * * @param $path *   The path, for example node/5. The function will find the corresponding *   node/% item and return that. * @param $router_item *   Internal use only. * @return *   The router item, an associate array corresponding to one row in the *   menu_router table. The value of key map holds the loaded objects. The *   value of key access is TRUE if the current user can access this page. *   The values for key title, page_arguments, access_arguments will be *   filled in based on the database values and the objects loaded. */function menu_get_item($path = NULL, $router_item = NULL) {  static $router_items;  if (!isset($path)) {    $path = $_GET['q'];  }  if (isset($router_item)) {    $router_items[$path] = $router_item;  }  if (!isset($router_items[$path])) {    $original_map = arg(NULL, $path);    $parts = array_slice($original_map, 0, MENU_MAX_PARTS);    list($ancestors, $placeholders) = menu_get_ancestors($parts);    if ($router_item = db_fetch_array(db_query_range('SELECT * FROM {menu_router} WHERE path IN ('. implode (',', $placeholders) .') ORDER BY fit DESC', $ancestors, 0, 1))) {      $map = _menu_translate($router_item, $original_map);      if ($map === FALSE) {        $router_items[$path] = FALSE;        return FALSE;      }      if ($router_item['access']) {        $router_item['map'] = $map;        $router_item['page_arguments'] = array_merge(menu_unserialize($router_item['page_arguments'], $map), array_slice($map, $router_item['number_parts']));      }    }    $router_items[$path] = $router_item;  }  return $router_items[$path];}/** * Execute the page callback associated with the current path */function menu_execute_active_handler($path = NULL) {  if (_menu_site_is_offline()) {    return MENU_SITE_OFFLINE;  }  // Rebuild if we know it's needed, or if the menu masks are missing which  // occurs rarely, likely due to a race condition of multiple rebuilds.  if (variable_get('menu_rebuild_needed', FALSE) || !variable_get('menu_masks', array())) {    menu_rebuild();  }  if ($router_item = menu_get_item($path)) {    if ($router_item['access']) {      if ($router_item['file']) {        require_once($router_item['file']);      }      return call_user_func_array($router_item['page_callback'], $router_item['page_arguments']);    }    else {      return MENU_ACCESS_DENIED;    }  }  return MENU_NOT_FOUND;}/** * Loads objects into the map as defined in the $item['load_functions']. * * @param $item *   A menu router or menu link item * @param $map *   An array of path arguments (ex: array('node', '5')) * @return *   Returns TRUE for success, FALSE if an object cannot be loaded. *   Names of object loading functions are placed in $item['load_functions']. *   Loaded objects are placed in $map[]; keys are the same as keys in the *   $item['load_functions'] array. *   $item['access'] is set to FALSE if an object cannot be loaded. */function _menu_load_objects(&$item, &$map) {  if ($load_functions = $item['load_functions']) {    // If someone calls this function twice, then unserialize will fail.    if ($load_functions_unserialized = unserialize($load_functions)) {      $load_functions = $load_functions_unserialized;    }    $path_map = $map;    foreach ($load_functions as $index => $function) {      if ($function) {        $value = isset($path_map[$index]) ? $path_map[$index] : '';        if (is_array($function)) {          // Set up arguments for the load function. These were pulled from          // 'load arguments' in the hook_menu() entry, but they need          // some processing. In this case the $function is the key to the          // load_function array, and the value is the list of arguments.          list($function, $args) = each($function);          $load_functions[$index] = $function;          // Some arguments are placeholders for dynamic items to process.          foreach ($args as $i => $arg) {            if ($arg === '%index') {              // Pass on argument index to the load function, so multiple              // occurances of the same placeholder can be identified.              $args[$i] = $index;            }            if ($arg === '%map') {              // Pass on menu map by reference. The accepting function must              // also declare this as a reference if it wants to modify              // the map.              $args[$i] = &$map;            }            if (is_int($arg)) {              $args[$i] = isset($path_map[$arg]) ? $path_map[$arg] : '';            }          }          array_unshift($args, $value);          $return = call_user_func_array($function, $args);        }        else {          $return = $function($value);        }        // If callback returned an error or there is no callback, trigger 404.        if ($return === FALSE) {          $item['access'] = FALSE;          $map = FALSE;          return FALSE;        }        $map[$index] = $return;      }    }    $item['load_functions'] = $load_functions;  }  return TRUE;}/** * Check access to a menu item using the access callback * * @param $item *   A menu router or menu link item * @param $map *   An array of path arguments (ex: array('node', '5')) * @return *   $item['access'] becomes TRUE if the item is accessible, FALSE otherwise. */function _menu_check_access(&$item, $map) {  // Determine access callback, which will decide whether or not the current  // user has access to this path.  $callback = empty($item['access_callback']) ? 0 : trim($item['access_callback']);  // Check for a TRUE or FALSE value.  if (is_numeric($callback)) {    $item['access'] = (bool)$callback;  }  else {    $arguments = menu_unserialize($item['access_arguments'], $map);    // As call_user_func_array is quite slow and user_access is a very common    // callback, it is worth making a special case for it.    if ($callback == 'user_access') {      $item['access'] = (count($arguments) == 1) ? user_access($arguments[0]) : user_access($arguments[0], $arguments[1]);    }    else {      $item['access'] = call_user_func_array($callback, $arguments);    }  }}/** * Localize the router item title using t() or another callback. * * Translate the title and description to allow storage of English title * strings in the database, yet display of them in the language required * by the current user. * * @param $item *   A menu router item or a menu link item. * @param $map *   The path as an array with objects already replaced. E.g., for path *   node/123 $map would be array('node', $node) where $node is the node *   object for node 123. * @param $link_translate *   TRUE if we are translating a menu link item; FALSE if we are *   translating a menu router item. * @return *   No return value. *   $item['title'] is localized according to $item['title_callback']. *   If an item's callback is check_plain(), $item['options']['html'] becomes *   TRUE. *   $item['description'] is translated using t(). *   When doing link translation and the $item['options']['attributes']['title'] *   (link title attribute) matches the description, it is translated as well. */function _menu_item_localize(&$item, $map, $link_translate = FALSE) {  $callback = $item['title_callback'];  $item['localized_options'] = $item['options'];  // If we are translating the title of a menu link, and its title is the same  // as the corresponding router item, then we can use the title information  // from the router. If it's customized, then we need to use the link title  // itself; can't localize.  // If we are translating a router item (tabs, page, breadcrumb), then we  // can always use the information from the router item.  if (!$link_translate || ($item['title'] == $item['link_title'])) {    // t() is a special case. Since it is used very close to all the time,    // we handle it directly instead of using indirect, slower methods.    if ($callback == 't') {      if (empty($item['title_arguments'])) {        $item['title'] = t($item['title']);      }      else {        $item['title'] = t($item['title'], menu_unserialize($item['title_arguments'], $map));      }    }    elseif ($callback) {      if (empty($item['title_arguments'])) {        $item['title'] = $callback($item['title']);      }      else {        $item['title'] = call_user_func_array($callback, menu_unserialize($item['title_arguments'], $map));      }      // Avoid calling check_plain again on l() function.      if ($callback == 'check_plain') {        $item['localized_options']['html'] = TRUE;      }    }  }  elseif ($link_translate) {    $item['title'] = $item['link_title'];  }  // Translate description, see the motivation above.  if (!empty($item['description'])) {    $original_description = $item['description'];    $item['description'] = t($item['description']);    if ($link_translate && isset($item['options']['attributes']['title']) && $item['options']['attributes']['title'] == $original_description) {      $item['localized_options']['attributes']['title'] = $item['description'];    }  }}/** * Handles dynamic path translation and menu access control. * * When a user arrives on a page such as node/5, this function determines * what "5" corresponds to, by inspecting the page's menu path definition, * node/%node. This will call node_load(5) to load the corresponding node * object. * * It also works in reverse, to allow the display of tabs and menu items which * contain these dynamic arguments, translating node/%node to node/5. * * Translation of menu item titles and descriptions are done here to * allow for storage of English strings in the database, and translation * to the language required to generate the current page * * @param $router_item *   A menu router item * @param $map *   An array of path arguments (ex: array('node', '5')) * @param $to_arg *   Execute $item['to_arg_functions'] or not. Use only if you want to render a *   path from the menu table, for example tabs. * @return *   Returns the map with objects loaded as defined in the *   $item['load_functions. $item['access'] becomes TRUE if the item is *   accessible, FALSE otherwise. $item['href'] is set according to the map. *   If an error occurs during calling the load_functions (like trying to load *   a non existing node) then this function return FALSE. */function _menu_translate(&$router_item, $map, $to_arg = FALSE) {  if ($to_arg) {    // Fill in missing path elements, such as the current uid.    _menu_link_map_translate($map, $router_item['to_arg_functions']);  }  // The $path_map saves the pieces of the path as strings, while elements in  // $map may be replaced with loaded objects.  $path_map = $map;  if (!_menu_load_objects($router_item, $map)) {    // An error occurred loading an object.    $router_item['access'] = FALSE;    return FALSE;  }  // Generate the link path for the page request or local tasks.  $link_map = explode('/', $router_item['path']);  for ($i = 0; $i < $router_item['number_parts']; $i++) {    if ($link_map[$i] == '%') {      $link_map[$i] = $path_map[$i];    }  }  $router_item['href'] = implode('/', $link_map);  $router_item['options'] = array();  _menu_check_access($router_item, $map);    // For performance, don't localize an item the user can't access.  if ($router_item['access']) {    _menu_item_localize($router_item, $map);  }  return $map;}/** * This function translates the path elements in the map using any to_arg * helper function. These functions take an argument and return an object. * See http://drupal.org/node/109153 for more information. * * @param map *   An array of path arguments (ex: array('node', '5')) * @param $to_arg_functions *   An array of helper function (ex: array(2 => 'menu_tail_to_arg')) */function _menu_link_map_translate(&$map, $to_arg_functions) {  if ($to_arg_functions) {    $to_arg_functions = unserialize($to_arg_functions);    foreach ($to_arg_functions as $index => $function) {      // Translate place-holders into real values.      $arg = $function(!empty($map[$index]) ? $map[$index] : '', $map, $index);      if (!empty($map[$index]) || isset($arg)) {        $map[$index] = $arg;      }      else {        unset($map[$index]);      }    }  }}function menu_tail_to_arg($arg, $map, $index) {  return implode('/', array_slice($map, $index));}/** * This function is similar to _menu_translate() but does link-specific * preparation such as always calling to_arg functions. * * @param $item *   A menu link * @return *   Returns the map of path arguments with objects loaded as defined in the *   $item['load_functions']: *   - $item['access'] becomes TRUE if the item is accessible, FALSE otherwise. *   - $item['href'] is generated from link_path, possibly by to_arg functions. *   - $item['title'] is generated from link_title, and may be localized. *   - $item['options'] is unserialized; it is also changed within the call *     here to $item['localized_options'] by _menu_item_localize(). */function _menu_link_translate(&$item) {  $item['options'] = unserialize($item['options']);  if ($item['external']) {    $item['access'] = 1;    $map = array();    $item['href'] = $item['link_path'];    $item['title'] = $item['link_title'];    $item['localized_options'] = $item['options'];  }  else {    $map = explode('/', $item['link_path']);    _menu_link_map_translate($map, $item['to_arg_functions']);    $item['href'] = implode('/', $map);    // Note - skip callbacks without real values for their arguments.    if (strpos($item['href'], '%') !== FALSE) {      $item['access'] = FALSE;      return FALSE;    }    // menu_tree_check_access() may set this ahead of time for links to nodes.    if (!isset($item['access'])) {      if (!_menu_load_objects($item, $map)) {        // An error occurred loading an object.        $item['access'] = FALSE;        return FALSE;      }      _menu_check_access($item, $map);    }    // For performance, don't localize a link the user can't access.    if ($item['access']) {      _menu_item_localize($item, $map, TRUE);    }  }  // Allow other customizations - e.g. adding a page-specific query string to the  // options array. For performance reasons we only invoke this hook if the link  // has the 'alter' flag set in the options array.  if (!empty($item['options']['alter'])) {    drupal_alter('translated_menu_link', $item, $map);  }  return $map;}/** * Get a loaded object from a router item. * * menu_get_object() will provide you the current node on paths like node/5, * node/5/revisions/48 etc. menu_get_object('user') will give you the user * account on user/5 etc. Note - this function should never be called within a * _to_arg function (like user_current_to_arg()) since this may result in an * infinite recursion. * * @param $type *   Type of the object. These appear in hook_menu definitons as %type. Core *   provides aggregator_feed, aggregator_category, contact, filter_format, *   forum_term, menu, menu_link, node, taxonomy_vocabulary, user. See the *   relevant {$type}_load function for more on each. Defaults to node. * @param $position *   The expected position for $type object. For node/%node this is 1, for *   comment/reply/%node this is 2. Defaults to 1. * @param $path *   See menu_get_item() for more on this. Defaults to the current path. */function menu_get_object($type = 'node', $position = 1, $path = NULL) {  $router_item = menu_get_item($path);  if (isset($router_item['load_functions'][$position]) && !empty($router_item['map'][$position]) && $router_item['load_functions'][$position] == $type .'_load') {    return $router_item['map'][$position];  }}/** * Render a menu tree based on the current path. * * The tree is expanded based on the current path and dynamic paths are also * changed according to the defined to_arg functions (for example the 'My account' * link is changed from user/% to a link with the current user's uid). * * @param $menu_name *   The name of the menu. * @return *   The rendered HTML of that menu on the current page. */function menu_tree($menu_name = 'navigation') {  static $menu_output = array();  if (!isset($menu_output[$menu_name])) {    $tree = menu_tree_page_data($menu_name);    $menu_output[$menu_name] = menu_tree_output($tree);  }  return $menu_output[$menu_name];}/** * Returns a rendered menu tree. * * @param $tree *   A data structure representing the tree as returned from menu_tree_data. * @return *   The rendered HTML of that data structure. */function menu_tree_output($tree) {  $output = '';  $items = array();  // Pull out just the menu items we are going to render so that we  // get an accurate count for the first/last classes.  foreach ($tree as $data) {    if (!$data['link']['hidden']) {      $items[] = $data;    }  }  $num_items = count($items);  foreach ($items as $i => $data) {    $extra_class = array();    if ($i == 0) {      $extra_class[] = 'first';    }    if ($i == $num_items - 1) {      $extra_class[] = 'last';    }    $extra_class = implode(' ', $extra_class);    $link = theme('menu_item_link', $data['link']);    if ($data['below']) {      $output .= theme('menu_item', $link, $data['link']['has_children'], menu_tree_output($data['below']), $data['link']['in_active_trail'], $extra_class);    }    else {      $output .= theme('menu_item', $link, $data['link']['has_children'], '', $data['link']['in_active_trail'], $extra_class);    }  }  return $output ? theme('menu_tree', $output) : '';}/** * Get the data structure representing a named menu tree. * * Since this can be the full tree including hidden items, the data returned * may be used for generating an an admin interface or a select. * * @param $menu_name *   The named menu links to return * @param $item *   A fully loaded menu link, or NULL.  If a link is supplied, only the *   path to root will be included in the returned tree- as if this link *   represented the current page in a visible menu. * @return *   An tree of menu links in an array, in the order they should be rendered. */function menu_tree_all_data($menu_name = 'navigation', $item = NULL) {  static $tree = array();  // Use $mlid as a flag for whether the data being loaded is for the whole tree.  $mlid = isset($item['mlid']) ? $item['mlid'] : 0;  // Generate a cache ID (cid) specific for this $menu_name and $item.  $cid = 'links:'. $menu_name .':all-cid:'. $mlid;  if (!isset($tree[$cid])) {    // If the static variable doesn't have the data, check {cache_menu}.    $cache = cache_get($cid, 'cache_menu');    if ($cache && isset($cache->data)) {      // If the cache entry exists, it will just be the cid for the actual data.      // This avoids duplication of large amounts of data.      $cache = cache_get($cache->data, 'cache_menu');      if ($cache && isset($cache->data)) {        $data = $cache->data;      }    }    // If the tree data was not in the cache, $data will be NULL.    if (!isset($data)) {      // Build and run the query, and build the tree.      if ($mlid) {        // The tree is for a single item, so we need to match the values in its        // p columns and 0 (the top level) with the plid values of other links.        $args = array(0);        for ($i = 1; $i < MENU_MAX_DEPTH; $i++) {          $args[] = $item["p$i"];        }        $args = array_unique($args);        $placeholders = implode(', ', array_fill(0, count($args), '%d'));        $where = ' AND ml.plid IN ('. $placeholders .')';        $parents = $args;        $parents[] = $item['mlid'];      }      else {        // Get all links in this menu.        $where = '';        $args = array();        $parents = array();      }      array_unshift($args, $menu_name);      // Select the links from the table, and recursively build the tree.  We      // LEFT JOIN since there is no match in {menu_router} for an external      // link.      $data['tree'] = menu_tree_data(db_query("        SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*        FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path        WHERE ml.menu_name = '%s'". $where ."        ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", $args), $parents);      $data['node_links'] = array();      menu_tree_collect_node_links($data['tree'], $data['node_links']);      // Cache the data, if it is not already in the cache.      $tree_cid = _menu_tree_cid($menu_name, $data);      if (!cache_get($tree_cid, 'cache_menu')) {        cache_set($tree_cid, $data, 'cache_menu');      }      // Cache the cid of the (shared) data using the menu and item-specific cid.      cache_set($cid, $tree_cid, 'cache_menu');    }    // Check access for the current user to each item in the tree.    menu_tree_check_access($data['tree'], $data['node_links']);    $tree[$cid] = $data['tree'];  }  return $tree[$cid];}/** * Get the data structure representing a named menu tree, based on the current page. * * The tree order is maintained by storing each parent in an individual * field, see http://drupal.org/node/141866 for more. * * @param $menu_name *   The named menu links to return * @return *   An array of menu links, in the order they should be rendered. The array *   is a list of associative arrays -- these have two keys, link and below. *   link is a menu item, ready for theming as a link. Below represents the *   submenu below the link if there is one, and it is a subtree that has the *   same structure described for the top-level array. */function menu_tree_page_data($menu_name = 'navigation') {  static $tree = array();  // Load the menu item corresponding to the current page.  if ($item = menu_get_item()) {    // Generate a cache ID (cid) specific for this page.    $cid = 'links:'. $menu_name .':page-cid:'. $item['href'] .':'. (int)$item['access'];    if (!isset($tree[$cid])) {      // If the static variable doesn't have the data, check {cache_menu}.      $cache = cache_get($cid, 'cache_menu');      if ($cache && isset($cache->data)) {        // If the cache entry exists, it will just be the cid for the actual data.        // This avoids duplication of large amounts of data.        $cache = cache_get($cache->data, 'cache_menu');        if ($cache && isset($cache->data)) {          $data = $cache->data;        }      }      // If the tree data was not in the cache, $data will be NULL.      if (!isset($data)) {        // Build and run the query, and build the tree.        if ($item['access']) {          // Check whether a menu link exists that corresponds to the current path.          $args = array($menu_name, $item['href']);          $placeholders = "'%s'";          if (drupal_is_front_page()) {            $args[] = '<front>';            $placeholders .= ", '%s'";          }          $parents = db_fetch_array(db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links} WHERE menu_name = '%s' AND link_path IN (". $placeholders .")", $args));          if (empty($parents)) {            // If no link exists, we may be on a local task that's not in the links.            // TODO: Handle the case like a local task on a specific node in the menu.            $parents = db_fetch_array(db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links} WHERE menu_name = '%s' AND link_path = '%s'", $menu_name, $item['tab_root']));          }          // We always want all the top-level links with plid == 0.          $parents[] = '0';          // Use array_values() so that the indices are numeric for array_merge().          $args = $parents = array_unique(array_values($parents));          $placeholders = implode(', ', array_fill(0, count($args), '%d'));          $expanded = variable_get('menu_expanded', array());          // Check whether the current menu has any links set to be expanded.          if (in_array($menu_name, $expanded)) {            // Collect all the links set to be expanded, and then add all of            // their children to the list as well.            do {              $result = db_query("SELECT mlid FROM {menu_links} WHERE menu_name = '%s' AND expanded = 1 AND has_children = 1 AND plid IN (". $placeholders .') AND mlid NOT IN ('. $placeholders .')', array_merge(array($menu_name), $args, $args));              $num_rows = FALSE;              while ($item = db_fetch_array($result)) {                $args[] = $item['mlid'];                $num_rows = TRUE;              }              $placeholders = implode(', ', array_fill(0, count($args), '%d'));            } while ($num_rows);          }          array_unshift($args, $menu_name);        }        else {          // Show only the top-level menu items when access is denied.          $args = array($menu_name, '0');          $placeholders = '%d';          $parents = array();        }        // Select the links from the table, and recursively build the tree. We        // LEFT JOIN since there is no match in {menu_router} for an external        // link.        $data['tree'] = menu_tree_data(db_query("          SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*          FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path          WHERE ml.menu_name = '%s' AND ml.plid IN (". $placeholders .")          ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", $args), $parents);        $data['node_links'] = array();        menu_tree_collect_node_links($data['tree'], $data['node_links']);        // Cache the data, if it is not already in the cache.        $tree_cid = _menu_tree_cid($menu_name, $data);        if (!cache_get($tree_cid, 'cache_menu')) {          cache_set($tree_cid, $data, 'cache_menu');        }        // Cache the cid of the (shared) data using the page-specific cid.        cache_set($cid, $tree_cid, 'cache_menu');      }      // Check access for the current user to each item in the tree.      menu_tree_check_access($data['tree'], $data['node_links']);      $tree[$cid] = $data['tree'];    }    return $tree[$cid];  }  return array();}/** * Helper function - compute the real cache ID for menu tree data. */function _menu_tree_cid($menu_name, $data) {  return 'links:'. $menu_name .':tree-data:'. md5(serialize($data));}/** * Recursive helper function - collect node links. * * @param $tree *   The menu tree you wish to collect node links from. * @param $node_links *   An array in which to store the collected node links. */function menu_tree_collect_node_links(&$tree, &$node_links) {  foreach ($tree as $key => $v) {    if ($tree[$key]['link']['router_path'] == 'node/%') {      $nid = substr($tree[$key]['link']['link_path'], 5);      if (is_numeric($nid)) {        $node_links[$nid][$tree[$key]['link']['mlid']] = &$tree[$key]['link'];        $tree[$key]['link']['access'] = FALSE;      }    }    if ($tree[$key]['below']) {      menu_tree_collect_node_links($tree[$key]['below'], $node_links);    }  }}/** * Check access and perform other dynamic operations for each link in the tree. * * @param $tree *   The menu tree you wish to operate on. * @param $node_links *   A collection of node link references generated from $tree by *   menu_tree_collect_node_links(). */function menu_tree_check_access(&$tree, $node_links = array()) {  if ($node_links) {    // Use db_rewrite_sql to evaluate view access without loading each full node.    $nids = array_keys($node_links);    $placeholders = '%d'. str_repeat(', %d', count($nids) - 1);    $result = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.status = 1 AND n.nid IN (". $placeholders .")"), $nids);    while ($node = db_fetch_array($result)) {      $nid = $node['nid'];      foreach ($node_links[$nid] as $mlid => $link) {        $node_links[$nid][$mlid]['access'] = TRUE;      }    }  }  _menu_tree_check_access($tree);  return;}/** * Recursive helper function for menu_tree_check_access() */function _menu_tree_check_access(&$tree) {  $new_tree = array();  foreach ($tree as $key => $v) {    $item = &$tree[$key]['link'];    _menu_link_translate($item);    if ($item['access']) {      if ($tree[$key]['below']) {        _menu_tree_check_access($tree[$key]['below']);      }      // The weights are made a uniform 5 digits by adding 50000 as an offset.      // After _menu_link_translate(), $item['title'] has the localized link title.      // Adding the mlid to the end of the index insures that it is unique.      $new_tree[(50000 + $item['weight']) .' '. $item['title'] .' '. $item['mlid']] = $tree[$key];    }  }  // Sort siblings in the tree based on the weights and localized titles.  ksort($new_tree);  $tree = $new_tree;}/** * Build the data representing a menu tree. * * @param $result *   The database result. * @param $parents *   An array of the plid values that represent the path from the current page *   to the root of the menu tree. * @param $depth *   The depth of the current menu tree. * @return *   See menu_tree_page_data for a description of the data structure. */function menu_tree_data($result = NULL, $parents = array(), $depth = 1) {  list(, $tree) = _menu_tree_data($result, $parents, $depth);  return $tree;}/** * Recursive helper function to build the data representing a menu tree. * * The function is a bit complex because the rendering of an item depends on * the next menu item. So we are always rendering the element previously * processed not the current one. */function _menu_tree_data($result, $parents, $depth, $previous_element = '') {  $remnant = NULL;  $tree = array();  while ($item = db_fetch_array($result)) {    // We need to determine if we're on the path to root so we can later build    // the correct active trail and breadcrumb.    $item['in_active_trail'] = in_array($item['mlid'], $parents);    // The current item is the first in a new submenu.    if ($item['depth'] > $depth) {      // _menu_tree returns an item and the menu tree structure.      list($item, $below) = _menu_tree_data($result, $parents, $item['depth'], $item);      if ($previous_element) {        $tree[$previous_element['mlid']] = array(          'link' => $previous_element,          'below' => $below,        );      }      else {        $tree = $below;      }      // We need to fall back one level.      if (!isset($item) || $item['depth'] < $depth) {        return array($item, $tree);      }      // This will be the link to be output in the next iteration.      $previous_element = $item;    }    // We are at the same depth, so we use the previous element.    elseif ($item['depth'] == $depth) {      if ($previous_element) {        // Only the first time.        $tree[$previous_element['mlid']] = array(          'link' => $previous_element,          'below' => FALSE,        );      }      // This will be the link to be output in the next iteration.      $previous_element = $item;    }    // The submenu ended with the previous item, so pass back the current item.    else {      $remnant = $item;      break;    }  }  if ($previous_element) {    // We have one more link dangling.    $tree[$previous_element['mlid']] = array(      'link' => $previous_element,      'below' => FALSE,    );  }  return array($remnant, $tree);}/** * Generate the HTML output for a single menu link. * * @ingroup themeable */function theme_menu_item_link($link) {  if (empty($link['localized_options'])) {    $link['localized_options'] = array();  }  return l($link['title'], $link['href'], $link['localized_options']);}/** * Generate the HTML output for a menu tree * * @ingroup themeable */function theme_menu_tree($tree) {  return '<ul class="menu">'. $tree .'</ul>';}/** * Generate the HTML output for a menu item and submenu. * * @ingroup themeable */function theme_menu_item($link, $has_children, $menu = '', $in_active_trail = FALSE, $extra_class = NULL) {  $class = ($menu ? 'expanded' : ($has_children ? 'collapsed' : 'leaf'));  if (!empty($extra_class)) {    $class .= ' '. $extra_class;  }  if ($in_active_trail) {    $class .= ' active-trail';  }  return '<li class="'. $class .'">'. $link . $menu ."</li>\n";}/** * Generate the HTML output for a single local task link. * * @ingroup themeable */function theme_menu_local_task($link, $active = FALSE) {  return '<li '. ($active ? 'class="active" ' : '') .'>'. $link ."</li>\n";}/** * Generates elements for the $arg array in the help hook. */function drupal_help_arg($arg = array()) {  // Note - the number of empty elements should be > MENU_MAX_PARTS.  return $arg + array('', '', '', '', '', '', '', '', '', '', '', '');}/** * Returns the help associated with the active menu item. */function menu_get_active_help() {  $output = '';  $router_path = menu_tab_root_path();  // We will always have a path unless we are on a 403 or 404.  if (!$router_path) {    return '';  }  $arg = drupal_help_arg(arg(NULL));  $empty_arg = drupal_help_arg();  foreach (module_list() as $name) {    if (module_hook($name, 'help')) {      // Lookup help for this path.      if ($help = module_invoke($name, 'help', $router_path, $arg)) {        $output .= $help ."\n";      }      // Add "more help" link on admin pages if the module provides a      // standalone help page.      if ($arg[0] == "admin" && module_exists('help') && module_invoke($name, 'help', 'admin/help#'. $arg[2], $empty_arg) && $help) {        $output .= theme("more_help_link", url('admin/help/'. $arg[2]));      }    }  }  return $output;}/** * Build a list of named menus. */function menu_get_names($reset = FALSE) {  static $names;  if ($reset || empty($names)) {    $names = array();    $result = db_query("SELECT DISTINCT(menu_name) FROM {menu_links} ORDER BY menu_name");    while ($name = db_fetch_array($result)) {      $names[] = $name['menu_name'];    }  }  return $names;}/** * Return an array containing the names of system-defined (default) menus. */function menu_list_system_menus() {  return array('navigation', 'primary-links', 'secondary-links');}/** * Return an array of links to be rendered as the Primary links. */function menu_primary_links() {  return menu_navigation_links(variable_get('menu_primary_links_source', 'primary-links'));}/** * Return an array of links to be rendered as the Secondary links. */function menu_secondary_links() {  // If the secondary menu source is set as the primary menu, we display the  // second level of the primary menu.  if (variable_get('menu_secondary_links_source', 'secondary-links') == variable_get('menu_primary_links_source', 'primary-links')) {    return menu_navigation_links(variable_get('menu_primary_links_source', 'primary-links'), 1);  }  else {    return menu_navigation_links(variable_get('menu_secondary_links_source', 'secondary-links'), 0);  }}/** * Return an array of links for a navigation menu. * * @param $menu_name *   The name of the menu. * @param $level *   Optional, the depth of the menu to be returned. * @return *   An array of links of the specified menu and level. */function menu_navigation_links($menu_name, $level = 0) {  // Don't even bother querying the menu table if no menu is specified.  if (empty($menu_name)) {    return array();  }  // Get the menu hierarchy for the current page.  $tree = menu_tree_page_data($menu_name);  // Go down the active trail until the right level is reached.  while ($level-- > 0 && $tree) {    // Loop through the current level's items until we find one that is in trail.    while ($item = array_shift($tree)) {      if ($item['link']['in_active_trail']) {        // If the item is in the active trail, we continue in the subtree.        $tree = empty($item['below']) ? array() : $item['below'];        break;      }    }  }  // Create a single level of links.  $links = array();  foreach ($tree as $item) {    if (!$item['link']['hidden']) {      $class = '';      $l = $item['link']['localized_options'];      $l['href'] = $item['link']['href'];      $l['title'] = $item['link']['title'];      if ($item['link']['in_active_trail']) {        $class = ' active-trail';      }      // Keyed with the unique mlid to generate classes in theme_links().      $links['menu-'. $item['link']['mlid'] . $class] = $l;    }  }  return $links;}/** * Collects the local tasks (tabs) for a given level. * * @param $level *   The level of tasks you ask for. Primary tasks are 0, secondary are 1. * @param $return_root *   Whether to return the root path for the current page. * @return *   Themed output corresponding to the tabs of the requested level, or *   router path if $return_root == TRUE. This router path corresponds to *   a parent tab, if the current page is a default local task. */function menu_local_tasks($level = 0, $return_root = FALSE) {  static $tabs;  static $root_path;  if (!isset($tabs)) {    $tabs = array();    $router_item = menu_get_item();    if (!$router_item || !$router_item['access']) {      return '';    }    // Get all tabs and the root page.    $result = db_query("SELECT * FROM {menu_router} WHERE tab_root = '%s' ORDER BY weight, title", $router_item['tab_root']);    $map = arg();    $children = array();    $tasks = array();    $root_path = $router_item['path'];    while ($item = db_fetch_array($result)) {      _menu_translate($item, $map, TRUE);      if ($item['tab_parent']) {        // All tabs, but not the root page.        $children[$item['tab_parent']][$item['path']] = $item;      }      // Store the translated item for later use.      $tasks[$item['path']] = $item;    }    // Find all tabs below the current path.    $path = $router_item['path'];    // Tab parenting may skip levels, so the number of parts in the path may not    // equal the depth. Thus we use the $depth counter (offset by 1000 for ksort).    $depth = 1001;    while (isset($children[$path])) {      $tabs_current = '';      $next_path = '';      $count = 0;      foreach ($children[$path] as $item) {        if ($item['access']) {          $count++;          // The default task is always active.          if ($item['type'] == MENU_DEFAULT_LOCAL_TASK) {            // Find the first parent which is not a default local task.            for ($p = $item['tab_parent']; $tasks[$p]['type'] == MENU_DEFAULT_LOCAL_TASK; $p = $tasks[$p]['tab_parent']);            $link = theme('menu_item_link', array('href' => $tasks[$p]['href']) + $item);            $tabs_current .= theme('menu_local_task', $link, TRUE);            $next_path = $item['path'];          }          else {            $link = theme('menu_item_link', $item);            $tabs_current .= theme('menu_local_task', $link);          }        }      }      $path = $next_path;      $tabs[$depth]['count'] = $count;      $tabs[$depth]['output'] = $tabs_current;      $depth++;    }    // Find all tabs at the same level or above the current one.    $parent = $router_item['tab_parent'];    $path = $router_item['path'];    $current = $router_item;    $depth = 1000;    while (isset($children[$parent])) {      $tabs_current = '';      $next_path = '';      $next_parent = '';      $count = 0;      foreach ($children[$parent] as $item) {        if ($item['access']) {          $count++;          if ($item['type'] == MENU_DEFAULT_LOCAL_TASK) {            // Find the first parent which is not a default local task.            for ($p = $item['tab_parent']; $tasks[$p]['type'] == MENU_DEFAULT_LOCAL_TASK; $p = $tasks[$p]['tab_parent']);            $link = theme('menu_item_link', array('href' => $tasks[$p]['href']) + $item);            if ($item['path'] == $router_item['path']) {              $root_path = $tasks[$p]['path'];            }          }          else {            $link = theme('menu_item_link', $item);          }          // We check for the active tab.          if ($item['path'] == $path) {            $tabs_current .= theme('menu_local_task', $link, TRUE);            $next_path = $item['tab_parent'];            if (isset($tasks[$next_path])) {              $next_parent = $tasks[$next_path]['tab_parent'];            }          }          else {            $tabs_current .= theme('menu_local_task', $link);          }        }      }      $path = $next_path;      $parent = $next_parent;      $tabs[$depth]['count'] = $count;      $tabs[$depth]['output'] = $tabs_current;      $depth--;    }    // Sort by depth.    ksort($tabs);    // Remove the depth, we are interested only in their relative placement.    $tabs = array_values($tabs);  }  if ($return_root) {    return $root_path;  }  else {    // We do not display single tabs.    return (isset($tabs[$level]) && $tabs[$level]['count'] > 1) ? $tabs[$level]['output'] : '';  }}/** * Returns the rendered local tasks at the top level. */function menu_primary_local_tasks() {  return menu_local_tasks(0);}/** * Returns the rendered local tasks at the second level. */function menu_secondary_local_tasks() {  return menu_local_tasks(1);}/** * Returns the router path, or the path of the parent tab of a default local task. */function menu_tab_root_path() {  return menu_local_tasks(0, TRUE);}/** * Returns the rendered local tasks. The default implementation renders them as tabs. * * @ingroup themeable */function theme_menu_local_tasks() {  $output = '';  if ($primary = menu_primary_local_tasks()) {    $output .= "<ul class=\"tabs primary\">\n". $primary ."</ul>\n";  }  if ($secondary = menu_secondary_local_tasks()) {    $output .= "<ul class=\"tabs secondary\">\n". $secondary ."</ul>\n";  }  return $output;}/** * Set (or get) the active menu for the current page - determines the active trail. */function menu_set_active_menu_name($menu_name = NULL) {  static $active;  if (isset($menu_name)) {    $active = $menu_name;  }  elseif (!isset($active)) {    $active = 'navigation';  }  return $active;}/** * Get the active menu for the current page - determines the active trail. */function menu_get_active_menu_name() {  return menu_set_active_menu_name();}/** * Set the active path, which determines which page is loaded. * * @param $path *   A Drupal path - not a path alias. * * Note that this may not have the desired effect unless invoked very early * in the page load, such as during hook_boot, or unless you call * menu_execute_active_handler() to generate your page output. */function menu_set_active_item($path) {  $_GET['q'] = $path;}/** * Sets or gets the active trail (path to root menu root) of the current page. * * @param $new_trail *   Menu trail to set, or NULL to use previously-set or calculated trail. If *   supplying a trail, use the same format as the return value (see below). * @return *   Path to menu root of the current page, as an array of menu link items, *   starting with the site's home page. Each link item is an associative array *   with the following components: *   - 'title': Title of the item. *   - 'href': Drupal path of the item. *   - 'localized_options': Options for passing into the l() function. *   - 'type': A menu type constant, such as MENU_DEFAULT_LOCAL_TASK, or 0 to *     indicate it's not really in the menu (used for the home page item). *   If $new_trail is supplied, the value is saved in a static variable and *   returned. If $new_trail is not supplied, and there is a saved value from *   a previous call, the saved value is returned. If $new_trail is not supplied *   and there is no saved value, the path to the current page is calculated, *   saved as the static value, and returned. */function menu_set_active_trail($new_trail = NULL) {  static $trail;  if (isset($new_trail)) {    $trail = $new_trail;  }  elseif (!isset($trail)) {    $trail = array();    $trail[] = array('title' => t('Home'), 'href' => '<front>', 'localized_options' => array(), 'type' => 0);    $item = menu_get_item();    // Check whether the current item is a local task (displayed as a tab).    if ($item['tab_parent']) {      // The title of a local task is used for the tab, never the page title.      // Thus, replace it with the item corresponding to the root path to get      // the relevant href and title.  For example, the menu item corresponding      // to 'admin' is used when on the 'By module' tab at 'admin/by-module'.      $parts = explode('/', $item['tab_root']);      $args = arg();      // Replace wildcards in the root path using the current path.      foreach ($parts as $index => $part) {        if ($part == '%') {          $parts[$index] = $args[$index];        }      }      // Retrieve the menu item using the root path after wildcard replacement.      $root_item = menu_get_item(implode('/', $parts));      if ($root_item && $root_item['access']) {        $item = $root_item;      }    }    $tree = menu_tree_page_data(menu_get_active_menu_name());    list($key, $curr) = each($tree);    while ($curr) {      // Terminate the loop when we find the current path in the active trail.      if ($curr['link']['href'] == $item['href']) {        $trail[] = $curr['link'];        $curr = FALSE;      }      else {        // Add the link if it's in the active trail, then move to the link below.        if ($curr['link']['in_active_trail']) {          $trail[] = $curr['link'];          $tree = $curr['below'] ? $curr['below'] : array();        }        list($key, $curr) = each($tree);      }    }    // Make sure the current page is in the trail (needed for the page title),    // but exclude tabs and the front page.    $last = count($trail) - 1;    if ($trail[$last]['href'] != $item['href'] && !(bool)($item['type'] & MENU_IS_LOCAL_TASK) && !drupal_is_front_page()) {      $trail[] = $item;    }  }  return $trail;}/** * Gets the active trail (path to root menu root) of the current page. * * See menu_set_active_trail() for details of return value. */function menu_get_active_trail() {  return menu_set_active_trail();}/** * Get the breadcrumb for the current page, as determined by the active trail. */function menu_get_active_breadcrumb() {  $breadcrumb = array();  // No breadcrumb for the front page.  if (drupal_is_front_page()) {    return $breadcrumb;  }  $item = menu_get_item();  if ($item && $item['access']) {    $active_trail = menu_get_active_trail();    foreach ($active_trail as $parent) {      $breadcrumb[] = l($parent['title'], $parent['href'], $parent['localized_options']);    }    $end = end($active_trail);    // Don't show a link to the current page in the breadcrumb trail.    if ($item['href'] == $end['href'] || ($item['type'] == MENU_DEFAULT_LOCAL_TASK && $end['href'] != '<front>')) {      array_pop($breadcrumb);    }  }  return $breadcrumb;}/** * Get the title of the current page, as determined by the active trail. */function menu_get_active_title() {  $active_trail = menu_get_active_trail();  foreach (array_reverse($active_trail) as $item) {    if (!(bool)($item['type'] & MENU_IS_LOCAL_TASK)) {      return $item['title'];    }  }}/** * Get a menu link by its mlid, access checked and link translated for rendering. * * This function should never be called from within node_load() or any other * function used as a menu object load function since an infinite recursion may * occur. * * @param $mlid *   The mlid of the menu item. * @return *   A menu link, with $item['access'] filled and link translated for *   rendering. */function menu_link_load($mlid) {  if (is_numeric($mlid) && $item = db_fetch_array(db_query("SELECT m.*, ml.* FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = %d", $mlid))) {    _menu_link_translate($item);    return $item;  }  return FALSE;}/** * Clears the cached cached data for a single named menu. */function menu_cache_clear($menu_name = 'navigation') {  static $cache_cleared = array();  if (empty($cache_cleared[$menu_name])) {    cache_clear_all('links:'. $menu_name .':', 'cache_menu', TRUE);    $cache_cleared[$menu_name] = 1;  }  elseif ($cache_cleared[$menu_name] == 1) {    register_shutdown_function('cache_clear_all', 'links:'. $menu_name .':', 'cache_menu', TRUE);    $cache_cleared[$menu_name] = 2;  }}/** * Clears all cached menu data.  This should be called any time broad changes * might have been made to the router items or menu links. */function menu_cache_clear_all() {  cache_clear_all('*', 'cache_menu', TRUE);}/** * (Re)populate the database tables used by various menu functions. * * This function will clear and populate the {menu_router} table, add entries * to {menu_links} for new router items, then remove stale items from * {menu_links}. If called from update.php or install.php, it will also * schedule a call to itself on the first real page load from * menu_execute_active_handler(), because the maintenance page environment * is different and leaves stale data in the menu tables. */function menu_rebuild() {  if (!lock_acquire('menu_rebuild')) {    // Wait for another request that is already doing this work.    // We choose to block here since otherwise the router item may not     // be avaiable in menu_execute_active_handler() resulting in a 404.    lock_wait('menu_rebuild');    return FALSE;  }  $menu = menu_router_build(TRUE);  _menu_navigation_links_rebuild($menu);  // Clear the menu, page and block caches.  menu_cache_clear_all();  _menu_clear_page_cache();    if (defined('MAINTENANCE_MODE')) {    variable_set('menu_rebuild_needed', TRUE);  }  else {    variable_del('menu_rebuild_needed');  }  lock_release('menu_rebuild');  return TRUE;}/** * Collect, alter and store the menu definitions. */function menu_router_build($reset = FALSE) {  static $menu;  if (!isset($menu) || $reset) {    // We need to manually call each module so that we can know which module    // a given item came from.    $callbacks = array();    foreach (module_implements('menu') as $module) {      $router_items = call_user_func($module .'_menu');      if (isset($router_items) && is_array($router_items)) {        foreach (array_keys($router_items) as $path) {          $router_items[$path]['module'] = $module;        }        $callbacks = array_merge($callbacks, $router_items);      }    }    // Alter the menu as defined in modules, keys are like user/%user.    drupal_alter('menu', $callbacks);    $menu = _menu_router_build($callbacks);    _menu_router_cache($menu);  }  return $menu;}/** * Helper function to store the menu router if we have it in memory. */function _menu_router_cache($new_menu = NULL) {  static $menu = NULL;  if (isset($new_menu)) {    $menu = $new_menu;  }  return $menu;}/** * Builds a link from a router item. */function _menu_link_build($item) {  if ($item['type'] == MENU_CALLBACK) {    $item['hidden'] = -1;  }  elseif ($item['type'] == MENU_SUGGESTED_ITEM) {    $item['hidden'] = 1;  }  // Note, we set this as 'system', so that we can be sure to distinguish all  // the menu links generated automatically from entries in {menu_router}.  $item['module'] = 'system';  $item += array(    'menu_name' => 'navigation',    'link_title' => $item['title'],    'link_path' => $item['path'],    'hidden' => 0,    'options' => empty($item['description']) ? array() : array('attributes' => array('title' => $item['description'])),  );  return $item;}/** * Helper function to build menu links for the items in the menu router. */function _menu_navigation_links_rebuild($menu) {  // Add normal and suggested items as links.  $menu_links = array();  foreach ($menu as $path => $item) {    if ($item['_visible']) {      $item = _menu_link_build($item);      $menu_links[$path] = $item;      $sort[$path] = $item['_number_parts'];    }  }  if ($menu_links) {    // Make sure no child comes before its parent.    array_multisort($sort, SORT_NUMERIC, $menu_links);    foreach ($menu_links as $item) {      $existing_item = db_fetch_array(db_query("SELECT mlid, menu_name, plid, customized, has_children, updated FROM {menu_links} WHERE link_path = '%s' AND module = '%s'", $item['link_path'], 'system'));      if ($existing_item) {        $item['mlid'] = $existing_item['mlid'];        // A change in hook_menu may move the link to a different menu        if (empty($item['menu_name']) || ($item['menu_name'] == $existing_item['menu_name'])) {          $item['menu_name'] = $existing_item['menu_name'];          $item['plid'] = $existing_item['plid'];        }        $item['has_children'] = $existing_item['has_children'];        $item['updated'] = $existing_item['updated'];      }      if (!$existing_item || !$existing_item['customized']) {        menu_link_save($item);      }    }  }  $placeholders = db_placeholders($menu, 'varchar');  $paths = array_keys($menu);  // Updated and customized items whose router paths are gone need new ones.  $result = db_query("SELECT ml.link_path, ml.mlid, ml.router_path, ml.updated FROM {menu_links} ml WHERE ml.updated = 1 OR (router_path NOT IN ($placeholders) AND external = 0 AND customized = 1)", $paths);  while ($item = db_fetch_array($result)) {    $router_path = _menu_find_router_path($item['link_path']);    if (!empty($router_path) && ($router_path != $item['router_path'] || $item['updated'])) {      // If the router path and the link path matches, it's surely a working      // item, so we clear the updated flag.      $updated = $item['updated'] && $router_path != $item['link_path'];      db_query("UPDATE {menu_links} SET router_path = '%s', updated = %d WHERE mlid = %d", $router_path, $updated, $item['mlid']);    }  }  // Find any item whose router path does not exist any more.  $result = db_query("SELECT * FROM {menu_links} WHERE router_path NOT IN ($placeholders) AND external = 0 AND updated = 0 AND customized = 0 ORDER BY depth DESC", $paths);  // Remove all such items. Starting from those with the greatest depth will  // minimize the amount of re-parenting done by menu_link_delete().  while ($item = db_fetch_array($result)) {    _menu_delete_item($item, TRUE);  }}/** * Delete one or several menu links. * * @param $mlid *   A valid menu link mlid or NULL. If NULL, $path is used. * @param $path *   The path to the menu items to be deleted. $mlid must be NULL. */function menu_link_delete($mlid, $path = NULL) {  if (isset($mlid)) {    _menu_delete_item(db_fetch_array(db_query("SELECT * FROM {menu_links} WHERE mlid = %d", $mlid)));  }  else {    $result = db_query("SELECT * FROM {menu_links} WHERE link_path = '%s'", $path);    while ($link = db_fetch_array($result)) {      _menu_delete_item($link);    }  }}/** * Helper function for menu_link_delete; deletes a single menu link. * * @param $item *   Item to be deleted. * @param $force *   Forces deletion. Internal use only, setting to TRUE is discouraged. */function _menu_delete_item($item, $force = FALSE) {  if ($item && ($item['module'] != 'system' || $item['updated'] || $force)) {    // Children get re-attached to the item's parent.    if ($item['has_children']) {      $result = db_query("SELECT mlid FROM {menu_links} WHERE plid = %d", $item['mlid']);      while ($m = db_fetch_array($result)) {        $child = menu_link_load($m['mlid']);        $child['plid'] = $item['plid'];        menu_link_save($child);      }    }    db_query('DELETE FROM {menu_links} WHERE mlid = %d', $item['mlid']);    // Update the has_children status of the parent.    _menu_update_parental_status($item);    menu_cache_clear($item['menu_name']);    _menu_clear_page_cache();  }}/** * Save a menu link. * * @param $item *   An array representing a menu link item. The only mandatory keys are *   link_path and link_title. Possible keys are: *   - menu_name   default is navigation *   - weight      default is 0 *   - expanded    whether the item is expanded. *   - options     An array of options, @see l for more. *   - mlid        Set to an existing value, or 0 or NULL to insert a new link. *   - plid        The mlid of the parent. *   - router_path The path of the relevant router item. * @return *   The mlid of the saved menu link, or FALSE if the menu link could not be  *   saved. */function menu_link_save(&$item) {  // Get the router if it's already in memory. $menu will be NULL, unless this  // is during a menu rebuild  $menu = _menu_router_cache();  drupal_alter('menu_link', $item, $menu);  // This is the easiest way to handle the unique internal path '<front>',  // since a path marked as external does not need to match a router path.  $item['_external'] = menu_path_is_external($item['link_path'])  || $item['link_path'] == '<front>';  // Load defaults.  $item += array(    'menu_name' => 'navigation',    'weight' => 0,    'link_title' => '',    'hidden' => 0,    'has_children' => 0,    'expanded' => 0,    'options' => array(),    'module' => 'menu',    'customized' => 0,    'updated' => 0,  );  $existing_item = FALSE;  if (isset($item['mlid'])) {    $existing_item = db_fetch_array(db_query("SELECT * FROM {menu_links} WHERE mlid = %d", $item['mlid']));  }  if (isset($item['plid'])) {    $parent = db_fetch_array(db_query("SELECT * FROM {menu_links} WHERE mlid = %d", $item['plid']));  }  else {    // Find the parent - it must be unique.    $parent_path = $item['link_path'];    $where = "WHERE link_path = '%s'";    // Only links derived from router items should have module == 'system', and    // we want to find the parent even if it's in a different menu.    if ($item['module'] == 'system') {      $where .= " AND module = '%s'";      $arg2 = 'system';    }    else {      // If not derived from a router item, we respect the specified menu name.      $where .= " AND menu_name = '%s'";      $arg2 = $item['menu_name'];    }    do {      $parent = FALSE;      $parent_path = substr($parent_path, 0, strrpos($parent_path, '/'));      $result = db_query("SELECT COUNT(*) FROM {menu_links} ". $where, $parent_path, $arg2);      // Only valid if we get a unique result.      if (db_result($result) == 1) {        $parent = db_fetch_array(db_query("SELECT * FROM {menu_links} ". $where, $parent_path, $arg2));      }    } while ($parent === FALSE && $parent_path);  }  if ($parent !== FALSE) {    $item['menu_name'] = $parent['menu_name'];  }  $menu_name = $item['menu_name'];  // Menu callbacks need to be in the links table for breadcrumbs, but can't  // be parents if they are generated directly from a router item.  if (empty($parent['mlid']) || $parent['hidden'] < 0) {    $item['plid'] =  0;  }  else {    $item['plid'] = $parent['mlid'];  }  if (!$existing_item) {    db_query("INSERT INTO {menu_links} (       menu_name, plid, link_path,      hidden, external, has_children,      expanded, weight,      module, link_title, options,      customized, updated) VALUES (      '%s', %d, '%s',      %d, %d, %d,      %d, %d,      '%s', '%s', '%s', %d, %d)",      $item['menu_name'], $item['plid'], $item['link_path'],      $item['hidden'], $item['_external'], $item['has_children'],      $item['expanded'], $item['weight'],      $item['module'],  $item['link_title'], serialize($item['options']),      $item['customized'], $item['updated']);    $item['mlid'] = db_last_insert_id('menu_links', 'mlid');  }  if (!$item['plid']) {    $item['p1'] = $item['mlid'];    for ($i = 2; $i <= MENU_MAX_DEPTH; $i++) {      $item["p$i"] = 0;    }    $item['depth'] = 1;  }  else {    // Cannot add beyond the maximum depth.    if ($item['has_children'] && $existing_item) {      $limit = MENU_MAX_DEPTH - menu_link_children_relative_depth($existing_item) - 1;    }    else {      $limit = MENU_MAX_DEPTH - 1;    }    if ($parent['depth'] > $limit) {      return FALSE;    }    $item['depth'] = $parent['depth'] + 1;    _menu_link_parents_set($item, $parent);  }  // Need to check both plid and menu_name, since plid can be 0 in any menu.  if ($existing_item && ($item['plid'] != $existing_item['plid'] || $menu_name != $existing_item['menu_name'])) {    _menu_link_move_children($item, $existing_item);  }  // Find the callback. During the menu update we store empty paths to be  // fixed later, so we skip this.  if (!isset($_SESSION['system_update_6021']) && (empty($item['router_path'])  || !$existing_item || ($existing_item['link_path'] != $item['link_path']))) {    if ($item['_external']) {      $item['router_path'] = '';    }    else {      // Find the router path which will serve this path.      $item['parts'] = explode('/', $item['link_path'], MENU_MAX_PARTS);      $item['router_path'] = _menu_find_router_path($item['link_path']);    }  }  db_query("UPDATE {menu_links} SET menu_name = '%s', plid = %d, link_path = '%s',    router_path = '%s', hidden = %d, external = %d, has_children = %d,    expanded = %d, weight = %d, depth = %d,    p1 = %d, p2 = %d, p3 = %d, p4 = %d, p5 = %d, p6 = %d, p7 = %d, p8 = %d, p9 = %d,    module = '%s', link_title = '%s', options = '%s', customized = %d WHERE mlid = %d",    $item['menu_name'], $item['plid'], $item['link_path'],    $item['router_path'], $item['hidden'], $item['_external'], $item['has_children'],    $item['expanded'], $item['weight'],  $item['depth'],    $item['p1'], $item['p2'], $item['p3'], $item['p4'], $item['p5'], $item['p6'], $item['p7'], $item['p8'], $item['p9'],    $item['module'],  $item['link_title'], serialize($item['options']), $item['customized'], $item['mlid']);  // Check the has_children status of the parent.  _menu_update_parental_status($item);  menu_cache_clear($menu_name);  if ($existing_item && $menu_name != $existing_item['menu_name']) {    menu_cache_clear($existing_item['menu_name']);  }  _menu_clear_page_cache();  return $item['mlid'];}/** * Helper function to clear the page and block caches at most twice per page load. */function _menu_clear_page_cache() {  static $cache_cleared = 0;  // Clear the page and block caches, but at most twice, including at  //  the end of the page load when there are multple links saved or deleted.  if (empty($cache_cleared)) {    cache_clear_all();    // Keep track of which menus have expanded items.    _menu_set_expanded_menus();    $cache_cleared = 1;  }  elseif ($cache_cleared == 1) {    register_shutdown_function('cache_clear_all');    // Keep track of which menus have expanded items.    register_shutdown_function('_menu_set_expanded_menus');    $cache_cleared = 2;  }}/** * Helper function to update a list of menus with expanded items */function _menu_set_expanded_menus() {  $names = array();  $result = db_query("SELECT menu_name FROM {menu_links} WHERE expanded != 0 GROUP BY menu_name");  while ($n = db_fetch_array($result)) {    $names[] = $n['menu_name'];  }  variable_set('menu_expanded', $names);}/** * Find the router path which will serve this path. * * @param $link_path *  The path for we are looking up its router path. * @return *  A path from $menu keys or empty if $link_path points to a nonexisting *  place. */function _menu_find_router_path($link_path) {  // $menu will only have data during a menu rebuild.  $menu = _menu_router_cache();  $router_path = $link_path;  $parts = explode('/', $link_path, MENU_MAX_PARTS);  list($ancestors, $placeholders) = menu_get_ancestors($parts);  if (empty($menu)) {    // Not during a menu rebuild, so look up in the database.    $router_path = (string)db_result(db_query_range('SELECT path FROM {menu_router} WHERE path IN ('. implode (',', $placeholders) .') ORDER BY fit DESC', $ancestors, 0, 1));  }  elseif (!isset($menu[$router_path])) {    // Add an empty path as a fallback.    $ancestors[] = '';    foreach ($ancestors as $key => $router_path) {      if (isset($menu[$router_path])) {        // Exit the loop leaving $router_path as the first match.        break;      }    }    // If we did not find the path, $router_path will be the empty string    // at the end of $ancestors.  }  return $router_path;}/** * Insert, update or delete an uncustomized menu link related to a module. * * @param $module *   The name of the module. * @param $op *   Operation to perform: insert, update or delete. * @param $link_path *   The path this link points to. * @param $link_title *   Title of the link to insert or new title to update the link to. *   Unused for delete. * @return *   The insert op returns the mlid of the new item. Others op return NULL. */function menu_link_maintain($module, $op, $link_path, $link_title) {  switch ($op) {    case 'insert':      $menu_link = array(        'link_title' => $link_title,        'link_path' => $link_path,        'module' => $module,      );      return menu_link_save($menu_link);      break;    case 'update':      db_query("UPDATE {menu_links} SET link_title = '%s' WHERE link_path = '%s' AND customized = 0 AND module = '%s'", $link_title, $link_path, $module);      $result = db_query("SELECT menu_name FROM {menu_links} WHERE link_path = '%s' AND customized = 0 AND module = '%s'", $link_path, $module);      while ($item = db_fetch_array($result)) {        menu_cache_clear($item['menu_name']);      }      break;    case 'delete':      menu_link_delete(NULL, $link_path);      break;  }}/** * Find the depth of an item's children relative to its depth. * * For example, if the item has a depth of 2, and the maximum of any child in * the menu link tree is 5, the relative depth is 3. * * @param $item *   An array representing a menu link item. * @return *   The relative depth, or zero. * */function menu_link_children_relative_depth($item) {  $i = 1;  $match = '';  $args[] = $item['menu_name'];  $p = 'p1';  while ($i <= MENU_MAX_DEPTH && $item[$p]) {    $match .= " AND $p = %d";    $args[] = $item[$p];    $p = 'p'. ++$i;  }  $max_depth = db_result(db_query_range("SELECT depth FROM {menu_links} WHERE menu_name = '%s'". $match ." ORDER BY depth DESC", $args, 0, 1));  return ($max_depth > $item['depth']) ? $max_depth - $item['depth'] : 0;}/** * Update the children of a menu link that's being moved. * * The menu name, parents (p1 - p6), and depth are updated for all children of * the link, and the has_children status of the previous parent is updated. */function _menu_link_move_children($item, $existing_item) {  $args[] = $item['menu_name'];  $set[] = "menu_name = '%s'";  $i = 1;  while ($i <= $item['depth']) {    $p = 'p'. $i++;    $set[] = "$p = %d";    $args[] = $item[$p];  }  $j = $existing_item['depth'] + 1;  while ($i <= MENU_MAX_DEPTH && $j <= MENU_MAX_DEPTH) {    $set[] = 'p'. $i++ .' = p'. $j++;  }  while ($i <= MENU_MAX_DEPTH) {    $set[] = 'p'. $i++ .' = 0';  }  $shift = $item['depth'] - $existing_item['depth'];  if ($shift < 0) {    $args[] = -$shift;    $set[] = 'depth = depth - %d';  }  elseif ($shift > 0) {    // The order of $set must be reversed so the new values don't overwrite the    // old ones before they can be used because "Single-table UPDATE    // assignments are generally evaluated from left to right"    // see: http://dev.mysql.com/doc/refman/5.0/en/update.html    $set = array_reverse($set);    $args = array_reverse($args);    $args[] = $shift;    $set[] = 'depth = depth + %d';  }  $where[] = "menu_name = '%s'";  $args[] = $existing_item['menu_name'];  $p = 'p1';  for ($i = 1; $i <= MENU_MAX_DEPTH && $existing_item[$p]; $p = 'p'. ++$i) {    $where[] = "$p = %d";    $args[] = $existing_item[$p];  }  db_query("UPDATE {menu_links} SET ". implode(', ', $set) ." WHERE ". implode(' AND ', $where), $args);  // Check the has_children status of the parent, while excluding this item.  _menu_update_parental_status($existing_item, TRUE);}/** * Check and update the has_children status for the parent of a link. */function _menu_update_parental_status($item, $exclude = FALSE) {  // If plid == 0, there is nothing to update.  if ($item['plid']) {    // We may want to exclude the passed link as a possible child.    $where = $exclude ? " AND mlid != %d" : '';    // Check if at least one visible child exists in the table.    $parent_has_children = (bool)db_result(db_query_range("SELECT mlid FROM {menu_links} WHERE menu_name = '%s' AND plid = %d AND hidden = 0". $where, $item['menu_name'], $item['plid'], $item['mlid'], 0, 1));    db_query("UPDATE {menu_links} SET has_children = %d WHERE mlid = %d", $parent_has_children, $item['plid']);  }}/** * Helper function that sets the p1..p9 values for a menu link being saved. */function _menu_link_parents_set(&$item, $parent) {  $i = 1;  while ($i < $item['depth']) {    $p = 'p'. $i++;    $item[$p] = $parent[$p];  }  $p = 'p'. $i++;  // The parent (p1 - p9) corresponding to the depth always equals the mlid.  $item[$p] = $item['mlid'];  while ($i <= MENU_MAX_DEPTH) {    $p = 'p'. $i++;    $item[$p] = 0;  }}/** * Helper function to build the router table based on the data from hook_menu. */function _menu_router_build($callbacks) {  // First pass: separate callbacks from paths, making paths ready for  // matching. Calculate fitness, and fill some default values.  $menu = array();  foreach ($callbacks as $path => $item) {    $load_functions = array();    $to_arg_functions = array();    $fit = 0;    $move = FALSE;    $parts = explode('/', $path, MENU_MAX_PARTS);    $number_parts = count($parts);    // We store the highest index of parts here to save some work in the fit    // calculation loop.    $slashes = $number_parts - 1;    // Extract load and to_arg functions.    foreach ($parts as $k => $part) {      $match = FALSE;      // Look for wildcards in the form allowed to be used in PHP functions,      // because we are using these to construct the load function names.      // See http://php.net/manual/en/language.functions.php for reference.      if (preg_match('/^%(|[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)$/', $part, $matches)) {        if (empty($matches[1])) {          $match = TRUE;          $load_functions[$k] = NULL;        }        else {          if (function_exists($matches[1] .'_to_arg')) {            $to_arg_functions[$k] = $matches[1] .'_to_arg';            $load_functions[$k] = NULL;            $match = TRUE;          }          if (function_exists($matches[1] .'_load')) {            $function = $matches[1] .'_load';            // Create an array of arguments that will be passed to the _load            // function when this menu path is checked, if 'load arguments'            // exists.            $load_functions[$k] = isset($item['load arguments']) ? array($function => $item['load arguments']) : $function;            $match = TRUE;          }        }      }      if ($match) {        $parts[$k] = '%';      }      else {        $fit |=  1 << ($slashes - $k);      }    }    if ($fit) {      $move = TRUE;    }    else {      // If there is no %, it fits maximally.      $fit = (1 << $number_parts) - 1;    }    $masks[$fit] = 1;    $item['load_functions'] = empty($load_functions) ? '' : serialize($load_functions);    $item['to_arg_functions'] = empty($to_arg_functions) ? '' : serialize($to_arg_functions);    $item += array(      'title' => '',      'weight' => 0,      'type' => MENU_NORMAL_ITEM,      '_number_parts' => $number_parts,      '_parts' => $parts,      '_fit' => $fit,    );    $item += array(      '_visible' => (bool)($item['type'] & MENU_VISIBLE_IN_BREADCRUMB),      '_tab' => (bool)($item['type'] & MENU_IS_LOCAL_TASK),    );    if ($move) {      $new_path = implode('/', $item['_parts']);      $menu[$new_path] = $item;      $sort[$new_path] = $number_parts;    }    else {      $menu[$path] = $item;      $sort[$path] = $number_parts;    }  }  array_multisort($sort, SORT_NUMERIC, $menu);  if (!$menu) {    // We must have a serious error - there is no data to save.    watchdog('php', 'Menu router rebuild failed - some paths may not work correctly.', array(), WATCHDOG_ERROR);    return array();  }  // Delete the existing router since we have some data to replace it.  db_query('DELETE FROM {menu_router}');  // Apply inheritance rules.  foreach ($menu as $path => $v) {    $item = &$menu[$path];    if (!$item['_tab']) {      // Non-tab items.      $item['tab_parent'] = '';      $item['tab_root'] = $path;    }    for ($i = $item['_number_parts'] - 1; $i; $i--) {      $parent_path = implode('/', array_slice($item['_parts'], 0, $i));      if (isset($menu[$parent_path])) {        $parent = $menu[$parent_path];        if (!isset($item['tab_parent'])) {          // Parent stores the parent of the path.          $item['tab_parent'] = $parent_path;        }        if (!isset($item['tab_root']) && !$parent['_tab']) {          $item['tab_root'] = $parent_path;        }        // If an access callback is not found for a default local task we use        // the callback from the parent, since we expect them to be identical.        // In all other cases, the access parameters must be specified.        if (($item['type'] == MENU_DEFAULT_LOCAL_TASK) && !isset($item['access callback']) && isset($parent['access callback'])) {          $item['access callback'] = $parent['access callback'];          if (!isset($item['access arguments']) && isset($parent['access arguments'])) {            $item['access arguments'] = $parent['access arguments'];          }        }        // Same for page callbacks.        if (!isset($item['page callback']) && isset($parent['page callback'])) {          $item['page callback'] = $parent['page callback'];          if (!isset($item['page arguments']) && isset($parent['page arguments'])) {            $item['page arguments'] = $parent['page arguments'];          }          if (!isset($item['file']) && isset($parent['file'])) {            $item['file'] = $parent['file'];          }          if (!isset($item['file path']) && isset($parent['file path'])) {            $item['file path'] = $parent['file path'];          }        }      }    }    if (!isset($item['access callback']) && isset($item['access arguments'])) {      // Default callback.      $item['access callback'] = 'user_access';    }    if (!isset($item['access callback']) || empty($item['page callback'])) {      $item['access callback'] = 0;    }    if (is_bool($item['access callback'])) {      $item['access callback'] = intval($item['access callback']);    }    $item += array(      'access arguments' => array(),      'access callback' => '',      'page arguments' => array(),      'page callback' => '',      'block callback' => '',      'title arguments' => array(),      'title callback' => 't',      'description' => '',      'position' => '',      'tab_parent' => '',      'tab_root' => $path,      'path' => $path,      'file' => '',      'file path' => '',      'include file' => '',    );    // Calculate out the file to be included for each callback, if any.    if ($item['file']) {      $file_path = $item['file path'] ? $item['file path'] : drupal_get_path('module', $item['module']);      $item['include file'] = $file_path .'/'. $item['file'];    }    $title_arguments = $item['title arguments'] ? serialize($item['title arguments']) : '';    db_query("INSERT INTO {menu_router}      (path, load_functions, to_arg_functions, access_callback,      access_arguments, page_callback, page_arguments, fit,      number_parts, tab_parent, tab_root,      title, title_callback, title_arguments,      type, block_callback, description, position, weight, file)      VALUES ('%s', '%s', '%s', '%s',      '%s', '%s', '%s', %d,      %d, '%s', '%s',      '%s', '%s', '%s',      %d, '%s', '%s', '%s', %d, '%s')",      $path, $item['load_functions'], $item['to_arg_functions'], $item['access callback'],      serialize($item['access arguments']), $item['page callback'], serialize($item['page arguments']), $item['_fit'],      $item['_number_parts'], $item['tab_parent'], $item['tab_root'],      $item['title'], $item['title callback'], $title_arguments,      $item['type'], $item['block callback'], $item['description'], $item['position'], $item['weight'], $item['include file']);  }  // Sort the masks so they are in order of descending fit, and store them.  $masks = array_keys($masks);  rsort($masks);  variable_set('menu_masks', $masks);  return $menu;}/** * Returns TRUE if a path is external (e.g. http://example.com). */function menu_path_is_external($path) {  $colonpos = strpos($path, ':');  return $colonpos !== FALSE && !preg_match('![/?#]!', substr($path, 0, $colonpos)) && filter_xss_bad_protocol($path, FALSE) == check_plain($path);}/** * Checks whether the site is off-line for maintenance. * * This function will log the current user out and redirect to front page * if the current user has no 'administer site configuration' permission. * * @return *   FALSE if the site is not off-line or its the login page or the user has *     'administer site configuration' permission. *   TRUE for anonymous users not on the login page if the site is off-line. */function _menu_site_is_offline() {  // Check if site is set to off-line mode.  if (variable_get('site_offline', 0)) {    // Check if the user has administration privileges.    if (user_access('administer site configuration')) {      // Ensure that the off-line message is displayed only once [allowing for      // page redirects], and specifically suppress its display on the site      // maintenance page.      if (drupal_get_normal_path($_GET['q']) != 'admin/settings/site-maintenance') {        drupal_set_message(l(t('Operating in off-line mode.'), 'admin/settings/site-maintenance'), 'status', FALSE);      }    }    else {      // Anonymous users get a FALSE at the login prompt, TRUE otherwise.      if (user_is_anonymous()) {        return $_GET['q'] != 'user' && $_GET['q'] != 'user/login';      }      // Logged in users are unprivileged here, so they are logged out.      require_once drupal_get_path('module', 'user') .'/user.pages.inc';      user_logout();    }  }  return FALSE;}/** * Validates the path of a menu link being created or edited. * * @return *   TRUE if it is a valid path AND the current user has access permission, *   FALSE otherwise. */function menu_valid_path($form_item) {  global $menu_admin;  $item = array();  $path = $form_item['link_path'];  // We indicate that a menu administrator is running the menu access check.  $menu_admin = TRUE;  if ($path == '<front>' || menu_path_is_external($path)) {    $item = array('access' => TRUE);  }  elseif (preg_match('/\/\%/', $path)) {    // Path is dynamic (ie 'user/%'), so check directly against menu_router table.    if ($item = db_fetch_array(db_query("SELECT * FROM {menu_router} where path = '%s' ", $path))) {      $item['link_path']  = $form_item['link_path'];      $item['link_title'] = $form_item['link_title'];      $item['external']   = FALSE;      $item['options'] = '';      _menu_link_translate($item);    }  }  else {    $item = menu_get_item($path);  }  $menu_admin = FALSE;  return $item && $item['access'];}/** * @} End of "defgroup menu". */
