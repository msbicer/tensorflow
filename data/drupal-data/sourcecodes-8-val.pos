<?php// $Id$/** * @file * Drupal XML-RPC library. Based on the IXR - The Incutio XML-RPC Library - (c) Incutio Ltd 2002-2005 * Version 1.7 (beta) - Simon Willison, 23rd May 2005 * Site:   http://scripts.incutio.com/xmlrpc/ * Manual: http://scripts.incutio.com/xmlrpc/manual.php * This version is made available under the GNU GPL License *//** * Recursively turn a data structure into objects with 'data' and 'type' attributes. * * @param $data *   The data structure. * @param  $type *   Optional type assign to $data. * @return *   Object. */function xmlrpc_value($data, $type = FALSE) {  $xmlrpc_value = new stdClass();  $xmlrpc_value->data = $data;  if (!$type) {    $type = xmlrpc_value_calculate_type($xmlrpc_value);  }  $xmlrpc_value->type = $type;  if ($type == 'struct') {    // Turn all the values in the array into new xmlrpc_values    foreach ($xmlrpc_value->data as $key => $value) {      $xmlrpc_value->data[$key] = xmlrpc_value($value);    }  }  if ($type == 'array') {    for ($i = 0, $j = count($xmlrpc_value->data); $i < $j; $i++) {      $xmlrpc_value->data[$i] = xmlrpc_value($xmlrpc_value->data[$i]);    }  }  return $xmlrpc_value;}/** * Map PHP type to XML-RPC type. * * @param $xmlrpc_value *   Variable whose type should be mapped. * @return *   XML-RPC type as string. * @see *   http://www.xmlrpc.com/spec#scalars */function xmlrpc_value_calculate_type(&$xmlrpc_value) {  // http://www.php.net/gettype: Never use gettype() to test for a certain type [...] Instead, use the is_* functions.  if (is_bool($xmlrpc_value->data)) {    return 'boolean';  }  if (is_double($xmlrpc_value->data)) {    return 'double';  }  if (is_int($xmlrpc_value->data)) {      return 'int';  }  if (is_array($xmlrpc_value->data)) {    // empty or integer-indexed arrays are 'array', string-indexed arrays 'struct'    return empty($xmlrpc_value->data) || range(0, count($xmlrpc_value->data) - 1) === array_keys($xmlrpc_value->data) ? 'array' : 'struct';  }  if (is_object($xmlrpc_value->data)) {    if ($xmlrpc_value->data->is_date) {      return 'date';    }    if ($xmlrpc_value->data->is_base64) {      return 'base64';    }    $xmlrpc_value->data = get_object_vars($xmlrpc_value->data);    return 'struct';  }  // default  return 'string';}/** * Generate XML representing the given value. * * @param $xmlrpc_value * @return *   XML representation of value. */function xmlrpc_value_get_xml($xmlrpc_value) {  switch ($xmlrpc_value->type) {    case 'boolean':      return '<boolean>'. (($xmlrpc_value->data) ? '1' : '0') .'</boolean>';      break;    case 'int':      return '<int>'. $xmlrpc_value->data .'</int>';      break;    case 'double':      return '<double>'. $xmlrpc_value->data .'</double>';      break;    case 'string':      // Note: we don't escape apostrophes because of the many blogging clients      // that don't support numerical entities (and XML in general) properly.      return '<string>'. htmlspecialchars($xmlrpc_value->data) .'</string>';      break;    case 'array':      $return = '<array><data>'."\n";      foreach ($xmlrpc_value->data as $item) {        $return .= '  <value>'. xmlrpc_value_get_xml($item) ."</value>\n";      }      $return .= '</data></array>';      return $return;      break;    case 'struct':      $return = '<struct>'."\n";      foreach ($xmlrpc_value->data as $name => $value) {        $return .= "  <member><name>". check_plain($name) ."</name><value>";        $return .= xmlrpc_value_get_xml($value) ."</value></member>\n";      }      $return .= '</struct>';      return $return;      break;    case 'date':      return xmlrpc_date_get_xml($xmlrpc_value->data);      break;    case 'base64':      return xmlrpc_base64_get_xml($xmlrpc_value->data);      break;  }  return FALSE;}/** * Construct an object representing an XML-RPC message. * * @param $message *   String containing XML as defined at http://www.xmlrpc.com/spec * @return *   Object */function xmlrpc_message($message) {  $xmlrpc_message = new stdClass();  $xmlrpc_message->array_structs = array();   // The stack used to keep track of the current array/struct  $xmlrpc_message->array_structs_types = array(); // The stack used to keep track of if things are structs or array  $xmlrpc_message->current_struct_name = array();  // A stack as well  $xmlrpc_message->message = $message;  return $xmlrpc_message;}/** * Parse an XML-RPC message. If parsing fails, the faultCode and faultString * will be added to the message object. * * @param $xmlrpc_message *   Object generated by xmlrpc_message() * @return *   TRUE if parsing succeeded; FALSE otherwise */function xmlrpc_message_parse(&$xmlrpc_message) {  // First remove the XML declaration  $xmlrpc_message->message = preg_replace('/<\?xml(.*)?\?'.'>/', '', $xmlrpc_message->message);  if (trim($xmlrpc_message->message) == '') {    return FALSE;  }  $xmlrpc_message->_parser = xml_parser_create();  // Set XML parser to take the case of tags into account.  xml_parser_set_option($xmlrpc_message->_parser, XML_OPTION_CASE_FOLDING, FALSE);  // Set XML parser callback functions  xml_set_element_handler($xmlrpc_message->_parser, 'xmlrpc_message_tag_open', 'xmlrpc_message_tag_close');  xml_set_character_data_handler($xmlrpc_message->_parser, 'xmlrpc_message_cdata');  xmlrpc_message_set($xmlrpc_message);  if (!xml_parse($xmlrpc_message->_parser, $xmlrpc_message->message)) {    return FALSE;  }  xml_parser_free($xmlrpc_message->_parser);  // Grab the error messages, if any  $xmlrpc_message = xmlrpc_message_get();  if ($xmlrpc_message->messagetype == 'fault') {    $xmlrpc_message->fault_code = $xmlrpc_message->params[0]['faultCode'];    $xmlrpc_message->fault_string = $xmlrpc_message->params[0]['faultString'];  }  return TRUE;}/** * Store a copy of the $xmlrpc_message object temporarily. * * @param $value *   Object * @return *   The most recently stored $xmlrpc_message */function xmlrpc_message_set($value = NULL) {  static $xmlrpc_message;  if ($value) {    $xmlrpc_message = $value;  }  return $xmlrpc_message;}function xmlrpc_message_get() {  return xmlrpc_message_set();}function xmlrpc_message_tag_open($parser, $tag, $attr) {  $xmlrpc_message = xmlrpc_message_get();  $xmlrpc_message->current_tag_contents = '';  $xmlrpc_message->last_open = $tag;  switch ($tag) {    case 'methodCall':    case 'methodResponse':    case 'fault':      $xmlrpc_message->messagetype = $tag;      break;    // Deal with stacks of arrays and structs    case 'data':      $xmlrpc_message->array_structs_types[] = 'array';      $xmlrpc_message->array_structs[] = array();      break;    case 'struct':      $xmlrpc_message->array_structs_types[] = 'struct';      $xmlrpc_message->array_structs[] = array();      break;  }  xmlrpc_message_set($xmlrpc_message);}function xmlrpc_message_cdata($parser, $cdata) {  $xmlrpc_message = xmlrpc_message_get();  $xmlrpc_message->current_tag_contents .= $cdata;  xmlrpc_message_set($xmlrpc_message);}function xmlrpc_message_tag_close($parser, $tag) {  $xmlrpc_message = xmlrpc_message_get();  $value_flag = FALSE;  switch ($tag) {    case 'int':    case 'i4':      $value = (int)trim($xmlrpc_message->current_tag_contents);      $value_flag = TRUE;      break;    case 'double':      $value = (double)trim($xmlrpc_message->current_tag_contents);      $value_flag = TRUE;      break;    case 'string':      $value = $xmlrpc_message->current_tag_contents;      $value_flag = TRUE;      break;    case 'dateTime.iso8601':      $value = xmlrpc_date(trim($xmlrpc_message->current_tag_contents));      // $value = $iso->getTimestamp();      $value_flag = TRUE;      break;    case 'value':      // If no type is indicated, the type is string      // We take special care for empty values      if (trim($xmlrpc_message->current_tag_contents) != '' || (isset($xmlrpc_message->last_open) && ($xmlrpc_message->last_open == 'value'))) {        $value = (string)$xmlrpc_message->current_tag_contents;        $value_flag = TRUE;      }      unset($xmlrpc_message->last_open);      break;    case 'boolean':      $value = (boolean)trim($xmlrpc_message->current_tag_contents);      $value_flag = TRUE;      break;    case 'base64':      $value = base64_decode(trim($xmlrpc_message->current_tag_contents));      $value_flag = TRUE;      break;    // Deal with stacks of arrays and structs    case 'data':    case 'struct':      $value = array_pop($xmlrpc_message->array_structs );      array_pop($xmlrpc_message->array_structs_types);      $value_flag = TRUE;      break;    case 'member':      array_pop($xmlrpc_message->current_struct_name);      break;    case 'name':      $xmlrpc_message->current_struct_name[] = trim($xmlrpc_message->current_tag_contents);      break;    case 'methodName':      $xmlrpc_message->methodname = trim($xmlrpc_message->current_tag_contents);      break;  }  if ($value_flag) {    if (count($xmlrpc_message->array_structs ) > 0) {      // Add value to struct or array      if ($xmlrpc_message->array_structs_types[count($xmlrpc_message->array_structs_types)-1] == 'struct') {        // Add to struct        $xmlrpc_message->array_structs [count($xmlrpc_message->array_structs )-1][$xmlrpc_message->current_struct_name[count($xmlrpc_message->current_struct_name)-1]] = $value;      }      else {        // Add to array        $xmlrpc_message->array_structs [count($xmlrpc_message->array_structs )-1][] = $value;      }    }    else {      // Just add as a parameter      $xmlrpc_message->params[] = $value;    }  }  if (!in_array($tag, array("data", "struct", "member"))) {    $xmlrpc_message->current_tag_contents = '';  }  xmlrpc_message_set($xmlrpc_message);}/** * Construct an object representing an XML-RPC request * * @param $method *   The name of the method to be called * @param $args *   An array of parameters to send with the method. * @return *   Object */function xmlrpc_request($method, $args) {  $xmlrpc_request = new stdClass();  $xmlrpc_request->method = $method;  $xmlrpc_request->args = $args;  $xmlrpc_request->xml = <<<EOD<?xml version="1.0"?><methodCall><methodName>{$xmlrpc_request->method}</methodName><params>EOD;  foreach ($xmlrpc_request->args as $arg) {    $xmlrpc_request->xml .= '<param><value>';    $v = xmlrpc_value($arg);    $xmlrpc_request->xml .= xmlrpc_value_get_xml($v);    $xmlrpc_request->xml .= "</value></param>\n";  }  $xmlrpc_request->xml .= '</params></methodCall>';  return $xmlrpc_request;}function xmlrpc_error($code = NULL, $message = NULL, $reset = FALSE) {  static $xmlrpc_error;  if (isset($code)) {    $xmlrpc_error = new stdClass();    $xmlrpc_error->is_error = TRUE;    $xmlrpc_error->code = $code;    $xmlrpc_error->message = $message;  }  elseif ($reset) {    $xmlrpc_error = NULL;  }  return $xmlrpc_error;}function xmlrpc_error_get_xml($xmlrpc_error) {  return <<<EOD<methodResponse>  <fault>  <value>    <struct>    <member>      <name>faultCode</name>      <value><int>{$xmlrpc_error->code}</int></value>    </member>    <member>      <name>faultString</name>      <value><string>{$xmlrpc_error->message}</string></value>    </member>    </struct>  </value>  </fault></methodResponse>EOD;}function xmlrpc_date($time) {  $xmlrpc_date = new stdClass();  $xmlrpc_date->is_date = TRUE;  // $time can be a PHP timestamp or an ISO one  if (is_numeric($time)) {    $xmlrpc_date->year = gmdate('Y', $time);    $xmlrpc_date->month = gmdate('m', $time);    $xmlrpc_date->day = gmdate('d', $time);    $xmlrpc_date->hour = gmdate('H', $time);    $xmlrpc_date->minute = gmdate('i', $time);    $xmlrpc_date->second = gmdate('s', $time);    $xmlrpc_date->iso8601 = gmdate('Ymd\TH:i:s', $time);  }  else {    $xmlrpc_date->iso8601 = $time;    $time = str_replace(array('-', ':'), '', $time);    $xmlrpc_date->year = substr($time, 0, 4);    $xmlrpc_date->month = substr($time, 4, 2);    $xmlrpc_date->day = substr($time, 6, 2);    $xmlrpc_date->hour = substr($time, 9, 2);    $xmlrpc_date->minute = substr($time, 11, 2);    $xmlrpc_date->second = substr($time, 13, 2);  }  return $xmlrpc_date;}function xmlrpc_date_get_xml($xmlrpc_date) {  return '<dateTime.iso8601>'. $xmlrpc_date->year . $xmlrpc_date->month . $xmlrpc_date->day .'T'. $xmlrpc_date->hour .':'. $xmlrpc_date->minute .':'. $xmlrpc_date->second .'</dateTime.iso8601>';}function xmlrpc_base64($data) {  $xmlrpc_base64 = new stdClass();  $xmlrpc_base64->is_base64 = TRUE;  $xmlrpc_base64->data = $data;  return $xmlrpc_base64;}function xmlrpc_base64_get_xml($xmlrpc_base64) {  return '<base64>'. base64_encode($xmlrpc_base64->data) .'</base64>';}/** * Execute an XML remote procedural call. This is private function; call xmlrpc() * in common.inc instead of this function. * * @return *   A $xmlrpc_message object if the call succeeded; FALSE if the call failed */function _xmlrpc() {  $args = func_get_args();  $url = array_shift($args);  xmlrpc_clear_error();  if (is_array($args[0])) {    $method = 'system.multicall';    $multicall_args = array();    foreach ($args[0] as $call) {      $multicall_args[] = array('methodName' => array_shift($call), 'params' => $call);    }    $args = array($multicall_args);  }  else {    $method = array_shift($args);  }  $xmlrpc_request = xmlrpc_request($method, $args);  $result = drupal_http_request($url, array("Content-Type" => "text/xml"), 'POST', $xmlrpc_request->xml);  if ($result->code != 200) {    xmlrpc_error($result->code, $result->error);    return FALSE;  }  $message = xmlrpc_message($result->data);  // Now parse what we've got back  if (!xmlrpc_message_parse($message)) {    // XML error    xmlrpc_error(-32700, t('Parse error. Not well formed'));    return FALSE;  }  // Is the message a fault?  if ($message->messagetype == 'fault') {    xmlrpc_error($message->fault_code, $message->fault_string);    return FALSE;  }  // Message must be OK  return $message->params[0];}/** * Returns the last XML-RPC client error number */function xmlrpc_errno() {  $error = xmlrpc_error();  return ($error != NULL ? $error->code : NULL);}/** * Returns the last XML-RPC client error message */function xmlrpc_error_msg() {  $error = xmlrpc_error();  return ($error != NULL ? $error->message : NULL);}/** * Clears any previous error. */function xmlrpc_clear_error() {  xmlrpc_error(NULL, NULL, TRUE);}
<?php// $Id$/** * @file * Page callbacks for the taxonomy module. *//** * Menu callback; displays all nodes associated with a term. */function taxonomy_term_page($str_tids = '', $depth = 0, $op = 'page') {  $terms = taxonomy_terms_parse_string($str_tids);  if ($terms['operator'] != 'and' && $terms['operator'] != 'or') {    drupal_not_found();  }  if ($terms['tids']) {    $result = db_query(db_rewrite_sql('SELECT t.tid, t.name FROM {term_data} t WHERE t.tid IN ('. db_placeholders($terms['tids']) .')', 't', 'tid'), $terms['tids']);    $tids = array(); // we rebuild the $tids-array so it only contains terms the user has access to.    $names = array();    while ($term = db_fetch_object($result)) {      $tids[] = $term->tid;      $names[] = $term->name;    }    if ($names) {      $title = implode(', ', $names);      drupal_set_title(check_plain($title));      switch ($op) {        case 'page':          // Build breadcrumb based on first hierarchy of first term:          $current->tid = $tids[0];          $breadcrumb = array();          while ($parents = taxonomy_get_parents($current->tid)) {            $current = array_shift($parents);            $breadcrumb[] = l($current->name, 'taxonomy/term/'. $current->tid);          }          $breadcrumb[] = l(t('Home'), NULL);          $breadcrumb = array_reverse($breadcrumb);          drupal_set_breadcrumb($breadcrumb);          $output = theme('taxonomy_term_page', $tids, taxonomy_select_nodes($tids, $terms['operator'], $depth, TRUE));          drupal_add_feed(url('taxonomy/term/'. $str_tids .'/'. $depth .'/feed'), 'RSS - '. $title);          return $output;          break;        case 'feed':          $channel['link'] = url('taxonomy/term/'. $str_tids .'/'. $depth, array('absolute' => TRUE));          $channel['title'] = variable_get('site_name', 'Drupal') .' - '. $title;          // Only display the description if we have a single term, to avoid clutter and confusion.          if (count($tids) == 1) {            $term = taxonomy_get_term($tids[0]);            // HTML will be removed from feed description, so no need to filter here.            $channel['description'] = $term->description;          }          $result = taxonomy_select_nodes($tids, $terms['operator'], $depth, FALSE);          $items = array();           while ($row = db_fetch_object($result)) {            $items[] = $row->nid;          }          node_feed($items, $channel);          break;        default:          drupal_not_found();      }    }    else {      drupal_not_found();    }  }}/** * Render a taxonomy term page HTML output. * * @param $tids *   An array of term ids. * @param $result *   A pager_query() result, such as that performed by taxonomy_select_nodes(). * * @ingroup themeable */function theme_taxonomy_term_page($tids, $result) {  drupal_add_css(drupal_get_path('module', 'taxonomy') .'/taxonomy.css');  $output = '';  // Only display the description if we have a single term, to avoid clutter and confusion.  if (count($tids) == 1) {    $term = taxonomy_get_term($tids[0]);    $description = $term->description;    // Check that a description is set.    if (!empty($description)) {      $output .= '<div class="taxonomy-term-description">';      $output .= filter_xss_admin($description);      $output .= '</div>';    }  }  $output .= taxonomy_render_nodes($result);  return $output;}/** * Helper function for autocompletion */function taxonomy_autocomplete($vid, $string = '') {  // The user enters a comma-separated list of tags. We only autocomplete the last tag.  $array = drupal_explode_tags($string);  // Fetch last tag  $last_string = trim(array_pop($array));  $matches = array();  if ($last_string != '') {    $result = db_query_range(db_rewrite_sql("SELECT t.tid, t.name FROM {term_data} t WHERE t.vid = %d AND LOWER(t.name) LIKE LOWER('%%%s%%')", 't', 'tid'), $vid, $last_string, 0, 10);    $prefix = count($array) ? implode(', ', $array) .', ' : '';    while ($tag = db_fetch_object($result)) {      $n = $tag->name;      // Commas and quotes in terms are special cases, so encode 'em.      if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {        $n = '"'. str_replace('"', '""', $tag->name) .'"';      }      $matches[$prefix . $n] = check_plain($tag->name);    }  }  drupal_json($matches);}
<?php// $Id$/** * @file * Functions to aid in presenting database results as a set of pages. *//** * Perform a paged database query. * * Use this function when doing select queries you wish to be able to page. The * pager uses LIMIT-based queries to fetch only the records required to render a * certain page. However, it has to learn the total number of records returned * by the query to compute the number of pages (the number of records / records * per page). This is done by inserting "COUNT(*)" in the original query. For * example, the query "SELECT nid, type FROM node WHERE status = '1' ORDER BY * sticky DESC, created DESC" would be rewritten to read "SELECT COUNT(*) FROM * node WHERE status = '1' ORDER BY sticky DESC, created DESC". Rewriting the * query is accomplished using a regular expression. * * Unfortunately, the rewrite rule does not always work as intended for queries * that already have a "COUNT(*)" or a "GROUP BY" clause, and possibly for * other complex queries. In those cases, you can optionally pass a query that * will be used to count the records. * * For example, if you want to page the query "SELECT COUNT(*), TYPE FROM node * GROUP BY TYPE", pager_query() would invoke the incorrect query "SELECT * COUNT(*) FROM node GROUP BY TYPE". So instead, you should pass "SELECT * COUNT(DISTINCT(TYPE)) FROM node" as the optional $count_query parameter. * * @param $query *   The SQL query that needs paging. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $count_query *   An SQL query used to count matching records. * @param ... *   A variable number of arguments which are substituted into the query (and *   the count query) using printf() syntax. Instead of a variable number of *   query arguments, you may also pass a single array containing the query *   arguments. * @return *   A database query result resource, or FALSE if the query was not executed *   correctly. * * @ingroup database */function pager_query($query, $limit = 10, $element = 0, $count_query = NULL) {  global $pager_page_array, $pager_total, $pager_total_items;  $page = isset($_GET['page']) ? $_GET['page'] : '';  // Substitute in query arguments.  $args = func_get_args();  $args = array_slice($args, 4);  // Alternative syntax for '...'  if (isset($args[0]) && is_array($args[0])) {    $args = $args[0];  }  // Construct a count query if none was given.  if (!isset($count_query)) {    $count_query = preg_replace(array('/SELECT.*?FROM /As', '/ORDER BY .*/'), array('SELECT COUNT(*) FROM ', ''), $query);  }  // Convert comma-separated $page to an array, used by other functions.  $pager_page_array = explode(',', $page);  // We calculate the total of pages as ceil(items / limit).  $pager_total_items[$element] = db_result(db_query($count_query, $args));  $pager_total[$element] = ceil($pager_total_items[$element] / $limit);  $pager_page_array[$element] = max(0, min((int)$pager_page_array[$element], ((int)$pager_total[$element]) - 1));  return db_query_range($query, $args, $pager_page_array[$element] * $limit, $limit);}/** * Compose a query string to append to pager requests. * * @return *   A query string that consists of all components of the current page request *   except for those pertaining to paging. */function pager_get_querystring() {  static $string = NULL;  if (!isset($string)) {    $string = drupal_query_string_encode($_REQUEST, array_merge(array('q', 'page', 'pass'), array_keys($_COOKIE)));  }  return $string;}/** * Format a query pager. * * Menu callbacks that display paged query results should call theme('pager') to * retrieve a pager control so that users can view other results. * Format a list of nearby pages with additional query results. * * @param $tags *   An array of labels for the controls in the pager. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @param $quantity *   The number of pages in the list. * @return *   An HTML string that generates the query pager. * * @ingroup themeable */function theme_pager($tags = array(), $limit = 10, $element = 0, $parameters = array(), $quantity = 9) {  global $pager_page_array, $pager_total;  // Calculate various markers within this pager piece:  // Middle is used to "center" pages around the current page.  $pager_middle = ceil($quantity / 2);  // current is the page we are currently paged to  $pager_current = $pager_page_array[$element] + 1;  // first is the first page listed by this pager piece (re quantity)  $pager_first = $pager_current - $pager_middle + 1;  // last is the last page listed by this pager piece (re quantity)  $pager_last = $pager_current + $quantity - $pager_middle;  // max is the maximum page number  $pager_max = $pager_total[$element];  // End of marker calculations.  // Prepare for generation loop.  $i = $pager_first;  if ($pager_last > $pager_max) {    // Adjust "center" if at end of query.    $i = $i + ($pager_max - $pager_last);    $pager_last = $pager_max;  }  if ($i <= 0) {    // Adjust "center" if at start of query.    $pager_last = $pager_last + (1 - $i);    $i = 1;  }  // End of generation loop preparation.  $li_first = theme('pager_first', (isset($tags[0]) ? $tags[0] : t(' first')), $limit, $element, $parameters);  $li_previous = theme('pager_previous', (isset($tags[1]) ? $tags[1] : t(' previous')), $limit, $element, 1, $parameters);  $li_next = theme('pager_next', (isset($tags[3]) ? $tags[3] : t('next ')), $limit, $element, 1, $parameters);  $li_last = theme('pager_last', (isset($tags[4]) ? $tags[4] : t('last ')), $limit, $element, $parameters);  if ($pager_total[$element] > 1) {    if ($li_first) {      $items[] = array(        'class' => 'pager-first',        'data' => $li_first,      );    }    if ($li_previous) {      $items[] = array(        'class' => 'pager-previous',        'data' => $li_previous,      );    }    // When there is more than one page, create the pager list.    if ($i != $pager_max) {      if ($i > 1) {        $items[] = array(          'class' => 'pager-ellipsis',          'data' => '',        );      }      // Now generate the actual pager piece.      for (; $i <= $pager_last && $i <= $pager_max; $i++) {        if ($i < $pager_current) {          $items[] = array(            'class' => 'pager-item',            'data' => theme('pager_previous', $i, $limit, $element, ($pager_current - $i), $parameters),          );        }        if ($i == $pager_current) {          $items[] = array(            'class' => 'pager-current',            'data' => $i,          );        }        if ($i > $pager_current) {          $items[] = array(            'class' => 'pager-item',            'data' => theme('pager_next', $i, $limit, $element, ($i - $pager_current), $parameters),          );        }      }      if ($i < $pager_max) {        $items[] = array(          'class' => 'pager-ellipsis',          'data' => '',        );      }    }    // End generation.    if ($li_next) {      $items[] = array(        'class' => 'pager-next',        'data' => $li_next,      );    }    if ($li_last) {      $items[] = array(        'class' => 'pager-last',        'data' => $li_last,      );    }    return theme('item_list', $items, NULL, 'ul', array('class' => 'pager'));  }}/** * @name Pager pieces * @{ * Use these pieces to construct your own custom pagers in your theme. Note that * you should NOT modify this file to customize your pager. *//** * Format a "first page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_first($text, $limit, $element = 0, $parameters = array()) {  global $pager_page_array;  $output = '';  // If we are anywhere but the first page  if ($pager_page_array[$element] > 0) {    $output = theme('pager_link', $text, pager_load_array(0, $element, $pager_page_array), $element, $parameters);  }  return $output;}/** * Format a "previous page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $interval *   The number of pages to move backward when the link is clicked. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_previous($text, $limit, $element = 0, $interval = 1, $parameters = array()) {  global $pager_page_array;  $output = '';  // If we are anywhere but the first page  if ($pager_page_array[$element] > 0) {    $page_new = pager_load_array($pager_page_array[$element] - $interval, $element, $pager_page_array);    // If the previous page is the first page, mark the link as such.    if ($page_new[$element] == 0) {      $output = theme('pager_first', $text, $limit, $element, $parameters);    }    // The previous page is not the first page.    else {      $output = theme('pager_link', $text, $page_new, $element, $parameters);    }  }  return $output;}/** * Format a "next page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $interval *   The number of pages to move forward when the link is clicked. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_next($text, $limit, $element = 0, $interval = 1, $parameters = array()) {  global $pager_page_array, $pager_total;  $output = '';  // If we are anywhere but the last page  if ($pager_page_array[$element] < ($pager_total[$element] - 1)) {    $page_new = pager_load_array($pager_page_array[$element] + $interval, $element, $pager_page_array);    // If the next page is the last page, mark the link as such.    if ($page_new[$element] == ($pager_total[$element] - 1)) {      $output = theme('pager_last', $text, $limit, $element, $parameters);    }    // The next page is not the last page.    else {      $output = theme('pager_link', $text, $page_new, $element, $parameters);    }  }  return $output;}/** * Format a "last page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_last($text, $limit, $element = 0, $parameters = array()) {  global $pager_page_array, $pager_total;  $output = '';  // If we are anywhere but the last page  if ($pager_page_array[$element] < ($pager_total[$element] - 1)) {    $output = theme('pager_link', $text, pager_load_array($pager_total[$element] - 1, $element, $pager_page_array), $element, $parameters);  }  return $output;}/** * Format a link to a specific query result page. * * @param $page_new *   The first result to display on the linked page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager link. * @param $attributes *   An associative array of HTML attributes to apply to a pager anchor tag. * @return *   An HTML string that generates the link. * * @ingroup themeable */function theme_pager_link($text, $page_new, $element, $parameters = array(), $attributes = array()) {  $page = isset($_GET['page']) ? $_GET['page'] : '';  if ($new_page = implode(',', pager_load_array($page_new[$element], $element, explode(',', $page)))) {    $parameters['page'] = $new_page;  }  $query = array();  if (count($parameters)) {    $query[] = drupal_query_string_encode($parameters, array());  }  $querystring = pager_get_querystring();  if ($querystring != '') {    $query[] = $querystring;  }  // Set each pager link title  if (!isset($attributes['title'])) {    static $titles = NULL;    if (!isset($titles)) {      $titles = array(        t(' first') => t('Go to first page'),        t(' previous') => t('Go to previous page'),        t('next ') => t('Go to next page'),        t('last ') => t('Go to last page'),      );    }    if (isset($titles[$text])) {      $attributes['title'] = $titles[$text];    }    else if (is_numeric($text)) {      $attributes['title'] = t('Go to page @number', array('@number' => $text));    }  }  return l($text, $_GET['q'], array('attributes' => $attributes, 'query' => count($query) ? implode('&', $query) : NULL));}/** * @} End of "Pager pieces". *//** * Helper function * * Copies $old_array to $new_array and sets $new_array[$element] = $value * Fills in $new_array[0 .. $element - 1] = 0 */function pager_load_array($value, $element, $old_array) {  $new_array = $old_array;  // Look for empty elements.  for ($i = 0; $i < $element; $i++) {    if (!$new_array[$i]) {      // Load found empty element with 0.      $new_array[$i] = 0;    }  }  // Update the changed element.  $new_array[$element] = (int)$value;  return $new_array;}
<?php// $Id$/** * Implementation of hook_install(). */function update_install() {  // Create cache table.  drupal_install_schema('update');  // Remove stale variables from update_status 5.x contrib, if any.  _update_remove_update_status_variables();}/** * Implementation of hook_uninstall(). */function update_uninstall() {  // Remove cache table.  drupal_uninstall_schema('update');  // Clear any variables that might be in use  $variables = array(    'update_check_frequency',    'update_fetch_url',    'update_last_check',    'update_notification_threshold',    'update_notify_emails',  );  foreach ($variables as $variable) {    variable_del($variable);  }  menu_rebuild();}/** * Implementation of hook_schema(). */function update_schema() {  $schema['cache_update'] = drupal_get_schema_unprocessed('system', 'cache');  $schema['cache_update']['description'] = 'Cache table for the Update module to store information about available releases, fetched from central server.';  return $schema;}/** * Private helper to clear out stale variables from update_status 5.x contrib. * * @see update_install() * @see update_update_6000() */function _update_remove_update_status_variables() {  variable_del('update_status_settings');  variable_del('update_status_notify_emails');  variable_del('update_status_check_frequency');  variable_del('update_status_notification_threshold');  variable_del('update_status_last');  variable_del('update_status_fetch_url');}/** * Clear out stale variables from update_status. */function update_update_6000() {  _update_remove_update_status_variables();  return array();}
<?php// $Id$/** * @file * Enables the organization of content into categories. *//** * Implementation of hook_perm(). */function taxonomy_perm() {  return array('administer taxonomy');}/** * Implementation of hook_theme() */function taxonomy_theme() {  return array(    'taxonomy_term_select' => array(      'arguments' => array('element' => NULL),    ),    'taxonomy_term_page' => array(      'arguments' => array('tids' => array(), 'result' => NULL),    ),    'taxonomy_overview_vocabularies' => array(      'arguments' => array('form' => array()),    ),    'taxonomy_overview_terms' => array(      'arguments' => array('form' => array()),    ),  );}/** * Implementation of hook_link(). * * This hook is extended with $type = 'taxonomy terms' to allow themes to * print lists of terms associated with a node. Themes can print taxonomy * links with: * * if (module_exists('taxonomy')) { *   $terms = taxonomy_link('taxonomy terms', $node); *   print theme('links', $terms); * } */function taxonomy_link($type, $node = NULL) {  if ($type == 'taxonomy terms' && $node != NULL) {    $links = array();    // If previewing, the terms must be converted to objects first.    if (isset($node->build_mode) && $node->build_mode == NODE_BUILD_PREVIEW) {      $node->taxonomy = taxonomy_preview_terms($node);    }    if (!empty($node->taxonomy)) {      foreach ($node->taxonomy as $term) {        // During preview the free tagging terms are in an array unlike the        // other terms which are objects. So we have to check if a $term        // is an object or not.        if (is_object($term)) {          $links['taxonomy_term_'. $term->tid] = array(            'title' => $term->name,            'href' => taxonomy_term_path($term),            'attributes' => array('rel' => 'tag', 'title' => strip_tags($term->description))          );        }        // Previewing free tagging terms; we don't link them because the        // term-page might not exist yet.        else {          foreach ($term as $free_typed) {            $typed_terms = drupal_explode_tags($free_typed);            foreach ($typed_terms as $typed_term) {              $links['taxonomy_preview_term_'. $typed_term] = array(                'title' => $typed_term,              );            }          }        }      }    }    // We call this hook again because some modules and themes    // call taxonomy_link('taxonomy terms') directly.    drupal_alter('link', $links, $node);    return $links;  }}/** * For vocabularies not maintained by taxonomy.module, give the maintaining * module a chance to provide a path for terms in that vocabulary. * * @param $term *   A term object. * @return *   An internal Drupal path. */function taxonomy_term_path($term) {  $vocabulary = taxonomy_vocabulary_load($term->vid);  if ($vocabulary->module != 'taxonomy' && $path = module_invoke($vocabulary->module, 'term_path', $term)) {    return $path;  }  return 'taxonomy/term/'. $term->tid;}/** * Implementation of hook_menu(). */function taxonomy_menu() {  $items['admin/content/taxonomy'] = array(    'title' => 'Taxonomy',    'description' => 'Manage tagging, categorization, and classification of your content.',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_overview_vocabularies'),    'access arguments' => array('administer taxonomy'),    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/taxonomy/add/vocabulary'] = array(    'title' => 'Add vocabulary',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_form_vocabulary'),    'access arguments' => array('administer taxonomy'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/taxonomy',    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/edit/vocabulary/%taxonomy_vocabulary'] = array(    'title' => 'Edit vocabulary',    'page callback' => 'taxonomy_admin_vocabulary_edit',    'page arguments' => array(5),    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/edit/term'] = array(    'title' => 'Edit term',    'page callback' => 'taxonomy_admin_term_edit',    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['taxonomy/term/%'] = array(    'title' => 'Taxonomy term',    'page callback' => 'taxonomy_term_page',    'page arguments' => array(2),    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.pages.inc',  );  $items['taxonomy/autocomplete'] = array(    'title' => 'Autocomplete taxonomy',    'page callback' => 'taxonomy_autocomplete',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.pages.inc',  );  $items['admin/content/taxonomy/%taxonomy_vocabulary'] = array(    'title' => 'List terms',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_overview_terms', 3),    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/%taxonomy_vocabulary/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/taxonomy/%taxonomy_vocabulary/add/term'] = array(    'title' => 'Add term',    'page callback' => 'taxonomy_add_term_page',    'page arguments' => array(3),    'access arguments' => array('administer taxonomy'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/taxonomy/%taxonomy_vocabulary',    'file' => 'taxonomy.admin.inc',  );  return $items;}function taxonomy_save_vocabulary(&$edit) {  $edit['nodes'] = empty($edit['nodes']) ? array() : $edit['nodes'];  if (!isset($edit['module'])) {    $edit['module'] = 'taxonomy';  }  if (!empty($edit['vid']) && !empty($edit['name'])) {    drupal_write_record('vocabulary', $edit, 'vid');    db_query("DELETE FROM {vocabulary_node_types} WHERE vid = %d", $edit['vid']);    foreach ($edit['nodes'] as $type => $selected) {      db_query("INSERT INTO {vocabulary_node_types} (vid, type) VALUES (%d, '%s')", $edit['vid'], $type);    }    module_invoke_all('taxonomy', 'update', 'vocabulary', $edit);    $status = SAVED_UPDATED;  }  else if (!empty($edit['vid'])) {    $status = taxonomy_del_vocabulary($edit['vid']);  }  else {    drupal_write_record('vocabulary', $edit);    foreach ($edit['nodes'] as $type => $selected) {      db_query("INSERT INTO {vocabulary_node_types} (vid, type) VALUES (%d, '%s')", $edit['vid'], $type);    }    module_invoke_all('taxonomy', 'insert', 'vocabulary', $edit);    $status = SAVED_NEW;  }  cache_clear_all();  return $status;}/** * Delete a vocabulary. * * @param $vid *   A vocabulary ID. * @return *   Constant indicating items were deleted. */function taxonomy_del_vocabulary($vid) {  $vocabulary = (array) taxonomy_vocabulary_load($vid);  db_query('DELETE FROM {vocabulary} WHERE vid = %d', $vid);  db_query('DELETE FROM {vocabulary_node_types} WHERE vid = %d', $vid);  $result = db_query('SELECT tid FROM {term_data} WHERE vid = %d', $vid);  while ($term = db_fetch_object($result)) {    taxonomy_del_term($term->tid);  }  module_invoke_all('taxonomy', 'delete', 'vocabulary', $vocabulary);  cache_clear_all();  return SAVED_DELETED;}/** * Dynamically check and update the hierarachy flag of a vocabulary. * * Checks the current parents of all terms in a vocabulary and updates the * vocabularies hierarchy setting to the lowest possible level. A hierarchy with * no parents in any of its terms will be given a hierarchy of 0. If terms * contain at most a single parent, the vocabulary will be given a hierarchy of * 1. If any term contain multiple parents, the vocabulary will be given a * hieararchy of 2. * * @param $vocabulary *   An array of the vocabulary structure. * @param $changed_term *   An array of the term structure that was updated. */function taxonomy_check_vocabulary_hierarchy($vocabulary, $changed_term) {  $tree = taxonomy_get_tree($vocabulary['vid']);  $hierarchy = 0;  foreach ($tree as $term) {    // Update the changed term with the new parent value before comparision.    if ($term->tid == $changed_term['tid']) {      $term = (object)$changed_term;      $term->parents = $term->parent;    }    // Check this term's parent count.    if (count($term->parents) > 1) {      $hierarchy = 2;      break;    }    elseif (count($term->parents) == 1 && 0 !== array_shift($term->parents)) {      $hierarchy = 1;    }  }  if ($hierarchy != $vocabulary['hierarchy']) {    $vocabulary['hierarchy'] = $hierarchy;    taxonomy_save_vocabulary($vocabulary);  }  return $hierarchy;}/** * Helper function for taxonomy_form_term_submit(). * * @param $form_state['values'] * @return *   Status constant indicating if term was inserted or updated. */function taxonomy_save_term(&$form_values) {  $form_values += array(    'description' => '',    'weight' => 0  );  if (!empty($form_values['tid']) && $form_values['name']) {    drupal_write_record('term_data', $form_values, 'tid');    $hook = 'update';    $status = SAVED_UPDATED;  }  else if (!empty($form_values['tid'])) {    return taxonomy_del_term($form_values['tid']);  }  else {    drupal_write_record('term_data', $form_values);    $hook = 'insert';    $status = SAVED_NEW;  }  db_query('DELETE FROM {term_relation} WHERE tid1 = %d OR tid2 = %d', $form_values['tid'], $form_values['tid']);  if (!empty($form_values['relations'])) {    foreach ($form_values['relations'] as $related_id) {      if ($related_id != 0) {        db_query('INSERT INTO {term_relation} (tid1, tid2) VALUES (%d, %d)', $form_values['tid'], $related_id);      }    }  }  db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $form_values['tid']);  if (!isset($form_values['parent']) || empty($form_values['parent'])) {    $form_values['parent'] = array(0);  }  if (is_array($form_values['parent'])) {    foreach ($form_values['parent'] as $parent) {      if (is_array($parent)) {        foreach ($parent as $tid) {          db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $tid);        }      }      else {        db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $parent);      }    }  }  else {    db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $form_values['parent']);  }  db_query('DELETE FROM {term_synonym} WHERE tid = %d', $form_values['tid']);  if (!empty($form_values['synonyms'])) {    foreach (explode ("\n", str_replace("\r", '', $form_values['synonyms'])) as $synonym) {      if ($synonym) {        db_query("INSERT INTO {term_synonym} (tid, name) VALUES (%d, '%s')", $form_values['tid'], chop($synonym));      }    }  }  if (isset($hook)) {    module_invoke_all('taxonomy', $hook, 'term', $form_values);  }  cache_clear_all();  return $status;}/** * Delete a term. * * @param $tid *   The term ID. * @return *   Status constant indicating deletion. */function taxonomy_del_term($tid) {  $tids = array($tid);  while ($tids) {    $children_tids = $orphans = array();    foreach ($tids as $tid) {      // See if any of the term's children are about to be become orphans:      if ($children = taxonomy_get_children($tid)) {        foreach ($children as $child) {          // If the term has multiple parents, we don't delete it.          $parents = taxonomy_get_parents($child->tid);          if (count($parents) == 1) {            $orphans[] = $child->tid;          }        }      }      $term = (array) taxonomy_get_term($tid);      db_query('DELETE FROM {term_data} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_relation} WHERE tid1 = %d OR tid2 = %d', $tid, $tid);      db_query('DELETE FROM {term_synonym} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_node} WHERE tid = %d', $tid);      module_invoke_all('taxonomy', 'delete', 'term', $term);    }    $tids = $orphans;  }  cache_clear_all();  return SAVED_DELETED;}/** * Generate a form element for selecting terms from a vocabulary. */function taxonomy_form($vid, $value = 0, $help = NULL, $name = 'taxonomy') {  $vocabulary = taxonomy_vocabulary_load($vid);  $help = ($help) ? $help : filter_xss_admin($vocabulary->help);  if (!$vocabulary->multiple) {    $blank = ($vocabulary->required) ? t('- Please choose -') : t('- None selected -');  }  else {    $blank = ($vocabulary->required) ? 0 : t('- None -');  }  return _taxonomy_term_select(check_plain($vocabulary->name), $name, $value, $vid, $help, intval($vocabulary->multiple), $blank);}/** * Generate a set of options for selecting a term from all vocabularies. */function taxonomy_form_all($free_tags = 0) {  $vocabularies = taxonomy_get_vocabularies();  $options = array();  foreach ($vocabularies as $vid => $vocabulary) {    if ($vocabulary->tags && !$free_tags) { continue; }    $tree = taxonomy_get_tree($vid);    if ($tree && (count($tree) > 0)) {      $options[$vocabulary->name] = array();      foreach ($tree as $term) {        $options[$vocabulary->name][$term->tid] = str_repeat('-', $term->depth) . $term->name;      }    }  }  return $options;}/** * Return an array of all vocabulary objects. * * @param $type *   If set, return only those vocabularies associated with this node type. */function taxonomy_get_vocabularies($type = NULL) {  if ($type) {    $result = db_query(db_rewrite_sql("SELECT v.vid, v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s' ORDER BY v.weight, v.name", 'v', 'vid'), $type);  }  else {    $result = db_query(db_rewrite_sql('SELECT v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid ORDER BY v.weight, v.name', 'v', 'vid'));  }  $vocabularies = array();  $node_types = array();  while ($voc = db_fetch_object($result)) {    // If no node types are associated with a vocabulary, the LEFT JOIN will    // return a NULL value for type.    if (isset($voc->type)) {      $node_types[$voc->vid][$voc->type] = $voc->type;      unset($voc->type);      $voc->nodes = $node_types[$voc->vid];    }    elseif (!isset($voc->nodes)) {      $voc->nodes = array();    }    $vocabularies[$voc->vid] = $voc;  }  return $vocabularies;}/** * Implementation of hook_form_alter(). * Generate a form for selecting terms to associate with a node. * We check for taxonomy_override_selector before loading the full * vocabulary, so contrib modules can intercept before hook_form_alter *  and provide scalable alternatives. */function taxonomy_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && (!variable_get('taxonomy_override_selector', FALSE)) && $form['type']['#value'] .'_node_form' == $form_id) {    $node = $form['#node'];    if (!isset($node->taxonomy)) {      $terms = empty($node->nid) ? array() : taxonomy_node_get_terms($node);    }    else {      // After preview the terms must be converted to objects.      if (isset($form_state['node_preview'])) {        $node->taxonomy = taxonomy_preview_terms($node);      }      $terms = $node->taxonomy;    }    $c = db_query(db_rewrite_sql("SELECT v.* FROM {vocabulary} v INNER JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s' ORDER BY v.weight, v.name", 'v', 'vid'), $node->type);    while ($vocabulary = db_fetch_object($c)) {      if ($vocabulary->tags) {        if (isset($form_state['node_preview'])) {          // Typed string can be changed by the user before preview,          // so we just insert the tags directly as provided in the form.          $typed_string = $node->taxonomy['tags'][$vocabulary->vid];        }        else {          $typed_string = taxonomy_implode_tags($terms, $vocabulary->vid) . (array_key_exists('tags', $terms) ? $terms['tags'][$vocabulary->vid] : NULL);        }        if ($vocabulary->help) {          $help = filter_xss_admin($vocabulary->help);        }        else {          $help = t('A comma-separated list of terms describing this content. Example: funny, bungee jumping, "Company, Inc.".');        }        $form['taxonomy']['tags'][$vocabulary->vid] = array('#type' => 'textfield',          '#title' => $vocabulary->name,          '#description' => $help,          '#required' => $vocabulary->required,          '#default_value' => $typed_string,          '#autocomplete_path' => 'taxonomy/autocomplete/'. $vocabulary->vid,          '#weight' => $vocabulary->weight,          '#maxlength' => 1024,        );      }      else {        // Extract terms belonging to the vocabulary in question.        $default_terms = array();        foreach ($terms as $term) {          // Free tagging has no default terms and also no vid after preview.          if (isset($term->vid) && $term->vid == $vocabulary->vid) {            $default_terms[$term->tid] = $term;          }        }        $form['taxonomy'][$vocabulary->vid] = taxonomy_form($vocabulary->vid, array_keys($default_terms), filter_xss_admin($vocabulary->help));        $form['taxonomy'][$vocabulary->vid]['#weight'] = $vocabulary->weight;        $form['taxonomy'][$vocabulary->vid]['#required'] = $vocabulary->required;      }    }    if (!empty($form['taxonomy']) && is_array($form['taxonomy'])) {      if (count($form['taxonomy']) > 1) {        // Add fieldset only if form has more than 1 element.        $form['taxonomy'] += array(          '#type' => 'fieldset',          '#title' => t('Vocabularies'),          '#collapsible' => TRUE,          '#collapsed' => FALSE,        );      }      $form['taxonomy']['#weight'] = -3;      $form['taxonomy']['#tree'] = TRUE;    }  }}/** * Helper function to convert terms after a preview. * * After preview the tags are an array instead of proper objects. This function * converts them back to objects with the exception of 'free tagging' terms, * because new tags can be added by the user before preview and those do not * yet exist in the database. We therefore save those tags as a string so * we can fill the form again after the preview. */function taxonomy_preview_terms($node) {  $taxonomy = array();  if (isset($node->taxonomy)) {    foreach ($node->taxonomy as $key => $term) {      unset($node->taxonomy[$key]);      // A 'Multiple select' and a 'Free tagging' field returns an array.      if (is_array($term)) {        foreach ($term as $tid) {          if ($key == 'tags') {            // Free tagging; the values will be saved for later as strings            // instead of objects to fill the form again.            $taxonomy['tags'] = $term;          }          else {            $taxonomy[$tid] = taxonomy_get_term($tid);          }        }      }      // A 'Single select' field returns the term id.      elseif ($term) {        $taxonomy[$term] = taxonomy_get_term($term);      }    }  }  return $taxonomy;}/** * Find all terms associated with the given node, within one vocabulary. */function taxonomy_node_get_terms_by_vocabulary($node, $vid, $key = 'tid') {  $result = db_query(db_rewrite_sql('SELECT t.tid, t.* FROM {term_data} t INNER JOIN {term_node} r ON r.tid = t.tid WHERE t.vid = %d AND r.vid = %d ORDER BY weight', 't', 'tid'), $vid, $node->vid);  $terms = array();  while ($term = db_fetch_object($result)) {    $terms[$term->$key] = $term;  }  return $terms;}/** * Find all terms associated with the given node, ordered by vocabulary and term weight. */function taxonomy_node_get_terms($node, $key = 'tid') {  static $terms;  if (!isset($terms[$node->vid][$key])) {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_node} r INNER JOIN {term_data} t ON r.tid = t.tid INNER JOIN {vocabulary} v ON t.vid = v.vid WHERE r.vid = %d ORDER BY v.weight, t.weight, t.name', 't', 'tid'), $node->vid);    $terms[$node->vid][$key] = array();    while ($term = db_fetch_object($result)) {      $terms[$node->vid][$key][$term->$key] = $term;    }  }  return $terms[$node->vid][$key];}/** * Make sure incoming vids are free tagging enabled. */function taxonomy_node_validate(&$node) {  if (!empty($node->taxonomy)) {    $terms = $node->taxonomy;    if (!empty($terms['tags'])) {      foreach ($terms['tags'] as $vid => $vid_value) {        $vocabulary = taxonomy_vocabulary_load($vid);        if (empty($vocabulary->tags)) {          // see form_get_error $key = implode('][', $element['#parents']);          // on why this is the key          form_set_error("taxonomy][tags][$vid", t('The %name vocabulary can not be modified in this way.', array('%name' => $vocabulary->name)));        }      }    }  }}/** * Save term associations for a given node. */function taxonomy_node_save($node, $terms) {  taxonomy_node_delete_revision($node);  // Free tagging vocabularies do not send their tids in the form,  // so we'll detect them here and process them independently.  if (isset($terms['tags'])) {    $typed_input = $terms['tags'];    unset($terms['tags']);    foreach ($typed_input as $vid => $vid_value) {      $typed_terms = drupal_explode_tags($vid_value);      $inserted = array();      foreach ($typed_terms as $typed_term) {        // See if the term exists in the chosen vocabulary        // and return the tid; otherwise, add a new record.        $possibilities = taxonomy_get_term_by_name($typed_term);        $typed_term_tid = NULL; // tid match, if any.        foreach ($possibilities as $possibility) {          if ($possibility->vid == $vid) {            $typed_term_tid = $possibility->tid;          }        }        if (!$typed_term_tid) {          $edit = array('vid' => $vid, 'name' => $typed_term);          $status = taxonomy_save_term($edit);          $typed_term_tid = $edit['tid'];        }        // Defend against duplicate, differently cased tags        if (!isset($inserted[$typed_term_tid])) {          db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $typed_term_tid);          $inserted[$typed_term_tid] = TRUE;        }      }    }  }  if (is_array($terms)) {    foreach ($terms as $term) {      if (is_array($term)) {        foreach ($term as $tid) {          if ($tid) {            db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $tid);          }        }      }      else if (is_object($term)) {        db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $term->tid);      }      else if ($term) {        db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $term);      }    }  }}/** * Remove associations of a node to its terms. */function taxonomy_node_delete($node) {  db_query('DELETE FROM {term_node} WHERE nid = %d', $node->nid);}/** * Remove associations of a node to its terms. */function taxonomy_node_delete_revision($node) {  db_query('DELETE FROM {term_node} WHERE vid = %d', $node->vid);}/** * Implementation of hook_node_type(). */function taxonomy_node_type($op, $info) {  if ($op == 'update' && !empty($info->old_type) && $info->type != $info->old_type) {    db_query("UPDATE {vocabulary_node_types} SET type = '%s' WHERE type = '%s'", $info->type, $info->old_type);  }  elseif ($op == 'delete') {    db_query("DELETE FROM {vocabulary_node_types} WHERE type = '%s'", $info->type);  }}/** * Find all term objects related to a given term ID. */function taxonomy_get_related($tid, $key = 'tid') {  if ($tid) {    $result = db_query('SELECT t.*, tid1, tid2 FROM {term_relation}, {term_data} t WHERE (t.tid = tid1 OR t.tid = tid2) AND (tid1 = %d OR tid2 = %d) AND t.tid != %d ORDER BY weight, name', $tid, $tid, $tid);    $related = array();    while ($term = db_fetch_object($result)) {      $related[$term->$key] = $term;    }    return $related;  }  else {    return array();  }}/** * Find all parents of a given term ID. */function taxonomy_get_parents($tid, $key = 'tid') {  if ($tid) {    $result = db_query(db_rewrite_sql('SELECT t.tid, t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.parent = t.tid WHERE h.tid = %d ORDER BY weight, name', 't', 'tid'), $tid);    $parents = array();    while ($parent = db_fetch_object($result)) {      $parents[$parent->$key] = $parent;    }    return $parents;  }  else {    return array();  }}/** * Find all ancestors of a given term ID. */function taxonomy_get_parents_all($tid) {  $parents = array();  if ($tid) {    $parents[] = taxonomy_get_term($tid);    $n = 0;    while ($parent = taxonomy_get_parents($parents[$n]->tid)) {      $parents = array_merge($parents, $parent);      $n++;    }  }  return $parents;}/** * Find all children of a term ID. */function taxonomy_get_children($tid, $vid = 0, $key = 'tid') {  if ($vid) {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.tid = t.tid WHERE t.vid = %d AND h.parent = %d ORDER BY weight, name', 't', 'tid'), $vid, $tid);  }  else {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.tid = t.tid WHERE parent = %d ORDER BY weight, name', 't', 'tid'), $tid);  }  $children = array();  while ($term = db_fetch_object($result)) {    $children[$term->$key] = $term;  }  return $children;}/** * Create a hierarchical representation of a vocabulary. * * @param $vid *   Which vocabulary to generate the tree for. * * @param $parent *   The term ID under which to generate the tree. If 0, generate the tree *   for the entire vocabulary. * * @param $depth *   Internal use only. * * @param $max_depth *   The number of levels of the tree to return. Leave NULL to return all levels. * * @return *   An array of all term objects in the tree. Each term object is extended *   to have "depth" and "parents" attributes in addition to its normal ones. *   Results are statically cached. */function taxonomy_get_tree($vid, $parent = 0, $depth = -1, $max_depth = NULL) {  static $children, $parents, $terms;  $depth++;  // We cache trees, so it's not CPU-intensive to call get_tree() on a term  // and its children, too.  if (!isset($children[$vid])) {    $children[$vid] = array();    $result = db_query(db_rewrite_sql('SELECT t.tid, t.*, parent FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE t.vid = %d ORDER BY weight, name', 't', 'tid'), $vid);    while ($term = db_fetch_object($result)) {      $children[$vid][$term->parent][] = $term->tid;      $parents[$vid][$term->tid][] = $term->parent;      $terms[$vid][$term->tid] = $term;    }  }  $max_depth = (is_null($max_depth)) ? count($children[$vid]) : $max_depth;  $tree = array();  if ($max_depth > $depth && !empty($children[$vid][$parent])) {    foreach ($children[$vid][$parent] as $child) {      $term = drupal_clone($terms[$vid][$child]);      $term->depth = $depth;      // The "parent" attribute is not useful, as it would show one parent only.      unset($term->parent);      $term->parents = $parents[$vid][$child];      $tree[] = $term;      if (!empty($children[$vid][$child])) {        $tree = array_merge($tree, taxonomy_get_tree($vid, $child, $depth, $max_depth));      }    }  }  return $tree;}/** * Return an array of synonyms of the given term ID. */function taxonomy_get_synonyms($tid) {  if ($tid) {    $synonyms = array();    $result = db_query('SELECT name FROM {term_synonym} WHERE tid = %d', $tid);    while ($synonym = db_fetch_array($result)) {      $synonyms[] = $synonym['name'];    }    return $synonyms;  }  else {    return array();  }}/** * Return the term object that has the given string as a synonym. */function taxonomy_get_synonym_root($synonym) {  return db_fetch_object(db_query("SELECT * FROM {term_synonym} s, {term_data} t WHERE t.tid = s.tid AND s.name = '%s'", $synonym));}/** * Count the number of published nodes classified by a term. * * @param $tid *   The term's ID * * @param $type *   The $node->type. If given, taxonomy_term_count_nodes only counts *   nodes of $type that are classified with the term $tid. * * @return int *   An integer representing a number of nodes. *   Results are statically cached. */function taxonomy_term_count_nodes($tid, $type = 0) {  static $count;  if (!isset($count[$type])) {    // $type == 0 always evaluates TRUE if $type is a string    if (is_numeric($type)) {      $result = db_query(db_rewrite_sql('SELECT t.tid, COUNT(n.nid) AS c FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.status = 1 GROUP BY t.tid'));    }    else {      $result = db_query(db_rewrite_sql("SELECT t.tid, COUNT(n.nid) AS c FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.status = 1 AND n.type = '%s' GROUP BY t.tid"), $type);    }    $count[$type] = array();    while ($term = db_fetch_object($result)) {      $count[$type][$term->tid] = $term->c;    }  }  $children_count = 0;  foreach (_taxonomy_term_children($tid) as $c) {    $children_count += taxonomy_term_count_nodes($c, $type);  }  return $children_count + (isset($count[$type][$tid]) ? $count[$type][$tid] : 0);}/** * Helper for taxonomy_term_count_nodes(). Used to find out * which terms are children of a parent term. * * @param $tid *   The parent term's ID * * @return array *   An array of term IDs representing the children of $tid. *   Results are statically cached. * */function _taxonomy_term_children($tid) {  static $children;  if (!isset($children)) {    $result = db_query('SELECT tid, parent FROM {term_hierarchy}');    while ($term = db_fetch_object($result)) {      $children[$term->parent][] = $term->tid;    }  }  return isset($children[$tid]) ? $children[$tid] : array();}/** * Try to map a string to an existing term, as for glossary use. * * Provides a case-insensitive and trimmed mapping, to maximize the * likelihood of a successful match. * * @param name *   Name of the term to search for. * * @return *   An array of matching term objects. */function taxonomy_get_term_by_name($name) {  $db_result = db_query(db_rewrite_sql("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s')", 't', 'tid'), trim($name));  $result = array();  while ($term = db_fetch_object($db_result)) {    $result[] = $term;  }  return $result;}/** * Return the vocabulary object matching a vocabulary ID. * * @param $vid *   The vocabulary's ID * @param $reset *   Whether to reset the internal taxonomy_vocabulary_load cache. * * @return *   The vocabulary object with all of its metadata, if exists, FALSE otherwise. *   Results are statically cached. */function taxonomy_vocabulary_load($vid, $reset = FALSE) {  static $vocabularies = array();  if ($reset) {    $vocabularies = array();  }  if (!isset($vocabularies[$vid])) {    // Initialize so if this vocabulary does not exist, we have    // that cached, and we will not try to load this later.    $vocabularies[$vid] = FALSE;    // Try to load the data and fill up the object.    $result = db_query('SELECT v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE v.vid = %d', $vid);    $node_types = array();    while ($voc = db_fetch_object($result)) {      if (!empty($voc->type)) {        $node_types[$voc->type] = $voc->type;      }      unset($voc->type);      $voc->nodes = $node_types;      $vocabularies[$vid] = $voc;    }  }  // Return FALSE if this vocabulary does not exist.  return !empty($vocabularies[$vid]) ? $vocabularies[$vid] : FALSE;}/** * Return the term object matching a term ID. * * @param $tid *   A term's ID * @param $reset *   Whether to reset the internal taxonomy_get_term cache. * * @return Object *   A term object. Results are statically cached. */function taxonomy_get_term($tid, $reset = FALSE) {  static $terms = array();  if ($reset) {    $terms = array();  }  if (!isset($terms[$tid])) {    $terms[$tid] = db_fetch_object(db_query('SELECT * FROM {term_data} WHERE tid = %d', $tid));  }  return $terms[$tid];}/** * Create a select form element for a given taxonomy vocabulary. * * NOTE: This function expects input that has already been sanitized and is * safe for display. Callers must properly sanitize the $title and * $description arguments to prevent XSS vulnerabilities. * * @param $title *   The title of the vocabulary. This MUST be sanitized by the caller. * @param $name *   Ignored. * @param $value *   The currently selected terms from this vocabulary, if any. * @param $vocabulary_id *   The vocabulary ID to build the form element for. * @param $description *   Help text for the form element. This MUST be sanitized by the caller. * @param $multiple *   Boolean to control if the form should use a single or multiple select. * @param $blank *   Optional form choice to use when no value has been selected. * @param $exclude *   Optional array of term ids to exclude in the selector. * @return *   A FAPI form array to select terms from the given vocabulary. * * @see taxonomy_form() * @see taxonomy_form_term() */function _taxonomy_term_select($title, $name, $value, $vocabulary_id, $description, $multiple, $blank, $exclude = array()) {  $tree = taxonomy_get_tree($vocabulary_id);  $options = array();  if ($blank) {    $options[''] = $blank;  }  if ($tree) {    foreach ($tree as $term) {      if (!in_array($term->tid, $exclude)) {        $choice = new stdClass();        $choice->option = array($term->tid => str_repeat('-', $term->depth) . $term->name);        $options[] = $choice;      }    }  }  return array('#type' => 'select',    '#title' => $title,    '#default_value' => $value,    '#options' => $options,    '#description' => $description,    '#multiple' => $multiple,    '#size' => $multiple ? min(9, count($options)) : 0,    '#weight' => -15,    '#theme' => 'taxonomy_term_select',  );}/** * Format the selection field for choosing terms * (by deafult the default selection field is used). * * @ingroup themeable */function theme_taxonomy_term_select($element) {  return theme('select', $element);}/** * Finds all nodes that match selected taxonomy conditions. * * @param $tids *   An array of term IDs to match. * @param $operator *   How to interpret multiple IDs in the array. Can be "or" or "and". * @param $depth *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative *   integer or "all". * @param $pager *   Whether the nodes are to be used with a pager (the case on most Drupal *   pages) or not (in an XML feed, for example). * @param $order *   The order clause for the query that retrieve the nodes. * @return *   A resource identifier pointing to the query results. */function taxonomy_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC') {  if (count($tids) > 0) {    // For each term ID, generate an array of descendant term IDs to the right depth.    $descendant_tids = array();    if ($depth === 'all') {      $depth = NULL;    }    foreach ($tids as $index => $tid) {      $term = taxonomy_get_term($tid);      $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);      $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));    }    if ($operator == 'or') {      $args = call_user_func_array('array_merge', $descendant_tids);      $placeholders = db_placeholders($args, 'int');      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN ('. $placeholders .') AND n.status = 1 ORDER BY '. $order;      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN ('. $placeholders .') AND n.status = 1';    }    else {      $joins = '';      $wheres = '';      $args = array();      foreach ($descendant_tids as $index => $tids) {        $joins .= ' INNER JOIN {term_node} tn'. $index .' ON n.vid = tn'. $index .'.vid';        $wheres .= ' AND tn'. $index .'.tid IN ('. db_placeholders($tids, 'int') .')';        $args = array_merge($args, $tids);      }      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres .' ORDER BY '. $order;      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres;    }    $sql = db_rewrite_sql($sql);    $sql_count = db_rewrite_sql($sql_count);    if ($pager) {      $result = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);    }    else {      $result = db_query_range($sql, $args, 0, variable_get('feed_default_items', 10));    }  }  return $result;}/** * Accepts the result of a pager_query() call, such as that performed by * taxonomy_select_nodes(), and formats each node along with a pager. */function taxonomy_render_nodes($result) {  $output = '';  $has_rows = FALSE;  while ($node = db_fetch_object($result)) {    $output .= node_view(node_load($node->nid), 1);    $has_rows = TRUE;  }  if ($has_rows) {    $output .= theme('pager', NULL, variable_get('default_nodes_main', 10), 0);  }  else {    $output .= '<p>'. t('There are currently no posts in this category.') .'</p>';  }  return $output;}/** * Implementation of hook_nodeapi(). */function taxonomy_nodeapi($node, $op, $arg = 0) {  switch ($op) {    case 'load':      $output['taxonomy'] = taxonomy_node_get_terms($node);      return $output;    case 'insert':      if (!empty($node->taxonomy)) {        taxonomy_node_save($node, $node->taxonomy);      }      break;    case 'update':      if (!empty($node->taxonomy)) {        taxonomy_node_save($node, $node->taxonomy);      }      break;    case 'delete':      taxonomy_node_delete($node);      break;    case 'delete revision':      taxonomy_node_delete_revision($node);      break;    case 'validate':      taxonomy_node_validate($node);      break;    case 'rss item':      return taxonomy_rss_item($node);    case 'update index':      return taxonomy_node_update_index($node);  }}/** * Implementation of hook_nodeapi('update_index'). */function taxonomy_node_update_index(&$node) {  $output = array();  foreach ($node->taxonomy as $term) {    $output[] = $term->name;  }  if (count($output)) {    return '<strong>('. implode(', ', $output) .')</strong>';  }}/** * Parses a comma or plus separated string of term IDs. * * @param $str_tids *   A string of term IDs, separated by plus or comma. *   comma (,) means AND *   plus (+) means OR * * @return an associative array with an operator key (either 'and' *   or 'or') and a tid key containing an array of the term ids. */function taxonomy_terms_parse_string($str_tids) {  $terms = array('operator' => '', 'tids' => array());  if (preg_match('/^([0-9]+[+ ])+[0-9]+$/', $str_tids)) {    $terms['operator'] = 'or';    // The '+' character in a query string may be parsed as ' '.    $terms['tids'] = preg_split('/[+ ]/', $str_tids);  }  else if (preg_match('/^([0-9]+,)*[0-9]+$/', $str_tids)) {    $terms['operator'] = 'and';    $terms['tids'] = explode(',', $str_tids);  }  return $terms;}/** * Provides category information for RSS feeds. */function taxonomy_rss_item($node) {  $output = array();  foreach ($node->taxonomy as $term) {    $output[] = array('key'   => 'category',                      'value' => $term->name,                      'attributes' => array('domain' => url('taxonomy/term/'. $term->tid, array('absolute' => TRUE))));  }  return $output;}/** * Implementation of hook_help(). */function taxonomy_help($path, $arg) {  switch ($path) {    case 'admin/help#taxonomy':      $output = '<p>'. t('The taxonomy module allows you to categorize content using various systems of classification. Free-tagging vocabularies are created by users on the fly when they submit posts (as commonly found in blogs and social bookmarking applications). Controlled vocabularies allow for administrator-defined short lists of terms as well as complex hierarchies with multiple relationships between different terms. These methods can be applied to different content types and combined together to create a powerful and flexible method of classifying and presenting your content.') .'</p>';      $output .= '<p>'. t('For example, when creating a recipe site, you might want to classify posts by both the type of meal and preparation time. A vocabulary for each allows you to categorize using each criteria independently instead of creating a tag for every possible combination.') .'</p>';      $output .= '<p>'. t('Type of Meal: <em>Appetizer, Main Course, Salad, Dessert</em>') .'</p>';      $output .= '<p>'. t('Preparation Time: <em>0-30mins, 30-60mins, 1-2 hrs, 2hrs+</em>') .'</p>';      $output .= '<p>'. t("Each taxonomy term (often called a 'category' or 'tag' in other systems) automatically provides lists of posts and a corresponding RSS feed. These taxonomy/term URLs can be manipulated to generate AND and OR lists of posts classified with terms. In our recipe site example, it then becomes easy to create pages displaying 'Main courses', '30 minute recipes', or '30 minute main courses and appetizers' by using terms on their own or in combination with others. There are a significant number of contributed modules which you to alter and extend the behavior of the core module for both display and organization of terms.") .'</p>';      $output .= '<p>'. t("Terms can also be organized in parent/child relationships from the admin interface. An example would be a vocabulary grouping countries under their parent geo-political regions. The taxonomy module also enables advanced implementations of hierarchy, for example placing Turkey in both the 'Middle East' and 'Europe'.") .'</p>';      $output .= '<p>'. t('The taxonomy module supports the use of both synonyms and related terms, but does not directly use this functionality. However, optional contributed or custom modules may make full use of these advanced features.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@taxonomy">Taxonomy module</a>.', array('@taxonomy' => 'http://drupal.org/handbook/modules/taxonomy/')) .'</p>';      return $output;    case 'admin/content/taxonomy':      $output = '<p>'. t("The taxonomy module allows you to categorize your content using both tags and administrator defined terms. It is a flexible tool for classifying content with many advanced features. To begin, create a 'Vocabulary' to hold one set of terms or tags. You can create one free-tagging vocabulary for everything, or separate controlled vocabularies to define the various properties of your content, for example 'Countries' or 'Colors'.") .'</p>';      $output .= '<p>'. t('Use the list below to configure and review the vocabularies defined on your site, or to list and manage the terms (tags) they contain. A vocabulary may (optionally) be tied to specific content types as shown in the <em>Type</em> column and, if so, will be displayed when creating or editing posts of that type. Multiple vocabularies tied to the same content type will be displayed in the order shown below. To change the order of a vocabulary, grab a drag-and-drop handle under the <em>Name</em> column and drag it to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save</em> button at the bottom of the page.') .'</p>';      return $output;    case 'admin/content/taxonomy/%':      $vocabulary = taxonomy_vocabulary_load($arg[3]);      if ($vocabulary->tags) {        return '<p>'. t('%capital_name is a free-tagging vocabulary. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name))) .'</p>';      }      switch ($vocabulary->hierarchy) {        case 0:          return '<p>'. t('%capital_name is a flat vocabulary. You may organize the terms in the %name vocabulary by using the handles on the left side of the table. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name)) .'</p>';        case 1:          return '<p>'. t('%capital_name is a single hierarchy vocabulary. You may organize the terms in the %name vocabulary by using the handles on the left side of the table. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name)) .'</p>';        case 2:          return '<p>'. t('%capital_name is a multiple hierarchy vocabulary. To change the name or description of a term, click the <em>edit</em> link next to the term. Drag and drop of multiple hierarchies is not supported, but you can re-enable drag and drop support by editing each term to include only a single parent.', array('%capital_name' => drupal_ucfirst($vocabulary->name))) .'</p>';      }    case 'admin/content/taxonomy/add/vocabulary':      return '<p>'. t('Define how your vocabulary will be presented to administrators and users, and which content types to categorize with it. Tags allows users to create terms when submitting posts by typing a comma separated list. Otherwise terms are chosen from a select list and can only be created by users with the "administer taxonomy" permission.') .'</p>';  }}/** * Helper function for array_map purposes. */function _taxonomy_get_tid_from_term($term) {  return $term->tid;}/** * Implode a list of tags of a certain vocabulary into a string. */function taxonomy_implode_tags($tags, $vid = NULL) {  $typed_tags = array();  foreach ($tags as $tag) {    // Extract terms belonging to the vocabulary in question.    if (is_null($vid) || $tag->vid == $vid) {      // Commas and quotes in tag names are special cases, so encode 'em.      if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {        $tag->name = '"'. str_replace('"', '""', $tag->name) .'"';      }      $typed_tags[] = $tag->name;    }  }  return implode(', ', $typed_tags);}/** * Implementation of hook_hook_info(). */function taxonomy_hook_info() {  return array(    'taxonomy' => array(      'taxonomy' => array(        'insert' => array(          'runs when' => t('After saving a new term to the database'),        ),        'update' => array(          'runs when' => t('After saving an updated term to the database'),        ),        'delete' => array(          'runs when' => t('After deleting a term')        ),      ),    ),  );}
<?php// $Id$/** * Implementation of hook_schema(). */function block_schema() {  $schema['blocks'] = array(    'description' => 'Stores block settings, such as region and visibility settings.',    'fields' => array(      'bid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique block ID.',      ),      'module' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => "The module from which the block originates; for example, 'user' for the Who's Online block, and 'block' for any custom blocks.",      ),      'delta' => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '0',        'description' => 'Unique ID for block within a module.',      ),      'theme' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'The theme under which the block settings apply.',      ),      'status' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Block enabled status. (1 = enabled, 0 = disabled)',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Block weight within region.',      ),      'region' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Theme region within which the block is set.',      ),      'custom' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate how users may control visibility of the block. (0 = Users cannot control, 1 = On by default, but can be hidden, 2 = Hidden by default, but can be shown)',      ),      'throttle' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate whether or not to remove block when website traffic is high. (1 = throttle, 0 = do not throttle)',      ),      'visibility' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate how to show blocks on pages. (0 = Show on all pages except listed pages, 1 = Show only on listed pages, 2 = Use custom PHP code to determine visibility)',      ),      'pages' => array(        'type' => 'text',        'not null' => TRUE,        'description' => 'Contents of the "Pages" block; contains either a list of paths on which to include/exclude the block or PHP code, depending on "visibility" setting.',      ),      'title' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Custom title for the block. (Empty string will use block default title, &lt;none&gt; will remove the title, text will cause block to use specified title.)',      ),      'cache' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 1,        'size' => 'tiny',        'description' => 'Binary flag to indicate block cache mode. (-1: Do not cache, 1: Cache per role, 2: Cache per user, 4: Cache per page, 8: Block cache global) See BLOCK_CACHE_* constants in block.module for more detailed information.',      ),    ),    'primary key' => array('bid'),    'unique keys' => array(      'tmd' => array('theme', 'module', 'delta'),    ),    'indexes' => array(      'list' => array('theme', 'status', 'region', 'weight', 'module'),    ),  );  $schema['blocks_roles'] = array(    'description' => 'Sets up access permissions for blocks based on user roles',    'fields' => array(      'module' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'description' => "The block's origin module, from {blocks}.module.",      ),      'delta'  => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'description' => "The block's unique delta within module, from {blocks}.delta.",      ),      'rid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => "The user's role ID from {users_roles}.rid.",      ),    ),    'primary key' => array(      'module',      'delta',      'rid'    ),    'indexes' => array(      'rid' => array('rid'),    ),  );  $schema['boxes'] = array(    'description' => 'Stores contents of custom-made blocks.',    'fields' => array(      'bid' => array(        'type' => 'serial',  'unsigned' => TRUE,        'not null' => TRUE,        'description' => "The block's {blocks}.bid.",      ),      'body' => array(        'type' => 'text',        'not null' => FALSE,        'size' => 'big',        'description' => 'Block contents.',      ),      'info' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Block description.',      ),      'format' => array(        'type' => 'int',        'size' => 'small',        'not null' => TRUE,        'default' => 0,        'description' => "Block body's {filter_formats}.format; for example, 1 = Filtered HTML.",      )    ),    'unique keys' => array('info' => array('info')),    'primary key' => array('bid'),  );  $schema['cache_block'] = drupal_get_schema_unprocessed('system', 'cache');  $schema['cache_block']['description'] = 'Cache table for the Block module to store already built blocks, identified by module, delta, and various contexts which may change the block, such as theme, locale, and caching mode defined for the block.';  return $schema;}
<?php// $Id$/** * @file node.tpl.php * * Theme implementation to display a node. * * Available variables: * - $title: the (sanitized) title of the node. * - $content: Node body or teaser depending on $teaser flag. * - $picture: The authors picture of the node output from *   theme_user_picture(). * - $date: Formatted creation date (use $created to reformat with *   format_date()). * - $links: Themed links like "Read more", "Add new comment", etc. output *   from theme_links(). * - $name: Themed username of node author output from theme_username(). * - $node_url: Direct url of the current node. * - $terms: the themed list of taxonomy term links output from theme_links(). * - $submitted: themed submission information output from *   theme_node_submitted(). * * Other variables: * - $node: Full node object. Contains data that may not be safe. * - $type: Node type, i.e. story, page, blog, etc. * - $comment_count: Number of comments attached to the node. * - $uid: User ID of the node author. * - $created: Time the node was published formatted in Unix timestamp. * - $zebra: Outputs either "even" or "odd". Useful for zebra striping in *   teaser listings. * - $id: Position of the node. Increments each time it's output. * * Node status variables: * - $teaser: Flag for the teaser state. * - $page: Flag for the full page state. * - $promote: Flag for front page promotion state. * - $sticky: Flags for sticky post setting. * - $status: Flag for published status. * - $comment: State of comment settings for the node. * - $readmore: Flags true if the teaser content of the node cannot hold the *   main body content. * - $is_front: Flags true when presented in the front page. * - $logged_in: Flags true when the current user is a logged-in member. * - $is_admin: Flags true when the current user is an administrator. * * @see template_preprocess() * @see template_preprocess_node() */?><div id="node-<?php print $node->nid; ?>" class="node<?php if ($sticky) { print ' sticky'; } ?><?php if (!$status) { print ' node-unpublished'; } ?> clear-block"><?php print $picture ?><?php if (!$page): ?>  <h2><a href="<?php print $node_url ?>" title="<?php print $title ?>"><?php print $title ?></a></h2><?php endif; ?>  <div class="meta">  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted ?></span>  <?php endif; ?>  <?php if ($terms): ?>    <div class="terms terms-inline"><?php print $terms ?></div>  <?php endif;?>  </div>  <div class="content">    <?php print $content ?>  </div>  <?php print $links; ?></div>
<?php// $Id$/** * @file * Code required only when fetching information about available updates. *//** * Callback to manually check the update status without cron. */function update_manual_status() {  if (_update_refresh()) {    drupal_set_message(t('Attempted to fetch information about all available new releases and updates.'));  }  else {    drupal_set_message(t('Unable to fetch any information about available new releases and updates.'), 'error');  }  drupal_goto('admin/reports/updates');}/** * Fetch project info via XML from a central server. */function _update_refresh() {  static $fail = array();  global $base_url;  module_load_include('inc', 'update', 'update.compare');  // Since we're fetching new available update data, we want to clear  // our cache of both the projects we care about, and the current update  // status of the site. We do *not* want to clear the cache of available  // releases just yet, since that data (even if it's stale) can be useful  // during update_get_projects(); for example, to modules that implement  // hook_system_info_alter() such as cvs_deploy.  _update_cache_clear('update_project_projects');  _update_cache_clear('update_project_data');  $available = array();  $data = array();  $site_key = md5($base_url . drupal_get_private_key());  $projects = update_get_projects();  // Now that we have the list of projects, we should also clear our cache of  // available release data, since even if we fail to fetch new data, we need  // to clear out the stale data at this point.  _update_cache_clear('update_available_releases');  $max_fetch_attempts = variable_get('update_max_fetch_attempts', UPDATE_MAX_FETCH_ATTEMPTS);    foreach ($projects as $key => $project) {    $url = _update_build_fetch_url($project, $site_key);    $fetch_url_base = _update_get_fetch_url_base($project);    if (empty($fail[$fetch_url_base]) || count($fail[$fetch_url_base]) < $max_fetch_attempts) {      $xml = drupal_http_request($url);      if (isset($xml->data)) {        $data[] = $xml->data;      }      else {        // Connection likely broken; prepare to give up.        $fail[$fetch_url_base][$key] = 1;      }    }    else {      // Didn't bother trying to fetch.      $fail[$fetch_url_base][$key] = 1;    }  }  if ($data) {    $parser = new update_xml_parser;    $available = $parser->parse($data);  }  if (!empty($available) && is_array($available)) {    // Record the projects where we failed to fetch data.    foreach ($fail as $fetch_url_base => $failures) {      foreach ($failures as $key => $value) {        $available[$key]['project_status'] = 'not-fetched';      }    }    $frequency = variable_get('update_check_frequency', 1);    _update_cache_set('update_available_releases', $available, time() + (60 * 60 * 24 * $frequency));    watchdog('update', 'Attempted to fetch information about all available new releases and updates.', array(), WATCHDOG_NOTICE, l(t('view'), 'admin/reports/updates'));  }  else {    watchdog('update', 'Unable to fetch any information about available new releases and updates.', array(), WATCHDOG_ERROR, l(t('view'), 'admin/reports/updates'));  }  // Whether this worked or not, we did just (try to) check for updates.  variable_set('update_last_check', time());  return $available;}/** * Generates the URL to fetch information about project updates. * * This figures out the right URL to use, based on the project's .info file * and the global defaults. Appends optional query arguments when the site is * configured to report usage stats. * * @param $project *   The array of project information from update_get_projects(). * @param $site_key *   The anonymous site key hash (optional). * * @see update_refresh() * @see update_get_projects() */function _update_build_fetch_url($project, $site_key = '') {  $name = $project['name'];  $url = _update_get_fetch_url_base($project);  $url .= '/'. $name .'/'. DRUPAL_CORE_COMPATIBILITY;  // Only append a site_key and the version information if we have a site_key  // in the first place, and if this is not a disabled module or theme. We do  // not want to record usage statistics for disabled code.  if (!empty($site_key) && (strpos($project['project_type'], 'disabled') === FALSE)) {    $url .= (strpos($url, '?') === TRUE) ? '&' : '?';    $url .= 'site_key=';    $url .= rawurlencode($site_key);    if (!empty($project['info']['version'])) {      $url .= '&version=';      $url .= rawurlencode($project['info']['version']);    }  }  return $url;}/** * Return the base of the URL to fetch available update data for a project. * * @param $project *   The array of project information from update_get_projects(). * @return *   The base of the URL used for fetching available update data. This does *   not include the path elements to specify a particular project, version, *   site_key, etc. * * @see _update_build_fetch_url() */function _update_get_fetch_url_base($project) {  return isset($project['info']['project status url']) ? $project['info']['project status url'] : variable_get('update_fetch_url', UPDATE_DEFAULT_URL);}/** * Perform any notifications that should be done once cron fetches new data. * * This method checks the status of the site using the new data and depending * on the configuration of the site, notifies administrators via email if there * are new releases or missing security updates. * * @see update_requirements() */function _update_cron_notify() {  include_once './includes/install.inc';  $status = update_requirements('runtime');  $params = array();  $notify_all = (variable_get('update_notification_threshold', 'all') == 'all');  foreach (array('core', 'contrib') as $report_type) {    $type = 'update_'. $report_type;    if (isset($status[$type]['severity'])        && ($status[$type]['severity'] == REQUIREMENT_ERROR || ($notify_all && $status[$type]['reason'] == UPDATE_NOT_CURRENT))) {      $params[$report_type] = $status[$type]['reason'];    }  }  if (!empty($params)) {    $notify_list = variable_get('update_notify_emails', '');    if (!empty($notify_list)) {      $default_language = language_default();      foreach ($notify_list as $target) {        if ($target_user = user_load(array('mail' => $target))) {          $target_language = user_preferred_language($target_user);        }        else {          $target_language = $default_language;        }        drupal_mail('update', 'status_notify', $target, $target_language, $params);      }    }  }}/** * XML Parser object to read Drupal's release history info files. * This uses PHP4's lame XML parsing, but it works. */class update_xml_parser {  var $projects = array();  var $current_project;  var $current_release;  var $current_term;  var $current_tag;  var $current_object;  /**   * Parse an array of XML data files.   */  function parse($data) {    foreach ($data as $datum) {      $parser = xml_parser_create();      xml_set_object($parser, $this);      xml_set_element_handler($parser, 'start', 'end');      xml_set_character_data_handler($parser, "data");      xml_parse($parser, $datum);      xml_parser_free($parser);    }    return $this->projects;  }  function start($parser, $name, $attr) {    $this->current_tag = $name;    switch ($name) {      case 'PROJECT':        unset($this->current_object);        $this->current_project = array();        $this->current_object = &$this->current_project;        break;      case 'RELEASE':        unset($this->current_object);        $this->current_release = array();        $this->current_object = &$this->current_release;        break;      case 'TERM':        unset($this->current_object);        $this->current_term = array();        $this->current_object = &$this->current_term;        break;    }  }  function end($parser, $name) {    switch ($name) {      case 'PROJECT':        unset($this->current_object);        $this->projects[$this->current_project['short_name']] = $this->current_project;        $this->current_project = array();        break;      case 'RELEASE':        unset($this->current_object);        $this->current_project['releases'][$this->current_release['version']] = $this->current_release;        break;      case 'RELEASES':        $this->current_object = &$this->current_project;        break;      case 'TERM':        unset($this->current_object);        $term_name = $this->current_term['name'];        if (!isset($this->current_release['terms'])) {          $this->current_release['terms'] = array();        }        if (!isset($this->current_release['terms'][$term_name])) {          $this->current_release['terms'][$term_name] = array();        }        $this->current_release['terms'][$term_name][] = $this->current_term['value'];        break;      case 'TERMS':        $this->current_object = &$this->current_release;        break;      default:        $this->current_object[strtolower($this->current_tag)] = trim($this->current_object[strtolower($this->current_tag)]);        $this->current_tag = '';    }  }  function data($parser, $data) {    if ($this->current_tag && !in_array($this->current_tag, array('PROJECT', 'RELEASE', 'RELEASES', 'TERM', 'TERMS'))) {      $tag = strtolower($this->current_tag);      if (isset($this->current_object[$tag])) {        $this->current_object[$tag] .= $data;      }      else {        $this->current_object[$tag] = $data;      }    }  }}
<?php// $Id$/** * Implementation of hook_install(). */function statistics_install() {  // Create tables.  drupal_install_schema('statistics');}/** * Changes session ID  field to VARCHAR(64) to add support for SHA-1 hashes. */function statistics_update_1000() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'mysql':    case 'mysqli':      $ret[] = update_sql("ALTER TABLE {accesslog} CHANGE COLUMN sid sid varchar(64) NOT NULL default ''");      break;    case 'pgsql':      db_change_column($ret, 'accesslog', 'sid', 'sid', 'varchar(64)', array('not null' => TRUE, 'default' => "''"));      break;  }  return $ret;}/** * Implementation of hook_uninstall(). */function statistics_uninstall() {  // Remove tables.  drupal_uninstall_schema('statistics');  variable_del('statistics_count_content_views');  variable_del('statistics_enable_access_log');  variable_del('statistics_flush_accesslog_timer');  variable_del('statistics_day_timestamp');  variable_del('statistics_block_top_day_num');  variable_del('statistics_block_top_all_num');  variable_del('statistics_block_top_last_num');}/** * Implementation of hook_schema(). */function statistics_schema() {  $schema['accesslog'] = array(    'description' => 'Stores site access information for statistics.',    'fields' => array(      'aid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique accesslog ID.',      ),      'sid' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Browser session ID of user that visited page.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => 'Title of page visited.',      ),      'path' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => 'Internal path to page visited (relative to Drupal root.)',      ),      'url' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'Referrer URI.',      ),      'hostname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => FALSE,        'description' => 'Hostname of user that visited the page.',      ),      'uid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => FALSE,        'default' => 0,        'description' => 'User {users}.uid that visited the page.',      ),      'timer' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Time in milliseconds that the page took to load.',      ),      'timestamp' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Timestamp of when the page was visited.',      ),    ),    'indexes' => array(      'accesslog_timestamp' => array('timestamp'),      'uid' => array('uid'),    ),    'primary key' => array('aid'),  );  return $schema;}/** * @defgroup updates-6.x-extra Extra statistics updates for 6.x * @{ *//** * Allow longer referrers. */function statistics_update_6000() {  $ret = array();  db_change_field($ret, 'accesslog', 'url', 'url', array('type' => 'text', 'not null' => FALSE));  return $ret;}/** * @} End of "defgroup updates-6.x-extra" * The next series of updates should start at 7000. */
<?php// $Id$/** * @file * Admin page callbacks for the trigger module. *//** * Build the form that allows users to assign actions to hooks. * * @param $type *   Name of hook. * @return *   HTML form. */function trigger_assign($type = NULL) {  // If no type is specified we default to node actions, since they  // are the most common.  if (!isset($type)) {    drupal_goto('admin/build/trigger/node');  }  if ($type == 'node') {    $type = 'nodeapi';  }  $output = '';  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $hook) {    if (isset($hook[$type])) {      foreach ($hook[$type] as $op => $description) {        $form_id = 'trigger_'. $type .'_'. $op .'_assign_form';        $output .= drupal_get_form($form_id, $type, $op, $description['runs when']);      }    }  }  return $output;}/** * Confirm removal of an assigned action. * * @param $hook * @param $op * @param $aid *   The action ID. * @ingroup forms * @see trigger_unassign_submit() */function trigger_unassign($form_state, $hook = NULL, $op = NULL, $aid = NULL) {  if (!($hook && $op && $aid)) {    drupal_goto('admin/build/trigger/assign');  }  $form['hook'] = array(    '#type' => 'value',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'value',    '#value' => $op,  );  $form['aid'] = array(    '#type' => 'value',    '#value' => $aid,  );  $action = actions_function_lookup($aid);  $actions = actions_get_all_actions();  $destination = 'admin/build/trigger/'. ($hook == 'nodeapi' ? 'node' : $hook);  return confirm_form($form,    t('Are you sure you want to unassign the action %title?', array('%title' => $actions[$action]['description'])),    $destination,    t('You can assign it again later if you wish.'),    t('Unassign'), t('Cancel')  );}function trigger_unassign_submit($form, &$form_state) {  $form_values = $form_state['values'];  if ($form_values['confirm'] == 1) {    $aid = actions_function_lookup($form_values['aid']);    db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid);    $actions = actions_get_all_actions();    watchdog('actions', 'Action %action has been unassigned.',  array('%action' => check_plain($actions[$aid]['description'])));    drupal_set_message(t('Action %action has been unassigned.', array('%action' => $actions[$aid]['description'])));    $hook = $form_values['hook'] == 'nodeapi' ? 'node' : $form_values['hook'];    $form_state['redirect'] = 'admin/build/trigger/'. $hook;  }  else {    drupal_goto('admin/build/trigger');  }}/** * Create the form definition for assigning an action to a hook-op combination. * * @param $form_state *   Information about the current form. * @param $hook *   The name of the hook, e.g., 'nodeapi'. * @param $op *   The name of the hook operation, e.g., 'insert'. * @param $description *   A plain English description of what this hook operation does. * @return * * @ingoup forms * @see trigger_assign_form_validate() * @see trigger_assign_form_submit() */function trigger_assign_form($form_state, $hook, $op, $description) {  $form['hook'] = array(    '#type' => 'hidden',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'hidden',    '#value' => $op,  );  // All of these forms use the same validate and submit functions.  $form['#validate'][] = 'trigger_assign_form_validate';  $form['#submit'][] = 'trigger_assign_form_submit';  $options = array();  $functions = array();  // Restrict the options list to actions that declare support for this hook-op  // combination.  foreach (actions_list() as $func => $metadata) {    if (isset($metadata['hooks']['any']) || (isset($metadata['hooks'][$hook]) && is_array($metadata['hooks'][$hook]) && (in_array($op, $metadata['hooks'][$hook])))) {      $functions[] = $func;    }  }  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {    if (in_array($action['callback'], $functions)) {      $options[$action['type']][$aid] = $action['description'];    }  }  $form[$op] = array(    '#type' => 'fieldset',    '#title' => t('Trigger: ') . $description,    '#theme' => 'trigger_display'    );  // Retrieve actions that are already assigned to this hook-op combination.  $actions = _trigger_get_hook_actions($hook, $op);  $form[$op]['assigned']['#type'] = 'value';  $form[$op]['assigned']['#value'] = array();  foreach ($actions as $aid => $description) {    $form[$op]['assigned']['#value'][$aid] = array(      'description' => $description,      'link' => l(t('unassign'), "admin/build/trigger/unassign/$hook/$op/". md5($aid))    );  }  $form[$op]['parent'] = array(    '#prefix' => "<div class='container-inline'>",    '#suffix' => '</div>',  );  // List possible actions that may be assigned.  if (count($options) != 0) {    array_unshift($options, t('Choose an action'));    $form[$op]['parent']['aid'] = array(      '#type' => 'select',      '#options' => $options,    );    $form[$op]['parent']['submit'] = array(      '#type' => 'submit',      '#value' => t('Assign')    );  }  else {    $form[$op]['none'] = array(      '#value' => t('No available actions for this trigger.')    );  }  return $form;}/** * Validation function for trigger_assign_form(). * * Makes sure that the user is not re-assigning an action to an event. */function trigger_assign_form_validate($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    if (db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid))) {      form_set_error($form_values['operation'], t('The action you chose is already assigned to that trigger.'));    }  }}/** * Submit function for trigger_assign_form(). */function trigger_assign_form_submit($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    $weight = db_result(db_query("SELECT MAX(weight) FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s'", $form_values['hook'], $form_values['operation']));    db_query("INSERT INTO {trigger_assignments} values ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], $aid, $weight + 1);    // If this action changes a node property, we need to save the node    // so the change will persist.    $actions = actions_list();    if (isset($actions[$aid]['behavior']) && in_array('changes_node_property', $actions[$aid]['behavior']) && ($form_values['operation'] != 'presave')) {      // Delete previous node_save_action if it exists, and re-add a new one at a higher weight.      $save_post_action_assigned = db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']));      if ($save_post_action_assigned) {        db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']);      }      db_query("INSERT INTO {trigger_assignments} VALUES ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], 'node_save_action', $weight + 2);      if (!$save_post_action_assigned) {        drupal_set_message(t('You have added an action that changes a the property of a post. A Save post action has been added so that the property change will be saved.'));      }    }  }}/** * Display actions assigned to this hook-op combination in a table. * * @param array $element *   The fieldset including all assigned actions. * @return *   The rendered form with the table prepended. * * @ingroup themeable */function theme_trigger_display($element) {  $header = array();  $rows = array();  if (count($element['assigned']['#value'])) {    $header = array(array('data' => t('Name')), array('data' => t('Operation')));    $rows = array();    foreach ($element['assigned']['#value'] as $aid => $info) {      $rows[] = array(        $info['description'],        $info['link']      );    }  }  if (count($rows)) {    $output = theme('table', $header, $rows) . drupal_render($element);  }  else {    $output = drupal_render($element);  }  return $output;}/** * Get the actions that have already been defined for this * type-hook-op combination. * * @param $type *   One of 'node', 'user', 'comment'. * @param $hook *   The name of the hook for which actions have been assigned, *   e.g. 'nodeapi'. * @param $op *   The hook operation for which the actions have been assigned, *   e.g., 'view'. * @return *   An array of action descriptions keyed by action IDs. */function _trigger_get_hook_actions($hook, $op, $type = NULL) {  $actions = array();  if ($type) {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE a.type = '%s' AND h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $type, $hook, $op);  }  else {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $hook, $op);  }  while ($action = db_fetch_object($result)) {    $actions[$action->aid] = $action->description;  }  return $actions;}
<?php// $Id$/** * @file * User page callbacks for the search module. *//** * Menu callback; presents the search form and/or search results. */function search_view($type = 'node') {  // Search form submits with POST but redirects to GET. This way we can keep  // the search query URL clean as a whistle:  // search/type/keyword+keyword  if (!isset($_POST['form_id'])) {    if ($type == '') {      // Note: search/node can not be a default tab because it would take on the      // path of its parent (search). It would prevent remembering keywords when      // switching tabs. This is why we drupal_goto to it from the parent instead.      drupal_goto('search/node');    }    $keys = search_get_keys();    // Only perform search if there is non-whitespace search term:    $results = '';    if (trim($keys)) {      // Log the search keys:      watchdog('search', '%keys (@type).', array('%keys' => $keys, '@type' => module_invoke($type, 'search', 'name')), WATCHDOG_NOTICE, l(t('results'), 'search/'. $type .'/'. $keys));      // Collect the search results:      $results = search_data($keys, $type);      if ($results) {        $results = theme('box', t('Search results'), $results);      }      else {        $results = theme('box', t('Your search yielded no results'), search_help('search#noresults', drupal_help_arg()));      }    }    // Construct the search form.    $output = drupal_get_form('search_form', NULL, $keys, $type);    $output .= $results;    return $output;  }  return drupal_get_form('search_form', NULL, empty($keys) ? '' : $keys, $type);}/** * Process variables for search-results.tpl.php. * * The $variables array contains the following arguments: * - $results * - $type * * @see search-results.tpl.php */function template_preprocess_search_results(&$variables) {  $variables['search_results'] = '';  foreach ($variables['results'] as $result) {    $variables['search_results'] .= theme('search_result', $result, $variables['type']);  }  $variables['pager'] = theme('pager', NULL, 10, 0);  // Provide alternate search results template.  $variables['template_files'][] = 'search-results-'. $variables['type'];}/** * Process variables for search-result.tpl.php. * * The $variables array contains the following arguments: * - $result * - $type * * @see search-result.tpl.php */function template_preprocess_search_result(&$variables) {  $result = $variables['result'];  $variables['url'] = check_url($result['link']);  $variables['title'] = check_plain($result['title']);  $info = array();  if (!empty($result['type'])) {    $info['type'] = check_plain($result['type']);  }  if (!empty($result['user'])) {    $info['user'] = $result['user'];  }  if (!empty($result['date'])) {    $info['date'] = format_date($result['date'], 'small');  }  if (isset($result['extra']) && is_array($result['extra'])) {    $info = array_merge($info, $result['extra']);  }  // Check for existence. User search does not include snippets.  $variables['snippet'] = isset($result['snippet']) ? $result['snippet'] : '';  // Provide separated and grouped meta information..  $variables['info_split'] = $info;  $variables['info'] = implode(' - ', $info);  // Provide alternate search result template.  $variables['template_files'][] = 'search-result-'. $variables['type'];}/** * As the search form collates keys from other modules hooked in via * hook_form_alter, the validation takes place in _submit. * search_form_validate() is used solely to set the 'processed_keys' form * value for the basic search form. */function search_form_validate($form, &$form_state) {  form_set_value($form['basic']['inline']['processed_keys'], trim($form_state['values']['keys']), $form_state);}/** * Process a search form submission. */function search_form_submit($form, &$form_state) {  $keys = $form_state['values']['processed_keys'];  if ($keys == '') {    form_set_error('keys', t('Please enter some keywords.'));    // Fall through to the drupal_goto() call.  }  $type = $form_state['values']['module'] ? $form_state['values']['module'] : 'node';  $form_state['redirect'] = 'search/'. $type .'/'. $keys;  return;}
<?php// $Id$/** * @file * API for loading and interacting with Drupal modules. *//** * Load all the modules that have been enabled in the system table. */function module_load_all() {  foreach (module_list(TRUE, FALSE) as $module) {    drupal_load('module', $module);  }}/** * Call a function repeatedly with each module in turn as an argument. */function module_iterate($function, $argument = '') {  foreach (module_list() as $name) {    $function($name, $argument);  }}/** * Collect a list of all loaded modules. During the bootstrap, return only * vital modules. See bootstrap.inc * * @param $refresh *   Whether to force the module list to be regenerated (such as after the *   administrator has changed the system settings). * @param $bootstrap *   Whether to return the reduced set of modules loaded in "bootstrap mode" *   for cached pages. See bootstrap.inc. * @param $sort *   By default, modules are ordered by weight and filename, settings this option *   to TRUE, module list will be ordered by module name. * @param $fixed_list *   (Optional) Override the module list with the given modules. Stays until the *   next call with $refresh = TRUE. * @return *   An associative array whose keys and values are the names of all loaded *   modules. */function module_list($refresh = FALSE, $bootstrap = TRUE, $sort = FALSE, $fixed_list = NULL) {  static $list, $sorted_list;  if ($refresh || $fixed_list) {    $list = array();    $sorted_list = NULL;    if ($fixed_list) {      foreach ($fixed_list as $name => $module) {        drupal_get_filename('module', $name, $module['filename']);        $list[$name] = $name;      }    }    else {      if ($bootstrap) {        $result = db_query("SELECT name, filename, throttle FROM {system} WHERE type = 'module' AND status = 1 AND bootstrap = 1 ORDER BY weight ASC, filename ASC");      }      else {        $result = db_query("SELECT name, filename, throttle FROM {system} WHERE type = 'module' AND status = 1 ORDER BY weight ASC, filename ASC");      }      while ($module = db_fetch_object($result)) {        if (file_exists($module->filename)) {          // Determine the current throttle status and see if the module should be          // loaded based on server load. We have to directly access the throttle          // variables, since throttle.module may not be loaded yet.          $throttle = ($module->throttle && variable_get('throttle_level', 0) > 0);          if (!$throttle) {            drupal_get_filename('module', $module->name, $module->filename);            $list[$module->name] = $module->name;          }        }      }    }  }  if ($sort) {    if (!isset($sorted_list)) {      $sorted_list = $list;      ksort($sorted_list);    }    return $sorted_list;  }  return $list;}/** * Rebuild the database cache of module files. * * @return *   The array of filesystem objects used to rebuild the cache. */function module_rebuild_cache() {  // Get current list of modules  $files = drupal_system_listing('\.module$', 'modules', 'name', 0);  // Extract current files from database.  system_get_files_database($files, 'module');  ksort($files);  // Set defaults for module info  $defaults = array(    'dependencies' => array(),    'dependents' => array(),    'description' => '',    'version' => NULL,    'php' => DRUPAL_MINIMUM_PHP,  );  foreach ($files as $filename => $file) {    // Look for the info file.    $file->info = drupal_parse_info_file(dirname($file->filename) .'/'. $file->name .'.info');    // Skip modules that don't provide info.    if (empty($file->info)) {      unset($files[$filename]);      continue;    }    // Merge in defaults and save.    $files[$filename]->info = $file->info + $defaults;    // Invoke hook_system_info_alter() to give installed modules a chance to    // modify the data in the .info files if necessary.    drupal_alter('system_info', $files[$filename]->info, $files[$filename]);    // Log the critical hooks implemented by this module.    $bootstrap = 0;    foreach (bootstrap_hooks() as $hook) {      if (module_hook($file->name, $hook)) {        $bootstrap = 1;        break;      }    }    // Update the contents of the system table:    if (isset($file->status) || (isset($file->old_filename) && $file->old_filename != $file->filename)) {      db_query("UPDATE {system} SET info = '%s', name = '%s', filename = '%s', bootstrap = %d WHERE filename = '%s'", serialize($files[$filename]->info), $file->name, $file->filename, $bootstrap, $file->old_filename);    }    else {      // This is a new module.      $files[$filename]->status = 0;      $files[$filename]->throttle = 0;      db_query("INSERT INTO {system} (name, info, type, filename, status, throttle, bootstrap) VALUES ('%s', '%s', '%s', '%s', %d, %d, %d)", $file->name, serialize($files[$filename]->info), 'module', $file->filename, 0, 0, $bootstrap);    }  }  $files = _module_build_dependencies($files);  return $files;}/** * Find dependencies any level deep and fill in dependents information too. * * If module A depends on B which in turn depends on C then this function will * add C to the list of modules A depends on. This will be repeated until * module A has a list of all modules it depends on. If it depends on itself, * called a circular dependency, that's marked by adding a nonexistent module, * called -circular- to this list of modules. Because this does not exist, * it'll be impossible to switch module A on. * * Also we fill in a dependents array in $file->info. Using the names above, * the dependents array of module B lists A. * * @param $files *   The array of filesystem objects used to rebuild the cache. * @return *   The same array with dependencies and dependents added where applicable. */function _module_build_dependencies($files) {  do {    $new_dependency = FALSE;    foreach ($files as $filename => $file) {      // We will modify this object (module A, see doxygen for module A, B, C).      $file = &$files[$filename];      if (isset($file->info['dependencies']) && is_array($file->info['dependencies'])) {        foreach ($file->info['dependencies'] as $dependency_name) {          // This is a nonexistent module.          if ($dependency_name == '-circular-' || !isset($files[$dependency_name])) {            continue;          }          // $dependency_name is module B (again, see doxygen).          $files[$dependency_name]->info['dependents'][$filename] = $filename;          $dependency = $files[$dependency_name];          if (isset($dependency->info['dependencies']) && is_array($dependency->info['dependencies'])) {            // Let's find possible C modules.            foreach ($dependency->info['dependencies'] as $candidate) {              if (array_search($candidate, $file->info['dependencies']) === FALSE) {                // Is this a circular dependency?                if ($candidate == $filename) {                  // As a module name can not contain dashes, this makes                  // impossible to switch on the module.                  $candidate = '-circular-';                  // Do not display the message or add -circular- more than once.                  if (array_search($candidate, $file->info['dependencies']) !== FALSE) {                    continue;                  }                  drupal_set_message(t('%module is part of a circular dependency. This is not supported and you will not be able to switch it on.', array('%module' => $file->info['name'])), 'error');                }                else {                  // We added a new dependency to module A. The next loop will                  // be able to use this as "B module" thus finding even                  // deeper dependencies.                  $new_dependency = TRUE;                }                $file->info['dependencies'][] = $candidate;              }            }          }        }      }      // Don't forget to break the reference.      unset($file);    }  } while ($new_dependency);  return $files;}/** * Determine whether a given module exists. * * @param $module *   The name of the module (without the .module extension). * @return *   TRUE if the module is both installed and enabled. */function module_exists($module) {  $list = module_list();  return array_key_exists($module, $list);}/** * Load a module's installation hooks. */function module_load_install($module) {  // Make sure the installation API is available  include_once './includes/install.inc';  module_load_include('install', $module);}/** * Load a module include file. *  * Examples: * @code *   // Load node.admin.inc from the node module. *   module_load_include('inc', 'node', 'node.admin'); *   // Load content_types.inc from the node module. *   module_load_include('inc', 'node', 'content_types');   * @endcode *  * Do not use this function to load an install file. Use module_load_install() * instead. * * @param $type *   The include file's type (file extension). * @param $module *   The module to which the include file belongs. * @param $name *   Optionally, specify the base file name (without the $type extension).  *   If not set, $module is used. */function module_load_include($type, $module, $name = NULL) {  if (empty($name)) {    $name = $module;  }  $file = './'. drupal_get_path('module', $module) ."/$name.$type";  if (is_file($file)) {    require_once $file;  }  else {    return FALSE;  }}/** * Load an include file for each of the modules that have been enabled in * the system table. */function module_load_all_includes($type, $name = NULL) {  $modules = module_list();  foreach ($modules as $module) {    module_load_include($type, $module, $name);  }}/** * Enable a given list of modules. * * @param $module_list *   An array of module names. */function module_enable($module_list) {  $invoke_modules = array();  foreach ($module_list as $module) {    $existing = db_fetch_object(db_query("SELECT status FROM {system} WHERE type = '%s' AND name = '%s'", 'module', $module));    if ($existing->status == 0) {      module_load_install($module);      db_query("UPDATE {system} SET status = %d, throttle = %d WHERE type = '%s' AND name = '%s'", 1, 0, 'module', $module);      drupal_load('module', $module);      $invoke_modules[] = $module;    }  }  if (!empty($invoke_modules)) {    // Refresh the module list to include the new enabled module.    module_list(TRUE, FALSE);    // Force to regenerate the stored list of hook implementations.    module_implements('', FALSE, TRUE);  }  foreach ($invoke_modules as $module) {    module_invoke($module, 'enable');    // Check if node_access table needs rebuilding.    // We check for the existence of node_access_needs_rebuild() since    // at install time, module_enable() could be called while node.module    // is not enabled yet.    if (function_exists('node_access_needs_rebuild') && !node_access_needs_rebuild() && module_hook($module, 'node_grants')) {      node_access_needs_rebuild(TRUE);    }  }}/** * Disable a given set of modules. * * @param $module_list *   An array of module names. */function module_disable($module_list) {  $invoke_modules = array();  foreach ($module_list as $module) {    if (module_exists($module)) {      // Check if node_access table needs rebuilding.      if (!node_access_needs_rebuild() && module_hook($module, 'node_grants')) {        node_access_needs_rebuild(TRUE);      }      module_load_install($module);      module_invoke($module, 'disable');      db_query("UPDATE {system} SET status = %d, throttle = %d WHERE type = '%s' AND name = '%s'", 0, 0, 'module', $module);      $invoke_modules[] = $module;    }  }  if (!empty($invoke_modules)) {    // Refresh the module list to exclude the disabled modules.    module_list(TRUE, FALSE);    // Force to regenerate the stored list of hook implementations.    module_implements('', FALSE, TRUE);  }  // If there remains no more node_access module, rebuilding will be  // straightforward, we can do it right now.  if (node_access_needs_rebuild() && count(module_implements('node_grants')) == 0) {    node_access_rebuild();  }}/** * @defgroup hooks Hooks * @{ * Allow modules to interact with the Drupal core. * * Drupal's module system is based on the concept of "hooks". A hook is a PHP * function that is named foo_bar(), where "foo" is the name of the module * (whose filename is thus foo.module) and "bar" is the name of the hook. Each * hook has a defined set of parameters and a specified result type. * * To extend Drupal, a module need simply implement a hook. When Drupal wishes * to allow intervention from modules, it determines which modules implement a * hook and calls that hook in all enabled modules that implement it. * * The available hooks to implement are explained here in the Hooks section of * the developer documentation. The string "hook" is used as a placeholder for * the module name in the hook definitions. For example, if the module file is * called example.module, then hook_help() as implemented by that module would * be defined as example_help(). *//** * Determine whether a module implements a hook. * * @param $module *   The name of the module (without the .module extension). * @param $hook *   The name of the hook (e.g. "help" or "menu"). * @return *   TRUE if the module is both installed and enabled, and the hook is *   implemented in that module. */function module_hook($module, $hook) {  return function_exists($module .'_'. $hook);}/** * Determine which modules are implementing a hook. * * @param $hook *   The name of the hook (e.g. "help" or "menu"). * @param $sort *   By default, modules are ordered by weight and filename, settings this option *   to TRUE, module list will be ordered by module name. * @param $refresh *   For internal use only: Whether to force the stored list of hook *   implementations to be regenerated (such as after enabling a new module, *   before processing hook_enable). * @return *   An array with the names of the modules which are implementing this hook. */function module_implements($hook, $sort = FALSE, $refresh = FALSE) {  static $implementations;  if ($refresh) {    $implementations = array();    return;  }  if (!isset($implementations[$hook])) {    $implementations[$hook] = array();    $list = module_list(FALSE, TRUE, $sort);    foreach ($list as $module) {      if (module_hook($module, $hook)) {        $implementations[$hook][] = $module;      }    }  }  // The explicit cast forces a copy to be made. This is needed because  // $implementations[$hook] is only a reference to an element of  // $implementations and if there are nested foreaches (due to nested node  // API calls, for example), they would both manipulate the same array's  // references, which causes some modules' hooks not to be called.  // See also http://www.zend.com/zend/art/ref-count.php.  return (array)$implementations[$hook];}/** * Invoke a hook in a particular module. * * @param $module *   The name of the module (without the .module extension). * @param $hook *   The name of the hook to invoke. * @param ... *   Arguments to pass to the hook implementation. * @return *   The return value of the hook implementation. */function module_invoke() {  $args = func_get_args();  $module = $args[0];  $hook = $args[1];  unset($args[0], $args[1]);  $function = $module .'_'. $hook;  if (module_hook($module, $hook)) {    return call_user_func_array($function, $args);  }}/** * Invoke a hook in all enabled modules that implement it. * * @param $hook *   The name of the hook to invoke. * @param ... *   Arguments to pass to the hook. * @return *   An array of return values of the hook implementations. If modules return *   arrays from their implementations, those are merged into one array. */function module_invoke_all() {  $args = func_get_args();  $hook = $args[0];  unset($args[0]);  $return = array();  foreach (module_implements($hook) as $module) {    $function = $module .'_'. $hook;    $result = call_user_func_array($function, $args);    if (isset($result) && is_array($result)) {      $return = array_merge_recursive($return, $result);    }    else if (isset($result)) {      $return[] = $result;    }  }  return $return;}/** * @} End of "defgroup hooks". *//** * Array of modules required by core. */function drupal_required_modules() {  return array('block', 'filter', 'node', 'system', 'user');}
<?php// $Id$/** * Indicates an error during check for PHP unicode support. */define('UNICODE_ERROR', -1);/** * Indicates that standard PHP (emulated) unicode support is being used. */define('UNICODE_SINGLEBYTE', 0);/** * Indicates that full unicode support with the PHP mbstring extension is being * used. */define('UNICODE_MULTIBYTE', 1);/** * Wrapper around _unicode_check(). */function unicode_check() {  list($GLOBALS['multibyte']) = _unicode_check();}/** * Perform checks about Unicode support in PHP, and set the right settings if * needed. * * Because Drupal needs to be able to handle text in various encodings, we do * not support mbstring function overloading. HTTP input/output conversion must * be disabled for similar reasons. * * @param $errors *   Whether to report any fatal errors with form_set_error(). */function _unicode_check() {  // Ensure translations don't break at install time  $t = get_t();  // Set the standard C locale to ensure consistent, ASCII-only string handling.  setlocale(LC_CTYPE, 'C');  // Check for outdated PCRE library  // Note: we check if U+E2 is in the range U+E0 - U+E1. This test returns TRUE on old PCRE versions.  if (preg_match('/[-]/u', '')) {    return array(UNICODE_ERROR, $t('The PCRE library in your PHP installation is outdated. This will cause problems when handling Unicode text. If you are running PHP 4.3.3 or higher, make sure you are using the PCRE library supplied by PHP. Please refer to the <a href="@url">PHP PCRE documentation</a> for more information.', array('@url' => 'http://www.php.net/pcre')));  }  // Check for mbstring extension  if (!function_exists('mb_strlen')) {    return array(UNICODE_SINGLEBYTE, $t('Operations on Unicode strings are emulated on a best-effort basis. Install the <a href="@url">PHP mbstring extension</a> for improved Unicode support.', array('@url' => 'http://www.php.net/mbstring')));  }  // Check mbstring configuration  if (ini_get('mbstring.func_overload') != 0) {    return array(UNICODE_ERROR, $t('Multibyte string function overloading in PHP is active and must be disabled. Check the php.ini <em>mbstring.func_overload</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.encoding_translation') != 0) {    return array(UNICODE_ERROR, $t('Multibyte string input conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.encoding_translation</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.http_input') != 'pass') {    return array(UNICODE_ERROR, $t('Multibyte string input conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.http_input</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.http_output') != 'pass') {    return array(UNICODE_ERROR, $t('Multibyte string output conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.http_output</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  // Set appropriate configuration  mb_internal_encoding('utf-8');  mb_language('uni');  return array(UNICODE_MULTIBYTE, '');}/** * Return Unicode library status and errors. */function unicode_requirements() {  // Ensure translations don't break at install time  $t = get_t();  $libraries = array(    UNICODE_SINGLEBYTE => $t('Standard PHP'),    UNICODE_MULTIBYTE => $t('PHP Mbstring Extension'),    UNICODE_ERROR => $t('Error'),  );  $severities = array(    UNICODE_SINGLEBYTE => REQUIREMENT_WARNING,    UNICODE_MULTIBYTE => REQUIREMENT_OK,    UNICODE_ERROR => REQUIREMENT_ERROR,  );  list($library, $description) = _unicode_check();  $requirements['unicode'] = array(    'title' => $t('Unicode library'),    'value' => $libraries[$library],  );  if ($description) {    $requirements['unicode']['description'] = $description;  }  $requirements['unicode']['severity'] = $severities[$library];  return $requirements;}/** * Prepare a new XML parser. * * This is a wrapper around xml_parser_create() which extracts the encoding from * the XML data first and sets the output encoding to UTF-8. This function should * be used instead of xml_parser_create(), because PHP 4's XML parser doesn't * check the input encoding itself. "Starting from PHP 5, the input encoding is * automatically detected, so that the encoding parameter specifies only the * output encoding." * * This is also where unsupported encodings will be converted. Callers should * take this into account: $data might have been changed after the call. * * @param &$data *   The XML data which will be parsed later. * @return *   An XML parser object. */function drupal_xml_parser_create(&$data) {  // Default XML encoding is UTF-8  $encoding = 'utf-8';  $bom = FALSE;  // Check for UTF-8 byte order mark (PHP5's XML parser doesn't handle it).  if (!strncmp($data, "\xEF\xBB\xBF", 3)) {    $bom = TRUE;    $data = substr($data, 3);  }  // Check for an encoding declaration in the XML prolog if no BOM was found.  if (!$bom && ereg('^<\?xml[^>]+encoding="([^"]+)"', $data, $match)) {    $encoding = $match[1];  }  // Unsupported encodings are converted here into UTF-8.  $php_supported = array('utf-8', 'iso-8859-1', 'us-ascii');  if (!in_array(strtolower($encoding), $php_supported)) {    $out = drupal_convert_to_utf8($data, $encoding);    if ($out !== FALSE) {      $encoding = 'utf-8';      $data = ereg_replace('^(<\?xml[^>]+encoding)="([^"]+)"', '\\1="utf-8"', $out);    }    else {      watchdog('php', 'Could not convert XML encoding %s to UTF-8.', array('%s' => $encoding), WATCHDOG_WARNING);      return 0;    }  }  $xml_parser = xml_parser_create($encoding);  xml_parser_set_option($xml_parser, XML_OPTION_TARGET_ENCODING, 'utf-8');  return $xml_parser;}/** * Convert data to UTF-8 * * Requires the iconv, GNU recode or mbstring PHP extension. * * @param $data *   The data to be converted. * @param $encoding *   The encoding that the data is in * @return *   Converted data or FALSE. */function drupal_convert_to_utf8($data, $encoding) {  if (function_exists('iconv')) {    $out = @iconv($encoding, 'utf-8', $data);  }  else if (function_exists('mb_convert_encoding')) {    $out = @mb_convert_encoding($data, 'utf-8', $encoding);  }  else if (function_exists('recode_string')) {    $out = @recode_string($encoding .'..utf-8', $data);  }  else {    watchdog('php', 'Unsupported encoding %s. Please install iconv, GNU recode or mbstring for PHP.', array('%s' => $encoding), WATCHDOG_ERROR);    return FALSE;  }  return $out;}/** * Truncate a UTF-8-encoded string safely to a number of bytes. * * If the end position is in the middle of a UTF-8 sequence, it scans backwards * until the beginning of the byte sequence. * * Use this function whenever you want to chop off a string at an unsure * location. On the other hand, if you're sure that you're splitting on a * character boundary (e.g. after using strpos() or similar), you can safely use * substr() instead. * * @param $string *   The string to truncate. * @param $len *   An upper limit on the returned string length. * @return *   The truncated string. */function drupal_truncate_bytes($string, $len) {  if (strlen($string) <= $len) {    return $string;  }  if ((ord($string[$len]) < 0x80) || (ord($string[$len]) >= 0xC0)) {    return substr($string, 0, $len);  }  while (--$len >= 0 && ord($string[$len]) >= 0x80 && ord($string[$len]) < 0xC0) {};  return substr($string, 0, $len);}/** * Truncate a UTF-8-encoded string safely to a number of characters. * * @param $string *   The string to truncate. * @param $len *   An upper limit on the returned string length. * @param $wordsafe *   Flag to truncate at last space within the upper limit. Defaults to FALSE. * @param $dots *   Flag to add trailing dots. Defaults to FALSE. * @return *   The truncated string. */function truncate_utf8($string, $len, $wordsafe = FALSE, $dots = FALSE) {  if (drupal_strlen($string) <= $len) {    return $string;  }  if ($dots) {    $len -= 4;  }  if ($wordsafe) {    $string = drupal_substr($string, 0, $len + 1); // leave one more character    if ($last_space = strrpos($string, ' ')) { // space exists AND is not on position 0      $string = substr($string, 0, $last_space);    }    else {      $string = drupal_substr($string, 0, $len);    }  }  else {    $string = drupal_substr($string, 0, $len);  }  if ($dots) {    $string .= ' ...';  }  return $string;}/** * Encodes MIME/HTTP header values that contain non-ASCII, UTF-8 encoded * characters. * * For example, mime_header_encode('tst.txt') returns "=?UTF-8?B?dMOpc3QudHh0?=". * * See http://www.rfc-editor.org/rfc/rfc2047.txt for more information. * * Notes: * - Only encode strings that contain non-ASCII characters. * - We progressively cut-off a chunk with truncate_utf8(). This is to ensure *   each chunk starts and ends on a character boundary. * - Using \n as the chunk separator may cause problems on some systems and may *   have to be changed to \r\n or \r. */function mime_header_encode($string) {  if (preg_match('/[^\x20-\x7E]/', $string)) {    $chunk_size = 47; // floor((75 - strlen("=?UTF-8?B??=")) * 0.75);    $len = strlen($string);    $output = '';    while ($len > 0) {      $chunk = drupal_truncate_bytes($string, $chunk_size);      $output .= ' =?UTF-8?B?'. base64_encode($chunk) ."?=\n";      $c = strlen($chunk);      $string = substr($string, $c);      $len -= $c;    }    return trim($output);  }  return $string;}/** * Complement to mime_header_encode */function mime_header_decode($header) {  // First step: encoded chunks followed by other encoded chunks (need to collapse whitespace)  $header = preg_replace_callback('/=\?([^?]+)\?(Q|B)\?([^?]+|\?(?!=))\?=\s+(?==\?)/', '_mime_header_decode', $header);  // Second step: remaining chunks (do not collapse whitespace)  return preg_replace_callback('/=\?([^?]+)\?(Q|B)\?([^?]+|\?(?!=))\?=/', '_mime_header_decode', $header);}/** * Helper function to mime_header_decode */function _mime_header_decode($matches) {  // Regexp groups:  // 1: Character set name  // 2: Escaping method (Q or B)  // 3: Encoded data  $data = ($matches[2] == 'B') ? base64_decode($matches[3]) : str_replace('_', ' ', quoted_printable_decode($matches[3]));  if (strtolower($matches[1]) != 'utf-8') {    $data = drupal_convert_to_utf8($data, $matches[1]);  }  return $data;}/** * Decode all HTML entities (including numerical ones) to regular UTF-8 bytes. * Double-escaped entities will only be decoded once ("&amp;lt;" becomes "&lt;", not "<"). * * @param $text *   The text to decode entities in. * @param $exclude *   An array of characters which should not be decoded. For example, *   array('<', '&', '"'). This affects both named and numerical entities. */function decode_entities($text, $exclude = array()) {  static $table;  // We store named entities in a table for quick processing.  if (!isset($table)) {    // Get all named HTML entities.    $table = array_flip(get_html_translation_table(HTML_ENTITIES));    // PHP gives us ISO-8859-1 data, we need UTF-8.    $table = array_map('utf8_encode', $table);    // Add apostrophe (XML)    $table['&apos;'] = "'";  }  $newtable = array_diff($table, $exclude);  // Use a regexp to select all entities in one pass, to avoid decoding double-escaped entities twice.  return preg_replace('/&(#x?)?([A-Za-z0-9]+);/e', '_decode_entities("$1", "$2", "$0", $newtable, $exclude)', $text);}/** * Helper function for decode_entities */function _decode_entities($prefix, $codepoint, $original, &$table, &$exclude) {  // Named entity  if (!$prefix) {    if (isset($table[$original])) {      return $table[$original];    }    else {      return $original;    }  }  // Hexadecimal numerical entity  if ($prefix == '#x') {    $codepoint = base_convert($codepoint, 16, 10);  }  // Decimal numerical entity (strip leading zeros to avoid PHP octal notation)  else {    $codepoint = preg_replace('/^0+/', '', $codepoint);  }  // Encode codepoint as UTF-8 bytes  if ($codepoint < 0x80) {    $str = chr($codepoint);  }  else if ($codepoint < 0x800) {    $str = chr(0xC0 | ($codepoint >> 6))         . chr(0x80 | ($codepoint & 0x3F));  }  else if ($codepoint < 0x10000) {    $str = chr(0xE0 | ( $codepoint >> 12))         . chr(0x80 | (($codepoint >> 6) & 0x3F))         . chr(0x80 | ( $codepoint       & 0x3F));  }  else if ($codepoint < 0x200000) {    $str = chr(0xF0 | ( $codepoint >> 18))         . chr(0x80 | (($codepoint >> 12) & 0x3F))         . chr(0x80 | (($codepoint >> 6)  & 0x3F))         . chr(0x80 | ( $codepoint        & 0x3F));  }  // Check for excluded characters  if (in_array($str, $exclude)) {    return $original;  }  else {    return $str;  }}/** * Count the amount of characters in a UTF-8 string. This is less than or * equal to the byte count. */function drupal_strlen($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strlen($text);  }  else {    // Do not count UTF-8 continuation bytes.    return strlen(preg_replace("/[\x80-\xBF]/", '', $text));  }}/** * Uppercase a UTF-8 string. */function drupal_strtoupper($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strtoupper($text);  }  else {    // Use C-locale for ASCII-only uppercase    $text = strtoupper($text);    // Case flip Latin-1 accented letters    $text = preg_replace_callback('/\xC3[\xA0-\xB6\xB8-\xBE]/', '_unicode_caseflip', $text);    return $text;  }}/** * Lowercase a UTF-8 string. */function drupal_strtolower($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strtolower($text);  }  else {    // Use C-locale for ASCII-only lowercase    $text = strtolower($text);    // Case flip Latin-1 accented letters    $text = preg_replace_callback('/\xC3[\x80-\x96\x98-\x9E]/', '_unicode_caseflip', $text);    return $text;  }}/** * Helper function for case conversion of Latin-1. * Used for flipping U+C0-U+DE to U+E0-U+FD and back. */function _unicode_caseflip($matches) {  return $matches[0][0] . chr(ord($matches[0][1]) ^ 32);}/** * Capitalize the first letter of a UTF-8 string. */function drupal_ucfirst($text) {  // Note: no mbstring equivalent!  return drupal_strtoupper(drupal_substr($text, 0, 1)) . drupal_substr($text, 1);}/** * Cut off a piece of a string based on character indices and counts. Follows * the same behavior as PHP's own substr() function. * * Note that for cutting off a string at a known character/substring * location, the usage of PHP's normal strpos/substr is safe and * much faster. */function drupal_substr($text, $start, $length = NULL) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return $length === NULL ? mb_substr($text, $start) : mb_substr($text, $start, $length);  }  else {    $strlen = strlen($text);    // Find the starting byte offset    $bytes = 0;    if ($start > 0) {      // Count all the continuation bytes from the start until we have found      // $start characters      $bytes = -1; $chars = -1;      while ($bytes < $strlen && $chars < $start) {        $bytes++;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }    }    else if ($start < 0) {      // Count all the continuation bytes from the end until we have found      // abs($start) characters      $start = abs($start);      $bytes = $strlen; $chars = 0;      while ($bytes > 0 && $chars < $start) {        $bytes--;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }    }    $istart = $bytes;    // Find the ending byte offset    if ($length === NULL) {      $bytes = $strlen - 1;    }    else if ($length > 0) {      // Count all the continuation bytes from the starting index until we have      // found $length + 1 characters. Then backtrack one byte.      $bytes = $istart; $chars = 0;      while ($bytes < $strlen && $chars < $length) {        $bytes++;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }      $bytes--;    }    else if ($length < 0) {      // Count all the continuation bytes from the end until we have found      // abs($length) characters      $length = abs($length);      $bytes = $strlen - 1; $chars = 0;      while ($bytes >= 0 && $chars < $length) {        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }        $bytes--;      }    }    $iend = $bytes;    return substr($text, $istart, max(0, $iend - $istart + 1));  }}
<?php// $Id$/** * @file * Admin page callbacks for the book module. *//** * Returns an administrative overview of all books. */function book_admin_overview() {  $rows = array();  foreach (book_get_books() as $book) {    $rows[] = array(l($book['title'], $book['href'], $book['options']), l(t('edit order and titles'), "admin/content/book/". $book['nid']));  }  $headers = array(t('Book'), t('Operations'));  return theme('table', $headers, $rows);}/** * Builds and returns the book settings form. * * @see book_admin_settings_validate() * * @ingroup forms */function book_admin_settings() {  $types = node_get_types('names');  $form['book_allowed_types'] = array(    '#type' => 'checkboxes',    '#title' => t('Allowed book outline types'),    '#default_value' => variable_get('book_allowed_types', array('book')),    '#options' => $types,    '#description' => t('Select content types which users with the %add-perm permission will be allowed to add to the book hierarchy. Users with the %outline-perm permission can add all content types.', array('%add-perm' => t('add content to books'),  '%outline-perm' => t('administer book outlines'))),    '#required' => TRUE,  );  $form['book_child_type'] = array(    '#type' => 'radios',    '#title' => t('Default child page type'),    '#default_value' => variable_get('book_child_type', 'book'),    '#options' => $types,    '#description' => t('The content type for the %add-child link must be one of those selected as an allowed book outline type.', array('%add-child' => t('Add child page'))),    '#required' => TRUE,  );  $form['array_filter'] = array('#type' => 'value', '#value' => TRUE);  $form['#validate'][] = 'book_admin_settings_validate';  return system_settings_form($form);}/** * Validate the book settings form. * * @see book_admin_settings() */function book_admin_settings_validate($form, &$form_state) {  $child_type = $form_state['values']['book_child_type'];  if (empty($form_state['values']['book_allowed_types'][$child_type])) {    form_set_error('book_child_type', t('The content type for the %add-child link must be one of those selected as an allowed book outline type.', array('%add-child' => t('Add child page'))));  }}/** * Build the form to administrate the hierarchy of a single book. * * @see book_admin_edit_submit() * * @ingroup forms. */function book_admin_edit($form_state, $node) {  drupal_set_title(check_plain($node->title));  $form = array();  $form['#node'] = $node;  _book_admin_table($node, $form);  $form['save'] = array(    '#type' => 'submit',    '#value' => t('Save book pages'),  );  return $form;}/** * Check that the book has not been changed while using the form. * * @see book_admin_edit() */function book_admin_edit_validate($form, &$form_state) {  if ($form_state['values']['tree_hash'] != $form_state['values']['tree_current_hash']) {    form_set_error('', t('This book has been modified by another user, the changes could not be saved.'));    $form_state['rebuild'] = TRUE;  }}/** * Handle submission of the book administrative page form. * * This function takes care to save parent menu items before their children. * Saving menu items in the incorrect order can break the menu tree. * * @see book_admin_edit() * @see menu_overview_form_submit() */function book_admin_edit_submit($form, &$form_state) {  // Save elements in the same order as defined in post rather than the form.  // This ensures parents are updated before their children, preventing orphans.  $order = array_flip(array_keys($form['#post']['table']));  $form['table'] = array_merge($order, $form['table']);  foreach (element_children($form['table']) as $key) {    if ($form['table'][$key]['#item']) {      $row = $form['table'][$key];      $values = $form_state['values']['table'][$key];      // Update menu item if moved.      if ($row['plid']['#default_value'] != $values['plid'] || $row['weight']['#default_value'] != $values['weight']) {        $row['#item']['plid'] = $values['plid'];        $row['#item']['weight'] = $values['weight'];        menu_link_save($row['#item']);      }      // Update the title if changed.      if ($row['title']['#default_value'] != $values['title']) {        $node = node_load($values['nid'], FALSE);        $node->title = $values['title'];        $node->book['link_title'] = $values['title'];        $node->revision = 1;        $node->log = t('Title changed from %original to %current.', array('%original' => $node->title, '%current' => $values['title']));        node_save($node);        watchdog('content', 'book: updated %title.', array('%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), 'node/'. $node->nid));      }    }  }  drupal_set_message(t('Updated book %title.', array('%title' => $form['#node']->title)));}/** * Build the table portion of the form for the book administration page. * * @see book_admin_edit() */function _book_admin_table($node, &$form) {  $form['table'] = array(    '#theme' => 'book_admin_table',    '#tree' => TRUE,  );  $tree = book_menu_subtree_data($node->book);  $tree = array_shift($tree); // Do not include the book item itself.  if ($tree['below']) {    $hash = sha1(serialize($tree['below']));    // Store the hash value as a hidden form element so that we can detect    // if another user changed the book hierarchy.    $form['tree_hash'] = array(      '#type' => 'hidden',      '#default_value' => $hash,    );    $form['tree_current_hash'] = array(      '#type' => 'value',      '#value' => $hash,    );    _book_admin_table_tree($tree['below'], $form['table']);  }}/** * Recursive helper to build the main table in the book administration page form. * * @see book_admin_edit() */function _book_admin_table_tree($tree, &$form) {  foreach ($tree as $data) {    $form['book-admin-'. $data['link']['nid']] = array(      '#item' => $data['link'],      'nid' => array('#type' => 'value', '#value' => $data['link']['nid']),      'depth' => array('#type' => 'value', '#value' => $data['link']['depth']),      'href' => array('#type' => 'value', '#value' => $data['link']['href']),      'title' => array(        '#type' => 'textfield',        '#default_value' => $data['link']['link_title'],        '#maxlength' => 255,        '#size' => 40,      ),      'weight' => array(        '#type' => 'weight',        '#default_value' => $data['link']['weight'],        '#delta' => 15,      ),      'plid' => array(        '#type' => 'textfield',        '#default_value' => $data['link']['plid'],        '#size' => 6,      ),      'mlid' => array(        '#type' => 'hidden',        '#default_value' => $data['link']['mlid'],      ),    );    if ($data['below']) {      _book_admin_table_tree($data['below'], $form);    }  }  return $form;}/** * Theme function for the book administration page form. * * @ingroup themeable * @see book_admin_table() */function theme_book_admin_table($form) {  drupal_add_tabledrag('book-outline', 'match', 'parent', 'book-plid', 'book-plid', 'book-mlid', TRUE, MENU_MAX_DEPTH - 2);  drupal_add_tabledrag('book-outline', 'order', 'sibling', 'book-weight');  $header = array(t('Title'), t('Weight'), t('Parent'), array('data' => t('Operations'), 'colspan' => '3'));  $rows = array();  $destination = drupal_get_destination();  $access = user_access('administer nodes');  foreach (element_children($form) as $key) {    $nid = $form[$key]['nid']['#value'];    $href = $form[$key]['href']['#value'];    // Add special classes to be used with tabledrag.js.    $form[$key]['plid']['#attributes']['class'] = 'book-plid';    $form[$key]['mlid']['#attributes']['class'] = 'book-mlid';    $form[$key]['weight']['#attributes']['class'] = 'book-weight';    $data = array(      theme('indentation', $form[$key]['depth']['#value'] - 2) . drupal_render($form[$key]['title']),      drupal_render($form[$key]['weight']),      drupal_render($form[$key]['plid']) . drupal_render($form[$key]['mlid']),      l(t('view'), $href),      $access ? l(t('edit'), 'node/'. $nid .'/edit', array('query' => $destination)) : '&nbsp',      $access ? l(t('delete'), 'node/'. $nid .'/delete', array('query' => $destination) )  : '&nbsp',    );    $row = array('data' => $data);    if (isset($form[$key]['#attributes'])) {      $row = array_merge($row, $form[$key]['#attributes']);    }    $row['class'] = empty($row['class']) ? 'draggable' : $row['class'] .' draggable';    $rows[] = $row;  }  return theme('table', $header, $rows, array('id' => 'book-outline'));}
<?php// $Id$/** * @file *   Manages content translations. * *   Translations are managed in sets of posts, which represent the same *   information in different languages. Only content types for which the *   administrator explicitly enabled translations could have translations *   associated. Translations are managed in sets with exactly one source *   post per set. The source post is used to translate to different *   languages, so if the source post is significantly updated, the *   editor can decide to mark all translations outdated. * *   The node table stores the values used by this module: *    - 'tnid' is the translation set id, which equals the node id *      of the source post. *    - 'translate' is a flag, either indicating that the translation *      is up to date (0) or needs to be updated (1). *//** * Identifies a content type which has translation support enabled. */define('TRANSLATION_ENABLED', 2);/** * Implementation of hook_help(). */function translation_help($path, $arg) {  switch ($path) {    case 'admin/help#translation':      $output = '<p>'. t('The content translation module allows content to be translated into different languages. Working with the <a href="@locale">locale module</a> (which manages enabled languages and provides translation for the site interface), the content translation module is key to creating and maintaining translated site content.', array('@locale' => url('admin/help/locale'))) .'</p>';      $output .= '<p>'. t('Configuring content translation and translation-enabled content types:') .'</p>';      $output .= '<ul><li>'. t('Assign the <em>translate content</em> permission to the appropriate user roles at the <a href="@permissions">Permissions configuration page</a>.', array('@permissions' => url('admin/user/permissions'))) .'</li>';      $output .= '<li>'. t('Add and enable desired languages at the <a href="@languages">Languages configuration page</a>.', array('@languages' => url('admin/settings/language'))) .'</li>';      $output .= '<li>'. t('Determine which <a href="@content-types">content types</a> should support translation features. To enable translation support for a content type, edit the type and at the <em>Multilingual support</em> drop down, select <em>Enabled, with translation</em>. (<em>Multilingual support</em> is located within <em>Workflow settings</em>.) Be sure to save each content type after enabling multilingual support.', array('@content-types' => url('admin/content/types'))) .'</li></ul>';      $output .= '<p>'. t('Working with translation-enabled content types:') .'</p>';      $output .= '<ul><li>'. t('Use the <em>Language</em> drop down to select the appropriate language when creating or editing posts.') .'</li>';      $output .= '<li>'. t('Provide new or edit current translations for existing posts via the <em>Translation</em> tab. Only visible while viewing a post as a user with the <em>translate content</em> permission, this tab allows translations to be added or edited using a specialized editing form that also displays the content being translated.') .'</li>';      $output .= '<li>'. t('Update translations as needed, so that they accurately reflect changes in the content of the original post. The translation status flag provides a simple method for tracking outdated translations. After editing a post, for example, select the <em>Flag translations as outdated</em> check box to mark all of its translations as outdated and in need of revision. Individual translations may be marked for revision by selecting the <em>This translation needs to be updated</em> check box on the translation editing form.') .'</li>';      $output .= '<li>'. t('The <a href="@content-node">Content management administration page</a> displays the language of each post, and also allows filtering by language or translation status.', array('@content-node' => url('admin/content/node'))) .'</li></ul>';      $output .= '<p>'. t('Use the <a href="@blocks">language switcher block</a> provided by locale module to allow users to select a language. If available, both the site interface and site content are presented in the language selected.', array('@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@translation">Translation module</a>.', array('@translation' => 'http://drupal.org/handbook/modules/translation/')) .'</p>';      return $output;    case 'node/%/translate':      $output = '<p>'. t('Translations of a piece of content are managed with translation sets. Each translation set has one source post and any number of translations in any of the <a href="!languages">enabled languages</a>. All translations are tracked to be up to date or outdated based on whether the source post was modified significantly.', array('!languages' => url('admin/settings/language'))) .'</p>';      return $output;  }}/** * Implementation of hook_menu(). */function translation_menu() {  $items = array();  $items['node/%node/translate'] = array(    'title' => 'Translate',    'page callback' => 'translation_node_overview',    'page arguments' => array(1),    'access callback' => '_translation_tab_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'translation.pages.inc',  );  return $items;}/** * Menu access callback. * * Only display translation tab for node types, which have translation enabled * and where the current node is not language neutral (which should span * all languages). */function _translation_tab_access($node) {  return !empty($node->language) && translation_supported_type($node->type) && node_access('view', $node) && user_access('translate content');}/** * Implementation of hook_perm(). */function translation_perm() {  return array('translate content');}/** * Implementation of hook_form_alter(). * * - Add translation option to content type form. * - Alters language fields on node forms when a translation *   is about to be created. */function translation_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'node_type_form') {    // Add translation option to content type form.    $form['workflow']['language_content_type']['#options'][TRANSLATION_ENABLED] = t('Enabled, with translation');    // Description based on text from locale.module.    $form['workflow']['language_content_type']['#description'] = t('Enable multilingual support for this content type. If enabled, a language selection field will be added to the editing form, allowing you to select from one of the <a href="!languages">enabled languages</a>. You can also turn on translation for this content type, which lets you have content translated to any of the enabled languages. If disabled, new posts are saved with the default language. Existing content will not be affected by changing this option.', array('!languages' => url('admin/settings/language')));  }  elseif (isset($form['#id']) && $form['#id'] == 'node-form' && translation_supported_type($form['#node']->type)) {    $node = $form['#node'];    if (!empty($node->translation_source)) {      // We are creating a translation. Add values and lock language field.      $form['translation_source'] = array('#type' => 'value', '#value' => $node->translation_source);      $form['language']['#disabled'] = TRUE;    }    elseif (!empty($node->nid) && !empty($node->tnid)) {      // Disable languages for existing translations, so it is not possible to switch this      // node to some language which is already in the translation set. Also remove the      // language neutral option.      unset($form['language']['#options']['']);      foreach (translation_node_get_translations($node->tnid) as $translation) {        if ($translation->nid != $node->nid) {          unset($form['language']['#options'][$translation->language]);        }      }      // Add translation values and workflow options.      $form['tnid'] = array('#type' => 'value', '#value' => $node->tnid);      $form['translation'] = array(        '#type' => 'fieldset',        '#title' => t('Translation settings'),        '#access' => user_access('translate content'),        '#collapsible' => TRUE,        '#collapsed' => !$node->translate,        '#tree' => TRUE,        '#weight' => 30,      );      if ($node->tnid == $node->nid) {        // This is the source node of the translation        $form['translation']['retranslate'] = array(          '#type' => 'checkbox',          '#title' => t('Flag translations as outdated'),          '#default_value' => 0,          '#description' => t('If you made a significant change, which means translations should be updated, you can flag all translations of this post as outdated. This will not change any other property of those posts, like whether they are published or not.'),        );        $form['translation']['status'] = array('#type' => 'value', '#value' => 0);      }      else {        $form['translation']['status'] = array(          '#type' => 'checkbox',          '#title' => t('This translation needs to be updated'),          '#default_value' => $node->translate,          '#description' => t('When this option is checked, this translation needs to be updated because the source post has changed. Uncheck when the translation is up to date again.'),        );      }    }  }}/** * Implementation of hook_link(). * * Display translation links with native language names, if this node * is part of a translation set. */function translation_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && ($node->tnid) && $translations = translation_node_get_translations($node->tnid)) {    // Do not show link to the same node.    unset($translations[$node->language]);    $languages = language_list();    foreach ($languages as $langcode => $language) {      if (isset($translations[$langcode])) {        $links["node_translation_$langcode"] = array(          'title' => $language->native,          'href' => 'node/'. $translations[$langcode]->nid,          'language' => $language,          'attributes' => array('title' => $translations[$langcode]->title, 'class' => 'translation-link')        );      }    }  }  return $links;}/** * Implementation of hook_nodeapi(). * * Manages translation information for nodes. */function translation_nodeapi(&$node, $op, $teaser, $page) {  // Only act if we are dealing with a content type supporting translations.  if (!translation_supported_type($node->type)) {    return;  }  switch ($op) {    case 'prepare':      if (empty($node->nid) && user_access('translate content') && isset($_GET['translation']) && isset($_GET['language']) && is_numeric($_GET['translation'])) {        $translation_source = node_load($_GET['translation']);        if (empty($translation_source) || !node_access('view', $translation_source)) {          // Source node not found or no access to view. We should not check          // for edit access, since the translator might not have permissions          // to edit the source node but should still be able to translate.          return;        }        $language_list = language_list();        if (!isset($language_list[$_GET['language']]) || ($translation_source->language == $_GET['language'])) {          // If not supported language, or same language as source node, break.          return;        }        // Populate fields based on source node.        $node->language = $_GET['language'];        $node->translation_source = $translation_source;        $node->title = $translation_source->title;        // If user has no access to the filter used for the body, Drupal core        // does not let the edit form to appear, so we should avoid exposing        // the source text here too.        $node->body = filter_access($translation_source->format) ? $translation_source->body : '';        // Let every module add custom translated fields.        node_invoke_nodeapi($node, 'prepare translation');      }      break;    case 'insert':      if (!empty($node->translation_source)) {        if ($node->translation_source->tnid) {          // Add node to existing translation set.          $tnid = $node->translation_source->tnid;        }        else {          // Create new translation set, using nid from the source node.          $tnid = $node->translation_source->nid;          db_query("UPDATE {node} SET tnid = %d, translate = %d WHERE nid = %d", $tnid, 0, $node->translation_source->nid);        }        db_query("UPDATE {node} SET tnid = %d, translate = %d WHERE nid = %d", $tnid, 0, $node->nid);      }      break;    case 'update':      if (isset($node->translation) && $node->translation && !empty($node->language) && $node->tnid) {        // Update translation information.        db_query("UPDATE {node} SET tnid = %d, translate = %d WHERE nid = %d", $node->tnid, $node->translation['status'], $node->nid);        if (!empty($node->translation['retranslate'])) {          // This is the source node, asking to mark all translations outdated.          db_query("UPDATE {node} SET translate = 1 WHERE tnid = %d AND nid != %d", $node->tnid, $node->nid);        }      }      break;    case 'delete':      translation_remove_from_set($node);      break;  }}/** * Remove a node from its translation set (if any) * and update the set accordingly. */function translation_remove_from_set($node) {  if (isset($node->tnid)) {    if (db_result(db_query('SELECT COUNT(*) FROM {node} WHERE tnid = %d', $node->tnid)) == 1) {      // There is only one node left in the set: remove the set altogether.      db_query('UPDATE {node} SET tnid = 0, translate = 0 WHERE tnid = %d', $node->tnid);    }    else {      db_query('UPDATE {node} SET tnid = 0, translate = 0 WHERE nid = %d', $node->nid);      // If the node being removed was the source of the translation set,      // we pick a new source - preferably one that is up to date.      if ($node->tnid == $node->nid) {        $new_tnid = db_result(db_query('SELECT nid FROM {node} WHERE tnid = %d ORDER BY translate ASC, nid ASC', $node->tnid));        db_query('UPDATE {node} SET tnid = %d WHERE tnid = %d', $new_tnid, $node->tnid);      }    }  }}/** * Get all nodes in a translation set, represented by $tnid. * * @param $tnid *   The translation source nid of the translation set, the identifier *   of the node used to derive all translations in the set. * @return *   Array of partial node objects (nid, title, language) representing *   all nodes in the translation set, in effect all translations *   of node $tnid, including node $tnid itself. Because these are *   partial nodes, you need to node_load() the full node, if you *   need more properties. The array is indexed by language code. */function translation_node_get_translations($tnid) {  static $translations = array();  if (is_numeric($tnid) && $tnid) {    if (!isset($translations[$tnid])) {      $translations[$tnid] = array();      $result = db_query(db_rewrite_sql('SELECT n.nid, n.title, n.language FROM {node} n WHERE n.tnid = %d'), $tnid);      while ($node = db_fetch_object($result)) {        $translations[$tnid][$node->language] = $node;      }    }    return $translations[$tnid];  }}/** * Returns whether the given content type has support for translations. * * @return *   Boolean value. */function translation_supported_type($type) {  return variable_get('language_content_type_'. $type, 0) == TRANSLATION_ENABLED;}/** * Return paths of all translations of a node, based on * its Drupal path. * * @param $path *   A Drupal path, for example node/432. * @return *   An array of paths of translations of the node accessible *   to the current user keyed with language codes. */function translation_path_get_translations($path) {  $paths = array();  // Check for a node related path, and for its translations.  if ((preg_match("!^node/([0-9]+)(/.+|)$!", $path, $matches)) && ($node = node_load((int)$matches[1])) && !empty($node->tnid)) {    foreach (translation_node_get_translations($node->tnid) as $language => $translation_node) {      $paths[$language] = 'node/'. $translation_node->nid . $matches[2];    }  }  return $paths;}/** * Implementation of hook_translation_link_alter(). * * Replaces links with pointers to translated versions of the content. */function translation_translation_link_alter(&$links, $path) {  if ($paths = translation_path_get_translations($path)) {    foreach ($links as $langcode => $link) {      if (isset($paths[$langcode])) {        // Translation in a different node.        $links[$langcode]['href'] = $paths[$langcode];      }      else {        // No translation in this language, or no permission to view.        unset($links[$langcode]);      }    }  }}
<?php// $Id$/** * @file * System monitoring and logging for administrators. * * The dblog module monitors your site and keeps a list of * recorded events containing usage and performance data, errors, * warnings, and similar operational information. * * @see watchdog() *//** * Implementation of hook_help(). */function dblog_help($path, $arg) {  switch ($path) {    case 'admin/help#dblog':      $output = '<p>'. t('The dblog module monitors your system, capturing system events in a log to be reviewed by an authorized individual at a later time. This is useful for site administrators who want a quick overview of activities on their site. The logs also record the sequence of events, so it can be useful for debugging site errors.') .'</p>';      $output .= '<p>'. t('The dblog log is simply a list of recorded events containing usage data, performance data, errors, warnings and operational information. Administrators should check the dblog report on a regular basis to ensure their site is working properly.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@dblog">Dblog module</a>.', array('@dblog' => 'http://drupal.org/handbook/modules/dblog/')) .'</p>';      return $output;    case 'admin/reports/dblog':      return '<p>'. t('The dblog module monitors your website, capturing system events in a log to be reviewed by an authorized individual at a later time. The dblog log is simply a list of recorded events containing usage data, performance data, errors, warnings and operational information. It is vital to check the dblog report on a regular basis as it is often the only way to tell what is going on.') .'</p>';  }}/** * Implementation of hook_theme() */function dblog_theme() {  return array(    'dblog_filters' => array(      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_menu(). */function dblog_menu() {  $items['admin/settings/logging/dblog'] = array(    'title' => 'Database logging',    'description' => 'Settings for logging to the Drupal database logs. This is the most common method for small to medium sites on shared hosting. The logs are viewable from the admin pages.',    'page callback' => 'drupal_get_form',    'page arguments' => array('dblog_admin_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'dblog.admin.inc',  );  $items['admin/reports/dblog'] = array(    'title' => 'Recent log entries',    'description' => 'View events that have recently been logged.',    'page callback' => 'dblog_overview',    'access arguments' => array('access site reports'),    'weight' => -1,    'file' => 'dblog.admin.inc',  );  $items['admin/reports/page-not-found'] = array(    'title' => "Top 'page not found' errors",    'description' => "View 'page not found' errors (404s).",    'page callback' => 'dblog_top',    'page arguments' => array('page not found'),    'access arguments' => array('access site reports'),    'file' => 'dblog.admin.inc',  );  $items['admin/reports/access-denied'] = array(    'title' => "Top 'access denied' errors",    'description' => "View 'access denied' errors (403s).",    'page callback' => 'dblog_top',    'page arguments' => array('access denied'),    'access arguments' => array('access site reports'),    'file' => 'dblog.admin.inc',  );  $items['admin/reports/event/%'] = array(    'title' => 'Details',    'page callback' => 'dblog_event',    'page arguments' => array(3),    'access arguments' => array('access site reports'),    'type' => MENU_CALLBACK,    'file' => 'dblog.admin.inc',  );  return $items;}function dblog_init() {  if (arg(0) == 'admin' && arg(1) == 'reports') {    // Add the CSS for this module    drupal_add_css(drupal_get_path('module', 'dblog') .'/dblog.css', 'module', 'all', FALSE);  }}/** * Implementation of hook_cron(). * * Remove expired log messages and flood control events. */function dblog_cron() {  // Cleanup the watchdog table  $max = db_result(db_query('SELECT MAX(wid) FROM {watchdog}'));  db_query('DELETE FROM {watchdog} WHERE wid <= %d', $max - variable_get('dblog_row_limit', 1000));}/** * Implementation of hook_user(). */function dblog_user($op, &$edit, &$user) {  if ($op == 'delete') {    db_query('UPDATE {watchdog} SET uid = 0 WHERE uid = %d', $user->uid);  }}function _dblog_get_message_types() {  $types = array();  $result = db_query('SELECT DISTINCT(type) FROM {watchdog} ORDER BY type');  while ($object = db_fetch_object($result)) {    $types[] = $object->type;  }  return $types;}/** * Implementation of hook_watchdog(). */function dblog_watchdog($log = array()) {  $current_db = db_set_active();  db_query("INSERT INTO {watchdog}    (uid, type, message, variables, severity, link, location, referer, hostname, timestamp)    VALUES    (%d, '%s', '%s', '%s', %d, '%s', '%s', '%s', '%s', %d)",    $log['user']->uid,    $log['type'],    $log['message'],    serialize($log['variables']),    $log['severity'],    $log['link'],    $log['request_uri'],    $log['referer'],    $log['ip'],    $log['timestamp']);  if ($current_db) {    db_set_active($current_db);  }}/** * Theme dblog administration filter selector. * * @ingroup themeable */function theme_dblog_filters($form) {  $output = '';  foreach (element_children($form['status']) as $key) {    $output .= drupal_render($form['status'][$key]);  }  $output .= '<div id="dblog-admin-buttons">'. drupal_render($form['buttons']) .'</div>';  return $output;}
<?php// $Id$/** * @file * Code required only when rendering the available updates report. *//** * Menu callback. Generate a page about the update status of projects. */function update_status() {  if ($available = update_get_available(TRUE)) {    module_load_include('inc', 'update', 'update.compare');    $data = update_calculate_project_data($available);    return theme('update_report', $data);  }  else {    return theme('update_report', _update_no_data());  }}/** * Theme project status report. * * @ingroup themeable */function theme_update_report($data) {  $last = variable_get('update_last_check', 0);  $output = '<div class="update checked">'. ($last ? t('Last checked: @time ago', array('@time' => format_interval(time() - $last))) : t('Last checked: never'));  $output .= ' <span class="check-manually">('. l(t('Check manually'), 'admin/reports/updates/check') .')</span>';  $output .= "</div>\n";  if (!is_array($data)) {    $output .= '<p>'. $data .'</p>';    return $output;  }  $header = array();  $rows = array();  $notification_level = variable_get('update_notification_threshold', 'all');  foreach ($data as $project) {    switch ($project['status']) {      case UPDATE_CURRENT:        $class = 'ok';        $icon = theme('image', 'misc/watchdog-ok.png', t('ok'), t('ok'));        break;      case UPDATE_UNKNOWN:      case UPDATE_NOT_FETCHED:        $class = 'unknown';        $icon = theme('image', 'misc/watchdog-warning.png', t('warning'), t('warning'));        break;      case UPDATE_NOT_SECURE:      case UPDATE_REVOKED:      case UPDATE_NOT_SUPPORTED:        $class = 'error';        $icon = theme('image', 'misc/watchdog-error.png', t('error'), t('error'));        break;      case UPDATE_NOT_CHECKED:      case UPDATE_NOT_CURRENT:      default:        $class = 'warning';        $icon = theme('image', 'misc/watchdog-warning.png', t('warning'), t('warning'));        break;    }    $row = '<div class="version-status">';    switch ($project['status']) {      case UPDATE_NOT_SECURE:        $row .= '<span class="security-error">'. t('Security update required!') .'</span>';        break;      case UPDATE_REVOKED:        $row .= '<span class="revoked">'. t('Revoked!') .'</span>';        break;      case UPDATE_NOT_SUPPORTED:        $row .= '<span class="not-supported">'. t('Not supported!') .'</span>';        break;      case UPDATE_NOT_CURRENT:        $row .= '<span class="not-current">'. t('Update available') .'</span>';        break;      case UPDATE_CURRENT:        $row .= '<span class="current">'. t('Up to date') .'</span>';        break;      default:        $row .= check_plain($project['reason']);        break;    }    $row .= '<span class="icon">'. $icon .'</span>';    $row .= "</div>\n";    $row .= '<div class="project">';    if (isset($project['title'])) {      if (isset($project['link'])) {        $row .= l($project['title'], $project['link']);      }      else {        $row .= check_plain($project['title']);      }    }    else {      $row .= check_plain($project['name']);    }    $row .= ' '. check_plain($project['existing_version']);    if ($project['install_type'] == 'dev' && !empty($project['datestamp'])) {      $row .= ' <span class="version-date">('. format_date($project['datestamp'], 'custom', 'Y-M-d') .')</span>';    }    $row .= "</div>\n";    $row .= "<div class=\"versions\">\n";    if (isset($project['recommended'])) {      if ($project['status'] != UPDATE_CURRENT || $project['existing_version'] !== $project['recommended']) {        // First, figure out what to recommend.        // If there's only 1 security update and it has the same version we're        // recommending, give it the same CSS class as if it was recommended,        // but don't print out a separate "Recommended" line for this project.        if (!empty($project['security updates']) && count($project['security updates']) == 1 && $project['security updates'][0]['version'] === $project['recommended']) {          $security_class = ' version-recommended version-recommended-strong';        }        else {          $security_class = '';          $version_class = 'version-recommended';          // Apply an extra class if we're displaying both a recommended          // version and anything else for an extra visual hint.          if ($project['recommended'] !== $project['latest_version']              || !empty($project['also'])              || ($project['install_type'] == 'dev'                 && isset($project['dev_version'])                 && $project['latest_version'] !== $project['dev_version']                 && $project['recommended'] !== $project['dev_version'])              || (isset($project['security updates'][0])                 && $project['recommended'] !== $project['security updates'][0])              ) {            $version_class .= ' version-recommended-strong';          }          $row .= theme('update_version', $project['releases'][$project['recommended']], t('Recommended version:'), $version_class);        }        // Now, print any security updates.        if (!empty($project['security updates'])) {          foreach ($project['security updates'] as $security_update) {            $row .= theme('update_version', $security_update, t('Security update:'), 'version-security'. $security_class);          }        }      }      if ($project['recommended'] !== $project['latest_version']) {        $row .= theme('update_version', $project['releases'][$project['latest_version']], t('Latest version:'), 'version-latest');      }      if ($project['install_type'] == 'dev'          && $project['status'] != UPDATE_CURRENT          && isset($project['dev_version'])          && $project['recommended'] !== $project['dev_version']) {        $row .= theme('update_version', $project['releases'][$project['dev_version']], t('Development version:'), 'version-latest');      }    }    if (isset($project['also'])) {      foreach ($project['also'] as $also) {        $row .= theme('update_version', $project['releases'][$also], t('Also available:'), 'version-also-available');      }    }    $row .= "</div>\n"; // versions div.    $row .= "<div class=\"info\">\n";    if (!empty($project['extra'])) {      $row .= '<div class="extra">'."\n";      foreach ($project['extra'] as $key => $value) {        $row .= '<div class="'. $value['class'] .'">';        $row .= check_plain($value['label']) .': ';        $row .= theme('placeholder', $value['data']);        $row .= "</div>\n";      }      $row .= "</div>\n";  // extra div.    }    $row .= '<div class="includes">';    sort($project['includes']);    $row .= t('Includes: %includes', array('%includes' => implode(', ', $project['includes'])));    $row .= "</div>\n";    if (!empty($project['base_themes'])) {      $row .= '<div class="basethemes">';      sort($project['base_themes']);      // We use !dependencies and manually call theme('placeholder') here to      // avoid breakding the D6 string freeze. This identical string is      // already in modules/system/system.admin.inc.      $row .= t('Depends on: !dependencies', array('!dependencies' => theme('placeholder', implode(', ', $project['base_themes']))));      $row .= "</div>\n";    }    if (!empty($project['sub_themes'])) {      $row .= '<div class="subthemes">';      sort($project['sub_themes']);      // We use !required and manually call theme('placeholder') here to avoid      // breakding the D6 string freeze. This identical string is already in      // modules/system/system.admin.inc.      $row .= t('Required by: !required', array('!required' => theme('placeholder', implode(', ', $project['sub_themes']))));      $row .= "</div>\n";    }    $row .= "</div>\n"; // info div.    if (!isset($rows[$project['project_type']])) {      $rows[$project['project_type']] = array();    }    $row_key = isset($project['title']) ? drupal_strtolower($project['title']) : drupal_strtolower($project['name']);    $rows[$project['project_type']][$row_key] = array(      'class' => $class,      'data' => array($row),    );  }  $project_types = array(    'core' => t('Drupal core'),    'module' => t('Modules'),    'theme' => t('Themes'),    'disabled-module' => t('Disabled modules'),    'disabled-theme' => t('Disabled themes'),  );  foreach ($project_types as $type_name => $type_label) {    if (!empty($rows[$type_name])) {      ksort($rows[$type_name]);      $output .= "\n<h3>". $type_label ."</h3>\n";      $output .= theme('table', $header, $rows[$type_name], array('class' => 'update'));    }  }  drupal_add_css(drupal_get_path('module', 'update') .'/update.css');  return $output;}/** * Theme the version display of a project. * * @ingroup themeable */function theme_update_version($version, $tag, $class) {  $output = '';  $output .= '<table class="version '. $class .'">';  $output .= '<tr>';  $output .= '<td class="version-title">'. $tag ."</td>\n";  $output .= '<td class="version-details">';  $output .= l($version['version'], $version['release_link']);  $output .= ' <span class="version-date">('. format_date($version['date'], 'custom', 'Y-M-d') .')</span>';  $output .= "</td>\n";  $output .= '<td class="version-links">';  $links = array();  $links['update-download'] = array(    'title' => t('Download'),    'href' => $version['download_link'],  );  $links['update-release-notes'] = array(    'title' => t('Release notes'),    'href' => $version['release_link'],  );  $output .= theme('links', $links);  $output .= '</td>';  $output .= '</tr>';  $output .= "</table>\n";  return $output;}
<?php// $Id$/** * @file * Functions to handle paths in Drupal, including path aliasing. * * These functions are not loaded for cached pages, but modules that need * to use them in hook_init() or hook exit() can make them available, by * executing "drupal_bootstrap(DRUPAL_BOOTSTRAP_PATH);". *//** * Initialize the $_GET['q'] variable to the proper normal path. */function drupal_init_path() {  if (!empty($_GET['q'])) {    $_GET['q'] = drupal_get_normal_path(trim($_GET['q'], '/'));  }  else {    $_GET['q'] = drupal_get_normal_path(variable_get('site_frontpage', 'node'));  }}/** * Given an alias, return its Drupal system URL if one exists. Given a Drupal * system URL return one of its aliases if such a one exists. Otherwise, * return FALSE. * * @param $action *   One of the following values: *   - wipe: delete the alias cache. *   - alias: return an alias for a given Drupal system path (if one exists). *   - source: return the Drupal system URL for a path alias (if one exists). * @param $path *   The path to investigate for corresponding aliases or system URLs. * @param $path_language *   Optional language code to search the path with. Defaults to the page language. *   If there's no path defined for that language it will search paths without *   language. * * @return *   Either a Drupal system path, an aliased path, or FALSE if no path was *   found. */function drupal_lookup_path($action, $path = '', $path_language = '') {  global $language;  // $map is an array with language keys, holding arrays of Drupal paths to alias relations  static $map = array(), $no_src = array(), $count;  $path_language = $path_language ? $path_language : $language->language;  // Use $count to avoid looking up paths in subsequent calls if there simply are no aliases  if (!isset($count)) {    $count = db_result(db_query('SELECT COUNT(pid) FROM {url_alias}'));  }  if ($action == 'wipe') {    $map = array();    $no_src = array();    $count = NULL;  }  elseif ($count > 0 && $path != '') {    if ($action == 'alias') {      if (isset($map[$path_language][$path])) {        return $map[$path_language][$path];      }      // Get the most fitting result falling back with alias without language      $alias = db_result(db_query("SELECT dst FROM {url_alias} WHERE src = '%s' AND language IN('%s', '') ORDER BY language DESC, pid DESC", $path, $path_language));      $map[$path_language][$path] = $alias;      return $alias;    }    // Check $no_src for this $path in case we've already determined that there    // isn't a path that has this alias    elseif ($action == 'source' && !isset($no_src[$path_language][$path])) {      // Look for the value $path within the cached $map      $src = '';      if (!isset($map[$path_language]) || !($src = array_search($path, $map[$path_language]))) {        // Get the most fitting result falling back with alias without language        if ($src = db_result(db_query("SELECT src FROM {url_alias} WHERE dst = '%s' AND language IN('%s', '') ORDER BY language DESC, pid DESC", $path, $path_language))) {          $map[$path_language][$src] = $path;        }        else {          // We can't record anything into $map because we do not have a valid          // index and there is no need because we have not learned anything          // about any Drupal path. Thus cache to $no_src.          $no_src[$path_language][$path] = TRUE;        }      }      return $src;    }  }  return FALSE;}/** * Given an internal Drupal path, return the alias set by the administrator. * * @param $path *   An internal Drupal path. * @param $path_language *   An optional language code to look up the path in. * * @return *   An aliased path if one was found, or the original path if no alias was *   found. */function drupal_get_path_alias($path, $path_language = '') {  $result = $path;  if ($alias = drupal_lookup_path('alias', $path, $path_language)) {    $result = $alias;  }  return $result;}/** * Given a path alias, return the internal path it represents. * * @param $path *   A Drupal path alias. * @param $path_language *   An optional language code to look up the path in. * * @return *   The internal path represented by the alias, or the original alias if no *   internal path was found. */function drupal_get_normal_path($path, $path_language = '') {  $result = $path;  if ($src = drupal_lookup_path('source', $path, $path_language)) {    $result = $src;  }  if (function_exists('custom_url_rewrite_inbound')) {    // Modules may alter the inbound request path by reference.    custom_url_rewrite_inbound($result, $path, $path_language);  }  return $result;}/** * Return a component of the current Drupal path. * * When viewing a page at the path "admin/content/types", for example, arg(0) * would return "admin", arg(1) would return "content", and arg(2) would return * "types". * * Avoid use of this function where possible, as resulting code is hard to read. * Instead, attempt to use named arguments in menu callback functions. See the * explanation in menu.inc for how to construct callbacks that take arguments. * * @param $index *   The index of the component, where each component is separated by a '/' *   (forward-slash), and where the first component has an index of 0 (zero). * * @return *   The component specified by $index, or NULL if the specified component was *   not found. */function arg($index = NULL, $path = NULL) {  static $arguments;  if (!isset($path)) {    $path = $_GET['q'];  }  if (!isset($arguments[$path])) {    $arguments[$path] = explode('/', $path);  }  if (!isset($index)) {    return $arguments[$path];  }  if (isset($arguments[$path][$index])) {    return $arguments[$path][$index];  }}/** * Get the title of the current page, for display on the page and in the title bar. * * @return *   The current page's title. */function drupal_get_title() {  $title = drupal_set_title();  // during a bootstrap, menu.inc is not included and thus we cannot provide a title  if (!isset($title) && function_exists('menu_get_active_title')) {    $title = check_plain(menu_get_active_title());  }  return $title;}/** * Set the title of the current page, for display on the page and in the title bar. * * @param $title *   Optional string value to assign to the page title; or if set to NULL *   (default), leaves the current title unchanged. * * @return *   The updated title of the current page. */function drupal_set_title($title = NULL) {  static $stored_title;  if (isset($title)) {    $stored_title = $title;  }  return $stored_title;}/** * Check if the current page is the front page. * * @return *   Boolean value: TRUE if the current page is the front page; FALSE if otherwise. */function drupal_is_front_page() {  // As drupal_init_path updates $_GET['q'] with the 'site_frontpage' path,  // we can check it against the 'site_frontpage' variable.  return $_GET['q'] == drupal_get_normal_path(variable_get('site_frontpage', 'node'));}/** * Check if a path matches any pattern in a set of patterns. * * @param $path *   The path to match. * @param $patterns *   String containing a set of patterns separated by \n, \r or \r\n. * * @return *   1 if there is a match, 0 if there is not a match. */function drupal_match_path($path, $patterns) {  static $regexps;  if (!isset($regexps[$patterns])) {    $regexps[$patterns] = '/^('. preg_replace(array('/(\r\n?|\n)/', '/\\\\\*/', '/(^|\|)\\\\<front\\\\>($|\|)/'), array('|', '.*', '\1'. preg_quote(variable_get('site_frontpage', 'node'), '/') .'\2'), preg_quote($patterns, '/')) .')$/';  }  return preg_match($regexps[$patterns], $path);}
<?php// $Id$/** * @file * Admin page callback file for the user module. */function user_admin($callback_arg = '') {  $op = isset($_POST['op']) ? $_POST['op'] : $callback_arg;  switch ($op) {    case t('Create new account'):    case 'create':      $output = drupal_get_form('user_register');      break;    default:      if (!empty($_POST['accounts']) && isset($_POST['operation']) && ($_POST['operation'] == 'delete')) {        $output = drupal_get_form('user_multiple_delete_confirm');      }      else {        $output = drupal_get_form('user_filter_form');        $output .= drupal_get_form('user_admin_account');      }  }  return $output;}/** * Form builder; Return form for user administration filters. * * @ingroup forms * @see user_filter_form_submit() */function user_filter_form() {  $session = &$_SESSION['user_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = user_filters();  $i = 0;  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Show only users where'),    '#theme' => 'user_filters',  );  foreach ($session as $filter) {    list($type, $value) = $filter;    // Merge an array of arrays into one if necessary.    $options = $type == 'permission' ? call_user_func_array('array_merge', $filters[$type]['options']) : $filters[$type]['options'];    $params = array('%property' => $filters[$type]['title'] , '%value' => $options[$value]);    if ($i++ > 0) {      $form['filters']['current'][] = array('#value' => t('<em>and</em> where <strong>%property</strong> is <strong>%value</strong>', $params));    }    else {      $form['filters']['current'][] = array('#value' => t('<strong>%property</strong> is <strong>%value</strong>', $params));    }  }  foreach ($filters as $key => $filter) {    $names[$key] = $filter['title'];    $form['filters']['status'][$key] = array(      '#type' => 'select',      '#options' => $filter['options'],    );  }  $form['filters']['filter'] = array(    '#type' => 'radios',    '#options' => $names,  );  $form['filters']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => (count($session) ? t('Refine') : t('Filter')),  );  if (count($session)) {    $form['filters']['buttons']['undo'] = array(      '#type' => 'submit',      '#value' => t('Undo'),    );    $form['filters']['buttons']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset'),    );  }  drupal_add_js('misc/form.js', 'core');  return $form;}/** * Process result from user administration filter form. */function user_filter_form_submit($form, &$form_state) {  $op = $form_state['values']['op'];  $filters = user_filters();  switch ($op) {    case t('Filter'): case t('Refine'):      if (isset($form_state['values']['filter'])) {        $filter = $form_state['values']['filter'];        // Merge an array of arrays into one if necessary.        $options = $filter == 'permission' ? call_user_func_array('array_merge', $filters[$filter]['options']) : $filters[$filter]['options'];        if (isset($options[$form_state['values'][$filter]])) {          $_SESSION['user_overview_filter'][] = array($filter, $form_state['values'][$filter]);        }      }      break;    case t('Undo'):      array_pop($_SESSION['user_overview_filter']);      break;    case t('Reset'):      $_SESSION['user_overview_filter'] = array();      break;    case t('Update'):      return;  }  $form_state['redirect'] = 'admin/user/user';  return;}/** * Form builder; User administration page. * * @ingroup forms * @see user_admin_account_validate() * @see user_admin_account_submit() */function user_admin_account() {  $filter = user_build_filter_query();  $header = array(    array(),    array('data' => t('Username'), 'field' => 'u.name'),    array('data' => t('Status'), 'field' => 'u.status'),    t('Roles'),    array('data' => t('Member for'), 'field' => 'u.created', 'sort' => 'desc'),    array('data' => t('Last access'), 'field' => 'u.access'),    t('Operations')  );  if ($filter['join'] != "") {    $sql = 'SELECT DISTINCT u.uid, u.name, u.status, u.created, u.access FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid '. $filter['join'] .' WHERE u.uid != 0 '. $filter['where'];    $query_count = 'SELECT COUNT(DISTINCT u.uid) FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid '. $filter['join'] .' WHERE u.uid != 0 '. $filter['where'];  }  else {    $sql = 'SELECT u.uid, u.name, u.status, u.created, u.access FROM {users} u WHERE u.uid != 0 '. $filter['where'];    $query_count = 'SELECT COUNT(u.uid) FROM {users} u WHERE u.uid != 0 '. $filter['where'];  }    $sql .= tablesort_sql($header);  $result = pager_query($sql, 50, 0, $query_count, $filter['args']);  $form['options'] = array(    '#type' => 'fieldset',    '#title' => t('Update options'),    '#prefix' => '<div class="container-inline">',    '#suffix' => '</div>',  );  $options = array();  foreach (module_invoke_all('user_operations') as $operation => $array) {    $options[$operation] = $array['label'];  }  $form['options']['operation'] = array(    '#type' => 'select',    '#options' => $options,    '#default_value' => 'unblock',  );  $form['options']['submit'] = array(    '#type' => 'submit',    '#value' => t('Update'),  );  $destination = drupal_get_destination();  $status = array(t('blocked'), t('active'));  $roles = user_roles(TRUE);  $accounts = array();  while ($account = db_fetch_object($result)) {    $accounts[$account->uid] = '';    $form['name'][$account->uid] = array('#value' => theme('username', $account));    $form['status'][$account->uid] =  array('#value' => $status[$account->status]);    $users_roles = array();    $roles_result = db_query('SELECT rid FROM {users_roles} WHERE uid = %d', $account->uid);    while ($user_role = db_fetch_object($roles_result)) {      $users_roles[] = $roles[$user_role->rid];    }    asort($users_roles);    $form['roles'][$account->uid][0] = array('#value' => theme('item_list', $users_roles));    $form['member_for'][$account->uid] = array('#value' => format_interval(time() - $account->created));    $form['last_access'][$account->uid] =  array('#value' => $account->access ? t('@time ago', array('@time' => format_interval(time() - $account->access))) : t('never'));    $form['operations'][$account->uid] = array('#value' => l(t('edit'), "user/$account->uid/edit", array('query' => $destination)));  }  $form['accounts'] = array(    '#type' => 'checkboxes',    '#options' => $accounts  );  $form['pager'] = array('#value' => theme('pager', NULL, 50, 0));  return $form;}/** * Submit the user administration update form. */function user_admin_account_submit($form, &$form_state) {  $operations = module_invoke_all('user_operations', $form_state);  $operation = $operations[$form_state['values']['operation']];  // Filter out unchecked accounts.  $accounts = array_filter($form_state['values']['accounts']);  if ($function = $operation['callback']) {    // Add in callback arguments if present.    if (isset($operation['callback arguments'])) {      $args = array_merge(array($accounts), $operation['callback arguments']);    }    else {      $args = array($accounts);    }    call_user_func_array($function, $args);    drupal_set_message(t('The update has been performed.'));  }}function user_admin_account_validate($form, &$form_state) {  $form_state['values']['accounts'] = array_filter($form_state['values']['accounts']);  if (count($form_state['values']['accounts']) == 0) {    form_set_error('', t('No users selected.'));  }}/** * Form builder; Configure user settings for this site. * * @ingroup forms * @see system_settings_form() */function user_admin_settings() {  // User registration settings.  $form['registration'] = array('#type' => 'fieldset', '#title' => t('User registration settings'));  $form['registration']['user_register'] = array('#type' => 'radios', '#title' => t('Public registrations'), '#default_value' => variable_get('user_register', 1), '#options' => array(t('Only site administrators can create new user accounts.'), t('Visitors can create accounts and no administrator approval is required.'), t('Visitors can create accounts but administrator approval is required.')));  $form['registration']['user_email_verification'] = array('#type' => 'checkbox', '#title' => t('Require e-mail verification when a visitor creates an account'), '#default_value' => variable_get('user_email_verification', TRUE), '#description' => t('If this box is checked, new users will be required to validate their e-mail address prior to logging into the site, and will be assigned a system-generated password. With it unchecked, users will be logged in immediately upon registering, and may select their own passwords during registration.'));  $form['registration']['user_registration_help'] = array('#type' => 'textarea', '#title' => t('User registration guidelines'), '#default_value' => variable_get('user_registration_help', ''), '#description' => t('This text is displayed at the top of the user registration form and is useful for helping or instructing your users.'));  // User e-mail settings.  $form['email'] = array(    '#type' => 'fieldset',    '#title' => t('User e-mail settings'),    '#description' => t('Drupal sends emails whenever new users register on your site, and optionally, may also notify users after other account actions. Using a simple set of content templates, notification e-mails can be customized to fit the specific needs of your site.'),  );  // These email tokens are shared for all settings, so just define  // the list once to help ensure they stay in sync.  $email_token_help = t('Available variables are:') .' !username, !site, !password, !uri, !uri_brief, !mailto, !date, !login_uri, !edit_uri, !login_url.';  $form['email']['admin_created'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, new user created by administrator'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 0),    '#description' => t('Customize welcome e-mail messages sent to new member accounts created by an administrator.') .' '. $email_token_help,  );  $form['email']['admin_created']['user_mail_register_admin_created_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_admin_created_subject'),    '#maxlength' => 180,  );  $form['email']['admin_created']['user_mail_register_admin_created_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_admin_created_body'),    '#rows' => 15,  );  $form['email']['no_approval_required'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, no approval required'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 1),    '#description' => t('Customize welcome e-mail messages sent to new members upon registering, when no administrator approval is required.') .' '. $email_token_help  );  $form['email']['no_approval_required']['user_mail_register_no_approval_required_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_no_approval_required_subject'),    '#maxlength' => 180,  );  $form['email']['no_approval_required']['user_mail_register_no_approval_required_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_no_approval_required_body'),    '#rows' => 15,  );  $form['email']['pending_approval'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, awaiting administrator approval'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 2),    '#description' => t('Customize welcome e-mail messages sent to new members upon registering, when administrative approval is required.') .' '. $email_token_help,  );  $form['email']['pending_approval']['user_mail_register_pending_approval_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_pending_approval_subject'),    '#maxlength' => 180,  );  $form['email']['pending_approval']['user_mail_register_pending_approval_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_pending_approval_body'),    '#rows' => 8,  );  $form['email']['password_reset'] = array(    '#type' => 'fieldset',    '#title' => t('Password recovery email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Customize e-mail messages sent to users who request a new password.') .' '. $email_token_help,  );  $form['email']['password_reset']['user_mail_password_reset_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('password_reset_subject'),    '#maxlength' => 180,  );  $form['email']['password_reset']['user_mail_password_reset_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('password_reset_body'),    '#rows' => 12,  );  $form['email']['activated'] = array(    '#type' => 'fieldset',    '#title' => t('Account activation email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users upon account activation (when an administrator activates an account of a user who has already registered, on a site where administrative approval is required).') .' '. $email_token_help,  );  $form['email']['activated']['user_mail_status_activated_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is activated.'),    '#default_value' => variable_get('user_mail_status_activated_notify', TRUE),  );  $form['email']['activated']['user_mail_status_activated_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_activated_subject'),    '#maxlength' => 180,  );  $form['email']['activated']['user_mail_status_activated_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_activated_body'),    '#rows' => 15,  );  $form['email']['blocked'] = array(    '#type' => 'fieldset',    '#title' => t('Account blocked email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users when their accounts are blocked.') .' '. $email_token_help,  );  $form['email']['blocked']['user_mail_status_blocked_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is blocked.'),    '#default_value' => variable_get('user_mail_status_blocked_notify', FALSE),  );  $form['email']['blocked']['user_mail_status_blocked_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_blocked_subject'),    '#maxlength' => 180,  );  $form['email']['blocked']['user_mail_status_blocked_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_blocked_body'),    '#rows' => 3,  );  $form['email']['deleted'] = array(    '#type' => 'fieldset',    '#title' => t('Account deleted email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users when their accounts are deleted.') .' '. $email_token_help,  );  $form['email']['deleted']['user_mail_status_deleted_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is deleted.'),    '#default_value' => variable_get('user_mail_status_deleted_notify', FALSE),  );  $form['email']['deleted']['user_mail_status_deleted_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_deleted_subject'),    '#maxlength' => 180,  );  $form['email']['deleted']['user_mail_status_deleted_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_deleted_body'),    '#rows' => 3,  );  // User signatures.  $form['signatures'] = array(    '#type' => 'fieldset',    '#title' => t('Signatures'),  );  $form['signatures']['user_signatures'] = array(    '#type' => 'radios',    '#title' => t('Signature support'),    '#default_value' => variable_get('user_signatures', 0),    '#options' => array(t('Disabled'), t('Enabled')),  );  // If picture support is enabled, check whether the picture directory exists:  if (variable_get('user_pictures', 0)) {    $picture_path = file_create_path(variable_get('user_picture_path', 'pictures'));    file_check_directory($picture_path, 1, 'user_picture_path');  }  $form['pictures'] = array(    '#type' => 'fieldset',    '#title' => t('Pictures'),  );  $picture_support = variable_get('user_pictures', 0);  $form['pictures']['user_pictures'] = array(    '#type' => 'radios',    '#title' => t('Picture support'),    '#default_value' => $picture_support,    '#options' => array(t('Disabled'), t('Enabled')),    '#prefix' => '<div class="user-admin-picture-radios">',    '#suffix' => '</div>',  );  drupal_add_js(drupal_get_path('module', 'user') .'/user.js');  // If JS is enabled, and the radio is defaulting to off, hide all  // the settings on page load via .css using the js-hide class so  // that there's no flicker.  $css_class = 'user-admin-picture-settings';  if (!$picture_support) {    $css_class .= ' js-hide';  }  $form['pictures']['settings'] = array(    '#prefix' => '<div class="'. $css_class .'">',    '#suffix' => '</div>',  );  $form['pictures']['settings']['user_picture_path'] = array(    '#type' => 'textfield',    '#title' => t('Picture image path'),    '#default_value' => variable_get('user_picture_path', 'pictures'),    '#size' => 30,    '#maxlength' => 255,    '#description' => t('Subdirectory in the directory %dir where pictures will be stored.', array('%dir' => file_directory_path() .'/')),  );  $form['pictures']['settings']['user_picture_default'] = array(    '#type' => 'textfield',    '#title' => t('Default picture'),    '#default_value' => variable_get('user_picture_default', ''),    '#size' => 30,    '#maxlength' => 255,    '#description' => t('URL of picture to display for users with no custom picture selected. Leave blank for none.'),  );  $form['pictures']['settings']['user_picture_dimensions'] = array(    '#type' => 'textfield',    '#title' => t('Picture maximum dimensions'),    '#default_value' => variable_get('user_picture_dimensions', '85x85'),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('Maximum dimensions for pictures, in pixels.'),  );  $form['pictures']['settings']['user_picture_file_size'] = array(    '#type' => 'textfield',    '#title' => t('Picture maximum file size'),    '#default_value' => variable_get('user_picture_file_size', '30'),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('Maximum file size for pictures, in kB.'),  );  $form['pictures']['settings']['user_picture_guidelines'] = array(    '#type' => 'textarea',    '#title' => t('Picture guidelines'),    '#default_value' => variable_get('user_picture_guidelines', ''),    '#description' => t("This text is displayed at the picture upload form in addition to the default guidelines. It's useful for helping or instructing your users."),  );  return system_settings_form($form);}/** * Menu callback: administer permissions. * * @ingroup forms * @see user_admin_perm_submit() * @see theme_user_admin_perm() */function user_admin_perm($form_state, $rid = NULL) {  if (is_numeric($rid)) {    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid WHERE r.rid = %d', $rid);  }  else {    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid ORDER BY name');  }  // Compile role array:  // Add a comma at the end so when searching for a permission, we can  // always search for "$perm," to make sure we do not confuse  // permissions that are substrings of each other.  while ($role = db_fetch_object($result)) {    $role_permissions[$role->rid] = $role->perm .',';  }  // Retrieve role names for columns.  $role_names = user_roles();  if (is_numeric($rid)) {    $role_names = array($rid => $role_names[$rid]);  }  // Render role/permission overview:  $options = array();  foreach (module_list(FALSE, FALSE, TRUE) as $module) {    if ($permissions = module_invoke($module, 'perm')) {      $form['permission'][] = array(        '#value' => $module,      );      asort($permissions);      foreach ($permissions as $perm) {        $options[$perm] = '';        $form['permission'][$perm] = array('#value' => t($perm));        foreach ($role_names as $rid => $name) {          // Builds arrays for checked boxes for each role          if (strpos($role_permissions[$rid], $perm .',') !== FALSE) {            $status[$rid][] = $perm;          }        }      }    }  }  // Have to build checkboxes here after checkbox arrays are built  foreach ($role_names as $rid => $name) {    $form['checkboxes'][$rid] = array('#type' => 'checkboxes', '#options' => $options, '#default_value' => isset($status[$rid]) ? $status[$rid] : array());    $form['role_names'][$rid] = array('#value' => $name, '#tree' => TRUE);  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save permissions'));  return $form;}function user_admin_perm_submit($form, &$form_state) {  // Save permissions:  $result = db_query('SELECT * FROM {role}');  while ($role = db_fetch_object($result)) {    if (isset($form_state['values'][$role->rid])) {      // Delete, so if we clear every checkbox we reset that role;      // otherwise permissions are active and denied everywhere.      db_query('DELETE FROM {permission} WHERE rid = %d', $role->rid);      $form_state['values'][$role->rid] = array_filter($form_state['values'][$role->rid]);      if (count($form_state['values'][$role->rid])) {        db_query("INSERT INTO {permission} (rid, perm) VALUES (%d, '%s')", $role->rid, implode(', ', array_keys($form_state['values'][$role->rid])));      }    }  }  drupal_set_message(t('The changes have been saved.'));  // Clear the cached pages  cache_clear_all();}/** * Theme the administer permissions page. * * @ingroup themeable */function theme_user_admin_perm($form) {  $roles = user_roles();  foreach (element_children($form['permission']) as $key) {    // Don't take form control structures    if (is_array($form['permission'][$key])) {      $row = array();      // Module name      if (is_numeric($key)) {        $row[] = array('data' => t('@module module', array('@module' => drupal_render($form['permission'][$key]))), 'class' => 'module', 'id' => 'module-'. $form['permission'][$key]['#value'], 'colspan' => count($form['role_names']) + 1);      }      else {        $row[] = array('data' => drupal_render($form['permission'][$key]), 'class' => 'permission');        foreach (element_children($form['checkboxes']) as $rid) {          if (is_array($form['checkboxes'][$rid])) {            $row[] = array('data' => drupal_render($form['checkboxes'][$rid][$key]), 'class' => 'checkbox', 'title' => $roles[$rid] .' : '. t($key));          }        }      }      $rows[] = $row;    }  }  $header[] = (t('Permission'));  foreach (element_children($form['role_names']) as $rid) {    if (is_array($form['role_names'][$rid])) {      $header[] = array('data' => drupal_render($form['role_names'][$rid]), 'class' => 'checkbox');    }  }  $output = theme('table', $header, $rows, array('id' => 'permissions'));  $output .= drupal_render($form);  return $output;}/** * Menu callback: administer roles. * * @ingroup forms * @see user_admin_role_validate() * @see user_admin_role_submit() * @see theme_user_admin_new_role() */function user_admin_role() {  $rid = arg(4);  if ($rid) {    if ($rid == DRUPAL_ANONYMOUS_RID || $rid == DRUPAL_AUTHENTICATED_RID) {      drupal_goto('admin/user/roles');    }    // Display the edit role form.    $role = db_fetch_object(db_query('SELECT * FROM {role} WHERE rid = %d', $rid));    $form['name'] = array(      '#type' => 'textfield',      '#title' => t('Role name'),      '#default_value' => $role->name,      '#size' => 30,      '#required' => TRUE,      '#maxlength' => 64,      '#description' => t('The name for this role. Example: "moderator", "editorial board", "site architect".'),    );    $form['rid'] = array(      '#type' => 'value',      '#value' => $rid,    );    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Save role'),    );    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete role'),    );  }  else {    $form['name'] = array(      '#type' => 'textfield',      '#size' => 32,      '#maxlength' => 64,    );    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Add role'),    );    $form['#submit'][] = 'user_admin_role_submit';    $form['#validate'][] = 'user_admin_role_validate';  }  return $form;}function user_admin_role_validate($form, &$form_state) {  if ($form_state['values']['name']) {    if ($form_state['values']['op'] == t('Save role')) {      if (db_result(db_query("SELECT COUNT(*) FROM {role} WHERE name = '%s' AND rid != %d", $form_state['values']['name'], $form_state['values']['rid']))) {        form_set_error('name', t('The role name %name already exists. Please choose another role name.', array('%name' => $form_state['values']['name'])));      }    }    else if ($form_state['values']['op'] == t('Add role')) {      if (db_result(db_query("SELECT COUNT(*) FROM {role} WHERE name = '%s'", $form_state['values']['name']))) {        form_set_error('name', t('The role name %name already exists. Please choose another role name.', array('%name' => $form_state['values']['name'])));      }    }  }  else {    form_set_error('name', t('You must specify a valid role name.'));  }}function user_admin_role_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Save role')) {    db_query("UPDATE {role} SET name = '%s' WHERE rid = %d", $form_state['values']['name'], $form_state['values']['rid']);    drupal_set_message(t('The role has been renamed.'));  }  else if ($form_state['values']['op'] == t('Delete role')) {    db_query('DELETE FROM {role} WHERE rid = %d', $form_state['values']['rid']);    db_query('DELETE FROM {permission} WHERE rid = %d', $form_state['values']['rid']);    // Update the users who have this role set:    db_query('DELETE FROM {users_roles} WHERE rid = %d', $form_state['values']['rid']);    drupal_set_message(t('The role has been deleted.'));  }  else if ($form_state['values']['op'] == t('Add role')) {    db_query("INSERT INTO {role} (name) VALUES ('%s')", $form_state['values']['name']);    drupal_set_message(t('The role has been added.'));  }  $form_state['redirect'] = 'admin/user/roles';  return;}/** * Menu callback: list all access rules */function user_admin_access_check() {  $output = drupal_get_form('user_admin_check_user');  $output .= drupal_get_form('user_admin_check_mail');  $output .= drupal_get_form('user_admin_check_host');  return $output;}/** * Menu callback: add an access rule. */function user_admin_access_add($mask = NULL, $type = NULL) {  $edit = array();  $edit['aid'] = 0;  $edit['mask'] = $mask;  $edit['type'] = $type;  return drupal_get_form('user_admin_access_add_form', $edit, t('Add rule'));}/** * Menu callback: edit an access rule. */function user_admin_access_edit($aid = 0) {  $edit = db_fetch_array(db_query('SELECT aid, type, status, mask FROM {access} WHERE aid = %d', $aid));  return drupal_get_form('user_admin_access_edit_form', $edit, t('Save rule'));}/** * Form builder; Configure access rules. * * @ingroup forms */function user_admin_access_form(&$form_state, $edit, $submit) {  $form = array();  $form['aid'] = array(    '#type' => 'value',    '#value' => $edit['aid'],  );  $form['status'] = array(    '#type' => 'radios',    '#title' => t('Access type'),    '#default_value' => isset($edit['status']) ? $edit['status'] : 0,    '#options' => array('1' => t('Allow'), '0' => t('Deny')),  );  $type_options = array('user' => t('Username'), 'mail' => t('E-mail'), 'host' => t('Host'));  $form['type'] = array(    '#type' => 'radios',    '#title' => t('Rule type'),    '#default_value' => (isset($type_options[$edit['type']]) ? $edit['type'] : 'user'),    '#options' => $type_options,  );  $form['mask'] = array(    '#type' => 'textfield',    '#title' => t('Mask'),    '#size' => 30,    '#maxlength' => 64,    '#default_value' => $edit['mask'],    '#description' => '%: '. t('Matches any number of characters, even zero characters') .'.<br />_: '. t('Matches exactly one character.'),    '#required' => TRUE,  );  $form['submit'] = array('#type' => 'submit', '#value' => $submit);  $form['#submit'] = array('user_admin_access_form_submit');  return $form;}/** * Submit callback for user_admin_access_form(). */function user_admin_access_form_submit($form, &$form_state) {  $edit = $form_state['values'];  if ($edit['aid']) {    db_query("UPDATE {access} SET mask = '%s', type = '%s', status = '%s' WHERE aid = %d", $edit['mask'], $edit['type'], $edit['status'], $edit['aid']);    drupal_set_message(t('The access rule has been saved.'));  }  else {    db_query("INSERT INTO {access} (mask, type, status) VALUES ('%s', '%s', %d)", $edit['mask'], $edit['type'], $edit['status']);    drupal_set_message(t('The access rule has been added.'));  }  $form_state['redirect'] = 'admin/user/rules';}function user_admin_access_check_validate($form, &$form_state) {  if (empty($form_state['values']['test'])) {    form_set_error($form_state['values']['type'], t('No value entered. Please enter a test string and try again.'));  }}function user_admin_check_user() {  $form['user'] = array('#type' => 'fieldset', '#title' => t('Username'));  $form['user']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter a username to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => USERNAME_MAX_LENGTH);  $form['user']['type'] = array('#type' => 'hidden', '#value' => 'user');  $form['user']['submit'] = array('#type' => 'submit', '#value' => t('Check username'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_check_mail() {  $form['mail'] = array('#type' => 'fieldset', '#title' => t('E-mail'));  $form['mail']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter an e-mail address to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => EMAIL_MAX_LENGTH);  $form['mail']['type'] = array('#type' => 'hidden', '#value' => 'mail');  $form['mail']['submit'] = array('#type' => 'submit', '#value' => t('Check e-mail'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_check_host() {  $form['host'] = array('#type' => 'fieldset', '#title' => t('Hostname'));  $form['host']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter a hostname or IP address to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => 64);  $form['host']['type'] = array('#type' => 'hidden', '#value' => 'host');  $form['host']['submit'] = array('#type' => 'submit', '#value' => t('Check hostname'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_access_check_submit($form, &$form_state) {  switch ($form_state['values']['type']) {    case 'user':      if (drupal_is_denied('user', $form_state['values']['test'])) {        drupal_set_message(t('The username %name is not allowed.', array('%name' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The username %name is allowed.', array('%name' => $form_state['values']['test'])));      }      break;    case 'mail':      if (drupal_is_denied('mail', $form_state['values']['test'])) {        drupal_set_message(t('The e-mail address %mail is not allowed.', array('%mail' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The e-mail address %mail is allowed.', array('%mail' => $form_state['values']['test'])));      }      break;    case 'host':      if (drupal_is_denied('host', $form_state['values']['test'])) {        drupal_set_message(t('The hostname %host is not allowed.', array('%host' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The hostname %host is allowed.', array('%host' => $form_state['values']['test'])));      }      break;    default:      break;  }}/** * Menu callback: delete an access rule * * @ingroup forms * @see user_admin_access_delete_confirm_submit() */function user_admin_access_delete_confirm($form_state, $aid = 0) {  $access_types = array('user' => t('username'), 'mail' => t('e-mail'), 'host' => t('host'));  $edit = db_fetch_object(db_query('SELECT aid, type, status, mask FROM {access} WHERE aid = %d', $aid));  $form = array();  $form['aid'] = array('#type' => 'hidden', '#value' => $aid);  $output = confirm_form($form,                  t('Are you sure you want to delete the @type rule for %rule?', array('@type' => $access_types[$edit->type], '%rule' => $edit->mask)),                  'admin/user/rules',                  t('This action cannot be undone.'),                  t('Delete'),                  t('Cancel'));  return $output;}function user_admin_access_delete_confirm_submit($form, &$form_state) {  db_query('DELETE FROM {access} WHERE aid = %d', $form_state['values']['aid']);  drupal_set_message(t('The access rule has been deleted.'));  $form_state['redirect'] = 'admin/user/rules';  return;}/** * Menu callback: list all access rules */function user_admin_access() {  $header = array(array('data' => t('Access type'), 'field' => 'status'), array('data' => t('Rule type'), 'field' => 'type'), array('data' => t('Mask'), 'field' => 'mask'), array('data' => t('Operations'), 'colspan' => 2));  $result = db_query("SELECT aid, type, status, mask FROM {access}". tablesort_sql($header));  $access_types = array('user' => t('username'), 'mail' => t('e-mail'), 'host' => t('host'));  $rows = array();  while ($rule = db_fetch_object($result)) {    $rows[] = array($rule->status ? t('allow') : t('deny'), $access_types[$rule->type], $rule->mask, l(t('edit'), 'admin/user/rules/edit/'. $rule->aid), l(t('delete'), 'admin/user/rules/delete/'. $rule->aid));  }  if (empty($rows)) {    $rows[] = array(array('data' => '<em>'. t('There are currently no access rules.') .'</em>', 'colspan' => 5));  }  return theme('table', $header, $rows);}/** * Theme user administration overview. * * @ingroup themeable */function theme_user_admin_account($form) {  // Overview table:  $header = array(    theme('table_select_header_cell'),    array('data' => t('Username'), 'field' => 'u.name'),    array('data' => t('Status'), 'field' => 'u.status'),    t('Roles'),    array('data' => t('Member for'), 'field' => 'u.created', 'sort' => 'desc'),    array('data' => t('Last access'), 'field' => 'u.access'),    t('Operations')  );  $output = drupal_render($form['options']);  if (isset($form['name']) && is_array($form['name'])) {    foreach (element_children($form['name']) as $key) {      $rows[] = array(        drupal_render($form['accounts'][$key]),        drupal_render($form['name'][$key]),        drupal_render($form['status'][$key]),        drupal_render($form['roles'][$key]),        drupal_render($form['member_for'][$key]),        drupal_render($form['last_access'][$key]),        drupal_render($form['operations'][$key]),      );    }  }  else {    $rows[] = array(array('data' => t('No users available.'), 'colspan' => '7'));  }  $output .= theme('table', $header, $rows);  if ($form['pager']['#value']) {    $output .= drupal_render($form['pager']);  }  $output .= drupal_render($form);  return $output;}/** * Theme the new-role form. * * @ingroup themeable */function theme_user_admin_new_role($form) {  $header = array(t('Name'), array('data' => t('Operations'), 'colspan' => 2));  foreach (user_roles() as $rid => $name) {    $edit_permissions = l(t('edit permissions'), 'admin/user/permissions/'. $rid);    if (!in_array($rid, array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID))) {      $rows[] = array($name, l(t('edit role'), 'admin/user/roles/edit/'. $rid), $edit_permissions);    }    else {      $rows[] = array($name, t('locked'), $edit_permissions);    }  }  $rows[] = array(drupal_render($form['name']), array('data' => drupal_render($form['submit']), 'colspan' => 2));  $output = drupal_render($form);  $output .= theme('table', $header, $rows);  return $output;}/** * Theme user administration filter form. * * @ingroup themeable */function theme_user_filter_form($form) {  $output = '<div id="user-admin-filter">';  $output .= drupal_render($form['filters']);  $output .= '</div>';  $output .= drupal_render($form);  return $output;}/** * Theme user administration filter selector. * * @ingroup themeable */function theme_user_filters($form) {  $output = '<ul class="clear-block">';  if (!empty($form['current'])) {    foreach (element_children($form['current']) as $key) {      $output .= '<li>'. drupal_render($form['current'][$key]) .'</li>';    }  }  $output .= '<li><dl class="multiselect">'. (!empty($form['current']) ? '<dt><em>'. t('and') .'</em> '. t('where') .'</dt>' : '') .'<dd class="a">';  foreach (element_children($form['filter']) as $key) {    $output .= drupal_render($form['filter'][$key]);  }  $output .= '</dd>';  $output .= '<dt>'. t('is') .'</dt><dd class="b">';  foreach (element_children($form['status']) as $key) {    $output .= drupal_render($form['status'][$key]);  }  $output .= '</dd>';  $output .= '</dl>';  $output .= '<div class="container-inline" id="user-admin-buttons">'. drupal_render($form['buttons']) .'</div>';  $output .= '</li></ul>';  return $output;}
<?php// $Id$/** * @file * Enables functions to be stored and executed at a later time when * triggered by other modules or by one of Drupal's core API hooks. *//** * Implementation of hook_help(). */function trigger_help($path, $arg) {  $explanation = '<p>'. t('Triggers are system events, such as when new content is added or when a user logs in. Trigger module combines these triggers with actions (functional tasks), such as unpublishing content or e-mailing an administrator. The <a href="@url">Actions settings page</a> contains a list of existing actions and provides the ability to create and configure additional actions.', array('@url' => url('admin/settings/actions'))) .'</p>';  switch ($path) {    case 'admin/build/trigger/comment':      return $explanation .'<p>'. t('Below you can assign actions to run when certain comment-related triggers happen. For example, you could promote a post to the front page when a comment is added.') .'</p>';    case 'admin/build/trigger/node':      return $explanation .'<p>'. t('Below you can assign actions to run when certain content-related triggers happen. For example, you could send an e-mail to an administrator when a post is created or updated.') .'</p>';    case 'admin/build/trigger/cron':      return $explanation .'<p>'. t('Below you can assign actions to run during each pass of a <a href="@cron">cron maintenance task</a>.', array('@cron' => url('admin/reports/status'))) .'</p>';    case 'admin/build/trigger/taxonomy':      return $explanation .'<p>'. t('Below you can assign actions to run when certain taxonomy-related triggers happen. For example, you could send an e-mail to an administrator when a term is deleted.') .'</p>';    case 'admin/build/trigger/user':      return $explanation .'<p>'. t("Below you can assign actions to run when certain user-related triggers happen. For example, you could send an e-mail to an administrator when a user account is deleted.") .'</p>';    case 'admin/help#trigger':      $output = '<p>'. t('The Trigger module provides the ability to trigger <a href="@actions">actions</a> upon system events, such as when new content is added or when a user logs in.', array('@actions' => url('admin/settings/actions'))) .'</p>';      $output .= '<p>'. t('The combination of actions and triggers can perform many useful tasks, such as e-mailing an administrator if a user account is deleted, or automatically unpublishing comments that contain certain words. By default, there are five "contexts" of events (Comments, Content, Cron, Taxonomy, and Users), but more may be added by additional modules.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@trigger">Trigger module</a>.', array('@trigger' => 'http://drupal.org/handbook/modules/trigger/')) .'</p>';      return $output;  }}/** * Implementation of hook_menu(). */function trigger_menu() {  $items['admin/build/trigger'] = array(    'title' => 'Triggers',    'description' => 'Tell Drupal when to execute actions.',    'page callback' => 'trigger_assign',    'access callback' => 'trigger_access_check',    'access arguments' => array('node'),    'file' => 'trigger.admin.inc',  );  // We don't use a menu wildcard here because these are tabs,  // not invisible items.  $items['admin/build/trigger/node'] = array(    'title' => 'Content',    'page callback' => 'trigger_assign',    'page arguments' => array('node'),    'access callback' => 'trigger_access_check',    'access arguments' => array('node'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/user'] = array(    'title' => 'Users',    'page callback' => 'trigger_assign',    'page arguments' => array('user'),    'access callback' => 'trigger_access_check',    'access arguments' => array('user'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/comment'] = array(    'title' => 'Comments',    'page callback' => 'trigger_assign',    'page arguments' => array('comment'),    'access callback' => 'trigger_access_check',    'access arguments' => array('comment'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/taxonomy'] = array(    'title' => 'Taxonomy',    'page callback' => 'trigger_assign',    'page arguments' => array('taxonomy'),    'access callback' => 'trigger_access_check',    'access arguments' => array('taxonomy'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/cron'] = array(    'title' => 'Cron',    'page callback' => 'trigger_assign',    'page arguments' => array('cron'),    'access arguments' => array('administer actions'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  // We want contributed modules to be able to describe  // their hooks and have actions assignable to them.  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $hook) {    // We've already done these.    if (in_array($module, array('node', 'comment', 'user', 'system', 'taxonomy'))) {      continue;    }    $info = db_result(db_query("SELECT info FROM {system} WHERE name = '%s'", $module));    $info = unserialize($info);    $nice_name = $info['name'];    $items["admin/build/trigger/$module"] = array(      'title' => $nice_name,      'page callback' => 'trigger_assign',      'page arguments' => array($module),      'access arguments' => array($module),      'type' => MENU_LOCAL_TASK,      'file' => 'trigger.admin.inc',    );  }  $items['admin/build/trigger/unassign'] = array(    'title' => 'Unassign',    'description' => 'Unassign an action from a trigger.',    'page callback' => 'drupal_get_form',    'page arguments' => array('trigger_unassign'),    'access arguments' => array('administer actions'),    'type' => MENU_CALLBACK,    'file' => 'trigger.admin.inc',  );  return $items;}/** * Access callback for menu system. */function trigger_access_check($module) {  return (module_exists($module) && user_access('administer actions'));}/** * Get the aids of actions to be executed for a hook-op combination. * * @param $hook *   The name of the hook being fired. * @param $op *   The name of the operation being executed. Defaults to an empty string *   because some hooks (e.g., hook_cron()) do not have operations. * @return *   An array of action IDs. */function _trigger_get_hook_aids($hook, $op = '') {  $aids = array();  $result = db_query("SELECT aa.aid, a.type FROM {trigger_assignments} aa LEFT JOIN {actions} a ON aa.aid = a.aid WHERE aa.hook = '%s' AND aa.op = '%s' ORDER BY weight", $hook, $op);  while ($action = db_fetch_object($result)) {    $aids[$action->aid]['type'] = $action->type;  }  return $aids;}/** * Implementation of hook_theme(). */function trigger_theme() {  return array(    'trigger_display' => array(      'arguments' => array('element'),      'file' => 'trigger.admin.inc',    ),  );}/** * Implementation of hook_forms(). We reuse code by using the * same assignment form definition for each node-op combination. */function trigger_forms() {  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $info) {    foreach ($hooks[$module] as $hook => $ops) {      foreach ($ops as $op => $description) {        $forms['trigger_'. $hook .'_'. $op .'_assign_form'] = array('callback' => 'trigger_assign_form');      }    }  }  return $forms;}/** * When an action is called in a context that does not match its type, * the object that the action expects must be retrieved. For example, when * an action that works on users is called during the node hook, the * user object is not available since the node hook doesn't pass it. * So here we load the object the action expects. * * @param $type *   The type of action that is about to be called. * @param $node *   The node that was passed via the nodeapi hook. * @return *   The object expected by the action that is about to be called. */function _trigger_normalize_node_context($type, $node) {  switch ($type) {    // If an action that works on comments is being called in a node context,    // the action is expecting a comment object. But we do not know which comment    // to give it. The first? The most recent? All of them? So comment actions    // in a node context are not supported.    // An action that works on users is being called in a node context.    // Load the user object of the node's author.    case 'user':      return user_load(array('uid' => $node->uid));  }}/** * Implementation of hook_nodeapi(). */function trigger_nodeapi(&$node, $op, $a3, $a4) {  // Keep objects for reuse so that changes actions make to objects can persist.  static $objects;  // Prevent recursion by tracking which operations have already been called.  static $recursion;  // Support a subset of operations.  if (!in_array($op, array('view', 'update', 'presave', 'insert', 'delete')) || isset($recursion[$op])) {    return;  }  $recursion[$op] = TRUE;  $aids = _trigger_get_hook_aids('nodeapi', $op);  if (!$aids) {    return;  }  $context = array(    'hook' => 'nodeapi',    'op' => $op,  );  // We need to get the expected object if the action's type is not 'node'.  // We keep the object in $objects so we can reuse it if we have multiple actions  // that make changes to an object.  foreach ($aids as $aid => $action_info) {    if ($action_info['type'] != 'node') {      if (!isset($objects[$action_info['type']])) {        $objects[$action_info['type']] = _trigger_normalize_node_context($action_info['type'], $node);      }      // Since we know about the node, we pass that info along to the action.      $context['node'] = $node;      $result = actions_do($aid, $objects[$action_info['type']], $context, $a3, $a4);    }    else {      actions_do($aid, $node, $context, $a3, $a4);    }  }}/** * When an action is called in a context that does not match its type, * the object that the action expects must be retrieved. For example, when * an action that works on nodes is called during the comment hook, the * node object is not available since the comment hook doesn't pass it. * So here we load the object the action expects. * * @param $type *   The type of action that is about to be called. * @param $comment *   The comment that was passed via the comment hook. * @return *   The object expected by the action that is about to be called. */function _trigger_normalize_comment_context($type, $comment) {  switch ($type) {    // An action that works with nodes is being called in a comment context.    case 'node':      return node_load(is_array($comment) ? $comment['nid'] : $comment->nid);    // An action that works on users is being called in a comment context.    case 'user':      return user_load(array('uid' => is_array($comment) ? $comment['uid'] : $comment->uid));  }}/** * Implementation of hook_comment(). */function trigger_comment($a1, $op) {  // Keep objects for reuse so that changes actions make to objects can persist.  static $objects;  // We support a subset of operations.  if (!in_array($op, array('insert', 'update', 'delete', 'view'))) {    return;  }  $aids = _trigger_get_hook_aids('comment', $op);  $context = array(    'hook' => 'comment',    'op' => $op,  );  // We need to get the expected object if the action's type is not 'comment'.  // We keep the object in $objects so we can reuse it if we have multiple actions  // that make changes to an object.  foreach ($aids as $aid => $action_info) {    if ($action_info['type'] != 'comment') {      if (!isset($objects[$action_info['type']])) {        $objects[$action_info['type']] = _trigger_normalize_comment_context($action_info['type'], $a1);      }      // Since we know about the comment, we pass it along to the action      // in case it wants to peek at it.      $context['comment'] = (object) $a1;      actions_do($aid, $objects[$action_info['type']], $context);    }    else {      $comment = (object) $a1;      actions_do($aid, $comment, $context);    }  }}/** * Implementation of hook_cron(). */function trigger_cron() {  $aids = _trigger_get_hook_aids('cron', 'run');  $context = array(    'hook' => 'cron',    'op' => 'run',  );  // Cron does not act on any specific object.  $object = NULL;  actions_do(array_keys($aids), $object, $context);}/** * When an action is called in a context that does not match its type, * the object that the action expects must be retrieved. For example, when * an action that works on nodes is called during the user hook, the * node object is not available since the user hook doesn't pass it. * So here we load the object the action expects. * * @param $type *   The type of action that is about to be called. * @param $account *   The account object that was passed via the user hook. * @return *   The object expected by the action that is about to be called. */function _trigger_normalize_user_context($type, $account) {  switch ($type) {    // If an action that works on comments is being called in a user context,    // the action is expecting a comment object. But we have no way of    // determining the appropriate comment object to pass. So comment    // actions in a user context are not supported.    // An action that works with nodes is being called in a user context.    // If a single node is being viewed, return the node.    case 'node':      // If we are viewing an individual node, return the node.      if ((arg(0) == 'node') && is_numeric(arg(1)) && (arg(2) == NULL)) {        return node_load(array('nid' => arg(1)));      }  }}/** * Implementation of hook_user(). */function trigger_user($op, &$edit, &$account, $category = NULL) {  // Keep objects for reuse so that changes actions make to objects can persist.  static $objects;  // We support a subset of operations.  if (!in_array($op, array('login', 'logout', 'insert', 'update', 'delete', 'view'))) {    return;  }  $aids = _trigger_get_hook_aids('user', $op);  $context = array(    'hook' => 'user',    'op' => $op,    'form_values' => &$edit,  );  foreach ($aids as $aid => $action_info) {    if ($action_info['type'] != 'user') {      if (!isset($objects[$action_info['type']])) {        $objects[$action_info['type']] = _trigger_normalize_user_context($action_info['type'], $account);      }      $context['account'] = $account;      actions_do($aid, $objects[$action_info['type']], $context);    }    else {      actions_do($aid, $account, $context, $category);    }  }}/** * Implementation of hook_taxonomy(). */function trigger_taxonomy($op, $type, $array) {  if ($type != 'term') {    return;  }  $aids = _trigger_get_hook_aids('taxonomy', $op);  $context = array(    'hook' => 'taxonomy',    'op' => $op  );  foreach ($aids as $aid => $action_info) {    $taxonomy_object = (object) $array;    actions_do($aid, $taxonomy_object, $context);  }}/** * Often we generate a select field of all actions. This function * generates the options for that select. * * @param $type *   One of 'node', 'user', 'comment'. * @return *   Array keyed by action ID. */function trigger_options($type = 'all') {  $options = array(t('Choose an action'));  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {    $options[$action['type']][$aid] = $action['description'];  }  if ($type == 'all') {    return $options;  }  else {    return $options[$type];  }}/** * Implementation of hook_actions_delete(). * * Remove all trigger entries for the given action, when deleted. */function trigger_actions_delete($aid) {  db_query("DELETE FROM {trigger_assignments} WHERE aid = '%s'", $aid);}
<?php// $Id$/** * @file * The theme system, which controls the output of Drupal. * * The theme system allows for nearly all output of the Drupal system to be * customized by user themes. * * @ingroup themeable *//** * @name Content markers * @{ * Markers used by theme_mark() and node_mark() to designate content. * @see theme_mark(), node_mark() */define('MARK_READ',    0);define('MARK_NEW',     1);define('MARK_UPDATED', 2);/** * @} End of "Content markers". *//** * Initialize the theme system by loading the theme. */function init_theme() {  global $theme, $user, $custom_theme, $theme_key;  // If $theme is already set, assume the others are set, too, and do nothing  if (isset($theme)) {    return;  }  drupal_bootstrap(DRUPAL_BOOTSTRAP_DATABASE);  $themes = list_themes();  // Only select the user selected theme if it is available in the  // list of enabled themes.  $theme = !empty($user->theme) && !empty($themes[$user->theme]->status) ? $user->theme : variable_get('theme_default', 'garland');  // Allow modules to override the present theme... only select custom theme  // if it is available in the list of installed themes.  $theme = $custom_theme && $themes[$custom_theme] ? $custom_theme : $theme;  // Store the identifier for retrieving theme settings with.  $theme_key = $theme;  // Find all our ancestor themes and put them in an array.  $base_theme = array();  $ancestor = $theme;  while ($ancestor && isset($themes[$ancestor]->base_theme)) {    $base_theme[] = $new_base_theme = $themes[$themes[$ancestor]->base_theme];    $ancestor = $themes[$ancestor]->base_theme;  }  _init_theme($themes[$theme], array_reverse($base_theme));}/** * Initialize the theme system given already loaded information. This * function is useful to initialize a theme when no database is present. * * @param $theme *   An object with the following information: *     filename *       The .info file for this theme. The 'path' to *       the theme will be in this file's directory. (Required) *     owner *       The path to the .theme file or the .engine file to load for *       the theme. (Required) *     stylesheet *       The primary stylesheet for the theme. (Optional) *     engine *       The name of theme engine to use. (Optional) * @param $base_theme *    An optional array of objects that represent the 'base theme' if the *    theme is meant to be derivative of another theme. It requires *    the same information as the $theme object. It should be in *    'oldest first' order, meaning the top level of the chain will *    be first. * @param $registry_callback *   The callback to invoke to set the theme registry. */function _init_theme($theme, $base_theme = array(), $registry_callback = '_theme_load_registry') {  global $theme_info, $base_theme_info, $theme_engine, $theme_path;  $theme_info = $theme;  $base_theme_info = $base_theme;  $theme_path = dirname($theme->filename);  // Prepare stylesheets from this theme as well as all ancestor themes.  // We work it this way so that we can have child themes override parent  // theme stylesheets easily.  $final_stylesheets = array();  // Grab stylesheets from base theme  foreach ($base_theme as $base) {    if (!empty($base->stylesheets)) {      foreach ($base->stylesheets as $media => $stylesheets) {        foreach ($stylesheets as $name => $stylesheet) {          $final_stylesheets[$media][$name] = $stylesheet;        }      }    }  }  // Add stylesheets used by this theme.  if (!empty($theme->stylesheets)) {    foreach ($theme->stylesheets as $media => $stylesheets) {      foreach ($stylesheets as $name => $stylesheet) {        $final_stylesheets[$media][$name] = $stylesheet;      }    }  }  // And now add the stylesheets properly  foreach ($final_stylesheets as $media => $stylesheets) {    foreach ($stylesheets as $stylesheet) {      drupal_add_css($stylesheet, 'theme', $media);    }  }  // Do basically the same as the above for scripts  $final_scripts = array();  // Grab scripts from base theme  foreach ($base_theme as $base) {    if (!empty($base->scripts)) {      foreach ($base->scripts as $name => $script) {        $final_scripts[$name] = $script;      }    }  }  // Add scripts used by this theme.  if (!empty($theme->scripts)) {    foreach ($theme->scripts as $name => $script) {      $final_scripts[$name] = $script;    }  }  // Add scripts used by this theme.  foreach ($final_scripts as $script) {    drupal_add_js($script, 'theme');  }  $theme_engine = NULL;  // Initialize the theme.  if (isset($theme->engine)) {    // Include the engine.    include_once './'. $theme->owner;    $theme_engine = $theme->engine;    if (function_exists($theme_engine .'_init')) {      foreach ($base_theme as $base) {        call_user_func($theme_engine .'_init', $base);      }      call_user_func($theme_engine .'_init', $theme);    }  }  else {    // include non-engine theme files    foreach ($base_theme as $base) {      // Include the theme file or the engine.      if (!empty($base->owner)) {        include_once './'. $base->owner;      }    }    // and our theme gets one too.    if (!empty($theme->owner)) {      include_once './'. $theme->owner;    }  }  $registry_callback($theme, $base_theme, $theme_engine);}/** * Retrieve the stored theme registry. If the theme registry is already * in memory it will be returned; otherwise it will attempt to load the * registry from cache. If this fails, it will construct the registry and * cache it. */function theme_get_registry($registry = NULL) {  static $theme_registry = NULL;  if (isset($registry)) {    $theme_registry = $registry;  }  return $theme_registry;}/** * Store the theme registry in memory. */function _theme_set_registry($registry) {  // Pass through for setting of static variable.  return theme_get_registry($registry);}/** * Get the theme_registry cache from the database; if it doesn't exist, build * it. * * @param $theme *   The loaded $theme object. * @param $base_theme *   An array of loaded $theme objects representing the ancestor themes in *   oldest first order. * @param theme_engine *   The name of the theme engine. */function _theme_load_registry($theme, $base_theme = NULL, $theme_engine = NULL) {  // Check the theme registry cache; if it exists, use it.  $cache = cache_get("theme_registry:$theme->name", 'cache');  if (isset($cache->data)) {    $registry = $cache->data;  }  else {    // If not, build one and cache it.    $registry = _theme_build_registry($theme, $base_theme, $theme_engine);    _theme_save_registry($theme, $registry);  }  _theme_set_registry($registry);}/** * Write the theme_registry cache into the database. */function _theme_save_registry($theme, $registry) {  cache_set("theme_registry:$theme->name", $registry);}/** * Force the system to rebuild the theme registry; this should be called * when modules are added to the system, or when a dynamic system needs * to add more theme hooks. */function drupal_rebuild_theme_registry() {  cache_clear_all('theme_registry', 'cache', TRUE);}/** * Process a single invocation of the theme hook. $type will be one * of 'module', 'theme_engine', 'base_theme_engine', 'theme', or 'base_theme' * and it tells us some important information. * * Because $cache is a reference, the cache will be continually * expanded upon; new entries will replace old entries in the * array_merge, but we are careful to ensure some data is carried * forward, such as the arguments a theme hook needs. * * An override flag can be set for preprocess functions. When detected the * cached preprocessors for the hook will not be merged with the newly set. * This can be useful to themes and theme engines by giving them more control * over how and when the preprocess functions are run. */function _theme_process_registry(&$cache, $name, $type, $theme, $path) {  $result = array();  $function = $name .'_theme';  if (function_exists($function)) {    $result = $function($cache, $type, $theme, $path);    foreach ($result as $hook => $info) {      $result[$hook]['type'] = $type;      $result[$hook]['theme path'] = $path;      // if function and file are left out, default to standard naming      // conventions.      if (!isset($info['template']) && !isset($info['function'])) {        $result[$hook]['function'] = ($type == 'module' ? 'theme_' : $name .'_') . $hook;      }      // Make sure include files is set so we don't generate notices later.      if (!isset($info['include files'])) {        $result[$hook]['include files'] = array();      }      // If a path is set in the info, use what was set. Otherwise use the      // default path. This is mostly so system.module can declare theme      // functions on behalf of core .include files.      // All files are included to be safe. Conditionally included      // files can prevent them from getting registered.      if (isset($info['file']) && !isset($info['path'])) {        // First, check to see if the fully qualified file exists.        $filename = './'. $path .'/'. $info['file'];        if (file_exists($filename)) {          require_once $filename;          $result[$hook]['include files'][] = $filename;        }        else {          $filename = './'. $info['file'];          if (file_exists($filename)) {            require_once $filename;            $result[$hook]['include files'][] = $filename;          }        }      }      elseif (isset($info['file']) && isset($info['path'])) {        $filename = './'. $info['path'] .'/'. $info['file'];        if (file_exists($filename)) {          require_once $filename;          $result[$hook]['include files'][] = $filename;        }      }      if (isset($info['template']) && !isset($info['path'])) {        $result[$hook]['template'] = $path .'/'. $info['template'];      }      // If 'arguments' have been defined previously, carry them forward.      // This should happen if a theme overrides a Drupal defined theme      // function, for example.      if (!isset($info['arguments']) && isset($cache[$hook])) {        $result[$hook]['arguments'] = $cache[$hook]['arguments'];      }      // Likewise with theme paths. These are used for template naming suggestions.      // Theme implementations can occur in multiple paths. Suggestions should follow.      if (!isset($info['theme paths']) && isset($cache[$hook])) {        $result[$hook]['theme paths'] = $cache[$hook]['theme paths'];      }      // Check for sub-directories.      $result[$hook]['theme paths'][] = isset($info['path']) ? $info['path'] : $path;      // Check for default _preprocess_ functions. Ensure arrayness.      if (!isset($info['preprocess functions']) || !is_array($info['preprocess functions'])) {        $info['preprocess functions'] = array();        $prefixes = array();        if ($type == 'module') {          // Default preprocessor prefix.          $prefixes[] = 'template';          // Add all modules so they can intervene with their own preprocessors. This allows them          // to provide preprocess functions even if they are not the owner of the current hook.          $prefixes += module_list();        }        elseif ($type == 'theme_engine' || $type == 'base_theme_engine') {          // Theme engines get an extra set that come before the normally named preprocessors.          $prefixes[] = $name .'_engine';          // The theme engine also registers on behalf of the theme. The theme or engine name can be used.          $prefixes[] = $name;          $prefixes[] = $theme;        }        else {          // This applies when the theme manually registers their own preprocessors.          $prefixes[] = $name;        }        foreach ($prefixes as $prefix) {          if (function_exists($prefix .'_preprocess')) {            $info['preprocess functions'][] = $prefix .'_preprocess';          }          if (function_exists($prefix .'_preprocess_'. $hook)) {            $info['preprocess functions'][] = $prefix .'_preprocess_'. $hook;          }          if (!empty($info['original hook']) && function_exists($prefix .'_preprocess_'. $info['original hook'])) {            $info['preprocess functions'][] = $prefix .'_preprocess_'. $info['original hook'];          }        }      }      // Check for the override flag and prevent the cached preprocess functions from being used.      // This allows themes or theme engines to remove preprocessors set earlier in the registry build.      if (!empty($info['override preprocess functions'])) {        // Flag not needed inside the registry.        unset($result[$hook]['override preprocess functions']);      }      elseif (isset($cache[$hook]['preprocess functions']) && is_array($cache[$hook]['preprocess functions'])) {        $info['preprocess functions'] = array_merge($cache[$hook]['preprocess functions'], $info['preprocess functions']);      }      elseif (isset($info['original hook']) && isset($cache[$info['original hook']]['preprocess functions']) && is_array($cache[$info['original hook']]['preprocess functions'])) {        $info['preprocess functions'] = array_merge($cache[$info['original hook']]['preprocess functions'], $info['preprocess functions']);      }      $result[$hook]['preprocess functions'] = $info['preprocess functions'];    }    // Merge the newly created theme hooks into the existing cache.    $cache = array_merge($cache, $result);  }  // Let themes have preprocess functions even if they didn't register a template.  if ($type == 'theme' || $type == 'base_theme') {    foreach ($cache as $hook => $info) {      // Check only if it's a template and not registered by the theme or engine.      if (!empty($info['template']) && empty($result[$hook])) {        if (!isset($info['preprocess functions'])) {          $cache[$hook]['preprocess functions'] = array();        }        if (function_exists($name .'_preprocess')) {          $cache[$hook]['preprocess functions'][] = $name .'_preprocess';        }        if (function_exists($name .'_preprocess_'. $hook)) {          $cache[$hook]['preprocess functions'][] = $name .'_preprocess_'. $hook;        }        // Ensure uniqueness.        $cache[$hook]['preprocess functions'] = array_unique($cache[$hook]['preprocess functions']);      }    }  }}/** * Rebuild the hook theme_registry cache. * * @param $theme *   The loaded $theme object. * @param $base_theme *   An array of loaded $theme objects representing the ancestor themes in *   oldest first order. * @param theme_engine *   The name of the theme engine. */function _theme_build_registry($theme, $base_theme, $theme_engine) {  $cache = array();  // First, process the theme hooks advertised by modules. This will  // serve as the basic registry.  foreach (module_implements('theme') as $module) {    _theme_process_registry($cache, $module, 'module', $module, drupal_get_path('module', $module));  }  // Process each base theme.  foreach ($base_theme as $base) {    // If the base theme uses a theme engine, process its hooks.    $base_path = dirname($base->filename);    if ($theme_engine) {      _theme_process_registry($cache, $theme_engine, 'base_theme_engine', $base->name, $base_path);    }    _theme_process_registry($cache, $base->name, 'base_theme', $base->name, $base_path);  }  // And then the same thing, but for the theme.  if ($theme_engine) {    _theme_process_registry($cache, $theme_engine, 'theme_engine', $theme->name, dirname($theme->filename));  }  // Finally, hooks provided by the theme itself.  _theme_process_registry($cache, $theme->name, 'theme', $theme->name, dirname($theme->filename));  // Let modules alter the registry  drupal_alter('theme_registry', $cache);  return $cache;}/** * Provides a list of currently available themes. * * If the database is active then it will be retrieved from the database. * Otherwise it will retrieve a new list. * * @param $refresh *   Whether to reload the list of themes from the database. * @return *   An array of the currently available themes. */function list_themes($refresh = FALSE) {  static $list = array();  if ($refresh) {    $list = array();  }  if (empty($list)) {    $list = array();    $themes = array();    // Extract from the database only when it is available.    // Also check that the site is not in the middle of an install or update.    if (db_is_active() && !defined('MAINTENANCE_MODE')) {      $result = db_query("SELECT * FROM {system} WHERE type = '%s'", 'theme');      while ($theme = db_fetch_object($result)) {        if (file_exists($theme->filename)) {          $theme->info = unserialize($theme->info);          $themes[] = $theme;        }      }    }    else {      // Scan the installation when the database should not be read.      $themes = _system_theme_data();    }    foreach ($themes as $theme) {      foreach ($theme->info['stylesheets'] as $media => $stylesheets) {        foreach ($stylesheets as $stylesheet => $path) {          $theme->stylesheets[$media][$stylesheet] = $path;        }      }      foreach ($theme->info['scripts'] as $script => $path) {        if (file_exists($path)) {          $theme->scripts[$script] = $path;        }      }      if (isset($theme->info['engine'])) {        $theme->engine = $theme->info['engine'];      }      if (isset($theme->info['base theme'])) {        $theme->base_theme = $theme->info['base theme'];      }      // Status is normally retrieved from the database. Add zero values when      // read from the installation directory to prevent notices.      if (!isset($theme->status)) {        $theme->status = 0;      }      $list[$theme->name] = $theme;    }  }  return $list;}/** * Generate the themed output. * * All requests for theme hooks must go through this function. It examines * the request and routes it to the appropriate theme function. The theme * registry is checked to determine which implementation to use, which may * be a function or a template. * * If the implementation is a function, it is executed and its return value * passed along. * * If the implementation is a template, the arguments are converted to a * $variables array. This array is then modified by the module implementing * the hook, theme engine (if applicable) and the theme. The following * functions may be used to modify the $variables array. They are processed in * this order when available: * * - template_preprocess(&$variables) *   This sets a default set of variables for all template implementations. * * - template_preprocess_HOOK(&$variables) *   This is the first preprocessor called specific to the hook; it should be *   implemented by the module that registers it. * * - MODULE_preprocess(&$variables) *   This will be called for all templates; it should only be used if there *   is a real need. It's purpose is similar to template_preprocess(). * * - MODULE_preprocess_HOOK(&$variables) *   This is for modules that want to alter or provide extra variables for *   theming hooks not registered to itself. For example, if a module named *   "foo" wanted to alter the $submitted variable for the hook "node" a *   preprocess function of foo_preprocess_node() can be created to intercept *   and alter the variable. * * - ENGINE_engine_preprocess(&$variables) *   This function should only be implemented by theme engines and exists *   so that it can set necessary variables for all hooks. * * - ENGINE_engine_preprocess_HOOK(&$variables) *   This is the same as the previous function, but it is called for a single *   theming hook. * * - ENGINE_preprocess(&$variables) *   This is meant to be used by themes that utilize a theme engine. It is *   provided so that the preprocessor is not locked into a specific theme. *   This makes it easy to share and transport code but theme authors must be *   careful to prevent fatal re-declaration errors when using sub-themes that *   have their own preprocessor named exactly the same as its base theme. In *   the default theme engine (PHPTemplate), sub-themes will load their own *   template.php file in addition to the one used for its parent theme. This *   increases the risk for these errors. A good practice is to use the engine *   name for the base theme and the theme name for the sub-themes to minimize *   this possibility. * * - ENGINE_preprocess_HOOK(&$variables) *   The same applies from the previous function, but it is called for a *   specific hook. * * - THEME_preprocess(&$variables) *   These functions are based upon the raw theme; they should primarily be *   used by themes that do not use an engine or by sub-themes. It serves the *   same purpose as ENGINE_preprocess(). * * - THEME_preprocess_HOOK(&$variables) *   The same applies from the previous function, but it is called for a *   specific hook. * * There are two special variables that these hooks can set: *   'template_file' and 'template_files'. These will be merged together *   to form a list of 'suggested' alternate template files to use, in *   reverse order of priority. template_file will always be a higher *   priority than items in template_files. theme() will then look for these *   files, one at a time, and use the first one *   that exists. * @param $hook *   The name of the theme function to call. May be an array, in which *   case the first hook that actually has an implementation registered *   will be used. This can be used to choose 'fallback' theme implementations, *   so that if the specific theme hook isn't implemented anywhere, a more *   generic one will be used. This can allow themes to create specific theme *   implementations for named objects. * @param ... *   Additional arguments to pass along to the theme function. * @return *   An HTML string that generates the themed output. */function theme() {  $args = func_get_args();  $hook = array_shift($args);  static $hooks = NULL;  if (!isset($hooks)) {    init_theme();    $hooks = theme_get_registry();  }  if (is_array($hook)) {    foreach ($hook as $candidate) {      if (isset($hooks[$candidate])) {        break;      }    }    $hook = $candidate;  }  if (!isset($hooks[$hook])) {    return;  }  $info = $hooks[$hook];  global $theme_path;  $temp = $theme_path;  // point path_to_theme() to the currently used theme path:  $theme_path = $hooks[$hook]['theme path'];  // Include a file if the theme function or preprocess function is held elsewhere.  if (!empty($info['include files'])) {    foreach ($info['include files'] as $include_file) {      include_once($include_file);    }  }  // Handle compatibility with theme_registry_alters to prevent failures.  if (!empty($info['file'])) {    static $included_files = array();    $include_file = $info['file'];    if (!empty($info['path'])) {      $include_file = $info['path'] .'/'. $include_file;    }    if (empty($included_files[$include_file])) {      // Statically cache files we've already tried to include so we don't      // run unnecessary file_exists calls.      $included_files[$include_file] = TRUE;      if (file_exists('./'. $include_file)) {        include_once('./'. $include_file);      }    }  }  if (isset($info['function'])) {    // The theme call is a function.    $output = call_user_func_array($info['function'], $args);  }  else {    // The theme call is a template.    $variables = array(      'template_files' => array()    );    if (!empty($info['arguments'])) {      $count = 0;      foreach ($info['arguments'] as $name => $default) {        $variables[$name] = isset($args[$count]) ? $args[$count] : $default;        $count++;      }    }    // default render function and extension.    $render_function = 'theme_render_template';    $extension = '.tpl.php';    // Run through the theme engine variables, if necessary    global $theme_engine;    if (isset($theme_engine)) {      // If theme or theme engine is implementing this, it may have      // a different extension and a different renderer.      if ($hooks[$hook]['type'] != 'module') {        if (function_exists($theme_engine .'_render_template')) {          $render_function = $theme_engine .'_render_template';        }        $extension_function = $theme_engine .'_extension';        if (function_exists($extension_function)) {          $extension = $extension_function();        }      }    }    if (isset($info['preprocess functions']) && is_array($info['preprocess functions'])) {      // This construct ensures that we can keep a reference through      // call_user_func_array.      $args = array(&$variables, $hook);      foreach ($info['preprocess functions'] as $preprocess_function) {        if (function_exists($preprocess_function)) {          call_user_func_array($preprocess_function, $args);        }      }    }    // Get suggestions for alternate templates out of the variables    // that were set. This lets us dynamically choose a template    // from a list. The order is FILO, so this array is ordered from    // least appropriate first to most appropriate last.    $suggestions = array();    if (isset($variables['template_files'])) {      $suggestions = $variables['template_files'];    }    if (isset($variables['template_file'])) {      $suggestions[] = $variables['template_file'];    }    if ($suggestions) {      $template_file = drupal_discover_template($info['theme paths'], $suggestions, $extension);    }    if (empty($template_file)) {      $template_file = $hooks[$hook]['template'] . $extension;      if (isset($hooks[$hook]['path'])) {        $template_file = $hooks[$hook]['path'] .'/'. $template_file;      }    }    $output = $render_function($template_file, $variables);  }  // restore path_to_theme()  $theme_path = $temp;  // Add final markup to the full page.  if ($hook == 'page' || $hook == 'book_export_html') {    $output = drupal_final_markup($output);  }  return $output;}/** * Choose which template file to actually render. These are all suggested * templates from themes and modules. Theming implementations can occur on * multiple levels. All paths are checked to account for this. */function drupal_discover_template($paths, $suggestions, $extension = '.tpl.php') {  global $theme_engine;  // Remove slashes or null to prevent files from being included from  // an unexpected location (especially on Windows servers).  $extension = str_replace(array("/", "\\", "\0"), '', $extension);  // Loop through all paths and suggestions in FIFO order.  $suggestions = array_reverse($suggestions);  $paths = array_reverse($paths);  foreach ($suggestions as $suggestion) {    if (!empty($suggestion)) {      $suggestion = str_replace(array("/", "\\", "\0"), '', $suggestion);      foreach ($paths as $path) {        if (file_exists($file = $path .'/'. $suggestion . $extension)) {          return $file;        }      }    }  }}/** * Return the path to the current themed element. * * It can point to the active theme or the module handling a themed implementation. * For example, when invoked within the scope of a theming call it will depend * on where the theming function is handled. If implemented from a module, it * will point to the module. If implemented from the active theme, it will point * to the active theme. When called outside the scope of a theming call, it will * always point to the active theme. */function path_to_theme() {  global $theme_path;  if (!isset($theme_path)) {    init_theme();  }  return $theme_path;}/** * Find overridden theme functions. Called by themes and/or theme engines to * easily discover theme functions. * * @param $cache *   The existing cache of theme hooks to test against. * @param $prefixes *   An array of prefixes to test, in reverse order of importance. * * @return $templates *   The functions found, suitable for returning from hook_theme; */function drupal_find_theme_functions($cache, $prefixes) {  $templates = array();  $functions = get_defined_functions();  foreach ($cache as $hook => $info) {    foreach ($prefixes as $prefix) {      if (!empty($info['pattern'])) {        $matches = preg_grep('/^'. $prefix .'_'. $info['pattern'] .'/', $functions['user']);        if ($matches) {          foreach ($matches as $match) {            $new_hook = str_replace($prefix .'_', '', $match);            $templates[$new_hook] = array(              'function' => $match,              'arguments' => $info['arguments'],              'original hook' => $hook,              'include files' => $info['include files'],            );          }        }      }      if (function_exists($prefix .'_'. $hook)) {        $templates[$hook] = array(          'function' => $prefix .'_'. $hook,          'include files' => $info['include files'],        );        // Ensure that the pattern is maintained from base themes to its sub-themes.        // Each sub-theme will have their functions scanned so the pattern must be        // held for subsequent runs.        if (isset($info['pattern'])) {          $templates[$hook]['pattern'] = $info['pattern'];        }        // Also ensure that the 'file' property is maintained, because it probably        // contains the preprocess.      }    }  }  return $templates;}/** * Find overridden theme templates. Called by themes and/or theme engines to * easily discover templates. * * @param $cache *   The existing cache of theme hooks to test against. * @param $extension *   The extension that these templates will have. * @param $path *   The path to search. */function drupal_find_theme_templates($cache, $extension, $path) {  $templates = array();  // Collect paths to all sub-themes grouped by base themes. These will be  // used for filtering. This allows base themes to have sub-themes in its  // folder hierarchy without affecting the base themes template discovery.  $theme_paths = array();  foreach (list_themes() as $theme_info) {    if (!empty($theme_info->base_theme)) {      $theme_paths[$theme_info->base_theme][$theme_info->name] = dirname($theme_info->filename);    }  }  foreach ($theme_paths as $basetheme => $subthemes) {    foreach ($subthemes as $subtheme => $subtheme_path) {      if (isset($theme_paths[$subtheme])) {        $theme_paths[$basetheme] = array_merge($theme_paths[$basetheme], $theme_paths[$subtheme]);      }    }  }  global $theme;  $subtheme_paths = isset($theme_paths[$theme]) ? $theme_paths[$theme] : array();  // Escape the periods in the extension.  $regex = str_replace('.', '\.', $extension) .'$';  // Because drupal_system_listing works the way it does, we check for real  // templates separately from checking for patterns.  $files = drupal_system_listing($regex, $path, 'name', 0);  foreach ($files as $template => $file) {    // Ignore sub-theme templates for the current theme.    if (strpos($file->filename, str_replace($subtheme_paths, '', $file->filename)) !== 0) {      continue;    }    // Chop off the remaining extensions if there are any. $template already    // has the rightmost extension removed, but there might still be more,    // such as with .tpl.php, which still has .tpl in $template at this point.    if (($pos = strpos($template, '.')) !== FALSE) {      $template = substr($template, 0, $pos);    }    // Transform - in filenames to _ to match function naming scheme    // for the purposes of searching.    $hook = strtr($template, '-', '_');    if (isset($cache[$hook])) {      $templates[$hook] = array(        'template' => $template,        'path' => dirname($file->filename),        'include files' => $cache[$hook]['include files'],      );    }    // Ensure that the pattern is maintained from base themes to its sub-themes.    // Each sub-theme will have their templates scanned so the pattern must be    // held for subsequent runs.    if (isset($cache[$hook]['pattern'])) {      $templates[$hook]['pattern'] = $cache[$hook]['pattern'];    }  }  $patterns = array_keys($files);  foreach ($cache as $hook => $info) {    if (!empty($info['pattern'])) {      // Transform _ in pattern to - to match file naming scheme      // for the purposes of searching.      $pattern = strtr($info['pattern'], '_', '-');      $matches = preg_grep('/^'. $pattern .'/', $patterns);      if ($matches) {        foreach ($matches as $match) {          $file = substr($match, 0, strpos($match, '.'));          // Put the underscores back in for the hook name and register this pattern.          $templates[strtr($file, '-', '_')] = array(            'template' => $file,            'path' => dirname($files[$match]->filename),            'arguments' => $info['arguments'],            'original hook' => $hook,            'include files' => $info['include files'],          );        }      }    }  }  return $templates;}/** * Retrieve an associative array containing the settings for a theme. * * The final settings are arrived at by merging the default settings, * the site-wide settings, and the settings defined for the specific theme. * If no $key was specified, only the site-wide theme defaults are retrieved. * * The default values for each of settings are also defined in this function. * To add new settings, add their default values here, and then add form elements * to system_theme_settings() in system.module. * * @param $key *  The template/style value for a given theme. * * @return *   An associative array containing theme settings. */function theme_get_settings($key = NULL) {  $defaults = array(    'mission'                       =>  '',    'default_logo'                  =>  1,    'logo_path'                     =>  '',    'default_favicon'               =>  1,    'favicon_path'                  =>  '',    'primary_links'                 =>  1,    'secondary_links'               =>  1,    'toggle_logo'                   =>  1,    'toggle_favicon'                =>  1,    'toggle_name'                   =>  1,    'toggle_search'                 =>  1,    'toggle_slogan'                 =>  0,    'toggle_mission'                =>  1,    'toggle_node_user_picture'      =>  0,    'toggle_comment_user_picture'   =>  0,    'toggle_primary_links'          =>  1,    'toggle_secondary_links'        =>  1,  );  if (module_exists('node')) {    foreach (node_get_types() as $type => $name) {      $defaults['toggle_node_info_'. $type] = 1;    }  }  $settings = array_merge($defaults, variable_get('theme_settings', array()));  if ($key) {    $settings = array_merge($settings, variable_get(str_replace('/', '_', 'theme_'. $key .'_settings'), array()));  }  // Only offer search box if search.module is enabled.  if (!module_exists('search') || !user_access('search content')) {    $settings['toggle_search'] = 0;  }  return $settings;}/** * Retrieve a setting for the current theme. * This function is designed for use from within themes & engines * to determine theme settings made in the admin interface. * * Caches values for speed (use $refresh = TRUE to refresh cache) * * @param $setting_name *  The name of the setting to be retrieved. * * @param $refresh *  Whether to reload the cache of settings. * * @return *   The value of the requested setting, NULL if the setting does not exist. */function theme_get_setting($setting_name, $refresh = FALSE) {  global $theme_key;  static $settings;  if (empty($settings) || $refresh) {    $settings = theme_get_settings($theme_key);    $themes = list_themes();    $theme_object = $themes[$theme_key];    if ($settings['mission'] == '') {      $settings['mission'] = variable_get('site_mission', '');    }    if (!$settings['toggle_mission']) {      $settings['mission'] = '';    }    if ($settings['toggle_logo']) {      if ($settings['default_logo']) {        $settings['logo'] = base_path() . dirname($theme_object->filename) .'/logo.png';      }      elseif ($settings['logo_path']) {        $settings['logo'] = base_path() . $settings['logo_path'];      }    }    if ($settings['toggle_favicon']) {      if ($settings['default_favicon']) {        if (file_exists($favicon = dirname($theme_object->filename) .'/favicon.ico')) {          $settings['favicon'] = base_path() . $favicon;        }        else {          $settings['favicon'] = base_path() .'misc/favicon.ico';        }      }      elseif ($settings['favicon_path']) {        $settings['favicon'] = base_path() . $settings['favicon_path'];      }      else {        $settings['toggle_favicon'] = FALSE;      }    }  }  return isset($settings[$setting_name]) ? $settings[$setting_name] : NULL;}/** * Render a system default template, which is essentially a PHP template. * * @param $template_file *   The filename of the template to render. Note that this will overwrite *   anything stored in $variables['template_file'] if using a preprocess hook. * @param $variables *   A keyed array of variables that will appear in the output. * * @return *   The output generated by the template. */function theme_render_template($template_file, $variables) {  extract($variables, EXTR_SKIP);  // Extract the variables to a local namespace  ob_start();                      // Start output buffering  include "./$template_file";      // Include the template file  $contents = ob_get_contents();   // Get the contents of the buffer  ob_end_clean();                  // End buffering and discard  return $contents;                // Return the contents}/** * @defgroup themeable Default theme implementations * @{ * Functions and templates that present output to the user, and can be * implemented by themes. * * Drupal's presentation layer is a pluggable system known as the theme * layer. Each theme can take control over most of Drupal's output, and * has complete control over the CSS. * * Inside Drupal, the theme layer is utilized by the use of the theme() * function, which is passed the name of a component (the theme hook) * and several arguments. For example, theme('table', $header, $rows); * Additionally, the theme() function can take an array of theme * hooks, which can be used to provide 'fallback' implementations to * allow for more specific control of output. For example, the function: * theme(array('table__foo', 'table'), $header, $rows) would look to see if * 'table__foo' is registered anywhere; if it is not, it would 'fall back' * to the generic 'table' implementation. This can be used to attach specific * theme functions to named objects, allowing the themer more control over * specific types of output. * * As of Drupal 6, every theme hook is required to be registered by the * module that owns it, so that Drupal can tell what to do with it and * to make it simple for themes to identify and override the behavior * for these calls. * * The theme hooks are registered via hook_theme(), which returns an * array of arrays with information about the hook. It describes the * arguments the function or template will need, and provides * defaults for the template in case they are not filled in. If the default * implementation is a function, by convention it is named theme_HOOK(). * * Each module should provide a default implementation for theme_hooks that * it registers. This implementation may be either a function or a template; * if it is a function it must be specified via hook_theme(). By convention, * default implementations of theme hooks are named theme_HOOK. Default * template implementations are stored in the module directory. * * Drupal's default template renderer is a simple PHP parsing engine that * includes the template and stores the output. Drupal's theme engines * can provide alternate template engines, such as XTemplate, Smarty and * PHPTal. The most common template engine is PHPTemplate (included with * Drupal and implemented in phptemplate.engine, which uses Drupal's default * template renderer. * * In order to create theme-specific implementations of these hooks, * themes can implement their own version of theme hooks, either as functions * or templates. These implementations will be used instead of the default * implementation. If using a pure .theme without an engine, the .theme is * required to implement its own version of hook_theme() to tell Drupal what * it is implementing; themes utilizing an engine will have their well-named * theming functions automatically registered for them. While this can vary * based upon the theme engine, the standard set by phptemplate is that theme * functions should be named either phptemplate_HOOK or THEMENAME_HOOK. For * example, for Drupal's default theme (Garland) to implement the 'table' hook, * the phptemplate.engine would find phptemplate_table() or garland_table(). * The ENGINE_HOOK() syntax is preferred, as this can be used by sub-themes * (which are themes that share code but use different stylesheets). * * The theme system is described and defined in theme.inc. * * @see theme() * @see hook_theme() *//** * Formats text for emphasized display in a placeholder inside a sentence. * Used automatically by t(). * * @param $text *   The text to format (plain-text). * @return *   The formatted text (html). */function theme_placeholder($text) {  return '<em>'. check_plain($text) .'</em>';}/** * Return a themed set of status and/or error messages. The messages are grouped * by type. * * @param $display *   (optional) Set to 'status' or 'error' to display only messages of that type. * * @return *   A string containing the messages. */function theme_status_messages($display = NULL) {  $output = '';  foreach (drupal_get_messages($display) as $type => $messages) {    $output .= "<div class=\"messages $type\">\n";    if (count($messages) > 1) {      $output .= " <ul>\n";      foreach ($messages as $message) {        $output .= '  <li>'. $message ."</li>\n";      }      $output .= " </ul>\n";    }    else {      $output .= $messages[0];    }    $output .= "</div>\n";  }  return $output;}/** * Return a themed set of links. * * @param $links *   A keyed array of links to be themed. * @param $attributes *   A keyed array of attributes * @return *   A string containing an unordered list of links. */function theme_links($links, $attributes = array('class' => 'links')) {  global $language;  $output = '';  if (count($links) > 0) {    $output = '<ul'. drupal_attributes($attributes) .'>';    $num_links = count($links);    $i = 1;    foreach ($links as $key => $link) {      $class = $key;      // Add first, last and active classes to the list of links to help out themers.      if ($i == 1) {        $class .= ' first';      }      if ($i == $num_links) {        $class .= ' last';      }      if (isset($link['href']) && ($link['href'] == $_GET['q'] || ($link['href'] == '<front>' && drupal_is_front_page()))          && (empty($link['language']) || $link['language']->language == $language->language)) {        $class .= ' active';      }      $output .= '<li'. drupal_attributes(array('class' => $class)) .'>';      if (isset($link['href'])) {        // Pass in $link as $options, they share the same keys.        $output .= l($link['title'], $link['href'], $link);      }      else if (!empty($link['title'])) {        // Some links are actually not links, but we wrap these in <span> for adding title and class attributes        if (empty($link['html'])) {          $link['title'] = check_plain($link['title']);        }        $span_attributes = '';        if (isset($link['attributes'])) {          $span_attributes = drupal_attributes($link['attributes']);        }        $output .= '<span'. $span_attributes .'>'. $link['title'] .'</span>';      }      $i++;      $output .= "</li>\n";    }    $output .= '</ul>';  }  return $output;}/** * Return a themed image. * * @param $path *   Either the path of the image file (relative to base_path()) or a full URL. * @param $alt *   The alternative text for text-based browsers. * @param $title *   The title text is displayed when the image is hovered in some popular browsers. * @param $attributes *   Associative array of attributes to be placed in the img tag. * @param $getsize *   If set to TRUE, the image's dimension are fetched and added as width/height attributes. * @return *   A string containing the image tag. */function theme_image($path, $alt = '', $title = '', $attributes = NULL, $getsize = TRUE) {  if (!$getsize || (is_file($path) && (list($width, $height, $type, $image_attributes) = @getimagesize($path)))) {    $attributes = drupal_attributes($attributes);    $url = (url($path) == $path) ? $path : (base_path() . $path);    return '<img src="'. check_url($url) .'" alt="'. check_plain($alt) .'" title="'. check_plain($title) .'" '. (isset($image_attributes) ? $image_attributes : '') . $attributes .' />';  }}/** * Return a themed breadcrumb trail. * * @param $breadcrumb *   An array containing the breadcrumb links. * @return a string containing the breadcrumb output. */function theme_breadcrumb($breadcrumb) {  if (!empty($breadcrumb)) {    return '<div class="breadcrumb">'. implode('  ', $breadcrumb) .'</div>';  }}/** * Return a themed help message. * * @return a string containing the helptext for the current page. */function theme_help() {  if ($help = menu_get_active_help()) {    return '<div class="help">'. $help .'</div>';  }}/** * Return a themed submenu, typically displayed under the tabs. * * @param $links *   An array of links. */function theme_submenu($links) {  return '<div class="submenu">'. implode(' | ', $links) .'</div>';}/** * Return a themed table. * * @param $header *   An array containing the table headers. Each element of the array can be *   either a localized string or an associative array with the following keys: *   - "data": The localized title of the table column. *   - "field": The database field represented in the table column (required if *     user is to be able to sort on this column). *   - "sort": A default sort order for this column ("asc" or "desc"). *   - Any HTML attributes, such as "colspan", to apply to the column header cell. * @param $rows *   An array of table rows. Every row is an array of cells, or an associative *   array with the following keys: *   - "data": an array of cells *   - Any HTML attributes, such as "class", to apply to the table row. * *   Each cell can be either a string or an associative array with the following keys: *   - "data": The string to display in the table cell. *   - "header": Indicates this cell is a header. *   - Any HTML attributes, such as "colspan", to apply to the table cell. * *   Here's an example for $rows: *   @code *   $rows = array( *     // Simple row *     array( *       'Cell 1', 'Cell 2', 'Cell 3' *     ), *     // Row with attributes on the row and some of its cells. *     array( *       'data' => array('Cell 1', array('data' => 'Cell 2', 'colspan' => 2)), 'class' => 'funky' *     ) *   ); *   @endcode * * @param $attributes *   An array of HTML attributes to apply to the table tag. * @param $caption *   A localized string to use for the <caption> tag. * @return *   An HTML string representing the table. */function theme_table($header, $rows, $attributes = array(), $caption = NULL) {  // Add sticky headers, if applicable.  if (count($header)) {    drupal_add_js('misc/tableheader.js');    // Add 'sticky-enabled' class to the table to identify it for JS.    // This is needed to target tables constructed by this function.    $attributes['class'] = empty($attributes['class']) ? 'sticky-enabled' : ($attributes['class'] .' sticky-enabled');  }  $output = '<table'. drupal_attributes($attributes) .">\n";  if (isset($caption)) {    $output .= '<caption>'. $caption ."</caption>\n";  }  // Format the table header:  if (count($header)) {    $ts = tablesort_init($header);    // HTML requires that the thead tag has tr tags in it followed by tbody    // tags. Using ternary operator to check and see if we have any rows.    $output .= (count($rows) ? ' <thead><tr>' : ' <tr>');    foreach ($header as $cell) {      $cell = tablesort_header($cell, $header, $ts);      $output .= _theme_table_cell($cell, TRUE);    }    // Using ternary operator to close the tags based on whether or not there are rows    $output .= (count($rows) ? " </tr></thead>\n" : "</tr>\n");  }  else {    $ts = array();  }  // Format the table rows:  if (count($rows)) {    $output .= "<tbody>\n";    $flip = array('even' => 'odd', 'odd' => 'even');    $class = 'even';    foreach ($rows as $number => $row) {      $attributes = array();      // Check if we're dealing with a simple or complex row      if (isset($row['data'])) {        foreach ($row as $key => $value) {          if ($key == 'data') {            $cells = $value;          }          else {            $attributes[$key] = $value;          }        }      }      else {        $cells = $row;      }      if (count($cells)) {        // Add odd/even class        $class = $flip[$class];        if (isset($attributes['class'])) {          $attributes['class'] .= ' '. $class;        }        else {          $attributes['class'] = $class;        }        // Build row        $output .= ' <tr'. drupal_attributes($attributes) .'>';        $i = 0;        foreach ($cells as $cell) {          $cell = tablesort_cell($cell, $header, $ts, $i++);          $output .= _theme_table_cell($cell);        }        $output .= " </tr>\n";      }    }    $output .= "</tbody>\n";  }  $output .= "</table>\n";  return $output;}/** * Returns a header cell for tables that have a select all functionality. */function theme_table_select_header_cell() {  drupal_add_js('misc/tableselect.js');  return array('class' => 'select-all');}/** * Return a themed sort icon. * * @param $style *   Set to either asc or desc. This sets which icon to show. * @return *   A themed sort icon. */function theme_tablesort_indicator($style) {  if ($style == "asc") {    return theme('image', 'misc/arrow-asc.png', t('sort icon'), t('sort ascending'));  }  else {    return theme('image', 'misc/arrow-desc.png', t('sort icon'), t('sort descending'));  }}/** * Return a themed box. * * @param $title *   The subject of the box. * @param $content *   The content of the box. * @param $region *   The region in which the box is displayed. * @return *   A string containing the box output. */function theme_box($title, $content, $region = 'main') {  $output = '<h2 class="title">'. $title .'</h2><div>'. $content .'</div>';  return $output;}/** * Return a themed marker, useful for marking new or updated * content. * * @param $type *   Number representing the marker type to display * @see MARK_NEW, MARK_UPDATED, MARK_READ * @return *   A string containing the marker. */function theme_mark($type = MARK_NEW) {  global $user;  if ($user->uid) {    if ($type == MARK_NEW) {      return ' <span class="marker">'. t('new') .'</span>';    }    else if ($type == MARK_UPDATED) {      return ' <span class="marker">'. t('updated') .'</span>';    }  }}/** * Return a themed list of items. * * @param $items *   An array of items to be displayed in the list. If an item is a string, *   then it is used as is. If an item is an array, then the "data" element of *   the array is used as the contents of the list item. If an item is an array *   with a "children" element, those children are displayed in a nested list. *   All other elements are treated as attributes of the list item element. * @param $title *   The title of the list. * @param $type *   The type of list to return (e.g. "ul", "ol") * @param $attributes *   The attributes applied to the list element. * @return *   A string containing the list output. */function theme_item_list($items = array(), $title = NULL, $type = 'ul', $attributes = NULL) {  $output = '<div class="item-list">';  if (isset($title)) {    $output .= '<h3>'. $title .'</h3>';  }  if (!empty($items)) {    $output .= "<$type". drupal_attributes($attributes) .'>';    $num_items = count($items);    foreach ($items as $i => $item) {      $attributes = array();      $children = array();      if (is_array($item)) {        foreach ($item as $key => $value) {          if ($key == 'data') {            $data = $value;          }          elseif ($key == 'children') {            $children = $value;          }          else {            $attributes[$key] = $value;          }        }      }      else {        $data = $item;      }      if (count($children) > 0) {        $data .= theme_item_list($children, NULL, $type, $attributes); // Render nested list      }      if ($i == 0) {        $attributes['class'] = empty($attributes['class']) ? 'first' : ($attributes['class'] .' first');      }      if ($i == $num_items - 1) {        $attributes['class'] = empty($attributes['class']) ? 'last' : ($attributes['class'] .' last');      }      $output .= '<li'. drupal_attributes($attributes) .'>'. $data ."</li>\n";    }    $output .= "</$type>";  }  $output .= '</div>';  return $output;}/** * Returns code that emits the 'more help'-link. */function theme_more_help_link($url) {  return '<div class="more-help-link">'. t('[<a href="@link">more help...</a>]', array('@link' => check_url($url))) .'</div>';}/** * Return code that emits an XML icon. * * For most use cases, this function has been superseded by theme_feed_icon(). * * @see theme_feed_icon() * @param $url *   The url of the feed. */function theme_xml_icon($url) {  if ($image = theme('image', 'misc/xml.png', t('XML feed'), t('XML feed'))) {    return '<a href="'. check_url($url) .'" class="xml-icon">'. $image .'</a>';  }}/** * Return code that emits an feed icon. * * @param $url *   The url of the feed. * @param $title *   A descriptive title of the feed.  */function theme_feed_icon($url, $title) {  if ($image = theme('image', 'misc/feed.png', t('Syndicate content'), $title)) {    return '<a href="'. check_url($url) .'" class="feed-icon">'. $image .'</a>';  }}/** * Returns code that emits the 'more' link used on blocks. * * @param $url *   The url of the main page * @param $title *   A descriptive verb for the link, like 'Read more' */function theme_more_link($url, $title) {  return '<div class="more-link">'. t('<a href="@link" title="@title">more</a>', array('@link' => check_url($url), '@title' => $title)) .'</div>';}/** * Execute hook_footer() which is run at the end of the page right before the * close of the body tag. * * @param $main (optional) *   Whether the current page is the front page of the site. * @return *   A string containing the results of the hook_footer() calls. */function theme_closure($main = 0) {  $footer = module_invoke_all('footer', $main);  return implode("\n", $footer) . drupal_get_js('footer');}/** * Return a set of blocks available for the current user. * * @param $region *   Which set of blocks to retrieve. * @return *   A string containing the themed blocks for this region. */function theme_blocks($region) {  $output = '';  if ($list = block_list($region)) {    foreach ($list as $key => $block) {      // $key == <i>module</i>_<i>delta</i>      $output .= theme('block', $block);    }  }  // Add any content assigned to this region through drupal_set_content() calls.  $output .= drupal_get_content($region);  return $output;}/** * Format a username. * * @param $object *   The user object to format, usually returned from user_load(). * @return *   A string containing an HTML link to the user's page if the passed object *   suggests that this is a site user. Otherwise, only the username is returned. */function theme_username($object) {  if ($object->uid && $object->name) {    // Shorten the name when it is too long or it will break many tables.    if (drupal_strlen($object->name) > 20) {      $name = drupal_substr($object->name, 0, 15) .'...';    }    else {      $name = $object->name;    }    if (user_access('access user profiles')) {      $output = l($name, 'user/'. $object->uid, array('attributes' => array('title' => t('View user profile.'))));    }    else {      $output = check_plain($name);    }  }  else if ($object->name) {    // Sometimes modules display content composed by people who are    // not registered members of the site (e.g. mailing list or news    // aggregator modules). This clause enables modules to display    // the true author of the content.    if (!empty($object->homepage)) {      $output = l($object->name, $object->homepage, array('attributes' => array('rel' => 'nofollow')));    }    else {      $output = check_plain($object->name);    }    $output .= ' ('. t('not verified') .')';  }  else {    $output = check_plain(variable_get('anonymous', t('Anonymous')));  }  return $output;}/** * Return a themed progress bar. * * @param $percent *   The percentage of the progress. * @param $message *   A string containing information to be displayed. * @return *   A themed HTML string representing the progress bar. */function theme_progress_bar($percent, $message) {  $output = '<div id="progress" class="progress">';  $output .= '<div class="bar"><div class="filled" style="width: '. $percent .'%"></div></div>';  $output .= '<div class="percentage">'. $percent .'%</div>';  $output .= '<div class="message">'. $message .'</div>';  $output .= '</div>';  return $output;}/** * Create a standard indentation div. Used for drag and drop tables. * * @param $size *   Optional. The number of indentations to create. * @return *   A string containing indentations. */function theme_indentation($size = 1) {  $output = '';  for ($n = 0; $n < $size; $n++) {    $output .= '<div class="indentation">&nbsp;</div>';  }  return $output;}/** * @} End of "defgroup themeable". */function _theme_table_cell($cell, $header = FALSE) {  $attributes = '';  if (is_array($cell)) {    $data = isset($cell['data']) ? $cell['data'] : '';    $header |= isset($cell['header']);    unset($cell['data']);    unset($cell['header']);    $attributes = drupal_attributes($cell);  }  else {    $data = $cell;  }  if ($header) {    $output = "<th$attributes>$data</th>";  }  else {    $output = "<td$attributes>$data</td>";  }  return $output;}/** * Adds a default set of helper variables for preprocess functions and * templates. This comes in before any other preprocess function which makes * it possible to be used in default theme implementations (non-overriden * theme functions). */function template_preprocess(&$variables, $hook) {  global $user;  static $count = array();  // Track run count for each hook to provide zebra striping.  // See "template_preprocess_block()" which provides the same feature specific to blocks.  $count[$hook] = isset($count[$hook]) && is_int($count[$hook]) ? $count[$hook] : 1;  $variables['zebra'] = ($count[$hook] % 2) ? 'odd' : 'even';  $variables['id'] = $count[$hook]++;  // Tell all templates where they are located.  $variables['directory'] = path_to_theme();  // Set default variables that depend on the database.  $variables['is_admin']            = FALSE;  $variables['is_front']            = FALSE;  $variables['logged_in']           = FALSE;  if ($variables['db_is_active'] = db_is_active()  && !defined('MAINTENANCE_MODE')) {    // Check for administrators.    if (user_access('access administration pages')) {      $variables['is_admin'] = TRUE;    }    // Flag front page status.    $variables['is_front'] = drupal_is_front_page();    // Tell all templates by which kind of user they're viewed.    $variables['logged_in'] = ($user->uid > 0);    // Provide user object to all templates    $variables['user'] = $user;  }}/** * Process variables for page.tpl.php * * Most themes utilize their own copy of page.tpl.php. The default is located * inside "modules/system/page.tpl.php". Look in there for the full list of * variables. * * Uses the arg() function to generate a series of page template suggestions * based on the current path. * * Any changes to variables in this preprocessor should also be changed inside * template_preprocess_maintenance_page() to keep all them consistent. * * The $variables array contains the following arguments: * - $content * - $show_blocks * * @see page.tpl.php */function template_preprocess_page(&$variables) {  // Add favicon  if (theme_get_setting('toggle_favicon')) {    drupal_set_html_head('<link rel="shortcut icon" href="'. check_url(theme_get_setting('favicon')) .'" type="image/x-icon" />');  }  global $theme;  // Populate all block regions.  $regions = system_region_list($theme);  // Load all region content assigned via blocks.  foreach (array_keys($regions) as $region) {    // Prevent left and right regions from rendering blocks when 'show_blocks' == FALSE.    if (!(!$variables['show_blocks'] && ($region == 'left' || $region == 'right'))) {      $blocks = theme('blocks', $region);    }    else {      $blocks = '';    }    // Assign region to a region variable.    isset($variables[$region]) ? $variables[$region] .= $blocks : $variables[$region] = $blocks;  }  // Set up layout variable.  $variables['layout'] = 'none';  if (!empty($variables['left'])) {    $variables['layout'] = 'left';  }  if (!empty($variables['right'])) {    $variables['layout'] = ($variables['layout'] == 'left') ? 'both' : 'right';  }  // Set mission when viewing the frontpage.  if (drupal_is_front_page()) {    $mission = filter_xss_admin(theme_get_setting('mission'));  }  // Construct page title  if (drupal_get_title()) {    $head_title = array(strip_tags(drupal_get_title()), variable_get('site_name', 'Drupal'));  }  else {    $head_title = array(variable_get('site_name', 'Drupal'));    if (variable_get('site_slogan', '')) {      $head_title[] = variable_get('site_slogan', '');    }  }  $variables['head_title']        = implode(' | ', $head_title);  $variables['base_path']         = base_path();  $variables['front_page']        = url();  $variables['breadcrumb']        = theme('breadcrumb', drupal_get_breadcrumb());  $variables['feed_icons']        = drupal_get_feeds();  $variables['footer_message']    = filter_xss_admin(variable_get('site_footer', FALSE));  $variables['head']              = drupal_get_html_head();  $variables['help']              = theme('help');  $variables['language']          = $GLOBALS['language'];  $variables['language']->dir     = $GLOBALS['language']->direction ? 'rtl' : 'ltr';  $variables['logo']              = theme_get_setting('logo');  $variables['messages']          = $variables['show_messages'] ? theme('status_messages') : '';  $variables['mission']           = isset($mission) ? $mission : '';  $variables['primary_links']     = theme_get_setting('toggle_primary_links') ? menu_primary_links() : array();  $variables['secondary_links']   = theme_get_setting('toggle_secondary_links') ? menu_secondary_links() : array();  $variables['search_box']        = (theme_get_setting('toggle_search') ? drupal_get_form('search_theme_form') : '');  $variables['site_name']         = (theme_get_setting('toggle_name') ? filter_xss_admin(variable_get('site_name', 'Drupal')) : '');  $variables['site_slogan']       = (theme_get_setting('toggle_slogan') ? filter_xss_admin(variable_get('site_slogan', '')) : '');  $variables['css']               = drupal_add_css();  $variables['styles']            = drupal_get_css();  $variables['scripts']           = drupal_get_js();  $variables['tabs']              = theme('menu_local_tasks');  $variables['title']             = drupal_get_title();  // Closure should be filled last.  $variables['closure']           = theme('closure');  if ($node = menu_get_object()) {    $variables['node'] = $node;  }  // Compile a list of classes that are going to be applied to the body element.  // This allows advanced theming based on context (home page, node of certain type, etc.).  $body_classes = array();  // Add a class that tells us whether we're on the front page or not.  $body_classes[] = $variables['is_front'] ? 'front' : 'not-front';  // Add a class that tells us whether the page is viewed by an authenticated user or not.  $body_classes[] = $variables['logged_in'] ? 'logged-in' : 'not-logged-in';  // Add arg(0) to make it possible to theme the page depending on the current page  // type (e.g. node, admin, user, etc.). To avoid illegal characters in the class,  // we're removing everything disallowed. We are not using 'a-z' as that might leave  // in certain international characters (e.g. German umlauts).  $body_classes[] = preg_replace('![^abcdefghijklmnopqrstuvwxyz0-9-_]+!s', '', 'page-'. form_clean_id(drupal_strtolower(arg(0))));  // If on an individual node page, add the node type.  if (isset($variables['node']) && $variables['node']->type) {    $body_classes[] = 'node-type-'. form_clean_id($variables['node']->type);  }  // Add information about the number of sidebars.  if ($variables['layout'] == 'both') {    $body_classes[] = 'two-sidebars';  }  elseif ($variables['layout'] == 'none') {    $body_classes[] = 'no-sidebars';  }  else {    $body_classes[] = 'one-sidebar sidebar-'. $variables['layout'];  }  // Implode with spaces.  $variables['body_classes'] = implode(' ', $body_classes);  // Build a list of suggested template files in order of specificity. One  // suggestion is made for every element of the current path, though  // numeric elements are not carried to subsequent suggestions. For example,  // http://www.example.com/node/1/edit would result in the following  // suggestions:  //  // page-node-edit.tpl.php  // page-node-1.tpl.php  // page-node.tpl.php  // page.tpl.php  $i = 0;  $suggestion = 'page';  $suggestions = array();  while ($arg = arg($i++)) {    $arg = str_replace(array("/", "\\", "\0"), '', $arg);    $suggestions[] = $suggestion .'-'. $arg;    if (!is_numeric($arg)) {      $suggestion .= '-'. $arg;    }  }  if (drupal_is_front_page()) {    $suggestions[] = 'page-front';  }  if ($suggestions) {    $variables['template_files'] = $suggestions;  }}/** * Process variables for node.tpl.php * * Most themes utilize their own copy of node.tpl.php. The default is located * inside "modules/node/node.tpl.php". Look in there for the full list of * variables. * * The $variables array contains the following arguments: * - $node * - $teaser * - $page * * @see node.tpl.php */function template_preprocess_node(&$variables) {  $node = $variables['node'];  if (module_exists('taxonomy')) {    $variables['taxonomy'] = taxonomy_link('taxonomy terms', $node);  }  else {    $variables['taxonomy'] = array();  }  if ($variables['teaser'] && $node->teaser) {    $variables['content'] = $node->teaser;  }  elseif (isset($node->body)) {    $variables['content'] = $node->body;  }  else {    $variables['content'] = '';  }  $variables['date']      = format_date($node->created);  $variables['links']     = !empty($node->links) ? theme('links', $node->links, array('class' => 'links inline')) : '';  $variables['name']      = theme('username', $node);  $variables['node_url']  = url('node/'. $node->nid);  $variables['terms']     = theme('links', $variables['taxonomy'], array('class' => 'links inline'));  $variables['title']     = check_plain($node->title);  // Flatten the node object's member fields.  $variables = array_merge((array)$node, $variables);  // Display info only on certain node types.  if (theme_get_setting('toggle_node_info_'. $node->type)) {    $variables['submitted'] = theme('node_submitted', $node);    $variables['picture'] = theme_get_setting('toggle_node_user_picture') ? theme('user_picture', $node) : '';  }  else {    $variables['submitted'] = '';    $variables['picture'] = '';  }  // Clean up name so there are no underscores.  $variables['template_files'][] = 'node-'. $node->type;}/** * Process variables for block.tpl.php * * Prepare the values passed to the theme_block function to be passed * into a pluggable template engine. Uses block properties to generate a * series of template file suggestions. If none are found, the default * block.tpl.php is used. * * Most themes utilize their own copy of block.tpl.php. The default is located * inside "modules/system/block.tpl.php". Look in there for the full list of * variables. * * The $variables array contains the following arguments: * - $block * * @see block.tpl.php */function template_preprocess_block(&$variables) {  static $block_counter = array();  // All blocks get an independent counter for each region.  if (!isset($block_counter[$variables['block']->region])) {    $block_counter[$variables['block']->region] = 1;  }  // Same with zebra striping.  $variables['block_zebra'] = ($block_counter[$variables['block']->region] % 2) ? 'odd' : 'even';  $variables['block_id'] = $block_counter[$variables['block']->region]++;  $variables['template_files'][] = 'block-'. $variables['block']->region;  $variables['template_files'][] = 'block-'. $variables['block']->module;  $variables['template_files'][] = 'block-'. $variables['block']->module .'-'. $variables['block']->delta;}
<?php// $Id$/** * @file * Administrative page callbacks for the path module. *//** * Return a listing of all defined URL aliases. * When filter key passed, perform a standard search on the given key, * and return the list of matching URL aliases. */function path_admin_overview($keys = NULL) {  // Add the filter form above the overview table.  $output = drupal_get_form('path_admin_filter_form', $keys);  // Enable language column if locale is enabled or if we have any alias with language  $count = db_result(db_query("SELECT COUNT(*) FROM {url_alias} WHERE language != ''"));  $multilanguage = (module_exists('locale') || $count);  if ($keys) {    // Replace wildcards with MySQL/PostgreSQL wildcards.    $keys = preg_replace('!\*+!', '%', $keys);    $sql = "SELECT * FROM {url_alias} WHERE dst LIKE '%%%s%%'";  }  else {    $sql = 'SELECT * FROM {url_alias}';  }  $header = array(    array('data' => t('Alias'), 'field' => 'dst', 'sort' => 'asc'),    array('data' => t('System'), 'field' => 'src'),    array('data' => t('Operations'), 'colspan' => '2')  );  if ($multilanguage) {    $header[3] = $header[2];    $header[2] = array('data' => t('Language'), 'field' => 'language');  }  $sql .= tablesort_sql($header);  $result = pager_query($sql, 50, 0 , NULL, $keys);  $rows = array();  $destination = drupal_get_destination();  while ($data = db_fetch_object($result)) {    $row = array(check_plain($data->dst), check_plain($data->src), l(t('edit'), "admin/build/path/edit/$data->pid", array('query' => $destination)), l(t('delete'), "admin/build/path/delete/$data->pid", array('query' => $destination)));    if ($multilanguage) {      $row[4] = $row[3];      $row[3] = $row[2];      $row[2] = module_invoke('locale', 'language_name', $data->language);    }    $rows[] = $row;  }  if (empty($rows)) {    $empty_message = $keys ? t('No URL aliases found.') : t('No URL aliases available.') ;    $rows[] = array(array('data' => $empty_message, 'colspan' => ($multilanguage ? 5 : 4)));  }  $output .= theme('table', $header, $rows);  $output .= theme('pager', NULL, 50, 0);  return $output;}/** * Menu callback; handles pages for creating and editing URL aliases. */function path_admin_edit($pid = 0) {  if ($pid) {    $alias = path_load($pid);    drupal_set_title(check_plain($alias['dst']));    $output = drupal_get_form('path_admin_form', $alias);  }  else {    $output = drupal_get_form('path_admin_form');  }  return $output;}/** * Return a form for editing or creating an individual URL alias. * * @ingroup forms * @see path_admin_form_validate() * @see path_admin_form_submit() */function path_admin_form(&$form_state, $edit = array('src' => '', 'dst' => '', 'language' => '', 'pid' => NULL)) {  $form['#alias'] = $edit;  $form['src'] = array(    '#type' => 'textfield',    '#title' => t('Existing system path'),    '#default_value' => $edit['src'],    '#maxlength' => 128,    '#size' => 45,    '#description' => t('Specify the existing path you wish to alias. For example: node/28, forum/1, taxonomy/term/1+2.'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q='),    '#required' => TRUE,  );  $form['dst'] = array(    '#type' => 'textfield',    '#title' => t('Path alias'),    '#default_value' => $edit['dst'],    '#maxlength' => 128,    '#size' => 45,    '#description' => t('Specify an alternative path by which this data can be accessed. For example, type "about" when writing an about page. Use a relative path and don\'t add a trailing slash or the URL alias won\'t work.'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q='),    '#required' => TRUE,  );  // This will be a hidden value unless locale module is enabled  $form['language'] = array(    '#type' => 'value',    '#value' => $edit['language']  );  if ($edit['pid']) {    $form['pid'] = array('#type' => 'hidden', '#value' => $edit['pid']);    $form['submit'] = array('#type' => 'submit', '#value' => t('Update alias'));  }  else {    $form['submit'] = array('#type' => 'submit', '#value' => t('Create new alias'));  }  return $form;}/** * Verify that a new URL alias is valid */function path_admin_form_validate($form, &$form_state) {  $src = $form_state['values']['src'];  $dst = $form_state['values']['dst'];  $pid = isset($form_state['values']['pid']) ? $form_state['values']['pid'] : 0;  // Language is only set if locale module is enabled, otherwise save for all languages.  $language = isset($form_state['values']['language']) ? $form_state['values']['language'] : '';  if (db_result(db_query("SELECT COUNT(dst) FROM {url_alias} WHERE pid != %d AND dst = '%s' AND language = '%s'", $pid, $dst, $language))) {    form_set_error('dst', t('The alias %alias is already in use in this language.', array('%alias' => $dst)));  }  $item = menu_get_item($src);  if (!$item || !$item['access']) {    form_set_error('src', t("The path '@link_path' is either invalid or you do not have access to it.", array('@link_path' => $src)));  }}/** * Save a new URL alias to the database. */function path_admin_form_submit($form, &$form_state) {  // Language is only set if locale module is enabled  path_set_alias($form_state['values']['src'], $form_state['values']['dst'], isset($form_state['values']['pid']) ? $form_state['values']['pid'] : 0, isset($form_state['values']['language']) ? $form_state['values']['language'] : '');  drupal_set_message(t('The alias has been saved.'));  $form_state['redirect'] = 'admin/build/path';  return;}/** * Menu callback; confirms deleting an URL alias */function path_admin_delete_confirm($form_state, $pid) {  $path = path_load($pid);  if (user_access('administer url aliases')) {    $form['pid'] = array('#type' => 'value', '#value' => $pid);    $output = confirm_form($form,      t('Are you sure you want to delete path alias %title?', array('%title' => $path['dst'])),      isset($_GET['destination']) ? $_GET['destination'] : 'admin/build/path');  }  return $output;}/** * Execute URL alias deletion */function path_admin_delete_confirm_submit($form, &$form_state) {  if ($form_state['values']['confirm']) {    path_admin_delete($form_state['values']['pid']);    $form_state['redirect'] = 'admin/build/path';    return;  }}/** * Return a form to filter URL aliases. * * @ingroup forms * @see path_admin_filter_form_submit() */function path_admin_filter_form(&$form_state, $keys = '') {  $form['#attributes'] = array('class' => 'search-form');  $form['basic'] = array('#type' => 'fieldset',    '#title' => t('Filter aliases')  );  $form['basic']['inline'] = array('#prefix' => '<div class="container-inline">', '#suffix' => '</div>');  $form['basic']['inline']['filter'] = array(    '#type' => 'textfield',    '#title' => '',    '#default_value' => $keys,    '#maxlength' => 128,    '#size' => 25,  );  $form['basic']['inline']['submit'] = array(    '#type' => 'submit',    '#value' => t('Filter'),    '#submit' => array('path_admin_filter_form_submit_filter'),    );  if ($keys) {    $form['basic']['inline']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset'),      '#submit' => array('path_admin_filter_form_submit_reset'),    );  }  return $form;}/** * Process filter form submission when the Filter button is pressed. */function path_admin_filter_form_submit_filter($form, &$form_state) {  $form_state['redirect'] = 'admin/build/path/list/'. trim($form_state['values']['filter']);}/** * Process filter form submission when the Reset button is pressed. */function path_admin_filter_form_submit_reset($form, &$form_state) {  $form_state['redirect'] = 'admin/build/path/list';}/** * Helper function for grabbing filter keys. */function path_admin_filter_get_keys() {  // Extract keys as remainder of path  $path = explode('/', $_GET['q'], 5);  return count($path) == 5 ? $path[4] : '';}
<?php// $Id$/** * @file * User page callbacks for the contact module. *//** * Site-wide contact page. */function contact_site_page() {  global $user;  if (!flood_is_allowed('contact', variable_get('contact_hourly_threshold', 3))) {    $output = t("You cannot send more than %number messages per hour. Please try again later.", array('%number' => variable_get('contact_hourly_threshold', 3)));  }  else {    $output = drupal_get_form('contact_mail_page');  }  return $output;}function contact_mail_page() {  global $user;  $form = $categories = array();  $result = db_query('SELECT cid, category, selected FROM {contact} ORDER BY weight, category');  while ($category = db_fetch_object($result)) {    $categories[$category->cid] = $category->category;    if ($category->selected) {      $default_category = $category->cid;    }  }  if (count($categories) > 0) {    $form['#token'] = $user->uid ? $user->name . $user->mail : '';    $form['contact_information'] = array('#value' => filter_xss_admin(variable_get('contact_form_information', t('You can leave a message using the contact form below.'))));    $form['name'] = array('#type' => 'textfield',      '#title' => t('Your name'),      '#maxlength' => 255,      '#default_value' => $user->uid ? $user->name : '',      '#required' => TRUE,    );    $form['mail'] = array('#type' => 'textfield',      '#title' => t('Your e-mail address'),      '#maxlength' => 255,      '#default_value' => $user->uid ? $user->mail : '',      '#required' => TRUE,    );    $form['subject'] = array('#type' => 'textfield',      '#title' => t('Subject'),      '#maxlength' => 255,      '#required' => TRUE,    );    if (count($categories) > 1) {      // If there is more than one category available and no default category has been selected,      // prepend a default placeholder value.      if (!isset($default_category)) {        $default_category = t('- Please choose -');        $categories = array($default_category) + $categories;      }      $form['cid'] = array('#type' => 'select',        '#title' => t('Category'),        '#default_value' => $default_category,        '#options' => $categories,        '#required' => TRUE,      );    }    else {      // If there is only one category, store its cid.      $category_keys = array_keys($categories);      $form['cid'] = array('#type' => 'value',        '#value' => array_shift($category_keys),      );    }    $form['message'] = array('#type' => 'textarea',      '#title' => t('Message'),      '#required' => TRUE,    );    // We do not allow anonymous users to send themselves a copy    // because it can be abused to spam people.    if ($user->uid) {      $form['copy'] = array('#type' => 'checkbox',        '#title' => t('Send yourself a copy.'),      );    }    else {      $form['copy'] = array('#type' => 'value', '#value' => FALSE);    }    $form['submit'] = array('#type' => 'submit',      '#value' => t('Send e-mail'),    );  }  else {    drupal_set_message(t('The contact form has not been configured. <a href="@add">Add one or more categories</a> to the form.', array('@add' => url('admin/build/contact/add'))), 'error');  }  return $form;}/** * Validate the site-wide contact page form submission. */function contact_mail_page_validate($form, &$form_state) {  if (!$form_state['values']['cid']) {    form_set_error('cid', t('You must select a valid category.'));  }  if (!valid_email_address($form_state['values']['mail'])) {    form_set_error('mail', t('You must enter a valid e-mail address.'));  }}/** * Process the site-wide contact page form submission. */function contact_mail_page_submit($form, &$form_state) {  global $language;  $values = $form_state['values'];  // E-mail address of the sender: as the form field is a text field,  // all instances of \r and \n have been automatically stripped from it.  $from = $values['mail'];  // Load category properties and save form values for email composition.  $contact = contact_load($values['cid']);  $values['contact'] = $contact;  // Send the e-mail to the recipients using the site default language.  drupal_mail('contact', 'page_mail', $contact['recipients'], language_default(), $values, $from);  // If the user requests it, send a copy using the current language.  if ($values['copy']) {    drupal_mail('contact', 'page_copy', $from, $language, $values, $from);  }  // Send an auto-reply if necessary using the current language.  if ($contact['reply']) {    drupal_mail('contact', 'page_autoreply', $from, $language, $values, $contact['recipients']);  }  flood_register_event('contact');  watchdog('mail', '%name-from sent an e-mail regarding %category.', array('%name-from' => $values['name'] ." [$from]", '%category' => $contact['category']));  drupal_set_message(t('Your message has been sent.'));  // Jump to home page rather than back to contact page to avoid  // contradictory messages if flood control has been activated.  $form_state['redirect'] = '';}/** * Personal contact page. */function contact_user_page($account) {  global $user;  if (!valid_email_address($user->mail)) {    $output = t('You need to provide a valid e-mail address to contact other users. Please update your <a href="@url">user information</a> and try again.', array('@url' => url("user/$user->uid/edit")));  }  else if (!flood_is_allowed('contact', variable_get('contact_hourly_threshold', 3))) {    $output = t('You cannot contact more than %number users per hour. Please try again later.', array('%number' => variable_get('contact_hourly_threshold', 3)));  }  else {    drupal_set_title(check_plain($account->name));    $output = drupal_get_form('contact_mail_user', $account);  }  return $output;}function contact_mail_user(&$form_state, $recipient) {  global $user;  $form['#token'] = $user->name . $user->mail;  $form['recipient'] = array('#type' => 'value', '#value' => $recipient);  $form['from'] = array('#type' => 'item',    '#title' => t('From'),    '#value' => theme('username', $user) .' &lt;'. check_plain($user->mail) .'&gt;',  );  $form['to'] = array('#type' => 'item',    '#title' => t('To'),    '#value' => theme('username', $recipient),  );  $form['subject'] = array('#type' => 'textfield',    '#title' => t('Subject'),    '#maxlength' => 50,    '#required' => TRUE,  );  $form['message'] = array('#type' => 'textarea',    '#title' => t('Message'),    '#rows' => 15,    '#required' => TRUE,  );  $form['copy'] = array('#type' => 'checkbox',    '#title' => t('Send yourself a copy.'),  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Send e-mail'),  );  return $form;}/** * Process the personal contact page form submission. */function contact_mail_user_submit($form, &$form_state) {  global $user, $language;  $account = $form_state['values']['recipient'];  // Send from the current user to the requested user.  $to = $account->mail;  $from = $user->mail;  // Save both users and all form values for email composition.  $values = $form_state['values'];  $values['account'] = $account;  $values['user'] = $user;  // Send the e-mail in the requested user language.  drupal_mail('contact', 'user_mail', $to, user_preferred_language($account), $values, $from);  // Send a copy if requested, using current page language.  if ($form_state['values']['copy']) {    drupal_mail('contact', 'user_copy', $from, $language, $values, $from);  }  flood_register_event('contact');  watchdog('mail', '%name-from sent %name-to an e-mail.', array('%name-from' => $user->name, '%name-to' => $account->name));  drupal_set_message(t('The message has been sent.'));  // Back to the requested users profile page.  $form_state['redirect'] = "user/$account->uid";}
<?php// $Id$/** * @file * User session handling functions. */function sess_open($save_path, $session_name) {  return TRUE;}function sess_close() {  return TRUE;}function sess_read($key) {  global $user;  // Write and Close handlers are called after destructing objects since PHP 5.0.5  // Thus destructors can use sessions but session handler can't use objects.  // So we are moving session closure before destructing objects.  register_shutdown_function('session_write_close');  // Handle the case of first time visitors and clients that don't store cookies (eg. web crawlers).  if (!isset($_COOKIE[session_name()])) {    $user = drupal_anonymous_user();    return '';  }  // Otherwise, if the session is still active, we have a record of the client's session in the database.  $user = db_fetch_object(db_query("SELECT u.*, s.* FROM {users} u INNER JOIN {sessions} s ON u.uid = s.uid WHERE s.sid = '%s'", $key));  // We found the client's session record and they are an authenticated,  // active user.  if ($user && $user->uid > 0 && $user->status == 1) {    // This is done to unserialize the data member of $user    $user = drupal_unpack($user);    // Add roles element to $user    $user->roles = array();    $user->roles[DRUPAL_AUTHENTICATED_RID] = 'authenticated user';    $result = db_query("SELECT r.rid, r.name FROM {role} r INNER JOIN {users_roles} ur ON ur.rid = r.rid WHERE ur.uid = %d", $user->uid);    while ($role = db_fetch_object($result)) {      $user->roles[$role->rid] = $role->name;    }  }  // We didn't find the client's record (session has expired), or they are  // blocked, or they are an anonymous user.  else {    $session = isset($user->session) ? $user->session : '';    $user = drupal_anonymous_user($session);  }  return $user->session;}function sess_write($key, $value) {  global $user;  // If saving of session data is disabled or if the client doesn't have a session,  // and one isn't being created ($value), do nothing. This keeps crawlers out of  // the session table. This reduces memory and server load, and gives more useful  // statistics. We can't eliminate anonymous session table rows without breaking  // the throttle module and the "Who's Online" block.  if (!session_save_session() || ($user->uid == 0 && empty($_COOKIE[session_name()]) && empty($value))) {    return TRUE;  }  db_query("UPDATE {sessions} SET uid = %d, cache = %d, hostname = '%s', session = '%s', timestamp = %d WHERE sid = '%s'", $user->uid, isset($user->cache) ? $user->cache : '', ip_address(), $value, time(), $key);  if (db_affected_rows()) {    // Last access time is updated no more frequently than once every 180 seconds.    // This reduces contention in the users table.    if ($user->uid && time() - $user->access > variable_get('session_write_interval', 180)) {      db_query("UPDATE {users} SET access = %d WHERE uid = %d", time(), $user->uid);    }  }  else {    // If this query fails, another parallel request probably got here first.    // In that case, any session data generated in this request is discarded.    @db_query("INSERT INTO {sessions} (sid, uid, cache, hostname, session, timestamp) VALUES ('%s', %d, %d, '%s', '%s', %d)", $key, $user->uid, isset($user->cache) ? $user->cache : '', ip_address(), $value, time());  }  return TRUE;}/** * Called when an anonymous user becomes authenticated or vice-versa. */function sess_regenerate() {  $old_session_id = session_id();  // We code around http://bugs.php.net/bug.php?id=32802 by destroying  // the session cookie by setting expiration in the past (a negative  // value).  This issue only arises in PHP versions before 4.4.0,  // regardless of the Drupal configuration.  // TODO: remove this when we require at least PHP 4.4.0  if (isset($_COOKIE[session_name()])) {    setcookie(session_name(), '', time() - 42000, '/');  }  session_regenerate_id();  db_query("UPDATE {sessions} SET sid = '%s' WHERE sid = '%s'", session_id(), $old_session_id);}/** * Counts how many users have sessions. Can count either anonymous sessions or authenticated sessions. * * @param int $timestamp *   A Unix timestamp representing a point of time in the past. *   The default is 0, which counts all existing sessions. * @param boolean $anonymous *   TRUE counts only anonymous users. *   FALSE counts only authenticated users. * @return  int *   The number of users with sessions. */function sess_count($timestamp = 0, $anonymous = true) {  $query = $anonymous ? ' AND uid = 0' : ' AND uid > 0';  return db_result(db_query('SELECT COUNT(sid) AS count FROM {sessions} WHERE timestamp >= %d'. $query, $timestamp));}/** * Called by PHP session handling with the PHP session ID to end a user's session. * * @param  string $sid *   the session id */function sess_destroy_sid($sid) {  db_query("DELETE FROM {sessions} WHERE sid = '%s'", $sid);}/** * End a specific user's session * * @param  string $uid *   the user id */function sess_destroy_uid($uid) {  db_query('DELETE FROM {sessions} WHERE uid = %d', $uid);}function sess_gc($lifetime) {  // Be sure to adjust 'php_value session.gc_maxlifetime' to a large enough  // value. For example, if you want user sessions to stay in your database  // for three weeks before deleting them, you need to set gc_maxlifetime  // to '1814400'. At that value, only after a user doesn't log in after  // three weeks (1814400 seconds) will his/her session be removed.  db_query("DELETE FROM {sessions} WHERE timestamp < %d", time() - $lifetime);  return TRUE;}/** * Determine whether to save session data of the current request. * * This function allows the caller to temporarily disable writing of session data, * should the request end while performing potentially dangerous operations, such as * manipulating the global $user object.  See http://drupal.org/node/218104 for usage * * @param $status *   Disables writing of session data when FALSE, (re-)enables writing when TRUE. * @return *   FALSE if writing session data has been disabled. Otherwise, TRUE. */function session_save_session($status = NULL) {  static $save_session = TRUE;  if (isset($status)) {    $save_session = $status;  }  return ($save_session);}
<?php// $Id$/** * @file * Theming for maintenance pages. *//** * Sets up the theming system for site installs, updates and when the site is * in off-line mode. It also applies when the database is unavailable. * * Minnelli is always used for the initial install and update operations. In * other cases, "settings.php" must have a "maintenance_theme" key set for the * $conf variable in order to change the maintenance theme. */function _drupal_maintenance_theme() {  global $theme, $theme_key;  // If $theme is already set, assume the others are set too, and do nothing.  if (isset($theme)) {    return;  }  require_once './includes/path.inc';  require_once './includes/theme.inc';  require_once './includes/common.inc';  require_once './includes/unicode.inc';  require_once './includes/file.inc';  require_once './includes/module.inc';  require_once './includes/database.inc';  unicode_check();  // Install and update pages are treated differently to prevent theming overrides.  if (defined('MAINTENANCE_MODE') && (MAINTENANCE_MODE == 'install' || MAINTENANCE_MODE == 'update')) {    $theme = 'minnelli';  }  else {    if (!db_is_active()) {      // Because we are operating in a crippled environment, we need to      // bootstrap just enough to allow hook invocations to work.      $module_list['system']['filename'] = 'modules/system/system.module';      $module_list['filter']['filename'] = 'modules/filter/filter.module';      module_list(TRUE, FALSE, FALSE, $module_list);      drupal_load('module', 'system');      drupal_load('module', 'filter');    }    $theme = variable_get('maintenance_theme', 'minnelli');  }  $themes = list_themes();  // Store the identifier for retrieving theme settings with.  $theme_key = $theme;  // Find all our ancestor themes and put them in an array.  $base_theme = array();  $ancestor = $theme;  while ($ancestor && isset($themes[$ancestor]->base_theme)) {    $base_theme[] = $new_base_theme = $themes[$themes[$ancestor]->base_theme];    $ancestor = $themes[$ancestor]->base_theme;  }  _init_theme($themes[$theme], array_reverse($base_theme), '_theme_load_offline_registry');  // These are usually added from system_init() -except maintenance.css.  // When the database is inactive it's not called so we add it here.  drupal_add_css(drupal_get_path('module', 'system') .'/defaults.css', 'module');  drupal_add_css(drupal_get_path('module', 'system') .'/system.css', 'module');  drupal_add_css(drupal_get_path('module', 'system') .'/system-menus.css', 'module');  drupal_add_css(drupal_get_path('module', 'system') .'/maintenance.css', 'module');}/** * This builds the registry when the site needs to bypass any database calls. */function _theme_load_offline_registry($theme, $base_theme = NULL, $theme_engine = NULL) {  $registry = _theme_build_registry($theme, $base_theme, $theme_engine);  _theme_set_registry($registry);}/** * Return a themed list of maintenance tasks to perform. * * @ingroup themeable */function theme_task_list($items, $active = NULL) {  $done = isset($items[$active]) || $active == NULL;  $output = '<ol class="task-list">';  foreach ($items as $k => $item) {    if ($active == $k) {      $class = 'active';      $done = false;    }    else {      $class = $done ? 'done' : '';    }    $output .= '<li class="'. $class .'">'. $item .'</li>';  }  $output .= '</ol>';  return $output;}/** * Generate a themed installation page. * * Note: this function is not themeable. * * @param $content *   The page content to show. */function theme_install_page($content) {  drupal_set_header('Content-Type: text/html; charset=utf-8');  // Assign content.  $variables['content'] = $content;  // Delay setting the message variable so it can be processed below.  $variables['show_messages'] = FALSE;  // The maintenance preprocess function is recycled here.  template_preprocess_maintenance_page($variables);  // Special handling of error messages  $messages = drupal_set_message();  if (isset($messages['error'])) {    $title = count($messages['error']) > 1 ? st('The following errors must be resolved before you can continue the installation process') : st('The following error must be resolved before you can continue the installation process');    $variables['messages'] .= '<h3>'. $title .':</h3>';    $variables['messages'] .= theme('status_messages', 'error');    $variables['content'] .= '<p>'. st('Please check the error messages and <a href="!url">try again</a>.', array('!url' => check_url(request_uri()))) .'</p>';  }  // Special handling of warning messages  if (isset($messages['warning'])) {    $title = count($messages['warning']) > 1 ? st('The following installation warnings should be carefully reviewed') : st('The following installation warning should be carefully reviewed');    $variables['messages'] .= '<h4>'. $title .':</h4>';    $variables['messages'] .= theme('status_messages', 'warning');  }  // Special handling of status messages  if (isset($messages['status'])) {    $title = count($messages['status']) > 1 ? st('The following installation warnings should be carefully reviewed, but in most cases may be safely ignored') : st('The following installation warning should be carefully reviewed, but in most cases may be safely ignored');    $variables['messages'] .= '<h4>'. $title .':</h4>';    $variables['messages'] .= theme('status_messages', 'status');  }  // This was called as a theme hook (not template), so we need to  // fix path_to_theme() for the template, to point at the actual  // theme rather than system module as owner of the hook.  global $theme_path;  $theme_path = 'themes/garland';  return theme_render_template('themes/garland/maintenance-page.tpl.php', $variables);}/** * Generate a themed update page. * * Note: this function is not themeable. * * @param $content *   The page content to show. * @param $show_messages *   Whether to output status and error messages. *   FALSE can be useful to postpone the messages to a subsequent page. */function theme_update_page($content, $show_messages = TRUE) {  // Set required headers.  drupal_set_header('Content-Type: text/html; charset=utf-8');  // Assign content and show message flag.  $variables['content'] = $content;  $variables['show_messages'] = $show_messages;  // The maintenance preprocess function is recycled here.  template_preprocess_maintenance_page($variables);  // Special handling of warning messages.  $messages = drupal_set_message();  if (isset($messages['warning'])) {    $title = count($messages['warning']) > 1 ? 'The following update warnings should be carefully reviewed before continuing' : 'The following update warning should be carefully reviewed before continuing';    $variables['messages'] .= '<h4>'. $title .':</h4>';    $variables['messages'] .= theme('status_messages', 'warning');  }  // This was called as a theme hook (not template), so we need to  // fix path_to_theme() for the template, to point at the actual  // theme rather than system module as owner of the hook.  global $theme_path;  $theme_path = 'themes/garland';  return theme_render_template('themes/garland/maintenance-page.tpl.php', $variables);}/** * The variables generated here is a mirror of template_preprocess_page(). * This preprocessor will run it's course when theme_maintenance_page() is * invoked. It is also used in theme_install_page() and theme_update_page() to * keep all the variables consistent. * * An alternate template file of "maintenance-page-offline.tpl.php" can be * used when the database is offline to hide errors and completely replace the * content. * * The $variables array contains the following arguments: * - $content * - $show_blocks * * @see maintenance-page.tpl.php */function template_preprocess_maintenance_page(&$variables) {  // Add favicon  if (theme_get_setting('toggle_favicon')) {    drupal_set_html_head('<link rel="shortcut icon" href="'. check_url(theme_get_setting('favicon')) .'" type="image/x-icon" />');  }  global $theme;  // Retrieve the theme data to list all available regions.  $theme_data = _system_theme_data();  $regions = $theme_data[$theme]->info['regions'];  // Get all region content set with drupal_set_content().  foreach (array_keys($regions) as $region) {    // Assign region to a region variable.    $region_content = drupal_get_content($region);    isset($variables[$region]) ? $variables[$region] .= $region_content : $variables[$region] = $region_content;  }  // Setup layout variable.  $variables['layout'] = 'none';  if (!empty($variables['left'])) {    $variables['layout'] = 'left';  }  if (!empty($variables['right'])) {    $variables['layout'] = ($variables['layout'] == 'left') ? 'both' : 'right';  }  // Construct page title  if (drupal_get_title()) {    $head_title = array(strip_tags(drupal_get_title()), variable_get('site_name', 'Drupal'));  }  else {    $head_title = array(variable_get('site_name', 'Drupal'));    if (variable_get('site_slogan', '')) {      $head_title[] = variable_get('site_slogan', '');    }  }  $variables['head_title']        = implode(' | ', $head_title);  $variables['base_path']         = base_path();  $variables['breadcrumb']        = '';  $variables['feed_icons']        = '';  $variables['footer_message']    = filter_xss_admin(variable_get('site_footer', FALSE));  $variables['head']              = drupal_get_html_head();  $variables['help']              = '';  $variables['language']          = $GLOBALS['language'];  $variables['language']->dir     = $GLOBALS['language']->direction ? 'rtl' : 'ltr';  $variables['logo']              = theme_get_setting('logo');  $variables['messages']          = $variables['show_messages'] ? theme('status_messages') : '';  $variables['mission']           = '';  $variables['primary_links']     = array();  $variables['secondary_links']   = array();  $variables['search_box']        = '';  $variables['site_name']         = (theme_get_setting('toggle_name') ? variable_get('site_name', 'Drupal') : '');  $variables['site_slogan']       = (theme_get_setting('toggle_slogan') ? variable_get('site_slogan', '') : '');  $variables['css']               = drupal_add_css();  $variables['styles']            = drupal_get_css();  $variables['scripts']           = drupal_get_js();  $variables['tabs']              = '';  $variables['title']             = drupal_get_title();  $variables['closure']           = '';  // Compile a list of classes that are going to be applied to the body element.  $body_classes = array();  $body_classes[] = 'in-maintenance';  if (isset($variables['db_is_active']) && !$variables['db_is_active']) {    $body_classes[] = 'db-offline';  }  if ($variables['layout'] == 'both') {    $body_classes[] = 'two-sidebars';  }  elseif ($variables['layout'] == 'none') {    $body_classes[] = 'no-sidebars';  }  else {    $body_classes[] = 'one-sidebar sidebar-'. $variables['layout'];  }  $variables['body_classes'] = implode(' ', $body_classes);  // Dead databases will show error messages so supplying this template will  // allow themers to override the page and the content completely.  if (isset($variables['db_is_active']) && !$variables['db_is_active']) {    $variables['template_file'] = 'maintenance-page-offline';  }}
<?php// $Id$/** * Implementation of hook_install(). */function openid_install() {  // Create table.  drupal_install_schema('openid');}/** * Implementation of hook_uninstall(). */function openid_uninstall() {  // Remove table.  drupal_uninstall_schema('openid');}/** * Implementation of hook_schema(). */function openid_schema() {  $schema['openid_association'] = array(    'description' => 'Stores temporary shared key association information for OpenID authentication.',    'fields' => array(      'idp_endpoint_uri' => array(        'type' => 'varchar',        'length' => 255,        'description' => 'URI of the OpenID Provider endpoint.',      ),      'assoc_handle' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'description' => 'Primary Key: Used to refer to this association in subsequent messages.',      ),      'assoc_type' => array(        'type' => 'varchar',        'length' => 32,        'description' => 'The signature algorithm used: one of HMAC-SHA1 or HMAC-SHA256.',      ),      'session_type' => array(        'type' => 'varchar',        'length' => 32,        'description' => 'Valid association session types: "no-encryption", "DH-SHA1", and "DH-SHA256".',      ),      'mac_key' => array(        'type' => 'varchar',        'length' => 255,        'description' => 'The MAC key (shared secret) for this association.',      ),      'created' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'UNIX timestamp for when the association was created.',      ),      'expires_in' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The lifetime, in seconds, of this association.',      ),    ),    'primary key' => array('assoc_handle'),  );  return $schema;}
<?php// $Id$/** * @file aggregator-summary-items.tpl.php * Default theme implementation to present feeds as list items. * * Each iteration generates a single feed source or category. * * Available variables: * - $title: Title of the feed or category. * - $summary_list: Unordered list of linked feed items generated through *   theme_item_list(). * - $source_url: URL to the local source or category. * * @see template_preprocess() * @see template_preprocess_aggregator_summary-items() */?><h2><?php print $title; ?></h2><?php print $summary_list; ?><div class="links">  <a href="<?php print $source_url; ?>"><?php print t('More'); ?></a></div>
<?php// $Id$/** * Test and report Drupal installation requirements. * * @param $phase *   The current system installation phase. * @return *   An array of system requirements. */function system_requirements($phase) {  $requirements = array();  // Ensure translations don't break at install time  $t = get_t();  // Report Drupal version  if ($phase == 'runtime') {    $requirements['drupal'] = array(      'title' => $t('Drupal'),      'value' => VERSION,      'severity' => REQUIREMENT_INFO,      'weight' => -10,    );  }  // Web server information.  $software = $_SERVER['SERVER_SOFTWARE'];  $requirements['webserver'] = array(    'title' => $t('Web server'),    'value' => $software,  );  // Test PHP version  $requirements['php'] = array(    'title' => $t('PHP'),    'value' => ($phase == 'runtime') ? l(phpversion(), 'admin/reports/status/php') : phpversion(),  );  if (version_compare(phpversion(), DRUPAL_MINIMUM_PHP) < 0) {    $requirements['php']['description'] = $t('Your PHP installation is too old. Drupal requires at least PHP %version.', array('%version' => DRUPAL_MINIMUM_PHP));    $requirements['php']['severity'] = REQUIREMENT_ERROR;  }  // Test PHP register_globals setting.  $requirements['php_register_globals'] = array(    'title' => $t('PHP register globals'),  );  $register_globals = trim(ini_get('register_globals'));  // Unfortunately, ini_get() may return many different values, and we can't  // be certain which values mean 'on', so we instead check for 'not off'  // since we never want to tell the user that their site is secure  // (register_globals off), when it is in fact on. We can only guarantee  // register_globals is off if the value returned is 'off', '', or 0.  if (!empty($register_globals) && strtolower($register_globals) != 'off') {    $requirements['php_register_globals']['description'] = $t('<em>register_globals</em> is enabled. Drupal requires this configuration directive to be disabled. Your site may not be secure when <em>register_globals</em> is enabled. The PHP manual has instructions for <a href="http://php.net/configuration.changes">how to change configuration settings</a>.');    $requirements['php_register_globals']['severity'] = REQUIREMENT_ERROR;    $requirements['php_register_globals']['value'] = $t("Enabled ('@value')", array('@value' => $register_globals));  }  else {    $requirements['php_register_globals']['value'] = $t('Disabled');  }  // Test PHP memory_limit  $memory_limit = ini_get('memory_limit');  $requirements['php_memory_limit'] = array(    'title' => $t('PHP memory limit'),    'value' => $memory_limit == -1 ? t('-1 (Unlimited)') : $memory_limit,  );  if ($memory_limit && $memory_limit != -1 && parse_size($memory_limit) < parse_size(DRUPAL_MINIMUM_PHP_MEMORY_LIMIT)) {    $description = '';    if ($phase == 'install') {      $description = $t('Consider increasing your PHP memory limit to %memory_minimum_limit to help prevent errors in the installation process.', array('%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));    }    elseif ($phase == 'update') {      $description = $t('Consider increasing your PHP memory limit to %memory_minimum_limit to help prevent errors in the update process.', array('%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));    }    elseif ($phase == 'runtime') {      $description = $t('Depending on your configuration, Drupal can run with a %memory_limit PHP memory limit. However, a %memory_minimum_limit PHP memory limit or above is recommended, especially if your site uses additional custom or contributed modules.', array('%memory_limit' => $memory_limit, '%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));    }    if (!empty($description)) {      if ($php_ini_path = get_cfg_var('cfg_file_path')) {        $description .= ' '. $t('Increase the memory limit by editing the memory_limit parameter in the file %configuration-file and then restart your web server (or contact your system administrator or hosting provider for assistance).', array('%configuration-file' => $php_ini_path));      }      else {        $description .= ' '. $t('Contact your system administrator or hosting provider for assistance with increasing your PHP memory limit.');      }      $requirements['php_memory_limit']['description'] = $description .' '. $t('See the <a href="@url">Drupal requirements</a> for more information.', array('@url' => 'http://drupal.org/requirements'));      $requirements['php_memory_limit']['severity'] = REQUIREMENT_WARNING;    }  }  // Test DB version  global $db_type;  if (function_exists('db_status_report')) {    $requirements += db_status_report($phase);  }  // Test settings.php file writability  if ($phase == 'runtime') {    $conf_dir = drupal_verify_install_file(conf_path(), FILE_NOT_WRITABLE, 'dir');    $conf_file = drupal_verify_install_file(conf_path() .'/settings.php', FILE_EXIST|FILE_READABLE|FILE_NOT_WRITABLE);    if (!$conf_dir || !$conf_file) {      $requirements['settings.php'] = array(        'value' => $t('Not protected'),        'severity' => REQUIREMENT_ERROR,        'description' => '',      );      if (!$conf_dir) {        $requirements['settings.php']['description'] .= $t('The directory %file is not protected from modifications and poses a security risk. You must change the directory\'s permissions to be non-writable. ', array('%file' => conf_path()));      }      if (!$conf_file) {        $requirements['settings.php']['description'] .= $t('The file %file is not protected from modifications and poses a security risk. You must change the file\'s permissions to be non-writable.', array('%file' => conf_path() .'/settings.php'));      }    }    else {      $requirements['settings.php'] = array(        'value' => $t('Protected'),      );    }    $requirements['settings.php']['title'] = $t('Configuration file');  }  // Report cron status.  if ($phase == 'runtime') {    // Cron warning threshold defaults to two days.    $threshold_warning = variable_get('cron_threshold_warning', 172800);    // Cron error threshold defaults to two weeks.    $threshold_error = variable_get('cron_threshold_error', 1209600);    // Cron configuration help text.    $help = $t('For more information, see the online handbook entry for <a href="@cron-handbook">configuring cron jobs</a>.', array('@cron-handbook' => 'http://drupal.org/cron'));    // Determine when cron last ran. If never, use the install time to    // determine the warning or error status.    $cron_last = variable_get('cron_last', NULL);    $never_run = FALSE;    if (!is_numeric($cron_last)) {      $never_run = TRUE;      $cron_last = variable_get('install_time', 0);    }    // Determine severity based on time since cron last ran.    $severity = REQUIREMENT_OK;    if (time() - $cron_last > $threshold_error) {      $severity = REQUIREMENT_ERROR;    }    else if ($never_run || (time() - $cron_last > $threshold_warning)) {      $severity = REQUIREMENT_WARNING;    }    // If cron hasn't been run, and the user is viewing the main    // administration page, instead of an error, we display a helpful reminder    // to configure cron jobs.    if ($never_run && $severity != REQUIREMENT_ERROR && $_GET['q'] == 'admin' && user_access('administer site configuration')) {      drupal_set_message($t('Cron has not run. Please visit the <a href="@status">status report</a> for more information.', array('@status' => url('admin/reports/status'))));    }    // Set summary and description based on values determined above.    if ($never_run) {      $summary = $t('Never run');      $description = $t('Cron has not run.') .' '. $help;    }    else {      $summary = $t('Last run !time ago', array('!time' => format_interval(time() - $cron_last)));      $description = '';      if ($severity != REQUIREMENT_OK) {        $description = $t('Cron has not run recently.') .' '. $help;      }    }    $requirements['cron'] = array(      'title' => $t('Cron maintenance tasks'),      'severity' => $severity,      'value' => $summary,      'description' => $description .' '. $t('You can <a href="@cron">run cron manually</a>.', array('@cron' => url('admin/reports/status/run-cron'))),    );  }  // Test files directory  $directory = file_directory_path();  $requirements['file system'] = array(    'title' => $t('File system'),  );  // For installer, create the directory if possible.  if ($phase == 'install' && !is_dir($directory) && @mkdir($directory)) {    @chmod($directory, 0775); // Necessary for non-webserver users.  }  $is_writable = is_writable($directory);  $is_directory = is_dir($directory);  if (!$is_writable || !$is_directory) {    $description = '';    $requirements['file system']['value'] = $t('Not writable');    if (!$is_directory) {      $error = $t('The directory %directory does not exist.', array('%directory' => $directory));    }    else {      $error = $t('The directory %directory is not writable.', array('%directory' => $directory));    }    // The files directory requirement check is done only during install and runtime.    if ($phase == 'runtime') {      $description = $error .' '. $t('You may need to set the correct directory at the <a href="@admin-file-system">file system settings page</a> or change the current directory\'s permissions so that it is writable.', array('@admin-file-system' => url('admin/settings/file-system')));    }    elseif ($phase == 'install') {      // For the installer UI, we need different wording. 'value' will      // be treated as version, so provide none there.      $description = $error .' '. $t('An automated attempt to create this directory failed, possibly due to a permissions problem. To proceed with the installation, either create the directory and modify its permissions manually, or ensure that the installer has the permissions to create it automatically. For more information, please see INSTALL.txt or the <a href="@handbook_url">on-line handbook</a>.', array('@handbook_url' => 'http://drupal.org/server-permissions'));      $requirements['file system']['value'] = '';    }    if (!empty($description)) {      $requirements['file system']['description'] = $description;      $requirements['file system']['severity'] = REQUIREMENT_ERROR;    }  }  else {    if (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC) {      $requirements['file system']['value'] = $t('Writable (<em>public</em> download method)');    }    else {      $requirements['file system']['value'] = $t('Writable (<em>private</em> download method)');    }  }  // See if updates are available in update.php.  if ($phase == 'runtime') {    $requirements['update'] = array(      'title' => $t('Database updates'),      'severity' => REQUIREMENT_OK,      'value' => $t('Up to date'),    );    // Check installed modules.    foreach (module_list() as $module) {      $updates = drupal_get_schema_versions($module);      if ($updates !== FALSE) {        $default = drupal_get_installed_schema_version($module);        if (max($updates) > $default) {          $requirements['update']['severity'] = REQUIREMENT_ERROR;          $requirements['update']['value'] = $t('Out of date');          $requirements['update']['description'] = $t('Some modules have database schema updates to install. You should run the <a href="@update">database update script</a> immediately.', array('@update' => base_path() .'update.php'));          break;        }      }    }  }  // Verify the update.php access setting  if ($phase == 'runtime') {    if (!empty($GLOBALS['update_free_access'])) {      $requirements['update access'] = array(        'value' => $t('Not protected'),        'severity' => REQUIREMENT_ERROR,        'description' => $t('The update.php script is accessible to everyone without authentication check, which is a security risk. You must change the $update_free_access value in your settings.php back to FALSE.'),      );    }    else {      $requirements['update access'] = array(        'value' => $t('Protected'),      );    }    $requirements['update access']['title'] = $t('Access to update.php');  }  // Test Unicode library  include_once './includes/unicode.inc';  $requirements = array_merge($requirements, unicode_requirements());  if ($phase == 'runtime') {    // Check for update status module.    if (!module_exists('update')) {      $requirements['update status'] = array(        'value' => $t('Not enabled'),        'severity' => REQUIREMENT_WARNING,        'description' => $t('Update notifications are not enabled. It is <strong>highly recommended</strong> that you enable the update status module from the <a href="@module">module administration page</a> in order to stay up-to-date on new releases. For more information please read the <a href="@update">Update status handbook page</a>.', array('@update' => 'http://drupal.org/handbook/modules/update', '@module' => url('admin/build/modules'))),      );    }    else {      $requirements['update status'] = array(        'value' => $t('Enabled'),      );    }    $requirements['update status']['title'] = $t('Update notifications');    // Check that Drupal can issue HTTP requests.    if (variable_get('drupal_http_request_fails', TRUE) && !system_check_http_request()) {      $requirements['http requests'] = array(        'title' => $t('HTTP request status'),        'value' => $t('Fails'),        'severity' => REQUIREMENT_ERROR,        'description' => $t('Your system or network configuration does not allow Drupal to access web pages, resulting in reduced functionality. This could be due to your webserver configuration or PHP settings, and should be resolved in order to download information about available updates, fetch aggregator feeds, sign in via OpenID, or use other network-dependent services.'),      );    }  }  return $requirements;}/** * Implementation of hook_install(). */function system_install() {  if ($GLOBALS['db_type'] == 'pgsql') {    // We create some custom types and functions using global names instead of    // prefixing them like we do with table names. If this function is ever    // called again (for example, by the test framework when creating prefixed    // test databases), the global names will already exist. We therefore avoid    // trying to create them again in that case.    // Create unsigned types.    if (!db_result(db_query("SELECT COUNT(*) FROM pg_constraint WHERE conname = 'int_unsigned_check'"))) {      db_query("CREATE DOMAIN int_unsigned integer CHECK (VALUE >= 0)");    }    if (!db_result(db_query("SELECT COUNT(*) FROM pg_constraint WHERE conname = 'smallint_unsigned_check'"))) {      db_query("CREATE DOMAIN smallint_unsigned smallint CHECK (VALUE >= 0)");    }    if (!db_result(db_query("SELECT COUNT(*) FROM pg_constraint WHERE conname = 'bigint_unsigned_check'"))) {      db_query("CREATE DOMAIN bigint_unsigned bigint CHECK (VALUE >= 0)");    }    // Create functions.    db_query('CREATE OR REPLACE FUNCTION "greatest"(numeric, numeric) RETURNS numeric AS      \'SELECT CASE WHEN (($1 > $2) OR ($2 IS NULL)) THEN $1 ELSE $2 END;\'      LANGUAGE \'sql\''    );    db_query('CREATE OR REPLACE FUNCTION "greatest"(numeric, numeric, numeric) RETURNS numeric AS      \'SELECT greatest($1, greatest($2, $3));\'      LANGUAGE \'sql\''    );    if (!db_result(db_query("SELECT COUNT(*) FROM pg_proc WHERE proname = 'rand'"))) {      db_query('CREATE OR REPLACE FUNCTION "rand"() RETURNS float AS        \'SELECT random();\'        LANGUAGE \'sql\''      );    }    if (!db_result(db_query("SELECT COUNT(*) FROM pg_proc WHERE proname = 'concat'"))) {      db_query('CREATE OR REPLACE FUNCTION "concat"(text, text) RETURNS text AS        \'SELECT $1 || $2;\'        LANGUAGE \'sql\''      );    }    db_query('CREATE OR REPLACE FUNCTION "if"(boolean, text, text) RETURNS text AS      \'SELECT CASE WHEN $1 THEN $2 ELSE $3 END;\'      LANGUAGE \'sql\''    );    db_query('CREATE OR REPLACE FUNCTION "if"(boolean, integer, integer) RETURNS integer AS      \'SELECT CASE WHEN $1 THEN $2 ELSE $3 END;\'      LANGUAGE \'sql\''    );  }  // Create tables.  $modules = array('system', 'filter', 'block', 'user', 'node', 'comment', 'taxonomy');  foreach ($modules as $module) {    drupal_install_schema($module);  }  // Clear out module list and hook implementation statics before calling  // system_theme_data().  module_list(TRUE, FALSE);  module_implements('', FALSE, TRUE);  // Load system theme data appropriately.  system_theme_data();  // Inserting uid 0 here confuses MySQL -- the next user might be created as  // uid 2 which is not what we want. So we insert the first user here, the  // anonymous user. uid is 1 here for now, but very soon it will be changed  // to 0.  db_query("INSERT INTO {users} (name, mail) VALUES('%s', '%s')", '', '');  // We need some placeholders here as name and mail are uniques and data is  // presumed to be a serialized array. Install will change uid 1 immediately  // anyways. So we insert the superuser here, the uid is 2 here for now, but  // very soon it will be changed to 1.  db_query("INSERT INTO {users} (name, mail, created, data) VALUES('%s', '%s', %d, '%s')", 'placeholder-for-uid-1', 'placeholder-for-uid-1', time(), serialize(array()));  // This sets the above two users uid 0 (anonymous). We avoid an explicit 0  // otherwise MySQL might insert the next auto_increment value.  db_query("UPDATE {users} SET uid = uid - uid WHERE name = '%s'", '');  // This sets uid 1 (superuser). We skip uid 2 but that's not a big problem.  db_query("UPDATE {users} SET uid = 1 WHERE name = '%s'", 'placeholder-for-uid-1');  db_query("INSERT INTO {role} (name) VALUES ('%s')", 'anonymous user');  db_query("INSERT INTO {role} (name) VALUES ('%s')", 'authenticated user');  db_query("INSERT INTO {permission} (rid, perm, tid) VALUES (%d, '%s', %d)", 1, 'access content', 0);  db_query("INSERT INTO {permission} (rid, perm, tid) VALUES (%d, '%s', %d)", 2, 'access comments, access content, post comments, post comments without approval', 0);  db_query("INSERT INTO {variable} (name, value) VALUES ('%s', '%s')", 'theme_default', 's:7:"garland";');  db_query("UPDATE {system} SET status = %d WHERE type = '%s' AND name = '%s'", 1, 'theme', 'garland');  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, pages, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', '%s', %d)", 'user', '0', 'garland', 1, 0, 'left', '', -1);  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, pages, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', '%s', %d)", 'user', '1', 'garland', 1, 0, 'left', '', -1);  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, pages, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', '%s', %d)", 'system', '0', 'garland', 1, 10, 'footer', '', -1);  db_query("INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, '%s', %d, %d, %d)", 0, 0, 'all', 1, 0, 0);  // Add input formats.  db_query("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('%s', '%s', %d)", 'Filtered HTML', ',1,2,', 1);  db_query("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('%s', '%s', %d)", 'Full HTML', '', 1);  // Enable filters for each input format.  // Filtered HTML:  // URL filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 2, 0);  // HTML filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 0, 1);  // Line break filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 1, 2);  // HTML corrector filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 3, 10);  // Full HTML:  // URL filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 2, 'filter', 2, 0);  // Line break filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 2, 'filter', 1, 1);  // HTML corrector filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 2, 'filter', 3, 10);  db_query("INSERT INTO {variable} (name, value) VALUES ('%s','%s')", 'filter_html_1', 'i:1;');  db_query("INSERT INTO {variable} (name, value) VALUES ('%s', '%s')", 'node_options_forum', 'a:1:{i:0;s:6:"status";}');}/** * Implementation of hook_schema(). */function system_schema() {  // NOTE: {variable} needs to be created before all other tables, as  // some database drivers, e.g. Oracle and DB2, will require variable_get()  // and variable_set() for overcoming some database specific limitations.  $schema['variable'] = array(    'description' => 'Named variable/value pairs created by Drupal core or any other module or theme. All variables are cached in memory at the start of every Drupal request so developers should not be careless about what is stored here.',    'fields' => array(      'name' => array(        'description' => 'The name of the variable.',        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => ''),      'value' => array(        'description' => 'The value of the variable.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      ),    'primary key' => array('name'),    );  $schema['actions'] = array(    'description' => 'Stores action information.',    'fields' => array(      'aid' => array(        'description' => 'Primary Key: Unique actions ID.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '0'),      'type' => array(        'description' => 'The object that that action acts on (node, user, comment, system or custom types.)',        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => ''),      'callback' => array(        'description' => 'The callback function that executes when the action runs.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'parameters' => array(        'description' => 'Parameters to be passed to the callback function.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'description' => array(        'description' => 'Description of the action.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '0'),      ),    'primary key' => array('aid'),    );  $schema['actions_aid'] = array(    'description' => 'Stores action IDs for non-default actions.',    'fields' => array(      'aid' => array(        'description' => 'Primary Key: Unique actions ID.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      ),    'primary key' => array('aid'),    );  $schema['batch'] = array(    'description' => t('Stores details about batches (processes that run in multiple HTTP requests).'),    'fields' => array(      'bid' => array(        'description' => 'Primary Key: Unique batch ID.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'token' => array(        'description' => "A string token generated against the current user's session id and the batch id, used to ensure that only the user who submitted the batch can effectively access it.",        'type' => 'varchar',        'length' => 64,        'not null' => TRUE),      'timestamp' => array(        'description' => 'A Unix timestamp indicating when this batch was submitted for processing. Stale batches are purged at cron time.',        'type' => 'int',        'not null' => TRUE),      'batch' => array(        'description' => 'A serialized array containing the processing data for the batch.',        'type' => 'text',        'not null' => FALSE,        'size' => 'big')      ),    'primary key' => array('bid'),    'indexes' => array('token' => array('token')),    );  $schema['cache'] = array(    'description' => 'Generic cache table for caching things not separated out into their own tables. Contributed modules may also use this to store cached items.',    'fields' => array(      'cid' => array(        'description' => 'Primary Key: Unique cache ID.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'data' => array(        'description' => 'A collection of data to cache.',        'type' => 'blob',        'not null' => FALSE,        'size' => 'big'),      'expire' => array(        'description' => 'A Unix timestamp indicating when the cache entry should expire, or 0 for never.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'created' => array(        'description' => 'A Unix timestamp indicating when the cache entry was created.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'headers' => array(        'description' => 'Any custom HTTP headers to be added to cached data.',        'type' => 'text',        'not null' => FALSE),      'serialized' => array(        'description' => 'A flag to indicate whether content is serialized (1) or not (0).',        'type' => 'int',        'size' => 'small',        'not null' => TRUE,        'default' => 0)      ),    'indexes' => array('expire' => array('expire')),    'primary key' => array('cid'),    );  $schema['cache_form'] = $schema['cache'];  $schema['cache_form']['description'] = 'Cache table for the form system to store recently built forms and their storage data, to be used in subsequent page requests.';  $schema['cache_page'] = $schema['cache'];  $schema['cache_page']['description'] = 'Cache table used to store compressed pages for anonymous users, if page caching is enabled.';  $schema['cache_menu'] = $schema['cache'];  $schema['cache_menu']['description'] = 'Cache table for the menu system to store router information as well as generated link trees for various menu/page/user combinations.';  $schema['files'] = array(    'description' => 'Stores information for uploaded files.',    'fields' => array(      'fid' => array(        'description' => 'Primary Key: Unique files ID.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'uid' => array(        'description' => 'The {users}.uid of the user who is associated with the file.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'filename' => array(        'description' => 'Name of the file.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'filepath' => array(        'description' => 'Path of the file relative to Drupal root.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'filemime' => array(        'description' => 'The file MIME type.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'filesize' => array(        'description' => 'The size of the file in bytes.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'status' => array(        'description' => 'A flag indicating whether file is temporary (1) or permanent (0).',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'timestamp' => array(        'description' => 'UNIX timestamp for when the file was added.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      ),    'indexes' => array(      'uid' => array('uid'),      'status' => array('status'),      'timestamp' => array('timestamp'),      ),    'primary key' => array('fid'),    );  $schema['flood'] = array(    'description' => 'Flood controls the threshold of events, such as the number of contact attempts.',    'fields' => array(      'fid' => array(        'description' => 'Unique flood event ID.',        'type' => 'serial',        'not null' => TRUE),      'event' => array(        'description' => 'Name of event (e.g. contact).',        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => ''),      'hostname' => array(        'description' => 'Hostname of the visitor.',        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => ''),      'timestamp' => array(        'description' => 'Timestamp of the event.',        'type' => 'int',        'not null' => TRUE,        'default' => 0)      ),    'primary key' => array('fid'),    'indexes' => array(      'allow' => array('event', 'hostname', 'timestamp'),    ),    );  $schema['history'] = array(    'description' => 'A record of which {users} have read which {node}s.',    'fields' => array(      'uid' => array(        'description' => 'The {users}.uid that read the {node} nid.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'nid' => array(        'description' => 'The {node}.nid that was read.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'timestamp' => array(        'description' => 'The Unix timestamp at which the read occurred.',        'type' => 'int',        'not null' => TRUE,        'default' => 0)      ),    'primary key' => array('uid', 'nid'),    'indexes' => array(      'nid' => array('nid'),    ),    );  $schema['menu_router'] = array(    'description' => 'Maps paths to various callbacks (access, page and title)',    'fields' => array(      'path' => array(        'description' => 'Primary Key: the Drupal path this entry describes',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'load_functions' => array(        'description' => 'A serialized array of function names (like node_load) to be called to load an object corresponding to a part of the current path.',        'type' => 'text',        'not null' => TRUE,),      'to_arg_functions' => array(        'description' => 'A serialized array of function names (like user_uid_optional_to_arg) to be called to replace a part of the router path with another string.',        'type' => 'text',        'not null' => TRUE,),      'access_callback' => array(        'description' => 'The callback which determines the access to this router path. Defaults to user_access.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'access_arguments' => array(        'description' => 'A serialized array of arguments for the access callback.',        'type' => 'text',        'not null' => FALSE),      'page_callback' => array(        'description' => 'The name of the function that renders the page.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'page_arguments' => array(        'description' => 'A serialized array of arguments for the page callback.',        'type' => 'text',        'not null' => FALSE),      'fit' => array(        'description' => 'A numeric representation of how specific the path is.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'number_parts' => array(        'description' => 'Number of parts in this router path.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'tab_parent' => array(        'description' => 'Only for local tasks (tabs) - the router path of the parent page (which may also be a local task).',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'tab_root' => array(        'description' => 'Router path of the closest non-tab parent page. For pages that are not local tasks, this will be the same as the path.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'title' => array(        'description' => 'The title for the current page, or the title for the tab if this is a local task.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'title_callback' => array(        'description' => 'A function which will alter the title. Defaults to t()',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'title_arguments' => array(        'description' => 'A serialized array of arguments for the title callback. If empty, the title will be used as the sole argument for the title callback.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'type' => array(        'description' => 'Numeric representation of the type of the menu item, like MENU_LOCAL_TASK.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'block_callback' => array(        'description' => 'Name of a function used to render the block on the system administration page for this item.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'description' => array(        'description' => 'A description of this item.',        'type' => 'text',        'not null' => TRUE),      'position' => array(        'description' => 'The position of the block (left or right) on the system administration page for this item.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'weight' => array(        'description' => 'Weight of the element. Lighter weights are higher up, heavier weights go down.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'file' => array(        'description' => 'The file to include for this element, usually the page callback function lives in this file.',        'type' => 'text',        'size' => 'medium')      ),    'indexes' => array(      'fit' => array('fit'),      'tab_parent' => array('tab_parent'),      'tab_root_weight_title' => array(array('tab_root', 64), 'weight', 'title'),            ),    'primary key' => array('path'),    );  $schema['menu_links'] = array(    'description' => 'Contains the individual links within a menu.',    'fields' => array(     'menu_name' => array(        'description' => "The menu name. All links with the same menu name (such as 'navigation') are part of the same menu.",        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => ''),      'mlid' => array(        'description' => 'The menu link ID (mlid) is the integer primary key.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'plid' => array(        'description' => 'The parent link ID (plid) is the mlid of the link above in the hierarchy, or zero if the link is at the top level in its menu.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'link_path' => array(        'description' => 'The Drupal path or external path this link points to.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'router_path' => array(        'description' => 'For links corresponding to a Drupal path (external = 0), this connects the link to a {menu_router}.path for joins.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'link_title' => array(      'description' => 'The text displayed for the link, which may be modified by a title callback stored in {menu_router}.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'options' => array(        'description' => 'A serialized array of options to be passed to the url() or l() function, such as a query string or HTML attributes.',        'type' => 'text',        'not null' => FALSE),      'module' => array(        'description' => 'The name of the module that generated this link.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => 'system'),      'hidden' => array(        'description' => 'A flag for whether the link should be rendered in menus. (1 = a disabled menu item that may be shown on admin screens, -1 = a menu callback, 0 = a normal, visible link)',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'external' => array(        'description' => 'A flag to indicate if the link points to a full URL starting with a protocol, like http:// (1 = external, 0 = internal).',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'has_children' => array(        'description' => 'Flag indicating whether any links have this link as a parent (1 = children exist, 0 = no children).',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'expanded' => array(        'description' => 'Flag for whether this link should be rendered as expanded in menus - expanded links always have their child links displayed, instead of only when the link is in the active trail (1 = expanded, 0 = not expanded)',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'weight' => array(        'description' => 'Link weight among links in the same menu at the same depth.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'depth' => array(        'description' => 'The depth relative to the top level. A link with plid == 0 will have depth == 1.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'customized' => array(        'description' => 'A flag to indicate that the user has manually created or edited the link (1 = customized, 0 = not customized).',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'p1' => array(        'description' => 'The first mlid in the materialized path. If N = depth, then pN must equal the mlid. If depth > 1 then p(N-1) must equal the plid. All pX where X > depth must equal zero. The columns p1 .. p9 are also called the parents.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p2' => array(        'description' => 'The second mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p3' => array(        'description' => 'The third mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p4' => array(        'description' => 'The fourth mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p5' => array(        'description' => 'The fifth mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p6' => array(        'description' => 'The sixth mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p7' => array(        'description' => 'The seventh mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p8' => array(        'description' => 'The eighth mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p9' => array(        'description' => 'The ninth mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'updated' => array(        'description' => 'Flag that indicates that this link was generated during the update from Drupal 5.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      ),    'indexes' => array(      'path_menu' => array(array('link_path', 128), 'menu_name'),      'menu_plid_expand_child' => array(        'menu_name', 'plid', 'expanded', 'has_children'),      'menu_parents' => array(        'menu_name', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7', 'p8', 'p9'),      'router_path' => array(array('router_path', 128)),      ),    'primary key' => array('mlid'),    );  $schema['semaphore'] = array(    'description' => 'Table for holding semaphores, locks, flags, etc. that cannot be stored as Drupal variables since they must not be cached.',    'fields' => array(      'name' => array(        'description' => 'Primary Key: Unique name.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'value' => array(        'description' => 'A value.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'expire' => array(        'description' => 'A Unix timestamp with microseconds indicating when the semaphore should expire.',        'type' => 'float',        'size' => 'big',        'not null' => TRUE),      ),    'indexes' => array('expire' => array('expire')),    'primary key' => array('name'),    );  $schema['sessions'] = array(    'description' => "Drupal's session handlers read and write into the sessions table. Each record represents a user session, either anonymous or authenticated.",    'fields' => array(      'uid' => array(        'description' => 'The {users}.uid corresponding to a session, or 0 for anonymous user.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE),      'sid' => array(        'description' => "Primary key: A session ID. The value is generated by PHP's Session API.",        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => ''),      'hostname' => array(        'description' => 'The IP address that last used this session ID (sid).',        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => ''),      'timestamp' => array(        'description' => 'The Unix timestamp when this session last requested a page. Old records are purged by PHP automatically.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'cache' => array(        'description' => "The time of this user's last post. This is used when the site has specified a minimum_cache_lifetime. See cache_get().",        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'session' => array(        'description' => 'The serialized contents of $_SESSION, an array of name/value pairs that persists across page requests by this session ID. Drupal loads $_SESSION from here at the start of each request and saves it at the end.',        'type' => 'text',        'not null' => FALSE,        'size' => 'big')      ),    'primary key' => array('sid'),    'indexes' => array(      'timestamp' => array('timestamp'),      'uid' => array('uid')      ),    );  $schema['system'] = array(    'description' => "A list of all modules, themes, and theme engines that are or have been installed in Drupal's file system.",    'fields' => array(      'filename' => array(        'description' => 'The path of the primary file for this item, relative to the Drupal root; e.g. modules/node/node.module.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'name' => array(        'description' => 'The name of the item; e.g. node.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'type' => array(        'description' => 'The type of the item, either module, theme, or theme_engine.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'owner' => array(        'description' => "A theme's 'parent'. Can be either a theme or an engine.",        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'status' => array(        'description' => 'Boolean indicating whether or not this item is enabled.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'throttle' => array(        'description' => 'Boolean indicating whether this item is disabled when the throttle.module disables throttleable items.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'bootstrap' => array(        'description' => "Boolean indicating whether this module is loaded during Drupal's early bootstrapping phase (e.g. even before the page cache is consulted).",        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'schema_version' => array(        'description' => "The module's database schema version number. -1 if the module is not installed (its tables do not exist); 0 or the largest N of the module's hook_update_N() function that has either been run or existed when the module was first installed.",        'type' => 'int',        'not null' => TRUE,        'default' => -1,        'size' => 'small'),      'weight' => array(        'description' => "The order in which this module's hooks should be invoked relative to other modules. Equal-weighted modules are ordered by name.",        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'info' => array(        'description' => "A serialized array containing information from the module's .info file; keys can include name, description, package, version, core, dependencies, dependents, and php.",        'type' => 'text',        'not null' => FALSE)      ),    'primary key' => array('filename'),    'indexes' =>      array(        'modules' => array(array('type', 12), 'status', 'weight', 'filename'),        'bootstrap' => array(array('type', 12), 'status', 'bootstrap', 'weight', 'filename'),        'type_name' => array(array('type', 12), 'name'),      ),    );  $schema['url_alias'] = array(    'description' => 'A list of URL aliases for Drupal paths; a user may visit either the source or destination path.',    'fields' => array(      'pid' => array(        'description' => 'A unique path alias identifier.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'src' => array(        'description' => 'The Drupal path this alias is for; e.g. node/12.',        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => ''),      'dst' => array(        'description' => 'The alias for this path; e.g. title-of-the-story.',        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => ''),      'language' => array(        'description' => 'The language this alias is for; if blank, the alias will be used for unknown languages. Each Drupal path can have an alias for each supported language.',        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => '')      ),    'unique keys' => array('dst_language_pid' => array('dst', 'language', 'pid')),    'primary key' => array('pid'),    'indexes' => array('src_language_pid' => array('src', 'language', 'pid')),    );  return $schema;}// Updates for core.function system_update_last_removed() {  return 1021;}/** * @defgroup updates-5.x-extra Extra system updates for 5.x * @{ *//** * Add index on users created column. */function system_update_1022() {  $ret = array();  db_add_index($ret, 'users', 'created', array('created'));  // Also appears as system_update_6004(). Ensure we don't update twice.  variable_set('system_update_1022', TRUE);  return $ret;}/** * @} End of "defgroup updates-5.x-extra" *//** * @defgroup updates-5.x-to-6.x System updates from 5.x to 6.x * @{ *//** * Remove auto_increment from {boxes} to allow adding custom blocks with * visibility settings. */function system_update_6000() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'mysql':    case 'mysqli':      $max = (int)db_result(db_query('SELECT MAX(bid) FROM {boxes}'));      $ret[] = update_sql('ALTER TABLE {boxes} CHANGE COLUMN bid bid int NOT NULL');      $ret[] = update_sql("REPLACE INTO {sequences} VALUES ('{boxes}_bid', $max)");      break;  }  return $ret;}/** * Add version id column to {term_node} to allow taxonomy module to use revisions. */function system_update_6001() {  $ret = array();  // Add vid to term-node relation.  The schema says it is unsigned.  db_add_field($ret, 'term_node', 'vid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_drop_primary_key($ret, 'term_node');  db_add_primary_key($ret, 'term_node', array('vid', 'tid', 'nid'));  db_add_index($ret, 'term_node', 'vid', array('vid'));  db_query('UPDATE {term_node} SET vid = (SELECT vid FROM {node} n WHERE {term_node}.nid = n.nid)');  return $ret;}/** * Increase the maximum length of variable names from 48 to 128. */function system_update_6002() {  $ret = array();  db_drop_primary_key($ret, 'variable');  db_change_field($ret, 'variable', 'name', 'name', array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''));  db_add_primary_key($ret, 'variable', array('name'));  return $ret;}/** * Add index on comments status column. */function system_update_6003() {  $ret = array();  db_add_index($ret, 'comments', 'status', array('status'));  return $ret;}/** * This update used to add an index on users created column (#127941). * However, system_update_1022() does the same thing.  This update * tried to detect if 1022 had already run but failed to do so, * resulting in an "index already exists" error. * * Adding the index here is never necessary.  Sites installed before * 1022 will run 1022, getting the update.  Sites installed on/after 1022 * got the index when the table was first created.  Therefore, this * function is now a no-op. */function system_update_6004() {  return array();}/** * Add language to url_alias table and modify indexes. */function system_update_6005() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      db_add_column($ret, 'url_alias', 'language', 'varchar(12)', array('default' => "''", 'not null' => TRUE));      // As of system.install:1.85 (before the new language      // subsystem), new installs got a unique key named      // url_alias_dst_key on url_alias.dst.  Unfortunately,      // system_update_162 created a unique key inconsistently named      // url_alias_dst_idx on url_alias.dst (keys should have the _key      // suffix, indexes the _idx suffix).  Therefore, sites installed      // before system_update_162 have a unique key with a different      // name than sites installed after system_update_162().  Now, we      // want to drop the unique key on dst which may have either one      // of two names and create a new unique key on (dst, language).      // There is no way to know which key name exists so we have to      // drop both, causing an SQL error.  Thus, we just hide the      // error and only report the update_sql results that work.      $err = error_reporting(0);      $ret1 = update_sql('DROP INDEX {url_alias}_dst_idx');      if ($ret1['success']) {  $ret[] = $ret1;      }      $ret1 = array();      db_drop_unique_key($ret, 'url_alias', 'dst');      foreach ($ret1 as $r) {  if ($r['success']) {    $ret[] = $r;  }      }      error_reporting($err);      $ret[] = update_sql('CREATE UNIQUE INDEX {url_alias}_dst_language_idx ON {url_alias}(dst, language)');      break;    case 'mysql':    case 'mysqli':      $ret[] = update_sql("ALTER TABLE {url_alias} ADD language varchar(12) NOT NULL default ''");      $ret[] = update_sql("ALTER TABLE {url_alias} DROP INDEX dst");      $ret[] = update_sql("ALTER TABLE {url_alias} ADD UNIQUE dst_language (dst, language)");      break;  }  return $ret;}/** * Drop useless indices on node_counter table. */function system_update_6006() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      $ret[] = update_sql('DROP INDEX {node_counter}_daycount_idx');      $ret[] = update_sql('DROP INDEX {node_counter}_totalcount_idx');      $ret[] = update_sql('DROP INDEX {node_counter}_timestamp_idx');      break;    case 'mysql':    case 'mysqli':      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX daycount");      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX totalcount");      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX timestamp");      break;  }  return $ret;}/** * Change the severity column in the watchdog table to the new values. */function system_update_6007() {  $ret = array();  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_NOTICE ." WHERE severity = 0");  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_WARNING ." WHERE severity = 1");  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_ERROR ." WHERE severity = 2");  return $ret;}/** * Add info files to themes.  The info and owner columns are added by * update_fix_d6_requirements() in update.php to avoid a large number * of error messages from update.php.  All we need to do here is copy * description to owner and then drop description. */function system_update_6008() {  $ret = array();  $ret[] = update_sql('UPDATE {system} SET owner = description');  db_drop_field($ret, 'system', 'description');  // Rebuild system table contents.  module_rebuild_cache();  system_theme_data();  return $ret;}/** * The PHP filter is now a separate module. */function system_update_6009() {  $ret = array();  // If any input format used the Drupal 5 PHP filter.  if (db_result(db_query("SELECT COUNT(format) FROM {filters} WHERE module = 'filter' AND delta = 1"))) {    // Enable the PHP filter module.    $ret[] = update_sql("UPDATE {system} SET status = 1 WHERE name = 'php' AND type = 'module'");    // Update the input filters.    $ret[] = update_sql("UPDATE {filters} SET delta = 0, module = 'php' WHERE module = 'filter' AND delta = 1");  }  // With the removal of the PHP evaluator filter, the deltas of the line break  // and URL filter have changed.  $ret[] = update_sql("UPDATE {filters} SET delta = 1 WHERE module = 'filter' AND delta = 2");  $ret[] = update_sql("UPDATE {filters} SET delta = 2 WHERE module = 'filter' AND delta = 3");  return $ret;}/** * Add variable replacement for watchdog messages. * * The variables field is NOT NULL and does not have a default value. * Existing log messages should not be translated in the new system, * so we insert 'N;' (serialize(NULL)) as the temporary default but * then remove the default value to match the schema. */function system_update_6010() {  $ret = array();  db_add_field($ret, 'watchdog', 'variables', array('type' => 'text', 'size' => 'big', 'not null' => TRUE, 'initial' => 'N;'));  return $ret;}/** * Add language support to nodes */function system_update_6011() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      db_add_column($ret, 'node', 'language', 'varchar(12)', array('default' => "''", 'not null' => TRUE));      break;    case 'mysql':    case 'mysqli':      $ret[] = update_sql("ALTER TABLE {node} ADD language varchar(12) NOT NULL default ''");      break;  }  return $ret;}/** * Add serialized field to cache tables.  This is now handled directly * by update.php, so this function is a no-op. */function system_update_6012() {  return array();}/** * Rebuild cache data for theme system changes */function system_update_6013() {  // Rebuild system table contents.  module_rebuild_cache();  system_theme_data();  return array(array('success' => TRUE, 'query' => 'Cache rebuilt.'));}/** * Record that the installer is done, so it is not * possible to run the installer on upgraded sites. */function system_update_6014() {  variable_set('install_task', 'done');  return array(array('success' => TRUE, 'query' => "variable_set('install_task')"));}/** * Add the form cache table. */function system_update_6015() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      $ret[] = update_sql("CREATE TABLE {cache_form} (        cid varchar(255) NOT NULL default '',        data bytea,        expire int NOT NULL default '0',        created int NOT NULL default '0',        headers text,        serialized smallint NOT NULL default '0',        PRIMARY KEY (cid)    )");      $ret[] = update_sql("CREATE INDEX {cache_form}_expire_idx ON {cache_form} (expire)");      break;    case 'mysql':    case 'mysqli':      $ret[] = update_sql("CREATE TABLE {cache_form} (        cid varchar(255) NOT NULL default '',        data longblob,        expire int NOT NULL default '0',        created int NOT NULL default '0',        headers text,        serialized int(1) NOT NULL default '0',        PRIMARY KEY (cid),        INDEX expire (expire)      ) /*!40100 DEFAULT CHARACTER SET UTF8 */ ");      break;  }  return $ret;}/** * Make {node}'s primary key be nid, change nid,vid to a unique key. * Add primary keys to block, filters, flood, permission, and term_relation. */function system_update_6016() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      $ret[] = update_sql("ALTER TABLE {node} ADD CONSTRAINT {node}_nid_vid_key UNIQUE (nid, vid)");      db_add_column($ret, 'blocks', 'bid', 'serial');      $ret[] = update_sql("ALTER TABLE {blocks} ADD PRIMARY KEY (bid)");      db_add_column($ret, 'filters', 'fid', 'serial');      $ret[] = update_sql("ALTER TABLE {filters} ADD PRIMARY KEY (fid)");      db_add_column($ret, 'flood', 'fid', 'serial');      $ret[] = update_sql("ALTER TABLE {flood} ADD PRIMARY KEY (fid)");      db_add_column($ret, 'permission', 'pid', 'serial');      $ret[] = update_sql("ALTER TABLE {permission} ADD PRIMARY KEY (pid)");      db_add_column($ret, 'term_relation', 'trid', 'serial');      $ret[] = update_sql("ALTER TABLE {term_relation} ADD PRIMARY KEY (trid)");      db_add_column($ret, 'term_synonym', 'tsid', 'serial');      $ret[] = update_sql("ALTER TABLE {term_synonym} ADD PRIMARY KEY (tsid)");      break;    case 'mysql':    case 'mysqli':      $ret[] = update_sql('ALTER TABLE {node} ADD UNIQUE KEY nid_vid (nid, vid)');      $ret[] = update_sql("ALTER TABLE {blocks} ADD bid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      $ret[] = update_sql("ALTER TABLE {filters} ADD fid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      $ret[] = update_sql("ALTER TABLE {flood} ADD fid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      $ret[] = update_sql("ALTER TABLE {permission} ADD pid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      $ret[] = update_sql("ALTER TABLE {term_relation} ADD trid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      $ret[] = update_sql("ALTER TABLE {term_synonym} ADD tsid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      break;  }  return $ret;}/** * Rename settings related to user.module email notifications. */function system_update_6017() {  $ret = array();  // Maps old names to new ones.  $var_names = array(    'admin'    => 'register_admin_created',    'approval' => 'register_pending_approval',    'welcome'  => 'register_no_approval_required',    'pass'     => 'password_reset',  );  foreach ($var_names as $old => $new) {    foreach (array('_subject', '_body') as $suffix) {      $old_name = 'user_mail_'. $old . $suffix;      $new_name = 'user_mail_'. $new . $suffix;      if ($old_val = variable_get($old_name, FALSE)) {        variable_set($new_name, $old_val);        variable_del($old_name);        $ret[] = array('success' => TRUE, 'query' => "variable_set($new_name)");        $ret[] = array('success' => TRUE, 'query' => "variable_del($old_name)");        if ($old_name == 'user_mail_approval_body') {          drupal_set_message('Saving an old value of the welcome message body for users that are pending administrator approval. However, you should consider modifying this text, since Drupal can now be configured to automatically notify users and send them their login information when their accounts are approved. See the <a href="'. url('admin/user/settings') .'">User settings</a> page for details.');        }      }    }  }  return $ret;}/** * Add HTML corrector to HTML formats or replace the old module if it was in use. */function system_update_6018() {  $ret = array();  // Disable htmlcorrector.module, if it exists and replace its filter.  if (module_exists('htmlcorrector')) {    module_disable(array('htmlcorrector'));    $ret[] = update_sql("UPDATE {filter_formats} SET module = 'filter', delta = 3 WHERE module = 'htmlcorrector'");    $ret[] = array('success' => TRUE, 'query' => 'HTML Corrector module was disabled; this functionality has now been added to core.');    return $ret;  }  // Otherwise, find any format with 'HTML' in its name and add the filter at the end.  $result = db_query("SELECT format, name FROM {filter_formats} WHERE name LIKE '%HTML%'");  while ($format = db_fetch_object($result)) {    $weight = db_result(db_query("SELECT MAX(weight) FROM {filters} WHERE format = %d", $format->format));    db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $format->format, 'filter', 3, max(10, $weight + 1));    $ret[] = array('success' => TRUE, 'query' => "HTML corrector filter added to the '". $format->name ."' input format.");  }  return $ret;}/** * Reconcile small differences in the previous, manually created mysql * and pgsql schemas so they are the same and can be represented by a * single schema structure. * * Note that the mysql and pgsql cases make different changes.  This * is because each schema needs to be tweaked in different ways to * conform to the new schema structure.  Also, since they operate on * tables defined by many optional core modules which may not ever * have been installed, they must test each table for existence.  If * the modules are first installed after this update exists the tables * will be created from the schema structure and will start out * correct. */function system_update_6019() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      // Remove default ''.      if (db_table_exists('aggregator_feed')) {        db_field_set_no_default($ret, 'aggregator_feed', 'description');        db_field_set_no_default($ret, 'aggregator_feed', 'image');      }      db_field_set_no_default($ret, 'blocks', 'pages');      if (db_table_exists('contact')) {        db_field_set_no_default($ret, 'contact', 'recipients');        db_field_set_no_default($ret, 'contact', 'reply');      }      db_field_set_no_default($ret, 'watchdog', 'location');      db_field_set_no_default($ret, 'node_revisions', 'body');      db_field_set_no_default($ret, 'node_revisions', 'teaser');      db_field_set_no_default($ret, 'node_revisions', 'log');      // Update from pgsql 'float' (which means 'double precision') to      // schema 'float' (which in pgsql means 'real').      if (db_table_exists('search_index')) {        db_change_field($ret, 'search_index', 'score', 'score', array('type' => 'float'));      }      if (db_table_exists('search_total')) {        db_change_field($ret, 'search_total', 'count', 'count', array('type' => 'float'));      }      // Replace unique index dst_language with a unique constraint.  The      // result is the same but the unique key fits our current schema      // structure.  Also, the postgres documentation implies that      // unique constraints are preferable to unique indexes.  See      // http://www.postgresql.org/docs/8.2/interactive/indexes-unique.html.      if (db_table_exists('url_alias')) {        db_drop_index($ret, 'url_alias', 'dst_language');        db_add_unique_key($ret, 'url_alias', 'dst_language',          array('dst', 'language'));      }      // Fix term_node pkey: mysql and pgsql code had different orders.      if (db_table_exists('term_node')) {        db_drop_primary_key($ret, 'term_node');        db_add_primary_key($ret, 'term_node', array('vid', 'tid', 'nid'));      }      // Make boxes.bid unsigned.      db_drop_primary_key($ret, 'boxes');      db_change_field($ret, 'boxes', 'bid', 'bid', array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array('bid')));      // Fix primary key      db_drop_primary_key($ret, 'node');      db_add_primary_key($ret, 'node', array('nid'));      break;    case 'mysql':    case 'mysqli':      // Rename key 'link' to 'url'.      if (db_table_exists('aggregator_feed')) {        db_drop_unique_key($ret, 'aggregator_feed', 'link');        db_add_unique_key($ret, 'aggregator_feed', 'url', array('url'));      }      // Change to size => small.      if (db_table_exists('boxes')) {        db_change_field($ret, 'boxes', 'format', 'format', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));      }      // Change to size => small.      // Rename index 'lid' to 'nid'.      if (db_table_exists('comments')) {        db_change_field($ret, 'comments', 'format', 'format', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));        db_drop_index($ret, 'comments', 'lid');        db_add_index($ret, 'comments', 'nid', array('nid'));      }      // Change to size => small.      db_change_field($ret, 'cache', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));      db_change_field($ret, 'cache_filter', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));      db_change_field($ret, 'cache_page', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));      db_change_field($ret, 'cache_form', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));      // Remove default => 0, set auto increment.      $new_uid = 1 + db_result(db_query('SELECT MAX(uid) FROM {users}'));      $ret[] = update_sql('UPDATE {users} SET uid = '. $new_uid .' WHERE uid = 0');      db_drop_primary_key($ret, 'users');      db_change_field($ret, 'users', 'uid', 'uid', array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array('uid')));      $ret[] = update_sql('UPDATE {users} SET uid = 0 WHERE uid = '. $new_uid);      // Special field names.      $map = array('node_revisions' => 'vid');      // Make sure these tables have proper auto_increment fields.      foreach (array('boxes', 'files', 'node', 'node_revisions') as $table) {        $field = isset($map[$table]) ? $map[$table] : $table[0] .'id';        db_drop_primary_key($ret, $table);        db_change_field($ret, $table, $field, $field, array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array($field)));      }      break;  }  return $ret;}/** * Create the tables for the new menu system. */function system_update_6020() {  $ret = array();  $schema['menu_router'] = array(    'fields' => array(      'path'             => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'load_functions'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'to_arg_functions' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'access_callback'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'access_arguments' => array('type' => 'text', 'not null' => FALSE),      'page_callback'    => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'page_arguments'   => array('type' => 'text', 'not null' => FALSE),      'fit'              => array('type' => 'int', 'not null' => TRUE, 'default' => 0),      'number_parts'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'tab_parent'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'tab_root'         => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'title'            => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'title_callback'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'title_arguments'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'type'             => array('type' => 'int', 'not null' => TRUE, 'default' => 0),      'block_callback'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'description'      => array('type' => 'text', 'not null' => TRUE),      'position'         => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'weight'           => array('type' => 'int', 'not null' => TRUE, 'default' => 0),      'file'             => array('type' => 'text', 'size' => 'medium')    ),    'indexes' => array(      'fit'        => array('fit'),      'tab_parent' => array('tab_parent')    ),    'primary key' => array('path'),  );  $schema['menu_links'] = array(    'fields' => array(      'menu_name'    => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),      'mlid'         => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE),      'plid'         => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'link_path'    => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'router_path'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'link_title'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'options'      => array('type' => 'text', 'not null' => FALSE),      'module'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => 'system'),      'hidden'       => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'external'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'has_children' => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'expanded'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'weight'       => array('type' => 'int', 'not null' => TRUE, 'default' => 0),      'depth'        => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'customized'   => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'p1'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p2'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p3'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p4'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p5'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p6'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p7'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p8'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p9'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'updated'      => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),    ),    'indexes' => array(      'path_menu'              => array(array('link_path', 128), 'menu_name'),      'menu_plid_expand_child' => array('menu_name', 'plid', 'expanded', 'has_children'),      'menu_parents'           => array('menu_name', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7', 'p8', 'p9'),      'router_path'            => array(array('router_path', 128)),    ),    'primary key' => array('mlid'),  );  foreach ($schema as $name => $table) {    db_create_table($ret, $name, $table);  }  return $ret;}/** * Migrate the menu items from the old menu system to the new menu_links table. */function system_update_6021() {  $ret = array('#finished' => 0);  $menus = array(    'navigation' => array(      'menu_name' => 'navigation',      'title' => 'Navigation',      'description' => 'The navigation menu is provided by Drupal and is the main interactive menu for any site. It is usually the only menu that contains personalized links for authenticated users, and is often not even visible to anonymous users.',    ),    'primary-links' => array(      'menu_name' => 'primary-links',      'title' => 'Primary links',      'description' => 'Primary links are often used at the theme layer to show the major sections of a site. A typical representation for primary links would be tabs along the top.',    ),    'secondary-links' => array(      'menu_name' => 'secondary-links',      'title' => 'Secondary links',      'description' => 'Secondary links are often used for pages like legal notices, contact details, and other secondary navigation items that play a lesser role than primary links.',    ),  );  // Multi-part update  if (!isset($_SESSION['system_update_6021'])) {    db_add_field($ret, 'menu', 'converted', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0, 'size' => 'tiny'));    $_SESSION['system_update_6021_max'] = db_result(db_query('SELECT COUNT(*) FROM {menu}'));    $_SESSION['menu_menu_map'] = array(1 => 'navigation');    // 0 => FALSE is for new menus, 1 => FALSE is for the navigation.    $_SESSION['menu_item_map'] = array(0 => FALSE, 1 => FALSE);    $table = array(      'fields' => array(        'menu_name'   => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),        'title'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),        'description' => array('type' => 'text', 'not null' => FALSE),      ),      'primary key' => array('menu_name'),    );    db_create_table($ret, 'menu_custom', $table);    db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menus['navigation']);    $_SESSION['system_update_6021'] = 0;  }  $limit = 50;  while ($limit-- && ($item = db_fetch_array(db_query_range('SELECT * FROM {menu} WHERE converted = 0', 0, 1)))) {    // If it's not a menu...    if ($item['pid']) {      // Let's climb up until we find an item with a converted parent.      $item_original = $item;      while ($item && !isset($_SESSION['menu_item_map'][$item['pid']])) {        $item = db_fetch_array(db_query('SELECT * FROM {menu} WHERE mid = %d', $item['pid']));      }      // This can only occur if the menu entry is a leftover in the menu table.      // These do not appear in Drupal 5 anyways, so we skip them.      if (!$item) {        db_query('UPDATE {menu} SET converted = %d WHERE mid = %d', 1, $item_original['mid']);        $_SESSION['system_update_6021']++;        continue;      }    }    // We need to recheck because item might have changed.    if ($item['pid']) {      // Fill the new fields.      $item['link_title'] = $item['title'];      $item['link_path'] = drupal_get_normal_path($item['path']);      // We know the parent is already set. If it's not FALSE then it's an item.      if ($_SESSION['menu_item_map'][$item['pid']]) {        // The new menu system parent link id.        $item['plid'] = $_SESSION['menu_item_map'][$item['pid']]['mlid'];        // The new menu system menu name.        $item['menu_name'] = $_SESSION['menu_item_map'][$item['pid']]['menu_name'];      }      else {        // This a top level element.        $item['plid'] = 0;        // The menu name is stored among the menus.        $item['menu_name'] = $_SESSION['menu_menu_map'][$item['pid']];      }      // Is the element visible in the menu block?      $item['hidden'] = !($item['type'] & MENU_VISIBLE_IN_TREE);      // Is it a custom(ized) element?      if ($item['type'] & (MENU_CREATED_BY_ADMIN | MENU_MODIFIED_BY_ADMIN)) {        $item['customized'] = TRUE;      }      // Items created via the menu module need to be assigned to it.      if ($item['type'] & MENU_CREATED_BY_ADMIN) {        $item['module'] = 'menu';        $item['router_path'] = '';        $item['updated'] = TRUE;      }      else {        $item['module'] = 'system';        $item['router_path'] = $item['path'];        $item['updated'] = FALSE;      }      if ($item['description']) {        $item['options']['attributes']['title'] = $item['description'];      }                  // Save the link.      menu_link_save($item);      $_SESSION['menu_item_map'][$item['mid']] = array('mlid' => $item['mlid'], 'menu_name' => $item['menu_name']);    }    elseif (!isset($_SESSION['menu_menu_map'][$item['mid']])) {      $item['menu_name'] = 'menu-'. preg_replace('/[^a-zA-Z0-9]/', '-', strtolower($item['title']));      $item['menu_name'] = substr($item['menu_name'], 0, 20);      $original_menu_name = $item['menu_name'];      $i = 0;      while (db_result(db_query("SELECT menu_name FROM {menu_custom} WHERE menu_name = '%s'", $item['menu_name']))) {        $item['menu_name'] = $original_menu_name . ($i++);      }      if ($item['path']) {        // Another bunch of bogus entries. Apparently, these are leftovers        // from Drupal 4.7 .        $_SESSION['menu_bogus_menus'][] = $item['menu_name'];      }      else {        // Add this menu to the list of custom menus.        db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '')", $item['menu_name'], $item['title']);      }      $_SESSION['menu_menu_map'][$item['mid']] = $item['menu_name'];      $_SESSION['menu_item_map'][$item['mid']] = FALSE;    }    db_query('UPDATE {menu} SET converted = %d WHERE mid = %d', 1, $item['mid']);    $_SESSION['system_update_6021']++;  }  if ($_SESSION['system_update_6021'] >= $_SESSION['system_update_6021_max']) {    if (!empty($_SESSION['menu_bogus_menus'])) {      // Remove entries in bogus menus. This is secure because we deleted      // every non-alpanumeric character from the menu name.      $ret[] = update_sql("DELETE FROM {menu_links} WHERE menu_name IN ('". implode("', '", $_SESSION['menu_bogus_menus']) ."')");    }    $menu_primary_menu = variable_get('menu_primary_menu', 0);    // Ensure that we wind up with a system menu named 'primary-links'.    if (isset($_SESSION['menu_menu_map'][2])) {      // The primary links menu that ships with Drupal 5 has mid = 2.  If this      // menu hasn't been deleted by the site admin, we use that.      $updated_primary_links_menu = 2;    }    elseif (isset($_SESSION['menu_menu_map'][$menu_primary_menu]) && $menu_primary_menu > 1) {      // Otherwise, we use the menu that is currently assigned to the primary      // links region of the theme, as long as it exists and isn't the      // Navigation menu.      $updated_primary_links_menu = $menu_primary_menu;    }    else {      // As a last resort, create 'primary-links' as a new menu.      $updated_primary_links_menu = 0;      db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menus['primary-links']);    }    if ($updated_primary_links_menu) {      // Change the existing menu name to 'primary-links'.      $replace = array('%new_name' => 'primary-links', '%desc' => $menus['primary-links']['description'], '%old_name' => $_SESSION['menu_menu_map'][$updated_primary_links_menu]);      $ret[] = update_sql(strtr("UPDATE {menu_custom} SET menu_name = '%new_name', description = '%desc' WHERE menu_name = '%old_name'", $replace));      $ret[] = update_sql("UPDATE {menu_links} SET menu_name = 'primary-links' WHERE menu_name = '". $_SESSION['menu_menu_map'][$updated_primary_links_menu] ."'");      $_SESSION['menu_menu_map'][$updated_primary_links_menu] = 'primary-links';    }    $menu_secondary_menu = variable_get('menu_secondary_menu', 0);    // Ensure that we wind up with a system menu named 'secondary-links'.    if (isset($_SESSION['menu_menu_map'][$menu_secondary_menu]) && $menu_secondary_menu > 1 && $menu_secondary_menu != $updated_primary_links_menu) {      // We use the menu that is currently assigned to the secondary links      // region of the theme, as long as (a) it exists, (b) it isn't the      // Navigation menu, (c) it isn't the same menu we assigned as the      // system 'primary-links' menu above, and (d) it isn't the same menu      // assigned to the primary links region of the theme.      $updated_secondary_links_menu = $menu_secondary_menu;    }    else {      // Otherwise, create 'secondary-links' as a new menu.      $updated_secondary_links_menu = 0;      db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menus['secondary-links']);    }    if ($updated_secondary_links_menu) {      // Change the existing menu name to 'secondary-links'.      $replace = array('%new_name' => 'secondary-links', '%desc' => $menus['secondary-links']['description'], '%old_name' => $_SESSION['menu_menu_map'][$updated_secondary_links_menu]);      $ret[] = update_sql(strtr("UPDATE {menu_custom} SET menu_name = '%new_name', description = '%desc' WHERE menu_name = '%old_name'", $replace));      $ret[] = update_sql("UPDATE {menu_links} SET menu_name = 'secondary-links' WHERE menu_name = '". $_SESSION['menu_menu_map'][$updated_secondary_links_menu] ."'");      $_SESSION['menu_menu_map'][$updated_secondary_links_menu] = 'secondary-links';    }    // Update menu OTF preferences.    $mid = variable_get('menu_parent_items', 0);    $menu_name = ($mid && isset($_SESSION['menu_menu_map'][$mid])) ? $_SESSION['menu_menu_map'][$mid] : 'navigation';    variable_set('menu_default_node_menu', $menu_name);    variable_del('menu_parent_items');    // Update the source of the primary and secondary links.    $menu_name = ($menu_primary_menu && isset($_SESSION['menu_menu_map'][$menu_primary_menu])) ? $_SESSION['menu_menu_map'][$menu_primary_menu] : '';    variable_set('menu_primary_links_source', $menu_name);    variable_del('menu_primary_menu');    $menu_name = ($menu_secondary_menu && isset($_SESSION['menu_menu_map'][$menu_secondary_menu])) ? $_SESSION['menu_menu_map'][$menu_secondary_menu] : '';    variable_set('menu_secondary_links_source', $menu_name);    variable_del('menu_secondary_menu');    // Skip the navigation menu - it is handled by the user module.    unset($_SESSION['menu_menu_map'][1]);    // Update the deltas for all menu module blocks.    foreach ($_SESSION['menu_menu_map'] as $mid => $menu_name) {      // This is again secure because we deleted every non-alpanumeric      // character from the menu name.      $ret[] = update_sql("UPDATE {blocks} SET delta = '". $menu_name ."' WHERE module = 'menu' AND delta = '". $mid ."'");      $ret[] = update_sql("UPDATE {blocks_roles} SET delta = '". $menu_name ."' WHERE module = 'menu' AND delta = '". $mid ."'");    }    $ret[] = array('success' => TRUE, 'query' => 'Relocated '. $_SESSION['system_update_6021'] .' existing items to the new menu system.');    $ret[] = update_sql("DROP TABLE {menu}");    unset($_SESSION['system_update_6021'], $_SESSION['system_update_6021_max'], $_SESSION['menu_menu_map'], $_SESSION['menu_item_map'], $_SESSION['menu_bogus_menus']);    // Create the menu overview links - also calls menu_rebuild(). If menu is    // disabled, then just call menu_rebuild.    if (function_exists('menu_enable')) {      menu_enable();    }    else {      menu_rebuild();    }    $ret['#finished'] = 1;  }  else {    $ret['#finished'] = $_SESSION['system_update_6021'] / $_SESSION['system_update_6021_max'];  }  return $ret;}/** * Update files tables to associate files to a uid by default instead of a nid. * Rename file_revisions to upload since it should only be used by the upload * module used by upload to link files to nodes. */function system_update_6022() {  $ret = array();  // Rename the nid field to vid, add status and timestamp fields, and indexes.  db_drop_index($ret, 'files', 'nid');  db_change_field($ret, 'files', 'nid', 'uid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_add_field($ret, 'files', 'status', array('type' => 'int', 'not null' => TRUE, 'default' => 0));  db_add_field($ret, 'files', 'timestamp', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_add_index($ret, 'files', 'uid', array('uid'));  db_add_index($ret, 'files', 'status', array('status'));  db_add_index($ret, 'files', 'timestamp', array('timestamp'));  // Rename the file_revisions table to upload then add nid column. Since we're  // changing the table name we need to drop and re-add the indexes and  // the primary key so both mysql and pgsql end up with the correct index  // names.  db_drop_primary_key($ret, 'file_revisions');  db_drop_index($ret, 'file_revisions', 'vid');  db_rename_table($ret, 'file_revisions', 'upload');  db_add_field($ret, 'upload', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_add_index($ret, 'upload', 'nid', array('nid'));  db_add_primary_key($ret, 'upload', array('vid', 'fid'));  db_add_index($ret, 'upload', 'fid', array('fid'));  // The nid column was renamed to uid. Use the old nid to find the node's uid.  update_sql('UPDATE {files} SET uid = (SELECT n.uid FROM {node} n WHERE {files}.uid = n.nid)');  update_sql('UPDATE {upload} SET nid = (SELECT r.nid FROM {node_revisions} r WHERE {upload}.vid = r.vid)');  // Mark all existing files as FILE_STATUS_PERMANENT.  $ret[] = update_sql('UPDATE {files} SET status = 1');  return $ret;}function system_update_6023() {  $ret = array();  // nid is DEFAULT 0  db_drop_index($ret, 'node_revisions', 'nid');  db_change_field($ret, 'node_revisions', 'nid', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_add_index($ret, 'node_revisions', 'nid', array('nid'));  return $ret;}/** * Add translation fields to nodes used by translation module. */function system_update_6024() {  $ret = array();  db_add_field($ret, 'node', 'tnid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_add_field($ret, 'node', 'translate', array('type' => 'int', 'not null' => TRUE, 'default' => 0));  db_add_index($ret, 'node', 'tnid', array('tnid'));  db_add_index($ret, 'node', 'translate', array('translate'));  return $ret;}/** * Increase the maximum length of node titles from 128 to 255. */function system_update_6025() {  $ret = array();  db_drop_index($ret, 'node', 'node_title_type');  db_change_field($ret, 'node', 'title', 'title', array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''));  db_add_index($ret, 'node', 'node_title_type', array('title', array('type', 4)));  db_change_field($ret, 'node_revisions', 'title', 'title', array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''));  return $ret;}/** * Display warning about new Update status module. */function system_update_6026() {  $ret = array();  // Notify user that new update module exists.  drupal_set_message('Drupal can check periodically for important bug fixes and security releases using the new update status module. This module can be turned on from the <a href="'. url('admin/build/modules') .'">modules administration page</a>. For more information please read the <a href="http://drupal.org/handbook/modules/update">Update status handbook page</a>.');  return $ret;}/** * Add block cache. */function system_update_6027() {  $ret = array();  // Create the blocks.cache column.  db_add_field($ret, 'blocks', 'cache', array('type' => 'int', 'not null' => TRUE, 'default' => 1, 'size' => 'tiny'));  // The cache_block table is created in update_fix_d6_requirements() since  // calls to cache_clear_all() would otherwise cause warnings.  // Fill in the values for the new 'cache' column in the {blocks} table.  foreach (module_list() as $module) {    if ($module_blocks = module_invoke($module, 'block', 'list')) {      foreach ($module_blocks as $delta => $block) {        if (isset($block['cache'])) {          db_query("UPDATE {blocks} SET cache = %d WHERE module = '%s' AND delta = '%s'", $block['cache'], $module, $delta);        }      }    }  }  return $ret;}/** * Add the node load cache table. */function system_update_6028() {  // Removed node_load cache to discuss it more for Drupal 7.  return array();}/** * Enable the dblog module on sites that upgrade, since otherwise * watchdog logging will stop unexpectedly. */function system_update_6029() {  // The watchdog table is now owned by dblog, which is not yet  // "installed" according to the system table, but the table already  // exists.  We set the module as "installed" here to avoid an error  // later.  //  // Although not the case for the initial D6 release, it is likely  // that dblog.install will have its own update functions eventually.  // However, dblog did not exist in D5 and this update is part of the  // initial D6 release, so we know that dblog is not installed yet.  // It is therefore correct to install it as version 0.  If  // dblog updates exist, the next run of update.php will get them.  drupal_set_installed_schema_version('dblog', 0);  module_enable(array('dblog'));  menu_rebuild();  return array(array('success' => TRUE, 'query' => "'dblog' module enabled."));}/** * Add the tables required by actions.inc. */function system_update_6030() {  $ret = array();  // Rename the old contrib actions table if it exists so the contrib version  // of the module can do something with the old data.  if (db_table_exists('actions')) {    db_rename_table($ret, 'actions', 'actions_old_contrib');  }  $schema['actions'] = array(    'fields' => array(      'aid' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => '0'),      'type' => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),      'callback' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'parameters' => array('type' => 'text', 'not null' => TRUE, 'size' => 'big'),      'description' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => '0'),    ),    'primary key' => array('aid'),  );  $schema['actions_aid'] = array(    'fields' => array(      'aid' => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE),    ),    'primary key' => array('aid'),  );  db_create_table($ret, 'actions', $schema['actions']);  db_create_table($ret, 'actions_aid', $schema['actions_aid']);  return $ret;}/** * Ensure that installer cannot be run again after updating from Drupal 5.x to 6.x * Actually, this is already done by system_update_6014(), so this is now a no-op. */function system_update_6031() {  return array();}/** * profile_fields.name used to be nullable but is part of a unique key * and so shouldn't be. */function system_update_6032() {  $ret = array();  if (db_table_exists('profile_fields')) {    db_drop_unique_key($ret, 'profile_fields', 'name');    db_change_field($ret, 'profile_fields', 'name', 'name', array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''));    db_add_unique_key($ret, 'profile_fields', 'name', array('name'));  }  return $ret;}/** * Change node_comment_statistics to be not autoincrement. */function system_update_6033() {  $ret = array();  if (db_table_exists('node_comment_statistics')) {    // On pgsql but not mysql, db_change_field() drops all keys    // involving the changed field, which in this case is the primary    // key.  The normal approach is explicitly drop the pkey, change the    // field, and re-create the pkey.    //    // Unfortunately, in this case that won't work on mysql; we CANNOT    // drop the pkey because on mysql auto-increment fields must be    // included in at least one key or index.    //    // Since we cannot drop the pkey before db_change_field(), after    // db_change_field() we may or may not still have a pkey.  The    // simple way out is to re-create the pkey only when using pgsql.    // Realistic requirements trump idealistic purity.    db_change_field($ret, 'node_comment_statistics', 'nid', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));    if ($GLOBALS['db_type'] == 'pgsql') {      db_add_primary_key($ret, 'node_comment_statistics', array('nid'));    }  }  return $ret;}/** * Rename permission "administer access control" to "administer permissions". */function system_update_6034() {  $ret = array();  $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");  while ($role = db_fetch_object($result)) {    $renamed_permission = preg_replace('/administer access control/', 'administer permissions', $role->perm);    if ($renamed_permission != $role->perm) {      $ret[] = update_sql("UPDATE {permission} SET perm = '$renamed_permission' WHERE rid = $role->rid");    }  }  return $ret;}/** * Change index on system table for better performance. */function system_update_6035() {  $ret = array();  db_drop_index($ret, 'system', 'weight');  db_add_index($ret, 'system', 'modules', array(array('type', 12), 'status', 'weight', 'filename'));  db_add_index($ret, 'system', 'bootstrap', array(array('type', 12), 'status', 'bootstrap', 'weight', 'filename'));  return $ret;}/** * Change the search schema and indexing. * * The table data is preserved where possible in MYSQL and MYSQLi using * ALTER IGNORE. Other databases don't support that, so for them the * tables are dropped and re-created, and will need to be re-indexed * from scratch. */function system_update_6036() {  $ret = array();  if (db_table_exists('search_index')) {    // Create the search_dataset.reindex column.    db_add_field($ret, 'search_dataset', 'reindex', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));    // Drop the search_index.from fields which are no longer used.    db_drop_index($ret, 'search_index', 'from_sid_type');    db_drop_field($ret, 'search_index', 'fromsid');    db_drop_field($ret, 'search_index', 'fromtype');    // Drop the search_dataset.sid_type index, so that it can be made unique.    db_drop_index($ret, 'search_dataset', 'sid_type');    // Create the search_node_links Table.    $search_node_links_schema = array(      'fields' => array(        'sid'      => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'type'     => array('type' => 'varchar', 'length' => 16, 'not null' => TRUE, 'default' => ''),        'nid'      => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'caption'    => array('type' => 'text', 'size' => 'big', 'not null' => FALSE),      ),      'primary key' => array('sid', 'type', 'nid'),      'indexes' => array('nid' => array('nid')),    );    db_create_table($ret, 'search_node_links', $search_node_links_schema);    // with the change to search_dataset.reindex, the search queue is handled differently,    // and this is no longer needed    variable_del('node_cron_last');    // Add a unique index for the search_index.    if ($GLOBALS['db_type'] == 'mysql' || $GLOBALS['db_type'] == 'mysqli') {      // Since it's possible that some existing sites have duplicates,      // create the index using the IGNORE keyword, which ignores duplicate errors.      // However, pgsql doesn't support it      $ret[] = update_sql("ALTER IGNORE TABLE {search_index} ADD UNIQUE KEY word_sid_type (word, sid, type)");      $ret[] = update_sql("ALTER IGNORE TABLE {search_dataset} ADD UNIQUE KEY sid_type (sid, type)");      // Everything needs to be reindexed.      $ret[] = update_sql("UPDATE {search_dataset} SET reindex = 1");    }    else {      // Delete the existing tables if there are duplicate values      if (db_result(db_query("SELECT sid FROM {search_dataset} GROUP BY sid, type HAVING COUNT(*) > 1")) || db_result(db_query("SELECT sid FROM {search_index} GROUP BY word, sid, type HAVING COUNT(*) > 1"))) {        $ret[] = update_sql('DELETE FROM {search_dataset}');        $ret[] = update_sql('DELETE FROM {search_index}');        $ret[] = update_sql('DELETE FROM {search_total}');      }      else {        // Everything needs to be reindexed.        $ret[] = update_sql("UPDATE {search_dataset} SET reindex = 1");      }      // create the new indexes      db_add_unique_key($ret, 'search_index', 'word_sid_type', array('word', 'sid', 'type'));      db_add_unique_key($ret, 'search_dataset', 'sid_type', array('sid', 'type'));    }  }  return $ret;}/** * Create consistent empty region for disabled blocks. */function system_update_6037() {  $ret = array();  db_change_field($ret, 'blocks', 'region', 'region', array('type' => 'varchar', 'length' => 64, 'not null' => TRUE, 'default' => ''));  $ret[] = update_sql("UPDATE {blocks} SET region = '' WHERE status = 0");  return $ret;}/** * Ensure that "Account" is not used as a Profile category. */function system_update_6038() {  $ret = array();  if (db_table_exists('profile_fields')) {    $ret[] = update_sql("UPDATE {profile_fields} SET category = 'Account settings' WHERE LOWER(category) = 'account'");    if ($affectedrows = db_affected_rows()) {      drupal_set_message('There were '. $affectedrows .' profile fields that used a reserved category name. They have been assigned to the category "Account settings".');    }  }  return $ret;}/** * Rename permissions "edit foo content" to "edit any foo content". * Also update poll module permission "create polls" to "create * poll content". */function system_update_6039() {  $ret = array();  $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");  while ($role = db_fetch_object($result)) {    $renamed_permission = preg_replace('/(?<=^|,\ )edit\ ([a-zA-Z0-9_\-]+)\ content(?=,|$)/', 'edit any $1 content', $role->perm);    $renamed_permission = preg_replace('/(?<=^|,\ )create\ polls(?=,|$)/', 'create poll content', $renamed_permission);    if ($renamed_permission != $role->perm) {      $ret[] = update_sql("UPDATE {permission} SET perm = '$renamed_permission' WHERE rid = $role->rid");    }  }  return $ret;}/** * Add a weight column to the upload table. */function system_update_6040() {  $ret = array();  if (db_table_exists('upload')) {    db_add_field($ret, 'upload', 'weight', array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'tiny'));  }  return $ret;}/** * Change forum vocabulary not to be required by default and set the weight of the forum.module 1 higher than the taxonomy.module. */function system_update_6041() {  $weight = intval((db_result(db_query("SELECT weight FROM {system} WHERE name = 'taxonomy'"))) + 1);  $ret = array();  $vid = intval(variable_get('forum_nav_vocabulary', ''));  if (db_table_exists('vocabulary') && $vid) {    $ret[] = update_sql("UPDATE {vocabulary} SET required = 0 WHERE vid = " . $vid);    $ret[] = update_sql("UPDATE {system} SET weight = ". $weight ." WHERE name = 'forum'");  }  return $ret;}/** * Upgrade recolored theme stylesheets to new array structure. */function system_update_6042() {  foreach (list_themes() as $theme) {    $stylesheet = variable_get('color_'. $theme->name .'_stylesheet', NULL);    if (!empty($stylesheet)) {      variable_set('color_'. $theme->name .'_stylesheets', array($stylesheet));      variable_del('color_'. $theme->name .'_stylesheet');    }  }  return array();}/** * Update table indices to make them more rational and useful. */function system_update_6043() {  $ret = array();  // Required modules first.  // Add new system module indexes.  db_add_index($ret, 'flood', 'allow', array('event', 'hostname', 'timestamp'));  db_add_index($ret, 'history', 'nid', array('nid'));  // Change length of theme field in {blocks} to be consistent with module, and  // to avoid a MySQL error regarding a too-long index.  Also add new indices.  db_change_field($ret, 'blocks', 'theme', 'theme', array('type' => 'varchar', 'length' => 64, 'not null' => TRUE, 'default' => ''),array(                  'unique keys' => array('tmd' => array('theme', 'module', 'delta'),),                  'indexes' => array('list' => array('theme', 'status', 'region', 'weight', 'module'),),));  db_add_index($ret, 'blocks_roles', 'rid', array('rid'));  // Improve filter module indices.  db_drop_index($ret, 'filters', 'weight');  db_add_unique_key($ret, 'filters', 'fmd', array('format', 'module', 'delta'));  db_add_index($ret, 'filters', 'list', array('format', 'weight', 'module', 'delta'));  // Drop unneeded keys form the node table.  db_drop_index($ret, 'node', 'status');  db_drop_unique_key($ret, 'node', 'nid_vid');  // Improve user module indices.  db_add_index($ret, 'users', 'mail', array('mail'));  db_add_index($ret, 'users_roles', 'rid', array('rid'));  // Optional modules - need to check if the tables exist.  // Alter aggregator module's tables primary keys to make them more useful.  if (db_table_exists('aggregator_category_feed')) {    db_drop_primary_key($ret, 'aggregator_category_feed');    db_add_primary_key($ret, 'aggregator_category_feed', array('cid', 'fid'));    db_add_index($ret, 'aggregator_category_feed', 'fid', array('fid'));  }  if (db_table_exists('aggregator_category_item')) {    db_drop_primary_key($ret, 'aggregator_category_item');    db_add_primary_key($ret, 'aggregator_category_item', array('cid', 'iid'));    db_add_index($ret, 'aggregator_category_item', 'iid', array('iid'));  }  // Alter contact module's table to add an index.  if (db_table_exists('contact')) {    db_add_index($ret, 'contact', 'list', array('weight', 'category'));  }  // Alter locale table to add a primary key, drop an index.  if (db_table_exists('locales_target')) {    db_add_primary_key($ret, 'locales_target', array('language', 'lid', 'plural'));  }  // Alter a poll module table to add a primary key.  if (db_table_exists('poll_votes')) {    db_drop_index($ret, 'poll_votes', 'nid');    db_add_primary_key($ret, 'poll_votes', array('nid', 'uid', 'hostname'));  }  // Alter a profile module table to add a primary key.  if (db_table_exists('profile_values')) {    db_drop_index($ret, 'profile_values', 'uid');    db_drop_index($ret, 'profile_values', 'fid');    db_change_field($ret,'profile_values' ,'fid', 'fid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0,), array('indexes' => array('fid' => array('fid'),)));    db_change_field($ret,'profile_values' ,'uid', 'uid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0,));    db_add_primary_key($ret, 'profile_values', array('uid', 'fid'));  }  // Alter a statistics module table to add an index.  if (db_table_exists('accesslog')) {    db_add_index($ret, 'accesslog', 'uid', array('uid'));  }  // Alter taxonomy module's tables.  if (db_table_exists('term_data')) {    db_drop_index($ret, 'term_data', 'vid');    db_add_index($ret, 'term_data', 'vid_name', array('vid', 'name'));    db_add_index($ret, 'term_data', 'taxonomy_tree', array('vid', 'weight', 'name'));  }  if (db_table_exists('term_node')) {    db_drop_primary_key($ret, 'term_node');    db_drop_index($ret, 'term_node', 'tid');    db_add_primary_key($ret, 'term_node', array('tid', 'vid'));  }  if (db_table_exists('term_relation')) {    db_drop_index($ret, 'term_relation', 'tid1');    db_add_unique_key($ret, 'term_relation', 'tid1_tid2', array('tid1', 'tid2'));  }  if (db_table_exists('term_synonym')) {    db_drop_index($ret, 'term_synonym', 'name');    db_add_index($ret, 'term_synonym', 'name_tid', array('name', 'tid'));  }  if (db_table_exists('vocabulary')) {    db_add_index($ret, 'vocabulary', 'list', array('weight', 'name'));  }  if (db_table_exists('vocabulary_node_types')) {    db_drop_primary_key($ret, 'vocabulary_node_types');    db_add_primary_key($ret, 'vocabulary_node_types', array('type', 'vid'));    db_add_index($ret, 'vocabulary_node_types', 'vid', array('vid'));  }  // If we updated in RC1 or before ensure we don't update twice.  variable_set('system_update_6043_RC2', TRUE);  return $ret;}/** * RC1 to RC2 index cleanup. */function system_update_6044() {  $ret = array();  // Delete invalid entries in {term_node} after system_update_6001.  $ret[] = update_sql("DELETE FROM {term_node} WHERE vid = 0");  // Only execute the rest of this function if 6043 was run in RC1 or before.  if (variable_get('system_update_6043_RC2', FALSE)) {    variable_del('system_update_6043_RC2');    return $ret;  }  // User module indices.  db_drop_unique_key($ret, 'users', 'mail');  db_add_index($ret, 'users', 'mail', array('mail'));  // Optional modules - need to check if the tables exist.  // Alter taxonomy module's tables.  if (db_table_exists('term_data')) {    db_drop_unique_key($ret, 'term_data', 'vid_name');    db_add_index($ret, 'term_data', 'vid_name', array('vid', 'name'));  }  if (db_table_exists('term_synonym')) {    db_drop_unique_key($ret, 'term_synonym', 'name_tid', array('name', 'tid'));    db_add_index($ret, 'term_synonym', 'name_tid', array('name', 'tid'));  }  return $ret;}/** * Update blog, book and locale module permissions. * * Blog module got "edit own blog" replaced with the more granular "create * blog entries", "edit own blog entries" and "delete own blog entries" * permissions. We grant create and edit to previously privileged users, but * delete is not granted to be in line with other permission changes in Drupal 6. * * Book module's "edit book pages" was upgraded to the bogus "edit book content" * in Drupal 6 RC1 instead of "edit any book content", which would be correct. * * Locale module introduced "administer languages" and "translate interface" * in place of "administer locales". * * Modeled after system_update_6039(). */function system_update_6045() {  $ret = array();  $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");  while ($role = db_fetch_object($result)) {    $renamed_permission = preg_replace('/(?<=^|,\ )edit\ own\ blog(?=,|$)/', 'create blog entries, edit own blog entries', $role->perm);    $renamed_permission = preg_replace('/(?<=^|,\ )edit\ book\ content(?=,|$)/', 'edit any book content', $renamed_permission);    $renamed_permission = preg_replace('/(?<=^|,\ )administer\ locales(?=,|$)/', 'administer languages, translate interface', $renamed_permission);    if ($renamed_permission != $role->perm) {      $ret[] = update_sql("UPDATE {permission} SET perm = '$renamed_permission' WHERE rid = $role->rid");    }  }  // Notify user that delete permissions may have been changed. This was in  // effect since system_update_6039(), but there was no user notice.  drupal_set_message('Drupal now has separate edit and delete permissions. Previously, users who were able to edit content were automatically allowed to delete it. For added security, delete permissions for individual core content types have been <strong>removed</strong> from all roles on your site (only roles with the "administer nodes" permission can now delete these types of content). If you would like to reenable any individual delete permissions, you can do this at the <a href="'. url('admin/user/permissions', array('fragment' => 'module-node')) .'">permissions page</a>.');  return $ret;}/** * Ensure that the file_directory_path variable is set (using the old 5.x * default, if necessary), so that the changed 6.x default won't break * existing sites. */function system_update_6046() {  $ret = array();  if (!variable_get('file_directory_path', FALSE)) {    variable_set('file_directory_path', 'files');    $ret[] = array('success' => TRUE, 'query' => "variable_set('file_directory_path')");  }  return $ret;}/** * Fix cache mode for blocks inserted in system_install() in fresh installs of previous RC. */function system_update_6047() {  $ret = array();  $ret[] = update_sql("UPDATE {blocks} SET cache = -1 WHERE module = 'user' AND delta IN ('0', '1')");  $ret[] = update_sql("UPDATE {blocks} SET cache = -1 WHERE module = 'system' AND delta = '0'");  return $ret;}/** * @} End of "defgroup updates-5.x-to-6.x" *//** * @defgroup updates-6.x-extra Extra system updates for 6.x * @{ *//*** Increase the size of the 'load_functions' and 'to_arg_functions' fields in table 'menu_router'.*/function system_update_6048() {  $ret = array();  db_change_field($ret, 'menu_router', 'load_functions', 'load_functions', array('type' => 'text', 'not null' => TRUE,));  db_change_field($ret, 'menu_router', 'to_arg_functions', 'to_arg_functions', array('type' => 'text', 'not null' => TRUE,));  return $ret;}/** * Replace src index on the {url_alias} table with src, language. */function system_update_6049() {  $ret = array();  db_drop_index($ret, 'url_alias', 'src');  db_add_index($ret, 'url_alias', 'src_language', array('src', 'language'));  return $ret;}/** * Clear any menu router blobs stored in the cache table. */function system_update_6050() {  $ret = array();  cache_clear_all('router:', 'cache_menu', TRUE);  return $ret;}/** * Create a signature_format column. */function system_update_6051() {  $ret = array();  if (!db_column_exists('users', 'signature_format')) {    // Set future input formats to FILTER_FORMAT_DEFAULT to ensure a safe default    // when incompatible modules insert into the users table. An actual format    // will be assigned when users save their signature.    $schema = array(      'type' => 'int',      'size' => 'small',      'not null' => TRUE,      'default' => FILTER_FORMAT_DEFAULT,      'description' => 'The {filter_formats}.format of the signature.',    );    db_add_field($ret, 'users', 'signature_format', $schema);    // Set the format of existing signatures to the current default input format.    if ($current_default_filter = variable_get('filter_default_format', 0)) {      $ret[] = update_sql("UPDATE {users} SET signature_format = ". $current_default_filter);    }    drupal_set_message("User signatures no longer inherit comment input formats. Each user's signature now has its own associated format that can be selected on the user's account page. Existing signatures have been set to your site's default input format.");  }  return $ret;}/** * Add a missing index on the {menu_router} table. */function system_update_6052() {  $ret = array();  db_add_index($ret, 'menu_router', 'tab_root_weight_title', array(array('tab_root', 64), 'weight', 'title'));  return $ret;}/** * Add a {system} index on type and name. */function system_update_6053() {  $ret = array();  db_add_index($ret, 'system', 'type_name', array(array('type', 12), 'name'));  return $ret;}/** * Add semaphore table. */function system_update_6054() {  $ret = array();  $schema['semaphore'] = array(    'fields' => array(      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'value' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'expire' => array(        'type' => 'float',        'size' => 'big',        'not null' => TRUE),      ),    'indexes' => array('expire' => array('expire')),    'primary key' => array('name'),  );  db_create_table($ret, 'semaphore', $schema['semaphore']);  return $ret;}/** * Improve indexes on the {url_alias} table. */function system_update_6055() {  $ret = array();  db_drop_index($ret, 'url_alias', 'src_language');  db_drop_unique_key($ret, 'url_alias', 'dst_language');  db_add_index($ret, 'url_alias', 'src_language_pid', array('src', 'language', 'pid'));  db_add_unique_key($ret, 'url_alias', 'dst_language_pid', array('dst', 'language', 'pid'));  return $ret;}/** * @} End of "defgroup updates-6.x-extra" * The next series of updates should start at 7000. */
<?php// $Id$?><div id="block-<?php print $block->module .'-'. $block->delta; ?>" class="clear-block block block-<?php print $block->module ?>"><?php if (!empty($block->subject)): ?>  <h2><?php print $block->subject ?></h2><?php endif;?>  <div class="content"><?php print $block->content ?></div></div>
<?php// $Id$/** * @file * Wrapper for database interface code. *//** * A hash value to check when outputting database errors, md5('DB_ERROR'). * * @see drupal_error_handler() */define('DB_ERROR', 'a515ac9c2796ca0e23adbe92c68fc9fc');/** * @defgroup database Database abstraction layer * @{ * Allow the use of different database servers using the same code base. * * Drupal provides a slim database abstraction layer to provide developers with * the ability to support multiple database servers easily. The intent of this * layer is to preserve the syntax and power of SQL as much as possible, while * letting Drupal control the pieces of queries that need to be written * differently for different servers and provide basic security checks. * * Most Drupal database queries are performed by a call to db_query() or * db_query_range(). Module authors should also consider using pager_query() for * queries that return results that need to be presented on multiple pages, and * tablesort_sql() for generating appropriate queries for sortable tables. * * For example, one might wish to return a list of the most recent 10 nodes * authored by a given user. Instead of directly issuing the SQL query * @code *   SELECT n.nid, n.title, n.created FROM node n WHERE n.uid = $uid LIMIT 0, 10; * @endcode * one would instead call the Drupal functions: * @code *   $result = db_query_range('SELECT n.nid, n.title, n.created *     FROM {node} n WHERE n.uid = %d', $uid, 0, 10); *   while ($node = db_fetch_object($result)) { *     // Perform operations on $node->body, etc. here. *   } * @endcode * Curly braces are used around "node" to provide table prefixing via * db_prefix_tables(). The explicit use of a user ID is pulled out into an * argument passed to db_query() so that SQL injection attacks from user input * can be caught and nullified. The LIMIT syntax varies between database servers, * so that is abstracted into db_query_range() arguments. Finally, note the * common pattern of iterating over the result set using db_fetch_object(). *//** * Perform an SQL query and return success or failure. * * @param $sql *   A string containing a complete SQL query.  %-substitution *   parameters are not supported. * @return *   An array containing the keys: *      success: a boolean indicating whether the query succeeded *      query: the SQL query executed, passed through check_plain() */function update_sql($sql) {  $result = db_query($sql, true);  return array('success' => $result !== FALSE, 'query' => check_plain($sql));}/** * Append a database prefix to all tables in a query. * * Queries sent to Drupal should wrap all table names in curly brackets. This * function searches for this syntax and adds Drupal's table prefix to all * tables, allowing Drupal to coexist with other systems in the same database if * necessary. * * @param $sql *   A string containing a partial or entire SQL query. * @return *   The properly-prefixed string. */function db_prefix_tables($sql) {  global $db_prefix;  if (is_array($db_prefix)) {    if (array_key_exists('default', $db_prefix)) {      $tmp = $db_prefix;      unset($tmp['default']);      foreach ($tmp as $key => $val) {        $sql = strtr($sql, array('{'. $key .'}' => $val . $key));      }      return strtr($sql, array('{' => $db_prefix['default'], '}' => ''));    }    else {      foreach ($db_prefix as $key => $val) {        $sql = strtr($sql, array('{'. $key .'}' => $val . $key));      }      return strtr($sql, array('{' => '', '}' => ''));    }  }  else {    return strtr($sql, array('{' => $db_prefix, '}' => ''));  }}/** * Activate a database for future queries. * * If it is necessary to use external databases in a project, this function can * be used to change where database queries are sent. If the database has not * yet been used, it is initialized using the URL specified for that name in * Drupal's configuration file. If this name is not defined, a duplicate of the * default connection is made instead. * * Be sure to change the connection back to the default when done with custom * code. * * @param $name *   The name assigned to the newly active database connection. If omitted, the *   default connection will be made active. * * @return the name of the previously active database or FALSE if non was found. */function db_set_active($name = 'default') {  global $db_url, $db_type, $active_db;  static $db_conns, $active_name = FALSE;  if (empty($db_url)) {    include_once 'includes/install.inc';    install_goto('install.php');  }  if (!isset($db_conns[$name])) {    // Initiate a new connection, using the named DB URL specified.    if (is_array($db_url)) {      $connect_url = array_key_exists($name, $db_url) ? $db_url[$name] : $db_url['default'];    }    else {      $connect_url = $db_url;    }    $db_type = substr($connect_url, 0, strpos($connect_url, '://'));    $handler = "./includes/database.$db_type.inc";    if (is_file($handler)) {      include_once $handler;    }    else {      _db_error_page("The database type '". $db_type ."' is unsupported. Please use either 'mysql' or 'mysqli' for MySQL, or 'pgsql' for PostgreSQL databases.");    }    $db_conns[$name] = db_connect($connect_url);  }  $previous_name = $active_name;  // Set the active connection.  $active_name = $name;  $active_db = $db_conns[$name];  return $previous_name;}/** * Helper function to show fatal database errors. * * Prints a themed maintenance page with the 'Site off-line' text, * adding the provided error message in the case of 'display_errors' * set to on. Ends the page request; no return. * * @param $error *   The error message to be appended if 'display_errors' is on. */function _db_error_page($error = '') {  global $db_type;  drupal_init_language();  drupal_maintenance_theme();  drupal_set_header('HTTP/1.1 503 Service Unavailable');  drupal_set_title('Site off-line');  $message = '<p>The site is currently not available due to technical problems. Please try again later. Thank you for your understanding.</p>';  $message .= '<hr /><p><small>If you are the maintainer of this site, please check your database settings in the <code>settings.php</code> file and ensure that your hosting provider\'s database server is running. For more help, see the <a href="http://drupal.org/node/258">handbook</a>, or contact your hosting provider.</small></p>';  if ($error && ini_get('display_errors')) {    $message .= '<p><small>The '. theme('placeholder', $db_type) .' error was: '. theme('placeholder', $error) .'.</small></p>';  }  print theme('maintenance_page', $message);  exit;}/** * Returns a boolean depending on the availability of the database. */function db_is_active() {  global $active_db;  return !empty($active_db);}/** * Helper function for db_query(). */function _db_query_callback($match, $init = FALSE) {  static $args = NULL;  if ($init) {    $args = $match;    return;  }  switch ($match[1]) {    case '%d': // We must use type casting to int to convert FALSE/NULL/(TRUE?)      $value = array_shift($args);      // Do we need special bigint handling?      if ($value > PHP_INT_MAX) {        $precision = ini_get('precision');        @ini_set('precision', 16);        $value = sprintf('%.0f', $value);        @ini_set('precision', $precision);      }      else {        $value = (int) $value;      }      // We don't need db_escape_string as numbers are db-safe.      return $value;    case '%s':      return db_escape_string(array_shift($args));    case '%n':      // Numeric values have arbitrary precision, so can't be treated as float.      // is_numeric() allows hex values (0xFF), but they are not valid.      $value = trim(array_shift($args));      return is_numeric($value) && !preg_match('/x/i', $value) ? $value : '0';    case '%%':      return '%';    case '%f':      return (float) array_shift($args);    case '%b': // binary data      return db_encode_blob(array_shift($args));  }}/** * Generate placeholders for an array of query arguments of a single type. * * Given a Schema API field type, return correct %-placeholders to * embed in a query * * @param $arguments *  An array with at least one element. * @param $type *   The Schema API type of a field (e.g. 'int', 'text', or 'varchar'). */function db_placeholders($arguments, $type = 'int') {  $placeholder = db_type_placeholder($type);  return implode(',', array_fill(0, count($arguments), $placeholder));}/** * Indicates the place holders that should be replaced in _db_query_callback(). */define('DB_QUERY_REGEXP', '/(%d|%s|%%|%f|%b|%n)/');/** * Helper function for db_rewrite_sql. * * Collects JOIN and WHERE statements via hook_db_rewrite_sql() * Decides whether to select primary_key or DISTINCT(primary_key) * * @param $query *   Query to be rewritten. * @param $primary_table *   Name or alias of the table which has the primary key field for this query. *   Typical table names would be: {blocks}, {comments}, {forum}, {node}, *   {menu}, {term_data} or {vocabulary}. However, in most cases the usual *   table alias (b, c, f, n, m, t or v) is used instead of the table name. * @param $primary_field *   Name of the primary field. * @param $args *   Array of additional arguments. * @return *   An array: join statements, where statements, field or DISTINCT(field). */function _db_rewrite_sql($query = '', $primary_table = 'n', $primary_field = 'nid', $args = array()) {  $where = array();  $join = array();  $distinct = FALSE;  foreach (module_implements('db_rewrite_sql') as $module) {    $result = module_invoke($module, 'db_rewrite_sql', $query, $primary_table, $primary_field, $args);    if (isset($result) && is_array($result)) {      if (isset($result['where'])) {        $where[] = $result['where'];      }      if (isset($result['join'])) {        $join[] = $result['join'];      }      if (isset($result['distinct']) && $result['distinct']) {        $distinct = TRUE;      }    }    elseif (isset($result)) {      $where[] = $result;    }  }  $where = empty($where) ? '' : '('. implode(') AND (', $where) .')';  $join = empty($join) ? '' : implode(' ', $join);  return array($join, $where, $distinct);}/** * Rewrites node, taxonomy and comment queries. Use it for listing queries. Do not * use FROM table1, table2 syntax, use JOIN instead. * * @param $query *   Query to be rewritten. * @param $primary_table *   Name or alias of the table which has the primary key field for this query. *   Typical table names would be: {blocks}, {comments}, {forum}, {node}, *   {menu}, {term_data} or {vocabulary}. However, it is more common to use the *   the usual table aliases: b, c, f, n, m, t or v. * @param $primary_field *   Name of the primary field. * @param $args *   An array of arguments, passed to the implementations of hook_db_rewrite_sql. * @return *   The original query with JOIN and WHERE statements inserted from *   hook_db_rewrite_sql implementations. nid is rewritten if needed. */function db_rewrite_sql($query, $primary_table = 'n', $primary_field = 'nid',  $args = array()) {  list($join, $where, $distinct) = _db_rewrite_sql($query, $primary_table, $primary_field, $args);  if ($distinct) {    $query = db_distinct_field($primary_table, $primary_field, $query);  }  if (!empty($where) || !empty($join)) {    $pattern = '{      # Beginning of the string      ^      ((?P<anonymous_view>        # Everything within this set of parentheses is named "anonymous view"        (?:          [^()]++                   # anything not parentheses        |          \( (?P>anonymous_view) \)          # an open parenthesis, more "anonymous view" and finally a close parenthesis.        )*      )[^()]+WHERE)    }x';    preg_match($pattern, $query, $matches);    if (!$where) {      $where = '1 = 1';    }    if ($matches) {      $n = strlen($matches[1]);      $second_part = substr($query, $n);      $first_part = substr($matches[1], 0, $n - 5) ." $join WHERE $where AND ( ";      // PHP 4 does not support strrpos for strings. We emulate it.      $haystack_reverse = strrev($second_part);    }    else {      $haystack_reverse = strrev($query);    }    // No need to use strrev on the needle, we supply GROUP, ORDER, LIMIT    // reversed.    foreach (array('PUORG', 'REDRO', 'TIMIL') as $needle_reverse) {      $pos = strpos($haystack_reverse, $needle_reverse);      if ($pos !== FALSE) {        // All needles are five characters long.        $pos += 5;        break;      }    }    if ($matches) {      if ($pos === FALSE) {        $query = $first_part . $second_part .')';      }      else {        $query = $first_part . substr($second_part, 0, -$pos) .')'. substr($second_part, -$pos);      }    }    elseif ($pos === FALSE) {      $query .= " $join WHERE $where";    }    else {      $query = substr($query, 0, -$pos) . " $join WHERE $where " . substr($query, -$pos);    }  }  return $query;}/** * Adds the DISTINCT flag to the supplied query if a DISTINCT doesn't already * exist in the query. Returns the altered query. * * This will not, and never did guarantee that you will obtain distinct  * values of $table.$field. * * @param $table Unused. Kept to remain API compatibility. * @param $field Unused. Kept to remain API compatibility. * @param $query Query to which the DISTINCT flag should be applied. * @return SQL query with the DISTINCT flag set. */function db_distinct_field($table, $field, $query) {  $matches = array();  if (!preg_match('/^SELECT\s*DISTINCT/i', $query, $matches)) {    // Only add distinct to the outer SELECT to avoid messing up subqueries.    $query = preg_replace('/^SELECT/i', 'SELECT DISTINCT', $query);  }  return $query;}/** * Restrict a dynamic table, column or constraint name to safe characters. * * Only keeps alphanumeric and underscores. */function db_escape_table($string) {  return preg_replace('/[^A-Za-z0-9_]+/', '', $string);}/** * @} End of "defgroup database". *//** * @defgroup schemaapi Schema API * @{ * * A Drupal schema definition is an array structure representing one or * more tables and their related keys and indexes. A schema is defined by * hook_schema(), which usually lives in a modulename.install file. * * By implementing hook_schema() and specifying the tables your module * declares, you can easily create and drop these tables on all * supported database engines. You don't have to deal with the * different SQL dialects for table creation and alteration of the * supported database engines. * * hook_schema() should return an array with a key for each table that * the module defines. * * The following keys are defined: * *   - 'description': A string describing this table and its purpose. *     References to other tables should be enclosed in *     curly-brackets.  For example, the node_revisions table *     description field might contain "Stores per-revision title and *     body data for each {node}." *   - 'fields': An associative array ('fieldname' => specification) *     that describes the table's database columns.  The specification *     is also an array.  The following specification parameters are defined: * *     - 'description': A string describing this field and its purpose. *       References to other tables should be enclosed in *       curly-brackets.  For example, the node table vid field *       description might contain "Always holds the largest (most *       recent) {node_revisions}.vid value for this nid." *     - 'type': The generic datatype: 'varchar', 'int', 'serial' *       'float', 'numeric', 'text', 'blob' or 'datetime'.  Most types *       just map to the according database engine specific *       datatypes.  Use 'serial' for auto incrementing fields. This *       will expand to 'int auto_increment' on mysql. *     - 'serialize': A boolean indicating whether the field will be stored         as a serialized string. *     - 'size': The data size: 'tiny', 'small', 'medium', 'normal', *       'big'.  This is a hint about the largest value the field will *       store and determines which of the database engine specific *       datatypes will be used (e.g. on MySQL, TINYINT vs. INT vs. BIGINT). *       'normal', the default, selects the base type (e.g. on MySQL, *       INT, VARCHAR, BLOB, etc.). * *       Not all sizes are available for all data types. See *       db_type_map() for possible combinations. *     - 'not null': If true, no NULL values will be allowed in this *       database column.  Defaults to false. *     - 'default': The field's default value.  The PHP type of the *       value matters: '', '0', and 0 are all different.  If you *       specify '0' as the default value for a type 'int' field it *       will not work because '0' is a string containing the *       character "zero", not an integer. *     - 'length': The maximal length of a type 'char', 'varchar' or 'text' *       field.  Ignored for other field types. *     - 'unsigned': A boolean indicating whether a type 'int', 'float' *       and 'numeric' only is signed or unsigned.  Defaults to *       FALSE.  Ignored for other field types. *     - 'precision', 'scale': For type 'numeric' fields, indicates *       the precision (total number of significant digits) and scale *       (decimal digits right of the decimal point).  Both values are *       mandatory.  Ignored for other field types. * *     All parameters apart from 'type' are optional except that type *     'numeric' columns must specify 'precision' and 'scale'. * *  - 'primary key': An array of one or more key column specifiers (see below) *    that form the primary key. *  - 'unique keys': An associative array of unique keys ('keyname' => *    specification).  Each specification is an array of one or more *    key column specifiers (see below) that form a unique key on the table. *  - 'indexes':  An associative array of indexes ('indexame' => *    specification).  Each specification is an array of one or more *    key column specifiers (see below) that form an index on the *    table. * * A key column specifier is either a string naming a column or an * array of two elements, column name and length, specifying a prefix * of the named column. * * As an example, here is a SUBSET of the schema definition for * Drupal's 'node' table.  It show four fields (nid, vid, type, and * title), the primary key on field 'nid', a unique key named 'vid' on * field 'vid', and two indexes, one named 'nid' on field 'nid' and * one named 'node_title_type' on the field 'title' and the first four * bytes of the field 'type': * * @code * $schema['node'] = array( *   'fields' => array( *     'nid'      => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), *     'vid'      => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0), *     'type'     => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''), *     'title'    => array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''), *   ), *   'primary key' => array('nid'), *   'unique keys' => array( *     'vid'     => array('vid') *   ), *   'indexes' => array( *     'nid'                 => array('nid'), *     'node_title_type'     => array('title', array('type', 4)), *   ), * ); * @endcode * * @see drupal_install_schema() */ /** * Create a new table from a Drupal table definition. * * @param $ret *   Array to which query results will be added. * @param $name *   The name of the table to create. * @param $table *   A Schema API table definition array. */function db_create_table(&$ret, $name, $table) {  $statements = db_create_table_sql($name, $table);  foreach ($statements as $statement) {    $ret[] = update_sql($statement);  }}/** * Return an array of field names from an array of key/index column specifiers. * * This is usually an identity function but if a key/index uses a column prefix * specification, this function extracts just the name. * * @param $fields *   An array of key/index column specifiers. * @return *   An array of field names. */function db_field_names($fields) {  $ret = array();  foreach ($fields as $field) {    if (is_array($field)) {      $ret[] = $field[0];    }    else {      $ret[] = $field;    }  }  return $ret;}/** * Given a Schema API field type, return the correct %-placeholder. * * Embed the placeholder in a query to be passed to db_query and and pass as an * argument to db_query a value of the specified type. * * @param $type *   The Schema API type of a field. * @return *   The placeholder string to embed in a query for that type. */function db_type_placeholder($type) {  switch ($type) {    case 'varchar':    case 'char':    case 'text':    case 'datetime':      return "'%s'";    case 'numeric':      // Numeric values are arbitrary precision numbers.  Syntacically, numerics      // should be specified directly in SQL. However, without single quotes      // the %s placeholder does not protect against non-numeric characters such      // as spaces which would expose us to SQL injection.      return '%n';    case 'serial':    case 'int':      return '%d';    case 'float':      return '%f';    case 'blob':      return '%b';  }  // There is no safe value to return here, so return something that  // will cause the query to fail.  return 'unsupported type '. $type .'for db_type_placeholder';}/** * @} End of "defgroup schemaapi". */
<?php// $Id$/** * Implementation of hook_install(). */function dblog_install() {  // Create tables.  drupal_install_schema('dblog');}/** * Implementation of hook_uninstall(). */function dblog_uninstall() {  // Remove tables.  drupal_uninstall_schema('dblog');}/** * Implementation of hook_schema(). */function dblog_schema() {  $schema['watchdog'] = array(    'description' => 'Table that contains logs of all system events.',    'fields' => array(      'wid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique watchdog event ID.',      ),      'uid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {users}.uid of the user who triggered the event.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => TRUE,        'default' => '',        'description' => 'Type of log message, for example "user" or "page not found."',      ),      'message' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Text of log message to be passed into the t() function.',      ),      'variables' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Serialized array of variables that match the message string and that is passed into the t() function.',      ),      'severity' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The severity level of the event; ranges from 0 (Emergency) to 7 (Debug)',      ),      'link' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Link to view the result of the event.',      ),      'location'  => array(        'type' => 'text',        'not null' => TRUE,        'description' => 'URL of the origin of the event.',      ),      'referer' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'URL of referring page.',      ),      'hostname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Hostname of the user who triggered the event.',      ),      'timestamp' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Unix timestamp of when event occurred.',      ),    ),    'primary key' => array('wid'),    'indexes' => array('type' => array('type')),  );  return $schema;}/** * @defgroup updates-6.x-extra Extra database logging updates for 6.x * @{ *//** * Allow longer referrers. */function dblog_update_6000() {  $ret = array();  db_change_field($ret, 'watchdog', 'referer', 'referer', array('type' => 'text', 'not null' => FALSE));  return $ret;}/** * @} End of "defgroup updates-6.x-extra" * The next series of updates should start at 7000. */
<?php// $Id$/** * @file * Code required only when comparing available updates to existing data. *//** * Fetch an array of installed and enabled projects. * * This is only responsible for generating an array of projects (taking into * account projects that include more than one module or theme). Other * information like the specific version and install type (official release, * dev snapshot, etc) is handled later in update_process_project_info() since * that logic is only required when preparing the status report, not for * fetching the available release data. * * This array is fairly expensive to construct, since it involves a lot of * disk I/O, so we cache the results into the {cache_update} table using the * 'update_project_projects' cache ID. However, since this is not the data * about available updates fetched from the network, it is ok to invalidate it * somewhat quickly. If we keep this data for very long, site administrators * are more likely to see incorrect results if they upgrade to a newer version * of a module or theme but do not visit certain pages that automatically * clear this cache. * * @see update_process_project_info() * @see update_calculate_project_data() * @see update_project_cache() */function update_get_projects() {  static $projects = array();  if (empty($projects)) {    // Retrieve the projects from cache, if present.    $projects = update_project_cache('update_project_projects');    if (empty($projects)) {      // Still empty, so we have to rebuild the cache.      _update_process_info_list($projects, module_rebuild_cache(), 'module');      _update_process_info_list($projects, system_theme_data(), 'theme');      // Allow other modules to alter projects before fetching and comparing.      drupal_alter('update_projects', $projects);      // Cache the site's project data for at most 1 hour.      _update_cache_set('update_project_projects', $projects, time() + 3600);    }  }  return $projects;}/** * Populate an array of project data. */function _update_process_info_list(&$projects, $list, $project_type) {  foreach ($list as $file) {    // A disabled base theme of an enabled sub-theme still has all of its code    // run by the sub-theme, so we include it in our "enabled" projects list.    if (!$file->status && !empty($file->sub_themes)) {      foreach ($file->sub_themes as $key => $name) {        // Build a list of enabled sub-themes.        if ($list[$key]->status) {          $file->enabled_sub_themes[$key] = $name;        }      }      // If there are no enabled subthemes, we should ingore this theme and go      // on to the next one.      if (empty($file->enabled_sub_themes)) {        continue;      }    }    elseif (empty($file->status)) {      // Skip disabled modules or themes.      continue;    }    // Skip if the .info file is broken.    if (empty($file->info)) {      continue;    }    // If the .info doesn't define the 'project', try to figure it out.    if (!isset($file->info['project'])) {      $file->info['project'] = update_get_project_name($file);    }    // If we still don't know the 'project', give up.    if (empty($file->info['project'])) {      continue;    }    // If we don't already know it, grab the change time on the .info file    // itself. Note: we need to use the ctime, not the mtime (modification    // time) since many (all?) tar implementations will go out of their way to    // set the mtime on the files it creates to the timestamps recorded in the    // tarball. We want to see the last time the file was changed on disk,    // which is left alone by tar and correctly set to the time the .info file    // was unpacked.    if (!isset($file->info['_info_file_ctime'])) {      $info_filename = dirname($file->filename) .'/'. $file->name .'.info';      $file->info['_info_file_ctime'] = filectime($info_filename);    }    if (!isset($file->info['datestamp'])) {      $file->info['datestamp'] = 0;    }    $project_name = $file->info['project'];    // Add a list of sub-themes that "depend on" the project and a list of base    // themes that are "required by" the project.    if ($project_name == 'drupal') {      // Drupal core is always required, so this extra info would be noise.      $sub_themes = array();      $base_themes = array();    }    else {      // Add list of enabled sub-themes.      $sub_themes = !empty($file->enabled_sub_themes) ? $file->enabled_sub_themes : array();      // Add list of base themes.      $base_themes = !empty($file->base_themes) ? $file->base_themes : array();    }    if (!isset($projects[$project_name])) {      // Only process this if we haven't done this project, since a single      // project can have multiple modules or themes.      $projects[$project_name] = array(        'name' => $project_name,        // Only save attributes from the .info file we care about so we do not        // bloat our RAM usage needlessly.        'info' => update_filter_project_info($file->info),        'datestamp' => $file->info['datestamp'],        'includes' => array($file->name => $file->info['name']),        'project_type' => $project_name == 'drupal' ? 'core' : $project_type,        'sub_themes' => $sub_themes,        'base_themes' => $base_themes,      );    }    else {      $projects[$project_name]['includes'][$file->name] = $file->info['name'];      $projects[$project_name]['info']['_info_file_ctime'] = max($projects[$project_name]['info']['_info_file_ctime'], $file->info['_info_file_ctime']);      $projects[$project_name]['datestamp'] = max($projects[$project_name]['datestamp'], $file->info['datestamp']);      $projects[$project_name]['sub_themes'] = array_merge($projects[$project_name]['sub_themes'], $sub_themes);      $projects[$project_name]['base_themes'] = array_merge($projects[$project_name]['base_themes'], $base_themes);    }  }}/** * Given a $file object (as returned by system_get_files_database()), figure * out what project it belongs to. * * @see system_get_files_database() */function update_get_project_name($file) {  $project_name = '';  if (isset($file->info['project'])) {    $project_name = $file->info['project'];  }  elseif (isset($file->info['package']) && (strpos($file->info['package'], 'Core -') !== FALSE)) {    $project_name = 'drupal';  }  elseif (in_array($file->name, array('bluemarine', 'chameleon', 'garland', 'marvin', 'minnelli', 'pushbutton'))) {    // Unfortunately, there's no way to tell if a theme is part of core,    // so we must hard-code a list here.    $project_name = 'drupal';  }  return $project_name;}/** * Process the list of projects on the system to figure out the currently * installed versions, and other information that is required before we can * compare against the available releases to produce the status report. * * @param $projects *   Array of project information from update_get_projects(). */function update_process_project_info(&$projects) {  foreach ($projects as $key => $project) {    // Assume an official release until we see otherwise.    $install_type = 'official';    $info = $project['info'];    if (isset($info['version'])) {      // Check for development snapshots      if (preg_match('@(dev|HEAD)@', $info['version'])) {        $install_type = 'dev';      }      // Figure out what the currently installed major version is. We need      // to handle both contribution (e.g. "5.x-1.3", major = 1) and core      // (e.g. "5.1", major = 5) version strings.      $matches = array();      if (preg_match('/^(\d+\.x-)?(\d+)\..*$/', $info['version'], $matches)) {        $info['major'] = $matches[2];      }      elseif (!isset($info['major'])) {        // This would only happen for version strings that don't follow the        // drupal.org convention. We let contribs define "major" in their        // .info in this case, and only if that's missing would we hit this.        $info['major'] = -1;      }    }    else {      // No version info available at all.      $install_type = 'unknown';      $info['version'] = t('Unknown');      $info['major'] = -1;    }    // Finally, save the results we care about into the $projects array.    $projects[$key]['existing_version'] = $info['version'];    $projects[$key]['existing_major'] = $info['major'];    $projects[$key]['install_type'] = $install_type;  }}/** * Given the installed projects and the available release data retrieved from * remote servers, calculate the current status. * * This function is the heart of the update status feature. It iterates over * every currently installed project. For each one, it first checks if the * project has been flagged with a special status like "unsupported" or * "insecure", or if the project node itself has been unpublished. In any of * those cases, the project is marked with an error and the next project is * considered. * * If the project itself is valid, the function decides what major release * series to consider. The project defines what the currently supported major * versions are for each version of core, so the first step is to make sure * the current version is still supported. If so, that's the target version. * If the current version is unsupported, the project maintainer's recommended * major version is used. There's also a check to make sure that this function * never recommends an earlier release than the currently installed major * version. * * Given a target major version, it scans the available releases looking for * the specific release to recommend (avoiding beta releases and development * snapshots if possible). This is complicated to describe, but an example * will help clarify. For the target major version, find the highest patch * level. If there is a release at that patch level with no extra ("beta", * etc), then we recommend the release at that patch level with the most * recent release date. If every release at that patch level has extra (only * betas), then recommend the latest release from the previous patch * level. For example: * * 1.6-bugfix <-- recommended version because 1.6 already exists. * 1.6 * * or * * 1.6-beta * 1.5 <-- recommended version because no 1.6 exists. * 1.4 * * It also looks for the latest release from the same major version, even a * beta release, to display to the user as the "Latest version" option. * Additionally, it finds the latest official release from any higher major * versions that have been released to provide a set of "Also available" * options. * * Finally, and most importantly, it keeps scanning the release history until * it gets to the currently installed release, searching for anything marked * as a security update. If any security updates have been found between the * recommended release and the installed version, all of the releases that * included a security fix are recorded so that the site administrator can be * warned their site is insecure, and links pointing to the release notes for * each security update can be included (which, in turn, will link to the * official security announcements for each vulnerability). * * This function relies on the fact that the .xml release history data comes * sorted based on major version and patch level, then finally by release date * if there are multiple releases such as betas from the same major.patch * version (e.g. 5.x-1.5-beta1, 5.x-1.5-beta2, and 5.x-1.5). Development * snapshots for a given major version are always listed last. * * The results of this function are expensive to compute, especially on sites * with lots of modules or themes, since it involves a lot of comparisons and * other operations. Therefore, we cache the results into the {cache_update} * table using the 'update_project_data' cache ID. However, since this is not * the data about available updates fetched from the network, it is ok to * invalidate it somewhat quickly. If we keep this data for very long, site * administrators are more likely to see incorrect results if they upgrade to * a newer version of a module or theme but do not visit certain pages that * automatically clear this cache. * * @param $available *  Array of data about available project releases. * * @see update_get_available() * @see update_get_projects() * @see update_process_project_info() * @see update_project_cache() */function update_calculate_project_data($available) {  // Retrieve the projects from cache, if present.  $projects = update_project_cache('update_project_data');  // If $projects is empty, then the cache must be rebuilt.  // Otherwise, return the cached data and skip the rest of the function.  if (!empty($projects)) {    return $projects;  }  $projects = update_get_projects();  update_process_project_info($projects);  foreach ($projects as $project => $project_info) {    if (isset($available[$project])) {      // If the project status is marked as something bad, there's nothing      // else to consider.      if (isset($available[$project]['project_status'])) {        switch ($available[$project]['project_status']) {          case 'insecure':            $projects[$project]['status'] = UPDATE_NOT_SECURE;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-not-secure',              'label' => t('Project not secure'),              'data' => t('This project has been labeled insecure by the Drupal security team, and is no longer available for download. Immediately disabling everything included by this project is strongly recommended!'),            );            break;          case 'unpublished':          case 'revoked':            $projects[$project]['status'] = UPDATE_REVOKED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-revoked',              'label' => t('Project revoked'),              'data' => t('This project has been revoked, and is no longer available for download. Disabling everything included by this project is strongly recommended!'),            );            break;          case 'unsupported':            $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-not-supported',              'label' => t('Project not supported'),              'data' => t('This project is no longer supported, and is no longer available for download. Disabling everything included by this project is strongly recommended!'),            );            break;          case 'not-fetched':            $projects[$project]['status'] = UPDATE_NOT_FETCHED;            $projects[$project]['reason'] = t('Failed to fetch available update data');            break;          default:            // Assume anything else (e.g. 'published') is valid and we should            // perform the rest of the logic in this function.            break;        }      }      if (!empty($projects[$project]['status'])) {        // We already know the status for this project, so there's nothing        // else to compute. Just record everything else we fetched from the        // XML file into our projects array and move to the next project.        $projects[$project] += $available[$project];        continue;      }      // Figure out the target major version.      $existing_major = $project_info['existing_major'];      $supported_majors = array();      if (isset($available[$project]['supported_majors'])) {        $supported_majors = explode(',', $available[$project]['supported_majors']);      }      elseif (isset($available[$project]['default_major'])) {        // Older release history XML file without supported or recommended.        $supported_majors[] = $available[$project]['default_major'];      }      if (in_array($existing_major, $supported_majors)) {        // Still supported, stay at the current major version.        $target_major = $existing_major;      }      elseif (isset($available[$project]['recommended_major'])) {        // Since 'recommended_major' is defined, we know this is the new XML        // format. Therefore, we know the current release is unsupported since        // its major version was not in the 'supported_majors' list. We should        // find the best release from the recommended major version.        $target_major = $available[$project]['recommended_major'];        $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;      }      elseif (isset($available[$project]['default_major'])) {        // Older release history XML file without recommended, so recommend        // the currently defined "default_major" version.        $target_major = $available[$project]['default_major'];      }      else {        // Malformed XML file? Stick with the current version.        $target_major = $existing_major;      }      // Make sure we never tell the admin to downgrade. If we recommended an      // earlier version than the one they're running, they'd face an      // impossible data migration problem, since Drupal never supports a DB      // downgrade path. In the unfortunate case that what they're running is      // unsupported, and there's nothing newer for them to upgrade to, we      // can't print out a "Recommended version", but just have to tell them      // what they have is unsupported and let them figure it out.      $target_major = max($existing_major, $target_major);      $version_patch_changed = '';      $patch = '';      // Defend ourselves from XML history files that contain no releases.      if (empty($available[$project]['releases'])) {        $projects[$project]['status'] = UPDATE_UNKNOWN;        $projects[$project]['reason'] = t('No available releases found');        continue;      }      foreach ($available[$project]['releases'] as $version => $release) {        // First, if this is the existing release, check a few conditions.        if ($projects[$project]['existing_version'] === $version) {          if (isset($release['terms']['Release type']) &&              in_array('Insecure', $release['terms']['Release type'])) {            $projects[$project]['status'] = UPDATE_NOT_SECURE;          }          elseif ($release['status'] == 'unpublished') {            $projects[$project]['status'] = UPDATE_REVOKED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'release-revoked',              'label' => t('Release revoked'),              'data' => t('Your currently installed release has been revoked, and is no longer available for download. Disabling everything included in this release or upgrading is strongly recommended!'),            );          }          elseif (isset($release['terms']['Release type']) &&                  in_array('Unsupported', $release['terms']['Release type'])) {            $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'release-not-supported',              'label' => t('Release not supported'),              'data' => t('Your currently installed release is now unsupported, and is no longer available for download. Disabling everything included in this release or upgrading is strongly recommended!'),            );          }        }        // Otherwise, ignore unpublished, insecure, or unsupported releases.        if ($release['status'] == 'unpublished' ||            (isset($release['terms']['Release type']) &&             (in_array('Insecure', $release['terms']['Release type']) ||              in_array('Unsupported', $release['terms']['Release type'])))) {          continue;        }        // See if this is a higher major version than our target and yet still        // supported. If so, record it as an "Also available" release.        if ($release['version_major'] > $target_major) {          if (in_array($release['version_major'], $supported_majors)) {            if (!isset($available[$project]['also'])) {              $available[$project]['also'] = array();            }            if (!isset($available[$project]['also'][$release['version_major']])) {              $available[$project]['also'][$release['version_major']] = $version;            }          }          // Otherwise, this release can't matter to us, since it's neither          // from the release series we're currently using nor the recommended          // release. We don't even care about security updates for this          // branch, since if a project maintainer puts out a security release          // at a higher major version and not at the lower major version,          // they must remove the lower version from the supported major          // versions at the same time, in which case we won't hit this code.          continue;        }        // Look for the 'latest version' if we haven't found it yet. Latest is        // defined as the most recent version for the target major version.        if (!isset($available[$project]['latest_version'])            && $release['version_major'] == $target_major) {          $available[$project]['latest_version'] = $version;        }        // Look for the development snapshot release for this branch.        if (!isset($available[$project]['dev_version'])            && $release['version_major'] == $target_major            && isset($release['version_extra'])            && $release['version_extra'] == 'dev') {          $available[$project]['dev_version'] = $version;        }        // Look for the 'recommended' version if we haven't found it yet (see        // phpdoc at the top of this function for the definition).        if (!isset($available[$project]['recommended'])            && $release['version_major'] == $target_major            && isset($release['version_patch'])) {          if ($patch != $release['version_patch']) {            $patch = $release['version_patch'];            $version_patch_changed = $release['version'];          }          if (empty($release['version_extra']) && $patch == $release['version_patch']) {            $available[$project]['recommended'] = $version_patch_changed;          }        }        // Stop searching once we hit the currently installed version.        if ($projects[$project]['existing_version'] === $version) {          break;        }        // If we're running a dev snapshot and have a timestamp, stop        // searching for security updates once we hit an official release        // older than what we've got. Allow 100 seconds of leeway to handle        // differences between the datestamp in the .info file and the        // timestamp of the tarball itself (which are usually off by 1 or 2        // seconds) so that we don't flag that as a new release.        if ($projects[$project]['install_type'] == 'dev') {          if (empty($projects[$project]['datestamp'])) {            // We don't have current timestamp info, so we can't know.            continue;          }          elseif (isset($release['date']) && ($projects[$project]['datestamp'] + 100 > $release['date'])) {            // We're newer than this, so we can skip it.            continue;          }        }        // See if this release is a security update.        if (isset($release['terms']['Release type'])            && in_array('Security update', $release['terms']['Release type'])) {          $projects[$project]['security updates'][] = $release;        }      }      // If we were unable to find a recommended version, then make the latest      // version the recommended version if possible.      if (!isset($available[$project]['recommended']) && isset($available[$project]['latest_version'])) {        $available[$project]['recommended'] = $available[$project]['latest_version'];      }      // Stash the info about available releases into our $projects array.      $projects[$project] += $available[$project];      //      // Check to see if we need an update or not.      //      if (!empty($projects[$project]['security updates'])) {        // If we found security updates, that always trumps any other status.        $projects[$project]['status'] = UPDATE_NOT_SECURE;      }      if (isset($projects[$project]['status'])) {        // If we already know the status, we're done.        continue;      }      // If we don't know what to recommend, there's nothing we can report.      // Bail out early.      if (!isset($projects[$project]['recommended'])) {        $projects[$project]['status'] = UPDATE_UNKNOWN;        $projects[$project]['reason'] = t('No available releases found');        continue;      }      // If we're running a dev snapshot, compare the date of the dev snapshot      // with the latest official version, and record the absolute latest in      // 'latest_dev' so we can correctly decide if there's a newer release      // than our current snapshot.      if ($projects[$project]['install_type'] == 'dev') {        if (isset($available[$project]['dev_version']) && $available[$project]['releases'][$available[$project]['dev_version']]['date'] > $available[$project]['releases'][$available[$project]['latest_version']]['date']) {          $projects[$project]['latest_dev'] = $available[$project]['dev_version'];        }        else {          $projects[$project]['latest_dev'] = $available[$project]['latest_version'];        }      }      // Figure out the status, based on what we've seen and the install type.      switch ($projects[$project]['install_type']) {        case 'official':          if ($projects[$project]['existing_version'] === $projects[$project]['recommended'] || $projects[$project]['existing_version'] === $projects[$project]['latest_version']) {            $projects[$project]['status'] = UPDATE_CURRENT;          }          else {            $projects[$project]['status'] = UPDATE_NOT_CURRENT;          }          break;        case 'dev':          $latest = $available[$project]['releases'][$projects[$project]['latest_dev']];          if (empty($projects[$project]['datestamp'])) {            $projects[$project]['status'] = UPDATE_NOT_CHECKED;            $projects[$project]['reason'] = t('Unknown release date');          }          elseif (($projects[$project]['datestamp'] + 100 > $latest['date'])) {            $projects[$project]['status'] = UPDATE_CURRENT;          }          else {            $projects[$project]['status'] = UPDATE_NOT_CURRENT;          }          break;        default:          $projects[$project]['status'] = UPDATE_UNKNOWN;          $projects[$project]['reason'] = t('Invalid info');      }    }    else {      $projects[$project]['status'] = UPDATE_UNKNOWN;      $projects[$project]['reason'] = t('No available releases found');    }  }  // Give other modules a chance to alter the status (for example, to allow a  // contrib module to provide fine-grained settings to ignore specific  // projects or releases).  drupal_alter('update_status', $projects);  // Cache the site's update status for at most 1 hour.  _update_cache_set('update_project_data', $projects, time() + 3600);  return $projects;}/** * Retrieve data from {cache_update} or empty the cache when necessary. * * Two very expensive arrays computed by this module are the list of all * installed modules and themes (and .info data, project associations, etc), * and the current status of the site relative to the currently available * releases. These two arrays are cached in the {cache_update} table and used * whenever possible. The cache is cleared whenever the administrator visits * the status report, available updates report, or the module or theme * administration pages, since we should always recompute the most current * values on any of those pages. * * Note: while both of these arrays are expensive to compute (in terms of disk * I/O and some fairly heavy CPU processing), neither of these is the actual * data about available updates that we have to fetch over the network from * updates.drupal.org. That information is stored with the * 'update_available_releases' cache ID -- it needs to persist longer than 1 * hour and never get invalidated just by visiting a page on the site. * * @param $cid *   The cache id of data to return from the cache. Valid options are *   'update_project_data' and 'update_project_projects'. * * @return *   The cached value of the $projects array generated by *   update_calculate_project_data() or update_get_projects(), or an empty *   array when the cache is cleared. */function update_project_cache($cid) {  $projects = array();  // On certain paths, we should clear the cache and recompute the projects or  // update status of the site to avoid presenting stale information.  $q = $_GET['q'];  $paths = array('admin/build/modules', 'admin/build/themes', 'admin/reports', 'admin/reports/updates', 'admin/reports/status', 'admin/reports/updates/check');  if (in_array($q, $paths)) {    _update_cache_clear($cid);  }  else {    $cache = _update_cache_get($cid);    if (!empty($cache->data) && $cache->expire > time()) {      $projects = $cache->data;    }  }  return $projects;}/** * Filter the project .info data to only save attributes we need. * * @param array $info *   Array of .info file data as returned by drupal_parse_info_file(). * * @return *   Array of .info file data we need for the Update manager. * * @see _update_process_info_list() */function update_filter_project_info($info) {  $whitelist = array(    '_info_file_ctime',    'datestamp',    'major',    'name',    'package',    'project',    'project status url',    'version',   );  return array_intersect_key($info, drupal_map_assoc($whitelist));}
<?php// $Id$/** * @file * Manages displaying online help. *//** * Implementation of hook_menu(). */function help_menu() {  $items['admin/help'] = array(    'title' => 'Help',    'page callback' => 'help_main',    'access arguments' => array('access administration pages'),    'weight' => 9,    'file' => 'help.admin.inc',  );  foreach (module_implements('help', TRUE) as $module) {    $items['admin/help/'. $module] = array(      'title' => $module,      'page callback' => 'help_page',      'page arguments' => array(2),      'access arguments' => array('access administration pages'),      'type' => MENU_CALLBACK,      'file' => 'help.admin.inc',    );  }  return $items;}/** * Implementation of hook_help(). */function help_help($path, $arg) {  switch ($path) {    case 'admin/help':      $output = '<p>'. t('This guide provides context sensitive help on the use and configuration of <a href="@drupal">Drupal</a> and its modules, and is a supplement to the more extensive online <a href="@handbook">Drupal handbook</a>. The online handbook may contain more up-to-date information, is annotated with helpful user-contributed comments, and serves as the definitive reference point for all Drupal documentation.', array('@drupal' => 'http://drupal.org', '@handbook' => 'http://drupal.org/handbook')) .'</p>';      return $output;    case 'admin/help#help':      $output = '<p>'. t('The help module provides context sensitive help on the use and configuration of <a href="@drupal">Drupal</a> and its modules, and is a supplement to the more extensive online <a href="@handbook">Drupal handbook</a>. The online handbook may contain more up-to-date information, is annotated with helpful user-contributed comments, and serves as the definitive reference point for all Drupal documentation.', array('@drupal' => 'http://drupal.org', '@handbook' => 'http://drupal.org/handbook')) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@help">Help module</a>.', array('@help' => 'http://drupal.org/handbook/modules/help/')) .'</p>';      return $output;  }}
<?php// $Id$/** * @file Batch processing API for processes to run in multiple HTTP requests. *//** * State-based dispatcher for the batch processing page. */function _batch_page() {  $batch =& batch_get();  // Retrieve the current state of batch from db.  if (isset($_REQUEST['id']) && $data = db_result(db_query("SELECT batch FROM {batch} WHERE bid = %d AND token = '%s'", $_REQUEST['id'], drupal_get_token($_REQUEST['id'])))) {    $batch = unserialize($data);  }  else {    return FALSE;  }  // Register database update for end of processing.  register_shutdown_function('_batch_shutdown');  $op = isset($_REQUEST['op']) ? $_REQUEST['op'] : '';  $output = NULL;  switch ($op) {    case 'start':      $output = _batch_start();      break;    case 'do':      // JS-version AJAX callback.      _batch_do();      break;    case 'do_nojs':      // Non-JS progress page.      $output = _batch_progress_page_nojs();      break;    case 'finished':      $output = _batch_finished();      break;  }  return $output;}/** * Initiate the batch processing */function _batch_start() {  // Choose between the JS and non-JS version.  // JS-enabled users are identified through the 'has_js' cookie set in drupal.js.  // If the user did not visit any JS enabled page during his browser session,  // he gets the non-JS version...  if (isset($_COOKIE['has_js']) && $_COOKIE['has_js']) {    return _batch_progress_page_js();  }  else {    return _batch_progress_page_nojs();  }}/** * Batch processing page with JavaScript support. */function _batch_progress_page_js() {  $batch = batch_get();  // The first batch set gets to set the page title  // and the initialization and error messages.  $current_set = _batch_current_set();  drupal_set_title($current_set['title']);  drupal_add_js('misc/progress.js', 'core', 'header', FALSE, FALSE);  $url = url($batch['url'], array('query' => array('id' => $batch['id'])));  $js_setting = array(    'batch' => array(      'errorMessage' => $current_set['error_message'] .'<br/>'. $batch['error_message'],      'initMessage' => $current_set['init_message'],      'uri' => $url,    ),  );  drupal_add_js($js_setting, 'setting');  drupal_add_js('misc/batch.js', 'core', 'header', FALSE, FALSE);  $output = '<div id="progress"></div>';  return $output;}/** * Do one pass of execution and inform back the browser about progression * (used for JavaScript-mode only). */function _batch_do() {  // HTTP POST required  if ($_SERVER['REQUEST_METHOD'] != 'POST') {    drupal_set_message(t('HTTP POST is required.'), 'error');    drupal_set_title(t('Error'));    return '';  }  // Perform actual processing.  list($percentage, $message) = _batch_process();  drupal_json(array('status' => TRUE, 'percentage' => $percentage, 'message' => $message));}/** * Batch processing page without JavaScript support. */function _batch_progress_page_nojs() {  $batch =& batch_get();  $current_set = _batch_current_set();  drupal_set_title($current_set['title']);  $new_op = 'do_nojs';  if (!isset($batch['running'])) {    // This is the first page so we return some output immediately.    $percentage = 0;    $message = $current_set['init_message'];    $batch['running'] = TRUE;  }  else {    // This is one of the later requests: do some processing first.    // Error handling: if PHP dies due to a fatal error (e.g. non-existant    // function), it will output whatever is in the output buffer,    // followed by the error message.    ob_start();    $fallback = $current_set['error_message'] .'<br/>'. $batch['error_message'];    $fallback = theme('maintenance_page', $fallback, FALSE, FALSE);    // We strip the end of the page using a marker in the template, so any    // additional HTML output by PHP shows up inside the page rather than    // below it. While this causes invalid HTML, the same would be true if    // we didn't, as content is not allowed to appear after </html> anyway.    list($fallback) = explode('<!--partial-->', $fallback);    print $fallback;    // Perform actual processing.    list($percentage, $message) = _batch_process($batch);    if ($percentage == 100) {      $new_op = 'finished';    }    // PHP did not die : remove the fallback output.    ob_end_clean();  }  $url = url($batch['url'], array('query' => array('id' => $batch['id'], 'op' => $new_op)));  drupal_set_html_head('<meta http-equiv="Refresh" content="0; URL='. $url .'">');  $output = theme('progress_bar', $percentage, $message);  return $output;}/** * Advance batch processing for 1 second (or process the whole batch if it * was not set for progressive execution - e.g forms submitted by drupal_execute). */function _batch_process() {  $batch =& batch_get();  $current_set =& _batch_current_set();  $set_changed = TRUE;  if ($batch['progressive']) {    timer_start('batch_processing');  }  while (!$current_set['success']) {    // If this is the first time we iterate this batch set in the current    // request, we check if it requires an additional file for functions    // definitions.    if ($set_changed && isset($current_set['file']) && is_file($current_set['file'])) {      include_once($current_set['file']);    }    $finished = 1;    $task_message = '';    if ((list($function, $args) = reset($current_set['operations'])) && function_exists($function)) {      // Build the 'context' array, execute the function call,      // and retrieve the user message.      $batch_context = array('sandbox' => &$current_set['sandbox'], 'results' => &$current_set['results'], 'finished' => &$finished, 'message' => &$task_message);      // Process the current operation.      call_user_func_array($function, array_merge($args, array(&$batch_context)));    }    if ($finished == 1) {      // Make sure this step isn't counted double when computing $current.      $finished = 0;      // Remove the operation and clear the sandbox.      array_shift($current_set['operations']);      $current_set['sandbox'] = array();    }    // If the batch set is completed, browse through the remaining sets,    // executing 'control sets' (stored form submit handlers) along the way -    // this might in turn insert new batch sets.    // Stop when we find a set that actually has operations.    $set_changed = FALSE;    $old_set = $current_set;    while (empty($current_set['operations']) && ($current_set['success'] = TRUE) && _batch_next_set()) {      $current_set =& _batch_current_set();      $set_changed = TRUE;    }    // At this point, either $current_set is a 'real' batch set (has operations),    // or all sets have been completed.    // If we're in progressive mode, stop after 1 second.    if ($batch['progressive'] && timer_read('batch_processing') > 1000) {      break;    }  }  if ($batch['progressive']) {    // Gather progress information.    // Reporting 100% progress will cause the whole batch to be considered    // processed. If processing was paused right after moving to a new set,    // we have to use the info from the new (unprocessed) one.    if ($set_changed && isset($current_set['operations'])) {      // Processing will continue with a fresh batch set.      $remaining = count($current_set['operations']);      $total = $current_set['total'];      $progress_message = $current_set['init_message'];      $task_message = '';    }    else {      $remaining = count($old_set['operations']);      $total = $old_set['total'];      $progress_message = $old_set['progress_message'];    }    $current    = $total - $remaining + $finished;    $percentage = $total ? floor($current / $total * 100) : 100;    $values = array(      '@remaining'  => $remaining,      '@total'      => $total,      '@current'    => floor($current),      '@percentage' => $percentage,      );    $message = strtr($progress_message, $values) .'<br/>';    $message .= $task_message ? $task_message : '&nbsp';    return array($percentage, $message);  }  else {    // If we're not in progressive mode, the whole batch has been processed by now.    return _batch_finished();  }}/** * Retrieve the batch set being currently processed. */function &_batch_current_set() {  $batch =& batch_get();  return $batch['sets'][$batch['current_set']];}/** * Move execution to the next batch set if any, executing the stored * form _submit handlers along the way (thus possibly inserting * additional batch sets). */function _batch_next_set() {  $batch =& batch_get();  if (isset($batch['sets'][$batch['current_set'] + 1])) {    $batch['current_set']++;    $current_set =& _batch_current_set();    if (isset($current_set['form_submit']) && ($function = $current_set['form_submit']) && function_exists($function)) {      // We use our stored copies of $form and $form_state, to account for      // possible alteration by the submit handlers.      $function($batch['form'], $batch['form_state']);    }    return TRUE;  }}/** * End the batch processing: * Call the 'finished' callbacks to allow custom handling of results, * and resolve page redirection. */function _batch_finished() {  $batch =& batch_get();  // Execute the 'finished' callbacks for each batch set.  foreach ($batch['sets'] as $key => $batch_set) {    if (isset($batch_set['finished'])) {      // Check if the set requires an additional file for functions definitions.      if (isset($batch_set['file']) && is_file($batch_set['file'])) {        include_once($batch_set['file']);      }      if (function_exists($batch_set['finished'])) {        $batch_set['finished']($batch_set['success'], $batch_set['results'], $batch_set['operations']);      }    }  }  // Cleanup the batch table and unset the global $batch variable.  if ($batch['progressive']) {    db_query("DELETE FROM {batch} WHERE bid = %d", $batch['id']);  }  $_batch = $batch;  $batch = NULL;  // Redirect if needed.  if ($_batch['progressive']) {    // Put back the 'destination' that was saved in batch_process().    if (isset($_batch['destination'])) {      $_REQUEST['destination'] = $_batch['destination'];    }    // Use $_batch['form_state']['redirect'], or $_batch['redirect'],    // or $_batch['source_page'].    if (isset($_batch['form_state']['redirect'])) {      $redirect = $_batch['form_state']['redirect'];    }    elseif (isset($_batch['redirect'])) {      $redirect = $_batch['redirect'];    }    else {      $redirect = $_batch['source_page'];    }    // Let drupal_redirect_form handle redirection logic.    $form = isset($batch['form']) ? $batch['form'] : array();    if (empty($_batch['form_state']['rebuild']) && empty($_batch['form_state']['storage'])) {      drupal_redirect_form($form, $redirect);    }    // We get here if $form['#redirect'] was FALSE, or if the form is a    // multi-step form. We save the final $form_state value to be retrieved    // by drupal_get_form, and we redirect to the originating page.    $_SESSION['batch_form_state'] = $_batch['form_state'];    drupal_goto($_batch['source_page']);  }}/** * Shutdown function: store the batch data for next request, * or clear the table if the batch is finished. */function _batch_shutdown() {  if ($batch = batch_get()) {    db_query("UPDATE {batch} SET batch = '%s' WHERE bid = %d", serialize($batch), $batch['id']);  }}
<?php// $Id$/** * @file * Admin page callbacks for the filter module. *//** * Menu callback; Displays a list of all input formats and which * one is the default. * * @ingroup forms * @see filter_admin_overview_submit() */function filter_admin_overview() {  // Overview of all formats.  $formats = filter_formats();  $error = FALSE;  foreach ($formats as $id => $format) {    $roles = array();    foreach (user_roles() as $rid => $name) {      // Prepare a roles array with roles that may access the filter.      if (strstr($format->roles, ",$rid,")) {        $roles[] = $name;      }    }    $default = ($id == variable_get('filter_default_format', 1));    $options[$id] = '';    $form[$format->name]['id'] = array('#value' => $id);    $form[$format->name]['roles'] = array('#value' => $default ? t('All roles may use default format') : ($roles ? implode(', ', $roles) : t('No roles may use this format')));    $form[$format->name]['configure'] = array('#value' => l(t('configure'), 'admin/settings/filters/'. $id));    $form[$format->name]['delete'] = array('#value' => $default ? '' : l(t('delete'), 'admin/settings/filters/delete/'. $id));  }  $form['default'] = array('#type' => 'radios', '#options' => $options, '#default_value' => variable_get('filter_default_format', 1));  $form['submit'] = array('#type' => 'submit', '#value' => t('Set default format'));  return $form;}function filter_admin_overview_submit($form, &$form_state) {  // Process form submission to set the default format.  if (is_numeric($form_state['values']['default'])) {    drupal_set_message(t('Default format updated.'));    variable_set('filter_default_format', $form_state['values']['default']);  }}/** * Theme the admin overview form. * * @ingroup themeable */function theme_filter_admin_overview($form) {  $rows = array();  foreach ($form as $name => $element) {    if (isset($element['roles']) && is_array($element['roles'])) {      $rows[] = array(        drupal_render($form['default'][$element['id']['#value']]),        check_plain($name),        drupal_render($element['roles']),        drupal_render($element['configure']),        drupal_render($element['delete'])      );      unset($form[$name]);    }  }  $header = array(t('Default'), t('Name'), t('Roles'), array('data' => t('Operations'), 'colspan' => 2));  $output = theme('table', $header, $rows);  $output .= drupal_render($form);  return $output;}/** * Menu callback; Display a filter format form. */function filter_admin_format_page($format = NULL) {  if (!isset($format->name)) {    drupal_set_title(t("Add input format"));    $format = (object)array('name' => '', 'roles' => '', 'format' => '');  }  return drupal_get_form('filter_admin_format_form', $format);}/** * Generate a filter format form. * * @ingroup forms * @see filter_admin_format_form_validate() * @see filter_admin_format_form_submit() */function filter_admin_format_form(&$form_state, $format) {  $default = ($format->format == variable_get('filter_default_format', 1));  if ($default) {    $help = t('All roles for the default format must be enabled and cannot be changed.');    $form['default_format'] = array('#type' => 'hidden', '#value' => 1);  }  $form['name'] = array('#type' => 'textfield',    '#title' => t('Name'),    '#default_value' => $format->name,    '#description' => t('Specify a unique name for this filter format.'),    '#required' => TRUE,  );  // Add a row of checkboxes for form group.  $form['roles'] = array('#type' => 'fieldset',    '#title' => t('Roles'),    '#description' => $default ? $help : t('Choose which roles may use this filter format. Note that roles with the "administer filters" permission can always use all the filter formats.'),    '#tree' => TRUE,  );  foreach (user_roles() as $rid => $name) {    $checked = strstr($format->roles, ",$rid,");    $form['roles'][$rid] = array('#type' => 'checkbox',      '#title' => $name,      '#default_value' => ($default || $checked),    );    if ($default) {      $form['roles'][$rid]['#disabled'] = TRUE;    }  }  // Table with filters  $all = filter_list_all();  $enabled = filter_list_format($format->format);  $form['filters'] = array('#type' => 'fieldset',    '#title' => t('Filters'),    '#description' => t('Choose the filters that will be used in this filter format.'),    '#tree' => TRUE,  );  foreach ($all as $id => $filter) {    $form['filters'][$id] = array('#type' => 'checkbox',      '#title' => $filter->name,      '#default_value' => isset($enabled[$id]),      '#description' => module_invoke($filter->module, 'filter', 'description', $filter->delta),    );  }  if (!empty($format->format)) {    $form['format'] = array('#type' => 'hidden', '#value' => $format->format);    // Composition tips (guidelines)    $tips = _filter_tips($format->format, FALSE);    $extra = '<p>'. l(t('More information about formatting options'), 'filter/tips') .'</p>';    $tiplist = theme('filter_tips', $tips, FALSE, $extra);    if (!$tiplist) {      $tiplist = '<p>'. t('No guidelines available.') .'</p>';    }    $group = '<p>'. t('These are the guidelines that users will see for posting in this input format. They are automatically generated from the filter settings.') .'</p>';    $group .= $tiplist;    $form['tips'] = array('#value' => '<h2>'. t('Formatting guidelines') .'</h2>'. $group);  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save configuration'));  return $form;}/** * Validate filter format form submissions. */function filter_admin_format_form_validate($form, &$form_state) {  if (!isset($form_state['values']['format'])) {    $name = trim($form_state['values']['name']);    $result = db_fetch_object(db_query("SELECT format FROM {filter_formats} WHERE name='%s'", $name));    if ($result) {      form_set_error('name', t('Filter format names need to be unique. A format named %name already exists.', array('%name' => $name)));    }  }}/** * Process filter format form submissions. */function filter_admin_format_form_submit($form, &$form_state) {  $format = isset($form_state['values']['format']) ? $form_state['values']['format'] : NULL;  $current = filter_list_format($format);  $name = trim($form_state['values']['name']);  $cache = TRUE;  // Add a new filter format.  if (!$format) {    $new = TRUE;    db_query("INSERT INTO {filter_formats} (name) VALUES ('%s')", $name);    $format = db_result(db_query("SELECT MAX(format) AS format FROM {filter_formats}"));    drupal_set_message(t('Added input format %format.', array('%format' => $name)));  }  else {    drupal_set_message(t('The input format settings have been updated.'));  }  db_query("DELETE FROM {filters} WHERE format = %d", $format);  foreach ($form_state['values']['filters'] as $id => $checked) {    if ($checked) {      list($module, $delta) = explode('/', $id);      // Add new filters to the bottom.      $weight = isset($current[$id]->weight) ? $current[$id]->weight : 10;      db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $format, $module, $delta, $weight);      // Check if there are any 'no cache' filters.      $cache &= !module_invoke($module, 'filter', 'no cache', $delta);    }  }  // We store the roles as a string for ease of use.  // We should always set all roles to TRUE when saving a default role.  // We use leading and trailing comma's to allow easy substring matching.  $roles = array();  if (isset($form_state['values']['roles'])) {    foreach ($form_state['values']['roles'] as $id => $checked) {      if ($checked) {        $roles[] = $id;      }    }  }  if (!empty($form_state['values']['default_format'])) {    $roles = ','. implode(',', array_keys(user_roles())) .',';  }  else {    $roles = ','. implode(',', $roles) .',';  }  db_query("UPDATE {filter_formats} SET cache = %d, name='%s', roles = '%s' WHERE format = %d", $cache, $name, $roles, $format);  cache_clear_all($format .':', 'cache_filter', TRUE);  // If a new filter was added, return to the main list of filters. Otherwise, stay on edit filter page to show new changes.  $return = 'admin/settings/filters';  if (!empty($new)) {    $return .= '/'. $format;  }  $form_state['redirect'] = $return;  return;}/** * Menu callback; confirm deletion of a format. * * @ingroup forms * @see filter_admin_delete_submit() */function filter_admin_delete() {  $format = arg(4);  $format = db_fetch_object(db_query('SELECT * FROM {filter_formats} WHERE format = %d', $format));  if ($format) {    if ($format->format != variable_get('filter_default_format', 1)) {      $form['format'] = array('#type' => 'hidden', '#value' => $format->format);      $form['name'] = array('#type' => 'hidden', '#value' => $format->name);      return confirm_form($form, t('Are you sure you want to delete the input format %format?', array('%format' => $format->name)), 'admin/settings/filters', t('If you have any content left in this input format, it will be switched to the default input format. This action cannot be undone.'), t('Delete'), t('Cancel'));    }    else {      drupal_set_message(t('The default format cannot be deleted.'));      drupal_goto('admin/settings/filters');    }  }  else {    drupal_not_found();  }}/** * Process filter delete form submission. */function filter_admin_delete_submit($form, &$form_state) {  db_query("DELETE FROM {filter_formats} WHERE format = %d", $form_state['values']['format']);  db_query("DELETE FROM {filters} WHERE format = %d", $form_state['values']['format']);  $default = variable_get('filter_default_format', 1);  // Replace existing instances of the deleted format with the default format.  db_query("UPDATE {node_revisions} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  db_query("UPDATE {comments} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  db_query("UPDATE {boxes} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);  drupal_set_message(t('Deleted input format %format.', array('%format' => $form_state['values']['name'])));  $form_state['redirect'] = 'admin/settings/filters';  return;}/** * Menu callback; display settings defined by a format's filters. */function filter_admin_configure_page($format) {  drupal_set_title(t("Configure %format", array('%format' => $format->name)));  return drupal_get_form('filter_admin_configure', $format);}/** * Build a form to change the settings for a format's filters. * * @ingroup forms */function filter_admin_configure(&$form_state, $format) {  $list = filter_list_format($format->format);  $form = array();  foreach ($list as $filter) {    $form_module = module_invoke($filter->module, 'filter', 'settings', $filter->delta, $format->format);    if (isset($form_module) && is_array($form_module)) {      $form = array_merge($form, $form_module);    }  }  if (!empty($form)) {    $form = system_settings_form($form);  }  else {    $form['error'] = array('#value' => t('No settings are available.'));  }  $form['format'] = array('#type' => 'hidden', '#value' => $format->format);  $form['#submit'][] = 'filter_admin_configure_submit';  return $form;}/** * Clear the filter's cache when configuration settings are saved. */function filter_admin_configure_submit($form, &$form_state) {  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);}/** * Menu callback; display form for ordering filters for a format. */function filter_admin_order_page($format) {  drupal_set_title(t("Rearrange %format", array('%format' => $format->name)));  return drupal_get_form('filter_admin_order', $format);}/** * Build the form for ordering filters for a format. * * @ingroup forms * @see theme_filter_admin_order() * @see filter_admin_order_submit() */function filter_admin_order(&$form_state, $format = NULL) {  // Get list (with forced refresh).  $filters = filter_list_format($format->format);  $form['weights'] = array('#tree' => TRUE);  foreach ($filters as $id => $filter) {    $form['names'][$id] = array('#value' => $filter->name);    $form['weights'][$id] = array('#type' => 'weight', '#default_value' => $filter->weight);  }  $form['format'] = array('#type' => 'hidden', '#value' => $format->format);  $form['submit'] = array('#type' => 'submit', '#value' => t('Save configuration'));  return $form;}/** * Theme filter order configuration form. * * @ingroup themeable */function theme_filter_admin_order($form) {  $header = array(t('Name'), t('Weight'));  $rows = array();  foreach (element_children($form['names']) as $id) {    // Don't take form control structures.    if (is_array($form['names'][$id])) {      $form['weights'][$id]['#attributes']['class'] = 'filter-order-weight';      $rows[] = array(        'data' => array(drupal_render($form['names'][$id]), drupal_render($form['weights'][$id])),        'class' => 'draggable',      );    }  }  $output = theme('table', $header, $rows, array('id' => 'filter-order'));  $output .= drupal_render($form);  drupal_add_tabledrag('filter-order', 'order', 'sibling', 'filter-order-weight', NULL, NULL, FALSE);  return $output;}/** * Process filter order configuration form submission. */function filter_admin_order_submit($form, &$form_state) {  foreach ($form_state['values']['weights'] as $id => $weight) {    list($module, $delta) = explode('/', $id);    db_query("UPDATE {filters} SET weight = %d WHERE format = %d AND module = '%s' AND delta = %d", $weight, $form_state['values']['format'], $module, $delta);  }  drupal_set_message(t('The filter ordering has been saved.'));  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);}
<?php// $Id$/** * @file book-navigation.tpl.php * Default theme implementation to navigate books. Presented under nodes that * are a part of book outlines. * * Available variables: * - $tree: The immediate children of the current node rendered as an *   unordered list. * - $current_depth: Depth of the current node within the book outline. *   Provided for context. * - $prev_url: URL to the previous node. * - $prev_title: Title of the previous node. * - $parent_url: URL to the parent node. * - $parent_title: Title of the parent node. Not printed by default. Provided *   as an option. * - $next_url: URL to the next node. * - $next_title: Title of the next node. * - $has_links: Flags TRUE whenever the previous, parent or next data has a *   value. * - $book_id: The book ID of the current outline being viewed. Same as the *   node ID containing the entire outline. Provided for context. * - $book_url: The book/node URL of the current outline being viewed. *   Provided as an option. Not used by default. * - $book_title: The book/node title of the current outline being viewed. *   Provided as an option. Not used by default. * * @see template_preprocess_book_navigation() */?><?php if ($tree || $has_links): ?>  <div id="book-navigation-<?php print $book_id; ?>" class="book-navigation">    <?php print $tree; ?>    <?php if ($has_links): ?>    <div class="page-links clear-block">      <?php if ($prev_url) : ?>        <a href="<?php print $prev_url; ?>" class="page-previous" title="<?php print t('Go to previous page'); ?>"><?php print t(' ') . $prev_title; ?></a>      <?php endif; ?>      <?php if ($parent_url) : ?>        <a href="<?php print $parent_url; ?>" class="page-up" title="<?php print t('Go to parent page'); ?>"><?php print t('up'); ?></a>      <?php endif; ?>      <?php if ($next_url) : ?>        <a href="<?php print $next_url; ?>" class="page-next" title="<?php print t('Go to next page'); ?>"><?php print $next_title . t(' '); ?></a>      <?php endif; ?>    </div>    <?php endif; ?>  </div><?php endif; ?>
<?php// $Id$/** * @file * Enables site-wide keyword searching. *//** * Matches Unicode character classes to exclude from the search index. * * See: http://www.unicode.org/Public/UNIDATA/UCD.html#General_Category_Values * * The index only contains the following character classes: * Lu     Letter, Uppercase * Ll     Letter, Lowercase * Lt     Letter, Titlecase * Lo     Letter, Other * Nd     Number, Decimal Digit * No     Number, Other */define('PREG_CLASS_SEARCH_EXCLUDE','\x{0}-\x{2f}\x{3a}-\x{40}\x{5b}-\x{60}\x{7b}-\x{bf}\x{d7}\x{f7}\x{2b0}-'.'\x{385}\x{387}\x{3f6}\x{482}-\x{489}\x{559}-\x{55f}\x{589}-\x{5c7}\x{5f3}-'.'\x{61f}\x{640}\x{64b}-\x{65e}\x{66a}-\x{66d}\x{670}\x{6d4}\x{6d6}-\x{6ed}'.'\x{6fd}\x{6fe}\x{700}-\x{70f}\x{711}\x{730}-\x{74a}\x{7a6}-\x{7b0}\x{901}-'.'\x{903}\x{93c}\x{93e}-\x{94d}\x{951}-\x{954}\x{962}-\x{965}\x{970}\x{981}-'.'\x{983}\x{9bc}\x{9be}-\x{9cd}\x{9d7}\x{9e2}\x{9e3}\x{9f2}-\x{a03}\x{a3c}-'.'\x{a4d}\x{a70}\x{a71}\x{a81}-\x{a83}\x{abc}\x{abe}-\x{acd}\x{ae2}\x{ae3}'.'\x{af1}-\x{b03}\x{b3c}\x{b3e}-\x{b57}\x{b70}\x{b82}\x{bbe}-\x{bd7}\x{bf0}-'.'\x{c03}\x{c3e}-\x{c56}\x{c82}\x{c83}\x{cbc}\x{cbe}-\x{cd6}\x{d02}\x{d03}'.'\x{d3e}-\x{d57}\x{d82}\x{d83}\x{dca}-\x{df4}\x{e31}\x{e34}-\x{e3f}\x{e46}-'.'\x{e4f}\x{e5a}\x{e5b}\x{eb1}\x{eb4}-\x{ebc}\x{ec6}-\x{ecd}\x{f01}-\x{f1f}'.'\x{f2a}-\x{f3f}\x{f71}-\x{f87}\x{f90}-\x{fd1}\x{102c}-\x{1039}\x{104a}-'.'\x{104f}\x{1056}-\x{1059}\x{10fb}\x{10fc}\x{135f}-\x{137c}\x{1390}-\x{1399}'.'\x{166d}\x{166e}\x{1680}\x{169b}\x{169c}\x{16eb}-\x{16f0}\x{1712}-\x{1714}'.'\x{1732}-\x{1736}\x{1752}\x{1753}\x{1772}\x{1773}\x{17b4}-\x{17db}\x{17dd}'.'\x{17f0}-\x{180e}\x{1843}\x{18a9}\x{1920}-\x{1945}\x{19b0}-\x{19c0}\x{19c8}'.'\x{19c9}\x{19de}-\x{19ff}\x{1a17}-\x{1a1f}\x{1d2c}-\x{1d61}\x{1d78}\x{1d9b}-'.'\x{1dc3}\x{1fbd}\x{1fbf}-\x{1fc1}\x{1fcd}-\x{1fcf}\x{1fdd}-\x{1fdf}\x{1fed}-'.'\x{1fef}\x{1ffd}-\x{2070}\x{2074}-\x{207e}\x{2080}-\x{2101}\x{2103}-\x{2106}'.'\x{2108}\x{2109}\x{2114}\x{2116}-\x{2118}\x{211e}-\x{2123}\x{2125}\x{2127}'.'\x{2129}\x{212e}\x{2132}\x{213a}\x{213b}\x{2140}-\x{2144}\x{214a}-\x{2b13}'.'\x{2ce5}-\x{2cff}\x{2d6f}\x{2e00}-\x{3005}\x{3007}-\x{303b}\x{303d}-\x{303f}'.'\x{3099}-\x{309e}\x{30a0}\x{30fb}-\x{30fe}\x{3190}-\x{319f}\x{31c0}-\x{31cf}'.'\x{3200}-\x{33ff}\x{4dc0}-\x{4dff}\x{a015}\x{a490}-\x{a716}\x{a802}\x{a806}'.'\x{a80b}\x{a823}-\x{a82b}\x{d800}-\x{f8ff}\x{fb1e}\x{fb29}\x{fd3e}\x{fd3f}'.'\x{fdfc}-\x{fe6b}\x{feff}-\x{ff0f}\x{ff1a}-\x{ff20}\x{ff3b}-\x{ff40}\x{ff5b}-'.'\x{ff65}\x{ff70}\x{ff9e}\x{ff9f}\x{ffe0}-\x{fffd}');/** * Matches all 'N' Unicode character classes (numbers) */define('PREG_CLASS_NUMBERS','\x{30}-\x{39}\x{b2}\x{b3}\x{b9}\x{bc}-\x{be}\x{660}-\x{669}\x{6f0}-\x{6f9}'.'\x{966}-\x{96f}\x{9e6}-\x{9ef}\x{9f4}-\x{9f9}\x{a66}-\x{a6f}\x{ae6}-\x{aef}'.'\x{b66}-\x{b6f}\x{be7}-\x{bf2}\x{c66}-\x{c6f}\x{ce6}-\x{cef}\x{d66}-\x{d6f}'.'\x{e50}-\x{e59}\x{ed0}-\x{ed9}\x{f20}-\x{f33}\x{1040}-\x{1049}\x{1369}-'.'\x{137c}\x{16ee}-\x{16f0}\x{17e0}-\x{17e9}\x{17f0}-\x{17f9}\x{1810}-\x{1819}'.'\x{1946}-\x{194f}\x{2070}\x{2074}-\x{2079}\x{2080}-\x{2089}\x{2153}-\x{2183}'.'\x{2460}-\x{249b}\x{24ea}-\x{24ff}\x{2776}-\x{2793}\x{3007}\x{3021}-\x{3029}'.'\x{3038}-\x{303a}\x{3192}-\x{3195}\x{3220}-\x{3229}\x{3251}-\x{325f}\x{3280}-'.'\x{3289}\x{32b1}-\x{32bf}\x{ff10}-\x{ff19}');/** * Matches all 'P' Unicode character classes (punctuation) */define('PREG_CLASS_PUNCTUATION','\x{21}-\x{23}\x{25}-\x{2a}\x{2c}-\x{2f}\x{3a}\x{3b}\x{3f}\x{40}\x{5b}-\x{5d}'.'\x{5f}\x{7b}\x{7d}\x{a1}\x{ab}\x{b7}\x{bb}\x{bf}\x{37e}\x{387}\x{55a}-\x{55f}'.'\x{589}\x{58a}\x{5be}\x{5c0}\x{5c3}\x{5f3}\x{5f4}\x{60c}\x{60d}\x{61b}\x{61f}'.'\x{66a}-\x{66d}\x{6d4}\x{700}-\x{70d}\x{964}\x{965}\x{970}\x{df4}\x{e4f}'.'\x{e5a}\x{e5b}\x{f04}-\x{f12}\x{f3a}-\x{f3d}\x{f85}\x{104a}-\x{104f}\x{10fb}'.'\x{1361}-\x{1368}\x{166d}\x{166e}\x{169b}\x{169c}\x{16eb}-\x{16ed}\x{1735}'.'\x{1736}\x{17d4}-\x{17d6}\x{17d8}-\x{17da}\x{1800}-\x{180a}\x{1944}\x{1945}'.'\x{2010}-\x{2027}\x{2030}-\x{2043}\x{2045}-\x{2051}\x{2053}\x{2054}\x{2057}'.'\x{207d}\x{207e}\x{208d}\x{208e}\x{2329}\x{232a}\x{23b4}-\x{23b6}\x{2768}-'.'\x{2775}\x{27e6}-\x{27eb}\x{2983}-\x{2998}\x{29d8}-\x{29db}\x{29fc}\x{29fd}'.'\x{3001}-\x{3003}\x{3008}-\x{3011}\x{3014}-\x{301f}\x{3030}\x{303d}\x{30a0}'.'\x{30fb}\x{fd3e}\x{fd3f}\x{fe30}-\x{fe52}\x{fe54}-\x{fe61}\x{fe63}\x{fe68}'.'\x{fe6a}\x{fe6b}\x{ff01}-\x{ff03}\x{ff05}-\x{ff0a}\x{ff0c}-\x{ff0f}\x{ff1a}'.'\x{ff1b}\x{ff1f}\x{ff20}\x{ff3b}-\x{ff3d}\x{ff3f}\x{ff5b}\x{ff5d}\x{ff5f}-'.'\x{ff65}');/** * Matches all CJK characters that are candidates for auto-splitting * (Chinese, Japanese, Korean). * Contains kana and BMP ideographs. */define('PREG_CLASS_CJK', '\x{3041}-\x{30ff}\x{31f0}-\x{31ff}\x{3400}-\x{4db5}'.'\x{4e00}-\x{9fbb}\x{f900}-\x{fad9}');/** * Implementation of hook_help(). */function search_help($path, $arg) {  switch ($path) {    case 'admin/help#search':      $output = '<p>'. t('The search module adds the ability to search for content by keywords. Search is often the only practical way to find content on a large site, and is useful for finding both users and posts.') .'</p>';      $output .= '<p>'. t('To provide keyword searching, the search engine maintains an index of words found in your site\'s content. To build and maintain this index, a correctly configured <a href="@cron">cron maintenance task</a> is required. Indexing behavior can be adjusted using the <a href="@searchsettings">search settings page</a>; for example, the <em>Number of items to index per cron run</em> sets the maximum number of items indexed in each pass of a <a href="@cron">cron maintenance task</a>. If necessary, reduce this number to prevent timeouts and memory errors when indexing.', array('@cron' => url('admin/reports/status'), '@searchsettings' => url('admin/settings/search'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@search">Search module</a>.', array('@search' => 'http://drupal.org/handbook/modules/search/')) .'</p>';      return $output;    case 'admin/settings/search':      return '<p>'. t('The search engine maintains an index of words found in your site\'s content. To build and maintain this index, a correctly configured <a href="@cron">cron maintenance task</a> is required. Indexing behavior can be adjusted using the settings below.', array('@cron' => url('admin/reports/status'))) .'</p>';    case 'search#noresults':      return t('<ul><li>Check if your spelling is correct.</li><li>Remove quotes around phrases to match each word individually: <em>"blue smurf"</em> will match less than <em>blue smurf</em>.</li><li>Consider loosening your query with <em>OR</em>: <em>blue smurf</em> will match less than <em>blue OR smurf</em>.</li></ul>');  }}/** * Implementation of hook_theme() */function search_theme() {  return array(    'search_theme_form' => array(      'arguments' => array('form' => NULL),      'template' => 'search-theme-form',    ),    'search_block_form' => array(      'arguments' => array('form' => NULL),      'template' => 'search-block-form',    ),    'search_result' => array(      'arguments' => array('result' => NULL, 'type' => NULL),      'file' => 'search.pages.inc',      'template' => 'search-result',    ),    'search_results' => array(      'arguments' => array('results' => NULL, 'type' => NULL),      'file' => 'search.pages.inc',      'template' => 'search-results',    ),  );}/** * Implementation of hook_perm(). */function search_perm() {  return array('search content', 'use advanced search', 'administer search');}/** * Implementation of hook_block(). */function search_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Search form');    // Not worth caching.    $blocks[0]['cache'] = BLOCK_NO_CACHE;    return $blocks;  }  else if ($op == 'view' && user_access('search content')) {    $block['content'] = drupal_get_form('search_block_form');    $block['subject'] = t('Search');    return $block;  }}/** * Implementation of hook_menu(). */function search_menu() {  $items['search'] = array(    'title' => 'Search',    'page callback' => 'search_view',    'access arguments' => array('search content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'search.pages.inc',  );  $items['admin/settings/search'] = array(    'title' => 'Search settings',    'description' => 'Configure relevance settings for search and other indexing options',    'page callback' => 'drupal_get_form',    'page arguments' => array('search_admin_settings'),    'access arguments' => array('administer search'),    'type' => MENU_NORMAL_ITEM,    'file' => 'search.admin.inc',  );  $items['admin/settings/search/wipe'] = array(    'title' => 'Clear index',    'page callback' => 'drupal_get_form',    'page arguments' => array('search_wipe_confirm'),    'access arguments' => array('administer search'),    'type' => MENU_CALLBACK,    'file' => 'search.admin.inc',  );  $items['admin/reports/search'] = array(    'title' => 'Top search phrases',    'description' => 'View most popular search phrases.',    'page callback' => 'dblog_top',    'page arguments' => array('search'),    'access arguments' => array('access site reports'),    'file' => 'dblog.admin.inc',    'file path' => drupal_get_path('module', 'dblog'),  );  foreach (module_implements('search') as $name) {    $items['search/'. $name .'/%menu_tail'] = array(      'title callback' => 'module_invoke',      'title arguments' => array($name, 'search', 'name', TRUE),      'page callback' => 'search_view',      'page arguments' => array($name),      'access callback' => '_search_menu',      'access arguments' => array($name),      'type' => MENU_LOCAL_TASK,      'parent' => 'search',      'file' => 'search.pages.inc',    );  }  return $items;}function _search_menu($name) {  return user_access('search content') && module_invoke($name, 'search', 'name');}/** * Wipes a part of or the entire search index. * * @param $sid *  (optional) The SID of the item to wipe. If specified, $type must be passed *  too. * @param $type *  (optional) The type of item to wipe. */function search_wipe($sid = NULL, $type = NULL, $reindex = FALSE) {  if ($type == NULL && $sid == NULL) {    module_invoke_all('search', 'reset');  }  else {    db_query("DELETE FROM {search_dataset} WHERE sid = %d AND type = '%s'", $sid, $type);    db_query("DELETE FROM {search_index} WHERE sid = %d AND type = '%s'", $sid, $type);    // Don't remove links if re-indexing.    if (!$reindex) {      db_query("DELETE FROM {search_node_links} WHERE sid = %d AND type = '%s'", $sid, $type);    }  }}/** * Marks a word as dirty (or retrieves the list of dirty words). This is used * during indexing (cron). Words which are dirty have outdated total counts in * the search_total table, and need to be recounted. */function search_dirty($word = NULL) {  static $dirty = array();  if ($word !== NULL) {    $dirty[$word] = TRUE;  }  else {    return $dirty;  }}/** * Implementation of hook_cron(). * * Fires hook_update_index() in all modules and cleans up dirty words (see * search_dirty). */function search_cron() {  // We register a shutdown function to ensure that search_total is always up  // to date.  register_shutdown_function('search_update_totals');  // Update word index  foreach (module_list() as $module) {    module_invoke($module, 'update_index');  }}/** * This function is called on shutdown to ensure that search_total is always * up to date (even if cron times out or otherwise fails). */function search_update_totals() {  // Update word IDF (Inverse Document Frequency) counts for new/changed words  foreach (search_dirty() as $word => $dummy) {    // Get total count    $total = db_result(db_query("SELECT SUM(score) FROM {search_index} WHERE word = '%s'", $word));    // Apply Zipf's law to equalize the probability distribution    $total = log10(1 + 1/(max(1, $total)));    db_query("UPDATE {search_total} SET count = %f WHERE word = '%s'", $total, $word);    if (!db_affected_rows()) {      db_query("INSERT INTO {search_total} (word, count) VALUES ('%s', %f)", $word, $total);    }  }  // Find words that were deleted from search_index, but are still in  // search_total. We use a LEFT JOIN between the two tables and keep only the  // rows which fail to join.  $result = db_query("SELECT t.word AS realword, i.word FROM {search_total} t LEFT JOIN {search_index} i ON t.word = i.word WHERE i.word IS NULL");  while ($word = db_fetch_object($result)) {    db_query("DELETE FROM {search_total} WHERE word = '%s'", $word->realword);  }}/** * Simplifies a string according to indexing rules. */function search_simplify($text) {  // Decode entities to UTF-8  $text = decode_entities($text);  // Lowercase  $text = drupal_strtolower($text);  // Call an external processor for word handling.  search_invoke_preprocess($text);  // Simple CJK handling  if (variable_get('overlap_cjk', TRUE)) {    $text = preg_replace_callback('/['. PREG_CLASS_CJK .']+/u', 'search_expand_cjk', $text);  }  // To improve searching for numerical data such as dates, IP addresses  // or version numbers, we consider a group of numerical characters  // separated only by punctuation characters to be one piece.  // This also means that searching for e.g. '20/03/1984' also returns  // results with '20-03-1984' in them.  // Readable regexp: ([number]+)[punctuation]+(?=[number])  $text = preg_replace('/(['. PREG_CLASS_NUMBERS .']+)['. PREG_CLASS_PUNCTUATION .']+(?=['. PREG_CLASS_NUMBERS .'])/u', '\1', $text);  // The dot, underscore and dash are simply removed. This allows meaningful  // search behavior with acronyms and URLs.  $text = preg_replace('/[._-]+/', '', $text);  // With the exception of the rules above, we consider all punctuation,  // marks, spacers, etc, to be a word boundary.  $text = preg_replace('/['. PREG_CLASS_SEARCH_EXCLUDE .']+/u', ' ', $text);  return $text;}/** * Basic CJK tokenizer. Simply splits a string into consecutive, overlapping * sequences of characters ('minimum_word_size' long). */function search_expand_cjk($matches) {  $min = variable_get('minimum_word_size', 3);  $str = $matches[0];  $l = drupal_strlen($str);  // Passthrough short words  if ($l <= $min) {    return ' '. $str .' ';  }  $tokens = ' ';  // FIFO queue of characters  $chars = array();  // Begin loop  for ($i = 0; $i < $l; ++$i) {    // Grab next character    $current = drupal_substr($str, 0, 1);    $str = substr($str, strlen($current));    $chars[] = $current;    if ($i >= $min - 1) {      $tokens .= implode('', $chars) .' ';      array_shift($chars);    }  }  return $tokens;}/** * Splits a string into tokens for indexing. */function search_index_split($text) {  static $last = NULL;  static $lastsplit = NULL;  if ($last == $text) {    return $lastsplit;  }  // Process words  $text = search_simplify($text);  $words = explode(' ', $text);  array_walk($words, '_search_index_truncate');  // Save last keyword result  $last = $text;  $lastsplit = $words;  return $words;}/** * Helper function for array_walk in search_index_split. */function _search_index_truncate(&$text) {  $text = truncate_utf8($text, 50);}/** * Invokes hook_search_preprocess() in modules. */function search_invoke_preprocess(&$text) {  foreach (module_implements('search_preprocess') as $module) {    $text = module_invoke($module, 'search_preprocess', $text);  }}/** * Update the full-text search index for a particular item. * * @param $sid *   A number identifying this particular item (e.g. node id). * * @param $type *   A string defining this type of item (e.g. 'node') * * @param $text *   The content of this item. Must be a piece of HTML text. * * @ingroup search */function search_index($sid, $type, $text) {  $minimum_word_size = variable_get('minimum_word_size', 3);  // Link matching  global $base_url;  $node_regexp = '@href=[\'"]?(?:'. preg_quote($base_url, '@') .'/|'. preg_quote(base_path(), '@') .')(?:\?q=)?/?((?![a-z]+:)[^\'">]+)[\'">]@i';  // Multipliers for scores of words inside certain HTML tags.  // Note: 'a' must be included for link ranking to work.  $tags = array('h1' => 25,                'h2' => 18,                'h3' => 15,                'h4' => 12,                'h5' => 9,                'h6' => 6,                'u' => 3,                'b' => 3,                'i' => 3,                'strong' => 3,                'em' => 3,                'a' => 10);  // Strip off all ignored tags to speed up processing, but insert space before/after  // them to keep word boundaries.  $text = str_replace(array('<', '>'), array(' <', '> '), $text);  $text = strip_tags($text, '<'. implode('><', array_keys($tags)) .'>');  // Split HTML tags from plain text.  $split = preg_split('/\s*<([^>]+?)>\s*/', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting $null as required).  $tag = FALSE; // Odd/even counter. Tag or no tag.  $link = FALSE; // State variable for link analyser  $score = 1; // Starting score per word  $accum = ' '; // Accumulator for cleaned up data  $tagstack = array(); // Stack with open tags  $tagwords = 0; // Counter for consecutive words  $focus = 1; // Focus state  $results = array(0 => array()); // Accumulator for words for index  foreach ($split as $value) {    if ($tag) {      // Increase or decrease score per word based on tag      list($tagname) = explode(' ', $value, 2);      $tagname = drupal_strtolower($tagname);      // Closing or opening tag?      if ($tagname[0] == '/') {        $tagname = substr($tagname, 1);        // If we encounter unexpected tags, reset score to avoid incorrect boosting.        if (!count($tagstack) || $tagstack[0] != $tagname) {          $tagstack = array();          $score = 1;        }        else {          // Remove from tag stack and decrement score          $score = max(1, $score - $tags[array_shift($tagstack)]);        }        if ($tagname == 'a') {          $link = FALSE;        }      }      else {        if (isset($tagstack[0]) && $tagstack[0] == $tagname) {          // None of the tags we look for make sense when nested identically.          // If they are, it's probably broken HTML.          $tagstack = array();          $score = 1;        }        else {          // Add to open tag stack and increment score          array_unshift($tagstack, $tagname);          $score += $tags[$tagname];        }        if ($tagname == 'a') {          // Check if link points to a node on this site          if (preg_match($node_regexp, $value, $match)) {            $path = drupal_get_normal_path($match[1]);            if (preg_match('!(?:node|book)/(?:view/)?([0-9]+)!i', $path, $match)) {              $linknid = $match[1];              if ($linknid > 0) {                // Note: ignore links to uncachable nodes to avoid redirect bugs.                $node = db_fetch_object(db_query('SELECT n.title, n.nid, n.vid, r.format FROM {node} n INNER JOIN {node_revisions} r ON n.vid = r.vid WHERE n.nid = %d', $linknid));                if (filter_format_allowcache($node->format)) {                  $link = TRUE;                  $linktitle = $node->title;                }              }            }          }        }      }      // A tag change occurred, reset counter.      $tagwords = 0;    }    else {      // Note: use of PREG_SPLIT_DELIM_CAPTURE above will introduce empty values      if ($value != '') {        if ($link) {          // Check to see if the node link text is its URL. If so, we use the target node title instead.          if (preg_match('!^https?://!i', $value)) {            $value = $linktitle;          }        }        $words = search_index_split($value);        foreach ($words as $word) {          // Add word to accumulator          $accum .= $word .' ';          $num = is_numeric($word);          // Check wordlength          if ($num || drupal_strlen($word) >= $minimum_word_size) {            // Normalize numbers            if ($num) {              $word = (int)ltrim($word, '-0');            }            // Links score mainly for the target.            if ($link) {              if (!isset($results[$linknid])) {                $results[$linknid] = array();              }              $results[$linknid][] = $word;              // Reduce score of the link caption in the source.              $focus *= 0.2;            }            // Fall-through            if (!isset($results[0][$word])) {              $results[0][$word] = 0;            }            $results[0][$word] += $score * $focus;            // Focus is a decaying value in terms of the amount of unique words up to this point.            // From 100 words and more, it decays, to e.g. 0.5 at 500 words and 0.3 at 1000 words.            $focus = min(1, .01 + 3.5 / (2 + count($results[0]) * .015));          }          $tagwords++;          // Too many words inside a single tag probably mean a tag was accidentally left open.          if (count($tagstack) && $tagwords >= 15) {            $tagstack = array();            $score = 1;          }        }      }    }    $tag = !$tag;  }  search_wipe($sid, $type, TRUE);  // Insert cleaned up data into dataset  db_query("INSERT INTO {search_dataset} (sid, type, data, reindex) VALUES (%d, '%s', '%s', %d)", $sid, $type, $accum, 0);  // Insert results into search index  foreach ($results[0] as $word => $score) {    // Try inserting first because this will succeed most times, but because    // the database collates similar words (accented and non-accented), the    // insert can fail, in which case we need to add the word scores together.    @db_query("INSERT INTO {search_index} (word, sid, type, score) VALUES ('%s', %d, '%s', %f)", $word, $sid, $type, $score);    if (!db_affected_rows()) {      db_query("UPDATE {search_index} SET score = score + %f WHERE word = '%s' AND sid = %d AND type = '%s'", $score, $word, $sid, $type);    }    search_dirty($word);  }  unset($results[0]);  // Get all previous links from this item.  $result = db_query("SELECT nid, caption FROM {search_node_links} WHERE sid = %d AND type = '%s'", $sid, $type);  $links = array();  while ($link = db_fetch_object($result)) {    $links[$link->nid] = $link->caption;  }  // Now store links to nodes.  foreach ($results as $nid => $words) {    $caption = implode(' ', $words);    if (isset($links[$nid])) {      if ($links[$nid] != $caption) {        // Update the existing link and mark the node for reindexing.        db_query("UPDATE {search_node_links} SET caption = '%s' WHERE sid = %d AND type = '%s' AND nid = %d", $caption, $sid, $type, $nid);        search_touch_node($nid);      }      // Unset the link to mark it as processed.      unset($links[$nid]);    }    else {      // Insert the existing link and mark the node for reindexing.      db_query("INSERT INTO {search_node_links} (caption, sid, type, nid) VALUES ('%s', %d, '%s', %d)", $caption, $sid, $type, $nid);      search_touch_node($nid);    }  }  // Any left-over links in $links no longer exist. Delete them and mark the nodes for reindexing.  foreach ($links as $nid => $caption) {    db_query("DELETE FROM {search_node_links} WHERE sid = %d AND type = '%s' AND nid = %d", $sid, $type, $nid);    search_touch_node($nid);  }}/** * Change a node's changed timestamp to 'now' to force reindexing. * * @param $nid *   The nid of the node that needs reindexing. */function search_touch_node($nid) {  db_query("UPDATE {search_dataset} SET reindex = %d WHERE sid = %d AND type = 'node'", time(), $nid);}/** * Implementation of hook_nodeapi(). */function search_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {  switch ($op) {    // Transplant links to a node into the target node.    case 'update index':      $result = db_query("SELECT caption FROM {search_node_links} WHERE nid = %d", $node->nid);      $output = array();      while ($link = db_fetch_object($result)) {        $output[] = $link->caption;      }      if (count($output)) {        return '<a>('. implode(', ', $output) .')</a>';      }      break;    // Reindex the node when it is updated.  The node is automatically indexed    // when it is added, simply by being added to the node table.    case 'update':      search_touch_node($node->nid);      break;  }}/** * Implementation of hook_comment(). */function search_comment($a1, $op) {  switch ($op) {    // Reindex the node when comments are added or changed    case 'insert':    case 'update':    case 'delete':    case 'publish':    case 'unpublish':      search_touch_node(is_array($a1) ? $a1['nid'] : $a1->nid);      break;  }}/** * Extract a module-specific search option from a search query. e.g. 'type:book' */function search_query_extract($keys, $option) {  if (preg_match('/(^| )'. $option .':([^ ]*)( |$)/i', $keys, $matches)) {    return $matches[2];  }}/** * Return a query with the given module-specific search option inserted in. * e.g. 'type:book'. */function search_query_insert($keys, $option, $value = '') {  if (search_query_extract($keys, $option)) {    $keys = trim(preg_replace('/(^| )'. $option .':[^ ]*/i', '', $keys));  }  if ($value != '') {    $keys .= ' '. $option .':'. $value;  }  return $keys;}/** * Parse a search query into SQL conditions. * * We build two queries that matches the dataset bodies. @See do_search for * more about these. * * @param $text *   The search keys. * @return *   A list of six elements. *    * A series of statements AND'd together which will be used to provide all *      possible matches. *    * Arguments for this query part. *    * A series of exact word matches OR'd together. *    * Arguments for this query part. *    * A bool indicating whether this is a simple query or not. Negative *      terms, presence of both AND / OR make this FALSE. *    * A bool indicating the presence of a lowercase or. Maybe the user *      wanted to use OR. */function search_parse_query($text) {  $keys = array('positive' => array(), 'negative' => array());  // Tokenize query string  preg_match_all('/ (-?)("[^"]+"|[^" ]+)/i', ' '. $text, $matches, PREG_SET_ORDER);  if (count($matches) < 1) {    return NULL;  }  // Classify tokens  $or = FALSE;  $warning = '';  $simple = TRUE;  foreach ($matches as $match) {    $phrase = FALSE;    // Strip off phrase quotes    if ($match[2]{0} == '"') {      $match[2] = substr($match[2], 1, -1);      $phrase = TRUE;      $simple = FALSE;    }    // Simplify keyword according to indexing rules and external preprocessors    $words = search_simplify($match[2]);    // Re-explode in case simplification added more words, except when matching a phrase    $words = $phrase ? array($words) : preg_split('/ /', $words, -1, PREG_SPLIT_NO_EMPTY);    // Negative matches    if ($match[1] == '-') {      $keys['negative'] = array_merge($keys['negative'], $words);    }    // OR operator: instead of a single keyword, we store an array of all    // OR'd keywords.    elseif ($match[2] == 'OR' && count($keys['positive'])) {      $last = array_pop($keys['positive']);      // Starting a new OR?      if (!is_array($last)) {        $last = array($last);      }      $keys['positive'][] = $last;      $or = TRUE;      continue;    }    // AND operator: implied, so just ignore it    elseif ($match[2] == 'AND' || $match[2] == 'and') {      $warning = $match[2];      continue;    }    // Plain keyword    else {      if ($match[2] == 'or') {        $warning = $match[2];      }      if ($or) {        // Add to last element (which is an array)        $keys['positive'][count($keys['positive']) - 1] = array_merge($keys['positive'][count($keys['positive']) - 1], $words);      }      else {        $keys['positive'] = array_merge($keys['positive'], $words);      }    }    $or = FALSE;  }  // Convert keywords into SQL statements.  $query = array();  $query2 = array();  $arguments = array();  $arguments2 = array();  $matches = 0;  $simple_and = FALSE;  $simple_or = FALSE;  // Positive matches  foreach ($keys['positive'] as $key) {    // Group of ORed terms    if (is_array($key) && count($key)) {      $simple_or = TRUE;      $queryor = array();      $any = FALSE;      foreach ($key as $or) {        list($q, $num_new_scores) = _search_parse_query($or, $arguments2);        $any |= $num_new_scores;        if ($q) {          $queryor[] = $q;          $arguments[] = $or;        }      }      if (count($queryor)) {        $query[] = '('. implode(' OR ', $queryor) .')';        // A group of OR keywords only needs to match once        $matches += ($any > 0);      }    }    // Single ANDed term    else {      $simple_and = TRUE;      list($q, $num_new_scores, $num_valid_words) = _search_parse_query($key, $arguments2);      if ($q) {        $query[] = $q;        $arguments[] = $key;        if (!$num_valid_words) {          $simple = FALSE;        }        // Each AND keyword needs to match at least once        $matches += $num_new_scores;      }    }  }  if ($simple_and && $simple_or) {    $simple = FALSE;  }  // Negative matches  foreach ($keys['negative'] as $key) {    list($q) = _search_parse_query($key, $arguments2, TRUE);    if ($q) {      $query[] = $q;      $arguments[] = $key;      $simple = FALSE;    }  }  $query = implode(' AND ', $query);  // Build word-index conditions for the first pass  $query2 = substr(str_repeat("i.word = '%s' OR ", count($arguments2)), 0, -4);  return array($query, $arguments, $query2, $arguments2, $matches, $simple, $warning);}/** * Helper function for search_parse_query(); */function _search_parse_query(&$word, &$scores, $not = FALSE) {  $num_new_scores = 0;  $num_valid_words = 0;  // Determine the scorewords of this word/phrase  if (!$not) {    $split = explode(' ', $word);    foreach ($split as $s) {      $num = is_numeric($s);      if ($num || drupal_strlen($s) >= variable_get('minimum_word_size', 3)) {        $s = $num ? ((int)ltrim($s, '-0')) : $s;        if (!isset($scores[$s])) {          $scores[$s] = $s;          $num_new_scores++;        }        $num_valid_words++;      }    }  }  // Return matching snippet and number of added words  return array("d.data ". ($not ? 'NOT ' : '') ."LIKE '%% %s %%'", $num_new_scores, $num_valid_words);}/** * Do a query on the full-text search index for a word or words. * * This function is normally only called by each module that support the * indexed search (and thus, implements hook_update_index()). * * Results are retrieved in two logical passes. However, the two passes are * joined together into a single query.  And in the case of most simple * queries the second pass is not even used. * * The first pass selects a set of all possible matches, which has the benefit * of also providing the exact result set for simple "AND" or "OR" searches. * * The second portion of the query further refines this set by verifying * advanced text conditions (such negative or phrase matches) * * @param $keywords *   A search string as entered by the user. * * @param $type *   A string identifying the calling module. * * @param $join1 *   (optional) Inserted into the JOIN part of the first SQL query. *   For example "INNER JOIN {node} n ON n.nid = i.sid". * * @param $where1 *   (optional) Inserted into the WHERE part of the first SQL query. *   For example "(n.status > %d)". * * @param $arguments1 *   (optional) Extra SQL arguments belonging to the first query. * * @param $columns2 *   (optional) Inserted into the SELECT pat of the second query. Must contain *   a column selected as 'score'. *   defaults to 'i.relevance AS score' * * @param $join2 *   (optional) Inserted into the JOIN par of the second SQL query. *   For example "INNER JOIN {node_comment_statistics} n ON n.nid = i.sid" * * @param $arguments2 *   (optional) Extra SQL arguments belonging to the second query parameter. * * @param $sort_parameters *   (optional) SQL arguments for sorting the final results. *              Default: 'ORDER BY score DESC' * * @return *   An array of SIDs for the search results. * * @ingroup search */function do_search($keywords, $type, $join1 = '', $where1 = '1 = 1', $arguments1 = array(), $columns2 = 'i.relevance AS score', $join2 = '', $arguments2 = array(), $sort_parameters = 'ORDER BY score DESC') {  $query = search_parse_query($keywords);  if ($query[2] == '') {    form_set_error('keys', t('You must include at least one positive keyword with @count characters or more.', array('@count' => variable_get('minimum_word_size', 3))));  }  if ($query[6]) {    if ($query[6] == 'or') {      drupal_set_message(t('Search for either of the two terms with uppercase <strong>OR</strong>. For example, <strong>cats OR dogs</strong>.'));    }  }  if ($query === NULL || $query[0] == '' || $query[2] == '') {    return array();  }  // Build query for keyword normalization.  $conditions = "$where1 AND ($query[2]) AND i.type = '%s'";  $arguments1 = array_merge($arguments1, $query[3], array($type));  $join = "INNER JOIN {search_total} t ON i.word = t.word $join1";  if (!$query[5]) {    $conditions .= " AND ($query[0])";    $arguments1 = array_merge($arguments1, $query[1]);    $join .= " INNER JOIN {search_dataset} d ON i.sid = d.sid AND i.type = d.type";  }  // Calculate maximum keyword relevance, to normalize it.  $select = "SELECT SUM(i.score * t.count) AS score FROM {search_index} i $join WHERE $conditions GROUP BY i.type, i.sid HAVING COUNT(*) >= %d ORDER BY score DESC";  $arguments = array_merge($arguments1, array($query[4]));  $normalize = db_result(db_query_range($select, $arguments, 0, 1));  if (!$normalize) {    return array();  }  $columns2 = str_replace('i.relevance', '('. (1.0 / $normalize) .' * SUM(i.score * t.count))', $columns2);  // Build query to retrieve results.  $select = "SELECT i.type, i.sid, $columns2 FROM {search_index} i $join $join2 WHERE $conditions GROUP BY i.type, i.sid HAVING COUNT(*) >= %d";  $count_select =  "SELECT COUNT(*) FROM ($select) n1";  $arguments = array_merge($arguments2, $arguments1, array($query[4]));  // Do actual search query  $result = pager_query("$select $sort_parameters", 10, 0, $count_select, $arguments);  $results = array();  while ($item = db_fetch_object($result)) {    $results[] = $item;  }  return $results;}/** * Helper function for grabbing search keys. */function search_get_keys() {  static $return;  if (!isset($return)) {    // Extract keys as remainder of path    // Note: support old GET format of searches for existing links.    $path = explode('/', $_GET['q'], 3);    $keys = empty($_REQUEST['keys']) ? '' : $_REQUEST['keys'];    $return = count($path) == 3 ? $path[2] : $keys;  }  return $return;}/** * @defgroup search Search interface * @{ * The Drupal search interface manages a global search mechanism. * * Modules may plug into this system to provide searches of different types of * data. Most of the system is handled by search.module, so this must be enabled * for all of the search features to work. * * There are three ways to interact with the search system: * - Specifically for searching nodes, you can implement nodeapi('update index') *   and nodeapi('search result'). However, note that the search system already *   indexes all visible output of a node, i.e. everything displayed normally *   by hook_view() and hook_nodeapi('view'). This is usually sufficient. *   You should only use this mechanism if you want additional, non-visible data *   to be indexed. * - Implement hook_search(). This will create a search tab for your module on *   the /search page with a simple keyword search form. You may optionally *   implement hook_search_item() to customize the display of your results. * - Implement hook_update_index(). This allows your module to use Drupal's *   HTML indexing mechanism for searching full text efficiently. * * If your module needs to provide a more complicated search form, then you need * to implement it yourself without hook_search(). In that case, you should * define it as a local task (tab) under the /search page (e.g. /search/mymodule) * so that users can easily find it. *//** * Render a search form. * * @param $action *   Form action. Defaults to "search". * @param $keys *   The search string entered by the user, containing keywords for the search. * @param $type *   The type of search to render the node for. Must be the name of module *   which implements hook_search(). Defaults to 'node'. * @param $prompt *   A piece of text to put before the form (e.g. "Enter your keywords") * @return *   An HTML string containing the search form. */function search_form(&$form_state, $action = '', $keys = '', $type = NULL, $prompt = NULL) {  // Add CSS  drupal_add_css(drupal_get_path('module', 'search') .'/search.css', 'module', 'all', FALSE);  if (!$action) {    $action = url('search/'. $type);  }  if (is_null($prompt)) {    $prompt = t('Enter your keywords');  }  $form = array(    '#action' => $action,    '#attributes' => array('class' => 'search-form'),  );  $form['module'] = array('#type' => 'value', '#value' => $type);  $form['basic'] = array('#type' => 'item', '#title' => $prompt);  $form['basic']['inline'] = array('#prefix' => '<div class="container-inline">', '#suffix' => '</div>');  $form['basic']['inline']['keys'] = array(    '#type' => 'textfield',    '#title' => '',    '#default_value' => $keys,    '#size' => $prompt ? 40 : 20,    '#maxlength' => 255,  );  // processed_keys is used to coordinate keyword passing between other forms  // that hook into the basic search form.  $form['basic']['inline']['processed_keys'] = array('#type' => 'value', '#value' => array());  $form['basic']['inline']['submit'] = array('#type' => 'submit', '#value' => t('Search'));  return $form;}/** * Form builder; Output a search form for the search block and the theme's search box. * * @ingroup forms * @see search_box_form_submit() * @see theme_search_box_form() */function search_box(&$form_state, $form_id) {  $form[$form_id] = array(    '#title' => t('Search this site'),    '#type' => 'textfield',    '#size' => 15,    '#default_value' => '',    '#attributes' => array('title' => t('Enter the terms you wish to search for.')),  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Search'));  $form['#submit'][] = 'search_box_form_submit';  return $form;}/** * Process a block search form submission. */function search_box_form_submit($form, &$form_state) {  // The search form relies on control of the redirect destination for its  // functionality, so we override any static destination set in the request,  // for example by drupal_access_denied() or drupal_not_found()  // (see http://drupal.org/node/292565).  if (isset($_REQUEST['destination'])) {    unset($_REQUEST['destination']);  }  if (isset($_REQUEST['edit']['destination'])) {    unset($_REQUEST['edit']['destination']);  }  $form_id = $form['form_id']['#value'];  $form_state['redirect'] = 'search/node/'. trim($form_state['values'][$form_id]);}/** * Process variables for search-theme-form.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see search-theme-form.tpl.php */function template_preprocess_search_theme_form(&$variables) {  $variables['search'] = array();  $hidden = array();  // Provide variables named after form keys so themers can print each element independently.  foreach (element_children($variables['form']) as $key) {    $type = $variables['form'][$key]['#type'];    if ($type == 'hidden' || $type == 'token') {      $hidden[] = drupal_render($variables['form'][$key]);    }    else {      $variables['search'][$key] = drupal_render($variables['form'][$key]);    }  }  // Hidden form elements have no value to themers. No need for separation.  $variables['search']['hidden'] = implode($hidden);  // Collect all form elements to make it easier to print the whole form.  $variables['search_form'] = implode($variables['search']);}/** * Process variables for search-block-form.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see search-block-form.tpl.php */function template_preprocess_search_block_form(&$variables) {  $variables['search'] = array();  $hidden = array();  // Provide variables named after form keys so themers can print each element independently.  foreach (element_children($variables['form']) as $key) {    $type = $variables['form'][$key]['#type'];    if ($type == 'hidden' || $type == 'token') {      $hidden[] = drupal_render($variables['form'][$key]);    }    else {      $variables['search'][$key] = drupal_render($variables['form'][$key]);    }  }  // Hidden form elements have no value to themers. No need for separation.  $variables['search']['hidden'] = implode($hidden);  // Collect all form elements to make it easier to print the whole form.  $variables['search_form'] = implode($variables['search']);}/** * Perform a standard search on the given keys, and return the formatted results. */function search_data($keys = NULL, $type = 'node') {  if (isset($keys)) {    if (module_hook($type, 'search')) {      $results = module_invoke($type, 'search', 'search', $keys);      if (isset($results) && is_array($results) && count($results)) {        if (module_hook($type, 'search_page')) {          return module_invoke($type, 'search_page', $results);        }        else {          return theme('search_results', $results, $type);        }      }    }  }}/** * Returns snippets from a piece of text, with certain keywords highlighted. * Used for formatting search results. * * @param $keys *   A string containing a search query. * * @param $text *   The text to extract fragments from. * * @return *   A string containing HTML for the excerpt. */function search_excerpt($keys, $text) {  // We highlight around non-indexable or CJK characters.  $boundary = '(?:(?<=['. PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK .'])|(?=['. PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK .']))';  // Extract positive keywords and phrases  preg_match_all('/ ("([^"]+)"|(?!OR)([^" ]+))/', ' '. $keys, $matches);  $keys = array_merge($matches[2], $matches[3]);  // Prepare text  $text = ' '. strip_tags(str_replace(array('<', '>'), array(' <', '> '), $text)) .' ';  array_walk($keys, '_search_excerpt_replace');  $workkeys = $keys;  // Extract a fragment per keyword for at most 4 keywords.  // First we collect ranges of text around each keyword, starting/ending  // at spaces.  // If the sum of all fragments is too short, we look for second occurrences.  $ranges = array();  $included = array();  $length = 0;  while ($length < 256 && count($workkeys)) {    foreach ($workkeys as $k => $key) {      if (strlen($key) == 0) {        unset($workkeys[$k]);        unset($keys[$k]);        continue;      }      if ($length >= 256) {        break;      }      // Remember occurrence of key so we can skip over it if more occurrences      // are desired.      if (!isset($included[$key])) {        $included[$key] = 0;      }      // Locate a keyword (position $p), then locate a space in front (position      // $q) and behind it (position $s)      if (preg_match('/'. $boundary . $key . $boundary .'/iu', $text, $match, PREG_OFFSET_CAPTURE, $included[$key])) {        $p = $match[0][1];        if (($q = strpos($text, ' ', max(0, $p - 60))) !== FALSE) {          $end = substr($text, $p, 80);          if (($s = strrpos($end, ' ')) !== FALSE) {            $ranges[$q] = $p + $s;            $length += $p + $s - $q;            $included[$key] = $p + 1;          }          else {            unset($workkeys[$k]);          }        }        else {          unset($workkeys[$k]);        }      }      else {        unset($workkeys[$k]);      }    }  }  // If we didn't find anything, return the beginning.  if (count($ranges) == 0) {    return truncate_utf8($text, 256) .' ...';  }  // Sort the text ranges by starting position.  ksort($ranges);  // Now we collapse overlapping text ranges into one. The sorting makes it O(n).  $newranges = array();  foreach ($ranges as $from2 => $to2) {    if (!isset($from1)) {      $from1 = $from2;      $to1 = $to2;      continue;    }    if ($from2 <= $to1) {      $to1 = max($to1, $to2);    }    else {      $newranges[$from1] = $to1;      $from1 = $from2;      $to1 = $to2;    }  }  $newranges[$from1] = $to1;  // Fetch text  $out = array();  foreach ($newranges as $from => $to) {    $out[] = substr($text, $from, $to - $from);  }  $text = (isset($newranges[0]) ? '' : '... ') . implode(' ... ', $out) .' ...';  // Highlight keywords. Must be done at once to prevent conflicts ('strong' and '<strong>').  $text = preg_replace('/'. $boundary .'('. implode('|', $keys) .')'. $boundary .'/iu', '<strong>\0</strong>', $text);  return $text;}/** * @} End of "defgroup search". *//** * Helper function for array_walk in search_except. */function _search_excerpt_replace(&$text) {  $text = preg_quote($text, '/');}function search_forms() {  $forms['search_theme_form']= array(    'callback' => 'search_box',    'callback arguments' => array('search_theme_form'),  );  $forms['search_block_form']= array(    'callback' => 'search_box',    'callback arguments' => array('search_block_form'),  );  return $forms;}
<?php// $Id$/** * @file * API for handling file uploads and server file management. *//** * @defgroup file File interface * @{ * Common file handling functions. */define('FILE_DOWNLOADS_PUBLIC', 1);define('FILE_DOWNLOADS_PRIVATE', 2);define('FILE_CREATE_DIRECTORY', 1);define('FILE_MODIFY_PERMISSIONS', 2);define('FILE_EXISTS_RENAME', 0);define('FILE_EXISTS_REPLACE', 1);define('FILE_EXISTS_ERROR', 2);/** * A files status can be one of two values: temporary or permanent. The status * for each file Drupal manages is stored in the {files} tables. If the status * is temporary Drupal's file garbage collection will delete the file and * remove it from the files table after a set period of time. * * If you wish to add custom statuses for use by contrib modules please expand as * binary flags and consider the first 8 bits reserved. (0,1,2,4,8,16,32,64,128) */define('FILE_STATUS_TEMPORARY', 0);define('FILE_STATUS_PERMANENT', 1);/** * Create the download path to a file. * * @param $path A string containing the path of the file to generate URL for. * @return A string containing a URL that can be used to download the file. */function file_create_url($path) {  // Strip file_directory_path from $path. We only include relative paths in urls.  if (strpos($path, file_directory_path() .'/') === 0) {    $path = trim(substr($path, strlen(file_directory_path())), '\\/');  }  switch (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC)) {    case FILE_DOWNLOADS_PUBLIC:      return $GLOBALS['base_url'] .'/'. file_directory_path() .'/'. str_replace('\\', '/', $path);    case FILE_DOWNLOADS_PRIVATE:      return url('system/files/'. $path, array('absolute' => TRUE));  }}/** * Make sure the destination is a complete path and resides in the file system * directory, if it is not prepend the file system directory. * * @param $dest A string containing the path to verify. If this value is *   omitted, Drupal's 'files' directory will be used. * @return A string containing the path to file, with file system directory *   appended if necessary, or FALSE if the path is invalid (i.e. outside the *   configured 'files' or temp directories). */function file_create_path($dest = 0) {  $file_path = file_directory_path();  if (!$dest) {    return $file_path;  }  // file_check_location() checks whether the destination is inside the Drupal files directory.  if (file_check_location($dest, $file_path)) {    return $dest;  }  // check if the destination is instead inside the Drupal temporary files directory.  else if (file_check_location($dest, file_directory_temp())) {    return $dest;  }  // Not found, try again with prefixed directory path.  else if (file_check_location($file_path .'/'. $dest, $file_path)) {    return $file_path .'/'. $dest;  }  // File not found.  return FALSE;}/** * Check that the directory exists and is writable. Directories need to * have execute permissions to be considered a directory by FTP servers, etc. * * @param $directory A string containing the name of a directory path. * @param $mode A Boolean value to indicate if the directory should be created *   if it does not exist or made writable if it is read-only. * @param $form_item An optional string containing the name of a form item that *   any errors will be attached to. This is useful for settings forms that *   require the user to specify a writable directory. If it can't be made to *   work, a form error will be set preventing them from saving the settings. * @return FALSE when directory not found, or TRUE when directory exists. */function file_check_directory(&$directory, $mode = 0, $form_item = NULL) {  $directory = rtrim($directory, '/\\');  // Check if directory exists.  if (!is_dir($directory)) {    if (($mode & FILE_CREATE_DIRECTORY) && @mkdir($directory)) {      drupal_set_message(t('The directory %directory has been created.', array('%directory' => $directory)));      @chmod($directory, 0775); // Necessary for non-webserver users.    }    else {      if ($form_item) {        form_set_error($form_item, t('The directory %directory does not exist.', array('%directory' => $directory)));      }      return FALSE;    }  }  // Check to see if the directory is writable.  if (!is_writable($directory)) {    if (($mode & FILE_MODIFY_PERMISSIONS) && @chmod($directory, 0775)) {      drupal_set_message(t('The permissions of directory %directory have been changed to make it writable.', array('%directory' => $directory)));    }    else {      form_set_error($form_item, t('The directory %directory is not writable', array('%directory' => $directory)));      watchdog('file system', 'The directory %directory is not writable, because it does not have the correct permissions set.', array('%directory' => $directory), WATCHDOG_ERROR);      return FALSE;    }  }  if ((file_directory_path() == $directory || file_directory_temp() == $directory) && !is_file("$directory/.htaccess")) {    $htaccess_lines = "SetHandler Drupal_Security_Do_Not_Remove_See_SA_2006_006\nOptions None\nOptions +FollowSymLinks";    if (($fp = fopen("$directory/.htaccess", 'w')) && fputs($fp, $htaccess_lines)) {      fclose($fp);      chmod($directory .'/.htaccess', 0664);    }    else {      $variables = array('%directory' => $directory, '!htaccess' => '<br />'. nl2br(check_plain($htaccess_lines)));      form_set_error($form_item, t("Security warning: Couldn't write .htaccess file. Please create a .htaccess file in your %directory directory which contains the following lines: <code>!htaccess</code>", $variables));      watchdog('security', "Security warning: Couldn't write .htaccess file. Please create a .htaccess file in your %directory directory which contains the following lines: <code>!htaccess</code>", $variables, WATCHDOG_ERROR);    }  }  return TRUE;}/** * Checks path to see if it is a directory, or a dir/file. * * @param $path A string containing a file path. This will be set to the *   directory's path. * @return If the directory is not in a Drupal writable directory, FALSE is *   returned. Otherwise, the base name of the path is returned. */function file_check_path(&$path) {  // Check if path is a directory.  if (file_check_directory($path)) {    return '';  }  // Check if path is a possible dir/file.  $filename = basename($path);  $path = dirname($path);  if (file_check_directory($path)) {    return $filename;  }  return FALSE;}/** * Check if a file is really located inside $directory. Should be used to make * sure a file specified is really located within the directory to prevent * exploits. * * @code *   // Returns FALSE: *   file_check_location('/www/example.com/files/../../../etc/passwd', '/www/example.com/files'); * @endcode * * @param $source A string set to the file to check. * @param $directory A string where the file should be located. * @return 0 for invalid path or the real path of the source. */function file_check_location($source, $directory = '') {  $check = realpath($source);  if ($check) {    $source = $check;  }  else {    // This file does not yet exist    $source = realpath(dirname($source)) .'/'. basename($source);  }  $directory = realpath($directory);  if ($directory && strpos($source, $directory) !== 0) {    return 0;  }  return $source;}/** * Copies a file to a new location. This is a powerful function that in many ways * performs like an advanced version of copy(). * - Checks if $source and $dest are valid and readable/writable. * - Performs a file copy if $source is not equal to $dest. * - If file already exists in $dest either the call will error out, replace the *   file or rename the file based on the $replace parameter. * * @param $source A string specifying the file location of the original file. *   This parameter will contain the resulting destination filename in case of *   success. * @param $dest A string containing the directory $source should be copied to. *   If this value is omitted, Drupal's 'files' directory will be used. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return True for success, FALSE for failure. */function file_copy(&$source, $dest = 0, $replace = FILE_EXISTS_RENAME) {  $dest = file_create_path($dest);  $directory = $dest;  $basename = file_check_path($directory);  // Make sure we at least have a valid directory.  if ($basename === FALSE) {    $source = is_object($source) ? $source->filepath : $source;    drupal_set_message(t('The selected file %file could not be uploaded, because the destination %directory is not properly configured.', array('%file' => $source, '%directory' => $dest)), 'error');    watchdog('file system', 'The selected file %file could not be uploaded, because the destination %directory could not be found, or because its permissions do not allow the file to be written.', array('%file' => $source, '%directory' => $dest), WATCHDOG_ERROR);    return 0;  }  // Process a file upload object.  if (is_object($source)) {    $file = $source;    $source = $file->filepath;    if (!$basename) {      $basename = $file->filename;    }  }  $source = realpath($source);  if (!file_exists($source)) {    drupal_set_message(t('The selected file %file could not be copied, because no file by that name exists. Please check that you supplied the correct filename.', array('%file' => $source)), 'error');    return 0;  }  // If the destination file is not specified then use the filename of the source file.  $basename = $basename ? $basename : basename($source);  $dest = $directory .'/'. $basename;  // Make sure source and destination filenames are not the same, makes no sense  // to copy it if they are. In fact copying the file will most likely result in  // a 0 byte file. Which is bad. Real bad.  if ($source != realpath($dest)) {    if (!$dest = file_destination($dest, $replace)) {      drupal_set_message(t('The selected file %file could not be copied, because a file by that name already exists in the destination.', array('%file' => $source)), 'error');      return FALSE;    }    if (!@copy($source, $dest)) {      drupal_set_message(t('The selected file %file could not be copied.', array('%file' => $source)), 'error');      return 0;    }    // Give everyone read access so that FTP'd users or    // non-webserver users can see/read these files,    // and give group write permissions so group members    // can alter files uploaded by the webserver.    @chmod($dest, 0664);  }  if (isset($file) && is_object($file)) {    $file->filename = $basename;    $file->filepath = $dest;    $source = $file;  }  else {    $source = $dest;  }  return 1; // Everything went ok.}/** * Determines the destination path for a file depending on how replacement of * existing files should be handled. * * @param $destination A string specifying the desired path. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is *     unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return The destination file path or FALSE if the file already exists and *   FILE_EXISTS_ERROR was specified. */function file_destination($destination, $replace) {  if (file_exists($destination)) {    switch ($replace) {      case FILE_EXISTS_RENAME:        $basename = basename($destination);        $directory = dirname($destination);        $destination = file_create_filename($basename, $directory);        break;      case FILE_EXISTS_ERROR:        drupal_set_message(t('The selected file %file could not be copied, because a file by that name already exists in the destination.', array('%file' => $destination)), 'error');        return FALSE;    }  }  return $destination;}/** * Moves a file to a new location. * - Checks if $source and $dest are valid and readable/writable. * - Performs a file move if $source is not equal to $dest. * - If file already exists in $dest either the call will error out, replace the *   file or rename the file based on the $replace parameter. * * @param $source A string specifying the file location of the original file. *   This parameter will contain the resulting destination filename in case of *   success. * @param $dest A string containing the directory $source should be copied to. *   If this value is omitted, Drupal's 'files' directory will be used. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return True for success, FALSE for failure. */function file_move(&$source, $dest = 0, $replace = FILE_EXISTS_RENAME) {  $path_original = is_object($source) ? $source->filepath : $source;  if (file_copy($source, $dest, $replace)) {    $path_current = is_object($source) ? $source->filepath : $source;    if ($path_original == $path_current || file_delete($path_original)) {      return 1;    }    drupal_set_message(t('The removal of the original file %file has failed.', array('%file' => $path_original)), 'error');  }  return 0;}/** * Modify a filename as needed for security purposes. * * Dangerous file names will be altered; for instance, the file name * "exploit.php.pps" will become "exploit.php_.pps". All extensions that are * between 2 and 5 characters in length, internal to the file name, and not * included in $extensions will be altered by adding an underscore. If variable * 'allow_insecure_uploads' evaluates to TRUE, no alterations will be made. * * @param $filename *   File name to modify. * @param $extensions *   A space-separated list of extensions that should not be altered. * @param $alerts *   If TRUE, drupal_set_message() will be called to display a message if the *   file name was changed. * * @return *   The potentially modified $filename. */function file_munge_filename($filename, $extensions, $alerts = TRUE) {  $original = $filename;  // Allow potentially insecure uploads for very savvy users and admin  if (!variable_get('allow_insecure_uploads', 0)) {    $whitelist = array_unique(explode(' ', trim($extensions)));    // Split the filename up by periods. The first part becomes the basename    // the last part the final extension.    $filename_parts = explode('.', $filename);    $new_filename = array_shift($filename_parts); // Remove file basename.    $final_extension = array_pop($filename_parts); // Remove final extension.    // Loop through the middle parts of the name and add an underscore to the    // end of each section that could be a file extension but isn't in the list    // of allowed extensions.    foreach ($filename_parts as $filename_part) {      $new_filename .= '.'. $filename_part;      if (!in_array($filename_part, $whitelist) && preg_match("/^[a-zA-Z]{2,5}\d?$/", $filename_part)) {        $new_filename .= '_';      }    }    $filename = $new_filename .'.'. $final_extension;    if ($alerts && $original != $filename) {      drupal_set_message(t('For security reasons, your upload has been renamed to %filename.', array('%filename' => $filename)));    }  }  return $filename;}/** * Undo the effect of upload_munge_filename(). * * @param $filename string filename * @return string */function file_unmunge_filename($filename) {  return str_replace('_.', '.', $filename);}/** * Create a full file path from a directory and filename. If a file with the * specified name already exists, an alternative will be used. * * @param $basename string filename * @param $directory string directory * @return */function file_create_filename($basename, $directory) {  $dest = $directory .'/'. $basename;  if (file_exists($dest)) {    // Destination file already exists, generate an alternative.    if ($pos = strrpos($basename, '.')) {      $name = substr($basename, 0, $pos);      $ext = substr($basename, $pos);    }    else {      $name = $basename;    }    $counter = 0;    do {      $dest = $directory .'/'. $name .'_'. $counter++ . $ext;    } while (file_exists($dest));  }  return $dest;}/** * Delete a file. * * @param $path A string containing a file path. * @return TRUE for success, FALSE for failure. */function file_delete($path) {  if (is_file($path)) {    return unlink($path);  }}/** * Determine total disk space used by a single user or the whole filesystem. * * @param $uid *   An optional user id. A NULL value returns the total space used *   by all files. */function file_space_used($uid = NULL) {  if (isset($uid)) {    return (int) db_result(db_query('SELECT SUM(filesize) FROM {files} WHERE uid = %d', $uid));  }  return (int) db_result(db_query('SELECT SUM(filesize) FROM {files}'));}/** * Saves a file upload to a new location. The source file is validated as a * proper upload and handled as such. * * The file will be added to the files table as a temporary file. Temporary files * are periodically cleaned. To make the file permanent file call * file_set_status() to change its status. * * @param $source *   A string specifying the name of the upload field to save. * @param $validators *   An optional, associative array of callback functions used to validate the *   file. The keys are function names and the values arrays of callback *   parameters which will be passed in after the file object. The *   functions should return an array of error messages; an empty array *   indicates that the file passed validation. The functions will be called in *   the order specified. * @param $dest *   A string containing the directory $source should be copied to. If this is *   not provided or is not writable, the temporary directory will be used. * @param $replace *   A boolean indicating whether an existing file of the same name in the *   destination directory should overwritten. A false value will generate a *   new, unique filename in the destination directory. * @return *   An object containing the file information, or 0 in the event of an error. */function file_save_upload($source, $validators = array(), $dest = FALSE, $replace = FILE_EXISTS_RENAME) {  global $user;  static $upload_cache;  // Add in our check of the the file name length.  $validators['file_validate_name_length'] = array();  // Return cached objects without processing since the file will have  // already been processed and the paths in _FILES will be invalid.  if (isset($upload_cache[$source])) {    return $upload_cache[$source];  }  // If a file was uploaded, process it.  if (isset($_FILES['files']) && $_FILES['files']['name'][$source] && is_uploaded_file($_FILES['files']['tmp_name'][$source])) {    // Check for file upload errors and return FALSE if a    // lower level system error occurred.    switch ($_FILES['files']['error'][$source]) {      // @see http://php.net/manual/en/features.file-upload.errors.php      case UPLOAD_ERR_OK:        break;      case UPLOAD_ERR_INI_SIZE:      case UPLOAD_ERR_FORM_SIZE:        drupal_set_message(t('The file %file could not be saved, because it exceeds %maxsize, the maximum allowed size for uploads.', array('%file' => $source, '%maxsize' => format_size(file_upload_max_size()))), 'error');        return 0;      case UPLOAD_ERR_PARTIAL:      case UPLOAD_ERR_NO_FILE:        drupal_set_message(t('The file %file could not be saved, because the upload did not complete.', array('%file' => $source)), 'error');        return 0;        // Unknown error      default:        drupal_set_message(t('The file %file could not be saved. An unknown error has occurred.', array('%file' => $source)), 'error');        return 0;    }    // Build the list of non-munged extensions.    // @todo: this should not be here. we need to figure out the right place.    $extensions = '';    foreach ($user->roles as $rid => $name) {      $extensions .= ' '. variable_get("upload_extensions_$rid",      variable_get('upload_extensions_default', 'jpg jpeg gif png txt html doc xls pdf ppt pps odt ods odp'));    }    // Begin building file object.    $file = new stdClass();    $file->filename = file_munge_filename(trim(basename($_FILES['files']['name'][$source]), '.'), $extensions);    $file->filepath = $_FILES['files']['tmp_name'][$source];    $file->filemime = file_get_mimetype($file->filename);    // If the destination is not provided, or is not writable, then use the    // temporary directory.    if (empty($dest) || file_check_path($dest) === FALSE) {      $dest = file_directory_temp();    }    $file->source = $source;    $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), $replace);    $file->filesize = $_FILES['files']['size'][$source];    // Call the validation functions.    $errors = array();    foreach ($validators as $function => $args) {      array_unshift($args, $file);      // Make sure $file is passed around by reference.      $args[0] = &$file;      $errors = array_merge($errors, call_user_func_array($function, $args));    }    // Rename potentially executable files, to help prevent exploits.    if (preg_match('/\.(php|pl|py|cgi|asp|js)$/i', $file->filename) && (substr($file->filename, -4) != '.txt')) {            $file->filemime = 'text/plain';      $file->filepath .= '.txt';      $file->filename .= '.txt';      // As the file may be named example.php.txt, we need to munge again to      // convert to example.php_.txt, then create the correct destination.      $file->filename = file_munge_filename($file->filename, $extensions);      $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), $replace);    }    // Check for validation errors.    if (!empty($errors)) {      $message = t('The selected file %name could not be uploaded.', array('%name' => $file->filename));      if (count($errors) > 1) {        $message .= '<ul><li>'. implode('</li><li>', $errors) .'</li></ul>';      }      else {        $message .= ' '. array_pop($errors);      }      form_set_error($source, $message);      return 0;    }    // Move uploaded files from PHP's upload_tmp_dir to Drupal's temporary directory.    // This overcomes open_basedir restrictions for future file operations.    $file->filepath = $file->destination;    if (!move_uploaded_file($_FILES['files']['tmp_name'][$source], $file->filepath)) {      form_set_error($source, t('File upload error. Could not move uploaded file.'));      watchdog('file', 'Upload error. Could not move uploaded file %file to destination %destination.', array('%file' => $file->filename, '%destination' => $file->filepath));      return 0;    }    // If we made it this far it's safe to record this file in the database.    $file->uid = $user->uid;    $file->status = FILE_STATUS_TEMPORARY;    $file->timestamp = time();    drupal_write_record('files', $file);    // Add file to the cache.    $upload_cache[$source] = $file;    return $file;  }  return 0;}/** * Check for files with names longer than we can store in the database. * * @param $file *   A Drupal file object. * @return *   An array. If the file name is too long, it will contain an error message. */function file_validate_name_length($file) {  $errors = array();  if (strlen($file->filename) > 255) {    $errors[] = t('Its name exceeds the 255 characters limit. Please rename the file and try again.');  }  return $errors;}/** * Check that the filename ends with an allowed extension. This check is not * enforced for the user #1. * * @param $file *   A Drupal file object. * @param $extensions *   A string with a space separated * @return *   An array. If the file extension is not allowed, it will contain an error message. */function file_validate_extensions($file, $extensions) {  global $user;  $errors = array();  // Bypass validation for uid  = 1.  if ($user->uid != 1) {    $regex = '/\.('. ereg_replace(' +', '|', preg_quote($extensions)) .')$/i';    if (!preg_match($regex, $file->filename)) {      $errors[] = t('Only files with the following extensions are allowed: %files-allowed.', array('%files-allowed' => $extensions));    }  }  return $errors;}/** * Check that the file's size is below certain limits. This check is not * enforced for the user #1. * * @param $file *   A Drupal file object. * @param $file_limit *   An integer specifying the maximum file size in bytes. Zero indicates that *   no limit should be enforced. * @param $user_limit *   An integer specifying the maximum number of bytes the user is allowed. Zero *   indicates that no limit should be enforced. * @return *   An array. If the file size exceeds limits, it will contain an error message. */function file_validate_size($file, $file_limit = 0, $user_limit = 0) {  global $user;  $errors = array();  // Bypass validation for uid  = 1.  if ($user->uid != 1) {    if ($file_limit && $file->filesize > $file_limit) {      $errors[] = t('The file is %filesize exceeding the maximum file size of %maxsize.', array('%filesize' => format_size($file->filesize), '%maxsize' => format_size($file_limit)));    }    // Save a query by only calling file_space_used() when a limit is provided.    if ($user_limit && (file_space_used($user->uid) + $file->filesize) > $user_limit) {      $errors[] = t('The file is %filesize which would exceed your disk quota of %quota.', array('%filesize' => format_size($file->filesize), '%quota' => format_size($user_limit)));    }  }  return $errors;}/** * Check that the file is recognized by image_get_info() as an image. * * @param $file *   A Drupal file object. * @return *   An array. If the file is not an image, it will contain an error message. */function file_validate_is_image(&$file) {  $errors = array();  $info = image_get_info($file->filepath);  if (!$info || empty($info['extension'])) {    $errors[] = t('Only JPEG, PNG and GIF images are allowed.');  }  return $errors;}/** * If the file is an image verify that its dimensions are within the specified * maximum and minimum dimensions. Non-image files will be ignored. * * @param $file *   A Drupal file object. This function may resize the file affecting its size. * @param $maximum_dimensions *   An optional string in the form WIDTHxHEIGHT e.g. '640x480' or '85x85'. If *   an image toolkit is installed the image will be resized down to these *   dimensions. A value of 0 indicates no restriction on size, so resizing *   will be attempted. * @param $minimum_dimensions *   An optional string in the form WIDTHxHEIGHT. This will check that the image *   meets a minimum size. A value of 0 indicates no restriction. * @return *   An array. If the file is an image and did not meet the requirements, it *   will contain an error message. */function file_validate_image_resolution(&$file, $maximum_dimensions = 0, $minimum_dimensions = 0) {  $errors = array();  // Check first that the file is an image.  if ($info = image_get_info($file->filepath)) {    if ($maximum_dimensions) {      // Check that it is smaller than the given dimensions.      list($width, $height) = explode('x', $maximum_dimensions);      if ($info['width'] > $width || $info['height'] > $height) {        // Try to resize the image to fit the dimensions.        if (image_get_toolkit() && image_scale($file->filepath, $file->filepath, $width, $height)) {          drupal_set_message(t('The image was resized to fit within the maximum allowed dimensions of %dimensions pixels.', array('%dimensions' => $maximum_dimensions)));          // Clear the cached filesize and refresh the image information.          clearstatcache();          $info = image_get_info($file->filepath);          $file->filesize = $info['file_size'];        }        else {          $errors[] = t('The image is too large; the maximum dimensions are %dimensions pixels.', array('%dimensions' => $maximum_dimensions));        }      }    }    if ($minimum_dimensions) {      // Check that it is larger than the given dimensions.      list($width, $height) = explode('x', $minimum_dimensions);      if ($info['width'] < $width || $info['height'] < $height) {        $errors[] = t('The image is too small; the minimum dimensions are %dimensions pixels.', array('%dimensions' => $minimum_dimensions));      }    }  }  return $errors;}/** * Save a string to the specified destination. * * @param $data A string containing the contents of the file. * @param $dest A string containing the destination location. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * * @return A string containing the resulting filename or 0 on error */function file_save_data($data, $dest, $replace = FILE_EXISTS_RENAME) {  $temp = file_directory_temp();  // On Windows, tempnam() requires an absolute path, so we use realpath().  $file = tempnam(realpath($temp), 'file');  if (!$fp = fopen($file, 'wb')) {    drupal_set_message(t('The file could not be created.'), 'error');    return 0;  }  fwrite($fp, $data);  fclose($fp);  if (!file_move($file, $dest, $replace)) {    return 0;  }  return $file;}/** * Set the status of a file. * * @param file A Drupal file object * @param status A status value to set the file to. * @return FALSE on failure, TRUE on success and $file->status will contain the *     status. */function file_set_status(&$file, $status) {  if (db_query('UPDATE {files} SET status = %d WHERE fid = %d', $status, $file->fid)) {    $file->status = $status;    return TRUE;  }  return FALSE;}/** * Transfer file using http to client. Pipes a file through Drupal to the * client. * * @param $source File to transfer. * @param $headers An array of http headers to send along with file. */function file_transfer($source, $headers) {  if (ob_get_level()) {    ob_end_clean();  }  foreach ($headers as $header) {    // To prevent HTTP header injection, we delete new lines that are    // not followed by a space or a tab.    // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2    $header = preg_replace('/\r?\n(?!\t| )/', '', $header);    drupal_set_header($header);  }  $source = file_create_path($source);  // Transfer file in 1024 byte chunks to save memory usage.  if ($fd = fopen($source, 'rb')) {    while (!feof($fd)) {      print fread($fd, 1024);    }    fclose($fd);  }  else {    drupal_not_found();  }  exit();}/** * Call modules that implement hook_file_download() to find out if a file is * accessible and what headers it should be transferred with. If a module * returns -1 drupal_access_denied() will be returned. If one or more modules * returned headers the download will start with the returned headers. If no * modules respond drupal_not_found() will be returned. */function file_download() {  // Merge remainder of arguments from GET['q'], into relative file path.  $args = func_get_args();  $filepath = implode('/', $args);  // Maintain compatibility with old ?file=paths saved in node bodies.  if (isset($_GET['file'])) {    $filepath =  $_GET['file'];  }  if (file_exists(file_create_path($filepath))) {    $headers = module_invoke_all('file_download', $filepath);    if (in_array(-1, $headers)) {      return drupal_access_denied();    }    if (count($headers)) {      file_transfer($filepath, $headers);    }  }  return drupal_not_found();}/** * Finds all files that match a given mask in a given directory. * Directories and files beginning with a period are excluded; this * prevents hidden files and directories (such as SVN working directories) * from being scanned. * * @param $dir *   The base directory for the scan, without trailing slash. * @param $mask *   The regular expression of the files to find. * @param $nomask *   An array of files/directories to ignore. * @param $callback *   The callback function to call for each match. * @param $recurse *   When TRUE, the directory scan will recurse the entire tree *   starting at the provided directory. * @param $key *   The key to be used for the returned array of files. Possible *   values are "filename", for the path starting with $dir, *   "basename", for the basename of the file, and "name" for the name *   of the file without an extension. * @param $min_depth *   Minimum depth of directories to return files from. * @param $depth *   Current depth of recursion. This parameter is only used internally and should not be passed. * * @return *   An associative array (keyed on the provided key) of objects with *   "path", "basename", and "name" members corresponding to the *   matching files. */function file_scan_directory($dir, $mask, $nomask = array('.', '..', 'CVS'), $callback = 0, $recurse = TRUE, $key = 'filename', $min_depth = 0, $depth = 0) {  $key = (in_array($key, array('filename', 'basename', 'name')) ? $key : 'filename');  $files = array();  if (is_dir($dir) && $handle = opendir($dir)) {    while (FALSE !== ($file = readdir($handle))) {      if (!in_array($file, $nomask) && $file[0] != '.') {        if (is_dir("$dir/$file") && $recurse) {          // Give priority to files in this folder by merging them in after any subdirectory files.          $files = array_merge(file_scan_directory("$dir/$file", $mask, $nomask, $callback, $recurse, $key, $min_depth, $depth + 1), $files);        }        elseif ($depth >= $min_depth && ereg($mask, $file)) {          // Always use this match over anything already set in $files with the same $$key.          $filename = "$dir/$file";          $basename = basename($file);          $name = substr($basename, 0, strrpos($basename, '.'));          $files[$$key] = new stdClass();          $files[$$key]->filename = $filename;          $files[$$key]->basename = $basename;          $files[$$key]->name = $name;          if ($callback) {            $callback($filename);          }        }      }    }    closedir($handle);  }  return $files;}/** * Determine the default temporary directory. * * @return A string containing a temp directory. */function file_directory_temp() {  $temporary_directory = variable_get('file_directory_temp', NULL);  if (is_null($temporary_directory)) {    $directories = array();    // Has PHP been set with an upload_tmp_dir?    if (ini_get('upload_tmp_dir')) {      $directories[] = ini_get('upload_tmp_dir');    }    // Operating system specific dirs.    if (substr(PHP_OS, 0, 3) == 'WIN') {      $directories[] = 'c:\\windows\\temp';      $directories[] = 'c:\\winnt\\temp';      $path_delimiter = '\\';    }    else {      $directories[] = '/tmp';      $path_delimiter = '/';    }    foreach ($directories as $directory) {      if (!$temporary_directory && is_dir($directory)) {        $temporary_directory = $directory;      }    }    // if a directory has been found, use it, otherwise default to 'files/tmp' or 'files\\tmp';    $temporary_directory = $temporary_directory ? $temporary_directory : file_directory_path() . $path_delimiter .'tmp';    variable_set('file_directory_temp', $temporary_directory);  }  return $temporary_directory;}/** * Determine the default 'files' directory. * * @return A string containing the path to Drupal's 'files' directory. */function file_directory_path() {  return variable_get('file_directory_path', conf_path() .'/files');}/** * Determine the maximum file upload size by querying the PHP settings. * * @return *   A file size limit in bytes based on the PHP upload_max_filesize and post_max_size */function file_upload_max_size() {  static $max_size = -1;  if ($max_size < 0) {    $upload_max = parse_size(ini_get('upload_max_filesize'));    $post_max = parse_size(ini_get('post_max_size'));    $max_size = ($upload_max < $post_max) ? $upload_max : $post_max;  }  return $max_size;}/** * Determine an Internet Media Type, or MIME type from a filename. * * @param $filename *   Name of the file, including extension. * @param $mapping *   An optional array of extension to media type mappings in the form *   'extension1|extension2|...' => 'type'. * * @return *   The internet media type registered for the extension or application/octet-stream for unknown extensions. */function file_get_mimetype($filename, $mapping = NULL) {  if (!is_array($mapping)) {    $mapping = variable_get('mime_extension_mapping', array(      'ez' => 'application/andrew-inset',      'atom' => 'application/atom',      'atomcat' => 'application/atomcat+xml',      'atomsrv' => 'application/atomserv+xml',      'cap|pcap' => 'application/cap',      'cu' => 'application/cu-seeme',      'tsp' => 'application/dsptype',      'spl' => 'application/x-futuresplash',      'hta' => 'application/hta',      'jar' => 'application/java-archive',      'ser' => 'application/java-serialized-object',      'class' => 'application/java-vm',      'hqx' => 'application/mac-binhex40',      'cpt' => 'image/x-corelphotopaint',      'nb' => 'application/mathematica',      'mdb' => 'application/msaccess',      'doc|dot' => 'application/msword',      'bin' => 'application/octet-stream',      'oda' => 'application/oda',      'ogg|ogx' => 'application/ogg',      'pdf' => 'application/pdf',      'key' => 'application/pgp-keys',      'pgp' => 'application/pgp-signature',      'prf' => 'application/pics-rules',      'ps|ai|eps' => 'application/postscript',      'rar' => 'application/rar',      'rdf' => 'application/rdf+xml',      'rss' => 'application/rss+xml',      'rtf' => 'application/rtf',      'smi|smil' => 'application/smil',      'wpd' => 'application/wordperfect',      'wp5' => 'application/wordperfect5.1',      'xhtml|xht' => 'application/xhtml+xml',      'xml|xsl' => 'application/xml',      'zip' => 'application/zip',      'cdy' => 'application/vnd.cinderella',      'kml' => 'application/vnd.google-earth.kml+xml',      'kmz' => 'application/vnd.google-earth.kmz',      'xul' => 'application/vnd.mozilla.xul+xml',      'xls|xlb|xlt' => 'application/vnd.ms-excel',      'cat' => 'application/vnd.ms-pki.seccat',      'stl' => 'application/vnd.ms-pki.stl',      'ppt|pps' => 'application/vnd.ms-powerpoint',      'odc' => 'application/vnd.oasis.opendocument.chart',      'odb' => 'application/vnd.oasis.opendocument.database',      'odf' => 'application/vnd.oasis.opendocument.formula',      'odg' => 'application/vnd.oasis.opendocument.graphics',      'otg' => 'application/vnd.oasis.opendocument.graphics-template',      'odi' => 'application/vnd.oasis.opendocument.image',      'odp' => 'application/vnd.oasis.opendocument.presentation',      'otp' => 'application/vnd.oasis.opendocument.presentation-template',      'ods' => 'application/vnd.oasis.opendocument.spreadsheet',      'ots' => 'application/vnd.oasis.opendocument.spreadsheet-template',      'odt' => 'application/vnd.oasis.opendocument.text',      'odm' => 'application/vnd.oasis.opendocument.text-master',      'ott' => 'application/vnd.oasis.opendocument.text-template',      'oth' => 'application/vnd.oasis.opendocument.text-web',      'docm' => 'application/vnd.ms-word.document.macroEnabled.12',      'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',      'dotm' => 'application/vnd.ms-word.template.macroEnabled.12',      'dotx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',      'potm' => 'application/vnd.ms-powerpoint.template.macroEnabled.12',      'potx' => 'application/vnd.openxmlformats-officedocument.presentationml.template',      'ppam' => 'application/vnd.ms-powerpoint.addin.macroEnabled.12',      'ppsm' => 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',      'ppsx' => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',      'pptm' => 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',      'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',      'xlam' => 'application/vnd.ms-excel.addin.macroEnabled.12',      'xlsb' => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',      'xlsm' => 'application/vnd.ms-excel.sheet.macroEnabled.12',      'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',      'xltm' => 'application/vnd.ms-excel.template.macroEnabled.12',      'xltx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',      'cod' => 'application/vnd.rim.cod',      'mmf' => 'application/vnd.smaf',      'sdc' => 'application/vnd.stardivision.calc',      'sds' => 'application/vnd.stardivision.chart',      'sda' => 'application/vnd.stardivision.draw',      'sdd' => 'application/vnd.stardivision.impress',      'sdf' => 'application/vnd.stardivision.math',      'sdw' => 'application/vnd.stardivision.writer',      'sgl' => 'application/vnd.stardivision.writer-global',      'sxc' => 'application/vnd.sun.xml.calc',      'stc' => 'application/vnd.sun.xml.calc.template',      'sxd' => 'application/vnd.sun.xml.draw',      'std' => 'application/vnd.sun.xml.draw.template',      'sxi' => 'application/vnd.sun.xml.impress',      'sti' => 'application/vnd.sun.xml.impress.template',      'sxm' => 'application/vnd.sun.xml.math',      'sxw' => 'application/vnd.sun.xml.writer',      'sxg' => 'application/vnd.sun.xml.writer.global',      'stw' => 'application/vnd.sun.xml.writer.template',      'sis' => 'application/vnd.symbian.install',      'vsd' => 'application/vnd.visio',      'wbxml' => 'application/vnd.wap.wbxml',      'wmlc' => 'application/vnd.wap.wmlc',      'wmlsc' => 'application/vnd.wap.wmlscriptc',      'wk' => 'application/x-123',      '7z' => 'application/x-7z-compressed',      'abw' => 'application/x-abiword',      'dmg' => 'application/x-apple-diskimage',      'bcpio' => 'application/x-bcpio',      'torrent' => 'application/x-bittorrent',      'cab' => 'application/x-cab',      'cbr' => 'application/x-cbr',      'cbz' => 'application/x-cbz',      'cdf' => 'application/x-cdf',      'vcd' => 'application/x-cdlink',      'pgn' => 'application/x-chess-pgn',      'cpio' => 'application/x-cpio',      'csh' => 'text/x-csh',      'deb|udeb' => 'application/x-debian-package',      'dcr|dir|dxr' => 'application/x-director',      'dms' => 'application/x-dms',      'wad' => 'application/x-doom',      'dvi' => 'application/x-dvi',      'rhtml' => 'application/x-httpd-eruby',      'flac' => 'application/x-flac',      'pfa|pfb|gsf|pcf|pcf.Z' => 'application/x-font',      'mm' => 'application/x-freemind',      'gnumeric' => 'application/x-gnumeric',      'sgf' => 'application/x-go-sgf',      'gcf' => 'application/x-graphing-calculator',      'gtar|tgz|taz' => 'application/x-gtar',      'hdf' => 'application/x-hdf',      'phtml|pht|php' => 'application/x-httpd-php',      'phps' => 'application/x-httpd-php-source',      'php3' => 'application/x-httpd-php3',      'php3p' => 'application/x-httpd-php3-preprocessed',      'php4' => 'application/x-httpd-php4',      'ica' => 'application/x-ica',      'ins|isp' => 'application/x-internet-signup',      'iii' => 'application/x-iphone',      'iso' => 'application/x-iso9660-image',      'jnlp' => 'application/x-java-jnlp-file',      'js' => 'application/x-javascript',      'jmz' => 'application/x-jmol',      'chrt' => 'application/x-kchart',      'kil' => 'application/x-killustrator',      'skp|skd|skt|skm' => 'application/x-koan',      'kpr|kpt' => 'application/x-kpresenter',      'ksp' => 'application/x-kspread',      'kwd|kwt' => 'application/x-kword',      'latex' => 'application/x-latex',      'lha' => 'application/x-lha',      'lyx' => 'application/x-lyx',      'lzh' => 'application/x-lzh',      'lzx' => 'application/x-lzx',      'frm|maker|frame|fm|fb|book|fbdoc' => 'application/x-maker',      'mif' => 'application/x-mif',      'wmd' => 'application/x-ms-wmd',      'wmz' => 'application/x-ms-wmz',      'com|exe|bat|dll' => 'application/x-msdos-program',      'msi' => 'application/x-msi',      'nc' => 'application/x-netcdf',      'pac' => 'application/x-ns-proxy-autoconfig',      'nwc' => 'application/x-nwc',      'o' => 'application/x-object',      'oza' => 'application/x-oz-application',      'p7r' => 'application/x-pkcs7-certreqresp',      'crl' => 'application/x-pkcs7-crl',      'pyc|pyo' => 'application/x-python-code',      'qtl' => 'application/x-quicktimeplayer',      'rpm' => 'application/x-redhat-package-manager',      'sh' => 'text/x-sh',      'shar' => 'application/x-shar',      'swf|swfl' => 'application/x-shockwave-flash',      'sit|sitx' => 'application/x-stuffit',      'sv4cpio' => 'application/x-sv4cpio',      'sv4crc' => 'application/x-sv4crc',      'tar' => 'application/x-tar',      'tcl' => 'application/x-tcl',      'gf' => 'application/x-tex-gf',      'pk' => 'application/x-tex-pk',      'texinfo|texi' => 'application/x-texinfo',      '~|%|bak|old|sik' => 'application/x-trash',      't|tr|roff' => 'application/x-troff',      'man' => 'application/x-troff-man',      'me' => 'application/x-troff-me',      'ms' => 'application/x-troff-ms',      'ustar' => 'application/x-ustar',      'src' => 'application/x-wais-source',      'wz' => 'application/x-wingz',      'crt' => 'application/x-x509-ca-cert',      'xcf' => 'application/x-xcf',      'fig' => 'application/x-xfig',      'xpi' => 'application/x-xpinstall',      'au|snd' => 'audio/basic',      'mid|midi|kar' => 'audio/midi',      'mpga|mpega|mp2|mp3|m4a' => 'audio/mpeg',      'f4a|f4b' => 'audio/mp4',      'm3u' => 'audio/x-mpegurl',      'oga|spx' => 'audio/ogg',      'sid' => 'audio/prs.sid',      'aif|aiff|aifc' => 'audio/x-aiff',      'gsm' => 'audio/x-gsm',      'wma' => 'audio/x-ms-wma',      'wax' => 'audio/x-ms-wax',      'ra|rm|ram' => 'audio/x-pn-realaudio',      'ra' => 'audio/x-realaudio',      'pls' => 'audio/x-scpls',      'sd2' => 'audio/x-sd2',      'wav' => 'audio/x-wav',      'alc' => 'chemical/x-alchemy',      'cac|cache' => 'chemical/x-cache',      'csf' => 'chemical/x-cache-csf',      'cbin|cascii|ctab' => 'chemical/x-cactvs-binary',      'cdx' => 'chemical/x-cdx',      'cer' => 'chemical/x-cerius',      'c3d' => 'chemical/x-chem3d',      'chm' => 'chemical/x-chemdraw',      'cif' => 'chemical/x-cif',      'cmdf' => 'chemical/x-cmdf',      'cml' => 'chemical/x-cml',      'cpa' => 'chemical/x-compass',      'bsd' => 'chemical/x-crossfire',      'csml|csm' => 'chemical/x-csml',      'ctx' => 'chemical/x-ctx',      'cxf|cef' => 'chemical/x-cxf',      'emb|embl' => 'chemical/x-embl-dl-nucleotide',      'spc' => 'chemical/x-galactic-spc',      'inp|gam|gamin' => 'chemical/x-gamess-input',      'fch|fchk' => 'chemical/x-gaussian-checkpoint',      'cub' => 'chemical/x-gaussian-cube',      'gau|gjc|gjf' => 'chemical/x-gaussian-input',      'gal' => 'chemical/x-gaussian-log',      'gcg' => 'chemical/x-gcg8-sequence',      'gen' => 'chemical/x-genbank',      'hin' => 'chemical/x-hin',      'istr|ist' => 'chemical/x-isostar',      'jdx|dx' => 'chemical/x-jcamp-dx',      'kin' => 'chemical/x-kinemage',      'mcm' => 'chemical/x-macmolecule',      'mmd|mmod' => 'chemical/x-macromodel-input',      'mol' => 'chemical/x-mdl-molfile',      'rd' => 'chemical/x-mdl-rdfile',      'rxn' => 'chemical/x-mdl-rxnfile',      'sd|sdf' => 'chemical/x-mdl-sdfile',      'tgf' => 'chemical/x-mdl-tgf',      'mcif' => 'chemical/x-mmcif',      'mol2' => 'chemical/x-mol2',      'b' => 'chemical/x-molconn-Z',      'gpt' => 'chemical/x-mopac-graph',      'mop|mopcrt|mpc|dat|zmt' => 'chemical/x-mopac-input',      'moo' => 'chemical/x-mopac-out',      'mvb' => 'chemical/x-mopac-vib',      'asn' => 'chemical/x-ncbi-asn1-spec',      'prt|ent' => 'chemical/x-ncbi-asn1-ascii',      'val|aso' => 'chemical/x-ncbi-asn1-binary',      'pdb|ent' => 'chemical/x-pdb',      'ros' => 'chemical/x-rosdal',      'sw' => 'chemical/x-swissprot',      'vms' => 'chemical/x-vamas-iso14976',      'vmd' => 'chemical/x-vmd',      'xtel' => 'chemical/x-xtel',      'xyz' => 'chemical/x-xyz',      'gif' => 'image/gif',      'ief' => 'image/ief',      'jpeg|jpg|jpe' => 'image/jpeg',      'pcx' => 'image/pcx',      'png' => 'image/png',      'svg|svgz' => 'image/svg+xml',      'tiff|tif' => 'image/tiff',      'djvu|djv' => 'image/vnd.djvu',      'wbmp' => 'image/vnd.wap.wbmp',      'ras' => 'image/x-cmu-raster',      'cdr' => 'image/x-coreldraw',      'pat' => 'image/x-coreldrawpattern',      'cdt' => 'image/x-coreldrawtemplate',      'ico' => 'image/x-icon',      'art' => 'image/x-jg',      'jng' => 'image/x-jng',      'bmp' => 'image/x-ms-bmp',      'psd' => 'image/x-photoshop',      'pnm' => 'image/x-portable-anymap',      'pbm' => 'image/x-portable-bitmap',      'pgm' => 'image/x-portable-graymap',      'ppm' => 'image/x-portable-pixmap',      'rgb' => 'image/x-rgb',      'xbm' => 'image/x-xbitmap',      'xpm' => 'image/x-xpixmap',      'xwd' => 'image/x-xwindowdump',      'eml' => 'message/rfc822',      'igs|iges' => 'model/iges',      'msh|mesh|silo' => 'model/mesh',      'wrl|vrml' => 'model/vrml',      'ics|icz' => 'text/calendar',      'css' => 'text/css',      'csv' => 'text/csv',      '323' => 'text/h323',      'html|htm|shtml' => 'text/html',      'uls' => 'text/iuls',      'mml' => 'text/mathml',      'asc|txt|text|pot' => 'text/plain',      'rtx' => 'text/richtext',      'sct|wsc' => 'text/scriptlet',      'tm|ts' => 'text/texmacs',      'tsv' => 'text/tab-separated-values',      'jad' => 'text/vnd.sun.j2me.app-descriptor',      'wml' => 'text/vnd.wap.wml',      'wmls' => 'text/vnd.wap.wmlscript',      'bib' => 'text/x-bibtex',      'boo' => 'text/x-boo',      'h++|hpp|hxx|hh' => 'text/x-c++hdr',      'c++|cpp|cxx|cc' => 'text/x-c++src',      'h' => 'text/x-chdr',      'htc' => 'text/x-component',      'c' => 'text/x-csrc',      'd' => 'text/x-dsrc',      'diff|patch' => 'text/x-diff',      'hs' => 'text/x-haskell',      'java' => 'text/x-java',      'lhs' => 'text/x-literate-haskell',      'moc' => 'text/x-moc',      'p|pas' => 'text/x-pascal',      'gcd' => 'text/x-pcs-gcd',      'pl|pm' => 'text/x-perl',      'py' => 'text/x-python',      'etx' => 'text/x-setext',      'tcl|tk' => 'text/x-tcl',      'tex|ltx|sty|cls' => 'text/x-tex',      'vcs' => 'text/x-vcalendar',      'vcf' => 'text/x-vcard',      '3gp' => 'video/3gpp',      'dl' => 'video/dl',      'dif|dv' => 'video/dv',      'fli' => 'video/fli',      'gl' => 'video/gl',      'mpeg|mpg|mpe' => 'video/mpeg',      'mp4|f4v|f4p' => 'video/mp4',      'flv' => 'video/x-flv',      'ogv' => 'video/ogg',      'qt|mov' => 'video/quicktime',      'mxu' => 'video/vnd.mpegurl',      'lsf|lsx' => 'video/x-la-asf',      'mng' => 'video/x-mng',      'asf|asx' => 'video/x-ms-asf',      'wm' => 'video/x-ms-wm',      'wmv' => 'video/x-ms-wmv',      'wmx' => 'video/x-ms-wmx',      'wvx' => 'video/x-ms-wvx',      'avi' => 'video/x-msvideo',      'movie' => 'video/x-sgi-movie',      'ice' => 'x-conference/x-cooltalk',      'sisx' => 'x-epoc/x-sisx-app',      'vrm|vrml|wrl' => 'x-world/x-vrml',      'xps' => 'application/vnd.ms-xpsdocument',    ));  }  foreach ($mapping as $ext_preg => $mime_match) {    if (preg_match('!\.('. $ext_preg .')$!i', $filename)) {      return $mime_match;    }  }  return 'application/octet-stream';}/** * @} End of "defgroup file". */
<?php// $Id$/** * @file * Controls the boxes that are displayed around the main content. *//** * Denotes that a block is not enabled in any region and should not * be shown. */define('BLOCK_REGION_NONE', -1);/** * Constants defining cache granularity for blocks. * * Modules specify the caching patterns for their blocks using binary * combinations of these constants in their hook_block(op 'list'): *   $block[delta]['cache'] = BLOCK_CACHE_PER_ROLE | BLOCK_CACHE_PER_PAGE; * BLOCK_CACHE_PER_ROLE is used as a default when no caching pattern is * specified. * * The block cache is cleared in cache_clear_all(), and uses the same clearing * policy than page cache (node, comment, user, taxonomy added or updated...). * Blocks requiring more fine-grained clearing might consider disabling the * built-in block cache (BLOCK_NO_CACHE) and roll their own. * * Note that user 1 is excluded from block caching. *//** * The block should not get cached. This setting should be used: * - for simple blocks (notably those that do not perform any db query), * where querying the db cache would be more expensive than directly generating * the content. * - for blocks that change too frequently. */define('BLOCK_NO_CACHE', -1);/** * The block can change depending on the roles the user viewing the page belongs to. * This is the default setting, used when the block does not specify anything. */define('BLOCK_CACHE_PER_ROLE', 0x0001);/** * The block can change depending on the user viewing the page. * This setting can be resource-consuming for sites with large number of users, * and thus should only be used when BLOCK_CACHE_PER_ROLE is not sufficient. */define('BLOCK_CACHE_PER_USER', 0x0002);/** * The block can change depending on the page being viewed. */define('BLOCK_CACHE_PER_PAGE', 0x0004);/** * The block is the same for every user on every page where it is visible. */define('BLOCK_CACHE_GLOBAL', 0x0008);/** * Implementation of hook_help(). */function block_help($path, $arg) {  switch ($path) {    case 'admin/help#block':      $output = '<p>'. t('Blocks are boxes of content rendered into an area, or region, of a web page. The default theme Garland, for example, implements the regions "left sidebar", "right sidebar", "content", "header", and "footer", and a block may appear in any one of these areas. The <a href="@blocks">blocks administration page</a> provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions.', array('@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('Although blocks are usually generated automatically by modules (like the <em>User login</em> block, for example), administrators can also define custom blocks. Custom blocks have a title, description, and body. The body of the block can be as long as necessary, and can contain content supported by any available <a href="@input-format">input format</a>.', array('@input-format' => url('admin/settings/filters'))) .'</p>';      $output .= '<p>'. t('When working with blocks, remember that:') .'</p>';      $output .= '<ul><li>'. t('since not all themes implement the same regions, or display regions in the same way, blocks are positioned on a per-theme basis.') .'</li>';      $output .= '<li>'. t('disabled blocks, or blocks not in a region, are never shown.') .'</li>';      $output .= '<li>'. t('when throttle module is enabled, throttled blocks (blocks with the <em>Throttle</em> checkbox selected) are hidden during high server loads.') .'</li>';      $output .= '<li>'. t('blocks can be configured to be visible only on certain pages.') .'</li>';      $output .= '<li>'. t('blocks can be configured to be visible only when specific conditions are true.') .'</li>';      $output .= '<li>'. t('blocks can be configured to be visible only for certain user roles.') .'</li>';      $output .= '<li>'. t('when allowed by an administrator, specific blocks may be enabled or disabled on a per-user basis using the <em>My account</em> page.') .'</li>';      $output .= '<li>'. t('some dynamic blocks, such as those generated by modules, will be displayed only on certain pages.') .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@block">Block module</a>.', array('@block' => 'http://drupal.org/handbook/modules/block/')) .'</p>';      return $output;    case 'admin/build/block':      $throttle = module_exists('throttle');      $output = '<p>'. t('This page provides a drag-and-drop interface for assigning a block to a region, and for controlling the order of blocks within regions. To change the region or order of a block, grab a drag-and-drop handle under the <em>Block</em> column and drag the block to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Since not all themes implement the same regions, or display regions in the same way, blocks are positioned on a per-theme basis. Remember that your changes will not be saved until you click the <em>Save blocks</em> button at the bottom of the page.') .'</p>';      if ($throttle) {        $output .= '<p>'. t('To reduce CPU usage, database traffic or bandwidth, blocks may be automatically disabled during high server loads by selecting their <em>Throttle</em> checkbox. Adjust throttle thresholds on the <a href="@throttleconfig">throttle configuration page</a>.', array('@throttleconfig' => url('admin/settings/throttle'))) .'</p>';      }      $output .= '<p>'. t('Click the <em>configure</em> link next to each block to configure its specific title and visibility settings. Use the <a href="@add-block">add block page</a> to create a custom block.', array('@add-block' => url('admin/build/block/add'))) .'</p>';      return $output;    case 'admin/build/block/add':      return '<p>'. t('Use this page to create a new custom block. New blocks are disabled by default, and must be moved to a region on the <a href="@blocks">blocks administration page</a> to be visible.', array('@blocks' => url('admin/build/block'))) .'</p>';  }}/** * Implementation of hook_theme() */function block_theme() {  return array(    'block_admin_display_form' => array(      'template' => 'block-admin-display-form',      'file' => 'block.admin.inc',      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_perm(). */function block_perm() {  return array('administer blocks', 'use PHP for block visibility');}/** * Implementation of hook_menu(). */function block_menu() {  $items['admin/build/block'] = array(    'title' => 'Blocks',    'description' => 'Configure what block content appears in your site\'s sidebars and other regions.',    'page callback' => 'block_admin_display',    'access arguments' => array('administer blocks'),    'file' => 'block.admin.inc',  );  $items['admin/build/block/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/build/block/list/js'] = array(    'title' => 'JavaScript List Form',    'page callback' => 'block_admin_display_js',    'access arguments' => array('administer blocks'),    'type' => MENU_CALLBACK,    'file' => 'block.admin.inc',  );  $items['admin/build/block/configure'] = array(    'title' => 'Configure block',    'page callback' => 'drupal_get_form',    'page arguments' => array('block_admin_configure'),    'access arguments' => array('administer blocks'),    'type' => MENU_CALLBACK,    'file' => 'block.admin.inc',  );  $items['admin/build/block/delete'] = array(    'title' => 'Delete block',    'page callback' => 'drupal_get_form',    'page arguments' => array('block_box_delete'),    'access arguments' => array('administer blocks'),    'type' => MENU_CALLBACK,    'file' => 'block.admin.inc',  );  $items['admin/build/block/add'] = array(    'title' => 'Add block',    'page callback' => 'drupal_get_form',    'page arguments' => array('block_add_block_form'),    'access arguments' => array('administer blocks'),    'type' => MENU_LOCAL_TASK,    'file' => 'block.admin.inc',  );  $default = variable_get('theme_default', 'garland');  foreach (list_themes() as $key => $theme) {    $items['admin/build/block/list/'. $key] = array(      'title' => check_plain($theme->info['name']),      'page arguments' => array($key),      'type' => $key == $default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,      'weight' => $key == $default ? -10 : 0,      'file' => 'block.admin.inc',      'access callback' => '_block_themes_access',      'access arguments' => array($theme),    );  }  return $items;}/** * Menu item access callback - only admin or enabled themes can be accessed */function _block_themes_access($theme) {  return user_access('administer blocks') && ($theme->status || $theme->name == variable_get('admin_theme', '0'));}/** * Implementation of hook_block(). * * Generates the administrator-defined blocks for display. */function block_block($op = 'list', $delta = 0, $edit = array()) {  switch ($op) {    case 'list':      $blocks = array();      $result = db_query('SELECT bid, info FROM {boxes} ORDER BY info');      while ($block = db_fetch_object($result)) {        $blocks[$block->bid]['info'] = $block->info;        // Not worth caching.        $blocks[$block->bid]['cache'] = BLOCK_NO_CACHE;      }      return $blocks;    case 'configure':      $box = array('format' => FILTER_FORMAT_DEFAULT);      if ($delta) {        $box = block_box_get($delta);      }      if (filter_access($box['format'])) {        return block_box_form($box);      }      break;    case 'save':      block_box_save($edit, $delta);      break;    case 'view':      $block = db_fetch_object(db_query('SELECT body, format FROM {boxes} WHERE bid = %d', $delta));      $data['content'] = check_markup($block->body, $block->format, FALSE);      return $data;  }}/** * Update the 'blocks' DB table with the blocks currently exported by modules. * * @return *   Blocks currently exported by modules. */function _block_rehash() {  global $theme_key;  init_theme();  $result = db_query("SELECT * FROM {blocks} WHERE theme = '%s'", $theme_key);  $old_blocks = array();  while ($old_block = db_fetch_array($result)) {    $old_blocks[$old_block['module']][$old_block['delta']] = $old_block;  }  $blocks = array();  // Valid region names for the theme.  $regions = system_region_list($theme_key);  foreach (module_list() as $module) {    $module_blocks = module_invoke($module, 'block', 'list');    if ($module_blocks) {      foreach ($module_blocks as $delta => $block) {        if (empty($old_blocks[$module][$delta])) {          // If it's a new block, add identifiers.          $block['module'] = $module;          $block['delta']  = $delta;          $block['theme']  = $theme_key;          if (!isset($block['pages'])) {            // {block}.pages is type 'text', so it cannot have a            // default value, and not null, so we need to provide            // value if the module did not.            $block['pages']  = '';          }          // Add defaults and save it into the database.          drupal_write_record('blocks', $block);          // Set region to none if not enabled.          $block['region'] = $block['status'] ? $block['region'] : BLOCK_REGION_NONE;          // Add to the list of blocks we return.          $blocks[] = $block;        }        else {          // If it's an existing block, database settings should overwrite          // the code. But aside from 'info' everything that's definable in          // code is stored in the database and we do not store 'info', so we          // do not need to update the database here.          // Add 'info' to this block.          $old_blocks[$module][$delta]['info'] = $block['info'];          // If the region name does not exist, disable the block and assign it to none.          if (!empty($old_blocks[$module][$delta]['region']) && !isset($regions[$old_blocks[$module][$delta]['region']])) {            drupal_set_message(t('The block %info was assigned to the invalid region %region and has been disabled.', array('%info' => $old_blocks[$module][$delta]['info'], '%region' => $old_blocks[$module][$delta]['region'])), 'warning');            $old_blocks[$module][$delta]['status'] = 0;            $old_blocks[$module][$delta]['region'] = BLOCK_REGION_NONE;          }          else {            $old_blocks[$module][$delta]['region'] = $old_blocks[$module][$delta]['status'] ? $old_blocks[$module][$delta]['region'] : BLOCK_REGION_NONE;          }          // Add this block to the list of blocks we return.          $blocks[] = $old_blocks[$module][$delta];          // Remove this block from the list of blocks to be deleted.          unset($old_blocks[$module][$delta]);        }      }    }  }  // Remove blocks that are no longer defined by the code from the database.  foreach ($old_blocks as $module => $old_module_blocks) {    foreach ($old_module_blocks as $delta => $block) {      db_query("DELETE FROM {blocks} WHERE module = '%s' AND delta = '%s' AND theme = '%s'", $module, $delta, $theme_key);    }  }  return $blocks;}/** * Returns information from database about a user-created (custom) block. * * @param $bid *   ID of the block to get information for. * @return *   Associative array of information stored in the database for this block. *   Array keys: *   - bid: Block ID. *   - info: Block description. *   - body: Block contents. *   - format: Filter ID of the filter format for the body. */function block_box_get($bid) {  return db_fetch_array(db_query("SELECT * FROM {boxes} WHERE bid = %d", $bid));}/** * Define the custom block form. */function block_box_form($edit = array()) {  $edit += array(    'info' => '',    'body' => '',  );  $form['info'] = array(    '#type' => 'textfield',    '#title' => t('Block description'),    '#default_value' => $edit['info'],    '#maxlength' => 64,    '#description' => t('A brief description of your block. Used on the <a href="@overview">block overview page</a>.', array('@overview' => url('admin/build/block'))),    '#required' => TRUE,    '#weight' => -19,  );  $form['body_field']['#weight'] = -17;  $form['body_field']['body'] = array(    '#type' => 'textarea',    '#title' => t('Block body'),    '#default_value' => $edit['body'],    '#rows' => 15,    '#description' => t('The content of the block as shown to the user.'),    '#weight' => -17,  );  if (!isset($edit['format'])) {    $edit['format'] = FILTER_FORMAT_DEFAULT;  }  $form['body_field']['format'] = filter_form($edit['format'], -16);  return $form;}/** * Saves a user-created block in the database. * * @param $edit *   Associative array of fields to save. Array keys: *   - info: Block description. *   - body: Block contents. *   - format: Filter ID of the filter format for the body. * @param $delta *   Block ID of the block to save. * @return *   Always returns TRUE. */function block_box_save($edit, $delta) {  if (!filter_access($edit['format'])) {    $edit['format'] = FILTER_FORMAT_DEFAULT;  }  db_query("UPDATE {boxes} SET body = '%s', info = '%s', format = %d WHERE bid = %d", $edit['body'], $edit['info'], $edit['format'], $delta);  return TRUE;}/** * Implementation of hook_user(). * * Allow users to decide which custom blocks to display when they visit * the site. */function block_user($type, $edit, &$account, $category = NULL) {  switch ($type) {    case 'form':      if ($category == 'account') {        $rids = array_keys($account->roles);        $result = db_query("SELECT DISTINCT b.* FROM {blocks} b LEFT JOIN {blocks_roles} r ON b.module = r.module AND b.delta = r.delta WHERE b.status = 1 AND b.custom != 0 AND (r.rid IN (". db_placeholders($rids) .") OR r.rid IS NULL) ORDER BY b.weight, b.module", $rids);        $form['block'] = array('#type' => 'fieldset', '#title' => t('Block configuration'), '#weight' => 3, '#collapsible' => TRUE, '#tree' => TRUE);        while ($block = db_fetch_object($result)) {          $data = module_invoke($block->module, 'block', 'list');          if ($data[$block->delta]['info']) {            $return = TRUE;            $form['block'][$block->module][$block->delta] = array('#type' => 'checkbox', '#title' => check_plain($data[$block->delta]['info']), '#default_value' => isset($account->block[$block->module][$block->delta]) ? $account->block[$block->module][$block->delta] : ($block->custom == 1));          }        }        if (!empty($return)) {          return $form;        }      }      break;    case 'validate':      if (empty($edit['block'])) {        $edit['block'] = array();      }      return $edit;  }}/** * Return all blocks in the specified region for the current user. * * @param $region *   The name of a region. * * @return *   An array of block objects, indexed with <i>module</i>_<i>delta</i>. *   If you are displaying your blocks in one or two sidebars, you may check *   whether this array is empty to see how many columns are going to be *   displayed. * * @todo *   Now that the blocks table has a primary key, we should use that as the *   array key instead of <i>module</i>_<i>delta</i>. */function block_list($region) {  global $user, $theme_key;  static $blocks = array();  if (!count($blocks)) {    $rids = array_keys($user->roles);    $result = db_query(db_rewrite_sql("SELECT DISTINCT b.* FROM {blocks} b LEFT JOIN {blocks_roles} r ON b.module = r.module AND b.delta = r.delta WHERE b.theme = '%s' AND b.status = 1 AND (r.rid IN (". db_placeholders($rids) .") OR r.rid IS NULL) ORDER BY b.region, b.weight, b.module", 'b', 'bid'), array_merge(array($theme_key), $rids));    while ($block = db_fetch_object($result)) {      if (!isset($blocks[$block->region])) {        $blocks[$block->region] = array();      }      // Use the user's block visibility setting, if necessary      if ($block->custom != 0) {        if ($user->uid && isset($user->block[$block->module][$block->delta])) {          $enabled = $user->block[$block->module][$block->delta];        }        else {          $enabled = ($block->custom == 1);        }      }      else {        $enabled = TRUE;      }      // Match path if necessary      if ($block->pages) {        if ($block->visibility < 2) {          $path = drupal_get_path_alias($_GET['q']);          // Compare with the internal and path alias (if any).          $page_match = drupal_match_path($path, $block->pages);          if ($path != $_GET['q']) {            $page_match = $page_match || drupal_match_path($_GET['q'], $block->pages);          }          // When $block->visibility has a value of 0, the block is displayed on          // all pages except those listed in $block->pages. When set to 1, it          // is displayed only on those pages listed in $block->pages.          $page_match = !($block->visibility xor $page_match);        }        else {          $page_match = drupal_eval($block->pages);        }      }      else {        $page_match = TRUE;      }      $block->enabled = $enabled;      $block->page_match = $page_match;      $blocks[$block->region]["{$block->module}_{$block->delta}"] = $block;    }  }  // Create an empty array if there were no entries  if (!isset($blocks[$region])) {    $blocks[$region] = array();  }  foreach ($blocks[$region] as $key => $block) {    // Render the block content if it has not been created already.    if (!isset($block->content)) {      // Erase the block from the static array - we'll put it back if it has content.      unset($blocks[$region][$key]);      if ($block->enabled && $block->page_match) {        // Check the current throttle status and see if block should be displayed        // based on server load.        if (!($block->throttle && (module_invoke('throttle', 'status') > 0))) {          // Try fetching the block from cache. Block caching is not compatible with          // node_access modules. We also preserve the submission of forms in blocks,          // by fetching from cache only if the request method is 'GET'.          if (!count(module_implements('node_grants')) && $_SERVER['REQUEST_METHOD'] == 'GET' && ($cid = _block_get_cache_id($block)) && ($cache = cache_get($cid, 'cache_block'))) {            $array = $cache->data;          }          else {            $array = module_invoke($block->module, 'block', 'view', $block->delta);            if (isset($cid)) {              cache_set($cid, $array, 'cache_block', CACHE_TEMPORARY);            }          }          if (isset($array) && is_array($array)) {            foreach ($array as $k => $v) {              $block->$k = $v;            }          }        }        if (isset($block->content) && $block->content) {          // Override default block title if a custom display title is present.          if ($block->title) {            // Check plain here to allow module generated titles to keep any markup.            $block->subject = $block->title == '<none>' ? '' : check_plain($block->title);          }          if (!isset($block->subject)) {            $block->subject = '';          }          $blocks[$block->region]["{$block->module}_{$block->delta}"] = $block;        }      }    }  }  return $blocks[$region];}/** * Assemble the cache_id to use for a given block. * * The cache_id string reflects the viewing context for the current block * instance, obtained by concatenating the relevant context information * (user, page, ...) according to the block's cache settings (BLOCK_CACHE_* * constants). Two block instances can use the same cached content when * they share the same cache_id. * * Theme and language contexts are automatically differenciated. * * @param $block * @return *   The string used as cache_id for the block. */function _block_get_cache_id($block) {  global $theme, $base_root, $user;  // User 1 being out of the regular 'roles define permissions' schema,  // it brings too many chances of having unwanted output get in the cache  // and later be served to other users. We therefore exclude user 1 from  // block caching.  if (variable_get('block_cache', 0) && $block->cache != BLOCK_NO_CACHE && $user->uid != 1) {    $cid_parts = array();    // Start with common sub-patterns: block identification, theme, language.    $cid_parts[] = $block->module;    $cid_parts[] = $block->delta;    $cid_parts[] = $theme;    if (module_exists('locale')) {      global $language;      $cid_parts[] = $language->language;    }    // 'PER_ROLE' and 'PER_USER' are mutually exclusive. 'PER_USER' can be a    // resource drag for sites with many users, so when a module is being    // equivocal, we favor the less expensive 'PER_ROLE' pattern.    if ($block->cache & BLOCK_CACHE_PER_ROLE) {      $cid_parts[] = 'r.'. implode(',', array_keys($user->roles));    }    elseif ($block->cache & BLOCK_CACHE_PER_USER) {      $cid_parts[] = "u.$user->uid";    }    if ($block->cache & BLOCK_CACHE_PER_PAGE) {      $cid_parts[] = $base_root . request_uri();    }    return implode(':', $cid_parts);  }}
<?php// $Id$/** * @file * Administrative page callbacks for the profile module. *//** * Form builder to display a listing of all editable profile fields. * * @ingroup forms * @see profile_admin_overview_submit() */function profile_admin_overview() {  $result = db_query('SELECT title, name, type, category, fid, weight FROM {profile_fields} ORDER BY category, weight');  $form = array();  $categories = array();  while ($field = db_fetch_object($result)) {    // Collect all category information    $categories[] = $field->category;    // Save all field information    $form[$field->fid]['name'] = array('#value' => check_plain($field->name));    $form[$field->fid]['title'] = array('#value' => check_plain($field->title));    $form[$field->fid]['type'] = array('#value' => $field->type);    $form[$field->fid]['category'] = array('#type' => 'select', '#default_value' => $field->category, '#options' => array());    $form[$field->fid]['weight'] = array('#type' => 'weight', '#default_value' => $field->weight);    $form[$field->fid]['edit'] = array('#value' => l(t('edit'), "admin/user/profile/edit/$field->fid"));    $form[$field->fid]['delete'] = array('#value' => l(t('delete'), "admin/user/profile/delete/$field->fid"));  }  // Add the cateogory combo boxes  $categories = array_unique($categories);  foreach ($form as $fid => $field) {    foreach ($categories as $cat => $category) {      $form[$fid]['category']['#options'][$category] = $category;    }  }  // Display the submit button only when there's more than one field  if (count($form) > 1) {    $form['submit'] = array('#type' => 'submit', '#value' => t('Save configuration'));  }  else {    // Disable combo boxes when there isn't a submit button    foreach ($form as $fid => $field) {      unset($form[$fid]['weight']);      $form[$fid]['category']['#type'] = 'value';    }  }  $form['#tree'] = TRUE;  $addnewfields = '<h2>'. t('Add new field') .'</h2>';  $addnewfields .= '<ul>';  foreach (_profile_field_types() as $key => $value) {    $addnewfields .= '<li>'. l($value, "admin/user/profile/add/$key") .'</li>';  }  $addnewfields .= '</ul>';  $form['addnewfields'] = array('#value' => $addnewfields);  return $form;}/** * Submit handler to update changed profile field weights and categories. * * @see profile_admin_overview() */function profile_admin_overview_submit($form, &$form_state) {  foreach (element_children($form_state['values']) as $fid) {    if (is_numeric($fid)) {      $weight = $form_state['values'][$fid]['weight'];      $category = $form_state['values'][$fid]['category'];      if ($weight != $form[$fid]['weight']['#default_value'] || $category != $form[$fid]['category']['#default_value']) {        db_query("UPDATE {profile_fields} SET weight = %d, category = '%s' WHERE fid = %d", $weight, $category, $fid);      }    }  }  drupal_set_message(t('Profile fields have been updated.'));  cache_clear_all();  menu_rebuild();}/** * Theme the profile field overview into a drag and drop enabled table. * * @ingroup themeable * @see profile_admin_overview() */function theme_profile_admin_overview($form) {  drupal_add_css(drupal_get_path('module', 'profile') .'/profile.css');  // Add javascript if there's more than one field.  if (isset($form['submit'])) {    drupal_add_js(drupal_get_path('module', 'profile') .'/profile.js');  }  $rows = array();  $categories = array();  $category_number = 0;  foreach (element_children($form) as $key) {    // Don't take form control structures.    if (array_key_exists('category', $form[$key])) {      $field = &$form[$key];      $category = $field['category']['#default_value'];      if (!isset($categories[$category])) {        // Category classes are given numeric IDs because there's no guarantee        // class names won't contain invalid characters.        $categories[$category] = $category_number;        $category_field['#attributes']['class'] = 'profile-category profile-category-'. $category_number;        $rows[] = array(array('data' => $category, 'colspan' => 7, 'class' => 'category'));        $rows[] = array('data' => array(array('data' => '<em>'. t('No fields in this category. If this category remains empty when saved, it will be removed.') .'</em>', 'colspan' => 7)), 'class' => 'category-'. $category_number .'-message category-message category-populated');        // Make it dragable only if there is more than one field        if (isset($form['submit'])) {          drupal_add_tabledrag('profile-fields', 'order', 'sibling', 'profile-weight', 'profile-weight-'. $category_number);          drupal_add_tabledrag('profile-fields', 'match', 'sibling', 'profile-category', 'profile-category-'. $category_number);        }        $category_number++;      }      // Add special drag and drop classes that group fields together.      $field['weight']['#attributes']['class'] = 'profile-weight profile-weight-'. $categories[$category];      $field['category']['#attributes']['class'] = 'profile-category profile-category-'. $categories[$category];      // Add the row      $row = array();      $row[] = drupal_render($field['title']);      $row[] = drupal_render($field['name']);      $row[] = drupal_render($field['type']);      if (isset($form['submit'])) {        $row[] = drupal_render($field['category']);        $row[] = drupal_render($field['weight']);      }      $row[] = drupal_render($field['edit']);      $row[] = drupal_render($field['delete']);      $rows[] = array('data' => $row, 'class' => 'draggable');    }  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No fields available.'), 'colspan' => 7));  }  $header = array(t('Title'), t('Name'), t('Type'));  if (isset($form['submit'])) {    $header[] = t('Category');    $header[] = t('Weight');  }  $header[] = array('data' => t('Operations'), 'colspan' => 2);  $output = theme('table', $header, $rows, array('id' => 'profile-fields'));  $output .= drupal_render($form);  return $output;}/** * Menu callback: Generate a form to add/edit a user profile field. * * @ingroup forms * @see profile_field_form_validate() * @see profile_field_form_submit() */function profile_field_form(&$form_state, $arg = NULL) {  if (arg(3) == 'edit') {    if (is_numeric($arg)) {      $fid = $arg;      $edit = db_fetch_array(db_query('SELECT * FROM {profile_fields} WHERE fid = %d', $fid));      if (!$edit) {        drupal_not_found();        return;      }      drupal_set_title(t('edit %title', array('%title' => $edit['title'])));      $form['fid'] = array('#type' => 'value',        '#value' => $fid,      );      $type = $edit['type'];    }    else {      drupal_not_found();      return;    }  }  else {    $types = _profile_field_types();    if (!isset($types[$arg])) {      drupal_not_found();      return;    }    $type = $arg;    drupal_set_title(t('add new %type', array('%type' => $types[$type])));    $edit = array('name' => 'profile_');    $form['type'] = array('#type' => 'value', '#value' => $type);  }  $edit += array(    'category' => '',    'title' => '',    'explanation' => '',    'weight' => 0,    'page' => '',    'autocomplete' => '',    'required' => '',    'register' => '',  );  $form['fields'] = array('#type' => 'fieldset',    '#title' => t('Field settings'),  );  $form['fields']['category'] = array('#type' => 'textfield',    '#title' => t('Category'),    '#default_value' => $edit['category'],    '#autocomplete_path' => 'admin/user/profile/autocomplete',    '#description' => t('The category the new field should be part of. Categories are used to group fields logically. An example category is "Personal information".'),    '#required' => TRUE,  );  $form['fields']['title'] = array('#type' => 'textfield',    '#title' => t('Title'),    '#default_value' => $edit['title'],    '#description' => t('The title of the new field. The title will be shown to the user. An example title is "Favorite color".'),    '#required' => TRUE,  );  $form['fields']['name'] = array('#type' => 'textfield',    '#title' => t('Form name'),    '#default_value' => $edit['name'],    '#description' => t('The name of the field. The form name is not shown to the user but used internally in the HTML code and URLs.Unless you know what you are doing, it is highly recommended that you prefix the form name with <code>profile_</code> to avoid name clashes with other fields. Spaces or any other special characters except dash (-) and underscore (_) are not allowed. An example name is "profile_favorite_color" or perhaps just "profile_color".'),    '#required' => TRUE,  );  $form['fields']['explanation'] = array('#type' => 'textarea',    '#title' => t('Explanation'),    '#default_value' => $edit['explanation'],    '#description' => t('An optional explanation to go with the new field. The explanation will be shown to the user.'),  );  if ($type == 'selection') {    $form['fields']['options'] = array('#type' => 'textarea',      '#title' => t('Selection options'),      '#default_value' => isset($edit['options']) ? $edit['options'] : '',      '#description' => t('A list of all options. Put each option on a separate line. Example options are "red", "blue", "green", etc.'),    );  }  $form['fields']['visibility'] = array('#type' => 'radios',    '#title' => t('Visibility'),    '#default_value' => isset($edit['visibility']) ? $edit['visibility'] : PROFILE_PUBLIC,    '#options' => array(PROFILE_HIDDEN => t('Hidden profile field, only accessible by administrators, modules and themes.'), PROFILE_PRIVATE => t('Private field, content only available to privileged users.'), PROFILE_PUBLIC => t('Public field, content shown on profile page but not used on member list pages.'), PROFILE_PUBLIC_LISTINGS => t('Public field, content shown on profile page and on member list pages.')),  );  if ($type == 'selection' || $type == 'list' || $type == 'textfield') {    $form['fields']['page'] = array('#type' => 'textfield',      '#title' => t('Page title'),      '#default_value' => $edit['page'],      '#description' => t('To enable browsing this field by value, enter a title for the resulting page. The word <code>%value</code> will be substituted with the corresponding value. An example page title is "People whose favorite color is %value". This is only applicable for a public field.'),    );  }  else if ($type == 'checkbox') {    $form['fields']['page'] = array('#type' => 'textfield',      '#title' => t('Page title'),      '#default_value' => $edit['page'],      '#description' => t('To enable browsing this field by value, enter a title for the resulting page. An example page title is "People who are employed". This is only applicable for a public field.'),    );  }  $form['fields']['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('The weights define the order in which the form fields are shown. Lighter fields "float up" towards the top of the category.'),  );  $form['fields']['autocomplete'] = array('#type' => 'checkbox',    '#title' => t('Form will auto-complete while user is typing.'),    '#default_value' => $edit['autocomplete'],    '#description' => t('For security, auto-complete will be disabled if the user does not have access to user profiles.'),  );  $form['fields']['required'] = array('#type' => 'checkbox',    '#title' => t('The user must enter a value.'),    '#default_value' => $edit['required'],  );  $form['fields']['register'] = array('#type' => 'checkbox',    '#title' => t('Visible in user registration form.'),    '#default_value' => $edit['register'],  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Save field'),  );  return $form;}/** * Validate profile_field_form submissions. */function profile_field_form_validate($form, &$form_state) {  // Validate the 'field name':  if (preg_match('/[^a-zA-Z0-9_-]/', $form_state['values']['name'])) {    form_set_error('name', t('The specified form name contains one or more illegal characters. Spaces or any other special characters except dash (-) and underscore (_) are not allowed.'));  }  if (in_array($form_state['values']['name'], user_fields())) {    form_set_error('name', t('The specified form name is reserved for use by Drupal.'));  }  // Validate the category:  if (!$form_state['values']['category']) {    form_set_error('category', t('You must enter a category.'));  }  if (strtolower($form_state['values']['category']) == 'account') {    form_set_error('category', t('The specified category name is reserved for use by Drupal.'));  }  $args1 = array($form_state['values']['title'], $form_state['values']['category']);  $args2 = array($form_state['values']['name']);  $query_suffix = '';  if (isset($form_state['values']['fid'])) {    $args1[] = $args2[] = $form_state['values']['fid'];    $query_suffix = ' AND fid != %d';  }  if (db_result(db_query("SELECT fid FROM {profile_fields} WHERE title = '%s' AND category = '%s'". $query_suffix, $args1))) {    form_set_error('title', t('The specified title is already in use.'));  }  if (db_result(db_query("SELECT fid FROM {profile_fields} WHERE name = '%s'". $query_suffix, $args2))) {    form_set_error('name', t('The specified name is already in use.'));  }  if ($form_state['values']['visibility'] == PROFILE_HIDDEN) {    if ($form_state['values']['required']) {      form_set_error('required', t('A hidden field cannot be required.'));    }    if ($form_state['values']['register']) {      form_set_error('register', t('A hidden field cannot be set to visible on the user registration form.'));    }  }}/** * Process profile_field_form submissions. */function profile_field_form_submit($form, &$form_state) {  if (!isset($form_state['values']['options'])) {    $form_state['values']['options'] = '';  }  if (!isset($form_state['values']['page'])) {    $form_state['values']['page'] = '';  }  if (!isset($form_state['values']['fid'])) {    db_query("INSERT INTO {profile_fields} (title, name, explanation, category, type, weight, required, register, visibility, autocomplete, options, page) VALUES ('%s', '%s', '%s', '%s', '%s', %d, %d, %d, %d, %d, '%s', '%s')", $form_state['values']['title'], $form_state['values']['name'], $form_state['values']['explanation'], $form_state['values']['category'], $form_state['values']['type'], $form_state['values']['weight'], $form_state['values']['required'], $form_state['values']['register'], $form_state['values']['visibility'], $form_state['values']['autocomplete'], $form_state['values']['options'], $form_state['values']['page']);    drupal_set_message(t('The field has been created.'));    watchdog('profile', 'Profile field %field added under category %category.', array('%field' => $form_state['values']['title'], '%category' => $form_state['values']['category']), WATCHDOG_NOTICE, l(t('view'), 'admin/user/profile'));  }  else {    db_query("UPDATE {profile_fields} SET title = '%s', name = '%s', explanation = '%s', category = '%s', weight = %d, required = %d, register = %d, visibility = %d, autocomplete = %d, options = '%s', page = '%s' WHERE fid = %d", $form_state['values']['title'], $form_state['values']['name'], $form_state['values']['explanation'], $form_state['values']['category'], $form_state['values']['weight'], $form_state['values']['required'], $form_state['values']['register'], $form_state['values']['visibility'], $form_state['values']['autocomplete'], $form_state['values']['options'], $form_state['values']['page'], $form_state['values']['fid']);    drupal_set_message(t('The field has been updated.'));  }  cache_clear_all();  menu_rebuild();  $form_state['redirect'] = 'admin/user/profile';  return;}/** * Menu callback; deletes a field from all user profiles. */function profile_field_delete(&$form_state, $fid) {  $field = db_fetch_object(db_query("SELECT title FROM {profile_fields} WHERE fid = %d", $fid));  if (!$field) {    drupal_not_found();    return;  }  $form['fid'] = array('#type' => 'value', '#value' => $fid);  $form['title'] = array('#type' => 'value', '#value' => $field->title);  return confirm_form($form,    t('Are you sure you want to delete the field %field?', array('%field' => $field->title)), 'admin/user/profile',    t('This action cannot be undone. If users have entered values into this field in their profile, these entries will also be deleted. If you want to keep the user-entered data, instead of deleting the field you may wish to <a href="@edit-field">edit this field</a> and change it to a hidden profile field so that it may only be accessed by administrators.', array('@edit-field' => url('admin/user/profile/edit/'. $fid))),    t('Delete'), t('Cancel'));}/** * Process a field delete form submission. */function profile_field_delete_submit($form, &$form_state) {  db_query('DELETE FROM {profile_fields} WHERE fid = %d', $form_state['values']['fid']);  db_query('DELETE FROM {profile_values} WHERE fid = %d', $form_state['values']['fid']);  cache_clear_all();  drupal_set_message(t('The field %field has been deleted.', array('%field' => $form_state['values']['title'])));  watchdog('profile', 'Profile field %field deleted.', array('%field' => $form_state['values']['title']), WATCHDOG_NOTICE, l(t('view'), 'admin/user/profile'));  $form_state['redirect'] = 'admin/user/profile';  return;}/** * Retrieve a pipe delimited string of autocomplete suggestions for profile categories */function profile_admin_settings_autocomplete($string) {  $matches = array();  $result = db_query_range("SELECT category FROM {profile_fields} WHERE LOWER(category) LIKE LOWER('%s%%')", $string, 0, 10);  while ($data = db_fetch_object($result)) {    $matches[$data->category] = check_plain($data->category);  }  drupal_json($matches);}
