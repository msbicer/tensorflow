<?php// $Id$/** * Implementation of hook_install(). */function forum_install() {  // Create tables.  drupal_install_schema('forum');  // Set the weight of the forum.module to 1 so it is loaded after the taxonomy.module.  db_query("UPDATE {system} SET weight = 1 WHERE name = 'forum'");}function forum_enable() {  if ($vocabulary = taxonomy_vocabulary_load(variable_get('forum_nav_vocabulary', 0))) {    // Existing install. Add back forum node type, if the forums    // vocabulary still exists. Keep all other node types intact there.    $vocabulary = (array) $vocabulary;    $vocabulary['nodes']['forum'] = 1;    taxonomy_save_vocabulary($vocabulary);  }  else {    // Create the forum vocabulary if it does not exist. Assign the vocabulary    // a low weight so it will appear first in forum topic create and edit    // forms.    $vocabulary = array(      'name' => t('Forums'),      'multiple' => 0,      'required' => 0,      'hierarchy' => 1,      'relations' => 0,      'module' => 'forum',      'weight' => -10,      'nodes' => array('forum' => 1),    );    taxonomy_save_vocabulary($vocabulary);    variable_set('forum_nav_vocabulary', $vocabulary['vid']);  }}/** * Implementation of hook_uninstall(). */function forum_uninstall() {  // Load the dependent Taxonomy module, in case it has been disabled.  drupal_load('module', 'taxonomy');  // Delete the vocabulary.  $vid = variable_get('forum_nav_vocabulary', '');  taxonomy_del_vocabulary($vid);  db_query('DROP TABLE {forum}');  variable_del('forum_containers');  variable_del('forum_nav_vocabulary');  variable_del('forum_hot_topic');  variable_del('forum_per_page');  variable_del('forum_order');  variable_del('forum_block_num_0');  variable_del('forum_block_num_1');}/** * Implementation of hook_schema(). */function forum_schema() {  $schema['forum'] = array(    'description' => 'Stores the relationship of nodes to forum terms.',    'fields' => array(      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid of the node.',      ),      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {node}.vid of the node.',      ),      'tid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {term_data}.tid of the forum term assigned to the node.',      ),    ),    'indexes' => array(      'nid' => array('nid'),      'tid' => array('tid')    ),    'primary key' => array('vid'),  );  return $schema;}/** * Create the forum vocabulary if does not exist. Assign the * vocabulary a low weight so it will appear first in forum topic * create and edit forms.  Do not just call forum_enable() because in * future versions it might do something different. */function forum_update_6000() {  $ret = array();  $vid = variable_get('forum_nav_vocabulary', 0);  $vocabularies = taxonomy_get_vocabularies();  if (!isset($vocabularies[$vid])) {    $vocabulary = array(      'name' => t('Forums'),      'multiple' => 0,      'required' => 0,      'hierarchy' => 1,      'relations' => 0,      'module' => 'forum',      'weight' => -10,      'nodes' => array('forum' => 1),    );    taxonomy_save_vocabulary($vocabulary);    variable_set('forum_nav_vocabulary', $vocabulary['vid']);  }  return $ret;}
<?php// $Id$/** * @file * User page callbacks for the profile module. *//** * Menu callback; display a list of user information. */function profile_browse() {  // Ensure that the path is converted to 3 levels always.  list(, $name, $value) = array_pad(explode('/', $_GET['q'], 3), 3, '');  $field = db_fetch_object(db_query("SELECT DISTINCT(fid), type, title, page, visibility FROM {profile_fields} WHERE name = '%s'", $name));  if ($name && $field->fid) {    // Only allow browsing of fields that have a page title set.    if (empty($field->page)) {      drupal_not_found();      return;    }    // Do not allow browsing of private and hidden fields by non-admins.    if (!user_access('administer users') && ($field->visibility == PROFILE_PRIVATE || $field->visibility == PROFILE_HIDDEN)) {      drupal_access_denied();      return;    }    // Compile a list of fields to show.    $fields = array();    $result = db_query('SELECT name, title, type, weight, page FROM {profile_fields} WHERE fid != %d AND visibility = %d ORDER BY weight', $field->fid, PROFILE_PUBLIC_LISTINGS);    while ($record = db_fetch_object($result)) {      $fields[] = $record;    }    // Determine what query to use:    $arguments = array($field->fid);    switch ($field->type) {      case 'checkbox':        $query = 'v.value = 1';        break;      case 'textfield':      case 'selection':        $query = "v.value = '%s'";        $arguments[] = $value;        break;      case 'list':        $query = "v.value LIKE '%%%s%%'";        $arguments[] = $value;        break;      default:        drupal_not_found();        return;    }    // Extract the affected users:    $result = pager_query("SELECT u.uid, u.access FROM {users} u INNER JOIN {profile_values} v ON u.uid = v.uid WHERE v.fid = %d AND $query AND u.access != 0 AND u.status != 0 ORDER BY u.access DESC", 20, 0, NULL, $arguments);    $content = '';    while ($account = db_fetch_object($result)) {      $account = user_load(array('uid' => $account->uid));      $profile = _profile_update_user_fields($fields, $account);      $content .= theme('profile_listing', $account, $profile);    }    $output = theme('profile_wrapper', $content);    $output .= theme('pager', NULL, 20);    if ($field->type == 'selection' || $field->type == 'list' || $field->type == 'textfield') {      $title = strtr(check_plain($field->page), array('%value' => theme('placeholder', $value)));    }    else {      $title = check_plain($field->page);    }    drupal_set_title($title);    return $output;  }  else if ($name && !$field->fid) {    drupal_not_found();  }  else {    // Compile a list of fields to show.    $fields = array();    $result = db_query('SELECT name, title, type, weight, page FROM {profile_fields} WHERE visibility = %d ORDER BY category, weight', PROFILE_PUBLIC_LISTINGS);    while ($record = db_fetch_object($result)) {      $fields[] = $record;    }    // Extract the affected users:    $result = pager_query('SELECT uid, access FROM {users} WHERE uid > 0 AND status != 0 AND access != 0 ORDER BY access DESC', 20, 0, NULL);    $content = '';    while ($account = db_fetch_object($result)) {      $account = user_load(array('uid' => $account->uid));      $profile = _profile_update_user_fields($fields, $account);      $content .= theme('profile_listing', $account, $profile);    }    $output = theme('profile_wrapper', $content);    $output .= theme('pager', NULL, 20);    drupal_set_title(t('User list'));    return $output;  }}/** * Callback to allow autocomplete of profile text fields. */function profile_autocomplete($field, $string) {  $matches = array();  if (db_result(db_query("SELECT COUNT(*) FROM {profile_fields} WHERE fid = %d AND autocomplete = 1", $field))) {    $result = db_query_range("SELECT value FROM {profile_values} WHERE fid = %d AND LOWER(value) LIKE LOWER('%s%%') GROUP BY value ORDER BY value ASC", $field, $string, 0, 10);    while ($data = db_fetch_object($result)) {      $matches[$data->value] = check_plain($data->value);    }  }  drupal_json($matches);}
<?php// $Id$/** * @file * Redirects logging messages to syslog. */if (defined('LOG_LOCAL0')) {  define('DEFAULT_SYSLOG_FACILITY', LOG_LOCAL0);}else {  define('DEFAULT_SYSLOG_FACILITY', LOG_USER);}/** * Implementation of hook_help(). */function syslog_help($path, $arg) {  switch ($path) {    case 'admin/help#syslog':      $output = '<p>'. t("The syslog module enables Drupal to send messages to the operating system's logging facility.") .'</p>';      $output .= '<p>'. t('Syslog is an operating system administrative logging tool, and provides valuable information for use in system management and security auditing. Most suited to medium and large sites, syslog provides filtering tools that allow messages to be routed by type and severity. On UNIX/Linux systems, the file /etc/syslog.conf defines this routing configuration; on Microsoft Windows, all messages are sent to the Event Log. For more information on syslog facilities, severity levels, and how to set up a syslog.conf file, see <a href="@syslog_conf">UNIX/Linux syslog.conf</a> and PHP\'s <a href="@php_openlog">openlog</a> and <a href="@php_syslog">syslog</a> functions.', array('@syslog_conf' => url('http://www.rt.com/man/syslog.5.html'), '@php_openlog' => url('http://www.php.net/manual/en/function.openlog.php'), '@php_syslog' => url('http://www.php.net/manual/en/function.syslog.php'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@syslog">Syslog module</a>.', array('@syslog' => 'http://drupal.org/handbook/modules/syslog')) .'</p>';      return $output;  }}function syslog_menu() {  $items['admin/settings/logging/syslog'] = array(    'title'          => 'Syslog',    'description'    => 'Settings for syslog logging. Syslog is an operating system administrative logging tool used in systems management and security auditing. Most suited to medium and large sites, syslog provides filtering tools that allow messages to be routed by type and severity.',    'page callback'  => 'drupal_get_form',    'page arguments' => array('syslog_admin_settings'),    'access arguments' => array('administer site configuration'),  );  return $items;}function syslog_admin_settings() {  $form['syslog_facility'] = array(    '#type'          => 'select',    '#title'         => t('Send events to this syslog facility'),    '#default_value' => variable_get('syslog_facility', DEFAULT_SYSLOG_FACILITY),    '#options'       => syslog_facility_list(),    '#description'   => t('Select the syslog facility code under which Drupal\'s messages should be sent. On UNIX/Linux systems, Drupal can flag its messages with the code LOG_LOCAL0 through LOG_LOCAL7; for Microsoft Windows, all messages are flagged with the code LOG_USER. Depending on the system configuration, syslog and other logging tools use this code to identify or filter Drupal messages from within the entire system log. For more information on syslog, see <a href="@syslog_help">Syslog help</a>.', array(      '@syslog_help' => url('admin/help/syslog'))),  );  return system_settings_form($form);}function syslog_facility_list() {  $facility_list = array(    LOG_USER   => t('LOG_USER - User level messages. Use this for Windows.'),  );  if (defined('LOG_LOCAL0')) {    $facility_list += array(      LOG_LOCAL0 => t('LOG_LOCAL0 - Local 0'),      LOG_LOCAL1 => t('LOG_LOCAL1 - Local 1'),      LOG_LOCAL2 => t('LOG_LOCAL2 - Local 2'),      LOG_LOCAL3 => t('LOG_LOCAL3 - Local 3'),      LOG_LOCAL4 => t('LOG_LOCAL4 - Local 4'),      LOG_LOCAL5 => t('LOG_LOCAL5 - Local 5'),      LOG_LOCAL6 => t('LOG_LOCAL6 - Local 6'),      LOG_LOCAL7 => t('LOG_LOCAL7 - Local 7'),    );  }  return $facility_list;}function syslog_watchdog($entry) {  static $log_init = FALSE;  if (!$log_init) {    $log_init = TRUE;    openlog('drupal', LOG_NDELAY, variable_get('syslog_facility', DEFAULT_SYSLOG_FACILITY));  }  syslog($entry['severity'], theme('syslog_format', $entry));}function syslog_theme() {  return array(    'syslog_format' => array(      'arguments' => array('entry' => NULL),    ),  );}/** * Format a system log entry. * * @ingroup themeable */function theme_syslog_format($entry) {  global $base_url;  $message  = $base_url;  $message .= '|'. $entry['timestamp'];  $message .= '|'. $entry['type'];  $message .= '|'. $entry['ip'];  $message .= '|'. $entry['request_uri'];  $message .= '|'. $entry['referer'];  $message .= '|'. $entry['user']->uid;  $message .= '|'. strip_tags($entry['link']);  $message .= '|'. strip_tags(is_null($entry['variables']) ? $entry['message'] : strtr($entry['message'], $entry['variables']));  return $message;}
<?php// $Id$/** * @file Batch processing API for processes to run in multiple HTTP requests. *//** * State-based dispatcher for the batch processing page. */function _batch_page() {  $batch =& batch_get();  // Retrieve the current state of batch from db.  if (isset($_REQUEST['id']) && $data = db_result(db_query("SELECT batch FROM {batch} WHERE bid = %d AND token = '%s'", $_REQUEST['id'], drupal_get_token($_REQUEST['id'])))) {    $batch = unserialize($data);  }  else {    return FALSE;  }  // Register database update for end of processing.  register_shutdown_function('_batch_shutdown');  $op = isset($_REQUEST['op']) ? $_REQUEST['op'] : '';  $output = NULL;  switch ($op) {    case 'start':      $output = _batch_start();      break;    case 'do':      // JS-version AJAX callback.      _batch_do();      break;    case 'do_nojs':      // Non-JS progress page.      $output = _batch_progress_page_nojs();      break;    case 'finished':      $output = _batch_finished();      break;  }  return $output;}/** * Initiate the batch processing */function _batch_start() {  // Choose between the JS and non-JS version.  // JS-enabled users are identified through the 'has_js' cookie set in drupal.js.  // If the user did not visit any JS enabled page during his browser session,  // he gets the non-JS version...  if (isset($_COOKIE['has_js']) && $_COOKIE['has_js']) {    return _batch_progress_page_js();  }  else {    return _batch_progress_page_nojs();  }}/** * Batch processing page with JavaScript support. */function _batch_progress_page_js() {  $batch = batch_get();  // The first batch set gets to set the page title  // and the initialization and error messages.  $current_set = _batch_current_set();  drupal_set_title($current_set['title']);  drupal_add_js('misc/progress.js', 'core', 'header', FALSE, FALSE);  $url = url($batch['url'], array('query' => array('id' => $batch['id'])));  $js_setting = array(    'batch' => array(      'errorMessage' => $current_set['error_message'] .'<br/>'. $batch['error_message'],      'initMessage' => $current_set['init_message'],      'uri' => $url,    ),  );  drupal_add_js($js_setting, 'setting');  drupal_add_js('misc/batch.js', 'core', 'header', FALSE, FALSE);  $output = '<div id="progress"></div>';  return $output;}/** * Do one pass of execution and inform back the browser about progression * (used for JavaScript-mode only). */function _batch_do() {  // HTTP POST required  if ($_SERVER['REQUEST_METHOD'] != 'POST') {    drupal_set_message(t('HTTP POST is required.'), 'error');    drupal_set_title(t('Error'));    return '';  }  // Perform actual processing.  list($percentage, $message) = _batch_process();  drupal_json(array('status' => TRUE, 'percentage' => $percentage, 'message' => $message));}/** * Batch processing page without JavaScript support. */function _batch_progress_page_nojs() {  $batch =& batch_get();  $current_set = _batch_current_set();  drupal_set_title($current_set['title']);  $new_op = 'do_nojs';  if (!isset($batch['running'])) {    // This is the first page so we return some output immediately.    $percentage = 0;    $message = $current_set['init_message'];    $batch['running'] = TRUE;  }  else {    // This is one of the later requests: do some processing first.    // Error handling: if PHP dies due to a fatal error (e.g. non-existant    // function), it will output whatever is in the output buffer,    // followed by the error message.    ob_start();    $fallback = $current_set['error_message'] .'<br/>'. $batch['error_message'];    $fallback = theme('maintenance_page', $fallback, FALSE, FALSE);    // We strip the end of the page using a marker in the template, so any    // additional HTML output by PHP shows up inside the page rather than    // below it. While this causes invalid HTML, the same would be true if    // we didn't, as content is not allowed to appear after </html> anyway.    list($fallback) = explode('<!--partial-->', $fallback);    print $fallback;    // Perform actual processing.    list($percentage, $message) = _batch_process($batch);    if ($percentage == 100) {      $new_op = 'finished';    }    // PHP did not die : remove the fallback output.    ob_end_clean();  }  $url = url($batch['url'], array('query' => array('id' => $batch['id'], 'op' => $new_op)));  drupal_set_html_head('<meta http-equiv="Refresh" content="0; URL='. $url .'">');  $output = theme('progress_bar', $percentage, $message);  return $output;}/** * Advance batch processing for 1 second (or process the whole batch if it * was not set for progressive execution - e.g forms submitted by drupal_execute). */function _batch_process() {  $batch =& batch_get();  $current_set =& _batch_current_set();  $set_changed = TRUE;  if ($batch['progressive']) {    timer_start('batch_processing');  }  while (!$current_set['success']) {    // If this is the first time we iterate this batch set in the current    // request, we check if it requires an additional file for functions    // definitions.    if ($set_changed && isset($current_set['file']) && is_file($current_set['file'])) {      include_once($current_set['file']);    }    $finished = 1;    $task_message = '';    if ((list($function, $args) = reset($current_set['operations'])) && function_exists($function)) {      // Build the 'context' array, execute the function call,      // and retrieve the user message.      $batch_context = array('sandbox' => &$current_set['sandbox'], 'results' => &$current_set['results'], 'finished' => &$finished, 'message' => &$task_message);      // Process the current operation.      call_user_func_array($function, array_merge($args, array(&$batch_context)));    }    if ($finished == 1) {      // Make sure this step isn't counted double when computing $current.      $finished = 0;      // Remove the operation and clear the sandbox.      array_shift($current_set['operations']);      $current_set['sandbox'] = array();    }    // If the batch set is completed, browse through the remaining sets,    // executing 'control sets' (stored form submit handlers) along the way -    // this might in turn insert new batch sets.    // Stop when we find a set that actually has operations.    $set_changed = FALSE;    $old_set = $current_set;    while (empty($current_set['operations']) && ($current_set['success'] = TRUE) && _batch_next_set()) {      $current_set =& _batch_current_set();      $set_changed = TRUE;    }    // At this point, either $current_set is a 'real' batch set (has operations),    // or all sets have been completed.    // If we're in progressive mode, stop after 1 second.    if ($batch['progressive'] && timer_read('batch_processing') > 1000) {      break;    }  }  if ($batch['progressive']) {    // Gather progress information.    // Reporting 100% progress will cause the whole batch to be considered    // processed. If processing was paused right after moving to a new set,    // we have to use the info from the new (unprocessed) one.    if ($set_changed && isset($current_set['operations'])) {      // Processing will continue with a fresh batch set.      $remaining = count($current_set['operations']);      $total = $current_set['total'];      $progress_message = $current_set['init_message'];      $task_message = '';    }    else {      $remaining = count($old_set['operations']);      $total = $old_set['total'];      $progress_message = $old_set['progress_message'];    }    $current    = $total - $remaining + $finished;    $percentage = $total ? floor($current / $total * 100) : 100;    $values = array(      '@remaining'  => $remaining,      '@total'      => $total,      '@current'    => floor($current),      '@percentage' => $percentage,      );    $message = strtr($progress_message, $values) .'<br/>';    $message .= $task_message ? $task_message : '&nbsp';    return array($percentage, $message);  }  else {    // If we're not in progressive mode, the whole batch has been processed by now.    return _batch_finished();  }}/** * Retrieve the batch set being currently processed. */function &_batch_current_set() {  $batch =& batch_get();  return $batch['sets'][$batch['current_set']];}/** * Move execution to the next batch set if any, executing the stored * form _submit handlers along the way (thus possibly inserting * additional batch sets). */function _batch_next_set() {  $batch =& batch_get();  if (isset($batch['sets'][$batch['current_set'] + 1])) {    $batch['current_set']++;    $current_set =& _batch_current_set();    if (isset($current_set['form_submit']) && ($function = $current_set['form_submit']) && function_exists($function)) {      // We use our stored copies of $form and $form_state, to account for      // possible alteration by the submit handlers.      $function($batch['form'], $batch['form_state']);    }    return TRUE;  }}/** * End the batch processing: * Call the 'finished' callbacks to allow custom handling of results, * and resolve page redirection. */function _batch_finished() {  $batch =& batch_get();  // Execute the 'finished' callbacks for each batch set.  foreach ($batch['sets'] as $key => $batch_set) {    if (isset($batch_set['finished'])) {      // Check if the set requires an additional file for functions definitions.      if (isset($batch_set['file']) && is_file($batch_set['file'])) {        include_once($batch_set['file']);      }      if (function_exists($batch_set['finished'])) {        $batch_set['finished']($batch_set['success'], $batch_set['results'], $batch_set['operations']);      }    }  }  // Cleanup the batch table and unset the global $batch variable.  if ($batch['progressive']) {    db_query("DELETE FROM {batch} WHERE bid = %d", $batch['id']);  }  $_batch = $batch;  $batch = NULL;  // Redirect if needed.  if ($_batch['progressive']) {    // Put back the 'destination' that was saved in batch_process().    if (isset($_batch['destination'])) {      $_REQUEST['destination'] = $_batch['destination'];    }    // Use $_batch['form_state']['redirect'], or $_batch['redirect'],    // or $_batch['source_page'].    if (isset($_batch['form_state']['redirect'])) {      $redirect = $_batch['form_state']['redirect'];    }    elseif (isset($_batch['redirect'])) {      $redirect = $_batch['redirect'];    }    else {      $redirect = $_batch['source_page'];    }    // Let drupal_redirect_form handle redirection logic.    $form = isset($batch['form']) ? $batch['form'] : array();    if (empty($_batch['form_state']['rebuild']) && empty($_batch['form_state']['storage'])) {      drupal_redirect_form($form, $redirect);    }    // We get here if $form['#redirect'] was FALSE, or if the form is a    // multi-step form. We save the final $form_state value to be retrieved    // by drupal_get_form, and we redirect to the originating page.    $_SESSION['batch_form_state'] = $_batch['form_state'];    drupal_goto($_batch['source_page']);  }}/** * Shutdown function: store the batch data for next request, * or clear the table if the batch is finished. */function _batch_shutdown() {  if ($batch = batch_get()) {    db_query("UPDATE {batch} SET batch = '%s' WHERE bid = %d", serialize($batch), $batch['id']);  }}
<?php// $Id$/** * @file * Admin page callbacks for the contact module. *//** * Categories/list tab. */function contact_admin_categories() {  $result = db_query('SELECT cid, category, recipients, selected FROM {contact} ORDER BY weight, category');  $rows = array();  while ($category = db_fetch_object($result)) {    $rows[] = array(check_plain($category->category), check_plain($category->recipients), ($category->selected ? t('Yes') : t('No')), l(t('edit'), 'admin/build/contact/edit/'. $category->cid), l(t('delete'), 'admin/build/contact/delete/'. $category->cid));  }  $header = array(t('Category'), t('Recipients'), t('Selected'), array('data' => t('Operations'), 'colspan' => 2));  return theme('table', $header, $rows);}/** * Category edit page. */function contact_admin_edit($form_state = array(), $op, $contact = NULL) {  if (empty($contact) || $op == 'add') {    $contact = array(      'category' => '',      'recipients' => '',      'reply' => '',      'weight' => 0,      'selected' => 0,      'cid' => NULL,    );  }  $form['contact_op'] = array('#type' => 'value', '#value' => $op);  $form['category'] = array('#type' => 'textfield',    '#title' => t('Category'),    '#maxlength' => 255,    '#default_value' => $contact['category'],    '#description' => t("Example: 'website feedback' or 'product information'."),    '#required' => TRUE,  );  $form['recipients'] = array('#type' => 'textarea',    '#title' => t('Recipients'),    '#default_value' => $contact['recipients'],    '#description' => t("Example: 'webmaster@example.com' or 'sales@example.com,support@example.com'. To specify multiple recipients, separate each e-mail address with a comma."),    '#required' => TRUE,  );  $form['reply'] = array('#type' => 'textarea',    '#title' => t('Auto-reply'),    '#default_value' => $contact['reply'],    '#description' => t('Optional auto-reply. Leave empty if you do not want to send the user an auto-reply message.'),  );  $form['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $contact['weight'],    '#description' => t('When listing categories, those with lighter (smaller) weights get listed before categories with heavier (larger) weights. Categories with equal weights are sorted alphabetically.'),  );  $form['selected'] = array('#type' => 'select',    '#title' => t('Selected'),    '#options' => array('0' => t('No'), '1' => t('Yes')),    '#default_value' => $contact['selected'],    '#description' => t('Set this to <em>Yes</em> if you would like this category to be selected by default.'),  );  $form['cid'] = array('#type' => 'value',    '#value' => $contact['cid'],  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Save'),  );  return $form;}/** * Validate the contact category edit page form submission. */function contact_admin_edit_validate($form, &$form_state) {  if (empty($form_state['values']['category'])) {    form_set_error('category', t('You must enter a category.'));  }  if (empty($form_state['values']['recipients'])) {    form_set_error('recipients', t('You must enter one or more recipients.'));  }  else {    $recipients = explode(',', $form_state['values']['recipients']);    foreach ($recipients as $recipient) {      if (!valid_email_address(trim($recipient))) {        form_set_error('recipients', t('%recipient is an invalid e-mail address.', array('%recipient' => $recipient)));      }    }  }}/** * Process the contact category edit page form submission. */function contact_admin_edit_submit($form, &$form_state) {  if ($form_state['values']['selected']) {    // Unselect all other contact categories.    db_query('UPDATE {contact} SET selected = 0');  }  $recipients = explode(',', $form_state['values']['recipients']);  foreach ($recipients as $key => $recipient) {    // E-mail address validation has already been done in _validate.    $recipients[$key] = trim($recipient);  }  $form_state['values']['recipients'] = implode(',', $recipients);  if (empty($form_state['values']['cid']) || $form_state['values']['contact_op'] == 'add') {    drupal_write_record('contact', $form_state['values']);    drupal_set_message(t('Category %category has been added.', array('%category' => $form_state['values']['category'])));    watchdog('mail', 'Contact form: category %category added.', array('%category' => $form_state['values']['category']), WATCHDOG_NOTICE, l(t('view'), 'admin/build/contact'));  }  else {    drupal_write_record('contact', $form_state['values'], 'cid');    drupal_set_message(t('Category %category has been updated.', array('%category' => $form_state['values']['category'])));    watchdog('mail', 'Contact form: category %category updated.', array('%category' => $form_state['values']['category']), WATCHDOG_NOTICE, l(t('view'), 'admin/build/contact'));  }  $form_state['redirect'] = 'admin/build/contact';  return;}/** * Category delete page. */function contact_admin_delete(&$form_state, $contact) {  $form['contact'] = array(    '#type' => 'value',    '#value' => $contact,  );  return confirm_form($form, t('Are you sure you want to delete %category?', array('%category' => $contact['category'])), 'admin/build/contact', t('This action cannot be undone.'), t('Delete'), t('Cancel'));}/** * Process category delete form submission. */function contact_admin_delete_submit($form, &$form_state) {  $contact = $form_state['values']['contact'];  db_query("DELETE FROM {contact} WHERE cid = %d", $contact['cid']);  drupal_set_message(t('Category %category has been deleted.', array('%category' => $contact['category'])));  watchdog('mail', 'Contact form: category %category deleted.', array('%category' => $contact['category']), WATCHDOG_NOTICE);  $form_state['redirect'] = 'admin/build/contact';  return;}function contact_admin_settings() {  $form['contact_form_information'] = array('#type' => 'textarea',    '#title' => t('Additional information'),    '#default_value' => variable_get('contact_form_information', t('You can leave a message using the contact form below.')),    '#description' => t('Information to show on the <a href="@form">contact page</a>. Can be anything from submission guidelines to your postal address or telephone number.', array('@form' => url('contact'))),  );  $form['contact_hourly_threshold'] = array('#type' => 'select',    '#title' => t('Hourly threshold'),    '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50)),    '#default_value' => variable_get('contact_hourly_threshold', 3),    '#description' => t('The maximum number of contact form submissions a user can perform per hour.'),  );  $form['contact_default_status'] = array(    '#type' => 'checkbox',    '#title' => t('Enable personal contact form by default'),    '#default_value' => variable_get('contact_default_status', 1),    '#description' => t('Default status of the personal contact form for new users.'),  );  return system_settings_form($form);}
<?php// $Id$/** * @file * Used to aggregate syndicated content (RSS, RDF, and Atom). *//** * Implementation of hook_help(). */function aggregator_help($path, $arg) {  switch ($path) {    case 'admin/help#aggregator':      $output = '<p>'. t('The aggregator is a powerful on-site syndicator and news reader that gathers fresh content from RSS-, RDF-, and Atom-based feeds made available across the web. Thousands of sites (particularly news sites and blogs) publish their latest headlines and posts in feeds, using a number of standardized XML-based formats. Formats supported by the aggregator include <a href="@rss">RSS</a>, <a href="@rdf">RDF</a>, and <a href="@atom">Atom</a>.', array('@rss' => 'http://cyber.law.harvard.edu/rss/', '@rdf' => 'http://www.w3.org/RDF/', '@atom' => 'http://www.atomenabled.org')) .'</p>';      $output .= '<p>'. t('Feeds contain feed items, or individual posts published by the site providing the feed. Feeds may be grouped in categories, generally by topic. Users view feed items in the <a href="@aggregator">main aggregator display</a> or by <a href="@aggregator-sources">their source</a>. Administrators can <a href="@feededit">add, edit and delete feeds</a> and choose how often to check each feed for newly updated items. The most recent items in either a feed or category can be displayed as a block through the <a href="@admin-block">blocks administration page</a>. A <a href="@aggregator-opml">machine-readable OPML file</a> of all feeds is available. A correctly configured <a href="@cron">cron maintenance task</a> is required to update feeds automatically.', array('@aggregator' => url('aggregator'), '@aggregator-sources' => url('aggregator/sources'), '@feededit' => url('admin/content/aggregator'), '@admin-block' => url('admin/build/block'), '@aggregator-opml' => url('aggregator/opml'), '@cron' => url('admin/reports/status'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@aggregator">Aggregator module</a>.', array('@aggregator' => 'http://drupal.org/handbook/modules/aggregator/')) .'</p>';      return $output;    case 'admin/content/aggregator':      $output = '<p>'. t('Thousands of sites (particularly news sites and blogs) publish their latest headlines and posts in feeds, using a number of standardized XML-based formats. Formats supported by the aggregator include <a href="@rss">RSS</a>, <a href="@rdf">RDF</a>, and <a href="@atom">Atom</a>.', array('@rss' => 'http://cyber.law.harvard.edu/rss/', '@rdf' => 'http://www.w3.org/RDF/', '@atom' => 'http://www.atomenabled.org')) .'</p>';      $output .= '<p>'. t('Current feeds are listed below, and <a href="@addfeed">new feeds may be added</a>. For each feed or feed category, the <em>latest items</em> block may be enabled at the <a href="@block">blocks administration page</a>.', array('@addfeed' => url('admin/content/aggregator/add/feed'), '@block' => url('admin/build/block'))) .'</p>';      return $output;    case 'admin/content/aggregator/add/feed':      return '<p>'. t('Add a feed in RSS, RDF or Atom format. A feed may only have one entry.') .'</p>';    case 'admin/content/aggregator/add/category':      return '<p>'. t('Categories allow feed items from different feeds to be grouped together. For example, several sport-related feeds may belong to a category named <em>Sports</em>. Feed items may be grouped automatically (by selecting a category when creating or editing a feed) or manually (via the <em>Categorize</em> page available from feed item listings). Each category provides its own feed page and block.') .'</p>';  }}/** * Implementation of hook_theme() */function aggregator_theme() {  return array(    'aggregator_wrapper' => array(      'arguments' => array('content' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-wrapper',    ),    'aggregator_categorize_items' => array(      'arguments' => array('form' => NULL),      'file' => 'aggregator.pages.inc',    ),    'aggregator_feed_source' => array(      'arguments' => array('feed' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-feed-source',    ),    'aggregator_block_item' => array(      'arguments' => array('item' => NULL, 'feed' => 0),    ),    'aggregator_summary_items' => array(      'arguments' => array('summary_items' => NULL, 'source' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-summary-items',    ),    'aggregator_summary_item' => array(      'arguments' => array('item' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-summary-item',    ),    'aggregator_item' => array(      'arguments' => array('item' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-item',    ),    'aggregator_page_opml' => array(      'arguments' => array('feeds' => NULL),      'file' => 'aggregator.pages.inc',    ),    'aggregator_page_rss' => array(      'arguments' => array('feeds' => NULL, 'category' => NULL),      'file' => 'aggregator.pages.inc',    ),  );}/** * Implementation of hook_menu(). */function aggregator_menu() {  $items['admin/content/aggregator'] = array(    'title' => 'Feed aggregator',    'description' => "Configure which content your site aggregates from other sites, how often it polls them, and how they're categorized.",    'page callback' => 'aggregator_admin_overview',    'access arguments' => array('administer news feeds'),    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/add/feed'] = array(    'title' => 'Add feed',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_feed'),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/aggregator',    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/add/category'] = array(    'title' => 'Add category',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_category'),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/aggregator',    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/remove/%aggregator_feed'] = array(    'title' => 'Remove items',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_admin_remove_feed', 4),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/update/%aggregator_feed'] = array(    'title' => 'Update items',    'page callback' => 'aggregator_admin_refresh_feed',    'page arguments' => array(4),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/aggregator/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_admin_settings'),    'type' => MENU_LOCAL_TASK,    'weight' => 10,    'access arguments' => array('administer news feeds'),    'file' => 'aggregator.admin.inc',  );  $items['aggregator'] = array(    'title' => 'Feed aggregator',    'page callback' => 'aggregator_page_last',    'access arguments' => array('access news feeds'),    'weight' => 5,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/sources'] = array(    'title' => 'Sources',    'page callback' => 'aggregator_page_sources',    'access arguments' => array('access news feeds'),    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories'] = array(    'title' => 'Categories',    'page callback' => 'aggregator_page_categories',    'access callback' => '_aggregator_has_categories',    'file' => 'aggregator.pages.inc',  );  $items['aggregator/rss'] = array(    'title' => 'RSS feed',    'page callback' => 'aggregator_page_rss',    'access arguments' => array('access news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/opml'] = array(    'title' => 'OPML feed',    'page callback' => 'aggregator_page_opml',    'access arguments' => array('access news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories/%aggregator_category'] = array(    'title callback' => '_aggregator_category_title',    'title arguments' => array(2),    'page callback' => 'aggregator_page_category',    'page arguments' => array(2),    'access callback' => 'user_access',    'access arguments' => array('access news feeds'),    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories/%aggregator_category/view'] = array(    'title' => 'View',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['aggregator/categories/%aggregator_category/categorize'] = array(    'title' => 'Categorize',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_page_category', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories/%aggregator_category/configure'] = array(    'title' => 'Configure',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_category', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'aggregator.admin.inc',  );  $items['aggregator/sources/%aggregator_feed'] = array(    'page callback' => 'aggregator_page_source',    'page arguments' => array(2),    'access arguments' => array('access news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/sources/%aggregator_feed/view'] = array(    'title' => 'View',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['aggregator/sources/%aggregator_feed/categorize'] = array(    'title' => 'Categorize',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_page_source', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/sources/%aggregator_feed/configure'] = array(    'title' => 'Configure',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_feed', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/edit/feed/%aggregator_feed'] = array(    'title' => 'Edit feed',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_feed', 5),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/edit/category/%aggregator_category'] = array(    'title' => 'Edit category',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_category', 5),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  return $items;}/** * Menu callback. * * @return *   An aggregator category title. */function _aggregator_category_title($category) {  return $category['title'];}/** * Implementation of hook_init(). */function aggregator_init() {  drupal_add_css(drupal_get_path('module', 'aggregator') .'/aggregator.css');}/** * Find out whether there are any aggregator categories. * * @return *   TRUE if there is at least one category and the user has access to them, FALSE otherwise. */function _aggregator_has_categories() {  return user_access('access news feeds') && db_result(db_query('SELECT COUNT(*) FROM {aggregator_category}'));}/** * Implementation of hook_perm(). */function aggregator_perm() {  return array('administer news feeds', 'access news feeds');}/** * Implementation of hook_cron(). * * Checks news feeds for updates once their refresh interval has elapsed. */function aggregator_cron() {  $result = db_query('SELECT * FROM {aggregator_feed} WHERE checked + refresh < %d', time());  while ($feed = db_fetch_array($result)) {    aggregator_refresh($feed);  }}/** * Implementation of hook_block(). * * Generates blocks for the latest news items in each category and feed. */function aggregator_block($op = 'list', $delta = 0, $edit = array()) {  if (user_access('access news feeds')) {    if ($op == 'list') {      $result = db_query('SELECT cid, title FROM {aggregator_category} ORDER BY title');      while ($category = db_fetch_object($result)) {        $block['category-'. $category->cid]['info'] = t('!title category latest items', array('!title' => $category->title));      }      $result = db_query('SELECT fid, title FROM {aggregator_feed} ORDER BY fid');      while ($feed = db_fetch_object($result)) {        $block['feed-'. $feed->fid]['info'] = t('!title feed latest items', array('!title' => $feed->title));      }    }    else if ($op == 'configure') {      list($type, $id) = explode('-', $delta);      if ($type == 'category') {        $value = db_result(db_query('SELECT block FROM {aggregator_category} WHERE cid = %d', $id));      }      else {        $value = db_result(db_query('SELECT block FROM {aggregator_feed} WHERE fid = %d', $id));      }      $form['block'] = array('#type' => 'select', '#title' => t('Number of news items in block'), '#default_value' => $value, '#options' => drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)));      return $form;    }    else if ($op == 'save') {      list($type, $id) = explode('-', $delta);      if ($type == 'category') {        $value = db_query('UPDATE {aggregator_category} SET block = %d WHERE cid = %d', $edit['block'], $id);      }      else {        $value = db_query('UPDATE {aggregator_feed} SET block = %d WHERE fid = %d', $edit['block'], $id);      }    }    else if ($op == 'view') {      list($type, $id) = explode('-', $delta);      switch ($type) {        case 'feed':          if ($feed = db_fetch_object(db_query('SELECT fid, title, block FROM {aggregator_feed} WHERE fid = %d', $id))) {            $block['subject'] = check_plain($feed->title);            $result = db_query_range('SELECT * FROM {aggregator_item} WHERE fid = %d ORDER BY timestamp DESC, iid DESC', $feed->fid, 0, $feed->block);            $read_more = theme('more_link', url('aggregator/sources/'. $feed->fid), t("View this feed's recent news."));          }          break;        case 'category':          if ($category = db_fetch_object(db_query('SELECT cid, title, block FROM {aggregator_category} WHERE cid = %d', $id))) {            $block['subject'] = check_plain($category->title);            $result = db_query_range('SELECT i.* FROM {aggregator_category_item} ci LEFT JOIN {aggregator_item} i ON ci.iid = i.iid WHERE ci.cid = %d ORDER BY i.timestamp DESC, i.iid DESC', $category->cid, 0, $category->block);            $read_more = theme('more_link', url('aggregator/categories/'. $category->cid), t("View this category's recent news."));          }          break;      }      $items = array();      while ($item = db_fetch_object($result)) {        $items[] = theme('aggregator_block_item', $item);      }      // Only display the block if there are items to show.      if (count($items) > 0) {        $block['content'] = theme('item_list', $items) . $read_more;      }    }    if (isset($block)) {      return $block;    }  }}/** * Add/edit/delete aggregator categories. * * @param $edit *   An associative array describing the category to be added/edited/deleted. */function aggregator_save_category($edit) {  $link_path = 'aggregator/categories/';  if (!empty($edit['cid'])) {    $link_path .= $edit['cid'];    if (!empty($edit['title'])) {      db_query("UPDATE {aggregator_category} SET title = '%s', description = '%s' WHERE cid = %d", $edit['title'], $edit['description'], $edit['cid']);      $op = 'update';    }    else {      db_query('DELETE FROM {aggregator_category} WHERE cid = %d', $edit['cid']);      // Make sure there is no active block for this category.      db_query("DELETE FROM {blocks} WHERE module = '%s' AND delta = '%s'", 'aggregator', 'category-' . $edit['cid']);      $edit['title'] = '';      $op = 'delete';    }  }  else if (!empty($edit['title'])) {    // A single unique id for bundles and feeds, to use in blocks    db_query("INSERT INTO {aggregator_category} (title, description, block) VALUES ('%s', '%s', 5)", $edit['title'], $edit['description']);    $link_path .= db_last_insert_id('aggregator_category', 'cid');    $op = 'insert';  }  if (isset($op)) {    menu_link_maintain('aggregator', $op, $link_path, $edit['title']);  }}/** * Add/edit/delete an aggregator feed. * * @param $edit *   An associative array describing the feed to be added/edited/deleted. */function aggregator_save_feed($edit) {  if (!empty($edit['fid'])) {    // An existing feed is being modified, delete the category listings.    db_query('DELETE FROM {aggregator_category_feed} WHERE fid = %d', $edit['fid']);  }  if (!empty($edit['fid']) && !empty($edit['title'])) {    db_query("UPDATE {aggregator_feed} SET title = '%s', url = '%s', refresh = %d WHERE fid = %d", $edit['title'], $edit['url'], $edit['refresh'], $edit['fid']);  }  else if (!empty($edit['fid'])) {    $items = array();    $result = db_query('SELECT iid FROM {aggregator_item} WHERE fid = %d', $edit['fid']);    while ($item = db_fetch_object($result)) {      $items[] = "iid = $item->iid";    }    if (!empty($items)) {      db_query('DELETE FROM {aggregator_category_item} WHERE '. implode(' OR ', $items));    }    db_query('DELETE FROM {aggregator_feed} WHERE fid = %d', $edit['fid']);    db_query('DELETE FROM {aggregator_item} WHERE fid = %d', $edit['fid']);    // Make sure there is no active block for this feed.    db_query("DELETE FROM {blocks} WHERE module = '%s' AND delta = '%s'", 'aggregator', 'feed-' . $edit['fid']);  }  else if (!empty($edit['title'])) {    db_query("INSERT INTO {aggregator_feed} (title, url, refresh, block, description, image) VALUES ('%s', '%s', %d, 5, '', '')", $edit['title'], $edit['url'], $edit['refresh']);    // A single unique id for bundles and feeds, to use in blocks.    $edit['fid'] = db_last_insert_id('aggregator_feed', 'fid');  }  if (!empty($edit['title'])) {    // The feed is being saved, save the categories as well.    if (!empty($edit['category'])) {      foreach ($edit['category'] as $cid => $value) {        if ($value) {          db_query('INSERT INTO {aggregator_category_feed} (fid, cid) VALUES (%d, %d)', $edit['fid'], $cid);        }      }    }  }}/** * Removes all items from a feed. * * @param $feed *   An associative array describing the feed to be cleared. */function aggregator_remove($feed) {  $result = db_query('SELECT iid FROM {aggregator_item} WHERE fid = %d', $feed['fid']);  while ($item = db_fetch_object($result)) {    $items[] = "iid = $item->iid";  }  if (!empty($items)) {    db_query('DELETE FROM {aggregator_category_item} WHERE '. implode(' OR ', $items));  }  db_query('DELETE FROM {aggregator_item} WHERE fid = %d', $feed['fid']);  db_query("UPDATE {aggregator_feed} SET checked = 0, etag = '', modified = 0 WHERE fid = %d", $feed['fid']);  drupal_set_message(t('The news items from %site have been removed.', array('%site' => $feed['title'])));}/** * Call-back function used by the XML parser. */function aggregator_element_start($parser, $name, $attributes) {  global $item, $element, $tag, $items, $channel;  switch ($name) {    case 'IMAGE':    case 'TEXTINPUT':    case 'CONTENT':    case 'SUMMARY':    case 'TAGLINE':    case 'SUBTITLE':    case 'LOGO':    case 'INFO':      $element = $name;      break;    case 'ID':      if ($element != 'ITEM') {        $element = $name;      }    case 'LINK':      if (!empty($attributes['REL']) && $attributes['REL'] == 'alternate') {        if ($element == 'ITEM') {          $items[$item]['LINK'] = $attributes['HREF'];        }        else {          $channel['LINK'] = $attributes['HREF'];        }      }      break;    case 'ITEM':      $element = $name;      $item += 1;      break;    case 'ENTRY':      $element = 'ITEM';      $item += 1;      break;  }  $tag = $name;}/** * Call-back function used by the XML parser. */function aggregator_element_end($parser, $name) {  global $element;  switch ($name) {    case 'IMAGE':    case 'TEXTINPUT':    case 'ITEM':    case 'ENTRY':    case 'CONTENT':    case 'INFO':      $element = '';      break;    case 'ID':      if ($element == 'ID') {        $element = '';      }  }}/** * Call-back function used by the XML parser. */function aggregator_element_data($parser, $data) {  global $channel, $element, $items, $item, $image, $tag;  $items += array($item => array());  switch ($element) {    case 'ITEM':      $items[$item] += array($tag => '');      $items[$item][$tag] .= $data;      break;    case 'IMAGE':    case 'LOGO':      $image += array($tag => '');      $image[$tag] .= $data;      break;    case 'LINK':      if ($data) {        $items[$item] += array($tag => '');        $items[$item][$tag] .= $data;      }      break;    case 'CONTENT':      $items[$item] += array('CONTENT' => '');      $items[$item]['CONTENT'] .= $data;      break;    case 'SUMMARY':      $items[$item] += array('SUMMARY' => '');      $items[$item]['SUMMARY'] .= $data;      break;    case 'TAGLINE':    case 'SUBTITLE':      $channel += array('DESCRIPTION' => '');      $channel['DESCRIPTION'] .= $data;      break;    case 'INFO':    case 'ID':    case 'TEXTINPUT':      // The sub-element is not supported. However, we must recognize      // it or its contents will end up in the item array.      break;    default:      $channel += array($tag => '');      $channel[$tag] .= $data;  }}/** * Checks a news feed for new items. * * @param $feed *   An associative array describing the feed to be refreshed. */function aggregator_refresh($feed) {  global $channel, $image;  // Generate conditional GET headers.  $headers = array();  if ($feed['etag']) {    $headers['If-None-Match'] = $feed['etag'];  }  if ($feed['modified']) {    $headers['If-Modified-Since'] = gmdate('D, d M Y H:i:s', $feed['modified']) .' GMT';  }  // Request feed.  $result = drupal_http_request($feed['url'], $headers);  // Process HTTP response code.  switch ($result->code) {    case 304:      db_query('UPDATE {aggregator_feed} SET checked = %d WHERE fid = %d', time(), $feed['fid']);      drupal_set_message(t('There is no new syndicated content from %site.', array('%site' => $feed['title'])));      break;    case 301:      $feed['url'] = $result->redirect_url;      watchdog('aggregator', 'Updated URL for feed %title to %url.', array('%title' => $feed['title'], '%url' => $feed['url']));      // Deliberate no break.    case 200:    case 302:    case 307:      // Filter the input data:      if (aggregator_parse_feed($result->data, $feed)) {        $modified = empty($result->headers['Last-Modified']) ? 0 : strtotime($result->headers['Last-Modified']);        // Prepare the channel data.        foreach ($channel as $key => $value) {          $channel[$key] = trim($value);        }        // Prepare the image data (if any).        foreach ($image as $key => $value) {          $image[$key] = trim($value);        }        if (!empty($image['LINK']) && !empty($image['URL']) && !empty($image['TITLE'])) {          // Note, we should really use theme_image() here but that only works with local images it won't work with images fetched with a URL unless PHP version > 5          $image = '<a href="'. check_url($image['LINK']) .'" class="feed-image"><img src="'. check_url($image['URL']) .'" alt="'. check_plain($image['TITLE']) .'" /></a>';        }        else {          $image = NULL;        }        $etag = empty($result->headers['ETag']) ? '' : $result->headers['ETag'];        // Update the feed data.        db_query("UPDATE {aggregator_feed} SET url = '%s', checked = %d, link = '%s', description = '%s', image = '%s', etag = '%s', modified = %d WHERE fid = %d", $feed['url'], time(), $channel['LINK'], $channel['DESCRIPTION'], $image, $etag, $modified, $feed['fid']);        // Clear the cache.        cache_clear_all();        watchdog('aggregator', 'There is new syndicated content from %site.', array('%site' => $feed['title']));        drupal_set_message(t('There is new syndicated content from %site.', array('%site' => $feed['title'])));        break;      }      $result->error = t('feed not parseable');      // Deliberate no break.    default:      watchdog('aggregator', 'The feed from %site seems to be broken, due to "%error".', array('%site' => $feed['title'], '%error' => $result->code .' '. $result->error), WATCHDOG_WARNING);      drupal_set_message(t('The feed from %site seems to be broken, because of error "%error".', array('%site' => $feed['title'], '%error' => $result->code .' '. $result->error)));  }}/** * Parse the W3C date/time format, a subset of ISO 8601. PHP date parsing * functions do not handle this format. * See http://www.w3.org/TR/NOTE-datetime for more information. * Originally from MagpieRSS (http://magpierss.sourceforge.net/). * * @param $date_str *   A string with a potentially W3C DTF date. * @return *   A timestamp if parsed successfully or FALSE if not. */function aggregator_parse_w3cdtf($date_str) {  if (preg_match('/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(:(\d{2}))?(?:([-+])(\d{2}):?(\d{2})|(Z))?/', $date_str, $match)) {    list($year, $month, $day, $hours, $minutes, $seconds) = array($match[1], $match[2], $match[3], $match[4], $match[5], $match[6]);    // calc epoch for current date assuming GMT    $epoch = gmmktime($hours, $minutes, $seconds, $month, $day, $year);    if ($match[10] != 'Z') { // Z is zulu time, aka GMT      list($tz_mod, $tz_hour, $tz_min) = array($match[8], $match[9], $match[10]);      // zero out the variables      if (!$tz_hour) {        $tz_hour = 0;      }      if (!$tz_min) {        $tz_min = 0;      }      $offset_secs = (($tz_hour * 60) + $tz_min) * 60;      // is timezone ahead of GMT?  then subtract offset      if ($tz_mod == '+') {        $offset_secs *= -1;      }      $epoch += $offset_secs;    }    return $epoch;  }  else {    return FALSE;  }}/** * Parse a feed and store its items. * * @param $data *   The feed data. * @param $feed *   An associative array describing the feed to be parsed. * @return *   0 on error, 1 otherwise. */function aggregator_parse_feed(&$data, $feed) {  global $items, $image, $channel;  // Unset the global variables before we use them:  unset($GLOBALS['element'], $GLOBALS['item'], $GLOBALS['tag']);  $items = array();  $image = array();  $channel = array();  // parse the data:  $xml_parser = drupal_xml_parser_create($data);  xml_set_element_handler($xml_parser, 'aggregator_element_start', 'aggregator_element_end');  xml_set_character_data_handler($xml_parser, 'aggregator_element_data');  if (!xml_parse($xml_parser, $data, 1)) {    watchdog('aggregator', 'The feed from %site seems to be broken, due to an error "%error" on line %line.', array('%site' => $feed['title'], '%error' => xml_error_string(xml_get_error_code($xml_parser)), '%line' => xml_get_current_line_number($xml_parser)), WATCHDOG_WARNING);    drupal_set_message(t('The feed from %site seems to be broken, because of error "%error" on line %line.', array('%site' => $feed['title'], '%error' => xml_error_string(xml_get_error_code($xml_parser)), '%line' => xml_get_current_line_number($xml_parser))), 'error');    return 0;  }  xml_parser_free($xml_parser);  // We reverse the array such that we store the first item last, and the last  // item first. In the database, the newest item should be at the top.  $items = array_reverse($items);  // Initialize variables.  $title = $link = $author = $description = $guid = NULL;  foreach ($items as $item) {    unset($title, $link, $author, $description, $guid);    // Prepare the item:    foreach ($item as $key => $value) {      $item[$key] = trim($value);    }    // Resolve the item's title. If no title is found, we use up to 40    // characters of the description ending at a word boundary but not    // splitting potential entities.    if (!empty($item['TITLE'])) {      $title = $item['TITLE'];    }    elseif (!empty($item['DESCRIPTION'])) {      $title = preg_replace('/^(.*)[^\w;&].*?$/', "\\1", truncate_utf8($item['DESCRIPTION'], 40));    }    else {      $title = '';    }    // Resolve the items link.    if (!empty($item['LINK'])) {      $link = $item['LINK'];    }    else {      $link = $feed['link'];    }    $guid = isset($item['GUID']) ? $item['GUID'] : '';    // Atom feeds have a CONTENT and/or SUMMARY tag instead of a DESCRIPTION tag.    if (!empty($item['CONTENT:ENCODED'])) {      $item['DESCRIPTION'] = $item['CONTENT:ENCODED'];    }    else if (!empty($item['SUMMARY'])) {      $item['DESCRIPTION'] = $item['SUMMARY'];    }    else if (!empty($item['CONTENT'])) {      $item['DESCRIPTION'] = $item['CONTENT'];    }    // Try to resolve and parse the item's publication date. If no date is    // found, we use the current date instead.    $date = 'now';    foreach (array('PUBDATE', 'DC:DATE', 'DCTERMS:ISSUED', 'DCTERMS:CREATED', 'DCTERMS:MODIFIED', 'ISSUED', 'CREATED', 'MODIFIED', 'PUBLISHED', 'UPDATED') as $key) {      if (!empty($item[$key])) {        $date = $item[$key];        break;      }    }    $timestamp = strtotime($date); // As of PHP 5.1.0, strtotime returns FALSE on failure instead of -1.    if ($timestamp <= 0) {      $timestamp = aggregator_parse_w3cdtf($date); // Returns FALSE on failure      if (!$timestamp) {        $timestamp = time(); // better than nothing      }    }    // Save this item. Try to avoid duplicate entries as much as possible. If    // we find a duplicate entry, we resolve it and pass along its ID is such    // that we can update it if needed.    if (!empty($guid)) {      $entry = db_fetch_object(db_query("SELECT iid FROM {aggregator_item} WHERE fid = %d AND guid = '%s'", $feed['fid'], $guid));    }    else if ($link && $link != $feed['link'] && $link != $feed['url']) {      $entry = db_fetch_object(db_query("SELECT iid FROM {aggregator_item} WHERE fid = %d AND link = '%s'", $feed['fid'], $link));    }    else {      $entry = db_fetch_object(db_query("SELECT iid FROM {aggregator_item} WHERE fid = %d AND title = '%s'", $feed['fid'], $title));    }    $item += array('AUTHOR' => '', 'DESCRIPTION' => '');    aggregator_save_item(array('iid' => (isset($entry->iid) ? $entry->iid:  ''), 'fid' => $feed['fid'], 'timestamp' => $timestamp, 'title' => $title, 'link' => $link, 'author' => $item['AUTHOR'], 'description' => $item['DESCRIPTION'], 'guid' => $guid));  }  // Remove all items that are older than flush item timer.  $age = time() - variable_get('aggregator_clear', 9676800);  $result = db_query('SELECT iid FROM {aggregator_item} WHERE fid = %d AND timestamp < %d', $feed['fid'], $age);  $items = array();  $num_rows = FALSE;  while ($item = db_fetch_object($result)) {    $items[] = $item->iid;    $num_rows = TRUE;  }  if ($num_rows) {    db_query('DELETE FROM {aggregator_category_item} WHERE iid IN ('. implode(', ', $items) .')');    db_query('DELETE FROM {aggregator_item} WHERE fid = %d AND timestamp < %d', $feed['fid'], $age);  }  return 1;}/** * Add/edit/delete an aggregator item. * * @param $edit *   An associative array describing the item to be added/edited/deleted. */function aggregator_save_item($edit) {  if ($edit['iid'] && $edit['title']) {    db_query("UPDATE {aggregator_item} SET title = '%s', link = '%s', author = '%s', description = '%s', guid = '%s', timestamp = %d WHERE iid = %d", $edit['title'], $edit['link'], $edit['author'], $edit['description'], $edit['guid'], $edit['timestamp'], $edit['iid']);  }  else if ($edit['iid']) {    db_query('DELETE FROM {aggregator_item} WHERE iid = %d', $edit['iid']);    db_query('DELETE FROM {aggregator_category_item} WHERE iid = %d', $edit['iid']);  }  else if ($edit['title'] && $edit['link']) {    db_query("INSERT INTO {aggregator_item} (fid, title, link, author, description, timestamp, guid) VALUES (%d, '%s', '%s', '%s', '%s', %d, '%s')", $edit['fid'], $edit['title'], $edit['link'], $edit['author'], $edit['description'], $edit['timestamp'], $edit['guid']);    $edit['iid'] = db_last_insert_id('aggregator_item', 'iid');    // file the items in the categories indicated by the feed    $categories = db_query('SELECT cid FROM {aggregator_category_feed} WHERE fid = %d', $edit['fid']);    while ($category = db_fetch_object($categories)) {      db_query('INSERT INTO {aggregator_category_item} (cid, iid) VALUES (%d, %d)', $category->cid, $edit['iid']);    }  }}/** * Load an aggregator feed. * * @param $fid *   The feed id. * @return *   An associative array describing the feed. */function aggregator_feed_load($fid) {  static $feeds;  if (!isset($feeds[$fid])) {    $feeds[$fid] = db_fetch_array(db_query('SELECT * FROM {aggregator_feed} WHERE fid = %d', $fid));  }  return $feeds[$fid];}/** * Load an aggregator category. * * @param $cid *   The category id. * @return *   An associative array describing the category. */function aggregator_category_load($cid) {  static $categories;  if (!isset($categories[$cid])) {    $categories[$cid] = db_fetch_array(db_query('SELECT * FROM {aggregator_category} WHERE cid = %d', $cid));  }  return $categories[$cid];}/** * Format an individual feed item for display in the block. * * @param $item *   The item to be displayed. * @param $feed *   Not used. * @return *   The item HTML. * @ingroup themeable */function theme_aggregator_block_item($item, $feed = 0) {  global $user;  $output = '';  if ($user->uid && module_exists('blog') && user_access('create blog entries')) {    if ($image = theme('image', 'misc/blog.png', t('blog it'), t('blog it'))) {      $output .= '<div class="icon">'. l($image, 'node/add/blog', array('attributes' => array('title' => t('Comment on this news item in your personal blog.'), 'class' => 'blog-it'), 'query' => "iid=$item->iid", 'html' => TRUE)) .'</div>';    }  }  // Display the external link to the item.  $output .= '<a href="'. check_url($item->link) .'">'. check_plain($item->title) ."</a>\n";  return $output;}/** * Safely render HTML content, as allowed. * * @param $value *   The content to be filtered. * @return *   The filtered content. */function aggregator_filter_xss($value) {  return filter_xss($value, preg_split('/\s+|<|>/', variable_get('aggregator_allowed_html_tags', '<a> <b> <br> <dd> <dl> <dt> <em> <i> <li> <ol> <p> <strong> <u> <ul>'), -1, PREG_SPLIT_NO_EMPTY));}/** * Helper function for drupal_map_assoc. * * @param $count *   Items count. * @return *   Plural-formatted "@count items" */function _aggregator_items($count) {  return format_plural($count, '1 item', '@count items');}
<?php// $Id$/** * @file * User page callback file for the user module. *//** * Menu callback; Retrieve a JSON object containing autocomplete suggestions for existing users. */function user_autocomplete($string = '') {  $matches = array();  if ($string) {    $result = db_query_range("SELECT name FROM {users} WHERE LOWER(name) LIKE LOWER('%s%%')", $string, 0, 10);    while ($user = db_fetch_object($result)) {      $matches[$user->name] = check_plain($user->name);    }  }  drupal_json($matches);}/** * Form builder; Request a password reset. * * @ingroup forms * @see user_pass_validate() * @see user_pass_submit() */function user_pass() {  $form['name'] = array(    '#type' => 'textfield',    '#title' => t('Username or e-mail address'),    '#size' => 60,    '#maxlength' => max(USERNAME_MAX_LENGTH, EMAIL_MAX_LENGTH),    '#required' => TRUE,  );  $form['submit'] = array('#type' => 'submit', '#value' => t('E-mail new password'));  return $form;}function user_pass_validate($form, &$form_state) {  $name = trim($form_state['values']['name']);    // Blocked accounts cannot request a new password,  // check provided username and email against access rules.  if (drupal_is_denied('user', $name) || drupal_is_denied('mail', $name)) {    form_set_error('name', t('%name is not allowed to request a new password.', array('%name' => $name)));  }  // Try to load by email.  $account = user_load(array('mail' => $name, 'status' => 1));  if (!$account) {    // No success, try to load by name.    $account = user_load(array('name' => $name, 'status' => 1));  }  if (isset($account->uid)) {    form_set_value(array('#parents' => array('account')), $account, $form_state);  }  else {    form_set_error('name', t('Sorry, %name is not recognized as a user name or an e-mail address.', array('%name' => $name)));  }}function user_pass_submit($form, &$form_state) {  global $language;  $account = $form_state['values']['account'];  // Mail one time login URL and instructions using current language.  _user_mail_notify('password_reset', $account, $language);  watchdog('user', 'Password reset instructions mailed to %name at %email.', array('%name' => $account->name, '%email' => $account->mail));  drupal_set_message(t('Further instructions have been sent to your e-mail address.'));  $form_state['redirect'] = 'user';  return;}/** * Menu callback; process one time login link and redirects to the user page on success. */function user_pass_reset(&$form_state, $uid, $timestamp, $hashed_pass, $action = NULL) {  global $user;  // Check if the user is already logged in. The back button is often the culprit here.  if ($user->uid) {    drupal_set_message(t('You have already used this one-time login link. It is not necessary to use this link to login anymore. You are already logged in.'));    drupal_goto();  }  else {    // Time out, in seconds, until login URL expires. 24 hours = 86400 seconds.    $timeout = 86400;    $current = time();    // Some redundant checks for extra security ?    if ($timestamp < $current && $account = user_load(array('uid' => $uid, 'status' => 1)) ) {      // Deny one-time login to blocked accounts.      if (drupal_is_denied('user', $account->name) || drupal_is_denied('mail', $account->mail)) {        drupal_set_message(t('You have tried to use a one-time login for an account which has been blocked.'), 'error');        drupal_goto();      }      // No time out for first time login.      if ($account->login && $current - $timestamp > $timeout) {        drupal_set_message(t('You have tried to use a one-time login link that has expired. Please request a new one using the form below.'));        drupal_goto('user/password');      }      else if ($account->uid && $timestamp > $account->login && $timestamp < $current && $hashed_pass == user_pass_rehash($account->pass, $timestamp, $account->login)) {        // First stage is a confirmation form, then login        if ($action == 'login') {          watchdog('user', 'User %name used one-time login link at time %timestamp.', array('%name' => $account->name, '%timestamp' => $timestamp));          // Set the new user.          $user = $account;          // user_authenticate_finalize() also updates the login timestamp of the          // user, which invalidates further use of the one-time login link.          user_authenticate_finalize($form_state['values']);          drupal_set_message(t('You have just used your one-time login link. It is no longer necessary to use this link to login. Please change your password.'));          drupal_goto('user/'. $user->uid .'/edit');        }        else {          $form['message'] = array('#value' => t('<p>This is a one-time login for %user_name and will expire on %expiration_date.</p><p>Click on this button to login to the site and change your password.</p>', array('%user_name' => $account->name, '%expiration_date' => format_date($timestamp + $timeout))));          $form['help'] = array('#value' => '<p>'. t('This login can be used only once.') .'</p>');          $form['submit'] = array('#type' => 'submit', '#value' => t('Log in'));          $form['#action'] = url("user/reset/$uid/$timestamp/$hashed_pass/login");          return $form;        }      }      else {        drupal_set_message(t('You have tried to use a one-time login link which has either been used or is no longer valid. Please request a new one using the form below.'));        drupal_goto('user/password');      }    }    else {      // Deny access, no more clues.      // Everything will be in the watchdog's URL for the administrator to check.      drupal_access_denied();    }  }}/** * Menu callback; logs the current user out, and redirects to the home page. */function user_logout() {  global $user;  watchdog('user', 'Session closed for %name.', array('%name' => $user->name));  // Destroy the current session:  session_destroy();  // Only variables can be passed by reference workaround.  $null = NULL;  user_module_invoke('logout', $null, $user);  // Load the anonymous user  $user = drupal_anonymous_user();  drupal_goto();}/** * Menu callback; Displays a user or user profile page. */function user_view($account) {  drupal_set_title(check_plain($account->name));  // Retrieve all profile fields and attach to $account->content.  user_build_content($account);  // To theme user profiles, copy modules/user/user_profile.tpl.php  // to your theme directory, and edit it as instructed in that file's comments.  return theme('user_profile', $account);}/** * Process variables for user-profile.tpl.php. * * The $variables array contains the following arguments: * - $account * * @see user-picture.tpl.php */function template_preprocess_user_profile(&$variables) {  $variables['profile'] = array();  // Sort sections by weight  uasort($variables['account']->content, 'element_sort');  // Provide keyed variables so themers can print each section independantly.  foreach (element_children($variables['account']->content) as $key) {    $variables['profile'][$key] = drupal_render($variables['account']->content[$key]);  }  // Collect all profiles to make it easier to print all items at once.  $variables['user_profile'] = implode($variables['profile']);}/** * Process variables for user-profile-item.tpl.php. * * The $variables array contains the following arguments: * - $element * * @see user-profile-item.tpl.php */function template_preprocess_user_profile_item(&$variables) {  $variables['title'] = $variables['element']['#title'];  $variables['value'] = $variables['element']['#value'];  $variables['attributes'] = '';  if (isset($variables['element']['#attributes'])) {    $variables['attributes'] = drupal_attributes($variables['element']['#attributes']);  }}/** * Process variables for user-profile-category.tpl.php. * * The $variables array contains the following arguments: * - $element * * @see user-profile-category.tpl.php */function template_preprocess_user_profile_category(&$variables) {  $variables['title'] = check_plain($variables['element']['#title']);  $variables['profile_items'] = $variables['element']['#children'];  $variables['attributes'] = '';  if (isset($variables['element']['#attributes'])) {    $variables['attributes'] = drupal_attributes($variables['element']['#attributes']);  }}/** * Form builder; Present the form to edit a given user or profile category. * * @ingroup forms * @see user_edit_validate() * @see user_edit_submit() */function user_edit($account, $category = 'account') {  drupal_set_title(check_plain($account->name));  return drupal_get_form('user_profile_form', $account, $category);}/** * Form builder; edit a user account or one of their profile categories. * * @ingroup forms * @see user_profile_form_validate() * @see user_profile_form_submit() * @see user_edit_delete_submit() */function user_profile_form($form_state, $account, $category = 'account') {  $edit = (empty($form_state['values'])) ? (array)$account : $form_state['values'];  $form = _user_forms($edit, $account, $category);  $form['_category'] = array('#type' => 'value', '#value' => $category);  $form['_account'] = array('#type' => 'value', '#value' => $account);  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 30);  if (user_access('administer users')) {    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete'),      '#weight' => 31,      '#submit' => array('user_edit_delete_submit'),    );  }  $form['#attributes']['enctype'] = 'multipart/form-data';  return $form;}/** * Validation function for the user account and profile editing form. */function user_profile_form_validate($form, &$form_state) {  user_module_invoke('validate', $form_state['values'], $form_state['values']['_account'], $form_state['values']['_category']);  // Validate input to ensure that non-privileged users can't alter protected data.  if ((!user_access('administer users') && array_intersect(array_keys($form_state['values']), array('uid', 'init', 'session'))) || (!user_access('administer permissions') && isset($form_state['values']['roles']))) {    watchdog('security', 'Detected malicious attempt to alter protected user fields.', array(), WATCHDOG_WARNING);    // set this to a value type field    form_set_error('category', t('Detected malicious attempt to alter protected user fields.'));  }}/** * Submit function for the user account and profile editing form. */function user_profile_form_submit($form, &$form_state) {  $account = $form_state['values']['_account'];  $category = $form_state['values']['_category'];  unset($form_state['values']['_account'], $form_state['values']['op'], $form_state['values']['submit'], $form_state['values']['delete'], $form_state['values']['form_token'], $form_state['values']['form_id'], $form_state['values']['_category']);  user_module_invoke('submit', $form_state['values'], $account, $category);  user_save($account, $form_state['values'], $category);  // Clear the page cache because pages can contain usernames and/or profile information:  cache_clear_all();  drupal_set_message(t('The changes have been saved.'));  return;}/** * Submit function for the 'Delete' button on the user edit form. */function user_edit_delete_submit($form, &$form_state) {  $destination = '';  if (isset($_REQUEST['destination'])) {    $destination = drupal_get_destination();    unset($_REQUEST['destination']);  }  // Note: We redirect from user/uid/edit to user/uid/delete to make the tabs disappear.  $form_state['redirect'] = array("user/". $form_state['values']['_account']->uid ."/delete", $destination);}/** * Form builder; confirm form for user deletion. * * @ingroup forms * @see user_confirm_delete_submit() */function user_confirm_delete(&$form_state, $account) {  $form['_account'] = array('#type' => 'value', '#value' => $account);  return confirm_form($form,    t('Are you sure you want to delete the account %name?', array('%name' => $account->name)),    'user/'. $account->uid,    t('All submissions made by this user will be attributed to the anonymous account. This action cannot be undone.'),    t('Delete'), t('Cancel'));}/** * Submit function for the confirm form for user deletion. */function user_confirm_delete_submit($form, &$form_state) {  user_delete($form_state['values'], $form_state['values']['_account']->uid);  drupal_set_message(t('%name has been deleted.', array('%name' => $form_state['values']['_account']->name)));  if (!isset($_REQUEST['destination'])) {    $form_state['redirect'] = 'admin/user/user';  }}function user_edit_validate($form, &$form_state) {  user_module_invoke('validate', $form_state['values'], $form_state['values']['_account'], $form_state['values']['_category']);  // Validate input to ensure that non-privileged users can't alter protected data.  if ((!user_access('administer users') && array_intersect(array_keys($form_state['values']), array('uid', 'init', 'session'))) || (!user_access('administer permissions') && isset($form_state['values']['roles']))) {    watchdog('security', 'Detected malicious attempt to alter protected user fields.', array(), WATCHDOG_WARNING);    // set this to a value type field    form_set_error('category', t('Detected malicious attempt to alter protected user fields.'));  }}function user_edit_submit($form, &$form_state) {  $account = $form_state['values']['_account'];  $category = $form_state['values']['_category'];  unset($form_state['values']['_account'], $form_state['values']['op'], $form_state['values']['submit'], $form_state['values']['delete'], $form_state['values']['form_token'], $form_state['values']['form_id'], $form_state['values']['_category']);  user_module_invoke('submit', $form_state['values'], $account, $category);  user_save($account, $form_state['values'], $category);  // Clear the page cache because pages can contain usernames and/or profile information:  cache_clear_all();  drupal_set_message(t('The changes have been saved.'));  return;}/** * Access callback for path /user. * * Displays user profile if user is logged in, or login form for anonymous * users. */function user_page() {  global $user;  if ($user->uid) {    menu_set_active_item('user/'. $user->uid);    return menu_execute_active_handler();  }  else {    return drupal_get_form('user_login');  }}
<?php// $Id$/** * Implementation of hook_help(). */function color_help($path, $arg) {  switch ($path) {    case 'admin/help#color':      $output = '<p>'. t('The color module allows a site administrator to quickly and easily change the color scheme of certain themes. Although not all themes support color module, both Garland (the default theme) and Minnelli were designed to take advantage of its features. By using color module with a compatible theme, you can easily change the color of links, backgrounds, text, and other theme elements. Color module requires that your <a href="@url">file download method</a> be set to public.', array('@url' => url('admin/settings/file-system'))) .'</p>';      $output .= '<p>'. t("It is important to remember that color module saves a modified copy of the theme's specified stylesheets in the files directory. This means that if you make any manual changes to your theme's stylesheet, you must save your color settings again, even if they haven't changed. This causes the color module generated version of the stylesheets in the files directory to be recreated using the new version of the original file.") .'</p>';      $output .= '<p>'. t('To change the color settings for a compatible theme, select the "configure" link for the theme on the <a href="@themes">themes administration page</a>.', array('@themes' => url('admin/build/themes'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@color">Color module</a>.', array('@color' => 'http://drupal.org/handbook/modules/color/')) .'</p>';      return $output;  }}/** * Implementation of hook_theme(). */function color_theme() {  return array(    'color_scheme_form' => array(      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_form_alter(). */function color_form_alter(&$form, $form_state, $form_id) {  // Insert the color changer into the theme settings page.  if ($form_id == 'system_theme_settings' && color_get_info(arg(4)) && function_exists('gd_info')) {    if (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) != FILE_DOWNLOADS_PUBLIC) {      // Disables the color changer when the private download method is used.      // TODO: This should be solved in a different way. See issue #181003.      drupal_set_message(t('The color picker only works if the <a href="@url">download method</a> is set to public.', array('@url' => url('admin/settings/file-system'))), 'warning');    }    else {      $form['color'] = array(        '#type' => 'fieldset',        '#title' => t('Color scheme'),        '#weight' => -1,        '#attributes' => array('id' => 'color_scheme_form'),        '#theme' => 'color_scheme_form',      );      $form['color'] += color_scheme_form($form_state, arg(4));      $form['#submit'][] = 'color_scheme_form_submit';    }  }  // Use the generated screenshot in the theme list.  if ($form_id == 'system_theme_select_form' || $form_id == 'system_themes') {    $themes = list_themes();    foreach (element_children($form) as $theme) {      if ($screenshot = variable_get('color_'. $theme .'_screenshot', NULL)) {        if (isset($form[$theme]['screenshot'])) {          $form[$theme]['screenshot']['#value'] = theme('image', $screenshot, '', '', array('class' => 'screenshot'), FALSE);        }      }    }  }}/** * Callback for the theme to alter the resources used. */function _color_page_alter(&$vars) {  global $language, $theme_key;  // Override stylesheets.  $color_paths = variable_get('color_'. $theme_key .'_stylesheets', array());  if (!empty($color_paths)) {    // Loop over theme CSS files and try to rebuild CSS array with rewritten    // stylesheets. Keep the orginal order intact for CSS cascading.    $new_theme_css = array();    foreach ($vars['css']['all']['theme'] as $old_path => $old_preprocess) {      // Add the non-colored stylesheet first as we might not find a      // re-colored stylesheet for replacement later.      $new_theme_css[$old_path] = $old_preprocess;      // Loop over the path array with recolored CSS files to find matching      // paths which could replace the non-recolored paths.      foreach ($color_paths as $color_path) {        // Color module currently requires unique file names to be used,        // which allows us to compare different file paths.        if (basename($old_path) == basename($color_path)) {          // Pull out the non-colored and add rewritten stylesheet.          unset($new_theme_css[$old_path]);          $new_theme_css[$color_path] = $old_preprocess;          // If the current language is RTL and the CSS file had an RTL variant,          // pull out the non-colored and add rewritten RTL stylesheet.          if ($language->direction == LANGUAGE_RTL) {            $rtl_old_path = str_replace('.css', '-rtl.css', $old_path);            $rtl_color_path = str_replace('.css', '-rtl.css', $color_path);            if (file_exists($rtl_color_path)) {              unset($new_theme_css[$rtl_old_path]);              $new_theme_css[$rtl_color_path] = $old_preprocess;            }          }          break;        }      }    }    $vars['css']['all']['theme'] = $new_theme_css;    $vars['styles'] = drupal_get_css($vars['css']);  }  // Override logo.  $logo = variable_get('color_'. $theme_key .'_logo', NULL);  if ($logo && $vars['logo'] && preg_match('!'. $theme_key .'/logo.png$!', $vars['logo'])) {    $vars['logo'] = base_path() . $logo;  }}/** * Retrieve the color.module info for a particular theme. */function color_get_info($theme) {  $path = drupal_get_path('theme', $theme);  $file = $path .'/color/color.inc';  if ($path && file_exists($file)) {    include $file;    return $info;  }}/** * Helper function to retrieve the color palette for a particular theme. */function color_get_palette($theme, $default = false) {  // Fetch and expand default palette  $fields = array('base', 'link', 'top', 'bottom', 'text');  $info = color_get_info($theme);  $keys = array_keys($info['schemes']);  foreach (explode(',', array_shift($keys)) as $k => $scheme) {    $palette[$fields[$k]] = $scheme;  }  // Load variable  return $default ? $palette : variable_get('color_'. $theme .'_palette', $palette);}/** * Form callback. Returns the configuration form. */function color_scheme_form(&$form_state, $theme) {  $base = drupal_get_path('module', 'color');  $info = color_get_info($theme);  // Add Farbtastic color picker  drupal_add_css('misc/farbtastic/farbtastic.css', 'module', 'all', FALSE);  drupal_add_js('misc/farbtastic/farbtastic.js');  // Add custom CSS/JS  drupal_add_css($base .'/color.css', 'module', 'all', FALSE);  drupal_add_js($base .'/color.js');  drupal_add_js(array('color' => array(    'reference' => color_get_palette($theme, true)  )), 'setting');  // See if we're using a predefined scheme  $current = implode(',', variable_get('color_'. $theme .'_palette', array()));  // Note: we use the original theme when the default scheme is chosen.  $current = isset($info['schemes'][$current]) ? $current : ($current == '' ? reset($info['schemes']) : '');  // Add scheme selector  $info['schemes'][''] = t('Custom');  $form['scheme'] = array(    '#type' => 'select',    '#title' => t('Color set'),    '#options' => $info['schemes'],    '#default_value' => $current,  );  // Add palette fields  $palette = color_get_palette($theme);  $names = array(    'base' => t('Base color'),    'link' => t('Link color'),    'top' => t('Header top'),    'bottom' => t('Header bottom'),    'text' => t('Text color')  );  $form['palette']['#tree'] = true;  foreach ($palette as $name => $value) {    $form['palette'][$name] = array(      '#type' => 'textfield',      '#title' => $names[$name],      '#default_value' => $value,      '#size' => 8,    );  }  $form['theme'] = array('#type' => 'value', '#value' => arg(4));  $form['info'] = array('#type' => 'value', '#value' => $info);  return $form;}/** * Theme color form. * * @ingroup themeable */function theme_color_scheme_form($form) {  // Include stylesheet  $theme = $form['theme']['#value'];  $info = $form['info']['#value'];  $path = drupal_get_path('theme', $theme) .'/';  drupal_add_css($path . $info['preview_css']);  $output = '';  // Wrapper  $output .= '<div class="color-form clear-block">';  // Color schemes  $output .= drupal_render($form['scheme']);  // Palette  $output .= '<div id="palette" class="clear-block">';  foreach (element_children($form['palette']) as $name) {    $output .= drupal_render($form['palette'][$name]);  }  $output .= '</div>';  // Preview  $output .= drupal_render($form);  $output .= '<h2>'. t('Preview') .'</h2>';  $output .= '<div id="preview"><div id="text"><h2>Lorem ipsum dolor</h2><p>Sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud <a href="#">exercitation ullamco</a> laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p></div><div id="img" style="background-image: url('. base_path() . $path . $info['preview_image'] .')"></div></div>';  // Close wrapper  $output .= '</div>';  return $output;}/** * Submit handler for color change form. */function color_scheme_form_submit($form, &$form_state) {  // Get theme coloring info  if (!isset($form_state['values']['info'])) {    return;  }  $theme = $form_state['values']['theme'];  $info = $form_state['values']['info'];  // Resolve palette  $palette = $form_state['values']['palette'];  if ($form_state['values']['scheme'] != '') {    $scheme = explode(',', $form_state['values']['scheme']);    foreach ($palette as $k => $color) {      $palette[$k] = array_shift($scheme);    }  }  // Make sure enough memory is available, if PHP's memory limit is compiled in.  if (function_exists('memory_get_usage')) {    // Fetch source image dimensions.    $source = drupal_get_path('theme', $theme) .'/'. $info['base_image'];    list($width, $height) = getimagesize($source);    // We need at least a copy of the source and a target buffer of the same    // size (both at 32bpp).    $required = $width * $height * 8;    $usage = memory_get_usage();    $limit = parse_size(ini_get('memory_limit'));    if ($usage + $required > $limit) {      drupal_set_message(t('There is not enough memory available to PHP to change this theme\'s color scheme. You need at least %size more. Check the <a href="@url">PHP documentation</a> for more information.', array('%size' => format_size($usage + $required - $limit), '@url' => 'http://www.php.net/manual/en/ini.core.php#ini.sect.resource-limits')), 'error');      return;    }  }  // Delete old files  foreach (variable_get('color_'. $theme .'_files', array()) as $file) {    @unlink($file);  }  if (isset($file) && $file = dirname($file)) {    @rmdir($file);  }  // Don't render the default colorscheme, use the standard theme instead.  if (implode(',', color_get_palette($theme, true)) == implode(',', $palette)    || $form_state['values']['op'] == t('Reset to defaults')) {    variable_del('color_'. $theme .'_palette');    variable_del('color_'. $theme .'_stylesheets');    variable_del('color_'. $theme .'_logo');    variable_del('color_'. $theme .'_files');    variable_del('color_'. $theme .'_screenshot');    return;  }  // Prepare target locations for generated files.  $id = $theme .'-'. substr(md5(serialize($palette) . microtime()), 0, 8);  $paths['color'] = file_directory_path() .'/color';  $paths['target'] = $paths['color'] .'/'. $id;  foreach ($paths as $path) {    file_check_directory($path, FILE_CREATE_DIRECTORY);  }  $paths['target'] = $paths['target'] .'/';  $paths['id'] = $id;  $paths['source'] = drupal_get_path('theme', $theme) .'/';  $paths['files'] = $paths['map'] = array();  // Save palette and logo location.  variable_set('color_'. $theme .'_palette', $palette);  variable_set('color_'. $theme .'_logo', $paths['target'] .'logo.png');  // Copy over neutral images.  foreach ($info['copy'] as $file) {    $base = basename($file);    $source = $paths['source'] . $file;    file_copy($source, $paths['target'] . $base);    $paths['map'][$file] = $base;    $paths['files'][] = $paths['target'] . $base;  }  // Render new images, if image provided.  if ($info['base_image']) {    _color_render_images($theme, $info, $paths, $palette);  }  // Rewrite theme stylesheets.  $css = array();  foreach ($info['css'] as $stylesheet) {    // Build a temporary array with LTR and RTL files.    $files = array();    if (file_exists($paths['source'] . $stylesheet)) {      $files[] = $stylesheet;      $rtl_file = str_replace('.css', '-rtl.css', $stylesheet);      if (file_exists($paths['source'] . $rtl_file)) {        $files[] = $rtl_file;      }    }    foreach ($files as $file) {      // Aggregate @imports recursively for each configured top level CSS file      // without optimization. Aggregation and optimization will be      // handled by drupal_build_css_cache() only.      $style = drupal_load_stylesheet($paths['source'] . $file, FALSE);      // Return the path to where this CSS file originated from, stripping      // off the name of the file at the end of the path.      $base = base_path() . dirname($paths['source'] . $file) .'/';      _drupal_build_css_path(NULL, $base);      // Prefix all paths within this CSS file, ignoring absolute paths.      $style = preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $style);      // Rewrite stylesheet with new colors.      $style = _color_rewrite_stylesheet($theme, $info, $paths, $palette, $style);      $base_file = basename($file);      $css[] = $paths['target'] . $base_file;      _color_save_stylesheet($paths['target'] . $base_file, $style, $paths);    }  }  // Maintain list of files.  variable_set('color_'. $theme .'_stylesheets', $css);  variable_set('color_'. $theme .'_files', $paths['files']);}/** * Rewrite the stylesheet to match the colors in the palette. */function _color_rewrite_stylesheet($theme, &$info, &$paths, $palette, $style) {  $themes = list_themes();  // Prepare color conversion table  $conversion = $palette;  unset($conversion['base']);  foreach ($conversion as $k => $v) {    $conversion[$k] = drupal_strtolower($v);  }  $default = color_get_palette($theme, true);  // Split off the "Don't touch" section of the stylesheet.  $split = "Color Module: Don't touch";  if (strpos($style, $split) !== FALSE) {    list($style, $fixed) = explode($split, $style);  }  // Find all colors in the stylesheet and the chunks in between.  $style = preg_split('/(#[0-9a-f]{6}|#[0-9a-f]{3})/i', $style, -1, PREG_SPLIT_DELIM_CAPTURE);  $is_color = false;  $output = '';  $base = 'base';  // Iterate over all parts.  foreach ($style as $chunk) {    if ($is_color) {      $chunk = drupal_strtolower($chunk);      // Check if this is one of the colors in the default palette.      if ($key = array_search($chunk, $default)) {        $chunk = $conversion[$key];      }      // Not a pre-set color. Extrapolate from the base.      else {        $chunk = _color_shift($palette[$base], $default[$base], $chunk, $info['blend_target']);      }    }    else {      // Determine the most suitable base color for the next color.      // 'a' declarations. Use link.      if (preg_match('@[^a-z0-9_-](a)[^a-z0-9_-][^/{]*{[^{]+$@i', $chunk)) {        $base = 'link';      }      // 'color:' styles. Use text.      else if (preg_match('/(?<!-)color[^{:]*:[^{#]*$/i', $chunk)) {        $base = 'text';      }      // Reset back to base.      else {        $base = 'base';      }    }    $output .= $chunk;    $is_color = !$is_color;  }  // Append fixed colors segment.  if (isset($fixed)) {    $output .= $fixed;  }  // Replace paths to images.  foreach ($paths['map'] as $before => $after) {    $before = base_path() . $paths['source'] . $before;    $before = preg_replace('`(^|/)(?!../)([^/]+)/../`', '$1', $before);    $output = str_replace($before, $after, $output);  }  return $output;}/** * Save the rewritten stylesheet to disk. */function _color_save_stylesheet($file, $style, &$paths) {  // Write new stylesheet.  file_save_data($style, $file, FILE_EXISTS_REPLACE);  $paths['files'][] = $file;  // Set standard file permissions for webserver-generated files.  @chmod($file, 0664);}/** * Render images that match a given palette. */function _color_render_images($theme, &$info, &$paths, $palette) {  // Prepare template image.  $source = $paths['source'] .'/'. $info['base_image'];  $source = imagecreatefrompng($source);  $width = imagesx($source);  $height = imagesy($source);  // Prepare target buffer.  $target = imagecreatetruecolor($width, $height);  imagealphablending($target, true);  // Fill regions of solid color.  foreach ($info['fill'] as $color => $fill) {    imagefilledrectangle($target, $fill[0], $fill[1], $fill[0] + $fill[2], $fill[1] + $fill[3], _color_gd($target, $palette[$color]));  }  // Render gradient.  for ($y = 0; $y < $info['gradient'][3]; ++$y) {    $color = _color_blend($target, $palette['top'], $palette['bottom'], $y / ($info['gradient'][3] - 1));    imagefilledrectangle($target, $info['gradient'][0], $info['gradient'][1] + $y, $info['gradient'][0] + $info['gradient'][2], $info['gradient'][1] + $y + 1, $color);  }  // Blend over template.  imagecopy($target, $source, 0, 0, 0, 0, $width, $height);  // Clean up template image.  imagedestroy($source);  // Cut out slices.  foreach ($info['slices'] as $file => $coord) {    list($x, $y, $width, $height) = $coord;    $base = basename($file);    $image = $paths['target'] . $base;    // Cut out slice.    if ($file == 'screenshot.png') {      $slice = imagecreatetruecolor(150, 90);      imagecopyresampled($slice, $target, 0, 0, $x, $y, 150, 90, $width, $height);      variable_set('color_'. $theme .'_screenshot', $image);    }    else {      $slice = imagecreatetruecolor($width, $height);      imagecopy($slice, $target, 0, 0, $x, $y, $width, $height);    }    // Save image.    imagepng($slice, $image);    imagedestroy($slice);    $paths['files'][] = $image;    // Set standard file permissions for webserver-generated files    @chmod(realpath($image), 0664);    // Build before/after map of image paths.    $paths['map'][$file] = $base;  }  // Clean up target buffer.  imagedestroy($target);}/** * Shift a given color, using a reference pair and a target blend color. * * Note: this function is significantly different from the JS version, as it * is written to match the blended images perfectly. * * Constraint: if (ref2 == target + (ref1 - target) * delta) for some fraction delta *              then (return == target + (given - target) * delta) * * Loose constraint: Preserve relative positions in saturation and luminance *                   space. */function _color_shift($given, $ref1, $ref2, $target) {  // We assume that ref2 is a blend of ref1 and target and find  // delta based on the length of the difference vectors:  // delta = 1 - |ref2 - ref1| / |white - ref1|  $target = _color_unpack($target, true);  $ref1 = _color_unpack($ref1, true);  $ref2 = _color_unpack($ref2, true);  $numerator = 0;  $denominator = 0;  for ($i = 0; $i < 3; ++$i) {    $numerator += ($ref2[$i] - $ref1[$i]) * ($ref2[$i] - $ref1[$i]);    $denominator += ($target[$i] - $ref1[$i]) * ($target[$i] - $ref1[$i]);  }  $delta = ($denominator > 0) ? (1 - sqrt($numerator / $denominator)) : 0;  // Calculate the color that ref2 would be if the assumption was true.  for ($i = 0; $i < 3; ++$i) {    $ref3[$i] = $target[$i] + ($ref1[$i] - $target[$i]) * $delta;  }  // If the assumption is not true, there is a difference between ref2 and ref3.  // We measure this in HSL space. Notation: x' = hsl(x).  $ref2 = _color_rgb2hsl($ref2);  $ref3 = _color_rgb2hsl($ref3);  for ($i = 0; $i < 3; ++$i) {    $shift[$i] = $ref2[$i] - $ref3[$i];  }  // Take the given color, and blend it towards the target.  $given = _color_unpack($given, true);  for ($i = 0; $i < 3; ++$i) {    $result[$i] = $target[$i] + ($given[$i] - $target[$i]) * $delta;  }  // Finally, we apply the extra shift in HSL space.  // Note: if ref2 is a pure blend of ref1 and target, then |shift| = 0.  $result = _color_rgb2hsl($result);  for ($i = 0; $i < 3; ++$i) {    $result[$i] = min(1, max(0, $result[$i] + $shift[$i]));  }  $result = _color_hsl2rgb($result);  // Return hex color.  return _color_pack($result, true);}/** * Convert a hex triplet into a GD color. */function _color_gd($img, $hex) {  $c = array_merge(array($img), _color_unpack($hex));  return call_user_func_array('imagecolorallocate', $c);}/** * Blend two hex colors and return the GD color. */function _color_blend($img, $hex1, $hex2, $alpha) {  $in1 = _color_unpack($hex1);  $in2 = _color_unpack($hex2);  $out = array($img);  for ($i = 0; $i < 3; ++$i) {    $out[] = $in1[$i] + ($in2[$i] - $in1[$i]) * $alpha;  }  return call_user_func_array('imagecolorallocate', $out);}/** * Convert a hex color into an RGB triplet. */function _color_unpack($hex, $normalize = false) {  if (strlen($hex) == 4) {    $hex = $hex[1] . $hex[1] . $hex[2] . $hex[2] . $hex[3] . $hex[3];  }  $c = hexdec($hex);  for ($i = 16; $i >= 0; $i -= 8) {    $out[] = (($c >> $i) & 0xFF) / ($normalize ? 255 : 1);  }  return $out;}/** * Convert an RGB triplet to a hex color. */function _color_pack($rgb, $normalize = false) {  $out = 0;  foreach ($rgb as $k => $v) {    $out |= (($v * ($normalize ? 255 : 1)) << (16 - $k * 8));  }  return '#'. str_pad(dechex($out), 6, 0, STR_PAD_LEFT);}/** * Convert a HSL triplet into RGB */function _color_hsl2rgb($hsl) {  $h = $hsl[0];  $s = $hsl[1];  $l = $hsl[2];  $m2 = ($l <= 0.5) ? $l * ($s + 1) : $l + $s - $l*$s;  $m1 = $l * 2 - $m2;  return array(    _color_hue2rgb($m1, $m2, $h + 0.33333),    _color_hue2rgb($m1, $m2, $h),    _color_hue2rgb($m1, $m2, $h - 0.33333),  );}/** * Helper function for _color_hsl2rgb(). */function _color_hue2rgb($m1, $m2, $h) {  $h = ($h < 0) ? $h + 1 : (($h > 1) ? $h - 1 : $h);  if ($h * 6 < 1) return $m1 + ($m2 - $m1) * $h * 6;  if ($h * 2 < 1) return $m2;  if ($h * 3 < 2) return $m1 + ($m2 - $m1) * (0.66666 - $h) * 6;  return $m1;}/** * Convert an RGB triplet to HSL. */function _color_rgb2hsl($rgb) {  $r = $rgb[0];  $g = $rgb[1];  $b = $rgb[2];  $min = min($r, min($g, $b));  $max = max($r, max($g, $b));  $delta = $max - $min;  $l = ($min + $max) / 2;  $s = 0;  if ($l > 0 && $l < 1) {    $s = $delta / ($l < 0.5 ? (2 * $l) : (2 - 2 * $l));  }  $h = 0;  if ($delta > 0) {    if ($max == $r && $max != $g) $h += ($g - $b) / $delta;    if ($max == $g && $max != $b) $h += (2 + ($b - $r) / $delta);    if ($max == $b && $max != $r) $h += (4 + ($r - $g) / $delta);    $h /= 6;  }  return array($h, $s, $l);}
<?php// $Id$/** * @file * Wrapper for database interface code. *//** * A hash value to check when outputting database errors, md5('DB_ERROR'). * * @see drupal_error_handler() */define('DB_ERROR', 'a515ac9c2796ca0e23adbe92c68fc9fc');/** * @defgroup database Database abstraction layer * @{ * Allow the use of different database servers using the same code base. * * Drupal provides a slim database abstraction layer to provide developers with * the ability to support multiple database servers easily. The intent of this * layer is to preserve the syntax and power of SQL as much as possible, while * letting Drupal control the pieces of queries that need to be written * differently for different servers and provide basic security checks. * * Most Drupal database queries are performed by a call to db_query() or * db_query_range(). Module authors should also consider using pager_query() for * queries that return results that need to be presented on multiple pages, and * tablesort_sql() for generating appropriate queries for sortable tables. * * For example, one might wish to return a list of the most recent 10 nodes * authored by a given user. Instead of directly issuing the SQL query * @code *   SELECT n.nid, n.title, n.created FROM node n WHERE n.uid = $uid LIMIT 0, 10; * @endcode * one would instead call the Drupal functions: * @code *   $result = db_query_range('SELECT n.nid, n.title, n.created *     FROM {node} n WHERE n.uid = %d', $uid, 0, 10); *   while ($node = db_fetch_object($result)) { *     // Perform operations on $node->body, etc. here. *   } * @endcode * Curly braces are used around "node" to provide table prefixing via * db_prefix_tables(). The explicit use of a user ID is pulled out into an * argument passed to db_query() so that SQL injection attacks from user input * can be caught and nullified. The LIMIT syntax varies between database servers, * so that is abstracted into db_query_range() arguments. Finally, note the * common pattern of iterating over the result set using db_fetch_object(). *//** * Perform an SQL query and return success or failure. * * @param $sql *   A string containing a complete SQL query.  %-substitution *   parameters are not supported. * @return *   An array containing the keys: *      success: a boolean indicating whether the query succeeded *      query: the SQL query executed, passed through check_plain() */function update_sql($sql) {  $result = db_query($sql, true);  return array('success' => $result !== FALSE, 'query' => check_plain($sql));}/** * Append a database prefix to all tables in a query. * * Queries sent to Drupal should wrap all table names in curly brackets. This * function searches for this syntax and adds Drupal's table prefix to all * tables, allowing Drupal to coexist with other systems in the same database if * necessary. * * @param $sql *   A string containing a partial or entire SQL query. * @return *   The properly-prefixed string. */function db_prefix_tables($sql) {  global $db_prefix;  if (is_array($db_prefix)) {    if (array_key_exists('default', $db_prefix)) {      $tmp = $db_prefix;      unset($tmp['default']);      foreach ($tmp as $key => $val) {        $sql = strtr($sql, array('{'. $key .'}' => $val . $key));      }      return strtr($sql, array('{' => $db_prefix['default'], '}' => ''));    }    else {      foreach ($db_prefix as $key => $val) {        $sql = strtr($sql, array('{'. $key .'}' => $val . $key));      }      return strtr($sql, array('{' => '', '}' => ''));    }  }  else {    return strtr($sql, array('{' => $db_prefix, '}' => ''));  }}/** * Activate a database for future queries. * * If it is necessary to use external databases in a project, this function can * be used to change where database queries are sent. If the database has not * yet been used, it is initialized using the URL specified for that name in * Drupal's configuration file. If this name is not defined, a duplicate of the * default connection is made instead. * * Be sure to change the connection back to the default when done with custom * code. * * @param $name *   The name assigned to the newly active database connection. If omitted, the *   default connection will be made active. * * @return the name of the previously active database or FALSE if non was found. */function db_set_active($name = 'default') {  global $db_url, $db_type, $active_db;  static $db_conns, $active_name = FALSE;  if (empty($db_url)) {    include_once 'includes/install.inc';    install_goto('install.php');  }  if (!isset($db_conns[$name])) {    // Initiate a new connection, using the named DB URL specified.    if (is_array($db_url)) {      $connect_url = array_key_exists($name, $db_url) ? $db_url[$name] : $db_url['default'];    }    else {      $connect_url = $db_url;    }    $db_type = substr($connect_url, 0, strpos($connect_url, '://'));    $handler = "./includes/database.$db_type.inc";    if (is_file($handler)) {      include_once $handler;    }    else {      _db_error_page("The database type '". $db_type ."' is unsupported. Please use either 'mysql' or 'mysqli' for MySQL, or 'pgsql' for PostgreSQL databases.");    }    $db_conns[$name] = db_connect($connect_url);  }  $previous_name = $active_name;  // Set the active connection.  $active_name = $name;  $active_db = $db_conns[$name];  return $previous_name;}/** * Helper function to show fatal database errors. * * Prints a themed maintenance page with the 'Site off-line' text, * adding the provided error message in the case of 'display_errors' * set to on. Ends the page request; no return. * * @param $error *   The error message to be appended if 'display_errors' is on. */function _db_error_page($error = '') {  global $db_type;  drupal_init_language();  drupal_maintenance_theme();  drupal_set_header('HTTP/1.1 503 Service Unavailable');  drupal_set_title('Site off-line');  $message = '<p>The site is currently not available due to technical problems. Please try again later. Thank you for your understanding.</p>';  $message .= '<hr /><p><small>If you are the maintainer of this site, please check your database settings in the <code>settings.php</code> file and ensure that your hosting provider\'s database server is running. For more help, see the <a href="http://drupal.org/node/258">handbook</a>, or contact your hosting provider.</small></p>';  if ($error && ini_get('display_errors')) {    $message .= '<p><small>The '. theme('placeholder', $db_type) .' error was: '. theme('placeholder', $error) .'.</small></p>';  }  print theme('maintenance_page', $message);  exit;}/** * Returns a boolean depending on the availability of the database. */function db_is_active() {  global $active_db;  return !empty($active_db);}/** * Helper function for db_query(). */function _db_query_callback($match, $init = FALSE) {  static $args = NULL;  if ($init) {    $args = $match;    return;  }  switch ($match[1]) {    case '%d': // We must use type casting to int to convert FALSE/NULL/(TRUE?)      $value = array_shift($args);      // Do we need special bigint handling?      if ($value > PHP_INT_MAX) {        $precision = ini_get('precision');        @ini_set('precision', 16);        $value = sprintf('%.0f', $value);        @ini_set('precision', $precision);      }      else {        $value = (int) $value;      }      // We don't need db_escape_string as numbers are db-safe.      return $value;    case '%s':      return db_escape_string(array_shift($args));    case '%n':      // Numeric values have arbitrary precision, so can't be treated as float.      // is_numeric() allows hex values (0xFF), but they are not valid.      $value = trim(array_shift($args));      return is_numeric($value) && !preg_match('/x/i', $value) ? $value : '0';    case '%%':      return '%';    case '%f':      return (float) array_shift($args);    case '%b': // binary data      return db_encode_blob(array_shift($args));  }}/** * Generate placeholders for an array of query arguments of a single type. * * Given a Schema API field type, return correct %-placeholders to * embed in a query * * @param $arguments *  An array with at least one element. * @param $type *   The Schema API type of a field (e.g. 'int', 'text', or 'varchar'). */function db_placeholders($arguments, $type = 'int') {  $placeholder = db_type_placeholder($type);  return implode(',', array_fill(0, count($arguments), $placeholder));}/** * Indicates the place holders that should be replaced in _db_query_callback(). */define('DB_QUERY_REGEXP', '/(%d|%s|%%|%f|%b|%n)/');/** * Helper function for db_rewrite_sql. * * Collects JOIN and WHERE statements via hook_db_rewrite_sql() * Decides whether to select primary_key or DISTINCT(primary_key) * * @param $query *   Query to be rewritten. * @param $primary_table *   Name or alias of the table which has the primary key field for this query. *   Typical table names would be: {blocks}, {comments}, {forum}, {node}, *   {menu}, {term_data} or {vocabulary}. However, in most cases the usual *   table alias (b, c, f, n, m, t or v) is used instead of the table name. * @param $primary_field *   Name of the primary field. * @param $args *   Array of additional arguments. * @return *   An array: join statements, where statements, field or DISTINCT(field). */function _db_rewrite_sql($query = '', $primary_table = 'n', $primary_field = 'nid', $args = array()) {  $where = array();  $join = array();  $distinct = FALSE;  foreach (module_implements('db_rewrite_sql') as $module) {    $result = module_invoke($module, 'db_rewrite_sql', $query, $primary_table, $primary_field, $args);    if (isset($result) && is_array($result)) {      if (isset($result['where'])) {        $where[] = $result['where'];      }      if (isset($result['join'])) {        $join[] = $result['join'];      }      if (isset($result['distinct']) && $result['distinct']) {        $distinct = TRUE;      }    }    elseif (isset($result)) {      $where[] = $result;    }  }  $where = empty($where) ? '' : '('. implode(') AND (', $where) .')';  $join = empty($join) ? '' : implode(' ', $join);  return array($join, $where, $distinct);}/** * Rewrites node, taxonomy and comment queries. Use it for listing queries. Do not * use FROM table1, table2 syntax, use JOIN instead. * * @param $query *   Query to be rewritten. * @param $primary_table *   Name or alias of the table which has the primary key field for this query. *   Typical table names would be: {blocks}, {comments}, {forum}, {node}, *   {menu}, {term_data} or {vocabulary}. However, it is more common to use the *   the usual table aliases: b, c, f, n, m, t or v. * @param $primary_field *   Name of the primary field. * @param $args *   An array of arguments, passed to the implementations of hook_db_rewrite_sql. * @return *   The original query with JOIN and WHERE statements inserted from *   hook_db_rewrite_sql implementations. nid is rewritten if needed. */function db_rewrite_sql($query, $primary_table = 'n', $primary_field = 'nid',  $args = array()) {  list($join, $where, $distinct) = _db_rewrite_sql($query, $primary_table, $primary_field, $args);  if ($distinct) {    $query = db_distinct_field($primary_table, $primary_field, $query);  }  if (!empty($where) || !empty($join)) {    $pattern = '{      # Beginning of the string      ^      ((?P<anonymous_view>        # Everything within this set of parentheses is named "anonymous view"        (?:          [^()]++                   # anything not parentheses        |          \( (?P>anonymous_view) \)          # an open parenthesis, more "anonymous view" and finally a close parenthesis.        )*      )[^()]+WHERE)    }x';    preg_match($pattern, $query, $matches);    if (!$where) {      $where = '1 = 1';    }    if ($matches) {      $n = strlen($matches[1]);      $second_part = substr($query, $n);      $first_part = substr($matches[1], 0, $n - 5) ." $join WHERE $where AND ( ";      // PHP 4 does not support strrpos for strings. We emulate it.      $haystack_reverse = strrev($second_part);    }    else {      $haystack_reverse = strrev($query);    }    // No need to use strrev on the needle, we supply GROUP, ORDER, LIMIT    // reversed.    foreach (array('PUORG', 'REDRO', 'TIMIL') as $needle_reverse) {      $pos = strpos($haystack_reverse, $needle_reverse);      if ($pos !== FALSE) {        // All needles are five characters long.        $pos += 5;        break;      }    }    if ($matches) {      if ($pos === FALSE) {        $query = $first_part . $second_part .')';      }      else {        $query = $first_part . substr($second_part, 0, -$pos) .')'. substr($second_part, -$pos);      }    }    elseif ($pos === FALSE) {      $query .= " $join WHERE $where";    }    else {      $query = substr($query, 0, -$pos) . " $join WHERE $where " . substr($query, -$pos);    }  }  return $query;}/** * Adds the DISTINCT flag to the supplied query if a DISTINCT doesn't already * exist in the query. Returns the altered query. * * This will not, and never did guarantee that you will obtain distinct  * values of $table.$field. * * @param $table Unused. Kept to remain API compatibility. * @param $field Unused. Kept to remain API compatibility. * @param $query Query to which the DISTINCT flag should be applied. * @return SQL query with the DISTINCT flag set. */function db_distinct_field($table, $field, $query) {  $matches = array();  if (!preg_match('/^SELECT\s*DISTINCT/i', $query, $matches)) {    // Only add distinct to the outer SELECT to avoid messing up subqueries.    $query = preg_replace('/^SELECT/i', 'SELECT DISTINCT', $query);  }  return $query;}/** * Restrict a dynamic table, column or constraint name to safe characters. * * Only keeps alphanumeric and underscores. */function db_escape_table($string) {  return preg_replace('/[^A-Za-z0-9_]+/', '', $string);}/** * @} End of "defgroup database". *//** * @defgroup schemaapi Schema API * @{ * * A Drupal schema definition is an array structure representing one or * more tables and their related keys and indexes. A schema is defined by * hook_schema(), which usually lives in a modulename.install file. * * By implementing hook_schema() and specifying the tables your module * declares, you can easily create and drop these tables on all * supported database engines. You don't have to deal with the * different SQL dialects for table creation and alteration of the * supported database engines. * * hook_schema() should return an array with a key for each table that * the module defines. * * The following keys are defined: * *   - 'description': A string describing this table and its purpose. *     References to other tables should be enclosed in *     curly-brackets.  For example, the node_revisions table *     description field might contain "Stores per-revision title and *     body data for each {node}." *   - 'fields': An associative array ('fieldname' => specification) *     that describes the table's database columns.  The specification *     is also an array.  The following specification parameters are defined: * *     - 'description': A string describing this field and its purpose. *       References to other tables should be enclosed in *       curly-brackets.  For example, the node table vid field *       description might contain "Always holds the largest (most *       recent) {node_revisions}.vid value for this nid." *     - 'type': The generic datatype: 'varchar', 'int', 'serial' *       'float', 'numeric', 'text', 'blob' or 'datetime'.  Most types *       just map to the according database engine specific *       datatypes.  Use 'serial' for auto incrementing fields. This *       will expand to 'int auto_increment' on mysql. *     - 'serialize': A boolean indicating whether the field will be stored         as a serialized string. *     - 'size': The data size: 'tiny', 'small', 'medium', 'normal', *       'big'.  This is a hint about the largest value the field will *       store and determines which of the database engine specific *       datatypes will be used (e.g. on MySQL, TINYINT vs. INT vs. BIGINT). *       'normal', the default, selects the base type (e.g. on MySQL, *       INT, VARCHAR, BLOB, etc.). * *       Not all sizes are available for all data types. See *       db_type_map() for possible combinations. *     - 'not null': If true, no NULL values will be allowed in this *       database column.  Defaults to false. *     - 'default': The field's default value.  The PHP type of the *       value matters: '', '0', and 0 are all different.  If you *       specify '0' as the default value for a type 'int' field it *       will not work because '0' is a string containing the *       character "zero", not an integer. *     - 'length': The maximal length of a type 'char', 'varchar' or 'text' *       field.  Ignored for other field types. *     - 'unsigned': A boolean indicating whether a type 'int', 'float' *       and 'numeric' only is signed or unsigned.  Defaults to *       FALSE.  Ignored for other field types. *     - 'precision', 'scale': For type 'numeric' fields, indicates *       the precision (total number of significant digits) and scale *       (decimal digits right of the decimal point).  Both values are *       mandatory.  Ignored for other field types. * *     All parameters apart from 'type' are optional except that type *     'numeric' columns must specify 'precision' and 'scale'. * *  - 'primary key': An array of one or more key column specifiers (see below) *    that form the primary key. *  - 'unique keys': An associative array of unique keys ('keyname' => *    specification).  Each specification is an array of one or more *    key column specifiers (see below) that form a unique key on the table. *  - 'indexes':  An associative array of indexes ('indexame' => *    specification).  Each specification is an array of one or more *    key column specifiers (see below) that form an index on the *    table. * * A key column specifier is either a string naming a column or an * array of two elements, column name and length, specifying a prefix * of the named column. * * As an example, here is a SUBSET of the schema definition for * Drupal's 'node' table.  It show four fields (nid, vid, type, and * title), the primary key on field 'nid', a unique key named 'vid' on * field 'vid', and two indexes, one named 'nid' on field 'nid' and * one named 'node_title_type' on the field 'title' and the first four * bytes of the field 'type': * * @code * $schema['node'] = array( *   'fields' => array( *     'nid'      => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), *     'vid'      => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0), *     'type'     => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''), *     'title'    => array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''), *   ), *   'primary key' => array('nid'), *   'unique keys' => array( *     'vid'     => array('vid') *   ), *   'indexes' => array( *     'nid'                 => array('nid'), *     'node_title_type'     => array('title', array('type', 4)), *   ), * ); * @endcode * * @see drupal_install_schema() */ /** * Create a new table from a Drupal table definition. * * @param $ret *   Array to which query results will be added. * @param $name *   The name of the table to create. * @param $table *   A Schema API table definition array. */function db_create_table(&$ret, $name, $table) {  $statements = db_create_table_sql($name, $table);  foreach ($statements as $statement) {    $ret[] = update_sql($statement);  }}/** * Return an array of field names from an array of key/index column specifiers. * * This is usually an identity function but if a key/index uses a column prefix * specification, this function extracts just the name. * * @param $fields *   An array of key/index column specifiers. * @return *   An array of field names. */function db_field_names($fields) {  $ret = array();  foreach ($fields as $field) {    if (is_array($field)) {      $ret[] = $field[0];    }    else {      $ret[] = $field;    }  }  return $ret;}/** * Given a Schema API field type, return the correct %-placeholder. * * Embed the placeholder in a query to be passed to db_query and and pass as an * argument to db_query a value of the specified type. * * @param $type *   The Schema API type of a field. * @return *   The placeholder string to embed in a query for that type. */function db_type_placeholder($type) {  switch ($type) {    case 'varchar':    case 'char':    case 'text':    case 'datetime':      return "'%s'";    case 'numeric':      // Numeric values are arbitrary precision numbers.  Syntacically, numerics      // should be specified directly in SQL. However, without single quotes      // the %s placeholder does not protect against non-numeric characters such      // as spaces which would expose us to SQL injection.      return '%n';    case 'serial':    case 'int':      return '%d';    case 'float':      return '%f';    case 'blob':      return '%b';  }  // There is no safe value to return here, so return something that  // will cause the query to fail.  return 'unsupported type '. $type .'for db_type_placeholder';}/** * @} End of "defgroup schemaapi". */
<?php// $Id$/** * Implementation of hook_schema(). */function filter_schema() {  $schema['filters'] = array(    'description' => 'Table that maps filters (HTML corrector) to input formats (Filtered HTML).',    'fields' => array(      'fid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Auto-incrementing filter ID.',      ),      'format' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Foreign key: The {filter_formats}.format to which this filter is assigned.',      ),      'module' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'The origin module of the filter.',      ),      'delta' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'ID to identify which filter within module is being referenced.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Weight of filter within format.',      )    ),    'primary key' => array('fid'),    'unique keys' => array(      'fmd' => array('format', 'module', 'delta'),    ),    'indexes' => array(      'list' => array('format', 'weight', 'module', 'delta'),    ),  );  $schema['filter_formats'] = array(    'description' => 'Stores input formats: custom groupings of filters, such as Filtered HTML.',    'fields' => array(      'format' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique ID for format.',      ),      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Name of the input format (Filtered HTML).',      ),      'roles' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'A comma-separated string of roles; references {role}.rid.', // This is bad since you can't use joins, nor index.      ),      'cache' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate whether format is cachable. (1 = cachable, 0 = not cachable)',      ),    ),    'primary key' => array('format'),    'unique keys' => array('name' => array('name')),  );  $schema['cache_filter'] = drupal_get_schema_unprocessed('system', 'cache');  $schema['cache_filter']['description'] = 'Cache table for the Filter module to store already filtered pieces of text, identified by input format and md5 hash of the text.';  return $schema;}
<?php// $Id$/** * @file * Manages displaying online help. *//** * Implementation of hook_menu(). */function help_menu() {  $items['admin/help'] = array(    'title' => 'Help',    'page callback' => 'help_main',    'access arguments' => array('access administration pages'),    'weight' => 9,    'file' => 'help.admin.inc',  );  foreach (module_implements('help', TRUE) as $module) {    $items['admin/help/'. $module] = array(      'title' => $module,      'page callback' => 'help_page',      'page arguments' => array(2),      'access arguments' => array('access administration pages'),      'type' => MENU_CALLBACK,      'file' => 'help.admin.inc',    );  }  return $items;}/** * Implementation of hook_help(). */function help_help($path, $arg) {  switch ($path) {    case 'admin/help':      $output = '<p>'. t('This guide provides context sensitive help on the use and configuration of <a href="@drupal">Drupal</a> and its modules, and is a supplement to the more extensive online <a href="@handbook">Drupal handbook</a>. The online handbook may contain more up-to-date information, is annotated with helpful user-contributed comments, and serves as the definitive reference point for all Drupal documentation.', array('@drupal' => 'http://drupal.org', '@handbook' => 'http://drupal.org/handbook')) .'</p>';      return $output;    case 'admin/help#help':      $output = '<p>'. t('The help module provides context sensitive help on the use and configuration of <a href="@drupal">Drupal</a> and its modules, and is a supplement to the more extensive online <a href="@handbook">Drupal handbook</a>. The online handbook may contain more up-to-date information, is annotated with helpful user-contributed comments, and serves as the definitive reference point for all Drupal documentation.', array('@drupal' => 'http://drupal.org', '@handbook' => 'http://drupal.org/handbook')) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@help">Help module</a>.', array('@help' => 'http://drupal.org/handbook/modules/help/')) .'</p>';      return $output;  }}
<?php// $Id$/** * @file * Admin page callback file for the user module. */function user_admin($callback_arg = '') {  $op = isset($_POST['op']) ? $_POST['op'] : $callback_arg;  switch ($op) {    case t('Create new account'):    case 'create':      $output = drupal_get_form('user_register');      break;    default:      if (!empty($_POST['accounts']) && isset($_POST['operation']) && ($_POST['operation'] == 'delete')) {        $output = drupal_get_form('user_multiple_delete_confirm');      }      else {        $output = drupal_get_form('user_filter_form');        $output .= drupal_get_form('user_admin_account');      }  }  return $output;}/** * Form builder; Return form for user administration filters. * * @ingroup forms * @see user_filter_form_submit() */function user_filter_form() {  $session = &$_SESSION['user_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = user_filters();  $i = 0;  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Show only users where'),    '#theme' => 'user_filters',  );  foreach ($session as $filter) {    list($type, $value) = $filter;    // Merge an array of arrays into one if necessary.    $options = $type == 'permission' ? call_user_func_array('array_merge', $filters[$type]['options']) : $filters[$type]['options'];    $params = array('%property' => $filters[$type]['title'] , '%value' => $options[$value]);    if ($i++ > 0) {      $form['filters']['current'][] = array('#value' => t('<em>and</em> where <strong>%property</strong> is <strong>%value</strong>', $params));    }    else {      $form['filters']['current'][] = array('#value' => t('<strong>%property</strong> is <strong>%value</strong>', $params));    }  }  foreach ($filters as $key => $filter) {    $names[$key] = $filter['title'];    $form['filters']['status'][$key] = array(      '#type' => 'select',      '#options' => $filter['options'],    );  }  $form['filters']['filter'] = array(    '#type' => 'radios',    '#options' => $names,  );  $form['filters']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => (count($session) ? t('Refine') : t('Filter')),  );  if (count($session)) {    $form['filters']['buttons']['undo'] = array(      '#type' => 'submit',      '#value' => t('Undo'),    );    $form['filters']['buttons']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset'),    );  }  drupal_add_js('misc/form.js', 'core');  return $form;}/** * Process result from user administration filter form. */function user_filter_form_submit($form, &$form_state) {  $op = $form_state['values']['op'];  $filters = user_filters();  switch ($op) {    case t('Filter'): case t('Refine'):      if (isset($form_state['values']['filter'])) {        $filter = $form_state['values']['filter'];        // Merge an array of arrays into one if necessary.        $options = $filter == 'permission' ? call_user_func_array('array_merge', $filters[$filter]['options']) : $filters[$filter]['options'];        if (isset($options[$form_state['values'][$filter]])) {          $_SESSION['user_overview_filter'][] = array($filter, $form_state['values'][$filter]);        }      }      break;    case t('Undo'):      array_pop($_SESSION['user_overview_filter']);      break;    case t('Reset'):      $_SESSION['user_overview_filter'] = array();      break;    case t('Update'):      return;  }  $form_state['redirect'] = 'admin/user/user';  return;}/** * Form builder; User administration page. * * @ingroup forms * @see user_admin_account_validate() * @see user_admin_account_submit() */function user_admin_account() {  $filter = user_build_filter_query();  $header = array(    array(),    array('data' => t('Username'), 'field' => 'u.name'),    array('data' => t('Status'), 'field' => 'u.status'),    t('Roles'),    array('data' => t('Member for'), 'field' => 'u.created', 'sort' => 'desc'),    array('data' => t('Last access'), 'field' => 'u.access'),    t('Operations')  );  if ($filter['join'] != "") {    $sql = 'SELECT DISTINCT u.uid, u.name, u.status, u.created, u.access FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid '. $filter['join'] .' WHERE u.uid != 0 '. $filter['where'];    $query_count = 'SELECT COUNT(DISTINCT u.uid) FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid '. $filter['join'] .' WHERE u.uid != 0 '. $filter['where'];  }  else {    $sql = 'SELECT u.uid, u.name, u.status, u.created, u.access FROM {users} u WHERE u.uid != 0 '. $filter['where'];    $query_count = 'SELECT COUNT(u.uid) FROM {users} u WHERE u.uid != 0 '. $filter['where'];  }    $sql .= tablesort_sql($header);  $result = pager_query($sql, 50, 0, $query_count, $filter['args']);  $form['options'] = array(    '#type' => 'fieldset',    '#title' => t('Update options'),    '#prefix' => '<div class="container-inline">',    '#suffix' => '</div>',  );  $options = array();  foreach (module_invoke_all('user_operations') as $operation => $array) {    $options[$operation] = $array['label'];  }  $form['options']['operation'] = array(    '#type' => 'select',    '#options' => $options,    '#default_value' => 'unblock',  );  $form['options']['submit'] = array(    '#type' => 'submit',    '#value' => t('Update'),  );  $destination = drupal_get_destination();  $status = array(t('blocked'), t('active'));  $roles = user_roles(TRUE);  $accounts = array();  while ($account = db_fetch_object($result)) {    $accounts[$account->uid] = '';    $form['name'][$account->uid] = array('#value' => theme('username', $account));    $form['status'][$account->uid] =  array('#value' => $status[$account->status]);    $users_roles = array();    $roles_result = db_query('SELECT rid FROM {users_roles} WHERE uid = %d', $account->uid);    while ($user_role = db_fetch_object($roles_result)) {      $users_roles[] = $roles[$user_role->rid];    }    asort($users_roles);    $form['roles'][$account->uid][0] = array('#value' => theme('item_list', $users_roles));    $form['member_for'][$account->uid] = array('#value' => format_interval(time() - $account->created));    $form['last_access'][$account->uid] =  array('#value' => $account->access ? t('@time ago', array('@time' => format_interval(time() - $account->access))) : t('never'));    $form['operations'][$account->uid] = array('#value' => l(t('edit'), "user/$account->uid/edit", array('query' => $destination)));  }  $form['accounts'] = array(    '#type' => 'checkboxes',    '#options' => $accounts  );  $form['pager'] = array('#value' => theme('pager', NULL, 50, 0));  return $form;}/** * Submit the user administration update form. */function user_admin_account_submit($form, &$form_state) {  $operations = module_invoke_all('user_operations', $form_state);  $operation = $operations[$form_state['values']['operation']];  // Filter out unchecked accounts.  $accounts = array_filter($form_state['values']['accounts']);  if ($function = $operation['callback']) {    // Add in callback arguments if present.    if (isset($operation['callback arguments'])) {      $args = array_merge(array($accounts), $operation['callback arguments']);    }    else {      $args = array($accounts);    }    call_user_func_array($function, $args);    drupal_set_message(t('The update has been performed.'));  }}function user_admin_account_validate($form, &$form_state) {  $form_state['values']['accounts'] = array_filter($form_state['values']['accounts']);  if (count($form_state['values']['accounts']) == 0) {    form_set_error('', t('No users selected.'));  }}/** * Form builder; Configure user settings for this site. * * @ingroup forms * @see system_settings_form() */function user_admin_settings() {  // User registration settings.  $form['registration'] = array('#type' => 'fieldset', '#title' => t('User registration settings'));  $form['registration']['user_register'] = array('#type' => 'radios', '#title' => t('Public registrations'), '#default_value' => variable_get('user_register', 1), '#options' => array(t('Only site administrators can create new user accounts.'), t('Visitors can create accounts and no administrator approval is required.'), t('Visitors can create accounts but administrator approval is required.')));  $form['registration']['user_email_verification'] = array('#type' => 'checkbox', '#title' => t('Require e-mail verification when a visitor creates an account'), '#default_value' => variable_get('user_email_verification', TRUE), '#description' => t('If this box is checked, new users will be required to validate their e-mail address prior to logging into the site, and will be assigned a system-generated password. With it unchecked, users will be logged in immediately upon registering, and may select their own passwords during registration.'));  $form['registration']['user_registration_help'] = array('#type' => 'textarea', '#title' => t('User registration guidelines'), '#default_value' => variable_get('user_registration_help', ''), '#description' => t('This text is displayed at the top of the user registration form and is useful for helping or instructing your users.'));  // User e-mail settings.  $form['email'] = array(    '#type' => 'fieldset',    '#title' => t('User e-mail settings'),    '#description' => t('Drupal sends emails whenever new users register on your site, and optionally, may also notify users after other account actions. Using a simple set of content templates, notification e-mails can be customized to fit the specific needs of your site.'),  );  // These email tokens are shared for all settings, so just define  // the list once to help ensure they stay in sync.  $email_token_help = t('Available variables are:') .' !username, !site, !password, !uri, !uri_brief, !mailto, !date, !login_uri, !edit_uri, !login_url.';  $form['email']['admin_created'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, new user created by administrator'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 0),    '#description' => t('Customize welcome e-mail messages sent to new member accounts created by an administrator.') .' '. $email_token_help,  );  $form['email']['admin_created']['user_mail_register_admin_created_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_admin_created_subject'),    '#maxlength' => 180,  );  $form['email']['admin_created']['user_mail_register_admin_created_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_admin_created_body'),    '#rows' => 15,  );  $form['email']['no_approval_required'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, no approval required'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 1),    '#description' => t('Customize welcome e-mail messages sent to new members upon registering, when no administrator approval is required.') .' '. $email_token_help  );  $form['email']['no_approval_required']['user_mail_register_no_approval_required_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_no_approval_required_subject'),    '#maxlength' => 180,  );  $form['email']['no_approval_required']['user_mail_register_no_approval_required_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_no_approval_required_body'),    '#rows' => 15,  );  $form['email']['pending_approval'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, awaiting administrator approval'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 2),    '#description' => t('Customize welcome e-mail messages sent to new members upon registering, when administrative approval is required.') .' '. $email_token_help,  );  $form['email']['pending_approval']['user_mail_register_pending_approval_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_pending_approval_subject'),    '#maxlength' => 180,  );  $form['email']['pending_approval']['user_mail_register_pending_approval_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_pending_approval_body'),    '#rows' => 8,  );  $form['email']['password_reset'] = array(    '#type' => 'fieldset',    '#title' => t('Password recovery email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Customize e-mail messages sent to users who request a new password.') .' '. $email_token_help,  );  $form['email']['password_reset']['user_mail_password_reset_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('password_reset_subject'),    '#maxlength' => 180,  );  $form['email']['password_reset']['user_mail_password_reset_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('password_reset_body'),    '#rows' => 12,  );  $form['email']['activated'] = array(    '#type' => 'fieldset',    '#title' => t('Account activation email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users upon account activation (when an administrator activates an account of a user who has already registered, on a site where administrative approval is required).') .' '. $email_token_help,  );  $form['email']['activated']['user_mail_status_activated_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is activated.'),    '#default_value' => variable_get('user_mail_status_activated_notify', TRUE),  );  $form['email']['activated']['user_mail_status_activated_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_activated_subject'),    '#maxlength' => 180,  );  $form['email']['activated']['user_mail_status_activated_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_activated_body'),    '#rows' => 15,  );  $form['email']['blocked'] = array(    '#type' => 'fieldset',    '#title' => t('Account blocked email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users when their accounts are blocked.') .' '. $email_token_help,  );  $form['email']['blocked']['user_mail_status_blocked_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is blocked.'),    '#default_value' => variable_get('user_mail_status_blocked_notify', FALSE),  );  $form['email']['blocked']['user_mail_status_blocked_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_blocked_subject'),    '#maxlength' => 180,  );  $form['email']['blocked']['user_mail_status_blocked_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_blocked_body'),    '#rows' => 3,  );  $form['email']['deleted'] = array(    '#type' => 'fieldset',    '#title' => t('Account deleted email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users when their accounts are deleted.') .' '. $email_token_help,  );  $form['email']['deleted']['user_mail_status_deleted_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is deleted.'),    '#default_value' => variable_get('user_mail_status_deleted_notify', FALSE),  );  $form['email']['deleted']['user_mail_status_deleted_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_deleted_subject'),    '#maxlength' => 180,  );  $form['email']['deleted']['user_mail_status_deleted_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_deleted_body'),    '#rows' => 3,  );  // User signatures.  $form['signatures'] = array(    '#type' => 'fieldset',    '#title' => t('Signatures'),  );  $form['signatures']['user_signatures'] = array(    '#type' => 'radios',    '#title' => t('Signature support'),    '#default_value' => variable_get('user_signatures', 0),    '#options' => array(t('Disabled'), t('Enabled')),  );  // If picture support is enabled, check whether the picture directory exists:  if (variable_get('user_pictures', 0)) {    $picture_path = file_create_path(variable_get('user_picture_path', 'pictures'));    file_check_directory($picture_path, 1, 'user_picture_path');  }  $form['pictures'] = array(    '#type' => 'fieldset',    '#title' => t('Pictures'),  );  $picture_support = variable_get('user_pictures', 0);  $form['pictures']['user_pictures'] = array(    '#type' => 'radios',    '#title' => t('Picture support'),    '#default_value' => $picture_support,    '#options' => array(t('Disabled'), t('Enabled')),    '#prefix' => '<div class="user-admin-picture-radios">',    '#suffix' => '</div>',  );  drupal_add_js(drupal_get_path('module', 'user') .'/user.js');  // If JS is enabled, and the radio is defaulting to off, hide all  // the settings on page load via .css using the js-hide class so  // that there's no flicker.  $css_class = 'user-admin-picture-settings';  if (!$picture_support) {    $css_class .= ' js-hide';  }  $form['pictures']['settings'] = array(    '#prefix' => '<div class="'. $css_class .'">',    '#suffix' => '</div>',  );  $form['pictures']['settings']['user_picture_path'] = array(    '#type' => 'textfield',    '#title' => t('Picture image path'),    '#default_value' => variable_get('user_picture_path', 'pictures'),    '#size' => 30,    '#maxlength' => 255,    '#description' => t('Subdirectory in the directory %dir where pictures will be stored.', array('%dir' => file_directory_path() .'/')),  );  $form['pictures']['settings']['user_picture_default'] = array(    '#type' => 'textfield',    '#title' => t('Default picture'),    '#default_value' => variable_get('user_picture_default', ''),    '#size' => 30,    '#maxlength' => 255,    '#description' => t('URL of picture to display for users with no custom picture selected. Leave blank for none.'),  );  $form['pictures']['settings']['user_picture_dimensions'] = array(    '#type' => 'textfield',    '#title' => t('Picture maximum dimensions'),    '#default_value' => variable_get('user_picture_dimensions', '85x85'),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('Maximum dimensions for pictures, in pixels.'),  );  $form['pictures']['settings']['user_picture_file_size'] = array(    '#type' => 'textfield',    '#title' => t('Picture maximum file size'),    '#default_value' => variable_get('user_picture_file_size', '30'),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('Maximum file size for pictures, in kB.'),  );  $form['pictures']['settings']['user_picture_guidelines'] = array(    '#type' => 'textarea',    '#title' => t('Picture guidelines'),    '#default_value' => variable_get('user_picture_guidelines', ''),    '#description' => t("This text is displayed at the picture upload form in addition to the default guidelines. It's useful for helping or instructing your users."),  );  return system_settings_form($form);}/** * Menu callback: administer permissions. * * @ingroup forms * @see user_admin_perm_submit() * @see theme_user_admin_perm() */function user_admin_perm($form_state, $rid = NULL) {  if (is_numeric($rid)) {    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid WHERE r.rid = %d', $rid);  }  else {    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid ORDER BY name');  }  // Compile role array:  // Add a comma at the end so when searching for a permission, we can  // always search for "$perm," to make sure we do not confuse  // permissions that are substrings of each other.  while ($role = db_fetch_object($result)) {    $role_permissions[$role->rid] = $role->perm .',';  }  // Retrieve role names for columns.  $role_names = user_roles();  if (is_numeric($rid)) {    $role_names = array($rid => $role_names[$rid]);  }  // Render role/permission overview:  $options = array();  foreach (module_list(FALSE, FALSE, TRUE) as $module) {    if ($permissions = module_invoke($module, 'perm')) {      $form['permission'][] = array(        '#value' => $module,      );      asort($permissions);      foreach ($permissions as $perm) {        $options[$perm] = '';        $form['permission'][$perm] = array('#value' => t($perm));        foreach ($role_names as $rid => $name) {          // Builds arrays for checked boxes for each role          if (strpos($role_permissions[$rid], $perm .',') !== FALSE) {            $status[$rid][] = $perm;          }        }      }    }  }  // Have to build checkboxes here after checkbox arrays are built  foreach ($role_names as $rid => $name) {    $form['checkboxes'][$rid] = array('#type' => 'checkboxes', '#options' => $options, '#default_value' => isset($status[$rid]) ? $status[$rid] : array());    $form['role_names'][$rid] = array('#value' => $name, '#tree' => TRUE);  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save permissions'));  return $form;}function user_admin_perm_submit($form, &$form_state) {  // Save permissions:  $result = db_query('SELECT * FROM {role}');  while ($role = db_fetch_object($result)) {    if (isset($form_state['values'][$role->rid])) {      // Delete, so if we clear every checkbox we reset that role;      // otherwise permissions are active and denied everywhere.      db_query('DELETE FROM {permission} WHERE rid = %d', $role->rid);      $form_state['values'][$role->rid] = array_filter($form_state['values'][$role->rid]);      if (count($form_state['values'][$role->rid])) {        db_query("INSERT INTO {permission} (rid, perm) VALUES (%d, '%s')", $role->rid, implode(', ', array_keys($form_state['values'][$role->rid])));      }    }  }  drupal_set_message(t('The changes have been saved.'));  // Clear the cached pages  cache_clear_all();}/** * Theme the administer permissions page. * * @ingroup themeable */function theme_user_admin_perm($form) {  $roles = user_roles();  foreach (element_children($form['permission']) as $key) {    // Don't take form control structures    if (is_array($form['permission'][$key])) {      $row = array();      // Module name      if (is_numeric($key)) {        $row[] = array('data' => t('@module module', array('@module' => drupal_render($form['permission'][$key]))), 'class' => 'module', 'id' => 'module-'. $form['permission'][$key]['#value'], 'colspan' => count($form['role_names']) + 1);      }      else {        $row[] = array('data' => drupal_render($form['permission'][$key]), 'class' => 'permission');        foreach (element_children($form['checkboxes']) as $rid) {          if (is_array($form['checkboxes'][$rid])) {            $row[] = array('data' => drupal_render($form['checkboxes'][$rid][$key]), 'class' => 'checkbox', 'title' => $roles[$rid] .' : '. t($key));          }        }      }      $rows[] = $row;    }  }  $header[] = (t('Permission'));  foreach (element_children($form['role_names']) as $rid) {    if (is_array($form['role_names'][$rid])) {      $header[] = array('data' => drupal_render($form['role_names'][$rid]), 'class' => 'checkbox');    }  }  $output = theme('table', $header, $rows, array('id' => 'permissions'));  $output .= drupal_render($form);  return $output;}/** * Menu callback: administer roles. * * @ingroup forms * @see user_admin_role_validate() * @see user_admin_role_submit() * @see theme_user_admin_new_role() */function user_admin_role() {  $rid = arg(4);  if ($rid) {    if ($rid == DRUPAL_ANONYMOUS_RID || $rid == DRUPAL_AUTHENTICATED_RID) {      drupal_goto('admin/user/roles');    }    // Display the edit role form.    $role = db_fetch_object(db_query('SELECT * FROM {role} WHERE rid = %d', $rid));    $form['name'] = array(      '#type' => 'textfield',      '#title' => t('Role name'),      '#default_value' => $role->name,      '#size' => 30,      '#required' => TRUE,      '#maxlength' => 64,      '#description' => t('The name for this role. Example: "moderator", "editorial board", "site architect".'),    );    $form['rid'] = array(      '#type' => 'value',      '#value' => $rid,    );    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Save role'),    );    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete role'),    );  }  else {    $form['name'] = array(      '#type' => 'textfield',      '#size' => 32,      '#maxlength' => 64,    );    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Add role'),    );    $form['#submit'][] = 'user_admin_role_submit';    $form['#validate'][] = 'user_admin_role_validate';  }  return $form;}function user_admin_role_validate($form, &$form_state) {  if ($form_state['values']['name']) {    if ($form_state['values']['op'] == t('Save role')) {      if (db_result(db_query("SELECT COUNT(*) FROM {role} WHERE name = '%s' AND rid != %d", $form_state['values']['name'], $form_state['values']['rid']))) {        form_set_error('name', t('The role name %name already exists. Please choose another role name.', array('%name' => $form_state['values']['name'])));      }    }    else if ($form_state['values']['op'] == t('Add role')) {      if (db_result(db_query("SELECT COUNT(*) FROM {role} WHERE name = '%s'", $form_state['values']['name']))) {        form_set_error('name', t('The role name %name already exists. Please choose another role name.', array('%name' => $form_state['values']['name'])));      }    }  }  else {    form_set_error('name', t('You must specify a valid role name.'));  }}function user_admin_role_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Save role')) {    db_query("UPDATE {role} SET name = '%s' WHERE rid = %d", $form_state['values']['name'], $form_state['values']['rid']);    drupal_set_message(t('The role has been renamed.'));  }  else if ($form_state['values']['op'] == t('Delete role')) {    db_query('DELETE FROM {role} WHERE rid = %d', $form_state['values']['rid']);    db_query('DELETE FROM {permission} WHERE rid = %d', $form_state['values']['rid']);    // Update the users who have this role set:    db_query('DELETE FROM {users_roles} WHERE rid = %d', $form_state['values']['rid']);    drupal_set_message(t('The role has been deleted.'));  }  else if ($form_state['values']['op'] == t('Add role')) {    db_query("INSERT INTO {role} (name) VALUES ('%s')", $form_state['values']['name']);    drupal_set_message(t('The role has been added.'));  }  $form_state['redirect'] = 'admin/user/roles';  return;}/** * Menu callback: list all access rules */function user_admin_access_check() {  $output = drupal_get_form('user_admin_check_user');  $output .= drupal_get_form('user_admin_check_mail');  $output .= drupal_get_form('user_admin_check_host');  return $output;}/** * Menu callback: add an access rule. */function user_admin_access_add($mask = NULL, $type = NULL) {  $edit = array();  $edit['aid'] = 0;  $edit['mask'] = $mask;  $edit['type'] = $type;  return drupal_get_form('user_admin_access_add_form', $edit, t('Add rule'));}/** * Menu callback: edit an access rule. */function user_admin_access_edit($aid = 0) {  $edit = db_fetch_array(db_query('SELECT aid, type, status, mask FROM {access} WHERE aid = %d', $aid));  return drupal_get_form('user_admin_access_edit_form', $edit, t('Save rule'));}/** * Form builder; Configure access rules. * * @ingroup forms */function user_admin_access_form(&$form_state, $edit, $submit) {  $form = array();  $form['aid'] = array(    '#type' => 'value',    '#value' => $edit['aid'],  );  $form['status'] = array(    '#type' => 'radios',    '#title' => t('Access type'),    '#default_value' => isset($edit['status']) ? $edit['status'] : 0,    '#options' => array('1' => t('Allow'), '0' => t('Deny')),  );  $type_options = array('user' => t('Username'), 'mail' => t('E-mail'), 'host' => t('Host'));  $form['type'] = array(    '#type' => 'radios',    '#title' => t('Rule type'),    '#default_value' => (isset($type_options[$edit['type']]) ? $edit['type'] : 'user'),    '#options' => $type_options,  );  $form['mask'] = array(    '#type' => 'textfield',    '#title' => t('Mask'),    '#size' => 30,    '#maxlength' => 64,    '#default_value' => $edit['mask'],    '#description' => '%: '. t('Matches any number of characters, even zero characters') .'.<br />_: '. t('Matches exactly one character.'),    '#required' => TRUE,  );  $form['submit'] = array('#type' => 'submit', '#value' => $submit);  $form['#submit'] = array('user_admin_access_form_submit');  return $form;}/** * Submit callback for user_admin_access_form(). */function user_admin_access_form_submit($form, &$form_state) {  $edit = $form_state['values'];  if ($edit['aid']) {    db_query("UPDATE {access} SET mask = '%s', type = '%s', status = '%s' WHERE aid = %d", $edit['mask'], $edit['type'], $edit['status'], $edit['aid']);    drupal_set_message(t('The access rule has been saved.'));  }  else {    db_query("INSERT INTO {access} (mask, type, status) VALUES ('%s', '%s', %d)", $edit['mask'], $edit['type'], $edit['status']);    drupal_set_message(t('The access rule has been added.'));  }  $form_state['redirect'] = 'admin/user/rules';}function user_admin_access_check_validate($form, &$form_state) {  if (empty($form_state['values']['test'])) {    form_set_error($form_state['values']['type'], t('No value entered. Please enter a test string and try again.'));  }}function user_admin_check_user() {  $form['user'] = array('#type' => 'fieldset', '#title' => t('Username'));  $form['user']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter a username to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => USERNAME_MAX_LENGTH);  $form['user']['type'] = array('#type' => 'hidden', '#value' => 'user');  $form['user']['submit'] = array('#type' => 'submit', '#value' => t('Check username'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_check_mail() {  $form['mail'] = array('#type' => 'fieldset', '#title' => t('E-mail'));  $form['mail']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter an e-mail address to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => EMAIL_MAX_LENGTH);  $form['mail']['type'] = array('#type' => 'hidden', '#value' => 'mail');  $form['mail']['submit'] = array('#type' => 'submit', '#value' => t('Check e-mail'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_check_host() {  $form['host'] = array('#type' => 'fieldset', '#title' => t('Hostname'));  $form['host']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter a hostname or IP address to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => 64);  $form['host']['type'] = array('#type' => 'hidden', '#value' => 'host');  $form['host']['submit'] = array('#type' => 'submit', '#value' => t('Check hostname'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_access_check_submit($form, &$form_state) {  switch ($form_state['values']['type']) {    case 'user':      if (drupal_is_denied('user', $form_state['values']['test'])) {        drupal_set_message(t('The username %name is not allowed.', array('%name' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The username %name is allowed.', array('%name' => $form_state['values']['test'])));      }      break;    case 'mail':      if (drupal_is_denied('mail', $form_state['values']['test'])) {        drupal_set_message(t('The e-mail address %mail is not allowed.', array('%mail' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The e-mail address %mail is allowed.', array('%mail' => $form_state['values']['test'])));      }      break;    case 'host':      if (drupal_is_denied('host', $form_state['values']['test'])) {        drupal_set_message(t('The hostname %host is not allowed.', array('%host' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The hostname %host is allowed.', array('%host' => $form_state['values']['test'])));      }      break;    default:      break;  }}/** * Menu callback: delete an access rule * * @ingroup forms * @see user_admin_access_delete_confirm_submit() */function user_admin_access_delete_confirm($form_state, $aid = 0) {  $access_types = array('user' => t('username'), 'mail' => t('e-mail'), 'host' => t('host'));  $edit = db_fetch_object(db_query('SELECT aid, type, status, mask FROM {access} WHERE aid = %d', $aid));  $form = array();  $form['aid'] = array('#type' => 'hidden', '#value' => $aid);  $output = confirm_form($form,                  t('Are you sure you want to delete the @type rule for %rule?', array('@type' => $access_types[$edit->type], '%rule' => $edit->mask)),                  'admin/user/rules',                  t('This action cannot be undone.'),                  t('Delete'),                  t('Cancel'));  return $output;}function user_admin_access_delete_confirm_submit($form, &$form_state) {  db_query('DELETE FROM {access} WHERE aid = %d', $form_state['values']['aid']);  drupal_set_message(t('The access rule has been deleted.'));  $form_state['redirect'] = 'admin/user/rules';  return;}/** * Menu callback: list all access rules */function user_admin_access() {  $header = array(array('data' => t('Access type'), 'field' => 'status'), array('data' => t('Rule type'), 'field' => 'type'), array('data' => t('Mask'), 'field' => 'mask'), array('data' => t('Operations'), 'colspan' => 2));  $result = db_query("SELECT aid, type, status, mask FROM {access}". tablesort_sql($header));  $access_types = array('user' => t('username'), 'mail' => t('e-mail'), 'host' => t('host'));  $rows = array();  while ($rule = db_fetch_object($result)) {    $rows[] = array($rule->status ? t('allow') : t('deny'), $access_types[$rule->type], $rule->mask, l(t('edit'), 'admin/user/rules/edit/'. $rule->aid), l(t('delete'), 'admin/user/rules/delete/'. $rule->aid));  }  if (empty($rows)) {    $rows[] = array(array('data' => '<em>'. t('There are currently no access rules.') .'</em>', 'colspan' => 5));  }  return theme('table', $header, $rows);}/** * Theme user administration overview. * * @ingroup themeable */function theme_user_admin_account($form) {  // Overview table:  $header = array(    theme('table_select_header_cell'),    array('data' => t('Username'), 'field' => 'u.name'),    array('data' => t('Status'), 'field' => 'u.status'),    t('Roles'),    array('data' => t('Member for'), 'field' => 'u.created', 'sort' => 'desc'),    array('data' => t('Last access'), 'field' => 'u.access'),    t('Operations')  );  $output = drupal_render($form['options']);  if (isset($form['name']) && is_array($form['name'])) {    foreach (element_children($form['name']) as $key) {      $rows[] = array(        drupal_render($form['accounts'][$key]),        drupal_render($form['name'][$key]),        drupal_render($form['status'][$key]),        drupal_render($form['roles'][$key]),        drupal_render($form['member_for'][$key]),        drupal_render($form['last_access'][$key]),        drupal_render($form['operations'][$key]),      );    }  }  else {    $rows[] = array(array('data' => t('No users available.'), 'colspan' => '7'));  }  $output .= theme('table', $header, $rows);  if ($form['pager']['#value']) {    $output .= drupal_render($form['pager']);  }  $output .= drupal_render($form);  return $output;}/** * Theme the new-role form. * * @ingroup themeable */function theme_user_admin_new_role($form) {  $header = array(t('Name'), array('data' => t('Operations'), 'colspan' => 2));  foreach (user_roles() as $rid => $name) {    $edit_permissions = l(t('edit permissions'), 'admin/user/permissions/'. $rid);    if (!in_array($rid, array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID))) {      $rows[] = array($name, l(t('edit role'), 'admin/user/roles/edit/'. $rid), $edit_permissions);    }    else {      $rows[] = array($name, t('locked'), $edit_permissions);    }  }  $rows[] = array(drupal_render($form['name']), array('data' => drupal_render($form['submit']), 'colspan' => 2));  $output = drupal_render($form);  $output .= theme('table', $header, $rows);  return $output;}/** * Theme user administration filter form. * * @ingroup themeable */function theme_user_filter_form($form) {  $output = '<div id="user-admin-filter">';  $output .= drupal_render($form['filters']);  $output .= '</div>';  $output .= drupal_render($form);  return $output;}/** * Theme user administration filter selector. * * @ingroup themeable */function theme_user_filters($form) {  $output = '<ul class="clear-block">';  if (!empty($form['current'])) {    foreach (element_children($form['current']) as $key) {      $output .= '<li>'. drupal_render($form['current'][$key]) .'</li>';    }  }  $output .= '<li><dl class="multiselect">'. (!empty($form['current']) ? '<dt><em>'. t('and') .'</em> '. t('where') .'</dt>' : '') .'<dd class="a">';  foreach (element_children($form['filter']) as $key) {    $output .= drupal_render($form['filter'][$key]);  }  $output .= '</dd>';  $output .= '<dt>'. t('is') .'</dt><dd class="b">';  foreach (element_children($form['status']) as $key) {    $output .= drupal_render($form['status'][$key]);  }  $output .= '</dd>';  $output .= '</dl>';  $output .= '<div class="container-inline" id="user-admin-buttons">'. drupal_render($form['buttons']) .'</div>';  $output .= '</li></ul>';  return $output;}
<?php// $Id$/** * @file * Admin page callbacks for the trigger module. *//** * Build the form that allows users to assign actions to hooks. * * @param $type *   Name of hook. * @return *   HTML form. */function trigger_assign($type = NULL) {  // If no type is specified we default to node actions, since they  // are the most common.  if (!isset($type)) {    drupal_goto('admin/build/trigger/node');  }  if ($type == 'node') {    $type = 'nodeapi';  }  $output = '';  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $hook) {    if (isset($hook[$type])) {      foreach ($hook[$type] as $op => $description) {        $form_id = 'trigger_'. $type .'_'. $op .'_assign_form';        $output .= drupal_get_form($form_id, $type, $op, $description['runs when']);      }    }  }  return $output;}/** * Confirm removal of an assigned action. * * @param $hook * @param $op * @param $aid *   The action ID. * @ingroup forms * @see trigger_unassign_submit() */function trigger_unassign($form_state, $hook = NULL, $op = NULL, $aid = NULL) {  if (!($hook && $op && $aid)) {    drupal_goto('admin/build/trigger/assign');  }  $form['hook'] = array(    '#type' => 'value',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'value',    '#value' => $op,  );  $form['aid'] = array(    '#type' => 'value',    '#value' => $aid,  );  $action = actions_function_lookup($aid);  $actions = actions_get_all_actions();  $destination = 'admin/build/trigger/'. ($hook == 'nodeapi' ? 'node' : $hook);  return confirm_form($form,    t('Are you sure you want to unassign the action %title?', array('%title' => $actions[$action]['description'])),    $destination,    t('You can assign it again later if you wish.'),    t('Unassign'), t('Cancel')  );}function trigger_unassign_submit($form, &$form_state) {  $form_values = $form_state['values'];  if ($form_values['confirm'] == 1) {    $aid = actions_function_lookup($form_values['aid']);    db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid);    $actions = actions_get_all_actions();    watchdog('actions', 'Action %action has been unassigned.',  array('%action' => check_plain($actions[$aid]['description'])));    drupal_set_message(t('Action %action has been unassigned.', array('%action' => $actions[$aid]['description'])));    $hook = $form_values['hook'] == 'nodeapi' ? 'node' : $form_values['hook'];    $form_state['redirect'] = 'admin/build/trigger/'. $hook;  }  else {    drupal_goto('admin/build/trigger');  }}/** * Create the form definition for assigning an action to a hook-op combination. * * @param $form_state *   Information about the current form. * @param $hook *   The name of the hook, e.g., 'nodeapi'. * @param $op *   The name of the hook operation, e.g., 'insert'. * @param $description *   A plain English description of what this hook operation does. * @return * * @ingoup forms * @see trigger_assign_form_validate() * @see trigger_assign_form_submit() */function trigger_assign_form($form_state, $hook, $op, $description) {  $form['hook'] = array(    '#type' => 'hidden',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'hidden',    '#value' => $op,  );  // All of these forms use the same validate and submit functions.  $form['#validate'][] = 'trigger_assign_form_validate';  $form['#submit'][] = 'trigger_assign_form_submit';  $options = array();  $functions = array();  // Restrict the options list to actions that declare support for this hook-op  // combination.  foreach (actions_list() as $func => $metadata) {    if (isset($metadata['hooks']['any']) || (isset($metadata['hooks'][$hook]) && is_array($metadata['hooks'][$hook]) && (in_array($op, $metadata['hooks'][$hook])))) {      $functions[] = $func;    }  }  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {    if (in_array($action['callback'], $functions)) {      $options[$action['type']][$aid] = $action['description'];    }  }  $form[$op] = array(    '#type' => 'fieldset',    '#title' => t('Trigger: ') . $description,    '#theme' => 'trigger_display'    );  // Retrieve actions that are already assigned to this hook-op combination.  $actions = _trigger_get_hook_actions($hook, $op);  $form[$op]['assigned']['#type'] = 'value';  $form[$op]['assigned']['#value'] = array();  foreach ($actions as $aid => $description) {    $form[$op]['assigned']['#value'][$aid] = array(      'description' => $description,      'link' => l(t('unassign'), "admin/build/trigger/unassign/$hook/$op/". md5($aid))    );  }  $form[$op]['parent'] = array(    '#prefix' => "<div class='container-inline'>",    '#suffix' => '</div>',  );  // List possible actions that may be assigned.  if (count($options) != 0) {    array_unshift($options, t('Choose an action'));    $form[$op]['parent']['aid'] = array(      '#type' => 'select',      '#options' => $options,    );    $form[$op]['parent']['submit'] = array(      '#type' => 'submit',      '#value' => t('Assign')    );  }  else {    $form[$op]['none'] = array(      '#value' => t('No available actions for this trigger.')    );  }  return $form;}/** * Validation function for trigger_assign_form(). * * Makes sure that the user is not re-assigning an action to an event. */function trigger_assign_form_validate($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    if (db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid))) {      form_set_error($form_values['operation'], t('The action you chose is already assigned to that trigger.'));    }  }}/** * Submit function for trigger_assign_form(). */function trigger_assign_form_submit($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    $weight = db_result(db_query("SELECT MAX(weight) FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s'", $form_values['hook'], $form_values['operation']));    db_query("INSERT INTO {trigger_assignments} values ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], $aid, $weight + 1);    // If this action changes a node property, we need to save the node    // so the change will persist.    $actions = actions_list();    if (isset($actions[$aid]['behavior']) && in_array('changes_node_property', $actions[$aid]['behavior']) && ($form_values['operation'] != 'presave')) {      // Delete previous node_save_action if it exists, and re-add a new one at a higher weight.      $save_post_action_assigned = db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']));      if ($save_post_action_assigned) {        db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']);      }      db_query("INSERT INTO {trigger_assignments} VALUES ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], 'node_save_action', $weight + 2);      if (!$save_post_action_assigned) {        drupal_set_message(t('You have added an action that changes a the property of a post. A Save post action has been added so that the property change will be saved.'));      }    }  }}/** * Display actions assigned to this hook-op combination in a table. * * @param array $element *   The fieldset including all assigned actions. * @return *   The rendered form with the table prepended. * * @ingroup themeable */function theme_trigger_display($element) {  $header = array();  $rows = array();  if (count($element['assigned']['#value'])) {    $header = array(array('data' => t('Name')), array('data' => t('Operation')));    $rows = array();    foreach ($element['assigned']['#value'] as $aid => $info) {      $rows[] = array(        $info['description'],        $info['link']      );    }  }  if (count($rows)) {    $output = theme('table', $header, $rows) . drupal_render($element);  }  else {    $output = drupal_render($element);  }  return $output;}/** * Get the actions that have already been defined for this * type-hook-op combination. * * @param $type *   One of 'node', 'user', 'comment'. * @param $hook *   The name of the hook for which actions have been assigned, *   e.g. 'nodeapi'. * @param $op *   The hook operation for which the actions have been assigned, *   e.g., 'view'. * @return *   An array of action descriptions keyed by action IDs. */function _trigger_get_hook_actions($hook, $op, $type = NULL) {  $actions = array();  if ($type) {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE a.type = '%s' AND h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $type, $hook, $op);  }  else {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $hook, $op);  }  while ($action = db_fetch_object($result)) {    $actions[$action->aid] = $action->description;  }  return $actions;}
<?php// $Id$/** * @file * Enable threaded discussions about general topics. *//** * Implementation of hook_help(). */function forum_help($path, $arg) {  switch ($path) {    case 'admin/help#forum':      $output = '<p>'. t('The forum module lets you create threaded discussion forums with functionality similar to other message board systems. Forums are useful because they allow community members to discuss topics with one another while ensuring those conversations are archived for later reference. The <a href="@create-topic">forum topic</a> menu item (under <em>Create content</em> on the Navigation menu) creates the initial post of a new threaded discussion, or thread.', array('@create-topic' => url('node/add/forum'))) .'</p>';      $output .= '<p>'. t('A threaded discussion occurs as people leave comments on a forum topic (or on other comments within that topic). A forum topic is contained within a forum, which may hold many similar or related forum topics. Forums are (optionally) nested within a container, which may hold many similar or related forums. Both containers and forums may be nested within other containers and forums, and provide structure for your message board. By carefully planning this structure, you make it easier for users to find and comment on a specific forum topic.') .'</p>';      $output .= '<p>'. t('When administering a forum, note that:') .'</p>';      $output .= '<ul><li>'. t('a forum topic (and all of its comments) may be moved between forums by selecting a different forum while editing a forum topic.') .'</li>';      $output .= '<li>'. t('when moving a forum topic between forums, the <em>Leave shadow copy</em> option creates a link in the original forum pointing to the new location.') .'</li>';      $output .= '<li>'. t('selecting <em>Read only</em> under <em>Comment settings</em> while editing a forum topic will lock (prevent new comments) on the thread.') .'</li>';      $output .= '<li>'. t('selecting <em>Disabled</em> under <em>Comment settings</em> while editing a forum topic will hide all existing comments on the thread, and prevent new ones.') .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@forum">Forum module</a>.', array('@forum' => 'http://drupal.org/handbook/modules/forum/')) .'</p>';      return $output;    case 'admin/content/forum':      return '<p>'. t('This page displays a list of existing forums and containers. Containers (optionally) hold forums, and forums hold forum topics (a forum topic is the initial post to a threaded discussion). To provide structure, both containers and forums may be placed inside other containers and forums. To rearrange forums and containers, grab a drag-and-drop handle under the <em>Name</em> column and drag the forum or container to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save</em> button at the bottom of the page.') .'</p>';    case 'admin/content/forum/add/container':      return '<p>'. t('By grouping related or similar forums, containers help organize forums. For example, a container named "Food" may hold two forums named "Fruit" and "Vegetables", respectively.') .'</p>';    case 'admin/content/forum/add/forum':      return '<p>'. t('A forum holds related or similar forum topics (a forum topic is the initial post to a threaded discussion). For example, a forum named "Fruit" may contain forum topics titled "Apples" and "Bananas", respectively.') .'</p>';    case 'admin/content/forum/settings':      return '<p>'. t('These settings allow you to adjust the display of your forum topics. The content types available for use within a forum may be selected by editing the <em>Content types</em> on the <a href="@forum-vocabulary">forum vocabulary page</a>.', array('@forum-vocabulary' => url('admin/content/taxonomy/edit/vocabulary/'. variable_get('forum_nav_vocabulary', '')))) .'</p>';  }}/** * Implementation of hook_theme() */function forum_theme() {  return array(    'forums' => array(      'template' => 'forums',      'arguments' => array('forums' => NULL, 'topics' => NULL, 'parents' => NULL, 'tid' => NULL, 'sortby' => NULL, 'forum_per_page' => NULL),    ),    'forum_list' => array(      'template' => 'forum-list',      'arguments' => array('forums' => NULL, 'parents' => NULL, 'tid' => NULL),    ),    'forum_topic_list' => array(      'template' => 'forum-topic-list',      'arguments' => array('tid' => NULL, 'topics' => NULL, 'sortby' => NULL, 'forum_per_page' => NULL),    ),    'forum_icon' => array(      'template' => 'forum-icon',      'arguments' => array('new_posts' => NULL, 'num_posts' => 0, 'comment_mode' => 0, 'sticky' => 0),    ),    'forum_topic_navigation' => array(      'template' => 'forum-topic-navigation',      'arguments' => array('node' => NULL),    ),    'forum_submitted' => array(      'template' => 'forum-submitted',      'arguments' => array('topic' => NULL),    ),  );}/** * Fetch a forum term. * * @param $tid *   The ID of the term which should be loaded. * * @return *   An associative array containing the term data or FALSE if the term cannot be loaded, or is not part of the forum vocabulary. */function forum_term_load($tid) {  $result = db_query(db_rewrite_sql('SELECT t.tid, t.vid, t.name, t.description, t.weight FROM {term_data} t WHERE t.tid = %d AND t.vid = %d', 't', 'tid'), $tid, variable_get('forum_nav_vocabulary', ''));  return db_fetch_array($result);}/** * Implementation of hook_menu(). */function forum_menu() {  $items['forum'] = array(    'title' => 'Forums',    'page callback' => 'forum_page',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'forum.pages.inc',  );  $items['admin/content/forum'] = array(    'title' => 'Forums',    'description' => 'Control forums and their hierarchy and change forum settings.',    'page callback' => 'drupal_get_form',    'page arguments' => array('forum_overview'),    'access arguments' => array('administer forums'),    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/forum/add/container'] = array(    'title' => 'Add container',    'page callback' => 'forum_form_main',    'page arguments' => array('container'),    'access arguments' => array('administer forums'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/add/forum'] = array(    'title' => 'Add forum',    'page callback' => 'forum_form_main',    'page arguments' => array('forum'),    'access arguments' => array('administer forums'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('forum_admin_settings'),    'access arguments' => array('administer forums'),    'weight' => 5,    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/%forum_term'] = array(    'page callback' => 'forum_form_main',    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/container/%forum_term'] = array(    'title' => 'Edit container',    'page callback' => 'forum_form_main',    'page arguments' => array('container', 5),    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/forum/%forum_term'] = array(    'title' => 'Edit forum',    'page callback' => 'forum_form_main',    'page arguments' => array('forum', 5),    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  return $items;}/** * Implementation of hook_init(). */function forum_init() {  drupal_add_css(drupal_get_path('module', 'forum') .'/forum.css');}/** * Implementation of hook_nodeapi(). */function forum_nodeapi(&$node, $op, $teaser, $page) {  // We are going to return if $node->type is not one of the node  // types assigned to the forum vocabulary.  If forum_nav_vocabulary  // is undefined or the vocabulary does not exist, it clearly cannot  // be assigned to $node->type, so return to avoid E_ALL warnings.  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  if (empty($vocabulary)) {    return;  }  // Operate only on node types assigned for the forum vocabulary.  if (!in_array($node->type, $vocabulary->nodes)) {    return;  }  switch ($op) {    case 'view':      if ($page && taxonomy_node_get_terms_by_vocabulary($node, $vid) && $tree = taxonomy_get_tree($vid)) {        // Get the forum terms from the (cached) tree        foreach ($tree as $term) {          $forum_terms[] = $term->tid;        }        foreach ($node->taxonomy as $term_id => $term) {          if (in_array($term_id, $forum_terms)) {            $node->tid = $term_id;          }        }        // Breadcrumb navigation        $breadcrumb[] = l(t('Home'), NULL);        $breadcrumb[] = l($vocabulary->name, 'forum');        if ($parents = taxonomy_get_parents_all($node->tid)) {          $parents = array_reverse($parents);          foreach ($parents as $p) {            $breadcrumb[] = l($p->name, 'forum/'. $p->tid);          }        }        drupal_set_breadcrumb($breadcrumb);        if (!$teaser) {          $node->content['forum_navigation'] = array(            '#value' => theme('forum_topic_navigation', $node),            '#weight' => 100,          );        }      }      break;    case 'prepare':      if (empty($node->nid)) {        // New topic        $node->taxonomy[arg(3)]->vid = $vid;        $node->taxonomy[arg(3)]->tid = arg(3);      }      break;    // Check in particular that only a "leaf" term in the associated taxonomy    // vocabulary is selected, not a "container" term.    case 'validate':      if ($node->taxonomy) {        // Extract the node's proper topic ID.        $vocabulary = $vid;        $containers = variable_get('forum_containers', array());        foreach ($node->taxonomy as $term) {          if (db_result(db_query('SELECT COUNT(*) FROM {term_data} WHERE tid = %d AND vid = %d', $term, $vocabulary))) {            if (in_array($term, $containers)) {              $term = taxonomy_get_term($term);              form_set_error('taxonomy', t('The item %forum is only a container for forums. Please select one of the forums below it.', array('%forum' => $term->name)));            }          }        }      }      break;    // Assign forum taxonomy when adding a topic from within a forum.    case 'presave':      // Make sure all fields are set properly:      $node->icon = !empty($node->icon) ? $node->icon : '';      if ($node->taxonomy && $tree = taxonomy_get_tree($vid)) {        // Get the forum terms from the (cached) tree if we have a taxonomy.        foreach ($tree as $term) {          $forum_terms[] = $term->tid;        }        foreach ($node->taxonomy as $term_id) {          if (in_array($term_id, $forum_terms)) {            $node->tid = $term_id;          }        }        $old_tid = db_result(db_query_range("SELECT t.tid FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.nid = %d ORDER BY t.vid DESC", $node->nid, 0, 1));        if ($old_tid && isset($node->tid) && ($node->tid != $old_tid) && !empty($node->shadow)) {          // A shadow copy needs to be created. Retain new term and add old term.          $node->taxonomy[] = $old_tid;        }      }      break;    case 'update':      if (empty($node->revision) && db_result(db_query('SELECT tid FROM {forum} WHERE nid=%d', $node->nid))) {        if (!empty($node->tid)) {          db_query('UPDATE {forum} SET tid = %d WHERE vid = %d', $node->tid, $node->vid);        }        // The node is removed from the forum.        else {          db_query('DELETE FROM {forum} WHERE nid = %d', $node->nid);        }        break;      }      // Deliberate no break -- for new revisions and for previously unassigned terms we need an insert.    case 'insert':      if (!empty($node->tid)) {        db_query('INSERT INTO {forum} (tid, vid, nid) VALUES (%d, %d, %d)', $node->tid, $node->vid, $node->nid);      }      break;    case 'delete':      db_query('DELETE FROM {forum} WHERE nid = %d', $node->nid);      break;    case 'load':      return db_fetch_array(db_query('SELECT tid AS forum_tid FROM {forum} WHERE vid = %d', $node->vid));  }  return;}/** * Implementation of hook_node_info(). */function forum_node_info() {  return array(    'forum' => array(      'name' => t('Forum topic'),      'module' => 'forum',      'description' => t('A <em>forum topic</em> is the initial post to a new discussion thread within a forum.'),      'title_label' => t('Subject'),    )  );}/** * Implementation of hook_access(). */function forum_access($op, $node, $account) {  switch ($op) {    case 'create':      return user_access('create forum topics', $account) ? TRUE : NULL;    case 'update':      return user_access('edit any forum topic', $account) || (user_access('edit own forum topics', $account) && ($account->uid == $node->uid)) ? TRUE : NULL;    case 'delete':      return user_access('delete any forum topic', $account) || (user_access('delete own forum topics', $account) && ($account->uid == $node->uid)) ? TRUE : NULL;  }}/** * Implementation of hook_perm(). */function forum_perm() {  return array('create forum topics', 'delete own forum topics', 'delete any forum topic', 'edit own forum topics', 'edit any forum topic', 'administer forums');}/** * Implementation of hook_taxonomy(). */function forum_taxonomy($op, $type, $term = NULL) {  if ($op == 'delete' && $term['vid'] == variable_get('forum_nav_vocabulary', '')) {    switch ($type) {      case 'term':        $results = db_query('SELECT tn.nid FROM {term_node} tn WHERE tn.tid = %d', $term['tid']);        while ($node = db_fetch_object($results)) {          // node_delete will also remove any association with non-forum vocabularies.          node_delete($node->nid);        }        // For containers, remove the tid from the forum_containers variable.        $containers = variable_get('forum_containers', array());        $key = array_search($term['tid'], $containers);        if ($key !== FALSE) {          unset($containers[$key]);        }        variable_set('forum_containers', $containers);        break;      case 'vocabulary':        variable_del('forum_nav_vocabulary');    }  }}/** * Implementation of hook_form_alter(). */function forum_form_alter(&$form, $form_state, $form_id) {  $vid = variable_get('forum_nav_vocabulary', '');  if (isset($form['vid']) && $form['vid']['#value'] == $vid) {    // Hide critical options from forum vocabulary.    if ($form_id == 'taxonomy_form_vocabulary') {      $form['help_forum_vocab'] = array(        '#value' => t('This is the designated forum vocabulary. Some of the normal vocabulary options have been removed.'),        '#weight' => -1,      );      $form['content_types']['nodes']['#required'] = TRUE;      $form['hierarchy'] = array('#type' => 'value', '#value' => 1);      $form['settings']['required'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['relations'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['tags'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['multiple'] = array('#type' => 'value', '#value' => FALSE);      unset($form['delete']);    }    // Hide multiple parents select from forum terms.    elseif ($form_id == 'taxonomy_form_term') {      $form['advanced']['parent']['#access'] = FALSE;    }  }  if ($form_id == 'forum_node_form') {    // Make the vocabulary required for 'real' forum-nodes.    $vid = variable_get('forum_nav_vocabulary', '');    $form['taxonomy'][$vid]['#required'] = TRUE;    $form['taxonomy'][$vid]['#options'][''] = t('- Please choose -');  }}/** * Implementation of hook_load(). */function forum_load($node) {  $forum = db_fetch_object(db_query('SELECT * FROM {forum} WHERE vid = %d', $node->vid));  return $forum;}/** * Implementation of hook_block(). * * Generates a block containing the currently active forum topics and the * most recently added forum topics. */function forum_block($op = 'list', $delta = 0, $edit = array()) {  switch ($op) {    case 'list':      $blocks[0]['info'] = t('Active forum topics');      $blocks[1]['info'] = t('New forum topics');      return $blocks;    case 'configure':      $form['forum_block_num_'. $delta] = array('#type' => 'select', '#title' => t('Number of topics'), '#default_value' => variable_get('forum_block_num_'. $delta, '5'), '#options' => drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)));      return $form;    case 'save':      variable_set('forum_block_num_'. $delta, $edit['forum_block_num_'. $delta]);      break;    case 'view':      if (user_access('access content')) {        switch ($delta) {          case 0:            $title = t('Active forum topics');            $sql = db_rewrite_sql("SELECT n.nid, n.title, l.comment_count, l.last_comment_timestamp FROM {node} n INNER JOIN {term_node} tn ON tn.vid = n.vid INNER JOIN {term_data} td ON td.tid = tn.tid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 AND td.vid = %d ORDER BY l.last_comment_timestamp DESC");            $result = db_query_range($sql, variable_get('forum_nav_vocabulary', ''), 0, variable_get('forum_block_num_0', '5'));            $content = node_title_list($result);            break;          case 1:            $title = t('New forum topics');            $sql = db_rewrite_sql("SELECT n.nid, n.title, l.comment_count FROM {node} n INNER JOIN {term_node} tn ON tn.vid = n.vid INNER JOIN {term_data} td ON td.tid = tn.tid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 AND td.vid = %d ORDER BY n.nid DESC");            $result = db_query_range($sql, variable_get('forum_nav_vocabulary', ''), 0, variable_get('forum_block_num_1', '5'));            $content = node_title_list($result);            break;        }        if (!empty($content)) {          $block['subject'] = $title;          $block['content'] = $content . theme('more_link', url('forum'), t('Read the latest forum topics.'));          return $block;        }      }  }}/** * Implementation of hook_form(). */function forum_form(&$node, $form_state) {  $type = node_get_types('type', $node);  $form['title'] = array('#type' => 'textfield', '#title' => check_plain($type->title_label), '#default_value' => !empty($node->title) ? $node->title : '', '#required' => TRUE, '#weight' => -5);  if (!empty($node->nid)) {    $vid = variable_get('forum_nav_vocabulary', '');    $forum_terms = taxonomy_node_get_terms_by_vocabulary($node, $vid);    // if editing, give option to leave shadows    $shadow = (count($forum_terms) > 1);    $form['shadow'] = array('#type' => 'checkbox', '#title' => t('Leave shadow copy'), '#default_value' => $shadow, '#description' => t('If you move this topic, you can leave a link in the old forum to the new forum.'));  }  $form['body_field'] = node_body_field($node, $type->body_label, 1);  $form['#submit'][] = 'forum_submit';  // Assign the forum topic submit handler.  return $form;}/** * Implementation of hook_term_path(). */function forum_term_path($term) {  return 'forum/'. $term->tid;}/** * Returns a list of all forums for a given taxonomy id * * Forum objects contain the following fields * -num_topics Number of topics in the forum * -num_posts Total number of posts in all topics * -last_post Most recent post for the forum * * @param $tid *   Taxonomy ID of the vocabulary that holds the forum list. * @return *   Array of object containing the forum information. */function forum_get_forums($tid = 0) {  $forums = array();  $vid = variable_get('forum_nav_vocabulary', '');  $_forums = taxonomy_get_tree($vid, $tid);  if (count($_forums)) {    $counts = array();    $sql = "SELECT r.tid, COUNT(n.nid) AS topic_count, SUM(l.comment_count) AS comment_count FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {term_node} r ON n.vid = r.vid WHERE n.status = 1 GROUP BY r.tid";    $sql = db_rewrite_sql($sql);    $_counts = db_query($sql);    while ($count = db_fetch_object($_counts)) {      $counts[$count->tid] = $count;    }  }  foreach ($_forums as $forum) {    if (in_array($forum->tid, variable_get('forum_containers', array()))) {      $forum->container = 1;    }    if (!empty($counts[$forum->tid])) {      $forum->num_topics = $counts[$forum->tid]->topic_count;      $forum->num_posts = $counts[$forum->tid]->topic_count + $counts[$forum->tid]->comment_count;    }    else {      $forum->num_topics = 0;      $forum->num_posts = 0;    }    // This query does not use full ANSI syntax since MySQL 3.x does not support    // table1 INNER JOIN table2 INNER JOIN table3 ON table2_criteria ON table3_criteria    // used to join node_comment_statistics to users.    $sql = "SELECT ncs.last_comment_timestamp, IF (ncs.last_comment_uid != 0, u2.name, ncs.last_comment_name) AS last_comment_name, ncs.last_comment_uid FROM {node} n INNER JOIN {users} u1 ON n.uid = u1.uid INNER JOIN {term_node} tn ON n.vid = tn.vid INNER JOIN {node_comment_statistics} ncs ON n.nid = ncs.nid INNER JOIN {users} u2 ON ncs.last_comment_uid=u2.uid WHERE n.status = 1 AND tn.tid = %d ORDER BY ncs.last_comment_timestamp DESC";    $sql = db_rewrite_sql($sql);    $topic = db_fetch_object(db_query_range($sql, $forum->tid, 0, 1));    $last_post = new stdClass();    if (!empty($topic->last_comment_timestamp)) {      $last_post->timestamp = $topic->last_comment_timestamp;      $last_post->name = $topic->last_comment_name;      $last_post->uid = $topic->last_comment_uid;    }    $forum->last_post = $last_post;    $forums[$forum->tid] = $forum;  }  return $forums;}/** * Calculate the number of nodes the user has not yet read and are newer * than NODE_NEW_LIMIT. */function _forum_topics_unread($term, $uid) {  $sql = "SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid AND tn.tid = %d LEFT JOIN {history} h ON n.nid = h.nid AND h.uid = %d WHERE n.status = 1 AND n.created > %d AND h.nid IS NULL";  $sql = db_rewrite_sql($sql);  return db_result(db_query($sql, $term, $uid, NODE_NEW_LIMIT));}function forum_get_topics($tid, $sortby, $forum_per_page) {  global $user, $forum_topic_list_header;  $forum_topic_list_header = array(    NULL,    array('data' => t('Topic'), 'field' => 'n.title'),    array('data' => t('Replies'), 'field' => 'l.comment_count'),    array('data' => t('Created'), 'field' => 'n.created'),    array('data' => t('Last reply'), 'field' => 'l.last_comment_timestamp'),  );  $order = _forum_get_topic_order($sortby);  for ($i = 0; $i < count($forum_topic_list_header); $i++) {    if ($forum_topic_list_header[$i]['field'] == $order['field']) {      $forum_topic_list_header[$i]['sort'] = $order['sort'];    }  }  $term = taxonomy_get_term($tid);  $sql = db_rewrite_sql("SELECT n.nid, r.tid, n.title, n.type, n.sticky, u.name, u.uid, n.created AS timestamp, n.comment AS comment_mode, l.last_comment_timestamp, IF(l.last_comment_uid != 0, cu.name, l.last_comment_name) AS last_comment_name, l.last_comment_uid, l.comment_count AS num_comments, f.tid AS forum_tid FROM {node_comment_statistics} l INNER JOIN {node} n ON n.nid = l.nid INNER JOIN {users} cu ON l.last_comment_uid = cu.uid INNER JOIN {term_node} r ON n.vid = r.vid INNER JOIN {users} u ON n.uid = u.uid INNER JOIN {forum} f ON n.vid = f.vid WHERE n.status = 1 AND r.tid = %d");  $sql .= tablesort_sql($forum_topic_list_header, 'n.sticky DESC,');  $sql .= ', n.created DESC';  // Always add a secondary sort order so that the news forum topics are on top.  $sql_count = db_rewrite_sql("SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} r ON n.vid = r.vid AND r.tid = %d WHERE n.status = 1");  $result = pager_query($sql, $forum_per_page, 0, $sql_count, $tid);  $topics = array();  while ($topic = db_fetch_object($result)) {    if ($user->uid) {      // folder is new if topic is new or there are new comments since last visit      if ($topic->tid != $tid) {        $topic->new = 0;      }      else {        $history = _forum_user_last_visit($topic->nid);        $topic->new_replies = comment_num_new($topic->nid, $history);        $topic->new = $topic->new_replies || ($topic->timestamp > $history);      }    }    else {      // Do not track "new replies" status for topics if the user is anonymous.      $topic->new_replies = 0;      $topic->new = 0;    }    if ($topic->num_comments > 0) {      $last_reply = new stdClass();      $last_reply->timestamp = $topic->last_comment_timestamp;      $last_reply->name = $topic->last_comment_name;      $last_reply->uid = $topic->last_comment_uid;      $topic->last_reply = $last_reply;    }    $topics[] = $topic;  }  return $topics;}/** * Finds the first unread node for a given forum. */function _forum_new($tid) {  global $user;  $sql = "SELECT n.nid FROM {node} n LEFT JOIN {history} h ON n.nid = h.nid AND h.uid = %d INNER JOIN {term_node} r ON n.nid = r.nid AND r.tid = %d WHERE n.status = 1 AND h.nid IS NULL AND n.created > %d ORDER BY created";  $sql = db_rewrite_sql($sql);  $nid = db_result(db_query_range($sql, $user->uid, $tid, NODE_NEW_LIMIT, 0, 1));  return $nid ? $nid : 0;}/** * Process variables for forums.tpl.php * * The $variables array contains the following arguments: * - $forums * - $topics * - $parents * - $tid * - $sortby * - $forum_per_page * * @see forums.tpl.php */function template_preprocess_forums(&$variables) {  global $user;  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  $title = !empty($vocabulary->name) ? $vocabulary->name : '';  // Breadcrumb navigation:  $breadcrumb[] = l(t('Home'), NULL);  if ($variables['tid']) {    $breadcrumb[] = l($vocabulary->name, 'forum');  }  if ($variables['parents']) {    $variables['parents'] = array_reverse($variables['parents']);    foreach ($variables['parents'] as $p) {      if ($p->tid == $variables['tid']) {        $title = $p->name;      }      else {        $breadcrumb[] = l($p->name, 'forum/'. $p->tid);      }    }  }  drupal_set_breadcrumb($breadcrumb);  drupal_set_title(check_plain($title));  if ($variables['forums_defined'] = count($variables['forums']) || count($variables['parents'])) {    // Format the "post new content" links listing.    $forum_types = array();    // Loop through all node types for forum vocabulary.    foreach ($vocabulary->nodes as $type) {      // Check if the current user has the 'create' permission for this node type.      if (node_access('create', $type)) {        // Fetch the "General" name of the content type;        // Push the link with title and url to the array.        $forum_types[$type] = array('title' => t('Post new @node_type', array('@node_type' => node_get_types('name', $type))), 'href' => 'node/add/'. str_replace('_', '-', $type) .'/'. $variables['tid']);      }    }    if (empty($forum_types)) {      // The user is logged-in; but denied access to create any new forum content type.      if ($user->uid) {        $forum_types['disallowed'] = array('title' => t('You are not allowed to post new content in the forum.'));      }      // The user is not logged-in; and denied access to create any new forum content type.      else {        $forum_types['login'] = array('title' => t('<a href="@login">Login</a> to post new content in the forum.', array('@login' => url('user/login', array('query' => drupal_get_destination())))), 'html' => TRUE);      }    }    $variables['links'] = $forum_types;    if (!empty($variables['forums'])) {      $variables['forums'] = theme('forum_list', $variables['forums'], $variables['parents'], $variables['tid']);    }    else {      $variables['forums'] = '';    }    if ($variables['tid'] && !in_array($variables['tid'], variable_get('forum_containers', array()))) {      $variables['topics'] = theme('forum_topic_list', $variables['tid'], $variables['topics'], $variables['sortby'], $variables['forum_per_page']);      drupal_add_feed(url('taxonomy/term/'. $variables['tid'] .'/0/feed'), 'RSS - '. $title);    }    else {      $variables['topics'] = '';    }    // Provide separate template suggestions based on what's being output. Topic id is also accounted for.    // Check both variables to be safe then the inverse. Forums with topic ID's take precedence.    if ($variables['forums'] && !$variables['topics']) {      $variables['template_files'][] = 'forums-containers';      $variables['template_files'][] = 'forums-'. $variables['tid'];      $variables['template_files'][] = 'forums-containers-'. $variables['tid'];    }    elseif (!$variables['forums'] && $variables['topics']) {      $variables['template_files'][] = 'forums-topics';      $variables['template_files'][] = 'forums-'. $variables['tid'];      $variables['template_files'][] = 'forums-topics-'. $variables['tid'];    }    else {      $variables['template_files'][] = 'forums-'. $variables['tid'];    }  }  else {    drupal_set_title(t('No forums defined'));    $variables['links'] = array();    $variables['forums'] = '';    $variables['topics'] = '';  }}/** * Process variables to format a forum listing. * * $variables contains the following information: * - $forums * - $parents * - $tid * * @see forum-list.tpl.php * @see theme_forum_list() */function template_preprocess_forum_list(&$variables) {  global $user;  $row = 0;  // Sanitize each forum so that the template can safely print the data.  foreach ($variables['forums'] as $id => $forum) {    $variables['forums'][$id]->description = !empty($forum->description) ? filter_xss_admin($forum->description) : '';    $variables['forums'][$id]->link = url("forum/$forum->tid");    $variables['forums'][$id]->name = check_plain($forum->name);    $variables['forums'][$id]->is_container = !empty($forum->container);    $variables['forums'][$id]->zebra = $row % 2 == 0 ? 'odd' : 'even';    $row++;    $variables['forums'][$id]->new_text = '';    $variables['forums'][$id]->new_url = '';    $variables['forums'][$id]->new_topics = 0;    $variables['forums'][$id]->old_topics = $forum->num_topics;    if ($user->uid) {      $variables['forums'][$id]->new_topics = _forum_topics_unread($forum->tid, $user->uid);      if ($variables['forums'][$id]->new_topics) {        $variables['forums'][$id]->new_text = format_plural($variables['forums'][$id]->new_topics, '1 new', '@count new');        $variables['forums'][$id]->new_url = url("forum/$forum->tid", array('fragment' => 'new'));      }      $variables['forums'][$id]->old_topics = $forum->num_topics - $variables['forums'][$id]->new_topics;    }    $variables['forums'][$id]->last_reply = theme('forum_submitted', $forum->last_post);  }  // Give meaning to $tid for themers. $tid actually stands for term id.  $variables['forum_id'] = $variables['tid'];  unset($variables['tid']);}/** * Preprocess variables to format the topic listing. * * $variables contains the following data: * - $tid * - $topics * - $sortby * - $forum_per_page * * @see forum-topic-list.tpl.php * @see theme_forum_topic_list() */function template_preprocess_forum_topic_list(&$variables) {  global $forum_topic_list_header;  // Create the tablesorting header.  $ts = tablesort_init($forum_topic_list_header);  $header = '';  foreach ($forum_topic_list_header as $cell) {    $cell = tablesort_header($cell, $forum_topic_list_header, $ts);    $header .= _theme_table_cell($cell, TRUE);  }  $variables['header'] = $header;  if (!empty($variables['topics'])) {    $row = 0;    foreach ($variables['topics'] as $id => $topic) {      $variables['topics'][$id]->icon = theme('forum_icon', $topic->new, $topic->num_comments, $topic->comment_mode, $topic->sticky);      $variables['topics'][$id]->zebra = $row % 2 == 0 ? 'odd' : 'even';      $row++;      // We keep the actual tid in forum table, if it's different from the      // current tid then it means the topic appears in two forums, one of      // them is a shadow copy.      if ($topic->forum_tid != $variables['tid']) {        $variables['topics'][$id]->moved = TRUE;        $variables['topics'][$id]->title = check_plain($topic->title);        $variables['topics'][$id]->message = l(t('This topic has been moved'), "forum/$topic->forum_tid");      }      else {        $variables['topics'][$id]->moved = FALSE;        $variables['topics'][$id]->title = l($topic->title, "node/$topic->nid");        $variables['topics'][$id]->message = '';      }      $variables['topics'][$id]->created = theme('forum_submitted', $topic);      $variables['topics'][$id]->last_reply = theme('forum_submitted', isset($topic->last_reply) ? $topic->last_reply : NULL);      $variables['topics'][$id]->new_text = '';      $variables['topics'][$id]->new_url = '';      if ($topic->new_replies) {        $variables['topics'][$id]->new_text = format_plural($topic->new_replies, '1 new', '@count new');        $variables['topics'][$id]->new_url = url("node/$topic->nid", array('query' => comment_new_page_count($topic->num_comments, $topic->new_replies, $topic), 'fragment' => 'new'));      }    }  }  else {    // Make this safe for the template    $variables['topics'] = array();  }  // Give meaning to $tid for themers. $tid actually stands for term id.  $variables['topic_id'] = $variables['tid'];  unset($variables['tid']);  $variables['pager'] = theme('pager', NULL, $variables['forum_per_page'], 0);}/** * Process variables to format the icon for each individual topic. * * $variables contains the following data: * - $new_posts * - $num_posts = 0 * - $comment_mode = 0 * - $sticky = 0 * * @see forum-icon.tpl.php * @see theme_forum_icon() */function template_preprocess_forum_icon(&$variables) {  $variables['hot_threshold'] = variable_get('forum_hot_topic', 15);  if ($variables['num_posts'] > $variables['hot_threshold']) {    $variables['icon'] = $variables['new_posts'] ? 'hot-new' : 'hot';  }  else {    $variables['icon'] = $variables['new_posts'] ? 'new' : 'default';  }  if ($variables['comment_mode'] == COMMENT_NODE_READ_ONLY || $variables['comment_mode'] == COMMENT_NODE_DISABLED) {    $variables['icon'] = 'closed';  }  if ($variables['sticky'] == 1) {    $variables['icon'] = 'sticky';  }}/** * Preprocess variables to format the next/previous forum topic navigation links. * * $variables contains $node. * * @see forum-topic-navigation.tpl.php * @see theme_forum_topic_navigation() */function template_preprocess_forum_topic_navigation(&$variables) {  $output = '';  // get previous and next topic  $sql = "SELECT n.nid, n.title, n.sticky, l.comment_count, l.last_comment_timestamp FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {term_node} r ON n.nid = r.nid AND r.tid = %d WHERE n.status = 1 ORDER BY n.sticky DESC, ". _forum_get_topic_order_sql(variable_get('forum_order', 1));  $result = db_query(db_rewrite_sql($sql), isset($variables['node']->tid) ? $variables['node']->tid : 0);  $stop = $variables['prev'] = $variables['next'] = 0;  while ($topic = db_fetch_object($result)) {    if ($stop == 1) {      $variables['next'] = $topic->nid;      $variables['next_title'] = check_plain($topic->title);      $variables['next_url'] = url("node/$topic->nid");      break;    }    if ($topic->nid == $variables['node']->nid) {      $stop = 1;    }    else {      $variables['prev'] = $topic->nid;      $variables['prev_title'] = check_plain($topic->title);      $variables['prev_url'] = url("node/$topic->nid");    }  }}/** * Process variables to format submission info for display in the forum list and topic list. * * $variables will contain: $topic * * @see forum-submitted.tpl.php * @see theme_forum_submitted() */function template_preprocess_forum_submitted(&$variables) {  $variables['author'] = isset($variables['topic']->uid) ? theme('username', $variables['topic']) : '';  $variables['time'] = isset($variables['topic']->timestamp) ? format_interval(time() - $variables['topic']->timestamp) : '';}function _forum_user_last_visit($nid) {  global $user;  static $history = array();  if (empty($history)) {    $result = db_query('SELECT nid, timestamp FROM {history} WHERE uid = %d', $user->uid);    while ($t = db_fetch_object($result)) {      $history[$t->nid] = $t->timestamp > NODE_NEW_LIMIT ? $t->timestamp : NODE_NEW_LIMIT;    }  }  return isset($history[$nid]) ? $history[$nid] : NODE_NEW_LIMIT;}function _forum_get_topic_order($sortby) {  switch ($sortby) {    case 1:      return array('field' => 'l.last_comment_timestamp', 'sort' => 'desc');      break;    case 2:      return array('field' => 'l.last_comment_timestamp', 'sort' => 'asc');      break;    case 3:      return array('field' => 'l.comment_count', 'sort' => 'desc');      break;    case 4:      return array('field' => 'l.comment_count', 'sort' => 'asc');      break;  }}function _forum_get_topic_order_sql($sortby) {  $order = _forum_get_topic_order($sortby);  return $order['field'] .' '. strtoupper($order['sort']);}
<?php// $Id$/** * @file * Admin page callbacks for the search module. *//** * Menu callback: confirm wiping of the index. */function search_wipe_confirm() {  return confirm_form(array(), t('Are you sure you want to re-index the site?'),                  'admin/settings/search', t(' The search index is not cleared but systematically updated to reflect the new settings. Searching will continue to work but new content won\'t be indexed until all existing content has been re-indexed. This action cannot be undone.'), t('Re-index site'), t('Cancel'));}/** * Handler for wipe confirmation */function search_wipe_confirm_submit(&$form, &$form_state) {  if ($form['confirm']) {    search_wipe();    drupal_set_message(t('The index will be rebuilt.'));    $form_state['redirect'] = 'admin/settings/search';    return;  }}/** * Menu callback; displays the search module settings page. * * @ingroup forms * @see system_settings_form() * @see search_admin_settings_validate() */function search_admin_settings() {  // Collect some stats  $remaining = 0;  $total = 0;  foreach (module_list() as $module) {    if (module_hook($module, 'search')) {      $status = module_invoke($module, 'search', 'status');      $remaining += $status['remaining'];      $total += $status['total'];    }  }  $count = format_plural($remaining, 'There is 1 item left to index.', 'There are @count items left to index.');  $percentage = ((int)min(100, 100 * ($total - $remaining) / max(1, $total))) .'%';  $status = '<p><strong>'. t('%percentage of the site has been indexed.', array('%percentage' => $percentage)) .' '. $count .'</strong></p>';  $form['status'] = array('#type' => 'fieldset', '#title' => t('Indexing status'));  $form['status']['status'] = array('#value' => $status);  $form['status']['wipe'] = array('#type' => 'submit', '#value' => t('Re-index site'));  $items = drupal_map_assoc(array(10, 20, 50, 100, 200, 500));  // Indexing throttle:  $form['indexing_throttle'] = array('#type' => 'fieldset', '#title' => t('Indexing throttle'));  $form['indexing_throttle']['search_cron_limit'] = array('#type' => 'select', '#title' => t('Number of items to index per cron run'), '#default_value' => variable_get('search_cron_limit', 100), '#options' => $items, '#description' => t('The maximum number of items indexed in each pass of a <a href="@cron">cron maintenance task</a>. If necessary, reduce the number of items to prevent timeouts and memory errors while indexing.', array('@cron' => url('admin/reports/status'))));  // Indexing settings:  $form['indexing_settings'] = array('#type' => 'fieldset', '#title' => t('Indexing settings'));  $form['indexing_settings']['info'] = array('#value' => t('<p><em>Changing the settings below will cause the site index to be rebuilt. The search index is not cleared but systematically updated to reflect the new settings. Searching will continue to work but new content won\'t be indexed until all existing content has been re-indexed.</em></p><p><em>The default settings should be appropriate for the majority of sites.</em></p>'));  $form['indexing_settings']['minimum_word_size'] = array('#type' => 'textfield', '#title' => t('Minimum word length to index'), '#default_value' => variable_get('minimum_word_size', 3), '#size' => 5, '#maxlength' => 3, '#description' => t('The number of characters a word has to be to be indexed. A lower setting means better search result ranking, but also a larger database. Each search query must contain at least one keyword that is this size (or longer).'));  $form['indexing_settings']['overlap_cjk'] = array('#type' => 'checkbox', '#title' => t('Simple CJK handling'), '#default_value' => variable_get('overlap_cjk', TRUE), '#description' => t('Whether to apply a simple Chinese/Japanese/Korean tokenizer based on overlapping sequences. Turn this off if you want to use an external preprocessor for this instead. Does not affect other languages.'));  $form['#validate'] = array('search_admin_settings_validate');  // Per module settings  $form = array_merge($form, module_invoke_all('search', 'admin'));  return system_settings_form($form);}/** * Validate callback. */function search_admin_settings_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Re-index site')) {    drupal_goto('admin/settings/search/wipe');  }  // If these settings change, the index needs to be rebuilt.  if ((variable_get('minimum_word_size', 3) != $form_state['values']['minimum_word_size']) ||      (variable_get('overlap_cjk', TRUE) != $form_state['values']['overlap_cjk'])) {    drupal_set_message(t('The index will be rebuilt.'));    search_wipe();  }}
<?php// $Id$/** * Implementation of hook_install(). */function search_install() {  // Create tables.  drupal_install_schema('search');}/** * Implementation of hook_uninstall(). */function search_uninstall() {  // Remove tables.  drupal_uninstall_schema('search');  variable_del('minimum_word_size');  variable_del('overlap_cjk');  variable_del('search_cron_limit');}/** * Implementation of hook_schema(). */function search_schema() {  $schema['search_dataset'] = array(    'description' => 'Stores items that will be searched.',    'fields' => array(      'sid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Search item ID, e.g. node ID for nodes.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => FALSE,        'description' => 'Type of item, e.g. node.',      ),      'data' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'List of space-separated words from the item.',      ),      'reindex' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Set to force node reindexing.',      ),    ),    'unique keys' => array('sid_type' => array('sid', 'type')),  );  $schema['search_index'] = array(    'description' => 'Stores the search index, associating words, items and scores.',    'fields' => array(      'word' => array(        'type' => 'varchar',        'length' => 50,        'not null' => TRUE,        'default' => '',        'description' => 'The {search_total}.word that is associated with the search item.',      ),      'sid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {search_dataset}.sid of the searchable item to which the word belongs.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => FALSE,        'description' => 'The {search_dataset}.type of the searchable item to which the word belongs.',      ),      'score' => array(        'type' => 'float',        'not null' => FALSE,        'description' => 'The numeric score of the word, higher being more important.',      ),    ),    'indexes' => array(      'sid_type' => array('sid', 'type'),      'word' => array('word')    ),    'unique keys' => array('word_sid_type' => array('word', 'sid', 'type')),  );  $schema['search_total'] = array(    'description' => 'Stores search totals for words.',    'fields' => array(      'word' => array(        'description' => 'Primary Key: Unique word in the search index.',        'type' => 'varchar',        'length' => 50,        'not null' => TRUE,        'default' => '',      ),      'count' => array(        'description' => "The count of the word in the index using Zipf's law to equalize the probability distribution.",        'type' => 'float',        'not null' => FALSE,      ),    ),    'primary key' => array('word'),  );  $schema['search_node_links'] = array(    'description' => 'Stores items (like nodes) that link to other nodes, used to improve search scores for nodes that are frequently linked to.',    'fields' => array(      'sid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {search_dataset}.sid of the searchable item containing the link to the node.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => TRUE,        'default' => '',        'description' => 'The {search_dataset}.type of the searchable item containing the link to the node.',      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid that this item links to.',      ),      'caption' => array(        'type' => 'text',        'size' => 'big',        'not null' => FALSE,        'description' => 'The text used to link to the {node}.nid.',      ),    ),    'primary key' => array('sid', 'type', 'nid'),    'indexes' => array('nid' => array('nid')),  );  return $schema;}
<?php// $Id$?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="<?php print $language->language ?>" xml:lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>"><head>  <?php print $head ?>  <title><?php print $head_title ?></title>  <?php print $styles ?>  <?php print $scripts ?>  <script type="text/javascript"><?php /* Needed to avoid Flash of Unstyle Content in IE */ ?> </script></head><body><table border="0" cellpadding="0" cellspacing="0" id="header">  <tr>    <td id="logo">      <?php if ($logo) { ?><a href="<?php print $front_page ?>" title="<?php print t('Home') ?>"><img src="<?php print $logo ?>" alt="<?php print t('Home') ?>" /></a><?php } ?>      <?php if ($site_name) { ?><h1 class='site-name'><a href="<?php print $front_page ?>" title="<?php print t('Home') ?>"><?php print $site_name ?></a></h1><?php } ?>      <?php if ($site_slogan) { ?><div class='site-slogan'><?php print $site_slogan ?></div><?php } ?>    </td>    <td id="menu">      <?php if (isset($secondary_links)) { ?><?php print theme('links', $secondary_links, array('class' => 'links', 'id' => 'subnavlist')) ?><?php } ?>      <?php if (isset($primary_links)) { ?><?php print theme('links', $primary_links, array('class' => 'links', 'id' => 'navlist')) ?><?php } ?>      <?php print $search_box ?>    </td>  </tr>  <tr>    <td colspan="2"><div><?php print $header ?></div></td>  </tr></table><table border="0" cellpadding="0" cellspacing="0" id="content">  <tr>    <?php if ($left) { ?><td id="sidebar-left">      <?php print $left ?>    </td><?php } ?>    <td valign="top">      <?php if ($mission) { ?><div id="mission"><?php print $mission ?></div><?php } ?>      <div id="main">        <?php print $breadcrumb ?>        <h1 class="title"><?php print $title ?></h1>        <div class="tabs"><?php print $tabs ?></div>        <?php if ($show_messages) { print $messages; } ?>        <?php print $help ?>        <?php print $content; ?>        <?php print $feed_icons; ?>      </div>    </td>    <?php if ($right) { ?><td id="sidebar-right">      <?php print $right ?>    </td><?php } ?>  </tr></table><div id="footer">  <?php print $footer_message ?>  <?php print $footer ?></div><?php print $closure ?></body></html>
<?php// $Id$/** * @file * Enables site-wide keyword searching. *//** * Matches Unicode character classes to exclude from the search index. * * See: http://www.unicode.org/Public/UNIDATA/UCD.html#General_Category_Values * * The index only contains the following character classes: * Lu     Letter, Uppercase * Ll     Letter, Lowercase * Lt     Letter, Titlecase * Lo     Letter, Other * Nd     Number, Decimal Digit * No     Number, Other */define('PREG_CLASS_SEARCH_EXCLUDE','\x{0}-\x{2f}\x{3a}-\x{40}\x{5b}-\x{60}\x{7b}-\x{bf}\x{d7}\x{f7}\x{2b0}-'.'\x{385}\x{387}\x{3f6}\x{482}-\x{489}\x{559}-\x{55f}\x{589}-\x{5c7}\x{5f3}-'.'\x{61f}\x{640}\x{64b}-\x{65e}\x{66a}-\x{66d}\x{670}\x{6d4}\x{6d6}-\x{6ed}'.'\x{6fd}\x{6fe}\x{700}-\x{70f}\x{711}\x{730}-\x{74a}\x{7a6}-\x{7b0}\x{901}-'.'\x{903}\x{93c}\x{93e}-\x{94d}\x{951}-\x{954}\x{962}-\x{965}\x{970}\x{981}-'.'\x{983}\x{9bc}\x{9be}-\x{9cd}\x{9d7}\x{9e2}\x{9e3}\x{9f2}-\x{a03}\x{a3c}-'.'\x{a4d}\x{a70}\x{a71}\x{a81}-\x{a83}\x{abc}\x{abe}-\x{acd}\x{ae2}\x{ae3}'.'\x{af1}-\x{b03}\x{b3c}\x{b3e}-\x{b57}\x{b70}\x{b82}\x{bbe}-\x{bd7}\x{bf0}-'.'\x{c03}\x{c3e}-\x{c56}\x{c82}\x{c83}\x{cbc}\x{cbe}-\x{cd6}\x{d02}\x{d03}'.'\x{d3e}-\x{d57}\x{d82}\x{d83}\x{dca}-\x{df4}\x{e31}\x{e34}-\x{e3f}\x{e46}-'.'\x{e4f}\x{e5a}\x{e5b}\x{eb1}\x{eb4}-\x{ebc}\x{ec6}-\x{ecd}\x{f01}-\x{f1f}'.'\x{f2a}-\x{f3f}\x{f71}-\x{f87}\x{f90}-\x{fd1}\x{102c}-\x{1039}\x{104a}-'.'\x{104f}\x{1056}-\x{1059}\x{10fb}\x{10fc}\x{135f}-\x{137c}\x{1390}-\x{1399}'.'\x{166d}\x{166e}\x{1680}\x{169b}\x{169c}\x{16eb}-\x{16f0}\x{1712}-\x{1714}'.'\x{1732}-\x{1736}\x{1752}\x{1753}\x{1772}\x{1773}\x{17b4}-\x{17db}\x{17dd}'.'\x{17f0}-\x{180e}\x{1843}\x{18a9}\x{1920}-\x{1945}\x{19b0}-\x{19c0}\x{19c8}'.'\x{19c9}\x{19de}-\x{19ff}\x{1a17}-\x{1a1f}\x{1d2c}-\x{1d61}\x{1d78}\x{1d9b}-'.'\x{1dc3}\x{1fbd}\x{1fbf}-\x{1fc1}\x{1fcd}-\x{1fcf}\x{1fdd}-\x{1fdf}\x{1fed}-'.'\x{1fef}\x{1ffd}-\x{2070}\x{2074}-\x{207e}\x{2080}-\x{2101}\x{2103}-\x{2106}'.'\x{2108}\x{2109}\x{2114}\x{2116}-\x{2118}\x{211e}-\x{2123}\x{2125}\x{2127}'.'\x{2129}\x{212e}\x{2132}\x{213a}\x{213b}\x{2140}-\x{2144}\x{214a}-\x{2b13}'.'\x{2ce5}-\x{2cff}\x{2d6f}\x{2e00}-\x{3005}\x{3007}-\x{303b}\x{303d}-\x{303f}'.'\x{3099}-\x{309e}\x{30a0}\x{30fb}-\x{30fe}\x{3190}-\x{319f}\x{31c0}-\x{31cf}'.'\x{3200}-\x{33ff}\x{4dc0}-\x{4dff}\x{a015}\x{a490}-\x{a716}\x{a802}\x{a806}'.'\x{a80b}\x{a823}-\x{a82b}\x{d800}-\x{f8ff}\x{fb1e}\x{fb29}\x{fd3e}\x{fd3f}'.'\x{fdfc}-\x{fe6b}\x{feff}-\x{ff0f}\x{ff1a}-\x{ff20}\x{ff3b}-\x{ff40}\x{ff5b}-'.'\x{ff65}\x{ff70}\x{ff9e}\x{ff9f}\x{ffe0}-\x{fffd}');/** * Matches all 'N' Unicode character classes (numbers) */define('PREG_CLASS_NUMBERS','\x{30}-\x{39}\x{b2}\x{b3}\x{b9}\x{bc}-\x{be}\x{660}-\x{669}\x{6f0}-\x{6f9}'.'\x{966}-\x{96f}\x{9e6}-\x{9ef}\x{9f4}-\x{9f9}\x{a66}-\x{a6f}\x{ae6}-\x{aef}'.'\x{b66}-\x{b6f}\x{be7}-\x{bf2}\x{c66}-\x{c6f}\x{ce6}-\x{cef}\x{d66}-\x{d6f}'.'\x{e50}-\x{e59}\x{ed0}-\x{ed9}\x{f20}-\x{f33}\x{1040}-\x{1049}\x{1369}-'.'\x{137c}\x{16ee}-\x{16f0}\x{17e0}-\x{17e9}\x{17f0}-\x{17f9}\x{1810}-\x{1819}'.'\x{1946}-\x{194f}\x{2070}\x{2074}-\x{2079}\x{2080}-\x{2089}\x{2153}-\x{2183}'.'\x{2460}-\x{249b}\x{24ea}-\x{24ff}\x{2776}-\x{2793}\x{3007}\x{3021}-\x{3029}'.'\x{3038}-\x{303a}\x{3192}-\x{3195}\x{3220}-\x{3229}\x{3251}-\x{325f}\x{3280}-'.'\x{3289}\x{32b1}-\x{32bf}\x{ff10}-\x{ff19}');/** * Matches all 'P' Unicode character classes (punctuation) */define('PREG_CLASS_PUNCTUATION','\x{21}-\x{23}\x{25}-\x{2a}\x{2c}-\x{2f}\x{3a}\x{3b}\x{3f}\x{40}\x{5b}-\x{5d}'.'\x{5f}\x{7b}\x{7d}\x{a1}\x{ab}\x{b7}\x{bb}\x{bf}\x{37e}\x{387}\x{55a}-\x{55f}'.'\x{589}\x{58a}\x{5be}\x{5c0}\x{5c3}\x{5f3}\x{5f4}\x{60c}\x{60d}\x{61b}\x{61f}'.'\x{66a}-\x{66d}\x{6d4}\x{700}-\x{70d}\x{964}\x{965}\x{970}\x{df4}\x{e4f}'.'\x{e5a}\x{e5b}\x{f04}-\x{f12}\x{f3a}-\x{f3d}\x{f85}\x{104a}-\x{104f}\x{10fb}'.'\x{1361}-\x{1368}\x{166d}\x{166e}\x{169b}\x{169c}\x{16eb}-\x{16ed}\x{1735}'.'\x{1736}\x{17d4}-\x{17d6}\x{17d8}-\x{17da}\x{1800}-\x{180a}\x{1944}\x{1945}'.'\x{2010}-\x{2027}\x{2030}-\x{2043}\x{2045}-\x{2051}\x{2053}\x{2054}\x{2057}'.'\x{207d}\x{207e}\x{208d}\x{208e}\x{2329}\x{232a}\x{23b4}-\x{23b6}\x{2768}-'.'\x{2775}\x{27e6}-\x{27eb}\x{2983}-\x{2998}\x{29d8}-\x{29db}\x{29fc}\x{29fd}'.'\x{3001}-\x{3003}\x{3008}-\x{3011}\x{3014}-\x{301f}\x{3030}\x{303d}\x{30a0}'.'\x{30fb}\x{fd3e}\x{fd3f}\x{fe30}-\x{fe52}\x{fe54}-\x{fe61}\x{fe63}\x{fe68}'.'\x{fe6a}\x{fe6b}\x{ff01}-\x{ff03}\x{ff05}-\x{ff0a}\x{ff0c}-\x{ff0f}\x{ff1a}'.'\x{ff1b}\x{ff1f}\x{ff20}\x{ff3b}-\x{ff3d}\x{ff3f}\x{ff5b}\x{ff5d}\x{ff5f}-'.'\x{ff65}');/** * Matches all CJK characters that are candidates for auto-splitting * (Chinese, Japanese, Korean). * Contains kana and BMP ideographs. */define('PREG_CLASS_CJK', '\x{3041}-\x{30ff}\x{31f0}-\x{31ff}\x{3400}-\x{4db5}'.'\x{4e00}-\x{9fbb}\x{f900}-\x{fad9}');/** * Implementation of hook_help(). */function search_help($path, $arg) {  switch ($path) {    case 'admin/help#search':      $output = '<p>'. t('The search module adds the ability to search for content by keywords. Search is often the only practical way to find content on a large site, and is useful for finding both users and posts.') .'</p>';      $output .= '<p>'. t('To provide keyword searching, the search engine maintains an index of words found in your site\'s content. To build and maintain this index, a correctly configured <a href="@cron">cron maintenance task</a> is required. Indexing behavior can be adjusted using the <a href="@searchsettings">search settings page</a>; for example, the <em>Number of items to index per cron run</em> sets the maximum number of items indexed in each pass of a <a href="@cron">cron maintenance task</a>. If necessary, reduce this number to prevent timeouts and memory errors when indexing.', array('@cron' => url('admin/reports/status'), '@searchsettings' => url('admin/settings/search'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@search">Search module</a>.', array('@search' => 'http://drupal.org/handbook/modules/search/')) .'</p>';      return $output;    case 'admin/settings/search':      return '<p>'. t('The search engine maintains an index of words found in your site\'s content. To build and maintain this index, a correctly configured <a href="@cron">cron maintenance task</a> is required. Indexing behavior can be adjusted using the settings below.', array('@cron' => url('admin/reports/status'))) .'</p>';    case 'search#noresults':      return t('<ul><li>Check if your spelling is correct.</li><li>Remove quotes around phrases to match each word individually: <em>"blue smurf"</em> will match less than <em>blue smurf</em>.</li><li>Consider loosening your query with <em>OR</em>: <em>blue smurf</em> will match less than <em>blue OR smurf</em>.</li></ul>');  }}/** * Implementation of hook_theme() */function search_theme() {  return array(    'search_theme_form' => array(      'arguments' => array('form' => NULL),      'template' => 'search-theme-form',    ),    'search_block_form' => array(      'arguments' => array('form' => NULL),      'template' => 'search-block-form',    ),    'search_result' => array(      'arguments' => array('result' => NULL, 'type' => NULL),      'file' => 'search.pages.inc',      'template' => 'search-result',    ),    'search_results' => array(      'arguments' => array('results' => NULL, 'type' => NULL),      'file' => 'search.pages.inc',      'template' => 'search-results',    ),  );}/** * Implementation of hook_perm(). */function search_perm() {  return array('search content', 'use advanced search', 'administer search');}/** * Implementation of hook_block(). */function search_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Search form');    // Not worth caching.    $blocks[0]['cache'] = BLOCK_NO_CACHE;    return $blocks;  }  else if ($op == 'view' && user_access('search content')) {    $block['content'] = drupal_get_form('search_block_form');    $block['subject'] = t('Search');    return $block;  }}/** * Implementation of hook_menu(). */function search_menu() {  $items['search'] = array(    'title' => 'Search',    'page callback' => 'search_view',    'access arguments' => array('search content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'search.pages.inc',  );  $items['admin/settings/search'] = array(    'title' => 'Search settings',    'description' => 'Configure relevance settings for search and other indexing options',    'page callback' => 'drupal_get_form',    'page arguments' => array('search_admin_settings'),    'access arguments' => array('administer search'),    'type' => MENU_NORMAL_ITEM,    'file' => 'search.admin.inc',  );  $items['admin/settings/search/wipe'] = array(    'title' => 'Clear index',    'page callback' => 'drupal_get_form',    'page arguments' => array('search_wipe_confirm'),    'access arguments' => array('administer search'),    'type' => MENU_CALLBACK,    'file' => 'search.admin.inc',  );  $items['admin/reports/search'] = array(    'title' => 'Top search phrases',    'description' => 'View most popular search phrases.',    'page callback' => 'dblog_top',    'page arguments' => array('search'),    'access arguments' => array('access site reports'),    'file' => 'dblog.admin.inc',    'file path' => drupal_get_path('module', 'dblog'),  );  foreach (module_implements('search') as $name) {    $items['search/'. $name .'/%menu_tail'] = array(      'title callback' => 'module_invoke',      'title arguments' => array($name, 'search', 'name', TRUE),      'page callback' => 'search_view',      'page arguments' => array($name),      'access callback' => '_search_menu',      'access arguments' => array($name),      'type' => MENU_LOCAL_TASK,      'parent' => 'search',      'file' => 'search.pages.inc',    );  }  return $items;}function _search_menu($name) {  return user_access('search content') && module_invoke($name, 'search', 'name');}/** * Wipes a part of or the entire search index. * * @param $sid *  (optional) The SID of the item to wipe. If specified, $type must be passed *  too. * @param $type *  (optional) The type of item to wipe. */function search_wipe($sid = NULL, $type = NULL, $reindex = FALSE) {  if ($type == NULL && $sid == NULL) {    module_invoke_all('search', 'reset');  }  else {    db_query("DELETE FROM {search_dataset} WHERE sid = %d AND type = '%s'", $sid, $type);    db_query("DELETE FROM {search_index} WHERE sid = %d AND type = '%s'", $sid, $type);    // Don't remove links if re-indexing.    if (!$reindex) {      db_query("DELETE FROM {search_node_links} WHERE sid = %d AND type = '%s'", $sid, $type);    }  }}/** * Marks a word as dirty (or retrieves the list of dirty words). This is used * during indexing (cron). Words which are dirty have outdated total counts in * the search_total table, and need to be recounted. */function search_dirty($word = NULL) {  static $dirty = array();  if ($word !== NULL) {    $dirty[$word] = TRUE;  }  else {    return $dirty;  }}/** * Implementation of hook_cron(). * * Fires hook_update_index() in all modules and cleans up dirty words (see * search_dirty). */function search_cron() {  // We register a shutdown function to ensure that search_total is always up  // to date.  register_shutdown_function('search_update_totals');  // Update word index  foreach (module_list() as $module) {    module_invoke($module, 'update_index');  }}/** * This function is called on shutdown to ensure that search_total is always * up to date (even if cron times out or otherwise fails). */function search_update_totals() {  // Update word IDF (Inverse Document Frequency) counts for new/changed words  foreach (search_dirty() as $word => $dummy) {    // Get total count    $total = db_result(db_query("SELECT SUM(score) FROM {search_index} WHERE word = '%s'", $word));    // Apply Zipf's law to equalize the probability distribution    $total = log10(1 + 1/(max(1, $total)));    db_query("UPDATE {search_total} SET count = %f WHERE word = '%s'", $total, $word);    if (!db_affected_rows()) {      db_query("INSERT INTO {search_total} (word, count) VALUES ('%s', %f)", $word, $total);    }  }  // Find words that were deleted from search_index, but are still in  // search_total. We use a LEFT JOIN between the two tables and keep only the  // rows which fail to join.  $result = db_query("SELECT t.word AS realword, i.word FROM {search_total} t LEFT JOIN {search_index} i ON t.word = i.word WHERE i.word IS NULL");  while ($word = db_fetch_object($result)) {    db_query("DELETE FROM {search_total} WHERE word = '%s'", $word->realword);  }}/** * Simplifies a string according to indexing rules. */function search_simplify($text) {  // Decode entities to UTF-8  $text = decode_entities($text);  // Lowercase  $text = drupal_strtolower($text);  // Call an external processor for word handling.  search_invoke_preprocess($text);  // Simple CJK handling  if (variable_get('overlap_cjk', TRUE)) {    $text = preg_replace_callback('/['. PREG_CLASS_CJK .']+/u', 'search_expand_cjk', $text);  }  // To improve searching for numerical data such as dates, IP addresses  // or version numbers, we consider a group of numerical characters  // separated only by punctuation characters to be one piece.  // This also means that searching for e.g. '20/03/1984' also returns  // results with '20-03-1984' in them.  // Readable regexp: ([number]+)[punctuation]+(?=[number])  $text = preg_replace('/(['. PREG_CLASS_NUMBERS .']+)['. PREG_CLASS_PUNCTUATION .']+(?=['. PREG_CLASS_NUMBERS .'])/u', '\1', $text);  // The dot, underscore and dash are simply removed. This allows meaningful  // search behavior with acronyms and URLs.  $text = preg_replace('/[._-]+/', '', $text);  // With the exception of the rules above, we consider all punctuation,  // marks, spacers, etc, to be a word boundary.  $text = preg_replace('/['. PREG_CLASS_SEARCH_EXCLUDE .']+/u', ' ', $text);  return $text;}/** * Basic CJK tokenizer. Simply splits a string into consecutive, overlapping * sequences of characters ('minimum_word_size' long). */function search_expand_cjk($matches) {  $min = variable_get('minimum_word_size', 3);  $str = $matches[0];  $l = drupal_strlen($str);  // Passthrough short words  if ($l <= $min) {    return ' '. $str .' ';  }  $tokens = ' ';  // FIFO queue of characters  $chars = array();  // Begin loop  for ($i = 0; $i < $l; ++$i) {    // Grab next character    $current = drupal_substr($str, 0, 1);    $str = substr($str, strlen($current));    $chars[] = $current;    if ($i >= $min - 1) {      $tokens .= implode('', $chars) .' ';      array_shift($chars);    }  }  return $tokens;}/** * Splits a string into tokens for indexing. */function search_index_split($text) {  static $last = NULL;  static $lastsplit = NULL;  if ($last == $text) {    return $lastsplit;  }  // Process words  $text = search_simplify($text);  $words = explode(' ', $text);  array_walk($words, '_search_index_truncate');  // Save last keyword result  $last = $text;  $lastsplit = $words;  return $words;}/** * Helper function for array_walk in search_index_split. */function _search_index_truncate(&$text) {  $text = truncate_utf8($text, 50);}/** * Invokes hook_search_preprocess() in modules. */function search_invoke_preprocess(&$text) {  foreach (module_implements('search_preprocess') as $module) {    $text = module_invoke($module, 'search_preprocess', $text);  }}/** * Update the full-text search index for a particular item. * * @param $sid *   A number identifying this particular item (e.g. node id). * * @param $type *   A string defining this type of item (e.g. 'node') * * @param $text *   The content of this item. Must be a piece of HTML text. * * @ingroup search */function search_index($sid, $type, $text) {  $minimum_word_size = variable_get('minimum_word_size', 3);  // Link matching  global $base_url;  $node_regexp = '@href=[\'"]?(?:'. preg_quote($base_url, '@') .'/|'. preg_quote(base_path(), '@') .')(?:\?q=)?/?((?![a-z]+:)[^\'">]+)[\'">]@i';  // Multipliers for scores of words inside certain HTML tags.  // Note: 'a' must be included for link ranking to work.  $tags = array('h1' => 25,                'h2' => 18,                'h3' => 15,                'h4' => 12,                'h5' => 9,                'h6' => 6,                'u' => 3,                'b' => 3,                'i' => 3,                'strong' => 3,                'em' => 3,                'a' => 10);  // Strip off all ignored tags to speed up processing, but insert space before/after  // them to keep word boundaries.  $text = str_replace(array('<', '>'), array(' <', '> '), $text);  $text = strip_tags($text, '<'. implode('><', array_keys($tags)) .'>');  // Split HTML tags from plain text.  $split = preg_split('/\s*<([^>]+?)>\s*/', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting $null as required).  $tag = FALSE; // Odd/even counter. Tag or no tag.  $link = FALSE; // State variable for link analyser  $score = 1; // Starting score per word  $accum = ' '; // Accumulator for cleaned up data  $tagstack = array(); // Stack with open tags  $tagwords = 0; // Counter for consecutive words  $focus = 1; // Focus state  $results = array(0 => array()); // Accumulator for words for index  foreach ($split as $value) {    if ($tag) {      // Increase or decrease score per word based on tag      list($tagname) = explode(' ', $value, 2);      $tagname = drupal_strtolower($tagname);      // Closing or opening tag?      if ($tagname[0] == '/') {        $tagname = substr($tagname, 1);        // If we encounter unexpected tags, reset score to avoid incorrect boosting.        if (!count($tagstack) || $tagstack[0] != $tagname) {          $tagstack = array();          $score = 1;        }        else {          // Remove from tag stack and decrement score          $score = max(1, $score - $tags[array_shift($tagstack)]);        }        if ($tagname == 'a') {          $link = FALSE;        }      }      else {        if (isset($tagstack[0]) && $tagstack[0] == $tagname) {          // None of the tags we look for make sense when nested identically.          // If they are, it's probably broken HTML.          $tagstack = array();          $score = 1;        }        else {          // Add to open tag stack and increment score          array_unshift($tagstack, $tagname);          $score += $tags[$tagname];        }        if ($tagname == 'a') {          // Check if link points to a node on this site          if (preg_match($node_regexp, $value, $match)) {            $path = drupal_get_normal_path($match[1]);            if (preg_match('!(?:node|book)/(?:view/)?([0-9]+)!i', $path, $match)) {              $linknid = $match[1];              if ($linknid > 0) {                // Note: ignore links to uncachable nodes to avoid redirect bugs.                $node = db_fetch_object(db_query('SELECT n.title, n.nid, n.vid, r.format FROM {node} n INNER JOIN {node_revisions} r ON n.vid = r.vid WHERE n.nid = %d', $linknid));                if (filter_format_allowcache($node->format)) {                  $link = TRUE;                  $linktitle = $node->title;                }              }            }          }        }      }      // A tag change occurred, reset counter.      $tagwords = 0;    }    else {      // Note: use of PREG_SPLIT_DELIM_CAPTURE above will introduce empty values      if ($value != '') {        if ($link) {          // Check to see if the node link text is its URL. If so, we use the target node title instead.          if (preg_match('!^https?://!i', $value)) {            $value = $linktitle;          }        }        $words = search_index_split($value);        foreach ($words as $word) {          // Add word to accumulator          $accum .= $word .' ';          $num = is_numeric($word);          // Check wordlength          if ($num || drupal_strlen($word) >= $minimum_word_size) {            // Normalize numbers            if ($num) {              $word = (int)ltrim($word, '-0');            }            // Links score mainly for the target.            if ($link) {              if (!isset($results[$linknid])) {                $results[$linknid] = array();              }              $results[$linknid][] = $word;              // Reduce score of the link caption in the source.              $focus *= 0.2;            }            // Fall-through            if (!isset($results[0][$word])) {              $results[0][$word] = 0;            }            $results[0][$word] += $score * $focus;            // Focus is a decaying value in terms of the amount of unique words up to this point.            // From 100 words and more, it decays, to e.g. 0.5 at 500 words and 0.3 at 1000 words.            $focus = min(1, .01 + 3.5 / (2 + count($results[0]) * .015));          }          $tagwords++;          // Too many words inside a single tag probably mean a tag was accidentally left open.          if (count($tagstack) && $tagwords >= 15) {            $tagstack = array();            $score = 1;          }        }      }    }    $tag = !$tag;  }  search_wipe($sid, $type, TRUE);  // Insert cleaned up data into dataset  db_query("INSERT INTO {search_dataset} (sid, type, data, reindex) VALUES (%d, '%s', '%s', %d)", $sid, $type, $accum, 0);  // Insert results into search index  foreach ($results[0] as $word => $score) {    // Try inserting first because this will succeed most times, but because    // the database collates similar words (accented and non-accented), the    // insert can fail, in which case we need to add the word scores together.    @db_query("INSERT INTO {search_index} (word, sid, type, score) VALUES ('%s', %d, '%s', %f)", $word, $sid, $type, $score);    if (!db_affected_rows()) {      db_query("UPDATE {search_index} SET score = score + %f WHERE word = '%s' AND sid = %d AND type = '%s'", $score, $word, $sid, $type);    }    search_dirty($word);  }  unset($results[0]);  // Get all previous links from this item.  $result = db_query("SELECT nid, caption FROM {search_node_links} WHERE sid = %d AND type = '%s'", $sid, $type);  $links = array();  while ($link = db_fetch_object($result)) {    $links[$link->nid] = $link->caption;  }  // Now store links to nodes.  foreach ($results as $nid => $words) {    $caption = implode(' ', $words);    if (isset($links[$nid])) {      if ($links[$nid] != $caption) {        // Update the existing link and mark the node for reindexing.        db_query("UPDATE {search_node_links} SET caption = '%s' WHERE sid = %d AND type = '%s' AND nid = %d", $caption, $sid, $type, $nid);        search_touch_node($nid);      }      // Unset the link to mark it as processed.      unset($links[$nid]);    }    else {      // Insert the existing link and mark the node for reindexing.      db_query("INSERT INTO {search_node_links} (caption, sid, type, nid) VALUES ('%s', %d, '%s', %d)", $caption, $sid, $type, $nid);      search_touch_node($nid);    }  }  // Any left-over links in $links no longer exist. Delete them and mark the nodes for reindexing.  foreach ($links as $nid => $caption) {    db_query("DELETE FROM {search_node_links} WHERE sid = %d AND type = '%s' AND nid = %d", $sid, $type, $nid);    search_touch_node($nid);  }}/** * Change a node's changed timestamp to 'now' to force reindexing. * * @param $nid *   The nid of the node that needs reindexing. */function search_touch_node($nid) {  db_query("UPDATE {search_dataset} SET reindex = %d WHERE sid = %d AND type = 'node'", time(), $nid);}/** * Implementation of hook_nodeapi(). */function search_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {  switch ($op) {    // Transplant links to a node into the target node.    case 'update index':      $result = db_query("SELECT caption FROM {search_node_links} WHERE nid = %d", $node->nid);      $output = array();      while ($link = db_fetch_object($result)) {        $output[] = $link->caption;      }      if (count($output)) {        return '<a>('. implode(', ', $output) .')</a>';      }      break;    // Reindex the node when it is updated.  The node is automatically indexed    // when it is added, simply by being added to the node table.    case 'update':      search_touch_node($node->nid);      break;  }}/** * Implementation of hook_comment(). */function search_comment($a1, $op) {  switch ($op) {    // Reindex the node when comments are added or changed    case 'insert':    case 'update':    case 'delete':    case 'publish':    case 'unpublish':      search_touch_node(is_array($a1) ? $a1['nid'] : $a1->nid);      break;  }}/** * Extract a module-specific search option from a search query. e.g. 'type:book' */function search_query_extract($keys, $option) {  if (preg_match('/(^| )'. $option .':([^ ]*)( |$)/i', $keys, $matches)) {    return $matches[2];  }}/** * Return a query with the given module-specific search option inserted in. * e.g. 'type:book'. */function search_query_insert($keys, $option, $value = '') {  if (search_query_extract($keys, $option)) {    $keys = trim(preg_replace('/(^| )'. $option .':[^ ]*/i', '', $keys));  }  if ($value != '') {    $keys .= ' '. $option .':'. $value;  }  return $keys;}/** * Parse a search query into SQL conditions. * * We build two queries that matches the dataset bodies. @See do_search for * more about these. * * @param $text *   The search keys. * @return *   A list of six elements. *    * A series of statements AND'd together which will be used to provide all *      possible matches. *    * Arguments for this query part. *    * A series of exact word matches OR'd together. *    * Arguments for this query part. *    * A bool indicating whether this is a simple query or not. Negative *      terms, presence of both AND / OR make this FALSE. *    * A bool indicating the presence of a lowercase or. Maybe the user *      wanted to use OR. */function search_parse_query($text) {  $keys = array('positive' => array(), 'negative' => array());  // Tokenize query string  preg_match_all('/ (-?)("[^"]+"|[^" ]+)/i', ' '. $text, $matches, PREG_SET_ORDER);  if (count($matches) < 1) {    return NULL;  }  // Classify tokens  $or = FALSE;  $warning = '';  $simple = TRUE;  foreach ($matches as $match) {    $phrase = FALSE;    // Strip off phrase quotes    if ($match[2]{0} == '"') {      $match[2] = substr($match[2], 1, -1);      $phrase = TRUE;      $simple = FALSE;    }    // Simplify keyword according to indexing rules and external preprocessors    $words = search_simplify($match[2]);    // Re-explode in case simplification added more words, except when matching a phrase    $words = $phrase ? array($words) : preg_split('/ /', $words, -1, PREG_SPLIT_NO_EMPTY);    // Negative matches    if ($match[1] == '-') {      $keys['negative'] = array_merge($keys['negative'], $words);    }    // OR operator: instead of a single keyword, we store an array of all    // OR'd keywords.    elseif ($match[2] == 'OR' && count($keys['positive'])) {      $last = array_pop($keys['positive']);      // Starting a new OR?      if (!is_array($last)) {        $last = array($last);      }      $keys['positive'][] = $last;      $or = TRUE;      continue;    }    // AND operator: implied, so just ignore it    elseif ($match[2] == 'AND' || $match[2] == 'and') {      $warning = $match[2];      continue;    }    // Plain keyword    else {      if ($match[2] == 'or') {        $warning = $match[2];      }      if ($or) {        // Add to last element (which is an array)        $keys['positive'][count($keys['positive']) - 1] = array_merge($keys['positive'][count($keys['positive']) - 1], $words);      }      else {        $keys['positive'] = array_merge($keys['positive'], $words);      }    }    $or = FALSE;  }  // Convert keywords into SQL statements.  $query = array();  $query2 = array();  $arguments = array();  $arguments2 = array();  $matches = 0;  $simple_and = FALSE;  $simple_or = FALSE;  // Positive matches  foreach ($keys['positive'] as $key) {    // Group of ORed terms    if (is_array($key) && count($key)) {      $simple_or = TRUE;      $queryor = array();      $any = FALSE;      foreach ($key as $or) {        list($q, $num_new_scores) = _search_parse_query($or, $arguments2);        $any |= $num_new_scores;        if ($q) {          $queryor[] = $q;          $arguments[] = $or;        }      }      if (count($queryor)) {        $query[] = '('. implode(' OR ', $queryor) .')';        // A group of OR keywords only needs to match once        $matches += ($any > 0);      }    }    // Single ANDed term    else {      $simple_and = TRUE;      list($q, $num_new_scores, $num_valid_words) = _search_parse_query($key, $arguments2);      if ($q) {        $query[] = $q;        $arguments[] = $key;        if (!$num_valid_words) {          $simple = FALSE;        }        // Each AND keyword needs to match at least once        $matches += $num_new_scores;      }    }  }  if ($simple_and && $simple_or) {    $simple = FALSE;  }  // Negative matches  foreach ($keys['negative'] as $key) {    list($q) = _search_parse_query($key, $arguments2, TRUE);    if ($q) {      $query[] = $q;      $arguments[] = $key;      $simple = FALSE;    }  }  $query = implode(' AND ', $query);  // Build word-index conditions for the first pass  $query2 = substr(str_repeat("i.word = '%s' OR ", count($arguments2)), 0, -4);  return array($query, $arguments, $query2, $arguments2, $matches, $simple, $warning);}/** * Helper function for search_parse_query(); */function _search_parse_query(&$word, &$scores, $not = FALSE) {  $num_new_scores = 0;  $num_valid_words = 0;  // Determine the scorewords of this word/phrase  if (!$not) {    $split = explode(' ', $word);    foreach ($split as $s) {      $num = is_numeric($s);      if ($num || drupal_strlen($s) >= variable_get('minimum_word_size', 3)) {        $s = $num ? ((int)ltrim($s, '-0')) : $s;        if (!isset($scores[$s])) {          $scores[$s] = $s;          $num_new_scores++;        }        $num_valid_words++;      }    }  }  // Return matching snippet and number of added words  return array("d.data ". ($not ? 'NOT ' : '') ."LIKE '%% %s %%'", $num_new_scores, $num_valid_words);}/** * Do a query on the full-text search index for a word or words. * * This function is normally only called by each module that support the * indexed search (and thus, implements hook_update_index()). * * Results are retrieved in two logical passes. However, the two passes are * joined together into a single query.  And in the case of most simple * queries the second pass is not even used. * * The first pass selects a set of all possible matches, which has the benefit * of also providing the exact result set for simple "AND" or "OR" searches. * * The second portion of the query further refines this set by verifying * advanced text conditions (such negative or phrase matches) * * @param $keywords *   A search string as entered by the user. * * @param $type *   A string identifying the calling module. * * @param $join1 *   (optional) Inserted into the JOIN part of the first SQL query. *   For example "INNER JOIN {node} n ON n.nid = i.sid". * * @param $where1 *   (optional) Inserted into the WHERE part of the first SQL query. *   For example "(n.status > %d)". * * @param $arguments1 *   (optional) Extra SQL arguments belonging to the first query. * * @param $columns2 *   (optional) Inserted into the SELECT pat of the second query. Must contain *   a column selected as 'score'. *   defaults to 'i.relevance AS score' * * @param $join2 *   (optional) Inserted into the JOIN par of the second SQL query. *   For example "INNER JOIN {node_comment_statistics} n ON n.nid = i.sid" * * @param $arguments2 *   (optional) Extra SQL arguments belonging to the second query parameter. * * @param $sort_parameters *   (optional) SQL arguments for sorting the final results. *              Default: 'ORDER BY score DESC' * * @return *   An array of SIDs for the search results. * * @ingroup search */function do_search($keywords, $type, $join1 = '', $where1 = '1 = 1', $arguments1 = array(), $columns2 = 'i.relevance AS score', $join2 = '', $arguments2 = array(), $sort_parameters = 'ORDER BY score DESC') {  $query = search_parse_query($keywords);  if ($query[2] == '') {    form_set_error('keys', t('You must include at least one positive keyword with @count characters or more.', array('@count' => variable_get('minimum_word_size', 3))));  }  if ($query[6]) {    if ($query[6] == 'or') {      drupal_set_message(t('Search for either of the two terms with uppercase <strong>OR</strong>. For example, <strong>cats OR dogs</strong>.'));    }  }  if ($query === NULL || $query[0] == '' || $query[2] == '') {    return array();  }  // Build query for keyword normalization.  $conditions = "$where1 AND ($query[2]) AND i.type = '%s'";  $arguments1 = array_merge($arguments1, $query[3], array($type));  $join = "INNER JOIN {search_total} t ON i.word = t.word $join1";  if (!$query[5]) {    $conditions .= " AND ($query[0])";    $arguments1 = array_merge($arguments1, $query[1]);    $join .= " INNER JOIN {search_dataset} d ON i.sid = d.sid AND i.type = d.type";  }  // Calculate maximum keyword relevance, to normalize it.  $select = "SELECT SUM(i.score * t.count) AS score FROM {search_index} i $join WHERE $conditions GROUP BY i.type, i.sid HAVING COUNT(*) >= %d ORDER BY score DESC";  $arguments = array_merge($arguments1, array($query[4]));  $normalize = db_result(db_query_range($select, $arguments, 0, 1));  if (!$normalize) {    return array();  }  $columns2 = str_replace('i.relevance', '('. (1.0 / $normalize) .' * SUM(i.score * t.count))', $columns2);  // Build query to retrieve results.  $select = "SELECT i.type, i.sid, $columns2 FROM {search_index} i $join $join2 WHERE $conditions GROUP BY i.type, i.sid HAVING COUNT(*) >= %d";  $count_select =  "SELECT COUNT(*) FROM ($select) n1";  $arguments = array_merge($arguments2, $arguments1, array($query[4]));  // Do actual search query  $result = pager_query("$select $sort_parameters", 10, 0, $count_select, $arguments);  $results = array();  while ($item = db_fetch_object($result)) {    $results[] = $item;  }  return $results;}/** * Helper function for grabbing search keys. */function search_get_keys() {  static $return;  if (!isset($return)) {    // Extract keys as remainder of path    // Note: support old GET format of searches for existing links.    $path = explode('/', $_GET['q'], 3);    $keys = empty($_REQUEST['keys']) ? '' : $_REQUEST['keys'];    $return = count($path) == 3 ? $path[2] : $keys;  }  return $return;}/** * @defgroup search Search interface * @{ * The Drupal search interface manages a global search mechanism. * * Modules may plug into this system to provide searches of different types of * data. Most of the system is handled by search.module, so this must be enabled * for all of the search features to work. * * There are three ways to interact with the search system: * - Specifically for searching nodes, you can implement nodeapi('update index') *   and nodeapi('search result'). However, note that the search system already *   indexes all visible output of a node, i.e. everything displayed normally *   by hook_view() and hook_nodeapi('view'). This is usually sufficient. *   You should only use this mechanism if you want additional, non-visible data *   to be indexed. * - Implement hook_search(). This will create a search tab for your module on *   the /search page with a simple keyword search form. You may optionally *   implement hook_search_item() to customize the display of your results. * - Implement hook_update_index(). This allows your module to use Drupal's *   HTML indexing mechanism for searching full text efficiently. * * If your module needs to provide a more complicated search form, then you need * to implement it yourself without hook_search(). In that case, you should * define it as a local task (tab) under the /search page (e.g. /search/mymodule) * so that users can easily find it. *//** * Render a search form. * * @param $action *   Form action. Defaults to "search". * @param $keys *   The search string entered by the user, containing keywords for the search. * @param $type *   The type of search to render the node for. Must be the name of module *   which implements hook_search(). Defaults to 'node'. * @param $prompt *   A piece of text to put before the form (e.g. "Enter your keywords") * @return *   An HTML string containing the search form. */function search_form(&$form_state, $action = '', $keys = '', $type = NULL, $prompt = NULL) {  // Add CSS  drupal_add_css(drupal_get_path('module', 'search') .'/search.css', 'module', 'all', FALSE);  if (!$action) {    $action = url('search/'. $type);  }  if (is_null($prompt)) {    $prompt = t('Enter your keywords');  }  $form = array(    '#action' => $action,    '#attributes' => array('class' => 'search-form'),  );  $form['module'] = array('#type' => 'value', '#value' => $type);  $form['basic'] = array('#type' => 'item', '#title' => $prompt);  $form['basic']['inline'] = array('#prefix' => '<div class="container-inline">', '#suffix' => '</div>');  $form['basic']['inline']['keys'] = array(    '#type' => 'textfield',    '#title' => '',    '#default_value' => $keys,    '#size' => $prompt ? 40 : 20,    '#maxlength' => 255,  );  // processed_keys is used to coordinate keyword passing between other forms  // that hook into the basic search form.  $form['basic']['inline']['processed_keys'] = array('#type' => 'value', '#value' => array());  $form['basic']['inline']['submit'] = array('#type' => 'submit', '#value' => t('Search'));  return $form;}/** * Form builder; Output a search form for the search block and the theme's search box. * * @ingroup forms * @see search_box_form_submit() * @see theme_search_box_form() */function search_box(&$form_state, $form_id) {  $form[$form_id] = array(    '#title' => t('Search this site'),    '#type' => 'textfield',    '#size' => 15,    '#default_value' => '',    '#attributes' => array('title' => t('Enter the terms you wish to search for.')),  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Search'));  $form['#submit'][] = 'search_box_form_submit';  return $form;}/** * Process a block search form submission. */function search_box_form_submit($form, &$form_state) {  // The search form relies on control of the redirect destination for its  // functionality, so we override any static destination set in the request,  // for example by drupal_access_denied() or drupal_not_found()  // (see http://drupal.org/node/292565).  if (isset($_REQUEST['destination'])) {    unset($_REQUEST['destination']);  }  if (isset($_REQUEST['edit']['destination'])) {    unset($_REQUEST['edit']['destination']);  }  $form_id = $form['form_id']['#value'];  $form_state['redirect'] = 'search/node/'. trim($form_state['values'][$form_id]);}/** * Process variables for search-theme-form.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see search-theme-form.tpl.php */function template_preprocess_search_theme_form(&$variables) {  $variables['search'] = array();  $hidden = array();  // Provide variables named after form keys so themers can print each element independently.  foreach (element_children($variables['form']) as $key) {    $type = $variables['form'][$key]['#type'];    if ($type == 'hidden' || $type == 'token') {      $hidden[] = drupal_render($variables['form'][$key]);    }    else {      $variables['search'][$key] = drupal_render($variables['form'][$key]);    }  }  // Hidden form elements have no value to themers. No need for separation.  $variables['search']['hidden'] = implode($hidden);  // Collect all form elements to make it easier to print the whole form.  $variables['search_form'] = implode($variables['search']);}/** * Process variables for search-block-form.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see search-block-form.tpl.php */function template_preprocess_search_block_form(&$variables) {  $variables['search'] = array();  $hidden = array();  // Provide variables named after form keys so themers can print each element independently.  foreach (element_children($variables['form']) as $key) {    $type = $variables['form'][$key]['#type'];    if ($type == 'hidden' || $type == 'token') {      $hidden[] = drupal_render($variables['form'][$key]);    }    else {      $variables['search'][$key] = drupal_render($variables['form'][$key]);    }  }  // Hidden form elements have no value to themers. No need for separation.  $variables['search']['hidden'] = implode($hidden);  // Collect all form elements to make it easier to print the whole form.  $variables['search_form'] = implode($variables['search']);}/** * Perform a standard search on the given keys, and return the formatted results. */function search_data($keys = NULL, $type = 'node') {  if (isset($keys)) {    if (module_hook($type, 'search')) {      $results = module_invoke($type, 'search', 'search', $keys);      if (isset($results) && is_array($results) && count($results)) {        if (module_hook($type, 'search_page')) {          return module_invoke($type, 'search_page', $results);        }        else {          return theme('search_results', $results, $type);        }      }    }  }}/** * Returns snippets from a piece of text, with certain keywords highlighted. * Used for formatting search results. * * @param $keys *   A string containing a search query. * * @param $text *   The text to extract fragments from. * * @return *   A string containing HTML for the excerpt. */function search_excerpt($keys, $text) {  // We highlight around non-indexable or CJK characters.  $boundary = '(?:(?<=['. PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK .'])|(?=['. PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK .']))';  // Extract positive keywords and phrases  preg_match_all('/ ("([^"]+)"|(?!OR)([^" ]+))/', ' '. $keys, $matches);  $keys = array_merge($matches[2], $matches[3]);  // Prepare text  $text = ' '. strip_tags(str_replace(array('<', '>'), array(' <', '> '), $text)) .' ';  array_walk($keys, '_search_excerpt_replace');  $workkeys = $keys;  // Extract a fragment per keyword for at most 4 keywords.  // First we collect ranges of text around each keyword, starting/ending  // at spaces.  // If the sum of all fragments is too short, we look for second occurrences.  $ranges = array();  $included = array();  $length = 0;  while ($length < 256 && count($workkeys)) {    foreach ($workkeys as $k => $key) {      if (strlen($key) == 0) {        unset($workkeys[$k]);        unset($keys[$k]);        continue;      }      if ($length >= 256) {        break;      }      // Remember occurrence of key so we can skip over it if more occurrences      // are desired.      if (!isset($included[$key])) {        $included[$key] = 0;      }      // Locate a keyword (position $p), then locate a space in front (position      // $q) and behind it (position $s)      if (preg_match('/'. $boundary . $key . $boundary .'/iu', $text, $match, PREG_OFFSET_CAPTURE, $included[$key])) {        $p = $match[0][1];        if (($q = strpos($text, ' ', max(0, $p - 60))) !== FALSE) {          $end = substr($text, $p, 80);          if (($s = strrpos($end, ' ')) !== FALSE) {            $ranges[$q] = $p + $s;            $length += $p + $s - $q;            $included[$key] = $p + 1;          }          else {            unset($workkeys[$k]);          }        }        else {          unset($workkeys[$k]);        }      }      else {        unset($workkeys[$k]);      }    }  }  // If we didn't find anything, return the beginning.  if (count($ranges) == 0) {    return truncate_utf8($text, 256) .' ...';  }  // Sort the text ranges by starting position.  ksort($ranges);  // Now we collapse overlapping text ranges into one. The sorting makes it O(n).  $newranges = array();  foreach ($ranges as $from2 => $to2) {    if (!isset($from1)) {      $from1 = $from2;      $to1 = $to2;      continue;    }    if ($from2 <= $to1) {      $to1 = max($to1, $to2);    }    else {      $newranges[$from1] = $to1;      $from1 = $from2;      $to1 = $to2;    }  }  $newranges[$from1] = $to1;  // Fetch text  $out = array();  foreach ($newranges as $from => $to) {    $out[] = substr($text, $from, $to - $from);  }  $text = (isset($newranges[0]) ? '' : '... ') . implode(' ... ', $out) .' ...';  // Highlight keywords. Must be done at once to prevent conflicts ('strong' and '<strong>').  $text = preg_replace('/'. $boundary .'('. implode('|', $keys) .')'. $boundary .'/iu', '<strong>\0</strong>', $text);  return $text;}/** * @} End of "defgroup search". *//** * Helper function for array_walk in search_except. */function _search_excerpt_replace(&$text) {  $text = preg_quote($text, '/');}function search_forms() {  $forms['search_theme_form']= array(    'callback' => 'search_box',    'callback arguments' => array('search_theme_form'),  );  $forms['search_block_form']= array(    'callback' => 'search_box',    'callback arguments' => array('search_block_form'),  );  return $forms;}
<?php// $Id$/** * @file * Multiple language handling functionality. *//** *  Choose a language for the page, based on language negotiation settings. */function language_initialize() {  global $user;  // Configured presentation language mode.  $mode = variable_get('language_negotiation', LANGUAGE_NEGOTIATION_NONE);  // Get a list of enabled languages.  $languages = language_list('enabled');  $languages = $languages[1];    switch ($mode) {    case LANGUAGE_NEGOTIATION_NONE:      return language_default();    case LANGUAGE_NEGOTIATION_DOMAIN:      foreach ($languages as $language) {        $parts = parse_url($language->domain);        if (!empty($parts['host']) && ($_SERVER['HTTP_HOST'] == $parts['host'])) {          return $language;        }      }      return language_default();    case LANGUAGE_NEGOTIATION_PATH_DEFAULT:    case LANGUAGE_NEGOTIATION_PATH:      // $_GET['q'] might not be available at this time, because      // path initialization runs after the language bootstrap phase.      $args = isset($_GET['q']) ? explode('/', $_GET['q']) : array();      $prefix = array_shift($args);      // Search prefix within enabled languages.      foreach ($languages as $language) {        if (!empty($language->prefix) && $language->prefix == $prefix) {          // Rebuild $GET['q'] with the language removed.          $_GET['q'] = implode('/', $args);          return $language;        }      }      if ($mode == LANGUAGE_NEGOTIATION_PATH_DEFAULT) {        // If we did not found the language by prefix, choose the default.        return language_default();      }      break;  }  // User language.  if ($user->uid && isset($languages[$user->language])) {    return $languages[$user->language];  }  // Browser accept-language parsing.  if ($language = language_from_browser()) {    return $language;  }  // Fall back on the default if everything else fails.  return language_default();}/** * Identify language from the Accept-language HTTP header we got. */function language_from_browser() {  // Specified by the user via the browser's Accept Language setting  // Samples: "hu, en-us;q=0.66, en;q=0.33", "hu,en-us;q=0.5"  $browser_langs = array();  if (isset($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {    $browser_accept = explode(",", $_SERVER['HTTP_ACCEPT_LANGUAGE']);    for ($i = 0; $i < count($browser_accept); $i++) {      // The language part is either a code or a code with a quality.      // We cannot do anything with a * code, so it is skipped.      // If the quality is missing, it is assumed to be 1 according to the RFC.      if (preg_match("!([a-z-]+)(;q=([0-9\\.]+))?!", trim($browser_accept[$i]), $found)) {        $browser_langs[$found[1]] = (isset($found[3]) ? (float) $found[3] : 1.0);      }    }  }  // Order the codes by quality  arsort($browser_langs);  // Try to find the first preferred language we have  $languages = language_list('enabled');  foreach ($browser_langs as $langcode => $q) {    if (isset($languages['1'][$langcode])) {      return $languages['1'][$langcode];    }  }}/** * Rewrite URL's with language based prefix. Parameters are the same * as those of the url() function. */function language_url_rewrite(&$path, &$options) {  global $language;  // Only modify relative (insite) URLs.  if (!$options['external']) {    // Language can be passed as an option, or we go for current language.    if (!isset($options['language'])) {      $options['language'] = $language;    }    switch (variable_get('language_negotiation', LANGUAGE_NEGOTIATION_NONE)) {      case LANGUAGE_NEGOTIATION_NONE:        // No language dependent path allowed in this mode.        unset($options['language']);        break;      case LANGUAGE_NEGOTIATION_DOMAIN:        if ($options['language']->domain) {          // Ask for an absolute URL with our modified base_url.          $options['absolute'] = TRUE;          $options['base_url'] = $options['language']->domain;        }        break;      case LANGUAGE_NEGOTIATION_PATH_DEFAULT:        $default = language_default();        if ($options['language']->language == $default->language) {          break;        }        // Intentionally no break here.      case LANGUAGE_NEGOTIATION_PATH:        if (!empty($options['language']->prefix)) {          $options['prefix'] = $options['language']->prefix .'/';        }        break;    }  }}
<?php// $Id$/** * @file * API for manipulating images. *//** * @defgroup image Image toolkits * @{ * Drupal's image toolkits provide an abstraction layer for common image file * manipulations like scaling, cropping, and rotating. The abstraction frees * module authors from the need to support multiple image libraries, and it * allows site administrators to choose the library that's best for them. * * PHP includes the GD library by default so a GD toolkit is installed with * Drupal. Other toolkits like ImageMagic are available from contrib modules. * GD works well for small images, but using it with larger files may cause PHP * to run out of memory. In contrast the ImageMagick library does not suffer * from this problem, but it requires the ISP to have installed additional * software. * * Image toolkits are installed by copying the image.ToolkitName.inc file into * Drupal's includes directory. The toolkit must then be enabled using the * admin/settings/image-toolkit form. * * Only one toolkit maybe selected at a time. If a module author wishes to call * a specific toolkit they can check that it is installed by calling * image_get_available_toolkits(), and then calling its functions directly. *//** * Return a list of available toolkits. * * @return *   An array of toolkit name => descriptive title. */function image_get_available_toolkits() {  $toolkits = file_scan_directory('includes', 'image\..*\.inc$');  $output = array();  foreach ($toolkits as $file => $toolkit) {    include_once "./$file";    $function = str_replace('.', '_', $toolkit->name) .'_info';    if (function_exists($function)) {      $info = $function();      $output[$info['name']] = $info['title'];    }  }  return $output;}/** * Retrieve the name of the currently used toolkit. * * @return *   String containing the name of the selected toolkit, or FALSE on error. */function image_get_toolkit() {  static $toolkit;  if (!$toolkit) {    $toolkit = variable_get('image_toolkit', 'gd');    $toolkit_file = './includes/image.'. $toolkit .'.inc';    if (isset($toolkit) && file_exists($toolkit_file)) {      include_once $toolkit_file;    }    elseif (!image_gd_check_settings()) {      $toolkit = FALSE;    }  }  return $toolkit;}/** * Invokes the given method using the currently selected toolkit. * * @param $method *   A string containing the method to invoke. * @param $params *   An optional array of parameters to pass to the toolkit method. * @return *   Mixed values (typically Boolean indicating successful operation). */function image_toolkit_invoke($method, $params = array()) {  if ($toolkit = image_get_toolkit()) {    $function = 'image_'. $toolkit .'_'. $method;    if (function_exists($function)) {      return call_user_func_array($function, $params);    }    else {      watchdog('php', 'The selected image handling toolkit %toolkit can not correctly process %function.', array('%toolkit' => $toolkit, '%function' => $function), WATCHDOG_ERROR);      return FALSE;    }  }}/** * Get details about an image. * * Drupal only supports GIF, JPG and PNG file formats. * * @return *   FALSE, if the file could not be found or is not an image. Otherwise, a *   keyed array containing information about the image: *    'width'     - Width in pixels. *    'height'    - Height in pixels. *    'extension' - Commonly used file extension for the image. *    'mime_type' - MIME type ('image/jpeg', 'image/gif', 'image/png'). *    'file_size' - File size in bytes. */function image_get_info($file) {  if (!is_file($file)) {    return FALSE;  }  $details = FALSE;  $data = @getimagesize($file);  $file_size = @filesize($file);  if (isset($data) && is_array($data)) {    $extensions = array('1' => 'gif', '2' => 'jpg', '3' => 'png');    $extension = array_key_exists($data[2], $extensions) ?  $extensions[$data[2]] : '';    $details = array('width'     => $data[0],                     'height'    => $data[1],                     'extension' => $extension,                     'file_size' => $file_size,                     'mime_type' => $data['mime']);  }  return $details;}/** * Scales an image to the exact width and height given. Achieves the * target aspect ratio by cropping the original image equally on both * sides, or equally on the top and bottom.  This function is, for * example, useful to create uniform sized avatars from larger images. * * The resulting image always has the exact target dimensions. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels. * @return *   TRUE or FALSE, based on success. */function image_scale_and_crop($source, $destination, $width, $height) {  $info = image_get_info($source);  $scale = max($width / $info['width'], $height / $info['height']);  $x = round(($info['width'] * $scale - $width) / 2);  $y = round(($info['height'] * $scale - $height) / 2);  if (image_toolkit_invoke('resize', array($source, $destination, $info['width'] * $scale, $info['height'] * $scale))) {    return image_toolkit_invoke('crop', array($destination, $destination, $x, $y, $width, $height));  }  return FALSE;}/** * Scales an image to the given width and height while maintaining aspect * ratio. * * The resulting image can be smaller for one or both target dimensions. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels. * @return *   TRUE or FALSE, based on success. */function image_scale($source, $destination, $width, $height) {  $info = image_get_info($source);  // Don't scale up.  if ($width >= $info['width'] && $height >= $info['height']) {    return FALSE;  }  $aspect = $info['height'] / $info['width'];  if ($aspect < $height / $width) {    $width = (int)min($width, $info['width']);    $height = (int)round($width * $aspect);  }  else {    $height = (int)min($height, $info['height']);    $width = (int)round($height / $aspect);  }  return image_toolkit_invoke('resize', array($source, $destination, $width, $height));}/** * Resize an image to the given dimensions (ignoring aspect ratio). * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels.  * @return *   TRUE or FALSE, based on success. */function image_resize($source, $destination, $width, $height) {  return image_toolkit_invoke('resize', array($source, $destination, $width, $height));}/** * Rotate an image by the given number of degrees. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $degrees *   The number of (clockwise) degrees to rotate the image. * @param $background *   An hexidecimal integer specifying the background color to use for the *   uncovered area of the image after the rotation. E.g. 0x000000 for black, *   0xff00ff for magenta, and 0xffffff for white. * @return *   TRUE or FALSE, based on success. */function image_rotate($source, $destination, $degrees, $background = 0x000000) {  return image_toolkit_invoke('rotate', array($source, $destination, $degrees, $background));}/** * Crop an image to the rectangle specified by the given rectangle. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $x *   The top left co-ordinate, in pixels, of the crop area (x axis value). * @param $y *   The top left co-ordinate, in pixels, of the crop area (y axis value). * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels. * @return *   TRUE or FALSE, based on success. */function image_crop($source, $destination, $x, $y, $width, $height) {  return image_toolkit_invoke('crop', array($source, $destination, $x, $y, $width, $height));}/** * @} End of "defgroup image". */
<?php// $Id$/** * @file maintenance-page.tpl.php * * This is an override of the default maintenance page. Used for Garland and * Minnelli, this file should not be moved or modified since the installation * and update pages depend on this file. * * This mirrors closely page.tpl.php for Garland in order to share the same * styles. */?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>">  <head>    <?php print $head ?>    <title><?php print $head_title ?></title>    <?php print $styles ?>    <?php print $scripts ?>    <!--[if lt IE 7]>      <?php print phptemplate_get_ie_styles(); ?>    <![endif]-->  </head>  <body<?php print phptemplate_body_class($left, $right); ?>><!-- Layout -->  <div id="header-region" class="clear-block"><?php print $header; ?></div>    <div id="wrapper">    <div id="container" class="clear-block">      <div id="header">        <div id="logo-floater">        <?php          // Prepare header          $site_fields = array();          if ($site_name) {            $site_fields[] = check_plain($site_name);          }          if ($site_slogan) {            $site_fields[] = check_plain($site_slogan);          }          $site_title = implode(' ', $site_fields);          if ($site_fields) {            $site_fields[0] = '<span>'. $site_fields[0] .'</span>';          }          $site_html = implode(' ', $site_fields);          if ($logo || $site_title) {            print '<h1><a href="'. check_url($base_path) .'" title="'. $site_title .'">';            if ($logo) {              print '<img src="'. check_url($logo) .'" alt="'. $site_title .'" id="logo" />';            }            print $site_html .'</a></h1>';          }        ?>        </div>      </div> <!-- /header -->      <?php if ($left): ?>        <div id="sidebar-left" class="sidebar">          <?php if ($search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $left ?>        </div>      <?php endif; ?>      <div id="center"><div id="squeeze"><div class="right-corner"><div class="left-corner">          <?php if ($title): print '<h2'. ($tabs ? ' class="with-tabs"' : '') .'>'. $title .'</h2>'; endif; ?>          <?php print $help; ?>          <?php print $messages; ?>          <div class="clear-block">            <?php print $content ?>          </div>          <div id="footer"><?php print $footer_message . $footer ?></div>      </div></div></div></div> <!-- /.left-corner, /.right-corner, /#squeeze, /#center -->      <?php if ($right): ?>        <div id="sidebar-right" class="sidebar">          <?php print $right ?>        </div>      <?php endif; ?>    </div> <!-- /container -->  </div><!-- /layout -->  </body></html>
<?php// $Id$/** * @file * Enables the organization of content into categories. *//** * Implementation of hook_perm(). */function taxonomy_perm() {  return array('administer taxonomy');}/** * Implementation of hook_theme() */function taxonomy_theme() {  return array(    'taxonomy_term_select' => array(      'arguments' => array('element' => NULL),    ),    'taxonomy_term_page' => array(      'arguments' => array('tids' => array(), 'result' => NULL),    ),    'taxonomy_overview_vocabularies' => array(      'arguments' => array('form' => array()),    ),    'taxonomy_overview_terms' => array(      'arguments' => array('form' => array()),    ),  );}/** * Implementation of hook_link(). * * This hook is extended with $type = 'taxonomy terms' to allow themes to * print lists of terms associated with a node. Themes can print taxonomy * links with: * * if (module_exists('taxonomy')) { *   $terms = taxonomy_link('taxonomy terms', $node); *   print theme('links', $terms); * } */function taxonomy_link($type, $node = NULL) {  if ($type == 'taxonomy terms' && $node != NULL) {    $links = array();    // If previewing, the terms must be converted to objects first.    if (isset($node->build_mode) && $node->build_mode == NODE_BUILD_PREVIEW) {      $node->taxonomy = taxonomy_preview_terms($node);    }    if (!empty($node->taxonomy)) {      foreach ($node->taxonomy as $term) {        // During preview the free tagging terms are in an array unlike the        // other terms which are objects. So we have to check if a $term        // is an object or not.        if (is_object($term)) {          $links['taxonomy_term_'. $term->tid] = array(            'title' => $term->name,            'href' => taxonomy_term_path($term),            'attributes' => array('rel' => 'tag', 'title' => strip_tags($term->description))          );        }        // Previewing free tagging terms; we don't link them because the        // term-page might not exist yet.        else {          foreach ($term as $free_typed) {            $typed_terms = drupal_explode_tags($free_typed);            foreach ($typed_terms as $typed_term) {              $links['taxonomy_preview_term_'. $typed_term] = array(                'title' => $typed_term,              );            }          }        }      }    }    // We call this hook again because some modules and themes    // call taxonomy_link('taxonomy terms') directly.    drupal_alter('link', $links, $node);    return $links;  }}/** * For vocabularies not maintained by taxonomy.module, give the maintaining * module a chance to provide a path for terms in that vocabulary. * * @param $term *   A term object. * @return *   An internal Drupal path. */function taxonomy_term_path($term) {  $vocabulary = taxonomy_vocabulary_load($term->vid);  if ($vocabulary->module != 'taxonomy' && $path = module_invoke($vocabulary->module, 'term_path', $term)) {    return $path;  }  return 'taxonomy/term/'. $term->tid;}/** * Implementation of hook_menu(). */function taxonomy_menu() {  $items['admin/content/taxonomy'] = array(    'title' => 'Taxonomy',    'description' => 'Manage tagging, categorization, and classification of your content.',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_overview_vocabularies'),    'access arguments' => array('administer taxonomy'),    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/taxonomy/add/vocabulary'] = array(    'title' => 'Add vocabulary',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_form_vocabulary'),    'access arguments' => array('administer taxonomy'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/taxonomy',    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/edit/vocabulary/%taxonomy_vocabulary'] = array(    'title' => 'Edit vocabulary',    'page callback' => 'taxonomy_admin_vocabulary_edit',    'page arguments' => array(5),    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/edit/term'] = array(    'title' => 'Edit term',    'page callback' => 'taxonomy_admin_term_edit',    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['taxonomy/term/%'] = array(    'title' => 'Taxonomy term',    'page callback' => 'taxonomy_term_page',    'page arguments' => array(2),    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.pages.inc',  );  $items['taxonomy/autocomplete'] = array(    'title' => 'Autocomplete taxonomy',    'page callback' => 'taxonomy_autocomplete',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.pages.inc',  );  $items['admin/content/taxonomy/%taxonomy_vocabulary'] = array(    'title' => 'List terms',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_overview_terms', 3),    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/%taxonomy_vocabulary/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/taxonomy/%taxonomy_vocabulary/add/term'] = array(    'title' => 'Add term',    'page callback' => 'taxonomy_add_term_page',    'page arguments' => array(3),    'access arguments' => array('administer taxonomy'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/taxonomy/%taxonomy_vocabulary',    'file' => 'taxonomy.admin.inc',  );  return $items;}function taxonomy_save_vocabulary(&$edit) {  $edit['nodes'] = empty($edit['nodes']) ? array() : $edit['nodes'];  if (!isset($edit['module'])) {    $edit['module'] = 'taxonomy';  }  if (!empty($edit['vid']) && !empty($edit['name'])) {    drupal_write_record('vocabulary', $edit, 'vid');    db_query("DELETE FROM {vocabulary_node_types} WHERE vid = %d", $edit['vid']);    foreach ($edit['nodes'] as $type => $selected) {      db_query("INSERT INTO {vocabulary_node_types} (vid, type) VALUES (%d, '%s')", $edit['vid'], $type);    }    module_invoke_all('taxonomy', 'update', 'vocabulary', $edit);    $status = SAVED_UPDATED;  }  else if (!empty($edit['vid'])) {    $status = taxonomy_del_vocabulary($edit['vid']);  }  else {    drupal_write_record('vocabulary', $edit);    foreach ($edit['nodes'] as $type => $selected) {      db_query("INSERT INTO {vocabulary_node_types} (vid, type) VALUES (%d, '%s')", $edit['vid'], $type);    }    module_invoke_all('taxonomy', 'insert', 'vocabulary', $edit);    $status = SAVED_NEW;  }  cache_clear_all();  return $status;}/** * Delete a vocabulary. * * @param $vid *   A vocabulary ID. * @return *   Constant indicating items were deleted. */function taxonomy_del_vocabulary($vid) {  $vocabulary = (array) taxonomy_vocabulary_load($vid);  db_query('DELETE FROM {vocabulary} WHERE vid = %d', $vid);  db_query('DELETE FROM {vocabulary_node_types} WHERE vid = %d', $vid);  $result = db_query('SELECT tid FROM {term_data} WHERE vid = %d', $vid);  while ($term = db_fetch_object($result)) {    taxonomy_del_term($term->tid);  }  module_invoke_all('taxonomy', 'delete', 'vocabulary', $vocabulary);  cache_clear_all();  return SAVED_DELETED;}/** * Dynamically check and update the hierarachy flag of a vocabulary. * * Checks the current parents of all terms in a vocabulary and updates the * vocabularies hierarchy setting to the lowest possible level. A hierarchy with * no parents in any of its terms will be given a hierarchy of 0. If terms * contain at most a single parent, the vocabulary will be given a hierarchy of * 1. If any term contain multiple parents, the vocabulary will be given a * hieararchy of 2. * * @param $vocabulary *   An array of the vocabulary structure. * @param $changed_term *   An array of the term structure that was updated. */function taxonomy_check_vocabulary_hierarchy($vocabulary, $changed_term) {  $tree = taxonomy_get_tree($vocabulary['vid']);  $hierarchy = 0;  foreach ($tree as $term) {    // Update the changed term with the new parent value before comparision.    if ($term->tid == $changed_term['tid']) {      $term = (object)$changed_term;      $term->parents = $term->parent;    }    // Check this term's parent count.    if (count($term->parents) > 1) {      $hierarchy = 2;      break;    }    elseif (count($term->parents) == 1 && 0 !== array_shift($term->parents)) {      $hierarchy = 1;    }  }  if ($hierarchy != $vocabulary['hierarchy']) {    $vocabulary['hierarchy'] = $hierarchy;    taxonomy_save_vocabulary($vocabulary);  }  return $hierarchy;}/** * Helper function for taxonomy_form_term_submit(). * * @param $form_state['values'] * @return *   Status constant indicating if term was inserted or updated. */function taxonomy_save_term(&$form_values) {  $form_values += array(    'description' => '',    'weight' => 0  );  if (!empty($form_values['tid']) && $form_values['name']) {    drupal_write_record('term_data', $form_values, 'tid');    $hook = 'update';    $status = SAVED_UPDATED;  }  else if (!empty($form_values['tid'])) {    return taxonomy_del_term($form_values['tid']);  }  else {    drupal_write_record('term_data', $form_values);    $hook = 'insert';    $status = SAVED_NEW;  }  db_query('DELETE FROM {term_relation} WHERE tid1 = %d OR tid2 = %d', $form_values['tid'], $form_values['tid']);  if (!empty($form_values['relations'])) {    foreach ($form_values['relations'] as $related_id) {      if ($related_id != 0) {        db_query('INSERT INTO {term_relation} (tid1, tid2) VALUES (%d, %d)', $form_values['tid'], $related_id);      }    }  }  db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $form_values['tid']);  if (!isset($form_values['parent']) || empty($form_values['parent'])) {    $form_values['parent'] = array(0);  }  if (is_array($form_values['parent'])) {    foreach ($form_values['parent'] as $parent) {      if (is_array($parent)) {        foreach ($parent as $tid) {          db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $tid);        }      }      else {        db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $parent);      }    }  }  else {    db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $form_values['parent']);  }  db_query('DELETE FROM {term_synonym} WHERE tid = %d', $form_values['tid']);  if (!empty($form_values['synonyms'])) {    foreach (explode ("\n", str_replace("\r", '', $form_values['synonyms'])) as $synonym) {      if ($synonym) {        db_query("INSERT INTO {term_synonym} (tid, name) VALUES (%d, '%s')", $form_values['tid'], chop($synonym));      }    }  }  if (isset($hook)) {    module_invoke_all('taxonomy', $hook, 'term', $form_values);  }  cache_clear_all();  return $status;}/** * Delete a term. * * @param $tid *   The term ID. * @return *   Status constant indicating deletion. */function taxonomy_del_term($tid) {  $tids = array($tid);  while ($tids) {    $children_tids = $orphans = array();    foreach ($tids as $tid) {      // See if any of the term's children are about to be become orphans:      if ($children = taxonomy_get_children($tid)) {        foreach ($children as $child) {          // If the term has multiple parents, we don't delete it.          $parents = taxonomy_get_parents($child->tid);          if (count($parents) == 1) {            $orphans[] = $child->tid;          }        }      }      $term = (array) taxonomy_get_term($tid);      db_query('DELETE FROM {term_data} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_relation} WHERE tid1 = %d OR tid2 = %d', $tid, $tid);      db_query('DELETE FROM {term_synonym} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_node} WHERE tid = %d', $tid);      module_invoke_all('taxonomy', 'delete', 'term', $term);    }    $tids = $orphans;  }  cache_clear_all();  return SAVED_DELETED;}/** * Generate a form element for selecting terms from a vocabulary. */function taxonomy_form($vid, $value = 0, $help = NULL, $name = 'taxonomy') {  $vocabulary = taxonomy_vocabulary_load($vid);  $help = ($help) ? $help : filter_xss_admin($vocabulary->help);  if (!$vocabulary->multiple) {    $blank = ($vocabulary->required) ? t('- Please choose -') : t('- None selected -');  }  else {    $blank = ($vocabulary->required) ? 0 : t('- None -');  }  return _taxonomy_term_select(check_plain($vocabulary->name), $name, $value, $vid, $help, intval($vocabulary->multiple), $blank);}/** * Generate a set of options for selecting a term from all vocabularies. */function taxonomy_form_all($free_tags = 0) {  $vocabularies = taxonomy_get_vocabularies();  $options = array();  foreach ($vocabularies as $vid => $vocabulary) {    if ($vocabulary->tags && !$free_tags) { continue; }    $tree = taxonomy_get_tree($vid);    if ($tree && (count($tree) > 0)) {      $options[$vocabulary->name] = array();      foreach ($tree as $term) {        $options[$vocabulary->name][$term->tid] = str_repeat('-', $term->depth) . $term->name;      }    }  }  return $options;}/** * Return an array of all vocabulary objects. * * @param $type *   If set, return only those vocabularies associated with this node type. */function taxonomy_get_vocabularies($type = NULL) {  if ($type) {    $result = db_query(db_rewrite_sql("SELECT v.vid, v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s' ORDER BY v.weight, v.name", 'v', 'vid'), $type);  }  else {    $result = db_query(db_rewrite_sql('SELECT v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid ORDER BY v.weight, v.name', 'v', 'vid'));  }  $vocabularies = array();  $node_types = array();  while ($voc = db_fetch_object($result)) {    // If no node types are associated with a vocabulary, the LEFT JOIN will    // return a NULL value for type.    if (isset($voc->type)) {      $node_types[$voc->vid][$voc->type] = $voc->type;      unset($voc->type);      $voc->nodes = $node_types[$voc->vid];    }    elseif (!isset($voc->nodes)) {      $voc->nodes = array();    }    $vocabularies[$voc->vid] = $voc;  }  return $vocabularies;}/** * Implementation of hook_form_alter(). * Generate a form for selecting terms to associate with a node. * We check for taxonomy_override_selector before loading the full * vocabulary, so contrib modules can intercept before hook_form_alter *  and provide scalable alternatives. */function taxonomy_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && (!variable_get('taxonomy_override_selector', FALSE)) && $form['type']['#value'] .'_node_form' == $form_id) {    $node = $form['#node'];    if (!isset($node->taxonomy)) {      $terms = empty($node->nid) ? array() : taxonomy_node_get_terms($node);    }    else {      // After preview the terms must be converted to objects.      if (isset($form_state['node_preview'])) {        $node->taxonomy = taxonomy_preview_terms($node);      }      $terms = $node->taxonomy;    }    $c = db_query(db_rewrite_sql("SELECT v.* FROM {vocabulary} v INNER JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s' ORDER BY v.weight, v.name", 'v', 'vid'), $node->type);    while ($vocabulary = db_fetch_object($c)) {      if ($vocabulary->tags) {        if (isset($form_state['node_preview'])) {          // Typed string can be changed by the user before preview,          // so we just insert the tags directly as provided in the form.          $typed_string = $node->taxonomy['tags'][$vocabulary->vid];        }        else {          $typed_string = taxonomy_implode_tags($terms, $vocabulary->vid) . (array_key_exists('tags', $terms) ? $terms['tags'][$vocabulary->vid] : NULL);        }        if ($vocabulary->help) {          $help = filter_xss_admin($vocabulary->help);        }        else {          $help = t('A comma-separated list of terms describing this content. Example: funny, bungee jumping, "Company, Inc.".');        }        $form['taxonomy']['tags'][$vocabulary->vid] = array('#type' => 'textfield',          '#title' => $vocabulary->name,          '#description' => $help,          '#required' => $vocabulary->required,          '#default_value' => $typed_string,          '#autocomplete_path' => 'taxonomy/autocomplete/'. $vocabulary->vid,          '#weight' => $vocabulary->weight,          '#maxlength' => 1024,        );      }      else {        // Extract terms belonging to the vocabulary in question.        $default_terms = array();        foreach ($terms as $term) {          // Free tagging has no default terms and also no vid after preview.          if (isset($term->vid) && $term->vid == $vocabulary->vid) {            $default_terms[$term->tid] = $term;          }        }        $form['taxonomy'][$vocabulary->vid] = taxonomy_form($vocabulary->vid, array_keys($default_terms), filter_xss_admin($vocabulary->help));        $form['taxonomy'][$vocabulary->vid]['#weight'] = $vocabulary->weight;        $form['taxonomy'][$vocabulary->vid]['#required'] = $vocabulary->required;      }    }    if (!empty($form['taxonomy']) && is_array($form['taxonomy'])) {      if (count($form['taxonomy']) > 1) {        // Add fieldset only if form has more than 1 element.        $form['taxonomy'] += array(          '#type' => 'fieldset',          '#title' => t('Vocabularies'),          '#collapsible' => TRUE,          '#collapsed' => FALSE,        );      }      $form['taxonomy']['#weight'] = -3;      $form['taxonomy']['#tree'] = TRUE;    }  }}/** * Helper function to convert terms after a preview. * * After preview the tags are an array instead of proper objects. This function * converts them back to objects with the exception of 'free tagging' terms, * because new tags can be added by the user before preview and those do not * yet exist in the database. We therefore save those tags as a string so * we can fill the form again after the preview. */function taxonomy_preview_terms($node) {  $taxonomy = array();  if (isset($node->taxonomy)) {    foreach ($node->taxonomy as $key => $term) {      unset($node->taxonomy[$key]);      // A 'Multiple select' and a 'Free tagging' field returns an array.      if (is_array($term)) {        foreach ($term as $tid) {          if ($key == 'tags') {            // Free tagging; the values will be saved for later as strings            // instead of objects to fill the form again.            $taxonomy['tags'] = $term;          }          else {            $taxonomy[$tid] = taxonomy_get_term($tid);          }        }      }      // A 'Single select' field returns the term id.      elseif ($term) {        $taxonomy[$term] = taxonomy_get_term($term);      }    }  }  return $taxonomy;}/** * Find all terms associated with the given node, within one vocabulary. */function taxonomy_node_get_terms_by_vocabulary($node, $vid, $key = 'tid') {  $result = db_query(db_rewrite_sql('SELECT t.tid, t.* FROM {term_data} t INNER JOIN {term_node} r ON r.tid = t.tid WHERE t.vid = %d AND r.vid = %d ORDER BY weight', 't', 'tid'), $vid, $node->vid);  $terms = array();  while ($term = db_fetch_object($result)) {    $terms[$term->$key] = $term;  }  return $terms;}/** * Find all terms associated with the given node, ordered by vocabulary and term weight. */function taxonomy_node_get_terms($node, $key = 'tid') {  static $terms;  if (!isset($terms[$node->vid][$key])) {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_node} r INNER JOIN {term_data} t ON r.tid = t.tid INNER JOIN {vocabulary} v ON t.vid = v.vid WHERE r.vid = %d ORDER BY v.weight, t.weight, t.name', 't', 'tid'), $node->vid);    $terms[$node->vid][$key] = array();    while ($term = db_fetch_object($result)) {      $terms[$node->vid][$key][$term->$key] = $term;    }  }  return $terms[$node->vid][$key];}/** * Make sure incoming vids are free tagging enabled. */function taxonomy_node_validate(&$node) {  if (!empty($node->taxonomy)) {    $terms = $node->taxonomy;    if (!empty($terms['tags'])) {      foreach ($terms['tags'] as $vid => $vid_value) {        $vocabulary = taxonomy_vocabulary_load($vid);        if (empty($vocabulary->tags)) {          // see form_get_error $key = implode('][', $element['#parents']);          // on why this is the key          form_set_error("taxonomy][tags][$vid", t('The %name vocabulary can not be modified in this way.', array('%name' => $vocabulary->name)));        }      }    }  }}/** * Save term associations for a given node. */function taxonomy_node_save($node, $terms) {  taxonomy_node_delete_revision($node);  // Free tagging vocabularies do not send their tids in the form,  // so we'll detect them here and process them independently.  if (isset($terms['tags'])) {    $typed_input = $terms['tags'];    unset($terms['tags']);    foreach ($typed_input as $vid => $vid_value) {      $typed_terms = drupal_explode_tags($vid_value);      $inserted = array();      foreach ($typed_terms as $typed_term) {        // See if the term exists in the chosen vocabulary        // and return the tid; otherwise, add a new record.        $possibilities = taxonomy_get_term_by_name($typed_term);        $typed_term_tid = NULL; // tid match, if any.        foreach ($possibilities as $possibility) {          if ($possibility->vid == $vid) {            $typed_term_tid = $possibility->tid;          }        }        if (!$typed_term_tid) {          $edit = array('vid' => $vid, 'name' => $typed_term);          $status = taxonomy_save_term($edit);          $typed_term_tid = $edit['tid'];        }        // Defend against duplicate, differently cased tags        if (!isset($inserted[$typed_term_tid])) {          db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $typed_term_tid);          $inserted[$typed_term_tid] = TRUE;        }      }    }  }  if (is_array($terms)) {    foreach ($terms as $term) {      if (is_array($term)) {        foreach ($term as $tid) {          if ($tid) {            db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $tid);          }        }      }      else if (is_object($term)) {        db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $term->tid);      }      else if ($term) {        db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $term);      }    }  }}/** * Remove associations of a node to its terms. */function taxonomy_node_delete($node) {  db_query('DELETE FROM {term_node} WHERE nid = %d', $node->nid);}/** * Remove associations of a node to its terms. */function taxonomy_node_delete_revision($node) {  db_query('DELETE FROM {term_node} WHERE vid = %d', $node->vid);}/** * Implementation of hook_node_type(). */function taxonomy_node_type($op, $info) {  if ($op == 'update' && !empty($info->old_type) && $info->type != $info->old_type) {    db_query("UPDATE {vocabulary_node_types} SET type = '%s' WHERE type = '%s'", $info->type, $info->old_type);  }  elseif ($op == 'delete') {    db_query("DELETE FROM {vocabulary_node_types} WHERE type = '%s'", $info->type);  }}/** * Find all term objects related to a given term ID. */function taxonomy_get_related($tid, $key = 'tid') {  if ($tid) {    $result = db_query('SELECT t.*, tid1, tid2 FROM {term_relation}, {term_data} t WHERE (t.tid = tid1 OR t.tid = tid2) AND (tid1 = %d OR tid2 = %d) AND t.tid != %d ORDER BY weight, name', $tid, $tid, $tid);    $related = array();    while ($term = db_fetch_object($result)) {      $related[$term->$key] = $term;    }    return $related;  }  else {    return array();  }}/** * Find all parents of a given term ID. */function taxonomy_get_parents($tid, $key = 'tid') {  if ($tid) {    $result = db_query(db_rewrite_sql('SELECT t.tid, t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.parent = t.tid WHERE h.tid = %d ORDER BY weight, name', 't', 'tid'), $tid);    $parents = array();    while ($parent = db_fetch_object($result)) {      $parents[$parent->$key] = $parent;    }    return $parents;  }  else {    return array();  }}/** * Find all ancestors of a given term ID. */function taxonomy_get_parents_all($tid) {  $parents = array();  if ($tid) {    $parents[] = taxonomy_get_term($tid);    $n = 0;    while ($parent = taxonomy_get_parents($parents[$n]->tid)) {      $parents = array_merge($parents, $parent);      $n++;    }  }  return $parents;}/** * Find all children of a term ID. */function taxonomy_get_children($tid, $vid = 0, $key = 'tid') {  if ($vid) {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.tid = t.tid WHERE t.vid = %d AND h.parent = %d ORDER BY weight, name', 't', 'tid'), $vid, $tid);  }  else {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.tid = t.tid WHERE parent = %d ORDER BY weight, name', 't', 'tid'), $tid);  }  $children = array();  while ($term = db_fetch_object($result)) {    $children[$term->$key] = $term;  }  return $children;}/** * Create a hierarchical representation of a vocabulary. * * @param $vid *   Which vocabulary to generate the tree for. * * @param $parent *   The term ID under which to generate the tree. If 0, generate the tree *   for the entire vocabulary. * * @param $depth *   Internal use only. * * @param $max_depth *   The number of levels of the tree to return. Leave NULL to return all levels. * * @return *   An array of all term objects in the tree. Each term object is extended *   to have "depth" and "parents" attributes in addition to its normal ones. *   Results are statically cached. */function taxonomy_get_tree($vid, $parent = 0, $depth = -1, $max_depth = NULL) {  static $children, $parents, $terms;  $depth++;  // We cache trees, so it's not CPU-intensive to call get_tree() on a term  // and its children, too.  if (!isset($children[$vid])) {    $children[$vid] = array();    $result = db_query(db_rewrite_sql('SELECT t.tid, t.*, parent FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE t.vid = %d ORDER BY weight, name', 't', 'tid'), $vid);    while ($term = db_fetch_object($result)) {      $children[$vid][$term->parent][] = $term->tid;      $parents[$vid][$term->tid][] = $term->parent;      $terms[$vid][$term->tid] = $term;    }  }  $max_depth = (is_null($max_depth)) ? count($children[$vid]) : $max_depth;  $tree = array();  if ($max_depth > $depth && !empty($children[$vid][$parent])) {    foreach ($children[$vid][$parent] as $child) {      $term = drupal_clone($terms[$vid][$child]);      $term->depth = $depth;      // The "parent" attribute is not useful, as it would show one parent only.      unset($term->parent);      $term->parents = $parents[$vid][$child];      $tree[] = $term;      if (!empty($children[$vid][$child])) {        $tree = array_merge($tree, taxonomy_get_tree($vid, $child, $depth, $max_depth));      }    }  }  return $tree;}/** * Return an array of synonyms of the given term ID. */function taxonomy_get_synonyms($tid) {  if ($tid) {    $synonyms = array();    $result = db_query('SELECT name FROM {term_synonym} WHERE tid = %d', $tid);    while ($synonym = db_fetch_array($result)) {      $synonyms[] = $synonym['name'];    }    return $synonyms;  }  else {    return array();  }}/** * Return the term object that has the given string as a synonym. */function taxonomy_get_synonym_root($synonym) {  return db_fetch_object(db_query("SELECT * FROM {term_synonym} s, {term_data} t WHERE t.tid = s.tid AND s.name = '%s'", $synonym));}/** * Count the number of published nodes classified by a term. * * @param $tid *   The term's ID * * @param $type *   The $node->type. If given, taxonomy_term_count_nodes only counts *   nodes of $type that are classified with the term $tid. * * @return int *   An integer representing a number of nodes. *   Results are statically cached. */function taxonomy_term_count_nodes($tid, $type = 0) {  static $count;  if (!isset($count[$type])) {    // $type == 0 always evaluates TRUE if $type is a string    if (is_numeric($type)) {      $result = db_query(db_rewrite_sql('SELECT t.tid, COUNT(n.nid) AS c FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.status = 1 GROUP BY t.tid'));    }    else {      $result = db_query(db_rewrite_sql("SELECT t.tid, COUNT(n.nid) AS c FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.status = 1 AND n.type = '%s' GROUP BY t.tid"), $type);    }    $count[$type] = array();    while ($term = db_fetch_object($result)) {      $count[$type][$term->tid] = $term->c;    }  }  $children_count = 0;  foreach (_taxonomy_term_children($tid) as $c) {    $children_count += taxonomy_term_count_nodes($c, $type);  }  return $children_count + (isset($count[$type][$tid]) ? $count[$type][$tid] : 0);}/** * Helper for taxonomy_term_count_nodes(). Used to find out * which terms are children of a parent term. * * @param $tid *   The parent term's ID * * @return array *   An array of term IDs representing the children of $tid. *   Results are statically cached. * */function _taxonomy_term_children($tid) {  static $children;  if (!isset($children)) {    $result = db_query('SELECT tid, parent FROM {term_hierarchy}');    while ($term = db_fetch_object($result)) {      $children[$term->parent][] = $term->tid;    }  }  return isset($children[$tid]) ? $children[$tid] : array();}/** * Try to map a string to an existing term, as for glossary use. * * Provides a case-insensitive and trimmed mapping, to maximize the * likelihood of a successful match. * * @param name *   Name of the term to search for. * * @return *   An array of matching term objects. */function taxonomy_get_term_by_name($name) {  $db_result = db_query(db_rewrite_sql("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s')", 't', 'tid'), trim($name));  $result = array();  while ($term = db_fetch_object($db_result)) {    $result[] = $term;  }  return $result;}/** * Return the vocabulary object matching a vocabulary ID. * * @param $vid *   The vocabulary's ID * @param $reset *   Whether to reset the internal taxonomy_vocabulary_load cache. * * @return *   The vocabulary object with all of its metadata, if exists, FALSE otherwise. *   Results are statically cached. */function taxonomy_vocabulary_load($vid, $reset = FALSE) {  static $vocabularies = array();  if ($reset) {    $vocabularies = array();  }  if (!isset($vocabularies[$vid])) {    // Initialize so if this vocabulary does not exist, we have    // that cached, and we will not try to load this later.    $vocabularies[$vid] = FALSE;    // Try to load the data and fill up the object.    $result = db_query('SELECT v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE v.vid = %d', $vid);    $node_types = array();    while ($voc = db_fetch_object($result)) {      if (!empty($voc->type)) {        $node_types[$voc->type] = $voc->type;      }      unset($voc->type);      $voc->nodes = $node_types;      $vocabularies[$vid] = $voc;    }  }  // Return FALSE if this vocabulary does not exist.  return !empty($vocabularies[$vid]) ? $vocabularies[$vid] : FALSE;}/** * Return the term object matching a term ID. * * @param $tid *   A term's ID * @param $reset *   Whether to reset the internal taxonomy_get_term cache. * * @return Object *   A term object. Results are statically cached. */function taxonomy_get_term($tid, $reset = FALSE) {  static $terms = array();  if ($reset) {    $terms = array();  }  if (!isset($terms[$tid])) {    $terms[$tid] = db_fetch_object(db_query('SELECT * FROM {term_data} WHERE tid = %d', $tid));  }  return $terms[$tid];}/** * Create a select form element for a given taxonomy vocabulary. * * NOTE: This function expects input that has already been sanitized and is * safe for display. Callers must properly sanitize the $title and * $description arguments to prevent XSS vulnerabilities. * * @param $title *   The title of the vocabulary. This MUST be sanitized by the caller. * @param $name *   Ignored. * @param $value *   The currently selected terms from this vocabulary, if any. * @param $vocabulary_id *   The vocabulary ID to build the form element for. * @param $description *   Help text for the form element. This MUST be sanitized by the caller. * @param $multiple *   Boolean to control if the form should use a single or multiple select. * @param $blank *   Optional form choice to use when no value has been selected. * @param $exclude *   Optional array of term ids to exclude in the selector. * @return *   A FAPI form array to select terms from the given vocabulary. * * @see taxonomy_form() * @see taxonomy_form_term() */function _taxonomy_term_select($title, $name, $value, $vocabulary_id, $description, $multiple, $blank, $exclude = array()) {  $tree = taxonomy_get_tree($vocabulary_id);  $options = array();  if ($blank) {    $options[''] = $blank;  }  if ($tree) {    foreach ($tree as $term) {      if (!in_array($term->tid, $exclude)) {        $choice = new stdClass();        $choice->option = array($term->tid => str_repeat('-', $term->depth) . $term->name);        $options[] = $choice;      }    }  }  return array('#type' => 'select',    '#title' => $title,    '#default_value' => $value,    '#options' => $options,    '#description' => $description,    '#multiple' => $multiple,    '#size' => $multiple ? min(9, count($options)) : 0,    '#weight' => -15,    '#theme' => 'taxonomy_term_select',  );}/** * Format the selection field for choosing terms * (by deafult the default selection field is used). * * @ingroup themeable */function theme_taxonomy_term_select($element) {  return theme('select', $element);}/** * Finds all nodes that match selected taxonomy conditions. * * @param $tids *   An array of term IDs to match. * @param $operator *   How to interpret multiple IDs in the array. Can be "or" or "and". * @param $depth *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative *   integer or "all". * @param $pager *   Whether the nodes are to be used with a pager (the case on most Drupal *   pages) or not (in an XML feed, for example). * @param $order *   The order clause for the query that retrieve the nodes. * @return *   A resource identifier pointing to the query results. */function taxonomy_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC') {  if (count($tids) > 0) {    // For each term ID, generate an array of descendant term IDs to the right depth.    $descendant_tids = array();    if ($depth === 'all') {      $depth = NULL;    }    foreach ($tids as $index => $tid) {      $term = taxonomy_get_term($tid);      $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);      $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));    }    if ($operator == 'or') {      $args = call_user_func_array('array_merge', $descendant_tids);      $placeholders = db_placeholders($args, 'int');      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN ('. $placeholders .') AND n.status = 1 ORDER BY '. $order;      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN ('. $placeholders .') AND n.status = 1';    }    else {      $joins = '';      $wheres = '';      $args = array();      foreach ($descendant_tids as $index => $tids) {        $joins .= ' INNER JOIN {term_node} tn'. $index .' ON n.vid = tn'. $index .'.vid';        $wheres .= ' AND tn'. $index .'.tid IN ('. db_placeholders($tids, 'int') .')';        $args = array_merge($args, $tids);      }      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres .' ORDER BY '. $order;      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres;    }    $sql = db_rewrite_sql($sql);    $sql_count = db_rewrite_sql($sql_count);    if ($pager) {      $result = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);    }    else {      $result = db_query_range($sql, $args, 0, variable_get('feed_default_items', 10));    }  }  return $result;}/** * Accepts the result of a pager_query() call, such as that performed by * taxonomy_select_nodes(), and formats each node along with a pager. */function taxonomy_render_nodes($result) {  $output = '';  $has_rows = FALSE;  while ($node = db_fetch_object($result)) {    $output .= node_view(node_load($node->nid), 1);    $has_rows = TRUE;  }  if ($has_rows) {    $output .= theme('pager', NULL, variable_get('default_nodes_main', 10), 0);  }  else {    $output .= '<p>'. t('There are currently no posts in this category.') .'</p>';  }  return $output;}/** * Implementation of hook_nodeapi(). */function taxonomy_nodeapi($node, $op, $arg = 0) {  switch ($op) {    case 'load':      $output['taxonomy'] = taxonomy_node_get_terms($node);      return $output;    case 'insert':      if (!empty($node->taxonomy)) {        taxonomy_node_save($node, $node->taxonomy);      }      break;    case 'update':      if (!empty($node->taxonomy)) {        taxonomy_node_save($node, $node->taxonomy);      }      break;    case 'delete':      taxonomy_node_delete($node);      break;    case 'delete revision':      taxonomy_node_delete_revision($node);      break;    case 'validate':      taxonomy_node_validate($node);      break;    case 'rss item':      return taxonomy_rss_item($node);    case 'update index':      return taxonomy_node_update_index($node);  }}/** * Implementation of hook_nodeapi('update_index'). */function taxonomy_node_update_index(&$node) {  $output = array();  foreach ($node->taxonomy as $term) {    $output[] = $term->name;  }  if (count($output)) {    return '<strong>('. implode(', ', $output) .')</strong>';  }}/** * Parses a comma or plus separated string of term IDs. * * @param $str_tids *   A string of term IDs, separated by plus or comma. *   comma (,) means AND *   plus (+) means OR * * @return an associative array with an operator key (either 'and' *   or 'or') and a tid key containing an array of the term ids. */function taxonomy_terms_parse_string($str_tids) {  $terms = array('operator' => '', 'tids' => array());  if (preg_match('/^([0-9]+[+ ])+[0-9]+$/', $str_tids)) {    $terms['operator'] = 'or';    // The '+' character in a query string may be parsed as ' '.    $terms['tids'] = preg_split('/[+ ]/', $str_tids);  }  else if (preg_match('/^([0-9]+,)*[0-9]+$/', $str_tids)) {    $terms['operator'] = 'and';    $terms['tids'] = explode(',', $str_tids);  }  return $terms;}/** * Provides category information for RSS feeds. */function taxonomy_rss_item($node) {  $output = array();  foreach ($node->taxonomy as $term) {    $output[] = array('key'   => 'category',                      'value' => $term->name,                      'attributes' => array('domain' => url('taxonomy/term/'. $term->tid, array('absolute' => TRUE))));  }  return $output;}/** * Implementation of hook_help(). */function taxonomy_help($path, $arg) {  switch ($path) {    case 'admin/help#taxonomy':      $output = '<p>'. t('The taxonomy module allows you to categorize content using various systems of classification. Free-tagging vocabularies are created by users on the fly when they submit posts (as commonly found in blogs and social bookmarking applications). Controlled vocabularies allow for administrator-defined short lists of terms as well as complex hierarchies with multiple relationships between different terms. These methods can be applied to different content types and combined together to create a powerful and flexible method of classifying and presenting your content.') .'</p>';      $output .= '<p>'. t('For example, when creating a recipe site, you might want to classify posts by both the type of meal and preparation time. A vocabulary for each allows you to categorize using each criteria independently instead of creating a tag for every possible combination.') .'</p>';      $output .= '<p>'. t('Type of Meal: <em>Appetizer, Main Course, Salad, Dessert</em>') .'</p>';      $output .= '<p>'. t('Preparation Time: <em>0-30mins, 30-60mins, 1-2 hrs, 2hrs+</em>') .'</p>';      $output .= '<p>'. t("Each taxonomy term (often called a 'category' or 'tag' in other systems) automatically provides lists of posts and a corresponding RSS feed. These taxonomy/term URLs can be manipulated to generate AND and OR lists of posts classified with terms. In our recipe site example, it then becomes easy to create pages displaying 'Main courses', '30 minute recipes', or '30 minute main courses and appetizers' by using terms on their own or in combination with others. There are a significant number of contributed modules which you to alter and extend the behavior of the core module for both display and organization of terms.") .'</p>';      $output .= '<p>'. t("Terms can also be organized in parent/child relationships from the admin interface. An example would be a vocabulary grouping countries under their parent geo-political regions. The taxonomy module also enables advanced implementations of hierarchy, for example placing Turkey in both the 'Middle East' and 'Europe'.") .'</p>';      $output .= '<p>'. t('The taxonomy module supports the use of both synonyms and related terms, but does not directly use this functionality. However, optional contributed or custom modules may make full use of these advanced features.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@taxonomy">Taxonomy module</a>.', array('@taxonomy' => 'http://drupal.org/handbook/modules/taxonomy/')) .'</p>';      return $output;    case 'admin/content/taxonomy':      $output = '<p>'. t("The taxonomy module allows you to categorize your content using both tags and administrator defined terms. It is a flexible tool for classifying content with many advanced features. To begin, create a 'Vocabulary' to hold one set of terms or tags. You can create one free-tagging vocabulary for everything, or separate controlled vocabularies to define the various properties of your content, for example 'Countries' or 'Colors'.") .'</p>';      $output .= '<p>'. t('Use the list below to configure and review the vocabularies defined on your site, or to list and manage the terms (tags) they contain. A vocabulary may (optionally) be tied to specific content types as shown in the <em>Type</em> column and, if so, will be displayed when creating or editing posts of that type. Multiple vocabularies tied to the same content type will be displayed in the order shown below. To change the order of a vocabulary, grab a drag-and-drop handle under the <em>Name</em> column and drag it to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save</em> button at the bottom of the page.') .'</p>';      return $output;    case 'admin/content/taxonomy/%':      $vocabulary = taxonomy_vocabulary_load($arg[3]);      if ($vocabulary->tags) {        return '<p>'. t('%capital_name is a free-tagging vocabulary. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name))) .'</p>';      }      switch ($vocabulary->hierarchy) {        case 0:          return '<p>'. t('%capital_name is a flat vocabulary. You may organize the terms in the %name vocabulary by using the handles on the left side of the table. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name)) .'</p>';        case 1:          return '<p>'. t('%capital_name is a single hierarchy vocabulary. You may organize the terms in the %name vocabulary by using the handles on the left side of the table. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name)) .'</p>';        case 2:          return '<p>'. t('%capital_name is a multiple hierarchy vocabulary. To change the name or description of a term, click the <em>edit</em> link next to the term. Drag and drop of multiple hierarchies is not supported, but you can re-enable drag and drop support by editing each term to include only a single parent.', array('%capital_name' => drupal_ucfirst($vocabulary->name))) .'</p>';      }    case 'admin/content/taxonomy/add/vocabulary':      return '<p>'. t('Define how your vocabulary will be presented to administrators and users, and which content types to categorize with it. Tags allows users to create terms when submitting posts by typing a comma separated list. Otherwise terms are chosen from a select list and can only be created by users with the "administer taxonomy" permission.') .'</p>';  }}/** * Helper function for array_map purposes. */function _taxonomy_get_tid_from_term($term) {  return $term->tid;}/** * Implode a list of tags of a certain vocabulary into a string. */function taxonomy_implode_tags($tags, $vid = NULL) {  $typed_tags = array();  foreach ($tags as $tag) {    // Extract terms belonging to the vocabulary in question.    if (is_null($vid) || $tag->vid == $vid) {      // Commas and quotes in tag names are special cases, so encode 'em.      if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {        $tag->name = '"'. str_replace('"', '""', $tag->name) .'"';      }      $typed_tags[] = $tag->name;    }  }  return implode(', ', $typed_tags);}/** * Implementation of hook_hook_info(). */function taxonomy_hook_info() {  return array(    'taxonomy' => array(      'taxonomy' => array(        'insert' => array(          'runs when' => t('After saving a new term to the database'),        ),        'update' => array(          'runs when' => t('After saving an updated term to the database'),        ),        'delete' => array(          'runs when' => t('After deleting a term')        ),      ),    ),  );}
<?php// $Id$/** * @file * Admin page callbacks for the aggregator module. *//** * Menu callback; displays the aggregator administration page. */function aggregator_admin_overview() {  return aggregator_view();}/** * Displays the aggregator administration page. * * @return *   The page HTML. */function aggregator_view() {  $result = db_query('SELECT f.*, COUNT(i.iid) AS items FROM {aggregator_feed} f LEFT JOIN {aggregator_item} i ON f.fid = i.fid GROUP BY f.fid, f.title, f.url, f.refresh, f.checked, f.link, f.description, f.etag, f.modified, f.image, f.block ORDER BY f.title');  $output = '<h3>'. t('Feed overview') .'</h3>';  $header = array(t('Title'), t('Items'), t('Last update'), t('Next update'), array('data' => t('Operations'), 'colspan' => '3'));  $rows = array();  while ($feed = db_fetch_object($result)) {    $rows[] = array(l($feed->title, "aggregator/sources/$feed->fid"), format_plural($feed->items, '1 item', '@count items'), ($feed->checked ? t('@time ago', array('@time' => format_interval(time() - $feed->checked))) : t('never')), ($feed->checked ? t('%time left', array('%time' => format_interval($feed->checked + $feed->refresh - time()))) : t('never')), l(t('edit'), "admin/content/aggregator/edit/feed/$feed->fid"), l(t('remove items'), "admin/content/aggregator/remove/$feed->fid"), l(t('update items'), "admin/content/aggregator/update/$feed->fid"));  }  $output .= theme('table', $header, $rows);  $result = db_query('SELECT c.cid, c.title, count(ci.iid) as items FROM {aggregator_category} c LEFT JOIN {aggregator_category_item} ci ON c.cid = ci.cid GROUP BY c.cid, c.title ORDER BY title');  $output .= '<h3>'. t('Category overview') .'</h3>';  $header = array(t('Title'), t('Items'), t('Operations'));  $rows = array();  while ($category = db_fetch_object($result)) {    $rows[] = array(l($category->title, "aggregator/categories/$category->cid"), format_plural($category->items, '1 item', '@count items'), l(t('edit'), "admin/content/aggregator/edit/category/$category->cid"));  }  $output .= theme('table', $header, $rows);  return $output;}/** * Form builder; Generate a form to add/edit feed sources. * * @ingroup forms * @see aggregator_form_feed_validate() * @see aggregator_form_feed_submit() */function aggregator_form_feed(&$form_state, $edit = array('refresh' => 900, 'title' => '', 'url' => '', 'fid' => NULL)) {  $period = drupal_map_assoc(array(900, 1800, 3600, 7200, 10800, 21600, 32400, 43200, 64800, 86400, 172800, 259200, 604800, 1209600, 2419200), 'format_interval');  if ($edit['refresh'] == '') {    $edit['refresh'] = 3600;  }  $form['title'] = array('#type' => 'textfield',    '#title' => t('Title'),    '#default_value' => $edit['title'],    '#maxlength' => 255,    '#description' => t('The name of the feed (or the name of the website providing the feed).'),    '#required' => TRUE,  );  $form['url'] = array('#type' => 'textfield',    '#title' => t('URL'),    '#default_value' => $edit['url'],    '#maxlength' => 255,    '#description' => t('The fully-qualified URL of the feed.'),    '#required' => TRUE,  );  $form['refresh'] = array('#type' => 'select',    '#title' => t('Update interval'),    '#default_value' => $edit['refresh'],    '#options' => $period,    '#description' => t('The length of time between feed updates. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status'))),  );  // Handling of categories:  $options = array();  $values = array();  $categories = db_query('SELECT c.cid, c.title, f.fid FROM {aggregator_category} c LEFT JOIN {aggregator_category_feed} f ON c.cid = f.cid AND f.fid = %d ORDER BY title', $edit['fid']);  while ($category = db_fetch_object($categories)) {    $options[$category->cid] = check_plain($category->title);    if ($category->fid) $values[] = $category->cid;  }  if ($options) {    $form['category'] = array('#type' => 'checkboxes',      '#title' => t('Categorize news items'),      '#default_value' => $values,      '#options' => $options,      '#description' => t('New feed items are automatically filed in the checked categories.'),    );  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));  if ($edit['fid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['fid'] = array('#type' => 'hidden', '#value' => $edit['fid']);  }  return $form;}/** * Validate aggregator_form_feed form submissions. */function aggregator_form_feed_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Save')) {    // Ensure URL is valid.    if (!valid_url($form_state['values']['url'], TRUE)) {      form_set_error('url', t('The URL %url is invalid. Please enter a fully-qualified URL, such as http://www.example.com/feed.xml.', array('%url' => $form_state['values']['url'])));    }    // Check for duplicate titles.    if (isset($form_state['values']['fid'])) {      $result = db_query("SELECT title, url FROM {aggregator_feed} WHERE (title = '%s' OR url = '%s') AND fid <> %d", $form_state['values']['title'], $form_state['values']['url'], $form_state['values']['fid']);    }    else {      $result = db_query("SELECT title, url FROM {aggregator_feed} WHERE title = '%s' OR url = '%s'", $form_state['values']['title'], $form_state['values']['url']);    }    while ($feed = db_fetch_object($result)) {      if (strcasecmp($feed->title, $form_state['values']['title']) == 0) {        form_set_error('title', t('A feed named %feed already exists. Please enter a unique title.', array('%feed' => $form_state['values']['title'])));      }      if (strcasecmp($feed->url, $form_state['values']['url']) == 0) {        form_set_error('url', t('A feed with this URL %url already exists. Please enter a unique URL.', array('%url' => $form_state['values']['url'])));      }    }  }}/** * Process aggregator_form_feed form submissions. * * @todo Add delete confirmation dialog. */function aggregator_form_feed_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Delete')) {    $title = $form_state['values']['title'];    // Unset the title:    unset($form_state['values']['title']);  }  aggregator_save_feed($form_state['values']);  if (isset($form_state['values']['fid'])) {    if (isset($form_state['values']['title'])) {      drupal_set_message(t('The feed %feed has been updated.', array('%feed' => $form_state['values']['title'])));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/sources/'. $form_state['values']['fid'];        return;      }    }    else {      watchdog('aggregator', 'Feed %feed deleted.', array('%feed' => $title));      drupal_set_message(t('The feed %feed has been deleted.', array('%feed' => $title)));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/sources/';        return;      }    }  }  else {    watchdog('aggregator', 'Feed %feed added.', array('%feed' => $form_state['values']['title']), WATCHDOG_NOTICE, l(t('view'), 'admin/content/aggregator'));    drupal_set_message(t('The feed %feed has been added.', array('%feed' => $form_state['values']['title'])));  }}function aggregator_admin_remove_feed($form_state, $feed) {  return confirm_form(    array(      'feed' => array(        '#type' => 'value',        '#value' => $feed,      ),    ),    t('Are you sure you want to remove all items from the feed %feed?', array('%feed' => $feed['title'])),    'admin/content/aggregator',    t('This action cannot be undone.'),    t('Remove items'),    t('Cancel')  );}/** * Remove all items from a feed and redirect to the overview page. * * @param $feed *   An associative array describing the feed to be cleared. */function aggregator_admin_remove_feed_submit($form, &$form_state) {  aggregator_remove($form_state['values']['feed']);  $form_state['redirect'] = 'admin/content/aggregator';}/** * Menu callback; refreshes a feed, then redirects to the overview page. * * @param $feed *   An associative array describing the feed to be refreshed. */function aggregator_admin_refresh_feed($feed) {  aggregator_refresh($feed);  drupal_goto('admin/content/aggregator');}/** * Form builder; Configure the aggregator system. * * @ingroup forms * @see system_settings_form() */function aggregator_admin_settings() {  $items = array(0 => t('none')) + drupal_map_assoc(array(3, 5, 10, 15, 20, 25), '_aggregator_items');  $period = drupal_map_assoc(array(3600, 10800, 21600, 32400, 43200, 86400, 172800, 259200, 604800, 1209600, 2419200, 4838400, 9676800), 'format_interval');  $form['aggregator_allowed_html_tags'] = array(    '#type' => 'textfield', '#title' => t('Allowed HTML tags'), '#size' => 80, '#maxlength' => 255,    '#default_value' => variable_get('aggregator_allowed_html_tags', '<a> <b> <br> <dd> <dl> <dt> <em> <i> <li> <ol> <p> <strong> <u> <ul>'),    '#description' => t('A space-separated list of HTML tags allowed in the content of feed items. (Tags in this list are not removed by Drupal.)')  );  $form['aggregator_summary_items'] = array(    '#type' => 'select', '#title' => t('Items shown in sources and categories pages') ,    '#default_value' => variable_get('aggregator_summary_items', 3), '#options' => $items,    '#description' => t('Number of feed items displayed in feed and category summary pages.')  );  $form['aggregator_clear'] = array(    '#type' => 'select', '#title' => t('Discard items older than'),    '#default_value' => variable_get('aggregator_clear', 9676800), '#options' => $period,    '#description' => t('The length of time to retain feed items before discarding. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status')))  );  $form['aggregator_category_selector'] = array(    '#type' => 'radios', '#title' => t('Category selection type'), '#default_value' => variable_get('aggregator_category_selector', 'checkboxes'),    '#options' => array('checkboxes' => t('checkboxes'), 'select' => t('multiple selector')),    '#description' => t('The type of category selection widget displayed on categorization pages. (For a small number of categories, checkboxes are easier to use, while a multiple selector work well with large numbers of categories.)')  );  return system_settings_form($form);}/** * Form builder; Generate a form to add/edit/delete aggregator categories. * * @ingroup forms * @see aggregator_form_category_validate() * @see aggregator_form_category_submit() */function aggregator_form_category(&$form_state, $edit = array('title' => '', 'description' => '', 'cid' => NULL)) {  $form['title'] = array('#type' => 'textfield',    '#title' => t('Title'),    '#default_value' => $edit['title'],    '#maxlength' => 64,    '#required' => TRUE,  );  $form['description'] = array('#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));  if ($edit['cid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['cid'] = array('#type' => 'hidden', '#value' => $edit['cid']);  }  return $form;}/** * Validate aggregator_form_feed form submissions. */function aggregator_form_category_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Save')) {    // Check for duplicate titles    if (isset($form_state['values']['cid'])) {      $category = db_fetch_object(db_query("SELECT cid FROM {aggregator_category} WHERE title = '%s' AND cid <> %d", $form_state['values']['title'], $form_state['values']['cid']));    }    else {      $category = db_fetch_object(db_query("SELECT cid FROM {aggregator_category} WHERE title = '%s'", $form_state['values']['title']));    }    if ($category) {      form_set_error('title', t('A category named %category already exists. Please enter a unique title.', array('%category' => $form_state['values']['title'])));    }  }}/** * Process aggregator_form_category form submissions. * * @todo Add delete confirmation dialog. */function aggregator_form_category_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Delete')) {    $title = $form_state['values']['title'];    // Unset the title:    unset($form_state['values']['title']);  }  aggregator_save_category($form_state['values']);  if (isset($form_state['values']['cid'])) {    if (isset($form_state['values']['title'])) {      drupal_set_message(t('The category %category has been updated.', array('%category' => $form_state['values']['title'])));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/categories/'. $form_state['values']['cid'];        return;      }    }    else {      watchdog('aggregator', 'Category %category deleted.', array('%category' => $title));      drupal_set_message(t('The category %category has been deleted.', array('%category' => $title)));      if (arg(0) == 'admin') {        $form_state['redirect'] = 'admin/content/aggregator/';        return;      }      else {        $form_state['redirect'] = 'aggregator/categories/';        return;      }    }  }  else {    watchdog('aggregator', 'Category %category added.', array('%category' => $form_state['values']['title']), WATCHDOG_NOTICE, l(t('view'), 'admin/content/aggregator'));    drupal_set_message(t('The category %category has been added.', array('%category' => $form_state['values']['title'])));  }}
<?php// $Id$/** * Implementation of hook_install(). */function dblog_install() {  // Create tables.  drupal_install_schema('dblog');}/** * Implementation of hook_uninstall(). */function dblog_uninstall() {  // Remove tables.  drupal_uninstall_schema('dblog');}/** * Implementation of hook_schema(). */function dblog_schema() {  $schema['watchdog'] = array(    'description' => 'Table that contains logs of all system events.',    'fields' => array(      'wid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique watchdog event ID.',      ),      'uid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {users}.uid of the user who triggered the event.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => TRUE,        'default' => '',        'description' => 'Type of log message, for example "user" or "page not found."',      ),      'message' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Text of log message to be passed into the t() function.',      ),      'variables' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Serialized array of variables that match the message string and that is passed into the t() function.',      ),      'severity' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The severity level of the event; ranges from 0 (Emergency) to 7 (Debug)',      ),      'link' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Link to view the result of the event.',      ),      'location'  => array(        'type' => 'text',        'not null' => TRUE,        'description' => 'URL of the origin of the event.',      ),      'referer' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'URL of referring page.',      ),      'hostname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Hostname of the user who triggered the event.',      ),      'timestamp' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Unix timestamp of when event occurred.',      ),    ),    'primary key' => array('wid'),    'indexes' => array('type' => array('type')),  );  return $schema;}/** * @defgroup updates-6.x-extra Extra database logging updates for 6.x * @{ *//** * Allow longer referrers. */function dblog_update_6000() {  $ret = array();  db_change_field($ret, 'watchdog', 'referer', 'referer', array('type' => 'text', 'not null' => FALSE));  return $ret;}/** * @} End of "defgroup updates-6.x-extra" * The next series of updates should start at 7000. */
<?php// $Id$/** * @file * Allows users to structure the pages of a site in a hierarchy or outline. *//** * Implementation of hook_theme() */function book_theme() {  return array(    'book_navigation' => array(      'arguments' => array('book_link' => NULL),      'template' => 'book-navigation',    ),    'book_export_html' => array(      'arguments' => array('title' => NULL, 'contents' => NULL, 'depth' => NULL),      'template' => 'book-export-html',    ),    'book_admin_table' => array(      'arguments' => array('form' => NULL),    ),    'book_title_link' => array(      'arguments' => array('link' => NULL),    ),    'book_all_books_block' => array(      'arguments' => array('book_menus' => array()),      'template' => 'book-all-books-block',    ),    'book_node_export_html' => array(      'arguments' => array('node' => NULL, 'children' => NULL),      'template' => 'book-node-export-html',    ),  );}/** * Implementation of hook_perm(). */function book_perm() {  return array('add content to books', 'administer book outlines', 'create new books', 'access printer-friendly version');}/** * Implementation of hook_link(). */function book_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && isset($node->book)) {    if (!$teaser) {      $child_type = variable_get('book_child_type', 'book');      if ((user_access('add content to books') || user_access('administer book outlines')) && node_access('create', $child_type) && $node->status == 1 && $node->book['depth'] < MENU_MAX_DEPTH) {        $links['book_add_child'] = array(          'title' => t('Add child page'),          'href' => "node/add/". str_replace('_', '-', $child_type),          'query' => "parent=". $node->book['mlid'],        );      }      if (user_access('access printer-friendly version')) {        $links['book_printer'] = array(          'title' => t('Printer-friendly version'),          'href' => 'book/export/html/'. $node->nid,          'attributes' => array('title' => t('Show a printer-friendly version of this book page and its sub-pages.'))        );      }    }  }  return $links;}/** * Implementation of hook_menu(). */function book_menu() {  $items['admin/content/book'] = array(    'title' => 'Books',    'description' => "Manage your site's book outlines.",    'page callback' => 'book_admin_overview',    'access arguments' => array('administer book outlines'),    'file' => 'book.admin.inc',  );  $items['admin/content/book/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/content/book/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_admin_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_LOCAL_TASK,    'weight' => 8,    'file' => 'book.admin.inc',  );  $items['admin/content/book/%node'] = array(    'title' => 'Re-order book pages and change titles',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_admin_edit', 3),    'access callback' => '_book_outline_access',    'access arguments' => array(3),    'type' => MENU_CALLBACK,    'file' => 'book.admin.inc',  );  $items['book'] = array(    'title' => 'Books',    'page callback' => 'book_render',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'book.pages.inc',  );  $items['book/export/%/%'] = array(    'page callback' => 'book_export',    'page arguments' => array(2, 3),    'access arguments' => array('access printer-friendly version'),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  $items['node/%node/outline'] = array(    'title' => 'Outline',    'page callback' => 'book_outline',    'page arguments' => array(1),    'access callback' => '_book_outline_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'book.pages.inc',  );  $items['node/%node/outline/remove'] = array(    'title' => 'Remove from outline',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_remove_form', 1),    'access callback' => '_book_outline_remove_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  $items['book/js/form'] = array(    'page callback' => 'book_form_update',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  return $items;}/** * Menu item access callback - determine if the outline tab is accessible. */function _book_outline_access($node) {  return user_access('administer book outlines') && node_access('view', $node);}/** * Menu item access callback - determine if the user can remove nodes from the outline. */function _book_outline_remove_access($node) {  return isset($node->book) && ($node->book['bid'] != $node->nid) && _book_outline_access($node);}/** * Implementation of hook_init(). Add's the book module's CSS. */function book_init() {  drupal_add_css(drupal_get_path('module', 'book') .'/book.css');}/** * Implementation of hook_block(). * * Displays the book table of contents in a block when the current page is a * single-node view of a book node. */function book_block($op = 'list', $delta = 0, $edit = array()) {  $block = array();  switch ($op) {    case 'list':      $block[0]['info'] = t('Book navigation');      $block[0]['cache'] = BLOCK_CACHE_PER_PAGE | BLOCK_CACHE_PER_ROLE;      return $block;    case 'view':      $current_bid = 0;      if ($node = menu_get_object()) {        $current_bid = empty($node->book['bid']) ? 0 : $node->book['bid'];      }      if (variable_get('book_block_mode', 'all pages') == 'all pages') {        $block['subject'] = t('Book navigation');        $book_menus = array();        $pseudo_tree = array(0 => array('below' => FALSE));        foreach (book_get_books() as $book_id => $book) {          if ($book['bid'] == $current_bid) {            // If the current page is a node associated with a book, the menu            // needs to be retrieved.            $book_menus[$book_id] = menu_tree_output(menu_tree_all_data($node->book['menu_name'], $node->book));          }          else {            // Since we know we will only display a link to the top node, there            // is no reason to run an additional menu tree query for each book.            $book['in_active_trail'] = FALSE;            $pseudo_tree[0]['link'] = $book;            $book_menus[$book_id] = menu_tree_output($pseudo_tree);          }        }        $block['content'] = theme('book_all_books_block', $book_menus);      }      elseif ($current_bid) {        // Only display this block when the user is browsing a book.        $title = db_result(db_query(db_rewrite_sql('SELECT n.title FROM {node} n WHERE n.nid = %d'), $node->book['bid']));        // Only show the block if the user has view access for the top-level node.        if ($title) {          $tree = menu_tree_all_data($node->book['menu_name'], $node->book);          // There should only be one element at the top level.          $data = array_shift($tree);          $block['subject'] = theme('book_title_link', $data['link']);          $block['content'] = ($data['below']) ? menu_tree_output($data['below']) : '';        }      }      return $block;    case 'configure':      $options = array(        'all pages' => t('Show block on all pages'),        'book pages' => t('Show block only on book pages'),      );      $form['book_block_mode'] = array(        '#type' => 'radios',        '#title' => t('Book navigation block display'),        '#options' => $options,        '#default_value' => variable_get('book_block_mode', 'all pages'),        '#description' => t("If <em>Show block on all pages</em> is selected, the block will contain the automatically generated menus for all of the site's books. If <em>Show block only on book pages</em> is selected, the block will contain only the one menu corresponding to the current page's book. In this case, if the current page is not in a book, no block will be displayed. The <em>Page specific visibility settings</em> or other visibility settings can be used in addition to selectively display this block."),        );      return $form;    case 'save':      variable_set('book_block_mode', $edit['book_block_mode']);      break;  }}/** * Generate the HTML output for a link to a book title when used as a block title. * * @ingroup themeable */function theme_book_title_link($link) {  $link['options']['attributes']['class'] =  'book-title';  return l($link['title'], $link['href'], $link['options']);}/** * Returns an array of all books. * * This list may be used for generating a list of all the books, or for building * the options for a form select. */function book_get_books() {  static $all_books;  if (!isset($all_books)) {    $all_books = array();    $result = db_query("SELECT DISTINCT(bid) FROM {book}");    $nids = array();    while ($book = db_fetch_array($result)) {      $nids[] = $book['bid'];    }    if ($nids) {      $result2 = db_query(db_rewrite_sql("SELECT n.type, n.title, b.*, ml.* FROM {book} b INNER JOIN {node} n on b.nid = n.nid INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE n.nid IN (". implode(',', $nids) .") AND n.status = 1 ORDER BY ml.weight, ml.link_title"));      while ($link = db_fetch_array($result2)) {        $link['href'] = $link['link_path'];        $link['options'] = unserialize($link['options']);        $all_books[$link['bid']] = $link;      }    }  }  return $all_books;}/** * Implementation of hook_form_alter(). Adds the book fieldset to the node form. * * @see book_pick_book_submit() * @see book_submit() */function book_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {    // Add elements to the node form    $node = $form['#node'];    $access = user_access('administer book outlines');    if (!$access) {      if (user_access('add content to books') && ((!empty($node->book['mlid']) && !empty($node->nid)) || book_type_is_allowed($node->type))) {        // Already in the book hierarchy or this node type is allowed        $access = TRUE;      }    }    if ($access) {      _book_add_form_elements($form, $node);      $form['book']['pick-book'] = array(        '#type' => 'submit',        '#value' => t('Change book (update list of parents)'),         // Submit the node form so the parent select options get updated.         // This is typically only used when JS is disabled.  Since the parent options         // won't be changed via AJAX, a button is provided in the node form to submit         // the form and generate options in the parent select corresponding to the         // selected book.  This is similar to what happens during a node preview.        '#submit' => array('node_form_submit_build_node'),        '#weight' => 20,      );    }  }}/** * Build the parent selection form element for the node form or outline tab * * This function is also called when generating a new set of options during the * AJAX callback, so an array is returned that can be used to replace an existing * form element. */function _book_parent_select($book_link) {  if (variable_get('menu_override_parent_selector', FALSE)) {    return array();  }  // Offer a message or a drop-down to choose a different parent page.  $form = array(    '#type' => 'hidden',    '#value' => -1,    '#prefix' => '<div id="edit-book-plid-wrapper">',    '#suffix' => '</div>',  );  if ($book_link['nid'] === $book_link['bid']) {    // This is a book - at the top level.    if ($book_link['original_bid'] === $book_link['bid']) {      $form['#prefix'] .= '<em>'. t('This is the top-level page in this book.') .'</em>';    }    else {      $form['#prefix'] .= '<em>'. t('This will be the top-level page in this book.') .'</em>';    }  }  elseif (!$book_link['bid']) {    $form['#prefix'] .= '<em>'. t('No book selected.') .'</em>';  }  else {    $form = array(      '#type' => 'select',      '#title' => t('Parent item'),      '#default_value' => $book_link['plid'],      '#description' => t('The parent page in the book. The maximum depth for a book and all child pages is !maxdepth. Some pages in the selected book may not be available as parents if selecting them would exceed this limit.', array('!maxdepth' => MENU_MAX_DEPTH)),      '#options' => book_toc($book_link['bid'], array($book_link['mlid']), $book_link['parent_depth_limit']),      '#attributes' => array('class' => 'book-title-select'),    );  }  return $form;}/** * Build the common elements of the book form for the node and outline forms. */function _book_add_form_elements(&$form, $node) {  // Need this for AJAX.  $form['#cache'] = TRUE;  drupal_add_js("if (Drupal.jsEnabled) { $(document).ready(function() { $('#edit-book-pick-book').css('display', 'none'); }); }", 'inline');  $form['book'] = array(    '#type' => 'fieldset',    '#title' => t('Book outline'),    '#weight' => 10,    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#tree' => TRUE,    '#attributes' => array('class' => 'book-outline-form'),  );  foreach (array('menu_name', 'mlid', 'nid', 'router_path', 'has_children', 'options', 'module', 'original_bid', 'parent_depth_limit') as $key) {    $form['book'][$key] = array(      '#type' => 'value',      '#value' => $node->book[$key],    );  }  $form['book']['plid'] = _book_parent_select($node->book);  $form['book']['weight'] = array(    '#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $node->book['weight'],    '#delta' => 15,    '#weight' => 5,    '#description' => t('Pages at a given level are ordered first by weight and then by title.'),  );  $options = array();  $nid = isset($node->nid) ? $node->nid : 'new';  if (isset($node->nid) && ($nid == $node->book['original_bid']) && ($node->book['parent_depth_limit'] == 0)) {    // This is the top level node in a maximum depth book and thus cannot be moved.    $options[$node->nid] = $node->title;  }  else {    foreach (book_get_books() as $book) {      $options[$book['nid']] = $book['title'];    }  }  if (user_access('create new books') && ($nid == 'new' || ($nid != $node->book['original_bid']))) {    // The node can become a new book, if it is not one already.    $options = array($nid => '<'. t('create a new book') .'>') + $options;  }  if (!$node->book['mlid']) {    // The node is not currently in a the hierarchy.    $options = array(0 => '<'. t('none') .'>') + $options;  }  // Add a drop-down to select the destination book.  $form['book']['bid'] = array(    '#type' => 'select',    '#title' => t('Book'),    '#default_value' => $node->book['bid'],    '#options' => $options,    '#access' => (bool)$options,    '#description' => t('Your page will be a part of the selected book.'),    '#weight' => -5,    '#attributes' => array('class' => 'book-title-select'),    '#ahah' => array(      'path' => 'book/js/form',      'wrapper' => 'edit-book-plid-wrapper',      'effect' => 'slide',    ),  );}/** * Common helper function to handles additions and updates to the book outline. * * Performs all additions and updates to the book outline through node addition, * node editing, node deletion, or the outline tab. */function _book_update_outline(&$node) {  if (empty($node->book['bid'])) {    return FALSE;  }  $new = empty($node->book['mlid']);  $node->book['link_path'] = 'node/'. $node->nid;  $node->book['link_title'] = $node->title;  $node->book['parent_mismatch'] = FALSE; // The normal case.  if ($node->book['bid'] == $node->nid) {    $node->book['plid'] = 0;    $node->book['menu_name'] = book_menu_name($node->nid);  }  else {    // Check in case the parent is not is this book; the book takes precedence.    if (!empty($node->book['plid'])) {      $parent = db_fetch_array(db_query("SELECT * FROM {book} WHERE mlid = %d", $node->book['plid']));    }    if (empty($node->book['plid']) || !$parent || $parent['bid'] != $node->book['bid']) {      $node->book['plid'] = db_result(db_query("SELECT mlid FROM {book} WHERE nid = %d", $node->book['bid']));      $node->book['parent_mismatch'] = TRUE; // Likely when JS is disabled.    }  }  if (menu_link_save($node->book)) {    if ($new) {      // Insert new.      db_query("INSERT INTO {book} (nid, mlid, bid) VALUES (%d, %d, %d)", $node->nid, $node->book['mlid'], $node->book['bid']);    }    else {      if ($node->book['bid'] != db_result(db_query("SELECT bid FROM {book} WHERE nid = %d", $node->nid))) {        // Update the bid for this page and all children.        book_update_bid($node->book);      }    }    return TRUE;  }  // Failed to save the menu link  return FALSE;}/** * Update the bid for a page and its children when it is moved to a new book. * * @param $book_link *   A fully loaded menu link that is part of the book hierarchy. */function book_update_bid($book_link) {  for ($i = 1; $i <= MENU_MAX_DEPTH && $book_link["p$i"]; $i++) {    $match[] = "p$i = %d";    $args[] = $book_link["p$i"];  }  $result = db_query("SELECT mlid FROM {menu_links} WHERE ". implode(' AND ', $match), $args);  $mlids = array();  while ($a = db_fetch_array($result)) {    $mlids[] = $a['mlid'];  }  if ($mlids) {    db_query("UPDATE {book} SET bid = %d WHERE mlid IN (". implode(',', $mlids) .")", $book_link['bid']);  }}/** * Get the book menu tree for a page, and return it as a linear array. * * @param $book_link *   A fully loaded menu link that is part of the book hierarchy. * @return *   A linear array of menu links in the order that the links are shown in the *   menu, so the previous and next pages are the elements before and after the *   element corresponding to $node.  The children of $node (if any) will come *   immediately after it in the array. */function book_get_flat_menu($book_link) {  static $flat = array();  if (!isset($flat[$book_link['mlid']])) {    // Call menu_tree_all_data() to take advantage of the menu system's caching.    $tree = menu_tree_all_data($book_link['menu_name'], $book_link);    $flat[$book_link['mlid']] = array();    _book_flatten_menu($tree, $flat[$book_link['mlid']]);  }  return $flat[$book_link['mlid']];}/** * Recursive helper function for book_get_flat_menu(). */function _book_flatten_menu($tree, &$flat) {  foreach ($tree as $data) {    if (!$data['link']['hidden']) {      $flat[$data['link']['mlid']] = $data['link'];      if ($data['below']) {        _book_flatten_menu($data['below'], $flat);      }    }  }}/** * Fetches the menu link for the previous page of the book. */function book_prev($book_link) {  // If the parent is zero, we are at the start of a book.  if ($book_link['plid'] == 0) {    return NULL;  }  $flat = book_get_flat_menu($book_link);  // Assigning the array to $flat resets the array pointer for use with each().  $curr = NULL;  do {    $prev = $curr;    list($key, $curr) = each($flat);  } while ($key && $key != $book_link['mlid']);  if ($key == $book_link['mlid']) {    // The previous page in the book may be a child of the previous visible link.    if ($prev['depth'] == $book_link['depth'] && $prev['has_children']) {      // The subtree will have only one link at the top level - get its data.      $data = array_shift(book_menu_subtree_data($prev));      // The link of interest is the last child - iterate to find the deepest one.      while ($data['below']) {        $data = end($data['below']);      }      return $data['link'];    }    else {      return $prev;    }  }}/** * Fetches the menu link for the next page of the book. */function book_next($book_link) {  $flat = book_get_flat_menu($book_link);  // Assigning the array to $flat resets the array pointer for use with each().  do {    list($key, $curr) = each($flat);  } while ($key && $key != $book_link['mlid']);  if ($key == $book_link['mlid']) {    return current($flat);  }}/** * Format the menu links for the child pages of the current page. */function book_children($book_link) {  $flat = book_get_flat_menu($book_link);  $children = array();  if ($book_link['has_children']) {    // Walk through the array until we find the current page.    do {      $link = array_shift($flat);    } while ($link && ($link['mlid'] != $book_link['mlid']));    // Continue though the array and collect the links whose parent is this page.    while (($link = array_shift($flat)) && $link['plid'] == $book_link['mlid']) {      $data['link'] = $link;      $data['below'] = '';      $children[] = $data;    }  }  return $children ? menu_tree_output($children) : '';}/** * Generate the corresponding menu name from a book ID. */function book_menu_name($bid) {  return 'book-toc-'. $bid;}/** * Build an active trail to show in the breadcrumb. */function book_build_active_trail($book_link) {  static $trail;  if (!isset($trail)) {    $trail = array();    $trail[] = array('title' => t('Home'), 'href' => '<front>', 'localized_options' => array());    $tree = menu_tree_all_data($book_link['menu_name'], $book_link);    $curr = array_shift($tree);    while ($curr) {      if ($curr['link']['href'] == $book_link['href']) {        $trail[] = $curr['link'];        $curr = FALSE;      }      else {        if ($curr['below'] && $curr['link']['in_active_trail']) {          $trail[] = $curr['link'];          $tree = $curr['below'];        }        $curr = array_shift($tree);      }    }  }  return $trail;}/** * Implementation of hook_nodeapi(). * * Appends book navigation to all nodes in the book, and handles book outline * insertions and updates via the node form. */function book_nodeapi(&$node, $op, $teaser, $page) {  switch ($op) {    case 'load':      // Note - we cannot use book_link_load() because it will call node_load()      $info['book'] = db_fetch_array(db_query('SELECT * FROM {book} b INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE b.nid = %d', $node->nid));      if ($info['book']) {        $info['book']['href'] = $info['book']['link_path'];        $info['book']['title'] = $info['book']['link_title'];        $info['book']['options'] = unserialize($info['book']['options']);        return $info;      }      break;    case 'view':    if (!$teaser) {        if (!empty($node->book['bid']) && $node->build_mode == NODE_BUILD_NORMAL) {          $node->content['book_navigation'] = array(            '#value' => theme('book_navigation', $node->book),            '#weight' => 100,          );          if ($page) {            menu_set_active_trail(book_build_active_trail($node->book));            menu_set_active_menu_name($node->book['menu_name']);          }        }      }      break;    case 'presave':      // Always save a revision for non-administrators.      if (!empty($node->book['bid']) && !user_access('administer nodes')) {        $node->revision = 1;      }      // Make sure a new node gets a new menu link.      if (empty($node->nid)) {        $node->book['mlid'] = NULL;      }      break;    case 'insert':    case 'update':      if (!empty($node->book['bid'])) {        if ($node->book['bid'] == 'new') {          // New nodes that are their own book.          $node->book['bid'] = $node->nid;        }        $node->book['nid'] = $node->nid;        $node->book['menu_name'] = book_menu_name($node->book['bid']);        _book_update_outline($node);      }      break;    case 'delete':      if (!empty($node->book['bid'])) {        if ($node->nid == $node->book['bid']) {          // Handle deletion of a top-level post.          $result = db_query("SELECT b.nid FROM {menu_links} ml INNER JOIN {book} b on b.mlid = ml.mlid WHERE ml.plid = %d", $node->book['mlid']);          while ($child = db_fetch_array($result)) {            $child_node = node_load($child['nid']);            $child_node->book['bid'] = $child_node->nid;            _book_update_outline($child_node);          }        }        menu_link_delete($node->book['mlid']);        db_query('DELETE FROM {book} WHERE mlid = %d', $node->book['mlid']);      }      break;    case 'prepare':      // Prepare defaults for the add/edit form.      if (empty($node->book) && (user_access('add content to books') || user_access('administer book outlines'))) {        $node->book = array();        if (empty($node->nid) && isset($_GET['parent']) && is_numeric($_GET['parent'])) {          // Handle "Add child page" links:          $parent = book_link_load($_GET['parent']);          if ($parent && $parent['access']) {            $node->book['bid'] = $parent['bid'];            $node->book['plid'] = $parent['mlid'];            $node->book['menu_name'] = $parent['menu_name'];          }        }        // Set defaults.        $node->book += _book_link_defaults(!empty($node->nid) ? $node->nid : 'new');      }      else {        if (isset($node->book['bid']) && !isset($node->book['original_bid'])) {          $node->book['original_bid'] = $node->book['bid'];        }      }      // Find the depth limit for the parent select.      if (isset($node->book['bid']) && !isset($node->book['parent_depth_limit'])) {        $node->book['parent_depth_limit'] = _book_parent_depth_limit($node->book);      }      break;  }}/** * Find the depth limit for items in the parent select. */function _book_parent_depth_limit($book_link) {  return MENU_MAX_DEPTH - 1 - (($book_link['mlid'] && $book_link['has_children']) ? menu_link_children_relative_depth($book_link) : 0);}/** * Form altering function for the confirm form for a single node deletion. */function book_form_node_delete_confirm_alter(&$form, $form_state) {  $node = node_load($form['nid']['#value']);  if (isset($node->book) && $node->book['has_children']) {    $form['book_warning'] = array(      '#value' => '<p>'. t('%title is part of a book outline, and has associated child pages. If you proceed with deletion, the child pages will be relocated automatically.', array('%title' => $node->title)) .'</p>',      '#weight' => -10,    );  }}/** * Return an array with default values for a book link. */function _book_link_defaults($nid) {  return array('original_bid' => 0, 'menu_name' => '', 'nid' => $nid, 'bid' => 0, 'router_path' => 'node/%', 'plid' => 0, 'mlid' => 0, 'has_children' => 0, 'weight' => 0, 'module' => 'book', 'options' => array());}/** * Process variables for book-navigation.tpl.php. * * The $variables array contains the following arguments: * - $book_link * * @see book-navigation.tpl.php */function template_preprocess_book_navigation(&$variables) {  $book_link = $variables['book_link'];  // Provide extra variables for themers. Not needed by default.  $variables['book_id'] = $book_link['bid'];  $variables['book_title'] = check_plain($book_link['link_title']);  $variables['book_url'] = 'node/'. $book_link['bid'];  $variables['current_depth'] = $book_link['depth'];  $variables['tree'] = '';  if ($book_link['mlid']) {    $variables['tree'] = book_children($book_link);    if ($prev = book_prev($book_link)) {      $prev_href = url($prev['href']);      drupal_add_link(array('rel' => 'prev', 'href' => $prev_href));      $variables['prev_url'] = $prev_href;      $variables['prev_title'] = check_plain($prev['title']);    }    if ($book_link['plid'] && $parent = book_link_load($book_link['plid'])) {      $parent_href = url($parent['href']);      drupal_add_link(array('rel' => 'up', 'href' => $parent_href));      $variables['parent_url'] = $parent_href;      $variables['parent_title'] = check_plain($parent['title']);    }    if ($next = book_next($book_link)) {      $next_href = url($next['href']);      drupal_add_link(array('rel' => 'next', 'href' => $next_href));      $variables['next_url'] = $next_href;      $variables['next_title'] = check_plain($next['title']);    }  }  $variables['has_links'] = FALSE;  // Link variables to filter for values and set state of the flag variable.  $links = array('prev_url', 'prev_title', 'parent_url', 'parent_title', 'next_url', 'next_title');  foreach ($links as $link) {    if (isset($variables[$link])) {      // Flag when there is a value.      $variables['has_links'] = TRUE;    }    else {      // Set empty to prevent notices.      $variables[$link] = '';    }  }}/** * A recursive helper function for book_toc(). */function _book_toc_recurse($tree, $indent, &$toc, $exclude, $depth_limit) {  foreach ($tree as $data) {    if ($data['link']['depth'] > $depth_limit) {      // Don't iterate through any links on this level.      break;    }    if (!in_array($data['link']['mlid'], $exclude)) {      $toc[$data['link']['mlid']] = $indent .' '. truncate_utf8($data['link']['title'], 30, TRUE, TRUE);      if ($data['below']) {        _book_toc_recurse($data['below'], $indent .'--', $toc, $exclude, $depth_limit);      }    }  }}/** * Returns an array of book pages in table of contents order. * * @param $bid *   The ID of the book whose pages are to be listed. * @param $exclude *   Optional array of mlid values.  Any link whose mlid is in this array *   will be excluded (along with its children). * @param $depth_limit *   Any link deeper than this value will be excluded (along with its children). * @return *   An array of mlid, title pairs for use as options for selecting a book page. */function book_toc($bid, $exclude = array(), $depth_limit) {  $tree = menu_tree_all_data(book_menu_name($bid));  $toc = array();  _book_toc_recurse($tree, '', $toc, $exclude, $depth_limit);  return $toc;}/** * Process variables for book-export-html.tpl.php. * * The $variables array contains the following arguments: * - $title * - $contents * - $depth * * @see book-export-html.tpl.php */function template_preprocess_book_export_html(&$variables) {  global $base_url, $language;  $variables['title'] = check_plain($variables['title']);  $variables['base_url'] = $base_url;  $variables['language'] = $language;  $variables['language_rtl'] = ($language->direction == LANGUAGE_RTL);  $variables['head'] = drupal_get_html_head();}/** * Traverse the book tree to build printable or exportable output. * * During the traversal, the $visit_func() callback is applied to each * node, and is called recursively for each child of the node (in weight, * title order). * * @param $tree *   A subtree of the book menu hierarchy, rooted at the current page. * @param $visit_func *   A function callback to be called upon visiting a node in the tree. * @return *   The output generated in visiting each node. */function book_export_traverse($tree, $visit_func) {  $output = '';  foreach ($tree as $data) {    // Note- access checking is already performed when building the tree.    if ($node = node_load($data['link']['nid'], FALSE)) {      $children = '';      if ($data['below']) {        $children = book_export_traverse($data['below'], $visit_func);      }      if (function_exists($visit_func)) {        $output .= call_user_func($visit_func, $node, $children);      }      else {        // Use the default function.        $output .= book_node_export($node, $children);      }    }  }  return $output;}/** * Generates printer-friendly HTML for a node. * * @see book_export_traverse() * * @param $node *   The node to generate output for. * @param $children *   All the rendered child nodes within the current node. * @return *   The HTML generated for the given node. */function book_node_export($node, $children = '') {  $node->build_mode = NODE_BUILD_PRINT;  $node = node_build_content($node, FALSE, FALSE);  $node->body = drupal_render($node->content);  return theme('book_node_export_html', $node, $children);}/** * Process variables for book-node-export-html.tpl.php. * * The $variables array contains the following arguments: * - $node * - $children * * @see book-node-export-html.tpl.php */function template_preprocess_book_node_export_html(&$variables) {  $variables['depth'] = $variables['node']->book['depth'];  $variables['title'] = check_plain($variables['node']->title);  $variables['content'] = $variables['node']->body;}/** * Determine if a given node type is in the list of types allowed for books. */function book_type_is_allowed($type) {  return in_array($type, variable_get('book_allowed_types', array('book')));}/** * Implementation of hook_node_type(). * * Update book module's persistent variables if the machine-readable name of a * node type is changed. */function book_node_type($op, $type) {  switch ($op) {    case 'update':      if (!empty($type->old_type) && $type->old_type != $type->type) {        // Update the list of node types that are allowed to be added to books.        $allowed_types = variable_get('book_allowed_types', array('book'));        $key = array_search($type->old_type, $allowed_types);        if ($key !== FALSE) {          $allowed_types[$type->type] = $allowed_types[$key] ? $type->type : 0;          unset($allowed_types[$key]);          variable_set('book_allowed_types', $allowed_types);        }        // Update the setting for the "Add child page" link.        if (variable_get('book_child_type', 'book') == $type->old_type) {          variable_set('book_child_type', $type->type);        }      }      break;  }}/** * Implementation of hook_help(). */function book_help($path, $arg) {  switch ($path) {    case 'admin/help#book':      $output = '<p>'. t('The book module is suited for creating structured, multi-page hypertexts such as site resource guides, manuals, and Frequently Asked Questions (FAQs). It permits a document to have chapters, sections, subsections, etc. Authors with suitable permissions can add pages to a collaborative book, placing them into the existing document by adding them to a table of contents menu.') .'</p>';      $output .= '<p>'. t('Pages in the book hierarchy have navigation elements at the bottom of the page for moving through the text. These links lead to the previous and next pages in the book, and to the level above the current page in the book\'s structure. More comprehensive navigation may be provided by enabling the <em>book navigation block</em> on the <a href="@admin-block">blocks administration page</a>.', array('@admin-block' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('Users can select the <em>printer-friendly version</em> link visible at the bottom of a book page to generate a printer-friendly display of the page and all of its subsections. ') .'</p>';      $output .= '<p>'. t("Users with the <em>administer book outlines</em> permission can add a post of any content type to a book, by selecting the appropriate book while editing the post or by using the interface available on the post's <em>outline</em> tab.") .'</p>';      $output .= '<p>'. t('Administrators can view a list of all books on the <a href="@admin-node-book">book administration page</a>. The <em>Outline</em> page for each book allows section titles to be edited or rearranged.', array('@admin-node-book' => url('admin/content/book'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@book">Book module</a>.', array('@book' => 'http://drupal.org/handbook/modules/book/')) .'</p>';      return $output;    case 'admin/content/book':      return '<p>'. t('The book module offers a means to organize a collection of related posts, collectively known as a book. When viewed, these posts automatically display links to adjacent book pages, providing a simple navigation system for creating and reviewing structured content.') .'</p>';    case 'node/%/outline':      return '<p>'. t('The outline feature allows you to include posts in the <a href="@book">book hierarchy</a>, as well as move them within the hierarchy or to <a href="@book-admin">reorder an entire book</a>.', array('@book' => url('book'), '@book-admin' => url('admin/content/book'))) .'</p>';  }}/** * Like menu_link_load(), but adds additional data from the {book} table. * * Do not call when loading a node, since this function may call node_load(). */function book_link_load($mlid) {  if ($item = db_fetch_array(db_query("SELECT * FROM {menu_links} ml INNER JOIN {book} b ON b.mlid = ml.mlid LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = %d", $mlid))) {    _menu_link_translate($item);    return $item;  }  return FALSE;}/** * Get the data representing a subtree of the book hierarchy. * * The root of the subtree will be the link passed as a parameter, so the * returned tree will contain this item and all its descendents in the menu tree. * * @param $item *   A fully loaded menu link. * @return *   An subtree of menu links in an array, in the order they should be rendered. */function book_menu_subtree_data($item) {  static $tree = array();  // Generate a cache ID (cid) specific for this $menu_name and $item.  $cid = 'links:'. $item['menu_name'] .':subtree-cid:'. $item['mlid'];  if (!isset($tree[$cid])) {    $cache = cache_get($cid, 'cache_menu');    if ($cache && isset($cache->data)) {      // If the cache entry exists, it will just be the cid for the actual data.      // This avoids duplication of large amounts of data.      $cache = cache_get($cache->data, 'cache_menu');      if ($cache && isset($cache->data)) {        $data = $cache->data;      }    }    // If the subtree data was not in the cache, $data will be NULL.    if (!isset($data)) {      $match = array("menu_name = '%s'");      $args = array($item['menu_name']);      $i = 1;      while ($i <= MENU_MAX_DEPTH && $item["p$i"]) {        $match[] = "p$i = %d";        $args[] = $item["p$i"];        $i++;      }      $sql = "        SELECT b.*, m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, ml.*        FROM {menu_links} ml INNER JOIN {menu_router} m ON m.path = ml.router_path        INNER JOIN {book} b ON ml.mlid = b.mlid        WHERE ". implode(' AND ', $match) ."        ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC";      $data['tree'] = menu_tree_data(db_query($sql, $args), array(), $item['depth']);      $data['node_links'] = array();      menu_tree_collect_node_links($data['tree'], $data['node_links']);      // Compute the real cid for book subtree data.      $tree_cid = 'links:'. $item['menu_name'] .':subtree-data:'. md5(serialize($data));      // Cache the data, if it is not already in the cache.      if (!cache_get($tree_cid, 'cache_menu')) {        cache_set($tree_cid, $data, 'cache_menu');      }      // Cache the cid of the (shared) data using the menu and item-specific cid.      cache_set($cid, $tree_cid, 'cache_menu');    }    // Check access for the current user to each item in the tree.    menu_tree_check_access($data['tree'], $data['node_links']);    $tree[$cid] = $data['tree'];  }  return $tree[$cid];}
<?php// $Id$/** * Implementation of hook_install(). */function poll_install() {  // Create tables.  drupal_install_schema('poll');}/** * Implementation of hook_uninstall(). */function poll_uninstall() {  // Remove tables.  drupal_uninstall_schema('poll');}/** * Implementation of hook_schema(). */function poll_schema() {  $schema['poll'] = array(    'description' => 'Stores poll-specific information for poll nodes.',    'fields' => array(      'nid'     => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The poll's {node}.nid."        ),      'runtime' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The number of seconds past {node}.created during which the poll is open.'        ),      'active'  => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Boolean indicating whether or not the poll is open.',        ),      ),    'primary key' => array('nid'),    );  $schema['poll_choices'] = array(    'description' => 'Stores information about all choices for all {poll}s.',    'fields' => array(      'chid'    => array(        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'Unique identifier for a poll choice.',        ),      'nid'     => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid this choice belongs to.',        ),      'chtext'  => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'The text for this choice.',        ),      'chvotes' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The total number of votes this choice has received by all users.',        ),      'chorder' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The sort order of this choice among all choices for the same node.',        )      ),    'indexes' => array(      'nid' => array('nid')      ),    'primary key' => array('chid'),    );  $schema['poll_votes'] = array(    'description' => 'Stores per-{users} votes for each {poll}.',    'fields' => array(      'nid'      => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'The {poll} node this vote is for.',        ),      'uid'      => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {users}.uid this vote is from unless the voter was anonymous.',        ),      'chorder'  => array(        'type' => 'int',        'not null' => TRUE,        'default' => -1,        'description' => "The {users}'s vote for this poll.",        ),      'hostname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'The IP address this vote is from unless the voter was logged in.',        ),      ),    'primary key' => array('nid', 'uid', 'hostname'),    'indexes' => array(      'hostname' => array('hostname'),      'uid'      => array('uid'),      ),    );  return $schema;}
<?php// $Id$/** * @file forum-icon.tpl.php * Display an appropriate icon for a forum post. * * Available variables: * - $new_posts: Indicates whether or not the topic contains new posts. * - $icon: The icon to display. May be one of 'hot', 'hot-new', 'new', *   'default', 'closed', or 'sticky'. * * @see template_preprocess_forum_icon() * @see theme_forum_icon() */?><?php if ($new_posts): ?>  <a name="new"><?php endif; ?><?php print theme('image', "misc/forum-$icon.png") ?><?php if ($new_posts): ?>  </a><?php endif; ?>
<?php// $Id$/** * @file * User page callbacks for the tracker module. *//** * Menu callback. Prints a listing of active nodes on the site. */function tracker_page($account = NULL, $set_title = FALSE) {  // Add CSS  drupal_add_css(drupal_get_path('module', 'tracker') .'/tracker.css', 'module', 'all', FALSE);  if ($account) {    if ($set_title) {      // When viewed from user/%user/track, display the name of the user      // as page title -- the tab title remains Track so this needs to be done      // here and not in the menu definiton.      drupal_set_title(check_plain($account->name));    }  // TODO: These queries are very expensive, see http://drupal.org/node/105639    $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.changed, n.uid, u.name, GREATEST(n.changed, l.last_comment_timestamp) AS last_updated, l.comment_count FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {users} u ON n.uid = u.uid LEFT JOIN {comments} c ON n.nid = c.nid AND (c.status = %d OR c.status IS NULL) WHERE n.status = 1 AND (n.uid = %d OR c.uid = %d) ORDER BY last_updated DESC';    $sql = db_rewrite_sql($sql);    $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n LEFT JOIN {comments} c ON n.nid = c.nid AND (c.status = %d OR c.status IS NULL) WHERE n.status = 1 AND (n.uid = %d OR c.uid = %d)';    $sql_count = db_rewrite_sql($sql_count);    $result = pager_query($sql, 25, 0, $sql_count, COMMENT_PUBLISHED, $account->uid, $account->uid);  }  else {    $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.changed, n.uid, u.name, GREATEST(n.changed, l.last_comment_timestamp) AS last_updated, l.comment_count FROM {node} n INNER JOIN {users} u ON n.uid = u.uid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 ORDER BY last_updated DESC';    $sql = db_rewrite_sql($sql);    $sql_count = 'SELECT COUNT(n.nid) FROM {node} n WHERE n.status = 1';    $sql_count = db_rewrite_sql($sql_count);    $result = pager_query($sql, 25, 0, $sql_count);  }  $rows = array();  while ($node = db_fetch_object($result)) {    // Determine the number of comments:    $comments = 0;    if ($node->comment_count) {      $comments = $node->comment_count;      if ($new = comment_num_new($node->nid)) {        $comments .= '<br />';        $comments .= l(format_plural($new, '1 new', '@count new'), "node/$node->nid", array('query' => comment_new_page_count($node->comment_count, $new, $node), 'fragment' => 'new'));      }    }    $rows[] = array(      check_plain(node_get_types('name', $node->type)),      l($node->title, "node/$node->nid") .' '. theme('mark', node_mark($node->nid, $node->changed)),      theme('username', $node),      array('class' => 'replies', 'data' => $comments),      t('!time ago', array('!time' => format_interval(time() - $node->last_updated)))    );  }  if (!$rows) {    $rows[] = array(array('data' => t('No posts available.'), 'colspan' => '5'));  }  $header = array(t('Type'), t('Post'), t('Author'), t('Replies'), t('Last updated'));  $output = '<div id="tracker">';  $output .= theme('table', $header, $rows);  $output .= theme('pager', NULL, 25, 0);  $output .= '</div>';  return $output;}
<?php// $Id$/** * @file * User page callbacks for the search module. *//** * Menu callback; presents the search form and/or search results. */function search_view($type = 'node') {  // Search form submits with POST but redirects to GET. This way we can keep  // the search query URL clean as a whistle:  // search/type/keyword+keyword  if (!isset($_POST['form_id'])) {    if ($type == '') {      // Note: search/node can not be a default tab because it would take on the      // path of its parent (search). It would prevent remembering keywords when      // switching tabs. This is why we drupal_goto to it from the parent instead.      drupal_goto('search/node');    }    $keys = search_get_keys();    // Only perform search if there is non-whitespace search term:    $results = '';    if (trim($keys)) {      // Log the search keys:      watchdog('search', '%keys (@type).', array('%keys' => $keys, '@type' => module_invoke($type, 'search', 'name')), WATCHDOG_NOTICE, l(t('results'), 'search/'. $type .'/'. $keys));      // Collect the search results:      $results = search_data($keys, $type);      if ($results) {        $results = theme('box', t('Search results'), $results);      }      else {        $results = theme('box', t('Your search yielded no results'), search_help('search#noresults', drupal_help_arg()));      }    }    // Construct the search form.    $output = drupal_get_form('search_form', NULL, $keys, $type);    $output .= $results;    return $output;  }  return drupal_get_form('search_form', NULL, empty($keys) ? '' : $keys, $type);}/** * Process variables for search-results.tpl.php. * * The $variables array contains the following arguments: * - $results * - $type * * @see search-results.tpl.php */function template_preprocess_search_results(&$variables) {  $variables['search_results'] = '';  foreach ($variables['results'] as $result) {    $variables['search_results'] .= theme('search_result', $result, $variables['type']);  }  $variables['pager'] = theme('pager', NULL, 10, 0);  // Provide alternate search results template.  $variables['template_files'][] = 'search-results-'. $variables['type'];}/** * Process variables for search-result.tpl.php. * * The $variables array contains the following arguments: * - $result * - $type * * @see search-result.tpl.php */function template_preprocess_search_result(&$variables) {  $result = $variables['result'];  $variables['url'] = check_url($result['link']);  $variables['title'] = check_plain($result['title']);  $info = array();  if (!empty($result['type'])) {    $info['type'] = check_plain($result['type']);  }  if (!empty($result['user'])) {    $info['user'] = $result['user'];  }  if (!empty($result['date'])) {    $info['date'] = format_date($result['date'], 'small');  }  if (isset($result['extra']) && is_array($result['extra'])) {    $info = array_merge($info, $result['extra']);  }  // Check for existence. User search does not include snippets.  $variables['snippet'] = isset($result['snippet']) ? $result['snippet'] : '';  // Provide separated and grouped meta information..  $variables['info_split'] = $info;  $variables['info'] = implode(' - ', $info);  // Provide alternate search result template.  $variables['template_files'][] = 'search-result-'. $variables['type'];}/** * As the search form collates keys from other modules hooked in via * hook_form_alter, the validation takes place in _submit. * search_form_validate() is used solely to set the 'processed_keys' form * value for the basic search form. */function search_form_validate($form, &$form_state) {  form_set_value($form['basic']['inline']['processed_keys'], trim($form_state['values']['keys']), $form_state);}/** * Process a search form submission. */function search_form_submit($form, &$form_state) {  $keys = $form_state['values']['processed_keys'];  if ($keys == '') {    form_set_error('keys', t('Please enter some keywords.'));    // Fall through to the drupal_goto() call.  }  $type = $form_state['values']['module'] ? $form_state['values']['module'] : 'node';  $form_state['redirect'] = 'search/'. $type .'/'. $keys;  return;}
<?php// $Id$/** * @file * User page callbacks for the openid module. *//** * Menu callback; Process an OpenID authentication. */function openid_authentication_page() {  $result = openid_complete();  switch ($result['status']) {    case 'success':      return openid_authentication($result);    case 'failed':      drupal_set_message(t('OpenID login failed.'), 'error');      break;    case 'cancel':      drupal_set_message(t('OpenID login cancelled.'));      break;  }  drupal_goto();}/** * Menu callback; Manage OpenID identities for the specified user. */function openid_user_identities($account) {  drupal_set_title(check_plain($account->name));  drupal_add_css(drupal_get_path('module', 'openid') .'/openid.css', 'module');  // Check to see if we got a response  $result = openid_complete();  if ($result['status'] == 'success') {    $identity = $result['openid.claimed_id'];    db_query("INSERT INTO {authmap} (uid, authname, module) VALUES (%d, '%s','openid')", $account->uid, $identity);    drupal_set_message(t('Successfully added %identity', array('%identity' => $identity)));  }  $header = array(t('OpenID'), t('Operations'));  $rows = array();  $result = db_query("SELECT * FROM {authmap} WHERE module='openid' AND uid=%d", $account->uid);  while ($identity = db_fetch_object($result)) {    $rows[] = array(check_plain($identity->authname), l(t('Delete'), 'user/'. $account->uid .'/openid/delete/'. $identity->aid));  }  $output = theme('table', $header, $rows);  $output .= drupal_get_form('openid_user_add');  return $output;}/** * Form builder; Add an OpenID identity. * * @ingroup forms * @see openid_user_add_validate() */function openid_user_add() {  $form['openid_identifier'] = array(    '#type' => 'textfield',    '#title' => t('OpenID'),  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Add an OpenID'));  return $form;}function openid_user_add_validate($form, &$form_state) {  // Check for existing entries.  $claimed_id = _openid_normalize($form_state['values']['openid_identifier']);  if (db_result(db_query("SELECT authname FROM {authmap} WHERE authname='%s'", $claimed_id))) {    form_set_error('openid_identifier', t('That OpenID is already in use on this site.'));  }}function openid_user_add_submit($form, &$form_state) {  $return_to = url('user/'. arg(1) .'/openid', array('absolute' => TRUE));  openid_begin($form_state['values']['openid_identifier'], $return_to);}/** * Present a confirmation form to delete the specified OpenID identity from the system. * * @ingroup forms * @see openid_user_delete_form_submit() */function openid_user_delete_form($form_state, $account, $aid = 0) {  $authname = db_result(db_query('SELECT authname FROM {authmap} WHERE uid = %d AND aid = %d', $account->uid, $aid));  $form = array();  $form['uid'] = array(    '#type' => 'value',    '#value' => $account->uid,  );  $form['aid'] = array(    '#type' => 'value',    '#value' => $aid,  );  return confirm_form($form, t('Are you sure you want to delete the OpenID %authname for %user?', array('%authname' => $authname, '%user' => $account->name)), 'user/'. $account->uid .'/openid');}function openid_user_delete_form_submit($form, &$form_state) {  db_query("DELETE FROM {authmap} WHERE uid = %d AND aid = %d AND module = 'openid'", $form_state['values']['uid'], $form_state['values']['aid']);  if (db_affected_rows()) {    drupal_set_message(t('OpenID deleted.'));  }  $form_state['redirect'] = 'user/'. $form_state['values']['uid'] .'/openid';}
<?php// $Id$?><div class="comment<?php print ($comment->new) ? ' comment-new' : ''; print ' '. $status; print ' '. $zebra; ?>">  <div class="clear-block">  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted; ?></span>  <?php endif; ?>  <?php if ($comment->new) : ?>    <span class="new"><?php print drupal_ucfirst($new) ?></span>  <?php endif; ?>  <?php print $picture ?>    <h3><?php print $title ?></h3>    <div class="content">      <?php print $content ?>      <?php if ($signature): ?>      <div class="clear-block">        <div></div>        <?php print $signature ?>      </div>      <?php endif; ?>    </div>  </div>  <?php if ($links): ?>    <div class="links"><?php print $links ?></div>  <?php endif; ?></div>
<?php// $Id$/** * @file * Administrative page callbacks for the dblog module. *//** * dblog module settings form. * * @ingroup forms * @see system_settings_form() */function dblog_admin_settings() {  $form['dblog_row_limit'] = array(    '#type' => 'select',    '#title' => t('Discard log entries above the following row limit'),    '#default_value' => variable_get('dblog_row_limit', 1000),    '#options' => drupal_map_assoc(array(100, 1000, 10000, 100000, 1000000)),    '#description' => t('The maximum number of rows to keep in the database log. Older entries will be automatically discarded. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status')))  );  return system_settings_form($form);}/** * Menu callback; displays a listing of log messages. */function dblog_overview() {  $filter = dblog_build_filter_query();  $rows = array();  $icons = array(    WATCHDOG_DEBUG    => '',    WATCHDOG_INFO     => '',    WATCHDOG_NOTICE   => '',    WATCHDOG_WARNING  => theme('image', 'misc/watchdog-warning.png', t('warning'), t('warning')),    WATCHDOG_ERROR    => theme('image', 'misc/watchdog-error.png', t('error'), t('error')),    WATCHDOG_CRITICAL => theme('image', 'misc/watchdog-error.png', t('critical'), t('critical')),    WATCHDOG_ALERT    => theme('image', 'misc/watchdog-error.png', t('alert'), t('alert')),    WATCHDOG_EMERG    => theme('image', 'misc/watchdog-error.png', t('emergency'), t('emergency')),  );  $classes = array(    WATCHDOG_DEBUG    => 'dblog-debug',    WATCHDOG_INFO     => 'dblog-info',    WATCHDOG_NOTICE   => 'dblog-notice',    WATCHDOG_WARNING  => 'dblog-warning',    WATCHDOG_ERROR    => 'dblog-error',    WATCHDOG_CRITICAL => 'dblog-critical',    WATCHDOG_ALERT    => 'dblog-alert',    WATCHDOG_EMERG    => 'dblog-emerg',  );  $output = drupal_get_form('dblog_filter_form');  $header = array(    ' ',    array('data' => t('Type'), 'field' => 'w.type'),    array('data' => t('Date'), 'field' => 'w.wid', 'sort' => 'desc'),    t('Message'),    array('data' => t('User'), 'field' => 'u.name'),    array('data' => t('Operations')),  );  $sql = "SELECT w.wid, w.uid, w.severity, w.type, w.timestamp, w.message, w.variables, w.link, u.name FROM {watchdog} w INNER JOIN {users} u ON w.uid = u.uid";  $tablesort = tablesort_sql($header);  if (!empty($filter['where'])) {    $result = pager_query($sql ." WHERE ". $filter['where'] . $tablesort, 50, 0, NULL, $filter['args']);  }  else {    $result = pager_query($sql . $tablesort, 50);  }  while ($dblog = db_fetch_object($result)) {    $rows[] = array('data' =>      array(        // Cells        $icons[$dblog->severity],        t($dblog->type),        format_date($dblog->timestamp, 'small'),        l(truncate_utf8(_dblog_format_message($dblog), 56, TRUE, TRUE), 'admin/reports/event/'. $dblog->wid, array('html' => TRUE)),        theme('username', $dblog),        $dblog->link,      ),      // Attributes for tr      'class' => "dblog-". preg_replace('/[^a-z]/i', '-', $dblog->type) .' '. $classes[$dblog->severity]    );  }  if (!$rows) {    $rows[] = array(array('data' => t('No log messages available.'), 'colspan' => 6));  }  $output .= theme('table', $header, $rows, array('id' => 'admin-dblog'));  $output .= theme('pager', NULL, 50, 0);  return $output;}/** * Menu callback; generic function to display a page of the most frequent * dblog events of a specified type. */function dblog_top($type) {  $header = array(    array('data' => t('Count'), 'field' => 'count', 'sort' => 'desc'),    array('data' => t('Message'), 'field' => 'message')  );  $result = pager_query("SELECT COUNT(wid) AS count, message, variables FROM {watchdog} WHERE type = '%s' GROUP BY message, variables ". tablesort_sql($header), 30, 0, "SELECT COUNT(DISTINCT(message)) FROM {watchdog} WHERE type = '%s'", $type);  $rows = array();  while ($dblog = db_fetch_object($result)) {    $rows[] = array($dblog->count, truncate_utf8(_dblog_format_message($dblog), 56, TRUE, TRUE));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No log messages available.'), 'colspan' => 2));  }  $output  = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; displays details about a log message. */function dblog_event($id) {  $severity = watchdog_severity_levels();  $output = '';  $result = db_query('SELECT w.*, u.name, u.uid FROM {watchdog} w INNER JOIN {users} u ON w.uid = u.uid WHERE w.wid = %d', $id);  if ($dblog = db_fetch_object($result)) {    $rows = array(      array(        array('data' => t('Type'), 'header' => TRUE),        t($dblog->type),      ),      array(        array('data' => t('Date'), 'header' => TRUE),        format_date($dblog->timestamp, 'large'),      ),      array(        array('data' => t('User'), 'header' => TRUE),        theme('username', $dblog),      ),      array(        array('data' => t('Location'), 'header' => TRUE),        l($dblog->location, $dblog->location),      ),      array(        array('data' => t('Referrer'), 'header' => TRUE),        l($dblog->referer, $dblog->referer),      ),      array(        array('data' => t('Message'), 'header' => TRUE),        _dblog_format_message($dblog),      ),      array(        array('data' => t('Severity'), 'header' => TRUE),        $severity[$dblog->severity],      ),      array(        array('data' => t('Hostname'), 'header' => TRUE),        check_plain($dblog->hostname),      ),      array(        array('data' => t('Operations'), 'header' => TRUE),        $dblog->link,      ),    );    $attributes = array('class' => 'dblog-event');    $output = theme('table', array(), $rows, $attributes);  }  return $output;}/** * Build query for dblog administration filters based on session. */function dblog_build_filter_query() {  if (empty($_SESSION['dblog_overview_filter'])) {    return;  }  $filters = dblog_filters();  // Build query  $where = $args = array();  foreach ($_SESSION['dblog_overview_filter'] as $key => $filter) {    $filter_where = array();    foreach ($filter as $value) {      $filter_where[] = $filters[$key]['where'];      $args[] = $value;    }    if (!empty($filter_where)) {      $where[] = '('. implode(' OR ', $filter_where) .')';    }  }  $where = !empty($where) ? implode(' AND ', $where) : '';  return array(    'where' => $where,    'args' => $args,  );}/** * List dblog administration filters that can be applied. */function dblog_filters() {  $filters = array();  foreach (_dblog_get_message_types() as $type) {    $types[$type] = $type;  }  if (!empty($types)) {    $filters['type'] = array(      'title' => t('Type'),      'where' => "w.type = '%s'",      'options' => $types,    );  }  $filters['severity'] = array(    'title' => t('Severity'),    'where' => 'w.severity = %d',    'options' => watchdog_severity_levels(),  );  return $filters;}/** * Formats a log message for display. * * @param $dblog *   An object with at least the message and variables properties */function _dblog_format_message($dblog) {  // Legacy messages and user specified text  if ($dblog->variables === 'N;') {    return $dblog->message;  }  // Message to translate with injected variables  else {    return t($dblog->message, unserialize($dblog->variables));  }}/** * Return form for dblog administration filters. * * @ingroup forms * @see dblog_filter_form_submit() * @see dblog_filter_form_validate() */function dblog_filter_form() {  $session = &$_SESSION['dblog_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = dblog_filters();  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Filter log messages'),    '#theme' => 'dblog_filters',    '#collapsible' => TRUE,    '#collapsed' => empty($session),  );  foreach ($filters as $key => $filter) {    $form['filters']['status'][$key] = array(      '#title' => $filter['title'],      '#type' => 'select',      '#multiple' => TRUE,      '#size' => 8,      '#options' => $filter['options'],    );    if (!empty($session[$key])) {      $form['filters']['status'][$key]['#default_value'] = $session[$key];    }  }  $form['filters']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Filter'),  );  if (!empty($session)) {    $form['filters']['buttons']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset')    );  }  return $form;}/** * Validate result from dblog administration filter form. */function dblog_filter_form_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Filter') && empty($form_state['values']['type']) && empty($form_state['values']['severity'])) {    form_set_error('type', t('You must select something to filter by.'));  }}/** * Process result from dblog administration filter form. */function dblog_filter_form_submit($form, &$form_state) {  $op = $form_state['values']['op'];  $filters = dblog_filters();  switch ($op) {    case t('Filter'):      foreach ($filters as $name => $filter) {        if (isset($form_state['values'][$name])) {          $_SESSION['dblog_overview_filter'][$name] = $form_state['values'][$name];        }      }      break;    case t('Reset'):      $_SESSION['dblog_overview_filter'] = array();      break;  }  return 'admin/reports/dblog';}
<?php// $Id$/** * @file profile-listing.tpl.php * Default theme implementation for displaying a user and their profile data * for member listing pages. * * @see profile-wrapper.tpl.php *      where all the data is collected and printed out. * * Available variables: * - $picture: Image configured for the account linking to the users page. * - $name: User's account name linking to the users page. * - $profile: Keyed array of all profile fields that are set as visible *   in member list pages (configured by site administrators). It also needs *   to have a value in order to be present. * * Each $field in $profile contains: * - $field->title: Title of the profile field. * - $field->value: Value of the profile field. * - $field->type: Type of the profile field, i.e., checkbox, textfield, *   textarea, selection, list, url or date. * * Since $profile is keyed, a direct print of the field is possible. Not * all accounts may have a value for a profile so do a check first. If a field * of "last_name" was set for the site, the following can be used. * *  <?php if (isset($profile['last_name'])): ?> *    <div class="field last-name"> *      <?php print $profile['last_name']->title; ?>:<br /> *      <?php print $profile['last_name']->value; ?> *    </div> *  <?php endif; ?> * * @see template_preprocess_profile_listing() */?><div class="profile">  <?php print $picture; ?>  <div class="name">    <?php print $name; ?>  </div>  <?php foreach ($profile as $field) : ?>    <div class="field">      <?php print $field->value; ?>    </div>  <?php endforeach; ?></div>
<?php// $Id$/** * Implementation of hook_install(). */function upload_install() {  // Create table. The upload table might have been created in the Drupal 5  // to Drupal 6 upgrade, and was migrated from the file_revisions table. So  // in this case, there is no need to create the table, it is already there.  if (!db_table_exists('upload')) {    drupal_install_schema('upload');  }}/** * Implementation of hook_uninstall(). */function upload_uninstall() {  // Remove tables.  drupal_uninstall_schema('upload');}/** * Implementation of hook_schema(). */function upload_schema() {  $schema['upload'] = array(    'description' => 'Stores uploaded file information and table associations.',    'fields' => array(      'fid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {files}.fid.',      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid associated with the uploaded file.',      ),      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {node}.vid associated with the uploaded file.',      ),      'description' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Description of the uploaded file.',      ),      'list' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether the file should be visibly listed on the node: yes(1) or no(0).',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Weight of this upload in relation to other uploads in this node.',      ),    ),    'primary key' => array('vid', 'fid'),    'indexes' => array(      'fid' => array('fid'),      'nid' => array('nid'),    ),  );  return $schema;}
<?php// $Id$/** * @file * Code required only when rendering the available updates report. *//** * Menu callback. Generate a page about the update status of projects. */function update_status() {  if ($available = update_get_available(TRUE)) {    module_load_include('inc', 'update', 'update.compare');    $data = update_calculate_project_data($available);    return theme('update_report', $data);  }  else {    return theme('update_report', _update_no_data());  }}/** * Theme project status report. * * @ingroup themeable */function theme_update_report($data) {  $last = variable_get('update_last_check', 0);  $output = '<div class="update checked">'. ($last ? t('Last checked: @time ago', array('@time' => format_interval(time() - $last))) : t('Last checked: never'));  $output .= ' <span class="check-manually">('. l(t('Check manually'), 'admin/reports/updates/check') .')</span>';  $output .= "</div>\n";  if (!is_array($data)) {    $output .= '<p>'. $data .'</p>';    return $output;  }  $header = array();  $rows = array();  $notification_level = variable_get('update_notification_threshold', 'all');  foreach ($data as $project) {    switch ($project['status']) {      case UPDATE_CURRENT:        $class = 'ok';        $icon = theme('image', 'misc/watchdog-ok.png', t('ok'), t('ok'));        break;      case UPDATE_UNKNOWN:      case UPDATE_NOT_FETCHED:        $class = 'unknown';        $icon = theme('image', 'misc/watchdog-warning.png', t('warning'), t('warning'));        break;      case UPDATE_NOT_SECURE:      case UPDATE_REVOKED:      case UPDATE_NOT_SUPPORTED:        $class = 'error';        $icon = theme('image', 'misc/watchdog-error.png', t('error'), t('error'));        break;      case UPDATE_NOT_CHECKED:      case UPDATE_NOT_CURRENT:      default:        $class = 'warning';        $icon = theme('image', 'misc/watchdog-warning.png', t('warning'), t('warning'));        break;    }    $row = '<div class="version-status">';    switch ($project['status']) {      case UPDATE_NOT_SECURE:        $row .= '<span class="security-error">'. t('Security update required!') .'</span>';        break;      case UPDATE_REVOKED:        $row .= '<span class="revoked">'. t('Revoked!') .'</span>';        break;      case UPDATE_NOT_SUPPORTED:        $row .= '<span class="not-supported">'. t('Not supported!') .'</span>';        break;      case UPDATE_NOT_CURRENT:        $row .= '<span class="not-current">'. t('Update available') .'</span>';        break;      case UPDATE_CURRENT:        $row .= '<span class="current">'. t('Up to date') .'</span>';        break;      default:        $row .= check_plain($project['reason']);        break;    }    $row .= '<span class="icon">'. $icon .'</span>';    $row .= "</div>\n";    $row .= '<div class="project">';    if (isset($project['title'])) {      if (isset($project['link'])) {        $row .= l($project['title'], $project['link']);      }      else {        $row .= check_plain($project['title']);      }    }    else {      $row .= check_plain($project['name']);    }    $row .= ' '. check_plain($project['existing_version']);    if ($project['install_type'] == 'dev' && !empty($project['datestamp'])) {      $row .= ' <span class="version-date">('. format_date($project['datestamp'], 'custom', 'Y-M-d') .')</span>';    }    $row .= "</div>\n";    $row .= "<div class=\"versions\">\n";    if (isset($project['recommended'])) {      if ($project['status'] != UPDATE_CURRENT || $project['existing_version'] !== $project['recommended']) {        // First, figure out what to recommend.        // If there's only 1 security update and it has the same version we're        // recommending, give it the same CSS class as if it was recommended,        // but don't print out a separate "Recommended" line for this project.        if (!empty($project['security updates']) && count($project['security updates']) == 1 && $project['security updates'][0]['version'] === $project['recommended']) {          $security_class = ' version-recommended version-recommended-strong';        }        else {          $security_class = '';          $version_class = 'version-recommended';          // Apply an extra class if we're displaying both a recommended          // version and anything else for an extra visual hint.          if ($project['recommended'] !== $project['latest_version']              || !empty($project['also'])              || ($project['install_type'] == 'dev'                 && isset($project['dev_version'])                 && $project['latest_version'] !== $project['dev_version']                 && $project['recommended'] !== $project['dev_version'])              || (isset($project['security updates'][0])                 && $project['recommended'] !== $project['security updates'][0])              ) {            $version_class .= ' version-recommended-strong';          }          $row .= theme('update_version', $project['releases'][$project['recommended']], t('Recommended version:'), $version_class);        }        // Now, print any security updates.        if (!empty($project['security updates'])) {          foreach ($project['security updates'] as $security_update) {            $row .= theme('update_version', $security_update, t('Security update:'), 'version-security'. $security_class);          }        }      }      if ($project['recommended'] !== $project['latest_version']) {        $row .= theme('update_version', $project['releases'][$project['latest_version']], t('Latest version:'), 'version-latest');      }      if ($project['install_type'] == 'dev'          && $project['status'] != UPDATE_CURRENT          && isset($project['dev_version'])          && $project['recommended'] !== $project['dev_version']) {        $row .= theme('update_version', $project['releases'][$project['dev_version']], t('Development version:'), 'version-latest');      }    }    if (isset($project['also'])) {      foreach ($project['also'] as $also) {        $row .= theme('update_version', $project['releases'][$also], t('Also available:'), 'version-also-available');      }    }    $row .= "</div>\n"; // versions div.    $row .= "<div class=\"info\">\n";    if (!empty($project['extra'])) {      $row .= '<div class="extra">'."\n";      foreach ($project['extra'] as $key => $value) {        $row .= '<div class="'. $value['class'] .'">';        $row .= check_plain($value['label']) .': ';        $row .= theme('placeholder', $value['data']);        $row .= "</div>\n";      }      $row .= "</div>\n";  // extra div.    }    $row .= '<div class="includes">';    sort($project['includes']);    $row .= t('Includes: %includes', array('%includes' => implode(', ', $project['includes'])));    $row .= "</div>\n";    if (!empty($project['base_themes'])) {      $row .= '<div class="basethemes">';      sort($project['base_themes']);      // We use !dependencies and manually call theme('placeholder') here to      // avoid breakding the D6 string freeze. This identical string is      // already in modules/system/system.admin.inc.      $row .= t('Depends on: !dependencies', array('!dependencies' => theme('placeholder', implode(', ', $project['base_themes']))));      $row .= "</div>\n";    }    if (!empty($project['sub_themes'])) {      $row .= '<div class="subthemes">';      sort($project['sub_themes']);      // We use !required and manually call theme('placeholder') here to avoid      // breakding the D6 string freeze. This identical string is already in      // modules/system/system.admin.inc.      $row .= t('Required by: !required', array('!required' => theme('placeholder', implode(', ', $project['sub_themes']))));      $row .= "</div>\n";    }    $row .= "</div>\n"; // info div.    if (!isset($rows[$project['project_type']])) {      $rows[$project['project_type']] = array();    }    $row_key = isset($project['title']) ? drupal_strtolower($project['title']) : drupal_strtolower($project['name']);    $rows[$project['project_type']][$row_key] = array(      'class' => $class,      'data' => array($row),    );  }  $project_types = array(    'core' => t('Drupal core'),    'module' => t('Modules'),    'theme' => t('Themes'),    'disabled-module' => t('Disabled modules'),    'disabled-theme' => t('Disabled themes'),  );  foreach ($project_types as $type_name => $type_label) {    if (!empty($rows[$type_name])) {      ksort($rows[$type_name]);      $output .= "\n<h3>". $type_label ."</h3>\n";      $output .= theme('table', $header, $rows[$type_name], array('class' => 'update'));    }  }  drupal_add_css(drupal_get_path('module', 'update') .'/update.css');  return $output;}/** * Theme the version display of a project. * * @ingroup themeable */function theme_update_version($version, $tag, $class) {  $output = '';  $output .= '<table class="version '. $class .'">';  $output .= '<tr>';  $output .= '<td class="version-title">'. $tag ."</td>\n";  $output .= '<td class="version-details">';  $output .= l($version['version'], $version['release_link']);  $output .= ' <span class="version-date">('. format_date($version['date'], 'custom', 'Y-M-d') .')</span>';  $output .= "</td>\n";  $output .= '<td class="version-links">';  $links = array();  $links['update-download'] = array(    'title' => t('Download'),    'href' => $version['download_link'],  );  $links['update-release-notes'] = array(    'title' => t('Release notes'),    'href' => $version['release_link'],  );  $output .= theme('links', $links);  $output .= '</td>';  $output .= '</tr>';  $output .= "</table>\n";  return $output;}
<?php// $Id$/** * @file * Enables keeping an easily and regularly updated web page or a blog. *//** * Implementation of hook_node_info(). */function blog_node_info() {  return array(    'blog' => array(      'name' => t('Blog entry'),      'module' => 'blog',      'description' => t('A <em>blog entry</em> is a single post to an online journal, or <em>blog</em>.'),    )  );}/** * Implementation of hook_perm(). */function blog_perm() {  return array('create blog entries', 'delete own blog entries', 'delete any blog entry', 'edit own blog entries', 'edit any blog entry');}/** * Implementation of hook_access(). */function blog_access($op, $node, $account) {  switch ($op) {    case 'create':      // Anonymous users cannot post even if they have the permission.       return user_access('create blog entries', $account) && $account->uid ? TRUE : NULL;    case 'update':      return user_access('edit any blog entry', $account) || (user_access('edit own blog entries', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;    case 'delete':      return user_access('delete any blog entry', $account) || (user_access('delete own blog entries', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;  }}/** * Implementation of hook_user(). */function blog_user($type, &$edit, &$user) {  if ($type == 'view' && user_access('create blog entries', $user)) {    $user->content['summary']['blog'] =  array(      '#type' => 'user_profile_item',      '#title' => t('Blog'),      // l() escapes the attributes, so we should not escape !username here.      '#value' => l(t('View recent blog entries'), "blog/$user->uid", array('attributes' => array('title' => t("Read !username's latest blog entries.", array('!username' => $user->name))))),      '#attributes' => array('class' => 'blog'),    );  }}/** * Implementation of hook_help(). */function blog_help($path, $arg) {  switch ($path) {    case 'admin/help#blog':      $output = '<p>'. t('The blog module allows registered users to maintain an online journal, or <em>blog</em>. Blogs are made up of individual <em>blog entries</em>, and the blog entries are most often displayed in descending order by creation time.') .'</p>';      $output .= '<p>'. t('There is an (optional) <em>Blogs</em> menu item added to the Navigation menu, which displays all blogs available on your site, and a <em>My blog</em> item displaying the current user\'s blog entries. The <em>Blog entry</em> menu item under <em>Create content</em> allows new blog entries to be created.') .'</p>';      $output .= '<p>'. t('Each blog entry is displayed with an automatic link to other blogs created by the same user. By default, blog entries have comments enabled and are automatically promoted to the site front page. The blog module also creates a <em>Recent blog posts</em> block that may be enabled at the <a href="@blocks">blocks administration page</a>.', array('@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('When using the aggregator module an automatic <em>blog it</em> icon is displayed next to the items in a feed\'s <em>latest items</em> block. Clicking this icon populates a <em>blog entry</em> with a title (the title of the feed item) and body (a link to the source item on its original site and illustrative content suitable for use in a block quote). Blog authors can use this feature to easily comment on items of interest that appear in aggregator feeds from other sites. To use this feature, be sure to <a href="@modules">enable</a> the aggregator module, <a href="@feeds">add and configure</a> a feed from another site, and <a href="@blocks">position</a> the feed\'s <em>latest items</em> block.', array('@modules' => url('admin/build/modules'), '@feeds' => url('admin/content/aggregator'), '@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@blog">Blog module</a>.', array('@blog' => 'http://drupal.org/handbook/modules/blog/')) .'</p>';      return $output;  }}/** * Implementation of hook_form(). */function blog_form(&$node) {  global $nid;  $iid = isset($_GET['iid']) ? (int)$_GET['iid'] : 0;  $type = node_get_types('type', $node);  if (empty($node->body)) {    // If the user clicked a "blog it" link, we load the data from the    // database and quote it in the blog.    if ($nid && $blog = node_load($nid)) {      $node->body = '<em>'. $blog->body .'</em> ['. l($blog->name, "node/$nid") .']';    }    if ($iid && $item = db_fetch_object(db_query('SELECT i.*, f.title as ftitle, f.link as flink FROM {aggregator_item} i, {aggregator_feed} f WHERE i.iid = %d AND i.fid = f.fid', $iid))) {      $node->title = $item->title;      // Note: $item->description has been validated on aggregation.      $node->body = '<a href="'. check_url($item->link) .'">'. check_plain($item->title) .'</a> - <em>'. $item->description .'</em> [<a href="'. check_url($item->flink) .'">'. check_plain($item->ftitle) ."</a>]\n";    }  }  $form['title'] = array('#type' => 'textfield', '#title' => check_plain($type->title_label), '#required' => TRUE, '#default_value' => !empty($node->title) ? $node->title : NULL, '#weight' => -5);  $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);  return $form;}/** * Implementation of hook_view(). */function blog_view($node, $teaser = FALSE, $page = FALSE) {  if ($page) {    // Breadcrumb navigation. l() escapes the title, so we should not escape !name.     drupal_set_breadcrumb(array(l(t('Home'), NULL), l(t('Blogs'), 'blog'), l(t("!name's blog", array('!name' => $node->name)), 'blog/'. $node->uid)));  }  return node_prepare($node, $teaser);}/** * Implementation of hook_link(). */function blog_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && $node->type == 'blog') {    if (arg(0) != 'blog' || arg(1) != $node->uid) {      // This goes to l() and therefore escapes !username in both the title and attributes.      $links['blog_usernames_blog'] = array(        'title' => t("!username's blog", array('!username' => $node->name)),        'href' => "blog/$node->uid",        'attributes' => array('title' => t("Read !username's latest blog entries.", array('!username' => $node->name)))      );    }  }  return $links;}/** * Implementation of hook_menu(). */function blog_menu() {  $items['blog'] = array(    'title' => 'Blogs',    'page callback' => 'blog_page_last',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'blog.pages.inc',  );  $items['blog/%user_uid_optional'] = array(    'title' => 'My blog',    'page callback' => 'blog_page_user',    'page arguments' => array(1),    'access callback' => 'blog_page_user_access',    'access arguments' => array(1),    'file' => 'blog.pages.inc',  );  $items['blog/%user/feed'] = array(    'title' => 'Blogs',    'page callback' => 'blog_feed_user',    'page arguments' => array(1),    'access callback' => 'blog_page_user_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,    'file' => 'blog.pages.inc',  );  $items['blog/feed'] = array(    'title' => 'Blogs',    'page callback' => 'blog_feed_last',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'blog.pages.inc',  );  return $items;}/** * Access callback for user blog pages. */function blog_page_user_access($account) {  // The visitor must be able to access the site's content.  // For a blog to 'exist' the user must either be able to  // create new blog entries, or it must have existing posts.  return $account->uid && user_access('access content') && (user_access('create blog entries', $account) || _blog_post_exists($account));}/** * Helper function to determine if a user has blog posts already. */function _blog_post_exists($account) {  return (bool)db_result(db_query_range(db_rewrite_sql("SELECT 1 FROM {node} n WHERE n.type = 'blog' AND n.uid = %d AND n.status = 1"), $account->uid, 0, 1));}/** * Implementation of hook_block(). * * Displays the most recent 10 blog titles. */function blog_block($op = 'list', $delta = 0) {  global $user;  if ($op == 'list') {    $block[0]['info'] = t('Recent blog posts');    return $block;  }  else if ($op == 'view') {    if (user_access('access content')) {      $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, n.created FROM {node} n WHERE n.type = 'blog' AND n.status = 1 ORDER BY n.created DESC"), 0, 10);      if ($node_title_list = node_title_list($result)) {        $block['content'] = $node_title_list;        $block['content'] .= theme('more_link', url('blog'), t('Read the latest blog entries.'));        $block['subject'] = t('Recent blog posts');        return $block;      }    }  }}
<?php// $Id$/** * @file * Enable users to post using applications that support XML-RPC blog APIs. *//** * Implementation of hook_help(). */function blogapi_help($path, $arg) {  switch ($path) {    case 'admin/help#blogapi':      $output = '<p>'. t("The Blog API module allows your site's users to access and post to their blogs from external blogging clients. External blogging clients are available for a wide range of desktop operating systems, and generally provide a feature-rich graphical environment for creating and editing posts.") .'</p>';      $output .= '<p>'. t('<a href="@ecto-link">Ecto</a>, a blogging client available for both Mac OS X and Microsoft Windows, can be used with Blog API. Blog API also supports <a href="@blogger-api">Blogger API</a>, <a href="@metaweblog-api">MetaWeblog API</a>, and most of the <a href="@movabletype-api">Movable Type API</a>. Blogging clients and other services (e.g. <a href="@flickr">Flickr\'s</a> "post to blog") that support these APIs may also be compatible.', array('@ecto-link' => url('http://infinite-sushi.com/software/ecto/'), '@blogger-api' => url('http://www.blogger.com/developers/api/1_docs/'), '@metaweblog-api' => url('http://www.xmlrpc.com/metaWeblogApi'), '@movabletype-api' => url('http://www.movabletype.org/docs/mtmanual_programmatic.html'), '@flickr' => url('http://www.flickr.com'))) .'</p>';      $output .= '<p>'. t('Select the content types available to external clients on the <a href="@blogapi-settings">Blog API settings page</a>. If supported and available, each content type will be displayed as a separate "blog" by the external client.', array('@blogapi-settings' => url('admin/settings/blogapi'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@blogapi">Blog API module</a>.', array('@blogapi' => url('http://drupal.org/handbook/modules/blogapi/'))) .'</p>';      return $output;  }}/** * Implementation of hook_perm(). */function blogapi_perm() {  return array('administer content with blog api');}/** * Implementation of hook_xmlrpc(). */function blogapi_xmlrpc() {  return array(    array(      'blogger.getUsersBlogs',      'blogapi_blogger_get_users_blogs',      array('array', 'string', 'string', 'string'),      t('Returns a list of blogs to which an author has posting privileges.')),    array(      'blogger.getUserInfo',      'blogapi_blogger_get_user_info',      array('struct', 'string', 'string', 'string'),      t('Returns information about an author in the system.')),    array(      'blogger.newPost',      'blogapi_blogger_new_post',      array('string', 'string', 'string', 'string', 'string', 'string', 'boolean'),      t('Creates a new post, and optionally publishes it.')),    array(      'blogger.editPost',      'blogapi_blogger_edit_post',      array('boolean', 'string', 'string', 'string', 'string', 'string', 'boolean'),      t('Updates the information about an existing post.')),    array(      'blogger.getPost',      'blogapi_blogger_get_post',      array('struct', 'string', 'string', 'string', 'string'),      t('Returns information about a specific post.')),    array(      'blogger.deletePost',      'blogapi_blogger_delete_post',      array('boolean', 'string', 'string', 'string', 'string', 'boolean'),      t('Deletes a post.')),    array(      'blogger.getRecentPosts',      'blogapi_blogger_get_recent_posts',      array('array', 'string', 'string', 'string', 'string', 'int'),      t('Returns a list of the most recent posts in the system.')),    array(      'metaWeblog.newPost',      'blogapi_metaweblog_new_post',      array('string', 'string', 'string', 'string', 'struct', 'boolean'),      t('Creates a new post, and optionally publishes it.')),    array(      'metaWeblog.editPost',      'blogapi_metaweblog_edit_post',      array('boolean', 'string', 'string', 'string', 'struct', 'boolean'),      t('Updates information about an existing post.')),    array(      'metaWeblog.getPost',      'blogapi_metaweblog_get_post',      array('struct', 'string', 'string', 'string'),      t('Returns information about a specific post.')),    array(      'metaWeblog.newMediaObject',      'blogapi_metaweblog_new_media_object',      array('string', 'string', 'string', 'string', 'struct'),      t('Uploads a file to your webserver.')),    array(      'metaWeblog.getCategories',      'blogapi_metaweblog_get_category_list',      array('struct', 'string', 'string', 'string'),      t('Returns a list of all categories to which the post is assigned.')),    array(      'metaWeblog.getRecentPosts',      'blogapi_metaweblog_get_recent_posts',      array('array', 'string', 'string', 'string', 'int'),      t('Returns a list of the most recent posts in the system.')),    array(      'mt.getRecentPostTitles',      'blogapi_mt_get_recent_post_titles',      array('array', 'string', 'string', 'string', 'int'),      t('Returns a bandwidth-friendly list of the most recent posts in the system.')),    array(      'mt.getCategoryList',      'blogapi_mt_get_category_list',      array('array', 'string', 'string', 'string'),      t('Returns a list of all categories defined in the blog.')),    array(      'mt.getPostCategories',      'blogapi_mt_get_post_categories',      array('array', 'string', 'string', 'string'),      t('Returns a list of all categories to which the post is assigned.')),    array(      'mt.setPostCategories',      'blogapi_mt_set_post_categories',      array('boolean', 'string', 'string', 'string', 'array'),      t('Sets the categories for a post.')),    array(      'mt.supportedMethods',      'xmlrpc_server_list_methods',      array('array'),      t('Retrieve information about the XML-RPC methods supported by the server.')),    array(      'mt.supportedTextFilters',      'blogapi_mt_supported_text_filters',      array('array'),      t('Retrieve information about the text formatting plugins supported by the server.')),    array(      'mt.publishPost',      'blogapi_mt_publish_post',      array('boolean', 'string', 'string', 'string'),      t('Publish (rebuild) all of the static files related to an entry from your blog. Equivalent to saving an entry in the system (but without the ping).')));}/** * Blogging API callback. Finds the URL of a user's blog. */function blogapi_blogger_get_users_blogs($appid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if ($user->uid) {    $types = _blogapi_get_node_types();    $structs = array();    foreach ($types as $type) {      $structs[] = array('url' => url('blog/'. $user->uid, array('absolute' => TRUE)), 'blogid' => $type, 'blogName' => $user->name .": ". $type);    }    return $structs;  }  else {    return blogapi_error($user);  }}/** * Blogging API callback. Returns profile information about a user. */function blogapi_blogger_get_user_info($appkey, $username, $password) {  $user = blogapi_validate_user($username, $password);  if ($user->uid) {    $name = explode(' ', $user->realname ? $user->realname : $user->name, 2);    return array(      'userid' => $user->uid,      'lastname' => $name[1],      'firstname' => $name[0],      'nickname' => $user->name,      'email' => $user->mail,      'url' => url('blog/'. $user->uid, array('absolute' => TRUE)));  }  else {    return blogapi_error($user);  }}/** * Blogging API callback. Inserts a new blog post as a node. */function blogapi_blogger_new_post($appkey, $blogid, $username, $password, $content, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  $edit = array();  $edit['type'] = $blogid;  // get the node type defaults  $node_type_default = variable_get('node_options_'. $edit['type'], array('status', 'promote'));  $edit['uid'] = $user->uid;  $edit['name'] = $user->name;  $edit['promote'] = in_array('promote', $node_type_default);  $edit['comment'] = variable_get('comment_'. $edit['type'], 2);  $edit['revision'] = in_array('revision', $node_type_default);  $edit['format'] = FILTER_FORMAT_DEFAULT;  $edit['status'] = $publish;  // check for bloggerAPI vs. metaWeblogAPI  if (is_array($content)) {    $edit['title'] = $content['title'];    $edit['body'] = $content['description'];    _blogapi_mt_extra($edit, $content);  }  else {    $edit['title'] = blogapi_blogger_title($content);    $edit['body'] = $content;  }  if (!node_access('create', $edit['type'])) {    return blogapi_error(t('You do not have permission to create this type of post.'));  }  if (user_access('administer nodes') && !isset($edit['date'])) {    $edit['date'] = format_date(time(), 'custom', 'Y-m-d H:i:s O');  }  node_invoke_nodeapi($edit, 'blogapi new');  $valid = blogapi_status_error_check($edit, $publish);  if ($valid !== TRUE) {    return $valid;  }  node_validate($edit);  if ($errors = form_get_errors()) {    return blogapi_error(implode("\n", $errors));  }  $node = node_submit($edit);  node_save($node);  if ($node->nid) {    watchdog('content', '@type: added %title using blog API.', array('@type' => $node->type, '%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), "node/$node->nid"));    // blogger.newPost returns a string so we cast the nid to a string by putting it in double quotes:    return "$node->nid";  }  return blogapi_error(t('Error storing post.'));}/** * Blogging API callback. Modifies the specified blog node. */function blogapi_blogger_edit_post($appkey, $postid, $username, $password, $content, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  if (!$node) {    return blogapi_error(t('n/a'));  }  // Let the teaser be re-generated.  unset($node->teaser);  if (!node_access('update', $node)) {    return blogapi_error(t('You do not have permission to update this post.'));  }  // Save the original status for validation of permissions.  $original_status = $node->status;  $node->status = $publish;  // check for bloggerAPI vs. metaWeblogAPI  if (is_array($content)) {    $node->title = $content['title'];    $node->body = $content['description'];    _blogapi_mt_extra($node, $content);  }  else {    $node->title = blogapi_blogger_title($content);    $node->body = $content;  }  node_invoke_nodeapi($node, 'blogapi edit');  $valid = blogapi_status_error_check($node, $original_status);  if ($valid !== TRUE) {    return $valid;  }  node_validate($node);  if ($errors = form_get_errors()) {    return blogapi_error(implode("\n", $errors));  }  if (user_access('administer nodes') && !isset($edit['date'])) {    $node->date = format_date($node->created, 'custom', 'Y-m-d H:i:s O');  }  $node = node_submit($node);  node_save($node);  if ($node->nid) {    watchdog('content', '@type: updated %title using Blog API.', array('@type' => $node->type, '%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), "node/$node->nid"));    return TRUE;  }  return blogapi_error(t('Error storing post.'));}/** * Blogging API callback. Returns a specified blog node. */function blogapi_blogger_get_post($appkey, $postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  return _blogapi_get_post($node, TRUE);}/** * Check that the user has permission to save the node with the chosen status. * * @return *   TRUE if no error, or the blogapi_error(). */function blogapi_status_error_check($node, $original_status) {    $node = (object) $node;  $node_type_default = variable_get('node_options_'. $node->type, array('status', 'promote'));  // If we don't have the 'administer nodes' permission and the status is  // changing or for a new node the status is not the content type's default,  // then return an error.  if (!user_access('administer nodes') && (($node->status != $original_status) || (empty($node->nid) && $node->status != in_array('status', $node_type_default)))) {    if ($node->status) {      return blogapi_error(t('You do not have permission to publish this type of post. Please save it as a draft instead.'));    }    else {      return blogapi_error(t('You do not have permission to save this post as a draft. Please publish it instead.'));    }  }  return TRUE;}/** * Blogging API callback. Removes the specified blog node. */function blogapi_blogger_delete_post($appkey, $postid, $username, $password, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  node_delete($postid);  return TRUE;}/** * Blogging API callback. Returns the latest few postings in a user's blog. $bodies TRUE * <a href="http://movabletype.org/docs/mtmanual_programmatic.html#item_mt%2EgetRecentPostTitles"> * returns a bandwidth-friendly list</a>. */function blogapi_blogger_get_recent_posts($appkey, $blogid, $username, $password, $number_of_posts, $bodies = TRUE) {  // Remove unused appkey (from bloggerAPI).  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  if ($bodies) {    $result = db_query_range("SELECT n.nid, n.title, r.body, r.format, n.comment, n.created, u.name FROM {node} n, {node_revisions} r, {users} u WHERE n.uid = u.uid AND n.vid = r.vid AND n.type = '%s' AND n.uid = %d ORDER BY n.created DESC",  $blogid, $user->uid, 0, $number_of_posts);  }  else {    $result = db_query_range("SELECT n.nid, n.title, n.created, u.name FROM {node} n, {users} u WHERE n.uid = u.uid AND n.type = '%s' AND n.uid = %d ORDER BY n.created DESC", $blogid, $user->uid, 0, $number_of_posts);  }  $blogs = array();  while ($blog = db_fetch_object($result)) {    $blogs[] = _blogapi_get_post($blog, $bodies);  }  return $blogs;}function blogapi_metaweblog_new_post($blogid, $username, $password, $content, $publish) {  return blogapi_blogger_new_post('0123456789ABCDEF', $blogid, $username, $password, $content, $publish);}function blogapi_metaweblog_edit_post($postid, $username, $password, $content, $publish) {  return blogapi_blogger_edit_post('0123456789ABCDEF', $postid, $username, $password, $content, $publish);}function blogapi_metaweblog_get_post($postid, $username, $password) {  return blogapi_blogger_get_post('01234567890ABCDEF', $postid, $username, $password);}/** * Blogging API callback. Inserts a file into Drupal. */function blogapi_metaweblog_new_media_object($blogid, $username, $password, $file) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $usersize = 0;  $uploadsize = 0;  $roles = array_intersect(user_roles(FALSE, 'administer content with blog api'), $user->roles);  foreach ($roles as $rid => $name) {    $extensions .= ' '. strtolower(variable_get("blogapi_extensions_$rid", variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp')));    $usersize= max($usersize, variable_get("blogapi_usersize_$rid", variable_get('blogapi_usersize_default', 1)) * 1024 * 1024);    $uploadsize = max($uploadsize, variable_get("blogapi_uploadsize_$rid", variable_get('blogapi_uploadsize_default', 1)) * 1024 * 1024);  }  $filesize = strlen($file['bits']);  if ($filesize > $uploadsize) {    return blogapi_error(t('It is not possible to upload the file, because it exceeded the maximum filesize of @maxsize.', array('@maxsize' => format_size($uploadsize))));  }  if (_blogapi_space_used($user->uid) + $filesize > $usersize) {    return blogapi_error(t('The file can not be attached to this post, because the disk quota of @quota has been reached.', array('@quota' => format_size($usersize))));  }  // Only allow files with whitelisted extensions and convert remaining dots to  // underscores to prevent attacks via non-terminal executable extensions with  // files such as exploit.php.jpg.  $whitelist = array_unique(explode(' ', trim($extensions)));  $name = basename($file['name']);  if ($extension_position = strrpos($name, '.')) {    $filename = drupal_substr($name, 0, $extension_position);    $final_extension = drupal_substr($name, $extension_position + 1);    if (!in_array(strtolower($final_extension), $whitelist)) {      return blogapi_error(t('It is not possible to upload the file, because it is only possible to upload files with the following extensions: @extensions', array('@extensions' => implode(' ', $whitelist))));    }    $filename = str_replace('.', '_', $filename);    $filename .= '.'. $final_extension;  }  $data = $file['bits'];  if (!$data) {    return blogapi_error(t('No file sent.'));  }  if (!$file = file_save_data($data, $filename)) {    return blogapi_error(t('Error storing file.'));  }  $row = new stdClass();  $row->uid = $user->uid;  $row->filepath = $file;  $row->filesize = $filesize;  drupal_write_record('blogapi_files', $row);  // Return the successful result.  return array('url' => file_create_url($file), 'struct');}/** * Blogging API callback. Returns a list of the taxonomy terms that can be * associated with a blog node. */function blogapi_metaweblog_get_category_list($blogid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  $vocabularies = module_invoke('taxonomy', 'get_vocabularies', $blogid, 'vid');  $categories = array();  if ($vocabularies) {    foreach ($vocabularies as $vocabulary) {      $terms = module_invoke('taxonomy', 'get_tree', $vocabulary->vid, 0, -1);      foreach ($terms as $term) {        $term_name = $term->name;        foreach (module_invoke('taxonomy', 'get_parents', $term->tid, 'tid') as $parent) {          $term_name = $parent->name .'/'. $term_name;        }        $categories[] = array('categoryName' => $term_name, 'categoryId' => $term->tid);      }    }  }  return $categories;}function blogapi_metaweblog_get_recent_posts($blogid, $username, $password, $number_of_posts) {  return blogapi_blogger_get_recent_posts('0123456789ABCDEF', $blogid, $username, $password, $number_of_posts, TRUE);}function blogapi_mt_get_recent_post_titles($blogid, $username, $password, $number_of_posts) {  return blogapi_blogger_get_recent_posts('0123456789ABCDEF', $blogid, $username, $password, $number_of_posts, FALSE);}function blogapi_mt_get_category_list($blogid, $username, $password) {  return blogapi_metaweblog_get_category_list($blogid, $username, $password);}/** * Blogging API callback. Returns a list of the taxonomy terms that are * assigned to a particular node. */function blogapi_mt_get_post_categories($postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  $terms = module_invoke('taxonomy', 'node_get_terms', $node, 'tid');  $categories = array();  foreach ($terms as $term) {    $term_name = $term->name;    foreach (module_invoke('taxonomy', 'get_parents', $term->tid, 'tid') as $parent) {      $term_name = $parent->name .'/'. $term_name;    }    $categories[] = array('categoryName' => $term_name, 'categoryId' => $term->tid, 'isPrimary' => TRUE);  }  return $categories;}/** * Blogging API callback. Assigns taxonomy terms to a particular node. */function blogapi_mt_set_post_categories($postid, $username, $password, $categories) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  $node->taxonomy = array();  foreach ($categories as $category) {    $node->taxonomy[] = $category['categoryId'];  }  $validated = blogapi_mt_validate_terms($node);  if ($validated !== TRUE) {    return $validated;  }  node_save($node);  return TRUE;}/** * Blogging API helper - find allowed taxonomy terms for a node type. */function blogapi_mt_validate_terms($node) {  // We do a lot of heavy lifting here since taxonomy module doesn't have a  // stand-alone validation function.  if (module_exists('taxonomy')) {    $found_terms = array();    if (!empty($node->taxonomy)) {      $term_list = array_unique($node->taxonomy);      $params = $term_list;      $params[] = $node->type;      $result = db_query(db_rewrite_sql("SELECT t.tid, t.vid FROM {term_data} t INNER JOIN {vocabulary_node_types} n ON t.vid = n.vid WHERE t.tid IN (". db_placeholders($term_list) .") AND n.type = '%s'", 't', 'tid'), $params);      $found_terms = array();      $found_count = 0;      while ($term = db_fetch_object($result)) {        $found_terms[$term->vid][$term->tid] = $term->tid;        $found_count++;      }      // If the counts don't match, some terms are invalid or not accessible to this user.      if (count($term_list) != $found_count) {        return blogapi_error(t('Invalid categories submitted.'));      }    }    // Look up all the vocabularies for this node type.    $result2 = db_query(db_rewrite_sql("SELECT v.vid, v.name, v.required, v.multiple FROM {vocabulary} v INNER JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s'", 'v', 'vid'), $node->type);    // Check each vocabulary associated with this node type.    while ($vocabulary = db_fetch_object($result2)) {      // Required vocabularies must have at least one term.      if ($vocabulary->required && empty($found_terms[$vocabulary->vid])) {        return blogapi_error(t('A category from the @vocabulary_name vocabulary is required.', array('@vocabulary_name' => $vocabulary->name)));      }      // Vocabularies that don't allow multiple terms may have at most one.      if (!($vocabulary->multiple) && (isset($found_terms[$vocabulary->vid]) && count($found_terms[$vocabulary->vid]) > 1)) {        return blogapi_error(t('You may only choose one category from the @vocabulary_name vocabulary.'), array('@vocabulary_name' => $vocabulary->name));      }    }  }  elseif (!empty($node->taxonomy)) {    return blogapi_error(t('Error saving categories. This feature is not available.'));  }  return TRUE;}/** * Blogging API callback. Sends a list of available input formats. */function blogapi_mt_supported_text_filters() {  // NOTE: we're only using anonymous' formats because the MT spec  // does not allow for per-user formats.  $formats = filter_formats();  $filters = array();  foreach ($formats as $format) {    $filter['key'] = $format->format;    $filter['label'] = $format->name;    $filters[] = $filter;  }  return $filters;}/** * Blogging API callback. Publishes the given node */function blogapi_mt_publish_post($postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  if (!$node) {    return blogapi_error(t('Invalid post.'));  }  // Nothing needs to be done if already published.  if ($node->status) {    return;  }  if (!node_access('update', $node) || !user_access('administer nodes')) {    return blogapi_error(t('You do not have permission to update this post.'));  }  $node->status = 1;  node_save($node);  return TRUE;}/** * Prepare an error message for returning to the XMLRPC caller. */function blogapi_error($message) {  static $xmlrpcusererr;  if (!is_array($message)) {    $message = array($message);  }  $message = implode(' ', $message);  return xmlrpc_error($xmlrpcusererr + 1, strip_tags($message));}/** * Ensure that the given user has permission to edit a blog. */function blogapi_validate_user($username, $password) {  global $user;  $user = user_authenticate(array('name' => $username, 'pass' => $password));  if ($user->uid) {    if (user_access('administer content with blog api', $user)) {      return $user;    }    else {      return t('You do not have permission to edit this blog.');    }  }  else {    return t('Wrong username or password.');  }}/** * For the blogger API, extract the node title from the contents field. */function blogapi_blogger_title(&$contents) {  if (eregi('<title>([^<]*)</title>', $contents, $title)) {    $title = strip_tags($title[0]);    $contents = ereg_replace('<title>[^<]*</title>', '', $contents);  }  else {    list($title, $contents) = explode("\n", $contents, 2);  }  return $title;}function blogapi_admin_settings() {  $node_types = array_map('check_plain', node_get_types('names'));  $defaults = isset($node_types['blog']) ? array('blog' => 1) : array();  $form['blogapi_node_types'] = array(    '#type' => 'checkboxes',    '#title' => t('Enable for external blogging clients'),    '#required' => TRUE,    '#default_value' => variable_get('blogapi_node_types', $defaults),    '#options' => $node_types,    '#description' => t('Select the content types available to external blogging clients via Blog API. If supported, each enabled content type will be displayed as a separate "blog" by the external client.')  );  $blogapi_extensions_default = variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp');  $blogapi_uploadsize_default = variable_get('blogapi_uploadsize_default', 1);  $blogapi_usersize_default = variable_get('blogapi_usersize_default', 1);  $form['settings_general'] = array(    '#type' => 'fieldset',    '#title' => t('File settings'),    '#collapsible' => TRUE,  );  $form['settings_general']['blogapi_extensions_default'] = array(    '#type' => 'textfield',    '#title' => t('Default permitted file extensions'),    '#default_value' => $blogapi_extensions_default,    '#maxlength' => 255,    '#description' => t('Default extensions that users can upload. Separate extensions with a space and do not include the leading dot.'),  );  $form['settings_general']['blogapi_uploadsize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default maximum file size per upload'),    '#default_value' => $blogapi_uploadsize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum file size a user can upload.'),    '#field_suffix' => t('MB')  );  $form['settings_general']['blogapi_usersize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default total file size per user'),    '#default_value' => $blogapi_usersize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum size of all files a user can have on the site.'),    '#field_suffix' => t('MB')  );  $form['settings_general']['upload_max_size'] = array('#value' => '<p>'. t('Your PHP settings limit the maximum file size per upload to %size.', array('%size' => format_size(file_upload_max_size()))).'</p>');  $roles = user_roles(0, 'administer content with blog api');  $form['roles'] = array('#type' => 'value', '#value' => $roles);  foreach ($roles as $rid => $role) {    $form['settings_role_'. $rid] = array(      '#type' => 'fieldset',      '#title' => t('Settings for @role', array('@role' => $role)),      '#collapsible' => TRUE,      '#collapsed' => TRUE,    );    $form['settings_role_'. $rid]['blogapi_extensions_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Permitted file extensions'),      '#default_value' => variable_get('blogapi_extensions_'. $rid, $blogapi_extensions_default),      '#maxlength' => 255,      '#description' => t('Extensions that users in this role can upload. Separate extensions with a space and do not include the leading dot.'),    );    $form['settings_role_'. $rid]['blogapi_uploadsize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Maximum file size per upload'),      '#default_value' => variable_get('blogapi_uploadsize_'. $rid, $blogapi_uploadsize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of a file a user can upload (in megabytes).'),    );    $form['settings_role_'. $rid]['blogapi_usersize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Total file size per user'),      '#default_value' => variable_get('blogapi_usersize_'. $rid, $blogapi_usersize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of all files a user can have on the site (in megabytes).'),    );  }  return system_settings_form($form);}function blogapi_menu() {  $items['blogapi/rsd'] = array(    'title' => 'RSD',    'page callback' => 'blogapi_rsd',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/blogapi'] = array(    'title' => 'Blog API',    'description' => 'Configure the content types available to external blogging clients.',    'page callback' => 'drupal_get_form',    'page arguments' => array('blogapi_admin_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_NORMAL_ITEM,  );  return $items;}function blogapi_init() {  if (drupal_is_front_page()) {    drupal_add_link(array('rel' => 'EditURI',                          'type' => 'application/rsd+xml',                          'title' => t('RSD'),                          'href' => url('blogapi/rsd', array('absolute' => TRUE))));  }}function blogapi_rsd() {  global $base_url;  $xmlrpc = $base_url .'/xmlrpc.php';  $base = url('', array('absolute' => TRUE));  $blogid = 1; # until we figure out how to handle multiple bloggers  drupal_set_header('Content-Type: application/rsd+xml; charset=utf-8');  print <<<__RSD__<?xml version="1.0"?><rsd version="1.0" xmlns="http://archipelago.phrasewise.com/rsd">  <service>    <engineName>Drupal</engineName>    <engineLink>http://drupal.org/</engineLink>    <homePageLink>$base</homePageLink>    <apis>      <api name="MetaWeblog" preferred="false" apiLink="$xmlrpc" blogID="$blogid" />      <api name="Blogger" preferred="false" apiLink="$xmlrpc" blogID="$blogid" />      <api name="MovableType" preferred="true" apiLink="$xmlrpc" blogID="$blogid" />    </apis>  </service></rsd>__RSD__;}/** * Handles extra information sent by clients according to MovableType's spec. */function _blogapi_mt_extra(&$node, $struct) {  if (is_array($node)) {    $was_array = TRUE;    $node = (object)$node;  }  // mt_allow_comments  if (array_key_exists('mt_allow_comments', $struct)) {    switch ($struct['mt_allow_comments']) {      case 0:        $node->comment = COMMENT_NODE_DISABLED;        break;      case 1:        $node->comment = COMMENT_NODE_READ_WRITE;        break;      case 2:        $node->comment = COMMENT_NODE_READ_ONLY;        break;    }  }  // merge the 3 body sections (description, mt_excerpt, mt_text_more) into  // one body  if ($struct['mt_excerpt']) {    $node->body = $struct['mt_excerpt'] .'<!--break-->'. $node->body;  }  if ($struct['mt_text_more']) {    $node->body = $node->body .'<!--extended-->'. $struct['mt_text_more'];  }  // mt_convert_breaks  if ($struct['mt_convert_breaks']) {    $node->format = $struct['mt_convert_breaks'];  }  // dateCreated  if ($struct['dateCreated']) {    $node->date = format_date(mktime($struct['dateCreated']->hour, $struct['dateCreated']->minute, $struct['dateCreated']->second, $struct['dateCreated']->month, $struct['dateCreated']->day, $struct['dateCreated']->year), 'custom', 'Y-m-d H:i:s O');  }  if ($was_array) {    $node = (array)$node;  }}function _blogapi_get_post($node, $bodies = TRUE) {  $xmlrpcval = array(    'userid' => $node->name,    'dateCreated' => xmlrpc_date($node->created),    'title' => $node->title,    'postid' => $node->nid,    'link' => url('node/'. $node->nid, array('absolute' => TRUE)),    'permaLink' => url('node/'. $node->nid, array('absolute' => TRUE)),  );  if ($bodies) {    if ($node->comment == 1) {      $comment = 2;    }    else if ($node->comment == 2) {      $comment = 1;    }    $xmlrpcval['content'] = "<title>$node->title</title>$node->body";    $xmlrpcval['description'] = $node->body;    // Add MT specific fields    $xmlrpcval['mt_allow_comments'] = (int) $comment;    $xmlrpcval['mt_convert_breaks'] = $node->format;  }  return $xmlrpcval;}/** * Validate blog ID, which maps to a content type in Drupal. * * Only content types configured to work with Blog API are supported. * * @return *   TRUE if the content type is supported and the user has permission *   to post, or a blogapi_error() XML construct otherwise. */function _blogapi_validate_blogid($blogid) {  $types = _blogapi_get_node_types();  if (in_array($blogid, $types, TRUE)) {    return TRUE;  }  return blogapi_error(t("Blog API module is not configured to support the %type content type, or you don't have sufficient permissions to post this type of content.", array('%type' => $blogid)));}function _blogapi_get_node_types() {  $available_types = array_keys(array_filter(variable_get('blogapi_node_types', array('blog' => 1))));  $types = array();  foreach (node_get_types() as $type => $name) {    if (node_access('create', $type) && in_array($type, $available_types)) {      $types[] = $type;    }  }  return $types;}function _blogapi_space_used($uid) {  return db_result(db_query('SELECT SUM(filesize) FROM {blogapi_files} f WHERE f.uid = %d', $uid));}
<?php// $Id$/** * @defgroup forms Form builder functions * @{ * Functions that build an abstract representation of a HTML form. * * All modules should declare their form builder functions to be in this * group and each builder function should reference its validate and submit * functions using \@see. Conversely, validate and submit functions should * reference the form builder function using \@see. For examples, of this see * system_modules_uninstall() or user_pass(), the latter of which has the * following in its doxygen documentation: * * \@ingroup forms * \@see user_pass_validate(). * \@see user_pass_submit(). * * @} End of "defgroup forms". *//** * @defgroup form_api Form generation * @{ * Functions to enable the processing and display of HTML forms. * * Drupal uses these functions to achieve consistency in its form processing and * presentation, while simplifying code and reducing the amount of HTML that * must be explicitly generated by modules. * * The drupal_get_form() function handles retrieving, processing, and * displaying a rendered HTML form for modules automatically. For example: * * @code * // Display the user registration form. * $output = drupal_get_form('user_register'); * @endcode * * Forms can also be built and submitted programmatically without any user input * using the drupal_execute() function. * * For information on the format of the structured arrays used to define forms, * and more detailed explanations of the Form API workflow, see the * @link http://api.drupal.org/api/file/developer/topics/forms_api_reference.html reference @endlink * and the @link http://api.drupal.org/api/file/developer/topics/forms_api.html quickstart guide. @endlink *//** * Retrieves a form from a constructor function, or from the cache if * the form was built in a previous page-load. The form is then passed * on for processing, after and rendered for display if necessary. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param ... *   Any additional arguments are passed on to the functions called by *   drupal_get_form(), including the unique form constructor function. *   For example, the node_edit form requires that a node object be passed *   in here when it is called. * @return *   The rendered form. */function drupal_get_form($form_id) {  $form_state = array('storage' => NULL, 'submitted' => FALSE);  $args = func_get_args();  $cacheable = FALSE;  if (isset($_SESSION['batch_form_state'])) {    // We've been redirected here after a batch processing : the form has    // already been processed, so we grab the post-process $form_state value    // and move on to form display. See _batch_finished() function.    $form_state = $_SESSION['batch_form_state'];    unset($_SESSION['batch_form_state']);  }  else {    // If the incoming $_POST contains a form_build_id, we'll check the    // cache for a copy of the form in question. If it's there, we don't    // have to rebuild the form to proceed. In addition, if there is stored    // form_state data from a previous step, we'll retrieve it so it can    // be passed on to the form processing code.    if (isset($_POST['form_id']) && $_POST['form_id'] == $form_id && !empty($_POST['form_build_id'])) {      $form = form_get_cache($_POST['form_build_id'], $form_state);    }    // If the previous bit of code didn't result in a populated $form    // object, we're hitting the form for the first time and we need    // to build it from scratch.    if (!isset($form)) {      $form_state['post'] = $_POST;      // Use a copy of the function's arguments for manipulation      $args_temp = $args;      $args_temp[0] = &$form_state;      array_unshift($args_temp, $form_id);      $form = call_user_func_array('drupal_retrieve_form', $args_temp);      $form_build_id = 'form-'. md5(uniqid(mt_rand(), true));      $form['#build_id'] = $form_build_id;      drupal_prepare_form($form_id, $form, $form_state);      // Store a copy of the unprocessed form for caching and indicate that it      // is cacheable if #cache will be set.      $original_form = $form;      $cacheable = TRUE;      unset($form_state['post']);    }    $form['#post'] = $_POST;    // Now that we know we have a form, we'll process it (validating,    // submitting, and handling the results returned by its submission    // handlers. Submit handlers accumulate data in the form_state by    // altering the $form_state variable, which is passed into them by    // reference.    drupal_process_form($form_id, $form, $form_state);    if ($cacheable && !empty($form['#cache'])) {      // Caching is done past drupal_process_form so #process callbacks can      // set #cache.      form_set_cache($form_build_id, $original_form, $form_state);    }  }  // Most simple, single-step forms will be finished by this point --  // drupal_process_form() usually redirects to another page (or to  // a 'fresh' copy of the form) once processing is complete. If one  // of the form's handlers has set $form_state['redirect'] to FALSE,  // the form will simply be re-rendered with the values still in its  // fields.  //  // If $form_state['storage'] or $form_state['rebuild'] has been set  // and input has been processed, we know that we're in a complex  // multi-part process of some sort and the form's workflow is NOT  // complete. We need to construct a fresh copy of the form, passing  // in the latest $form_state in addition to any other variables passed  // into drupal_get_form().  if ((!empty($form_state['storage']) || !empty($form_state['rebuild'])) && !empty($form_state['process_input']) && !form_get_errors()) {    $form = drupal_rebuild_form($form_id, $form_state, $args);  }  // If we haven't redirected to a new location by now, we want to  // render whatever form array is currently in hand.  return drupal_render_form($form_id, $form);}/** * Retrieves a form, caches it and processes it with an empty $_POST. * * This function clears $_POST and passes the empty $_POST to the form_builder. * To preserve some parts from $_POST, pass them in $form_state. * * If your AHAH callback simulates the pressing of a button, then your AHAH * callback will need to do the same as what drupal_get_form would do when the * button is pressed: get the form from the cache, run drupal_process_form over * it and then if it needs rebuild, run drupal_rebuild_form over it. Then send * back a part of the returned form. * $form_state['clicked_button']['#array_parents'] will help you to find which * part. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param $form_state *   A keyed array containing the current state of the form. Most *   important is the $form_state['storage'] collection. * @param $args *   Any additional arguments are passed on to the functions called by *   drupal_get_form(), plus the original form_state in the beginning. If you *   are getting a form from the cache, use $form['#parameters'] to shift off *   the $form_id from its beginning then the resulting array can be used as *   $arg here. * @param $form_build_id *   If the AHAH callback calling this function only alters part of the form, *   then pass in the existing form_build_id so we can re-cache with the same *   csid. * @return *   The newly built form. */function drupal_rebuild_form($form_id, &$form_state, $args, $form_build_id = NULL) {  // Remove the first argument. This is $form_id.when called from  // drupal_get_form and the original $form_state when called from some AHAH  // callback. Neither is needed. After that, put in the current state.  $args[0] = &$form_state;  // And the form_id.  array_unshift($args, $form_id);  $form = call_user_func_array('drupal_retrieve_form', $args);  if (!isset($form_build_id)) {    // We need a new build_id for the new version of the form.    $form_build_id = 'form-'. md5(mt_rand());  }  $form['#build_id'] = $form_build_id;  drupal_prepare_form($form_id, $form, $form_state);  // Now, we cache the form structure so it can be retrieved later for  // validation. If $form_state['storage'] is populated, we'll also cache  // it so that it can be used to resume complex multi-step processes.  form_set_cache($form_build_id, $form, $form_state);  // Clear out all post data, as we don't want the previous step's  // data to pollute this one and trigger validate/submit handling,  // then process the form for rendering.  $_POST = array();  $form['#post'] = array();  drupal_process_form($form_id, $form, $form_state);  return $form;}/** * Store a form in the cache. */function form_set_cache($form_build_id, $form, $form_state) {  global $user;  // 6 hours cache life time for forms should be plenty.  $expire = 21600;  if ($user->uid) {    $form['#cache_token'] = drupal_get_token();  }  cache_set('form_'. $form_build_id, $form, 'cache_form', time() + $expire);  if (!empty($form_state['storage'])) {    cache_set('storage_'. $form_build_id, $form_state['storage'], 'cache_form', time() + $expire);  }}/** * Fetch a form from cache. */function form_get_cache($form_build_id, &$form_state) {  global $user;  if ($cached = cache_get('form_'. $form_build_id, 'cache_form')) {    $form = $cached->data;    if ((isset($form['#cache_token']) && drupal_valid_token($form['#cache_token'])) || (!isset($form['#cache_token']) && !$user->uid)) {      if ($cached = cache_get('storage_'. $form_build_id, 'cache_form')) {        $form_state['storage'] = $cached->data;      }      return $form;    }  }}/** * Retrieves a form using a form_id, populates it with $form_state['values'], * processes it, and returns any validation errors encountered. This * function is the programmatic counterpart to drupal_get_form(). * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param $form_state *   A keyed array containing the current state of the form. Most *   important is the $form_state['values'] collection, a tree of data *   used to simulate the incoming $_POST information from a user's *   form submission. * @param ... *   Any additional arguments are passed on to the functions called by *   drupal_execute(), including the unique form constructor function. *   For example, the node_edit form requires that a node object be passed *   in here when it is called. * For example: * * @code * // register a new user * $form_state = array(); * $form_state['values']['name'] = 'robo-user'; * $form_state['values']['mail'] = 'robouser@example.com'; * $form_state['values']['pass']['pass1'] = 'password'; * $form_state['values']['pass']['pass2'] = 'password'; * $form_state['values']['op'] = t('Create new account'); * drupal_execute('user_register', $form_state); * * // Create a new node * $form_state = array(); * module_load_include('inc', 'node', 'node.pages'); * $node = array('type' => 'story'); * $form_state['values']['title'] = 'My node'; * $form_state['values']['body'] = 'This is the body text!'; * $form_state['values']['name'] = 'robo-user'; * $form_state['values']['op'] = t('Save'); * drupal_execute('story_node_form', $form_state, (object)$node); * @endcode */function drupal_execute($form_id, &$form_state) {  $args = func_get_args();  // Make sure $form_state is passed around by reference.  $args[1] = &$form_state;    $form = call_user_func_array('drupal_retrieve_form', $args);  $form['#post'] = $form_state['values'];  drupal_prepare_form($form_id, $form, $form_state);  drupal_process_form($form_id, $form, $form_state);}/** * Retrieves the structured array that defines a given form. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. * @param $form_state *   A keyed array containing the current state of the form. * @param ... *   Any additional arguments needed by the unique form constructor *   function. Generally, these are any arguments passed into the *   drupal_get_form() or drupal_execute() functions after the first *   argument. If a module implements hook_forms(), it can examine *   these additional arguments and conditionally return different *   builder functions as well. */function drupal_retrieve_form($form_id, &$form_state) {  static $forms;  // We save two copies of the incoming arguments: one for modules to use  // when mapping form ids to constructor functions, and another to pass to  // the constructor function itself. We shift out the first argument -- the  // $form_id itself -- from the list to pass into the constructor function,  // since it's already known.  $args = func_get_args();  $saved_args = $args;  array_shift($args);  if (isset($form_state)) {    array_shift($args);  }  // We first check to see if there's a function named after the $form_id.  // If there is, we simply pass the arguments on to it to get the form.  if (!function_exists($form_id)) {    // In cases where many form_ids need to share a central constructor function,    // such as the node editing form, modules can implement hook_forms(). It    // maps one or more form_ids to the correct constructor functions.    //    // We cache the results of that hook to save time, but that only works    // for modules that know all their form_ids in advance. (A module that    // adds a small 'rate this comment' form to each comment in a list    // would need a unique form_id for each one, for example.)    //    // So, we call the hook if $forms isn't yet populated, OR if it doesn't    // yet have an entry for the requested form_id.    if (!isset($forms) || !isset($forms[$form_id])) {      $forms = module_invoke_all('forms', $form_id, $args);    }    $form_definition = $forms[$form_id];    if (isset($form_definition['callback arguments'])) {      $args = array_merge($form_definition['callback arguments'], $args);    }    if (isset($form_definition['callback'])) {      $callback = $form_definition['callback'];    }  }  array_unshift($args, NULL);  $args[0] = &$form_state;  // If $callback was returned by a hook_forms() implementation, call it.  // Otherwise, call the function named after the form id.  $form = call_user_func_array(isset($callback) ? $callback : $form_id, $args);  // We store the original function arguments, rather than the final $arg  // value, so that form_alter functions can see what was originally  // passed to drupal_retrieve_form(). This allows the contents of #parameters  // to be saved and passed in at a later date to recreate the form.  $form['#parameters'] = $saved_args;  return $form;}/** * This function is the heart of form API. The form gets built, validated and in * appropriate cases, submitted. * * @param $form_id *   The unique string identifying the current form. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. This *   includes the current persistent storage data for the form, and *   any data passed along by earlier steps when displaying a *   multi-step form. Additional information, like the sanitized $_POST *   data, is also accumulated here. */function drupal_process_form($form_id, &$form, &$form_state) {  $form_state['values'] = array();  $form = form_builder($form_id, $form, $form_state);  // Only process the form if it is programmed or the form_id coming  // from the POST data is set and matches the current form_id.  if ((!empty($form['#programmed'])) || (!empty($form['#post']) && (isset($form['#post']['form_id']) && ($form['#post']['form_id'] == $form_id)))) {    $form_state['process_input'] = TRUE;    drupal_validate_form($form_id, $form, $form_state);    // form_clean_id() maintains a cache of element IDs it has seen,    // so it can prevent duplicates. We want to be sure we reset that    // cache when a form is processed, so scenerios that result in    // the form being built behind the scenes and again for the    // browser don't increment all the element IDs needlessly.    form_clean_id(NULL, TRUE);    if ((!empty($form_state['submitted'])) && !form_get_errors() && empty($form_state['rebuild'])) {      $form_state['redirect'] = NULL;      form_execute_handlers('submit', $form, $form_state);      // We'll clear out the cached copies of the form and its stored data      // here, as we've finished with them. The in-memory copies are still      // here, though.      if (variable_get('cache', CACHE_DISABLED) == CACHE_DISABLED && !empty($form_state['values']['form_build_id'])) {        cache_clear_all('form_'. $form_state['values']['form_build_id'], 'cache_form');        cache_clear_all('storage_'. $form_state['values']['form_build_id'], 'cache_form');      }      // If batches were set in the submit handlers, we process them now,      // possibly ending execution. We make sure we do not react to the batch      // that is already being processed (if a batch operation performs a      // drupal_execute).      if ($batch =& batch_get() && !isset($batch['current_set'])) {        // The batch uses its own copies of $form and $form_state for        // late execution of submit handers and post-batch redirection.        $batch['form'] = $form;        $batch['form_state'] = $form_state;        $batch['progressive'] = !$form['#programmed'];        batch_process();        // Execution continues only for programmatic forms.        // For 'regular' forms, we get redirected to the batch processing        // page. Form redirection will be handled in _batch_finished(),        // after the batch is processed.      }      // If no submit handlers have populated the $form_state['storage']      // bundle, and the $form_state['rebuild'] flag has not been set,      // we're finished and should redirect to a new destination page      // if one has been set (and a fresh, unpopulated copy of the form      // if one hasn't). If the form was called by drupal_execute(),      // however, we'll skip this and let the calling function examine      // the resulting $form_state bundle itself.      if (!$form['#programmed'] && empty($form_state['rebuild']) && empty($form_state['storage'])) {        drupal_redirect_form($form, $form_state['redirect']);      }    }  }}/** * Prepares a structured form array by adding required elements, * executing any hook_form_alter functions, and optionally inserting * a validation token to prevent tampering. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. Passed *   in here so that hook_form_alter() calls can use it, as well. */function drupal_prepare_form($form_id, &$form, &$form_state) {  global $user;  $form['#type'] = 'form';  $form['#programmed'] = isset($form['#post']);  if (isset($form['#build_id'])) {    $form['form_build_id'] = array(      '#type' => 'hidden',      '#value' => $form['#build_id'],      '#id' => $form['#build_id'],      '#name' => 'form_build_id',    );  }  // Add a token, based on either #token or form_id, to any form displayed to  // authenticated users. This ensures that any submitted form was actually  // requested previously by the user and protects against cross site request  // forgeries.  if (isset($form['#token'])) {    if ($form['#token'] === FALSE || $user->uid == 0 || $form['#programmed']) {      unset($form['#token']);    }    else {      $form['form_token'] = array('#type' => 'token', '#default_value' => drupal_get_token($form['#token']));    }  }  else if (isset($user->uid) && $user->uid && !$form['#programmed']) {    $form['#token'] = $form_id;    $form['form_token'] = array(      '#id' => form_clean_id('edit-'. $form_id .'-form-token'),      '#type' => 'token',      '#default_value' => drupal_get_token($form['#token']),    );  }  if (isset($form_id)) {    $form['form_id'] = array(      '#type' => 'hidden',      '#value' => $form_id,      '#id' => form_clean_id("edit-$form_id"),    );  }  if (!isset($form['#id'])) {    $form['#id'] = form_clean_id($form_id);  }  $form += _element_info('form');  if (!isset($form['#validate'])) {    if (function_exists($form_id .'_validate')) {      $form['#validate'] = array($form_id .'_validate');    }  }  if (!isset($form['#submit'])) {    if (function_exists($form_id .'_submit')) {      // We set submit here so that it can be altered.      $form['#submit'] = array($form_id .'_submit');    }  }  // Normally, we would call drupal_alter($form_id, $form, $form_state).  // However, drupal_alter() normally supports just one byref parameter. Using  // the __drupal_alter_by_ref key, we can store any additional parameters  // that need to be altered, and they'll be split out into additional params  // for the hook_form_alter() implementations.  // @todo: Remove this in Drupal 7.  $data = &$form;  $data['__drupal_alter_by_ref'] = array(&$form_state);  drupal_alter('form_'. $form_id, $data);  // __drupal_alter_by_ref is unset in the drupal_alter() function, we need  // to repopulate it to ensure both calls get the data.  $data['__drupal_alter_by_ref'] = array(&$form_state);  drupal_alter('form', $data, $form_id);}/** * Validates user-submitted form data from the $form_state using * the validate functions defined in a structured form array. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. The current *   user-submitted data is stored in $form_state['values'], though *   form validation functions are passed an explicit copy of the *   values for the sake of simplicity. Validation handlers can also *   $form_state to pass information on to submit handlers. For example: *     $form_state['data_for_submision'] = $data; *   This technique is useful when validation requires file parsing, *   web service requests, or other expensive requests that should *   not be repeated in the submission step. */function drupal_validate_form($form_id, $form, &$form_state) {  static $validated_forms = array();  if (isset($validated_forms[$form_id])) {    return;  }  // If the session token was set by drupal_prepare_form(), ensure that it  // matches the current user's session.  if (isset($form['#token'])) {    if (!drupal_valid_token($form_state['values']['form_token'], $form['#token'])) {      // Setting this error will cause the form to fail validation.      form_set_error('form_token', t('Validation error, please try again. If this error persists, please contact the site administrator.'));    }  }  _form_validate($form, $form_state, $form_id);  $validated_forms[$form_id] = TRUE;}/** * Renders a structured form array into themed HTML. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @return *   A string containing the themed HTML. */function drupal_render_form($form_id, &$form) {  // Don't override #theme if someone already set it.  if (!isset($form['#theme'])) {    init_theme();    $registry = theme_get_registry();    if (isset($registry[$form_id])) {      $form['#theme'] = $form_id;    }  }  $output = drupal_render($form);  return $output;}/** * Redirect the user to a URL after a form has been processed. * * @param $form *   An associative array containing the structure of the form. * @param $redirect *   An optional value containing the destination path to redirect *   to if none is specified by the form. */function drupal_redirect_form($form, $redirect = NULL) {  $goto = NULL;  if (isset($redirect)) {    $goto = $redirect;  }  if ($goto !== FALSE && isset($form['#redirect'])) {    $goto = $form['#redirect'];  }  if (!isset($goto) || ($goto !== FALSE)) {    if (isset($goto)) {      if (is_array($goto)) {        call_user_func_array('drupal_goto', $goto);      }      else {        drupal_goto($goto);      }    }    drupal_goto($_GET['q']);  }}/** * Performs validation on form elements. First ensures required fields are * completed, #maxlength is not exceeded, and selected options were in the * list of options given to the user. Then calls user-defined validators. * * @param $elements *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. The current *   user-submitted data is stored in $form_state['values'], though *   form validation functions are passed an explicit copy of the *   values for the sake of simplicity. Validation handlers can also *   $form_state to pass information on to submit handlers. For example: *     $form_state['data_for_submision'] = $data; *   This technique is useful when validation requires file parsing, *   web service requests, or other expensive requests that should *   not be repeated in the submission step. * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. */function _form_validate($elements, &$form_state, $form_id = NULL) {  static $complete_form;  // Also used in the installer, pre-database setup.  $t = get_t();  // Recurse through all children.  foreach (element_children($elements) as $key) {    if (isset($elements[$key]) && $elements[$key]) {      _form_validate($elements[$key], $form_state);    }  }  // Validate the current input.  if (!isset($elements['#validated']) || !$elements['#validated']) {    if (isset($elements['#needs_validation'])) {      // Make sure a value is passed when the field is required.      // A simple call to empty() will not cut it here as some fields, like      // checkboxes, can return a valid value of '0'. Instead, check the      // length if it's a string, and the item count if it's an array.      if ($elements['#required'] && (!count($elements['#value']) || (is_string($elements['#value']) && strlen(trim($elements['#value'])) == 0))) {        form_error($elements, $t('!name field is required.', array('!name' => $elements['#title'])));      }      // Verify that the value is not longer than #maxlength.      if (isset($elements['#maxlength']) && drupal_strlen($elements['#value']) > $elements['#maxlength']) {        form_error($elements, $t('!name cannot be longer than %max characters but is currently %length characters long.', array('!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title'], '%max' => $elements['#maxlength'], '%length' => drupal_strlen($elements['#value']))));      }      if (isset($elements['#options']) && isset($elements['#value'])) {        if ($elements['#type'] == 'select') {          $options = form_options_flatten($elements['#options']);        }        else {          $options = $elements['#options'];        }        if (is_array($elements['#value'])) {          $value = $elements['#type'] == 'checkboxes' ? array_keys(array_filter($elements['#value'])) : $elements['#value'];          foreach ($value as $v) {            if (!isset($options[$v])) {              form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));              watchdog('form', 'Illegal choice %choice in !name element.', array('%choice' => $v, '!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);            }          }        }        elseif (!isset($options[$elements['#value']])) {          form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));          watchdog('form', 'Illegal choice %choice in %name element.', array('%choice' => $elements['#value'], '%name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);        }      }    }    // Call user-defined form level validators and store a copy of the full    // form so that element-specific validators can examine the entire structure    // if necessary.    if (isset($form_id)) {      form_execute_handlers('validate', $elements, $form_state);      $complete_form = $elements;    }    // Call any element-specific validators. These must act on the element    // #value data.    elseif (isset($elements['#element_validate'])) {      foreach ($elements['#element_validate'] as $function) {        if (function_exists($function))  {          $function($elements, $form_state, $complete_form);        }      }    }    $elements['#validated'] = TRUE;  }}/** * A helper function used to execute custom validation and submission * handlers for a given form. Button-specific handlers are checked * first. If none exist, the function falls back to form-level handlers. * * @param $type *   The type of handler to execute. 'validate' or 'submit' are the *   defaults used by Form API. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. If the user *   submitted the form by clicking a button with custom handler functions *   defined, those handlers will be stored here. */function form_execute_handlers($type, &$form, &$form_state) {  $return = FALSE;  if (isset($form_state[$type .'_handlers'])) {    $handlers = $form_state[$type .'_handlers'];  }  elseif (isset($form['#'. $type])) {    $handlers = $form['#'. $type];  }  else {    $handlers = array();  }  foreach ($handlers as $function) {    if (function_exists($function))  {      // Check to see if a previous _submit handler has set a batch, but       // make sure we do not react to a batch that is already being processed       // (for instance if a batch operation performs a drupal_execute()).      if ($type == 'submit' && ($batch =& batch_get()) && !isset($batch['current_set'])) {        // Some previous _submit handler has set a batch. We store the call        // in a special 'control' batch set, for execution at the correct        // time during the batch processing workflow.        $batch['sets'][] = array('form_submit' => $function);      }      else {        $function($form, $form_state);      }      $return = TRUE;    }  }  return $return;}/** * File an error against a form element. * * @param $name *   The name of the form element. If the #parents property of your form *   element is array('foo', 'bar', 'baz') then you may set an error on 'foo' *   or 'foo][bar][baz'. Setting an error on 'foo' sets an error for every *   element where the #parents array starts with 'foo'. * @param $message *   The error message to present to the user. * @param $reset *   Reset the form errors static cache. * @return *   Never use the return value of this function, use form_get_errors and *   form_get_error instead. */function form_set_error($name = NULL, $message = '', $reset = FALSE) {  static $form = array();  if ($reset) {    $form = array();  }  if (isset($name) && !isset($form[$name])) {    $form[$name] = $message;    if ($message) {      drupal_set_message($message, 'error');    }  }  return $form;}/** * Return an associative array of all errors. */function form_get_errors() {  $form = form_set_error();  if (!empty($form)) {    return $form;  }}/** * Return the error message filed against the form with the specified name. */function form_get_error($element) {  $form = form_set_error();  $key = $element['#parents'][0];  if (isset($form[$key])) {    return $form[$key];  }  $key = implode('][', $element['#parents']);  if (isset($form[$key])) {    return $form[$key];  }}/** * Flag an element as having an error. */function form_error(&$element, $message = '') {  form_set_error(implode('][', $element['#parents']), $message);}/** * Walk through the structured form array, adding any required * properties to each element and mapping the incoming $_POST * data to the proper elements. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. In this *   context, it is used to accumulate information about which button *   was clicked when the form was submitted, as well as the sanitized *   $_POST data. */function form_builder($form_id, $form, &$form_state) {  static $complete_form, $cache;  // Initialize as unprocessed.  $form['#processed'] = FALSE;  // Use element defaults.  if ((!empty($form['#type'])) && ($info = _element_info($form['#type']))) {    // Overlay $info onto $form, retaining preexisting keys in $form.    $form += $info;  }  if (isset($form['#type']) && $form['#type'] == 'form') {    $cache = NULL;    $complete_form = $form;    if (!empty($form['#programmed'])) {      $form_state['submitted'] = TRUE;    }  }  if (isset($form['#input']) && $form['#input']) {    _form_builder_handle_input_element($form_id, $form, $form_state, $complete_form);  }  $form['#defaults_loaded'] = TRUE;  // We start off assuming all form elements are in the correct order.  $form['#sorted'] = TRUE;  // Recurse through all child elements.  $count = 0;  foreach (element_children($form) as $key) {    $form[$key]['#post'] = $form['#post'];    $form[$key]['#programmed'] = $form['#programmed'];    // Don't squash an existing tree value.    if (!isset($form[$key]['#tree'])) {      $form[$key]['#tree'] = $form['#tree'];    }    // Deny access to child elements if parent is denied.    if (isset($form['#access']) && !$form['#access']) {      $form[$key]['#access'] = FALSE;    }    // Don't squash existing parents value.    if (!isset($form[$key]['#parents'])) {      // Check to see if a tree of child elements is present. If so,      // continue down the tree if required.      $form[$key]['#parents'] = $form[$key]['#tree'] && $form['#tree'] ? array_merge($form['#parents'], array($key)) : array($key);      $array_parents = isset($form['#array_parents']) ? $form['#array_parents'] : array();      $array_parents[] = $key;      $form[$key]['#array_parents'] = $array_parents;    }    // Assign a decimal placeholder weight to preserve original array order.    if (!isset($form[$key]['#weight'])) {      $form[$key]['#weight'] = $count/1000;    }    else {      // If one of the child elements has a weight then we will need to sort      // later.      unset($form['#sorted']);    }    $form[$key] = form_builder($form_id, $form[$key], $form_state);    $count++;  }  // The #after_build flag allows any piece of a form to be altered  // after normal input parsing has been completed.  if (isset($form['#after_build']) && !isset($form['#after_build_done'])) {    foreach ($form['#after_build'] as $function) {      $form = $function($form, $form_state);      $form['#after_build_done'] = TRUE;    }  }  // Now that we've processed everything, we can go back to handle the funky  // Internet Explorer button-click scenario.  _form_builder_ie_cleanup($form, $form_state);  // We shoud keep the buttons array until the IE clean up function  // has recognized the submit button so the form has been marked  // as submitted. If we already know which button was submitted,  // we don't need the array.  if (!empty($form_state['submitted'])) {    unset($form_state['buttons']);  }  // If some callback set #cache, we need to flip a static flag so later it  // can be found.  if (!empty($form['#cache'])) {    $cache = $form['#cache'];  }  // We are on the top form, we can copy back #cache if it's set.  if (isset($form['#type']) && $form['#type'] == 'form' && isset($cache)) {    $form['#cache'] = TRUE;  }  return $form;}/** * Populate the #value and #name properties of input elements so they * can be processed and rendered. Also, execute any #process handlers * attached to a specific element. */function _form_builder_handle_input_element($form_id, &$form, &$form_state, $complete_form) {  if (!isset($form['#name'])) {    $name = array_shift($form['#parents']);    $form['#name'] = $name;    if ($form['#type'] == 'file') {      // To make it easier to handle $_FILES in file.inc, we place all      // file fields in the 'files' array. Also, we do not support      // nested file names.      $form['#name'] = 'files['. $form['#name'] .']';    }    elseif (count($form['#parents'])) {      $form['#name'] .= '['. implode('][', $form['#parents']) .']';    }    array_unshift($form['#parents'], $name);  }  if (!isset($form['#id'])) {    $form['#id'] = form_clean_id('edit-'. implode('-', $form['#parents']));  }  if (!empty($form['#disabled'])) {    $form['#attributes']['disabled'] = 'disabled';  }  if (!isset($form['#value']) && !array_key_exists('#value', $form)) {    $function = !empty($form['#value_callback']) ? $form['#value_callback'] : 'form_type_'. $form['#type'] .'_value';    if (($form['#programmed']) || ((!isset($form['#access']) || $form['#access']) && isset($form['#post']) && (isset($form['#post']['form_id']) && $form['#post']['form_id'] == $form_id))) {      $edit = $form['#post'];      foreach ($form['#parents'] as $parent) {        $edit = isset($edit[$parent]) ? $edit[$parent] : NULL;      }      if (!$form['#programmed'] || isset($edit)) {        // Call #type_value to set the form value;        if (function_exists($function)) {          $form['#value'] = $function($form, $edit);        }        if (!isset($form['#value']) && isset($edit)) {          $form['#value'] = $edit;        }      }      // Mark all posted values for validation.      if (isset($form['#value']) || (isset($form['#required']) && $form['#required'])) {        $form['#needs_validation'] = TRUE;      }    }    // Load defaults.    if (!isset($form['#value'])) {      // Call #type_value without a second argument to request default_value handling.      if (function_exists($function)) {        $form['#value'] = $function($form);      }      // Final catch. If we haven't set a value yet, use the explicit default value.      // Avoid image buttons (which come with garbage value), so we only get value      // for the button actually clicked.      if (!isset($form['#value']) && empty($form['#has_garbage_value'])) {        $form['#value'] = isset($form['#default_value']) ? $form['#default_value'] : '';      }    }  }  // Determine which button (if any) was clicked to submit the form.  // We compare the incoming values with the buttons defined in the form,  // and flag the one that matches. We have to do some funky tricks to  // deal with Internet Explorer's handling of single-button forms, though.  if (!empty($form['#post']) && isset($form['#executes_submit_callback'])) {    // First, accumulate a collection of buttons, divided into two bins:    // those that execute full submit callbacks and those that only validate.    $button_type = $form['#executes_submit_callback'] ? 'submit' : 'button';    $form_state['buttons'][$button_type][] = $form;    if (_form_button_was_clicked($form)) {      $form_state['submitted'] = $form_state['submitted'] || $form['#executes_submit_callback'];      // In most cases, we want to use form_set_value() to manipulate      // the global variables. In this special case, we want to make sure that      // the value of this element is listed in $form_variables under 'op'.      $form_state['values'][$form['#name']] = $form['#value'];      $form_state['clicked_button'] = $form;      if (isset($form['#validate'])) {        $form_state['validate_handlers'] = $form['#validate'];      }      if (isset($form['#submit'])) {        $form_state['submit_handlers'] = $form['#submit'];      }    }  }  // Allow for elements to expand to multiple elements, e.g., radios,  // checkboxes and files.  if (isset($form['#process']) && !$form['#processed']) {    foreach ($form['#process'] as $process) {      if (function_exists($process)) {        $form = $process($form, isset($edit) ? $edit : NULL, $form_state, $complete_form);      }    }    $form['#processed'] = TRUE;  }  form_set_value($form, $form['#value'], $form_state);}/** * Helper function to handle the sometimes-convoluted logic of button * click detection. * * In Internet Explorer, if ONLY one submit button is present, AND the * enter key is used to submit the form, no form value is sent for it * and we'll never detect a match. That special case is handled by * _form_builder_ie_cleanup(). */function _form_button_was_clicked($form) {  // First detect normal 'vanilla' button clicks. Traditionally, all  // standard buttons on a form share the same name (usually 'op'),  // and the specific return value is used to determine which was  // clicked. This ONLY works as long as $form['#name'] puts the  // value at the top level of the tree of $_POST data.  if (isset($form['#post'][$form['#name']]) && $form['#post'][$form['#name']] == $form['#value']) {    return TRUE;  }  // When image buttons are clicked, browsers do NOT pass the form element  // value in $_POST. Instead they pass an integer representing the  // coordinates of the click on the button image. This means that image  // buttons MUST have unique $form['#name'] values, but the details of  // their $_POST data should be ignored.  elseif (!empty($form['#has_garbage_value']) && isset($form['#value']) && $form['#value'] !== '') {    return TRUE;  }  return FALSE;}/** * In IE, if only one submit button is present, AND the enter key is * used to submit the form, no form value is sent for it and our normal * button detection code will never detect a match. We call this * function after all other button-detection is complete to check * for the proper conditions, and treat the single button on the form * as 'clicked' if they are met. */function _form_builder_ie_cleanup($form, &$form_state) {  // Quick check to make sure we're always looking at the full form  // and not a sub-element.  if (!empty($form['#type']) && $form['#type'] == 'form') {    // If we haven't recognized a submission yet, and there's a single    // submit button, we know that we've hit the right conditions. Grab    // the first one and treat it as the clicked button.    if (empty($form_state['submitted']) && !empty($form_state['buttons']['submit']) && empty($form_state['buttons']['button'])) {      $button = $form_state['buttons']['submit'][0];      // Set up all the $form_state information that would have been      // populated had the button been recognized earlier.      $form_state['submitted'] = TRUE;      $form_state['submit_handlers'] = empty($button['#submit']) ? NULL : $button['#submit'];      $form_state['validate_handlers'] = empty($button['#validate']) ? NULL : $button['#validate'];      $form_state['values'][$button['#name']] = $button['#value'];      $form_state['clicked_button'] = $button;    }  }}/** * Helper function to determine the value for an image button form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_image_button_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (!empty($edit)) {      // If we're dealing with Mozilla or Opera, we're lucky. It will      // return a proper value, and we can get on with things.      return $form['#return_value'];    }    else {      // Unfortunately, in IE we never get back a proper value for THIS      // form element. Instead, we get back two split values: one for the      // X and one for the Y coordinates on which the user clicked the      // button. We'll find this element in the #post data, and search      // in the same spot for its name, with '_x'.      $post = $form['#post'];      foreach (split('\[', $form['#name']) as $element_name) {        // chop off the ] that may exist.        if (substr($element_name, -1) == ']') {          $element_name = substr($element_name, 0, -1);        }        if (!isset($post[$element_name])) {          if (isset($post[$element_name .'_x'])) {            return $form['#return_value'];          }          return NULL;        }        $post = $post[$element_name];      }      return $form['#return_value'];    }  }}/** * Helper function to determine the value for a checkbox form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_checkbox_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (empty($form['#disabled'])) {      return !empty($edit) ? $form['#return_value'] : 0;    }    else {      return $form['#default_value'];    }  }}/** * Helper function to determine the value for a checkboxes form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_checkboxes_value($form, $edit = FALSE) {  if ($edit === FALSE) {    $value = array();    $form += array('#default_value' => array());    foreach ($form['#default_value'] as $key) {      $value[$key] = 1;    }    return $value;  }  elseif (!isset($edit)) {    return array();  }}/** * Helper function to determine the value for a password_confirm form * element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_password_confirm_value($form, $edit = FALSE) {  if ($edit === FALSE) {    $form += array('#default_value' => array());    return $form['#default_value'] + array('pass1' => '', 'pass2' => '');  }}/** * Helper function to determine the value for a select form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_select_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (isset($form['#multiple']) && $form['#multiple']) {      return (is_array($edit)) ? drupal_map_assoc($edit) : array();    }    else {      return $edit;    }  }}/** * Helper function to determine the value for a textfield form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_textfield_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    // Equate $edit to the form value to ensure it's marked for    // validation.    return str_replace(array("\r", "\n"), '', $edit);  }}/** * Helper function to determine the value for form's token value. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_token_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    return (string)$edit;  }}/** * Change submitted form values during the form processing cycle. * * Use this function to change the submitted value of a form item in the * validation phase so that it persists in $form_state through to the * submission handlers in the submission phase. * * Since $form_state['values'] can either be a flat array of values, or a tree * of nested values, some care must be taken when using this function. * Specifically, $form_item['#parents'] is an array that describes the branch of * the tree whose value should be updated. For example, if we wanted to update * $form_state['values']['one']['two'] to 'new value', we'd pass in * $form_item['#parents'] = array('one', 'two') and $value = 'new value'. * * @param $form_item *   The form item that should have its value updated. Keys used: #parents, *   #value. In most cases you can just pass in the right element from the $form *   array. * @param $value *   The new value for the form item. * @param $form_state *   The array where the value change should be recorded. */function form_set_value($form_item, $value, &$form_state) {  _form_set_value($form_state['values'], $form_item, $form_item['#parents'], $value);}/** * Helper function for form_set_value(). * * We iterate over $parents and create nested arrays for them * in $form_state['values'] if needed. Then we insert the value into * the right array. */function _form_set_value(&$form_values, $form_item, $parents, $value) {  $parent = array_shift($parents);  if (empty($parents)) {    $form_values[$parent] = $value;  }  else {    if (!isset($form_values[$parent])) {      $form_values[$parent] = array();    }    _form_set_value($form_values[$parent], $form_item, $parents, $value);  }}/** * Retrieve the default properties for the defined element type. */function _element_info($type, $refresh = NULL) {  static $cache;  $basic_defaults = array(    '#description' => NULL,    '#attributes' => array(),    '#required' => FALSE,    '#tree' => FALSE,    '#parents' => array()  );  if (!isset($cache) || $refresh) {    $cache = array();    foreach (module_implements('elements') as $module) {      $elements = module_invoke($module, 'elements');      if (isset($elements) && is_array($elements)) {        $cache = array_merge_recursive($cache, $elements);      }    }    if (sizeof($cache)) {      foreach ($cache as $element_type => $info) {        $cache[$element_type] = array_merge_recursive($basic_defaults, $info);      }    }  }  return $cache[$type];}function form_options_flatten($array, $reset = TRUE) {  static $return;  if ($reset) {    $return = array();  }  foreach ($array as $key => $value) {    if (is_object($value)) {      form_options_flatten($value->option, FALSE);    }    else if (is_array($value)) {      form_options_flatten($value, FALSE);    }    else {      $return[$key] = 1;    }  }  return $return;}/** * Format a dropdown menu or scrolling selection box. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, extra, multiple, required * @return *   A themed HTML string representing the form element. * * @ingroup themeable * * It is possible to group options together; to do this, change the format of * $options to an associative array in which the keys are group labels, and the * values are associative arrays in the normal $options format. */function theme_select($element) {  $select = '';  $size = $element['#size'] ? ' size="'. $element['#size'] .'"' : '';  _form_set_class($element, array('form-select'));  $multiple = $element['#multiple'];  return theme('form_element', $element, '<select name="'. $element['#name'] .''. ($multiple ? '[]' : '') .'"'. ($multiple ? ' multiple="multiple" ' : '') . drupal_attributes($element['#attributes']) .' id="'. $element['#id'] .'" '. $size .'>'. form_select_options($element) .'</select>');}function form_select_options($element, $choices = NULL) {  if (!isset($choices)) {    $choices = $element['#options'];  }  // array_key_exists() accommodates the rare event where $element['#value'] is NULL.  // isset() fails in this situation.  $value_valid = isset($element['#value']) || array_key_exists('#value', $element);  $value_is_array = is_array($element['#value']);  $options = '';  foreach ($choices as $key => $choice) {    if (is_array($choice)) {      $options .= '<optgroup label="'. $key .'">';      $options .= form_select_options($element, $choice);      $options .= '</optgroup>';    }    elseif (is_object($choice)) {      $options .= form_select_options($element, $choice->option);    }    else {      $key = (string)$key;      if ($value_valid && (!$value_is_array && (string)$element['#value'] === $key || ($value_is_array && in_array($key, $element['#value'])))) {        $selected = ' selected="selected"';      }      else {        $selected = '';      }      $options .= '<option value="'. check_plain($key) .'"'. $selected .'>'. check_plain($choice) .'</option>';    }  }  return $options;}/** * Traverses a select element's #option array looking for any values * that hold the given key. Returns an array of indexes that match. * * This function is useful if you need to modify the options that are * already in a form element; for example, to remove choices which are * not valid because of additional filters imposed by another module. * One example might be altering the choices in a taxonomy selector. * To correctly handle the case of a multiple hierarchy taxonomy, * #options arrays can now hold an array of objects, instead of a * direct mapping of keys to labels, so that multiple choices in the * selector can have the same key (and label). This makes it difficult * to manipulate directly, which is why this helper function exists. * * This function does not support optgroups (when the elements of the * #options array are themselves arrays), and will return FALSE if * arrays are found. The caller must either flatten/restore or * manually do their manipulations in this case, since returning the * index is not sufficient, and supporting this would make the * "helper" too complicated and cumbersome to be of any help. * * As usual with functions that can return array() or FALSE, do not * forget to use === and !== if needed. * * @param $element *   The select element to search. * @param $key *   The key to look for. * @return *   An array of indexes that match the given $key. Array will be *   empty if no elements were found. FALSE if optgroups were found. */function form_get_options($element, $key) {  $keys = array();  foreach ($element['#options'] as $index => $choice) {    if (is_array($choice)) {      return FALSE;    }    else if (is_object($choice)) {      if (isset($choice->option[$key])) {        $keys[] = $index;      }    }    else if ($index == $key) {      $keys[] = $index;    }  }  return $keys;}/** * Format a group of form items. * * @param $element *   An associative array containing the properties of the element. *   Properties used: attributes, title, value, description, children, collapsible, collapsed * @return *   A themed HTML string representing the form item group. * * @ingroup themeable */function theme_fieldset($element) {  if (!empty($element['#collapsible'])) {    drupal_add_js('misc/collapse.js');    if (!isset($element['#attributes']['class'])) {      $element['#attributes']['class'] = '';    }    $element['#attributes']['class'] .= ' collapsible';    if (!empty($element['#collapsed'])) {      $element['#attributes']['class'] .= ' collapsed';    }  }  return '<fieldset'. drupal_attributes($element['#attributes']) .'>'. ($element['#title'] ? '<legend>'. $element['#title'] .'</legend>' : '') . (isset($element['#description']) && $element['#description'] ? '<div class="description">'. $element['#description'] .'</div>' : '') . (!empty($element['#children']) ? $element['#children'] : '') . (isset($element['#value']) ? $element['#value'] : '') ."</fieldset>\n";}/** * Format a radio button. * * @param $element *   An associative array containing the properties of the element. *   Properties used: required, return_value, value, attributes, title, description * @return *   A themed HTML string representing the form item group. * * @ingroup themeable */function theme_radio($element) {  _form_set_class($element, array('form-radio'));  $output = '<input type="radio" ';  $output .= 'id="'. $element['#id'] .'" ';  $output .= 'name="'. $element['#name'] .'" ';  $output .= 'value="'. $element['#return_value'] .'" ';  $output .= (check_plain($element['#value']) == $element['#return_value']) ? ' checked="checked" ' : ' ';  $output .= drupal_attributes($element['#attributes']) .' />';  if (!is_null($element['#title'])) {    $output = '<label class="option" for="'. $element['#id'] .'">'. $output .' '. $element['#title'] .'</label>';  }  unset($element['#title']);  return theme('form_element', $element, $output);}/** * Format a set of radio buttons. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, required and attributes. * @return *   A themed HTML string representing the radio button set. * * @ingroup themeable */function theme_radios($element) {  $class = 'form-radios';  if (isset($element['#attributes']['class'])) {    $class .= ' '. $element['#attributes']['class'];  }  $element['#children'] = '<div class="'. $class .'">'. (!empty($element['#children']) ? $element['#children'] : '') .'</div>';  if ($element['#title'] || $element['#description']) {    unset($element['#id']);    return theme('form_element', $element, $element['#children']);  }  else {    return $element['#children'];  }}/** * Format a password_confirm item. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, id, required, error. * @return *   A themed HTML string representing the form item. * * @ingroup themeable */function theme_password_confirm($element) {  return theme('form_element', $element, $element['#children']);}/** * Expand a password_confirm field into two text boxes. */function expand_password_confirm($element) {  $element['pass1'] =  array(    '#type' => 'password',    '#title' => t('Password'),    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass1'],    '#required' => $element['#required'],    '#attributes' => array('class' => 'password-field'),  );  $element['pass2'] =  array(    '#type' => 'password',    '#title' => t('Confirm password'),    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass2'],    '#required' => $element['#required'],    '#attributes' => array('class' => 'password-confirm'),  );  $element['#element_validate'] = array('password_confirm_validate');  $element['#tree'] = TRUE;  if (isset($element['#size'])) {    $element['pass1']['#size'] = $element['pass2']['#size'] = $element['#size'];  }  return $element;}/** * Validate password_confirm element. */function password_confirm_validate($form, &$form_state) {  $pass1 = trim($form['pass1']['#value']);  if (!empty($pass1)) {    $pass2 = trim($form['pass2']['#value']);    if (strcmp($pass1, $pass2)) {      form_error($form, t('The specified passwords do not match.'));    }  }  elseif ($form['#required'] && !empty($form['#post'])) {    form_error($form, t('Password field is required.'));  }  // Password field must be converted from a two-element array into a single  // string regardless of validation results.  form_set_value($form['pass1'], NULL, $form_state);  form_set_value($form['pass2'], NULL, $form_state);  form_set_value($form, $pass1, $form_state);  return $form;}/** * Format a date selection element. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, required and attributes. * @return *   A themed HTML string representing the date selection boxes. * * @ingroup themeable */function theme_date($element) {  return theme('form_element', $element, '<div class="container-inline">'. $element['#children'] .'</div>');}/** * Roll out a single date element. */function expand_date($element) {  // Default to current date  if (empty($element['#value'])) {    $element['#value'] = array('day' => format_date(time(), 'custom', 'j'),                            'month' => format_date(time(), 'custom', 'n'),                            'year' => format_date(time(), 'custom', 'Y'));  }  $element['#tree'] = TRUE;  // Determine the order of day, month, year in the site's chosen date format.  $format = variable_get('date_format_short', 'm/d/Y - H:i');  $sort = array();  $sort['day'] = max(strpos($format, 'd'), strpos($format, 'j'));  $sort['month'] = max(strpos($format, 'm'), strpos($format, 'M'));  $sort['year'] = strpos($format, 'Y');  asort($sort);  $order = array_keys($sort);  // Output multi-selector for date.  foreach ($order as $type) {    switch ($type) {      case 'day':        $options = drupal_map_assoc(range(1, 31));        break;      case 'month':        $options = drupal_map_assoc(range(1, 12), 'map_month');        break;      case 'year':        $options = drupal_map_assoc(range(1900, 2050));        break;    }    $parents = $element['#parents'];    $parents[] = $type;    $element[$type] = array(      '#type' => 'select',      '#value' => $element['#value'][$type],      '#attributes' => $element['#attributes'],      '#options' => $options,    );  }  return $element;}/** * Validates the date type to stop dates like February 30, 2006. */function date_validate($form) {  if (!checkdate($form['#value']['month'], $form['#value']['day'], $form['#value']['year'])) {    form_error($form, t('The specified date is invalid.'));  }}/** * Helper function for usage with drupal_map_assoc to display month names. */function map_month($month) {  return format_date(gmmktime(0, 0, 0, $month, 2, 1970), 'custom', 'M', 0);}/** * If no default value is set for weight select boxes, use 0. */function weight_value(&$form) {  if (isset($form['#default_value'])) {    $form['#value'] = $form['#default_value'];  }  else {    $form['#value'] = 0;  }}/** * Roll out a single radios element to a list of radios, * using the options array as index. */function expand_radios($element) {  if (count($element['#options']) > 0) {    foreach ($element['#options'] as $key => $choice) {      if (!isset($element[$key])) {        // Generate the parents as the autogenerator does, so we will have a        // unique id for each radio button.        $parents_for_id = array_merge($element['#parents'], array($key));        $element[$key] = array(          '#type' => 'radio',          '#title' => $choice,          '#return_value' => check_plain($key),          '#default_value' => isset($element['#default_value']) ? $element['#default_value'] : NULL,          '#attributes' => $element['#attributes'],          '#parents' => $element['#parents'],          '#id' => form_clean_id('edit-'. implode('-', $parents_for_id)),          '#ahah' => isset($element['#ahah']) ? $element['#ahah'] : NULL,        );      }    }  }  return $element;}/** * Add AHAH information about a form element to the page to communicate with * javascript. If #ahah[path] is set on an element, this additional javascript is * added to the page header to attach the AHAH behaviors. See ahah.js for more * information. * * @param $element *   An associative array containing the properties of the element. *   Properties used: ahah_event, ahah_path, ahah_wrapper, ahah_parameters, *   ahah_effect. * @return *   None. Additional code is added to the header of the page using *   drupal_add_js. */function form_expand_ahah($element) {  static $js_added = array();  // Add a reasonable default event handler if none specified.  if (isset($element['#ahah']['path']) && !isset($element['#ahah']['event'])) {    switch ($element['#type']) {      case 'submit':      case 'button':      case 'image_button':        // Use the mousedown instead of the click event because form        // submission via pressing the enter key triggers a click event on        // submit inputs, inappropriately triggering AHAH behaviors.        $element['#ahah']['event'] = 'mousedown';        // Attach an additional event handler so that AHAH behaviours        // can be triggered still via keyboard input.        $element['#ahah']['keypress'] = TRUE;        break;      case 'password':      case 'textfield':      case 'textarea':        $element['#ahah']['event'] = 'blur';        break;      case 'radio':      case 'checkbox':      case 'select':        $element['#ahah']['event'] = 'change';        break;    }  }  // Adding the same javascript settings twice will cause a recursion error,  // we avoid the problem by checking if the javascript has already been added.  if (isset($element['#ahah']['path']) && isset($element['#ahah']['event']) && !isset($js_added[$element['#id']])) {    drupal_add_js('misc/jquery.form.js');    drupal_add_js('misc/ahah.js');    $ahah_binding = array(      'url'      => url($element['#ahah']['path']),      'event'    => $element['#ahah']['event'],      'keypress' => empty($element['#ahah']['keypress']) ? NULL : $element['#ahah']['keypress'],      'wrapper'  => empty($element['#ahah']['wrapper']) ? NULL : $element['#ahah']['wrapper'],      'selector' => empty($element['#ahah']['selector']) ? '#'. $element['#id'] : $element['#ahah']['selector'],      'effect'   => empty($element['#ahah']['effect']) ? 'none' : $element['#ahah']['effect'],      'method'   => empty($element['#ahah']['method']) ? 'replace' : $element['#ahah']['method'],      'progress' => empty($element['#ahah']['progress']) ? array('type' => 'throbber') : $element['#ahah']['progress'],      'button'   => isset($element['#executes_submit_callback']) ? array($element['#name'] => $element['#value']) : FALSE,    );    // Convert a simple #ahah[progress] type string into an array.    if (is_string($ahah_binding['progress'])) {      $ahah_binding['progress'] = array('type' => $ahah_binding['progress']);    }    // Change progress path to a full url.    if (isset($ahah_binding['progress']['path'])) {      $ahah_binding['progress']['url'] = url($ahah_binding['progress']['path']);    }    // Add progress.js if we're doing a bar display.    if ($ahah_binding['progress']['type'] == 'bar') {      drupal_add_js('misc/progress.js');    }    drupal_add_js(array('ahah' => array($element['#id'] => $ahah_binding)), 'setting');    $js_added[$element['#id']] = TRUE;    $element['#cache'] = TRUE;  }  return $element;}/** * Format a form item. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, required, error * @return *   A themed HTML string representing the form item. * * @ingroup themeable */function theme_item($element) {  return theme('form_element', $element, $element['#value'] . (!empty($element['#children']) ? $element['#children'] : ''));}/** * Format a checkbox. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, return_value, description, required * @return *   A themed HTML string representing the checkbox. * * @ingroup themeable */function theme_checkbox($element) {  _form_set_class($element, array('form-checkbox'));  $checkbox = '<input ';  $checkbox .= 'type="checkbox" ';  $checkbox .= 'name="'. $element['#name'] .'" ';  $checkbox .= 'id="'. $element['#id'] .'" ' ;  $checkbox .= 'value="'. $element['#return_value'] .'" ';  $checkbox .= $element['#value'] ? ' checked="checked" ' : ' ';  $checkbox .= drupal_attributes($element['#attributes']) .' />';  if (!is_null($element['#title'])) {    $checkbox = '<label class="option" for="'. $element['#id'] .'">'. $checkbox .' '. $element['#title'] .'</label>';  }  unset($element['#title']);  return theme('form_element', $element, $checkbox);}/** * Format a set of checkboxes. * * @param $element *   An associative array containing the properties of the element. * @return *   A themed HTML string representing the checkbox set. * * @ingroup themeable */function theme_checkboxes($element) {  $class = 'form-checkboxes';  if (isset($element['#attributes']['class'])) {    $class .= ' '. $element['#attributes']['class'];  }  $element['#children'] = '<div class="'. $class .'">'. (!empty($element['#children']) ? $element['#children'] : '') .'</div>';  if ($element['#title'] || $element['#description']) {    unset($element['#id']);    return theme('form_element', $element, $element['#children']);  }  else {    return $element['#children'];  }}function expand_checkboxes($element) {  $value = is_array($element['#value']) ? $element['#value'] : array();  $element['#tree'] = TRUE;  if (count($element['#options']) > 0) {    if (!isset($element['#default_value']) || $element['#default_value'] == 0) {      $element['#default_value'] = array();    }    foreach ($element['#options'] as $key => $choice) {      if (!isset($element[$key])) {        $element[$key] = array(          '#type' => 'checkbox',          '#processed' => TRUE,          '#title' => $choice,          '#return_value' => $key,          '#default_value' => isset($value[$key]),          '#attributes' => $element['#attributes'],          '#ahah' => isset($element['#ahah']) ? $element['#ahah'] : NULL,        );      }    }  }  return $element;}/** * Theme a form submit button. * * @ingroup themeable */function theme_submit($element) {  return theme('button', $element);}/** * Theme a form button. * * @ingroup themeable */function theme_button($element) {  // Make sure not to overwrite classes.  if (isset($element['#attributes']['class'])) {    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];  }  else {    $element['#attributes']['class'] = 'form-'. $element['#button_type'];  }  return '<input type="submit" '. (empty($element['#name']) ? '' : 'name="'. $element['#name'] .'" ') .'id="'. $element['#id'] .'" value="'. check_plain($element['#value']) .'" '. drupal_attributes($element['#attributes']) ." />\n";}/** * Theme a form image button. * * @ingroup themeable */function theme_image_button($element) {  // Make sure not to overwrite classes.  if (isset($element['#attributes']['class'])) {    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];  }  else {    $element['#attributes']['class'] = 'form-'. $element['#button_type'];  }  return '<input type="image" name="'. $element['#name'] .'" '.    (!empty($element['#value']) ? ('value="'. check_plain($element['#value']) .'" ') : '') .    'id="'. $element['#id'] .'" '.    drupal_attributes($element['#attributes']) .    ' src="'. base_path() . $element['#src'] .'" '.    (!empty($element['#title']) ? 'alt="'. check_plain($element['#title']) .'" title="'. check_plain($element['#title']) .'" ' : '' ) .    "/>\n";}/** * Format a hidden form field. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  value, edit * @return *   A themed HTML string representing the hidden form field. * * @ingroup themeable */function theme_hidden($element) {  return '<input type="hidden" name="'. $element['#name'] .'" id="'. $element['#id'] .'" value="'. check_plain($element['#value']) ."\" ". drupal_attributes($element['#attributes']) ." />\n";}/** * Format a form token. * * @ingroup themeable */function theme_token($element) {  return theme('hidden', $element);}/** * Format a textfield. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, size, maxlength, required, attributes autocomplete_path * @return *   A themed HTML string representing the textfield. * * @ingroup themeable */function theme_textfield($element) {  $size = empty($element['#size']) ? '' : ' size="'. $element['#size'] .'"';  $maxlength = empty($element['#maxlength']) ? '' : ' maxlength="'. $element['#maxlength'] .'"';  $class = array('form-text');  $extra = '';  $output = '';  if ($element['#autocomplete_path'] && menu_valid_path(array('link_path' => $element['#autocomplete_path']))) {    drupal_add_js('misc/autocomplete.js');    $class[] = 'form-autocomplete';    $extra =  '<input class="autocomplete" type="hidden" id="'. $element['#id'] .'-autocomplete" value="'. check_url(url($element['#autocomplete_path'], array('absolute' => TRUE))) .'" disabled="disabled" />';  }  _form_set_class($element, $class);  if (isset($element['#field_prefix'])) {    $output .= '<span class="field-prefix">'. $element['#field_prefix'] .'</span> ';  }  $output .= '<input type="text"'. $maxlength .' name="'. $element['#name'] .'" id="'. $element['#id'] .'"'. $size .' value="'. check_plain($element['#value']) .'"'. drupal_attributes($element['#attributes']) .' />';  if (isset($element['#field_suffix'])) {    $output .= ' <span class="field-suffix">'. $element['#field_suffix'] .'</span>';  }  return theme('form_element', $element, $output) . $extra;}/** * Format a form. * * @param $element *   An associative array containing the properties of the element. *   Properties used: action, method, attributes, children * @return *   A themed HTML string representing the form. * * @ingroup themeable */function theme_form($element) {  // Anonymous div to satisfy XHTML compliance.  $action = $element['#action'] ? 'action="'. check_url($element['#action']) .'" ' : '';  return '<form '. $action .' accept-charset="UTF-8" method="'. $element['#method'] .'" id="'. $element['#id'] .'"'. drupal_attributes($element['#attributes']) .">\n<div>". $element['#children'] ."\n</div></form>\n";}/** * Format a textarea. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, description, rows, cols, required, attributes * @return *   A themed HTML string representing the textarea. * * @ingroup themeable */function theme_textarea($element) {  $class = array('form-textarea');  // Add teaser behavior (must come before resizable)  if (!empty($element['#teaser'])) {    drupal_add_js('misc/teaser.js');    // Note: arrays are merged in drupal_get_js().    drupal_add_js(array('teaserCheckbox' => array($element['#id'] => $element['#teaser_checkbox'])), 'setting');    drupal_add_js(array('teaser' => array($element['#id'] => $element['#teaser'])), 'setting');    $class[] = 'teaser';  }  // Add resizable behavior  if ($element['#resizable'] !== FALSE) {    drupal_add_js('misc/textarea.js');    $class[] = 'resizable';  }  _form_set_class($element, $class);  return theme('form_element', $element, '<textarea cols="'. $element['#cols'] .'" rows="'. $element['#rows'] .'" name="'. $element['#name'] .'" id="'. $element['#id'] .'" '. drupal_attributes($element['#attributes']) .'>'. check_plain($element['#value']) .'</textarea>');}/** * Format HTML markup for use in forms. * * This is used in more advanced forms, such as theme selection and filter format. * * @param $element *   An associative array containing the properties of the element. *   Properties used: value, children. * @return *   A themed HTML string representing the HTML markup. * * @ingroup themeable */function theme_markup($element) {  return (isset($element['#value']) ? $element['#value'] : '') . (isset($element['#children']) ? $element['#children'] : '');}/** * Format a password field. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, size, maxlength, required, attributes * @return *   A themed HTML string representing the form. * * @ingroup themeable */function theme_password($element) {  $size = $element['#size'] ? ' size="'. $element['#size'] .'" ' : '';  $maxlength = $element['#maxlength'] ? ' maxlength="'. $element['#maxlength'] .'" ' : '';  _form_set_class($element, array('form-text'));  $output = '<input type="password" name="'. $element['#name'] .'" id="'. $element['#id'] .'" '. $maxlength . $size . drupal_attributes($element['#attributes']) .' />';  return theme('form_element', $element, $output);}/** * Expand weight elements into selects. */function process_weight($element) {  for ($n = (-1 * $element['#delta']); $n <= $element['#delta']; $n++) {    $weights[$n] = $n;  }  $element['#options'] = $weights;  $element['#type'] = 'select';  $element['#is_weight'] = TRUE;  $element += _element_info('select');  return $element;}/** * Format a file upload field. * * @param $title *   The label for the file upload field. * @param $name *   The internal name used to refer to the field. * @param $size *   A measure of the visible size of the field (passed directly to HTML). * @param $description *   Explanatory text to display after the form item. * @param $required *   Whether the user must upload a file to the field. * @return *   A themed HTML string representing the field. * * @ingroup themeable * * For assistance with handling the uploaded file correctly, see the API * provided by file.inc. */function theme_file($element) {  _form_set_class($element, array('form-file'));  return theme('form_element', $element, '<input type="file" name="'. $element['#name'] .'"'. ($element['#attributes'] ? ' '. drupal_attributes($element['#attributes']) : '') .' id="'. $element['#id'] .'" size="'. $element['#size'] ."\" />\n");}/** * Return a themed form element. * * @param element *   An associative array containing the properties of the element. *   Properties used: title, description, id, required * @param $value *   The form element's data. * @return *   A string representing the form element. * * @ingroup themeable */function theme_form_element($element, $value) {  // This is also used in the installer, pre-database setup.  $t = get_t();  $output = '<div class="form-item"';  if (!empty($element['#id'])) {    $output .= ' id="'. $element['#id'] .'-wrapper"';  }  $output .= ">\n";  $required = !empty($element['#required']) ? '<span class="form-required" title="'. $t('This field is required.') .'">*</span>' : '';  if (!empty($element['#title'])) {    $title = $element['#title'];    if (!empty($element['#id'])) {      $output .= ' <label for="'. $element['#id'] .'">'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";    }    else {      $output .= ' <label>'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";    }  }  $output .= " $value\n";  if (!empty($element['#description'])) {    $output .= ' <div class="description">'. $element['#description'] ."</div>\n";  }  $output .= "</div>\n";  return $output;}/** * Sets a form element's class attribute. * * Adds 'required' and 'error' classes as needed. * * @param &$element *   The form element. * @param $name *   Array of new class names to be added. */function _form_set_class(&$element, $class = array()) {  if ($element['#required']) {    $class[] = 'required';  }  if (form_get_error($element)) {    $class[] = 'error';  }  if (isset($element['#attributes']['class'])) {    $class[] = $element['#attributes']['class'];  }  $element['#attributes']['class'] = implode(' ', $class);}/** * Prepare an HTML ID attribute string for a form item. * * Remove invalid characters and guarantee uniqueness. * * @param $id *   The ID to clean. * @param $flush *   If set to TRUE, the function will flush and reset the static array *   which is built to test the uniqueness of element IDs. This is only *   used if a form has completed the validation process. This parameter *   should never be set to TRUE if this function is being called to *   assign an ID to the #ID element. * @return *   The cleaned ID. */function form_clean_id($id = NULL, $flush = FALSE) {  static $seen_ids = array();  if ($flush) {    $seen_ids = array();    return;  }  $id = str_replace(array('][', '_', ' '), '-', $id);  // Ensure IDs are unique. The first occurrence is held but left alone.  // Subsequent occurrences get a number appended to them. This incrementing  // will almost certainly break code that relies on explicit HTML IDs in  // forms that appear more than once on the page, but the alternative is  // outputting duplicate IDs, which would break JS code and XHTML  // validity anyways. For now, it's an acceptable stopgap solution.  if (isset($seen_ids[$id])) {    $id = $id .'-'. $seen_ids[$id]++;  }  else {    $seen_ids[$id] = 1;  }  return $id;}/** * @} End of "defgroup form_api". *//** * @defgroup batch Batch operations * @{ * Functions allowing forms processing to be spread out over several page * requests, thus ensuring that the processing does not get interrupted * because of a PHP timeout, while allowing the user to receive feedback * on the progress of the ongoing operations. * * The API is primarily designed to integrate nicely with the Form API * workflow, but can also be used by non-FAPI scripts (like update.php) * or even simple page callbacks (which should probably be used sparingly). * * Example: * @code * $batch = array( *   'title' => t('Exporting'), *   'operations' => array( *     array('my_function_1', array($account->uid, 'story')), *     array('my_function_2', array()), *   ), *   'finished' => 'my_finished_callback', *   'file' => 'path_to_file_containing_myfunctions', * ); * batch_set($batch); * // only needed if not inside a form _submit handler : * batch_process(); * @endcode * * Note: if the batch 'title', 'init_message', 'progress_message', or * 'error_message' could contain any user input, it is the responsibility of * the code calling batch_set() to sanitize them first with a function like * check_plain() or filter_xss(). * * Sample batch operations: * @code * // Simple and artificial: load a node of a given type for a given user * function my_function_1($uid, $type, &$context) { *   // The $context array gathers batch context information about the execution (read), *   // as well as 'return values' for the current operation (write) *   // The following keys are provided : *   // 'results' (read / write): The array of results gathered so far by *   //   the batch processing, for the current operation to append its own. *   // 'message' (write): A text message displayed in the progress page. *   // The following keys allow for multi-step operations : *   // 'sandbox' (read / write): An array that can be freely used to *   //   store persistent data between iterations. It is recommended to *   //   use this instead of $_SESSION, which is unsafe if the user *   //   continues browsing in a separate window while the batch is processing. *   // 'finished' (write): A float number between 0 and 1 informing *   //   the processing engine of the completion level for the operation. *   //   1 (or no value explicitly set) means the operation is finished *   //   and the batch processing can continue to the next operation. * *   $node = node_load(array('uid' => $uid, 'type' => $type)); *   $context['results'][] = $node->nid .' : '. $node->title; *   $context['message'] = $node->title; * } * * // More advanced example: multi-step operation - load all nodes, five by five * function my_function_2(&$context) { *   if (empty($context['sandbox'])) { *     $context['sandbox']['progress'] = 0; *     $context['sandbox']['current_node'] = 0; *     $context['sandbox']['max'] = db_result(db_query('SELECT COUNT(DISTINCT nid) FROM {node}')); *   } *   $limit = 5; *   $result = db_query_range("SELECT nid FROM {node} WHERE nid > %d ORDER BY nid ASC", $context['sandbox']['current_node'], 0, $limit); *   while ($row = db_fetch_array($result)) { *     $node = node_load($row['nid'], NULL, TRUE); *     $context['results'][] = $node->nid .' : '. $node->title; *     $context['sandbox']['progress']++; *     $context['sandbox']['current_node'] = $node->nid; *     $context['message'] = $node->title; *   } *   if ($context['sandbox']['progress'] != $context['sandbox']['max']) { *     $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max']; *   } * } * @endcode * * Sample 'finished' callback: * @code * function batch_test_finished($success, $results, $operations) { *   if ($success) { *     $message = format_plural(count($results), 'One post processed.', '@count posts processed.'); *   } *   else { *     $message = t('Finished with an error.'); *   } *   drupal_set_message($message); *   // Providing data for the redirected page is done through $_SESSION. *   foreach ($results as $result) { *     $items[] = t('Loaded node %title.', array('%title' => $result)); *   } *   $_SESSION['my_batch_results'] = $items; * } * @endcode *//** * Opens a new batch. * * @param $batch *   An array defining the batch. The following keys can be used -- only *   'operations' is required, and batch_init() provides default values for *   the messages. *   - 'operations': Array of function calls to be performed. *     Example: *     @code *     array( *       array('my_function_1', array($arg1)), *       array('my_function_2', array($arg2_1, $arg2_2)), *     ) *     @endcode *   - 'title': Title for the progress page. Only safe strings should be passed. *     Defaults to t('Processing'). *   - 'init_message': Message displayed while the processing is initialized. *     Defaults to t('Initializing.'). *   - 'progress_message': Message displayed while processing the batch. *     Available placeholders are @current, @remaining, @total, @percentage, *     @estimate and @elapsed. Defaults to t('Completed @current of @total.'). *   - 'error_message': Message displayed if an error occurred while processing *     the batch. Defaults to t('An error has occurred.'). *   - 'finished': Name of a function to be executed after the batch has *     completed. This should be used to perform any result massaging that *     may be needed, and possibly save data in $_SESSION for display after *     final page redirection. *   - 'file': Path to the file containing the definitions of the *     'operations' and 'finished' functions, for instance if they don't *     reside in the main .module file. The path should be relative to *     base_path(), and thus should be built using drupal_get_path(). * * Operations are added as new batch sets. Batch sets are used to ensure * clean code independence, ensuring that several batches submitted by * different parts of the code (core / contrib modules) can be processed * correctly while not interfering or having to cope with each other. Each * batch set gets to specify his own UI messages, operates on its own set * of operations and results, and triggers its own 'finished' callback. * Batch sets are processed sequentially, with the progress bar starting * fresh for every new set. */function batch_set($batch_definition) {  if ($batch_definition) {    $batch =& batch_get();    // Initialize the batch    if (empty($batch)) {      $batch = array(        'sets' => array(),      );    }    $init = array(      'sandbox' => array(),      'results' => array(),      'success' => FALSE,    );    // Use get_t() to allow batches at install time.    $t = get_t();    $defaults = array(      'title' => $t('Processing'),      'init_message' => $t('Initializing.'),      'progress_message' => $t('Remaining @remaining of @total.'),      'error_message' => $t('An error has occurred.'),    );    $batch_set = $init + $batch_definition + $defaults;    // Tweak init_message to avoid the bottom of the page flickering down after init phase.    $batch_set['init_message'] .= '<br/>&nbsp;';    $batch_set['total'] = count($batch_set['operations']);    // If the batch is being processed (meaning we are executing a stored submit handler),    // insert the new set after the current one.    if (isset($batch['current_set'])) {      // array_insert does not exist...      $slice1 = array_slice($batch['sets'], 0, $batch['current_set'] + 1);      $slice2 = array_slice($batch['sets'], $batch['current_set'] + 1);      $batch['sets'] = array_merge($slice1, array($batch_set), $slice2);    }    else {      $batch['sets'][] = $batch_set;    }  }}/** * Processes the batch. * * Unless the batch has been marked with 'progressive' = FALSE, the function * issues a drupal_goto and thus ends page execution. * * This function is not needed in form submit handlers; Form API takes care * of batches that were set during form submission. * * @param $redirect *   (optional) Path to redirect to when the batch has finished processing. * @param $url *   (optional - should only be used for separate scripts like update.php) *   URL of the batch processing page. */function batch_process($redirect = NULL, $url = NULL) {  $batch =& batch_get();  if (isset($batch)) {    // Add process information    $url = isset($url) ? $url : 'batch';    $process_info = array(      'current_set' => 0,      'progressive' => TRUE,      'url' => isset($url) ? $url : 'batch',      'source_page' => $_GET['q'],      'redirect' => $redirect,    );    $batch += $process_info;    if ($batch['progressive']) {      // Clear the way for the drupal_goto redirection to the batch processing      // page, by saving and unsetting the 'destination' if any, on both places      // drupal_goto looks for it.      if (isset($_REQUEST['destination'])) {        $batch['destination'] = $_REQUEST['destination'];        unset($_REQUEST['destination']);      }      elseif (isset($_REQUEST['edit']['destination'])) {        $batch['destination'] = $_REQUEST['edit']['destination'];        unset($_REQUEST['edit']['destination']);      }      // Initiate db storage in order to get a batch id. We have to provide      // at least an empty string for the (not null) 'token' column.      db_query("INSERT INTO {batch} (token, timestamp) VALUES ('', %d)", time());      $batch['id'] = db_last_insert_id('batch', 'bid');      // Now that we have a batch id, we can generate the redirection link in      // the generic error message.      $t = get_t();      $batch['error_message'] = $t('Please continue to <a href="@error_url">the error page</a>', array('@error_url' => url($url, array('query' => array('id' => $batch['id'], 'op' => 'finished')))));      // Actually store the batch data and the token generated form the batch id.      db_query("UPDATE {batch} SET token = '%s', batch = '%s' WHERE bid = %d", drupal_get_token($batch['id']), serialize($batch), $batch['id']);      drupal_goto($batch['url'], 'op=start&id='. $batch['id']);    }    else {      // Non-progressive execution: bypass the whole progressbar workflow      // and execute the batch in one pass.      require_once './includes/batch.inc';      _batch_process();    }  }}/** * Retrieves the current batch. */function &batch_get() {  static $batch = array();  return $batch;}/** * @} End of "defgroup batch". */
<?php// $Id$/** * @file *   Manages content translations. * *   Translations are managed in sets of posts, which represent the same *   information in different languages. Only content types for which the *   administrator explicitly enabled translations could have translations *   associated. Translations are managed in sets with exactly one source *   post per set. The source post is used to translate to different *   languages, so if the source post is significantly updated, the *   editor can decide to mark all translations outdated. * *   The node table stores the values used by this module: *    - 'tnid' is the translation set id, which equals the node id *      of the source post. *    - 'translate' is a flag, either indicating that the translation *      is up to date (0) or needs to be updated (1). *//** * Identifies a content type which has translation support enabled. */define('TRANSLATION_ENABLED', 2);/** * Implementation of hook_help(). */function translation_help($path, $arg) {  switch ($path) {    case 'admin/help#translation':      $output = '<p>'. t('The content translation module allows content to be translated into different languages. Working with the <a href="@locale">locale module</a> (which manages enabled languages and provides translation for the site interface), the content translation module is key to creating and maintaining translated site content.', array('@locale' => url('admin/help/locale'))) .'</p>';      $output .= '<p>'. t('Configuring content translation and translation-enabled content types:') .'</p>';      $output .= '<ul><li>'. t('Assign the <em>translate content</em> permission to the appropriate user roles at the <a href="@permissions">Permissions configuration page</a>.', array('@permissions' => url('admin/user/permissions'))) .'</li>';      $output .= '<li>'. t('Add and enable desired languages at the <a href="@languages">Languages configuration page</a>.', array('@languages' => url('admin/settings/language'))) .'</li>';      $output .= '<li>'. t('Determine which <a href="@content-types">content types</a> should support translation features. To enable translation support for a content type, edit the type and at the <em>Multilingual support</em> drop down, select <em>Enabled, with translation</em>. (<em>Multilingual support</em> is located within <em>Workflow settings</em>.) Be sure to save each content type after enabling multilingual support.', array('@content-types' => url('admin/content/types'))) .'</li></ul>';      $output .= '<p>'. t('Working with translation-enabled content types:') .'</p>';      $output .= '<ul><li>'. t('Use the <em>Language</em> drop down to select the appropriate language when creating or editing posts.') .'</li>';      $output .= '<li>'. t('Provide new or edit current translations for existing posts via the <em>Translation</em> tab. Only visible while viewing a post as a user with the <em>translate content</em> permission, this tab allows translations to be added or edited using a specialized editing form that also displays the content being translated.') .'</li>';      $output .= '<li>'. t('Update translations as needed, so that they accurately reflect changes in the content of the original post. The translation status flag provides a simple method for tracking outdated translations. After editing a post, for example, select the <em>Flag translations as outdated</em> check box to mark all of its translations as outdated and in need of revision. Individual translations may be marked for revision by selecting the <em>This translation needs to be updated</em> check box on the translation editing form.') .'</li>';      $output .= '<li>'. t('The <a href="@content-node">Content management administration page</a> displays the language of each post, and also allows filtering by language or translation status.', array('@content-node' => url('admin/content/node'))) .'</li></ul>';      $output .= '<p>'. t('Use the <a href="@blocks">language switcher block</a> provided by locale module to allow users to select a language. If available, both the site interface and site content are presented in the language selected.', array('@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@translation">Translation module</a>.', array('@translation' => 'http://drupal.org/handbook/modules/translation/')) .'</p>';      return $output;    case 'node/%/translate':      $output = '<p>'. t('Translations of a piece of content are managed with translation sets. Each translation set has one source post and any number of translations in any of the <a href="!languages">enabled languages</a>. All translations are tracked to be up to date or outdated based on whether the source post was modified significantly.', array('!languages' => url('admin/settings/language'))) .'</p>';      return $output;  }}/** * Implementation of hook_menu(). */function translation_menu() {  $items = array();  $items['node/%node/translate'] = array(    'title' => 'Translate',    'page callback' => 'translation_node_overview',    'page arguments' => array(1),    'access callback' => '_translation_tab_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'translation.pages.inc',  );  return $items;}/** * Menu access callback. * * Only display translation tab for node types, which have translation enabled * and where the current node is not language neutral (which should span * all languages). */function _translation_tab_access($node) {  return !empty($node->language) && translation_supported_type($node->type) && node_access('view', $node) && user_access('translate content');}/** * Implementation of hook_perm(). */function translation_perm() {  return array('translate content');}/** * Implementation of hook_form_alter(). * * - Add translation option to content type form. * - Alters language fields on node forms when a translation *   is about to be created. */function translation_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'node_type_form') {    // Add translation option to content type form.    $form['workflow']['language_content_type']['#options'][TRANSLATION_ENABLED] = t('Enabled, with translation');    // Description based on text from locale.module.    $form['workflow']['language_content_type']['#description'] = t('Enable multilingual support for this content type. If enabled, a language selection field will be added to the editing form, allowing you to select from one of the <a href="!languages">enabled languages</a>. You can also turn on translation for this content type, which lets you have content translated to any of the enabled languages. If disabled, new posts are saved with the default language. Existing content will not be affected by changing this option.', array('!languages' => url('admin/settings/language')));  }  elseif (isset($form['#id']) && $form['#id'] == 'node-form' && translation_supported_type($form['#node']->type)) {    $node = $form['#node'];    if (!empty($node->translation_source)) {      // We are creating a translation. Add values and lock language field.      $form['translation_source'] = array('#type' => 'value', '#value' => $node->translation_source);      $form['language']['#disabled'] = TRUE;    }    elseif (!empty($node->nid) && !empty($node->tnid)) {      // Disable languages for existing translations, so it is not possible to switch this      // node to some language which is already in the translation set. Also remove the      // language neutral option.      unset($form['language']['#options']['']);      foreach (translation_node_get_translations($node->tnid) as $translation) {        if ($translation->nid != $node->nid) {          unset($form['language']['#options'][$translation->language]);        }      }      // Add translation values and workflow options.      $form['tnid'] = array('#type' => 'value', '#value' => $node->tnid);      $form['translation'] = array(        '#type' => 'fieldset',        '#title' => t('Translation settings'),        '#access' => user_access('translate content'),        '#collapsible' => TRUE,        '#collapsed' => !$node->translate,        '#tree' => TRUE,        '#weight' => 30,      );      if ($node->tnid == $node->nid) {        // This is the source node of the translation        $form['translation']['retranslate'] = array(          '#type' => 'checkbox',          '#title' => t('Flag translations as outdated'),          '#default_value' => 0,          '#description' => t('If you made a significant change, which means translations should be updated, you can flag all translations of this post as outdated. This will not change any other property of those posts, like whether they are published or not.'),        );        $form['translation']['status'] = array('#type' => 'value', '#value' => 0);      }      else {        $form['translation']['status'] = array(          '#type' => 'checkbox',          '#title' => t('This translation needs to be updated'),          '#default_value' => $node->translate,          '#description' => t('When this option is checked, this translation needs to be updated because the source post has changed. Uncheck when the translation is up to date again.'),        );      }    }  }}/** * Implementation of hook_link(). * * Display translation links with native language names, if this node * is part of a translation set. */function translation_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && ($node->tnid) && $translations = translation_node_get_translations($node->tnid)) {    // Do not show link to the same node.    unset($translations[$node->language]);    $languages = language_list();    foreach ($languages as $langcode => $language) {      if (isset($translations[$langcode])) {        $links["node_translation_$langcode"] = array(          'title' => $language->native,          'href' => 'node/'. $translations[$langcode]->nid,          'language' => $language,          'attributes' => array('title' => $translations[$langcode]->title, 'class' => 'translation-link')        );      }    }  }  return $links;}/** * Implementation of hook_nodeapi(). * * Manages translation information for nodes. */function translation_nodeapi(&$node, $op, $teaser, $page) {  // Only act if we are dealing with a content type supporting translations.  if (!translation_supported_type($node->type)) {    return;  }  switch ($op) {    case 'prepare':      if (empty($node->nid) && user_access('translate content') && isset($_GET['translation']) && isset($_GET['language']) && is_numeric($_GET['translation'])) {        $translation_source = node_load($_GET['translation']);        if (empty($translation_source) || !node_access('view', $translation_source)) {          // Source node not found or no access to view. We should not check          // for edit access, since the translator might not have permissions          // to edit the source node but should still be able to translate.          return;        }        $language_list = language_list();        if (!isset($language_list[$_GET['language']]) || ($translation_source->language == $_GET['language'])) {          // If not supported language, or same language as source node, break.          return;        }        // Populate fields based on source node.        $node->language = $_GET['language'];        $node->translation_source = $translation_source;        $node->title = $translation_source->title;        // If user has no access to the filter used for the body, Drupal core        // does not let the edit form to appear, so we should avoid exposing        // the source text here too.        $node->body = filter_access($translation_source->format) ? $translation_source->body : '';        // Let every module add custom translated fields.        node_invoke_nodeapi($node, 'prepare translation');      }      break;    case 'insert':      if (!empty($node->translation_source)) {        if ($node->translation_source->tnid) {          // Add node to existing translation set.          $tnid = $node->translation_source->tnid;        }        else {          // Create new translation set, using nid from the source node.          $tnid = $node->translation_source->nid;          db_query("UPDATE {node} SET tnid = %d, translate = %d WHERE nid = %d", $tnid, 0, $node->translation_source->nid);        }        db_query("UPDATE {node} SET tnid = %d, translate = %d WHERE nid = %d", $tnid, 0, $node->nid);      }      break;    case 'update':      if (isset($node->translation) && $node->translation && !empty($node->language) && $node->tnid) {        // Update translation information.        db_query("UPDATE {node} SET tnid = %d, translate = %d WHERE nid = %d", $node->tnid, $node->translation['status'], $node->nid);        if (!empty($node->translation['retranslate'])) {          // This is the source node, asking to mark all translations outdated.          db_query("UPDATE {node} SET translate = 1 WHERE tnid = %d AND nid != %d", $node->tnid, $node->nid);        }      }      break;    case 'delete':      translation_remove_from_set($node);      break;  }}/** * Remove a node from its translation set (if any) * and update the set accordingly. */function translation_remove_from_set($node) {  if (isset($node->tnid)) {    if (db_result(db_query('SELECT COUNT(*) FROM {node} WHERE tnid = %d', $node->tnid)) == 1) {      // There is only one node left in the set: remove the set altogether.      db_query('UPDATE {node} SET tnid = 0, translate = 0 WHERE tnid = %d', $node->tnid);    }    else {      db_query('UPDATE {node} SET tnid = 0, translate = 0 WHERE nid = %d', $node->nid);      // If the node being removed was the source of the translation set,      // we pick a new source - preferably one that is up to date.      if ($node->tnid == $node->nid) {        $new_tnid = db_result(db_query('SELECT nid FROM {node} WHERE tnid = %d ORDER BY translate ASC, nid ASC', $node->tnid));        db_query('UPDATE {node} SET tnid = %d WHERE tnid = %d', $new_tnid, $node->tnid);      }    }  }}/** * Get all nodes in a translation set, represented by $tnid. * * @param $tnid *   The translation source nid of the translation set, the identifier *   of the node used to derive all translations in the set. * @return *   Array of partial node objects (nid, title, language) representing *   all nodes in the translation set, in effect all translations *   of node $tnid, including node $tnid itself. Because these are *   partial nodes, you need to node_load() the full node, if you *   need more properties. The array is indexed by language code. */function translation_node_get_translations($tnid) {  static $translations = array();  if (is_numeric($tnid) && $tnid) {    if (!isset($translations[$tnid])) {      $translations[$tnid] = array();      $result = db_query(db_rewrite_sql('SELECT n.nid, n.title, n.language FROM {node} n WHERE n.tnid = %d'), $tnid);      while ($node = db_fetch_object($result)) {        $translations[$tnid][$node->language] = $node;      }    }    return $translations[$tnid];  }}/** * Returns whether the given content type has support for translations. * * @return *   Boolean value. */function translation_supported_type($type) {  return variable_get('language_content_type_'. $type, 0) == TRANSLATION_ENABLED;}/** * Return paths of all translations of a node, based on * its Drupal path. * * @param $path *   A Drupal path, for example node/432. * @return *   An array of paths of translations of the node accessible *   to the current user keyed with language codes. */function translation_path_get_translations($path) {  $paths = array();  // Check for a node related path, and for its translations.  if ((preg_match("!^node/([0-9]+)(/.+|)$!", $path, $matches)) && ($node = node_load((int)$matches[1])) && !empty($node->tnid)) {    foreach (translation_node_get_translations($node->tnid) as $language => $translation_node) {      $paths[$language] = 'node/'. $translation_node->nid . $matches[2];    }  }  return $paths;}/** * Implementation of hook_translation_link_alter(). * * Replaces links with pointers to translated versions of the content. */function translation_translation_link_alter(&$links, $path) {  if ($paths = translation_path_get_translations($path)) {    foreach ($links as $langcode => $link) {      if (isset($paths[$langcode])) {        // Translation in a different node.        $links[$langcode]['href'] = $paths[$langcode];      }      else {        // No translation in this language, or no permission to view.        unset($links[$langcode]);      }    }  }}
<?php// $Id$/** * Sets the body-tag class attribute. * * Adds 'sidebar-left', 'sidebar-right' or 'sidebars' classes as needed. */function phptemplate_body_class($left, $right) {  if ($left != '' && $right != '') {    $class = 'sidebars';  }  else {    if ($left != '') {      $class = 'sidebar-left';    }    if ($right != '') {      $class = 'sidebar-right';    }  }  if (isset($class)) {    print ' class="'. $class .'"';  }}/** * Return a themed breadcrumb trail. * * @param $breadcrumb *   An array containing the breadcrumb links. * @return a string containing the breadcrumb output. */function phptemplate_breadcrumb($breadcrumb) {  if (!empty($breadcrumb)) {    return '<div class="breadcrumb">'. implode('  ', $breadcrumb) .'</div>';  }}/** * Override or insert PHPTemplate variables into the templates. */function phptemplate_preprocess_page(&$vars) {  $vars['tabs2'] = menu_secondary_local_tasks();  // Hook into color.module  if (module_exists('color')) {    _color_page_alter($vars);  }}/** * Add a "Comments" heading above comments except on forum pages. */function garland_preprocess_comment_wrapper(&$vars) {  if ($vars['content'] && $vars['node']->type != 'forum') {    $vars['content'] = '<h2 class="comments">'. t('Comments') .'</h2>'.  $vars['content'];  }}/** * Returns the rendered local tasks. The default implementation renders * them as tabs. Overridden to split the secondary tasks. * * @ingroup themeable */function phptemplate_menu_local_tasks() {  return menu_primary_local_tasks();}function phptemplate_comment_submitted($comment) {  return t('!datetime  !username',    array(      '!username' => theme('username', $comment),      '!datetime' => format_date($comment->timestamp)    ));}function phptemplate_node_submitted($node) {  return t('!datetime  !username',    array(      '!username' => theme('username', $node),      '!datetime' => format_date($node->created),    ));}/** * Generates IE CSS links for LTR and RTL languages. */function phptemplate_get_ie_styles() {  global $language;  $iecss = '<link type="text/css" rel="stylesheet" media="all" href="'. base_path() . path_to_theme() .'/fix-ie.css" />';  if ($language->direction == LANGUAGE_RTL) {    $iecss .= '<style type="text/css" media="all">@import "'. base_path() . path_to_theme() .'/fix-ie-rtl.css";</style>';  }  return $iecss;}
