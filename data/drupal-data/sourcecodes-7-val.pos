<?php// $Id$/** * @file * Functions to aid in the creation of sortable tables. * * All tables created with a call to theme('table') have the option of having * column headers that the user can click on to sort the table by that column. *//** * Initialize the table sort context. */function tablesort_init($header) {  $ts = tablesort_get_order($header);  $ts['sort'] = tablesort_get_sort($header);  $ts['query_string'] = tablesort_get_querystring();  return $ts;}/** * Create an SQL sort clause. * * This function produces the ORDER BY clause to insert in your SQL queries, * assuring that the returned database table rows match the sort order chosen * by the user. * * @param $header *   An array of column headers in the format described in theme_table(). * @param $before *   An SQL string to insert after ORDER BY and before the table sorting code. *   Useful for sorting by important attributes like "sticky" first. * @return *   An SQL string to append to the end of a query. * * @ingroup database */function tablesort_sql($header, $before = '') {  $ts = tablesort_init($header);  if ($ts['sql']) {    // Based on code from db_escape_table(), but this can also contain a dot.    $field = preg_replace('/[^A-Za-z0-9_.]+/', '', $ts['sql']);    // Sort order can only be ASC or DESC.    $sort = drupal_strtoupper($ts['sort']);    $sort = in_array($sort, array('ASC', 'DESC')) ? $sort : '';    return " ORDER BY $before $field $sort";  }}/** * Format a column header. * * If the cell in question is the column header for the current sort criterion, * it gets special formatting. All possible sort criteria become links. * * @param $cell *   The cell to format. * @param $header *   An array of column headers in the format described in theme_table(). * @param $ts *   The current table sort context as returned from tablesort_init(). * @return *   A properly formatted cell, ready for _theme_table_cell(). */function tablesort_header($cell, $header, $ts) {  // Special formatting for the currently sorted column header.  if (is_array($cell) && isset($cell['field'])) {    $title = t('sort by @s', array('@s' => $cell['data']));    if ($cell['data'] == $ts['name']) {      $ts['sort'] = (($ts['sort'] == 'asc') ? 'desc' : 'asc');      if (isset($cell['class'])) {        $cell['class'] .= ' active';      }      else {        $cell['class'] = 'active';      }      $image = theme('tablesort_indicator', $ts['sort']);    }    else {      // If the user clicks a different header, we want to sort ascending initially.      $ts['sort'] = 'asc';      $image = '';    }    if (!empty($ts['query_string'])) {      $ts['query_string'] = '&'. $ts['query_string'];    }    $cell['data'] = l($cell['data'] . $image, $_GET['q'], array('attributes' => array('title' => $title), 'query' => 'sort='. $ts['sort'] .'&order='. urlencode($cell['data']) . $ts['query_string'], 'html' => TRUE));    unset($cell['field'], $cell['sort']);  }  return $cell;}/** * Format a table cell. * * Adds a class attribute to all cells in the currently active column. * * @param $cell *   The cell to format. * @param $header *   An array of column headers in the format described in theme_table(). * @param $ts *   The current table sort context as returned from tablesort_init(). * @param $i *   The index of the cell's table column. * @return *   A properly formatted cell, ready for _theme_table_cell(). */function tablesort_cell($cell, $header, $ts, $i) {  if (isset($header[$i]['data']) && $header[$i]['data'] == $ts['name'] && !empty($header[$i]['field'])) {    if (is_array($cell)) {      if (isset($cell['class'])) {        $cell['class'] .= ' active';      }      else {        $cell['class'] = 'active';      }    }    else {      $cell = array('data' => $cell, 'class' => 'active');    }  }  return $cell;}/** * Compose a query string to append to table sorting requests. * * @return *   A query string that consists of all components of the current page request *   except for those pertaining to table sorting. */function tablesort_get_querystring() {  return drupal_query_string_encode($_REQUEST, array_merge(array('q', 'sort', 'order', 'pass'), array_keys($_COOKIE)));}/** * Determine the current sort criterion. * * @param $headers *   An array of column headers in the format described in theme_table(). * @return *   An associative array describing the criterion, containing the keys: *   - "name": The localized title of the table column. *   - "sql": The name of the database field to sort on. */function tablesort_get_order($headers) {  $order = isset($_GET['order']) ? $_GET['order'] : '';  foreach ($headers as $header) {    if (isset($header['data']) && $order == $header['data']) {      return array('name' => $header['data'], 'sql' => isset($header['field']) ? $header['field'] : '');    }    if (isset($header['sort']) && ($header['sort'] == 'asc' || $header['sort'] == 'desc')) {      $default = array('name' => $header['data'], 'sql' => isset($header['field']) ? $header['field'] : '');    }  }  if (isset($default)) {    return $default;  }  else {    // The first column specified is initial 'order by' field unless otherwise specified    if (is_array($headers[0])) {      $headers[0] += array('data' => NULL, 'field' => NULL);      return array('name' => $headers[0]['data'], 'sql' => $headers[0]['field']);    }    else {      return array('name' => $headers[0]);    }  }}/** * Determine the current sort direction. * * @param $headers *   An array of column headers in the format described in theme_table(). * @return *   The current sort direction ("asc" or "desc"). */function tablesort_get_sort($headers) {  if (isset($_GET['sort'])) {    return ($_GET['sort'] == 'desc') ? 'desc' : 'asc';  }  // User has not specified a sort. Use default if specified; otherwise use "asc".  else {    foreach ($headers as $header) {      if (is_array($header) && array_key_exists('sort', $header)) {        return $header['sort'];      }    }  }  return 'asc';}
<?php// $Id$/** * @file * Framework for handling filtering of content. */// This is a special format ID which means "use the default format". This value// can be passed to the filter APIs as a format ID: this is equivalent to not// passing an explicit format at all.define('FILTER_FORMAT_DEFAULT', 0);define('FILTER_HTML_STRIP', 1);define('FILTER_HTML_ESCAPE', 2);/** * Implementation of hook_help(). */function filter_help($path, $arg) {  switch ($path) {    case 'admin/help#filter':      $output = '<p>'. t("The filter module allows administrators to configure text input formats for use on your site. An input format defines the HTML tags, codes, and other input allowed in both content and comments, and is a key feature in guarding against potentially damaging input from malicious users. Two input formats included by default are <em>Filtered HTML</em> (which allows only an administrator-approved subset of HTML tags) and <em>Full HTML</em> (which allows the full set of HTML tags). Additional input formats may be created by an administrator.") .'</p>';      $output .= '<p>'. t('Each input format uses filters to manipulate text, and most input formats apply several different filters to text in a specific order. Each filter is designed for a specific purpose, and generally either adds, removes or transforms elements within user-entered text before it is displayed. A filter does not change the actual content of a post, but instead, modifies it temporarily before it is displayed. A filter may remove unapproved HTML tags, for instance, while another automatically adds HTML to make links referenced in text clickable.') .'</p>';      $output .= '<p>'. t('Users can choose between the available input formats when creating or editing content. Administrators can configure which input formats are available to which user roles, as well as choose a default input format.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@filter">Filter module</a>.', array('@filter' => 'http://drupal.org/handbook/modules/filter/')) .'</p>';      return $output;    case 'admin/settings/filters':      $output = '<p>'. t('<em>Input formats</em> define a way of processing user-supplied text in Drupal. Each input format uses filters to manipulate text, and most input formats apply several different filters to text, in a specific order. Each filter is designed to accomplish a specific purpose, and generally either removes elements from or adds elements to text before it is displayed. Users can choose between the available input formats when submitting content.') .'</p>';      $output .= '<p>'. t('Use the list below to configure which input formats are available to which roles, as well as choose a default input format (used for imported content, for example). The default format is always available to users. All input formats are available to users in a role with the "administer filters" permission.') .'</p>';      return $output;    case 'admin/settings/filters/%':      return '<p>'. t('Every <em>filter</em> performs one particular change on the user input, for example stripping out malicious HTML or making URLs clickable. Choose which filters you want to apply to text in this input format. If you notice some filters are causing conflicts in the output, you can <a href="@rearrange">rearrange them</a>.', array('@rearrange' => url('admin/settings/filters/'. $arg[3] .'/order'))) .'</p>';    case 'admin/settings/filters/%/configure':      return '<p>'. t('If you cannot find the settings for a certain filter, make sure you have enabled it on the <a href="@url">view tab</a> first.', array('@url' => url('admin/settings/filters/'. $arg[3]))) .'</p>';    case 'admin/settings/filters/%/order':      $output = '<p>'. t('Because of the flexible filtering system, you might encounter a situation where one filter prevents another from doing its job. For example: a word in an URL gets converted into a glossary term, before the URL can be converted to a clickable link. When this happens, rearrange the order of the filters.') .'</p>';      $output .= '<p>'. t("Filters are executed from top-to-bottom. To change the order of the filters, modify the values in the <em>Weight</em> column or grab a drag-and-drop handle under the <em>Name</em> column and drag filters to new locations in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save configuration</em> button at the bottom of the page.") .'</p>';      return $output;  }}/** * Implementation of hook_theme() */function filter_theme() {  return array(    'filter_admin_overview' => array(      'arguments' => array('form' => NULL),      'file' => 'filter.admin.inc',    ),    'filter_admin_order' => array(      'arguments' => array('form' => NULL),      'file' => 'filter.admin.inc',    ),    'filter_tips' => array(      'arguments' => array('tips' => NULL, 'long' => FALSE, 'extra' => ''),      'file' => 'filter.pages.inc',    ),    'filter_tips_more_info' => array(      'arguments' => array(),    ),  );}/** * Implementation of hook_menu(). */function filter_menu() {  $items['admin/settings/filters'] = array(    'title' => 'Input formats',    'description' => 'Configure how content input by users is filtered, including allowed HTML tags. Also allows enabling of module-provided filters.',    'page callback' => 'drupal_get_form',    'page arguments' => array('filter_admin_overview'),    'access arguments' => array('administer filters'),    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/settings/filters/add'] = array(    'title' => 'Add input format',    'page callback' => 'filter_admin_format_page',    'access arguments' => array('administer filters'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/delete'] = array(    'title' => 'Delete input format',    'page callback' => 'drupal_get_form',    'page arguments' => array('filter_admin_delete'),    'access arguments' => array('administer filters'),    'type' => MENU_CALLBACK,    'file' => 'filter.admin.inc',  );  $items['filter/tips'] = array(    'title' => 'Compose tips',    'page callback' => 'filter_tips_long',    'access callback' => TRUE,    'type' => MENU_SUGGESTED_ITEM,    'file' => 'filter.pages.inc',  );  $items['admin/settings/filters/%filter_format'] = array(    'type' => MENU_CALLBACK,    'title callback' => 'filter_admin_format_title',    'title arguments' => array(3),    'page callback' => 'filter_admin_format_page',    'page arguments' => array(3),    'access arguments' => array('administer filters'),    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/%filter_format/edit'] = array(    'title' => 'Edit',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => 0,    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/%filter_format/configure'] = array(    'title' => 'Configure',    'page callback' => 'filter_admin_configure_page',    'page arguments' => array(3),    'access arguments' => array('administer filters'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/%filter_format/order'] = array(    'title' => 'Rearrange',    'page callback' => 'filter_admin_order_page',    'page arguments' => array(3),    'access arguments' => array('administer filters'),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'filter.admin.inc',  );  return $items;}function filter_format_load($arg) {  return filter_formats($arg);}/** * Display a filter format form title. */function filter_admin_format_title($format) {  return $format->name;}/** * Implementation of hook_perm(). */function filter_perm() {  return array('administer filters');}/** * Implementation of hook_cron(). * * Expire outdated filter cache entries */function filter_cron() {  cache_clear_all(NULL, 'cache_filter');}/** * Implementation of hook_filter_tips(). */function filter_filter_tips($delta, $format, $long = FALSE) {  global $base_url;  switch ($delta) {    case 0:      if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_STRIP) {        if ($allowed_html = variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>')) {          switch ($long) {            case 0:              return t('Allowed HTML tags: @tags', array('@tags' => $allowed_html));            case 1:              $output = '<p>'. t('Allowed HTML tags: @tags', array('@tags' => $allowed_html)) .'</p>';              if (!variable_get("filter_html_help_$format", 1)) {                return $output;              }              $output .= t('<p>This site allows HTML content. While learning all of HTML may feel intimidating, learning how to use a very small number of the most basic HTML "tags" is very easy. This table provides examples for each tag that is enabled on this site.</p><p>For more information see W3C\'s <a href="http://www.w3.org/TR/html/">HTML Specifications</a> or use your favorite search engine to find other sites that explain HTML.</p>');              $tips = array(                'a' => array( t('Anchors are used to make links to other pages.'), '<a href="'. $base_url .'">'. variable_get('site_name', 'Drupal') .'</a>'),                'br' => array( t('By default line break tags are automatically added, so use this tag to add additional ones. Use of this tag is different because it is not used with an open/close pair like all the others. Use the extra " /" inside the tag to maintain XHTML 1.0 compatibility'), t('Text with <br />line break')),                'p' => array( t('By default paragraph tags are automatically added, so use this tag to add additional ones.'), '<p>'. t('Paragraph one.') .'</p> <p>'. t('Paragraph two.') .'</p>'),                'strong' => array( t('Strong'), '<strong>'. t('Strong') .'</strong>'),                'em' => array( t('Emphasized'), '<em>'. t('Emphasized') .'</em>'),                'cite' => array( t('Cited'), '<cite>'. t('Cited') .'</cite>'),                'code' => array( t('Coded text used to show programming source code'), '<code>'. t('Coded') .'</code>'),                'b' => array( t('Bolded'), '<b>'. t('Bolded') .'</b>'),                'u' => array( t('Underlined'), '<u>'. t('Underlined') .'</u>'),                'i' => array( t('Italicized'), '<i>'. t('Italicized') .'</i>'),                'sup' => array( t('Superscripted'), t('<sup>Super</sup>scripted')),                'sub' => array( t('Subscripted'), t('<sub>Sub</sub>scripted')),                'pre' => array( t('Preformatted'), '<pre>'. t('Preformatted') .'</pre>'),                'abbr' => array( t('Abbreviation'), t('<abbr title="Abbreviation">Abbrev.</abbr>')),                'acronym' => array( t('Acronym'), t('<acronym title="Three-Letter Acronym">TLA</acronym>')),                'blockquote' => array( t('Block quoted'), '<blockquote>'. t('Block quoted') .'</blockquote>'),                'q' => array( t('Quoted inline'), '<q>'. t('Quoted inline') .'</q>'),                // Assumes and describes tr, td, th.                'table' => array( t('Table'), '<table> <tr><th>'. t('Table header') .'</th></tr> <tr><td>'. t('Table cell') .'</td></tr> </table>'),                'tr' => NULL, 'td' => NULL, 'th' => NULL,                'del' => array( t('Deleted'), '<del>'. t('Deleted') .'</del>'),                'ins' => array( t('Inserted'), '<ins>'. t('Inserted') .'</ins>'),                 // Assumes and describes li.                'ol' => array( t('Ordered list - use the &lt;li&gt; to begin each list item'), '<ol> <li>'. t('First item') .'</li> <li>'. t('Second item') .'</li> </ol>'),                'ul' => array( t('Unordered list - use the &lt;li&gt; to begin each list item'), '<ul> <li>'. t('First item') .'</li> <li>'. t('Second item') .'</li> </ul>'),                'li' => NULL,                // Assumes and describes dt and dd.                'dl' => array( t('Definition lists are similar to other HTML lists. &lt;dl&gt; begins the definition list, &lt;dt&gt; begins the definition term and &lt;dd&gt; begins the definition description.'), '<dl> <dt>'. t('First term') .'</dt> <dd>'. t('First definition') .'</dd> <dt>'. t('Second term') .'</dt> <dd>'. t('Second definition') .'</dd> </dl>'),                'dt' => NULL, 'dd' => NULL,                'h1' => array( t('Header'), '<h1>'. t('Title') .'</h1>'),                'h2' => array( t('Header'), '<h2>'. t('Subtitle') .'</h2>'),                'h3' => array( t('Header'), '<h3>'. t('Subtitle three') .'</h3>'),                'h4' => array( t('Header'), '<h4>'. t('Subtitle four') .'</h4>'),                'h5' => array( t('Header'), '<h5>'. t('Subtitle five') .'</h5>'),                'h6' => array( t('Header'), '<h6>'. t('Subtitle six') .'</h6>')              );              $header = array(t('Tag Description'), t('You Type'), t('You Get'));              preg_match_all('/<([a-z0-9]+)[^a-z0-9]/i', $allowed_html, $out);              foreach ($out[1] as $tag) {                if (array_key_exists($tag, $tips)) {                  if ($tips[$tag]) {                    $rows[] = array(                      array('data' => $tips[$tag][0], 'class' => 'description'),                      array('data' => '<code>'. check_plain($tips[$tag][1]) .'</code>', 'class' => 'type'),                      array('data' => $tips[$tag][1], 'class' => 'get')                    );                  }                }                else {                  $rows[] = array(                    array('data' => t('No help provided for tag %tag.', array('%tag' => $tag)), 'class' => 'description', 'colspan' => 3),                  );                }              }              $output .= theme('table', $header, $rows);              $output .= t('<p>Most unusual characters can be directly entered without any problems.</p><p>If you do encounter problems, try using HTML character entities. A common example looks like &amp;amp; for an ampersand &amp; character. For a full list of entities see HTML\'s <a href="http://www.w3.org/TR/html4/sgml/entities.html">entities</a> page. Some of the available characters include:</p>');              $entities = array(                array( t('Ampersand'), '&amp;'),                array( t('Greater than'), '&gt;'),                array( t('Less than'), '&lt;'),                array( t('Quotation mark'), '&quot;'),              );              $header = array(t('Character Description'), t('You Type'), t('You Get'));              unset($rows);              foreach ($entities as $entity) {                $rows[] = array(                  array('data' => $entity[0], 'class' => 'description'),                  array('data' => '<code>'. check_plain($entity[1]) .'</code>', 'class' => 'type'),                  array('data' => $entity[1], 'class' => 'get')                );              }              $output .= theme('table', $header, $rows);              return $output;          }        }        else {          return t('No HTML tags allowed');        }      }      break;    case 1:      switch ($long) {        case 0:          return t('Lines and paragraphs break automatically.');        case 1:          return t('Lines and paragraphs are automatically recognized. The &lt;br /&gt; line break, &lt;p&gt; paragraph and &lt;/p&gt; close paragraph tags are inserted automatically. If paragraphs are not recognized simply add a couple blank lines.');      }      break;    case 2:      return t('Web page addresses and e-mail addresses turn into links automatically.');  }}/** * Retrieve a list of input formats. */function filter_formats($index = NULL) {  global $user;  static $formats;  // Administrators can always use all input formats.  $all = user_access('administer filters');  if (!isset($formats)) {    $formats = array();    $query = 'SELECT * FROM {filter_formats}';    // Build query for selecting the format(s) based on the user's roles.    $args = array();    if (!$all) {      $where = array();      foreach ($user->roles as $rid => $role) {        $where[] = "roles LIKE '%%,%d,%%'";        $args[] = $rid;      }      $query .= ' WHERE '. implode(' OR ', $where) .' OR format = %d';      $args[] = variable_get('filter_default_format', 1);    }    $result = db_query($query, $args);    while ($format = db_fetch_object($result)) {      $formats[$format->format] = $format;    }  }  if (isset($index)) {    return isset($formats[$index]) ? $formats[$index] : FALSE;  }  return $formats;}/** * Build a list of all filters. */function filter_list_all() {  $filters = array();  foreach (module_list() as $module) {    $list = module_invoke($module, 'filter', 'list');    if (isset($list) && is_array($list)) {      foreach ($list as $delta => $name) {        $filters[$module .'/'. $delta] = (object)array('module' => $module, 'delta' => $delta, 'name' => $name);      }    }  }  uasort($filters, '_filter_list_cmp');  return $filters;}/** * Helper function for sorting the filter list by filter name. */function _filter_list_cmp($a, $b) {  return strcmp($a->name, $b->name);}/** * Resolve a format id, including the default format. */function filter_resolve_format($format) {  return $format == FILTER_FORMAT_DEFAULT ? variable_get('filter_default_format', 1) : $format;}/** * Check if text in a certain input format is allowed to be cached. */function filter_format_allowcache($format) {  static $cache = array();  $format = filter_resolve_format($format);  if (!isset($cache[$format])) {    $cache[$format] = db_result(db_query('SELECT cache FROM {filter_formats} WHERE format = %d', $format));  }  return $cache[$format];}/** * Retrieve a list of filters for a certain format. */function filter_list_format($format) {  static $filters = array();  if (!isset($filters[$format])) {    $result = db_query("SELECT * FROM {filters} WHERE format = %d ORDER BY weight, module, delta", $format);    if (db_affected_rows($result) == 0 && !db_result(db_query("SELECT 1 FROM {filter_formats} WHERE format = %d", $format))) {      // The format has no filters and does not exist, use the default input      // format.      $filters[$format] = filter_list_format(variable_get('filter_default_format', 1));    }    else {      $filters[$format] = array();      while ($filter = db_fetch_object($result)) {        $list = module_invoke($filter->module, 'filter', 'list');        if (isset($list) && is_array($list) && isset($list[$filter->delta])) {          $filter->name = $list[$filter->delta];          $filters[$format][$filter->module .'/'. $filter->delta] = $filter;        }      }    }  }  return $filters[$format];}/** * @name Filtering functions * @{ * Modules which need to have content filtered can use these functions to * interact with the filter system. * * For more info, see the hook_filter() documentation. * * Note: because filters can inject JavaScript or execute PHP code, security is * vital here. When a user supplies a $format, you should validate it with * filter_access($format) before accepting/using it. This is normally done in * the validation stage of the node system. You should for example never make a * preview of content in a disallowed format. *//** * Run all the enabled filters on a piece of text. * * @param $text *    The text to be filtered. * @param $format *    The format of the text to be filtered. Specify FILTER_FORMAT_DEFAULT for *    the default format. * @param $check *    Whether to check the $format with filter_access() first. Defaults to TRUE. *    Note that this will check the permissions of the current user, so you *    should specify $check = FALSE when viewing other people's content. When *    showing content that is not (yet) stored in the database (eg. upon preview), *    set to TRUE so the user's permissions are checked. */function check_markup($text, $format = FILTER_FORMAT_DEFAULT, $check = TRUE) {  // When $check = TRUE, do an access check on $format.  if (isset($text) && (!$check || filter_access($format))) {    $format = filter_resolve_format($format);    // Check for a cached version of this piece of text.    $cache_id = $format .':'. md5($text);    if ($cached = cache_get($cache_id, 'cache_filter')) {      return $cached->data;    }    // See if caching is allowed for this format.    $cache = filter_format_allowcache($format);    // Convert all Windows and Mac newlines to a single newline,    // so filters only need to deal with one possibility.    $text = str_replace(array("\r\n", "\r"), "\n", $text);    // Get a complete list of filters, ordered properly.    $filters = filter_list_format($format);    // Give filters the chance to escape HTML-like data such as code or formulas.    foreach ($filters as $filter) {      $text = module_invoke($filter->module, 'filter', 'prepare', $filter->delta, $format, $text, $cache_id);    }    // Perform filtering.    foreach ($filters as $filter) {      $text = module_invoke($filter->module, 'filter', 'process', $filter->delta, $format, $text, $cache_id);    }    // Store in cache with a minimum expiration time of 1 day.    if ($cache) {      cache_set($cache_id, $text, 'cache_filter', time() + (60 * 60 * 24));    }  }  else {    $text = t('n/a');  }  return $text;}/** * Generate a selector for choosing a format in a form. * * @ingroup forms * @see filter_form_validate() * @param $value *   The ID of the format that is currently selected. * @param $weight *   The weight of the input format. * @param $parents *   Required when defining multiple input formats on a single node or having a different parent than 'format'. * @return *   HTML for the form element. */function filter_form($value = FILTER_FORMAT_DEFAULT, $weight = NULL, $parents = array('format')) {  $value = filter_resolve_format($value);  $formats = filter_formats();  $extra = theme('filter_tips_more_info');  if (count($formats) > 1) {    $form = array(      '#type' => 'fieldset',      '#title' => t('Input format'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#weight' => $weight,      '#element_validate' => array('filter_form_validate'),    );    // Multiple formats available: display radio buttons with tips.    foreach ($formats as $format) {      // Generate the parents as the autogenerator does, so we will have a      // unique id for each radio button.      $parents_for_id = array_merge($parents, array($format->format));      $form[$format->format] = array(        '#type' => 'radio',        '#title' => $format->name,        '#default_value' => $value,        '#return_value' => $format->format,        '#parents' => $parents,        '#description' => theme('filter_tips', _filter_tips($format->format, FALSE)),        '#id' => form_clean_id('edit-'. implode('-', $parents_for_id)),      );    }  }  else {    // Only one format available: use a hidden form item and only show tips.    $format = array_shift($formats);    $form[$format->format] = array('#type' => 'value', '#value' => $format->format, '#parents' => $parents);    $tips = _filter_tips(variable_get('filter_default_format', 1), FALSE);    $form['format']['guidelines'] = array(      '#title' => t('Formatting guidelines'),      '#value' => theme('filter_tips', $tips, FALSE, $extra),    );  }  $form[] = array('#value' => $extra);  return $form;}function filter_form_validate($form) {  foreach (element_children($form) as $key) {    if ($form[$key]['#value'] == $form[$key]['#return_value']) {      return;    }  }  form_error($form, t('An illegal choice has been detected. Please contact the site administrator.'));  watchdog('form', 'Illegal choice %choice in %name element.', array('%choice' => $form[$key]['#value'], '%name' => empty($form['#title']) ? $form['#parents'][0] : $form['#title']), WATCHDOG_ERROR);}/** * Returns TRUE if the user is allowed to access this format. */function filter_access($format) {  $format = filter_resolve_format($format);  if (user_access('administer filters') || ($format == variable_get('filter_default_format', 1))) {    return TRUE;  }  else {    $formats = filter_formats();    return isset($formats[$format]);  }}/** * @} End of "Filtering functions". *//** * Helper function for fetching filter tips. */function _filter_tips($format, $long = FALSE) {  if ($format == -1) {    $formats = filter_formats();  }  else {    $formats = array(db_fetch_object(db_query("SELECT * FROM {filter_formats} WHERE format = %d", $format)));  }  $tips = array();  foreach ($formats as $format) {    $filters = filter_list_format($format->format);    $tips[$format->name] = array();    foreach ($filters as $id => $filter) {      if ($tip = module_invoke($filter->module, 'filter_tips', $filter->delta, $format->format, $long)) {        $tips[$format->name][] = array('tip' => $tip, 'id' => $id);      }    }  }  return $tips;}/** * Format a link to the more extensive filter tips. * * @ingroup themeable */function theme_filter_tips_more_info() {  return '<p>'. l(t('More information about formatting options'), 'filter/tips') .'</p>';}/** * @name Standard filters * @{ * Filters implemented by the filter.module. *//** * Implementation of hook_filter(). Contains a basic set of essential filters. * - HTML filter: *     Validates user-supplied HTML, transforming it as necessary. * - Line break converter: *     Converts newlines into paragraph and break tags. * - URL and e-mail address filter: *     Converts newlines into paragraph and break tags. */function filter_filter($op, $delta = 0, $format = -1, $text = '') {  switch ($op) {    case 'list':      return array(0 => t('HTML filter'), 1 => t('Line break converter'), 2 => t('URL filter'), 3 => t('HTML corrector'));    case 'description':      switch ($delta) {        case 0:          return t('Allows you to restrict whether users can post HTML and which tags to filter out. It will also remove harmful content such as JavaScript events, JavaScript URLs and CSS styles from those tags that are not removed.');        case 1:          return t('Converts line breaks into HTML (i.e. &lt;br&gt; and &lt;p&gt; tags).');        case 2:          return t('Turns web and e-mail addresses into clickable links.');        case 3:          return t('Corrects faulty and chopped off HTML in postings.');        default:          return;      }    case 'process':      switch ($delta) {        case 0:          return _filter_html($text, $format);        case 1:          return _filter_autop($text);        case 2:          return _filter_url($text, $format);        case 3:          return _filter_htmlcorrector($text);        default:          return $text;      }    case 'settings':      switch ($delta) {        case 0:          return _filter_html_settings($format);        case 2:          return _filter_url_settings($format);        default:          return;      }    default:      return $text;  }}/** * Settings for the HTML filter. */function _filter_html_settings($format) {  $form['filter_html'] = array(    '#type' => 'fieldset',    '#title' => t('HTML filter'),    '#collapsible' => TRUE,  );  $form['filter_html']["filter_html_$format"] = array(    '#type' => 'radios',    '#title' => t('Filter HTML tags'),    '#default_value' => variable_get("filter_html_$format", FILTER_HTML_STRIP),    '#options' => array(FILTER_HTML_STRIP => t('Strip disallowed tags'), FILTER_HTML_ESCAPE => t('Escape all tags')),    '#description' => t('How to deal with HTML tags in user-contributed content. If set to "Strip disallowed tags", dangerous tags are removed (see below). If set to "Escape tags", all HTML is escaped and presented as it was typed.'),  );  $form['filter_html']["allowed_html_$format"] = array(    '#type' => 'textfield',    '#title' => t('Allowed HTML tags'),    '#default_value' => variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>'),    '#size' => 64,    '#maxlength' => 1024,    '#description' => t('If "Strip disallowed tags" is selected, optionally specify tags which should not be stripped. JavaScript event attributes are always stripped.'),  );  $form['filter_html']["filter_html_help_$format"] = array(    '#type' => 'checkbox',    '#title' => t('Display HTML help'),    '#default_value' => variable_get("filter_html_help_$format", 1),    '#description' => t('If enabled, Drupal will display some basic HTML help in the long filter tips.'),  );  $form['filter_html']["filter_html_nofollow_$format"] = array(    '#type' => 'checkbox',    '#title' => t('Spam link deterrent'),    '#default_value' => variable_get("filter_html_nofollow_$format", FALSE),    '#description' => t('If enabled, Drupal will add rel="nofollow" to all links, as a measure to reduce the effectiveness of spam links. Note: this will also prevent valid links from being followed by search engines, therefore it is likely most effective when enabled for anonymous users.'),  );  return $form;}/** * HTML filter. Provides filtering of input into accepted HTML. */function _filter_html($text, $format) {  if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_STRIP) {    $allowed_tags = preg_split('/\s+|<|>/', variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>'), -1, PREG_SPLIT_NO_EMPTY);    $text = filter_xss($text, $allowed_tags);  }  if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_ESCAPE) {    // Escape HTML    $text = check_plain($text);  }  if (variable_get("filter_html_nofollow_$format", FALSE)) {    $text = preg_replace('/<a([^>]+)>/i', '<a\\1 rel="nofollow">', $text);  }  return trim($text);}/** * Settings for URL filter. */function _filter_url_settings($format) {  $form['filter_urlfilter'] = array(    '#type' => 'fieldset',    '#title' => t('URL filter'),    '#collapsible' => TRUE,  );  $form['filter_urlfilter']['filter_url_length_'. $format] = array(    '#type' => 'textfield',    '#title' => t('Maximum link text length'),    '#default_value' => variable_get('filter_url_length_'. $format, 72),    '#maxlength' => 4,    '#description' => t('URLs longer than this number of characters will be truncated to prevent long strings that break formatting. The link itself will be retained; just the text portion of the link will be truncated.'),  );  return $form;}/** * URL filter. Automatically converts text web addresses (URLs, e-mail addresses, * ftp links, etc.) into hyperlinks. */function _filter_url($text, $format) {  // Pass length to regexp callback  _filter_url_trim(NULL, variable_get('filter_url_length_'. $format, 72));  $text = ' '. $text .' ';  // Match absolute URLs.  $text = preg_replace_callback("`(<p>|<li>|<br\s*/?>|[ \n\r\t\(])((http://|https://|ftp://|mailto:|smb://|afp://|file://|gopher://|news://|ssl://|sslv2://|sslv3://|tls://|tcp://|udp://)([a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+*~#&=/;-]))([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '_filter_url_parse_full_links', $text);  // Match e-mail addresses.  $text = preg_replace("`(<p>|<li>|<br\s*/?>|[ \n\r\t\(])([A-Za-z0-9._-]+@[A-Za-z0-9._+-]+\.[A-Za-z]{2,4})([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '\1<a href="mailto:\2">\2</a>\3', $text);  // Match www domains/addresses.  $text = preg_replace_callback("`(<p>|<li>|[ \n\r\t\(])(www\.[a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+~#\&=/;-])([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '_filter_url_parse_partial_links', $text);  $text = substr($text, 1, -1);  return $text;}/** * Scan input and make sure that all HTML tags are properly closed and nested. */function _filter_htmlcorrector($text) {  // Prepare tag lists.  static $no_nesting, $single_use;  if (!isset($no_nesting)) {    // Tags which cannot be nested but are typically left unclosed.    $no_nesting = drupal_map_assoc(array('li', 'p'));    // Single use tags in HTML4    $single_use = drupal_map_assoc(array('base', 'meta', 'link', 'hr', 'br', 'param', 'img', 'area', 'input', 'col', 'frame'));  }  // Properly entify angles.  $text = preg_replace('!<([^a-zA-Z/])!', '&lt;\1', $text);  // Split tags from text.  $split = preg_split('/<([^>]+?)>/', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting $null as required).  $tag = false; // Odd/even counter. Tag or no tag.  $stack = array();  $output = '';  foreach ($split as $value) {    // Process HTML tags.    if ($tag) {      list($tagname) = explode(' ', strtolower($value), 2);      // Closing tag      if ($tagname{0} == '/') {        $tagname = substr($tagname, 1);        // Discard XHTML closing tags for single use tags.        if (!isset($single_use[$tagname])) {          // See if we possibly have a matching opening tag on the stack.          if (in_array($tagname, $stack)) {            // Close other tags lingering first.            do {              $output .= '</'. $stack[0] .'>';            } while (array_shift($stack) != $tagname);          }          // Otherwise, discard it.        }      }      // Opening tag      else {        // See if we have an identical 'no nesting' tag already open and close it if found.        if (count($stack) && ($stack[0] == $tagname) && isset($no_nesting[$stack[0]])) {          $output .= '</'. array_shift($stack) .'>';        }        // Push non-single-use tags onto the stack        if (!isset($single_use[$tagname])) {          array_unshift($stack, $tagname);        }        // Add trailing slash to single-use tags as per X(HT)ML.        else {          $value = rtrim($value, ' /') .' /';        }        $output .= '<'. $value .'>';      }    }    else {      // Passthrough all text.      $output .= $value;    }    $tag = !$tag;  }  // Close remaining tags.  while (count($stack) > 0) {    $output .= '</'. array_shift($stack) .'>';  }  return $output;}/** * Make links out of absolute URLs. */function _filter_url_parse_full_links($match) {  $match[2] = decode_entities($match[2]);  $caption = check_plain(_filter_url_trim($match[2]));  $match[2] = check_url($match[2]);  return $match[1] .'<a href="'. $match[2] .'" title="'. $match[2] .'">'. $caption .'</a>'. $match[5];}/** * Make links out of domain names starting with "www." */function _filter_url_parse_partial_links($match) {  $match[2] = decode_entities($match[2]);  $caption = check_plain(_filter_url_trim($match[2]));  $match[2] = check_plain($match[2]);  return $match[1] .'<a href="http://'. $match[2] .'" title="'. $match[2] .'">'. $caption .'</a>'. $match[3];}/** * Shortens long URLs to http://www.example.com/long/url... */function _filter_url_trim($text, $length = NULL) {  static $_length;  if ($length !== NULL) {    $_length = $length;  }  // Use +3 for '...' string length.  if (strlen($text) > $_length + 3) {    $text = substr($text, 0, $_length) .'...';  }  return $text;}/** * Convert line breaks into <p> and <br> in an intelligent fashion. * Based on: http://photomatt.net/scripts/autop */function _filter_autop($text) {  // All block level tags  $block = '(?:table|thead|tfoot|caption|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|select|form|blockquote|address|p|h[1-6]|hr)';  // Split at <pre>, <script>, <style> and </pre>, </script>, </style> tags.  // We don't apply any processing to the contents of these tags to avoid messing  // up code. We look for matched pairs and allow basic nesting. For example:  // "processed <pre> ignored <script> ignored </script> ignored </pre> processed"  $chunks = preg_split('@(</?(?:pre|script|style|object)[^>]*>)@i', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting NULL as required).  $ignore = FALSE;  $ignoretag = '';  $output = '';  foreach ($chunks as $i => $chunk) {    if ($i % 2) {      // Opening or closing tag?      $open = ($chunk[1] != '/');      list($tag) = split('[ >]', substr($chunk, 2 - $open), 2);      if (!$ignore) {        if ($open) {          $ignore = TRUE;          $ignoretag = $tag;        }      }      // Only allow a matching tag to close it.      else if (!$open && $ignoretag == $tag) {        $ignore = FALSE;        $ignoretag = '';      }    }    else if (!$ignore) {      $chunk = preg_replace('|\n*$|', '', $chunk) ."\n\n"; // just to make things a little easier, pad the end      $chunk = preg_replace('|<br />\s*<br />|', "\n\n", $chunk);      $chunk = preg_replace('!(<'. $block .'[^>]*>)!', "\n$1", $chunk); // Space things out a little      $chunk = preg_replace('!(</'. $block .'>)!', "$1\n\n", $chunk); // Space things out a little      $chunk = preg_replace("/\n\n+/", "\n\n", $chunk); // take care of duplicates      $chunk = preg_replace('/\n?(.+?)(?:\n\s*\n|\z)/s', "<p>$1</p>\n", $chunk); // make paragraphs, including one at the end      $chunk = preg_replace("|<p>(<li.+?)</p>|", "$1", $chunk); // problem with nested lists      $chunk = preg_replace('|<p><blockquote([^>]*)>|i', "<blockquote$1><p>", $chunk);      $chunk = str_replace('</blockquote></p>', '</p></blockquote>', $chunk);      $chunk = preg_replace('|<p>\s*</p>\n?|', '', $chunk); // under certain strange conditions it could create a P of entirely whitespace      $chunk = preg_replace('!<p>\s*(</?'. $block .'[^>]*>)!', "$1", $chunk);      $chunk = preg_replace('!(</?'. $block .'[^>]*>)\s*</p>!', "$1", $chunk);      $chunk = preg_replace('|(?<!<br />)\s*\n|', "<br />\n", $chunk); // make line breaks      $chunk = preg_replace('!(</?'. $block .'[^>]*>)\s*<br />!', "$1", $chunk);      $chunk = preg_replace('!<br />(\s*</?(?:p|li|div|th|pre|td|ul|ol)>)!', '$1', $chunk);      $chunk = preg_replace('/&([^#])(?![A-Za-z0-9]{1,8};)/', '&amp;$1', $chunk);    }    $output .= $chunk;  }  return $output;}/** * Very permissive XSS/HTML filter for admin-only use. * * Use only for fields where it is impractical to use the * whole filter system, but where some (mainly inline) mark-up * is desired (so check_plain() is not acceptable). * * Allows all tags that can be used inside an HTML body, save * for scripts and styles. */function filter_xss_admin($string) {  return filter_xss($string, array('a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big', 'blockquote', 'br', 'caption', 'cite', 'code', 'col', 'colgroup', 'dd', 'del', 'dfn', 'div', 'dl', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'ol', 'p', 'pre', 'q', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'ul', 'var'));}/** * Filters XSS. Based on kses by Ulf Harnhammar, see * http://sourceforge.net/projects/kses * * For examples of various XSS attacks, see: * http://ha.ckers.org/xss.html * * This code does four things: * - Removes characters and constructs that can trick browsers * - Makes sure all HTML entities are well-formed * - Makes sure all HTML tags and attributes are well-formed * - Makes sure no HTML tags contain URLs with a disallowed protocol (e.g. javascript:) * * @param $string *   The string with raw HTML in it. It will be stripped of everything that can cause *   an XSS attack. * @param $allowed_tags *   An array of allowed tags. */function filter_xss($string, $allowed_tags = array('a', 'em', 'strong', 'cite', 'code', 'ul', 'ol', 'li', 'dl', 'dt', 'dd')) {  // Only operate on valid UTF-8 strings. This is necessary to prevent cross  // site scripting issues on Internet Explorer 6.  if (!drupal_validate_utf8($string)) {    return '';  }  // Store the input format  _filter_xss_split($allowed_tags, TRUE);  // Remove NUL characters (ignored by some browsers)  $string = str_replace(chr(0), '', $string);  // Remove Netscape 4 JS entities  $string = preg_replace('%&\s*\{[^}]*(\}\s*;?|$)%', '', $string);  // Defuse all HTML entities  $string = str_replace('&', '&amp;', $string);  // Change back only well-formed entities in our whitelist  // Decimal numeric entities  $string = preg_replace('/&amp;#([0-9]+;)/', '&#\1', $string);  // Hexadecimal numeric entities  $string = preg_replace('/&amp;#[Xx]0*((?:[0-9A-Fa-f]{2})+;)/', '&#x\1', $string);  // Named entities  $string = preg_replace('/&amp;([A-Za-z][A-Za-z0-9]*;)/', '&\1', $string);  return preg_replace_callback('%    (    <(?=[^a-zA-Z!/])  # a lone <    |                 # or    <[^>]*(>|$)       # a string that starts with a <, up until the > or the end of the string    |                 # or    >                 # just a >    )%x', '_filter_xss_split', $string);}/** * Processes an HTML tag. * * @param @m *   An array with various meaning depending on the value of $store. *   If $store is TRUE then the array contains the allowed tags. *   If $store is FALSE then the array has one element, the HTML tag to process. * @param $store *   Whether to store $m. * @return *   If the element isn't allowed, an empty string. Otherwise, the cleaned up *   version of the HTML element. */function _filter_xss_split($m, $store = FALSE) {  static $allowed_html;  if ($store) {    $allowed_html = array_flip($m);    return;  }  $string = $m[1];  if (substr($string, 0, 1) != '<') {    // We matched a lone ">" character    return '&gt;';  }  else if (strlen($string) == 1) {    // We matched a lone "<" character    return '&lt;';  }  if (!preg_match('%^<\s*(/\s*)?([a-zA-Z0-9]+)([^>]*)>?$%', $string, $matches)) {    // Seriously malformed    return '';  }  $slash = trim($matches[1]);  $elem = &$matches[2];  $attrlist = &$matches[3];  if (!isset($allowed_html[strtolower($elem)])) {    // Disallowed HTML element    return '';  }  if ($slash != '') {    return "</$elem>";  }  // Is there a closing XHTML slash at the end of the attributes?  // In PHP 5.1.0+ we could count the changes, currently we need a separate match  $xhtml_slash = preg_match('%\s?/\s*$%', $attrlist) ? ' /' : '';  $attrlist = preg_replace('%(\s?)/\s*$%', '\1', $attrlist);  // Clean up attributes  $attr2 = implode(' ', _filter_xss_attributes($attrlist));  $attr2 = preg_replace('/[<>]/', '', $attr2);  $attr2 = strlen($attr2) ? ' '. $attr2 : '';  return "<$elem$attr2$xhtml_slash>";}/** * Processes a string of HTML attributes. * * @return *   Cleaned up version of the HTML attributes. */function _filter_xss_attributes($attr) {  $attrarr = array();  $mode = 0;  $attrname = '';  while (strlen($attr) != 0) {    // Was the last operation successful?    $working = 0;    switch ($mode) {      case 0:        // Attribute name, href for instance        if (preg_match('/^([-a-zA-Z]+)/', $attr, $match)) {          $attrname = strtolower($match[1]);          $skip = ($attrname == 'style' || substr($attrname, 0, 2) == 'on');          $working = $mode = 1;          $attr = preg_replace('/^[-a-zA-Z]+/', '', $attr);        }        break;      case 1:        // Equals sign or valueless ("selected")        if (preg_match('/^\s*=\s*/', $attr)) {          $working = 1; $mode = 2;          $attr = preg_replace('/^\s*=\s*/', '', $attr);          break;        }        if (preg_match('/^\s+/', $attr)) {          $working = 1; $mode = 0;          if (!$skip) {            $attrarr[] = $attrname;          }          $attr = preg_replace('/^\s+/', '', $attr);        }        break;      case 2:        // Attribute value, a URL after href= for instance        if (preg_match('/^"([^"]*)"(\s+|$)/', $attr, $match)) {          $thisval = filter_xss_bad_protocol($match[1]);          if (!$skip) {            $attrarr[] = "$attrname=\"$thisval\"";          }          $working = 1;          $mode = 0;          $attr = preg_replace('/^"[^"]*"(\s+|$)/', '', $attr);          break;        }        if (preg_match("/^'([^']*)'(\s+|$)/", $attr, $match)) {          $thisval = filter_xss_bad_protocol($match[1]);          if (!$skip) {            $attrarr[] = "$attrname='$thisval'";;          }          $working = 1; $mode = 0;          $attr = preg_replace("/^'[^']*'(\s+|$)/", '', $attr);          break;        }        if (preg_match("%^([^\s\"']+)(\s+|$)%", $attr, $match)) {          $thisval = filter_xss_bad_protocol($match[1]);          if (!$skip) {            $attrarr[] = "$attrname=\"$thisval\"";          }          $working = 1; $mode = 0;          $attr = preg_replace("%^[^\s\"']+(\s+|$)%", '', $attr);        }        break;    }    if ($working == 0) {      // not well formed, remove and try again      $attr = preg_replace('/        ^        (        "[^"]*("|$)     # - a string that starts with a double quote, up until the next double quote or the end of the string        |               # or        \'[^\']*(\'|$)| # - a string that starts with a quote, up until the next quote or the end of the string        |               # or        \S              # - a non-whitespace character        )*              # any number of the above three        \s*             # any number of whitespaces        /x', '', $attr);      $mode = 0;    }  }  // the attribute list ends with a valueless attribute like "selected"  if ($mode == 1) {    $attrarr[] = $attrname;  }  return $attrarr;}/** * Processes an HTML attribute value and ensures it does not contain an URL * with a disallowed protocol (e.g. javascript:) * * @param $string *   The string with the attribute value. * @param $decode *   Whether to decode entities in the $string. Set to FALSE if the $string *   is in plain text, TRUE otherwise. Defaults to TRUE. * @return *   Cleaned up and HTML-escaped version of $string. */function filter_xss_bad_protocol($string, $decode = TRUE) {  static $allowed_protocols;  if (!isset($allowed_protocols)) {    $allowed_protocols = array_flip(variable_get('filter_allowed_protocols', array('http', 'https', 'ftp', 'news', 'nntp', 'telnet', 'mailto', 'irc', 'ssh', 'sftp', 'webcal', 'rtsp')));  }  // Get the plain text representation of the attribute value (i.e. its meaning).  if ($decode) {    $string = decode_entities($string);  }  // Iteratively remove any invalid protocol found.  do {    $before = $string;    $colonpos = strpos($string, ':');    if ($colonpos > 0) {      // We found a colon, possibly a protocol. Verify.      $protocol = substr($string, 0, $colonpos);      // If a colon is preceded by a slash, question mark or hash, it cannot      // possibly be part of the URL scheme. This must be a relative URL,      // which inherits the (safe) protocol of the base document.      if (preg_match('![/?#]!', $protocol)) {        break;      }      // Per RFC2616, section 3.2.3 (URI Comparison) scheme comparison must be case-insensitive      // Check if this is a disallowed protocol.      if (!isset($allowed_protocols[strtolower($protocol)])) {        $string = substr($string, $colonpos + 1);      }    }  } while ($before != $string);  return check_plain($string);}/** * @} End of "Standard filters". */
<?php// $Id$/** * Implementation of hook_install(). */function php_install() {  $format_exists = db_result(db_query("SELECT COUNT(*) FROM {filter_formats} WHERE name = 'PHP code'"));  // Add a PHP code input format, if it does not exist. Do this only for the  // first install (or if the format has been manually deleted) as there is no  // reliable method to identify the format in an uninstall hook or in  // subsequent clean installs.  if (!$format_exists) {    db_query("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('PHP code', '', 0)");    $format = db_result(db_query("SELECT MAX(format) FROM {filter_formats}"));    // Enable the PHP evaluator filter.    db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, 'php', 0, 0)", $format);    drupal_set_message(t('A !php-code input format has been created.', array('!php-code' => l('PHP code', 'admin/settings/filters/'. $format))));  }}/** * Implementation of hook_disable(). */function php_disable() {  drupal_set_message(t('The PHP module has been disabled. Please note that any existing content that was using the PHP filter will now be visible in plain text. This might pose a security risk by exposing sensitive information, if any, used in the PHP code.'));}
<?php// $Id$?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>">  <head>    <?php print $head ?>    <title><?php print $head_title ?></title>    <?php print $styles ?>    <?php print $scripts ?>    <!--[if lt IE 7]>      <?php print phptemplate_get_ie_styles(); ?>    <![endif]-->  </head>  <body<?php print phptemplate_body_class($left, $right); ?>><!-- Layout -->  <div id="header-region" class="clear-block"><?php print $header; ?></div>    <div id="wrapper">    <div id="container" class="clear-block">      <div id="header">        <div id="logo-floater">        <?php          // Prepare header          $site_fields = array();          if ($site_name) {            $site_fields[] = check_plain($site_name);          }          if ($site_slogan) {            $site_fields[] = check_plain($site_slogan);          }          $site_title = implode(' ', $site_fields);          if ($site_fields) {            $site_fields[0] = '<span>'. $site_fields[0] .'</span>';          }          $site_html = implode(' ', $site_fields);          if ($logo || $site_title) {            print '<h1><a href="'. check_url($front_page) .'" title="'. $site_title .'">';            if ($logo) {              print '<img src="'. check_url($logo) .'" alt="'. $site_title .'" id="logo" />';            }            print $site_html .'</a></h1>';          }        ?>        </div>        <?php if (isset($primary_links)) : ?>          <?php print theme('links', $primary_links, array('class' => 'links primary-links')) ?>        <?php endif; ?>        <?php if (isset($secondary_links)) : ?>          <?php print theme('links', $secondary_links, array('class' => 'links secondary-links')) ?>        <?php endif; ?>      </div> <!-- /header -->      <?php if ($left): ?>        <div id="sidebar-left" class="sidebar">          <?php if ($search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $left ?>        </div>      <?php endif; ?>      <div id="center"><div id="squeeze"><div class="right-corner"><div class="left-corner">          <?php print $breadcrumb; ?>          <?php if ($mission): print '<div id="mission">'. $mission .'</div>'; endif; ?>          <?php if ($tabs): print '<div id="tabs-wrapper" class="clear-block">'; endif; ?>          <?php if ($title): print '<h2'. ($tabs ? ' class="with-tabs"' : '') .'>'. $title .'</h2>'; endif; ?>          <?php if ($tabs): print '<ul class="tabs primary">'. $tabs .'</ul></div>'; endif; ?>          <?php if ($tabs2): print '<ul class="tabs secondary">'. $tabs2 .'</ul>'; endif; ?>          <?php if ($show_messages && $messages): print $messages; endif; ?>          <?php print $help; ?>          <div class="clear-block">            <?php print $content ?>          </div>          <?php print $feed_icons ?>          <div id="footer"><?php print $footer_message . $footer ?></div>      </div></div></div></div> <!-- /.left-corner, /.right-corner, /#squeeze, /#center -->      <?php if ($right): ?>        <div id="sidebar-right" class="sidebar">          <?php if (!$left && $search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $right ?>        </div>      <?php endif; ?>    </div> <!-- /container -->  </div><!-- /layout -->  <?php print $closure ?>  </body></html>
<?php// $Id$/** * @file * User session handling functions. */function sess_open($save_path, $session_name) {  return TRUE;}function sess_close() {  return TRUE;}function sess_read($key) {  global $user;  // Write and Close handlers are called after destructing objects since PHP 5.0.5  // Thus destructors can use sessions but session handler can't use objects.  // So we are moving session closure before destructing objects.  register_shutdown_function('session_write_close');  // Handle the case of first time visitors and clients that don't store cookies (eg. web crawlers).  if (!isset($_COOKIE[session_name()])) {    $user = drupal_anonymous_user();    return '';  }  // Otherwise, if the session is still active, we have a record of the client's session in the database.  $user = db_fetch_object(db_query("SELECT u.*, s.* FROM {users} u INNER JOIN {sessions} s ON u.uid = s.uid WHERE s.sid = '%s'", $key));  // We found the client's session record and they are an authenticated,  // active user.  if ($user && $user->uid > 0 && $user->status == 1) {    // This is done to unserialize the data member of $user    $user = drupal_unpack($user);    // Add roles element to $user    $user->roles = array();    $user->roles[DRUPAL_AUTHENTICATED_RID] = 'authenticated user';    $result = db_query("SELECT r.rid, r.name FROM {role} r INNER JOIN {users_roles} ur ON ur.rid = r.rid WHERE ur.uid = %d", $user->uid);    while ($role = db_fetch_object($result)) {      $user->roles[$role->rid] = $role->name;    }  }  // We didn't find the client's record (session has expired), or they are  // blocked, or they are an anonymous user.  else {    $session = isset($user->session) ? $user->session : '';    $user = drupal_anonymous_user($session);  }  return $user->session;}function sess_write($key, $value) {  global $user;  // If saving of session data is disabled or if the client doesn't have a session,  // and one isn't being created ($value), do nothing. This keeps crawlers out of  // the session table. This reduces memory and server load, and gives more useful  // statistics. We can't eliminate anonymous session table rows without breaking  // the throttle module and the "Who's Online" block.  if (!session_save_session() || ($user->uid == 0 && empty($_COOKIE[session_name()]) && empty($value))) {    return TRUE;  }  db_query("UPDATE {sessions} SET uid = %d, cache = %d, hostname = '%s', session = '%s', timestamp = %d WHERE sid = '%s'", $user->uid, isset($user->cache) ? $user->cache : '', ip_address(), $value, time(), $key);  if (db_affected_rows()) {    // Last access time is updated no more frequently than once every 180 seconds.    // This reduces contention in the users table.    if ($user->uid && time() - $user->access > variable_get('session_write_interval', 180)) {      db_query("UPDATE {users} SET access = %d WHERE uid = %d", time(), $user->uid);    }  }  else {    // If this query fails, another parallel request probably got here first.    // In that case, any session data generated in this request is discarded.    @db_query("INSERT INTO {sessions} (sid, uid, cache, hostname, session, timestamp) VALUES ('%s', %d, %d, '%s', '%s', %d)", $key, $user->uid, isset($user->cache) ? $user->cache : '', ip_address(), $value, time());  }  return TRUE;}/** * Called when an anonymous user becomes authenticated or vice-versa. */function sess_regenerate() {  $old_session_id = session_id();  // We code around http://bugs.php.net/bug.php?id=32802 by destroying  // the session cookie by setting expiration in the past (a negative  // value).  This issue only arises in PHP versions before 4.4.0,  // regardless of the Drupal configuration.  // TODO: remove this when we require at least PHP 4.4.0  if (isset($_COOKIE[session_name()])) {    setcookie(session_name(), '', time() - 42000, '/');  }  session_regenerate_id();  db_query("UPDATE {sessions} SET sid = '%s' WHERE sid = '%s'", session_id(), $old_session_id);}/** * Counts how many users have sessions. Can count either anonymous sessions or authenticated sessions. * * @param int $timestamp *   A Unix timestamp representing a point of time in the past. *   The default is 0, which counts all existing sessions. * @param boolean $anonymous *   TRUE counts only anonymous users. *   FALSE counts only authenticated users. * @return  int *   The number of users with sessions. */function sess_count($timestamp = 0, $anonymous = true) {  $query = $anonymous ? ' AND uid = 0' : ' AND uid > 0';  return db_result(db_query('SELECT COUNT(sid) AS count FROM {sessions} WHERE timestamp >= %d'. $query, $timestamp));}/** * Called by PHP session handling with the PHP session ID to end a user's session. * * @param  string $sid *   the session id */function sess_destroy_sid($sid) {  db_query("DELETE FROM {sessions} WHERE sid = '%s'", $sid);}/** * End a specific user's session * * @param  string $uid *   the user id */function sess_destroy_uid($uid) {  db_query('DELETE FROM {sessions} WHERE uid = %d', $uid);}function sess_gc($lifetime) {  // Be sure to adjust 'php_value session.gc_maxlifetime' to a large enough  // value. For example, if you want user sessions to stay in your database  // for three weeks before deleting them, you need to set gc_maxlifetime  // to '1814400'. At that value, only after a user doesn't log in after  // three weeks (1814400 seconds) will his/her session be removed.  db_query("DELETE FROM {sessions} WHERE timestamp < %d", time() - $lifetime);  return TRUE;}/** * Determine whether to save session data of the current request. * * This function allows the caller to temporarily disable writing of session data, * should the request end while performing potentially dangerous operations, such as * manipulating the global $user object.  See http://drupal.org/node/218104 for usage * * @param $status *   Disables writing of session data when FALSE, (re-)enables writing when TRUE. * @return *   FALSE if writing session data has been disabled. Otherwise, TRUE. */function session_save_session($status = NULL) {  static $save_session = TRUE;  if (isset($status)) {    $save_session = $status;  }  return ($save_session);}
<?php// $Id$/** * Implementation of hook_install(). */function profile_install() {  // Create tables.  drupal_install_schema('profile');}/** * Implementation of hook_uninstall(). */function profile_uninstall() {  // Remove tables  drupal_uninstall_schema('profile');  variable_del('profile_block_author_fields');}/** * Implementation of hook_schema(). */function profile_schema() {  $schema['profile_fields'] = array(    'description' => 'Stores profile field information.',    'fields' => array(      'fid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique profile field ID.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => 'Title of the field shown to the end user.',      ),      'name' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Internal name of the field used in the form HTML and URLs.',      ),      'explanation' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'Explanation of the field to end users.',      ),      'category' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => 'Profile category that the field will be grouped under.',      ),      'page' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => "Title of page used for browsing by the field's value",      ),      'type' => array(        'type' => 'varchar',        'length' => 128,        'not null' => FALSE,        'description' => 'Type of form field.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Weight of field in relation to other profile fields.',      ),      'required' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether the user is required to enter a value. (0 = no, 1 = yes)',      ),      'register' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether the field is visible in the user registration form. (1 = yes, 0 = no)',      ),      'visibility' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The level of visibility for the field. (0 = hidden, 1 = private, 2 = public on profile but not member list pages, 3 = public on profile and list pages)',      ),      'autocomplete' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether form auto-completion is enabled. (0 = disabled, 1 = enabled)',      ),      'options' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'List of options to be used in a list selection field.',      ),    ),    'indexes' => array('category' => array('category')),    'unique keys' => array('name' => array('name')),    'primary key' => array('fid'),  );  $schema['profile_values'] = array(    'description' => 'Stores values for profile fields.',    'fields' => array(      'fid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {profile_fields}.fid of the field.',      ),      'uid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {users}.uid of the profile user.',      ),      'value' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'The value for the field.',      ),    ),    'primary key' => array('uid', 'fid'),    'indexes' => array(      'fid' => array('fid'),    ),  );  return $schema;}
<?php// $Id$/** * @file * Enables users to rename URLs. *//** * Implementation of hook_help(). */function path_help($path, $arg) {  switch ($path) {    case 'admin/help#path':      $output = '<p>'. t('The path module allows you to specify aliases for Drupal URLs. Such aliases improve readability of URLs for your users and may help internet search engines to index your content more effectively. More than one alias may be created for a given page.') .'</p>';      $output .= t('<p>Some examples of URL aliases are:</p><ul><li>user/login =&gt; login</li><li>image/tid/16 =&gt; store</li><li>taxonomy/term/7+19+20+21 =&gt; store/products/whirlygigs</li><li>node/3 =&gt; contact</li></ul>');      $output .= '<p>'. t('The path module enables appropriately permissioned users to specify an optional alias in all node input and editing forms, and provides an interface to view and edit all URL aliases. The two permissions related to URL aliasing are <em>administer url aliases</em> and <em>create url aliases</em>. ') .'</p>';      $output .= '<p>'. t('This module also provides user-defined mass URL aliasing capabilities, which is useful if you wish to uniformly use URLs different from the default. For example, you may want to have your URLs presented in a different language. Access to the Drupal source code on the web server is required to set up mass URL aliasing. ') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@path">Path module</a>.', array('@path' => 'http://drupal.org/handbook/modules/path/')) .'</p>';      return $output;    case 'admin/build/path':      return '<p>'. t("Drupal provides complete control over URLs through aliasing, which is often used to make URLs more readable or easy to remember. For example, the alias 'about' may be mapped onto the post at the system path 'node/1', creating a more meaningful URL. Each system path can have multiple aliases.") .'</p>';    case 'admin/build/path/add':      return '<p>'. t('Enter the path you wish to create the alias for, followed by the name of the new alias.') .'</p>';  }}/** * Implementation of hook_menu(). */function path_menu() {  $items['admin/build/path'] = array(    'title' => 'URL aliases',    'description' => "Change your site's URL paths by aliasing them.",    'page callback' => 'path_admin_overview',    'access arguments' => array('administer url aliases'),    'file' => 'path.admin.inc',  );  $items['admin/build/path/edit'] = array(    'title' => 'Edit alias',    'page callback' => 'path_admin_edit',    'access arguments' => array('administer url aliases'),    'type' => MENU_CALLBACK,    'file' => 'path.admin.inc',  );  $items['admin/build/path/delete'] = array(    'title' => 'Delete alias',    'page callback' => 'drupal_get_form',    'page arguments' => array('path_admin_delete_confirm'),    'access arguments' => array('administer url aliases'),    'type' => MENU_CALLBACK,    'file' => 'path.admin.inc',  );  $items['admin/build/path/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/build/path/add'] = array(    'title' => 'Add alias',    'page callback' => 'path_admin_edit',    'access arguments' => array('administer url aliases'),    'type' => MENU_LOCAL_TASK,    'file' => 'path.admin.inc',  );  return $items;}/** * Post-confirmation; delete an URL alias. */function path_admin_delete($pid = 0) {  db_query('DELETE FROM {url_alias} WHERE pid = %d', $pid);  drupal_set_message(t('The alias has been deleted.'));}/** * Set an aliased path for a given Drupal path, preventing duplicates. */function path_set_alias($path = NULL, $alias = NULL, $pid = NULL, $language = '') {  $path = urldecode($path);  $alias = urldecode($alias);  // First we check if we deal with an existing alias and delete or modify it based on pid.  if ($pid) {    // An existing alias.    if (!$path || !$alias) {      // Delete the alias based on pid.      db_query('DELETE FROM {url_alias} WHERE pid = %d', $pid);    }    else {      // Update the existing alias.      db_query("UPDATE {url_alias} SET src = '%s', dst = '%s', language = '%s' WHERE pid = %d", $path, $alias, $language, $pid);    }  }  else if ($path && $alias) {    // Check for existing aliases.    if ($alias == drupal_get_path_alias($path, $language)) {      // There is already such an alias, neutral or in this language.      // Update the alias based on alias; setting the language if not yet done.      db_query("UPDATE {url_alias} SET src = '%s', dst = '%s', language = '%s' WHERE dst = '%s'", $path, $alias, $language, $alias);    }    else {      // A new alias. Add it to the database.      db_query("INSERT INTO {url_alias} (src, dst, language) VALUES ('%s', '%s', '%s')", $path, $alias, $language);    }  }  else {    // Delete the alias.    if ($alias) {      db_query("DELETE FROM {url_alias} WHERE dst = '%s'", $alias);    }    else {      db_query("DELETE FROM {url_alias} WHERE src = '%s'", $path);    }  }  drupal_clear_path_cache();}/** * Implementation of hook_nodeapi(). * * Allows URL aliases for nodes to be specified at node edit time rather * than through the administrative interface. */function path_nodeapi(&$node, $op, $arg) {  // Permissions are required for everything except node loading.  if (user_access('create url aliases') || user_access('administer url aliases') || ($op == 'load')) {    $language = isset($node->language) ? $node->language : '';    switch ($op) {      case 'validate':        if (isset($node->path)) {          $node->path = trim($node->path);          if (db_result(db_query("SELECT COUNT(dst) FROM {url_alias} WHERE dst = '%s' AND src != '%s' AND language = '%s'", $node->path, "node/$node->nid", $language))) {            form_set_error('path', t('The path is already in use.'));          }        }        break;      case 'load':        $path = 'node/'. $node->nid;        $alias = drupal_get_path_alias($path, $language);        if ($path != $alias) {          $node->path = $alias;        }        break;      case 'insert':        // Don't try to insert if path is NULL. We may have already set        // the alias ahead of time.        if (isset($node->path)) {          path_set_alias('node/'. $node->nid, $node->path, NULL, $language);        }        break;      case 'update':        path_set_alias('node/'. $node->nid, isset($node->path) ? $node->path : NULL, isset($node->pid) ? $node->pid : NULL, $language);        break;      case 'delete':        $path = 'node/'. $node->nid;        if (drupal_get_path_alias($path) != $path) {          path_set_alias($path);        }        break;    }  }}/** * Implementation of hook_form_alter(). */function path_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {    $path = isset($form['#node']->path) ? $form['#node']->path : NULL;    $form['path'] = array(      '#type' => 'fieldset',      '#title' => t('URL path settings'),      '#collapsible' => TRUE,      '#collapsed' => empty($path),      '#access' => user_access('create url aliases'),      '#weight' => 30,    );    $form['path']['path'] = array(      '#type' => 'textfield',      '#default_value' => $path,      '#maxlength' => 128,      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#description' => t('Optionally specify an alternative URL by which this node can be accessed. For example, type "about" when writing an about page. Use a relative path and don\'t add a trailing slash or the URL alias won\'t work.'),    );    if ($path) {      $form['path']['pid'] = array(        '#type' => 'value',        '#value' => db_result(db_query("SELECT pid FROM {url_alias} WHERE dst = '%s' AND language = '%s'", $path, $form['#node']->language))      );    }  }}/** * Implementation of hook_perm(). */function path_perm() {  return array('create url aliases', 'administer url aliases');}/** * Fetch a specific URL alias from the database. */function path_load($pid) {  return db_fetch_array(db_query('SELECT * FROM {url_alias} WHERE pid = %d', $pid));}
<?php// $Id$/** * @file forum-topic-navigation.tpl.php * Default theme implementation to display the topic navigation string at the * bottom of all forum topics. * * Available variables: * * - $prev: The node ID of the previous post. * - $prev_url: The URL of the previous post. * - $prev_title: The title of the previous post. * * - $next: The node ID of the next post. * - $next_url: The URL of the next post. * - $next_title: The title of the next post. * * - $node: The raw node currently being viewed. Contains unsafe data *   and any data in this must be cleaned before presenting. * * @see template_preprocess_forum_topic_navigation() * @see theme_forum_topic_navigation() */?><?php if ($prev || $next): ?>  <div class="forum-topic-navigation clear-block">    <?php if ($prev): ?>      <a href="<?php print $prev_url; ?>" class="topic-previous" title="<?php print t('Go to previous forum topic') ?>"> <?php print $prev_title ?></a>    <?php endif; ?>    <?php if ($next): ?>      <a href="<?php print $next_url; ?>" class="topic-next" title="<?php print t('Go to next forum topic') ?>"><?php print $next_title ?> </a>    <?php endif; ?>  </div><?php endif; ?>
<?php// $Id$/** * @defgroup forms Form builder functions * @{ * Functions that build an abstract representation of a HTML form. * * All modules should declare their form builder functions to be in this * group and each builder function should reference its validate and submit * functions using \@see. Conversely, validate and submit functions should * reference the form builder function using \@see. For examples, of this see * system_modules_uninstall() or user_pass(), the latter of which has the * following in its doxygen documentation: * * \@ingroup forms * \@see user_pass_validate(). * \@see user_pass_submit(). * * @} End of "defgroup forms". *//** * @defgroup form_api Form generation * @{ * Functions to enable the processing and display of HTML forms. * * Drupal uses these functions to achieve consistency in its form processing and * presentation, while simplifying code and reducing the amount of HTML that * must be explicitly generated by modules. * * The drupal_get_form() function handles retrieving, processing, and * displaying a rendered HTML form for modules automatically. For example: * * @code * // Display the user registration form. * $output = drupal_get_form('user_register'); * @endcode * * Forms can also be built and submitted programmatically without any user input * using the drupal_execute() function. * * For information on the format of the structured arrays used to define forms, * and more detailed explanations of the Form API workflow, see the * @link http://api.drupal.org/api/file/developer/topics/forms_api_reference.html reference @endlink * and the @link http://api.drupal.org/api/file/developer/topics/forms_api.html quickstart guide. @endlink *//** * Retrieves a form from a constructor function, or from the cache if * the form was built in a previous page-load. The form is then passed * on for processing, after and rendered for display if necessary. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param ... *   Any additional arguments are passed on to the functions called by *   drupal_get_form(), including the unique form constructor function. *   For example, the node_edit form requires that a node object be passed *   in here when it is called. * @return *   The rendered form. */function drupal_get_form($form_id) {  $form_state = array('storage' => NULL, 'submitted' => FALSE);  $args = func_get_args();  $cacheable = FALSE;  if (isset($_SESSION['batch_form_state'])) {    // We've been redirected here after a batch processing : the form has    // already been processed, so we grab the post-process $form_state value    // and move on to form display. See _batch_finished() function.    $form_state = $_SESSION['batch_form_state'];    unset($_SESSION['batch_form_state']);  }  else {    // If the incoming $_POST contains a form_build_id, we'll check the    // cache for a copy of the form in question. If it's there, we don't    // have to rebuild the form to proceed. In addition, if there is stored    // form_state data from a previous step, we'll retrieve it so it can    // be passed on to the form processing code.    if (isset($_POST['form_id']) && $_POST['form_id'] == $form_id && !empty($_POST['form_build_id'])) {      $form = form_get_cache($_POST['form_build_id'], $form_state);    }    // If the previous bit of code didn't result in a populated $form    // object, we're hitting the form for the first time and we need    // to build it from scratch.    if (!isset($form)) {      $form_state['post'] = $_POST;      // Use a copy of the function's arguments for manipulation      $args_temp = $args;      $args_temp[0] = &$form_state;      array_unshift($args_temp, $form_id);      $form = call_user_func_array('drupal_retrieve_form', $args_temp);      $form_build_id = 'form-'. md5(uniqid(mt_rand(), true));      $form['#build_id'] = $form_build_id;      drupal_prepare_form($form_id, $form, $form_state);      // Store a copy of the unprocessed form for caching and indicate that it      // is cacheable if #cache will be set.      $original_form = $form;      $cacheable = TRUE;      unset($form_state['post']);    }    $form['#post'] = $_POST;    // Now that we know we have a form, we'll process it (validating,    // submitting, and handling the results returned by its submission    // handlers. Submit handlers accumulate data in the form_state by    // altering the $form_state variable, which is passed into them by    // reference.    drupal_process_form($form_id, $form, $form_state);    if ($cacheable && !empty($form['#cache'])) {      // Caching is done past drupal_process_form so #process callbacks can      // set #cache.      form_set_cache($form_build_id, $original_form, $form_state);    }  }  // Most simple, single-step forms will be finished by this point --  // drupal_process_form() usually redirects to another page (or to  // a 'fresh' copy of the form) once processing is complete. If one  // of the form's handlers has set $form_state['redirect'] to FALSE,  // the form will simply be re-rendered with the values still in its  // fields.  //  // If $form_state['storage'] or $form_state['rebuild'] has been set  // and input has been processed, we know that we're in a complex  // multi-part process of some sort and the form's workflow is NOT  // complete. We need to construct a fresh copy of the form, passing  // in the latest $form_state in addition to any other variables passed  // into drupal_get_form().  if ((!empty($form_state['storage']) || !empty($form_state['rebuild'])) && !empty($form_state['process_input']) && !form_get_errors()) {    $form = drupal_rebuild_form($form_id, $form_state, $args);  }  // If we haven't redirected to a new location by now, we want to  // render whatever form array is currently in hand.  return drupal_render_form($form_id, $form);}/** * Retrieves a form, caches it and processes it with an empty $_POST. * * This function clears $_POST and passes the empty $_POST to the form_builder. * To preserve some parts from $_POST, pass them in $form_state. * * If your AHAH callback simulates the pressing of a button, then your AHAH * callback will need to do the same as what drupal_get_form would do when the * button is pressed: get the form from the cache, run drupal_process_form over * it and then if it needs rebuild, run drupal_rebuild_form over it. Then send * back a part of the returned form. * $form_state['clicked_button']['#array_parents'] will help you to find which * part. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param $form_state *   A keyed array containing the current state of the form. Most *   important is the $form_state['storage'] collection. * @param $args *   Any additional arguments are passed on to the functions called by *   drupal_get_form(), plus the original form_state in the beginning. If you *   are getting a form from the cache, use $form['#parameters'] to shift off *   the $form_id from its beginning then the resulting array can be used as *   $arg here. * @param $form_build_id *   If the AHAH callback calling this function only alters part of the form, *   then pass in the existing form_build_id so we can re-cache with the same *   csid. * @return *   The newly built form. */function drupal_rebuild_form($form_id, &$form_state, $args, $form_build_id = NULL) {  // Remove the first argument. This is $form_id.when called from  // drupal_get_form and the original $form_state when called from some AHAH  // callback. Neither is needed. After that, put in the current state.  $args[0] = &$form_state;  // And the form_id.  array_unshift($args, $form_id);  $form = call_user_func_array('drupal_retrieve_form', $args);  if (!isset($form_build_id)) {    // We need a new build_id for the new version of the form.    $form_build_id = 'form-'. md5(mt_rand());  }  $form['#build_id'] = $form_build_id;  drupal_prepare_form($form_id, $form, $form_state);  // Now, we cache the form structure so it can be retrieved later for  // validation. If $form_state['storage'] is populated, we'll also cache  // it so that it can be used to resume complex multi-step processes.  form_set_cache($form_build_id, $form, $form_state);  // Clear out all post data, as we don't want the previous step's  // data to pollute this one and trigger validate/submit handling,  // then process the form for rendering.  $_POST = array();  $form['#post'] = array();  drupal_process_form($form_id, $form, $form_state);  return $form;}/** * Store a form in the cache. */function form_set_cache($form_build_id, $form, $form_state) {  global $user;  // 6 hours cache life time for forms should be plenty.  $expire = 21600;  if ($user->uid) {    $form['#cache_token'] = drupal_get_token();  }  cache_set('form_'. $form_build_id, $form, 'cache_form', time() + $expire);  if (!empty($form_state['storage'])) {    cache_set('storage_'. $form_build_id, $form_state['storage'], 'cache_form', time() + $expire);  }}/** * Fetch a form from cache. */function form_get_cache($form_build_id, &$form_state) {  global $user;  if ($cached = cache_get('form_'. $form_build_id, 'cache_form')) {    $form = $cached->data;    if ((isset($form['#cache_token']) && drupal_valid_token($form['#cache_token'])) || (!isset($form['#cache_token']) && !$user->uid)) {      if ($cached = cache_get('storage_'. $form_build_id, 'cache_form')) {        $form_state['storage'] = $cached->data;      }      return $form;    }  }}/** * Retrieves a form using a form_id, populates it with $form_state['values'], * processes it, and returns any validation errors encountered. This * function is the programmatic counterpart to drupal_get_form(). * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param $form_state *   A keyed array containing the current state of the form. Most *   important is the $form_state['values'] collection, a tree of data *   used to simulate the incoming $_POST information from a user's *   form submission. * @param ... *   Any additional arguments are passed on to the functions called by *   drupal_execute(), including the unique form constructor function. *   For example, the node_edit form requires that a node object be passed *   in here when it is called. * For example: * * @code * // register a new user * $form_state = array(); * $form_state['values']['name'] = 'robo-user'; * $form_state['values']['mail'] = 'robouser@example.com'; * $form_state['values']['pass']['pass1'] = 'password'; * $form_state['values']['pass']['pass2'] = 'password'; * $form_state['values']['op'] = t('Create new account'); * drupal_execute('user_register', $form_state); * * // Create a new node * $form_state = array(); * module_load_include('inc', 'node', 'node.pages'); * $node = array('type' => 'story'); * $form_state['values']['title'] = 'My node'; * $form_state['values']['body'] = 'This is the body text!'; * $form_state['values']['name'] = 'robo-user'; * $form_state['values']['op'] = t('Save'); * drupal_execute('story_node_form', $form_state, (object)$node); * @endcode */function drupal_execute($form_id, &$form_state) {  $args = func_get_args();  // Make sure $form_state is passed around by reference.  $args[1] = &$form_state;    $form = call_user_func_array('drupal_retrieve_form', $args);  $form['#post'] = $form_state['values'];  drupal_prepare_form($form_id, $form, $form_state);  drupal_process_form($form_id, $form, $form_state);}/** * Retrieves the structured array that defines a given form. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. * @param $form_state *   A keyed array containing the current state of the form. * @param ... *   Any additional arguments needed by the unique form constructor *   function. Generally, these are any arguments passed into the *   drupal_get_form() or drupal_execute() functions after the first *   argument. If a module implements hook_forms(), it can examine *   these additional arguments and conditionally return different *   builder functions as well. */function drupal_retrieve_form($form_id, &$form_state) {  static $forms;  // We save two copies of the incoming arguments: one for modules to use  // when mapping form ids to constructor functions, and another to pass to  // the constructor function itself. We shift out the first argument -- the  // $form_id itself -- from the list to pass into the constructor function,  // since it's already known.  $args = func_get_args();  $saved_args = $args;  array_shift($args);  if (isset($form_state)) {    array_shift($args);  }  // We first check to see if there's a function named after the $form_id.  // If there is, we simply pass the arguments on to it to get the form.  if (!function_exists($form_id)) {    // In cases where many form_ids need to share a central constructor function,    // such as the node editing form, modules can implement hook_forms(). It    // maps one or more form_ids to the correct constructor functions.    //    // We cache the results of that hook to save time, but that only works    // for modules that know all their form_ids in advance. (A module that    // adds a small 'rate this comment' form to each comment in a list    // would need a unique form_id for each one, for example.)    //    // So, we call the hook if $forms isn't yet populated, OR if it doesn't    // yet have an entry for the requested form_id.    if (!isset($forms) || !isset($forms[$form_id])) {      $forms = module_invoke_all('forms', $form_id, $args);    }    $form_definition = $forms[$form_id];    if (isset($form_definition['callback arguments'])) {      $args = array_merge($form_definition['callback arguments'], $args);    }    if (isset($form_definition['callback'])) {      $callback = $form_definition['callback'];    }  }  array_unshift($args, NULL);  $args[0] = &$form_state;  // If $callback was returned by a hook_forms() implementation, call it.  // Otherwise, call the function named after the form id.  $form = call_user_func_array(isset($callback) ? $callback : $form_id, $args);  // We store the original function arguments, rather than the final $arg  // value, so that form_alter functions can see what was originally  // passed to drupal_retrieve_form(). This allows the contents of #parameters  // to be saved and passed in at a later date to recreate the form.  $form['#parameters'] = $saved_args;  return $form;}/** * This function is the heart of form API. The form gets built, validated and in * appropriate cases, submitted. * * @param $form_id *   The unique string identifying the current form. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. This *   includes the current persistent storage data for the form, and *   any data passed along by earlier steps when displaying a *   multi-step form. Additional information, like the sanitized $_POST *   data, is also accumulated here. */function drupal_process_form($form_id, &$form, &$form_state) {  $form_state['values'] = array();  $form = form_builder($form_id, $form, $form_state);  // Only process the form if it is programmed or the form_id coming  // from the POST data is set and matches the current form_id.  if ((!empty($form['#programmed'])) || (!empty($form['#post']) && (isset($form['#post']['form_id']) && ($form['#post']['form_id'] == $form_id)))) {    $form_state['process_input'] = TRUE;    drupal_validate_form($form_id, $form, $form_state);    // form_clean_id() maintains a cache of element IDs it has seen,    // so it can prevent duplicates. We want to be sure we reset that    // cache when a form is processed, so scenerios that result in    // the form being built behind the scenes and again for the    // browser don't increment all the element IDs needlessly.    form_clean_id(NULL, TRUE);    if ((!empty($form_state['submitted'])) && !form_get_errors() && empty($form_state['rebuild'])) {      $form_state['redirect'] = NULL;      form_execute_handlers('submit', $form, $form_state);      // We'll clear out the cached copies of the form and its stored data      // here, as we've finished with them. The in-memory copies are still      // here, though.      if (variable_get('cache', CACHE_DISABLED) == CACHE_DISABLED && !empty($form_state['values']['form_build_id'])) {        cache_clear_all('form_'. $form_state['values']['form_build_id'], 'cache_form');        cache_clear_all('storage_'. $form_state['values']['form_build_id'], 'cache_form');      }      // If batches were set in the submit handlers, we process them now,      // possibly ending execution. We make sure we do not react to the batch      // that is already being processed (if a batch operation performs a      // drupal_execute).      if ($batch =& batch_get() && !isset($batch['current_set'])) {        // The batch uses its own copies of $form and $form_state for        // late execution of submit handers and post-batch redirection.        $batch['form'] = $form;        $batch['form_state'] = $form_state;        $batch['progressive'] = !$form['#programmed'];        batch_process();        // Execution continues only for programmatic forms.        // For 'regular' forms, we get redirected to the batch processing        // page. Form redirection will be handled in _batch_finished(),        // after the batch is processed.      }      // If no submit handlers have populated the $form_state['storage']      // bundle, and the $form_state['rebuild'] flag has not been set,      // we're finished and should redirect to a new destination page      // if one has been set (and a fresh, unpopulated copy of the form      // if one hasn't). If the form was called by drupal_execute(),      // however, we'll skip this and let the calling function examine      // the resulting $form_state bundle itself.      if (!$form['#programmed'] && empty($form_state['rebuild']) && empty($form_state['storage'])) {        drupal_redirect_form($form, $form_state['redirect']);      }    }  }}/** * Prepares a structured form array by adding required elements, * executing any hook_form_alter functions, and optionally inserting * a validation token to prevent tampering. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. Passed *   in here so that hook_form_alter() calls can use it, as well. */function drupal_prepare_form($form_id, &$form, &$form_state) {  global $user;  $form['#type'] = 'form';  $form['#programmed'] = isset($form['#post']);  if (isset($form['#build_id'])) {    $form['form_build_id'] = array(      '#type' => 'hidden',      '#value' => $form['#build_id'],      '#id' => $form['#build_id'],      '#name' => 'form_build_id',    );  }  // Add a token, based on either #token or form_id, to any form displayed to  // authenticated users. This ensures that any submitted form was actually  // requested previously by the user and protects against cross site request  // forgeries.  if (isset($form['#token'])) {    if ($form['#token'] === FALSE || $user->uid == 0 || $form['#programmed']) {      unset($form['#token']);    }    else {      $form['form_token'] = array('#type' => 'token', '#default_value' => drupal_get_token($form['#token']));    }  }  else if (isset($user->uid) && $user->uid && !$form['#programmed']) {    $form['#token'] = $form_id;    $form['form_token'] = array(      '#id' => form_clean_id('edit-'. $form_id .'-form-token'),      '#type' => 'token',      '#default_value' => drupal_get_token($form['#token']),    );  }  if (isset($form_id)) {    $form['form_id'] = array(      '#type' => 'hidden',      '#value' => $form_id,      '#id' => form_clean_id("edit-$form_id"),    );  }  if (!isset($form['#id'])) {    $form['#id'] = form_clean_id($form_id);  }  $form += _element_info('form');  if (!isset($form['#validate'])) {    if (function_exists($form_id .'_validate')) {      $form['#validate'] = array($form_id .'_validate');    }  }  if (!isset($form['#submit'])) {    if (function_exists($form_id .'_submit')) {      // We set submit here so that it can be altered.      $form['#submit'] = array($form_id .'_submit');    }  }  // Normally, we would call drupal_alter($form_id, $form, $form_state).  // However, drupal_alter() normally supports just one byref parameter. Using  // the __drupal_alter_by_ref key, we can store any additional parameters  // that need to be altered, and they'll be split out into additional params  // for the hook_form_alter() implementations.  // @todo: Remove this in Drupal 7.  $data = &$form;  $data['__drupal_alter_by_ref'] = array(&$form_state);  drupal_alter('form_'. $form_id, $data);  // __drupal_alter_by_ref is unset in the drupal_alter() function, we need  // to repopulate it to ensure both calls get the data.  $data['__drupal_alter_by_ref'] = array(&$form_state);  drupal_alter('form', $data, $form_id);}/** * Validates user-submitted form data from the $form_state using * the validate functions defined in a structured form array. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. The current *   user-submitted data is stored in $form_state['values'], though *   form validation functions are passed an explicit copy of the *   values for the sake of simplicity. Validation handlers can also *   $form_state to pass information on to submit handlers. For example: *     $form_state['data_for_submision'] = $data; *   This technique is useful when validation requires file parsing, *   web service requests, or other expensive requests that should *   not be repeated in the submission step. */function drupal_validate_form($form_id, $form, &$form_state) {  static $validated_forms = array();  if (isset($validated_forms[$form_id])) {    return;  }  // If the session token was set by drupal_prepare_form(), ensure that it  // matches the current user's session.  if (isset($form['#token'])) {    if (!drupal_valid_token($form_state['values']['form_token'], $form['#token'])) {      // Setting this error will cause the form to fail validation.      form_set_error('form_token', t('Validation error, please try again. If this error persists, please contact the site administrator.'));    }  }  _form_validate($form, $form_state, $form_id);  $validated_forms[$form_id] = TRUE;}/** * Renders a structured form array into themed HTML. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @return *   A string containing the themed HTML. */function drupal_render_form($form_id, &$form) {  // Don't override #theme if someone already set it.  if (!isset($form['#theme'])) {    init_theme();    $registry = theme_get_registry();    if (isset($registry[$form_id])) {      $form['#theme'] = $form_id;    }  }  $output = drupal_render($form);  return $output;}/** * Redirect the user to a URL after a form has been processed. * * @param $form *   An associative array containing the structure of the form. * @param $redirect *   An optional value containing the destination path to redirect *   to if none is specified by the form. */function drupal_redirect_form($form, $redirect = NULL) {  $goto = NULL;  if (isset($redirect)) {    $goto = $redirect;  }  if ($goto !== FALSE && isset($form['#redirect'])) {    $goto = $form['#redirect'];  }  if (!isset($goto) || ($goto !== FALSE)) {    if (isset($goto)) {      if (is_array($goto)) {        call_user_func_array('drupal_goto', $goto);      }      else {        drupal_goto($goto);      }    }    drupal_goto($_GET['q']);  }}/** * Performs validation on form elements. First ensures required fields are * completed, #maxlength is not exceeded, and selected options were in the * list of options given to the user. Then calls user-defined validators. * * @param $elements *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. The current *   user-submitted data is stored in $form_state['values'], though *   form validation functions are passed an explicit copy of the *   values for the sake of simplicity. Validation handlers can also *   $form_state to pass information on to submit handlers. For example: *     $form_state['data_for_submision'] = $data; *   This technique is useful when validation requires file parsing, *   web service requests, or other expensive requests that should *   not be repeated in the submission step. * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. */function _form_validate($elements, &$form_state, $form_id = NULL) {  static $complete_form;  // Also used in the installer, pre-database setup.  $t = get_t();  // Recurse through all children.  foreach (element_children($elements) as $key) {    if (isset($elements[$key]) && $elements[$key]) {      _form_validate($elements[$key], $form_state);    }  }  // Validate the current input.  if (!isset($elements['#validated']) || !$elements['#validated']) {    if (isset($elements['#needs_validation'])) {      // Make sure a value is passed when the field is required.      // A simple call to empty() will not cut it here as some fields, like      // checkboxes, can return a valid value of '0'. Instead, check the      // length if it's a string, and the item count if it's an array.      if ($elements['#required'] && (!count($elements['#value']) || (is_string($elements['#value']) && strlen(trim($elements['#value'])) == 0))) {        form_error($elements, $t('!name field is required.', array('!name' => $elements['#title'])));      }      // Verify that the value is not longer than #maxlength.      if (isset($elements['#maxlength']) && drupal_strlen($elements['#value']) > $elements['#maxlength']) {        form_error($elements, $t('!name cannot be longer than %max characters but is currently %length characters long.', array('!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title'], '%max' => $elements['#maxlength'], '%length' => drupal_strlen($elements['#value']))));      }      if (isset($elements['#options']) && isset($elements['#value'])) {        if ($elements['#type'] == 'select') {          $options = form_options_flatten($elements['#options']);        }        else {          $options = $elements['#options'];        }        if (is_array($elements['#value'])) {          $value = $elements['#type'] == 'checkboxes' ? array_keys(array_filter($elements['#value'])) : $elements['#value'];          foreach ($value as $v) {            if (!isset($options[$v])) {              form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));              watchdog('form', 'Illegal choice %choice in !name element.', array('%choice' => $v, '!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);            }          }        }        elseif (!isset($options[$elements['#value']])) {          form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));          watchdog('form', 'Illegal choice %choice in %name element.', array('%choice' => $elements['#value'], '%name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);        }      }    }    // Call user-defined form level validators and store a copy of the full    // form so that element-specific validators can examine the entire structure    // if necessary.    if (isset($form_id)) {      form_execute_handlers('validate', $elements, $form_state);      $complete_form = $elements;    }    // Call any element-specific validators. These must act on the element    // #value data.    elseif (isset($elements['#element_validate'])) {      foreach ($elements['#element_validate'] as $function) {        if (function_exists($function))  {          $function($elements, $form_state, $complete_form);        }      }    }    $elements['#validated'] = TRUE;  }}/** * A helper function used to execute custom validation and submission * handlers for a given form. Button-specific handlers are checked * first. If none exist, the function falls back to form-level handlers. * * @param $type *   The type of handler to execute. 'validate' or 'submit' are the *   defaults used by Form API. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. If the user *   submitted the form by clicking a button with custom handler functions *   defined, those handlers will be stored here. */function form_execute_handlers($type, &$form, &$form_state) {  $return = FALSE;  if (isset($form_state[$type .'_handlers'])) {    $handlers = $form_state[$type .'_handlers'];  }  elseif (isset($form['#'. $type])) {    $handlers = $form['#'. $type];  }  else {    $handlers = array();  }  foreach ($handlers as $function) {    if (function_exists($function))  {      // Check to see if a previous _submit handler has set a batch, but       // make sure we do not react to a batch that is already being processed       // (for instance if a batch operation performs a drupal_execute()).      if ($type == 'submit' && ($batch =& batch_get()) && !isset($batch['current_set'])) {        // Some previous _submit handler has set a batch. We store the call        // in a special 'control' batch set, for execution at the correct        // time during the batch processing workflow.        $batch['sets'][] = array('form_submit' => $function);      }      else {        $function($form, $form_state);      }      $return = TRUE;    }  }  return $return;}/** * File an error against a form element. * * @param $name *   The name of the form element. If the #parents property of your form *   element is array('foo', 'bar', 'baz') then you may set an error on 'foo' *   or 'foo][bar][baz'. Setting an error on 'foo' sets an error for every *   element where the #parents array starts with 'foo'. * @param $message *   The error message to present to the user. * @param $reset *   Reset the form errors static cache. * @return *   Never use the return value of this function, use form_get_errors and *   form_get_error instead. */function form_set_error($name = NULL, $message = '', $reset = FALSE) {  static $form = array();  if ($reset) {    $form = array();  }  if (isset($name) && !isset($form[$name])) {    $form[$name] = $message;    if ($message) {      drupal_set_message($message, 'error');    }  }  return $form;}/** * Return an associative array of all errors. */function form_get_errors() {  $form = form_set_error();  if (!empty($form)) {    return $form;  }}/** * Return the error message filed against the form with the specified name. */function form_get_error($element) {  $form = form_set_error();  $key = $element['#parents'][0];  if (isset($form[$key])) {    return $form[$key];  }  $key = implode('][', $element['#parents']);  if (isset($form[$key])) {    return $form[$key];  }}/** * Flag an element as having an error. */function form_error(&$element, $message = '') {  form_set_error(implode('][', $element['#parents']), $message);}/** * Walk through the structured form array, adding any required * properties to each element and mapping the incoming $_POST * data to the proper elements. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. In this *   context, it is used to accumulate information about which button *   was clicked when the form was submitted, as well as the sanitized *   $_POST data. */function form_builder($form_id, $form, &$form_state) {  static $complete_form, $cache;  // Initialize as unprocessed.  $form['#processed'] = FALSE;  // Use element defaults.  if ((!empty($form['#type'])) && ($info = _element_info($form['#type']))) {    // Overlay $info onto $form, retaining preexisting keys in $form.    $form += $info;  }  if (isset($form['#type']) && $form['#type'] == 'form') {    $cache = NULL;    $complete_form = $form;    if (!empty($form['#programmed'])) {      $form_state['submitted'] = TRUE;    }  }  if (isset($form['#input']) && $form['#input']) {    _form_builder_handle_input_element($form_id, $form, $form_state, $complete_form);  }  $form['#defaults_loaded'] = TRUE;  // We start off assuming all form elements are in the correct order.  $form['#sorted'] = TRUE;  // Recurse through all child elements.  $count = 0;  foreach (element_children($form) as $key) {    $form[$key]['#post'] = $form['#post'];    $form[$key]['#programmed'] = $form['#programmed'];    // Don't squash an existing tree value.    if (!isset($form[$key]['#tree'])) {      $form[$key]['#tree'] = $form['#tree'];    }    // Deny access to child elements if parent is denied.    if (isset($form['#access']) && !$form['#access']) {      $form[$key]['#access'] = FALSE;    }    // Don't squash existing parents value.    if (!isset($form[$key]['#parents'])) {      // Check to see if a tree of child elements is present. If so,      // continue down the tree if required.      $form[$key]['#parents'] = $form[$key]['#tree'] && $form['#tree'] ? array_merge($form['#parents'], array($key)) : array($key);      $array_parents = isset($form['#array_parents']) ? $form['#array_parents'] : array();      $array_parents[] = $key;      $form[$key]['#array_parents'] = $array_parents;    }    // Assign a decimal placeholder weight to preserve original array order.    if (!isset($form[$key]['#weight'])) {      $form[$key]['#weight'] = $count/1000;    }    else {      // If one of the child elements has a weight then we will need to sort      // later.      unset($form['#sorted']);    }    $form[$key] = form_builder($form_id, $form[$key], $form_state);    $count++;  }  // The #after_build flag allows any piece of a form to be altered  // after normal input parsing has been completed.  if (isset($form['#after_build']) && !isset($form['#after_build_done'])) {    foreach ($form['#after_build'] as $function) {      $form = $function($form, $form_state);      $form['#after_build_done'] = TRUE;    }  }  // Now that we've processed everything, we can go back to handle the funky  // Internet Explorer button-click scenario.  _form_builder_ie_cleanup($form, $form_state);  // We shoud keep the buttons array until the IE clean up function  // has recognized the submit button so the form has been marked  // as submitted. If we already know which button was submitted,  // we don't need the array.  if (!empty($form_state['submitted'])) {    unset($form_state['buttons']);  }  // If some callback set #cache, we need to flip a static flag so later it  // can be found.  if (!empty($form['#cache'])) {    $cache = $form['#cache'];  }  // We are on the top form, we can copy back #cache if it's set.  if (isset($form['#type']) && $form['#type'] == 'form' && isset($cache)) {    $form['#cache'] = TRUE;  }  return $form;}/** * Populate the #value and #name properties of input elements so they * can be processed and rendered. Also, execute any #process handlers * attached to a specific element. */function _form_builder_handle_input_element($form_id, &$form, &$form_state, $complete_form) {  if (!isset($form['#name'])) {    $name = array_shift($form['#parents']);    $form['#name'] = $name;    if ($form['#type'] == 'file') {      // To make it easier to handle $_FILES in file.inc, we place all      // file fields in the 'files' array. Also, we do not support      // nested file names.      $form['#name'] = 'files['. $form['#name'] .']';    }    elseif (count($form['#parents'])) {      $form['#name'] .= '['. implode('][', $form['#parents']) .']';    }    array_unshift($form['#parents'], $name);  }  if (!isset($form['#id'])) {    $form['#id'] = form_clean_id('edit-'. implode('-', $form['#parents']));  }  if (!empty($form['#disabled'])) {    $form['#attributes']['disabled'] = 'disabled';  }  if (!isset($form['#value']) && !array_key_exists('#value', $form)) {    $function = !empty($form['#value_callback']) ? $form['#value_callback'] : 'form_type_'. $form['#type'] .'_value';    if (($form['#programmed']) || ((!isset($form['#access']) || $form['#access']) && isset($form['#post']) && (isset($form['#post']['form_id']) && $form['#post']['form_id'] == $form_id))) {      $edit = $form['#post'];      foreach ($form['#parents'] as $parent) {        $edit = isset($edit[$parent]) ? $edit[$parent] : NULL;      }      if (!$form['#programmed'] || isset($edit)) {        // Call #type_value to set the form value;        if (function_exists($function)) {          $form['#value'] = $function($form, $edit);        }        if (!isset($form['#value']) && isset($edit)) {          $form['#value'] = $edit;        }      }      // Mark all posted values for validation.      if (isset($form['#value']) || (isset($form['#required']) && $form['#required'])) {        $form['#needs_validation'] = TRUE;      }    }    // Load defaults.    if (!isset($form['#value'])) {      // Call #type_value without a second argument to request default_value handling.      if (function_exists($function)) {        $form['#value'] = $function($form);      }      // Final catch. If we haven't set a value yet, use the explicit default value.      // Avoid image buttons (which come with garbage value), so we only get value      // for the button actually clicked.      if (!isset($form['#value']) && empty($form['#has_garbage_value'])) {        $form['#value'] = isset($form['#default_value']) ? $form['#default_value'] : '';      }    }  }  // Determine which button (if any) was clicked to submit the form.  // We compare the incoming values with the buttons defined in the form,  // and flag the one that matches. We have to do some funky tricks to  // deal with Internet Explorer's handling of single-button forms, though.  if (!empty($form['#post']) && isset($form['#executes_submit_callback'])) {    // First, accumulate a collection of buttons, divided into two bins:    // those that execute full submit callbacks and those that only validate.    $button_type = $form['#executes_submit_callback'] ? 'submit' : 'button';    $form_state['buttons'][$button_type][] = $form;    if (_form_button_was_clicked($form)) {      $form_state['submitted'] = $form_state['submitted'] || $form['#executes_submit_callback'];      // In most cases, we want to use form_set_value() to manipulate      // the global variables. In this special case, we want to make sure that      // the value of this element is listed in $form_variables under 'op'.      $form_state['values'][$form['#name']] = $form['#value'];      $form_state['clicked_button'] = $form;      if (isset($form['#validate'])) {        $form_state['validate_handlers'] = $form['#validate'];      }      if (isset($form['#submit'])) {        $form_state['submit_handlers'] = $form['#submit'];      }    }  }  // Allow for elements to expand to multiple elements, e.g., radios,  // checkboxes and files.  if (isset($form['#process']) && !$form['#processed']) {    foreach ($form['#process'] as $process) {      if (function_exists($process)) {        $form = $process($form, isset($edit) ? $edit : NULL, $form_state, $complete_form);      }    }    $form['#processed'] = TRUE;  }  form_set_value($form, $form['#value'], $form_state);}/** * Helper function to handle the sometimes-convoluted logic of button * click detection. * * In Internet Explorer, if ONLY one submit button is present, AND the * enter key is used to submit the form, no form value is sent for it * and we'll never detect a match. That special case is handled by * _form_builder_ie_cleanup(). */function _form_button_was_clicked($form) {  // First detect normal 'vanilla' button clicks. Traditionally, all  // standard buttons on a form share the same name (usually 'op'),  // and the specific return value is used to determine which was  // clicked. This ONLY works as long as $form['#name'] puts the  // value at the top level of the tree of $_POST data.  if (isset($form['#post'][$form['#name']]) && $form['#post'][$form['#name']] == $form['#value']) {    return TRUE;  }  // When image buttons are clicked, browsers do NOT pass the form element  // value in $_POST. Instead they pass an integer representing the  // coordinates of the click on the button image. This means that image  // buttons MUST have unique $form['#name'] values, but the details of  // their $_POST data should be ignored.  elseif (!empty($form['#has_garbage_value']) && isset($form['#value']) && $form['#value'] !== '') {    return TRUE;  }  return FALSE;}/** * In IE, if only one submit button is present, AND the enter key is * used to submit the form, no form value is sent for it and our normal * button detection code will never detect a match. We call this * function after all other button-detection is complete to check * for the proper conditions, and treat the single button on the form * as 'clicked' if they are met. */function _form_builder_ie_cleanup($form, &$form_state) {  // Quick check to make sure we're always looking at the full form  // and not a sub-element.  if (!empty($form['#type']) && $form['#type'] == 'form') {    // If we haven't recognized a submission yet, and there's a single    // submit button, we know that we've hit the right conditions. Grab    // the first one and treat it as the clicked button.    if (empty($form_state['submitted']) && !empty($form_state['buttons']['submit']) && empty($form_state['buttons']['button'])) {      $button = $form_state['buttons']['submit'][0];      // Set up all the $form_state information that would have been      // populated had the button been recognized earlier.      $form_state['submitted'] = TRUE;      $form_state['submit_handlers'] = empty($button['#submit']) ? NULL : $button['#submit'];      $form_state['validate_handlers'] = empty($button['#validate']) ? NULL : $button['#validate'];      $form_state['values'][$button['#name']] = $button['#value'];      $form_state['clicked_button'] = $button;    }  }}/** * Helper function to determine the value for an image button form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_image_button_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (!empty($edit)) {      // If we're dealing with Mozilla or Opera, we're lucky. It will      // return a proper value, and we can get on with things.      return $form['#return_value'];    }    else {      // Unfortunately, in IE we never get back a proper value for THIS      // form element. Instead, we get back two split values: one for the      // X and one for the Y coordinates on which the user clicked the      // button. We'll find this element in the #post data, and search      // in the same spot for its name, with '_x'.      $post = $form['#post'];      foreach (split('\[', $form['#name']) as $element_name) {        // chop off the ] that may exist.        if (substr($element_name, -1) == ']') {          $element_name = substr($element_name, 0, -1);        }        if (!isset($post[$element_name])) {          if (isset($post[$element_name .'_x'])) {            return $form['#return_value'];          }          return NULL;        }        $post = $post[$element_name];      }      return $form['#return_value'];    }  }}/** * Helper function to determine the value for a checkbox form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_checkbox_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (empty($form['#disabled'])) {      return !empty($edit) ? $form['#return_value'] : 0;    }    else {      return $form['#default_value'];    }  }}/** * Helper function to determine the value for a checkboxes form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_checkboxes_value($form, $edit = FALSE) {  if ($edit === FALSE) {    $value = array();    $form += array('#default_value' => array());    foreach ($form['#default_value'] as $key) {      $value[$key] = 1;    }    return $value;  }  elseif (!isset($edit)) {    return array();  }}/** * Helper function to determine the value for a password_confirm form * element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_password_confirm_value($form, $edit = FALSE) {  if ($edit === FALSE) {    $form += array('#default_value' => array());    return $form['#default_value'] + array('pass1' => '', 'pass2' => '');  }}/** * Helper function to determine the value for a select form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_select_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (isset($form['#multiple']) && $form['#multiple']) {      return (is_array($edit)) ? drupal_map_assoc($edit) : array();    }    else {      return $edit;    }  }}/** * Helper function to determine the value for a textfield form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_textfield_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    // Equate $edit to the form value to ensure it's marked for    // validation.    return str_replace(array("\r", "\n"), '', $edit);  }}/** * Helper function to determine the value for form's token value. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_token_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    return (string)$edit;  }}/** * Change submitted form values during the form processing cycle. * * Use this function to change the submitted value of a form item in the * validation phase so that it persists in $form_state through to the * submission handlers in the submission phase. * * Since $form_state['values'] can either be a flat array of values, or a tree * of nested values, some care must be taken when using this function. * Specifically, $form_item['#parents'] is an array that describes the branch of * the tree whose value should be updated. For example, if we wanted to update * $form_state['values']['one']['two'] to 'new value', we'd pass in * $form_item['#parents'] = array('one', 'two') and $value = 'new value'. * * @param $form_item *   The form item that should have its value updated. Keys used: #parents, *   #value. In most cases you can just pass in the right element from the $form *   array. * @param $value *   The new value for the form item. * @param $form_state *   The array where the value change should be recorded. */function form_set_value($form_item, $value, &$form_state) {  _form_set_value($form_state['values'], $form_item, $form_item['#parents'], $value);}/** * Helper function for form_set_value(). * * We iterate over $parents and create nested arrays for them * in $form_state['values'] if needed. Then we insert the value into * the right array. */function _form_set_value(&$form_values, $form_item, $parents, $value) {  $parent = array_shift($parents);  if (empty($parents)) {    $form_values[$parent] = $value;  }  else {    if (!isset($form_values[$parent])) {      $form_values[$parent] = array();    }    _form_set_value($form_values[$parent], $form_item, $parents, $value);  }}/** * Retrieve the default properties for the defined element type. */function _element_info($type, $refresh = NULL) {  static $cache;  $basic_defaults = array(    '#description' => NULL,    '#attributes' => array(),    '#required' => FALSE,    '#tree' => FALSE,    '#parents' => array()  );  if (!isset($cache) || $refresh) {    $cache = array();    foreach (module_implements('elements') as $module) {      $elements = module_invoke($module, 'elements');      if (isset($elements) && is_array($elements)) {        $cache = array_merge_recursive($cache, $elements);      }    }    if (sizeof($cache)) {      foreach ($cache as $element_type => $info) {        $cache[$element_type] = array_merge_recursive($basic_defaults, $info);      }    }  }  return $cache[$type];}function form_options_flatten($array, $reset = TRUE) {  static $return;  if ($reset) {    $return = array();  }  foreach ($array as $key => $value) {    if (is_object($value)) {      form_options_flatten($value->option, FALSE);    }    else if (is_array($value)) {      form_options_flatten($value, FALSE);    }    else {      $return[$key] = 1;    }  }  return $return;}/** * Format a dropdown menu or scrolling selection box. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, extra, multiple, required * @return *   A themed HTML string representing the form element. * * @ingroup themeable * * It is possible to group options together; to do this, change the format of * $options to an associative array in which the keys are group labels, and the * values are associative arrays in the normal $options format. */function theme_select($element) {  $select = '';  $size = $element['#size'] ? ' size="'. $element['#size'] .'"' : '';  _form_set_class($element, array('form-select'));  $multiple = $element['#multiple'];  return theme('form_element', $element, '<select name="'. $element['#name'] .''. ($multiple ? '[]' : '') .'"'. ($multiple ? ' multiple="multiple" ' : '') . drupal_attributes($element['#attributes']) .' id="'. $element['#id'] .'" '. $size .'>'. form_select_options($element) .'</select>');}function form_select_options($element, $choices = NULL) {  if (!isset($choices)) {    $choices = $element['#options'];  }  // array_key_exists() accommodates the rare event where $element['#value'] is NULL.  // isset() fails in this situation.  $value_valid = isset($element['#value']) || array_key_exists('#value', $element);  $value_is_array = is_array($element['#value']);  $options = '';  foreach ($choices as $key => $choice) {    if (is_array($choice)) {      $options .= '<optgroup label="'. $key .'">';      $options .= form_select_options($element, $choice);      $options .= '</optgroup>';    }    elseif (is_object($choice)) {      $options .= form_select_options($element, $choice->option);    }    else {      $key = (string)$key;      if ($value_valid && (!$value_is_array && (string)$element['#value'] === $key || ($value_is_array && in_array($key, $element['#value'])))) {        $selected = ' selected="selected"';      }      else {        $selected = '';      }      $options .= '<option value="'. check_plain($key) .'"'. $selected .'>'. check_plain($choice) .'</option>';    }  }  return $options;}/** * Traverses a select element's #option array looking for any values * that hold the given key. Returns an array of indexes that match. * * This function is useful if you need to modify the options that are * already in a form element; for example, to remove choices which are * not valid because of additional filters imposed by another module. * One example might be altering the choices in a taxonomy selector. * To correctly handle the case of a multiple hierarchy taxonomy, * #options arrays can now hold an array of objects, instead of a * direct mapping of keys to labels, so that multiple choices in the * selector can have the same key (and label). This makes it difficult * to manipulate directly, which is why this helper function exists. * * This function does not support optgroups (when the elements of the * #options array are themselves arrays), and will return FALSE if * arrays are found. The caller must either flatten/restore or * manually do their manipulations in this case, since returning the * index is not sufficient, and supporting this would make the * "helper" too complicated and cumbersome to be of any help. * * As usual with functions that can return array() or FALSE, do not * forget to use === and !== if needed. * * @param $element *   The select element to search. * @param $key *   The key to look for. * @return *   An array of indexes that match the given $key. Array will be *   empty if no elements were found. FALSE if optgroups were found. */function form_get_options($element, $key) {  $keys = array();  foreach ($element['#options'] as $index => $choice) {    if (is_array($choice)) {      return FALSE;    }    else if (is_object($choice)) {      if (isset($choice->option[$key])) {        $keys[] = $index;      }    }    else if ($index == $key) {      $keys[] = $index;    }  }  return $keys;}/** * Format a group of form items. * * @param $element *   An associative array containing the properties of the element. *   Properties used: attributes, title, value, description, children, collapsible, collapsed * @return *   A themed HTML string representing the form item group. * * @ingroup themeable */function theme_fieldset($element) {  if (!empty($element['#collapsible'])) {    drupal_add_js('misc/collapse.js');    if (!isset($element['#attributes']['class'])) {      $element['#attributes']['class'] = '';    }    $element['#attributes']['class'] .= ' collapsible';    if (!empty($element['#collapsed'])) {      $element['#attributes']['class'] .= ' collapsed';    }  }  return '<fieldset'. drupal_attributes($element['#attributes']) .'>'. ($element['#title'] ? '<legend>'. $element['#title'] .'</legend>' : '') . (isset($element['#description']) && $element['#description'] ? '<div class="description">'. $element['#description'] .'</div>' : '') . (!empty($element['#children']) ? $element['#children'] : '') . (isset($element['#value']) ? $element['#value'] : '') ."</fieldset>\n";}/** * Format a radio button. * * @param $element *   An associative array containing the properties of the element. *   Properties used: required, return_value, value, attributes, title, description * @return *   A themed HTML string representing the form item group. * * @ingroup themeable */function theme_radio($element) {  _form_set_class($element, array('form-radio'));  $output = '<input type="radio" ';  $output .= 'id="'. $element['#id'] .'" ';  $output .= 'name="'. $element['#name'] .'" ';  $output .= 'value="'. $element['#return_value'] .'" ';  $output .= (check_plain($element['#value']) == $element['#return_value']) ? ' checked="checked" ' : ' ';  $output .= drupal_attributes($element['#attributes']) .' />';  if (!is_null($element['#title'])) {    $output = '<label class="option" for="'. $element['#id'] .'">'. $output .' '. $element['#title'] .'</label>';  }  unset($element['#title']);  return theme('form_element', $element, $output);}/** * Format a set of radio buttons. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, required and attributes. * @return *   A themed HTML string representing the radio button set. * * @ingroup themeable */function theme_radios($element) {  $class = 'form-radios';  if (isset($element['#attributes']['class'])) {    $class .= ' '. $element['#attributes']['class'];  }  $element['#children'] = '<div class="'. $class .'">'. (!empty($element['#children']) ? $element['#children'] : '') .'</div>';  if ($element['#title'] || $element['#description']) {    unset($element['#id']);    return theme('form_element', $element, $element['#children']);  }  else {    return $element['#children'];  }}/** * Format a password_confirm item. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, id, required, error. * @return *   A themed HTML string representing the form item. * * @ingroup themeable */function theme_password_confirm($element) {  return theme('form_element', $element, $element['#children']);}/** * Expand a password_confirm field into two text boxes. */function expand_password_confirm($element) {  $element['pass1'] =  array(    '#type' => 'password',    '#title' => t('Password'),    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass1'],    '#required' => $element['#required'],    '#attributes' => array('class' => 'password-field'),  );  $element['pass2'] =  array(    '#type' => 'password',    '#title' => t('Confirm password'),    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass2'],    '#required' => $element['#required'],    '#attributes' => array('class' => 'password-confirm'),  );  $element['#element_validate'] = array('password_confirm_validate');  $element['#tree'] = TRUE;  if (isset($element['#size'])) {    $element['pass1']['#size'] = $element['pass2']['#size'] = $element['#size'];  }  return $element;}/** * Validate password_confirm element. */function password_confirm_validate($form, &$form_state) {  $pass1 = trim($form['pass1']['#value']);  if (!empty($pass1)) {    $pass2 = trim($form['pass2']['#value']);    if (strcmp($pass1, $pass2)) {      form_error($form, t('The specified passwords do not match.'));    }  }  elseif ($form['#required'] && !empty($form['#post'])) {    form_error($form, t('Password field is required.'));  }  // Password field must be converted from a two-element array into a single  // string regardless of validation results.  form_set_value($form['pass1'], NULL, $form_state);  form_set_value($form['pass2'], NULL, $form_state);  form_set_value($form, $pass1, $form_state);  return $form;}/** * Format a date selection element. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, required and attributes. * @return *   A themed HTML string representing the date selection boxes. * * @ingroup themeable */function theme_date($element) {  return theme('form_element', $element, '<div class="container-inline">'. $element['#children'] .'</div>');}/** * Roll out a single date element. */function expand_date($element) {  // Default to current date  if (empty($element['#value'])) {    $element['#value'] = array('day' => format_date(time(), 'custom', 'j'),                            'month' => format_date(time(), 'custom', 'n'),                            'year' => format_date(time(), 'custom', 'Y'));  }  $element['#tree'] = TRUE;  // Determine the order of day, month, year in the site's chosen date format.  $format = variable_get('date_format_short', 'm/d/Y - H:i');  $sort = array();  $sort['day'] = max(strpos($format, 'd'), strpos($format, 'j'));  $sort['month'] = max(strpos($format, 'm'), strpos($format, 'M'));  $sort['year'] = strpos($format, 'Y');  asort($sort);  $order = array_keys($sort);  // Output multi-selector for date.  foreach ($order as $type) {    switch ($type) {      case 'day':        $options = drupal_map_assoc(range(1, 31));        break;      case 'month':        $options = drupal_map_assoc(range(1, 12), 'map_month');        break;      case 'year':        $options = drupal_map_assoc(range(1900, 2050));        break;    }    $parents = $element['#parents'];    $parents[] = $type;    $element[$type] = array(      '#type' => 'select',      '#value' => $element['#value'][$type],      '#attributes' => $element['#attributes'],      '#options' => $options,    );  }  return $element;}/** * Validates the date type to stop dates like February 30, 2006. */function date_validate($form) {  if (!checkdate($form['#value']['month'], $form['#value']['day'], $form['#value']['year'])) {    form_error($form, t('The specified date is invalid.'));  }}/** * Helper function for usage with drupal_map_assoc to display month names. */function map_month($month) {  return format_date(gmmktime(0, 0, 0, $month, 2, 1970), 'custom', 'M', 0);}/** * If no default value is set for weight select boxes, use 0. */function weight_value(&$form) {  if (isset($form['#default_value'])) {    $form['#value'] = $form['#default_value'];  }  else {    $form['#value'] = 0;  }}/** * Roll out a single radios element to a list of radios, * using the options array as index. */function expand_radios($element) {  if (count($element['#options']) > 0) {    foreach ($element['#options'] as $key => $choice) {      if (!isset($element[$key])) {        // Generate the parents as the autogenerator does, so we will have a        // unique id for each radio button.        $parents_for_id = array_merge($element['#parents'], array($key));        $element[$key] = array(          '#type' => 'radio',          '#title' => $choice,          '#return_value' => check_plain($key),          '#default_value' => isset($element['#default_value']) ? $element['#default_value'] : NULL,          '#attributes' => $element['#attributes'],          '#parents' => $element['#parents'],          '#id' => form_clean_id('edit-'. implode('-', $parents_for_id)),          '#ahah' => isset($element['#ahah']) ? $element['#ahah'] : NULL,        );      }    }  }  return $element;}/** * Add AHAH information about a form element to the page to communicate with * javascript. If #ahah[path] is set on an element, this additional javascript is * added to the page header to attach the AHAH behaviors. See ahah.js for more * information. * * @param $element *   An associative array containing the properties of the element. *   Properties used: ahah_event, ahah_path, ahah_wrapper, ahah_parameters, *   ahah_effect. * @return *   None. Additional code is added to the header of the page using *   drupal_add_js. */function form_expand_ahah($element) {  static $js_added = array();  // Add a reasonable default event handler if none specified.  if (isset($element['#ahah']['path']) && !isset($element['#ahah']['event'])) {    switch ($element['#type']) {      case 'submit':      case 'button':      case 'image_button':        // Use the mousedown instead of the click event because form        // submission via pressing the enter key triggers a click event on        // submit inputs, inappropriately triggering AHAH behaviors.        $element['#ahah']['event'] = 'mousedown';        // Attach an additional event handler so that AHAH behaviours        // can be triggered still via keyboard input.        $element['#ahah']['keypress'] = TRUE;        break;      case 'password':      case 'textfield':      case 'textarea':        $element['#ahah']['event'] = 'blur';        break;      case 'radio':      case 'checkbox':      case 'select':        $element['#ahah']['event'] = 'change';        break;    }  }  // Adding the same javascript settings twice will cause a recursion error,  // we avoid the problem by checking if the javascript has already been added.  if (isset($element['#ahah']['path']) && isset($element['#ahah']['event']) && !isset($js_added[$element['#id']])) {    drupal_add_js('misc/jquery.form.js');    drupal_add_js('misc/ahah.js');    $ahah_binding = array(      'url'      => url($element['#ahah']['path']),      'event'    => $element['#ahah']['event'],      'keypress' => empty($element['#ahah']['keypress']) ? NULL : $element['#ahah']['keypress'],      'wrapper'  => empty($element['#ahah']['wrapper']) ? NULL : $element['#ahah']['wrapper'],      'selector' => empty($element['#ahah']['selector']) ? '#'. $element['#id'] : $element['#ahah']['selector'],      'effect'   => empty($element['#ahah']['effect']) ? 'none' : $element['#ahah']['effect'],      'method'   => empty($element['#ahah']['method']) ? 'replace' : $element['#ahah']['method'],      'progress' => empty($element['#ahah']['progress']) ? array('type' => 'throbber') : $element['#ahah']['progress'],      'button'   => isset($element['#executes_submit_callback']) ? array($element['#name'] => $element['#value']) : FALSE,    );    // Convert a simple #ahah[progress] type string into an array.    if (is_string($ahah_binding['progress'])) {      $ahah_binding['progress'] = array('type' => $ahah_binding['progress']);    }    // Change progress path to a full url.    if (isset($ahah_binding['progress']['path'])) {      $ahah_binding['progress']['url'] = url($ahah_binding['progress']['path']);    }    // Add progress.js if we're doing a bar display.    if ($ahah_binding['progress']['type'] == 'bar') {      drupal_add_js('misc/progress.js');    }    drupal_add_js(array('ahah' => array($element['#id'] => $ahah_binding)), 'setting');    $js_added[$element['#id']] = TRUE;    $element['#cache'] = TRUE;  }  return $element;}/** * Format a form item. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, required, error * @return *   A themed HTML string representing the form item. * * @ingroup themeable */function theme_item($element) {  return theme('form_element', $element, $element['#value'] . (!empty($element['#children']) ? $element['#children'] : ''));}/** * Format a checkbox. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, return_value, description, required * @return *   A themed HTML string representing the checkbox. * * @ingroup themeable */function theme_checkbox($element) {  _form_set_class($element, array('form-checkbox'));  $checkbox = '<input ';  $checkbox .= 'type="checkbox" ';  $checkbox .= 'name="'. $element['#name'] .'" ';  $checkbox .= 'id="'. $element['#id'] .'" ' ;  $checkbox .= 'value="'. $element['#return_value'] .'" ';  $checkbox .= $element['#value'] ? ' checked="checked" ' : ' ';  $checkbox .= drupal_attributes($element['#attributes']) .' />';  if (!is_null($element['#title'])) {    $checkbox = '<label class="option" for="'. $element['#id'] .'">'. $checkbox .' '. $element['#title'] .'</label>';  }  unset($element['#title']);  return theme('form_element', $element, $checkbox);}/** * Format a set of checkboxes. * * @param $element *   An associative array containing the properties of the element. * @return *   A themed HTML string representing the checkbox set. * * @ingroup themeable */function theme_checkboxes($element) {  $class = 'form-checkboxes';  if (isset($element['#attributes']['class'])) {    $class .= ' '. $element['#attributes']['class'];  }  $element['#children'] = '<div class="'. $class .'">'. (!empty($element['#children']) ? $element['#children'] : '') .'</div>';  if ($element['#title'] || $element['#description']) {    unset($element['#id']);    return theme('form_element', $element, $element['#children']);  }  else {    return $element['#children'];  }}function expand_checkboxes($element) {  $value = is_array($element['#value']) ? $element['#value'] : array();  $element['#tree'] = TRUE;  if (count($element['#options']) > 0) {    if (!isset($element['#default_value']) || $element['#default_value'] == 0) {      $element['#default_value'] = array();    }    foreach ($element['#options'] as $key => $choice) {      if (!isset($element[$key])) {        $element[$key] = array(          '#type' => 'checkbox',          '#processed' => TRUE,          '#title' => $choice,          '#return_value' => $key,          '#default_value' => isset($value[$key]),          '#attributes' => $element['#attributes'],          '#ahah' => isset($element['#ahah']) ? $element['#ahah'] : NULL,        );      }    }  }  return $element;}/** * Theme a form submit button. * * @ingroup themeable */function theme_submit($element) {  return theme('button', $element);}/** * Theme a form button. * * @ingroup themeable */function theme_button($element) {  // Make sure not to overwrite classes.  if (isset($element['#attributes']['class'])) {    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];  }  else {    $element['#attributes']['class'] = 'form-'. $element['#button_type'];  }  return '<input type="submit" '. (empty($element['#name']) ? '' : 'name="'. $element['#name'] .'" ') .'id="'. $element['#id'] .'" value="'. check_plain($element['#value']) .'" '. drupal_attributes($element['#attributes']) ." />\n";}/** * Theme a form image button. * * @ingroup themeable */function theme_image_button($element) {  // Make sure not to overwrite classes.  if (isset($element['#attributes']['class'])) {    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];  }  else {    $element['#attributes']['class'] = 'form-'. $element['#button_type'];  }  return '<input type="image" name="'. $element['#name'] .'" '.    (!empty($element['#value']) ? ('value="'. check_plain($element['#value']) .'" ') : '') .    'id="'. $element['#id'] .'" '.    drupal_attributes($element['#attributes']) .    ' src="'. base_path() . $element['#src'] .'" '.    (!empty($element['#title']) ? 'alt="'. check_plain($element['#title']) .'" title="'. check_plain($element['#title']) .'" ' : '' ) .    "/>\n";}/** * Format a hidden form field. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  value, edit * @return *   A themed HTML string representing the hidden form field. * * @ingroup themeable */function theme_hidden($element) {  return '<input type="hidden" name="'. $element['#name'] .'" id="'. $element['#id'] .'" value="'. check_plain($element['#value']) ."\" ". drupal_attributes($element['#attributes']) ." />\n";}/** * Format a form token. * * @ingroup themeable */function theme_token($element) {  return theme('hidden', $element);}/** * Format a textfield. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, size, maxlength, required, attributes autocomplete_path * @return *   A themed HTML string representing the textfield. * * @ingroup themeable */function theme_textfield($element) {  $size = empty($element['#size']) ? '' : ' size="'. $element['#size'] .'"';  $maxlength = empty($element['#maxlength']) ? '' : ' maxlength="'. $element['#maxlength'] .'"';  $class = array('form-text');  $extra = '';  $output = '';  if ($element['#autocomplete_path'] && menu_valid_path(array('link_path' => $element['#autocomplete_path']))) {    drupal_add_js('misc/autocomplete.js');    $class[] = 'form-autocomplete';    $extra =  '<input class="autocomplete" type="hidden" id="'. $element['#id'] .'-autocomplete" value="'. check_url(url($element['#autocomplete_path'], array('absolute' => TRUE))) .'" disabled="disabled" />';  }  _form_set_class($element, $class);  if (isset($element['#field_prefix'])) {    $output .= '<span class="field-prefix">'. $element['#field_prefix'] .'</span> ';  }  $output .= '<input type="text"'. $maxlength .' name="'. $element['#name'] .'" id="'. $element['#id'] .'"'. $size .' value="'. check_plain($element['#value']) .'"'. drupal_attributes($element['#attributes']) .' />';  if (isset($element['#field_suffix'])) {    $output .= ' <span class="field-suffix">'. $element['#field_suffix'] .'</span>';  }  return theme('form_element', $element, $output) . $extra;}/** * Format a form. * * @param $element *   An associative array containing the properties of the element. *   Properties used: action, method, attributes, children * @return *   A themed HTML string representing the form. * * @ingroup themeable */function theme_form($element) {  // Anonymous div to satisfy XHTML compliance.  $action = $element['#action'] ? 'action="'. check_url($element['#action']) .'" ' : '';  return '<form '. $action .' accept-charset="UTF-8" method="'. $element['#method'] .'" id="'. $element['#id'] .'"'. drupal_attributes($element['#attributes']) .">\n<div>". $element['#children'] ."\n</div></form>\n";}/** * Format a textarea. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, description, rows, cols, required, attributes * @return *   A themed HTML string representing the textarea. * * @ingroup themeable */function theme_textarea($element) {  $class = array('form-textarea');  // Add teaser behavior (must come before resizable)  if (!empty($element['#teaser'])) {    drupal_add_js('misc/teaser.js');    // Note: arrays are merged in drupal_get_js().    drupal_add_js(array('teaserCheckbox' => array($element['#id'] => $element['#teaser_checkbox'])), 'setting');    drupal_add_js(array('teaser' => array($element['#id'] => $element['#teaser'])), 'setting');    $class[] = 'teaser';  }  // Add resizable behavior  if ($element['#resizable'] !== FALSE) {    drupal_add_js('misc/textarea.js');    $class[] = 'resizable';  }  _form_set_class($element, $class);  return theme('form_element', $element, '<textarea cols="'. $element['#cols'] .'" rows="'. $element['#rows'] .'" name="'. $element['#name'] .'" id="'. $element['#id'] .'" '. drupal_attributes($element['#attributes']) .'>'. check_plain($element['#value']) .'</textarea>');}/** * Format HTML markup for use in forms. * * This is used in more advanced forms, such as theme selection and filter format. * * @param $element *   An associative array containing the properties of the element. *   Properties used: value, children. * @return *   A themed HTML string representing the HTML markup. * * @ingroup themeable */function theme_markup($element) {  return (isset($element['#value']) ? $element['#value'] : '') . (isset($element['#children']) ? $element['#children'] : '');}/** * Format a password field. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, size, maxlength, required, attributes * @return *   A themed HTML string representing the form. * * @ingroup themeable */function theme_password($element) {  $size = $element['#size'] ? ' size="'. $element['#size'] .'" ' : '';  $maxlength = $element['#maxlength'] ? ' maxlength="'. $element['#maxlength'] .'" ' : '';  _form_set_class($element, array('form-text'));  $output = '<input type="password" name="'. $element['#name'] .'" id="'. $element['#id'] .'" '. $maxlength . $size . drupal_attributes($element['#attributes']) .' />';  return theme('form_element', $element, $output);}/** * Expand weight elements into selects. */function process_weight($element) {  for ($n = (-1 * $element['#delta']); $n <= $element['#delta']; $n++) {    $weights[$n] = $n;  }  $element['#options'] = $weights;  $element['#type'] = 'select';  $element['#is_weight'] = TRUE;  $element += _element_info('select');  return $element;}/** * Format a file upload field. * * @param $title *   The label for the file upload field. * @param $name *   The internal name used to refer to the field. * @param $size *   A measure of the visible size of the field (passed directly to HTML). * @param $description *   Explanatory text to display after the form item. * @param $required *   Whether the user must upload a file to the field. * @return *   A themed HTML string representing the field. * * @ingroup themeable * * For assistance with handling the uploaded file correctly, see the API * provided by file.inc. */function theme_file($element) {  _form_set_class($element, array('form-file'));  return theme('form_element', $element, '<input type="file" name="'. $element['#name'] .'"'. ($element['#attributes'] ? ' '. drupal_attributes($element['#attributes']) : '') .' id="'. $element['#id'] .'" size="'. $element['#size'] ."\" />\n");}/** * Return a themed form element. * * @param element *   An associative array containing the properties of the element. *   Properties used: title, description, id, required * @param $value *   The form element's data. * @return *   A string representing the form element. * * @ingroup themeable */function theme_form_element($element, $value) {  // This is also used in the installer, pre-database setup.  $t = get_t();  $output = '<div class="form-item"';  if (!empty($element['#id'])) {    $output .= ' id="'. $element['#id'] .'-wrapper"';  }  $output .= ">\n";  $required = !empty($element['#required']) ? '<span class="form-required" title="'. $t('This field is required.') .'">*</span>' : '';  if (!empty($element['#title'])) {    $title = $element['#title'];    if (!empty($element['#id'])) {      $output .= ' <label for="'. $element['#id'] .'">'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";    }    else {      $output .= ' <label>'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";    }  }  $output .= " $value\n";  if (!empty($element['#description'])) {    $output .= ' <div class="description">'. $element['#description'] ."</div>\n";  }  $output .= "</div>\n";  return $output;}/** * Sets a form element's class attribute. * * Adds 'required' and 'error' classes as needed. * * @param &$element *   The form element. * @param $name *   Array of new class names to be added. */function _form_set_class(&$element, $class = array()) {  if ($element['#required']) {    $class[] = 'required';  }  if (form_get_error($element)) {    $class[] = 'error';  }  if (isset($element['#attributes']['class'])) {    $class[] = $element['#attributes']['class'];  }  $element['#attributes']['class'] = implode(' ', $class);}/** * Prepare an HTML ID attribute string for a form item. * * Remove invalid characters and guarantee uniqueness. * * @param $id *   The ID to clean. * @param $flush *   If set to TRUE, the function will flush and reset the static array *   which is built to test the uniqueness of element IDs. This is only *   used if a form has completed the validation process. This parameter *   should never be set to TRUE if this function is being called to *   assign an ID to the #ID element. * @return *   The cleaned ID. */function form_clean_id($id = NULL, $flush = FALSE) {  static $seen_ids = array();  if ($flush) {    $seen_ids = array();    return;  }  $id = str_replace(array('][', '_', ' '), '-', $id);  // Ensure IDs are unique. The first occurrence is held but left alone.  // Subsequent occurrences get a number appended to them. This incrementing  // will almost certainly break code that relies on explicit HTML IDs in  // forms that appear more than once on the page, but the alternative is  // outputting duplicate IDs, which would break JS code and XHTML  // validity anyways. For now, it's an acceptable stopgap solution.  if (isset($seen_ids[$id])) {    $id = $id .'-'. $seen_ids[$id]++;  }  else {    $seen_ids[$id] = 1;  }  return $id;}/** * @} End of "defgroup form_api". *//** * @defgroup batch Batch operations * @{ * Functions allowing forms processing to be spread out over several page * requests, thus ensuring that the processing does not get interrupted * because of a PHP timeout, while allowing the user to receive feedback * on the progress of the ongoing operations. * * The API is primarily designed to integrate nicely with the Form API * workflow, but can also be used by non-FAPI scripts (like update.php) * or even simple page callbacks (which should probably be used sparingly). * * Example: * @code * $batch = array( *   'title' => t('Exporting'), *   'operations' => array( *     array('my_function_1', array($account->uid, 'story')), *     array('my_function_2', array()), *   ), *   'finished' => 'my_finished_callback', *   'file' => 'path_to_file_containing_myfunctions', * ); * batch_set($batch); * // only needed if not inside a form _submit handler : * batch_process(); * @endcode * * Note: if the batch 'title', 'init_message', 'progress_message', or * 'error_message' could contain any user input, it is the responsibility of * the code calling batch_set() to sanitize them first with a function like * check_plain() or filter_xss(). * * Sample batch operations: * @code * // Simple and artificial: load a node of a given type for a given user * function my_function_1($uid, $type, &$context) { *   // The $context array gathers batch context information about the execution (read), *   // as well as 'return values' for the current operation (write) *   // The following keys are provided : *   // 'results' (read / write): The array of results gathered so far by *   //   the batch processing, for the current operation to append its own. *   // 'message' (write): A text message displayed in the progress page. *   // The following keys allow for multi-step operations : *   // 'sandbox' (read / write): An array that can be freely used to *   //   store persistent data between iterations. It is recommended to *   //   use this instead of $_SESSION, which is unsafe if the user *   //   continues browsing in a separate window while the batch is processing. *   // 'finished' (write): A float number between 0 and 1 informing *   //   the processing engine of the completion level for the operation. *   //   1 (or no value explicitly set) means the operation is finished *   //   and the batch processing can continue to the next operation. * *   $node = node_load(array('uid' => $uid, 'type' => $type)); *   $context['results'][] = $node->nid .' : '. $node->title; *   $context['message'] = $node->title; * } * * // More advanced example: multi-step operation - load all nodes, five by five * function my_function_2(&$context) { *   if (empty($context['sandbox'])) { *     $context['sandbox']['progress'] = 0; *     $context['sandbox']['current_node'] = 0; *     $context['sandbox']['max'] = db_result(db_query('SELECT COUNT(DISTINCT nid) FROM {node}')); *   } *   $limit = 5; *   $result = db_query_range("SELECT nid FROM {node} WHERE nid > %d ORDER BY nid ASC", $context['sandbox']['current_node'], 0, $limit); *   while ($row = db_fetch_array($result)) { *     $node = node_load($row['nid'], NULL, TRUE); *     $context['results'][] = $node->nid .' : '. $node->title; *     $context['sandbox']['progress']++; *     $context['sandbox']['current_node'] = $node->nid; *     $context['message'] = $node->title; *   } *   if ($context['sandbox']['progress'] != $context['sandbox']['max']) { *     $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max']; *   } * } * @endcode * * Sample 'finished' callback: * @code * function batch_test_finished($success, $results, $operations) { *   if ($success) { *     $message = format_plural(count($results), 'One post processed.', '@count posts processed.'); *   } *   else { *     $message = t('Finished with an error.'); *   } *   drupal_set_message($message); *   // Providing data for the redirected page is done through $_SESSION. *   foreach ($results as $result) { *     $items[] = t('Loaded node %title.', array('%title' => $result)); *   } *   $_SESSION['my_batch_results'] = $items; * } * @endcode *//** * Opens a new batch. * * @param $batch *   An array defining the batch. The following keys can be used -- only *   'operations' is required, and batch_init() provides default values for *   the messages. *   - 'operations': Array of function calls to be performed. *     Example: *     @code *     array( *       array('my_function_1', array($arg1)), *       array('my_function_2', array($arg2_1, $arg2_2)), *     ) *     @endcode *   - 'title': Title for the progress page. Only safe strings should be passed. *     Defaults to t('Processing'). *   - 'init_message': Message displayed while the processing is initialized. *     Defaults to t('Initializing.'). *   - 'progress_message': Message displayed while processing the batch. *     Available placeholders are @current, @remaining, @total, @percentage, *     @estimate and @elapsed. Defaults to t('Completed @current of @total.'). *   - 'error_message': Message displayed if an error occurred while processing *     the batch. Defaults to t('An error has occurred.'). *   - 'finished': Name of a function to be executed after the batch has *     completed. This should be used to perform any result massaging that *     may be needed, and possibly save data in $_SESSION for display after *     final page redirection. *   - 'file': Path to the file containing the definitions of the *     'operations' and 'finished' functions, for instance if they don't *     reside in the main .module file. The path should be relative to *     base_path(), and thus should be built using drupal_get_path(). * * Operations are added as new batch sets. Batch sets are used to ensure * clean code independence, ensuring that several batches submitted by * different parts of the code (core / contrib modules) can be processed * correctly while not interfering or having to cope with each other. Each * batch set gets to specify his own UI messages, operates on its own set * of operations and results, and triggers its own 'finished' callback. * Batch sets are processed sequentially, with the progress bar starting * fresh for every new set. */function batch_set($batch_definition) {  if ($batch_definition) {    $batch =& batch_get();    // Initialize the batch    if (empty($batch)) {      $batch = array(        'sets' => array(),      );    }    $init = array(      'sandbox' => array(),      'results' => array(),      'success' => FALSE,    );    // Use get_t() to allow batches at install time.    $t = get_t();    $defaults = array(      'title' => $t('Processing'),      'init_message' => $t('Initializing.'),      'progress_message' => $t('Remaining @remaining of @total.'),      'error_message' => $t('An error has occurred.'),    );    $batch_set = $init + $batch_definition + $defaults;    // Tweak init_message to avoid the bottom of the page flickering down after init phase.    $batch_set['init_message'] .= '<br/>&nbsp;';    $batch_set['total'] = count($batch_set['operations']);    // If the batch is being processed (meaning we are executing a stored submit handler),    // insert the new set after the current one.    if (isset($batch['current_set'])) {      // array_insert does not exist...      $slice1 = array_slice($batch['sets'], 0, $batch['current_set'] + 1);      $slice2 = array_slice($batch['sets'], $batch['current_set'] + 1);      $batch['sets'] = array_merge($slice1, array($batch_set), $slice2);    }    else {      $batch['sets'][] = $batch_set;    }  }}/** * Processes the batch. * * Unless the batch has been marked with 'progressive' = FALSE, the function * issues a drupal_goto and thus ends page execution. * * This function is not needed in form submit handlers; Form API takes care * of batches that were set during form submission. * * @param $redirect *   (optional) Path to redirect to when the batch has finished processing. * @param $url *   (optional - should only be used for separate scripts like update.php) *   URL of the batch processing page. */function batch_process($redirect = NULL, $url = NULL) {  $batch =& batch_get();  if (isset($batch)) {    // Add process information    $url = isset($url) ? $url : 'batch';    $process_info = array(      'current_set' => 0,      'progressive' => TRUE,      'url' => isset($url) ? $url : 'batch',      'source_page' => $_GET['q'],      'redirect' => $redirect,    );    $batch += $process_info;    if ($batch['progressive']) {      // Clear the way for the drupal_goto redirection to the batch processing      // page, by saving and unsetting the 'destination' if any, on both places      // drupal_goto looks for it.      if (isset($_REQUEST['destination'])) {        $batch['destination'] = $_REQUEST['destination'];        unset($_REQUEST['destination']);      }      elseif (isset($_REQUEST['edit']['destination'])) {        $batch['destination'] = $_REQUEST['edit']['destination'];        unset($_REQUEST['edit']['destination']);      }      // Initiate db storage in order to get a batch id. We have to provide      // at least an empty string for the (not null) 'token' column.      db_query("INSERT INTO {batch} (token, timestamp) VALUES ('', %d)", time());      $batch['id'] = db_last_insert_id('batch', 'bid');      // Now that we have a batch id, we can generate the redirection link in      // the generic error message.      $t = get_t();      $batch['error_message'] = $t('Please continue to <a href="@error_url">the error page</a>', array('@error_url' => url($url, array('query' => array('id' => $batch['id'], 'op' => 'finished')))));      // Actually store the batch data and the token generated form the batch id.      db_query("UPDATE {batch} SET token = '%s', batch = '%s' WHERE bid = %d", drupal_get_token($batch['id']), serialize($batch), $batch['id']);      drupal_goto($batch['url'], 'op=start&id='. $batch['id']);    }    else {      // Non-progressive execution: bypass the whole progressbar workflow      // and execute the batch in one pass.      require_once './includes/batch.inc';      _batch_process();    }  }}/** * Retrieves the current batch. */function &batch_get() {  static $batch = array();  return $batch;}/** * @} End of "defgroup batch". */
<?php// $Id$?><div class="comment<?php print ($comment->new) ? ' comment-new' : ''; print ' '. $status; print ' '. $zebra; ?>">  <div class="clear-block">  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted; ?></span>  <?php endif; ?>  <?php if ($comment->new) : ?>    <span class="new"><?php print drupal_ucfirst($new) ?></span>  <?php endif; ?>  <?php print $picture ?>    <h3><?php print $title ?></h3>    <div class="content">      <?php print $content ?>      <?php if ($signature): ?>      <div class="clear-block">        <div></div>        <?php print $signature ?>      </div>      <?php endif; ?>    </div>  </div>  <?php if ($links): ?>    <div class="links"><?php print $links ?></div>  <?php endif; ?></div>
<?php// $Id$/** * Implementation of hook_schema(). */function filter_schema() {  $schema['filters'] = array(    'description' => 'Table that maps filters (HTML corrector) to input formats (Filtered HTML).',    'fields' => array(      'fid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Auto-incrementing filter ID.',      ),      'format' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Foreign key: The {filter_formats}.format to which this filter is assigned.',      ),      'module' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'The origin module of the filter.',      ),      'delta' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'ID to identify which filter within module is being referenced.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Weight of filter within format.',      )    ),    'primary key' => array('fid'),    'unique keys' => array(      'fmd' => array('format', 'module', 'delta'),    ),    'indexes' => array(      'list' => array('format', 'weight', 'module', 'delta'),    ),  );  $schema['filter_formats'] = array(    'description' => 'Stores input formats: custom groupings of filters, such as Filtered HTML.',    'fields' => array(      'format' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique ID for format.',      ),      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Name of the input format (Filtered HTML).',      ),      'roles' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'A comma-separated string of roles; references {role}.rid.', // This is bad since you can't use joins, nor index.      ),      'cache' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate whether format is cachable. (1 = cachable, 0 = not cachable)',      ),    ),    'primary key' => array('format'),    'unique keys' => array('name' => array('name')),  );  $schema['cache_filter'] = drupal_get_schema_unprocessed('system', 'cache');  $schema['cache_filter']['description'] = 'Cache table for the Filter module to store already filtered pieces of text, identified by input format and md5 hash of the text.';  return $schema;}
<?php// $Id$/** * @file * User page callbacks for the translation module. *//** * Overview page for a node's translations. * * @param $node *   Node object. */function translation_node_overview($node) {  if ($node->tnid) {    // Already part of a set, grab that set.    $tnid = $node->tnid;    $translations = translation_node_get_translations($node->tnid);  }  else {    // We have no translation source nid, this could be a new set, emulate that.    $tnid = $node->nid;    $translations = array($node->language => $node);  }  $header = array(t('Language'), t('Title'), t('Status'), t('Operations'));  foreach (language_list() as $language) {    $options = array();    $language_name = $language->name;    if (isset($translations[$language->language])) {      // Existing translation in the translation set: display status.      // We load the full node to check whether the user can edit it.      $translation_node = node_load($translations[$language->language]->nid);      $title = l($translation_node->title, 'node/'. $translation_node->nid);      if (node_access('update', $translation_node)) {        $options[] = l(t('edit'), "node/$translation_node->nid/edit");      }      $status = $translation_node->status ? t('Published') : t('Not published');      $status .= $translation_node->translate ? ' - <span class="marker">'. t('outdated') .'</span>' : '';      if ($translation_node->nid == $tnid) {        $language_name = t('<strong>@language_name</strong> (source)', array('@language_name' => $language_name));      }    }    else {      // No such translation in the set yet: help user to create it.      $title = t('n/a');      if (node_access('create', $node)) {        $options[] = l(t('add translation'), 'node/add/'. str_replace('_', '-', $node->type), array('query' => "translation=$node->nid&language=$language->language"));      }      $status = t('Not translated');    }    $rows[] = array($language_name, $title, $status, implode(" | ", $options));  }  drupal_set_title(t('Translations of %title', array('%title' => $node->title)));  return theme('table', $header, $rows);}
<?php// $Id$?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="<?php print $language->language ?>" xml:lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>"><head>  <?php print $head ?>  <title><?php print $head_title ?></title>  <?php print $styles ?>  <?php print $scripts ?>  <script type="text/javascript"><?php /* Needed to avoid Flash of Unstyle Content in IE */ ?> </script></head><body><table border="0" cellpadding="0" cellspacing="0" id="header">  <tr>    <td id="logo">      <?php if ($logo) { ?><a href="<?php print $front_page ?>" title="<?php print t('Home') ?>"><img src="<?php print $logo ?>" alt="<?php print t('Home') ?>" /></a><?php } ?>      <?php if ($site_name) { ?><h1 class='site-name'><a href="<?php print $front_page ?>" title="<?php print t('Home') ?>"><?php print $site_name ?></a></h1><?php } ?>      <?php if ($site_slogan) { ?><div class='site-slogan'><?php print $site_slogan ?></div><?php } ?>    </td>    <td id="menu">      <?php if (isset($secondary_links)) { ?><?php print theme('links', $secondary_links, array('class' => 'links', 'id' => 'subnavlist')) ?><?php } ?>      <?php if (isset($primary_links)) { ?><?php print theme('links', $primary_links, array('class' => 'links', 'id' => 'navlist')) ?><?php } ?>      <?php print $search_box ?>    </td>  </tr>  <tr>    <td colspan="2"><div><?php print $header ?></div></td>  </tr></table><table border="0" cellpadding="0" cellspacing="0" id="content">  <tr>    <?php if ($left) { ?><td id="sidebar-left">      <?php print $left ?>    </td><?php } ?>    <td valign="top">      <?php if ($mission) { ?><div id="mission"><?php print $mission ?></div><?php } ?>      <div id="main">        <?php print $breadcrumb ?>        <h1 class="title"><?php print $title ?></h1>        <div class="tabs"><?php print $tabs ?></div>        <?php if ($show_messages) { print $messages; } ?>        <?php print $help ?>        <?php print $content; ?>        <?php print $feed_icons; ?>      </div>    </td>    <?php if ($right) { ?><td id="sidebar-right">      <?php print $right ?>    </td><?php } ?>  </tr></table><div id="footer">  <?php print $footer_message ?>  <?php print $footer ?></div><?php print $closure ?></body></html>
<?php// $Id$/** * @file * User page callbacks for the forum module. *//** * Menu callback; prints a forum listing. */function forum_page($tid = 0) {  if (!is_numeric($tid)) {    return MENU_NOT_FOUND;  }  $tid = (int)$tid;  $topics = '';  $forum_per_page = variable_get('forum_per_page', 25);  $sortby = variable_get('forum_order', 1);  $forums = forum_get_forums($tid);  $parents = taxonomy_get_parents_all($tid);  if ($tid && !in_array($tid, variable_get('forum_containers', array()))) {    $topics = forum_get_topics($tid, $sortby, $forum_per_page);  }  return theme('forums', $forums, $topics, $parents, $tid, $sortby, $forum_per_page);}
<?php// $Id$/** * @file * Enables users to comment on published content. * * When enabled, the Drupal comment module creates a discussion * board for each Drupal node. Users can post comments to discuss * a forum topic, weblog post, story, collaborative book page, etc. *//** * Comment is published. */define('COMMENT_PUBLISHED', 0);/** * Comment is awaiting approval. */define('COMMENT_NOT_PUBLISHED', 1);/** * Comments are displayed in a flat list - collapsed. */define('COMMENT_MODE_FLAT_COLLAPSED', 1);/** * Comments are displayed in a flat list - expanded. */define('COMMENT_MODE_FLAT_EXPANDED', 2);/** * Comments are displayed as a threaded list - collapsed. */define('COMMENT_MODE_THREADED_COLLAPSED', 3);/** * Comments are displayed as a threaded list - expanded. */define('COMMENT_MODE_THREADED_EXPANDED', 4);/** * Comments are ordered by date - newest first. */define('COMMENT_ORDER_NEWEST_FIRST', 1);/** * Comments are ordered by date - oldest first. */define('COMMENT_ORDER_OLDEST_FIRST', 2);/** * Comment controls should be shown above the comment list. */define('COMMENT_CONTROLS_ABOVE', 0);/** * Comment controls should be shown below the comment list. */define('COMMENT_CONTROLS_BELOW', 1);/** * Comment controls should be shown both above and below the comment list. */define('COMMENT_CONTROLS_ABOVE_BELOW', 2);/** * Comment controls are hidden. */define('COMMENT_CONTROLS_HIDDEN', 3);/** * Anonymous posters may not enter their contact information. */define('COMMENT_ANONYMOUS_MAYNOT_CONTACT', 0);/** * Anonymous posters may leave their contact information. */define('COMMENT_ANONYMOUS_MAY_CONTACT', 1);/** * Anonymous posters must leave their contact information. */define('COMMENT_ANONYMOUS_MUST_CONTACT', 2);/** * Comment form should be displayed on a separate page. */define('COMMENT_FORM_SEPARATE_PAGE', 0);/** * Comment form should be shown below post or list of comments. */define('COMMENT_FORM_BELOW', 1);/** * Comments for this node are disabled. */define('COMMENT_NODE_DISABLED', 0);/** * Comments for this node are locked. */define('COMMENT_NODE_READ_ONLY', 1);/** * Comments are enabled on this node. */define('COMMENT_NODE_READ_WRITE', 2);/** * Comment preview is optional. */define('COMMENT_PREVIEW_OPTIONAL', 0);/** * Comment preview is required. */define('COMMENT_PREVIEW_REQUIRED', 1);/** * Implementation of hook_help(). */function comment_help($path, $arg) {  switch ($path) {    case 'admin/help#comment':      $output = '<p>'. t('The comment module allows visitors to comment on your posts, creating ad hoc discussion boards. Any <a href="@content-type">content type</a> may have its <em>Default comment setting</em> set to <em>Read/Write</em> to allow comments, or <em>Disabled</em>, to prevent comments. Comment display settings and other controls may also be customized for each content type (some display settings are customizable by individual users).', array('@content-type' => url('admin/content/types'))) .'</p>';      $output .= '<p>'. t('Comment permissions are assigned to user roles, and are used to determine whether anonymous users (or other roles) are allowed to comment on posts. If anonymous users are allowed to comment, their individual contact information may be retained in cookies stored on their local computer for use in later comment submissions. When a comment has no replies, it may be (optionally) edited by its author. The comment module uses the same input formats and HTML tags available when creating other forms of content.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@comment">Comment module</a>.', array('@comment' => 'http://drupal.org/handbook/modules/comment/')) .'</p>';      return $output;    case 'admin/content/comment':      return '<p>'. t("Below is a list of the latest comments posted to your site. Click on a subject to see the comment, the author's name to edit the author's user information, 'edit' to modify the text, and 'delete' to remove their submission.") .'</p>';    case 'admin/content/comment/approval':      return '<p>'. t("Below is a list of the comments posted to your site that need approval. To approve a comment, click on 'edit' and then change its 'moderation status' to Approved. Click on a subject to see the comment, the author's name to edit the author's user information, 'edit' to modify the text, and 'delete' to remove their submission.") .'</p>';  }}/** * Implementation of hook_theme(). */function comment_theme() {  return array(    'comment_block' => array(      'arguments' => array(),    ),    'comment_admin_overview' => array(      'arguments' => array('form' => NULL),    ),    'comment_preview' => array(      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array(), 'visible' => 1),    ),    'comment_view' => array(      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array(), 'visible' => 1),    ),    'comment_controls' => array(      'arguments' => array('form' => NULL),    ),    'comment' => array(      'template' => 'comment',      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array()),    ),    'comment_folded' => array(      'template' => 'comment-folded',      'arguments' => array('comment' => NULL),    ),    'comment_flat_collapsed' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_flat_expanded' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_thread_collapsed' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_thread_expanded' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_post_forbidden' => array(      'arguments' => array('nid' => NULL),    ),    'comment_wrapper' => array(      'template' => 'comment-wrapper',      'arguments' => array('content' => NULL, 'node' => NULL),    ),    'comment_submitted' => array(      'arguments' => array('comment' => NULL),    ),  );}/** * Implementation of hook_menu(). */function comment_menu() {  $items['admin/content/comment'] = array(    'title' => 'Comments',    'description' => 'List and edit site comments and the comment moderation queue.',    'page callback' => 'comment_admin',    'access arguments' => array('administer comments'),    'file' => 'comment.admin.inc',  );  // Tabs:  $items['admin/content/comment/new'] = array(    'title' => 'Published comments',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/comment/approval'] = array(    'title' => 'Approval queue',    'page arguments' => array('approval'),    'access arguments' => array('administer comments'),    'type' => MENU_LOCAL_TASK,    'file' => 'comment.admin.inc',  );  $items['comment/delete'] = array(    'title' => 'Delete comment',    'page callback' => 'comment_delete',    'access arguments' => array('administer comments'),    'type' => MENU_CALLBACK,    'file' => 'comment.admin.inc',  );  $items['comment/edit'] = array(    'title' => 'Edit comment',    'page callback' => 'comment_edit',    'access arguments' => array('post comments'),    'type' => MENU_CALLBACK,    'file' => 'comment.pages.inc',  );  $items['comment/reply/%node'] = array(    'title' => 'Reply to comment',    'page callback' => 'comment_reply',    'page arguments' => array(2),    'access callback' => 'node_access',    'access arguments' => array('view', 2),    'type' => MENU_CALLBACK,    'file' => 'comment.pages.inc',  );  return $items;}/** * Implementation of hook_node_type(). */function comment_node_type($op, $info) {  $settings = array(    'comment',    'comment_default_mode',    'comment_default_order',    'comment_default_per_page',    'comment_controls',    'comment_anonymous',    'comment_subject_field',    'comment_preview',    'comment_form_location',  );  switch ($op) {    case 'delete':      foreach ($settings as $setting) {        variable_del($setting .'_'. $info->type);      }      break;  }}/** * Implementation of hook_perm(). */function comment_perm() {  return array('access comments', 'post comments', 'administer comments', 'post comments without approval');}/** * Implementation of hook_block(). * * Generates a block with the most recent comments. */function comment_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Recent comments');    return $blocks;  }  else if ($op == 'view' && user_access('access comments')) {    $block['subject'] = t('Recent comments');    $block['content'] = theme('comment_block');    return $block;  }}/** * Find a number of recent comments. This is done in two steps. *   1. Find the n (specified by $number) nodes that have the most recent *      comments.  This is done by querying node_comment_statistics which has *      an index on last_comment_timestamp, and is thus a fast query. *   2. Loading the information from the comments table based on the nids found *      in step 1. * * @param $number *   (optional) The maximum number of comments to find. * @return *   An array of comment objects each containing a nid, *   subject, cid, and timestamp, or an empty array if there are no recent *   comments visible to the current user. */function comment_get_recent($number = 10) {  // Select the $number nodes (visible to the current user) with the most  // recent comments. This is efficient due to the index on  // last_comment_timestamp.  $result = db_query_range(db_rewrite_sql("SELECT nc.nid FROM {node_comment_statistics} nc WHERE nc.comment_count > 0 ORDER BY nc.last_comment_timestamp DESC", 'nc'), 0, $number);  $nids = array();  while ($row = db_fetch_object($result)) {    $nids[] = $row->nid;  }  $comments = array();  if (!empty($nids)) {    // From among the comments on the nodes selected in the first query,    // find the $number most recent comments.    $result = db_query_range('SELECT c.nid, c.subject, c.cid, c.timestamp FROM {comments} c INNER JOIN {node} n ON n.nid = c.nid WHERE c.nid IN ('. implode(',', $nids) .') AND n.status = 1 AND c.status = %d ORDER BY c.cid DESC', COMMENT_PUBLISHED, 0, $number);    while ($comment = db_fetch_object($result)) {      $comments[] = $comment;    }  }  return $comments;}/** * Calculate page number for first new comment. * * @param $num_comments *   Number of comments. * @param $new_replies *   Number of new replies. * @param $node *   The first new comment node. * @return *   "page=X" if the page number is greater than zero; empty string otherwise. */function comment_new_page_count($num_comments, $new_replies, $node) {  $comments_per_page = _comment_get_display_setting('comments_per_page', $node);  $mode = _comment_get_display_setting('mode', $node);  $order = _comment_get_display_setting('sort', $node);  $pagenum = NULL;  $flat = in_array($mode, array(COMMENT_MODE_FLAT_COLLAPSED, COMMENT_MODE_FLAT_EXPANDED));  if ($num_comments <= $comments_per_page || ($flat && $order == COMMENT_ORDER_NEWEST_FIRST)) {    // Only one page of comments or flat forum and newest first.    // First new comment will always be on first page.    $pageno = 0;  }  else {    if ($flat) {      // Flat comments and oldest first.      $count = $num_comments - $new_replies;    }    else {      // Threaded comments. See the documentation for comment_render().      if ($order == COMMENT_ORDER_NEWEST_FIRST) {        // Newest first: find the last thread with new comment        $result = db_query('SELECT thread FROM (SELECT thread FROM {comments} WHERE nid = %d AND status = 0 ORDER BY timestamp DESC LIMIT %d) AS thread ORDER BY thread DESC LIMIT 1', $node->nid, $new_replies);        $thread = db_result($result);        $result_count = db_query("SELECT COUNT(*) FROM {comments} WHERE nid = %d AND status = 0 AND thread > '". $thread ."'", $node->nid);      }      else {        // Oldest first: find the first thread with new comment        $result = db_query('SELECT thread FROM (SELECT thread FROM {comments} WHERE nid = %d AND status = 0 ORDER BY timestamp DESC LIMIT %d) AS thread ORDER BY SUBSTRING(thread, 1, (LENGTH(thread) - 1)) LIMIT 1', $node->nid, $new_replies);        $thread = substr(db_result($result), 0, -1);        $result_count = db_query("SELECT COUNT(*) FROM {comments} WHERE nid = %d AND status = 0 AND SUBSTRING(thread, 1, (LENGTH(thread) - 1)) < '". $thread ."'", $node->nid);      }      $count = db_result($result_count);    }    $pageno =  $count / $comments_per_page;  }  if ($pageno >= 1) {    $pagenum = "page=". intval($pageno);  }  return $pagenum;}/** * Returns a formatted list of recent comments to be displayed in the comment block. * * @return *   The comment list HTML. * @ingroup themeable */function theme_comment_block() {  $items = array();  foreach (comment_get_recent() as $comment) {    $items[] = l($comment->subject, 'node/'. $comment->nid, array('fragment' => 'comment-'. $comment->cid)) .'<br />'. t('@time ago', array('@time' => format_interval(time() - $comment->timestamp)));  }  if ($items) {    return theme('item_list', $items);  }}/** * Implementation of hook_link(). */function comment_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && $node->comment) {    if ($teaser) {      // Main page: display the number of comments that have been posted.      if (user_access('access comments')) {        $all = comment_num_all($node->nid);        if ($all) {          $links['comment_comments'] = array(            'title' => format_plural($all, '1 comment', '@count comments'),            'href' => "node/$node->nid",            'attributes' => array('title' => t('Jump to the first comment of this posting.')),            'fragment' => 'comments'          );          $new = comment_num_new($node->nid);          if ($new) {            $links['comment_new_comments'] = array(              'title' => format_plural($new, '1 new comment', '@count new comments'),              'href' => "node/$node->nid",              'query' => comment_new_page_count($all, $new, $node),              'attributes' => array('title' => t('Jump to the first new comment of this posting.')),              'fragment' => 'new'            );          }        }        else {          if ($node->comment == COMMENT_NODE_READ_WRITE) {            if (user_access('post comments')) {              $links['comment_add'] = array(                'title' => t('Add new comment'),                'href' => "comment/reply/$node->nid",                'attributes' => array('title' => t('Add a new comment to this page.')),                'fragment' => 'comment-form'              );            }            else {              $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);            }          }        }      }    }    else {      // Node page: add a "post comment" link if the user is allowed to      // post comments, if this node is not read-only, and if the comment form isn't already shown      if ($node->comment == COMMENT_NODE_READ_WRITE) {        if (user_access('post comments')) {          if (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_SEPARATE_PAGE) {            $links['comment_add'] = array(              'title' => t('Add new comment'),              'href' => "comment/reply/$node->nid",              'attributes' => array('title' => t('Share your thoughts and opinions related to this posting.')),              'fragment' => 'comment-form'            );          }        }        else {          $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);        }      }    }  }  if ($type == 'comment') {    $links = comment_links($node, $teaser);  }  if (isset($links['comment_forbidden'])) {    $links['comment_forbidden']['html'] = TRUE;  }  return $links;}/** * Implementation of hook_form_alter(). */function comment_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {    $form['comment'] = array(      '#type' => 'fieldset',      '#title' => t('Comment settings'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,    );    $form['comment']['comment'] = array(      '#type' => 'radios',      '#title' => t('Default comment setting'),      '#default_value' => variable_get('comment_'. $form['#node_type']->type, COMMENT_NODE_READ_WRITE),      '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),      '#description' => t('Users with the <em>administer comments</em> permission will be able to override this setting.'),    );    $form['comment']['comment_default_mode'] = array(      '#type' => 'radios',      '#title' => t('Default display mode'),      '#default_value' => variable_get('comment_default_mode_'. $form['#node_type']->type, COMMENT_MODE_THREADED_EXPANDED),      '#options' => _comment_get_modes(),      '#description' => t('The default view for comments. Expanded views display the body of the comment. Threaded views keep replies together.'),    );    $form['comment']['comment_default_order'] = array(      '#type' => 'radios',      '#title' => t('Default display order'),      '#default_value' => variable_get('comment_default_order_'. $form['#node_type']->type, COMMENT_ORDER_NEWEST_FIRST),      '#options' => _comment_get_orders(),      '#description' => t('The default sorting for new users and anonymous users while viewing comments. These users may change their view using the comment control panel. For registered users, this change is remembered as a persistent user preference.'),    );    $form['comment']['comment_default_per_page'] = array(      '#type' => 'select',      '#title' => t('Default comments per page'),      '#default_value' => variable_get('comment_default_per_page_'. $form['#node_type']->type, 50),      '#options' => _comment_per_page(),      '#description' => t('Default number of comments for each page: more comments are distributed in several pages.'),    );    $form['comment']['comment_controls'] = array(      '#type' => 'radios',      '#title' => t('Comment controls'),      '#default_value' => variable_get('comment_controls_'. $form['#node_type']->type, COMMENT_CONTROLS_HIDDEN),      '#options' => array(        t('Display above the comments'),        t('Display below the comments'),        t('Display above and below the comments'),        t('Do not display')),      '#description' => t('Position of the comment controls box. The comment controls let the user change the default display mode and display order of comments.'),    );    $form['comment']['comment_anonymous'] = array(      '#type' => 'radios',      '#title' => t('Anonymous commenting'),      '#default_value' => variable_get('comment_anonymous_'. $form['#node_type']->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT),      '#options' => array(        COMMENT_ANONYMOUS_MAYNOT_CONTACT => t('Anonymous posters may not enter their contact information'),        COMMENT_ANONYMOUS_MAY_CONTACT => t('Anonymous posters may leave their contact information'),        COMMENT_ANONYMOUS_MUST_CONTACT => t('Anonymous posters must leave their contact information')),      '#description' => t('This option is enabled when anonymous users have permission to post comments on the <a href="@url">permissions page</a>.', array('@url' => url('admin/user/permissions', array('fragment' => 'module-comment')))),    );    if (!user_access('post comments', drupal_anonymous_user())) {      $form['comment']['comment_anonymous']['#disabled'] = TRUE;    }    $form['comment']['comment_subject_field'] = array(      '#type' => 'radios',      '#title' => t('Comment subject field'),      '#default_value' => variable_get('comment_subject_field_'. $form['#node_type']->type, 1),      '#options' => array(t('Disabled'), t('Enabled')),      '#description' => t('Can users provide a unique subject for their comments?'),    );    $form['comment']['comment_preview'] = array(      '#type' => 'radios',      '#title' => t('Preview comment'),      '#default_value' => variable_get('comment_preview_'. $form['#node_type']->type, COMMENT_PREVIEW_REQUIRED),      '#options' => array(t('Optional'), t('Required')),      '#description' => t("Forces a user to look at their comment by clicking on a 'Preview' button before they can actually add the comment"),    );    $form['comment']['comment_form_location'] = array(      '#type' => 'radios',      '#title' => t('Location of comment submission form'),      '#default_value' => variable_get('comment_form_location_'. $form['#node_type']->type, COMMENT_FORM_SEPARATE_PAGE),      '#options' => array(t('Display on separate page'), t('Display below post or comments')),    );  }  elseif (isset($form['type']) && isset($form['#node'])) {    if ($form['type']['#value'] .'_node_form' == $form_id) {      $node = $form['#node'];      $form['comment_settings'] = array(        '#type' => 'fieldset',        '#access' => user_access('administer comments'),        '#title' => t('Comment settings'),        '#collapsible' => TRUE,        '#collapsed' => TRUE,        '#weight' => 30,      );      $form['comment_settings']['comment'] = array(        '#type' => 'radios',        '#parents' => array('comment'),        '#default_value' => $node->comment,        '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),      );    }  }}/** * Implementation of hook_nodeapi(). */function comment_nodeapi(&$node, $op, $arg = 0) {  switch ($op) {    case 'load':      return db_fetch_array(db_query("SELECT last_comment_timestamp, last_comment_name, comment_count FROM {node_comment_statistics} WHERE nid = %d", $node->nid));      break;    case 'prepare':      if (!isset($node->comment)) {        $node->comment = variable_get("comment_$node->type", COMMENT_NODE_READ_WRITE);      }      break;    case 'insert':      db_query('INSERT INTO {node_comment_statistics} (nid, last_comment_timestamp, last_comment_name, last_comment_uid, comment_count) VALUES (%d, %d, NULL, %d, 0)', $node->nid, $node->changed, $node->uid);      break;    case 'delete':      db_query('DELETE FROM {comments} WHERE nid = %d', $node->nid);      db_query('DELETE FROM {node_comment_statistics} WHERE nid = %d', $node->nid);      break;    case 'update index':      $text = '';      $comments = db_query('SELECT subject, comment, format FROM {comments} WHERE nid = %d AND status = %d', $node->nid, COMMENT_PUBLISHED);      while ($comment = db_fetch_object($comments)) {        $text .= '<h2>'. check_plain($comment->subject) .'</h2>'. check_markup($comment->comment, $comment->format, FALSE);      }      return $text;    case 'search result':      $comments = db_result(db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = %d', $node->nid));      return format_plural($comments, '1 comment', '@count comments');    case 'rss item':      if ($node->comment != COMMENT_NODE_DISABLED) {        return array(array('key' => 'comments', 'value' => url('node/'. $node->nid, array('fragment' => 'comments', 'absolute' => TRUE))));      }      else {        return array();      }  }}/** * Implementation of hook_user(). */function comment_user($type, $edit, &$user, $category = NULL) {  if ($type == 'delete') {    db_query('UPDATE {comments} SET uid = 0 WHERE uid = %d', $user->uid);    db_query('UPDATE {node_comment_statistics} SET last_comment_uid = 0 WHERE last_comment_uid = %d', $user->uid);  }}/** * This is *not* a hook_access() implementation. This function is called * to determine whether the current user has access to a particular comment. * * Authenticated users can edit their comments as long they have not been * replied to. This prevents people from changing or revising their * statements based on the replies to their posts. * * @param $op *   The operation that is to be performed on the comment. Only 'edit' is recognized now. * @param $comment *   The comment object. * @return *   TRUE if the current user has acces to the comment, FALSE otherwise. */function comment_access($op, $comment) {  global $user;  if ($op == 'edit') {    return ($user->uid && $user->uid == $comment->uid && comment_num_replies($comment->cid) == 0) || user_access('administer comments');  }}/** * A simple helper function. * * @return *   The 0th and the 1st path components joined by a slash. */function comment_node_url() {  return arg(0) .'/'. arg(1);}/** * Accepts a submission of new or changed comment content. * * @param $edit *   A comment array. * * @return *   If the comment is successfully saved the comment ID is returned. If the comment *   is not saved, FALSE is returned. */function comment_save($edit) {  global $user;  if (user_access('post comments') && (user_access('administer comments') || node_comment_mode($edit['nid']) == COMMENT_NODE_READ_WRITE)) {    if (!form_get_errors()) {      $edit += array(        'mail' => '',        'homepage' => '',        'name' => '',        'status' => user_access('post comments without approval') ? COMMENT_PUBLISHED : COMMENT_NOT_PUBLISHED,      );      if ($edit['cid']) {        // Update the comment in the database.        db_query("UPDATE {comments} SET status = %d, timestamp = %d, subject = '%s', comment = '%s', format = %d, uid = %d, name = '%s', mail = '%s', homepage = '%s' WHERE cid = %d", $edit['status'], $edit['timestamp'], $edit['subject'], $edit['comment'], $edit['format'], $edit['uid'], $edit['name'], $edit['mail'], $edit['homepage'], $edit['cid']);        // Allow modules to respond to the updating of a comment.        comment_invoke_comment($edit, 'update');        // Add an entry to the watchdog log.        watchdog('content', 'Comment: updated %subject.', array('%subject' => $edit['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $edit['nid'], array('fragment' => 'comment-'. $edit['cid'])));      }      else {        // Add the comment to database.        // Here we are building the thread field. See the documentation for        // comment_render().        if ($edit['pid'] == 0) {          // This is a comment with no parent comment (depth 0): we start          // by retrieving the maximum thread level.          $max = db_result(db_query('SELECT MAX(thread) FROM {comments} WHERE nid = %d', $edit['nid']));          // Strip the "/" from the end of the thread.          $max = rtrim($max, '/');          // Finally, build the thread field for this new comment.          $thread = int2vancode(vancode2int($max) + 1) .'/';        }        else {          // This is comment with a parent comment: we increase          // the part of the thread value at the proper depth.          // Get the parent comment:          $parent = _comment_load($edit['pid']);          // Strip the "/" from the end of the parent thread.          $parent->thread = (string) rtrim((string) $parent->thread, '/');          // Get the max value in _this_ thread.          $max = db_result(db_query("SELECT MAX(thread) FROM {comments} WHERE thread LIKE '%s.%%' AND nid = %d", $parent->thread, $edit['nid']));          if ($max == '') {            // First child of this parent.            $thread = $parent->thread .'.'. int2vancode(0) .'/';          }          else {            // Strip the "/" at the end of the thread.            $max = rtrim($max, '/');            // We need to get the value at the correct depth.            $parts = explode('.', $max);            $parent_depth = count(explode('.', $parent->thread));            $last = $parts[$parent_depth];            // Finally, build the thread field for this new comment.            $thread = $parent->thread .'.'. int2vancode(vancode2int($last) + 1) .'/';          }        }        if (empty($edit['timestamp'])) {          $edit['timestamp'] = time();        }        if ($edit['uid'] === $user->uid && isset($user->name)) { // '===' Need to modify anonymous users as well.          $edit['name'] = $user->name;        }        db_query("INSERT INTO {comments} (nid, pid, uid, subject, comment, format, hostname, timestamp, status, thread, name, mail, homepage) VALUES (%d, %d, %d, '%s', '%s', %d, '%s', %d, %d, '%s', '%s', '%s', '%s')", $edit['nid'], $edit['pid'], $edit['uid'], $edit['subject'], $edit['comment'], $edit['format'], ip_address(), $edit['timestamp'], $edit['status'], $thread, $edit['name'], $edit['mail'], $edit['homepage']);        $edit['cid'] = db_last_insert_id('comments', 'cid');        // Tell the other modules a new comment has been submitted.        comment_invoke_comment($edit, 'insert');        // Add an entry to the watchdog log.        watchdog('content', 'Comment: added %subject.', array('%subject' => $edit['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $edit['nid'], array('fragment' => 'comment-'. $edit['cid'])));      }      _comment_update_node_statistics($edit['nid']);      // Clear the cache so an anonymous user can see his comment being added.      cache_clear_all();      // Explain the approval queue if necessary, and then      // redirect the user to the node he's commenting on.      if ($edit['status'] == COMMENT_NOT_PUBLISHED) {        drupal_set_message(t('Your comment has been queued for moderation by site administrators and will be published after approval.'));      }      else {        comment_invoke_comment($edit, 'publish');      }      return $edit['cid'];    }    else {      return FALSE;    }  }  else {    watchdog('content', 'Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $edit['subject']), WATCHDOG_WARNING);    drupal_set_message(t('Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $edit['subject'])), 'error');    return FALSE;  }}/** * Build command links for a comment (e.g.\ edit, reply, delete) with respect to the current user's access permissions. * * @param $comment *   The comment to which the links will be related. * @param $return *   Not used. * @return *   An associative array containing the links. */function comment_links($comment, $return = 1) {  global $user;  $links = array();  // If we are viewing just this comment, we link back to the node.  if ($return) {    $links['comment_parent'] = array(      'title' => t('parent'),      'href' => comment_node_url(),      'fragment' => "comment-$comment->cid"    );  }  if (node_comment_mode($comment->nid) == COMMENT_NODE_READ_WRITE) {    if (user_access('administer comments') && user_access('post comments')) {      $links['comment_delete'] = array(        'title' => t('delete'),        'href' => "comment/delete/$comment->cid"      );      $links['comment_edit'] = array(        'title' => t('edit'),        'href' => "comment/edit/$comment->cid"      );      $links['comment_reply'] = array(        'title' => t('reply'),        'href' => "comment/reply/$comment->nid/$comment->cid"      );    }    else if (user_access('post comments')) {      if (comment_access('edit', $comment)) {        $links['comment_edit'] = array(          'title' => t('edit'),          'href' => "comment/edit/$comment->cid"        );      }      $links['comment_reply'] = array(        'title' => t('reply'),        'href' => "comment/reply/$comment->nid/$comment->cid"      );    }    else {      $node = node_load($comment->nid);      $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);    }  }  return $links;}/** * Renders comment(s). * * @param $node *   The node which comment(s) needs rendering. * @param $cid *   Optional, if given, only one comment is rendered. * * To display threaded comments in the correct order we keep a 'thread' field * and order by that value. This field keeps this data in * a way which is easy to update and convenient to use. * * A "thread" value starts at "1". If we add a child (A) to this comment, * we assign it a "thread" = "1.1". A child of (A) will have "1.1.1". Next * brother of (A) will get "1.2". Next brother of the parent of (A) will get * "2" and so on. * * First of all note that the thread field stores the depth of the comment: * depth 0 will be "X", depth 1 "X.X", depth 2 "X.X.X", etc. * * Now to get the ordering right, consider this example: * * 1 * 1.1 * 1.1.1 * 1.2 * 2 * * If we "ORDER BY thread ASC" we get the above result, and this is the * natural order sorted by time. However, if we "ORDER BY thread DESC" * we get: * * 2 * 1.2 * 1.1.1 * 1.1 * 1 * * Clearly, this is not a natural way to see a thread, and users will get * confused. The natural order to show a thread by time desc would be: * * 2 * 1 * 1.2 * 1.1 * 1.1.1 * * which is what we already did before the standard pager patch. To achieve * this we simply add a "/" at the end of each "thread" value. This way out * thread fields will look like depicted below: * * 1/ * 1.1/ * 1.1.1/ * 1.2/ * 2/ * * we add "/" since this char is, in ASCII, higher than every number, so if * now we "ORDER BY thread DESC" we get the correct order. However this would * spoil the reverse ordering, "ORDER BY thread ASC" -- here, we do not need * to consider the trailing "/" so we use a substring only. */function comment_render($node, $cid = 0) {  global $user;  $output = '';  if (user_access('access comments')) {    // Pre-process variables.    $nid = $node->nid;    if (empty($nid)) {      $nid = 0;    }    $mode = _comment_get_display_setting('mode', $node);    $order = _comment_get_display_setting('sort', $node);    $comments_per_page = _comment_get_display_setting('comments_per_page', $node);    if ($cid && is_numeric($cid)) {      // Single comment view.      $query = 'SELECT c.cid, c.pid, c.nid, c.subject, c.comment, c.format, c.timestamp, c.name, c.mail, c.homepage, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data, c.status FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d';      $query_args = array($cid);      if (!user_access('administer comments')) {        $query .= ' AND c.status = %d';        $query_args[] = COMMENT_PUBLISHED;      }      $query = db_rewrite_sql($query, 'c', 'cid');      $result = db_query($query, $query_args);      if ($comment = db_fetch_object($result)) {        $comment->name = $comment->uid ? $comment->registered_name : $comment->name;        $links = module_invoke_all('link', 'comment', $comment, 1);        drupal_alter('link', $links, $node);        $output .= theme('comment_view', $comment, $node, $links);      }    }    else {      // Multiple comment view      $query_count = 'SELECT COUNT(*) FROM {comments} c WHERE c.nid = %d';      $query = 'SELECT c.cid as cid, c.pid, c.nid, c.subject, c.comment, c.format, c.timestamp, c.name, c.mail, c.homepage, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data, c.thread, c.status FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.nid = %d';      $query_args = array($nid);      if (!user_access('administer comments')) {        $query .= ' AND c.status = %d';        $query_count .= ' AND c.status = %d';        $query_args[] = COMMENT_PUBLISHED;      }      if ($order == COMMENT_ORDER_NEWEST_FIRST) {        if ($mode == COMMENT_MODE_FLAT_COLLAPSED || $mode == COMMENT_MODE_FLAT_EXPANDED) {          $query .= ' ORDER BY c.cid DESC';        }        else {          $query .= ' ORDER BY c.thread DESC';        }      }      else if ($order == COMMENT_ORDER_OLDEST_FIRST) {        if ($mode == COMMENT_MODE_FLAT_COLLAPSED || $mode == COMMENT_MODE_FLAT_EXPANDED) {          $query .= ' ORDER BY c.cid';        }        else {          // See comment above. Analysis reveals that this doesn't cost too          // much. It scales much much better than having the whole comment          // structure.          $query .= ' ORDER BY SUBSTRING(c.thread, 1, (LENGTH(c.thread) - 1))';        }      }      $query = db_rewrite_sql($query, 'c', 'cid');      $query_count = db_rewrite_sql($query_count, 'c', 'cid');      // Start a form, for use with comment control.      $result = pager_query($query, $comments_per_page, 0, $query_count, $query_args);      $divs = 0;      $num_rows = FALSE;      $comments = '';      drupal_add_css(drupal_get_path('module', 'comment') .'/comment.css');      while ($comment = db_fetch_object($result)) {        $comment = drupal_unpack($comment);        $comment->name = $comment->uid ? $comment->registered_name : $comment->name;        $comment->depth = count(explode('.', $comment->thread)) - 1;        if ($mode == COMMENT_MODE_THREADED_COLLAPSED || $mode == COMMENT_MODE_THREADED_EXPANDED) {          if ($comment->depth > $divs) {            $divs++;            $comments .= '<div class="indented">';          }          else {            while ($comment->depth < $divs) {              $divs--;              $comments .= '</div>';            }          }        }        if ($mode == COMMENT_MODE_FLAT_COLLAPSED) {          $comments .= theme('comment_flat_collapsed', $comment, $node);        }        else if ($mode == COMMENT_MODE_FLAT_EXPANDED) {          $comments .= theme('comment_flat_expanded', $comment, $node);        }        else if ($mode == COMMENT_MODE_THREADED_COLLAPSED) {          $comments .= theme('comment_thread_collapsed', $comment, $node);        }        else if ($mode == COMMENT_MODE_THREADED_EXPANDED) {          $comments .= theme('comment_thread_expanded', $comment, $node);        }        $num_rows = TRUE;      }      while ($divs-- > 0) {        $comments .= '</div>';      }      $comment_controls = variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN);      if ($num_rows && ($comment_controls == COMMENT_CONTROLS_ABOVE || $comment_controls == COMMENT_CONTROLS_ABOVE_BELOW)) {        $output .= drupal_get_form('comment_controls', $mode, $order, $comments_per_page);      }      $output .= $comments;      $output .= theme('pager', NULL, $comments_per_page, 0);      if ($num_rows && ($comment_controls == COMMENT_CONTROLS_BELOW || $comment_controls == COMMENT_CONTROLS_ABOVE_BELOW)) {        $output .= drupal_get_form('comment_controls', $mode, $order, $comments_per_page);      }    }    // If enabled, show new comment form if it's not already being displayed.    $reply = arg(0) == 'comment' && arg(1) == 'reply';    if (user_access('post comments') && node_comment_mode($nid) == COMMENT_NODE_READ_WRITE && (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_BELOW) && !$reply) {      $output .= comment_form_box(array('nid' => $nid), t('Post new comment'));    }    if ($output) {      $output = theme('comment_wrapper', $output, $node);    }  }  return $output;}/** * Comment operations. We offer different update operations depending on * which comment administration page we're on. * * @param $action *   The comment administration page. * @return *   An associative array containing the offered operations. */function comment_operations($action = NULL) {  if ($action == 'publish') {    $operations = array(      'publish' => array(t('Publish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  else if ($action == 'unpublish') {    $operations = array(      'unpublish' => array(t('Unpublish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  else {    $operations = array(      'publish' => array(t('Publish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d'),      'unpublish' => array(t('Unpublish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  return $operations;}/** * Misc functions: helpers, privates, history *//** * Load the entire comment by cid. * * @param $cid *   The identifying comment id. * @return *   The comment object. */function _comment_load($cid) {  return db_fetch_object(db_query('SELECT * FROM {comments} WHERE cid = %d', $cid));}/** * Get comment count for a node. * * @param $nid *   The node id. * @return *   The comment count. */function comment_num_all($nid) {  static $cache;  if (!isset($cache[$nid])) {    $cache[$nid] = db_result(db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = %d', $nid));  }  return $cache[$nid];}/** * Get replies count for a comment. * * @param $pid *   The comment id. * @return *   The replies count. */function comment_num_replies($pid) {  static $cache;  if (!isset($cache[$pid])) {    $cache[$pid] = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE pid = %d AND status = %d', $pid, COMMENT_PUBLISHED));  }  return $cache[$pid];}/** * Get number of new comments for current user and specified node. * * @param $nid *   node-id to count comments for * @param $timestamp *   time to count from (defaults to time of last user access *   to node) */function comment_num_new($nid, $timestamp = 0) {  global $user;  if ($user->uid) {    // Retrieve the timestamp at which the current user last viewed the    // specified node.    if (!$timestamp) {      $timestamp = node_last_viewed($nid);    }    $timestamp = ($timestamp > NODE_NEW_LIMIT ? $timestamp : NODE_NEW_LIMIT);    // Use the timestamp to retrieve the number of new comments.    $result = db_result(db_query('SELECT COUNT(c.cid) FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid WHERE n.nid = %d AND timestamp > %d AND c.status = %d', $nid, $timestamp, COMMENT_PUBLISHED));    return $result;  }  else {    return 0;  }}/** * Validate comment data. * * @param $edit *   An associative array containig the comment data. * @return *   The original $edit. */function comment_validate($edit) {  global $user;  // Invoke other validation handlers  comment_invoke_comment($edit, 'validate');  if (isset($edit['date'])) {    // As of PHP 5.1.0, strtotime returns FALSE upon failure instead of -1.    if (strtotime($edit['date']) <= 0) {      form_set_error('date', t('You have to specify a valid date.'));    }  }  if (isset($edit['author']) && !$account = user_load(array('name' => $edit['author']))) {    form_set_error('author', t('You have to specify a valid author.'));  }  // Check validity of name, mail and homepage (if given)  if (!$user->uid || isset($edit['is_anonymous'])) {    $node = node_load($edit['nid']);    if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) > COMMENT_ANONYMOUS_MAYNOT_CONTACT) {      if ($edit['name']) {        $taken = db_result(db_query("SELECT COUNT(uid) FROM {users} WHERE LOWER(name) = '%s'", $edit['name']));        if ($taken != 0) {          form_set_error('name', t('The name you used belongs to a registered user.'));        }      }      else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {        form_set_error('name', t('You have to leave your name.'));      }      if ($edit['mail']) {        if (!valid_email_address($edit['mail'])) {          form_set_error('mail', t('The e-mail address you specified is not valid.'));        }      }      else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {        form_set_error('mail', t('You have to leave an e-mail address.'));      }      if ($edit['homepage']) {        if (!valid_url($edit['homepage'], TRUE)) {          form_set_error('homepage', t('The URL of your homepage is not valid. Remember that it must be fully qualified, i.e. of the form <code>http://example.com/directory</code>.'));        }      }    }  }  return $edit;}/** * Generate the basic commenting form, for appending to a node or display on a separate page. * * @param $title *   Not used. * @ingroup forms * @see comment_form_validate() * @see comment_form_submit() */function comment_form(&$form_state, $edit, $title = NULL) {  global $user;  $op = isset($_POST['op']) ? $_POST['op'] : '';  $node = node_load($edit['nid']);  if (!$user->uid && variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) != COMMENT_ANONYMOUS_MAYNOT_CONTACT) {    drupal_add_js(drupal_get_path('module', 'comment') .'/comment.js');  }  $edit += array('name' => '', 'mail' => '', 'homepage' => '');  if ($user->uid) {    if (!empty($edit['cid']) && user_access('administer comments')) {      if (!empty($edit['author'])) {        $author = $edit['author'];      }      elseif (!empty($edit['name'])) {        $author = $edit['name'];      }      else {        $author = $edit['registered_name'];      }      if (!empty($edit['status'])) {        $status = $edit['status'];      }      else {        $status = 0;      }      if (!empty($edit['date'])) {        $date = $edit['date'];      }      else {        $date = format_date($edit['timestamp'], 'custom', 'Y-m-d H:i O');      }      $form['admin'] = array(        '#type' => 'fieldset',        '#title' => t('Administration'),        '#collapsible' => TRUE,        '#collapsed' => TRUE,        '#weight' => -2,      );      if ($edit['registered_name'] != '') {        // The comment is by a registered user        $form['admin']['author'] = array(          '#type' => 'textfield',          '#title' => t('Authored by'),          '#size' => 30,          '#maxlength' => 60,          '#autocomplete_path' => 'user/autocomplete',          '#default_value' => $author,          '#weight' => -1,        );      }      else {        // The comment is by an anonymous user        $form['is_anonymous'] = array(          '#type' => 'value',          '#value' => TRUE,        );        $form['admin']['name'] = array(          '#type' => 'textfield',          '#title' => t('Authored by'),          '#size' => 30,          '#maxlength' => 60,          '#default_value' => $author,          '#weight' => -1,        );        $form['admin']['mail'] = array(          '#type' => 'textfield',          '#title' => t('E-mail'),          '#maxlength' => 64,          '#size' => 30,          '#default_value' => $edit['mail'],          '#description' => t('The content of this field is kept private and will not be shown publicly.'),        );        $form['admin']['homepage'] = array(          '#type' => 'textfield',          '#title' => t('Homepage'),          '#maxlength' => 255,          '#size' => 30,          '#default_value' => $edit['homepage'],        );      }      $form['admin']['date'] = array('#type' => 'textfield', '#parents' => array('date'), '#title' => t('Authored on'), '#size' => 20, '#maxlength' => 25, '#default_value' => $date, '#weight' => -1);      $form['admin']['status'] = array('#type' => 'radios', '#parents' => array('status'), '#title' => t('Status'), '#default_value' =>  $status, '#options' => array(t('Published'), t('Not published')), '#weight' => -1);    }    else {      $form['_author'] = array('#type' => 'item', '#title' => t('Your name'), '#value' => theme('username', $user)      );      $form['author'] = array('#type' => 'value', '#value' => $user->name);    }  }  else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MAY_CONTACT) {    $form['name'] = array('#type' => 'textfield', '#title' => t('Your name'), '#maxlength' => 60, '#size' => 30, '#default_value' => $edit['name'] ? $edit['name'] : variable_get('anonymous', t('Anonymous'))    );    $form['mail'] = array('#type' => 'textfield', '#title' => t('E-mail'), '#maxlength' => 64, '#size' => 30, '#default_value' => $edit['mail'], '#description' => t('The content of this field is kept private and will not be shown publicly.')    );    $form['homepage'] = array('#type' => 'textfield', '#title' => t('Homepage'), '#maxlength' => 255, '#size' => 30, '#default_value' => $edit['homepage']);  }  else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {    $form['name'] = array('#type' => 'textfield', '#title' => t('Your name'), '#maxlength' => 60, '#size' => 30, '#default_value' => $edit['name'] ? $edit['name'] : variable_get('anonymous', t('Anonymous')), '#required' => TRUE);    $form['mail'] = array('#type' => 'textfield', '#title' => t('E-mail'), '#maxlength' => 64, '#size' => 30, '#default_value' => $edit['mail'], '#description' => t('The content of this field is kept private and will not be shown publicly.'), '#required' => TRUE);    $form['homepage'] = array('#type' => 'textfield', '#title' => t('Homepage'), '#maxlength' => 255, '#size' => 30, '#default_value' => $edit['homepage']);  }  if (variable_get('comment_subject_field_'. $node->type, 1) == 1) {    $form['subject'] = array('#type' => 'textfield', '#title' => t('Subject'), '#maxlength' => 64, '#default_value' => !empty($edit['subject']) ? $edit['subject'] : '');  }  if (!empty($edit['comment'])) {    $default = $edit['comment'];  }  else {    $default = '';  }  $form['comment_filter']['comment'] = array(    '#type' => 'textarea',    '#title' => t('Comment'),    '#rows' => 15,    '#default_value' => $default,    '#required' => TRUE,  );  if (!isset($edit['format'])) {    $edit['format'] = FILTER_FORMAT_DEFAULT;  }  $form['comment_filter']['format'] = filter_form($edit['format']);  $form['cid'] = array('#type' => 'value', '#value' => !empty($edit['cid']) ? $edit['cid'] : NULL);  $form['pid'] = array('#type' => 'value', '#value' => !empty($edit['pid']) ? $edit['pid'] : NULL);  $form['nid'] = array('#type' => 'value', '#value' => $edit['nid']);  $form['uid'] = array('#type' => 'value', '#value' => !empty($edit['uid']) ? $edit['uid'] : 0);  // Only show save button if preview is optional or if we are in preview mode.  // We show the save button in preview mode even if there are form errors so that  // optional form elements (e.g., captcha) can be updated in preview mode.  if (!form_get_errors() && ((variable_get('comment_preview_'. $node->type, COMMENT_PREVIEW_REQUIRED) == COMMENT_PREVIEW_OPTIONAL) || ($op == t('Preview')) || ($op == t('Save')))) {    $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 19);  }  $form['preview'] = array('#type' => 'button', '#value' => t('Preview'), '#weight' => 20);  $form['#token'] = 'comment'. $edit['nid'] . (isset($edit['pid']) ? $edit['pid'] : '');  if ($op == t('Preview')) {    $form['#after_build'] = array('comment_form_add_preview');  }  if (empty($edit['cid']) && empty($edit['pid'])) {    $form['#action'] = url('comment/reply/'. $edit['nid']);  }  return $form;}/** * Theme the comment form box. * * @param $edit *   The form structure. * @param $title *   The form title. */function comment_form_box($edit, $title = NULL) {  return theme('box', $title, drupal_get_form('comment_form', $edit, $title));}/** * Form builder; Generate and validate a comment preview form. * * @ingroup forms */function comment_form_add_preview($form, &$form_state) {  global $user;  $edit = $form_state['values'];  drupal_set_title(t('Preview comment'));  $output = '';  $node = node_load($edit['nid']);  // Invoke full validation for the form, to protect against cross site  // request forgeries (CSRF) and setting arbitrary values for fields such as  // the input format. Preview the comment only when form validation does not  // set any errors.  drupal_validate_form($form['form_id']['#value'], $form, $form_state);  if (!form_get_errors()) {    _comment_form_submit($edit);    $comment = (object)$edit;    // Attach the user and time information.    if (!empty($edit['author'])) {      $account = user_load(array('name' => $edit['author']));    }    elseif ($user->uid && !isset($edit['is_anonymous'])) {      $account = $user;    }    if (!empty($account)) {      $comment->uid = $account->uid;      $comment->name = check_plain($account->name);    }    elseif (empty($comment->name)) {      $comment->name = variable_get('anonymous', t('Anonymous'));    }    $comment->timestamp = !empty($edit['timestamp']) ? $edit['timestamp'] : time();    $output .= theme('comment_view', $comment, $node);  }  $form['comment_preview'] = array(    '#value' => $output,    '#weight' => -100,    '#prefix' => '<div class="preview">',    '#suffix' => '</div>',  );  $output = '';  if ($edit['pid']) {    $comment = db_fetch_object(db_query('SELECT c.*, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status = %d', $edit['pid'], COMMENT_PUBLISHED));    $comment = drupal_unpack($comment);    $comment->name = $comment->uid ? $comment->registered_name : $comment->name;    $output .= theme('comment_view', $comment, $node);  }  else {    $suffix = empty($form['#suffix']) ? '' : $form['#suffix'];    $form['#suffix'] = $suffix . node_view($node);    $edit['pid'] = 0;  }  $form['comment_preview_below'] = array('#value' => $output, '#weight' => 100);  return $form;}/** * Validate comment form submissions. */function comment_form_validate($form, &$form_state) {  global $user;  if ($user->uid === 0) {    foreach (array('name', 'homepage', 'mail') as $field) {      // Set cookie for 365 days.      if (isset($form_state['values'][$field])) {        setcookie('comment_info_'. $field, $form_state['values'][$field], time() + 31536000, '/');      }    }  }  comment_validate($form_state['values']);}/** * Prepare a comment for submission. * * @param $comment_values *   An associative array containing the comment data. */function _comment_form_submit(&$comment_values) {  $comment_values += array('subject' => '');  if (!isset($comment_values['date'])) {    $comment_values['date'] = 'now';  }  $comment_values['timestamp'] = strtotime($comment_values['date']);  if (isset($comment_values['author'])) {    $account = user_load(array('name' => $comment_values['author']));    $comment_values['uid'] = $account->uid;    $comment_values['name'] = $comment_values['author'];  }  // Validate the comment's subject. If not specified, extract  // one from the comment's body.  if (trim($comment_values['subject']) == '') {    // The body may be in any format, so we:    // 1) Filter it into HTML    // 2) Strip out all HTML tags    // 3) Convert entities back to plain-text.    // Note: format is checked by check_markup().    $comment_values['subject'] = truncate_utf8(trim(decode_entities(strip_tags(check_markup($comment_values['comment'], $comment_values['format'])))), 29, TRUE);    // Edge cases where the comment body is populated only by HTML tags will    // require a default subject.    if ($comment_values['subject'] == '') {      $comment_values['subject'] = t('(No subject)');    }  }}/** * Process comment form submissions; prepare the comment, store it, and set a redirection target. */function comment_form_submit($form, &$form_state) {  _comment_form_submit($form_state['values']);  if ($cid = comment_save($form_state['values'])) {    $node = node_load($form_state['values']['nid']);    // Add 1 to existing $node->comment count to include new comment being added.    $comment_count = $node->comment_count + 1;    $page = comment_new_page_count($comment_count, 1, $node);    $form_state['redirect'] = array('node/'. $node->nid, $page, "comment-$cid");    return;  }}/** * Themes a single comment and related items. * * @param $comment *   The comment object. * @param $node *   The comment node. * @param $links *   An associative array containing control links suitable for passing into *   theme_links(). These are generated by modules implementing hook_link() with *   $type='comment'. Typical examples are links for editing and deleting *   comments. * @param $visible *   Switches between folded/unfolded view. If TRUE the comments are visible, if *   FALSE the comments are folded. * @ingroup themeable */function theme_comment_view($comment, $node, $links = array(), $visible = TRUE) {  static $first_new = TRUE;  $output = '';  $comment->new = node_mark($comment->nid, $comment->timestamp);  if ($first_new && $comment->new != MARK_READ) {    // Assign the anchor only for the first new comment. This avoids duplicate    // id attributes on a page.    $first_new = FALSE;    $output .= "<a id=\"new\"></a>\n";  }  $output .= "<a id=\"comment-$comment->cid\"></a>\n";  // Switch to folded/unfolded view of the comment  if ($visible) {    $comment->comment = check_markup($comment->comment, $comment->format, FALSE);    // Comment API hook    comment_invoke_comment($comment, 'view');    $output .= theme('comment', $comment, $node, $links);  }  else {    $output .= theme('comment_folded', $comment);  }  return $output;}/** * Build a comment control form. * * @param $mode *   Comment display mode. * @param $order *   Comment order mode. * @param $comments_per_page *   Comments per page. * @ingroup forms */function comment_controls(&$form_state, $mode = COMMENT_MODE_THREADED_EXPANDED, $order = COMMENT_ORDER_NEWEST_FIRST, $comments_per_page = 50) {  $form['mode'] = array('#type' => 'select',    '#default_value' => $mode,    '#options' => _comment_get_modes(),    '#weight' => 1,  );  $form['order'] = array(    '#type' => 'select',    '#default_value' => $order,    '#options' => _comment_get_orders(),    '#weight' => 2,  );  foreach (_comment_per_page() as $i) {    $options[$i] = t('!a comments per page', array('!a' => $i));  }  $form['comments_per_page'] = array('#type' => 'select',    '#default_value' => $comments_per_page,    '#options' => $options,    '#weight' => 3,  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Save settings'),    '#weight' => 20,  );  return $form;}/** * Theme comment controls box where the user can change the default display mode and display order of comments. * * @param $form *   The form structure. * @ingroup themeable */function theme_comment_controls($form) {  $output = '<div class="container-inline">';  $output .=  drupal_render($form);  $output .= '</div>';  $output .= '<div class="description">'. t('Select your preferred way to display the comments and click "Save settings" to activate your changes.') .'</div>';  return theme('box', t('Comment viewing options'), $output);}/** * Process comment_controls form submissions. */function comment_controls_submit($form, &$form_state) {  global $user;  $mode = $form_state['values']['mode'];  $order = $form_state['values']['order'];  $comments_per_page = $form_state['values']['comments_per_page'];  if ($user->uid) {    $account = user_save($user, array('mode' => $mode, 'sort' => $order, 'comments_per_page' => $comments_per_page));    // Terminate if an error occured during user_save().    if (!$account) {      drupal_set_message(t("Error saving user account."), 'error');      return;    }    $user = $account;  }  else {    $_SESSION['comment_mode'] = $mode;    $_SESSION['comment_sort'] = $order;    $_SESSION['comment_comments_per_page'] = $comments_per_page;  }}/** * Process variables for comment.tpl.php. * * @see comment.tpl.php * @see theme_comment() */function template_preprocess_comment(&$variables) {  $comment = $variables['comment'];  $node = $variables['node'];  $variables['author']    = theme('username', $comment);  $variables['content']   = $comment->comment;  $variables['date']      = format_date($comment->timestamp);  $variables['links']     = isset($variables['links']) ? theme('links', $variables['links']) : '';  $variables['new']       = $comment->new ? t('new') : '';  $variables['picture']   = theme_get_setting('toggle_comment_user_picture') ? theme('user_picture', $comment) : '';  $variables['signature'] = $comment->signature;  $variables['submitted'] = theme('comment_submitted', $comment);  $variables['title']     = l($comment->subject, $_GET['q'], array('fragment' => "comment-$comment->cid"));  $variables['template_files'][] = 'comment-'. $node->type;  // set status to a string representation of comment->status.  if (isset($comment->preview)) {    $variables['status']  = 'comment-preview';  }  else {    $variables['status']  = ($comment->status == COMMENT_NOT_PUBLISHED) ? 'comment-unpublished' : 'comment-published';  }}/** * Process variables for comment-folded.tpl.php. * * @see comment-folded.tpl.php * @see theme_comment_folded() */function template_preprocess_comment_folded(&$variables) {  $comment = $variables['comment'];  $variables['author'] = theme('username', $comment);  $variables['date']   = format_date($comment->timestamp);  $variables['new']    = $comment->new ? t('new') : '';  $variables['title']  = l($comment->subject, comment_node_url() .'/'. $comment->cid, array('fragment' => "comment-$comment->cid"));}/** * Theme comment flat collapsed view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_flat_collapsed($comment, $node) {  return theme('comment_view', $comment, $node, '', 0);}/** * Theme comment flat expanded view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_flat_expanded($comment, $node) {  $links = module_invoke_all('link', 'comment', $comment, 0);  drupal_alter('link', $links, $node);  return theme('comment_view', $comment, $node, $links);}/** * Theme comment thread collapsed view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_thread_collapsed($comment, $node) {  return theme('comment_view', $comment, $node, '', 0);}/** * Theme comment thread expanded view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_thread_expanded($comment, $node) {  $links = module_invoke_all('link', 'comment', $comment, 0);  drupal_alter('link', $links, $node);  return theme('comment_view', $comment, $node, $links);}/** * Theme a "you can't post comments" notice. * * @param $node *   The comment node. * @ingroup themeable */function theme_comment_post_forbidden($node) {  global $user;  static $authenticated_post_comments;  if (!$user->uid) {    if (!isset($authenticated_post_comments)) {      // We only output any link if we are certain, that users get permission      // to post comments by logging in. We also locally cache this information.      $authenticated_post_comments = array_key_exists(DRUPAL_AUTHENTICATED_RID, user_roles(TRUE, 'post comments') + user_roles(TRUE, 'post comments without approval'));    }    if ($authenticated_post_comments) {      // We cannot use drupal_get_destination() because these links      // sometimes appear on /node and taxonomy listing pages.      if (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_SEPARATE_PAGE) {        $destination = 'destination='. rawurlencode("comment/reply/$node->nid#comment-form");      }      else {        $destination = 'destination='. rawurlencode("node/$node->nid#comment-form");      }      if (variable_get('user_register', 1)) {        // Users can register themselves.        return t('<a href="@login">Login</a> or <a href="@register">register</a> to post comments', array('@login' => url('user/login', array('query' => $destination)), '@register' => url('user/register', array('query' => $destination))));      }      else {        // Only admins can add new users, no public registration.        return t('<a href="@login">Login</a> to post comments', array('@login' => url('user/login', array('query' => $destination))));      }    }  }}/** * Process variables for comment-wrapper.tpl.php. * * @see comment-wrapper.tpl.php * @see theme_comment_wrapper() */function template_preprocess_comment_wrapper(&$variables) {  // Provide contextual information.  $variables['display_mode']  = _comment_get_display_setting('mode', $variables['node']);  $variables['display_order'] = _comment_get_display_setting('sort', $variables['node']);  $variables['comment_controls_state'] = variable_get('comment_controls_'. $variables['node']->type, COMMENT_CONTROLS_HIDDEN);  $variables['template_files'][] = 'comment-wrapper-'. $variables['node']->type;}/** * Theme a "Submitted by ..." notice. * * @param $comment *   The comment. * @ingroup themeable */function theme_comment_submitted($comment) {  return t('Submitted by !username on @datetime.',    array(      '!username' => theme('username', $comment),      '@datetime' => format_date($comment->timestamp)    ));}/** * Return an array of viewing modes for comment listings. * * We can't use a global variable array because the locale system * is not initialized yet when the comment module is loaded. */function _comment_get_modes() {  return array(    COMMENT_MODE_FLAT_COLLAPSED => t('Flat list - collapsed'),    COMMENT_MODE_FLAT_EXPANDED => t('Flat list - expanded'),    COMMENT_MODE_THREADED_COLLAPSED => t('Threaded list - collapsed'),    COMMENT_MODE_THREADED_EXPANDED => t('Threaded list - expanded')  );}/** * Return an array of viewing orders for comment listings. * * We can't use a global variable array because the locale system * is not initialized yet when the comment module is loaded. */function _comment_get_orders() {  return array(    COMMENT_ORDER_NEWEST_FIRST => t('Date - newest first'),    COMMENT_ORDER_OLDEST_FIRST => t('Date - oldest first')  );}/** * Return an array of "comments per page" settings from which the user * can choose. */function _comment_per_page() {  return drupal_map_assoc(array(10, 30, 50, 70, 90, 150, 200, 250, 300));}/** * Return a current comment display setting * * @param $setting *   can be one of these: 'mode', 'sort', 'comments_per_page' * @param $node *   The comment node in question. */function _comment_get_display_setting($setting, $node) {  global $user;  if (isset($_GET[$setting])) {    $value = $_GET[$setting];  }  else {    // get the setting's site default    switch ($setting) {      case 'mode':        $default = variable_get('comment_default_mode_'. $node->type, COMMENT_MODE_THREADED_EXPANDED);        break;      case 'sort':        $default = variable_get('comment_default_order_'. $node->type, COMMENT_ORDER_NEWEST_FIRST);        break;      case 'comments_per_page':        $default = variable_get('comment_default_per_page_'. $node->type, 50);    }    if (variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN) == COMMENT_CONTROLS_HIDDEN) {      // if comment controls are disabled use site default      $value = $default;    }    else {      // otherwise use the user's setting if set      if (isset($user->$setting) && $user->$setting) {        $value = $user->$setting;      }      else if (isset($_SESSION['comment_'. $setting]) && $_SESSION['comment_'. $setting]) {        $value = $_SESSION['comment_'. $setting];      }      else {        $value = $default;      }    }  }  return $value;}/** * Updates the comment statistics for a given node. This should be called any * time a comment is added, deleted, or updated. * * The following fields are contained in the node_comment_statistics table. * - last_comment_timestamp: the timestamp of the last comment for this node or the node create stamp if no comments exist for the node. * - last_comment_name: the name of the anonymous poster for the last comment * - last_comment_uid: the uid of the poster for the last comment for this node or the node authors uid if no comments exists for the node. * - comment_count: the total number of approved/published comments on this node. */function _comment_update_node_statistics($nid) {  $count = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE nid = %d AND status = %d', $nid, COMMENT_PUBLISHED));  // comments exist  if ($count > 0) {    $last_reply = db_fetch_object(db_query_range('SELECT cid, name, timestamp, uid FROM {comments} WHERE nid = %d AND status = %d ORDER BY cid DESC', $nid, COMMENT_PUBLISHED, 0, 1));    db_query("UPDATE {node_comment_statistics} SET comment_count = %d, last_comment_timestamp = %d, last_comment_name = '%s', last_comment_uid = %d WHERE nid = %d", $count, $last_reply->timestamp, $last_reply->uid ? '' : $last_reply->name, $last_reply->uid, $nid);  }  // no comments  else {    $node = db_fetch_object(db_query("SELECT uid, created FROM {node} WHERE nid = %d", $nid));    db_query("UPDATE {node_comment_statistics} SET comment_count = 0, last_comment_timestamp = %d, last_comment_name = '', last_comment_uid = %d WHERE nid = %d", $node->created, $node->uid, $nid);  }}/** * Invoke a hook_comment() operation in all modules. * * @param &$comment *   A comment object. * @param $op *   A string containing the name of the comment operation. * @return *   The returned value of the invoked hooks. */function comment_invoke_comment(&$comment, $op) {  $return = array();  foreach (module_implements('comment') as $name) {    $function = $name .'_comment';    $result = $function($comment, $op);    if (isset($result) && is_array($result)) {      $return = array_merge($return, $result);    }    else if (isset($result)) {      $return[] = $result;    }  }  return $return;}/** * Generate vancode. * * Consists of a leading character indicating length, followed by N digits * with a numerical value in base 36. Vancodes can be sorted as strings * without messing up numerical order. * * It goes: * 00, 01, 02, ..., 0y, 0z, * 110, 111, ... , 1zy, 1zz, * 2100, 2101, ..., 2zzy, 2zzz, * 31000, 31001, ... */function int2vancode($i = 0) {  $num = base_convert((int)$i, 10, 36);  $length = strlen($num);  return chr($length + ord('0') - 1) . $num;}/** * Decode vancode back to an integer. */function vancode2int($c = '00') {  return base_convert(substr($c, 1), 36, 10);}/** * Implementation of hook_hook_info(). */function comment_hook_info() {  return array(    'comment' => array(      'comment' => array(        'insert' => array(          'runs when' => t('After saving a new comment'),        ),        'update' => array(          'runs when' => t('After saving an updated comment'),        ),        'delete' => array(          'runs when' => t('After deleting a comment')        ),        'view' => array(          'runs when' => t('When a comment is being viewed by an authenticated user')        ),      ),    ),  );}/** * Implementation of hook_action_info(). */function comment_action_info() {  return array(    'comment_unpublish_action' => array(      'description' => t('Unpublish comment'),      'type' => 'comment',      'configurable' => FALSE,      'hooks' => array(        'comment' => array('insert', 'update'),      )    ),    'comment_unpublish_by_keyword_action' => array(      'description' => t('Unpublish comment containing keyword(s)'),      'type' => 'comment',      'configurable' => TRUE,      'hooks' => array(        'comment' => array('insert', 'update'),      )    )  );}/** * Drupal action to unpublish a comment. * * @param $context *   Keyed array. Must contain the id of the comment if $comment is not passed. * @param $comment *   An optional comment object. */function comment_unpublish_action($comment, $context = array()) {  if (isset($comment->cid)) {    $cid = $comment->cid;    $subject = $comment->subject;  }  else {    $cid = $context['cid'];    $subject = db_result(db_query("SELECT subject FROM {comments} WHERE cid = %d", $cid));  }  db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_NOT_PUBLISHED, $cid);  watchdog('action', 'Unpublished comment %subject.', array('%subject' => $subject));}/** * Form builder; Prepare a form for blacklisted keywords. * * @ingroup forms */function comment_unpublish_by_keyword_action_form($context) {  $form['keywords'] = array(    '#title' => t('Keywords'),    '#type' => 'textarea',    '#description' => t('The comment will be unpublished if it contains any of the character sequences above. Use a comma-separated list of character sequences. Example: funny, bungee jumping, "Company, Inc.". Character sequences are case-sensitive.'),    '#default_value' => isset($context['keywords']) ? drupal_implode_tags($context['keywords']) : '',  );  return $form;}/** * Process comment_unpublish_by_keyword_action_form form submissions. */function comment_unpublish_by_keyword_action_submit($form, $form_state) {  return array('keywords' => drupal_explode_tags($form_state['values']['keywords']));}/** * Implementation of a configurable Drupal action. * Unpublish a comment if it contains a certain string. * * @param $context *   An array providing more information about the context of the call to this action. *   Unused here since this action currently only supports the insert and update ops of *   the comment hook, both of which provide a complete $comment object. * @param $comment *   A comment object. */function comment_unpublish_by_keyword_action($comment, $context) {  foreach ($context['keywords'] as $keyword) {    if (strstr($comment->comment, $keyword) || strstr($comment->subject, $keyword)) {      db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_NOT_PUBLISHED, $comment->cid);      watchdog('action', 'Unpublished comment %subject.', array('%subject' => $comment->subject));      break;    }  }}
<?php// $Id$/** * Implementation of hook_install(). */function aggregator_install() {  // Create tables.  drupal_install_schema('aggregator');}/** * Implementation of hook_uninstall(). */function aggregator_uninstall() {  // Remove tables.  drupal_uninstall_schema('aggregator');  variable_del('aggregator_allowed_html_tags');  variable_del('aggregator_summary_items');  variable_del('aggregator_clear');  variable_del('aggregator_category_selector');}/** * Implementation of hook_schema(). */function aggregator_schema() {  $schema['aggregator_category'] = array(    'description' => 'Stores categories for aggregator feeds and feed items.',    'fields' => array(      'cid'  => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique aggregator category ID.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Title of the category.',      ),      'description' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Description of the category',      ),      'block' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The number of recent items to show within the category block.',      )    ),    'primary key' => array('cid'),    'unique keys' => array('title' => array('title')),  );  $schema['aggregator_category_feed'] = array(    'description' => 'Bridge table; maps feeds to categories.',    'fields' => array(      'fid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => "The feed's {aggregator_feed}.fid.",      ),      'cid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {aggregator_category}.cid to which the feed is being assigned.',      )    ),    'primary key' => array('cid', 'fid'),    'indexes' => array('fid' => array('fid')),  );  $schema['aggregator_category_item'] = array(    'description' => 'Bridge table; maps feed items to categories.',    'fields' => array(      'iid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => "The feed item's {aggregator_item}.iid.",      ),      'cid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {aggregator_category}.cid to which the feed item is being assigned.',      )    ),    'primary key' => array('cid', 'iid'),    'indexes' => array('iid' => array('iid')),  );  $schema['aggregator_feed'] = array(    'description' => 'Stores feeds to be parsed by the aggregator.',    'fields' => array(      'fid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique feed ID.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Title of the feed.',      ),      'url' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'URL to the feed.',      ),      'refresh' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'How often to check for new feed items, in seconds.',      ),      'checked' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Last time feed was checked for new items, as Unix timestamp.',      ),      'link' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'The parent website of the feed; comes from the &lt;link&gt; element in the feed.',      ),      'description' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => "The parent website's description; comes from the &lt;description&gt; element in the feed.",      ),      'image' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'An image representing the feed.',      ),      'etag' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Entity tag HTTP response header, used for validating cache.',      ),      'modified' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'When the feed was last modified, as a Unix timestamp.',      ),      'block' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => "Number of items to display in the feed's block.",      )    ),    'primary key' => array('fid'),    'unique keys' => array(      'url'  => array('url'),      'title' => array('title'),    ),  );  $schema['aggregator_item'] = array(    'description' => 'Stores the individual items imported from feeds.',    'fields' => array(      'iid'  => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique ID for feed item.',      ),      'fid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {aggregator_feed}.fid to which this item belongs.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Title of the feed item.',      ),      'link' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Link to the feed item.',      ),      'author' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Author of the feed item.',      ),      'description' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Body of the feed item.',      ),      'timestamp' => array(        'type' => 'int',        'not null' => FALSE,        'description' => 'Post date of feed item, as a Unix timestamp.',      ),      'guid' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => 'Unique identifier for the feed item.',      )    ),    'primary key' => array('iid'),    'indexes' => array('fid' => array('fid')),  );  return $schema;}
<?php// $Id$/** * @file * API for the Drupal menu system. *//** * @defgroup menu Menu system * @{ * Define the navigation menus, and route page requests to code based on URLs. * * The Drupal menu system drives both the navigation system from a user * perspective and the callback system that Drupal uses to respond to URLs * passed from the browser. For this reason, a good understanding of the * menu system is fundamental to the creation of complex modules. * * Drupal's menu system follows a simple hierarchy defined by paths. * Implementations of hook_menu() define menu items and assign them to * paths (which should be unique). The menu system aggregates these items * and determines the menu hierarchy from the paths. For example, if the * paths defined were a, a/b, e, a/b/c/d, f/g, and a/b/h, the menu system * would form the structure: * - a *   - a/b *     - a/b/c/d *     - a/b/h * - e * - f/g * Note that the number of elements in the path does not necessarily * determine the depth of the menu item in the tree. * * When responding to a page request, the menu system looks to see if the * path requested by the browser is registered as a menu item with a * callback. If not, the system searches up the menu tree for the most * complete match with a callback it can find. If the path a/b/i is * requested in the tree above, the callback for a/b would be used. * * The found callback function is called with any arguments specified * in the "page arguments" attribute of its menu item. The * attribute must be an array. After these arguments, any remaining * components of the path are appended as further arguments. In this * way, the callback for a/b above could respond to a request for * a/b/i differently than a request for a/b/j. * * For an illustration of this process, see page_example.module. * * Access to the callback functions is also protected by the menu system. * The "access callback" with an optional "access arguments" of each menu * item is called before the page callback proceeds. If this returns TRUE, * then access is granted; if FALSE, then access is denied. Menu items may * omit this attribute to use the value provided by an ancestor item. * * In the default Drupal interface, you will notice many links rendered as * tabs. These are known in the menu system as "local tasks", and they are * rendered as tabs by default, though other presentations are possible. * Local tasks function just as other menu items in most respects. It is * convention that the names of these tasks should be short verbs if * possible. In addition, a "default" local task should be provided for * each set. When visiting a local task's parent menu item, the default * local task will be rendered as if it is selected; this provides for a * normal tab user experience. This default task is special in that it * links not to its provided path, but to its parent item's path instead. * The default task's path is only used to place it appropriately in the * menu hierarchy. * * Everything described so far is stored in the menu_router table. The * menu_links table holds the visible menu links. By default these are * derived from the same hook_menu definitions, however you are free to * add more with menu_link_save(). *//** * @name Menu flags * @{ * Flags for use in the "type" attribute of menu items. */define('MENU_IS_ROOT', 0x0001);define('MENU_VISIBLE_IN_TREE', 0x0002);define('MENU_VISIBLE_IN_BREADCRUMB', 0x0004);define('MENU_LINKS_TO_PARENT', 0x0008);define('MENU_MODIFIED_BY_ADMIN', 0x0020);define('MENU_CREATED_BY_ADMIN', 0x0040);define('MENU_IS_LOCAL_TASK', 0x0080);/** * @} End of "Menu flags". *//** * @name Menu item types * @{ * Menu item definitions provide one of these constants, which are shortcuts for * combinations of the above flags. *//** * Normal menu items show up in the menu tree and can be moved/hidden by * the administrator. Use this for most menu items. It is the default value if * no menu item type is specified. */define('MENU_NORMAL_ITEM', MENU_VISIBLE_IN_TREE | MENU_VISIBLE_IN_BREADCRUMB);/** * Callbacks simply register a path so that the correct function is fired * when the URL is accessed. They are not shown in the menu. */define('MENU_CALLBACK', MENU_VISIBLE_IN_BREADCRUMB);/** * Modules may "suggest" menu items that the administrator may enable. They act * just as callbacks do until enabled, at which time they act like normal items. * Note for the value: 0x0010 was a flag which is no longer used, but this way * the values of MENU_CALLBACK and MENU_SUGGESTED_ITEM are separate. */define('MENU_SUGGESTED_ITEM', MENU_VISIBLE_IN_BREADCRUMB | 0x0010);/** * Local tasks are rendered as tabs by default. Use this for menu items that * describe actions to be performed on their parent item. An example is the path * "node/52/edit", which performs the "edit" task on "node/52". */define('MENU_LOCAL_TASK', MENU_IS_LOCAL_TASK);/** * Every set of local tasks should provide one "default" task, that links to the * same path as its parent when clicked. */define('MENU_DEFAULT_LOCAL_TASK', MENU_IS_LOCAL_TASK | MENU_LINKS_TO_PARENT);/** * @} End of "Menu item types". *//** * @name Menu status codes * @{ * Status codes for menu callbacks. */define('MENU_FOUND', 1);define('MENU_NOT_FOUND', 2);define('MENU_ACCESS_DENIED', 3);define('MENU_SITE_OFFLINE', 4);/** * @} End of "Menu status codes". *//** * @Name Menu tree parameters * @{ * Menu tree */ /** * The maximum number of path elements for a menu callback */define('MENU_MAX_PARTS', 7);/** * The maximum depth of a menu links tree - matches the number of p columns. */define('MENU_MAX_DEPTH', 9);/** * @} End of "Menu tree parameters". *//** * Returns the ancestors (and relevant placeholders) for any given path. * * For example, the ancestors of node/12345/edit are: * - node/12345/edit * - node/12345/% * - node/%/edit * - node/%/% * - node/12345 * - node/% * - node * * To generate these, we will use binary numbers. Each bit represents a * part of the path. If the bit is 1, then it represents the original * value while 0 means wildcard. If the path is node/12/edit/foo * then the 1011 bitstring represents node/%/edit/foo where % means that * any argument matches that part.  We limit ourselves to using binary * numbers that correspond the patterns of wildcards of router items that * actually exists.  This list of 'masks' is built in menu_rebuild(). * * @param $parts *   An array of path parts, for the above example *   array('node', '12345', 'edit'). * @return *   An array which contains the ancestors and placeholders. Placeholders *   simply contain as many '%s' as the ancestors. */function menu_get_ancestors($parts) {  $number_parts = count($parts);  $placeholders = array();  $ancestors = array();  $length =  $number_parts - 1;  $end = (1 << $number_parts) - 1;  $masks = variable_get('menu_masks', array());  // Only examine patterns that actually exist as router items (the masks).  foreach ($masks as $i) {    if ($i > $end) {      // Only look at masks that are not longer than the path of interest.      continue;    }    elseif ($i < (1 << $length)) {      // We have exhausted the masks of a given length, so decrease the length.      --$length;    }    $current = '';    for ($j = $length; $j >= 0; $j--) {      if ($i & (1 << $j)) {        $current .= $parts[$length - $j];      }      else {        $current .= '%';      }      if ($j) {        $current .= '/';      }    }    $placeholders[] = "'%s'";    $ancestors[] = $current;  }  return array($ancestors, $placeholders);}/** * The menu system uses serialized arrays stored in the database for * arguments. However, often these need to change according to the * current path. This function unserializes such an array and does the * necessary change. * * Integer values are mapped according to the $map parameter. For * example, if unserialize($data) is array('view', 1) and $map is * array('node', '12345') then 'view' will not be changed because * it is not an integer, but 1 will as it is an integer. As $map[1] * is '12345', 1 will be replaced with '12345'. So the result will * be array('node_load', '12345'). * * @param @data *   A serialized array. * @param @map *   An array of potential replacements. * @return *   The $data array unserialized and mapped. */function menu_unserialize($data, $map) {  if ($data = unserialize($data)) {    foreach ($data as $k => $v) {      if (is_int($v)) {        $data[$k] = isset($map[$v]) ? $map[$v] : '';      }    }    return $data;  }  else {    return array();  }}/** * Replaces the statically cached item for a given path. * * @param $path *   The path. * @param $router_item *   The router item. Usually you take a router entry from menu_get_item and *   set it back either modified or to a different path. This lets you modify the *   navigation block, the page title, the breadcrumb and the page help in one *   call. */function menu_set_item($path, $router_item) {  menu_get_item($path, $router_item);}/** * Get a router item. * * @param $path *   The path, for example node/5. The function will find the corresponding *   node/% item and return that. * @param $router_item *   Internal use only. * @return *   The router item, an associate array corresponding to one row in the *   menu_router table. The value of key map holds the loaded objects. The *   value of key access is TRUE if the current user can access this page. *   The values for key title, page_arguments, access_arguments will be *   filled in based on the database values and the objects loaded. */function menu_get_item($path = NULL, $router_item = NULL) {  static $router_items;  if (!isset($path)) {    $path = $_GET['q'];  }  if (isset($router_item)) {    $router_items[$path] = $router_item;  }  if (!isset($router_items[$path])) {    $original_map = arg(NULL, $path);    $parts = array_slice($original_map, 0, MENU_MAX_PARTS);    list($ancestors, $placeholders) = menu_get_ancestors($parts);    if ($router_item = db_fetch_array(db_query_range('SELECT * FROM {menu_router} WHERE path IN ('. implode (',', $placeholders) .') ORDER BY fit DESC', $ancestors, 0, 1))) {      $map = _menu_translate($router_item, $original_map);      if ($map === FALSE) {        $router_items[$path] = FALSE;        return FALSE;      }      if ($router_item['access']) {        $router_item['map'] = $map;        $router_item['page_arguments'] = array_merge(menu_unserialize($router_item['page_arguments'], $map), array_slice($map, $router_item['number_parts']));      }    }    $router_items[$path] = $router_item;  }  return $router_items[$path];}/** * Execute the page callback associated with the current path */function menu_execute_active_handler($path = NULL) {  if (_menu_site_is_offline()) {    return MENU_SITE_OFFLINE;  }  // Rebuild if we know it's needed, or if the menu masks are missing which  // occurs rarely, likely due to a race condition of multiple rebuilds.  if (variable_get('menu_rebuild_needed', FALSE) || !variable_get('menu_masks', array())) {    menu_rebuild();  }  if ($router_item = menu_get_item($path)) {    if ($router_item['access']) {      if ($router_item['file']) {        require_once($router_item['file']);      }      return call_user_func_array($router_item['page_callback'], $router_item['page_arguments']);    }    else {      return MENU_ACCESS_DENIED;    }  }  return MENU_NOT_FOUND;}/** * Loads objects into the map as defined in the $item['load_functions']. * * @param $item *   A menu router or menu link item * @param $map *   An array of path arguments (ex: array('node', '5')) * @return *   Returns TRUE for success, FALSE if an object cannot be loaded. *   Names of object loading functions are placed in $item['load_functions']. *   Loaded objects are placed in $map[]; keys are the same as keys in the *   $item['load_functions'] array. *   $item['access'] is set to FALSE if an object cannot be loaded. */function _menu_load_objects(&$item, &$map) {  if ($load_functions = $item['load_functions']) {    // If someone calls this function twice, then unserialize will fail.    if ($load_functions_unserialized = unserialize($load_functions)) {      $load_functions = $load_functions_unserialized;    }    $path_map = $map;    foreach ($load_functions as $index => $function) {      if ($function) {        $value = isset($path_map[$index]) ? $path_map[$index] : '';        if (is_array($function)) {          // Set up arguments for the load function. These were pulled from          // 'load arguments' in the hook_menu() entry, but they need          // some processing. In this case the $function is the key to the          // load_function array, and the value is the list of arguments.          list($function, $args) = each($function);          $load_functions[$index] = $function;          // Some arguments are placeholders for dynamic items to process.          foreach ($args as $i => $arg) {            if ($arg === '%index') {              // Pass on argument index to the load function, so multiple              // occurances of the same placeholder can be identified.              $args[$i] = $index;            }            if ($arg === '%map') {              // Pass on menu map by reference. The accepting function must              // also declare this as a reference if it wants to modify              // the map.              $args[$i] = &$map;            }            if (is_int($arg)) {              $args[$i] = isset($path_map[$arg]) ? $path_map[$arg] : '';            }          }          array_unshift($args, $value);          $return = call_user_func_array($function, $args);        }        else {          $return = $function($value);        }        // If callback returned an error or there is no callback, trigger 404.        if ($return === FALSE) {          $item['access'] = FALSE;          $map = FALSE;          return FALSE;        }        $map[$index] = $return;      }    }    $item['load_functions'] = $load_functions;  }  return TRUE;}/** * Check access to a menu item using the access callback * * @param $item *   A menu router or menu link item * @param $map *   An array of path arguments (ex: array('node', '5')) * @return *   $item['access'] becomes TRUE if the item is accessible, FALSE otherwise. */function _menu_check_access(&$item, $map) {  // Determine access callback, which will decide whether or not the current  // user has access to this path.  $callback = empty($item['access_callback']) ? 0 : trim($item['access_callback']);  // Check for a TRUE or FALSE value.  if (is_numeric($callback)) {    $item['access'] = (bool)$callback;  }  else {    $arguments = menu_unserialize($item['access_arguments'], $map);    // As call_user_func_array is quite slow and user_access is a very common    // callback, it is worth making a special case for it.    if ($callback == 'user_access') {      $item['access'] = (count($arguments) == 1) ? user_access($arguments[0]) : user_access($arguments[0], $arguments[1]);    }    else {      $item['access'] = call_user_func_array($callback, $arguments);    }  }}/** * Localize the router item title using t() or another callback. * * Translate the title and description to allow storage of English title * strings in the database, yet display of them in the language required * by the current user. * * @param $item *   A menu router item or a menu link item. * @param $map *   The path as an array with objects already replaced. E.g., for path *   node/123 $map would be array('node', $node) where $node is the node *   object for node 123. * @param $link_translate *   TRUE if we are translating a menu link item; FALSE if we are *   translating a menu router item. * @return *   No return value. *   $item['title'] is localized according to $item['title_callback']. *   If an item's callback is check_plain(), $item['options']['html'] becomes *   TRUE. *   $item['description'] is translated using t(). *   When doing link translation and the $item['options']['attributes']['title'] *   (link title attribute) matches the description, it is translated as well. */function _menu_item_localize(&$item, $map, $link_translate = FALSE) {  $callback = $item['title_callback'];  $item['localized_options'] = $item['options'];  // If we are translating the title of a menu link, and its title is the same  // as the corresponding router item, then we can use the title information  // from the router. If it's customized, then we need to use the link title  // itself; can't localize.  // If we are translating a router item (tabs, page, breadcrumb), then we  // can always use the information from the router item.  if (!$link_translate || ($item['title'] == $item['link_title'])) {    // t() is a special case. Since it is used very close to all the time,    // we handle it directly instead of using indirect, slower methods.    if ($callback == 't') {      if (empty($item['title_arguments'])) {        $item['title'] = t($item['title']);      }      else {        $item['title'] = t($item['title'], menu_unserialize($item['title_arguments'], $map));      }    }    elseif ($callback) {      if (empty($item['title_arguments'])) {        $item['title'] = $callback($item['title']);      }      else {        $item['title'] = call_user_func_array($callback, menu_unserialize($item['title_arguments'], $map));      }      // Avoid calling check_plain again on l() function.      if ($callback == 'check_plain') {        $item['localized_options']['html'] = TRUE;      }    }  }  elseif ($link_translate) {    $item['title'] = $item['link_title'];  }  // Translate description, see the motivation above.  if (!empty($item['description'])) {    $original_description = $item['description'];    $item['description'] = t($item['description']);    if ($link_translate && isset($item['options']['attributes']['title']) && $item['options']['attributes']['title'] == $original_description) {      $item['localized_options']['attributes']['title'] = $item['description'];    }  }}/** * Handles dynamic path translation and menu access control. * * When a user arrives on a page such as node/5, this function determines * what "5" corresponds to, by inspecting the page's menu path definition, * node/%node. This will call node_load(5) to load the corresponding node * object. * * It also works in reverse, to allow the display of tabs and menu items which * contain these dynamic arguments, translating node/%node to node/5. * * Translation of menu item titles and descriptions are done here to * allow for storage of English strings in the database, and translation * to the language required to generate the current page * * @param $router_item *   A menu router item * @param $map *   An array of path arguments (ex: array('node', '5')) * @param $to_arg *   Execute $item['to_arg_functions'] or not. Use only if you want to render a *   path from the menu table, for example tabs. * @return *   Returns the map with objects loaded as defined in the *   $item['load_functions. $item['access'] becomes TRUE if the item is *   accessible, FALSE otherwise. $item['href'] is set according to the map. *   If an error occurs during calling the load_functions (like trying to load *   a non existing node) then this function return FALSE. */function _menu_translate(&$router_item, $map, $to_arg = FALSE) {  if ($to_arg) {    // Fill in missing path elements, such as the current uid.    _menu_link_map_translate($map, $router_item['to_arg_functions']);  }  // The $path_map saves the pieces of the path as strings, while elements in  // $map may be replaced with loaded objects.  $path_map = $map;  if (!_menu_load_objects($router_item, $map)) {    // An error occurred loading an object.    $router_item['access'] = FALSE;    return FALSE;  }  // Generate the link path for the page request or local tasks.  $link_map = explode('/', $router_item['path']);  for ($i = 0; $i < $router_item['number_parts']; $i++) {    if ($link_map[$i] == '%') {      $link_map[$i] = $path_map[$i];    }  }  $router_item['href'] = implode('/', $link_map);  $router_item['options'] = array();  _menu_check_access($router_item, $map);    // For performance, don't localize an item the user can't access.  if ($router_item['access']) {    _menu_item_localize($router_item, $map);  }  return $map;}/** * This function translates the path elements in the map using any to_arg * helper function. These functions take an argument and return an object. * See http://drupal.org/node/109153 for more information. * * @param map *   An array of path arguments (ex: array('node', '5')) * @param $to_arg_functions *   An array of helper function (ex: array(2 => 'menu_tail_to_arg')) */function _menu_link_map_translate(&$map, $to_arg_functions) {  if ($to_arg_functions) {    $to_arg_functions = unserialize($to_arg_functions);    foreach ($to_arg_functions as $index => $function) {      // Translate place-holders into real values.      $arg = $function(!empty($map[$index]) ? $map[$index] : '', $map, $index);      if (!empty($map[$index]) || isset($arg)) {        $map[$index] = $arg;      }      else {        unset($map[$index]);      }    }  }}function menu_tail_to_arg($arg, $map, $index) {  return implode('/', array_slice($map, $index));}/** * This function is similar to _menu_translate() but does link-specific * preparation such as always calling to_arg functions. * * @param $item *   A menu link * @return *   Returns the map of path arguments with objects loaded as defined in the *   $item['load_functions']: *   - $item['access'] becomes TRUE if the item is accessible, FALSE otherwise. *   - $item['href'] is generated from link_path, possibly by to_arg functions. *   - $item['title'] is generated from link_title, and may be localized. *   - $item['options'] is unserialized; it is also changed within the call *     here to $item['localized_options'] by _menu_item_localize(). */function _menu_link_translate(&$item) {  $item['options'] = unserialize($item['options']);  if ($item['external']) {    $item['access'] = 1;    $map = array();    $item['href'] = $item['link_path'];    $item['title'] = $item['link_title'];    $item['localized_options'] = $item['options'];  }  else {    $map = explode('/', $item['link_path']);    _menu_link_map_translate($map, $item['to_arg_functions']);    $item['href'] = implode('/', $map);    // Note - skip callbacks without real values for their arguments.    if (strpos($item['href'], '%') !== FALSE) {      $item['access'] = FALSE;      return FALSE;    }    // menu_tree_check_access() may set this ahead of time for links to nodes.    if (!isset($item['access'])) {      if (!_menu_load_objects($item, $map)) {        // An error occurred loading an object.        $item['access'] = FALSE;        return FALSE;      }      _menu_check_access($item, $map);    }    // For performance, don't localize a link the user can't access.    if ($item['access']) {      _menu_item_localize($item, $map, TRUE);    }  }  // Allow other customizations - e.g. adding a page-specific query string to the  // options array. For performance reasons we only invoke this hook if the link  // has the 'alter' flag set in the options array.  if (!empty($item['options']['alter'])) {    drupal_alter('translated_menu_link', $item, $map);  }  return $map;}/** * Get a loaded object from a router item. * * menu_get_object() will provide you the current node on paths like node/5, * node/5/revisions/48 etc. menu_get_object('user') will give you the user * account on user/5 etc. Note - this function should never be called within a * _to_arg function (like user_current_to_arg()) since this may result in an * infinite recursion. * * @param $type *   Type of the object. These appear in hook_menu definitons as %type. Core *   provides aggregator_feed, aggregator_category, contact, filter_format, *   forum_term, menu, menu_link, node, taxonomy_vocabulary, user. See the *   relevant {$type}_load function for more on each. Defaults to node. * @param $position *   The expected position for $type object. For node/%node this is 1, for *   comment/reply/%node this is 2. Defaults to 1. * @param $path *   See menu_get_item() for more on this. Defaults to the current path. */function menu_get_object($type = 'node', $position = 1, $path = NULL) {  $router_item = menu_get_item($path);  if (isset($router_item['load_functions'][$position]) && !empty($router_item['map'][$position]) && $router_item['load_functions'][$position] == $type .'_load') {    return $router_item['map'][$position];  }}/** * Render a menu tree based on the current path. * * The tree is expanded based on the current path and dynamic paths are also * changed according to the defined to_arg functions (for example the 'My account' * link is changed from user/% to a link with the current user's uid). * * @param $menu_name *   The name of the menu. * @return *   The rendered HTML of that menu on the current page. */function menu_tree($menu_name = 'navigation') {  static $menu_output = array();  if (!isset($menu_output[$menu_name])) {    $tree = menu_tree_page_data($menu_name);    $menu_output[$menu_name] = menu_tree_output($tree);  }  return $menu_output[$menu_name];}/** * Returns a rendered menu tree. * * @param $tree *   A data structure representing the tree as returned from menu_tree_data. * @return *   The rendered HTML of that data structure. */function menu_tree_output($tree) {  $output = '';  $items = array();  // Pull out just the menu items we are going to render so that we  // get an accurate count for the first/last classes.  foreach ($tree as $data) {    if (!$data['link']['hidden']) {      $items[] = $data;    }  }  $num_items = count($items);  foreach ($items as $i => $data) {    $extra_class = array();    if ($i == 0) {      $extra_class[] = 'first';    }    if ($i == $num_items - 1) {      $extra_class[] = 'last';    }    $extra_class = implode(' ', $extra_class);    $link = theme('menu_item_link', $data['link']);    if ($data['below']) {      $output .= theme('menu_item', $link, $data['link']['has_children'], menu_tree_output($data['below']), $data['link']['in_active_trail'], $extra_class);    }    else {      $output .= theme('menu_item', $link, $data['link']['has_children'], '', $data['link']['in_active_trail'], $extra_class);    }  }  return $output ? theme('menu_tree', $output) : '';}/** * Get the data structure representing a named menu tree. * * Since this can be the full tree including hidden items, the data returned * may be used for generating an an admin interface or a select. * * @param $menu_name *   The named menu links to return * @param $item *   A fully loaded menu link, or NULL.  If a link is supplied, only the *   path to root will be included in the returned tree- as if this link *   represented the current page in a visible menu. * @return *   An tree of menu links in an array, in the order they should be rendered. */function menu_tree_all_data($menu_name = 'navigation', $item = NULL) {  static $tree = array();  // Use $mlid as a flag for whether the data being loaded is for the whole tree.  $mlid = isset($item['mlid']) ? $item['mlid'] : 0;  // Generate a cache ID (cid) specific for this $menu_name and $item.  $cid = 'links:'. $menu_name .':all-cid:'. $mlid;  if (!isset($tree[$cid])) {    // If the static variable doesn't have the data, check {cache_menu}.    $cache = cache_get($cid, 'cache_menu');    if ($cache && isset($cache->data)) {      // If the cache entry exists, it will just be the cid for the actual data.      // This avoids duplication of large amounts of data.      $cache = cache_get($cache->data, 'cache_menu');      if ($cache && isset($cache->data)) {        $data = $cache->data;      }    }    // If the tree data was not in the cache, $data will be NULL.    if (!isset($data)) {      // Build and run the query, and build the tree.      if ($mlid) {        // The tree is for a single item, so we need to match the values in its        // p columns and 0 (the top level) with the plid values of other links.        $args = array(0);        for ($i = 1; $i < MENU_MAX_DEPTH; $i++) {          $args[] = $item["p$i"];        }        $args = array_unique($args);        $placeholders = implode(', ', array_fill(0, count($args), '%d'));        $where = ' AND ml.plid IN ('. $placeholders .')';        $parents = $args;        $parents[] = $item['mlid'];      }      else {        // Get all links in this menu.        $where = '';        $args = array();        $parents = array();      }      array_unshift($args, $menu_name);      // Select the links from the table, and recursively build the tree.  We      // LEFT JOIN since there is no match in {menu_router} for an external      // link.      $data['tree'] = menu_tree_data(db_query("        SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*        FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path        WHERE ml.menu_name = '%s'". $where ."        ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", $args), $parents);      $data['node_links'] = array();      menu_tree_collect_node_links($data['tree'], $data['node_links']);      // Cache the data, if it is not already in the cache.      $tree_cid = _menu_tree_cid($menu_name, $data);      if (!cache_get($tree_cid, 'cache_menu')) {        cache_set($tree_cid, $data, 'cache_menu');      }      // Cache the cid of the (shared) data using the menu and item-specific cid.      cache_set($cid, $tree_cid, 'cache_menu');    }    // Check access for the current user to each item in the tree.    menu_tree_check_access($data['tree'], $data['node_links']);    $tree[$cid] = $data['tree'];  }  return $tree[$cid];}/** * Get the data structure representing a named menu tree, based on the current page. * * The tree order is maintained by storing each parent in an individual * field, see http://drupal.org/node/141866 for more. * * @param $menu_name *   The named menu links to return * @return *   An array of menu links, in the order they should be rendered. The array *   is a list of associative arrays -- these have two keys, link and below. *   link is a menu item, ready for theming as a link. Below represents the *   submenu below the link if there is one, and it is a subtree that has the *   same structure described for the top-level array. */function menu_tree_page_data($menu_name = 'navigation') {  static $tree = array();  // Load the menu item corresponding to the current page.  if ($item = menu_get_item()) {    // Generate a cache ID (cid) specific for this page.    $cid = 'links:'. $menu_name .':page-cid:'. $item['href'] .':'. (int)$item['access'];    if (!isset($tree[$cid])) {      // If the static variable doesn't have the data, check {cache_menu}.      $cache = cache_get($cid, 'cache_menu');      if ($cache && isset($cache->data)) {        // If the cache entry exists, it will just be the cid for the actual data.        // This avoids duplication of large amounts of data.        $cache = cache_get($cache->data, 'cache_menu');        if ($cache && isset($cache->data)) {          $data = $cache->data;        }      }      // If the tree data was not in the cache, $data will be NULL.      if (!isset($data)) {        // Build and run the query, and build the tree.        if ($item['access']) {          // Check whether a menu link exists that corresponds to the current path.          $args = array($menu_name, $item['href']);          $placeholders = "'%s'";          if (drupal_is_front_page()) {            $args[] = '<front>';            $placeholders .= ", '%s'";          }          $parents = db_fetch_array(db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links} WHERE menu_name = '%s' AND link_path IN (". $placeholders .")", $args));          if (empty($parents)) {            // If no link exists, we may be on a local task that's not in the links.            // TODO: Handle the case like a local task on a specific node in the menu.            $parents = db_fetch_array(db_query("SELECT p1, p2, p3, p4, p5, p6, p7, p8 FROM {menu_links} WHERE menu_name = '%s' AND link_path = '%s'", $menu_name, $item['tab_root']));          }          // We always want all the top-level links with plid == 0.          $parents[] = '0';          // Use array_values() so that the indices are numeric for array_merge().          $args = $parents = array_unique(array_values($parents));          $placeholders = implode(', ', array_fill(0, count($args), '%d'));          $expanded = variable_get('menu_expanded', array());          // Check whether the current menu has any links set to be expanded.          if (in_array($menu_name, $expanded)) {            // Collect all the links set to be expanded, and then add all of            // their children to the list as well.            do {              $result = db_query("SELECT mlid FROM {menu_links} WHERE menu_name = '%s' AND expanded = 1 AND has_children = 1 AND plid IN (". $placeholders .') AND mlid NOT IN ('. $placeholders .')', array_merge(array($menu_name), $args, $args));              $num_rows = FALSE;              while ($item = db_fetch_array($result)) {                $args[] = $item['mlid'];                $num_rows = TRUE;              }              $placeholders = implode(', ', array_fill(0, count($args), '%d'));            } while ($num_rows);          }          array_unshift($args, $menu_name);        }        else {          // Show only the top-level menu items when access is denied.          $args = array($menu_name, '0');          $placeholders = '%d';          $parents = array();        }        // Select the links from the table, and recursively build the tree. We        // LEFT JOIN since there is no match in {menu_router} for an external        // link.        $data['tree'] = menu_tree_data(db_query("          SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*          FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path          WHERE ml.menu_name = '%s' AND ml.plid IN (". $placeholders .")          ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC", $args), $parents);        $data['node_links'] = array();        menu_tree_collect_node_links($data['tree'], $data['node_links']);        // Cache the data, if it is not already in the cache.        $tree_cid = _menu_tree_cid($menu_name, $data);        if (!cache_get($tree_cid, 'cache_menu')) {          cache_set($tree_cid, $data, 'cache_menu');        }        // Cache the cid of the (shared) data using the page-specific cid.        cache_set($cid, $tree_cid, 'cache_menu');      }      // Check access for the current user to each item in the tree.      menu_tree_check_access($data['tree'], $data['node_links']);      $tree[$cid] = $data['tree'];    }    return $tree[$cid];  }  return array();}/** * Helper function - compute the real cache ID for menu tree data. */function _menu_tree_cid($menu_name, $data) {  return 'links:'. $menu_name .':tree-data:'. md5(serialize($data));}/** * Recursive helper function - collect node links. * * @param $tree *   The menu tree you wish to collect node links from. * @param $node_links *   An array in which to store the collected node links. */function menu_tree_collect_node_links(&$tree, &$node_links) {  foreach ($tree as $key => $v) {    if ($tree[$key]['link']['router_path'] == 'node/%') {      $nid = substr($tree[$key]['link']['link_path'], 5);      if (is_numeric($nid)) {        $node_links[$nid][$tree[$key]['link']['mlid']] = &$tree[$key]['link'];        $tree[$key]['link']['access'] = FALSE;      }    }    if ($tree[$key]['below']) {      menu_tree_collect_node_links($tree[$key]['below'], $node_links);    }  }}/** * Check access and perform other dynamic operations for each link in the tree. * * @param $tree *   The menu tree you wish to operate on. * @param $node_links *   A collection of node link references generated from $tree by *   menu_tree_collect_node_links(). */function menu_tree_check_access(&$tree, $node_links = array()) {  if ($node_links) {    // Use db_rewrite_sql to evaluate view access without loading each full node.    $nids = array_keys($node_links);    $placeholders = '%d'. str_repeat(', %d', count($nids) - 1);    $result = db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.status = 1 AND n.nid IN (". $placeholders .")"), $nids);    while ($node = db_fetch_array($result)) {      $nid = $node['nid'];      foreach ($node_links[$nid] as $mlid => $link) {        $node_links[$nid][$mlid]['access'] = TRUE;      }    }  }  _menu_tree_check_access($tree);  return;}/** * Recursive helper function for menu_tree_check_access() */function _menu_tree_check_access(&$tree) {  $new_tree = array();  foreach ($tree as $key => $v) {    $item = &$tree[$key]['link'];    _menu_link_translate($item);    if ($item['access']) {      if ($tree[$key]['below']) {        _menu_tree_check_access($tree[$key]['below']);      }      // The weights are made a uniform 5 digits by adding 50000 as an offset.      // After _menu_link_translate(), $item['title'] has the localized link title.      // Adding the mlid to the end of the index insures that it is unique.      $new_tree[(50000 + $item['weight']) .' '. $item['title'] .' '. $item['mlid']] = $tree[$key];    }  }  // Sort siblings in the tree based on the weights and localized titles.  ksort($new_tree);  $tree = $new_tree;}/** * Build the data representing a menu tree. * * @param $result *   The database result. * @param $parents *   An array of the plid values that represent the path from the current page *   to the root of the menu tree. * @param $depth *   The depth of the current menu tree. * @return *   See menu_tree_page_data for a description of the data structure. */function menu_tree_data($result = NULL, $parents = array(), $depth = 1) {  list(, $tree) = _menu_tree_data($result, $parents, $depth);  return $tree;}/** * Recursive helper function to build the data representing a menu tree. * * The function is a bit complex because the rendering of an item depends on * the next menu item. So we are always rendering the element previously * processed not the current one. */function _menu_tree_data($result, $parents, $depth, $previous_element = '') {  $remnant = NULL;  $tree = array();  while ($item = db_fetch_array($result)) {    // We need to determine if we're on the path to root so we can later build    // the correct active trail and breadcrumb.    $item['in_active_trail'] = in_array($item['mlid'], $parents);    // The current item is the first in a new submenu.    if ($item['depth'] > $depth) {      // _menu_tree returns an item and the menu tree structure.      list($item, $below) = _menu_tree_data($result, $parents, $item['depth'], $item);      if ($previous_element) {        $tree[$previous_element['mlid']] = array(          'link' => $previous_element,          'below' => $below,        );      }      else {        $tree = $below;      }      // We need to fall back one level.      if (!isset($item) || $item['depth'] < $depth) {        return array($item, $tree);      }      // This will be the link to be output in the next iteration.      $previous_element = $item;    }    // We are at the same depth, so we use the previous element.    elseif ($item['depth'] == $depth) {      if ($previous_element) {        // Only the first time.        $tree[$previous_element['mlid']] = array(          'link' => $previous_element,          'below' => FALSE,        );      }      // This will be the link to be output in the next iteration.      $previous_element = $item;    }    // The submenu ended with the previous item, so pass back the current item.    else {      $remnant = $item;      break;    }  }  if ($previous_element) {    // We have one more link dangling.    $tree[$previous_element['mlid']] = array(      'link' => $previous_element,      'below' => FALSE,    );  }  return array($remnant, $tree);}/** * Generate the HTML output for a single menu link. * * @ingroup themeable */function theme_menu_item_link($link) {  if (empty($link['localized_options'])) {    $link['localized_options'] = array();  }  return l($link['title'], $link['href'], $link['localized_options']);}/** * Generate the HTML output for a menu tree * * @ingroup themeable */function theme_menu_tree($tree) {  return '<ul class="menu">'. $tree .'</ul>';}/** * Generate the HTML output for a menu item and submenu. * * @ingroup themeable */function theme_menu_item($link, $has_children, $menu = '', $in_active_trail = FALSE, $extra_class = NULL) {  $class = ($menu ? 'expanded' : ($has_children ? 'collapsed' : 'leaf'));  if (!empty($extra_class)) {    $class .= ' '. $extra_class;  }  if ($in_active_trail) {    $class .= ' active-trail';  }  return '<li class="'. $class .'">'. $link . $menu ."</li>\n";}/** * Generate the HTML output for a single local task link. * * @ingroup themeable */function theme_menu_local_task($link, $active = FALSE) {  return '<li '. ($active ? 'class="active" ' : '') .'>'. $link ."</li>\n";}/** * Generates elements for the $arg array in the help hook. */function drupal_help_arg($arg = array()) {  // Note - the number of empty elements should be > MENU_MAX_PARTS.  return $arg + array('', '', '', '', '', '', '', '', '', '', '', '');}/** * Returns the help associated with the active menu item. */function menu_get_active_help() {  $output = '';  $router_path = menu_tab_root_path();  // We will always have a path unless we are on a 403 or 404.  if (!$router_path) {    return '';  }  $arg = drupal_help_arg(arg(NULL));  $empty_arg = drupal_help_arg();  foreach (module_list() as $name) {    if (module_hook($name, 'help')) {      // Lookup help for this path.      if ($help = module_invoke($name, 'help', $router_path, $arg)) {        $output .= $help ."\n";      }      // Add "more help" link on admin pages if the module provides a      // standalone help page.      if ($arg[0] == "admin" && module_exists('help') && module_invoke($name, 'help', 'admin/help#'. $arg[2], $empty_arg) && $help) {        $output .= theme("more_help_link", url('admin/help/'. $arg[2]));      }    }  }  return $output;}/** * Build a list of named menus. */function menu_get_names($reset = FALSE) {  static $names;  if ($reset || empty($names)) {    $names = array();    $result = db_query("SELECT DISTINCT(menu_name) FROM {menu_links} ORDER BY menu_name");    while ($name = db_fetch_array($result)) {      $names[] = $name['menu_name'];    }  }  return $names;}/** * Return an array containing the names of system-defined (default) menus. */function menu_list_system_menus() {  return array('navigation', 'primary-links', 'secondary-links');}/** * Return an array of links to be rendered as the Primary links. */function menu_primary_links() {  return menu_navigation_links(variable_get('menu_primary_links_source', 'primary-links'));}/** * Return an array of links to be rendered as the Secondary links. */function menu_secondary_links() {  // If the secondary menu source is set as the primary menu, we display the  // second level of the primary menu.  if (variable_get('menu_secondary_links_source', 'secondary-links') == variable_get('menu_primary_links_source', 'primary-links')) {    return menu_navigation_links(variable_get('menu_primary_links_source', 'primary-links'), 1);  }  else {    return menu_navigation_links(variable_get('menu_secondary_links_source', 'secondary-links'), 0);  }}/** * Return an array of links for a navigation menu. * * @param $menu_name *   The name of the menu. * @param $level *   Optional, the depth of the menu to be returned. * @return *   An array of links of the specified menu and level. */function menu_navigation_links($menu_name, $level = 0) {  // Don't even bother querying the menu table if no menu is specified.  if (empty($menu_name)) {    return array();  }  // Get the menu hierarchy for the current page.  $tree = menu_tree_page_data($menu_name);  // Go down the active trail until the right level is reached.  while ($level-- > 0 && $tree) {    // Loop through the current level's items until we find one that is in trail.    while ($item = array_shift($tree)) {      if ($item['link']['in_active_trail']) {        // If the item is in the active trail, we continue in the subtree.        $tree = empty($item['below']) ? array() : $item['below'];        break;      }    }  }  // Create a single level of links.  $links = array();  foreach ($tree as $item) {    if (!$item['link']['hidden']) {      $class = '';      $l = $item['link']['localized_options'];      $l['href'] = $item['link']['href'];      $l['title'] = $item['link']['title'];      if ($item['link']['in_active_trail']) {        $class = ' active-trail';      }      // Keyed with the unique mlid to generate classes in theme_links().      $links['menu-'. $item['link']['mlid'] . $class] = $l;    }  }  return $links;}/** * Collects the local tasks (tabs) for a given level. * * @param $level *   The level of tasks you ask for. Primary tasks are 0, secondary are 1. * @param $return_root *   Whether to return the root path for the current page. * @return *   Themed output corresponding to the tabs of the requested level, or *   router path if $return_root == TRUE. This router path corresponds to *   a parent tab, if the current page is a default local task. */function menu_local_tasks($level = 0, $return_root = FALSE) {  static $tabs;  static $root_path;  if (!isset($tabs)) {    $tabs = array();    $router_item = menu_get_item();    if (!$router_item || !$router_item['access']) {      return '';    }    // Get all tabs and the root page.    $result = db_query("SELECT * FROM {menu_router} WHERE tab_root = '%s' ORDER BY weight, title", $router_item['tab_root']);    $map = arg();    $children = array();    $tasks = array();    $root_path = $router_item['path'];    while ($item = db_fetch_array($result)) {      _menu_translate($item, $map, TRUE);      if ($item['tab_parent']) {        // All tabs, but not the root page.        $children[$item['tab_parent']][$item['path']] = $item;      }      // Store the translated item for later use.      $tasks[$item['path']] = $item;    }    // Find all tabs below the current path.    $path = $router_item['path'];    // Tab parenting may skip levels, so the number of parts in the path may not    // equal the depth. Thus we use the $depth counter (offset by 1000 for ksort).    $depth = 1001;    while (isset($children[$path])) {      $tabs_current = '';      $next_path = '';      $count = 0;      foreach ($children[$path] as $item) {        if ($item['access']) {          $count++;          // The default task is always active.          if ($item['type'] == MENU_DEFAULT_LOCAL_TASK) {            // Find the first parent which is not a default local task.            for ($p = $item['tab_parent']; $tasks[$p]['type'] == MENU_DEFAULT_LOCAL_TASK; $p = $tasks[$p]['tab_parent']);            $link = theme('menu_item_link', array('href' => $tasks[$p]['href']) + $item);            $tabs_current .= theme('menu_local_task', $link, TRUE);            $next_path = $item['path'];          }          else {            $link = theme('menu_item_link', $item);            $tabs_current .= theme('menu_local_task', $link);          }        }      }      $path = $next_path;      $tabs[$depth]['count'] = $count;      $tabs[$depth]['output'] = $tabs_current;      $depth++;    }    // Find all tabs at the same level or above the current one.    $parent = $router_item['tab_parent'];    $path = $router_item['path'];    $current = $router_item;    $depth = 1000;    while (isset($children[$parent])) {      $tabs_current = '';      $next_path = '';      $next_parent = '';      $count = 0;      foreach ($children[$parent] as $item) {        if ($item['access']) {          $count++;          if ($item['type'] == MENU_DEFAULT_LOCAL_TASK) {            // Find the first parent which is not a default local task.            for ($p = $item['tab_parent']; $tasks[$p]['type'] == MENU_DEFAULT_LOCAL_TASK; $p = $tasks[$p]['tab_parent']);            $link = theme('menu_item_link', array('href' => $tasks[$p]['href']) + $item);            if ($item['path'] == $router_item['path']) {              $root_path = $tasks[$p]['path'];            }          }          else {            $link = theme('menu_item_link', $item);          }          // We check for the active tab.          if ($item['path'] == $path) {            $tabs_current .= theme('menu_local_task', $link, TRUE);            $next_path = $item['tab_parent'];            if (isset($tasks[$next_path])) {              $next_parent = $tasks[$next_path]['tab_parent'];            }          }          else {            $tabs_current .= theme('menu_local_task', $link);          }        }      }      $path = $next_path;      $parent = $next_parent;      $tabs[$depth]['count'] = $count;      $tabs[$depth]['output'] = $tabs_current;      $depth--;    }    // Sort by depth.    ksort($tabs);    // Remove the depth, we are interested only in their relative placement.    $tabs = array_values($tabs);  }  if ($return_root) {    return $root_path;  }  else {    // We do not display single tabs.    return (isset($tabs[$level]) && $tabs[$level]['count'] > 1) ? $tabs[$level]['output'] : '';  }}/** * Returns the rendered local tasks at the top level. */function menu_primary_local_tasks() {  return menu_local_tasks(0);}/** * Returns the rendered local tasks at the second level. */function menu_secondary_local_tasks() {  return menu_local_tasks(1);}/** * Returns the router path, or the path of the parent tab of a default local task. */function menu_tab_root_path() {  return menu_local_tasks(0, TRUE);}/** * Returns the rendered local tasks. The default implementation renders them as tabs. * * @ingroup themeable */function theme_menu_local_tasks() {  $output = '';  if ($primary = menu_primary_local_tasks()) {    $output .= "<ul class=\"tabs primary\">\n". $primary ."</ul>\n";  }  if ($secondary = menu_secondary_local_tasks()) {    $output .= "<ul class=\"tabs secondary\">\n". $secondary ."</ul>\n";  }  return $output;}/** * Set (or get) the active menu for the current page - determines the active trail. */function menu_set_active_menu_name($menu_name = NULL) {  static $active;  if (isset($menu_name)) {    $active = $menu_name;  }  elseif (!isset($active)) {    $active = 'navigation';  }  return $active;}/** * Get the active menu for the current page - determines the active trail. */function menu_get_active_menu_name() {  return menu_set_active_menu_name();}/** * Set the active path, which determines which page is loaded. * * @param $path *   A Drupal path - not a path alias. * * Note that this may not have the desired effect unless invoked very early * in the page load, such as during hook_boot, or unless you call * menu_execute_active_handler() to generate your page output. */function menu_set_active_item($path) {  $_GET['q'] = $path;}/** * Sets or gets the active trail (path to root menu root) of the current page. * * @param $new_trail *   Menu trail to set, or NULL to use previously-set or calculated trail. If *   supplying a trail, use the same format as the return value (see below). * @return *   Path to menu root of the current page, as an array of menu link items, *   starting with the site's home page. Each link item is an associative array *   with the following components: *   - 'title': Title of the item. *   - 'href': Drupal path of the item. *   - 'localized_options': Options for passing into the l() function. *   - 'type': A menu type constant, such as MENU_DEFAULT_LOCAL_TASK, or 0 to *     indicate it's not really in the menu (used for the home page item). *   If $new_trail is supplied, the value is saved in a static variable and *   returned. If $new_trail is not supplied, and there is a saved value from *   a previous call, the saved value is returned. If $new_trail is not supplied *   and there is no saved value, the path to the current page is calculated, *   saved as the static value, and returned. */function menu_set_active_trail($new_trail = NULL) {  static $trail;  if (isset($new_trail)) {    $trail = $new_trail;  }  elseif (!isset($trail)) {    $trail = array();    $trail[] = array('title' => t('Home'), 'href' => '<front>', 'localized_options' => array(), 'type' => 0);    $item = menu_get_item();    // Check whether the current item is a local task (displayed as a tab).    if ($item['tab_parent']) {      // The title of a local task is used for the tab, never the page title.      // Thus, replace it with the item corresponding to the root path to get      // the relevant href and title.  For example, the menu item corresponding      // to 'admin' is used when on the 'By module' tab at 'admin/by-module'.      $parts = explode('/', $item['tab_root']);      $args = arg();      // Replace wildcards in the root path using the current path.      foreach ($parts as $index => $part) {        if ($part == '%') {          $parts[$index] = $args[$index];        }      }      // Retrieve the menu item using the root path after wildcard replacement.      $root_item = menu_get_item(implode('/', $parts));      if ($root_item && $root_item['access']) {        $item = $root_item;      }    }    $tree = menu_tree_page_data(menu_get_active_menu_name());    list($key, $curr) = each($tree);    while ($curr) {      // Terminate the loop when we find the current path in the active trail.      if ($curr['link']['href'] == $item['href']) {        $trail[] = $curr['link'];        $curr = FALSE;      }      else {        // Add the link if it's in the active trail, then move to the link below.        if ($curr['link']['in_active_trail']) {          $trail[] = $curr['link'];          $tree = $curr['below'] ? $curr['below'] : array();        }        list($key, $curr) = each($tree);      }    }    // Make sure the current page is in the trail (needed for the page title),    // but exclude tabs and the front page.    $last = count($trail) - 1;    if ($trail[$last]['href'] != $item['href'] && !(bool)($item['type'] & MENU_IS_LOCAL_TASK) && !drupal_is_front_page()) {      $trail[] = $item;    }  }  return $trail;}/** * Gets the active trail (path to root menu root) of the current page. * * See menu_set_active_trail() for details of return value. */function menu_get_active_trail() {  return menu_set_active_trail();}/** * Get the breadcrumb for the current page, as determined by the active trail. */function menu_get_active_breadcrumb() {  $breadcrumb = array();  // No breadcrumb for the front page.  if (drupal_is_front_page()) {    return $breadcrumb;  }  $item = menu_get_item();  if ($item && $item['access']) {    $active_trail = menu_get_active_trail();    foreach ($active_trail as $parent) {      $breadcrumb[] = l($parent['title'], $parent['href'], $parent['localized_options']);    }    $end = end($active_trail);    // Don't show a link to the current page in the breadcrumb trail.    if ($item['href'] == $end['href'] || ($item['type'] == MENU_DEFAULT_LOCAL_TASK && $end['href'] != '<front>')) {      array_pop($breadcrumb);    }  }  return $breadcrumb;}/** * Get the title of the current page, as determined by the active trail. */function menu_get_active_title() {  $active_trail = menu_get_active_trail();  foreach (array_reverse($active_trail) as $item) {    if (!(bool)($item['type'] & MENU_IS_LOCAL_TASK)) {      return $item['title'];    }  }}/** * Get a menu link by its mlid, access checked and link translated for rendering. * * This function should never be called from within node_load() or any other * function used as a menu object load function since an infinite recursion may * occur. * * @param $mlid *   The mlid of the menu item. * @return *   A menu link, with $item['access'] filled and link translated for *   rendering. */function menu_link_load($mlid) {  if (is_numeric($mlid) && $item = db_fetch_array(db_query("SELECT m.*, ml.* FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = %d", $mlid))) {    _menu_link_translate($item);    return $item;  }  return FALSE;}/** * Clears the cached cached data for a single named menu. */function menu_cache_clear($menu_name = 'navigation') {  static $cache_cleared = array();  if (empty($cache_cleared[$menu_name])) {    cache_clear_all('links:'. $menu_name .':', 'cache_menu', TRUE);    $cache_cleared[$menu_name] = 1;  }  elseif ($cache_cleared[$menu_name] == 1) {    register_shutdown_function('cache_clear_all', 'links:'. $menu_name .':', 'cache_menu', TRUE);    $cache_cleared[$menu_name] = 2;  }}/** * Clears all cached menu data.  This should be called any time broad changes * might have been made to the router items or menu links. */function menu_cache_clear_all() {  cache_clear_all('*', 'cache_menu', TRUE);}/** * (Re)populate the database tables used by various menu functions. * * This function will clear and populate the {menu_router} table, add entries * to {menu_links} for new router items, then remove stale items from * {menu_links}. If called from update.php or install.php, it will also * schedule a call to itself on the first real page load from * menu_execute_active_handler(), because the maintenance page environment * is different and leaves stale data in the menu tables. */function menu_rebuild() {  if (!lock_acquire('menu_rebuild')) {    // Wait for another request that is already doing this work.    // We choose to block here since otherwise the router item may not     // be avaiable in menu_execute_active_handler() resulting in a 404.    lock_wait('menu_rebuild');    return FALSE;  }  $menu = menu_router_build(TRUE);  _menu_navigation_links_rebuild($menu);  // Clear the menu, page and block caches.  menu_cache_clear_all();  _menu_clear_page_cache();    if (defined('MAINTENANCE_MODE')) {    variable_set('menu_rebuild_needed', TRUE);  }  else {    variable_del('menu_rebuild_needed');  }  lock_release('menu_rebuild');  return TRUE;}/** * Collect, alter and store the menu definitions. */function menu_router_build($reset = FALSE) {  static $menu;  if (!isset($menu) || $reset) {    // We need to manually call each module so that we can know which module    // a given item came from.    $callbacks = array();    foreach (module_implements('menu') as $module) {      $router_items = call_user_func($module .'_menu');      if (isset($router_items) && is_array($router_items)) {        foreach (array_keys($router_items) as $path) {          $router_items[$path]['module'] = $module;        }        $callbacks = array_merge($callbacks, $router_items);      }    }    // Alter the menu as defined in modules, keys are like user/%user.    drupal_alter('menu', $callbacks);    $menu = _menu_router_build($callbacks);    _menu_router_cache($menu);  }  return $menu;}/** * Helper function to store the menu router if we have it in memory. */function _menu_router_cache($new_menu = NULL) {  static $menu = NULL;  if (isset($new_menu)) {    $menu = $new_menu;  }  return $menu;}/** * Builds a link from a router item. */function _menu_link_build($item) {  if ($item['type'] == MENU_CALLBACK) {    $item['hidden'] = -1;  }  elseif ($item['type'] == MENU_SUGGESTED_ITEM) {    $item['hidden'] = 1;  }  // Note, we set this as 'system', so that we can be sure to distinguish all  // the menu links generated automatically from entries in {menu_router}.  $item['module'] = 'system';  $item += array(    'menu_name' => 'navigation',    'link_title' => $item['title'],    'link_path' => $item['path'],    'hidden' => 0,    'options' => empty($item['description']) ? array() : array('attributes' => array('title' => $item['description'])),  );  return $item;}/** * Helper function to build menu links for the items in the menu router. */function _menu_navigation_links_rebuild($menu) {  // Add normal and suggested items as links.  $menu_links = array();  foreach ($menu as $path => $item) {    if ($item['_visible']) {      $item = _menu_link_build($item);      $menu_links[$path] = $item;      $sort[$path] = $item['_number_parts'];    }  }  if ($menu_links) {    // Make sure no child comes before its parent.    array_multisort($sort, SORT_NUMERIC, $menu_links);    foreach ($menu_links as $item) {      $existing_item = db_fetch_array(db_query("SELECT mlid, menu_name, plid, customized, has_children, updated FROM {menu_links} WHERE link_path = '%s' AND module = '%s'", $item['link_path'], 'system'));      if ($existing_item) {        $item['mlid'] = $existing_item['mlid'];        // A change in hook_menu may move the link to a different menu        if (empty($item['menu_name']) || ($item['menu_name'] == $existing_item['menu_name'])) {          $item['menu_name'] = $existing_item['menu_name'];          $item['plid'] = $existing_item['plid'];        }        $item['has_children'] = $existing_item['has_children'];        $item['updated'] = $existing_item['updated'];      }      if (!$existing_item || !$existing_item['customized']) {        menu_link_save($item);      }    }  }  $placeholders = db_placeholders($menu, 'varchar');  $paths = array_keys($menu);  // Updated and customized items whose router paths are gone need new ones.  $result = db_query("SELECT ml.link_path, ml.mlid, ml.router_path, ml.updated FROM {menu_links} ml WHERE ml.updated = 1 OR (router_path NOT IN ($placeholders) AND external = 0 AND customized = 1)", $paths);  while ($item = db_fetch_array($result)) {    $router_path = _menu_find_router_path($item['link_path']);    if (!empty($router_path) && ($router_path != $item['router_path'] || $item['updated'])) {      // If the router path and the link path matches, it's surely a working      // item, so we clear the updated flag.      $updated = $item['updated'] && $router_path != $item['link_path'];      db_query("UPDATE {menu_links} SET router_path = '%s', updated = %d WHERE mlid = %d", $router_path, $updated, $item['mlid']);    }  }  // Find any item whose router path does not exist any more.  $result = db_query("SELECT * FROM {menu_links} WHERE router_path NOT IN ($placeholders) AND external = 0 AND updated = 0 AND customized = 0 ORDER BY depth DESC", $paths);  // Remove all such items. Starting from those with the greatest depth will  // minimize the amount of re-parenting done by menu_link_delete().  while ($item = db_fetch_array($result)) {    _menu_delete_item($item, TRUE);  }}/** * Delete one or several menu links. * * @param $mlid *   A valid menu link mlid or NULL. If NULL, $path is used. * @param $path *   The path to the menu items to be deleted. $mlid must be NULL. */function menu_link_delete($mlid, $path = NULL) {  if (isset($mlid)) {    _menu_delete_item(db_fetch_array(db_query("SELECT * FROM {menu_links} WHERE mlid = %d", $mlid)));  }  else {    $result = db_query("SELECT * FROM {menu_links} WHERE link_path = '%s'", $path);    while ($link = db_fetch_array($result)) {      _menu_delete_item($link);    }  }}/** * Helper function for menu_link_delete; deletes a single menu link. * * @param $item *   Item to be deleted. * @param $force *   Forces deletion. Internal use only, setting to TRUE is discouraged. */function _menu_delete_item($item, $force = FALSE) {  if ($item && ($item['module'] != 'system' || $item['updated'] || $force)) {    // Children get re-attached to the item's parent.    if ($item['has_children']) {      $result = db_query("SELECT mlid FROM {menu_links} WHERE plid = %d", $item['mlid']);      while ($m = db_fetch_array($result)) {        $child = menu_link_load($m['mlid']);        $child['plid'] = $item['plid'];        menu_link_save($child);      }    }    db_query('DELETE FROM {menu_links} WHERE mlid = %d', $item['mlid']);    // Update the has_children status of the parent.    _menu_update_parental_status($item);    menu_cache_clear($item['menu_name']);    _menu_clear_page_cache();  }}/** * Save a menu link. * * @param $item *   An array representing a menu link item. The only mandatory keys are *   link_path and link_title. Possible keys are: *   - menu_name   default is navigation *   - weight      default is 0 *   - expanded    whether the item is expanded. *   - options     An array of options, @see l for more. *   - mlid        Set to an existing value, or 0 or NULL to insert a new link. *   - plid        The mlid of the parent. *   - router_path The path of the relevant router item. * @return *   The mlid of the saved menu link, or FALSE if the menu link could not be  *   saved. */function menu_link_save(&$item) {  // Get the router if it's already in memory. $menu will be NULL, unless this  // is during a menu rebuild  $menu = _menu_router_cache();  drupal_alter('menu_link', $item, $menu);  // This is the easiest way to handle the unique internal path '<front>',  // since a path marked as external does not need to match a router path.  $item['_external'] = menu_path_is_external($item['link_path'])  || $item['link_path'] == '<front>';  // Load defaults.  $item += array(    'menu_name' => 'navigation',    'weight' => 0,    'link_title' => '',    'hidden' => 0,    'has_children' => 0,    'expanded' => 0,    'options' => array(),    'module' => 'menu',    'customized' => 0,    'updated' => 0,  );  $existing_item = FALSE;  if (isset($item['mlid'])) {    $existing_item = db_fetch_array(db_query("SELECT * FROM {menu_links} WHERE mlid = %d", $item['mlid']));  }  if (isset($item['plid'])) {    $parent = db_fetch_array(db_query("SELECT * FROM {menu_links} WHERE mlid = %d", $item['plid']));  }  else {    // Find the parent - it must be unique.    $parent_path = $item['link_path'];    $where = "WHERE link_path = '%s'";    // Only links derived from router items should have module == 'system', and    // we want to find the parent even if it's in a different menu.    if ($item['module'] == 'system') {      $where .= " AND module = '%s'";      $arg2 = 'system';    }    else {      // If not derived from a router item, we respect the specified menu name.      $where .= " AND menu_name = '%s'";      $arg2 = $item['menu_name'];    }    do {      $parent = FALSE;      $parent_path = substr($parent_path, 0, strrpos($parent_path, '/'));      $result = db_query("SELECT COUNT(*) FROM {menu_links} ". $where, $parent_path, $arg2);      // Only valid if we get a unique result.      if (db_result($result) == 1) {        $parent = db_fetch_array(db_query("SELECT * FROM {menu_links} ". $where, $parent_path, $arg2));      }    } while ($parent === FALSE && $parent_path);  }  if ($parent !== FALSE) {    $item['menu_name'] = $parent['menu_name'];  }  $menu_name = $item['menu_name'];  // Menu callbacks need to be in the links table for breadcrumbs, but can't  // be parents if they are generated directly from a router item.  if (empty($parent['mlid']) || $parent['hidden'] < 0) {    $item['plid'] =  0;  }  else {    $item['plid'] = $parent['mlid'];  }  if (!$existing_item) {    db_query("INSERT INTO {menu_links} (       menu_name, plid, link_path,      hidden, external, has_children,      expanded, weight,      module, link_title, options,      customized, updated) VALUES (      '%s', %d, '%s',      %d, %d, %d,      %d, %d,      '%s', '%s', '%s', %d, %d)",      $item['menu_name'], $item['plid'], $item['link_path'],      $item['hidden'], $item['_external'], $item['has_children'],      $item['expanded'], $item['weight'],      $item['module'],  $item['link_title'], serialize($item['options']),      $item['customized'], $item['updated']);    $item['mlid'] = db_last_insert_id('menu_links', 'mlid');  }  if (!$item['plid']) {    $item['p1'] = $item['mlid'];    for ($i = 2; $i <= MENU_MAX_DEPTH; $i++) {      $item["p$i"] = 0;    }    $item['depth'] = 1;  }  else {    // Cannot add beyond the maximum depth.    if ($item['has_children'] && $existing_item) {      $limit = MENU_MAX_DEPTH - menu_link_children_relative_depth($existing_item) - 1;    }    else {      $limit = MENU_MAX_DEPTH - 1;    }    if ($parent['depth'] > $limit) {      return FALSE;    }    $item['depth'] = $parent['depth'] + 1;    _menu_link_parents_set($item, $parent);  }  // Need to check both plid and menu_name, since plid can be 0 in any menu.  if ($existing_item && ($item['plid'] != $existing_item['plid'] || $menu_name != $existing_item['menu_name'])) {    _menu_link_move_children($item, $existing_item);  }  // Find the callback. During the menu update we store empty paths to be  // fixed later, so we skip this.  if (!isset($_SESSION['system_update_6021']) && (empty($item['router_path'])  || !$existing_item || ($existing_item['link_path'] != $item['link_path']))) {    if ($item['_external']) {      $item['router_path'] = '';    }    else {      // Find the router path which will serve this path.      $item['parts'] = explode('/', $item['link_path'], MENU_MAX_PARTS);      $item['router_path'] = _menu_find_router_path($item['link_path']);    }  }  db_query("UPDATE {menu_links} SET menu_name = '%s', plid = %d, link_path = '%s',    router_path = '%s', hidden = %d, external = %d, has_children = %d,    expanded = %d, weight = %d, depth = %d,    p1 = %d, p2 = %d, p3 = %d, p4 = %d, p5 = %d, p6 = %d, p7 = %d, p8 = %d, p9 = %d,    module = '%s', link_title = '%s', options = '%s', customized = %d WHERE mlid = %d",    $item['menu_name'], $item['plid'], $item['link_path'],    $item['router_path'], $item['hidden'], $item['_external'], $item['has_children'],    $item['expanded'], $item['weight'],  $item['depth'],    $item['p1'], $item['p2'], $item['p3'], $item['p4'], $item['p5'], $item['p6'], $item['p7'], $item['p8'], $item['p9'],    $item['module'],  $item['link_title'], serialize($item['options']), $item['customized'], $item['mlid']);  // Check the has_children status of the parent.  _menu_update_parental_status($item);  menu_cache_clear($menu_name);  if ($existing_item && $menu_name != $existing_item['menu_name']) {    menu_cache_clear($existing_item['menu_name']);  }  _menu_clear_page_cache();  return $item['mlid'];}/** * Helper function to clear the page and block caches at most twice per page load. */function _menu_clear_page_cache() {  static $cache_cleared = 0;  // Clear the page and block caches, but at most twice, including at  //  the end of the page load when there are multple links saved or deleted.  if (empty($cache_cleared)) {    cache_clear_all();    // Keep track of which menus have expanded items.    _menu_set_expanded_menus();    $cache_cleared = 1;  }  elseif ($cache_cleared == 1) {    register_shutdown_function('cache_clear_all');    // Keep track of which menus have expanded items.    register_shutdown_function('_menu_set_expanded_menus');    $cache_cleared = 2;  }}/** * Helper function to update a list of menus with expanded items */function _menu_set_expanded_menus() {  $names = array();  $result = db_query("SELECT menu_name FROM {menu_links} WHERE expanded != 0 GROUP BY menu_name");  while ($n = db_fetch_array($result)) {    $names[] = $n['menu_name'];  }  variable_set('menu_expanded', $names);}/** * Find the router path which will serve this path. * * @param $link_path *  The path for we are looking up its router path. * @return *  A path from $menu keys or empty if $link_path points to a nonexisting *  place. */function _menu_find_router_path($link_path) {  // $menu will only have data during a menu rebuild.  $menu = _menu_router_cache();  $router_path = $link_path;  $parts = explode('/', $link_path, MENU_MAX_PARTS);  list($ancestors, $placeholders) = menu_get_ancestors($parts);  if (empty($menu)) {    // Not during a menu rebuild, so look up in the database.    $router_path = (string)db_result(db_query_range('SELECT path FROM {menu_router} WHERE path IN ('. implode (',', $placeholders) .') ORDER BY fit DESC', $ancestors, 0, 1));  }  elseif (!isset($menu[$router_path])) {    // Add an empty path as a fallback.    $ancestors[] = '';    foreach ($ancestors as $key => $router_path) {      if (isset($menu[$router_path])) {        // Exit the loop leaving $router_path as the first match.        break;      }    }    // If we did not find the path, $router_path will be the empty string    // at the end of $ancestors.  }  return $router_path;}/** * Insert, update or delete an uncustomized menu link related to a module. * * @param $module *   The name of the module. * @param $op *   Operation to perform: insert, update or delete. * @param $link_path *   The path this link points to. * @param $link_title *   Title of the link to insert or new title to update the link to. *   Unused for delete. * @return *   The insert op returns the mlid of the new item. Others op return NULL. */function menu_link_maintain($module, $op, $link_path, $link_title) {  switch ($op) {    case 'insert':      $menu_link = array(        'link_title' => $link_title,        'link_path' => $link_path,        'module' => $module,      );      return menu_link_save($menu_link);      break;    case 'update':      db_query("UPDATE {menu_links} SET link_title = '%s' WHERE link_path = '%s' AND customized = 0 AND module = '%s'", $link_title, $link_path, $module);      $result = db_query("SELECT menu_name FROM {menu_links} WHERE link_path = '%s' AND customized = 0 AND module = '%s'", $link_path, $module);      while ($item = db_fetch_array($result)) {        menu_cache_clear($item['menu_name']);      }      break;    case 'delete':      menu_link_delete(NULL, $link_path);      break;  }}/** * Find the depth of an item's children relative to its depth. * * For example, if the item has a depth of 2, and the maximum of any child in * the menu link tree is 5, the relative depth is 3. * * @param $item *   An array representing a menu link item. * @return *   The relative depth, or zero. * */function menu_link_children_relative_depth($item) {  $i = 1;  $match = '';  $args[] = $item['menu_name'];  $p = 'p1';  while ($i <= MENU_MAX_DEPTH && $item[$p]) {    $match .= " AND $p = %d";    $args[] = $item[$p];    $p = 'p'. ++$i;  }  $max_depth = db_result(db_query_range("SELECT depth FROM {menu_links} WHERE menu_name = '%s'". $match ." ORDER BY depth DESC", $args, 0, 1));  return ($max_depth > $item['depth']) ? $max_depth - $item['depth'] : 0;}/** * Update the children of a menu link that's being moved. * * The menu name, parents (p1 - p6), and depth are updated for all children of * the link, and the has_children status of the previous parent is updated. */function _menu_link_move_children($item, $existing_item) {  $args[] = $item['menu_name'];  $set[] = "menu_name = '%s'";  $i = 1;  while ($i <= $item['depth']) {    $p = 'p'. $i++;    $set[] = "$p = %d";    $args[] = $item[$p];  }  $j = $existing_item['depth'] + 1;  while ($i <= MENU_MAX_DEPTH && $j <= MENU_MAX_DEPTH) {    $set[] = 'p'. $i++ .' = p'. $j++;  }  while ($i <= MENU_MAX_DEPTH) {    $set[] = 'p'. $i++ .' = 0';  }  $shift = $item['depth'] - $existing_item['depth'];  if ($shift < 0) {    $args[] = -$shift;    $set[] = 'depth = depth - %d';  }  elseif ($shift > 0) {    // The order of $set must be reversed so the new values don't overwrite the    // old ones before they can be used because "Single-table UPDATE    // assignments are generally evaluated from left to right"    // see: http://dev.mysql.com/doc/refman/5.0/en/update.html    $set = array_reverse($set);    $args = array_reverse($args);    $args[] = $shift;    $set[] = 'depth = depth + %d';  }  $where[] = "menu_name = '%s'";  $args[] = $existing_item['menu_name'];  $p = 'p1';  for ($i = 1; $i <= MENU_MAX_DEPTH && $existing_item[$p]; $p = 'p'. ++$i) {    $where[] = "$p = %d";    $args[] = $existing_item[$p];  }  db_query("UPDATE {menu_links} SET ". implode(', ', $set) ." WHERE ". implode(' AND ', $where), $args);  // Check the has_children status of the parent, while excluding this item.  _menu_update_parental_status($existing_item, TRUE);}/** * Check and update the has_children status for the parent of a link. */function _menu_update_parental_status($item, $exclude = FALSE) {  // If plid == 0, there is nothing to update.  if ($item['plid']) {    // We may want to exclude the passed link as a possible child.    $where = $exclude ? " AND mlid != %d" : '';    // Check if at least one visible child exists in the table.    $parent_has_children = (bool)db_result(db_query_range("SELECT mlid FROM {menu_links} WHERE menu_name = '%s' AND plid = %d AND hidden = 0". $where, $item['menu_name'], $item['plid'], $item['mlid'], 0, 1));    db_query("UPDATE {menu_links} SET has_children = %d WHERE mlid = %d", $parent_has_children, $item['plid']);  }}/** * Helper function that sets the p1..p9 values for a menu link being saved. */function _menu_link_parents_set(&$item, $parent) {  $i = 1;  while ($i < $item['depth']) {    $p = 'p'. $i++;    $item[$p] = $parent[$p];  }  $p = 'p'. $i++;  // The parent (p1 - p9) corresponding to the depth always equals the mlid.  $item[$p] = $item['mlid'];  while ($i <= MENU_MAX_DEPTH) {    $p = 'p'. $i++;    $item[$p] = 0;  }}/** * Helper function to build the router table based on the data from hook_menu. */function _menu_router_build($callbacks) {  // First pass: separate callbacks from paths, making paths ready for  // matching. Calculate fitness, and fill some default values.  $menu = array();  foreach ($callbacks as $path => $item) {    $load_functions = array();    $to_arg_functions = array();    $fit = 0;    $move = FALSE;    $parts = explode('/', $path, MENU_MAX_PARTS);    $number_parts = count($parts);    // We store the highest index of parts here to save some work in the fit    // calculation loop.    $slashes = $number_parts - 1;    // Extract load and to_arg functions.    foreach ($parts as $k => $part) {      $match = FALSE;      // Look for wildcards in the form allowed to be used in PHP functions,      // because we are using these to construct the load function names.      // See http://php.net/manual/en/language.functions.php for reference.      if (preg_match('/^%(|[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)$/', $part, $matches)) {        if (empty($matches[1])) {          $match = TRUE;          $load_functions[$k] = NULL;        }        else {          if (function_exists($matches[1] .'_to_arg')) {            $to_arg_functions[$k] = $matches[1] .'_to_arg';            $load_functions[$k] = NULL;            $match = TRUE;          }          if (function_exists($matches[1] .'_load')) {            $function = $matches[1] .'_load';            // Create an array of arguments that will be passed to the _load            // function when this menu path is checked, if 'load arguments'            // exists.            $load_functions[$k] = isset($item['load arguments']) ? array($function => $item['load arguments']) : $function;            $match = TRUE;          }        }      }      if ($match) {        $parts[$k] = '%';      }      else {        $fit |=  1 << ($slashes - $k);      }    }    if ($fit) {      $move = TRUE;    }    else {      // If there is no %, it fits maximally.      $fit = (1 << $number_parts) - 1;    }    $masks[$fit] = 1;    $item['load_functions'] = empty($load_functions) ? '' : serialize($load_functions);    $item['to_arg_functions'] = empty($to_arg_functions) ? '' : serialize($to_arg_functions);    $item += array(      'title' => '',      'weight' => 0,      'type' => MENU_NORMAL_ITEM,      '_number_parts' => $number_parts,      '_parts' => $parts,      '_fit' => $fit,    );    $item += array(      '_visible' => (bool)($item['type'] & MENU_VISIBLE_IN_BREADCRUMB),      '_tab' => (bool)($item['type'] & MENU_IS_LOCAL_TASK),    );    if ($move) {      $new_path = implode('/', $item['_parts']);      $menu[$new_path] = $item;      $sort[$new_path] = $number_parts;    }    else {      $menu[$path] = $item;      $sort[$path] = $number_parts;    }  }  array_multisort($sort, SORT_NUMERIC, $menu);  if (!$menu) {    // We must have a serious error - there is no data to save.    watchdog('php', 'Menu router rebuild failed - some paths may not work correctly.', array(), WATCHDOG_ERROR);    return array();  }  // Delete the existing router since we have some data to replace it.  db_query('DELETE FROM {menu_router}');  // Apply inheritance rules.  foreach ($menu as $path => $v) {    $item = &$menu[$path];    if (!$item['_tab']) {      // Non-tab items.      $item['tab_parent'] = '';      $item['tab_root'] = $path;    }    for ($i = $item['_number_parts'] - 1; $i; $i--) {      $parent_path = implode('/', array_slice($item['_parts'], 0, $i));      if (isset($menu[$parent_path])) {        $parent = $menu[$parent_path];        if (!isset($item['tab_parent'])) {          // Parent stores the parent of the path.          $item['tab_parent'] = $parent_path;        }        if (!isset($item['tab_root']) && !$parent['_tab']) {          $item['tab_root'] = $parent_path;        }        // If an access callback is not found for a default local task we use        // the callback from the parent, since we expect them to be identical.        // In all other cases, the access parameters must be specified.        if (($item['type'] == MENU_DEFAULT_LOCAL_TASK) && !isset($item['access callback']) && isset($parent['access callback'])) {          $item['access callback'] = $parent['access callback'];          if (!isset($item['access arguments']) && isset($parent['access arguments'])) {            $item['access arguments'] = $parent['access arguments'];          }        }        // Same for page callbacks.        if (!isset($item['page callback']) && isset($parent['page callback'])) {          $item['page callback'] = $parent['page callback'];          if (!isset($item['page arguments']) && isset($parent['page arguments'])) {            $item['page arguments'] = $parent['page arguments'];          }          if (!isset($item['file']) && isset($parent['file'])) {            $item['file'] = $parent['file'];          }          if (!isset($item['file path']) && isset($parent['file path'])) {            $item['file path'] = $parent['file path'];          }        }      }    }    if (!isset($item['access callback']) && isset($item['access arguments'])) {      // Default callback.      $item['access callback'] = 'user_access';    }    if (!isset($item['access callback']) || empty($item['page callback'])) {      $item['access callback'] = 0;    }    if (is_bool($item['access callback'])) {      $item['access callback'] = intval($item['access callback']);    }    $item += array(      'access arguments' => array(),      'access callback' => '',      'page arguments' => array(),      'page callback' => '',      'block callback' => '',      'title arguments' => array(),      'title callback' => 't',      'description' => '',      'position' => '',      'tab_parent' => '',      'tab_root' => $path,      'path' => $path,      'file' => '',      'file path' => '',      'include file' => '',    );    // Calculate out the file to be included for each callback, if any.    if ($item['file']) {      $file_path = $item['file path'] ? $item['file path'] : drupal_get_path('module', $item['module']);      $item['include file'] = $file_path .'/'. $item['file'];    }    $title_arguments = $item['title arguments'] ? serialize($item['title arguments']) : '';    db_query("INSERT INTO {menu_router}      (path, load_functions, to_arg_functions, access_callback,      access_arguments, page_callback, page_arguments, fit,      number_parts, tab_parent, tab_root,      title, title_callback, title_arguments,      type, block_callback, description, position, weight, file)      VALUES ('%s', '%s', '%s', '%s',      '%s', '%s', '%s', %d,      %d, '%s', '%s',      '%s', '%s', '%s',      %d, '%s', '%s', '%s', %d, '%s')",      $path, $item['load_functions'], $item['to_arg_functions'], $item['access callback'],      serialize($item['access arguments']), $item['page callback'], serialize($item['page arguments']), $item['_fit'],      $item['_number_parts'], $item['tab_parent'], $item['tab_root'],      $item['title'], $item['title callback'], $title_arguments,      $item['type'], $item['block callback'], $item['description'], $item['position'], $item['weight'], $item['include file']);  }  // Sort the masks so they are in order of descending fit, and store them.  $masks = array_keys($masks);  rsort($masks);  variable_set('menu_masks', $masks);  return $menu;}/** * Returns TRUE if a path is external (e.g. http://example.com). */function menu_path_is_external($path) {  $colonpos = strpos($path, ':');  return $colonpos !== FALSE && !preg_match('![/?#]!', substr($path, 0, $colonpos)) && filter_xss_bad_protocol($path, FALSE) == check_plain($path);}/** * Checks whether the site is off-line for maintenance. * * This function will log the current user out and redirect to front page * if the current user has no 'administer site configuration' permission. * * @return *   FALSE if the site is not off-line or its the login page or the user has *     'administer site configuration' permission. *   TRUE for anonymous users not on the login page if the site is off-line. */function _menu_site_is_offline() {  // Check if site is set to off-line mode.  if (variable_get('site_offline', 0)) {    // Check if the user has administration privileges.    if (user_access('administer site configuration')) {      // Ensure that the off-line message is displayed only once [allowing for      // page redirects], and specifically suppress its display on the site      // maintenance page.      if (drupal_get_normal_path($_GET['q']) != 'admin/settings/site-maintenance') {        drupal_set_message(l(t('Operating in off-line mode.'), 'admin/settings/site-maintenance'), 'status', FALSE);      }    }    else {      // Anonymous users get a FALSE at the login prompt, TRUE otherwise.      if (user_is_anonymous()) {        return $_GET['q'] != 'user' && $_GET['q'] != 'user/login';      }      // Logged in users are unprivileged here, so they are logged out.      require_once drupal_get_path('module', 'user') .'/user.pages.inc';      user_logout();    }  }  return FALSE;}/** * Validates the path of a menu link being created or edited. * * @return *   TRUE if it is a valid path AND the current user has access permission, *   FALSE otherwise. */function menu_valid_path($form_item) {  global $menu_admin;  $item = array();  $path = $form_item['link_path'];  // We indicate that a menu administrator is running the menu access check.  $menu_admin = TRUE;  if ($path == '<front>' || menu_path_is_external($path)) {    $item = array('access' => TRUE);  }  elseif (preg_match('/\/\%/', $path)) {    // Path is dynamic (ie 'user/%'), so check directly against menu_router table.    if ($item = db_fetch_array(db_query("SELECT * FROM {menu_router} where path = '%s' ", $path))) {      $item['link_path']  = $form_item['link_path'];      $item['link_title'] = $form_item['link_title'];      $item['external']   = FALSE;      $item['options'] = '';      _menu_link_translate($item);    }  }  else {    $item = menu_get_item($path);  }  $menu_admin = FALSE;  return $item && $item['access'];}/** * @} End of "defgroup menu". */
<?php// $Id$/** * Indicates an error during check for PHP unicode support. */define('UNICODE_ERROR', -1);/** * Indicates that standard PHP (emulated) unicode support is being used. */define('UNICODE_SINGLEBYTE', 0);/** * Indicates that full unicode support with the PHP mbstring extension is being * used. */define('UNICODE_MULTIBYTE', 1);/** * Wrapper around _unicode_check(). */function unicode_check() {  list($GLOBALS['multibyte']) = _unicode_check();}/** * Perform checks about Unicode support in PHP, and set the right settings if * needed. * * Because Drupal needs to be able to handle text in various encodings, we do * not support mbstring function overloading. HTTP input/output conversion must * be disabled for similar reasons. * * @param $errors *   Whether to report any fatal errors with form_set_error(). */function _unicode_check() {  // Ensure translations don't break at install time  $t = get_t();  // Set the standard C locale to ensure consistent, ASCII-only string handling.  setlocale(LC_CTYPE, 'C');  // Check for outdated PCRE library  // Note: we check if U+E2 is in the range U+E0 - U+E1. This test returns TRUE on old PCRE versions.  if (preg_match('/[-]/u', '')) {    return array(UNICODE_ERROR, $t('The PCRE library in your PHP installation is outdated. This will cause problems when handling Unicode text. If you are running PHP 4.3.3 or higher, make sure you are using the PCRE library supplied by PHP. Please refer to the <a href="@url">PHP PCRE documentation</a> for more information.', array('@url' => 'http://www.php.net/pcre')));  }  // Check for mbstring extension  if (!function_exists('mb_strlen')) {    return array(UNICODE_SINGLEBYTE, $t('Operations on Unicode strings are emulated on a best-effort basis. Install the <a href="@url">PHP mbstring extension</a> for improved Unicode support.', array('@url' => 'http://www.php.net/mbstring')));  }  // Check mbstring configuration  if (ini_get('mbstring.func_overload') != 0) {    return array(UNICODE_ERROR, $t('Multibyte string function overloading in PHP is active and must be disabled. Check the php.ini <em>mbstring.func_overload</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.encoding_translation') != 0) {    return array(UNICODE_ERROR, $t('Multibyte string input conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.encoding_translation</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.http_input') != 'pass') {    return array(UNICODE_ERROR, $t('Multibyte string input conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.http_input</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.http_output') != 'pass') {    return array(UNICODE_ERROR, $t('Multibyte string output conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.http_output</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  // Set appropriate configuration  mb_internal_encoding('utf-8');  mb_language('uni');  return array(UNICODE_MULTIBYTE, '');}/** * Return Unicode library status and errors. */function unicode_requirements() {  // Ensure translations don't break at install time  $t = get_t();  $libraries = array(    UNICODE_SINGLEBYTE => $t('Standard PHP'),    UNICODE_MULTIBYTE => $t('PHP Mbstring Extension'),    UNICODE_ERROR => $t('Error'),  );  $severities = array(    UNICODE_SINGLEBYTE => REQUIREMENT_WARNING,    UNICODE_MULTIBYTE => REQUIREMENT_OK,    UNICODE_ERROR => REQUIREMENT_ERROR,  );  list($library, $description) = _unicode_check();  $requirements['unicode'] = array(    'title' => $t('Unicode library'),    'value' => $libraries[$library],  );  if ($description) {    $requirements['unicode']['description'] = $description;  }  $requirements['unicode']['severity'] = $severities[$library];  return $requirements;}/** * Prepare a new XML parser. * * This is a wrapper around xml_parser_create() which extracts the encoding from * the XML data first and sets the output encoding to UTF-8. This function should * be used instead of xml_parser_create(), because PHP 4's XML parser doesn't * check the input encoding itself. "Starting from PHP 5, the input encoding is * automatically detected, so that the encoding parameter specifies only the * output encoding." * * This is also where unsupported encodings will be converted. Callers should * take this into account: $data might have been changed after the call. * * @param &$data *   The XML data which will be parsed later. * @return *   An XML parser object. */function drupal_xml_parser_create(&$data) {  // Default XML encoding is UTF-8  $encoding = 'utf-8';  $bom = FALSE;  // Check for UTF-8 byte order mark (PHP5's XML parser doesn't handle it).  if (!strncmp($data, "\xEF\xBB\xBF", 3)) {    $bom = TRUE;    $data = substr($data, 3);  }  // Check for an encoding declaration in the XML prolog if no BOM was found.  if (!$bom && ereg('^<\?xml[^>]+encoding="([^"]+)"', $data, $match)) {    $encoding = $match[1];  }  // Unsupported encodings are converted here into UTF-8.  $php_supported = array('utf-8', 'iso-8859-1', 'us-ascii');  if (!in_array(strtolower($encoding), $php_supported)) {    $out = drupal_convert_to_utf8($data, $encoding);    if ($out !== FALSE) {      $encoding = 'utf-8';      $data = ereg_replace('^(<\?xml[^>]+encoding)="([^"]+)"', '\\1="utf-8"', $out);    }    else {      watchdog('php', 'Could not convert XML encoding %s to UTF-8.', array('%s' => $encoding), WATCHDOG_WARNING);      return 0;    }  }  $xml_parser = xml_parser_create($encoding);  xml_parser_set_option($xml_parser, XML_OPTION_TARGET_ENCODING, 'utf-8');  return $xml_parser;}/** * Convert data to UTF-8 * * Requires the iconv, GNU recode or mbstring PHP extension. * * @param $data *   The data to be converted. * @param $encoding *   The encoding that the data is in * @return *   Converted data or FALSE. */function drupal_convert_to_utf8($data, $encoding) {  if (function_exists('iconv')) {    $out = @iconv($encoding, 'utf-8', $data);  }  else if (function_exists('mb_convert_encoding')) {    $out = @mb_convert_encoding($data, 'utf-8', $encoding);  }  else if (function_exists('recode_string')) {    $out = @recode_string($encoding .'..utf-8', $data);  }  else {    watchdog('php', 'Unsupported encoding %s. Please install iconv, GNU recode or mbstring for PHP.', array('%s' => $encoding), WATCHDOG_ERROR);    return FALSE;  }  return $out;}/** * Truncate a UTF-8-encoded string safely to a number of bytes. * * If the end position is in the middle of a UTF-8 sequence, it scans backwards * until the beginning of the byte sequence. * * Use this function whenever you want to chop off a string at an unsure * location. On the other hand, if you're sure that you're splitting on a * character boundary (e.g. after using strpos() or similar), you can safely use * substr() instead. * * @param $string *   The string to truncate. * @param $len *   An upper limit on the returned string length. * @return *   The truncated string. */function drupal_truncate_bytes($string, $len) {  if (strlen($string) <= $len) {    return $string;  }  if ((ord($string[$len]) < 0x80) || (ord($string[$len]) >= 0xC0)) {    return substr($string, 0, $len);  }  while (--$len >= 0 && ord($string[$len]) >= 0x80 && ord($string[$len]) < 0xC0) {};  return substr($string, 0, $len);}/** * Truncate a UTF-8-encoded string safely to a number of characters. * * @param $string *   The string to truncate. * @param $len *   An upper limit on the returned string length. * @param $wordsafe *   Flag to truncate at last space within the upper limit. Defaults to FALSE. * @param $dots *   Flag to add trailing dots. Defaults to FALSE. * @return *   The truncated string. */function truncate_utf8($string, $len, $wordsafe = FALSE, $dots = FALSE) {  if (drupal_strlen($string) <= $len) {    return $string;  }  if ($dots) {    $len -= 4;  }  if ($wordsafe) {    $string = drupal_substr($string, 0, $len + 1); // leave one more character    if ($last_space = strrpos($string, ' ')) { // space exists AND is not on position 0      $string = substr($string, 0, $last_space);    }    else {      $string = drupal_substr($string, 0, $len);    }  }  else {    $string = drupal_substr($string, 0, $len);  }  if ($dots) {    $string .= ' ...';  }  return $string;}/** * Encodes MIME/HTTP header values that contain non-ASCII, UTF-8 encoded * characters. * * For example, mime_header_encode('tst.txt') returns "=?UTF-8?B?dMOpc3QudHh0?=". * * See http://www.rfc-editor.org/rfc/rfc2047.txt for more information. * * Notes: * - Only encode strings that contain non-ASCII characters. * - We progressively cut-off a chunk with truncate_utf8(). This is to ensure *   each chunk starts and ends on a character boundary. * - Using \n as the chunk separator may cause problems on some systems and may *   have to be changed to \r\n or \r. */function mime_header_encode($string) {  if (preg_match('/[^\x20-\x7E]/', $string)) {    $chunk_size = 47; // floor((75 - strlen("=?UTF-8?B??=")) * 0.75);    $len = strlen($string);    $output = '';    while ($len > 0) {      $chunk = drupal_truncate_bytes($string, $chunk_size);      $output .= ' =?UTF-8?B?'. base64_encode($chunk) ."?=\n";      $c = strlen($chunk);      $string = substr($string, $c);      $len -= $c;    }    return trim($output);  }  return $string;}/** * Complement to mime_header_encode */function mime_header_decode($header) {  // First step: encoded chunks followed by other encoded chunks (need to collapse whitespace)  $header = preg_replace_callback('/=\?([^?]+)\?(Q|B)\?([^?]+|\?(?!=))\?=\s+(?==\?)/', '_mime_header_decode', $header);  // Second step: remaining chunks (do not collapse whitespace)  return preg_replace_callback('/=\?([^?]+)\?(Q|B)\?([^?]+|\?(?!=))\?=/', '_mime_header_decode', $header);}/** * Helper function to mime_header_decode */function _mime_header_decode($matches) {  // Regexp groups:  // 1: Character set name  // 2: Escaping method (Q or B)  // 3: Encoded data  $data = ($matches[2] == 'B') ? base64_decode($matches[3]) : str_replace('_', ' ', quoted_printable_decode($matches[3]));  if (strtolower($matches[1]) != 'utf-8') {    $data = drupal_convert_to_utf8($data, $matches[1]);  }  return $data;}/** * Decode all HTML entities (including numerical ones) to regular UTF-8 bytes. * Double-escaped entities will only be decoded once ("&amp;lt;" becomes "&lt;", not "<"). * * @param $text *   The text to decode entities in. * @param $exclude *   An array of characters which should not be decoded. For example, *   array('<', '&', '"'). This affects both named and numerical entities. */function decode_entities($text, $exclude = array()) {  static $table;  // We store named entities in a table for quick processing.  if (!isset($table)) {    // Get all named HTML entities.    $table = array_flip(get_html_translation_table(HTML_ENTITIES));    // PHP gives us ISO-8859-1 data, we need UTF-8.    $table = array_map('utf8_encode', $table);    // Add apostrophe (XML)    $table['&apos;'] = "'";  }  $newtable = array_diff($table, $exclude);  // Use a regexp to select all entities in one pass, to avoid decoding double-escaped entities twice.  return preg_replace('/&(#x?)?([A-Za-z0-9]+);/e', '_decode_entities("$1", "$2", "$0", $newtable, $exclude)', $text);}/** * Helper function for decode_entities */function _decode_entities($prefix, $codepoint, $original, &$table, &$exclude) {  // Named entity  if (!$prefix) {    if (isset($table[$original])) {      return $table[$original];    }    else {      return $original;    }  }  // Hexadecimal numerical entity  if ($prefix == '#x') {    $codepoint = base_convert($codepoint, 16, 10);  }  // Decimal numerical entity (strip leading zeros to avoid PHP octal notation)  else {    $codepoint = preg_replace('/^0+/', '', $codepoint);  }  // Encode codepoint as UTF-8 bytes  if ($codepoint < 0x80) {    $str = chr($codepoint);  }  else if ($codepoint < 0x800) {    $str = chr(0xC0 | ($codepoint >> 6))         . chr(0x80 | ($codepoint & 0x3F));  }  else if ($codepoint < 0x10000) {    $str = chr(0xE0 | ( $codepoint >> 12))         . chr(0x80 | (($codepoint >> 6) & 0x3F))         . chr(0x80 | ( $codepoint       & 0x3F));  }  else if ($codepoint < 0x200000) {    $str = chr(0xF0 | ( $codepoint >> 18))         . chr(0x80 | (($codepoint >> 12) & 0x3F))         . chr(0x80 | (($codepoint >> 6)  & 0x3F))         . chr(0x80 | ( $codepoint        & 0x3F));  }  // Check for excluded characters  if (in_array($str, $exclude)) {    return $original;  }  else {    return $str;  }}/** * Count the amount of characters in a UTF-8 string. This is less than or * equal to the byte count. */function drupal_strlen($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strlen($text);  }  else {    // Do not count UTF-8 continuation bytes.    return strlen(preg_replace("/[\x80-\xBF]/", '', $text));  }}/** * Uppercase a UTF-8 string. */function drupal_strtoupper($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strtoupper($text);  }  else {    // Use C-locale for ASCII-only uppercase    $text = strtoupper($text);    // Case flip Latin-1 accented letters    $text = preg_replace_callback('/\xC3[\xA0-\xB6\xB8-\xBE]/', '_unicode_caseflip', $text);    return $text;  }}/** * Lowercase a UTF-8 string. */function drupal_strtolower($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strtolower($text);  }  else {    // Use C-locale for ASCII-only lowercase    $text = strtolower($text);    // Case flip Latin-1 accented letters    $text = preg_replace_callback('/\xC3[\x80-\x96\x98-\x9E]/', '_unicode_caseflip', $text);    return $text;  }}/** * Helper function for case conversion of Latin-1. * Used for flipping U+C0-U+DE to U+E0-U+FD and back. */function _unicode_caseflip($matches) {  return $matches[0][0] . chr(ord($matches[0][1]) ^ 32);}/** * Capitalize the first letter of a UTF-8 string. */function drupal_ucfirst($text) {  // Note: no mbstring equivalent!  return drupal_strtoupper(drupal_substr($text, 0, 1)) . drupal_substr($text, 1);}/** * Cut off a piece of a string based on character indices and counts. Follows * the same behavior as PHP's own substr() function. * * Note that for cutting off a string at a known character/substring * location, the usage of PHP's normal strpos/substr is safe and * much faster. */function drupal_substr($text, $start, $length = NULL) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return $length === NULL ? mb_substr($text, $start) : mb_substr($text, $start, $length);  }  else {    $strlen = strlen($text);    // Find the starting byte offset    $bytes = 0;    if ($start > 0) {      // Count all the continuation bytes from the start until we have found      // $start characters      $bytes = -1; $chars = -1;      while ($bytes < $strlen && $chars < $start) {        $bytes++;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }    }    else if ($start < 0) {      // Count all the continuation bytes from the end until we have found      // abs($start) characters      $start = abs($start);      $bytes = $strlen; $chars = 0;      while ($bytes > 0 && $chars < $start) {        $bytes--;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }    }    $istart = $bytes;    // Find the ending byte offset    if ($length === NULL) {      $bytes = $strlen - 1;    }    else if ($length > 0) {      // Count all the continuation bytes from the starting index until we have      // found $length + 1 characters. Then backtrack one byte.      $bytes = $istart; $chars = 0;      while ($bytes < $strlen && $chars < $length) {        $bytes++;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }      $bytes--;    }    else if ($length < 0) {      // Count all the continuation bytes from the end until we have found      // abs($length) characters      $length = abs($length);      $bytes = $strlen - 1; $chars = 0;      while ($bytes >= 0 && $chars < $length) {        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }        $bytes--;      }    }    $iend = $bytes;    return substr($text, $istart, max(0, $iend - $istart + 1));  }}
<?php// $Id$/** * @file * User page callbacks for the profile module. *//** * Menu callback; display a list of user information. */function profile_browse() {  // Ensure that the path is converted to 3 levels always.  list(, $name, $value) = array_pad(explode('/', $_GET['q'], 3), 3, '');  $field = db_fetch_object(db_query("SELECT DISTINCT(fid), type, title, page, visibility FROM {profile_fields} WHERE name = '%s'", $name));  if ($name && $field->fid) {    // Only allow browsing of fields that have a page title set.    if (empty($field->page)) {      drupal_not_found();      return;    }    // Do not allow browsing of private and hidden fields by non-admins.    if (!user_access('administer users') && ($field->visibility == PROFILE_PRIVATE || $field->visibility == PROFILE_HIDDEN)) {      drupal_access_denied();      return;    }    // Compile a list of fields to show.    $fields = array();    $result = db_query('SELECT name, title, type, weight, page FROM {profile_fields} WHERE fid != %d AND visibility = %d ORDER BY weight', $field->fid, PROFILE_PUBLIC_LISTINGS);    while ($record = db_fetch_object($result)) {      $fields[] = $record;    }    // Determine what query to use:    $arguments = array($field->fid);    switch ($field->type) {      case 'checkbox':        $query = 'v.value = 1';        break;      case 'textfield':      case 'selection':        $query = "v.value = '%s'";        $arguments[] = $value;        break;      case 'list':        $query = "v.value LIKE '%%%s%%'";        $arguments[] = $value;        break;      default:        drupal_not_found();        return;    }    // Extract the affected users:    $result = pager_query("SELECT u.uid, u.access FROM {users} u INNER JOIN {profile_values} v ON u.uid = v.uid WHERE v.fid = %d AND $query AND u.access != 0 AND u.status != 0 ORDER BY u.access DESC", 20, 0, NULL, $arguments);    $content = '';    while ($account = db_fetch_object($result)) {      $account = user_load(array('uid' => $account->uid));      $profile = _profile_update_user_fields($fields, $account);      $content .= theme('profile_listing', $account, $profile);    }    $output = theme('profile_wrapper', $content);    $output .= theme('pager', NULL, 20);    if ($field->type == 'selection' || $field->type == 'list' || $field->type == 'textfield') {      $title = strtr(check_plain($field->page), array('%value' => theme('placeholder', $value)));    }    else {      $title = check_plain($field->page);    }    drupal_set_title($title);    return $output;  }  else if ($name && !$field->fid) {    drupal_not_found();  }  else {    // Compile a list of fields to show.    $fields = array();    $result = db_query('SELECT name, title, type, weight, page FROM {profile_fields} WHERE visibility = %d ORDER BY category, weight', PROFILE_PUBLIC_LISTINGS);    while ($record = db_fetch_object($result)) {      $fields[] = $record;    }    // Extract the affected users:    $result = pager_query('SELECT uid, access FROM {users} WHERE uid > 0 AND status != 0 AND access != 0 ORDER BY access DESC', 20, 0, NULL);    $content = '';    while ($account = db_fetch_object($result)) {      $account = user_load(array('uid' => $account->uid));      $profile = _profile_update_user_fields($fields, $account);      $content .= theme('profile_listing', $account, $profile);    }    $output = theme('profile_wrapper', $content);    $output .= theme('pager', NULL, 20);    drupal_set_title(t('User list'));    return $output;  }}/** * Callback to allow autocomplete of profile text fields. */function profile_autocomplete($field, $string) {  $matches = array();  if (db_result(db_query("SELECT COUNT(*) FROM {profile_fields} WHERE fid = %d AND autocomplete = 1", $field))) {    $result = db_query_range("SELECT value FROM {profile_values} WHERE fid = %d AND LOWER(value) LIKE LOWER('%s%%') GROUP BY value ORDER BY value ASC", $field, $string, 0, 10);    while ($data = db_fetch_object($result)) {      $matches[$data->value] = check_plain($data->value);    }  }  drupal_json($matches);}
<?php// $Id$/** * @file * The theme system, which controls the output of Drupal. * * The theme system allows for nearly all output of the Drupal system to be * customized by user themes. * * @ingroup themeable *//** * @name Content markers * @{ * Markers used by theme_mark() and node_mark() to designate content. * @see theme_mark(), node_mark() */define('MARK_READ',    0);define('MARK_NEW',     1);define('MARK_UPDATED', 2);/** * @} End of "Content markers". *//** * Initialize the theme system by loading the theme. */function init_theme() {  global $theme, $user, $custom_theme, $theme_key;  // If $theme is already set, assume the others are set, too, and do nothing  if (isset($theme)) {    return;  }  drupal_bootstrap(DRUPAL_BOOTSTRAP_DATABASE);  $themes = list_themes();  // Only select the user selected theme if it is available in the  // list of enabled themes.  $theme = !empty($user->theme) && !empty($themes[$user->theme]->status) ? $user->theme : variable_get('theme_default', 'garland');  // Allow modules to override the present theme... only select custom theme  // if it is available in the list of installed themes.  $theme = $custom_theme && $themes[$custom_theme] ? $custom_theme : $theme;  // Store the identifier for retrieving theme settings with.  $theme_key = $theme;  // Find all our ancestor themes and put them in an array.  $base_theme = array();  $ancestor = $theme;  while ($ancestor && isset($themes[$ancestor]->base_theme)) {    $base_theme[] = $new_base_theme = $themes[$themes[$ancestor]->base_theme];    $ancestor = $themes[$ancestor]->base_theme;  }  _init_theme($themes[$theme], array_reverse($base_theme));}/** * Initialize the theme system given already loaded information. This * function is useful to initialize a theme when no database is present. * * @param $theme *   An object with the following information: *     filename *       The .info file for this theme. The 'path' to *       the theme will be in this file's directory. (Required) *     owner *       The path to the .theme file or the .engine file to load for *       the theme. (Required) *     stylesheet *       The primary stylesheet for the theme. (Optional) *     engine *       The name of theme engine to use. (Optional) * @param $base_theme *    An optional array of objects that represent the 'base theme' if the *    theme is meant to be derivative of another theme. It requires *    the same information as the $theme object. It should be in *    'oldest first' order, meaning the top level of the chain will *    be first. * @param $registry_callback *   The callback to invoke to set the theme registry. */function _init_theme($theme, $base_theme = array(), $registry_callback = '_theme_load_registry') {  global $theme_info, $base_theme_info, $theme_engine, $theme_path;  $theme_info = $theme;  $base_theme_info = $base_theme;  $theme_path = dirname($theme->filename);  // Prepare stylesheets from this theme as well as all ancestor themes.  // We work it this way so that we can have child themes override parent  // theme stylesheets easily.  $final_stylesheets = array();  // Grab stylesheets from base theme  foreach ($base_theme as $base) {    if (!empty($base->stylesheets)) {      foreach ($base->stylesheets as $media => $stylesheets) {        foreach ($stylesheets as $name => $stylesheet) {          $final_stylesheets[$media][$name] = $stylesheet;        }      }    }  }  // Add stylesheets used by this theme.  if (!empty($theme->stylesheets)) {    foreach ($theme->stylesheets as $media => $stylesheets) {      foreach ($stylesheets as $name => $stylesheet) {        $final_stylesheets[$media][$name] = $stylesheet;      }    }  }  // And now add the stylesheets properly  foreach ($final_stylesheets as $media => $stylesheets) {    foreach ($stylesheets as $stylesheet) {      drupal_add_css($stylesheet, 'theme', $media);    }  }  // Do basically the same as the above for scripts  $final_scripts = array();  // Grab scripts from base theme  foreach ($base_theme as $base) {    if (!empty($base->scripts)) {      foreach ($base->scripts as $name => $script) {        $final_scripts[$name] = $script;      }    }  }  // Add scripts used by this theme.  if (!empty($theme->scripts)) {    foreach ($theme->scripts as $name => $script) {      $final_scripts[$name] = $script;    }  }  // Add scripts used by this theme.  foreach ($final_scripts as $script) {    drupal_add_js($script, 'theme');  }  $theme_engine = NULL;  // Initialize the theme.  if (isset($theme->engine)) {    // Include the engine.    include_once './'. $theme->owner;    $theme_engine = $theme->engine;    if (function_exists($theme_engine .'_init')) {      foreach ($base_theme as $base) {        call_user_func($theme_engine .'_init', $base);      }      call_user_func($theme_engine .'_init', $theme);    }  }  else {    // include non-engine theme files    foreach ($base_theme as $base) {      // Include the theme file or the engine.      if (!empty($base->owner)) {        include_once './'. $base->owner;      }    }    // and our theme gets one too.    if (!empty($theme->owner)) {      include_once './'. $theme->owner;    }  }  $registry_callback($theme, $base_theme, $theme_engine);}/** * Retrieve the stored theme registry. If the theme registry is already * in memory it will be returned; otherwise it will attempt to load the * registry from cache. If this fails, it will construct the registry and * cache it. */function theme_get_registry($registry = NULL) {  static $theme_registry = NULL;  if (isset($registry)) {    $theme_registry = $registry;  }  return $theme_registry;}/** * Store the theme registry in memory. */function _theme_set_registry($registry) {  // Pass through for setting of static variable.  return theme_get_registry($registry);}/** * Get the theme_registry cache from the database; if it doesn't exist, build * it. * * @param $theme *   The loaded $theme object. * @param $base_theme *   An array of loaded $theme objects representing the ancestor themes in *   oldest first order. * @param theme_engine *   The name of the theme engine. */function _theme_load_registry($theme, $base_theme = NULL, $theme_engine = NULL) {  // Check the theme registry cache; if it exists, use it.  $cache = cache_get("theme_registry:$theme->name", 'cache');  if (isset($cache->data)) {    $registry = $cache->data;  }  else {    // If not, build one and cache it.    $registry = _theme_build_registry($theme, $base_theme, $theme_engine);    _theme_save_registry($theme, $registry);  }  _theme_set_registry($registry);}/** * Write the theme_registry cache into the database. */function _theme_save_registry($theme, $registry) {  cache_set("theme_registry:$theme->name", $registry);}/** * Force the system to rebuild the theme registry; this should be called * when modules are added to the system, or when a dynamic system needs * to add more theme hooks. */function drupal_rebuild_theme_registry() {  cache_clear_all('theme_registry', 'cache', TRUE);}/** * Process a single invocation of the theme hook. $type will be one * of 'module', 'theme_engine', 'base_theme_engine', 'theme', or 'base_theme' * and it tells us some important information. * * Because $cache is a reference, the cache will be continually * expanded upon; new entries will replace old entries in the * array_merge, but we are careful to ensure some data is carried * forward, such as the arguments a theme hook needs. * * An override flag can be set for preprocess functions. When detected the * cached preprocessors for the hook will not be merged with the newly set. * This can be useful to themes and theme engines by giving them more control * over how and when the preprocess functions are run. */function _theme_process_registry(&$cache, $name, $type, $theme, $path) {  $result = array();  $function = $name .'_theme';  if (function_exists($function)) {    $result = $function($cache, $type, $theme, $path);    foreach ($result as $hook => $info) {      $result[$hook]['type'] = $type;      $result[$hook]['theme path'] = $path;      // if function and file are left out, default to standard naming      // conventions.      if (!isset($info['template']) && !isset($info['function'])) {        $result[$hook]['function'] = ($type == 'module' ? 'theme_' : $name .'_') . $hook;      }      // Make sure include files is set so we don't generate notices later.      if (!isset($info['include files'])) {        $result[$hook]['include files'] = array();      }      // If a path is set in the info, use what was set. Otherwise use the      // default path. This is mostly so system.module can declare theme      // functions on behalf of core .include files.      // All files are included to be safe. Conditionally included      // files can prevent them from getting registered.      if (isset($info['file']) && !isset($info['path'])) {        // First, check to see if the fully qualified file exists.        $filename = './'. $path .'/'. $info['file'];        if (file_exists($filename)) {          require_once $filename;          $result[$hook]['include files'][] = $filename;        }        else {          $filename = './'. $info['file'];          if (file_exists($filename)) {            require_once $filename;            $result[$hook]['include files'][] = $filename;          }        }      }      elseif (isset($info['file']) && isset($info['path'])) {        $filename = './'. $info['path'] .'/'. $info['file'];        if (file_exists($filename)) {          require_once $filename;          $result[$hook]['include files'][] = $filename;        }      }      if (isset($info['template']) && !isset($info['path'])) {        $result[$hook]['template'] = $path .'/'. $info['template'];      }      // If 'arguments' have been defined previously, carry them forward.      // This should happen if a theme overrides a Drupal defined theme      // function, for example.      if (!isset($info['arguments']) && isset($cache[$hook])) {        $result[$hook]['arguments'] = $cache[$hook]['arguments'];      }      // Likewise with theme paths. These are used for template naming suggestions.      // Theme implementations can occur in multiple paths. Suggestions should follow.      if (!isset($info['theme paths']) && isset($cache[$hook])) {        $result[$hook]['theme paths'] = $cache[$hook]['theme paths'];      }      // Check for sub-directories.      $result[$hook]['theme paths'][] = isset($info['path']) ? $info['path'] : $path;      // Check for default _preprocess_ functions. Ensure arrayness.      if (!isset($info['preprocess functions']) || !is_array($info['preprocess functions'])) {        $info['preprocess functions'] = array();        $prefixes = array();        if ($type == 'module') {          // Default preprocessor prefix.          $prefixes[] = 'template';          // Add all modules so they can intervene with their own preprocessors. This allows them          // to provide preprocess functions even if they are not the owner of the current hook.          $prefixes += module_list();        }        elseif ($type == 'theme_engine' || $type == 'base_theme_engine') {          // Theme engines get an extra set that come before the normally named preprocessors.          $prefixes[] = $name .'_engine';          // The theme engine also registers on behalf of the theme. The theme or engine name can be used.          $prefixes[] = $name;          $prefixes[] = $theme;        }        else {          // This applies when the theme manually registers their own preprocessors.          $prefixes[] = $name;        }        foreach ($prefixes as $prefix) {          if (function_exists($prefix .'_preprocess')) {            $info['preprocess functions'][] = $prefix .'_preprocess';          }          if (function_exists($prefix .'_preprocess_'. $hook)) {            $info['preprocess functions'][] = $prefix .'_preprocess_'. $hook;          }          if (!empty($info['original hook']) && function_exists($prefix .'_preprocess_'. $info['original hook'])) {            $info['preprocess functions'][] = $prefix .'_preprocess_'. $info['original hook'];          }        }      }      // Check for the override flag and prevent the cached preprocess functions from being used.      // This allows themes or theme engines to remove preprocessors set earlier in the registry build.      if (!empty($info['override preprocess functions'])) {        // Flag not needed inside the registry.        unset($result[$hook]['override preprocess functions']);      }      elseif (isset($cache[$hook]['preprocess functions']) && is_array($cache[$hook]['preprocess functions'])) {        $info['preprocess functions'] = array_merge($cache[$hook]['preprocess functions'], $info['preprocess functions']);      }      elseif (isset($info['original hook']) && isset($cache[$info['original hook']]['preprocess functions']) && is_array($cache[$info['original hook']]['preprocess functions'])) {        $info['preprocess functions'] = array_merge($cache[$info['original hook']]['preprocess functions'], $info['preprocess functions']);      }      $result[$hook]['preprocess functions'] = $info['preprocess functions'];    }    // Merge the newly created theme hooks into the existing cache.    $cache = array_merge($cache, $result);  }  // Let themes have preprocess functions even if they didn't register a template.  if ($type == 'theme' || $type == 'base_theme') {    foreach ($cache as $hook => $info) {      // Check only if it's a template and not registered by the theme or engine.      if (!empty($info['template']) && empty($result[$hook])) {        if (!isset($info['preprocess functions'])) {          $cache[$hook]['preprocess functions'] = array();        }        if (function_exists($name .'_preprocess')) {          $cache[$hook]['preprocess functions'][] = $name .'_preprocess';        }        if (function_exists($name .'_preprocess_'. $hook)) {          $cache[$hook]['preprocess functions'][] = $name .'_preprocess_'. $hook;        }        // Ensure uniqueness.        $cache[$hook]['preprocess functions'] = array_unique($cache[$hook]['preprocess functions']);      }    }  }}/** * Rebuild the hook theme_registry cache. * * @param $theme *   The loaded $theme object. * @param $base_theme *   An array of loaded $theme objects representing the ancestor themes in *   oldest first order. * @param theme_engine *   The name of the theme engine. */function _theme_build_registry($theme, $base_theme, $theme_engine) {  $cache = array();  // First, process the theme hooks advertised by modules. This will  // serve as the basic registry.  foreach (module_implements('theme') as $module) {    _theme_process_registry($cache, $module, 'module', $module, drupal_get_path('module', $module));  }  // Process each base theme.  foreach ($base_theme as $base) {    // If the base theme uses a theme engine, process its hooks.    $base_path = dirname($base->filename);    if ($theme_engine) {      _theme_process_registry($cache, $theme_engine, 'base_theme_engine', $base->name, $base_path);    }    _theme_process_registry($cache, $base->name, 'base_theme', $base->name, $base_path);  }  // And then the same thing, but for the theme.  if ($theme_engine) {    _theme_process_registry($cache, $theme_engine, 'theme_engine', $theme->name, dirname($theme->filename));  }  // Finally, hooks provided by the theme itself.  _theme_process_registry($cache, $theme->name, 'theme', $theme->name, dirname($theme->filename));  // Let modules alter the registry  drupal_alter('theme_registry', $cache);  return $cache;}/** * Provides a list of currently available themes. * * If the database is active then it will be retrieved from the database. * Otherwise it will retrieve a new list. * * @param $refresh *   Whether to reload the list of themes from the database. * @return *   An array of the currently available themes. */function list_themes($refresh = FALSE) {  static $list = array();  if ($refresh) {    $list = array();  }  if (empty($list)) {    $list = array();    $themes = array();    // Extract from the database only when it is available.    // Also check that the site is not in the middle of an install or update.    if (db_is_active() && !defined('MAINTENANCE_MODE')) {      $result = db_query("SELECT * FROM {system} WHERE type = '%s'", 'theme');      while ($theme = db_fetch_object($result)) {        if (file_exists($theme->filename)) {          $theme->info = unserialize($theme->info);          $themes[] = $theme;        }      }    }    else {      // Scan the installation when the database should not be read.      $themes = _system_theme_data();    }    foreach ($themes as $theme) {      foreach ($theme->info['stylesheets'] as $media => $stylesheets) {        foreach ($stylesheets as $stylesheet => $path) {          $theme->stylesheets[$media][$stylesheet] = $path;        }      }      foreach ($theme->info['scripts'] as $script => $path) {        if (file_exists($path)) {          $theme->scripts[$script] = $path;        }      }      if (isset($theme->info['engine'])) {        $theme->engine = $theme->info['engine'];      }      if (isset($theme->info['base theme'])) {        $theme->base_theme = $theme->info['base theme'];      }      // Status is normally retrieved from the database. Add zero values when      // read from the installation directory to prevent notices.      if (!isset($theme->status)) {        $theme->status = 0;      }      $list[$theme->name] = $theme;    }  }  return $list;}/** * Generate the themed output. * * All requests for theme hooks must go through this function. It examines * the request and routes it to the appropriate theme function. The theme * registry is checked to determine which implementation to use, which may * be a function or a template. * * If the implementation is a function, it is executed and its return value * passed along. * * If the implementation is a template, the arguments are converted to a * $variables array. This array is then modified by the module implementing * the hook, theme engine (if applicable) and the theme. The following * functions may be used to modify the $variables array. They are processed in * this order when available: * * - template_preprocess(&$variables) *   This sets a default set of variables for all template implementations. * * - template_preprocess_HOOK(&$variables) *   This is the first preprocessor called specific to the hook; it should be *   implemented by the module that registers it. * * - MODULE_preprocess(&$variables) *   This will be called for all templates; it should only be used if there *   is a real need. It's purpose is similar to template_preprocess(). * * - MODULE_preprocess_HOOK(&$variables) *   This is for modules that want to alter or provide extra variables for *   theming hooks not registered to itself. For example, if a module named *   "foo" wanted to alter the $submitted variable for the hook "node" a *   preprocess function of foo_preprocess_node() can be created to intercept *   and alter the variable. * * - ENGINE_engine_preprocess(&$variables) *   This function should only be implemented by theme engines and exists *   so that it can set necessary variables for all hooks. * * - ENGINE_engine_preprocess_HOOK(&$variables) *   This is the same as the previous function, but it is called for a single *   theming hook. * * - ENGINE_preprocess(&$variables) *   This is meant to be used by themes that utilize a theme engine. It is *   provided so that the preprocessor is not locked into a specific theme. *   This makes it easy to share and transport code but theme authors must be *   careful to prevent fatal re-declaration errors when using sub-themes that *   have their own preprocessor named exactly the same as its base theme. In *   the default theme engine (PHPTemplate), sub-themes will load their own *   template.php file in addition to the one used for its parent theme. This *   increases the risk for these errors. A good practice is to use the engine *   name for the base theme and the theme name for the sub-themes to minimize *   this possibility. * * - ENGINE_preprocess_HOOK(&$variables) *   The same applies from the previous function, but it is called for a *   specific hook. * * - THEME_preprocess(&$variables) *   These functions are based upon the raw theme; they should primarily be *   used by themes that do not use an engine or by sub-themes. It serves the *   same purpose as ENGINE_preprocess(). * * - THEME_preprocess_HOOK(&$variables) *   The same applies from the previous function, but it is called for a *   specific hook. * * There are two special variables that these hooks can set: *   'template_file' and 'template_files'. These will be merged together *   to form a list of 'suggested' alternate template files to use, in *   reverse order of priority. template_file will always be a higher *   priority than items in template_files. theme() will then look for these *   files, one at a time, and use the first one *   that exists. * @param $hook *   The name of the theme function to call. May be an array, in which *   case the first hook that actually has an implementation registered *   will be used. This can be used to choose 'fallback' theme implementations, *   so that if the specific theme hook isn't implemented anywhere, a more *   generic one will be used. This can allow themes to create specific theme *   implementations for named objects. * @param ... *   Additional arguments to pass along to the theme function. * @return *   An HTML string that generates the themed output. */function theme() {  $args = func_get_args();  $hook = array_shift($args);  static $hooks = NULL;  if (!isset($hooks)) {    init_theme();    $hooks = theme_get_registry();  }  if (is_array($hook)) {    foreach ($hook as $candidate) {      if (isset($hooks[$candidate])) {        break;      }    }    $hook = $candidate;  }  if (!isset($hooks[$hook])) {    return;  }  $info = $hooks[$hook];  global $theme_path;  $temp = $theme_path;  // point path_to_theme() to the currently used theme path:  $theme_path = $hooks[$hook]['theme path'];  // Include a file if the theme function or preprocess function is held elsewhere.  if (!empty($info['include files'])) {    foreach ($info['include files'] as $include_file) {      include_once($include_file);    }  }  // Handle compatibility with theme_registry_alters to prevent failures.  if (!empty($info['file'])) {    static $included_files = array();    $include_file = $info['file'];    if (!empty($info['path'])) {      $include_file = $info['path'] .'/'. $include_file;    }    if (empty($included_files[$include_file])) {      // Statically cache files we've already tried to include so we don't      // run unnecessary file_exists calls.      $included_files[$include_file] = TRUE;      if (file_exists('./'. $include_file)) {        include_once('./'. $include_file);      }    }  }  if (isset($info['function'])) {    // The theme call is a function.    $output = call_user_func_array($info['function'], $args);  }  else {    // The theme call is a template.    $variables = array(      'template_files' => array()    );    if (!empty($info['arguments'])) {      $count = 0;      foreach ($info['arguments'] as $name => $default) {        $variables[$name] = isset($args[$count]) ? $args[$count] : $default;        $count++;      }    }    // default render function and extension.    $render_function = 'theme_render_template';    $extension = '.tpl.php';    // Run through the theme engine variables, if necessary    global $theme_engine;    if (isset($theme_engine)) {      // If theme or theme engine is implementing this, it may have      // a different extension and a different renderer.      if ($hooks[$hook]['type'] != 'module') {        if (function_exists($theme_engine .'_render_template')) {          $render_function = $theme_engine .'_render_template';        }        $extension_function = $theme_engine .'_extension';        if (function_exists($extension_function)) {          $extension = $extension_function();        }      }    }    if (isset($info['preprocess functions']) && is_array($info['preprocess functions'])) {      // This construct ensures that we can keep a reference through      // call_user_func_array.      $args = array(&$variables, $hook);      foreach ($info['preprocess functions'] as $preprocess_function) {        if (function_exists($preprocess_function)) {          call_user_func_array($preprocess_function, $args);        }      }    }    // Get suggestions for alternate templates out of the variables    // that were set. This lets us dynamically choose a template    // from a list. The order is FILO, so this array is ordered from    // least appropriate first to most appropriate last.    $suggestions = array();    if (isset($variables['template_files'])) {      $suggestions = $variables['template_files'];    }    if (isset($variables['template_file'])) {      $suggestions[] = $variables['template_file'];    }    if ($suggestions) {      $template_file = drupal_discover_template($info['theme paths'], $suggestions, $extension);    }    if (empty($template_file)) {      $template_file = $hooks[$hook]['template'] . $extension;      if (isset($hooks[$hook]['path'])) {        $template_file = $hooks[$hook]['path'] .'/'. $template_file;      }    }    $output = $render_function($template_file, $variables);  }  // restore path_to_theme()  $theme_path = $temp;  // Add final markup to the full page.  if ($hook == 'page' || $hook == 'book_export_html') {    $output = drupal_final_markup($output);  }  return $output;}/** * Choose which template file to actually render. These are all suggested * templates from themes and modules. Theming implementations can occur on * multiple levels. All paths are checked to account for this. */function drupal_discover_template($paths, $suggestions, $extension = '.tpl.php') {  global $theme_engine;  // Remove slashes or null to prevent files from being included from  // an unexpected location (especially on Windows servers).  $extension = str_replace(array("/", "\\", "\0"), '', $extension);  // Loop through all paths and suggestions in FIFO order.  $suggestions = array_reverse($suggestions);  $paths = array_reverse($paths);  foreach ($suggestions as $suggestion) {    if (!empty($suggestion)) {      $suggestion = str_replace(array("/", "\\", "\0"), '', $suggestion);      foreach ($paths as $path) {        if (file_exists($file = $path .'/'. $suggestion . $extension)) {          return $file;        }      }    }  }}/** * Return the path to the current themed element. * * It can point to the active theme or the module handling a themed implementation. * For example, when invoked within the scope of a theming call it will depend * on where the theming function is handled. If implemented from a module, it * will point to the module. If implemented from the active theme, it will point * to the active theme. When called outside the scope of a theming call, it will * always point to the active theme. */function path_to_theme() {  global $theme_path;  if (!isset($theme_path)) {    init_theme();  }  return $theme_path;}/** * Find overridden theme functions. Called by themes and/or theme engines to * easily discover theme functions. * * @param $cache *   The existing cache of theme hooks to test against. * @param $prefixes *   An array of prefixes to test, in reverse order of importance. * * @return $templates *   The functions found, suitable for returning from hook_theme; */function drupal_find_theme_functions($cache, $prefixes) {  $templates = array();  $functions = get_defined_functions();  foreach ($cache as $hook => $info) {    foreach ($prefixes as $prefix) {      if (!empty($info['pattern'])) {        $matches = preg_grep('/^'. $prefix .'_'. $info['pattern'] .'/', $functions['user']);        if ($matches) {          foreach ($matches as $match) {            $new_hook = str_replace($prefix .'_', '', $match);            $templates[$new_hook] = array(              'function' => $match,              'arguments' => $info['arguments'],              'original hook' => $hook,              'include files' => $info['include files'],            );          }        }      }      if (function_exists($prefix .'_'. $hook)) {        $templates[$hook] = array(          'function' => $prefix .'_'. $hook,          'include files' => $info['include files'],        );        // Ensure that the pattern is maintained from base themes to its sub-themes.        // Each sub-theme will have their functions scanned so the pattern must be        // held for subsequent runs.        if (isset($info['pattern'])) {          $templates[$hook]['pattern'] = $info['pattern'];        }        // Also ensure that the 'file' property is maintained, because it probably        // contains the preprocess.      }    }  }  return $templates;}/** * Find overridden theme templates. Called by themes and/or theme engines to * easily discover templates. * * @param $cache *   The existing cache of theme hooks to test against. * @param $extension *   The extension that these templates will have. * @param $path *   The path to search. */function drupal_find_theme_templates($cache, $extension, $path) {  $templates = array();  // Collect paths to all sub-themes grouped by base themes. These will be  // used for filtering. This allows base themes to have sub-themes in its  // folder hierarchy without affecting the base themes template discovery.  $theme_paths = array();  foreach (list_themes() as $theme_info) {    if (!empty($theme_info->base_theme)) {      $theme_paths[$theme_info->base_theme][$theme_info->name] = dirname($theme_info->filename);    }  }  foreach ($theme_paths as $basetheme => $subthemes) {    foreach ($subthemes as $subtheme => $subtheme_path) {      if (isset($theme_paths[$subtheme])) {        $theme_paths[$basetheme] = array_merge($theme_paths[$basetheme], $theme_paths[$subtheme]);      }    }  }  global $theme;  $subtheme_paths = isset($theme_paths[$theme]) ? $theme_paths[$theme] : array();  // Escape the periods in the extension.  $regex = str_replace('.', '\.', $extension) .'$';  // Because drupal_system_listing works the way it does, we check for real  // templates separately from checking for patterns.  $files = drupal_system_listing($regex, $path, 'name', 0);  foreach ($files as $template => $file) {    // Ignore sub-theme templates for the current theme.    if (strpos($file->filename, str_replace($subtheme_paths, '', $file->filename)) !== 0) {      continue;    }    // Chop off the remaining extensions if there are any. $template already    // has the rightmost extension removed, but there might still be more,    // such as with .tpl.php, which still has .tpl in $template at this point.    if (($pos = strpos($template, '.')) !== FALSE) {      $template = substr($template, 0, $pos);    }    // Transform - in filenames to _ to match function naming scheme    // for the purposes of searching.    $hook = strtr($template, '-', '_');    if (isset($cache[$hook])) {      $templates[$hook] = array(        'template' => $template,        'path' => dirname($file->filename),        'include files' => $cache[$hook]['include files'],      );    }    // Ensure that the pattern is maintained from base themes to its sub-themes.    // Each sub-theme will have their templates scanned so the pattern must be    // held for subsequent runs.    if (isset($cache[$hook]['pattern'])) {      $templates[$hook]['pattern'] = $cache[$hook]['pattern'];    }  }  $patterns = array_keys($files);  foreach ($cache as $hook => $info) {    if (!empty($info['pattern'])) {      // Transform _ in pattern to - to match file naming scheme      // for the purposes of searching.      $pattern = strtr($info['pattern'], '_', '-');      $matches = preg_grep('/^'. $pattern .'/', $patterns);      if ($matches) {        foreach ($matches as $match) {          $file = substr($match, 0, strpos($match, '.'));          // Put the underscores back in for the hook name and register this pattern.          $templates[strtr($file, '-', '_')] = array(            'template' => $file,            'path' => dirname($files[$match]->filename),            'arguments' => $info['arguments'],            'original hook' => $hook,            'include files' => $info['include files'],          );        }      }    }  }  return $templates;}/** * Retrieve an associative array containing the settings for a theme. * * The final settings are arrived at by merging the default settings, * the site-wide settings, and the settings defined for the specific theme. * If no $key was specified, only the site-wide theme defaults are retrieved. * * The default values for each of settings are also defined in this function. * To add new settings, add their default values here, and then add form elements * to system_theme_settings() in system.module. * * @param $key *  The template/style value for a given theme. * * @return *   An associative array containing theme settings. */function theme_get_settings($key = NULL) {  $defaults = array(    'mission'                       =>  '',    'default_logo'                  =>  1,    'logo_path'                     =>  '',    'default_favicon'               =>  1,    'favicon_path'                  =>  '',    'primary_links'                 =>  1,    'secondary_links'               =>  1,    'toggle_logo'                   =>  1,    'toggle_favicon'                =>  1,    'toggle_name'                   =>  1,    'toggle_search'                 =>  1,    'toggle_slogan'                 =>  0,    'toggle_mission'                =>  1,    'toggle_node_user_picture'      =>  0,    'toggle_comment_user_picture'   =>  0,    'toggle_primary_links'          =>  1,    'toggle_secondary_links'        =>  1,  );  if (module_exists('node')) {    foreach (node_get_types() as $type => $name) {      $defaults['toggle_node_info_'. $type] = 1;    }  }  $settings = array_merge($defaults, variable_get('theme_settings', array()));  if ($key) {    $settings = array_merge($settings, variable_get(str_replace('/', '_', 'theme_'. $key .'_settings'), array()));  }  // Only offer search box if search.module is enabled.  if (!module_exists('search') || !user_access('search content')) {    $settings['toggle_search'] = 0;  }  return $settings;}/** * Retrieve a setting for the current theme. * This function is designed for use from within themes & engines * to determine theme settings made in the admin interface. * * Caches values for speed (use $refresh = TRUE to refresh cache) * * @param $setting_name *  The name of the setting to be retrieved. * * @param $refresh *  Whether to reload the cache of settings. * * @return *   The value of the requested setting, NULL if the setting does not exist. */function theme_get_setting($setting_name, $refresh = FALSE) {  global $theme_key;  static $settings;  if (empty($settings) || $refresh) {    $settings = theme_get_settings($theme_key);    $themes = list_themes();    $theme_object = $themes[$theme_key];    if ($settings['mission'] == '') {      $settings['mission'] = variable_get('site_mission', '');    }    if (!$settings['toggle_mission']) {      $settings['mission'] = '';    }    if ($settings['toggle_logo']) {      if ($settings['default_logo']) {        $settings['logo'] = base_path() . dirname($theme_object->filename) .'/logo.png';      }      elseif ($settings['logo_path']) {        $settings['logo'] = base_path() . $settings['logo_path'];      }    }    if ($settings['toggle_favicon']) {      if ($settings['default_favicon']) {        if (file_exists($favicon = dirname($theme_object->filename) .'/favicon.ico')) {          $settings['favicon'] = base_path() . $favicon;        }        else {          $settings['favicon'] = base_path() .'misc/favicon.ico';        }      }      elseif ($settings['favicon_path']) {        $settings['favicon'] = base_path() . $settings['favicon_path'];      }      else {        $settings['toggle_favicon'] = FALSE;      }    }  }  return isset($settings[$setting_name]) ? $settings[$setting_name] : NULL;}/** * Render a system default template, which is essentially a PHP template. * * @param $template_file *   The filename of the template to render. Note that this will overwrite *   anything stored in $variables['template_file'] if using a preprocess hook. * @param $variables *   A keyed array of variables that will appear in the output. * * @return *   The output generated by the template. */function theme_render_template($template_file, $variables) {  extract($variables, EXTR_SKIP);  // Extract the variables to a local namespace  ob_start();                      // Start output buffering  include "./$template_file";      // Include the template file  $contents = ob_get_contents();   // Get the contents of the buffer  ob_end_clean();                  // End buffering and discard  return $contents;                // Return the contents}/** * @defgroup themeable Default theme implementations * @{ * Functions and templates that present output to the user, and can be * implemented by themes. * * Drupal's presentation layer is a pluggable system known as the theme * layer. Each theme can take control over most of Drupal's output, and * has complete control over the CSS. * * Inside Drupal, the theme layer is utilized by the use of the theme() * function, which is passed the name of a component (the theme hook) * and several arguments. For example, theme('table', $header, $rows); * Additionally, the theme() function can take an array of theme * hooks, which can be used to provide 'fallback' implementations to * allow for more specific control of output. For example, the function: * theme(array('table__foo', 'table'), $header, $rows) would look to see if * 'table__foo' is registered anywhere; if it is not, it would 'fall back' * to the generic 'table' implementation. This can be used to attach specific * theme functions to named objects, allowing the themer more control over * specific types of output. * * As of Drupal 6, every theme hook is required to be registered by the * module that owns it, so that Drupal can tell what to do with it and * to make it simple for themes to identify and override the behavior * for these calls. * * The theme hooks are registered via hook_theme(), which returns an * array of arrays with information about the hook. It describes the * arguments the function or template will need, and provides * defaults for the template in case they are not filled in. If the default * implementation is a function, by convention it is named theme_HOOK(). * * Each module should provide a default implementation for theme_hooks that * it registers. This implementation may be either a function or a template; * if it is a function it must be specified via hook_theme(). By convention, * default implementations of theme hooks are named theme_HOOK. Default * template implementations are stored in the module directory. * * Drupal's default template renderer is a simple PHP parsing engine that * includes the template and stores the output. Drupal's theme engines * can provide alternate template engines, such as XTemplate, Smarty and * PHPTal. The most common template engine is PHPTemplate (included with * Drupal and implemented in phptemplate.engine, which uses Drupal's default * template renderer. * * In order to create theme-specific implementations of these hooks, * themes can implement their own version of theme hooks, either as functions * or templates. These implementations will be used instead of the default * implementation. If using a pure .theme without an engine, the .theme is * required to implement its own version of hook_theme() to tell Drupal what * it is implementing; themes utilizing an engine will have their well-named * theming functions automatically registered for them. While this can vary * based upon the theme engine, the standard set by phptemplate is that theme * functions should be named either phptemplate_HOOK or THEMENAME_HOOK. For * example, for Drupal's default theme (Garland) to implement the 'table' hook, * the phptemplate.engine would find phptemplate_table() or garland_table(). * The ENGINE_HOOK() syntax is preferred, as this can be used by sub-themes * (which are themes that share code but use different stylesheets). * * The theme system is described and defined in theme.inc. * * @see theme() * @see hook_theme() *//** * Formats text for emphasized display in a placeholder inside a sentence. * Used automatically by t(). * * @param $text *   The text to format (plain-text). * @return *   The formatted text (html). */function theme_placeholder($text) {  return '<em>'. check_plain($text) .'</em>';}/** * Return a themed set of status and/or error messages. The messages are grouped * by type. * * @param $display *   (optional) Set to 'status' or 'error' to display only messages of that type. * * @return *   A string containing the messages. */function theme_status_messages($display = NULL) {  $output = '';  foreach (drupal_get_messages($display) as $type => $messages) {    $output .= "<div class=\"messages $type\">\n";    if (count($messages) > 1) {      $output .= " <ul>\n";      foreach ($messages as $message) {        $output .= '  <li>'. $message ."</li>\n";      }      $output .= " </ul>\n";    }    else {      $output .= $messages[0];    }    $output .= "</div>\n";  }  return $output;}/** * Return a themed set of links. * * @param $links *   A keyed array of links to be themed. * @param $attributes *   A keyed array of attributes * @return *   A string containing an unordered list of links. */function theme_links($links, $attributes = array('class' => 'links')) {  global $language;  $output = '';  if (count($links) > 0) {    $output = '<ul'. drupal_attributes($attributes) .'>';    $num_links = count($links);    $i = 1;    foreach ($links as $key => $link) {      $class = $key;      // Add first, last and active classes to the list of links to help out themers.      if ($i == 1) {        $class .= ' first';      }      if ($i == $num_links) {        $class .= ' last';      }      if (isset($link['href']) && ($link['href'] == $_GET['q'] || ($link['href'] == '<front>' && drupal_is_front_page()))          && (empty($link['language']) || $link['language']->language == $language->language)) {        $class .= ' active';      }      $output .= '<li'. drupal_attributes(array('class' => $class)) .'>';      if (isset($link['href'])) {        // Pass in $link as $options, they share the same keys.        $output .= l($link['title'], $link['href'], $link);      }      else if (!empty($link['title'])) {        // Some links are actually not links, but we wrap these in <span> for adding title and class attributes        if (empty($link['html'])) {          $link['title'] = check_plain($link['title']);        }        $span_attributes = '';        if (isset($link['attributes'])) {          $span_attributes = drupal_attributes($link['attributes']);        }        $output .= '<span'. $span_attributes .'>'. $link['title'] .'</span>';      }      $i++;      $output .= "</li>\n";    }    $output .= '</ul>';  }  return $output;}/** * Return a themed image. * * @param $path *   Either the path of the image file (relative to base_path()) or a full URL. * @param $alt *   The alternative text for text-based browsers. * @param $title *   The title text is displayed when the image is hovered in some popular browsers. * @param $attributes *   Associative array of attributes to be placed in the img tag. * @param $getsize *   If set to TRUE, the image's dimension are fetched and added as width/height attributes. * @return *   A string containing the image tag. */function theme_image($path, $alt = '', $title = '', $attributes = NULL, $getsize = TRUE) {  if (!$getsize || (is_file($path) && (list($width, $height, $type, $image_attributes) = @getimagesize($path)))) {    $attributes = drupal_attributes($attributes);    $url = (url($path) == $path) ? $path : (base_path() . $path);    return '<img src="'. check_url($url) .'" alt="'. check_plain($alt) .'" title="'. check_plain($title) .'" '. (isset($image_attributes) ? $image_attributes : '') . $attributes .' />';  }}/** * Return a themed breadcrumb trail. * * @param $breadcrumb *   An array containing the breadcrumb links. * @return a string containing the breadcrumb output. */function theme_breadcrumb($breadcrumb) {  if (!empty($breadcrumb)) {    return '<div class="breadcrumb">'. implode('  ', $breadcrumb) .'</div>';  }}/** * Return a themed help message. * * @return a string containing the helptext for the current page. */function theme_help() {  if ($help = menu_get_active_help()) {    return '<div class="help">'. $help .'</div>';  }}/** * Return a themed submenu, typically displayed under the tabs. * * @param $links *   An array of links. */function theme_submenu($links) {  return '<div class="submenu">'. implode(' | ', $links) .'</div>';}/** * Return a themed table. * * @param $header *   An array containing the table headers. Each element of the array can be *   either a localized string or an associative array with the following keys: *   - "data": The localized title of the table column. *   - "field": The database field represented in the table column (required if *     user is to be able to sort on this column). *   - "sort": A default sort order for this column ("asc" or "desc"). *   - Any HTML attributes, such as "colspan", to apply to the column header cell. * @param $rows *   An array of table rows. Every row is an array of cells, or an associative *   array with the following keys: *   - "data": an array of cells *   - Any HTML attributes, such as "class", to apply to the table row. * *   Each cell can be either a string or an associative array with the following keys: *   - "data": The string to display in the table cell. *   - "header": Indicates this cell is a header. *   - Any HTML attributes, such as "colspan", to apply to the table cell. * *   Here's an example for $rows: *   @code *   $rows = array( *     // Simple row *     array( *       'Cell 1', 'Cell 2', 'Cell 3' *     ), *     // Row with attributes on the row and some of its cells. *     array( *       'data' => array('Cell 1', array('data' => 'Cell 2', 'colspan' => 2)), 'class' => 'funky' *     ) *   ); *   @endcode * * @param $attributes *   An array of HTML attributes to apply to the table tag. * @param $caption *   A localized string to use for the <caption> tag. * @return *   An HTML string representing the table. */function theme_table($header, $rows, $attributes = array(), $caption = NULL) {  // Add sticky headers, if applicable.  if (count($header)) {    drupal_add_js('misc/tableheader.js');    // Add 'sticky-enabled' class to the table to identify it for JS.    // This is needed to target tables constructed by this function.    $attributes['class'] = empty($attributes['class']) ? 'sticky-enabled' : ($attributes['class'] .' sticky-enabled');  }  $output = '<table'. drupal_attributes($attributes) .">\n";  if (isset($caption)) {    $output .= '<caption>'. $caption ."</caption>\n";  }  // Format the table header:  if (count($header)) {    $ts = tablesort_init($header);    // HTML requires that the thead tag has tr tags in it followed by tbody    // tags. Using ternary operator to check and see if we have any rows.    $output .= (count($rows) ? ' <thead><tr>' : ' <tr>');    foreach ($header as $cell) {      $cell = tablesort_header($cell, $header, $ts);      $output .= _theme_table_cell($cell, TRUE);    }    // Using ternary operator to close the tags based on whether or not there are rows    $output .= (count($rows) ? " </tr></thead>\n" : "</tr>\n");  }  else {    $ts = array();  }  // Format the table rows:  if (count($rows)) {    $output .= "<tbody>\n";    $flip = array('even' => 'odd', 'odd' => 'even');    $class = 'even';    foreach ($rows as $number => $row) {      $attributes = array();      // Check if we're dealing with a simple or complex row      if (isset($row['data'])) {        foreach ($row as $key => $value) {          if ($key == 'data') {            $cells = $value;          }          else {            $attributes[$key] = $value;          }        }      }      else {        $cells = $row;      }      if (count($cells)) {        // Add odd/even class        $class = $flip[$class];        if (isset($attributes['class'])) {          $attributes['class'] .= ' '. $class;        }        else {          $attributes['class'] = $class;        }        // Build row        $output .= ' <tr'. drupal_attributes($attributes) .'>';        $i = 0;        foreach ($cells as $cell) {          $cell = tablesort_cell($cell, $header, $ts, $i++);          $output .= _theme_table_cell($cell);        }        $output .= " </tr>\n";      }    }    $output .= "</tbody>\n";  }  $output .= "</table>\n";  return $output;}/** * Returns a header cell for tables that have a select all functionality. */function theme_table_select_header_cell() {  drupal_add_js('misc/tableselect.js');  return array('class' => 'select-all');}/** * Return a themed sort icon. * * @param $style *   Set to either asc or desc. This sets which icon to show. * @return *   A themed sort icon. */function theme_tablesort_indicator($style) {  if ($style == "asc") {    return theme('image', 'misc/arrow-asc.png', t('sort icon'), t('sort ascending'));  }  else {    return theme('image', 'misc/arrow-desc.png', t('sort icon'), t('sort descending'));  }}/** * Return a themed box. * * @param $title *   The subject of the box. * @param $content *   The content of the box. * @param $region *   The region in which the box is displayed. * @return *   A string containing the box output. */function theme_box($title, $content, $region = 'main') {  $output = '<h2 class="title">'. $title .'</h2><div>'. $content .'</div>';  return $output;}/** * Return a themed marker, useful for marking new or updated * content. * * @param $type *   Number representing the marker type to display * @see MARK_NEW, MARK_UPDATED, MARK_READ * @return *   A string containing the marker. */function theme_mark($type = MARK_NEW) {  global $user;  if ($user->uid) {    if ($type == MARK_NEW) {      return ' <span class="marker">'. t('new') .'</span>';    }    else if ($type == MARK_UPDATED) {      return ' <span class="marker">'. t('updated') .'</span>';    }  }}/** * Return a themed list of items. * * @param $items *   An array of items to be displayed in the list. If an item is a string, *   then it is used as is. If an item is an array, then the "data" element of *   the array is used as the contents of the list item. If an item is an array *   with a "children" element, those children are displayed in a nested list. *   All other elements are treated as attributes of the list item element. * @param $title *   The title of the list. * @param $type *   The type of list to return (e.g. "ul", "ol") * @param $attributes *   The attributes applied to the list element. * @return *   A string containing the list output. */function theme_item_list($items = array(), $title = NULL, $type = 'ul', $attributes = NULL) {  $output = '<div class="item-list">';  if (isset($title)) {    $output .= '<h3>'. $title .'</h3>';  }  if (!empty($items)) {    $output .= "<$type". drupal_attributes($attributes) .'>';    $num_items = count($items);    foreach ($items as $i => $item) {      $attributes = array();      $children = array();      if (is_array($item)) {        foreach ($item as $key => $value) {          if ($key == 'data') {            $data = $value;          }          elseif ($key == 'children') {            $children = $value;          }          else {            $attributes[$key] = $value;          }        }      }      else {        $data = $item;      }      if (count($children) > 0) {        $data .= theme_item_list($children, NULL, $type, $attributes); // Render nested list      }      if ($i == 0) {        $attributes['class'] = empty($attributes['class']) ? 'first' : ($attributes['class'] .' first');      }      if ($i == $num_items - 1) {        $attributes['class'] = empty($attributes['class']) ? 'last' : ($attributes['class'] .' last');      }      $output .= '<li'. drupal_attributes($attributes) .'>'. $data ."</li>\n";    }    $output .= "</$type>";  }  $output .= '</div>';  return $output;}/** * Returns code that emits the 'more help'-link. */function theme_more_help_link($url) {  return '<div class="more-help-link">'. t('[<a href="@link">more help...</a>]', array('@link' => check_url($url))) .'</div>';}/** * Return code that emits an XML icon. * * For most use cases, this function has been superseded by theme_feed_icon(). * * @see theme_feed_icon() * @param $url *   The url of the feed. */function theme_xml_icon($url) {  if ($image = theme('image', 'misc/xml.png', t('XML feed'), t('XML feed'))) {    return '<a href="'. check_url($url) .'" class="xml-icon">'. $image .'</a>';  }}/** * Return code that emits an feed icon. * * @param $url *   The url of the feed. * @param $title *   A descriptive title of the feed.  */function theme_feed_icon($url, $title) {  if ($image = theme('image', 'misc/feed.png', t('Syndicate content'), $title)) {    return '<a href="'. check_url($url) .'" class="feed-icon">'. $image .'</a>';  }}/** * Returns code that emits the 'more' link used on blocks. * * @param $url *   The url of the main page * @param $title *   A descriptive verb for the link, like 'Read more' */function theme_more_link($url, $title) {  return '<div class="more-link">'. t('<a href="@link" title="@title">more</a>', array('@link' => check_url($url), '@title' => $title)) .'</div>';}/** * Execute hook_footer() which is run at the end of the page right before the * close of the body tag. * * @param $main (optional) *   Whether the current page is the front page of the site. * @return *   A string containing the results of the hook_footer() calls. */function theme_closure($main = 0) {  $footer = module_invoke_all('footer', $main);  return implode("\n", $footer) . drupal_get_js('footer');}/** * Return a set of blocks available for the current user. * * @param $region *   Which set of blocks to retrieve. * @return *   A string containing the themed blocks for this region. */function theme_blocks($region) {  $output = '';  if ($list = block_list($region)) {    foreach ($list as $key => $block) {      // $key == <i>module</i>_<i>delta</i>      $output .= theme('block', $block);    }  }  // Add any content assigned to this region through drupal_set_content() calls.  $output .= drupal_get_content($region);  return $output;}/** * Format a username. * * @param $object *   The user object to format, usually returned from user_load(). * @return *   A string containing an HTML link to the user's page if the passed object *   suggests that this is a site user. Otherwise, only the username is returned. */function theme_username($object) {  if ($object->uid && $object->name) {    // Shorten the name when it is too long or it will break many tables.    if (drupal_strlen($object->name) > 20) {      $name = drupal_substr($object->name, 0, 15) .'...';    }    else {      $name = $object->name;    }    if (user_access('access user profiles')) {      $output = l($name, 'user/'. $object->uid, array('attributes' => array('title' => t('View user profile.'))));    }    else {      $output = check_plain($name);    }  }  else if ($object->name) {    // Sometimes modules display content composed by people who are    // not registered members of the site (e.g. mailing list or news    // aggregator modules). This clause enables modules to display    // the true author of the content.    if (!empty($object->homepage)) {      $output = l($object->name, $object->homepage, array('attributes' => array('rel' => 'nofollow')));    }    else {      $output = check_plain($object->name);    }    $output .= ' ('. t('not verified') .')';  }  else {    $output = check_plain(variable_get('anonymous', t('Anonymous')));  }  return $output;}/** * Return a themed progress bar. * * @param $percent *   The percentage of the progress. * @param $message *   A string containing information to be displayed. * @return *   A themed HTML string representing the progress bar. */function theme_progress_bar($percent, $message) {  $output = '<div id="progress" class="progress">';  $output .= '<div class="bar"><div class="filled" style="width: '. $percent .'%"></div></div>';  $output .= '<div class="percentage">'. $percent .'%</div>';  $output .= '<div class="message">'. $message .'</div>';  $output .= '</div>';  return $output;}/** * Create a standard indentation div. Used for drag and drop tables. * * @param $size *   Optional. The number of indentations to create. * @return *   A string containing indentations. */function theme_indentation($size = 1) {  $output = '';  for ($n = 0; $n < $size; $n++) {    $output .= '<div class="indentation">&nbsp;</div>';  }  return $output;}/** * @} End of "defgroup themeable". */function _theme_table_cell($cell, $header = FALSE) {  $attributes = '';  if (is_array($cell)) {    $data = isset($cell['data']) ? $cell['data'] : '';    $header |= isset($cell['header']);    unset($cell['data']);    unset($cell['header']);    $attributes = drupal_attributes($cell);  }  else {    $data = $cell;  }  if ($header) {    $output = "<th$attributes>$data</th>";  }  else {    $output = "<td$attributes>$data</td>";  }  return $output;}/** * Adds a default set of helper variables for preprocess functions and * templates. This comes in before any other preprocess function which makes * it possible to be used in default theme implementations (non-overriden * theme functions). */function template_preprocess(&$variables, $hook) {  global $user;  static $count = array();  // Track run count for each hook to provide zebra striping.  // See "template_preprocess_block()" which provides the same feature specific to blocks.  $count[$hook] = isset($count[$hook]) && is_int($count[$hook]) ? $count[$hook] : 1;  $variables['zebra'] = ($count[$hook] % 2) ? 'odd' : 'even';  $variables['id'] = $count[$hook]++;  // Tell all templates where they are located.  $variables['directory'] = path_to_theme();  // Set default variables that depend on the database.  $variables['is_admin']            = FALSE;  $variables['is_front']            = FALSE;  $variables['logged_in']           = FALSE;  if ($variables['db_is_active'] = db_is_active()  && !defined('MAINTENANCE_MODE')) {    // Check for administrators.    if (user_access('access administration pages')) {      $variables['is_admin'] = TRUE;    }    // Flag front page status.    $variables['is_front'] = drupal_is_front_page();    // Tell all templates by which kind of user they're viewed.    $variables['logged_in'] = ($user->uid > 0);    // Provide user object to all templates    $variables['user'] = $user;  }}/** * Process variables for page.tpl.php * * Most themes utilize their own copy of page.tpl.php. The default is located * inside "modules/system/page.tpl.php". Look in there for the full list of * variables. * * Uses the arg() function to generate a series of page template suggestions * based on the current path. * * Any changes to variables in this preprocessor should also be changed inside * template_preprocess_maintenance_page() to keep all them consistent. * * The $variables array contains the following arguments: * - $content * - $show_blocks * * @see page.tpl.php */function template_preprocess_page(&$variables) {  // Add favicon  if (theme_get_setting('toggle_favicon')) {    drupal_set_html_head('<link rel="shortcut icon" href="'. check_url(theme_get_setting('favicon')) .'" type="image/x-icon" />');  }  global $theme;  // Populate all block regions.  $regions = system_region_list($theme);  // Load all region content assigned via blocks.  foreach (array_keys($regions) as $region) {    // Prevent left and right regions from rendering blocks when 'show_blocks' == FALSE.    if (!(!$variables['show_blocks'] && ($region == 'left' || $region == 'right'))) {      $blocks = theme('blocks', $region);    }    else {      $blocks = '';    }    // Assign region to a region variable.    isset($variables[$region]) ? $variables[$region] .= $blocks : $variables[$region] = $blocks;  }  // Set up layout variable.  $variables['layout'] = 'none';  if (!empty($variables['left'])) {    $variables['layout'] = 'left';  }  if (!empty($variables['right'])) {    $variables['layout'] = ($variables['layout'] == 'left') ? 'both' : 'right';  }  // Set mission when viewing the frontpage.  if (drupal_is_front_page()) {    $mission = filter_xss_admin(theme_get_setting('mission'));  }  // Construct page title  if (drupal_get_title()) {    $head_title = array(strip_tags(drupal_get_title()), variable_get('site_name', 'Drupal'));  }  else {    $head_title = array(variable_get('site_name', 'Drupal'));    if (variable_get('site_slogan', '')) {      $head_title[] = variable_get('site_slogan', '');    }  }  $variables['head_title']        = implode(' | ', $head_title);  $variables['base_path']         = base_path();  $variables['front_page']        = url();  $variables['breadcrumb']        = theme('breadcrumb', drupal_get_breadcrumb());  $variables['feed_icons']        = drupal_get_feeds();  $variables['footer_message']    = filter_xss_admin(variable_get('site_footer', FALSE));  $variables['head']              = drupal_get_html_head();  $variables['help']              = theme('help');  $variables['language']          = $GLOBALS['language'];  $variables['language']->dir     = $GLOBALS['language']->direction ? 'rtl' : 'ltr';  $variables['logo']              = theme_get_setting('logo');  $variables['messages']          = $variables['show_messages'] ? theme('status_messages') : '';  $variables['mission']           = isset($mission) ? $mission : '';  $variables['primary_links']     = theme_get_setting('toggle_primary_links') ? menu_primary_links() : array();  $variables['secondary_links']   = theme_get_setting('toggle_secondary_links') ? menu_secondary_links() : array();  $variables['search_box']        = (theme_get_setting('toggle_search') ? drupal_get_form('search_theme_form') : '');  $variables['site_name']         = (theme_get_setting('toggle_name') ? filter_xss_admin(variable_get('site_name', 'Drupal')) : '');  $variables['site_slogan']       = (theme_get_setting('toggle_slogan') ? filter_xss_admin(variable_get('site_slogan', '')) : '');  $variables['css']               = drupal_add_css();  $variables['styles']            = drupal_get_css();  $variables['scripts']           = drupal_get_js();  $variables['tabs']              = theme('menu_local_tasks');  $variables['title']             = drupal_get_title();  // Closure should be filled last.  $variables['closure']           = theme('closure');  if ($node = menu_get_object()) {    $variables['node'] = $node;  }  // Compile a list of classes that are going to be applied to the body element.  // This allows advanced theming based on context (home page, node of certain type, etc.).  $body_classes = array();  // Add a class that tells us whether we're on the front page or not.  $body_classes[] = $variables['is_front'] ? 'front' : 'not-front';  // Add a class that tells us whether the page is viewed by an authenticated user or not.  $body_classes[] = $variables['logged_in'] ? 'logged-in' : 'not-logged-in';  // Add arg(0) to make it possible to theme the page depending on the current page  // type (e.g. node, admin, user, etc.). To avoid illegal characters in the class,  // we're removing everything disallowed. We are not using 'a-z' as that might leave  // in certain international characters (e.g. German umlauts).  $body_classes[] = preg_replace('![^abcdefghijklmnopqrstuvwxyz0-9-_]+!s', '', 'page-'. form_clean_id(drupal_strtolower(arg(0))));  // If on an individual node page, add the node type.  if (isset($variables['node']) && $variables['node']->type) {    $body_classes[] = 'node-type-'. form_clean_id($variables['node']->type);  }  // Add information about the number of sidebars.  if ($variables['layout'] == 'both') {    $body_classes[] = 'two-sidebars';  }  elseif ($variables['layout'] == 'none') {    $body_classes[] = 'no-sidebars';  }  else {    $body_classes[] = 'one-sidebar sidebar-'. $variables['layout'];  }  // Implode with spaces.  $variables['body_classes'] = implode(' ', $body_classes);  // Build a list of suggested template files in order of specificity. One  // suggestion is made for every element of the current path, though  // numeric elements are not carried to subsequent suggestions. For example,  // http://www.example.com/node/1/edit would result in the following  // suggestions:  //  // page-node-edit.tpl.php  // page-node-1.tpl.php  // page-node.tpl.php  // page.tpl.php  $i = 0;  $suggestion = 'page';  $suggestions = array();  while ($arg = arg($i++)) {    $arg = str_replace(array("/", "\\", "\0"), '', $arg);    $suggestions[] = $suggestion .'-'. $arg;    if (!is_numeric($arg)) {      $suggestion .= '-'. $arg;    }  }  if (drupal_is_front_page()) {    $suggestions[] = 'page-front';  }  if ($suggestions) {    $variables['template_files'] = $suggestions;  }}/** * Process variables for node.tpl.php * * Most themes utilize their own copy of node.tpl.php. The default is located * inside "modules/node/node.tpl.php". Look in there for the full list of * variables. * * The $variables array contains the following arguments: * - $node * - $teaser * - $page * * @see node.tpl.php */function template_preprocess_node(&$variables) {  $node = $variables['node'];  if (module_exists('taxonomy')) {    $variables['taxonomy'] = taxonomy_link('taxonomy terms', $node);  }  else {    $variables['taxonomy'] = array();  }  if ($variables['teaser'] && $node->teaser) {    $variables['content'] = $node->teaser;  }  elseif (isset($node->body)) {    $variables['content'] = $node->body;  }  else {    $variables['content'] = '';  }  $variables['date']      = format_date($node->created);  $variables['links']     = !empty($node->links) ? theme('links', $node->links, array('class' => 'links inline')) : '';  $variables['name']      = theme('username', $node);  $variables['node_url']  = url('node/'. $node->nid);  $variables['terms']     = theme('links', $variables['taxonomy'], array('class' => 'links inline'));  $variables['title']     = check_plain($node->title);  // Flatten the node object's member fields.  $variables = array_merge((array)$node, $variables);  // Display info only on certain node types.  if (theme_get_setting('toggle_node_info_'. $node->type)) {    $variables['submitted'] = theme('node_submitted', $node);    $variables['picture'] = theme_get_setting('toggle_node_user_picture') ? theme('user_picture', $node) : '';  }  else {    $variables['submitted'] = '';    $variables['picture'] = '';  }  // Clean up name so there are no underscores.  $variables['template_files'][] = 'node-'. $node->type;}/** * Process variables for block.tpl.php * * Prepare the values passed to the theme_block function to be passed * into a pluggable template engine. Uses block properties to generate a * series of template file suggestions. If none are found, the default * block.tpl.php is used. * * Most themes utilize their own copy of block.tpl.php. The default is located * inside "modules/system/block.tpl.php". Look in there for the full list of * variables. * * The $variables array contains the following arguments: * - $block * * @see block.tpl.php */function template_preprocess_block(&$variables) {  static $block_counter = array();  // All blocks get an independent counter for each region.  if (!isset($block_counter[$variables['block']->region])) {    $block_counter[$variables['block']->region] = 1;  }  // Same with zebra striping.  $variables['block_zebra'] = ($block_counter[$variables['block']->region] % 2) ? 'odd' : 'even';  $variables['block_id'] = $block_counter[$variables['block']->region]++;  $variables['template_files'][] = 'block-'. $variables['block']->region;  $variables['template_files'][] = 'block-'. $variables['block']->module;  $variables['template_files'][] = 'block-'. $variables['block']->module .'-'. $variables['block']->delta;}
<?php// $Id$/** * @file * Admin page callbacks for the contact module. *//** * Categories/list tab. */function contact_admin_categories() {  $result = db_query('SELECT cid, category, recipients, selected FROM {contact} ORDER BY weight, category');  $rows = array();  while ($category = db_fetch_object($result)) {    $rows[] = array(check_plain($category->category), check_plain($category->recipients), ($category->selected ? t('Yes') : t('No')), l(t('edit'), 'admin/build/contact/edit/'. $category->cid), l(t('delete'), 'admin/build/contact/delete/'. $category->cid));  }  $header = array(t('Category'), t('Recipients'), t('Selected'), array('data' => t('Operations'), 'colspan' => 2));  return theme('table', $header, $rows);}/** * Category edit page. */function contact_admin_edit($form_state = array(), $op, $contact = NULL) {  if (empty($contact) || $op == 'add') {    $contact = array(      'category' => '',      'recipients' => '',      'reply' => '',      'weight' => 0,      'selected' => 0,      'cid' => NULL,    );  }  $form['contact_op'] = array('#type' => 'value', '#value' => $op);  $form['category'] = array('#type' => 'textfield',    '#title' => t('Category'),    '#maxlength' => 255,    '#default_value' => $contact['category'],    '#description' => t("Example: 'website feedback' or 'product information'."),    '#required' => TRUE,  );  $form['recipients'] = array('#type' => 'textarea',    '#title' => t('Recipients'),    '#default_value' => $contact['recipients'],    '#description' => t("Example: 'webmaster@example.com' or 'sales@example.com,support@example.com'. To specify multiple recipients, separate each e-mail address with a comma."),    '#required' => TRUE,  );  $form['reply'] = array('#type' => 'textarea',    '#title' => t('Auto-reply'),    '#default_value' => $contact['reply'],    '#description' => t('Optional auto-reply. Leave empty if you do not want to send the user an auto-reply message.'),  );  $form['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $contact['weight'],    '#description' => t('When listing categories, those with lighter (smaller) weights get listed before categories with heavier (larger) weights. Categories with equal weights are sorted alphabetically.'),  );  $form['selected'] = array('#type' => 'select',    '#title' => t('Selected'),    '#options' => array('0' => t('No'), '1' => t('Yes')),    '#default_value' => $contact['selected'],    '#description' => t('Set this to <em>Yes</em> if you would like this category to be selected by default.'),  );  $form['cid'] = array('#type' => 'value',    '#value' => $contact['cid'],  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Save'),  );  return $form;}/** * Validate the contact category edit page form submission. */function contact_admin_edit_validate($form, &$form_state) {  if (empty($form_state['values']['category'])) {    form_set_error('category', t('You must enter a category.'));  }  if (empty($form_state['values']['recipients'])) {    form_set_error('recipients', t('You must enter one or more recipients.'));  }  else {    $recipients = explode(',', $form_state['values']['recipients']);    foreach ($recipients as $recipient) {      if (!valid_email_address(trim($recipient))) {        form_set_error('recipients', t('%recipient is an invalid e-mail address.', array('%recipient' => $recipient)));      }    }  }}/** * Process the contact category edit page form submission. */function contact_admin_edit_submit($form, &$form_state) {  if ($form_state['values']['selected']) {    // Unselect all other contact categories.    db_query('UPDATE {contact} SET selected = 0');  }  $recipients = explode(',', $form_state['values']['recipients']);  foreach ($recipients as $key => $recipient) {    // E-mail address validation has already been done in _validate.    $recipients[$key] = trim($recipient);  }  $form_state['values']['recipients'] = implode(',', $recipients);  if (empty($form_state['values']['cid']) || $form_state['values']['contact_op'] == 'add') {    drupal_write_record('contact', $form_state['values']);    drupal_set_message(t('Category %category has been added.', array('%category' => $form_state['values']['category'])));    watchdog('mail', 'Contact form: category %category added.', array('%category' => $form_state['values']['category']), WATCHDOG_NOTICE, l(t('view'), 'admin/build/contact'));  }  else {    drupal_write_record('contact', $form_state['values'], 'cid');    drupal_set_message(t('Category %category has been updated.', array('%category' => $form_state['values']['category'])));    watchdog('mail', 'Contact form: category %category updated.', array('%category' => $form_state['values']['category']), WATCHDOG_NOTICE, l(t('view'), 'admin/build/contact'));  }  $form_state['redirect'] = 'admin/build/contact';  return;}/** * Category delete page. */function contact_admin_delete(&$form_state, $contact) {  $form['contact'] = array(    '#type' => 'value',    '#value' => $contact,  );  return confirm_form($form, t('Are you sure you want to delete %category?', array('%category' => $contact['category'])), 'admin/build/contact', t('This action cannot be undone.'), t('Delete'), t('Cancel'));}/** * Process category delete form submission. */function contact_admin_delete_submit($form, &$form_state) {  $contact = $form_state['values']['contact'];  db_query("DELETE FROM {contact} WHERE cid = %d", $contact['cid']);  drupal_set_message(t('Category %category has been deleted.', array('%category' => $contact['category'])));  watchdog('mail', 'Contact form: category %category deleted.', array('%category' => $contact['category']), WATCHDOG_NOTICE);  $form_state['redirect'] = 'admin/build/contact';  return;}function contact_admin_settings() {  $form['contact_form_information'] = array('#type' => 'textarea',    '#title' => t('Additional information'),    '#default_value' => variable_get('contact_form_information', t('You can leave a message using the contact form below.')),    '#description' => t('Information to show on the <a href="@form">contact page</a>. Can be anything from submission guidelines to your postal address or telephone number.', array('@form' => url('contact'))),  );  $form['contact_hourly_threshold'] = array('#type' => 'select',    '#title' => t('Hourly threshold'),    '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50)),    '#default_value' => variable_get('contact_hourly_threshold', 3),    '#description' => t('The maximum number of contact form submissions a user can perform per hour.'),  );  $form['contact_default_status'] = array(    '#type' => 'checkbox',    '#title' => t('Enable personal contact form by default'),    '#default_value' => variable_get('contact_default_status', 1),    '#description' => t('Default status of the personal contact form for new users.'),  );  return system_settings_form($form);}
<?php// $Id$/** * @file * API for manipulating images. *//** * @defgroup image Image toolkits * @{ * Drupal's image toolkits provide an abstraction layer for common image file * manipulations like scaling, cropping, and rotating. The abstraction frees * module authors from the need to support multiple image libraries, and it * allows site administrators to choose the library that's best for them. * * PHP includes the GD library by default so a GD toolkit is installed with * Drupal. Other toolkits like ImageMagic are available from contrib modules. * GD works well for small images, but using it with larger files may cause PHP * to run out of memory. In contrast the ImageMagick library does not suffer * from this problem, but it requires the ISP to have installed additional * software. * * Image toolkits are installed by copying the image.ToolkitName.inc file into * Drupal's includes directory. The toolkit must then be enabled using the * admin/settings/image-toolkit form. * * Only one toolkit maybe selected at a time. If a module author wishes to call * a specific toolkit they can check that it is installed by calling * image_get_available_toolkits(), and then calling its functions directly. *//** * Return a list of available toolkits. * * @return *   An array of toolkit name => descriptive title. */function image_get_available_toolkits() {  $toolkits = file_scan_directory('includes', 'image\..*\.inc$');  $output = array();  foreach ($toolkits as $file => $toolkit) {    include_once "./$file";    $function = str_replace('.', '_', $toolkit->name) .'_info';    if (function_exists($function)) {      $info = $function();      $output[$info['name']] = $info['title'];    }  }  return $output;}/** * Retrieve the name of the currently used toolkit. * * @return *   String containing the name of the selected toolkit, or FALSE on error. */function image_get_toolkit() {  static $toolkit;  if (!$toolkit) {    $toolkit = variable_get('image_toolkit', 'gd');    $toolkit_file = './includes/image.'. $toolkit .'.inc';    if (isset($toolkit) && file_exists($toolkit_file)) {      include_once $toolkit_file;    }    elseif (!image_gd_check_settings()) {      $toolkit = FALSE;    }  }  return $toolkit;}/** * Invokes the given method using the currently selected toolkit. * * @param $method *   A string containing the method to invoke. * @param $params *   An optional array of parameters to pass to the toolkit method. * @return *   Mixed values (typically Boolean indicating successful operation). */function image_toolkit_invoke($method, $params = array()) {  if ($toolkit = image_get_toolkit()) {    $function = 'image_'. $toolkit .'_'. $method;    if (function_exists($function)) {      return call_user_func_array($function, $params);    }    else {      watchdog('php', 'The selected image handling toolkit %toolkit can not correctly process %function.', array('%toolkit' => $toolkit, '%function' => $function), WATCHDOG_ERROR);      return FALSE;    }  }}/** * Get details about an image. * * Drupal only supports GIF, JPG and PNG file formats. * * @return *   FALSE, if the file could not be found or is not an image. Otherwise, a *   keyed array containing information about the image: *    'width'     - Width in pixels. *    'height'    - Height in pixels. *    'extension' - Commonly used file extension for the image. *    'mime_type' - MIME type ('image/jpeg', 'image/gif', 'image/png'). *    'file_size' - File size in bytes. */function image_get_info($file) {  if (!is_file($file)) {    return FALSE;  }  $details = FALSE;  $data = @getimagesize($file);  $file_size = @filesize($file);  if (isset($data) && is_array($data)) {    $extensions = array('1' => 'gif', '2' => 'jpg', '3' => 'png');    $extension = array_key_exists($data[2], $extensions) ?  $extensions[$data[2]] : '';    $details = array('width'     => $data[0],                     'height'    => $data[1],                     'extension' => $extension,                     'file_size' => $file_size,                     'mime_type' => $data['mime']);  }  return $details;}/** * Scales an image to the exact width and height given. Achieves the * target aspect ratio by cropping the original image equally on both * sides, or equally on the top and bottom.  This function is, for * example, useful to create uniform sized avatars from larger images. * * The resulting image always has the exact target dimensions. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels. * @return *   TRUE or FALSE, based on success. */function image_scale_and_crop($source, $destination, $width, $height) {  $info = image_get_info($source);  $scale = max($width / $info['width'], $height / $info['height']);  $x = round(($info['width'] * $scale - $width) / 2);  $y = round(($info['height'] * $scale - $height) / 2);  if (image_toolkit_invoke('resize', array($source, $destination, $info['width'] * $scale, $info['height'] * $scale))) {    return image_toolkit_invoke('crop', array($destination, $destination, $x, $y, $width, $height));  }  return FALSE;}/** * Scales an image to the given width and height while maintaining aspect * ratio. * * The resulting image can be smaller for one or both target dimensions. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels. * @return *   TRUE or FALSE, based on success. */function image_scale($source, $destination, $width, $height) {  $info = image_get_info($source);  // Don't scale up.  if ($width >= $info['width'] && $height >= $info['height']) {    return FALSE;  }  $aspect = $info['height'] / $info['width'];  if ($aspect < $height / $width) {    $width = (int)min($width, $info['width']);    $height = (int)round($width * $aspect);  }  else {    $height = (int)min($height, $info['height']);    $width = (int)round($height / $aspect);  }  return image_toolkit_invoke('resize', array($source, $destination, $width, $height));}/** * Resize an image to the given dimensions (ignoring aspect ratio). * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels.  * @return *   TRUE or FALSE, based on success. */function image_resize($source, $destination, $width, $height) {  return image_toolkit_invoke('resize', array($source, $destination, $width, $height));}/** * Rotate an image by the given number of degrees. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $degrees *   The number of (clockwise) degrees to rotate the image. * @param $background *   An hexidecimal integer specifying the background color to use for the *   uncovered area of the image after the rotation. E.g. 0x000000 for black, *   0xff00ff for magenta, and 0xffffff for white. * @return *   TRUE or FALSE, based on success. */function image_rotate($source, $destination, $degrees, $background = 0x000000) {  return image_toolkit_invoke('rotate', array($source, $destination, $degrees, $background));}/** * Crop an image to the rectangle specified by the given rectangle. * * @param $source *   The file path of the source image. * @param $destination *   The file path of the destination image. * @param $x *   The top left co-ordinate, in pixels, of the crop area (x axis value). * @param $y *   The top left co-ordinate, in pixels, of the crop area (y axis value). * @param $width *   The target width, in pixels. * @param $height *   The target height, in pixels. * @return *   TRUE or FALSE, based on success. */function image_crop($source, $destination, $x, $y, $width, $height) {  return image_toolkit_invoke('crop', array($source, $destination, $x, $y, $width, $height));}/** * @} End of "defgroup image". */
<?php// $Id$define('SCHEMA_UNINSTALLED', -1);define('SCHEMA_INSTALLED', 0);define('REQUIREMENT_INFO', -1);define('REQUIREMENT_OK', 0);define('REQUIREMENT_WARNING', 1);define('REQUIREMENT_ERROR', 2);define('FILE_EXIST',          1);define('FILE_READABLE',       2);define('FILE_WRITABLE',       4);define('FILE_EXECUTABLE',     8);define('FILE_NOT_EXIST',      16);define('FILE_NOT_READABLE',   32);define('FILE_NOT_WRITABLE',   64);define('FILE_NOT_EXECUTABLE', 128);/** * Initialize the update system by loading all installed module's .install files. */function drupal_load_updates() {  foreach (drupal_get_installed_schema_version(NULL, FALSE, TRUE) as $module => $schema_version) {    if ($schema_version > -1) {      module_load_install($module);    }  }}/** * Returns an array of available schema versions for a module. * * @param $module *   A module name. * @return *   If the module has updates, an array of available updates sorted by version.  *   Otherwise, FALSE. */function drupal_get_schema_versions($module) {  $updates = array();  $functions = get_defined_functions();  foreach ($functions['user'] as $function) {    if (strpos($function, $module .'_update_') === 0) {      $version = substr($function, strlen($module .'_update_'));      if (is_numeric($version)) {        $updates[] = $version;      }    }  }  if (count($updates) == 0) {    return FALSE;  }  sort($updates, SORT_NUMERIC);  return $updates;}/** * Returns the currently installed schema version for a module. * * @param $module *   A module name. * @param $reset *   Set to TRUE after modifying the system table. * @param $array *   Set to TRUE if you want to get information about all modules in the *   system. * @return *   The currently installed schema version. */function drupal_get_installed_schema_version($module, $reset = FALSE, $array = FALSE) {  static $versions = array();  if ($reset) {    $versions = array();  }  if (!$versions) {    $versions = array();    $result = db_query("SELECT name, schema_version FROM {system} WHERE type = '%s'", 'module');    while ($row = db_fetch_object($result)) {      $versions[$row->name] = $row->schema_version;    }  }  return $array ? $versions : $versions[$module];}/** * Update the installed version information for a module. * * @param $module *   A module name. * @param $version *   The new schema version. */function drupal_set_installed_schema_version($module, $version) {  db_query("UPDATE {system} SET schema_version = %d WHERE name = '%s'", $version, $module);}/** * Loads the profile definition, extracting the profile's defined name. * * @return *   The name defined in the profile's _profile_details() hook. */function drupal_install_profile_name() {  global $profile;  static $name = NULL;  if (!isset($name)) {    // Load profile details.    $function = $profile .'_profile_details';    if (function_exists($function)) {      $details = $function();    }    $name = isset($details['name']) ? $details['name'] : 'Drupal';  }  return $name;}/** * Auto detect the base_url with PHP predefined variables. * * @param $file *   The name of the file calling this function so we can strip it out of *   the URI when generating the base_url. * * @return *   The auto-detected $base_url that should be configured in settings.php */function drupal_detect_baseurl($file = 'install.php') {  global $profile;  $proto = $_SERVER['HTTPS'] ? 'https://' : 'http://';  $host = $_SERVER['SERVER_NAME'];  $port = ($_SERVER['SERVER_PORT'] == 80 ? '' : ':'. $_SERVER['SERVER_PORT']);  $uri = preg_replace("/\?.*/", '', $_SERVER['REQUEST_URI']);  $dir = str_replace("/$file", '', $uri);  return "$proto$host$port$dir";}/** * Detect all databases supported by Drupal that are compiled into the current * PHP installation. * * @return *  An array of database types compiled into PHP. */function drupal_detect_database_types() {  $databases = array();  foreach (array('mysql', 'mysqli', 'pgsql') as $type) {    if (file_exists('./includes/install.'. $type .'.inc')) {      include_once './includes/install.'. $type .'.inc';      $function = $type .'_is_available';      if ($function()) {        $databases[$type] = $type;      }    }  }  return $databases;}/** * Read settings.php into a buffer line by line, changing values specified in * $settings array, then over-writing the old settings.php file. * * @param $settings *   An array of settings that need to be updated. */function drupal_rewrite_settings($settings = array(), $prefix = '') {  $default_settings = './sites/default/default.settings.php';  $settings_file = './'. conf_path(FALSE, TRUE) .'/'. $prefix .'settings.php';  // Build list of setting names and insert the values into the global namespace.  $keys = array();  foreach ($settings as $setting => $data) {    $GLOBALS[$setting] = $data['value'];    $keys[] = $setting;  }  $buffer = NULL;  $first = TRUE;  if ($fp = fopen($default_settings, 'r')) {    // Step line by line through settings.php.    while (!feof($fp)) {      $line = fgets($fp);      if ($first && substr($line, 0, 5) != '<?php') {        $buffer = "<?php\n\n";      }      $first = FALSE;      // Check for constants.      if (substr($line, 0, 7) == 'define(') {        preg_match('/define\(\s*[\'"]([A-Z_-]+)[\'"]\s*,(.*?)\);/', $line, $variable);        if (in_array($variable[1], $keys)) {          $setting = $settings[$variable[1]];          $buffer .= str_replace($variable[2], " '". $setting['value'] ."'", $line);          unset($settings[$variable[1]]);          unset($settings[$variable[2]]);        }        else {          $buffer .= $line;        }      }      // Check for variables.      elseif (substr($line, 0, 1) == '$') {        preg_match('/\$([^ ]*) /', $line, $variable);        if (in_array($variable[1], $keys)) {          // Write new value to settings.php in the following format:          //    $'setting' = 'value'; // 'comment'          $setting = $settings[$variable[1]];          $buffer .= '$'. $variable[1] ." = '". $setting['value'] ."';". (!empty($setting['comment']) ? ' // '. $setting['comment'] ."\n" : "\n");          unset($settings[$variable[1]]);        }        else {          $buffer .= $line;        }      }      else {        $buffer .= $line;      }    }    fclose($fp);    // Add required settings that were missing from settings.php.    foreach ($settings as $setting => $data) {      if ($data['required']) {        $buffer .= "\$$setting = '". $data['value'] ."';\n";      }    }    $fp = fopen($settings_file, 'w');    if ($fp && fwrite($fp, $buffer) === FALSE) {      drupal_set_message(st('Failed to modify %settings, please verify the file permissions.', array('%settings' => $settings_file)), 'error');    }  }  else {    drupal_set_message(st('Failed to open %settings, please verify the file permissions.', array('%settings' => $default_settings)), 'error');  }}/** * Get list of all .install files. * * @param $module_list *   An array of modules to search for their .install files. */function drupal_get_install_files($module_list = array()) {  $installs = array();  foreach ($module_list as $module) {    $installs = array_merge($installs, drupal_system_listing($module .'.install$', 'modules'));  }  return $installs;}/** * Verify a profile for installation. * * @param profile *   Name of profile to verify. * @param locale *   Name of locale used (if any). * @return *   The list of modules to install. */function drupal_verify_profile($profile, $locale) {  include_once './includes/file.inc';  include_once './includes/common.inc';  $profile_file = "./profiles/$profile/$profile.profile";  if (!isset($profile) || !file_exists($profile_file)) {    install_no_profile_error();  }  require_once($profile_file);  // Get a list of modules required by this profile.  $function = $profile .'_profile_modules';  $module_list = array_merge(drupal_required_modules(), $function(), ($locale != 'en' && !empty($locale) ? array('locale') : array()));  // Get a list of modules that exist in Drupal's assorted subdirectories.  $present_modules = array();  foreach (drupal_system_listing('\.module$', 'modules', 'name', 0) as $present_module) {    $present_modules[] = $present_module->name;  }  // Verify that all of the profile's required modules are present.  $missing_modules = array_diff($module_list, $present_modules);  if (count($missing_modules)) {    foreach ($missing_modules as $module) {      drupal_set_message(st('The %module module is required but was not found. Please move it into the <em>modules</em> subdirectory.', array('%module' => $module)), 'error');    }  }  else {    return $module_list;  }}/** * Calls the install function and updates the system table for a given list of * modules. * * @param module_list *   The modules to install. */function drupal_install_modules($module_list = array()) {  $files = module_rebuild_cache();  $module_list = array_flip(array_values($module_list));  do {    $moved = FALSE;    foreach ($module_list as $module => $weight) {      $file = $files[$module];      if (isset($file->info['dependencies']) && is_array($file->info['dependencies'])) {        foreach ($file->info['dependencies'] as $dependency) {          if (isset($module_list[$dependency]) && $module_list[$module] < $module_list[$dependency] +1) {            $module_list[$module] = $module_list[$dependency] +1;            $moved = TRUE;          }        }      }    }  } while ($moved);  asort($module_list);  $module_list = array_keys($module_list);  array_filter($module_list, '_drupal_install_module');  module_enable($module_list);}/** * Callback to install an individual profile module. * * Used during installation to install modules one at a time and then * enable them, or to install a number of modules at one time * from admin/build/modules. */function _drupal_install_module($module) {  if (drupal_get_installed_schema_version($module, TRUE) == SCHEMA_UNINSTALLED) {    module_load_install($module);    module_invoke($module, 'install');    $versions = drupal_get_schema_versions($module);    drupal_set_installed_schema_version($module, $versions ? max($versions) : SCHEMA_INSTALLED);    return TRUE;  }}/** * Callback to install the system module. * * Separated from the installation of other modules so core system * functions can be made available while other modules are installed. */function drupal_install_system() {  $system_path = dirname(drupal_get_filename('module', 'system', NULL));  require_once './'. $system_path .'/system.install';  module_invoke('system', 'install');  $system_versions = drupal_get_schema_versions('system');  $system_version = $system_versions ? max($system_versions) : SCHEMA_INSTALLED;  db_query("INSERT INTO {system} (filename, name, type, owner, status, throttle, bootstrap, schema_version) VALUES('%s', '%s', '%s', '%s', %d, %d, %d, %d)", $system_path .'/system.module', 'system', 'module', '', 1, 0, 0, $system_version);  // Now that we've installed things properly, bootstrap the full Drupal environment  drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);  module_rebuild_cache();}/** * Calls the uninstall function and updates the system table for a given module. * * @param $module *   The module to uninstall. */function drupal_uninstall_module($module) {  // First, retrieve all the module's menu paths from db.  drupal_load('module', $module);  $paths = module_invoke($module, 'menu');  // Uninstall the module(s).  module_load_install($module);  module_invoke($module, 'uninstall');  // Now remove the menu links for all paths declared by this module.  if (!empty($paths)) {    $paths = array_keys($paths);    // Clean out the names of load functions.    foreach ($paths as $index => $path) {      $parts = explode('/', $path, MENU_MAX_PARTS);      foreach ($parts as $k => $part) {        if (preg_match('/^%[a-z_]*$/', $part)) {          $parts[$k] = '%';        }      }      $paths[$index] = implode('/', $parts);    }    $placeholders = implode(', ', array_fill(0, count($paths), "'%s'"));    $result = db_query('SELECT * FROM {menu_links} WHERE router_path IN ('. $placeholders .') AND external = 0 ORDER BY depth DESC', $paths);    // Remove all such items. Starting from those with the greatest depth will    // minimize the amount of re-parenting done by menu_link_delete().    while ($item = db_fetch_array($result)) {      _menu_delete_item($item, TRUE);    }  }  drupal_set_installed_schema_version($module, SCHEMA_UNINSTALLED);}/** * Verify the state of the specified file. * * @param $file *   The file to check for. * @param $mask *   An optional bitmask created from various FILE_* constants. * @param $type *   The type of file. Can be file (default), dir, or link. * @return *   TRUE on success or FALSE on failure. A message is set for the latter. */function drupal_verify_install_file($file, $mask = NULL, $type = 'file') {  $return = TRUE;  // Check for files that shouldn't be there.  if (isset($mask) && ($mask & FILE_NOT_EXIST) && file_exists($file)) {    return FALSE;  }  // Verify that the file is the type of file it is supposed to be.  if (isset($type) && file_exists($file)) {    $check = 'is_'. $type;    if (!function_exists($check) || !$check($file)) {      $return = FALSE;    }  }  // Verify file permissions.  if (isset($mask)) {    $masks = array(FILE_EXIST, FILE_READABLE, FILE_WRITABLE, FILE_EXECUTABLE, FILE_NOT_READABLE, FILE_NOT_WRITABLE, FILE_NOT_EXECUTABLE);    foreach ($masks as $current_mask) {      if ($mask & $current_mask) {        switch ($current_mask) {          case FILE_EXIST:            if (!file_exists($file)) {              if ($type == 'dir') {                drupal_install_mkdir($file, $mask);              }              if (!file_exists($file)) {                $return = FALSE;              }            }            break;          case FILE_READABLE:            if (!is_readable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;          case FILE_WRITABLE:            if (!is_writable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;          case FILE_EXECUTABLE:            if (!is_executable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;          case FILE_NOT_READABLE:            if (is_readable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;          case FILE_NOT_WRITABLE:            if (is_writable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;          case FILE_NOT_EXECUTABLE:            if (is_executable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;        }      }    }  }  return $return;}/** * Create a directory with specified permissions. * * @param file *  The name of the directory to create; * @param mask *  The permissions of the directory to create. * @param $message *  (optional) Whether to output messages. Defaults to TRUE. * * @return *  TRUE/FALSE whether or not the directory was successfully created. */function drupal_install_mkdir($file, $mask, $message = TRUE) {  $mod = 0;  $masks = array(FILE_READABLE, FILE_WRITABLE, FILE_EXECUTABLE, FILE_NOT_READABLE, FILE_NOT_WRITABLE, FILE_NOT_EXECUTABLE);  foreach ($masks as $m) {    if ($mask & $m) {      switch ($m) {        case FILE_READABLE:          $mod += 444;          break;        case FILE_WRITABLE:          $mod += 222;          break;        case FILE_EXECUTABLE:          $mod += 111;          break;      }    }  }  if (@mkdir($file, intval("0$mod", 8))) {    return TRUE;  }  else {    return FALSE;  }}/** * Attempt to fix file permissions. * * The general approach here is that, because we do not know the security * setup of the webserver, we apply our permission changes to all three * digits of the file permission (i.e. user, group and all). * * To ensure that the values behave as expected (and numbers don't carry * from one digit to the next) we do the calculation on the octal value * using bitwise operations. This lets us remove, for example, 0222 from * 0700 and get the correct value of 0500. * * @param $file *  The name of the file with permissions to fix. * @param $mask *  The desired permissions for the file. * @param $message *  (optional) Whether to output messages. Defaults to TRUE. * * @return *  TRUE/FALSE whether or not we were able to fix the file's permissions. */function drupal_install_fix_file($file, $mask, $message = TRUE) {  $mod = fileperms($file) & 0777;  $masks = array(FILE_READABLE, FILE_WRITABLE, FILE_EXECUTABLE, FILE_NOT_READABLE, FILE_NOT_WRITABLE, FILE_NOT_EXECUTABLE);  // FILE_READABLE, FILE_WRITABLE, and FILE_EXECUTABLE permission strings  // can theoretically be 0400, 0200, and 0100 respectively, but to be safe  // we set all three access types in case the administrator intends to  // change the owner of settings.php after installation.  foreach ($masks as $m) {    if ($mask & $m) {      switch ($m) {        case FILE_READABLE:          if (!is_readable($file)) {            $mod |= 0444;          }          break;        case FILE_WRITABLE:          if (!is_writable($file)) {            $mod |= 0222;          }          break;        case FILE_EXECUTABLE:          if (!is_executable($file)) {            $mod |= 0111;          }          break;        case FILE_NOT_READABLE:          if (is_readable($file)) {            $mod &= ~0444;          }          break;        case FILE_NOT_WRITABLE:          if (is_writable($file)) {            $mod &= ~0222;          }          break;        case FILE_NOT_EXECUTABLE:          if (is_executable($file)) {            $mod &= ~0111;          }          break;      }    }  }  // chmod() will work if the web server is running as owner of the file.  // If PHP safe_mode is enabled the currently executing script must also  // have the same owner.  if (@chmod($file, $mod)) {    return TRUE;  }  else {    return FALSE;  }}/** * Send the user to a different installer page. This issues an on-site HTTP * redirect. Messages (and errors) are erased. * * @param $path *   An installer path. */function install_goto($path) {  global $base_url;  header('Location: '. $base_url .'/'. $path);  header('Cache-Control: no-cache'); // Not a permanent redirect.  exit();}/** * Hardcoded function for doing the equivalent of t() during * the install process, when database, theme, and localization * system is possibly not yet available. */function st($string, $args = array()) {  static $locale_strings = NULL;  global $profile, $install_locale;  if (!isset($locale_strings)) {    $locale_strings = array();    $filename = './profiles/'. $profile .'/translations/'. $install_locale .'.po';    if (file_exists($filename)) {      require_once './includes/locale.inc';      $file = (object) array('filepath' => $filename);      _locale_import_read_po('mem-store', $file);      $locale_strings = _locale_import_one_string('mem-report');    }  }  require_once './includes/theme.inc';  // Transform arguments before inserting them  foreach ($args as $key => $value) {    switch ($key[0]) {      // Escaped only      case '@':        $args[$key] = check_plain($value);        break;      // Escaped and placeholder      case '%':      default:        $args[$key] = '<em>'. check_plain($value) .'</em>';        break;      // Pass-through      case '!':    }  }  return strtr((!empty($locale_strings[$string]) ? $locale_strings[$string] : $string), $args);}/** * Check a profile's requirements. * * @param profile *   Name of profile to check. */function drupal_check_profile($profile) {  include_once './includes/file.inc';  $profile_file = "./profiles/$profile/$profile.profile";  if (!isset($profile) || !file_exists($profile_file)) {    install_no_profile_error();  }  require_once($profile_file);  // Get a list of modules required by this profile.  $function = $profile .'_profile_modules';  $module_list = array_unique(array_merge(drupal_required_modules(), $function()));  // Get a list of all .install files.  $installs = drupal_get_install_files($module_list);  // Collect requirement testing results  $requirements = array();  foreach ($installs as $install) {    require_once $install->filename;    if (module_hook($install->name, 'requirements')) {      $requirements = array_merge($requirements, module_invoke($install->name, 'requirements', 'install'));    }  }  return $requirements;}/** * Extract highest severity from requirements array. */function drupal_requirements_severity(&$requirements) {  $severity = REQUIREMENT_OK;  foreach ($requirements as $requirement) {    if (isset($requirement['severity'])) {      $severity = max($severity, $requirement['severity']);    }  }  return $severity;}/** * Check a module's requirements. */function drupal_check_module($module) {  // Include install file  $install = drupal_get_install_files(array($module));  if (isset($install[$module])) {    require_once $install[$module]->filename;    // Check requirements    $requirements = module_invoke($module, 'requirements', 'install');    if (is_array($requirements) && drupal_requirements_severity($requirements) == REQUIREMENT_ERROR) {      // Print any error messages      foreach ($requirements as $requirement) {        if (isset($requirement['severity']) && $requirement['severity'] == REQUIREMENT_ERROR) {          $message = $requirement['description'];          if (isset($requirement['value']) && $requirement['value']) {            $message .= ' ('. t('Currently using !item !version', array('!item' => $requirement['title'], '!version' => $requirement['value'])) .')';          }          drupal_set_message($message, 'error');        }      }      return FALSE;    }  }  return TRUE;}
<?php// $Id$/** * Implementation of hook_install(). */function book_install() {  // Create tables.  drupal_install_schema('book');  // Add the node type.  _book_install_type_create();}/** * Implementation of hook_uninstall(). */function book_uninstall() {  // Delete menu links.  db_query("DELETE FROM {menu_links} WHERE module = 'book'");  menu_cache_clear_all();  // Remove tables.  drupal_uninstall_schema('book');}function _book_install_type_create() {  // Create an additional node type  $book_node_type = array(    'type' => 'book',    'name' => t('Book page'),    'module' => 'node',    'description' => t('A <em>book page</em> is a page of content, organized into a collection of related entries collectively known as a <em>book</em>. A <em>book page</em> automatically displays links to adjacent pages, providing a simple navigation system for organizing and reviewing structured content.'),    'custom' => TRUE,    'modified' => TRUE,    'locked' => FALSE,  );  $book_node_type = (object)_node_type_set_defaults($book_node_type);  node_type_save($book_node_type);  // Default to not promoted.  variable_set('node_options_book', array('status'));  // Use this default type for adding content to books.  variable_set('book_allowed_types', array('book'));  variable_set('book_child_type', 'book');}/** * Drupal 5.x to 6.x update. * * This function moves any existing book hierarchy into the new structure used * in the 6.x module.  Rather than storing the hierarchy in the {book} table, * the menu API is used to store the hierarchy in the {menu_links} table and the * {book} table serves to uniquely connect a node to a menu link. * * In order to accomplish this, the current hierarchy is processed using a stack. * The stack insures that each parent is processed before any of its children * in the book hierarchy, and is compatible with batched update processing. * */function book_update_6000() {  $ret = array();  // Set up for a multi-part update.  if (!isset($_SESSION['book_update_6000'])) {    $schema['book'] = array(      'fields' => array(        'mlid'    => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'nid'     => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'bid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      ),      'primary key' => array('mlid'),      'unique keys' => array(        'nid' => array('nid'),      ),      'indexes' => array(        'bid' => array('bid'),      ),    );    // Add the node type.    _book_install_type_create();    // Fix role permissions to account for the changed names    // Setup the array holding strings to match and the corresponding    // strings to replace them with.    $replace = array(      'outline posts in books' => 'administer book outlines',      'create book pages' => 'create book content',      'edit book pages' => 'edit any book content',      'edit own book pages' => 'edit own book content',      'see printer-friendly version' => 'access printer-friendly version',    );    // Loop over all the roles, and do the necessary transformations.    $query = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");    while ($role = db_fetch_object($query)) {      // Replace all the old permissions with the corresponding new permissions.      $fixed_perm = strtr($role->perm, $replace);      // If the user could previously create book pages, they should get the new      // 'add content to books' permission.      if (strpos($role->perm, 'create book pages') !== FALSE) {        $fixed_perm .= ', add content to books';      }      // Only save if the permissions have changed.      if ($fixed_perm != $role->perm) {        $ret[] = update_sql("UPDATE {permission} SET perm = '$fixed_perm' WHERE rid = $role->rid");      }    }    // Determine whether there are any existing nodes in the book hierarchy.    if (db_result(db_query("SELECT COUNT(*) FROM {book}"))) {      // Temporary table for the old book hierarchy; we'll discard revision info.      $schema['book_temp'] = array(        'fields' => array(          'nid'    => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),          'parent' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),          'weight' => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'tiny')        ),        'indexes' => array(          'parent' => array('parent')        ),        'primary key' => array('nid'),      );      db_create_table($ret, 'book_temp', $schema['book_temp']);      // Insert each node in the old table into the temporary table.      $ret[] = update_sql("INSERT INTO {book_temp} (nid, parent, weight) SELECT b.nid, b.parent, b.weight FROM {book} b INNER JOIN {node} n on b.vid = n.vid");      $ret[] = update_sql("DROP TABLE {book}");      db_create_table($ret, 'book', $schema['book']);      $_SESSION['book_update_6000_orphans']['from'] = 0;      $_SESSION['book_update_6000'] = array();      $result = db_query("SELECT * from {book_temp} WHERE parent = 0");      // Collect all books - top-level nodes.      while ($a = db_fetch_array($result)) {        $_SESSION['book_update_6000'][] = $a;      }      $ret['#finished'] = FALSE;      return $ret;    }    else {      // No exising nodes in the hierarchy, so drop the table and re-create it.      $ret[] = update_sql("DROP TABLE {book}");      db_create_table($ret, 'book', $schema['book']);      return $ret;    }  }  elseif ($_SESSION['book_update_6000_orphans']) {    // Do the first batched part of the update - collect orphans.    $update_count = 400; // Update this many at a time    $result = db_query_range("SELECT * FROM {book_temp}", $_SESSION['book_update_6000_orphans']['from'], $update_count);    $has_rows = FALSE;    // Go through the next $update_count book pages and locate the orphans.    while ($book = db_fetch_array($result)) {      $has_rows = TRUE;      // Orphans are defined as nodes whose parent does not exist in the table.      if ($book['parent'] && !db_result(db_query("SELECT COUNT(*) FROM {book_temp} WHERE nid = %d", $book['parent']))) {        if (empty($_SESSION['book_update_6000_orphans']['book'])) {          // The first orphan becomes the parent for all other orphans.          $book['parent'] = 0;          $_SESSION['book_update_6000_orphans']['book'] = $book;          $ret[] = array('success' => TRUE, 'query' => 'Relocated orphan book pages.');        }        else {          // Re-assign the parent value of the book, and add it to the stack.          $book['parent'] = $_SESSION['book_update_6000_orphans']['book']['nid'];          $_SESSION['book_update_6000'][] = $book;        }      }    }    if ($has_rows) {      $_SESSION['book_update_6000_orphans']['from'] += $update_count;    }    else {      // Done with this part      if (!empty($_SESSION['book_update_6000_orphans']['book'])) {        // The orphans' parent is added last, so it will be processed first.        $_SESSION['book_update_6000'][] = $_SESSION['book_update_6000_orphans']['book'];      }      $_SESSION['book_update_6000_orphans'] = FALSE;    }    $ret['#finished'] = FALSE;    return $ret;  }  else {    // Do the next batched part of the update    $update_count = 100; // Update this many at a time    while ($update_count && $_SESSION['book_update_6000']) {      // Get the last node off the stack.      $book = array_pop($_SESSION['book_update_6000']);      // Add all of this node's children to the stack      $result = db_query("SELECT * FROM {book_temp} WHERE parent = %d", $book['nid']);      while ($a = db_fetch_array($result)) {        $_SESSION['book_update_6000'][] = $a;      }      if ($book['parent']) {        // If its not a top level page, get its parent's mlid.        $parent = db_fetch_array(db_query("SELECT b.mlid AS plid, b.bid FROM {book} b WHERE b.nid = %d", $book['parent']));        $book = array_merge($book, $parent);      }      else {        // There is not a parent - this is a new book.        $book['plid'] = 0;        $book['bid'] = $book['nid'];      }      $book += array(        'module' => 'book',        'link_path' => 'node/'. $book['nid'],        'router_path' => 'node/%',        'menu_name' => 'book-toc-'. $book['bid'],      );      $book = array_merge($book, db_fetch_array(db_query("SELECT title AS link_title FROM {node} WHERE nid = %d", $book['nid'])));      // Items with depth > MENU_MAX_DEPTH cannot be saved.      if (menu_link_save($book)) {        db_query("INSERT INTO {book} (mlid, nid, bid) VALUES (%d, %d, %d)", $book['mlid'], $book['nid'], $book['bid']);      }      else {        // The depth was greater then MENU_MAX_DEPTH, so attach it to the        // closest valid parent.        $book['plid'] = db_result(db_query("SELECT plid FROM {menu_links} WHERE mlid = %d", $book['plid']));        if (menu_link_save($book)) {          db_query("INSERT INTO {book} (mlid, nid, bid) VALUES (%d, %d, %d)", $book['mlid'], $book['nid'], $book['bid']);        }      }      $update_count--;    }    $ret['#finished'] = FALSE;  }  if (empty($_SESSION['book_update_6000'])) {    $ret['#finished'] = TRUE;    $ret[] = array('success' => TRUE, 'query' => 'Relocated existing book pages.');    $ret[] = update_sql("DROP TABLE {book_temp}");    unset($_SESSION['book_update_6000']);    unset($_SESSION['book_update_6000_orphans']);  }  return $ret;}/** * Implementation of hook_schema(). */function book_schema() {  $schema['book'] = array(  'description' => 'Stores book outline information. Uniquely connects each node in the outline to a link in {menu_links}',    'fields' => array(      'mlid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book page's {menu_links}.mlid.",      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book page's {node}.nid.",      ),      'bid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book ID is the {book}.nid of the top-level page.",      ),    ),    'primary key' => array('mlid'),    'unique keys' => array(      'nid' => array('nid'),    ),    'indexes' => array(      'bid' => array('bid'),    ),  );  return $schema;}
<?php// $Id$/** * Implementation of hook_schema(). */function node_schema() {  $schema['node'] = array(    'description' => 'The base table for nodes.',    'fields' => array(      'nid' => array(        'description' => 'The primary identifier for a node.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'vid' => array(        'description' => 'The current {node_revisions}.vid version identifier.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'type' => array(        'description' => 'The {node_type}.type of this node.',        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => ''),      'language' => array(        'description' => 'The {languages}.language of this node.',        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => ''),      'title' => array(        'description' => 'The title of this node, always treated as non-markup plain text.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'uid' => array(        'description' => 'The {users}.uid that owns this node; initially, this is the user that created it.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'status' => array(        'description' => 'Boolean indicating whether the node is published (visible to non-administrators).',        'type' => 'int',        'not null' => TRUE,        'default' => 1),      'created' => array(        'description' => 'The Unix timestamp when the node was created.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'changed' => array(        'description' => 'The Unix timestamp when the node was most recently saved.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'comment' => array(        'description' => 'Whether comments are allowed on this node: 0 = no, 1 = read only, 2 = read/write.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'promote' => array(        'description' => 'Boolean indicating whether the node should be displayed on the front page.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'moderate' => array(        'description' => 'Previously, a boolean indicating whether the node was "in moderation"; mostly no longer used.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'sticky' => array(        'description' => 'Boolean indicating whether the node should be displayed at the top of lists in which it appears.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'tnid' => array(        'description' => 'The translation set id for this node, which equals the node id of the source post in each set.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'translate' => array(        'description' => 'A boolean indicating whether this translation page needs to be updated.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      ),    'indexes' => array(      'node_changed'        => array('changed'),      'node_created'        => array('created'),      'node_moderate'       => array('moderate'),      'node_promote_status' => array('promote', 'status'),      'node_status_type'    => array('status', 'type', 'nid'),      'node_title_type'     => array('title', array('type', 4)),      'node_type'           => array(array('type', 4)),      'uid'                 => array('uid'),      'tnid'                => array('tnid'),      'translate'           => array('translate'),      ),    'unique keys' => array(      'vid'     => array('vid')      ),    'primary key' => array('nid'),    );  $schema['node_access'] = array(    'description' => 'Identifies which realm/grant pairs a user must possess in order to view, update, or delete specific nodes.',    'fields' => array(      'nid' => array(        'description' => 'The {node}.nid this record affects.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'gid' => array(        'description' => "The grant ID a user must possess in the specified realm to gain this row's privileges on the node.",        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'realm' => array(        'description' => 'The realm in which the user must possess the grant ID. Each node access node can define one or more realms.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'grant_view' => array(        'description' => 'Boolean indicating whether a user with the realm/grant pair can view this node.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'grant_update' => array(        'description' => 'Boolean indicating whether a user with the realm/grant pair can edit this node.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'grant_delete' => array(        'description' => 'Boolean indicating whether a user with the realm/grant pair can delete this node.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny')      ),    'primary key' => array('nid', 'gid', 'realm'),    );  $schema['node_counter'] = array(    'description' => 'Access statistics for {node}s.',    'fields' => array(      'nid' => array(        'description' => 'The {node}.nid for these statistics.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'totalcount' => array(        'description' => 'The total number of times the {node} has been viewed.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'big'),      'daycount' => array(        'description' => 'The total number of times the {node} has been viewed today.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'medium'),      'timestamp' => array(        'description' => 'The most recent time the {node} has been viewed.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0)      ),    'primary key' => array('nid'),    );  $schema['node_revisions'] = array(    'description' => 'Stores information about each saved version of a {node}.',    'fields' => array(      'nid' => array(        'description' => 'The {node} this version belongs to.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'vid' => array(        'description' => 'The primary identifier for this version.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'uid' => array(        'description' => 'The {users}.uid that created this version.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'title' => array(        'description' => 'The title of this version.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'body' => array(        'description' => 'The body of this version.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'teaser' => array(        'description' => 'The teaser of this version.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'log' => array(        'description' => 'The log entry explaining the changes in this version.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'timestamp' => array(        'description' => 'A Unix timestamp indicating when this version was created.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'format' => array(        'description' => "The input format used by this version's body.",        'type' => 'int',        'not null' => TRUE,        'default' => 0)      ),    'indexes' => array(      'nid' => array('nid'),      'uid' => array('uid')      ),    'primary key' => array('vid'),    );  $schema['node_type'] = array(    'description' => 'Stores information about all defined {node} types.',    'fields' => array(      'type' => array(        'description' => 'The machine-readable name of this type.',        'type' => 'varchar',        'length' => 32,        'not null' => TRUE),      'name' => array(        'description' => 'The human-readable name of this type.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'module' => array(        'description' => 'The base string used to construct callbacks corresponding to this node type.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE),      'description'    => array(        'description' => 'A brief description of this type.',        'type' => 'text',        'not null' => TRUE,        'size' => 'medium'),      'help' => array(        'description' => 'Help information shown to the user when creating a {node} of this type.',        'type' => 'text',        'not null' => TRUE,        'size' => 'medium'),      'has_title' => array(        'description' => 'Boolean indicating whether this type uses the {node}.title field.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'size' => 'tiny'),      'title_label' => array(        'description' => 'The label displayed for the title field on the edit form.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'has_body' => array(        'description' => 'Boolean indicating whether this type uses the {node_revisions}.body field.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'size' => 'tiny'),      'body_label' => array(        'description' => 'The label displayed for the body field on the edit form.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'min_word_count' => array(        'description' => 'The minimum number of words the body must contain.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'size' => 'small'),      'custom' => array(        'description' => 'A boolean indicating whether this type is defined by a module (FALSE) or by a user via a module like the Content Construction Kit (TRUE).',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'modified' => array(        'description' => 'A boolean indicating whether this type has been modified by an administrator; currently not used in any way.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'locked' => array(        'description' => 'A boolean indicating whether the administrator can change the machine name of this type.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'orig_type' => array(        'description' => 'The original machine-readable name of this node type. This may be different from the current type name if the locked field is 0.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '')      ),    'primary key' => array('type'),    );  return $schema;}
<?php// $Id$/** * Implementation of hook_install(). */function upload_install() {  // Create table. The upload table might have been created in the Drupal 5  // to Drupal 6 upgrade, and was migrated from the file_revisions table. So  // in this case, there is no need to create the table, it is already there.  if (!db_table_exists('upload')) {    drupal_install_schema('upload');  }}/** * Implementation of hook_uninstall(). */function upload_uninstall() {  // Remove tables.  drupal_uninstall_schema('upload');}/** * Implementation of hook_schema(). */function upload_schema() {  $schema['upload'] = array(    'description' => 'Stores uploaded file information and table associations.',    'fields' => array(      'fid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {files}.fid.',      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid associated with the uploaded file.',      ),      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {node}.vid associated with the uploaded file.',      ),      'description' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Description of the uploaded file.',      ),      'list' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether the file should be visibly listed on the node: yes(1) or no(0).',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Weight of this upload in relation to other uploads in this node.',      ),    ),    'primary key' => array('vid', 'fid'),    'indexes' => array(      'fid' => array('fid'),      'nid' => array('nid'),    ),  );  return $schema;}
<?php// $Id$/** * The main entry point for XML-RPC requests. * * @param $callbacks *   Array of external XML-RPC method names with the callbacks they map to. */function xmlrpc_server($callbacks) {  $xmlrpc_server = new stdClass();  // Define built-in XML-RPC method names  $defaults = array(      'system.multicall' => 'xmlrpc_server_multicall',    array(      'system.methodSignature',      'xmlrpc_server_method_signature',      array('array', 'string'),      'Returns an array describing the return type and required parameters of a method.'    ),    array(      'system.getCapabilities',      'xmlrpc_server_get_capabilities',      array('struct'),      'Returns a struct describing the XML-RPC specifications supported by this server.'    ),    array(      'system.listMethods',      'xmlrpc_server_list_methods',      array('array'),      'Returns an array of available methods on this server.'),    array(      'system.methodHelp',      'xmlrpc_server_method_help',      array('string', 'string'),      'Returns a documentation string for the specified method.')  );  // We build an array of all method names by combining the built-ins  // with those defined by modules implementing the _xmlrpc hook.  // Built-in methods are overridable.  foreach (array_merge($defaults, (array)$callbacks) as $key => $callback) {    // we could check for is_array($callback)    if (is_int($key)) {      $method = $callback[0];      $xmlrpc_server->callbacks[$method] = $callback[1];      $xmlrpc_server->signatures[$method] = $callback[2];      $xmlrpc_server->help[$method] = $callback[3];    }    else {      $xmlrpc_server->callbacks[$key] = $callback;      $xmlrpc_server->signatures[$key] = '';      $xmlrpc_server->help[$key] = '';    }  }  $data = file_get_contents('php://input');  if (!$data) {    die('XML-RPC server accepts POST requests only.');  }  $xmlrpc_server->message = xmlrpc_message($data);  if (!xmlrpc_message_parse($xmlrpc_server->message)) {    xmlrpc_server_error(-32700, t('Parse error. Request not well formed.'));  }  if ($xmlrpc_server->message->messagetype != 'methodCall') {    xmlrpc_server_error(-32600, t('Server error. Invalid XML-RPC. Request must be a methodCall.'));  }  if (!isset($xmlrpc_server->message->params)) {    $xmlrpc_server->message->params = array();  }  xmlrpc_server_set($xmlrpc_server);  $result = xmlrpc_server_call($xmlrpc_server, $xmlrpc_server->message->methodname, $xmlrpc_server->message->params);  if (is_object($result) && !empty($result->is_error)) {    xmlrpc_server_error($result);  }  // Encode the result  $r = xmlrpc_value($result);  // Create the XML  $xml = '<methodResponse>  <params>  <param>    <value>'.    xmlrpc_value_get_xml($r)    .'</value>  </param>  </params></methodResponse>';  // Send it  xmlrpc_server_output($xml);}/** * Throw an XML-RPC error. * * @param $error *   an error object OR integer error code * @param $message *   description of error, used only if integer error code was passed */function xmlrpc_server_error($error, $message = FALSE) {  if ($message && !is_object($error)) {    $error = xmlrpc_error($error, $message);  }  xmlrpc_server_output(xmlrpc_error_get_xml($error));}function xmlrpc_server_output($xml) {  $xml = '<?xml version="1.0"?>'."\n". $xml;  header('Connection: close');  header('Content-Length: '. strlen($xml));  header('Content-Type: text/xml');  header('Date: '. date('r'));  echo $xml;  exit;}/** * Store a copy of the request temporarily. * * @param $xmlrpc_server *   Request object created by xmlrpc_server(). */function xmlrpc_server_set($xmlrpc_server = NULL) {  static $server;  if (!isset($server)) {    $server = $xmlrpc_server;  }  return $server;}// Retrieve the stored request.function xmlrpc_server_get() {  return xmlrpc_server_set();}/** * Dispatch the request and any parameters to the appropriate handler. * * @param $xmlrpc_server * @param $methodname *   The external XML-RPC method name, e.g. 'system.methodHelp' * @param $args *   Array containing any parameters that were sent along with the request. */function xmlrpc_server_call($xmlrpc_server, $methodname, $args) {  // Make sure parameters are in an array  if ($args && !is_array($args)) {    $args = array($args);  }  // Has this method been mapped to a Drupal function by us or by modules?  if (!isset($xmlrpc_server->callbacks[$methodname])) {    return xmlrpc_error(-32601, t('Server error. Requested method @methodname not specified.', array("@methodname" => $xmlrpc_server->message->methodname)));  }  $method = $xmlrpc_server->callbacks[$methodname];  $signature = $xmlrpc_server->signatures[$methodname];  // If the method has a signature, validate the request against the signature  if (is_array($signature)) {    $ok = TRUE;    $return_type = array_shift($signature);    // Check the number of arguments    if (count($args) != count($signature)) {      return xmlrpc_error(-32602, t('Server error. Wrong number of method parameters.'));    }    // Check the argument types    foreach ($signature as $key => $type) {      $arg = $args[$key];      switch ($type) {        case 'int':        case 'i4':          if (is_array($arg) || !is_int($arg)) {            $ok = FALSE;          }          break;        case 'base64':        case 'string':          if (!is_string($arg)) {            $ok = FALSE;          }          break;        case 'boolean':          if ($arg !== FALSE && $arg !== TRUE) {            $ok = FALSE;          }          break;        case 'float':        case 'double':          if (!is_float($arg)) {            $ok = FALSE;          }          break;        case 'date':        case 'dateTime.iso8601':          if (!$arg->is_date) {            $ok = FALSE;          }          break;      }      if (!$ok) {        return xmlrpc_error(-32602, t('Server error. Invalid method parameters.'));      }    }  }  if (!function_exists($method)) {    return xmlrpc_error(-32601, t('Server error. Requested function @method does not exist.', array("@method" => $method)));  }  // Call the mapped function  return call_user_func_array($method, $args);}function xmlrpc_server_multicall($methodcalls) {  // See http://www.xmlrpc.com/discuss/msgReader$1208  $return = array();  $xmlrpc_server = xmlrpc_server_get();  foreach ($methodcalls as $call) {    $ok = TRUE;    if (!isset($call['methodName']) || !isset($call['params'])) {      $result = xmlrpc_error(3, t('Invalid syntax for system.multicall.'));      $ok = FALSE;    }    $method = $call['methodName'];    $params = $call['params'];    if ($method == 'system.multicall') {      $result = xmlrpc_error(-32600, t('Recursive calls to system.multicall are forbidden.'));    }    elseif ($ok) {      $result = xmlrpc_server_call($xmlrpc_server, $method, $params);    }    if ($result->is_error) {      $return[] = array(        'faultCode' => $result->code,        'faultString' => $result->message      );    }    else {      $return[] = $result;    }  }  return $return;}/** * XML-RPC method system.listMethods maps to this function. */function xmlrpc_server_list_methods() {  $xmlrpc_server = xmlrpc_server_get();  return array_keys($xmlrpc_server->callbacks);}/** * XML-RPC method system.getCapabilities maps to this function. * See http://groups.yahoo.com/group/xml-rpc/message/2897 */function xmlrpc_server_get_capabilities() {  return array(    'xmlrpc' => array(      'specUrl' => 'http://www.xmlrpc.com/spec',      'specVersion' => 1    ),    'faults_interop' => array(      'specUrl' => 'http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php',      'specVersion' => 20010516    ),    'system.multicall' => array(      'specUrl' => 'http://www.xmlrpc.com/discuss/msgReader$1208',      'specVersion' => 1    ),    'introspection' => array(    'specUrl' => 'http://scripts.incutio.com/xmlrpc/introspection.html',    'specVersion' => 1    )  );}/** * XML-RPC method system.methodSignature maps to this function. * * @param $methodname *   Name of method for which we return a method signature. * @return array *   An array of types representing the method signature of the *   function that the methodname maps to. The methodSignature of *   this function is 'array', 'string' because it takes an array *   and returns a string. */function xmlrpc_server_method_signature($methodname) {  $xmlrpc_server = xmlrpc_server_get();  if (!isset($xmlrpc_server->callbacks[$methodname])) {    return xmlrpc_error(-32601, t('Server error. Requested method @methodname not specified.', array("@methodname" => $methodname)));  }  if (!is_array($xmlrpc_server->signatures[$methodname])) {    return xmlrpc_error(-32601, t('Server error. Requested method @methodname signature not specified.', array("@methodname" => $methodname)));  }  // We array of types  $return = array();  foreach ($xmlrpc_server->signatures[$methodname] as $type) {    $return[] = $type;  }  return $return;}/** * XML-RPC method system.methodHelp maps to this function. * * @param $method *   Name of method for which we return a help string. */function xmlrpc_server_method_help($method) {  $xmlrpc_server = xmlrpc_server_get();  return $xmlrpc_server->help[$method];}
<?php// $Id$/** * @file * Admin page callbacks for the system module. *//** * Menu callback; Provide the administration overview page. */function system_main_admin_page($arg = NULL) {  // If we received an argument, they probably meant some other page.  // Let's 404 them since the menu system cannot be told we do not  // accept arguments.  if (isset($arg) && substr($arg, 0, 3) != 'by-') {    return drupal_not_found();  }  // Check for status report errors.  if (system_status(TRUE) && user_access('administer site configuration')) {    drupal_set_message(t('One or more problems were detected with your Drupal installation. Check the <a href="@status">status report</a> for more information.', array('@status' => url('admin/reports/status'))), 'error');  }  $blocks = array();  if ($admin = db_fetch_array(db_query("SELECT menu_name, mlid FROM {menu_links} WHERE link_path = 'admin' AND module = 'system'"))) {    $result = db_query("      SELECT m.*, ml.*      FROM {menu_links} ml      INNER JOIN {menu_router} m ON ml.router_path = m.path      WHERE ml.link_path != 'admin/help' AND menu_name = '%s' AND ml.plid = %d AND hidden = 0", $admin);    while ($item = db_fetch_array($result)) {      _menu_link_translate($item);      if (!$item['access']) {        continue;      }      // The link 'description' either derived from the hook_menu 'description'      // or entered by the user via menu module is saved as the title attribute.      if (!empty($item['localized_options']['attributes']['title'])) {        $item['description'] = $item['localized_options']['attributes']['title'];      }      $block = $item;      $block['content'] = '';      if ($item['block_callback'] && function_exists($item['block_callback'])) {        $function = $item['block_callback'];        $block['content'] .= $function();      }      $block['content'] .= theme('admin_block_content', system_admin_menu_block($item));      // Prepare for sorting as in function _menu_tree_check_access().      // The weight is offset so it is always positive, with a uniform 5-digits.      $blocks[(50000 + $item['weight']) .' '. $item['title'] .' '. $item['mlid']] = $block;    }  }  if ($blocks) {    ksort($blocks);    return theme('admin_page', $blocks);  }  else {    return t('You do not have any administrative items.');  }}/** * Provide a single block from the administration menu as a page. * This function is often a destination for these blocks. * For example, 'admin/content/types' needs to have a destination to be valid * in the Drupal menu system, but too much information there might be * hidden, so we supply the contents of the block. * * @return *   The output HTML. */function system_admin_menu_block_page() {  $item = menu_get_item();  if ($content = system_admin_menu_block($item)) {    $output = theme('admin_block_content', $content);  }  else {    $output = t('You do not have any administrative items.');  }  return $output;}/** * Menu callback; Sets whether the admin menu is in compact mode or not. * * @param $mode *   Valid values are 'on' and 'off'. */function system_admin_compact_page($mode = 'off') {  global $user;  user_save($user, array('admin_compact_mode' => ($mode == 'on')));  drupal_goto('admin');}/** * Menu callback; prints a listing of admin tasks for each installed module. */function system_admin_by_module() {  $modules = module_rebuild_cache();  $menu_items = array();  $help_arg = module_exists('help') ? drupal_help_arg() : FALSE;  foreach ($modules as $file) {    $module = $file->name;    if ($module == 'help') {      continue;    }    $admin_tasks = system_get_module_admin_tasks($module);    // Only display a section if there are any available tasks.    if (count($admin_tasks)) {      // Check for help links.      if ($help_arg && module_invoke($module, 'help', "admin/help#$module", $help_arg)) {        $admin_tasks[100] = l(t('Get help'), "admin/help/$module");      }      // Sort.      ksort($admin_tasks);      $menu_items[$file->info['name']] = array($file->info['description'], $admin_tasks);    }  }  return theme('system_admin_by_module', $menu_items);}/** * Menu callback; displays a module's settings page. */function system_settings_overview() {  // Check database setup if necessary  if (function_exists('db_check_setup') && empty($_POST)) {    db_check_setup();  }  $item = menu_get_item('admin/settings');  $content = system_admin_menu_block($item);  $output = theme('admin_block_content', $content);  return $output;}/** * Form builder; This function allows selection of the theme to show in administration sections. * * @ingroup forms * @see system_settings_form() */function system_admin_theme_settings() {  $themes = system_theme_data();  uasort($themes, 'system_sort_modules_by_info_name');  $options[0] = '<'. t('System default') .'>';  foreach ($themes as $theme) {    $options[$theme->name] = $theme->info['name'];  }  $form['admin_theme'] = array(    '#type' => 'select',    '#options' => $options,    '#title' => t('Administration theme'),    '#description' => t('Choose which theme the administration pages should display in. If you choose "System default" the administration pages will use the same theme as the rest of the site.'),    '#default_value' => variable_get('admin_theme', '0'),  );  $form['node_admin_theme'] = array(    '#type' => 'checkbox',    '#title' => t('Use administration theme for content editing'),    '#description' => t('Use the administration theme when editing existing posts or creating new ones.'),    '#default_value' => variable_get('node_admin_theme', '0'),  );  $form['#submit'][] = 'system_admin_theme_submit';  return system_settings_form($form);}/** * Menu callback; displays a listing of all themes. * * @ingroup forms * @see system_themes_form_submit() */function system_themes_form() {  $themes = system_theme_data();  uasort($themes, 'system_sort_modules_by_info_name');  $status = array();  $incompatible_core = array();  $incompatible_php = array();  foreach ($themes as $theme) {    $screenshot = NULL;    // Create a list which includes the current theme and all its base themes.    if (isset($themes[$theme->name]->base_themes)) {      $theme_keys = array_keys($themes[$theme->name]->base_themes);      $theme_keys[] = $theme->name;    }    else {      $theme_keys = array($theme->name);    }    // Look for a screenshot in the current theme or in its closest ancestor.    foreach (array_reverse($theme_keys) as $theme_key) {      if (isset($themes[$theme_key]) && file_exists($themes[$theme_key]->info['screenshot'])) {        $screenshot = $themes[$theme_key]->info['screenshot'];        break;      }    }    $screenshot = $screenshot ? theme('image', $screenshot, t('Screenshot for %theme theme', array('%theme' => $theme->info['name'])), '', array('class' => 'screenshot'), FALSE) : t('no screenshot');    $form[$theme->name]['screenshot'] = array('#value' => $screenshot);    $form[$theme->name]['info'] = array(      '#type' => 'value',      '#value' => $theme->info,    );    $options[$theme->name] = '';    if (!empty($theme->status) || $theme->name == variable_get('admin_theme', '0')) {      $form[$theme->name]['operations'] = array('#value' => l(t('configure'), 'admin/build/themes/settings/'. $theme->name) );    }    else {      // Dummy element for drupal_render. Cleaner than adding a check in the theme function.      $form[$theme->name]['operations'] = array();    }    if (!empty($theme->status)) {      $status[] = $theme->name;    }    else {      // Ensure this theme is compatible with this version of core.      if (!isset($theme->info['core']) || $theme->info['core'] != DRUPAL_CORE_COMPATIBILITY) {        $incompatible_core[] = $theme->name;      }      if (version_compare(phpversion(), $theme->info['php']) < 0) {        $incompatible_php[$theme->name] = $theme->info['php'];      }    }  }  $form['status'] = array(    '#type' => 'checkboxes',    '#options' => $options,    '#default_value' => $status,    '#incompatible_themes_core' => drupal_map_assoc($incompatible_core),    '#incompatible_themes_php' => $incompatible_php,  );  $form['theme_default'] = array(    '#type' => 'radios',    '#options' => $options,    '#default_value' => variable_get('theme_default', 'garland'),  );  $form['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Save configuration'),  );  $form['buttons']['reset'] = array(    '#type' => 'submit',    '#value' => t('Reset to defaults'),  );  return $form;}/** * Process system_themes_form form submissions. */function system_themes_form_submit($form, &$form_state) {  drupal_clear_css_cache();  // Store list of previously enabled themes and disable all themes  $old_theme_list = $new_theme_list = array();  foreach (list_themes() as $theme) {    if ($theme->status) {      $old_theme_list[] = $theme->name;    }  }  db_query("UPDATE {system} SET status = 0 WHERE type = 'theme'");  if ($form_state['values']['op'] == t('Save configuration')) {    if (is_array($form_state['values']['status'])) {      foreach ($form_state['values']['status'] as $key => $choice) {        // Always enable the default theme, despite its status checkbox being checked:        if ($choice || $form_state['values']['theme_default'] == $key) {          system_initialize_theme_blocks($key);          $new_theme_list[] = $key;          db_query("UPDATE {system} SET status = 1 WHERE type = 'theme' and name = '%s'", $key);        }      }    }    if (($admin_theme = variable_get('admin_theme', '0')) != '0' && $admin_theme != $form_state['values']['theme_default']) {      drupal_set_message(t('Please note that the <a href="!admin_theme_page">administration theme</a> is still set to the %admin_theme theme; consequently, the theme on this page remains unchanged. All non-administrative sections of the site, however, will show the selected %selected_theme theme by default.', array(        '!admin_theme_page' => url('admin/settings/admin'),        '%admin_theme' => $admin_theme,        '%selected_theme' => $form_state['values']['theme_default'],      )));    }    variable_set('theme_default', $form_state['values']['theme_default']);  }  else {    // Revert to defaults: only Garland is enabled.    variable_del('theme_default');    db_query("UPDATE {system} SET status = 1 WHERE type = 'theme' AND name = 'garland'");    $new_theme_list = array('garland');  }  list_themes(TRUE);  menu_rebuild();  drupal_rebuild_theme_registry();  drupal_set_message(t('The configuration options have been saved.'));  $form_state['redirect'] = 'admin/build/themes';  // Notify locale module about new themes being enabled, so translations can  // be imported. This might start a batch, and only return to the redirect  // path after that.  module_invoke('locale', 'system_update', array_diff($new_theme_list, $old_theme_list));  return;}/** * Form builder; display theme configuration for entire site and individual themes. * * @param $key *   A theme name. * @return *   The form structure. * @ingroup forms * @see system_theme_settings_submit() */function system_theme_settings(&$form_state, $key = '') {  $directory_path = file_directory_path();  file_check_directory($directory_path, FILE_CREATE_DIRECTORY, 'file_directory_path');  // Default settings are defined in theme_get_settings() in includes/theme.inc  if ($key) {    $settings = theme_get_settings($key);    $var = str_replace('/', '_', 'theme_'. $key .'_settings');    $themes = system_theme_data();    $features = $themes[$key]->info['features'];  }  else {    $settings = theme_get_settings('');    $var = 'theme_settings';  }  $form['var'] = array('#type' => 'hidden', '#value' => $var);  // Check for a new uploaded logo, and use that instead.  if ($file = file_save_upload('logo_upload', array('file_validate_is_image' => array()))) {    $parts = pathinfo($file->filename);    $filename = ($key) ? str_replace('/', '_', $key) .'_logo.'. $parts['extension'] : 'logo.'. $parts['extension'];    // The image was saved using file_save_upload() and was added to the    // files table as a temporary file. We'll make a copy and let the garbage    // collector delete the original upload.    if (file_copy($file, $filename, FILE_EXISTS_REPLACE)) {      $_POST['default_logo'] = 0;      $_POST['logo_path'] = $file->filepath;      $_POST['toggle_logo'] = 1;    }  }  // Check for a new uploaded favicon, and use that instead.  if ($file = file_save_upload('favicon_upload')) {    $parts = pathinfo($file->filename);    $filename = ($key) ? str_replace('/', '_', $key) .'_favicon.'. $parts['extension'] : 'favicon.'. $parts['extension'];    // The image was saved using file_save_upload() and was added to the    // files table as a temporary file. We'll make a copy and let the garbage    // collector delete the original upload.    if (file_copy($file, $filename)) {      $_POST['default_favicon'] = 0;      $_POST['favicon_path'] = $file->filepath;      $_POST['toggle_favicon'] = 1;    }  }  // Toggle settings  $toggles = array(    'logo'                 => t('Logo'),    'name'                 => t('Site name'),    'slogan'               => t('Site slogan'),    'mission'              => t('Mission statement'),    'node_user_picture'    => t('User pictures in posts'),    'comment_user_picture' => t('User pictures in comments'),    'search'               => t('Search box'),    'favicon'              => t('Shortcut icon'),    'primary_links'        => t('Primary links'),    'secondary_links'      => t('Secondary links'),  );  // Some features are not always available  $disabled = array();  if (!variable_get('user_pictures', 0)) {    $disabled['toggle_node_user_picture'] = TRUE;    $disabled['toggle_comment_user_picture'] = TRUE;  }  if (!module_exists('search')) {    $disabled['toggle_search'] = TRUE;  }  $form['theme_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Toggle display'),    '#description' => t('Enable or disable the display of certain page elements.'),  );  foreach ($toggles as $name => $title) {    if ((!$key) || in_array($name, $features)) {      $form['theme_settings']['toggle_'. $name] = array('#type' => 'checkbox', '#title' => $title, '#default_value' => $settings['toggle_'. $name]);      // Disable checkboxes for features not supported in the current configuration.      if (isset($disabled['toggle_'. $name])) {        $form['theme_settings']['toggle_'. $name]['#disabled'] = TRUE;      }    }  }  // System wide only settings.  if (!$key) {    // Create neat 2-column layout for the toggles    $form['theme_settings'] += array(      '#prefix' => '<div class="theme-settings-left">',      '#suffix' => '</div>',    );    // Toggle node display.    $node_types = node_get_types('names');    if ($node_types) {      $form['node_info'] = array(        '#type' => 'fieldset',        '#title' => t('Display post information on'),        '#description' => t('Enable or disable the <em>submitted by Username on date</em> text when displaying posts of the following type.'),        '#prefix' => '<div class="theme-settings-right">',        '#suffix' => '</div>',      );      foreach ($node_types as $type => $name) {        $form['node_info']["toggle_node_info_$type"] = array('#type' => 'checkbox', '#title' => check_plain($name), '#default_value' => $settings["toggle_node_info_$type"]);      }    }  }  elseif (!element_children($form['theme_settings'])) {    // If there is no element in the theme settings fieldset then do not show    // it -- but keep it in the form if another module wants to alter.    $form['theme_settings']['#access'] = FALSE;  }  // Logo settings  if ((!$key) || in_array('logo', $features)) {    $form['logo'] = array(      '#type' => 'fieldset',      '#title' => t('Logo image settings'),      '#description' => t('If toggled on, the following logo will be displayed.'),      '#attributes' => array('class' => 'theme-settings-bottom'),    );    $form['logo']["default_logo"] = array(      '#type' => 'checkbox',      '#title' => t('Use the default logo'),      '#default_value' => $settings['default_logo'],      '#tree' => FALSE,      '#description' => t('Check here if you want the theme to use the logo supplied with it.')    );    $form['logo']['logo_path'] = array(      '#type' => 'textfield',      '#title' => t('Path to custom logo'),      '#default_value' => $settings['logo_path'],      '#description' => t('The path to the file you would like to use as your logo file instead of the default logo.'));    $form['logo']['logo_upload'] = array(      '#type' => 'file',      '#title' => t('Upload logo image'),      '#maxlength' => 40,      '#description' => t("If you don't have direct file access to the server, use this field to upload your logo.")    );  }  if ((!$key) || in_array('favicon', $features)) {    $form['favicon'] = array(      '#type' => 'fieldset',      '#title' => t('Shortcut icon settings'),      '#description' => t("Your shortcut icon, or 'favicon', is displayed in the address bar and bookmarks of most browsers.")    );    $form['favicon']['default_favicon'] = array(      '#type' => 'checkbox',      '#title' => t('Use the default shortcut icon.'),      '#default_value' => $settings['default_favicon'],      '#description' => t('Check here if you want the theme to use the default shortcut icon.')    );    $form['favicon']['favicon_path'] = array(      '#type' => 'textfield',      '#title' => t('Path to custom icon'),      '#default_value' => $settings['favicon_path'],      '#description' => t('The path to the image file you would like to use as your custom shortcut icon.')    );    $form['favicon']['favicon_upload'] = array(      '#type' => 'file',      '#title' => t('Upload icon image'),      '#description' => t("If you don't have direct file access to the server, use this field to upload your shortcut icon.")    );  }  if ($key) {    // Include the theme's theme-settings.php file    $filename = './'. str_replace("/$key.info", '', $themes[$key]->filename) .'/theme-settings.php';    if (!file_exists($filename) and !empty($themes[$key]->info['base theme'])) {      // If the theme doesn't have a theme-settings.php file, use the base theme's.      $base = $themes[$key]->info['base theme'];      $filename = './'. str_replace("/$base.info", '', $themes[$base]->filename) .'/theme-settings.php';    }    if (file_exists($filename)) {      require_once $filename;    }    // Call engine-specific settings.    $function = $themes[$key]->prefix .'_engine_settings';    if (function_exists($function)) {      $group = $function($settings);      if (!empty($group)) {        $form['engine_specific'] = array('#type' => 'fieldset', '#title' => t('Theme-engine-specific settings'), '#description' => t('These settings only exist for all the templates and styles based on the %engine theme engine.', array('%engine' => $themes[$key]->prefix)));        $form['engine_specific'] = array_merge($form['engine_specific'], $group);      }    }    // Call theme-specific settings.    $function = $key .'_settings';    if (!function_exists($function)) {      $function = $themes[$key]->prefix .'_settings';    }    if (function_exists($function)) {      $group = $function($settings);      if (!empty($group)) {        $form['theme_specific'] = array('#type' => 'fieldset', '#title' => t('Theme-specific settings'), '#description' => t('These settings only exist for the %theme theme and all the styles based on it.', array('%theme' => $themes[$key]->info['name'])));        $form['theme_specific'] = array_merge($form['theme_specific'], $group);      }    }  }  $form['#attributes'] = array('enctype' => 'multipart/form-data');  $form = system_settings_form($form);  // We don't want to call system_settings_form_submit(), so change #submit.  $form['#submit'] = array('system_theme_settings_submit');  return $form;}/** * Process system_theme_settings form submissions. */function system_theme_settings_submit($form, &$form_state) {  $values = $form_state['values'];  $key = $values['var'];  if ($values['op'] == t('Reset to defaults')) {    variable_del($key);    drupal_set_message(t('The configuration options have been reset to their default values.'));  }  else {    // Exclude unnecessary elements before saving.    unset($values['var'], $values['submit'], $values['reset'], $values['form_id'], $values['op'], $values['form_build_id'], $values['form_token']);    variable_set($key, $values);    drupal_set_message(t('The configuration options have been saved.'));  }  cache_clear_all();}/** * Recursively check compatibility. * * @param $incompatible *   An associative array which at the end of the check contains all incompatible files as the keys, their values being TRUE. * @param $files *   The set of files that will be tested. * @param $file *   The file at which the check starts. * @return *   Returns TRUE if an incompatible file is found, NULL (no return value) otherwise. */function _system_is_incompatible(&$incompatible, $files, $file) {  static $seen;  // We need to protect ourselves in case of a circular dependency.  if (isset($seen[$file->name])) {    return isset($incompatible[$file->name]);  }  $seen[$file->name] = TRUE;  if (isset($incompatible[$file->name])) {    return TRUE;  }  // The 'dependencies' key in .info files was a string in Drupal 5, but changed  // to an array in Drupal 6. If it is not an array, the module is not  // compatible and we can skip the check below which requires an array.  if (!is_array($file->info['dependencies'])) {    $file->info['dependencies'] = array();    $incompatible[$file->name] = TRUE;    return TRUE;  }  // Recursively traverse the dependencies, looking for incompatible modules  foreach ($file->info['dependencies'] as $dependency) {    if (isset($files[$dependency]) && _system_is_incompatible($incompatible, $files, $files[$dependency])) {      $incompatible[$file->name] = TRUE;      return TRUE;    }  }}/** * Menu callback; provides module enable/disable interface. * * Modules can be enabled or disabled and set for throttling if the throttle module is enabled. * The list of modules gets populated by module.info files, which contain each module's name, * description and dependencies. * @see drupal_parse_info_file for information on module.info descriptors. * * Dependency checking is performed to ensure that a module cannot be enabled if the module has * disabled dependencies and also to ensure that the module cannot be disabled if the module has * enabled dependents. * * @param $form_state *   An associative array containing the current state of the form. * @ingroup forms * @see theme_system_modules() * @see system_modules_submit() * @return *   The form array. */function system_modules($form_state = array()) {  // Get current list of modules.  $files = module_rebuild_cache();  uasort($files, 'system_sort_modules_by_info_name');  if (!empty($form_state['storage'])) {    return system_modules_confirm_form($files, $form_state['storage']);  }  $dependencies = array();  // Store module list for validation callback.  $form['validation_modules'] = array('#type' => 'value', '#value' => $files);  // Create storage for disabled modules as browser will disable checkboxes.  $form['disabled_modules'] = array('#type' => 'value', '#value' => array());  // Traverse the files, checking for compatibility  $incompatible_core = array();  $incompatible_php = array();  foreach ($files as $filename => $file) {    // Ensure this module is compatible with this version of core.    if (!isset($file->info['core']) || $file->info['core'] != DRUPAL_CORE_COMPATIBILITY) {      $incompatible_core[$file->name] = $file->name;    }    // Ensure this module is compatible with the currently installed version of PHP.    if (version_compare(phpversion(), $file->info['php']) < 0) {      $incompatible_php[$file->name] = $file->info['php'];    }  }  // Array for disabling checkboxes in callback system_module_disable.  $disabled = array();  $throttle = array();  // Traverse the files retrieved and build the form.  foreach ($files as $filename => $file) {    $form['name'][$filename] = array('#value' => $file->info['name']);    $form['version'][$filename] = array('#value' => $file->info['version']);    $form['description'][$filename] = array('#value' => t($file->info['description']));    $options[$filename] = '';    // Ensure this module is compatible with this version of core and php.    if (_system_is_incompatible($incompatible_core, $files, $file) || _system_is_incompatible($incompatible_php, $files, $file)) {      $disabled[] = $file->name;      // Nothing else in this loop matters, so move to the next module.      continue;    }    if ($file->status) {      $status[] = $file->name;    }    if ($file->throttle) {      $throttle[] = $file->name;    }    $dependencies = array();    // Check for missing dependencies.    if (is_array($file->info['dependencies'])) {      foreach ($file->info['dependencies'] as $dependency) {        if (!isset($files[$dependency]) || !$files[$dependency]->status) {          if (isset($files[$dependency])) {            $dependencies[] = t('@module (<span class="admin-disabled">disabled</span>)', array('@module' => $files[$dependency]->info['name']));          }          else {            $dependencies[] = t('@module (<span class="admin-missing">missing</span>)', array('@module' => drupal_ucfirst($dependency)));            $disabled[] = $filename;            $form['disabled_modules']['#value'][$filename] = FALSE;          }        }        else {          $dependencies[] = t('@module (<span class="admin-enabled">enabled</span>)', array('@module' => $files[$dependency]->info['name']));        }      }      // Add text for dependencies.      if (!empty($dependencies)) {        $form['description'][$filename]['dependencies'] = array(          '#value' => t('Depends on: !dependencies', array('!dependencies' => implode(', ', $dependencies))),          '#prefix' => '<div class="admin-dependencies">',          '#suffix' => '</div>',        );      }    }    // Mark dependents disabled so user can not remove modules being depended on.    $dependents = array();    foreach ($file->info['dependents'] as $dependent) {      if ($files[$dependent]->status == 1) {        $dependents[] = t('@module (<span class="admin-enabled">enabled</span>)', array('@module' => $files[$dependent]->info['name']));        $disabled[] = $filename;        $form['disabled_modules']['#value'][$filename] = TRUE;      }      else {        $dependents[] = t('@module (<span class="admin-disabled">disabled</span>)', array('@module' => $files[$dependent]->info['name']));      }    }    // Add text for enabled dependents.    if (!empty($dependents)) {      $form['description'][$filename]['required'] = array(        '#value' => t('Required by: !required', array('!required' => implode(', ', $dependents))),        '#prefix' => '<div class="admin-required">',        '#suffix' => '</div>',      );    }  }  $modules_required = drupal_required_modules();  // Merge in required modules.  foreach ($modules_required as $required) {    $disabled[] = $required;    $form['disabled_modules']['#value'][$required] = TRUE;  }  // Handle status checkboxes, including overriding  // the generated checkboxes for required modules.  $form['status'] = array(    '#type' => 'checkboxes',    '#default_value' => $status,    '#options' => $options,    '#process' => array(      'expand_checkboxes',      'system_modules_disable',    ),    '#disabled_modules' => $disabled,    '#incompatible_modules_core' => $incompatible_core,    '#incompatible_modules_php' => $incompatible_php,  );  // Handle throttle checkboxes, including overriding the  // generated checkboxes for required modules.  if (module_exists('throttle')) {    $form['throttle'] = array(      '#type' => 'checkboxes',      '#default_value' => $throttle,      '#options' => $options,      '#process' => array(        'expand_checkboxes',        'system_modules_disable',      ),      '#disabled_modules' => array_merge($modules_required, array('throttle')),    );  }  $form['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Save configuration'),  );  $form['#action'] = url('admin/build/modules/list/confirm');  return $form;}/** * Array sorting callback; sorts modules or themes by their name. */function system_sort_modules_by_info_name($a, $b) {  return strcasecmp($a->info['name'], $b->info['name']);}/** * Form process callback function to disable check boxes. * * @param $form *   The form structure. * @param $edit *   Not used. * @ingroup forms * @return *   The form structure. */function system_modules_disable($form, $edit) {  foreach ($form['#disabled_modules'] as $key) {    $form[$key]['#attributes']['disabled'] = 'disabled';  }  return $form;}/** * Display confirmation form for dependencies. * * @param $modules *   Array of module file objects as returned from module_rebuild_cache(). * @param $storage *   The contents of $form_state['storage']; an array with two *   elements: the list of dependencies and the list of status *   form field values from the previous screen. * @ingroup forms */function system_modules_confirm_form($modules, $storage) {  $form = array();  $items = array();  list($dependencies, $status) = $storage;  $form['validation_modules'] = array('#type' => 'value', '#value' => $modules);  $form['status']['#tree'] = TRUE;  // Remember list of modules selected on the module listing page already.  foreach ($status as $key => $choice) {    $form['status'][$key] = array('#type' => 'value', '#value' => $choice);  }  foreach ($dependencies as $name => $missing_dependencies) {    $form['status'][$name] = array('#type' => 'hidden', '#value' => 1);    foreach ($missing_dependencies as $k => $dependency) {      $form['status'][$dependency] = array('#type' => 'hidden', '#value' => 1);      $info = $modules[$dependency]->info;      $missing_dependencies[$k] = $info['name'] ? $info['name'] : drupal_ucfirst($dependency);    }    $t_argument = array(      '@module' => $modules[$name]->info['name'],      '@dependencies' => implode(', ', $missing_dependencies),    );    $items[] = format_plural(count($missing_dependencies), 'You must enable the @dependencies module to install @module.', 'You must enable the @dependencies modules to install @module.', $t_argument);  }  $form['text'] = array('#value' => theme('item_list', $items));  if ($form) {    // Set some default form values    $form = confirm_form(      $form,      t('Some required modules must be enabled'),      'admin/build/modules',      t('Would you like to continue with enabling the above?'),      t('Continue'),      t('Cancel'));    return $form;  }}/** * Submit callback; handles modules form submission. */function system_modules_submit($form, &$form_state) {  include_once './includes/install.inc';  $new_modules = array();  // If we are coming from the confirm form...  if (!isset($form_state['storage'])) {    // Merge in disabled active modules since they should be enabled.    // They don't appear because disabled checkboxes are not submitted    // by browsers.    $form_state['values']['status'] = array_merge($form_state['values']['status'], $form_state['values']['disabled_modules']);    // Check values for dependency that we can't install.    if ($dependencies = system_module_build_dependencies($form_state['values']['validation_modules'], $form_state['values'])) {      // These are the modules that depend on existing modules.      foreach (array_keys($dependencies) as $name) {        $form_state['values']['status'][$name] = 0;      }    }  }  else {    $dependencies = NULL;  }  // Update throttle settings, if present  if (isset($form_state['values']['throttle'])) {    foreach ($form_state['values']['throttle'] as $key => $choice) {      db_query("UPDATE {system} SET throttle = %d WHERE type = 'module' and name = '%s'", $choice ? 1 : 0, $key);    }  }  // If there where unmet dependencies and they haven't confirmed don't process  // the submission yet. Store the form submission data needed later.  if ($dependencies) {    if (!isset($form_state['values']['confirm'])) {      $form_state['storage'] = array($dependencies, $form_state['values']['status']);      return;    }    else {      $form_state['values']['status'] = array_merge($form_state['values']['status'], $form_storage[1]);    }  }  // If we have no dependencies, or the dependencies are confirmed  // to be installed, we don't need the temporary storage anymore.  unset($form_state['storage']);  $enable_modules = array();  $disable_modules = array();  foreach ($form_state['values']['status'] as $key => $choice) {    if ($choice) {      if (drupal_get_installed_schema_version($key) == SCHEMA_UNINSTALLED) {        $new_modules[] = $key;      }      else {        $enable_modules[] = $key;      }    }    else {      $disable_modules[] = $key;    }  }  $old_module_list = module_list();  if (!empty($enable_modules)) {    module_enable($enable_modules);  }  if (!empty($disable_modules)) {    module_disable($disable_modules);  }  // Install new modules.  foreach ($new_modules as $key => $module) {    if (!drupal_check_module($module)) {      unset($new_modules[$key]);    }  }  drupal_install_modules($new_modules);  $current_module_list = module_list(TRUE, FALSE);  if ($old_module_list != $current_module_list) {    drupal_set_message(t('The configuration options have been saved.'));  }  drupal_rebuild_theme_registry();  node_types_rebuild();  menu_rebuild();  cache_clear_all('schema', 'cache');  drupal_clear_css_cache();  drupal_clear_js_cache();  $form_state['redirect'] = 'admin/build/modules';  // Notify locale module about module changes, so translations can be  // imported. This might start a batch, and only return to the redirect  // path after that.  module_invoke('locale', 'system_update', $new_modules);  // Synchronize to catch any actions that were added or removed.  actions_synchronize();  return;}/** * Generate a list of dependencies for modules that are going to be switched on. * * @param $modules *   The list of modules to check. * @param $form_values *   Submitted form values used to determine what modules have been enabled. * @return *   An array of dependencies. */function system_module_build_dependencies($modules, $form_values) {  static $dependencies;  if (!isset($dependencies) && isset($form_values)) {    $dependencies = array();    foreach ($modules as $name => $module) {      // If the module is disabled, will be switched on and it has dependencies.      if (!$module->status && $form_values['status'][$name] && isset($module->info['dependencies'])) {        foreach ($module->info['dependencies'] as $dependency) {          if (!$form_values['status'][$dependency] && isset($modules[$dependency])) {            if (!isset($dependencies[$name])) {              $dependencies[$name] = array();            }            $dependencies[$name][] = $dependency;          }        }      }    }  }  return $dependencies;}/** * Uninstall functions *//** * Builds a form of currently disabled modules. * * @ingroup forms * @see system_modules_uninstall_validate() * @see system_modules_uninstall_submit() * @param $form_state['values'] *   Submitted form values. * @return *   A form array representing the currently disabled modules. */function system_modules_uninstall($form_state = NULL) {  // Make sure the install API is available.  include_once './includes/install.inc';  // Display the confirm form if any modules have been submitted.  if (isset($form_state) && $confirm_form = system_modules_uninstall_confirm_form($form_state['storage'])) {    return $confirm_form;  }  $form = array();  // Pull all disabled modules from the system table.  $disabled_modules = db_query("SELECT name, filename, info FROM {system} WHERE type = 'module' AND status = 0 AND schema_version > %d ORDER BY name", SCHEMA_UNINSTALLED);  while ($module = db_fetch_object($disabled_modules)) {    // Grab the module info    $info = unserialize($module->info);    // Load the .install file, and check for an uninstall hook.    // If the hook exists, the module can be uninstalled.    module_load_install($module->name);    if (module_hook($module->name, 'uninstall')) {      $form['modules'][$module->name]['name'] = array('#value' => $info['name'] ? $info['name'] : $module->name);      $form['modules'][$module->name]['description'] = array('#value' => t($info['description']));      $options[$module->name] = '';    }  }  // Only build the rest of the form if there are any modules available to uninstall.  if (!empty($options)) {    $form['uninstall'] = array(      '#type' => 'checkboxes',      '#options' => $options,    );    $form['buttons']['submit'] = array(      '#type' => 'submit',      '#value' => t('Uninstall'),    );    $form['#action'] = url('admin/build/modules/uninstall/confirm');  }  else {    $form['modules'] = array();  }  return $form;}/** * Confirm uninstall of selected modules. * * @ingroup forms * @param $storage *   An associative array of modules selected to be uninstalled. * @return *   A form array representing modules to confirm. */function system_modules_uninstall_confirm_form($storage) {  // Nothing to build.  if (!isset($storage)) {    return;  }  // Construct the hidden form elements and list items.  foreach (array_filter($storage['uninstall']) as $module => $value) {    $info = drupal_parse_info_file(dirname(drupal_get_filename('module', $module)) .'/'. $module .'.info');    $uninstall[] = $info['name'];    $form['uninstall'][$module] = array('#type' => 'hidden',      '#value' => 1,    );  }  // Display a confirm form if modules have been selected.  if (isset($uninstall)) {    $form['#confirmed'] = TRUE;    $form['uninstall']['#tree'] = TRUE;    $form['modules'] = array('#value' => '<p>'. t('The following modules will be completely uninstalled from your site, and <em>all data from these modules will be lost</em>!') .'</p>'. theme('item_list', $uninstall));    $form = confirm_form(      $form,      t('Confirm uninstall'),      'admin/build/modules/uninstall',      t('Would you like to continue with uninstalling the above?'),      t('Uninstall'),      t('Cancel'));    return $form;  }}/** * Validates the submitted uninstall form. */function system_modules_uninstall_validate($form, &$form_state) {  // Form submitted, but no modules selected.  if (!count(array_filter($form_state['values']['uninstall']))) {    drupal_set_message(t('No modules selected.'), 'error');    drupal_goto('admin/build/modules/uninstall');  }}/** * Processes the submitted uninstall form. */function system_modules_uninstall_submit($form, &$form_state) {  // Make sure the install API is available.  include_once './includes/install.inc';  if (!empty($form['#confirmed'])) {    // Call the uninstall routine for each selected module.    foreach (array_filter($form_state['values']['uninstall']) as $module => $value) {      drupal_uninstall_module($module);    }    drupal_set_message(t('The selected modules have been uninstalled.'));    unset($form_state['storage']);    $form_state['redirect'] = 'admin/build/modules/uninstall';  }  else {    $form_state['storage'] = $form_state['values'];  }}/** * Form builder; The general site information form. * * @ingroup forms * @see system_settings_form() */function system_site_information_settings() {  $form['site_name'] = array(    '#type' => 'textfield',    '#title' => t('Name'),    '#default_value' => variable_get('site_name', 'Drupal'),    '#description' => t('The name of this website.'),    '#required' => TRUE  );  $form['site_mail'] = array(    '#type' => 'textfield',    '#title' => t('E-mail address'),    '#default_value' => variable_get('site_mail', ini_get('sendmail_from')),    '#description' => t("The <em>From</em> address in automated e-mails sent during registration and new password requests, and other notifications. (Use an address ending in your site's domain to help prevent this e-mail being flagged as spam.)"),    '#required' => TRUE,  );  $form['site_slogan'] = array(    '#type' => 'textfield',    '#title' => t('Slogan'),    '#default_value' => variable_get('site_slogan', ''),    '#description' => t("Your site's motto, tag line, or catchphrase (often displayed alongside the title of the site).")  );  $form['site_mission'] = array(    '#type' => 'textarea',    '#title' => t('Mission'),    '#default_value' => variable_get('site_mission', ''),    '#description' => t("Your site's mission or focus statement (often prominently displayed on the front page).")  );  $form['site_footer'] = array(    '#type' => 'textarea',    '#title' => t('Footer message'),    '#default_value' => variable_get('site_footer', ''),    '#description' => t('This text will be displayed at the bottom of each page. Useful for adding a copyright notice to your pages.')  );  $form['anonymous'] = array(    '#type' => 'textfield',    '#title' => t('Anonymous user'),    '#default_value' => variable_get('anonymous', t('Anonymous')),    '#description' => t('The name used to indicate anonymous users.'),    '#required' => TRUE,  );  $form['site_frontpage'] = array(    '#type' => 'textfield',    '#title' => t('Default front page'),    '#default_value' => variable_get('site_frontpage', 'node'),    '#size' => 40,    '#description' => t('The home page displays content from this relative URL. If unsure, specify "node".'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q='),    '#required' => TRUE,  );  $form['#validate'][] = 'system_site_information_settings_validate';  return system_settings_form($form);}/** * Validate the submitted site-information form. */function system_site_information_settings_validate($form, &$form_state) {  // Validate the e-mail address.  if ($error = user_validate_mail($form_state['values']['site_mail'])) {    form_set_error('site_mail', $error);  }  // Validate front page path.  $item = array('link_path' => $form_state['values']['site_frontpage']);  $normal_path = drupal_get_normal_path($item['link_path']);  if ($item['link_path'] != $normal_path) {    drupal_set_message(t('The menu system stores system paths only, but will use the URL alias for display. %link_path has been stored as %normal_path', array('%link_path' => $item['link_path'], '%normal_path' => $normal_path)));    $item['link_path'] = $normal_path;  }  if (!empty($item) && !menu_valid_path($item)) {    form_set_error('site_frontpage', t("The path '@path' is either invalid or you do not have access to it.", array('@path' => $item['link_path'])));  }}/** * Form builder; Configure error reporting settings. * * @ingroup forms * @see system_settings_form() */function system_error_reporting_settings() {  $form['site_403'] = array(    '#type' => 'textfield',    '#title' => t('Default 403 (access denied) page'),    '#default_value' => variable_get('site_403', ''),    '#size' => 40,    '#description' => t('This page is displayed when the requested document is denied to the current user. If unsure, specify nothing.'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q=')  );  $form['site_404'] = array(    '#type' => 'textfield',    '#title' => t('Default 404 (not found) page'),    '#default_value' => variable_get('site_404', ''),    '#size' => 40,    '#description' => t('This page is displayed when no other content matches the requested document. If unsure, specify nothing.'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q=')  );  $form['error_level'] = array(    '#type' => 'select', '#title' => t('Error reporting'), '#default_value' => variable_get('error_level', 1),    '#options' => array(t('Write errors to the log'), t('Write errors to the log and to the screen')),    '#description' => t('Specify where Drupal, PHP and SQL errors are logged. While it is recommended that a site running in a production environment write errors to the log only, in a development or testing environment it may be helpful to write errors both to the log and to the screen.')  );  return system_settings_form($form);}/** * Menu callback; Menu page for the various logging options. */function system_logging_overview() {  $item = menu_get_item('admin/settings/logging');  $content = system_admin_menu_block($item);  $output = theme('admin_block_content', $content);  return $output;}/** * Form builder; Configure site performance settings. * * @ingroup forms * @see system_settings_form() */function system_performance_settings() {  $description = '<p>'. t("The normal cache mode is suitable for most sites and does not cause any side effects. The aggressive cache mode causes Drupal to skip the loading (boot) and unloading (exit) of enabled modules when serving a cached page. This results in an additional performance boost but can cause unwanted side effects.") .'</p>';  $problem_modules = array_unique(array_merge(module_implements('boot'), module_implements('exit')));  sort($problem_modules);  if (count($problem_modules) > 0) {    $description .= '<p>'. t('<strong class="error">The following enabled modules are incompatible with aggressive mode caching and will not function properly: %modules</strong>', array('%modules' => implode(', ', $problem_modules))) .'.</p>';  }  else {    $description .= '<p>'. t('<strong class="ok">Currently, all enabled modules are compatible with the aggressive caching policy.</strong> Please note, if you use aggressive caching and enable new modules, you will need to check this page again to ensure compatibility.') .'</p>';  }  $form['page_cache'] = array(    '#type' => 'fieldset',    '#title' => t('Page cache'),    '#description' => t('Enabling the page cache will offer a significant performance boost. Drupal can store and send compressed cached pages requested by <em>anonymous</em> users. By caching a web page, Drupal does not have to construct the page each time it is viewed.'),  );  $form['page_cache']['cache'] = array(    '#type' => 'radios',    '#title' => t('Caching mode'),    '#default_value' => variable_get('cache', CACHE_DISABLED),    '#options' => array(CACHE_DISABLED => t('Disabled'), CACHE_NORMAL => t('Normal (recommended for production sites, no side effects)'), CACHE_AGGRESSIVE => t('Aggressive (experts only, possible side effects)')),    '#description' => $description  );  $period = drupal_map_assoc(array(0, 60, 180, 300, 600, 900, 1800, 2700, 3600, 10800, 21600, 32400, 43200, 86400), 'format_interval');  $period[0] = '<'. t('none') .'>';  $form['page_cache']['cache_lifetime'] = array(    '#type' => 'select',    '#title' => t('Minimum cache lifetime'),    '#default_value' => variable_get('cache_lifetime', 0),    '#options' => $period,    '#description' => t('On high-traffic sites, it may be necessary to enforce a minimum cache lifetime. The minimum cache lifetime is the minimum amount of time that will elapse before the cache is emptied and recreated, and is applied to both page and block caches. A larger minimum cache lifetime offers better performance, but users will not see new content for a longer period of time.')  );  $form['page_cache']['page_compression'] = array(    '#type' => 'radios',    '#title' => t('Page compression'),    '#default_value' => variable_get('page_compression', TRUE),    '#options' => array(t('Disabled'), t('Enabled')),    '#description' => t("By default, Drupal compresses the pages it caches in order to save bandwidth and improve download times. This option should be disabled when using a webserver that performs compression."),  );  $form['block_cache'] = array(    '#type' => 'fieldset',    '#title' => t('Block cache'),    '#description' => t('Enabling the block cache can offer a performance increase for all users by preventing blocks from being reconstructed on each page load. If the page cache is also enabled, performance increases from enabling the block cache will mainly benefit authenticated users.'),  );  $form['block_cache']['block_cache'] = array(    '#type' => 'radios',    '#title' => t('Block cache'),    '#default_value' => variable_get('block_cache', CACHE_DISABLED),    '#options' => array(CACHE_DISABLED => t('Disabled'), CACHE_NORMAL => t('Enabled (recommended)')),    '#disabled' => count(module_implements('node_grants')),    '#description' => t('Note that block caching is inactive when modules defining content access restrictions are enabled.'),  );  $form['bandwidth_optimizations'] = array(    '#type' => 'fieldset',    '#title' => t('Bandwidth optimizations'),    '#description' => t('<p>Drupal can automatically optimize external resources like CSS and JavaScript, which can reduce both the size and number of requests made to your website. CSS files can be aggregated and compressed into a single file, while JavaScript files are aggregated (but not compressed). These optional optimizations may reduce server load, bandwidth requirements, and page loading times.</p><p>These options are disabled if you have not set up your files directory, or if your download method is set to private.</p>')  );  $directory = file_directory_path();  $is_writable = is_dir($directory) && is_writable($directory) && (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC);  $form['bandwidth_optimizations']['preprocess_css'] = array(    '#type' => 'radios',    '#title' => t('Optimize CSS files'),    '#default_value' => intval(variable_get('preprocess_css', 0) && $is_writable),    '#disabled' => !$is_writable,    '#options' => array(t('Disabled'), t('Enabled')),    '#description' => t('This option can interfere with theme development and should only be enabled in a production environment.'),  );  $form['bandwidth_optimizations']['preprocess_js'] = array(    '#type' => 'radios',    '#title' => t('Optimize JavaScript files'),    '#default_value' => intval(variable_get('preprocess_js', 0) && $is_writable),    '#disabled' => !$is_writable,    '#options' => array(t('Disabled'), t('Enabled')),    '#description' => t('This option can interfere with module development and should only be enabled in a production environment.'),  );  $form['clear_cache'] = array(    '#type' => 'fieldset',    '#title' => t('Clear cached data'),    '#description' => t('Caching data improves performance, but may cause problems while troubleshooting new modules, themes, or translations, if outdated information has been cached. To refresh all cached data on your site, click the button below. <em>Warning: high-traffic sites will experience performance slowdowns while cached data is rebuilt.</em>'),  );  $form['clear_cache']['clear'] = array(    '#type' => 'submit',    '#value' => t('Clear cached data'),    '#submit' => array('system_clear_cache_submit'),  );  $form['#submit'][] = 'drupal_clear_css_cache';  $form['#submit'][] = 'drupal_clear_js_cache';  return system_settings_form($form);}/** * Submit callback; clear system caches. * * @ingroup forms */function system_clear_cache_submit($form, &$form_state) {  drupal_flush_all_caches();  drupal_set_message(t('Caches cleared.'));}/** * Form builder; Configure the site file handling. * * @ingroup forms * @see system_settings_form() */function system_file_system_settings() {  $form['file_directory_path'] = array(    '#type' => 'textfield',    '#title' => t('File system path'),    '#default_value' => file_directory_path(),    '#maxlength' => 255,    '#description' => t('A file system path where the files will be stored. This directory must exist and be writable by Drupal. If the download method is set to public, this directory must be relative to the Drupal installation directory and be accessible over the web. If the download method is set to private, this directory should not be accessible over the web. Changing this location will modify all download paths and may cause unexpected problems on an existing site.'),    '#after_build' => array('system_check_directory'),  );  $form['file_directory_temp'] = array(    '#type' => 'textfield',    '#title' => t('Temporary directory'),    '#default_value' => file_directory_temp(),    '#maxlength' => 255,    '#description' => t('A file system path where uploaded files will be stored during previews.'),    '#after_build' => array('system_check_directory'),  );  $form['file_downloads'] = array(    '#type' => 'radios',    '#title' => t('Download method'),    '#default_value' => variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC),    '#options' => array(FILE_DOWNLOADS_PUBLIC => t('Public - files are available using HTTP directly.'), FILE_DOWNLOADS_PRIVATE => t('Private - files are transferred by Drupal.')),    '#description' => t('Choose the <em>Public download</em> method unless you wish to enforce fine-grained access controls over file downloads. Changing the download method will modify all download paths and may cause unexpected problems on an existing site.')  );  return system_settings_form($form);}/** * Form builder; Configure site image toolkit usage. * * @ingroup forms * @see system_settings_form() */function system_image_toolkit_settings() {  $toolkits_available = image_get_available_toolkits();  if (count($toolkits_available) > 1) {    $form['image_toolkit'] = array(      '#type' => 'radios',      '#title' => t('Select an image processing toolkit'),      '#default_value' => variable_get('image_toolkit', image_get_toolkit()),      '#options' => $toolkits_available    );  }  elseif (count($toolkits_available) == 1) {    variable_set('image_toolkit', key($toolkits_available));  }  $form['image_toolkit_settings'] = image_toolkit_invoke('settings');  return system_settings_form($form);}/** * Form builder; Configure how the site handles RSS feeds. * * @ingroup forms * @see system_settings_form() */function system_rss_feeds_settings() {  $form['feed_default_items'] = array(    '#type' => 'select',    '#title' => t('Number of items in each feed'),    '#default_value' => variable_get('feed_default_items', 10),    '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30)),    '#description' => t('Default number of items to include in each feed.')  );  $form['feed_item_length'] = array(    '#type' => 'select',    '#title' => t('Feed content'),    '#default_value' => variable_get('feed_item_length', 'teaser'),    '#options' => array('title' => t('Titles only'), 'teaser' => t('Titles plus teaser'), 'fulltext' => t('Full text')),    '#description' => t('Global setting for the default display of content items in each feed.')  );  return system_settings_form($form);}/** * Form builder; Configure the site date and time settings. * * @ingroup forms * @see system_settings_form() * @see system_date_time_settings_submit() */function system_date_time_settings() {  drupal_add_js(drupal_get_path('module', 'system') .'/system.js', 'module');  drupal_add_js(array('dateTime' => array('lookup' => url('admin/settings/date-time/lookup'))), 'setting');  // Date settings:  $zones = _system_zonelist();  // Date settings: possible date formats  $date_short = array('Y-m-d H:i', 'm/d/Y - H:i', 'd/m/Y - H:i', 'Y/m/d - H:i',           'd.m.Y - H:i', 'm/d/Y - g:ia', 'd/m/Y - g:ia', 'Y/m/d - g:ia',           'M j Y - H:i', 'j M Y - H:i', 'Y M j - H:i',           'M j Y - g:ia', 'j M Y - g:ia', 'Y M j - g:ia');  $date_medium = array('D, Y-m-d H:i', 'D, m/d/Y - H:i', 'D, d/m/Y - H:i',          'D, Y/m/d - H:i', 'F j, Y - H:i', 'j F, Y - H:i', 'Y, F j - H:i',          'D, m/d/Y - g:ia', 'D, d/m/Y - g:ia', 'D, Y/m/d - g:ia',          'F j, Y - g:ia', 'j F Y - g:ia', 'Y, F j - g:ia', 'j. F Y - G:i');  $date_long = array('l, F j, Y - H:i', 'l, j F, Y - H:i', 'l, Y, F j - H:i',        'l, F j, Y - g:ia', 'l, j F Y - g:ia', 'l, Y, F j - g:ia', 'l, j. F Y - G:i');  // Date settings: construct choices for user  foreach ($date_short as $f) {    $date_short_choices[$f] = format_date(time(), 'custom', $f);  }  foreach ($date_medium as $f) {    $date_medium_choices[$f] = format_date(time(), 'custom', $f);  }  foreach ($date_long as $f) {    $date_long_choices[$f] = format_date(time(), 'custom', $f);  }  $date_long_choices['custom'] = $date_medium_choices['custom'] = $date_short_choices['custom'] = t('Custom format');  $form['locale'] = array(    '#type' => 'fieldset',    '#title' => t('Locale settings'),  );  $form['locale']['date_default_timezone'] = array(    '#type' => 'select',    '#title' => t('Default time zone'),    '#default_value' => variable_get('date_default_timezone', 0),    '#options' => $zones,    '#description' => t('Select the default site time zone.')  );  $form['locale']['configurable_timezones'] = array(    '#type' => 'radios',    '#title' => t('User-configurable time zones'),    '#default_value' => variable_get('configurable_timezones', 1),    '#options' => array(t('Disabled'), t('Enabled')),    '#description' => t('When enabled, users can set their own time zone and dates will be displayed accordingly.')  );  $form['locale']['date_first_day'] = array(    '#type' => 'select',    '#title' => t('First day of week'),    '#default_value' => variable_get('date_first_day', 0),    '#options' => array(0 => t('Sunday'), 1 => t('Monday'), 2 => t('Tuesday'), 3 => t('Wednesday'), 4 => t('Thursday'), 5 => t('Friday'), 6 => t('Saturday')),    '#description' => t('The first day of the week for calendar views.')  );  $form['date_formats'] = array(    '#type' => 'fieldset',    '#title' => t('Formatting'),  );  $date_format_short = variable_get('date_format_short', $date_short[1]);  $form['date_formats']['date_format_short'] = array(    '#prefix' => '<div class="date-container"><div class="select-container">',    '#suffix' => '</div>',    '#type' => 'select',    '#title' => t('Short date format'),    '#attributes' => array('class' => 'date-format'),    '#default_value' => (isset($date_short_choices[$date_format_short]) ? $date_format_short : 'custom'),    '#options' => $date_short_choices,    '#description' => t('The short format of date display.'),  );  $default_short_custom = variable_get('date_format_short_custom', (isset($date_short_choices[$date_format_short]) ? $date_format_short : ''));  $form['date_formats']['date_format_short_custom'] = array(    '#prefix' => '<div class="custom-container">',    '#suffix' => '</div></div>',    '#type' => 'textfield',    '#title' => t('Custom short date format'),    '#attributes' => array('class' => 'custom-format'),    '#default_value' => $default_short_custom,    '#description' => t('A user-defined short date format. See the <a href="@url">PHP manual</a> for available options. This format is currently set to display as <span>%date</span>.', array('@url' => 'http://php.net/manual/function.date.php', '%date' => format_date(time(), 'custom', $default_short_custom))),  );  $date_format_medium = variable_get('date_format_medium', $date_medium[1]);  $form['date_formats']['date_format_medium'] = array(    '#prefix' => '<div class="date-container"><div class="select-container">',    '#suffix' => '</div>',    '#type' => 'select',    '#title' => t('Medium date format'),    '#attributes' => array('class' => 'date-format'),    '#default_value' => (isset($date_medium_choices[$date_format_medium]) ? $date_format_medium : 'custom'),    '#options' => $date_medium_choices,    '#description' => t('The medium sized date display.'),  );  $default_medium_custom = variable_get('date_format_medium_custom', (isset($date_medium_choices[$date_format_medium]) ? $date_format_medium : ''));  $form['date_formats']['date_format_medium_custom'] = array(    '#prefix' => '<div class="custom-container">',    '#suffix' => '</div></div>',    '#type' => 'textfield',    '#title' => t('Custom medium date format'),    '#attributes' => array('class' => 'custom-format'),    '#default_value' => $default_medium_custom,    '#description' => t('A user-defined medium date format. See the <a href="@url">PHP manual</a> for available options. This format is currently set to display as <span>%date</span>.', array('@url' => 'http://php.net/manual/function.date.php', '%date' => format_date(time(), 'custom', $default_medium_custom))),  );  $date_format_long = variable_get('date_format_long', $date_long[0]);  $form['date_formats']['date_format_long'] = array(    '#prefix' => '<div class="date-container"><div class="select-container">',    '#suffix' => '</div>',    '#type' => 'select',    '#title' => t('Long date format'),    '#attributes' => array('class' => 'date-format'),    '#default_value' => (isset($date_long_choices[$date_format_long]) ? $date_format_long : 'custom'),    '#options' => $date_long_choices,    '#description' => t('Longer date format used for detailed display.')  );  $default_long_custom = variable_get('date_format_long_custom', (isset($date_long_choices[$date_format_long]) ? $date_format_long : ''));  $form['date_formats']['date_format_long_custom'] = array(    '#prefix' => '<div class="custom-container">',    '#suffix' => '</div></div>',    '#type' => 'textfield',    '#title' => t('Custom long date format'),    '#attributes' => array('class' => 'custom-format'),    '#default_value' => $default_long_custom,    '#description' => t('A user-defined long date format. See the <a href="@url">PHP manual</a> for available options. This format is currently set to display as <span>%date</span>.', array('@url' => 'http://php.net/manual/function.date.php', '%date' => format_date(time(), 'custom', $default_long_custom))),  );  $form = system_settings_form($form);  // We will call system_settings_form_submit() manually, so remove it for now.  unset($form['#submit']);  return $form;}/** * Process system_date_time_settings form submissions. */function system_date_time_settings_submit($form, &$form_state) {  if ($form_state['values']['date_format_short'] == 'custom') {    $form_state['values']['date_format_short'] = $form_state['values']['date_format_short_custom'];  }  if ($form_state['values']['date_format_medium'] == 'custom') {    $form_state['values']['date_format_medium'] = $form_state['values']['date_format_medium_custom'];  }  if ($form_state['values']['date_format_long'] == 'custom') {    $form_state['values']['date_format_long'] = $form_state['values']['date_format_long_custom'];  }  return system_settings_form_submit($form, $form_state);}/** * Return the date for a given format string via Ajax. */function system_date_time_lookup() {  $result = format_date(time(), 'custom', $_GET['format']);  drupal_json($result);}/** * Form builder; Configure the site's maintenance status. * * @ingroup forms * @see system_settings_form() */function system_site_maintenance_settings() {  $form['site_offline'] = array(    '#type' => 'radios',    '#title' => t('Site status'),    '#default_value' => variable_get('site_offline', 0),    '#options' => array(t('Online'), t('Off-line')),    '#description' => t('When set to "Online", all visitors will be able to browse your site normally. When set to "Off-line", only users with the "administer site configuration" permission will be able to access your site to perform maintenance; all other visitors will see the site off-line message configured below. Authorized users can log in during "Off-line" mode directly via the <a href="@user-login">user login</a> page.', array('@user-login' => url('user'))),  );  $form['site_offline_message'] = array(    '#type' => 'textarea',    '#title' => t('Site off-line message'),    '#default_value' => variable_get('site_offline_message', t('@site is currently under maintenance. We should be back shortly. Thank you for your patience.', array('@site' => variable_get('site_name', 'Drupal')))),    '#description' => t('Message to show visitors when the site is in off-line mode.')  );  return system_settings_form($form);}/** * Form builder; Configure Clean URL settings. * * @ingroup forms * @see system_settings_form() */function system_clean_url_settings() {  $form['clean_url'] = array(    '#type' => 'radios',    '#title' => t('Clean URLs'),    '#default_value' => variable_get('clean_url', 0),    '#options' => array(t('Disabled'), t('Enabled')),    '#description' => t('This option makes Drupal emit "clean" URLs (i.e. without <code>?q=</code> in the URL).'),  );  if (!variable_get('clean_url', 0)) {    if (strpos(request_uri(), '?q=') !== FALSE) {      drupal_add_js(drupal_get_path('module', 'system') .'/system.js', 'module');      $form['clean_url']['#description'] .= ' <span>'. t('Before enabling clean URLs, you must perform a test to determine if your server is properly configured. If you are able to see this page again after clicking the "Run the clean URL test" link, the test has succeeded and the radio buttons above will be available. If instead you are directed to a "Page not found" error, you will need to change the configuration of your server. The <a href="@handbook">handbook page on Clean URLs</a> has additional troubleshooting information.', array('@handbook' => 'http://drupal.org/node/15365')) .'</span>';      $form['clean_url']['#disabled'] = TRUE;      $form['clean_url']['#prefix'] = '<div id="clean-url">';      $form['clean_url']['#suffix'] = '<p>'. t('<a href="@clean_url">Run the clean url test</a>.', array('@clean_url' => base_path() .'admin/settings/clean-urls')) .'</p></div>';    }    else {      $form['clean_url']['#description'] .= ' <div class="ok">'. t('Your server has been successfully tested to support this feature.') .'</div>';    }  }  return system_settings_form($form);}/** * Menu callback: displays the site status report. Can also be used as a pure check. * * @param $check *   If true, only returns a boolean whether there are system status errors. */function system_status($check = FALSE) {  // Load .install files  include_once './includes/install.inc';  drupal_load_updates();  // Check run-time requirements and status information.  $requirements = module_invoke_all('requirements', 'runtime');  usort($requirements, '_system_sort_requirements');  if ($check) {    return drupal_requirements_severity($requirements) == REQUIREMENT_ERROR;  }  // MySQL import might have set the uid of the anonymous user to autoincrement  // value. Let's try fixing it. See http://drupal.org/node/204411  db_query("UPDATE {users} SET uid = uid - uid WHERE name = '' AND pass = '' AND status = 0");  return theme('status_report', $requirements);}/** * Menu callback: run cron manually. */function system_run_cron() {  // Run cron manually  if (drupal_cron_run()) {    drupal_set_message(t('Cron ran successfully.'));  }  else {    drupal_set_message(t('Cron run failed.'), 'error');  }  drupal_goto('admin/reports/status');}/** * Menu callback: return information about PHP. */function system_php() {  phpinfo();  exit();}/** * Theme a SQL result table. * * @param $data *   The actual table data. * @param $keys *   Data keys and descriptions. * @return *   The output HTML. */function _system_sql($data, $keys) {  $rows = array();  foreach ($keys as $key => $explanation) {    if (isset($data[$key])) {      $rows[] = array(check_plain($key), check_plain($data[$key]), $explanation);    }  }  return theme('table', array(t('Variable'), t('Value'), t('Description')), $rows);}/** * Menu callback: return information about the database. */function system_sql() {  $result = db_query("SHOW STATUS");  while ($entry = db_fetch_object($result)) {    // 'SHOW STATUS' returns fields named 'Variable_name' and 'Value',    // case is important.    $data[$entry->Variable_name] = $entry->Value;  }  $output  = '<h2>'. t('Command counters') .'</h2>';  $output .= _system_sql($data, array(   'Com_select' => t('The number of <code>SELECT</code>-statements.'),   'Com_insert' => t('The number of <code>INSERT</code>-statements.'),   'Com_update' => t('The number of <code>UPDATE</code>-statements.'),   'Com_delete' => t('The number of <code>DELETE</code>-statements.'),   'Com_lock_tables' => t('The number of table locks.'),   'Com_unlock_tables' => t('The number of table unlocks.')  ));  $output .= '<h2>'. t('Query performance') .'</h2>';  $output .= _system_sql($data, array(   'Select_full_join' => t('The number of joins without an index; should be zero.'),   'Select_range_check' => t('The number of joins without keys that check for key usage after each row; should be zero.'),   'Sort_scan' => t('The number of sorts done without using an index; should be zero.'),   'Table_locks_immediate' => t('The number of times a lock could be acquired immediately.'),   'Table_locks_waited' => t('The number of times the server had to wait for a lock.')  ));  $output .= '<h2>'. t('Query cache information') .'</h2>';  $output .= '<p>'. t('The MySQL query cache can improve performance of your site by storing the result of queries. Then, if an identical query is received later, the MySQL server retrieves the result from the query cache rather than parsing and executing the statement again.') .'</p>';  $output .= _system_sql($data, array(   'Qcache_queries_in_cache' => t('The number of queries in the query cache.'),   'Qcache_hits' => t('The number of times MySQL found previous results in the cache.'),   'Qcache_inserts' => t('The number of times MySQL added a query to the cache (misses).'),   'Qcache_lowmem_prunes' => t('The number of times MySQL had to remove queries from the cache because it ran out of memory. Ideally should be zero.')  ));  return $output;}/** * Default page callback for batches. */function system_batch_page() {  require_once './includes/batch.inc';  $output = _batch_page();  if ($output === FALSE) {    drupal_access_denied();  }  elseif (isset($output)) {    // Force a page without blocks or messages to    // display a list of collected messages later.    print theme('page', $output, FALSE, FALSE);  }}/** * This function formats an administrative block for display. * * @param $block *   An array containing information about the block. It should *   include a 'title', a 'description' and a formatted 'content'. * @ingroup themeable */function theme_admin_block($block) {  // Don't display the block if it has no content to display.  if (empty($block['content'])) {    return '';  }  $output = <<< EOT  <div class="admin-panel">    <h3>      $block[title]    </h3>    <div class="body">      <p class="description">        $block[description]      </p>      $block[content]    </div>  </div>EOT;  return $output;}/** * This function formats the content of an administrative block. * * @param $content *   An array containing information about the block. It should *   include a 'title', a 'description' and a formatted 'content'. * @ingroup themeable */function theme_admin_block_content($content) {  if (!$content) {    return '';  }  if (system_admin_compact_mode()) {    $output = '<ul class="menu">';    foreach ($content as $item) {      $output .= '<li class="leaf">'. l($item['title'], $item['href'], $item['localized_options']) .'</li>';    }    $output .= '</ul>';  }  else {    $output = '<dl class="admin-list">';    foreach ($content as $item) {      $output .= '<dt>'. l($item['title'], $item['href'], $item['localized_options']) .'</dt>';      $output .= '<dd>'. $item['description'] .'</dd>';    }    $output .= '</dl>';  }  return $output;}/** * This function formats an administrative page for viewing. * * @param $blocks *   An array of blocks to display. Each array should include a *   'title', a 'description', a formatted 'content' and a *   'position' which will control which container it will be *   in. This is usually 'left' or 'right'. * @ingroup themeable */function theme_admin_page($blocks) {  $stripe = 0;  $container = array();  foreach ($blocks as $block) {    if ($block_output = theme('admin_block', $block)) {      if (empty($block['position'])) {        // perform automatic striping.        $block['position'] = ++$stripe % 2 ? 'left' : 'right';      }      if (!isset($container[$block['position']])) {        $container[$block['position']] = '';      }      $container[$block['position']] .= $block_output;    }  }  $output = '<div class="admin clear-block">';  $output .= '<div class="compact-link">';  if (system_admin_compact_mode()) {    $output .= l(t('Show descriptions'), 'admin/compact/off', array('attributes' => array('title' => t('Expand layout to include descriptions.'))));  }  else {    $output .= l(t('Hide descriptions'), 'admin/compact/on', array('attributes' => array('title' => t('Compress layout by hiding descriptions.'))));  }  $output .= '</div>';  foreach ($container as $id => $data) {    $output .= '<div class="'. $id .' clear-block">';    $output .= $data;    $output .= '</div>';  }  $output .= '</div>';  return $output;}/** * Theme output of the dashboard page. * * @param $menu_items *   An array of modules to be displayed. * @ingroup themeable */function theme_system_admin_by_module($menu_items) {  $stripe = 0;  $output = '';  $container = array('left' => '', 'right' => '');  $flip = array('left' => 'right', 'right' => 'left');  $position = 'left';  // Iterate over all modules  foreach ($menu_items as $module => $block) {    list($description, $items) = $block;    // Output links    if (count($items)) {      $block = array();      $block['title'] = $module;      $block['content'] = theme('item_list', $items);      $block['description'] = t($description);      if ($block_output = theme('admin_block', $block)) {        if (!isset($block['position'])) {          // Perform automatic striping.          $block['position'] = $position;          $position = $flip[$position];        }        $container[$block['position']] .= $block_output;      }    }  }  $output = '<div class="admin clear-block">';  foreach ($container as $id => $data) {    $output .= '<div class="'. $id .' clear-block">';    $output .= $data;    $output .= '</div>';  }  $output .= '</div>';  return $output;}/** * Theme requirements status report. * * @param $requirements *   An array of requirements. * @ingroup themeable */function theme_status_report($requirements) {  $i = 0;  $output = '<table class="system-status-report">';  foreach ($requirements as $requirement) {    if (empty($requirement['#type'])) {      $class = ++$i % 2 == 0 ? 'even' : 'odd';      $classes = array(        REQUIREMENT_INFO => 'info',        REQUIREMENT_OK => 'ok',        REQUIREMENT_WARNING => 'warning',        REQUIREMENT_ERROR => 'error',      );      $class = $classes[isset($requirement['severity']) ? (int)$requirement['severity'] : 0] .' '. $class;      // Output table row(s)      if (!empty($requirement['description'])) {        $output .= '<tr class="'. $class .' merge-down"><th>'. $requirement['title'] .'</th><td>'. $requirement['value'] .'</td></tr>';        $output .= '<tr class="'. $class .' merge-up"><td colspan="2">'. $requirement['description'] .'</td></tr>';      }      else {        $output .= '<tr class="'. $class .'"><th>'. $requirement['title'] .'</th><td>'. $requirement['value'] .'</td></tr>';      }    }  }  $output .= '</table>';  return $output;}/** * Theme callback for the modules form. * * @param $form *   An associative array containing the structure of the form. * @ingroup themeable */function theme_system_modules($form) {  if (isset($form['confirm'])) {    return drupal_render($form);  }  // Individual table headers.  $header = array();  $header[] = array('data' => t('Enabled'), 'class' => 'checkbox');  if (module_exists('throttle')) {    $header[] = array('data' => t('Throttle'), 'class' => 'checkbox');  }  $header[] = t('Name');  $header[] = t('Version');  $header[] = t('Description');  // Pull package information from module list and start grouping modules.  $modules = $form['validation_modules']['#value'];  foreach ($modules as $module) {    if (!isset($module->info['package']) || !$module->info['package']) {      $module->info['package'] = t('Other');    }    $packages[$module->info['package']][$module->name] = $module->info;  }  ksort($packages);  // Display packages.  $output = '';  foreach ($packages as $package => $modules) {    $rows = array();    foreach ($modules as $key => $module) {      $row = array();      $description = drupal_render($form['description'][$key]);      if (isset($form['status']['#incompatible_modules_core'][$key])) {        unset($form['status'][$key]);        $status = theme('image', 'misc/watchdog-error.png', t('incompatible'), t('Incompatible with this version of Drupal core'));        $description .= '<div class="incompatible">'. t('This version is incompatible with the !core_version version of Drupal core.', array('!core_version' => VERSION)) .'</div>';      }      elseif (isset($form['status']['#incompatible_modules_php'][$key])) {        unset($form['status'][$key]);        $status = theme('image', 'misc/watchdog-error.png', t('incompatible'), t('Incompatible with this version of PHP'));        $php_required = $form['status']['#incompatible_modules_php'][$key];        if (substr_count($php_required, '.') < 2) {          $php_required .= '.*';        }        $description .= '<div class="incompatible">'. t('This module requires PHP version @php_required and is incompatible with PHP version !php_version.', array('@php_required' => $php_required, '!php_version' => phpversion())) .'</div>';      }      else {        $status = drupal_render($form['status'][$key]);      }      $row[] = array('data' => $status, 'class' => 'checkbox');      if (module_exists('throttle')) {        $row[] = array('data' => drupal_render($form['throttle'][$key]), 'class' => 'checkbox');      }      // Add labels only when there is also a checkbox.      if (isset($form['status'][$key])) {        $row[] = '<strong><label for="'. $form['status'][$key]['#id'] .'">'. drupal_render($form['name'][$key]) .'</label></strong>';      }      else {        $row[] = '<strong>'. drupal_render($form['name'][$key]) .'</strong>';      }      $row[] = array('data' => drupal_render($form['version'][$key]), 'class' => 'version');      $row[] = array('data' => $description, 'class' => 'description');      $rows[] = $row;    }    $fieldset = array(      '#title' => t($package),      '#collapsible' => TRUE,      '#collapsed' => ($package == 'Core - required'),      '#value' => theme('table', $header, $rows, array('class' => 'package')),    );    $output .= theme('fieldset', $fieldset);  }  $output .= drupal_render($form);  return $output;}/** * Themes a table of currently disabled modules. * * @ingroup themeable * @param $form *   The form array representing the currently disabled modules. * @return *   An HTML string representing the table. */function theme_system_modules_uninstall($form) {  // No theming for the confirm form.  if (isset($form['confirm'])) {    return drupal_render($form);  }  // Table headers.  $header = array(t('Uninstall'),    t('Name'),    t('Description'),  );  // Display table.  $rows = array();  foreach (element_children($form['modules']) as $module) {    $rows[] = array(      array('data' => drupal_render($form['uninstall'][$module]), 'align' => 'center'),      '<strong>'. drupal_render($form['modules'][$module]['name']) .'</strong>',      array('data' => drupal_render($form['modules'][$module]['description']), 'class' => 'description'),    );  }  // Only display table if there are modules that can be uninstalled.  if (empty($rows)) {    $rows[] = array(array('data' => t('No modules are available to uninstall.'), 'colspan' => '3', 'align' => 'center', 'class' => 'message'));  }  $output  = theme('table', $header, $rows);  $output .= drupal_render($form);  return $output;}/** * Theme the theme select form. * @param $form *   An associative array containing the structure of the form. * @ingroup themeable */function theme_system_theme_select_form($form) {  foreach (element_children($form) as $key) {    $row = array();    if (isset($form[$key]['description']) && is_array($form[$key]['description'])) {      $row[] = drupal_render($form[$key]['screenshot']);      $row[] = drupal_render($form[$key]['description']);      $row[] = drupal_render($form['theme'][$key]);    }    $rows[] = $row;  }  $header = array(t('Screenshot'), t('Name'), t('Selected'));  $output = theme('table', $header, $rows);  return $output;}/** * Theme function for the system themes form. * * @param $form *   An associative array containing the structure of the form. * @ingroup themeable */function theme_system_themes_form($form) {  foreach (element_children($form) as $key) {    // Only look for themes    if (!isset($form[$key]['info'])) {      continue;    }    // Fetch info    $info = $form[$key]['info']['#value'];    // Localize theme description.    $description = t($info['description']);    // Make sure it is compatible and render the checkbox if so.    if (isset($form['status']['#incompatible_themes_core'][$key])) {      unset($form['status'][$key]);      $status = theme('image', 'misc/watchdog-error.png', t('incompatible'), t('Incompatible with this version of Drupal core'));      $description .= '<div class="incompatible">'. t('This version is incompatible with the !core_version version of Drupal core.', array('!core_version' => VERSION)) .'</div>';    }    elseif (isset($form['status']['#incompatible_themes_php'][$key])) {      unset($form['status'][$key]);      $status = theme('image', 'misc/watchdog-error.png', t('incompatible'), t('Incompatible with this version of PHP'));      $php_required = $form['status']['#incompatible_themes_php'][$key];      if (substr_count($php_required, '.') < 2) {        $php_required .= '.*';      }      $description .= '<div class="incompatible">'. t('This theme requires PHP version @php_required and is incompatible with PHP version !php_version.', array('@php_required' => $php_required, '!php_version' => phpversion())) .'</div>';    }    else {      $status = drupal_render($form['status'][$key]);    }    // Style theme info    $theme = '<div class="theme-info"><h2>'. $info['name'] .'</h2><div class="description">'. $description .'</div></div>';    // Build rows    $row = array();    $row[] = drupal_render($form[$key]['screenshot']);    $row[] = $theme;    $row[] = isset($info['version']) ? $info['version'] : '';    $row[] = array('data' => $status, 'align' => 'center');    if ($form['theme_default']) {      $row[] = array('data' => drupal_render($form['theme_default'][$key]), 'align' => 'center');      $row[] = array('data' => drupal_render($form[$key]['operations']), 'align' => 'center');    }    $rows[] = $row;  }  $header = array(t('Screenshot'), t('Name'), t('Version'), t('Enabled'), t('Default'), t('Operations'));  $output = theme('table', $header, $rows);  $output .= drupal_render($form);  return $output;}
<?php// $Id$/** * Implementation of hook_help(). */function color_help($path, $arg) {  switch ($path) {    case 'admin/help#color':      $output = '<p>'. t('The color module allows a site administrator to quickly and easily change the color scheme of certain themes. Although not all themes support color module, both Garland (the default theme) and Minnelli were designed to take advantage of its features. By using color module with a compatible theme, you can easily change the color of links, backgrounds, text, and other theme elements. Color module requires that your <a href="@url">file download method</a> be set to public.', array('@url' => url('admin/settings/file-system'))) .'</p>';      $output .= '<p>'. t("It is important to remember that color module saves a modified copy of the theme's specified stylesheets in the files directory. This means that if you make any manual changes to your theme's stylesheet, you must save your color settings again, even if they haven't changed. This causes the color module generated version of the stylesheets in the files directory to be recreated using the new version of the original file.") .'</p>';      $output .= '<p>'. t('To change the color settings for a compatible theme, select the "configure" link for the theme on the <a href="@themes">themes administration page</a>.', array('@themes' => url('admin/build/themes'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@color">Color module</a>.', array('@color' => 'http://drupal.org/handbook/modules/color/')) .'</p>';      return $output;  }}/** * Implementation of hook_theme(). */function color_theme() {  return array(    'color_scheme_form' => array(      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_form_alter(). */function color_form_alter(&$form, $form_state, $form_id) {  // Insert the color changer into the theme settings page.  if ($form_id == 'system_theme_settings' && color_get_info(arg(4)) && function_exists('gd_info')) {    if (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) != FILE_DOWNLOADS_PUBLIC) {      // Disables the color changer when the private download method is used.      // TODO: This should be solved in a different way. See issue #181003.      drupal_set_message(t('The color picker only works if the <a href="@url">download method</a> is set to public.', array('@url' => url('admin/settings/file-system'))), 'warning');    }    else {      $form['color'] = array(        '#type' => 'fieldset',        '#title' => t('Color scheme'),        '#weight' => -1,        '#attributes' => array('id' => 'color_scheme_form'),        '#theme' => 'color_scheme_form',      );      $form['color'] += color_scheme_form($form_state, arg(4));      $form['#submit'][] = 'color_scheme_form_submit';    }  }  // Use the generated screenshot in the theme list.  if ($form_id == 'system_theme_select_form' || $form_id == 'system_themes') {    $themes = list_themes();    foreach (element_children($form) as $theme) {      if ($screenshot = variable_get('color_'. $theme .'_screenshot', NULL)) {        if (isset($form[$theme]['screenshot'])) {          $form[$theme]['screenshot']['#value'] = theme('image', $screenshot, '', '', array('class' => 'screenshot'), FALSE);        }      }    }  }}/** * Callback for the theme to alter the resources used. */function _color_page_alter(&$vars) {  global $language, $theme_key;  // Override stylesheets.  $color_paths = variable_get('color_'. $theme_key .'_stylesheets', array());  if (!empty($color_paths)) {    // Loop over theme CSS files and try to rebuild CSS array with rewritten    // stylesheets. Keep the orginal order intact for CSS cascading.    $new_theme_css = array();    foreach ($vars['css']['all']['theme'] as $old_path => $old_preprocess) {      // Add the non-colored stylesheet first as we might not find a      // re-colored stylesheet for replacement later.      $new_theme_css[$old_path] = $old_preprocess;      // Loop over the path array with recolored CSS files to find matching      // paths which could replace the non-recolored paths.      foreach ($color_paths as $color_path) {        // Color module currently requires unique file names to be used,        // which allows us to compare different file paths.        if (basename($old_path) == basename($color_path)) {          // Pull out the non-colored and add rewritten stylesheet.          unset($new_theme_css[$old_path]);          $new_theme_css[$color_path] = $old_preprocess;          // If the current language is RTL and the CSS file had an RTL variant,          // pull out the non-colored and add rewritten RTL stylesheet.          if ($language->direction == LANGUAGE_RTL) {            $rtl_old_path = str_replace('.css', '-rtl.css', $old_path);            $rtl_color_path = str_replace('.css', '-rtl.css', $color_path);            if (file_exists($rtl_color_path)) {              unset($new_theme_css[$rtl_old_path]);              $new_theme_css[$rtl_color_path] = $old_preprocess;            }          }          break;        }      }    }    $vars['css']['all']['theme'] = $new_theme_css;    $vars['styles'] = drupal_get_css($vars['css']);  }  // Override logo.  $logo = variable_get('color_'. $theme_key .'_logo', NULL);  if ($logo && $vars['logo'] && preg_match('!'. $theme_key .'/logo.png$!', $vars['logo'])) {    $vars['logo'] = base_path() . $logo;  }}/** * Retrieve the color.module info for a particular theme. */function color_get_info($theme) {  $path = drupal_get_path('theme', $theme);  $file = $path .'/color/color.inc';  if ($path && file_exists($file)) {    include $file;    return $info;  }}/** * Helper function to retrieve the color palette for a particular theme. */function color_get_palette($theme, $default = false) {  // Fetch and expand default palette  $fields = array('base', 'link', 'top', 'bottom', 'text');  $info = color_get_info($theme);  $keys = array_keys($info['schemes']);  foreach (explode(',', array_shift($keys)) as $k => $scheme) {    $palette[$fields[$k]] = $scheme;  }  // Load variable  return $default ? $palette : variable_get('color_'. $theme .'_palette', $palette);}/** * Form callback. Returns the configuration form. */function color_scheme_form(&$form_state, $theme) {  $base = drupal_get_path('module', 'color');  $info = color_get_info($theme);  // Add Farbtastic color picker  drupal_add_css('misc/farbtastic/farbtastic.css', 'module', 'all', FALSE);  drupal_add_js('misc/farbtastic/farbtastic.js');  // Add custom CSS/JS  drupal_add_css($base .'/color.css', 'module', 'all', FALSE);  drupal_add_js($base .'/color.js');  drupal_add_js(array('color' => array(    'reference' => color_get_palette($theme, true)  )), 'setting');  // See if we're using a predefined scheme  $current = implode(',', variable_get('color_'. $theme .'_palette', array()));  // Note: we use the original theme when the default scheme is chosen.  $current = isset($info['schemes'][$current]) ? $current : ($current == '' ? reset($info['schemes']) : '');  // Add scheme selector  $info['schemes'][''] = t('Custom');  $form['scheme'] = array(    '#type' => 'select',    '#title' => t('Color set'),    '#options' => $info['schemes'],    '#default_value' => $current,  );  // Add palette fields  $palette = color_get_palette($theme);  $names = array(    'base' => t('Base color'),    'link' => t('Link color'),    'top' => t('Header top'),    'bottom' => t('Header bottom'),    'text' => t('Text color')  );  $form['palette']['#tree'] = true;  foreach ($palette as $name => $value) {    $form['palette'][$name] = array(      '#type' => 'textfield',      '#title' => $names[$name],      '#default_value' => $value,      '#size' => 8,    );  }  $form['theme'] = array('#type' => 'value', '#value' => arg(4));  $form['info'] = array('#type' => 'value', '#value' => $info);  return $form;}/** * Theme color form. * * @ingroup themeable */function theme_color_scheme_form($form) {  // Include stylesheet  $theme = $form['theme']['#value'];  $info = $form['info']['#value'];  $path = drupal_get_path('theme', $theme) .'/';  drupal_add_css($path . $info['preview_css']);  $output = '';  // Wrapper  $output .= '<div class="color-form clear-block">';  // Color schemes  $output .= drupal_render($form['scheme']);  // Palette  $output .= '<div id="palette" class="clear-block">';  foreach (element_children($form['palette']) as $name) {    $output .= drupal_render($form['palette'][$name]);  }  $output .= '</div>';  // Preview  $output .= drupal_render($form);  $output .= '<h2>'. t('Preview') .'</h2>';  $output .= '<div id="preview"><div id="text"><h2>Lorem ipsum dolor</h2><p>Sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud <a href="#">exercitation ullamco</a> laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p></div><div id="img" style="background-image: url('. base_path() . $path . $info['preview_image'] .')"></div></div>';  // Close wrapper  $output .= '</div>';  return $output;}/** * Submit handler for color change form. */function color_scheme_form_submit($form, &$form_state) {  // Get theme coloring info  if (!isset($form_state['values']['info'])) {    return;  }  $theme = $form_state['values']['theme'];  $info = $form_state['values']['info'];  // Resolve palette  $palette = $form_state['values']['palette'];  if ($form_state['values']['scheme'] != '') {    $scheme = explode(',', $form_state['values']['scheme']);    foreach ($palette as $k => $color) {      $palette[$k] = array_shift($scheme);    }  }  // Make sure enough memory is available, if PHP's memory limit is compiled in.  if (function_exists('memory_get_usage')) {    // Fetch source image dimensions.    $source = drupal_get_path('theme', $theme) .'/'. $info['base_image'];    list($width, $height) = getimagesize($source);    // We need at least a copy of the source and a target buffer of the same    // size (both at 32bpp).    $required = $width * $height * 8;    $usage = memory_get_usage();    $limit = parse_size(ini_get('memory_limit'));    if ($usage + $required > $limit) {      drupal_set_message(t('There is not enough memory available to PHP to change this theme\'s color scheme. You need at least %size more. Check the <a href="@url">PHP documentation</a> for more information.', array('%size' => format_size($usage + $required - $limit), '@url' => 'http://www.php.net/manual/en/ini.core.php#ini.sect.resource-limits')), 'error');      return;    }  }  // Delete old files  foreach (variable_get('color_'. $theme .'_files', array()) as $file) {    @unlink($file);  }  if (isset($file) && $file = dirname($file)) {    @rmdir($file);  }  // Don't render the default colorscheme, use the standard theme instead.  if (implode(',', color_get_palette($theme, true)) == implode(',', $palette)    || $form_state['values']['op'] == t('Reset to defaults')) {    variable_del('color_'. $theme .'_palette');    variable_del('color_'. $theme .'_stylesheets');    variable_del('color_'. $theme .'_logo');    variable_del('color_'. $theme .'_files');    variable_del('color_'. $theme .'_screenshot');    return;  }  // Prepare target locations for generated files.  $id = $theme .'-'. substr(md5(serialize($palette) . microtime()), 0, 8);  $paths['color'] = file_directory_path() .'/color';  $paths['target'] = $paths['color'] .'/'. $id;  foreach ($paths as $path) {    file_check_directory($path, FILE_CREATE_DIRECTORY);  }  $paths['target'] = $paths['target'] .'/';  $paths['id'] = $id;  $paths['source'] = drupal_get_path('theme', $theme) .'/';  $paths['files'] = $paths['map'] = array();  // Save palette and logo location.  variable_set('color_'. $theme .'_palette', $palette);  variable_set('color_'. $theme .'_logo', $paths['target'] .'logo.png');  // Copy over neutral images.  foreach ($info['copy'] as $file) {    $base = basename($file);    $source = $paths['source'] . $file;    file_copy($source, $paths['target'] . $base);    $paths['map'][$file] = $base;    $paths['files'][] = $paths['target'] . $base;  }  // Render new images, if image provided.  if ($info['base_image']) {    _color_render_images($theme, $info, $paths, $palette);  }  // Rewrite theme stylesheets.  $css = array();  foreach ($info['css'] as $stylesheet) {    // Build a temporary array with LTR and RTL files.    $files = array();    if (file_exists($paths['source'] . $stylesheet)) {      $files[] = $stylesheet;      $rtl_file = str_replace('.css', '-rtl.css', $stylesheet);      if (file_exists($paths['source'] . $rtl_file)) {        $files[] = $rtl_file;      }    }    foreach ($files as $file) {      // Aggregate @imports recursively for each configured top level CSS file      // without optimization. Aggregation and optimization will be      // handled by drupal_build_css_cache() only.      $style = drupal_load_stylesheet($paths['source'] . $file, FALSE);      // Return the path to where this CSS file originated from, stripping      // off the name of the file at the end of the path.      $base = base_path() . dirname($paths['source'] . $file) .'/';      _drupal_build_css_path(NULL, $base);      // Prefix all paths within this CSS file, ignoring absolute paths.      $style = preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $style);      // Rewrite stylesheet with new colors.      $style = _color_rewrite_stylesheet($theme, $info, $paths, $palette, $style);      $base_file = basename($file);      $css[] = $paths['target'] . $base_file;      _color_save_stylesheet($paths['target'] . $base_file, $style, $paths);    }  }  // Maintain list of files.  variable_set('color_'. $theme .'_stylesheets', $css);  variable_set('color_'. $theme .'_files', $paths['files']);}/** * Rewrite the stylesheet to match the colors in the palette. */function _color_rewrite_stylesheet($theme, &$info, &$paths, $palette, $style) {  $themes = list_themes();  // Prepare color conversion table  $conversion = $palette;  unset($conversion['base']);  foreach ($conversion as $k => $v) {    $conversion[$k] = drupal_strtolower($v);  }  $default = color_get_palette($theme, true);  // Split off the "Don't touch" section of the stylesheet.  $split = "Color Module: Don't touch";  if (strpos($style, $split) !== FALSE) {    list($style, $fixed) = explode($split, $style);  }  // Find all colors in the stylesheet and the chunks in between.  $style = preg_split('/(#[0-9a-f]{6}|#[0-9a-f]{3})/i', $style, -1, PREG_SPLIT_DELIM_CAPTURE);  $is_color = false;  $output = '';  $base = 'base';  // Iterate over all parts.  foreach ($style as $chunk) {    if ($is_color) {      $chunk = drupal_strtolower($chunk);      // Check if this is one of the colors in the default palette.      if ($key = array_search($chunk, $default)) {        $chunk = $conversion[$key];      }      // Not a pre-set color. Extrapolate from the base.      else {        $chunk = _color_shift($palette[$base], $default[$base], $chunk, $info['blend_target']);      }    }    else {      // Determine the most suitable base color for the next color.      // 'a' declarations. Use link.      if (preg_match('@[^a-z0-9_-](a)[^a-z0-9_-][^/{]*{[^{]+$@i', $chunk)) {        $base = 'link';      }      // 'color:' styles. Use text.      else if (preg_match('/(?<!-)color[^{:]*:[^{#]*$/i', $chunk)) {        $base = 'text';      }      // Reset back to base.      else {        $base = 'base';      }    }    $output .= $chunk;    $is_color = !$is_color;  }  // Append fixed colors segment.  if (isset($fixed)) {    $output .= $fixed;  }  // Replace paths to images.  foreach ($paths['map'] as $before => $after) {    $before = base_path() . $paths['source'] . $before;    $before = preg_replace('`(^|/)(?!../)([^/]+)/../`', '$1', $before);    $output = str_replace($before, $after, $output);  }  return $output;}/** * Save the rewritten stylesheet to disk. */function _color_save_stylesheet($file, $style, &$paths) {  // Write new stylesheet.  file_save_data($style, $file, FILE_EXISTS_REPLACE);  $paths['files'][] = $file;  // Set standard file permissions for webserver-generated files.  @chmod($file, 0664);}/** * Render images that match a given palette. */function _color_render_images($theme, &$info, &$paths, $palette) {  // Prepare template image.  $source = $paths['source'] .'/'. $info['base_image'];  $source = imagecreatefrompng($source);  $width = imagesx($source);  $height = imagesy($source);  // Prepare target buffer.  $target = imagecreatetruecolor($width, $height);  imagealphablending($target, true);  // Fill regions of solid color.  foreach ($info['fill'] as $color => $fill) {    imagefilledrectangle($target, $fill[0], $fill[1], $fill[0] + $fill[2], $fill[1] + $fill[3], _color_gd($target, $palette[$color]));  }  // Render gradient.  for ($y = 0; $y < $info['gradient'][3]; ++$y) {    $color = _color_blend($target, $palette['top'], $palette['bottom'], $y / ($info['gradient'][3] - 1));    imagefilledrectangle($target, $info['gradient'][0], $info['gradient'][1] + $y, $info['gradient'][0] + $info['gradient'][2], $info['gradient'][1] + $y + 1, $color);  }  // Blend over template.  imagecopy($target, $source, 0, 0, 0, 0, $width, $height);  // Clean up template image.  imagedestroy($source);  // Cut out slices.  foreach ($info['slices'] as $file => $coord) {    list($x, $y, $width, $height) = $coord;    $base = basename($file);    $image = $paths['target'] . $base;    // Cut out slice.    if ($file == 'screenshot.png') {      $slice = imagecreatetruecolor(150, 90);      imagecopyresampled($slice, $target, 0, 0, $x, $y, 150, 90, $width, $height);      variable_set('color_'. $theme .'_screenshot', $image);    }    else {      $slice = imagecreatetruecolor($width, $height);      imagecopy($slice, $target, 0, 0, $x, $y, $width, $height);    }    // Save image.    imagepng($slice, $image);    imagedestroy($slice);    $paths['files'][] = $image;    // Set standard file permissions for webserver-generated files    @chmod(realpath($image), 0664);    // Build before/after map of image paths.    $paths['map'][$file] = $base;  }  // Clean up target buffer.  imagedestroy($target);}/** * Shift a given color, using a reference pair and a target blend color. * * Note: this function is significantly different from the JS version, as it * is written to match the blended images perfectly. * * Constraint: if (ref2 == target + (ref1 - target) * delta) for some fraction delta *              then (return == target + (given - target) * delta) * * Loose constraint: Preserve relative positions in saturation and luminance *                   space. */function _color_shift($given, $ref1, $ref2, $target) {  // We assume that ref2 is a blend of ref1 and target and find  // delta based on the length of the difference vectors:  // delta = 1 - |ref2 - ref1| / |white - ref1|  $target = _color_unpack($target, true);  $ref1 = _color_unpack($ref1, true);  $ref2 = _color_unpack($ref2, true);  $numerator = 0;  $denominator = 0;  for ($i = 0; $i < 3; ++$i) {    $numerator += ($ref2[$i] - $ref1[$i]) * ($ref2[$i] - $ref1[$i]);    $denominator += ($target[$i] - $ref1[$i]) * ($target[$i] - $ref1[$i]);  }  $delta = ($denominator > 0) ? (1 - sqrt($numerator / $denominator)) : 0;  // Calculate the color that ref2 would be if the assumption was true.  for ($i = 0; $i < 3; ++$i) {    $ref3[$i] = $target[$i] + ($ref1[$i] - $target[$i]) * $delta;  }  // If the assumption is not true, there is a difference between ref2 and ref3.  // We measure this in HSL space. Notation: x' = hsl(x).  $ref2 = _color_rgb2hsl($ref2);  $ref3 = _color_rgb2hsl($ref3);  for ($i = 0; $i < 3; ++$i) {    $shift[$i] = $ref2[$i] - $ref3[$i];  }  // Take the given color, and blend it towards the target.  $given = _color_unpack($given, true);  for ($i = 0; $i < 3; ++$i) {    $result[$i] = $target[$i] + ($given[$i] - $target[$i]) * $delta;  }  // Finally, we apply the extra shift in HSL space.  // Note: if ref2 is a pure blend of ref1 and target, then |shift| = 0.  $result = _color_rgb2hsl($result);  for ($i = 0; $i < 3; ++$i) {    $result[$i] = min(1, max(0, $result[$i] + $shift[$i]));  }  $result = _color_hsl2rgb($result);  // Return hex color.  return _color_pack($result, true);}/** * Convert a hex triplet into a GD color. */function _color_gd($img, $hex) {  $c = array_merge(array($img), _color_unpack($hex));  return call_user_func_array('imagecolorallocate', $c);}/** * Blend two hex colors and return the GD color. */function _color_blend($img, $hex1, $hex2, $alpha) {  $in1 = _color_unpack($hex1);  $in2 = _color_unpack($hex2);  $out = array($img);  for ($i = 0; $i < 3; ++$i) {    $out[] = $in1[$i] + ($in2[$i] - $in1[$i]) * $alpha;  }  return call_user_func_array('imagecolorallocate', $out);}/** * Convert a hex color into an RGB triplet. */function _color_unpack($hex, $normalize = false) {  if (strlen($hex) == 4) {    $hex = $hex[1] . $hex[1] . $hex[2] . $hex[2] . $hex[3] . $hex[3];  }  $c = hexdec($hex);  for ($i = 16; $i >= 0; $i -= 8) {    $out[] = (($c >> $i) & 0xFF) / ($normalize ? 255 : 1);  }  return $out;}/** * Convert an RGB triplet to a hex color. */function _color_pack($rgb, $normalize = false) {  $out = 0;  foreach ($rgb as $k => $v) {    $out |= (($v * ($normalize ? 255 : 1)) << (16 - $k * 8));  }  return '#'. str_pad(dechex($out), 6, 0, STR_PAD_LEFT);}/** * Convert a HSL triplet into RGB */function _color_hsl2rgb($hsl) {  $h = $hsl[0];  $s = $hsl[1];  $l = $hsl[2];  $m2 = ($l <= 0.5) ? $l * ($s + 1) : $l + $s - $l*$s;  $m1 = $l * 2 - $m2;  return array(    _color_hue2rgb($m1, $m2, $h + 0.33333),    _color_hue2rgb($m1, $m2, $h),    _color_hue2rgb($m1, $m2, $h - 0.33333),  );}/** * Helper function for _color_hsl2rgb(). */function _color_hue2rgb($m1, $m2, $h) {  $h = ($h < 0) ? $h + 1 : (($h > 1) ? $h - 1 : $h);  if ($h * 6 < 1) return $m1 + ($m2 - $m1) * $h * 6;  if ($h * 2 < 1) return $m2;  if ($h * 3 < 2) return $m1 + ($m2 - $m1) * (0.66666 - $h) * 6;  return $m1;}/** * Convert an RGB triplet to HSL. */function _color_rgb2hsl($rgb) {  $r = $rgb[0];  $g = $rgb[1];  $b = $rgb[2];  $min = min($r, min($g, $b));  $max = max($r, max($g, $b));  $delta = $max - $min;  $l = ($min + $max) / 2;  $s = 0;  if ($l > 0 && $l < 1) {    $s = $delta / ($l < 0.5 ? (2 * $l) : (2 - 2 * $l));  }  $h = 0;  if ($delta > 0) {    if ($max == $r && $max != $g) $h += ($g - $b) / $delta;    if ($max == $g && $max != $b) $h += (2 + ($b - $r) / $delta);    if ($max == $b && $max != $r) $h += (4 + ($r - $g) / $delta);    $h /= 6;  }  return array($h, $s, $l);}
<?php// $Id$/** * @file * Enable threaded discussions about general topics. *//** * Implementation of hook_help(). */function forum_help($path, $arg) {  switch ($path) {    case 'admin/help#forum':      $output = '<p>'. t('The forum module lets you create threaded discussion forums with functionality similar to other message board systems. Forums are useful because they allow community members to discuss topics with one another while ensuring those conversations are archived for later reference. The <a href="@create-topic">forum topic</a> menu item (under <em>Create content</em> on the Navigation menu) creates the initial post of a new threaded discussion, or thread.', array('@create-topic' => url('node/add/forum'))) .'</p>';      $output .= '<p>'. t('A threaded discussion occurs as people leave comments on a forum topic (or on other comments within that topic). A forum topic is contained within a forum, which may hold many similar or related forum topics. Forums are (optionally) nested within a container, which may hold many similar or related forums. Both containers and forums may be nested within other containers and forums, and provide structure for your message board. By carefully planning this structure, you make it easier for users to find and comment on a specific forum topic.') .'</p>';      $output .= '<p>'. t('When administering a forum, note that:') .'</p>';      $output .= '<ul><li>'. t('a forum topic (and all of its comments) may be moved between forums by selecting a different forum while editing a forum topic.') .'</li>';      $output .= '<li>'. t('when moving a forum topic between forums, the <em>Leave shadow copy</em> option creates a link in the original forum pointing to the new location.') .'</li>';      $output .= '<li>'. t('selecting <em>Read only</em> under <em>Comment settings</em> while editing a forum topic will lock (prevent new comments) on the thread.') .'</li>';      $output .= '<li>'. t('selecting <em>Disabled</em> under <em>Comment settings</em> while editing a forum topic will hide all existing comments on the thread, and prevent new ones.') .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@forum">Forum module</a>.', array('@forum' => 'http://drupal.org/handbook/modules/forum/')) .'</p>';      return $output;    case 'admin/content/forum':      return '<p>'. t('This page displays a list of existing forums and containers. Containers (optionally) hold forums, and forums hold forum topics (a forum topic is the initial post to a threaded discussion). To provide structure, both containers and forums may be placed inside other containers and forums. To rearrange forums and containers, grab a drag-and-drop handle under the <em>Name</em> column and drag the forum or container to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save</em> button at the bottom of the page.') .'</p>';    case 'admin/content/forum/add/container':      return '<p>'. t('By grouping related or similar forums, containers help organize forums. For example, a container named "Food" may hold two forums named "Fruit" and "Vegetables", respectively.') .'</p>';    case 'admin/content/forum/add/forum':      return '<p>'. t('A forum holds related or similar forum topics (a forum topic is the initial post to a threaded discussion). For example, a forum named "Fruit" may contain forum topics titled "Apples" and "Bananas", respectively.') .'</p>';    case 'admin/content/forum/settings':      return '<p>'. t('These settings allow you to adjust the display of your forum topics. The content types available for use within a forum may be selected by editing the <em>Content types</em> on the <a href="@forum-vocabulary">forum vocabulary page</a>.', array('@forum-vocabulary' => url('admin/content/taxonomy/edit/vocabulary/'. variable_get('forum_nav_vocabulary', '')))) .'</p>';  }}/** * Implementation of hook_theme() */function forum_theme() {  return array(    'forums' => array(      'template' => 'forums',      'arguments' => array('forums' => NULL, 'topics' => NULL, 'parents' => NULL, 'tid' => NULL, 'sortby' => NULL, 'forum_per_page' => NULL),    ),    'forum_list' => array(      'template' => 'forum-list',      'arguments' => array('forums' => NULL, 'parents' => NULL, 'tid' => NULL),    ),    'forum_topic_list' => array(      'template' => 'forum-topic-list',      'arguments' => array('tid' => NULL, 'topics' => NULL, 'sortby' => NULL, 'forum_per_page' => NULL),    ),    'forum_icon' => array(      'template' => 'forum-icon',      'arguments' => array('new_posts' => NULL, 'num_posts' => 0, 'comment_mode' => 0, 'sticky' => 0),    ),    'forum_topic_navigation' => array(      'template' => 'forum-topic-navigation',      'arguments' => array('node' => NULL),    ),    'forum_submitted' => array(      'template' => 'forum-submitted',      'arguments' => array('topic' => NULL),    ),  );}/** * Fetch a forum term. * * @param $tid *   The ID of the term which should be loaded. * * @return *   An associative array containing the term data or FALSE if the term cannot be loaded, or is not part of the forum vocabulary. */function forum_term_load($tid) {  $result = db_query(db_rewrite_sql('SELECT t.tid, t.vid, t.name, t.description, t.weight FROM {term_data} t WHERE t.tid = %d AND t.vid = %d', 't', 'tid'), $tid, variable_get('forum_nav_vocabulary', ''));  return db_fetch_array($result);}/** * Implementation of hook_menu(). */function forum_menu() {  $items['forum'] = array(    'title' => 'Forums',    'page callback' => 'forum_page',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'forum.pages.inc',  );  $items['admin/content/forum'] = array(    'title' => 'Forums',    'description' => 'Control forums and their hierarchy and change forum settings.',    'page callback' => 'drupal_get_form',    'page arguments' => array('forum_overview'),    'access arguments' => array('administer forums'),    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/forum/add/container'] = array(    'title' => 'Add container',    'page callback' => 'forum_form_main',    'page arguments' => array('container'),    'access arguments' => array('administer forums'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/add/forum'] = array(    'title' => 'Add forum',    'page callback' => 'forum_form_main',    'page arguments' => array('forum'),    'access arguments' => array('administer forums'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('forum_admin_settings'),    'access arguments' => array('administer forums'),    'weight' => 5,    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/%forum_term'] = array(    'page callback' => 'forum_form_main',    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/container/%forum_term'] = array(    'title' => 'Edit container',    'page callback' => 'forum_form_main',    'page arguments' => array('container', 5),    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/forum/%forum_term'] = array(    'title' => 'Edit forum',    'page callback' => 'forum_form_main',    'page arguments' => array('forum', 5),    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  return $items;}/** * Implementation of hook_init(). */function forum_init() {  drupal_add_css(drupal_get_path('module', 'forum') .'/forum.css');}/** * Implementation of hook_nodeapi(). */function forum_nodeapi(&$node, $op, $teaser, $page) {  // We are going to return if $node->type is not one of the node  // types assigned to the forum vocabulary.  If forum_nav_vocabulary  // is undefined or the vocabulary does not exist, it clearly cannot  // be assigned to $node->type, so return to avoid E_ALL warnings.  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  if (empty($vocabulary)) {    return;  }  // Operate only on node types assigned for the forum vocabulary.  if (!in_array($node->type, $vocabulary->nodes)) {    return;  }  switch ($op) {    case 'view':      if ($page && taxonomy_node_get_terms_by_vocabulary($node, $vid) && $tree = taxonomy_get_tree($vid)) {        // Get the forum terms from the (cached) tree        foreach ($tree as $term) {          $forum_terms[] = $term->tid;        }        foreach ($node->taxonomy as $term_id => $term) {          if (in_array($term_id, $forum_terms)) {            $node->tid = $term_id;          }        }        // Breadcrumb navigation        $breadcrumb[] = l(t('Home'), NULL);        $breadcrumb[] = l($vocabulary->name, 'forum');        if ($parents = taxonomy_get_parents_all($node->tid)) {          $parents = array_reverse($parents);          foreach ($parents as $p) {            $breadcrumb[] = l($p->name, 'forum/'. $p->tid);          }        }        drupal_set_breadcrumb($breadcrumb);        if (!$teaser) {          $node->content['forum_navigation'] = array(            '#value' => theme('forum_topic_navigation', $node),            '#weight' => 100,          );        }      }      break;    case 'prepare':      if (empty($node->nid)) {        // New topic        $node->taxonomy[arg(3)]->vid = $vid;        $node->taxonomy[arg(3)]->tid = arg(3);      }      break;    // Check in particular that only a "leaf" term in the associated taxonomy    // vocabulary is selected, not a "container" term.    case 'validate':      if ($node->taxonomy) {        // Extract the node's proper topic ID.        $vocabulary = $vid;        $containers = variable_get('forum_containers', array());        foreach ($node->taxonomy as $term) {          if (db_result(db_query('SELECT COUNT(*) FROM {term_data} WHERE tid = %d AND vid = %d', $term, $vocabulary))) {            if (in_array($term, $containers)) {              $term = taxonomy_get_term($term);              form_set_error('taxonomy', t('The item %forum is only a container for forums. Please select one of the forums below it.', array('%forum' => $term->name)));            }          }        }      }      break;    // Assign forum taxonomy when adding a topic from within a forum.    case 'presave':      // Make sure all fields are set properly:      $node->icon = !empty($node->icon) ? $node->icon : '';      if ($node->taxonomy && $tree = taxonomy_get_tree($vid)) {        // Get the forum terms from the (cached) tree if we have a taxonomy.        foreach ($tree as $term) {          $forum_terms[] = $term->tid;        }        foreach ($node->taxonomy as $term_id) {          if (in_array($term_id, $forum_terms)) {            $node->tid = $term_id;          }        }        $old_tid = db_result(db_query_range("SELECT t.tid FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.nid = %d ORDER BY t.vid DESC", $node->nid, 0, 1));        if ($old_tid && isset($node->tid) && ($node->tid != $old_tid) && !empty($node->shadow)) {          // A shadow copy needs to be created. Retain new term and add old term.          $node->taxonomy[] = $old_tid;        }      }      break;    case 'update':      if (empty($node->revision) && db_result(db_query('SELECT tid FROM {forum} WHERE nid=%d', $node->nid))) {        if (!empty($node->tid)) {          db_query('UPDATE {forum} SET tid = %d WHERE vid = %d', $node->tid, $node->vid);        }        // The node is removed from the forum.        else {          db_query('DELETE FROM {forum} WHERE nid = %d', $node->nid);        }        break;      }      // Deliberate no break -- for new revisions and for previously unassigned terms we need an insert.    case 'insert':      if (!empty($node->tid)) {        db_query('INSERT INTO {forum} (tid, vid, nid) VALUES (%d, %d, %d)', $node->tid, $node->vid, $node->nid);      }      break;    case 'delete':      db_query('DELETE FROM {forum} WHERE nid = %d', $node->nid);      break;    case 'load':      return db_fetch_array(db_query('SELECT tid AS forum_tid FROM {forum} WHERE vid = %d', $node->vid));  }  return;}/** * Implementation of hook_node_info(). */function forum_node_info() {  return array(    'forum' => array(      'name' => t('Forum topic'),      'module' => 'forum',      'description' => t('A <em>forum topic</em> is the initial post to a new discussion thread within a forum.'),      'title_label' => t('Subject'),    )  );}/** * Implementation of hook_access(). */function forum_access($op, $node, $account) {  switch ($op) {    case 'create':      return user_access('create forum topics', $account) ? TRUE : NULL;    case 'update':      return user_access('edit any forum topic', $account) || (user_access('edit own forum topics', $account) && ($account->uid == $node->uid)) ? TRUE : NULL;    case 'delete':      return user_access('delete any forum topic', $account) || (user_access('delete own forum topics', $account) && ($account->uid == $node->uid)) ? TRUE : NULL;  }}/** * Implementation of hook_perm(). */function forum_perm() {  return array('create forum topics', 'delete own forum topics', 'delete any forum topic', 'edit own forum topics', 'edit any forum topic', 'administer forums');}/** * Implementation of hook_taxonomy(). */function forum_taxonomy($op, $type, $term = NULL) {  if ($op == 'delete' && $term['vid'] == variable_get('forum_nav_vocabulary', '')) {    switch ($type) {      case 'term':        $results = db_query('SELECT tn.nid FROM {term_node} tn WHERE tn.tid = %d', $term['tid']);        while ($node = db_fetch_object($results)) {          // node_delete will also remove any association with non-forum vocabularies.          node_delete($node->nid);        }        // For containers, remove the tid from the forum_containers variable.        $containers = variable_get('forum_containers', array());        $key = array_search($term['tid'], $containers);        if ($key !== FALSE) {          unset($containers[$key]);        }        variable_set('forum_containers', $containers);        break;      case 'vocabulary':        variable_del('forum_nav_vocabulary');    }  }}/** * Implementation of hook_form_alter(). */function forum_form_alter(&$form, $form_state, $form_id) {  $vid = variable_get('forum_nav_vocabulary', '');  if (isset($form['vid']) && $form['vid']['#value'] == $vid) {    // Hide critical options from forum vocabulary.    if ($form_id == 'taxonomy_form_vocabulary') {      $form['help_forum_vocab'] = array(        '#value' => t('This is the designated forum vocabulary. Some of the normal vocabulary options have been removed.'),        '#weight' => -1,      );      $form['content_types']['nodes']['#required'] = TRUE;      $form['hierarchy'] = array('#type' => 'value', '#value' => 1);      $form['settings']['required'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['relations'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['tags'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['multiple'] = array('#type' => 'value', '#value' => FALSE);      unset($form['delete']);    }    // Hide multiple parents select from forum terms.    elseif ($form_id == 'taxonomy_form_term') {      $form['advanced']['parent']['#access'] = FALSE;    }  }  if ($form_id == 'forum_node_form') {    // Make the vocabulary required for 'real' forum-nodes.    $vid = variable_get('forum_nav_vocabulary', '');    $form['taxonomy'][$vid]['#required'] = TRUE;    $form['taxonomy'][$vid]['#options'][''] = t('- Please choose -');  }}/** * Implementation of hook_load(). */function forum_load($node) {  $forum = db_fetch_object(db_query('SELECT * FROM {forum} WHERE vid = %d', $node->vid));  return $forum;}/** * Implementation of hook_block(). * * Generates a block containing the currently active forum topics and the * most recently added forum topics. */function forum_block($op = 'list', $delta = 0, $edit = array()) {  switch ($op) {    case 'list':      $blocks[0]['info'] = t('Active forum topics');      $blocks[1]['info'] = t('New forum topics');      return $blocks;    case 'configure':      $form['forum_block_num_'. $delta] = array('#type' => 'select', '#title' => t('Number of topics'), '#default_value' => variable_get('forum_block_num_'. $delta, '5'), '#options' => drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)));      return $form;    case 'save':      variable_set('forum_block_num_'. $delta, $edit['forum_block_num_'. $delta]);      break;    case 'view':      if (user_access('access content')) {        switch ($delta) {          case 0:            $title = t('Active forum topics');            $sql = db_rewrite_sql("SELECT n.nid, n.title, l.comment_count, l.last_comment_timestamp FROM {node} n INNER JOIN {term_node} tn ON tn.vid = n.vid INNER JOIN {term_data} td ON td.tid = tn.tid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 AND td.vid = %d ORDER BY l.last_comment_timestamp DESC");            $result = db_query_range($sql, variable_get('forum_nav_vocabulary', ''), 0, variable_get('forum_block_num_0', '5'));            $content = node_title_list($result);            break;          case 1:            $title = t('New forum topics');            $sql = db_rewrite_sql("SELECT n.nid, n.title, l.comment_count FROM {node} n INNER JOIN {term_node} tn ON tn.vid = n.vid INNER JOIN {term_data} td ON td.tid = tn.tid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 AND td.vid = %d ORDER BY n.nid DESC");            $result = db_query_range($sql, variable_get('forum_nav_vocabulary', ''), 0, variable_get('forum_block_num_1', '5'));            $content = node_title_list($result);            break;        }        if (!empty($content)) {          $block['subject'] = $title;          $block['content'] = $content . theme('more_link', url('forum'), t('Read the latest forum topics.'));          return $block;        }      }  }}/** * Implementation of hook_form(). */function forum_form(&$node, $form_state) {  $type = node_get_types('type', $node);  $form['title'] = array('#type' => 'textfield', '#title' => check_plain($type->title_label), '#default_value' => !empty($node->title) ? $node->title : '', '#required' => TRUE, '#weight' => -5);  if (!empty($node->nid)) {    $vid = variable_get('forum_nav_vocabulary', '');    $forum_terms = taxonomy_node_get_terms_by_vocabulary($node, $vid);    // if editing, give option to leave shadows    $shadow = (count($forum_terms) > 1);    $form['shadow'] = array('#type' => 'checkbox', '#title' => t('Leave shadow copy'), '#default_value' => $shadow, '#description' => t('If you move this topic, you can leave a link in the old forum to the new forum.'));  }  $form['body_field'] = node_body_field($node, $type->body_label, 1);  $form['#submit'][] = 'forum_submit';  // Assign the forum topic submit handler.  return $form;}/** * Implementation of hook_term_path(). */function forum_term_path($term) {  return 'forum/'. $term->tid;}/** * Returns a list of all forums for a given taxonomy id * * Forum objects contain the following fields * -num_topics Number of topics in the forum * -num_posts Total number of posts in all topics * -last_post Most recent post for the forum * * @param $tid *   Taxonomy ID of the vocabulary that holds the forum list. * @return *   Array of object containing the forum information. */function forum_get_forums($tid = 0) {  $forums = array();  $vid = variable_get('forum_nav_vocabulary', '');  $_forums = taxonomy_get_tree($vid, $tid);  if (count($_forums)) {    $counts = array();    $sql = "SELECT r.tid, COUNT(n.nid) AS topic_count, SUM(l.comment_count) AS comment_count FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {term_node} r ON n.vid = r.vid WHERE n.status = 1 GROUP BY r.tid";    $sql = db_rewrite_sql($sql);    $_counts = db_query($sql);    while ($count = db_fetch_object($_counts)) {      $counts[$count->tid] = $count;    }  }  foreach ($_forums as $forum) {    if (in_array($forum->tid, variable_get('forum_containers', array()))) {      $forum->container = 1;    }    if (!empty($counts[$forum->tid])) {      $forum->num_topics = $counts[$forum->tid]->topic_count;      $forum->num_posts = $counts[$forum->tid]->topic_count + $counts[$forum->tid]->comment_count;    }    else {      $forum->num_topics = 0;      $forum->num_posts = 0;    }    // This query does not use full ANSI syntax since MySQL 3.x does not support    // table1 INNER JOIN table2 INNER JOIN table3 ON table2_criteria ON table3_criteria    // used to join node_comment_statistics to users.    $sql = "SELECT ncs.last_comment_timestamp, IF (ncs.last_comment_uid != 0, u2.name, ncs.last_comment_name) AS last_comment_name, ncs.last_comment_uid FROM {node} n INNER JOIN {users} u1 ON n.uid = u1.uid INNER JOIN {term_node} tn ON n.vid = tn.vid INNER JOIN {node_comment_statistics} ncs ON n.nid = ncs.nid INNER JOIN {users} u2 ON ncs.last_comment_uid=u2.uid WHERE n.status = 1 AND tn.tid = %d ORDER BY ncs.last_comment_timestamp DESC";    $sql = db_rewrite_sql($sql);    $topic = db_fetch_object(db_query_range($sql, $forum->tid, 0, 1));    $last_post = new stdClass();    if (!empty($topic->last_comment_timestamp)) {      $last_post->timestamp = $topic->last_comment_timestamp;      $last_post->name = $topic->last_comment_name;      $last_post->uid = $topic->last_comment_uid;    }    $forum->last_post = $last_post;    $forums[$forum->tid] = $forum;  }  return $forums;}/** * Calculate the number of nodes the user has not yet read and are newer * than NODE_NEW_LIMIT. */function _forum_topics_unread($term, $uid) {  $sql = "SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid AND tn.tid = %d LEFT JOIN {history} h ON n.nid = h.nid AND h.uid = %d WHERE n.status = 1 AND n.created > %d AND h.nid IS NULL";  $sql = db_rewrite_sql($sql);  return db_result(db_query($sql, $term, $uid, NODE_NEW_LIMIT));}function forum_get_topics($tid, $sortby, $forum_per_page) {  global $user, $forum_topic_list_header;  $forum_topic_list_header = array(    NULL,    array('data' => t('Topic'), 'field' => 'n.title'),    array('data' => t('Replies'), 'field' => 'l.comment_count'),    array('data' => t('Created'), 'field' => 'n.created'),    array('data' => t('Last reply'), 'field' => 'l.last_comment_timestamp'),  );  $order = _forum_get_topic_order($sortby);  for ($i = 0; $i < count($forum_topic_list_header); $i++) {    if ($forum_topic_list_header[$i]['field'] == $order['field']) {      $forum_topic_list_header[$i]['sort'] = $order['sort'];    }  }  $term = taxonomy_get_term($tid);  $sql = db_rewrite_sql("SELECT n.nid, r.tid, n.title, n.type, n.sticky, u.name, u.uid, n.created AS timestamp, n.comment AS comment_mode, l.last_comment_timestamp, IF(l.last_comment_uid != 0, cu.name, l.last_comment_name) AS last_comment_name, l.last_comment_uid, l.comment_count AS num_comments, f.tid AS forum_tid FROM {node_comment_statistics} l INNER JOIN {node} n ON n.nid = l.nid INNER JOIN {users} cu ON l.last_comment_uid = cu.uid INNER JOIN {term_node} r ON n.vid = r.vid INNER JOIN {users} u ON n.uid = u.uid INNER JOIN {forum} f ON n.vid = f.vid WHERE n.status = 1 AND r.tid = %d");  $sql .= tablesort_sql($forum_topic_list_header, 'n.sticky DESC,');  $sql .= ', n.created DESC';  // Always add a secondary sort order so that the news forum topics are on top.  $sql_count = db_rewrite_sql("SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} r ON n.vid = r.vid AND r.tid = %d WHERE n.status = 1");  $result = pager_query($sql, $forum_per_page, 0, $sql_count, $tid);  $topics = array();  while ($topic = db_fetch_object($result)) {    if ($user->uid) {      // folder is new if topic is new or there are new comments since last visit      if ($topic->tid != $tid) {        $topic->new = 0;      }      else {        $history = _forum_user_last_visit($topic->nid);        $topic->new_replies = comment_num_new($topic->nid, $history);        $topic->new = $topic->new_replies || ($topic->timestamp > $history);      }    }    else {      // Do not track "new replies" status for topics if the user is anonymous.      $topic->new_replies = 0;      $topic->new = 0;    }    if ($topic->num_comments > 0) {      $last_reply = new stdClass();      $last_reply->timestamp = $topic->last_comment_timestamp;      $last_reply->name = $topic->last_comment_name;      $last_reply->uid = $topic->last_comment_uid;      $topic->last_reply = $last_reply;    }    $topics[] = $topic;  }  return $topics;}/** * Finds the first unread node for a given forum. */function _forum_new($tid) {  global $user;  $sql = "SELECT n.nid FROM {node} n LEFT JOIN {history} h ON n.nid = h.nid AND h.uid = %d INNER JOIN {term_node} r ON n.nid = r.nid AND r.tid = %d WHERE n.status = 1 AND h.nid IS NULL AND n.created > %d ORDER BY created";  $sql = db_rewrite_sql($sql);  $nid = db_result(db_query_range($sql, $user->uid, $tid, NODE_NEW_LIMIT, 0, 1));  return $nid ? $nid : 0;}/** * Process variables for forums.tpl.php * * The $variables array contains the following arguments: * - $forums * - $topics * - $parents * - $tid * - $sortby * - $forum_per_page * * @see forums.tpl.php */function template_preprocess_forums(&$variables) {  global $user;  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  $title = !empty($vocabulary->name) ? $vocabulary->name : '';  // Breadcrumb navigation:  $breadcrumb[] = l(t('Home'), NULL);  if ($variables['tid']) {    $breadcrumb[] = l($vocabulary->name, 'forum');  }  if ($variables['parents']) {    $variables['parents'] = array_reverse($variables['parents']);    foreach ($variables['parents'] as $p) {      if ($p->tid == $variables['tid']) {        $title = $p->name;      }      else {        $breadcrumb[] = l($p->name, 'forum/'. $p->tid);      }    }  }  drupal_set_breadcrumb($breadcrumb);  drupal_set_title(check_plain($title));  if ($variables['forums_defined'] = count($variables['forums']) || count($variables['parents'])) {    // Format the "post new content" links listing.    $forum_types = array();    // Loop through all node types for forum vocabulary.    foreach ($vocabulary->nodes as $type) {      // Check if the current user has the 'create' permission for this node type.      if (node_access('create', $type)) {        // Fetch the "General" name of the content type;        // Push the link with title and url to the array.        $forum_types[$type] = array('title' => t('Post new @node_type', array('@node_type' => node_get_types('name', $type))), 'href' => 'node/add/'. str_replace('_', '-', $type) .'/'. $variables['tid']);      }    }    if (empty($forum_types)) {      // The user is logged-in; but denied access to create any new forum content type.      if ($user->uid) {        $forum_types['disallowed'] = array('title' => t('You are not allowed to post new content in the forum.'));      }      // The user is not logged-in; and denied access to create any new forum content type.      else {        $forum_types['login'] = array('title' => t('<a href="@login">Login</a> to post new content in the forum.', array('@login' => url('user/login', array('query' => drupal_get_destination())))), 'html' => TRUE);      }    }    $variables['links'] = $forum_types;    if (!empty($variables['forums'])) {      $variables['forums'] = theme('forum_list', $variables['forums'], $variables['parents'], $variables['tid']);    }    else {      $variables['forums'] = '';    }    if ($variables['tid'] && !in_array($variables['tid'], variable_get('forum_containers', array()))) {      $variables['topics'] = theme('forum_topic_list', $variables['tid'], $variables['topics'], $variables['sortby'], $variables['forum_per_page']);      drupal_add_feed(url('taxonomy/term/'. $variables['tid'] .'/0/feed'), 'RSS - '. $title);    }    else {      $variables['topics'] = '';    }    // Provide separate template suggestions based on what's being output. Topic id is also accounted for.    // Check both variables to be safe then the inverse. Forums with topic ID's take precedence.    if ($variables['forums'] && !$variables['topics']) {      $variables['template_files'][] = 'forums-containers';      $variables['template_files'][] = 'forums-'. $variables['tid'];      $variables['template_files'][] = 'forums-containers-'. $variables['tid'];    }    elseif (!$variables['forums'] && $variables['topics']) {      $variables['template_files'][] = 'forums-topics';      $variables['template_files'][] = 'forums-'. $variables['tid'];      $variables['template_files'][] = 'forums-topics-'. $variables['tid'];    }    else {      $variables['template_files'][] = 'forums-'. $variables['tid'];    }  }  else {    drupal_set_title(t('No forums defined'));    $variables['links'] = array();    $variables['forums'] = '';    $variables['topics'] = '';  }}/** * Process variables to format a forum listing. * * $variables contains the following information: * - $forums * - $parents * - $tid * * @see forum-list.tpl.php * @see theme_forum_list() */function template_preprocess_forum_list(&$variables) {  global $user;  $row = 0;  // Sanitize each forum so that the template can safely print the data.  foreach ($variables['forums'] as $id => $forum) {    $variables['forums'][$id]->description = !empty($forum->description) ? filter_xss_admin($forum->description) : '';    $variables['forums'][$id]->link = url("forum/$forum->tid");    $variables['forums'][$id]->name = check_plain($forum->name);    $variables['forums'][$id]->is_container = !empty($forum->container);    $variables['forums'][$id]->zebra = $row % 2 == 0 ? 'odd' : 'even';    $row++;    $variables['forums'][$id]->new_text = '';    $variables['forums'][$id]->new_url = '';    $variables['forums'][$id]->new_topics = 0;    $variables['forums'][$id]->old_topics = $forum->num_topics;    if ($user->uid) {      $variables['forums'][$id]->new_topics = _forum_topics_unread($forum->tid, $user->uid);      if ($variables['forums'][$id]->new_topics) {        $variables['forums'][$id]->new_text = format_plural($variables['forums'][$id]->new_topics, '1 new', '@count new');        $variables['forums'][$id]->new_url = url("forum/$forum->tid", array('fragment' => 'new'));      }      $variables['forums'][$id]->old_topics = $forum->num_topics - $variables['forums'][$id]->new_topics;    }    $variables['forums'][$id]->last_reply = theme('forum_submitted', $forum->last_post);  }  // Give meaning to $tid for themers. $tid actually stands for term id.  $variables['forum_id'] = $variables['tid'];  unset($variables['tid']);}/** * Preprocess variables to format the topic listing. * * $variables contains the following data: * - $tid * - $topics * - $sortby * - $forum_per_page * * @see forum-topic-list.tpl.php * @see theme_forum_topic_list() */function template_preprocess_forum_topic_list(&$variables) {  global $forum_topic_list_header;  // Create the tablesorting header.  $ts = tablesort_init($forum_topic_list_header);  $header = '';  foreach ($forum_topic_list_header as $cell) {    $cell = tablesort_header($cell, $forum_topic_list_header, $ts);    $header .= _theme_table_cell($cell, TRUE);  }  $variables['header'] = $header;  if (!empty($variables['topics'])) {    $row = 0;    foreach ($variables['topics'] as $id => $topic) {      $variables['topics'][$id]->icon = theme('forum_icon', $topic->new, $topic->num_comments, $topic->comment_mode, $topic->sticky);      $variables['topics'][$id]->zebra = $row % 2 == 0 ? 'odd' : 'even';      $row++;      // We keep the actual tid in forum table, if it's different from the      // current tid then it means the topic appears in two forums, one of      // them is a shadow copy.      if ($topic->forum_tid != $variables['tid']) {        $variables['topics'][$id]->moved = TRUE;        $variables['topics'][$id]->title = check_plain($topic->title);        $variables['topics'][$id]->message = l(t('This topic has been moved'), "forum/$topic->forum_tid");      }      else {        $variables['topics'][$id]->moved = FALSE;        $variables['topics'][$id]->title = l($topic->title, "node/$topic->nid");        $variables['topics'][$id]->message = '';      }      $variables['topics'][$id]->created = theme('forum_submitted', $topic);      $variables['topics'][$id]->last_reply = theme('forum_submitted', isset($topic->last_reply) ? $topic->last_reply : NULL);      $variables['topics'][$id]->new_text = '';      $variables['topics'][$id]->new_url = '';      if ($topic->new_replies) {        $variables['topics'][$id]->new_text = format_plural($topic->new_replies, '1 new', '@count new');        $variables['topics'][$id]->new_url = url("node/$topic->nid", array('query' => comment_new_page_count($topic->num_comments, $topic->new_replies, $topic), 'fragment' => 'new'));      }    }  }  else {    // Make this safe for the template    $variables['topics'] = array();  }  // Give meaning to $tid for themers. $tid actually stands for term id.  $variables['topic_id'] = $variables['tid'];  unset($variables['tid']);  $variables['pager'] = theme('pager', NULL, $variables['forum_per_page'], 0);}/** * Process variables to format the icon for each individual topic. * * $variables contains the following data: * - $new_posts * - $num_posts = 0 * - $comment_mode = 0 * - $sticky = 0 * * @see forum-icon.tpl.php * @see theme_forum_icon() */function template_preprocess_forum_icon(&$variables) {  $variables['hot_threshold'] = variable_get('forum_hot_topic', 15);  if ($variables['num_posts'] > $variables['hot_threshold']) {    $variables['icon'] = $variables['new_posts'] ? 'hot-new' : 'hot';  }  else {    $variables['icon'] = $variables['new_posts'] ? 'new' : 'default';  }  if ($variables['comment_mode'] == COMMENT_NODE_READ_ONLY || $variables['comment_mode'] == COMMENT_NODE_DISABLED) {    $variables['icon'] = 'closed';  }  if ($variables['sticky'] == 1) {    $variables['icon'] = 'sticky';  }}/** * Preprocess variables to format the next/previous forum topic navigation links. * * $variables contains $node. * * @see forum-topic-navigation.tpl.php * @see theme_forum_topic_navigation() */function template_preprocess_forum_topic_navigation(&$variables) {  $output = '';  // get previous and next topic  $sql = "SELECT n.nid, n.title, n.sticky, l.comment_count, l.last_comment_timestamp FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {term_node} r ON n.nid = r.nid AND r.tid = %d WHERE n.status = 1 ORDER BY n.sticky DESC, ". _forum_get_topic_order_sql(variable_get('forum_order', 1));  $result = db_query(db_rewrite_sql($sql), isset($variables['node']->tid) ? $variables['node']->tid : 0);  $stop = $variables['prev'] = $variables['next'] = 0;  while ($topic = db_fetch_object($result)) {    if ($stop == 1) {      $variables['next'] = $topic->nid;      $variables['next_title'] = check_plain($topic->title);      $variables['next_url'] = url("node/$topic->nid");      break;    }    if ($topic->nid == $variables['node']->nid) {      $stop = 1;    }    else {      $variables['prev'] = $topic->nid;      $variables['prev_title'] = check_plain($topic->title);      $variables['prev_url'] = url("node/$topic->nid");    }  }}/** * Process variables to format submission info for display in the forum list and topic list. * * $variables will contain: $topic * * @see forum-submitted.tpl.php * @see theme_forum_submitted() */function template_preprocess_forum_submitted(&$variables) {  $variables['author'] = isset($variables['topic']->uid) ? theme('username', $variables['topic']) : '';  $variables['time'] = isset($variables['topic']->timestamp) ? format_interval(time() - $variables['topic']->timestamp) : '';}function _forum_user_last_visit($nid) {  global $user;  static $history = array();  if (empty($history)) {    $result = db_query('SELECT nid, timestamp FROM {history} WHERE uid = %d', $user->uid);    while ($t = db_fetch_object($result)) {      $history[$t->nid] = $t->timestamp > NODE_NEW_LIMIT ? $t->timestamp : NODE_NEW_LIMIT;    }  }  return isset($history[$nid]) ? $history[$nid] : NODE_NEW_LIMIT;}function _forum_get_topic_order($sortby) {  switch ($sortby) {    case 1:      return array('field' => 'l.last_comment_timestamp', 'sort' => 'desc');      break;    case 2:      return array('field' => 'l.last_comment_timestamp', 'sort' => 'asc');      break;    case 3:      return array('field' => 'l.comment_count', 'sort' => 'desc');      break;    case 4:      return array('field' => 'l.comment_count', 'sort' => 'asc');      break;  }}function _forum_get_topic_order_sql($sortby) {  $order = _forum_get_topic_order($sortby);  return $order['field'] .' '. strtoupper($order['sort']);}
<?php// $Id$/** * @file * Page callbacks for adding, editing, deleting, and revisions management for content. *//** * Menu callback; presents the node editing form, or redirects to delete confirmation. */function node_page_edit($node) {  drupal_set_title(check_plain($node->title));  return drupal_get_form($node->type .'_node_form', $node);}function node_add_page() {  $item = menu_get_item();  $content = system_admin_menu_block($item);  return theme('node_add_list', $content);}/** * Display the list of available node types for node creation. * * @ingroup themeable */function theme_node_add_list($content) {  $output = '';  if ($content) {    $output = '<dl class="node-type-list">';    foreach ($content as $item) {      $output .= '<dt>'. l($item['title'], $item['href'], $item['localized_options']) .'</dt>';            $output .= '<dd>'. filter_xss_admin($item['description']) .'</dd>';    }    $output .= '</dl>';  }  return $output;}/** * Present a node submission form or a set of links to such forms. */function node_add($type) {  global $user;  $types = node_get_types();  $type = isset($type) ? str_replace('-', '_', $type) : NULL;  // If a node type has been specified, validate its existence.  if (isset($types[$type]) && node_access('create', $type)) {    // Initialize settings:    $node = array('uid' => $user->uid, 'name' => (isset($user->name) ? $user->name : ''), 'type' => $type, 'language' => '');    drupal_set_title(t('Create @name', array('@name' => $types[$type]->name)));    $output = drupal_get_form($type .'_node_form', $node);  }  return $output;}function node_form_validate($form, &$form_state) {  node_validate($form_state['values'], $form);}function node_object_prepare(&$node) {  // Set up default values, if required.  $node_options = variable_get('node_options_'. $node->type, array('status', 'promote'));  // If this is a new node, fill in the default values.  if (!isset($node->nid)) {    foreach (array('status', 'promote', 'sticky') as $key) {      $node->$key = in_array($key, $node_options);    }    global $user;    $node->uid = $user->uid;    $node->created = time();  }  else {    $node->date = format_date($node->created, 'custom', 'Y-m-d H:i:s O');    // Remove the log message from the original node object.    $node->log = NULL;  }  // Always use the default revision setting.  $node->revision = in_array('revision', $node_options);  node_invoke($node, 'prepare');  node_invoke_nodeapi($node, 'prepare');}/** * Generate the node add/edit form array. */function node_form(&$form_state, $node) {  global $user;  if (isset($form_state['node'])) {    $node = $form_state['node'] + (array)$node;  }  if (isset($form_state['node_preview'])) {    $form['#prefix'] = $form_state['node_preview'];  }  $node = (object)$node;  foreach (array('body', 'title', 'format') as $key) {    if (!isset($node->$key)) {      $node->$key = NULL;    }  }  if (!isset($form_state['node_preview'])) {    node_object_prepare($node);  }  else {    $node->build_mode = NODE_BUILD_PREVIEW;  }  // Set the id of the top-level form tag  $form['#id'] = 'node-form';  // Basic node information.  // These elements are just values so they are not even sent to the client.  foreach (array('nid', 'vid', 'uid', 'created', 'type', 'language') as $key) {    $form[$key] = array(      '#type' => 'value',      '#value' => isset($node->$key) ? $node->$key : NULL,    );  }  // Changed must be sent to the client, for later overwrite error checking.  $form['changed'] = array(    '#type' => 'hidden',    '#default_value' => isset($node->changed) ? $node->changed : NULL,  );  // Get the node-specific bits.  if ($extra = node_invoke($node, 'form', $form_state)) {    $form = array_merge_recursive($form, $extra);  }  if (!isset($form['title']['#weight'])) {    $form['title']['#weight'] = -5;  }  $form['#node'] = $node;  // Add a log field if the "Create new revision" option is checked, or if the  // current user has the ability to check that option.  if (!empty($node->revision) || user_access('administer nodes')) {    $form['revision_information'] = array(      '#type' => 'fieldset',      '#title' => t('Revision information'),      '#collapsible' => TRUE,      // Collapsed by default when "Create new revision" is unchecked      '#collapsed' => !$node->revision,      '#weight' => 20,    );    $form['revision_information']['revision'] = array(      '#access' => user_access('administer nodes'),      '#type' => 'checkbox',      '#title' => t('Create new revision'),      '#default_value' => $node->revision,    );    $form['revision_information']['log'] = array(      '#type' => 'textarea',      '#title' => t('Log message'),      '#default_value' => (isset($node->log) ? $node->log : ''),      '#rows' => 2,      '#description' => t('An explanation of the additions or updates being made to help other authors understand your motivations.'),    );  }  // Node author information for administrators  $form['author'] = array(    '#type' => 'fieldset',    '#access' => user_access('administer nodes'),    '#title' => t('Authoring information'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#weight' => 20,  );  $form['author']['name'] = array(    '#type' => 'textfield',    '#title' => t('Authored by'),    '#maxlength' => 60,    '#autocomplete_path' => 'user/autocomplete',    '#default_value' => $node->name ? $node->name : '',    '#weight' => -1,    '#description' => t('Leave blank for %anonymous.', array('%anonymous' => variable_get('anonymous', t('Anonymous')))),  );  $form['author']['date'] = array(    '#type' => 'textfield',    '#title' => t('Authored on'),    '#maxlength' => 25,    '#description' => t('Format: %time. Leave blank to use the time of form submission.', array('%time' => !empty($node->date) ? $node->date : format_date($node->created, 'custom', 'Y-m-d H:i:s O'))),  );  if (isset($node->date)) {    $form['author']['date']['#default_value'] = $node->date;  }  // Node options for administrators  $form['options'] = array(    '#type' => 'fieldset',    '#access' => user_access('administer nodes'),    '#title' => t('Publishing options'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#weight' => 25,  );  $form['options']['status'] = array(    '#type' => 'checkbox',    '#title' => t('Published'),    '#default_value' => $node->status,  );  $form['options']['promote'] = array(    '#type' => 'checkbox',    '#title' => t('Promoted to front page'),    '#default_value' => $node->promote,  );  $form['options']['sticky'] = array(    '#type' => 'checkbox',    '#title' => t('Sticky at top of lists'),    '#default_value' => $node->sticky,  );  // These values are used when the user has no administrator access.  foreach (array('uid', 'created') as $key) {    $form[$key] = array(      '#type' => 'value',      '#value' => $node->$key,    );  }  // Add the buttons.  $form['buttons'] = array();  $form['buttons']['submit'] = array(    '#type' => 'submit',    '#access' => !variable_get('node_preview', 0) || (!form_get_errors() && isset($form_state['node_preview'])),    '#value' => t('Save'),    '#weight' => 5,    '#submit' => array('node_form_submit'),  );  $form['buttons']['preview'] = array(    '#type' => 'submit',    '#value' => t('Preview'),    '#weight' => 10,    '#submit' => array('node_form_build_preview'),  );  if (!empty($node->nid) && node_access('delete', $node)) {    $form['buttons']['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete'),      '#weight' => 15,      '#submit' => array('node_form_delete_submit'),    );  }  $form['#validate'][] = 'node_form_validate';  $form['#theme'] = array($node->type .'_node_form', 'node_form');  return $form;}/** * Return a node body field, with format and teaser. */function node_body_field(&$node, $label, $word_count) {  // Check if we need to restore the teaser at the beginning of the body.  $include = !isset($node->teaser) || ($node->teaser == substr($node->body, 0, strlen($node->teaser)));  $form = array(    '#after_build' => array('node_teaser_js', 'node_teaser_include_verify'));  $form['#prefix'] = '<div class="body-field-wrapper">';  $form['#suffix'] = '</div>';  $form['teaser_js'] = array(    '#type' => 'textarea',    '#rows' => 10,    '#teaser' => 'edit-body',    '#teaser_checkbox' => 'edit-teaser-include',    '#disabled' => TRUE,  );  $form['teaser_include'] = array(    '#type' => 'checkbox',    '#title' => t('Show summary in full view'),    '#default_value' => $include,    '#prefix' => '<div class="teaser-checkbox">',    '#suffix' => '</div>',  );  $form['body'] = array(    '#type' => 'textarea',    '#title' => check_plain($label),    '#default_value' => $include ? $node->body : ($node->teaser . $node->body),    '#rows' => 20,    '#required' => ($word_count > 0),  );  $form['format'] = filter_form($node->format);  return $form;}/** * Button sumit function: handle the 'Delete' button on the node form. */function node_form_delete_submit($form, &$form_state) {  $destination = '';  if (isset($_REQUEST['destination'])) {    $destination = drupal_get_destination();    unset($_REQUEST['destination']);  }  $node = $form['#node'];  $form_state['redirect'] = array('node/'. $node->nid .'/delete', $destination);}function node_form_build_preview($form, &$form_state) {  $node = node_form_submit_build_node($form, $form_state);  $form_state['node_preview'] = node_preview($node);}/** * Present a node submission form. * * @ingroup themeable */function theme_node_form($form) {  $output = "\n<div class=\"node-form\">\n";  // Admin form fields and submit buttons must be rendered first, because  // they need to go to the bottom of the form, and so should not be part of  // the catch-all call to drupal_render().  $admin = '';  if (isset($form['author'])) {    $admin .= "    <div class=\"authored\">\n";    $admin .= drupal_render($form['author']);    $admin .= "    </div>\n";  }  if (isset($form['options'])) {    $admin .= "    <div class=\"options\">\n";    $admin .= drupal_render($form['options']);    $admin .= "    </div>\n";  }  $buttons = drupal_render($form['buttons']);  // Everything else gets rendered here, and is displayed before the admin form  // field and the submit buttons.  $output .= "  <div class=\"standard\">\n";  $output .= drupal_render($form);  $output .= "  </div>\n";  if (!empty($admin)) {    $output .= "  <div class=\"admin\">\n";    $output .= $admin;    $output .= "  </div>\n";  }  $output .= $buttons;  $output .= "</div>\n";  return $output;}/** * Generate a node preview. */function node_preview($node) {  if (node_access('create', $node) || node_access('update', $node)) {    // Load the user's name when needed.    if (isset($node->name)) {      // The use of isset() is mandatory in the context of user IDs, because      // user ID 0 denotes the anonymous user.      if ($user = user_load(array('name' => $node->name))) {        $node->uid = $user->uid;        $node->picture = $user->picture;      }      else {        $node->uid = 0; // anonymous user      }    }    else if ($node->uid) {      $user = user_load(array('uid' => $node->uid));      $node->name = $user->name;      $node->picture = $user->picture;    }    $node->changed = time();    // Extract a teaser, if it hasn't been set (e.g. by a module-provided    // 'teaser' form item).    if (!isset($node->teaser)) {      $node->teaser = empty($node->body) ? '' : node_teaser($node->body, $node->format);      // Chop off the teaser from the body if needed.      if (!$node->teaser_include && $node->teaser == substr($node->body, 0, strlen($node->teaser))) {        $node->body = substr($node->body, strlen($node->teaser));      }    }    // Display a preview of the node.    // Previewing alters $node so it needs to be cloned.    if (!form_get_errors()) {      $cloned_node = drupal_clone($node);      $cloned_node->build_mode = NODE_BUILD_PREVIEW;      $output = theme('node_preview', $cloned_node);    }    drupal_set_title(t('Preview'));    return $output;  }}/** * Display a node preview for display during node creation and editing. * * @param $node *   The node object which is being previewed. * * @ingroup themeable */function theme_node_preview($node) {  $output = '<div class="preview">';  $preview_trimmed_version = FALSE;  // Do we need to preview trimmed version of post as well as full version?  if (isset($node->teaser) && isset($node->body)) {    $teaser = trim($node->teaser);    $body = trim(str_replace('<!--break-->', '', $node->body));    // Preview trimmed version if teaser and body will appear different;    // also (edge case) if both teaser and body have been specified by the user    // and are actually the same.    if ($teaser != $body || ($body && strpos($node->body, '<!--break-->') === 0)) {      $preview_trimmed_version = TRUE;    }  }  if ($preview_trimmed_version) {    drupal_set_message(t('The trimmed version of your post shows what your post looks like when promoted to the main page or when exported for syndication.<span class="no-js"> You can insert the delimiter "&lt;!--break--&gt;" (without the quotes) to fine-tune where your post gets split.</span>'));    $output .= '<h3>'. t('Preview trimmed version') .'</h3>';    $output .= node_view(drupal_clone($node), 1, FALSE, 0);    $output .= '<h3>'. t('Preview full version') .'</h3>';    $output .= node_view($node, 0, FALSE, 0);  }  else {    $output .= node_view($node, 0, FALSE, 0);  }  $output .= "</div>\n";  return $output;}function node_form_submit($form, &$form_state) {  global $user;  $node = node_form_submit_build_node($form, $form_state);  $insert = empty($node->nid);  node_save($node);  $node_link = l(t('view'), 'node/'. $node->nid);  $watchdog_args = array('@type' => $node->type, '%title' => $node->title);  $t_args = array('@type' => node_get_types('name', $node), '%title' => $node->title);  if ($insert) {    watchdog('content', '@type: added %title.', $watchdog_args, WATCHDOG_NOTICE, $node_link);    drupal_set_message(t('@type %title has been created.', $t_args));  }  else {    watchdog('content', '@type: updated %title.', $watchdog_args, WATCHDOG_NOTICE, $node_link);    drupal_set_message(t('@type %title has been updated.', $t_args));  }  if ($node->nid) {    unset($form_state['rebuild']);    $form_state['nid'] = $node->nid;    $form_state['redirect'] = 'node/'. $node->nid;  }  else {    // In the unlikely case something went wrong on save, the node will be    // rebuilt and node form redisplayed the same way as in preview.    drupal_set_message(t('The post could not be saved.'), 'error');  }}/** * Build a node by processing submitted form values and prepare for a form rebuild. */function node_form_submit_build_node($form, &$form_state) {  // Unset any button-level handlers, execute all the form-level submit  // functions to process the form values into an updated node.  unset($form_state['submit_handlers']);  form_execute_handlers('submit', $form, $form_state);  $node = node_submit($form_state['values']);  $form_state['node'] = (array)$node;  $form_state['rebuild'] = TRUE;  return $node;}/** * Menu callback -- ask for confirmation of node deletion */function node_delete_confirm(&$form_state, $node) {  $form['nid'] = array(    '#type' => 'value',    '#value' => $node->nid,  );  return confirm_form($form,    t('Are you sure you want to delete %title?', array('%title' => $node->title)),    isset($_GET['destination']) ? $_GET['destination'] : 'node/'. $node->nid,    t('This action cannot be undone.'),    t('Delete'),    t('Cancel')  );}/** * Execute node deletion */function node_delete_confirm_submit($form, &$form_state) {  if ($form_state['values']['confirm']) {    node_delete($form_state['values']['nid']);  }  $form_state['redirect'] = '<front>';}/** * Generate an overview table of older revisions of a node. */function node_revision_overview($node) {  drupal_set_title(t('Revisions for %title', array('%title' => $node->title)));  $header = array(t('Revision'), array('data' => t('Operations'), 'colspan' => 2));  $revisions = node_revision_list($node);  $rows = array();  $revert_permission = FALSE;  if ((user_access('revert revisions') || user_access('administer nodes')) && node_access('update', $node)) {    $revert_permission = TRUE;  }  $delete_permission = FALSE;  if ((user_access('delete revisions') || user_access('administer nodes')) && node_access('delete', $node)) {    $delete_permission = TRUE;  }  foreach ($revisions as $revision) {    $row = array();    $operations = array();    if ($revision->current_vid > 0) {      $row[] = array('data' => t('!date by !username', array('!date' => l(format_date($revision->timestamp, 'small'), "node/$node->nid"), '!username' => theme('username', $revision)))                               . (($revision->log != '') ? '<p class="revision-log">'. filter_xss($revision->log) .'</p>' : ''),                     'class' => 'revision-current');      $operations[] = array('data' => theme('placeholder', t('current revision')), 'class' => 'revision-current', 'colspan' => 2);    }    else {      $row[] = t('!date by !username', array('!date' => l(format_date($revision->timestamp, 'small'), "node/$node->nid/revisions/$revision->vid/view"), '!username' => theme('username', $revision)))               . (($revision->log != '') ? '<p class="revision-log">'. filter_xss($revision->log) .'</p>' : '');      if ($revert_permission) {        $operations[] = l(t('revert'), "node/$node->nid/revisions/$revision->vid/revert");      }      if ($delete_permission) {        $operations[] = l(t('delete'), "node/$node->nid/revisions/$revision->vid/delete");      }    }    $rows[] = array_merge($row, $operations);  }  return theme('table', $header, $rows);}/** * Ask for confirmation of the reversion to prevent against CSRF attacks. */function node_revision_revert_confirm($form_state, $node_revision) {  $form['#node_revision'] = $node_revision;  return confirm_form($form, t('Are you sure you want to revert to the revision from %revision-date?', array('%revision-date' => format_date($node_revision->revision_timestamp))), 'node/'. $node_revision->nid .'/revisions', '', t('Revert'), t('Cancel'));}function node_revision_revert_confirm_submit($form, &$form_state) {  $node_revision = $form['#node_revision'];  $node_revision->revision = 1;  $node_revision->log = t('Copy of the revision from %date.', array('%date' => format_date($node_revision->revision_timestamp)));  if (module_exists('taxonomy')) {    $node_revision->taxonomy = array_keys($node_revision->taxonomy);  }  node_save($node_revision);  watchdog('content', '@type: reverted %title revision %revision.', array('@type' => $node_revision->type, '%title' => $node_revision->title, '%revision' => $node_revision->vid));  drupal_set_message(t('@type %title has been reverted back to the revision from %revision-date.', array('@type' => node_get_types('name', $node_revision), '%title' => $node_revision->title, '%revision-date' => format_date($node_revision->revision_timestamp))));  $form_state['redirect'] = 'node/'. $node_revision->nid .'/revisions';}function node_revision_delete_confirm($form_state, $node_revision) {  $form['#node_revision'] = $node_revision;  return confirm_form($form, t('Are you sure you want to delete the revision from %revision-date?', array('%revision-date' => format_date($node_revision->revision_timestamp))), 'node/'. $node_revision->nid .'/revisions', t('This action cannot be undone.'), t('Delete'), t('Cancel'));}function node_revision_delete_confirm_submit($form, &$form_state) {  $node_revision = $form['#node_revision'];  db_query("DELETE FROM {node_revisions} WHERE nid = %d AND vid = %d", $node_revision->nid, $node_revision->vid);  node_invoke_nodeapi($node_revision, 'delete revision');  watchdog('content', '@type: deleted %title revision %revision.', array('@type' => $node_revision->type, '%title' => $node_revision->title, '%revision' => $node_revision->vid));  drupal_set_message(t('Revision from %revision-date of @type %title has been deleted.', array('%revision-date' => format_date($node_revision->revision_timestamp), '@type' => node_get_types('name', $node_revision), '%title' => $node_revision->title)));  $form_state['redirect'] = 'node/'. $node_revision->nid;  if (db_result(db_query('SELECT COUNT(vid) FROM {node_revisions} WHERE nid = %d', $node_revision->nid)) > 1) {    $form_state['redirect'] .= '/revisions';  }}
<?php// $Id$/** * @file * Code required only when comparing available updates to existing data. *//** * Fetch an array of installed and enabled projects. * * This is only responsible for generating an array of projects (taking into * account projects that include more than one module or theme). Other * information like the specific version and install type (official release, * dev snapshot, etc) is handled later in update_process_project_info() since * that logic is only required when preparing the status report, not for * fetching the available release data. * * This array is fairly expensive to construct, since it involves a lot of * disk I/O, so we cache the results into the {cache_update} table using the * 'update_project_projects' cache ID. However, since this is not the data * about available updates fetched from the network, it is ok to invalidate it * somewhat quickly. If we keep this data for very long, site administrators * are more likely to see incorrect results if they upgrade to a newer version * of a module or theme but do not visit certain pages that automatically * clear this cache. * * @see update_process_project_info() * @see update_calculate_project_data() * @see update_project_cache() */function update_get_projects() {  static $projects = array();  if (empty($projects)) {    // Retrieve the projects from cache, if present.    $projects = update_project_cache('update_project_projects');    if (empty($projects)) {      // Still empty, so we have to rebuild the cache.      _update_process_info_list($projects, module_rebuild_cache(), 'module');      _update_process_info_list($projects, system_theme_data(), 'theme');      // Allow other modules to alter projects before fetching and comparing.      drupal_alter('update_projects', $projects);      // Cache the site's project data for at most 1 hour.      _update_cache_set('update_project_projects', $projects, time() + 3600);    }  }  return $projects;}/** * Populate an array of project data. */function _update_process_info_list(&$projects, $list, $project_type) {  foreach ($list as $file) {    // A disabled base theme of an enabled sub-theme still has all of its code    // run by the sub-theme, so we include it in our "enabled" projects list.    if (!$file->status && !empty($file->sub_themes)) {      foreach ($file->sub_themes as $key => $name) {        // Build a list of enabled sub-themes.        if ($list[$key]->status) {          $file->enabled_sub_themes[$key] = $name;        }      }      // If there are no enabled subthemes, we should ingore this theme and go      // on to the next one.      if (empty($file->enabled_sub_themes)) {        continue;      }    }    elseif (empty($file->status)) {      // Skip disabled modules or themes.      continue;    }    // Skip if the .info file is broken.    if (empty($file->info)) {      continue;    }    // If the .info doesn't define the 'project', try to figure it out.    if (!isset($file->info['project'])) {      $file->info['project'] = update_get_project_name($file);    }    // If we still don't know the 'project', give up.    if (empty($file->info['project'])) {      continue;    }    // If we don't already know it, grab the change time on the .info file    // itself. Note: we need to use the ctime, not the mtime (modification    // time) since many (all?) tar implementations will go out of their way to    // set the mtime on the files it creates to the timestamps recorded in the    // tarball. We want to see the last time the file was changed on disk,    // which is left alone by tar and correctly set to the time the .info file    // was unpacked.    if (!isset($file->info['_info_file_ctime'])) {      $info_filename = dirname($file->filename) .'/'. $file->name .'.info';      $file->info['_info_file_ctime'] = filectime($info_filename);    }    if (!isset($file->info['datestamp'])) {      $file->info['datestamp'] = 0;    }    $project_name = $file->info['project'];    // Add a list of sub-themes that "depend on" the project and a list of base    // themes that are "required by" the project.    if ($project_name == 'drupal') {      // Drupal core is always required, so this extra info would be noise.      $sub_themes = array();      $base_themes = array();    }    else {      // Add list of enabled sub-themes.      $sub_themes = !empty($file->enabled_sub_themes) ? $file->enabled_sub_themes : array();      // Add list of base themes.      $base_themes = !empty($file->base_themes) ? $file->base_themes : array();    }    if (!isset($projects[$project_name])) {      // Only process this if we haven't done this project, since a single      // project can have multiple modules or themes.      $projects[$project_name] = array(        'name' => $project_name,        // Only save attributes from the .info file we care about so we do not        // bloat our RAM usage needlessly.        'info' => update_filter_project_info($file->info),        'datestamp' => $file->info['datestamp'],        'includes' => array($file->name => $file->info['name']),        'project_type' => $project_name == 'drupal' ? 'core' : $project_type,        'sub_themes' => $sub_themes,        'base_themes' => $base_themes,      );    }    else {      $projects[$project_name]['includes'][$file->name] = $file->info['name'];      $projects[$project_name]['info']['_info_file_ctime'] = max($projects[$project_name]['info']['_info_file_ctime'], $file->info['_info_file_ctime']);      $projects[$project_name]['datestamp'] = max($projects[$project_name]['datestamp'], $file->info['datestamp']);      $projects[$project_name]['sub_themes'] = array_merge($projects[$project_name]['sub_themes'], $sub_themes);      $projects[$project_name]['base_themes'] = array_merge($projects[$project_name]['base_themes'], $base_themes);    }  }}/** * Given a $file object (as returned by system_get_files_database()), figure * out what project it belongs to. * * @see system_get_files_database() */function update_get_project_name($file) {  $project_name = '';  if (isset($file->info['project'])) {    $project_name = $file->info['project'];  }  elseif (isset($file->info['package']) && (strpos($file->info['package'], 'Core -') !== FALSE)) {    $project_name = 'drupal';  }  elseif (in_array($file->name, array('bluemarine', 'chameleon', 'garland', 'marvin', 'minnelli', 'pushbutton'))) {    // Unfortunately, there's no way to tell if a theme is part of core,    // so we must hard-code a list here.    $project_name = 'drupal';  }  return $project_name;}/** * Process the list of projects on the system to figure out the currently * installed versions, and other information that is required before we can * compare against the available releases to produce the status report. * * @param $projects *   Array of project information from update_get_projects(). */function update_process_project_info(&$projects) {  foreach ($projects as $key => $project) {    // Assume an official release until we see otherwise.    $install_type = 'official';    $info = $project['info'];    if (isset($info['version'])) {      // Check for development snapshots      if (preg_match('@(dev|HEAD)@', $info['version'])) {        $install_type = 'dev';      }      // Figure out what the currently installed major version is. We need      // to handle both contribution (e.g. "5.x-1.3", major = 1) and core      // (e.g. "5.1", major = 5) version strings.      $matches = array();      if (preg_match('/^(\d+\.x-)?(\d+)\..*$/', $info['version'], $matches)) {        $info['major'] = $matches[2];      }      elseif (!isset($info['major'])) {        // This would only happen for version strings that don't follow the        // drupal.org convention. We let contribs define "major" in their        // .info in this case, and only if that's missing would we hit this.        $info['major'] = -1;      }    }    else {      // No version info available at all.      $install_type = 'unknown';      $info['version'] = t('Unknown');      $info['major'] = -1;    }    // Finally, save the results we care about into the $projects array.    $projects[$key]['existing_version'] = $info['version'];    $projects[$key]['existing_major'] = $info['major'];    $projects[$key]['install_type'] = $install_type;  }}/** * Given the installed projects and the available release data retrieved from * remote servers, calculate the current status. * * This function is the heart of the update status feature. It iterates over * every currently installed project. For each one, it first checks if the * project has been flagged with a special status like "unsupported" or * "insecure", or if the project node itself has been unpublished. In any of * those cases, the project is marked with an error and the next project is * considered. * * If the project itself is valid, the function decides what major release * series to consider. The project defines what the currently supported major * versions are for each version of core, so the first step is to make sure * the current version is still supported. If so, that's the target version. * If the current version is unsupported, the project maintainer's recommended * major version is used. There's also a check to make sure that this function * never recommends an earlier release than the currently installed major * version. * * Given a target major version, it scans the available releases looking for * the specific release to recommend (avoiding beta releases and development * snapshots if possible). This is complicated to describe, but an example * will help clarify. For the target major version, find the highest patch * level. If there is a release at that patch level with no extra ("beta", * etc), then we recommend the release at that patch level with the most * recent release date. If every release at that patch level has extra (only * betas), then recommend the latest release from the previous patch * level. For example: * * 1.6-bugfix <-- recommended version because 1.6 already exists. * 1.6 * * or * * 1.6-beta * 1.5 <-- recommended version because no 1.6 exists. * 1.4 * * It also looks for the latest release from the same major version, even a * beta release, to display to the user as the "Latest version" option. * Additionally, it finds the latest official release from any higher major * versions that have been released to provide a set of "Also available" * options. * * Finally, and most importantly, it keeps scanning the release history until * it gets to the currently installed release, searching for anything marked * as a security update. If any security updates have been found between the * recommended release and the installed version, all of the releases that * included a security fix are recorded so that the site administrator can be * warned their site is insecure, and links pointing to the release notes for * each security update can be included (which, in turn, will link to the * official security announcements for each vulnerability). * * This function relies on the fact that the .xml release history data comes * sorted based on major version and patch level, then finally by release date * if there are multiple releases such as betas from the same major.patch * version (e.g. 5.x-1.5-beta1, 5.x-1.5-beta2, and 5.x-1.5). Development * snapshots for a given major version are always listed last. * * The results of this function are expensive to compute, especially on sites * with lots of modules or themes, since it involves a lot of comparisons and * other operations. Therefore, we cache the results into the {cache_update} * table using the 'update_project_data' cache ID. However, since this is not * the data about available updates fetched from the network, it is ok to * invalidate it somewhat quickly. If we keep this data for very long, site * administrators are more likely to see incorrect results if they upgrade to * a newer version of a module or theme but do not visit certain pages that * automatically clear this cache. * * @param $available *  Array of data about available project releases. * * @see update_get_available() * @see update_get_projects() * @see update_process_project_info() * @see update_project_cache() */function update_calculate_project_data($available) {  // Retrieve the projects from cache, if present.  $projects = update_project_cache('update_project_data');  // If $projects is empty, then the cache must be rebuilt.  // Otherwise, return the cached data and skip the rest of the function.  if (!empty($projects)) {    return $projects;  }  $projects = update_get_projects();  update_process_project_info($projects);  foreach ($projects as $project => $project_info) {    if (isset($available[$project])) {      // If the project status is marked as something bad, there's nothing      // else to consider.      if (isset($available[$project]['project_status'])) {        switch ($available[$project]['project_status']) {          case 'insecure':            $projects[$project]['status'] = UPDATE_NOT_SECURE;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-not-secure',              'label' => t('Project not secure'),              'data' => t('This project has been labeled insecure by the Drupal security team, and is no longer available for download. Immediately disabling everything included by this project is strongly recommended!'),            );            break;          case 'unpublished':          case 'revoked':            $projects[$project]['status'] = UPDATE_REVOKED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-revoked',              'label' => t('Project revoked'),              'data' => t('This project has been revoked, and is no longer available for download. Disabling everything included by this project is strongly recommended!'),            );            break;          case 'unsupported':            $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-not-supported',              'label' => t('Project not supported'),              'data' => t('This project is no longer supported, and is no longer available for download. Disabling everything included by this project is strongly recommended!'),            );            break;          case 'not-fetched':            $projects[$project]['status'] = UPDATE_NOT_FETCHED;            $projects[$project]['reason'] = t('Failed to fetch available update data');            break;          default:            // Assume anything else (e.g. 'published') is valid and we should            // perform the rest of the logic in this function.            break;        }      }      if (!empty($projects[$project]['status'])) {        // We already know the status for this project, so there's nothing        // else to compute. Just record everything else we fetched from the        // XML file into our projects array and move to the next project.        $projects[$project] += $available[$project];        continue;      }      // Figure out the target major version.      $existing_major = $project_info['existing_major'];      $supported_majors = array();      if (isset($available[$project]['supported_majors'])) {        $supported_majors = explode(',', $available[$project]['supported_majors']);      }      elseif (isset($available[$project]['default_major'])) {        // Older release history XML file without supported or recommended.        $supported_majors[] = $available[$project]['default_major'];      }      if (in_array($existing_major, $supported_majors)) {        // Still supported, stay at the current major version.        $target_major = $existing_major;      }      elseif (isset($available[$project]['recommended_major'])) {        // Since 'recommended_major' is defined, we know this is the new XML        // format. Therefore, we know the current release is unsupported since        // its major version was not in the 'supported_majors' list. We should        // find the best release from the recommended major version.        $target_major = $available[$project]['recommended_major'];        $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;      }      elseif (isset($available[$project]['default_major'])) {        // Older release history XML file without recommended, so recommend        // the currently defined "default_major" version.        $target_major = $available[$project]['default_major'];      }      else {        // Malformed XML file? Stick with the current version.        $target_major = $existing_major;      }      // Make sure we never tell the admin to downgrade. If we recommended an      // earlier version than the one they're running, they'd face an      // impossible data migration problem, since Drupal never supports a DB      // downgrade path. In the unfortunate case that what they're running is      // unsupported, and there's nothing newer for them to upgrade to, we      // can't print out a "Recommended version", but just have to tell them      // what they have is unsupported and let them figure it out.      $target_major = max($existing_major, $target_major);      $version_patch_changed = '';      $patch = '';      // Defend ourselves from XML history files that contain no releases.      if (empty($available[$project]['releases'])) {        $projects[$project]['status'] = UPDATE_UNKNOWN;        $projects[$project]['reason'] = t('No available releases found');        continue;      }      foreach ($available[$project]['releases'] as $version => $release) {        // First, if this is the existing release, check a few conditions.        if ($projects[$project]['existing_version'] === $version) {          if (isset($release['terms']['Release type']) &&              in_array('Insecure', $release['terms']['Release type'])) {            $projects[$project]['status'] = UPDATE_NOT_SECURE;          }          elseif ($release['status'] == 'unpublished') {            $projects[$project]['status'] = UPDATE_REVOKED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'release-revoked',              'label' => t('Release revoked'),              'data' => t('Your currently installed release has been revoked, and is no longer available for download. Disabling everything included in this release or upgrading is strongly recommended!'),            );          }          elseif (isset($release['terms']['Release type']) &&                  in_array('Unsupported', $release['terms']['Release type'])) {            $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'release-not-supported',              'label' => t('Release not supported'),              'data' => t('Your currently installed release is now unsupported, and is no longer available for download. Disabling everything included in this release or upgrading is strongly recommended!'),            );          }        }        // Otherwise, ignore unpublished, insecure, or unsupported releases.        if ($release['status'] == 'unpublished' ||            (isset($release['terms']['Release type']) &&             (in_array('Insecure', $release['terms']['Release type']) ||              in_array('Unsupported', $release['terms']['Release type'])))) {          continue;        }        // See if this is a higher major version than our target and yet still        // supported. If so, record it as an "Also available" release.        if ($release['version_major'] > $target_major) {          if (in_array($release['version_major'], $supported_majors)) {            if (!isset($available[$project]['also'])) {              $available[$project]['also'] = array();            }            if (!isset($available[$project]['also'][$release['version_major']])) {              $available[$project]['also'][$release['version_major']] = $version;            }          }          // Otherwise, this release can't matter to us, since it's neither          // from the release series we're currently using nor the recommended          // release. We don't even care about security updates for this          // branch, since if a project maintainer puts out a security release          // at a higher major version and not at the lower major version,          // they must remove the lower version from the supported major          // versions at the same time, in which case we won't hit this code.          continue;        }        // Look for the 'latest version' if we haven't found it yet. Latest is        // defined as the most recent version for the target major version.        if (!isset($available[$project]['latest_version'])            && $release['version_major'] == $target_major) {          $available[$project]['latest_version'] = $version;        }        // Look for the development snapshot release for this branch.        if (!isset($available[$project]['dev_version'])            && $release['version_major'] == $target_major            && isset($release['version_extra'])            && $release['version_extra'] == 'dev') {          $available[$project]['dev_version'] = $version;        }        // Look for the 'recommended' version if we haven't found it yet (see        // phpdoc at the top of this function for the definition).        if (!isset($available[$project]['recommended'])            && $release['version_major'] == $target_major            && isset($release['version_patch'])) {          if ($patch != $release['version_patch']) {            $patch = $release['version_patch'];            $version_patch_changed = $release['version'];          }          if (empty($release['version_extra']) && $patch == $release['version_patch']) {            $available[$project]['recommended'] = $version_patch_changed;          }        }        // Stop searching once we hit the currently installed version.        if ($projects[$project]['existing_version'] === $version) {          break;        }        // If we're running a dev snapshot and have a timestamp, stop        // searching for security updates once we hit an official release        // older than what we've got. Allow 100 seconds of leeway to handle        // differences between the datestamp in the .info file and the        // timestamp of the tarball itself (which are usually off by 1 or 2        // seconds) so that we don't flag that as a new release.        if ($projects[$project]['install_type'] == 'dev') {          if (empty($projects[$project]['datestamp'])) {            // We don't have current timestamp info, so we can't know.            continue;          }          elseif (isset($release['date']) && ($projects[$project]['datestamp'] + 100 > $release['date'])) {            // We're newer than this, so we can skip it.            continue;          }        }        // See if this release is a security update.        if (isset($release['terms']['Release type'])            && in_array('Security update', $release['terms']['Release type'])) {          $projects[$project]['security updates'][] = $release;        }      }      // If we were unable to find a recommended version, then make the latest      // version the recommended version if possible.      if (!isset($available[$project]['recommended']) && isset($available[$project]['latest_version'])) {        $available[$project]['recommended'] = $available[$project]['latest_version'];      }      // Stash the info about available releases into our $projects array.      $projects[$project] += $available[$project];      //      // Check to see if we need an update or not.      //      if (!empty($projects[$project]['security updates'])) {        // If we found security updates, that always trumps any other status.        $projects[$project]['status'] = UPDATE_NOT_SECURE;      }      if (isset($projects[$project]['status'])) {        // If we already know the status, we're done.        continue;      }      // If we don't know what to recommend, there's nothing we can report.      // Bail out early.      if (!isset($projects[$project]['recommended'])) {        $projects[$project]['status'] = UPDATE_UNKNOWN;        $projects[$project]['reason'] = t('No available releases found');        continue;      }      // If we're running a dev snapshot, compare the date of the dev snapshot      // with the latest official version, and record the absolute latest in      // 'latest_dev' so we can correctly decide if there's a newer release      // than our current snapshot.      if ($projects[$project]['install_type'] == 'dev') {        if (isset($available[$project]['dev_version']) && $available[$project]['releases'][$available[$project]['dev_version']]['date'] > $available[$project]['releases'][$available[$project]['latest_version']]['date']) {          $projects[$project]['latest_dev'] = $available[$project]['dev_version'];        }        else {          $projects[$project]['latest_dev'] = $available[$project]['latest_version'];        }      }      // Figure out the status, based on what we've seen and the install type.      switch ($projects[$project]['install_type']) {        case 'official':          if ($projects[$project]['existing_version'] === $projects[$project]['recommended'] || $projects[$project]['existing_version'] === $projects[$project]['latest_version']) {            $projects[$project]['status'] = UPDATE_CURRENT;          }          else {            $projects[$project]['status'] = UPDATE_NOT_CURRENT;          }          break;        case 'dev':          $latest = $available[$project]['releases'][$projects[$project]['latest_dev']];          if (empty($projects[$project]['datestamp'])) {            $projects[$project]['status'] = UPDATE_NOT_CHECKED;            $projects[$project]['reason'] = t('Unknown release date');          }          elseif (($projects[$project]['datestamp'] + 100 > $latest['date'])) {            $projects[$project]['status'] = UPDATE_CURRENT;          }          else {            $projects[$project]['status'] = UPDATE_NOT_CURRENT;          }          break;        default:          $projects[$project]['status'] = UPDATE_UNKNOWN;          $projects[$project]['reason'] = t('Invalid info');      }    }    else {      $projects[$project]['status'] = UPDATE_UNKNOWN;      $projects[$project]['reason'] = t('No available releases found');    }  }  // Give other modules a chance to alter the status (for example, to allow a  // contrib module to provide fine-grained settings to ignore specific  // projects or releases).  drupal_alter('update_status', $projects);  // Cache the site's update status for at most 1 hour.  _update_cache_set('update_project_data', $projects, time() + 3600);  return $projects;}/** * Retrieve data from {cache_update} or empty the cache when necessary. * * Two very expensive arrays computed by this module are the list of all * installed modules and themes (and .info data, project associations, etc), * and the current status of the site relative to the currently available * releases. These two arrays are cached in the {cache_update} table and used * whenever possible. The cache is cleared whenever the administrator visits * the status report, available updates report, or the module or theme * administration pages, since we should always recompute the most current * values on any of those pages. * * Note: while both of these arrays are expensive to compute (in terms of disk * I/O and some fairly heavy CPU processing), neither of these is the actual * data about available updates that we have to fetch over the network from * updates.drupal.org. That information is stored with the * 'update_available_releases' cache ID -- it needs to persist longer than 1 * hour and never get invalidated just by visiting a page on the site. * * @param $cid *   The cache id of data to return from the cache. Valid options are *   'update_project_data' and 'update_project_projects'. * * @return *   The cached value of the $projects array generated by *   update_calculate_project_data() or update_get_projects(), or an empty *   array when the cache is cleared. */function update_project_cache($cid) {  $projects = array();  // On certain paths, we should clear the cache and recompute the projects or  // update status of the site to avoid presenting stale information.  $q = $_GET['q'];  $paths = array('admin/build/modules', 'admin/build/themes', 'admin/reports', 'admin/reports/updates', 'admin/reports/status', 'admin/reports/updates/check');  if (in_array($q, $paths)) {    _update_cache_clear($cid);  }  else {    $cache = _update_cache_get($cid);    if (!empty($cache->data) && $cache->expire > time()) {      $projects = $cache->data;    }  }  return $projects;}/** * Filter the project .info data to only save attributes we need. * * @param array $info *   Array of .info file data as returned by drupal_parse_info_file(). * * @return *   Array of .info file data we need for the Update manager. * * @see _update_process_info_list() */function update_filter_project_info($info) {  $whitelist = array(    '_info_file_ctime',    'datestamp',    'major',    'name',    'package',    'project',    'project status url',    'version',   );  return array_intersect_key($info, drupal_map_assoc($whitelist));}
<?php// $Id$/** * @file book-navigation.tpl.php * Default theme implementation to navigate books. Presented under nodes that * are a part of book outlines. * * Available variables: * - $tree: The immediate children of the current node rendered as an *   unordered list. * - $current_depth: Depth of the current node within the book outline. *   Provided for context. * - $prev_url: URL to the previous node. * - $prev_title: Title of the previous node. * - $parent_url: URL to the parent node. * - $parent_title: Title of the parent node. Not printed by default. Provided *   as an option. * - $next_url: URL to the next node. * - $next_title: Title of the next node. * - $has_links: Flags TRUE whenever the previous, parent or next data has a *   value. * - $book_id: The book ID of the current outline being viewed. Same as the *   node ID containing the entire outline. Provided for context. * - $book_url: The book/node URL of the current outline being viewed. *   Provided as an option. Not used by default. * - $book_title: The book/node title of the current outline being viewed. *   Provided as an option. Not used by default. * * @see template_preprocess_book_navigation() */?><?php if ($tree || $has_links): ?>  <div id="book-navigation-<?php print $book_id; ?>" class="book-navigation">    <?php print $tree; ?>    <?php if ($has_links): ?>    <div class="page-links clear-block">      <?php if ($prev_url) : ?>        <a href="<?php print $prev_url; ?>" class="page-previous" title="<?php print t('Go to previous page'); ?>"><?php print t(' ') . $prev_title; ?></a>      <?php endif; ?>      <?php if ($parent_url) : ?>        <a href="<?php print $parent_url; ?>" class="page-up" title="<?php print t('Go to parent page'); ?>"><?php print t('up'); ?></a>      <?php endif; ?>      <?php if ($next_url) : ?>        <a href="<?php print $next_url; ?>" class="page-next" title="<?php print t('Go to next page'); ?>"><?php print $next_title . t(' '); ?></a>      <?php endif; ?>    </div>    <?php endif; ?>  </div><?php endif; ?>
<?php// $Id$/** * @file * Enables tracking of recent posts for users. *//** * Implementation of hook_help(). */function tracker_help($path, $arg) {  switch ($path) {    case 'admin/help#tracker':      $output = '<p>'. t('The tracker module displays the most recently added or updated content on your site, and provides user-level tracking to follow the contributions of particular authors.') .'</p>';      $output .= '<p>'. t("The <em>Recent posts</em> page is available via a link in the navigation menu block and displays new and recently-updated content (including the content type, the title, the author's name, number of comments, and time of last update) in reverse chronological order. Posts are marked updated when changes occur in the text, or when new comments are added. To use the tracker module to follow a specific user's contributions, select the <em>Track</em> tab from the user's profile page.") .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@tracker">Tracker module</a>.', array('@tracker' => 'http://drupal.org/handbook/modules/tracker/')) .'</p>';      return $output;  }}/** * Implementation of hook_menu(). */function tracker_menu() {  $items['tracker'] = array(    'title' => 'Recent posts',    'page callback' => 'tracker_page',    'access arguments' => array('access content'),    'weight' => 1,    'file' => 'tracker.pages.inc',  );  $items['tracker/all'] = array(    'title' => 'All recent posts',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['tracker/%user_uid_optional'] = array(    'title' => 'My recent posts',    'access callback' => '_tracker_myrecent_access',    'access arguments' => array(1),    'page arguments' => array(1),    'type' => MENU_LOCAL_TASK,  );  $items['user/%user/track'] = array(    'title' => 'Track',    'page callback' => 'tracker_page',    'page arguments' => array(1, TRUE),    'access callback' => '_tracker_user_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'file' => 'tracker.pages.inc',  );  $items['user/%user/track/posts'] = array(    'title' => 'Track posts',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  return $items;}/** * Access callback for tracker/%user_uid_optional */function _tracker_myrecent_access($account) {  // This path is only allowed for authenticated users looking at their own posts.  return $account->uid && ($GLOBALS['user']->uid == $account->uid) && user_access('access content');}/** * Access callback for user/%user/track */function _tracker_user_access($account) {  return user_view_access($account) && user_access('access content');}
<?php// $Id$/** * @file * Admin page callbacks for the statistics module. *//** * Menu callback; presents the "recent hits" page. */function statistics_recent_hits() {  $header = array(    array('data' => t('Timestamp'), 'field' => 'a.timestamp', 'sort' => 'desc'),    array('data' => t('Page'), 'field' => 'a.path'),    array('data' => t('User'), 'field' => 'u.name'),    array('data' => t('Operations'))  );  $sql = 'SELECT a.aid, a.path, a.title, a.uid, u.name, a.timestamp FROM {accesslog} a LEFT JOIN {users} u ON u.uid = a.uid'. tablesort_sql($header);  $result = pager_query($sql, 30);  $rows = array();  while ($log = db_fetch_object($result)) {    $rows[] = array(      array('data' => format_date($log->timestamp, 'small'), 'class' => 'nowrap'),      _statistics_format_item($log->title, $log->path),      theme('username', $log),      l(t('details'), "admin/reports/access/$log->aid"));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "top pages" page. */function statistics_top_pages() {  // MAX(title) avoids having empty node titles which otherwise causes duplicates in the top pages list  $sql = "SELECT COUNT(path) AS hits, path, MAX(title) AS title, AVG(timer) AS average_time, SUM(timer) AS total_time FROM {accesslog} GROUP BY path";  $sql_cnt = "SELECT COUNT(DISTINCT(path)) FROM {accesslog}";  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Page'), 'field' => 'path'),    array('data' => t('Average page generation time'), 'field' => 'average_time'),    array('data' => t('Total page generation time'), 'field' => 'total_time')  );  $sql .= tablesort_sql($header);  $result = pager_query($sql, 30, 0, $sql_cnt);  $rows = array();  while ($page = db_fetch_object($result)) {    $rows[] = array($page->hits, _statistics_format_item($page->title, $page->path), t('%time ms', array('%time' => round($page->average_time))), format_interval(round($page->total_time / 1000)));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  drupal_set_title(t('Top pages in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "top visitors" page. */function statistics_top_visitors() {  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Visitor'), 'field' => 'u.name'),    array('data' => t('Total page generation time'), 'field' => 'total'),    array('data' => t('Operations'))  );  $sql = "SELECT COUNT(a.uid) AS hits, a.uid, u.name, a.hostname, SUM(a.timer) AS total, ac.aid FROM {accesslog} a LEFT JOIN {access} ac ON ac.type = 'host' AND LOWER(a.hostname) LIKE (ac.mask) LEFT JOIN {users} u ON a.uid = u.uid GROUP BY a.hostname, a.uid, u.name, ac.aid". tablesort_sql($header);  $sql_cnt = "SELECT COUNT(DISTINCT(CONCAT(uid, hostname))) FROM {accesslog}";  $result = pager_query($sql, 30, 0, $sql_cnt);  $rows = array();  while ($account = db_fetch_object($result)) {    $qs = drupal_get_destination();    $ban_link = $account->aid ? l(t('unban'), "admin/user/rules/delete/$account->aid", array('query' => $qs)) : l(t('ban'), "admin/user/rules/add/$account->hostname/host", array('query' => $qs));    $rows[] = array($account->hits, ($account->uid ? theme('username', $account) : $account->hostname), format_interval(round($account->total / 1000)), $ban_link);  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  drupal_set_title(t('Top visitors in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "referrer" page. */function statistics_top_referrers() {  $query = "SELECT url, COUNT(url) AS hits, MAX(timestamp) AS last FROM {accesslog} WHERE url NOT LIKE '%%%s%%' AND url <> '' GROUP BY url";  $query_cnt = "SELECT COUNT(DISTINCT(url)) FROM {accesslog} WHERE url <> '' AND url NOT LIKE '%%%s%%'";  drupal_set_title(t('Top referrers in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Url'), 'field' => 'url'),    array('data' => t('Last visit'), 'field' => 'last'),  );  $query .= tablesort_sql($header);  $result = pager_query($query, 30, 0, $query_cnt, $_SERVER['HTTP_HOST']);  $rows = array();  while ($referrer = db_fetch_object($result)) {    $rows[] = array($referrer->hits, _statistics_link($referrer->url), t('@time ago', array('@time' => format_interval(time() - $referrer->last))));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 3));  }  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; Displays recent page accesses. */function statistics_access_log($aid) {  $result = db_query('SELECT a.*, u.name FROM {accesslog} a LEFT JOIN {users} u ON a.uid = u.uid WHERE aid = %d', $aid);  if ($access = db_fetch_object($result)) {    $rows[] = array(      array('data' => t('URL'), 'header' => TRUE),      l(url($access->path, array('absolute' => TRUE)), $access->path)    );    // It is safe to avoid filtering $access->title through check_plain because    // it comes from drupal_get_title().    $rows[] = array(      array('data' => t('Title'), 'header' => TRUE),      $access->title    );    $rows[] = array(      array('data' => t('Referrer'), 'header' => TRUE),      ($access->url ? l($access->url, $access->url) : '')    );    $rows[] = array(      array('data' => t('Date'), 'header' => TRUE),      format_date($access->timestamp, 'large')    );    $rows[] = array(      array('data' => t('User'), 'header' => TRUE),      theme('username', $access)    );    $rows[] = array(      array('data' => t('Hostname'), 'header' => TRUE),      check_plain($access->hostname)    );    return theme('table', array(), $rows);  }  else {    drupal_not_found();  }}/** * Form builder; Configure access logging. * * @ingroup forms * @see system_settings_form() */function statistics_access_logging_settings() {  // Access log settings:  $options = array('1' => t('Enabled'), '0' => t('Disabled'));  $form['access'] = array(    '#type' => 'fieldset',    '#title' => t('Access log settings'));  $form['access']['statistics_enable_access_log'] = array(    '#type' => 'radios',    '#title' => t('Enable access log'),    '#default_value' => variable_get('statistics_enable_access_log', 0),    '#options' => $options,    '#description' => t('Log each page access. Required for referrer statistics.'));  $period = drupal_map_assoc(array(3600, 10800, 21600, 32400, 43200, 86400, 172800, 259200, 604800, 1209600, 2419200, 4838400, 9676800), 'format_interval');  $form['access']['statistics_flush_accesslog_timer'] = array(    '#type' => 'select',    '#title' => t('Discard access logs older than'),    '#default_value'   => variable_get('statistics_flush_accesslog_timer', 259200),    '#options' => $period,    '#description' => t('Older access log entries (including referrer statistics) will be automatically discarded. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status'))));  // count content views settings  $form['content'] = array(    '#type' => 'fieldset',    '#title' => t('Content viewing counter settings'));  $form['content']['statistics_count_content_views'] = array(    '#type' => 'radios',    '#title' => t('Count content views'),    '#default_value' => variable_get('statistics_count_content_views', 0),    '#options' => $options,    '#description' => t('Increment a counter each time content is viewed.'));  return system_settings_form($form);}
<?php// $Id$/** * @file * Enables keeping an easily and regularly updated web page or a blog. *//** * Implementation of hook_node_info(). */function blog_node_info() {  return array(    'blog' => array(      'name' => t('Blog entry'),      'module' => 'blog',      'description' => t('A <em>blog entry</em> is a single post to an online journal, or <em>blog</em>.'),    )  );}/** * Implementation of hook_perm(). */function blog_perm() {  return array('create blog entries', 'delete own blog entries', 'delete any blog entry', 'edit own blog entries', 'edit any blog entry');}/** * Implementation of hook_access(). */function blog_access($op, $node, $account) {  switch ($op) {    case 'create':      // Anonymous users cannot post even if they have the permission.       return user_access('create blog entries', $account) && $account->uid ? TRUE : NULL;    case 'update':      return user_access('edit any blog entry', $account) || (user_access('edit own blog entries', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;    case 'delete':      return user_access('delete any blog entry', $account) || (user_access('delete own blog entries', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;  }}/** * Implementation of hook_user(). */function blog_user($type, &$edit, &$user) {  if ($type == 'view' && user_access('create blog entries', $user)) {    $user->content['summary']['blog'] =  array(      '#type' => 'user_profile_item',      '#title' => t('Blog'),      // l() escapes the attributes, so we should not escape !username here.      '#value' => l(t('View recent blog entries'), "blog/$user->uid", array('attributes' => array('title' => t("Read !username's latest blog entries.", array('!username' => $user->name))))),      '#attributes' => array('class' => 'blog'),    );  }}/** * Implementation of hook_help(). */function blog_help($path, $arg) {  switch ($path) {    case 'admin/help#blog':      $output = '<p>'. t('The blog module allows registered users to maintain an online journal, or <em>blog</em>. Blogs are made up of individual <em>blog entries</em>, and the blog entries are most often displayed in descending order by creation time.') .'</p>';      $output .= '<p>'. t('There is an (optional) <em>Blogs</em> menu item added to the Navigation menu, which displays all blogs available on your site, and a <em>My blog</em> item displaying the current user\'s blog entries. The <em>Blog entry</em> menu item under <em>Create content</em> allows new blog entries to be created.') .'</p>';      $output .= '<p>'. t('Each blog entry is displayed with an automatic link to other blogs created by the same user. By default, blog entries have comments enabled and are automatically promoted to the site front page. The blog module also creates a <em>Recent blog posts</em> block that may be enabled at the <a href="@blocks">blocks administration page</a>.', array('@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('When using the aggregator module an automatic <em>blog it</em> icon is displayed next to the items in a feed\'s <em>latest items</em> block. Clicking this icon populates a <em>blog entry</em> with a title (the title of the feed item) and body (a link to the source item on its original site and illustrative content suitable for use in a block quote). Blog authors can use this feature to easily comment on items of interest that appear in aggregator feeds from other sites. To use this feature, be sure to <a href="@modules">enable</a> the aggregator module, <a href="@feeds">add and configure</a> a feed from another site, and <a href="@blocks">position</a> the feed\'s <em>latest items</em> block.', array('@modules' => url('admin/build/modules'), '@feeds' => url('admin/content/aggregator'), '@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@blog">Blog module</a>.', array('@blog' => 'http://drupal.org/handbook/modules/blog/')) .'</p>';      return $output;  }}/** * Implementation of hook_form(). */function blog_form(&$node) {  global $nid;  $iid = isset($_GET['iid']) ? (int)$_GET['iid'] : 0;  $type = node_get_types('type', $node);  if (empty($node->body)) {    // If the user clicked a "blog it" link, we load the data from the    // database and quote it in the blog.    if ($nid && $blog = node_load($nid)) {      $node->body = '<em>'. $blog->body .'</em> ['. l($blog->name, "node/$nid") .']';    }    if ($iid && $item = db_fetch_object(db_query('SELECT i.*, f.title as ftitle, f.link as flink FROM {aggregator_item} i, {aggregator_feed} f WHERE i.iid = %d AND i.fid = f.fid', $iid))) {      $node->title = $item->title;      // Note: $item->description has been validated on aggregation.      $node->body = '<a href="'. check_url($item->link) .'">'. check_plain($item->title) .'</a> - <em>'. $item->description .'</em> [<a href="'. check_url($item->flink) .'">'. check_plain($item->ftitle) ."</a>]\n";    }  }  $form['title'] = array('#type' => 'textfield', '#title' => check_plain($type->title_label), '#required' => TRUE, '#default_value' => !empty($node->title) ? $node->title : NULL, '#weight' => -5);  $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);  return $form;}/** * Implementation of hook_view(). */function blog_view($node, $teaser = FALSE, $page = FALSE) {  if ($page) {    // Breadcrumb navigation. l() escapes the title, so we should not escape !name.     drupal_set_breadcrumb(array(l(t('Home'), NULL), l(t('Blogs'), 'blog'), l(t("!name's blog", array('!name' => $node->name)), 'blog/'. $node->uid)));  }  return node_prepare($node, $teaser);}/** * Implementation of hook_link(). */function blog_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && $node->type == 'blog') {    if (arg(0) != 'blog' || arg(1) != $node->uid) {      // This goes to l() and therefore escapes !username in both the title and attributes.      $links['blog_usernames_blog'] = array(        'title' => t("!username's blog", array('!username' => $node->name)),        'href' => "blog/$node->uid",        'attributes' => array('title' => t("Read !username's latest blog entries.", array('!username' => $node->name)))      );    }  }  return $links;}/** * Implementation of hook_menu(). */function blog_menu() {  $items['blog'] = array(    'title' => 'Blogs',    'page callback' => 'blog_page_last',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'blog.pages.inc',  );  $items['blog/%user_uid_optional'] = array(    'title' => 'My blog',    'page callback' => 'blog_page_user',    'page arguments' => array(1),    'access callback' => 'blog_page_user_access',    'access arguments' => array(1),    'file' => 'blog.pages.inc',  );  $items['blog/%user/feed'] = array(    'title' => 'Blogs',    'page callback' => 'blog_feed_user',    'page arguments' => array(1),    'access callback' => 'blog_page_user_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,    'file' => 'blog.pages.inc',  );  $items['blog/feed'] = array(    'title' => 'Blogs',    'page callback' => 'blog_feed_last',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'blog.pages.inc',  );  return $items;}/** * Access callback for user blog pages. */function blog_page_user_access($account) {  // The visitor must be able to access the site's content.  // For a blog to 'exist' the user must either be able to  // create new blog entries, or it must have existing posts.  return $account->uid && user_access('access content') && (user_access('create blog entries', $account) || _blog_post_exists($account));}/** * Helper function to determine if a user has blog posts already. */function _blog_post_exists($account) {  return (bool)db_result(db_query_range(db_rewrite_sql("SELECT 1 FROM {node} n WHERE n.type = 'blog' AND n.uid = %d AND n.status = 1"), $account->uid, 0, 1));}/** * Implementation of hook_block(). * * Displays the most recent 10 blog titles. */function blog_block($op = 'list', $delta = 0) {  global $user;  if ($op == 'list') {    $block[0]['info'] = t('Recent blog posts');    return $block;  }  else if ($op == 'view') {    if (user_access('access content')) {      $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, n.created FROM {node} n WHERE n.type = 'blog' AND n.status = 1 ORDER BY n.created DESC"), 0, 10);      if ($node_title_list = node_title_list($result)) {        $block['content'] = $node_title_list;        $block['content'] .= theme('more_link', url('blog'), t('Read the latest blog entries.'));        $block['subject'] = t('Recent blog posts');        return $block;      }    }  }}
<?php// $Id$/** * @file * Used to aggregate syndicated content (RSS, RDF, and Atom). *//** * Implementation of hook_help(). */function aggregator_help($path, $arg) {  switch ($path) {    case 'admin/help#aggregator':      $output = '<p>'. t('The aggregator is a powerful on-site syndicator and news reader that gathers fresh content from RSS-, RDF-, and Atom-based feeds made available across the web. Thousands of sites (particularly news sites and blogs) publish their latest headlines and posts in feeds, using a number of standardized XML-based formats. Formats supported by the aggregator include <a href="@rss">RSS</a>, <a href="@rdf">RDF</a>, and <a href="@atom">Atom</a>.', array('@rss' => 'http://cyber.law.harvard.edu/rss/', '@rdf' => 'http://www.w3.org/RDF/', '@atom' => 'http://www.atomenabled.org')) .'</p>';      $output .= '<p>'. t('Feeds contain feed items, or individual posts published by the site providing the feed. Feeds may be grouped in categories, generally by topic. Users view feed items in the <a href="@aggregator">main aggregator display</a> or by <a href="@aggregator-sources">their source</a>. Administrators can <a href="@feededit">add, edit and delete feeds</a> and choose how often to check each feed for newly updated items. The most recent items in either a feed or category can be displayed as a block through the <a href="@admin-block">blocks administration page</a>. A <a href="@aggregator-opml">machine-readable OPML file</a> of all feeds is available. A correctly configured <a href="@cron">cron maintenance task</a> is required to update feeds automatically.', array('@aggregator' => url('aggregator'), '@aggregator-sources' => url('aggregator/sources'), '@feededit' => url('admin/content/aggregator'), '@admin-block' => url('admin/build/block'), '@aggregator-opml' => url('aggregator/opml'), '@cron' => url('admin/reports/status'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@aggregator">Aggregator module</a>.', array('@aggregator' => 'http://drupal.org/handbook/modules/aggregator/')) .'</p>';      return $output;    case 'admin/content/aggregator':      $output = '<p>'. t('Thousands of sites (particularly news sites and blogs) publish their latest headlines and posts in feeds, using a number of standardized XML-based formats. Formats supported by the aggregator include <a href="@rss">RSS</a>, <a href="@rdf">RDF</a>, and <a href="@atom">Atom</a>.', array('@rss' => 'http://cyber.law.harvard.edu/rss/', '@rdf' => 'http://www.w3.org/RDF/', '@atom' => 'http://www.atomenabled.org')) .'</p>';      $output .= '<p>'. t('Current feeds are listed below, and <a href="@addfeed">new feeds may be added</a>. For each feed or feed category, the <em>latest items</em> block may be enabled at the <a href="@block">blocks administration page</a>.', array('@addfeed' => url('admin/content/aggregator/add/feed'), '@block' => url('admin/build/block'))) .'</p>';      return $output;    case 'admin/content/aggregator/add/feed':      return '<p>'. t('Add a feed in RSS, RDF or Atom format. A feed may only have one entry.') .'</p>';    case 'admin/content/aggregator/add/category':      return '<p>'. t('Categories allow feed items from different feeds to be grouped together. For example, several sport-related feeds may belong to a category named <em>Sports</em>. Feed items may be grouped automatically (by selecting a category when creating or editing a feed) or manually (via the <em>Categorize</em> page available from feed item listings). Each category provides its own feed page and block.') .'</p>';  }}/** * Implementation of hook_theme() */function aggregator_theme() {  return array(    'aggregator_wrapper' => array(      'arguments' => array('content' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-wrapper',    ),    'aggregator_categorize_items' => array(      'arguments' => array('form' => NULL),      'file' => 'aggregator.pages.inc',    ),    'aggregator_feed_source' => array(      'arguments' => array('feed' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-feed-source',    ),    'aggregator_block_item' => array(      'arguments' => array('item' => NULL, 'feed' => 0),    ),    'aggregator_summary_items' => array(      'arguments' => array('summary_items' => NULL, 'source' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-summary-items',    ),    'aggregator_summary_item' => array(      'arguments' => array('item' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-summary-item',    ),    'aggregator_item' => array(      'arguments' => array('item' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-item',    ),    'aggregator_page_opml' => array(      'arguments' => array('feeds' => NULL),      'file' => 'aggregator.pages.inc',    ),    'aggregator_page_rss' => array(      'arguments' => array('feeds' => NULL, 'category' => NULL),      'file' => 'aggregator.pages.inc',    ),  );}/** * Implementation of hook_menu(). */function aggregator_menu() {  $items['admin/content/aggregator'] = array(    'title' => 'Feed aggregator',    'description' => "Configure which content your site aggregates from other sites, how often it polls them, and how they're categorized.",    'page callback' => 'aggregator_admin_overview',    'access arguments' => array('administer news feeds'),    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/add/feed'] = array(    'title' => 'Add feed',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_feed'),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/aggregator',    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/add/category'] = array(    'title' => 'Add category',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_category'),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/aggregator',    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/remove/%aggregator_feed'] = array(    'title' => 'Remove items',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_admin_remove_feed', 4),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/update/%aggregator_feed'] = array(    'title' => 'Update items',    'page callback' => 'aggregator_admin_refresh_feed',    'page arguments' => array(4),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/aggregator/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_admin_settings'),    'type' => MENU_LOCAL_TASK,    'weight' => 10,    'access arguments' => array('administer news feeds'),    'file' => 'aggregator.admin.inc',  );  $items['aggregator'] = array(    'title' => 'Feed aggregator',    'page callback' => 'aggregator_page_last',    'access arguments' => array('access news feeds'),    'weight' => 5,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/sources'] = array(    'title' => 'Sources',    'page callback' => 'aggregator_page_sources',    'access arguments' => array('access news feeds'),    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories'] = array(    'title' => 'Categories',    'page callback' => 'aggregator_page_categories',    'access callback' => '_aggregator_has_categories',    'file' => 'aggregator.pages.inc',  );  $items['aggregator/rss'] = array(    'title' => 'RSS feed',    'page callback' => 'aggregator_page_rss',    'access arguments' => array('access news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/opml'] = array(    'title' => 'OPML feed',    'page callback' => 'aggregator_page_opml',    'access arguments' => array('access news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories/%aggregator_category'] = array(    'title callback' => '_aggregator_category_title',    'title arguments' => array(2),    'page callback' => 'aggregator_page_category',    'page arguments' => array(2),    'access callback' => 'user_access',    'access arguments' => array('access news feeds'),    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories/%aggregator_category/view'] = array(    'title' => 'View',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['aggregator/categories/%aggregator_category/categorize'] = array(    'title' => 'Categorize',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_page_category', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories/%aggregator_category/configure'] = array(    'title' => 'Configure',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_category', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'aggregator.admin.inc',  );  $items['aggregator/sources/%aggregator_feed'] = array(    'page callback' => 'aggregator_page_source',    'page arguments' => array(2),    'access arguments' => array('access news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/sources/%aggregator_feed/view'] = array(    'title' => 'View',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['aggregator/sources/%aggregator_feed/categorize'] = array(    'title' => 'Categorize',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_page_source', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/sources/%aggregator_feed/configure'] = array(    'title' => 'Configure',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_feed', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/edit/feed/%aggregator_feed'] = array(    'title' => 'Edit feed',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_feed', 5),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/edit/category/%aggregator_category'] = array(    'title' => 'Edit category',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_category', 5),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  return $items;}/** * Menu callback. * * @return *   An aggregator category title. */function _aggregator_category_title($category) {  return $category['title'];}/** * Implementation of hook_init(). */function aggregator_init() {  drupal_add_css(drupal_get_path('module', 'aggregator') .'/aggregator.css');}/** * Find out whether there are any aggregator categories. * * @return *   TRUE if there is at least one category and the user has access to them, FALSE otherwise. */function _aggregator_has_categories() {  return user_access('access news feeds') && db_result(db_query('SELECT COUNT(*) FROM {aggregator_category}'));}/** * Implementation of hook_perm(). */function aggregator_perm() {  return array('administer news feeds', 'access news feeds');}/** * Implementation of hook_cron(). * * Checks news feeds for updates once their refresh interval has elapsed. */function aggregator_cron() {  $result = db_query('SELECT * FROM {aggregator_feed} WHERE checked + refresh < %d', time());  while ($feed = db_fetch_array($result)) {    aggregator_refresh($feed);  }}/** * Implementation of hook_block(). * * Generates blocks for the latest news items in each category and feed. */function aggregator_block($op = 'list', $delta = 0, $edit = array()) {  if (user_access('access news feeds')) {    if ($op == 'list') {      $result = db_query('SELECT cid, title FROM {aggregator_category} ORDER BY title');      while ($category = db_fetch_object($result)) {        $block['category-'. $category->cid]['info'] = t('!title category latest items', array('!title' => $category->title));      }      $result = db_query('SELECT fid, title FROM {aggregator_feed} ORDER BY fid');      while ($feed = db_fetch_object($result)) {        $block['feed-'. $feed->fid]['info'] = t('!title feed latest items', array('!title' => $feed->title));      }    }    else if ($op == 'configure') {      list($type, $id) = explode('-', $delta);      if ($type == 'category') {        $value = db_result(db_query('SELECT block FROM {aggregator_category} WHERE cid = %d', $id));      }      else {        $value = db_result(db_query('SELECT block FROM {aggregator_feed} WHERE fid = %d', $id));      }      $form['block'] = array('#type' => 'select', '#title' => t('Number of news items in block'), '#default_value' => $value, '#options' => drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)));      return $form;    }    else if ($op == 'save') {      list($type, $id) = explode('-', $delta);      if ($type == 'category') {        $value = db_query('UPDATE {aggregator_category} SET block = %d WHERE cid = %d', $edit['block'], $id);      }      else {        $value = db_query('UPDATE {aggregator_feed} SET block = %d WHERE fid = %d', $edit['block'], $id);      }    }    else if ($op == 'view') {      list($type, $id) = explode('-', $delta);      switch ($type) {        case 'feed':          if ($feed = db_fetch_object(db_query('SELECT fid, title, block FROM {aggregator_feed} WHERE fid = %d', $id))) {            $block['subject'] = check_plain($feed->title);            $result = db_query_range('SELECT * FROM {aggregator_item} WHERE fid = %d ORDER BY timestamp DESC, iid DESC', $feed->fid, 0, $feed->block);            $read_more = theme('more_link', url('aggregator/sources/'. $feed->fid), t("View this feed's recent news."));          }          break;        case 'category':          if ($category = db_fetch_object(db_query('SELECT cid, title, block FROM {aggregator_category} WHERE cid = %d', $id))) {            $block['subject'] = check_plain($category->title);            $result = db_query_range('SELECT i.* FROM {aggregator_category_item} ci LEFT JOIN {aggregator_item} i ON ci.iid = i.iid WHERE ci.cid = %d ORDER BY i.timestamp DESC, i.iid DESC', $category->cid, 0, $category->block);            $read_more = theme('more_link', url('aggregator/categories/'. $category->cid), t("View this category's recent news."));          }          break;      }      $items = array();      while ($item = db_fetch_object($result)) {        $items[] = theme('aggregator_block_item', $item);      }      // Only display the block if there are items to show.      if (count($items) > 0) {        $block['content'] = theme('item_list', $items) . $read_more;      }    }    if (isset($block)) {      return $block;    }  }}/** * Add/edit/delete aggregator categories. * * @param $edit *   An associative array describing the category to be added/edited/deleted. */function aggregator_save_category($edit) {  $link_path = 'aggregator/categories/';  if (!empty($edit['cid'])) {    $link_path .= $edit['cid'];    if (!empty($edit['title'])) {      db_query("UPDATE {aggregator_category} SET title = '%s', description = '%s' WHERE cid = %d", $edit['title'], $edit['description'], $edit['cid']);      $op = 'update';    }    else {      db_query('DELETE FROM {aggregator_category} WHERE cid = %d', $edit['cid']);      // Make sure there is no active block for this category.      db_query("DELETE FROM {blocks} WHERE module = '%s' AND delta = '%s'", 'aggregator', 'category-' . $edit['cid']);      $edit['title'] = '';      $op = 'delete';    }  }  else if (!empty($edit['title'])) {    // A single unique id for bundles and feeds, to use in blocks    db_query("INSERT INTO {aggregator_category} (title, description, block) VALUES ('%s', '%s', 5)", $edit['title'], $edit['description']);    $link_path .= db_last_insert_id('aggregator_category', 'cid');    $op = 'insert';  }  if (isset($op)) {    menu_link_maintain('aggregator', $op, $link_path, $edit['title']);  }}/** * Add/edit/delete an aggregator feed. * * @param $edit *   An associative array describing the feed to be added/edited/deleted. */function aggregator_save_feed($edit) {  if (!empty($edit['fid'])) {    // An existing feed is being modified, delete the category listings.    db_query('DELETE FROM {aggregator_category_feed} WHERE fid = %d', $edit['fid']);  }  if (!empty($edit['fid']) && !empty($edit['title'])) {    db_query("UPDATE {aggregator_feed} SET title = '%s', url = '%s', refresh = %d WHERE fid = %d", $edit['title'], $edit['url'], $edit['refresh'], $edit['fid']);  }  else if (!empty($edit['fid'])) {    $items = array();    $result = db_query('SELECT iid FROM {aggregator_item} WHERE fid = %d', $edit['fid']);    while ($item = db_fetch_object($result)) {      $items[] = "iid = $item->iid";    }    if (!empty($items)) {      db_query('DELETE FROM {aggregator_category_item} WHERE '. implode(' OR ', $items));    }    db_query('DELETE FROM {aggregator_feed} WHERE fid = %d', $edit['fid']);    db_query('DELETE FROM {aggregator_item} WHERE fid = %d', $edit['fid']);    // Make sure there is no active block for this feed.    db_query("DELETE FROM {blocks} WHERE module = '%s' AND delta = '%s'", 'aggregator', 'feed-' . $edit['fid']);  }  else if (!empty($edit['title'])) {    db_query("INSERT INTO {aggregator_feed} (title, url, refresh, block, description, image) VALUES ('%s', '%s', %d, 5, '', '')", $edit['title'], $edit['url'], $edit['refresh']);    // A single unique id for bundles and feeds, to use in blocks.    $edit['fid'] = db_last_insert_id('aggregator_feed', 'fid');  }  if (!empty($edit['title'])) {    // The feed is being saved, save the categories as well.    if (!empty($edit['category'])) {      foreach ($edit['category'] as $cid => $value) {        if ($value) {          db_query('INSERT INTO {aggregator_category_feed} (fid, cid) VALUES (%d, %d)', $edit['fid'], $cid);        }      }    }  }}/** * Removes all items from a feed. * * @param $feed *   An associative array describing the feed to be cleared. */function aggregator_remove($feed) {  $result = db_query('SELECT iid FROM {aggregator_item} WHERE fid = %d', $feed['fid']);  while ($item = db_fetch_object($result)) {    $items[] = "iid = $item->iid";  }  if (!empty($items)) {    db_query('DELETE FROM {aggregator_category_item} WHERE '. implode(' OR ', $items));  }  db_query('DELETE FROM {aggregator_item} WHERE fid = %d', $feed['fid']);  db_query("UPDATE {aggregator_feed} SET checked = 0, etag = '', modified = 0 WHERE fid = %d", $feed['fid']);  drupal_set_message(t('The news items from %site have been removed.', array('%site' => $feed['title'])));}/** * Call-back function used by the XML parser. */function aggregator_element_start($parser, $name, $attributes) {  global $item, $element, $tag, $items, $channel;  switch ($name) {    case 'IMAGE':    case 'TEXTINPUT':    case 'CONTENT':    case 'SUMMARY':    case 'TAGLINE':    case 'SUBTITLE':    case 'LOGO':    case 'INFO':      $element = $name;      break;    case 'ID':      if ($element != 'ITEM') {        $element = $name;      }    case 'LINK':      if (!empty($attributes['REL']) && $attributes['REL'] == 'alternate') {        if ($element == 'ITEM') {          $items[$item]['LINK'] = $attributes['HREF'];        }        else {          $channel['LINK'] = $attributes['HREF'];        }      }      break;    case 'ITEM':      $element = $name;      $item += 1;      break;    case 'ENTRY':      $element = 'ITEM';      $item += 1;      break;  }  $tag = $name;}/** * Call-back function used by the XML parser. */function aggregator_element_end($parser, $name) {  global $element;  switch ($name) {    case 'IMAGE':    case 'TEXTINPUT':    case 'ITEM':    case 'ENTRY':    case 'CONTENT':    case 'INFO':      $element = '';      break;    case 'ID':      if ($element == 'ID') {        $element = '';      }  }}/** * Call-back function used by the XML parser. */function aggregator_element_data($parser, $data) {  global $channel, $element, $items, $item, $image, $tag;  $items += array($item => array());  switch ($element) {    case 'ITEM':      $items[$item] += array($tag => '');      $items[$item][$tag] .= $data;      break;    case 'IMAGE':    case 'LOGO':      $image += array($tag => '');      $image[$tag] .= $data;      break;    case 'LINK':      if ($data) {        $items[$item] += array($tag => '');        $items[$item][$tag] .= $data;      }      break;    case 'CONTENT':      $items[$item] += array('CONTENT' => '');      $items[$item]['CONTENT'] .= $data;      break;    case 'SUMMARY':      $items[$item] += array('SUMMARY' => '');      $items[$item]['SUMMARY'] .= $data;      break;    case 'TAGLINE':    case 'SUBTITLE':      $channel += array('DESCRIPTION' => '');      $channel['DESCRIPTION'] .= $data;      break;    case 'INFO':    case 'ID':    case 'TEXTINPUT':      // The sub-element is not supported. However, we must recognize      // it or its contents will end up in the item array.      break;    default:      $channel += array($tag => '');      $channel[$tag] .= $data;  }}/** * Checks a news feed for new items. * * @param $feed *   An associative array describing the feed to be refreshed. */function aggregator_refresh($feed) {  global $channel, $image;  // Generate conditional GET headers.  $headers = array();  if ($feed['etag']) {    $headers['If-None-Match'] = $feed['etag'];  }  if ($feed['modified']) {    $headers['If-Modified-Since'] = gmdate('D, d M Y H:i:s', $feed['modified']) .' GMT';  }  // Request feed.  $result = drupal_http_request($feed['url'], $headers);  // Process HTTP response code.  switch ($result->code) {    case 304:      db_query('UPDATE {aggregator_feed} SET checked = %d WHERE fid = %d', time(), $feed['fid']);      drupal_set_message(t('There is no new syndicated content from %site.', array('%site' => $feed['title'])));      break;    case 301:      $feed['url'] = $result->redirect_url;      watchdog('aggregator', 'Updated URL for feed %title to %url.', array('%title' => $feed['title'], '%url' => $feed['url']));      // Deliberate no break.    case 200:    case 302:    case 307:      // Filter the input data:      if (aggregator_parse_feed($result->data, $feed)) {        $modified = empty($result->headers['Last-Modified']) ? 0 : strtotime($result->headers['Last-Modified']);        // Prepare the channel data.        foreach ($channel as $key => $value) {          $channel[$key] = trim($value);        }        // Prepare the image data (if any).        foreach ($image as $key => $value) {          $image[$key] = trim($value);        }        if (!empty($image['LINK']) && !empty($image['URL']) && !empty($image['TITLE'])) {          // Note, we should really use theme_image() here but that only works with local images it won't work with images fetched with a URL unless PHP version > 5          $image = '<a href="'. check_url($image['LINK']) .'" class="feed-image"><img src="'. check_url($image['URL']) .'" alt="'. check_plain($image['TITLE']) .'" /></a>';        }        else {          $image = NULL;        }        $etag = empty($result->headers['ETag']) ? '' : $result->headers['ETag'];        // Update the feed data.        db_query("UPDATE {aggregator_feed} SET url = '%s', checked = %d, link = '%s', description = '%s', image = '%s', etag = '%s', modified = %d WHERE fid = %d", $feed['url'], time(), $channel['LINK'], $channel['DESCRIPTION'], $image, $etag, $modified, $feed['fid']);        // Clear the cache.        cache_clear_all();        watchdog('aggregator', 'There is new syndicated content from %site.', array('%site' => $feed['title']));        drupal_set_message(t('There is new syndicated content from %site.', array('%site' => $feed['title'])));        break;      }      $result->error = t('feed not parseable');      // Deliberate no break.    default:      watchdog('aggregator', 'The feed from %site seems to be broken, due to "%error".', array('%site' => $feed['title'], '%error' => $result->code .' '. $result->error), WATCHDOG_WARNING);      drupal_set_message(t('The feed from %site seems to be broken, because of error "%error".', array('%site' => $feed['title'], '%error' => $result->code .' '. $result->error)));  }}/** * Parse the W3C date/time format, a subset of ISO 8601. PHP date parsing * functions do not handle this format. * See http://www.w3.org/TR/NOTE-datetime for more information. * Originally from MagpieRSS (http://magpierss.sourceforge.net/). * * @param $date_str *   A string with a potentially W3C DTF date. * @return *   A timestamp if parsed successfully or FALSE if not. */function aggregator_parse_w3cdtf($date_str) {  if (preg_match('/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(:(\d{2}))?(?:([-+])(\d{2}):?(\d{2})|(Z))?/', $date_str, $match)) {    list($year, $month, $day, $hours, $minutes, $seconds) = array($match[1], $match[2], $match[3], $match[4], $match[5], $match[6]);    // calc epoch for current date assuming GMT    $epoch = gmmktime($hours, $minutes, $seconds, $month, $day, $year);    if ($match[10] != 'Z') { // Z is zulu time, aka GMT      list($tz_mod, $tz_hour, $tz_min) = array($match[8], $match[9], $match[10]);      // zero out the variables      if (!$tz_hour) {        $tz_hour = 0;      }      if (!$tz_min) {        $tz_min = 0;      }      $offset_secs = (($tz_hour * 60) + $tz_min) * 60;      // is timezone ahead of GMT?  then subtract offset      if ($tz_mod == '+') {        $offset_secs *= -1;      }      $epoch += $offset_secs;    }    return $epoch;  }  else {    return FALSE;  }}/** * Parse a feed and store its items. * * @param $data *   The feed data. * @param $feed *   An associative array describing the feed to be parsed. * @return *   0 on error, 1 otherwise. */function aggregator_parse_feed(&$data, $feed) {  global $items, $image, $channel;  // Unset the global variables before we use them:  unset($GLOBALS['element'], $GLOBALS['item'], $GLOBALS['tag']);  $items = array();  $image = array();  $channel = array();  // parse the data:  $xml_parser = drupal_xml_parser_create($data);  xml_set_element_handler($xml_parser, 'aggregator_element_start', 'aggregator_element_end');  xml_set_character_data_handler($xml_parser, 'aggregator_element_data');  if (!xml_parse($xml_parser, $data, 1)) {    watchdog('aggregator', 'The feed from %site seems to be broken, due to an error "%error" on line %line.', array('%site' => $feed['title'], '%error' => xml_error_string(xml_get_error_code($xml_parser)), '%line' => xml_get_current_line_number($xml_parser)), WATCHDOG_WARNING);    drupal_set_message(t('The feed from %site seems to be broken, because of error "%error" on line %line.', array('%site' => $feed['title'], '%error' => xml_error_string(xml_get_error_code($xml_parser)), '%line' => xml_get_current_line_number($xml_parser))), 'error');    return 0;  }  xml_parser_free($xml_parser);  // We reverse the array such that we store the first item last, and the last  // item first. In the database, the newest item should be at the top.  $items = array_reverse($items);  // Initialize variables.  $title = $link = $author = $description = $guid = NULL;  foreach ($items as $item) {    unset($title, $link, $author, $description, $guid);    // Prepare the item:    foreach ($item as $key => $value) {      $item[$key] = trim($value);    }    // Resolve the item's title. If no title is found, we use up to 40    // characters of the description ending at a word boundary but not    // splitting potential entities.    if (!empty($item['TITLE'])) {      $title = $item['TITLE'];    }    elseif (!empty($item['DESCRIPTION'])) {      $title = preg_replace('/^(.*)[^\w;&].*?$/', "\\1", truncate_utf8($item['DESCRIPTION'], 40));    }    else {      $title = '';    }    // Resolve the items link.    if (!empty($item['LINK'])) {      $link = $item['LINK'];    }    else {      $link = $feed['link'];    }    $guid = isset($item['GUID']) ? $item['GUID'] : '';    // Atom feeds have a CONTENT and/or SUMMARY tag instead of a DESCRIPTION tag.    if (!empty($item['CONTENT:ENCODED'])) {      $item['DESCRIPTION'] = $item['CONTENT:ENCODED'];    }    else if (!empty($item['SUMMARY'])) {      $item['DESCRIPTION'] = $item['SUMMARY'];    }    else if (!empty($item['CONTENT'])) {      $item['DESCRIPTION'] = $item['CONTENT'];    }    // Try to resolve and parse the item's publication date. If no date is    // found, we use the current date instead.    $date = 'now';    foreach (array('PUBDATE', 'DC:DATE', 'DCTERMS:ISSUED', 'DCTERMS:CREATED', 'DCTERMS:MODIFIED', 'ISSUED', 'CREATED', 'MODIFIED', 'PUBLISHED', 'UPDATED') as $key) {      if (!empty($item[$key])) {        $date = $item[$key];        break;      }    }    $timestamp = strtotime($date); // As of PHP 5.1.0, strtotime returns FALSE on failure instead of -1.    if ($timestamp <= 0) {      $timestamp = aggregator_parse_w3cdtf($date); // Returns FALSE on failure      if (!$timestamp) {        $timestamp = time(); // better than nothing      }    }    // Save this item. Try to avoid duplicate entries as much as possible. If    // we find a duplicate entry, we resolve it and pass along its ID is such    // that we can update it if needed.    if (!empty($guid)) {      $entry = db_fetch_object(db_query("SELECT iid FROM {aggregator_item} WHERE fid = %d AND guid = '%s'", $feed['fid'], $guid));    }    else if ($link && $link != $feed['link'] && $link != $feed['url']) {      $entry = db_fetch_object(db_query("SELECT iid FROM {aggregator_item} WHERE fid = %d AND link = '%s'", $feed['fid'], $link));    }    else {      $entry = db_fetch_object(db_query("SELECT iid FROM {aggregator_item} WHERE fid = %d AND title = '%s'", $feed['fid'], $title));    }    $item += array('AUTHOR' => '', 'DESCRIPTION' => '');    aggregator_save_item(array('iid' => (isset($entry->iid) ? $entry->iid:  ''), 'fid' => $feed['fid'], 'timestamp' => $timestamp, 'title' => $title, 'link' => $link, 'author' => $item['AUTHOR'], 'description' => $item['DESCRIPTION'], 'guid' => $guid));  }  // Remove all items that are older than flush item timer.  $age = time() - variable_get('aggregator_clear', 9676800);  $result = db_query('SELECT iid FROM {aggregator_item} WHERE fid = %d AND timestamp < %d', $feed['fid'], $age);  $items = array();  $num_rows = FALSE;  while ($item = db_fetch_object($result)) {    $items[] = $item->iid;    $num_rows = TRUE;  }  if ($num_rows) {    db_query('DELETE FROM {aggregator_category_item} WHERE iid IN ('. implode(', ', $items) .')');    db_query('DELETE FROM {aggregator_item} WHERE fid = %d AND timestamp < %d', $feed['fid'], $age);  }  return 1;}/** * Add/edit/delete an aggregator item. * * @param $edit *   An associative array describing the item to be added/edited/deleted. */function aggregator_save_item($edit) {  if ($edit['iid'] && $edit['title']) {    db_query("UPDATE {aggregator_item} SET title = '%s', link = '%s', author = '%s', description = '%s', guid = '%s', timestamp = %d WHERE iid = %d", $edit['title'], $edit['link'], $edit['author'], $edit['description'], $edit['guid'], $edit['timestamp'], $edit['iid']);  }  else if ($edit['iid']) {    db_query('DELETE FROM {aggregator_item} WHERE iid = %d', $edit['iid']);    db_query('DELETE FROM {aggregator_category_item} WHERE iid = %d', $edit['iid']);  }  else if ($edit['title'] && $edit['link']) {    db_query("INSERT INTO {aggregator_item} (fid, title, link, author, description, timestamp, guid) VALUES (%d, '%s', '%s', '%s', '%s', %d, '%s')", $edit['fid'], $edit['title'], $edit['link'], $edit['author'], $edit['description'], $edit['timestamp'], $edit['guid']);    $edit['iid'] = db_last_insert_id('aggregator_item', 'iid');    // file the items in the categories indicated by the feed    $categories = db_query('SELECT cid FROM {aggregator_category_feed} WHERE fid = %d', $edit['fid']);    while ($category = db_fetch_object($categories)) {      db_query('INSERT INTO {aggregator_category_item} (cid, iid) VALUES (%d, %d)', $category->cid, $edit['iid']);    }  }}/** * Load an aggregator feed. * * @param $fid *   The feed id. * @return *   An associative array describing the feed. */function aggregator_feed_load($fid) {  static $feeds;  if (!isset($feeds[$fid])) {    $feeds[$fid] = db_fetch_array(db_query('SELECT * FROM {aggregator_feed} WHERE fid = %d', $fid));  }  return $feeds[$fid];}/** * Load an aggregator category. * * @param $cid *   The category id. * @return *   An associative array describing the category. */function aggregator_category_load($cid) {  static $categories;  if (!isset($categories[$cid])) {    $categories[$cid] = db_fetch_array(db_query('SELECT * FROM {aggregator_category} WHERE cid = %d', $cid));  }  return $categories[$cid];}/** * Format an individual feed item for display in the block. * * @param $item *   The item to be displayed. * @param $feed *   Not used. * @return *   The item HTML. * @ingroup themeable */function theme_aggregator_block_item($item, $feed = 0) {  global $user;  $output = '';  if ($user->uid && module_exists('blog') && user_access('create blog entries')) {    if ($image = theme('image', 'misc/blog.png', t('blog it'), t('blog it'))) {      $output .= '<div class="icon">'. l($image, 'node/add/blog', array('attributes' => array('title' => t('Comment on this news item in your personal blog.'), 'class' => 'blog-it'), 'query' => "iid=$item->iid", 'html' => TRUE)) .'</div>';    }  }  // Display the external link to the item.  $output .= '<a href="'. check_url($item->link) .'">'. check_plain($item->title) ."</a>\n";  return $output;}/** * Safely render HTML content, as allowed. * * @param $value *   The content to be filtered. * @return *   The filtered content. */function aggregator_filter_xss($value) {  return filter_xss($value, preg_split('/\s+|<|>/', variable_get('aggregator_allowed_html_tags', '<a> <b> <br> <dd> <dl> <dt> <em> <i> <li> <ol> <p> <strong> <u> <ul>'), -1, PREG_SPLIT_NO_EMPTY));}/** * Helper function for drupal_map_assoc. * * @param $count *   Items count. * @return *   Plural-formatted "@count items" */function _aggregator_items($count) {  return format_plural($count, '1 item', '@count items');}
<?php// $Id$require_once './includes/install.inc';define('MAINTENANCE_MODE', 'install');/** * The Drupal installation happens in a series of steps. We begin by verifying * that the current environment meets our minimum requirements. We then go * on to verify that settings.php is properly configured. From there we * connect to the configured database and verify that it meets our minimum * requirements. Finally we can allow the user to select an installation * profile and complete the installation process. * * @param $phase *   The installation phase we should proceed to. */function install_main() {  require_once './includes/bootstrap.inc';  drupal_bootstrap(DRUPAL_BOOTSTRAP_CONFIGURATION);  // This must go after drupal_bootstrap(), which unsets globals!  global $profile, $install_locale, $conf;  require_once './modules/system/system.install';  require_once './includes/file.inc';  // Ensure correct page headers are sent (e.g. caching)  drupal_page_header();  // Set up $language, so t() caller functions will still work.  drupal_init_language();  // Load module basics (needed for hook invokes).  include_once './includes/module.inc';  $module_list['system']['filename'] = 'modules/system/system.module';  $module_list['filter']['filename'] = 'modules/filter/filter.module';  module_list(TRUE, FALSE, FALSE, $module_list);  drupal_load('module', 'system');  drupal_load('module', 'filter');  // Install profile chosen, set the global immediately.  // This needs to be done before the theme cache gets   // initialized in drupal_maintenance_theme().  if (!empty($_GET['profile'])) {    $profile = preg_replace('/[^a-zA-Z_0-9]/', '', $_GET['profile']);  }  // Set up theme system for the maintenance page.  drupal_maintenance_theme();  // Check existing settings.php.  $verify = install_verify_settings();  if ($verify) {    // Since we have a database connection, we use the normal cache system.    // This is important, as the installer calls into the Drupal system for    // the clean URL checks, so we should maintain the cache properly.    require_once './includes/cache.inc';    $conf['cache_inc'] = './includes/cache.inc';    // Establish a connection to the database.    require_once './includes/database.inc';    db_set_active();    // Check if Drupal is installed.    $task = install_verify_drupal();    if ($task == 'done') {      install_already_done_error();    }  }  else {    // Since no persistent storage is available yet, and functions that check    // for cached data will fail, we temporarily replace the normal cache    // system with a stubbed-out version that short-circuits the actual    // caching process and avoids any errors.    require_once './includes/cache-install.inc';    $conf['cache_inc'] = './includes/cache-install.inc';    $task = NULL;  }  // No profile was passed in GET, ask the user.  if (empty($_GET['profile'])) {    if ($profile = install_select_profile()) {      install_goto("install.php?profile=$profile");    }    else {      install_no_profile_error();    }  }  // Load the profile.  require_once "./profiles/$profile/$profile.profile";  // Locale selection  if (!empty($_GET['locale'])) {    $install_locale = preg_replace('/[^a-zA-Z_0-9\-]/', '', $_GET['locale']);  }  elseif (($install_locale = install_select_locale($profile)) !== FALSE) {    install_goto("install.php?profile=$profile&locale=$install_locale");  }  // Tasks come after the database is set up  if (!$task) {    global $db_url;    if (!$verify && !empty($db_url)) {      // Do not install over a configured settings.php.      install_already_done_error();    }    // Check the installation requirements for Drupal and this profile.    install_check_requirements($profile, $verify);    // Verify existence of all required modules.    $modules = drupal_verify_profile($profile, $install_locale);    // If any error messages are set now, it means a requirement problem.    $messages = drupal_set_message();    if (!empty($messages['error'])) {      install_task_list('requirements');      drupal_set_title(st('Requirements problem'));      print theme('install_page', '');      exit;    }    // Change the settings.php information if verification failed earlier.    // Note: will trigger a redirect if database credentials change.    if (!$verify) {      install_change_settings($profile, $install_locale);    }    // Install system.module.    drupal_install_system();    // Save the list of other modules to install for the 'profile-install'    // task. variable_set() can be used now that system.module is installed    // and drupal is bootstrapped.    variable_set('install_profile_modules', array_diff($modules, array('system')));  }  // The database is set up, turn to further tasks.  install_tasks($profile, $task);}/** * Verify if Drupal is installed. */function install_verify_drupal() {  // Read the variable manually using the @ so we don't trigger an error if it fails.  $result = @db_query("SELECT value FROM {variable} WHERE name = '%s'", 'install_task');  if ($result) {    return unserialize(db_result($result));  }}/** * Verify existing settings.php */function install_verify_settings() {  global $db_prefix, $db_type, $db_url;  // Verify existing settings (if any).  if (!empty($db_url)) {    // We need this because we want to run form_get_errors.    include_once './includes/form.inc';    $url = parse_url(is_array($db_url) ? $db_url['default'] : $db_url);    $db_user = urldecode($url['user']);    $db_pass = isset($url['pass']) ? urldecode($url['pass']) : NULL;    $db_host = urldecode($url['host']);    $db_port = isset($url['port']) ? urldecode($url['port']) : '';    $db_path = ltrim(urldecode($url['path']), '/');    $settings_file = './'. conf_path(FALSE, TRUE) .'/settings.php';    $form_state = array();    _install_settings_form_validate($db_prefix, $db_type, $db_user, $db_pass, $db_host, $db_port, $db_path, $settings_file, $form_state);    if (!form_get_errors()) {      return TRUE;    }  }  return FALSE;}/** * Configure and rewrite settings.php. */function install_change_settings($profile = 'default', $install_locale = '') {  global $db_url, $db_type, $db_prefix;  $url = parse_url(is_array($db_url) ? $db_url['default'] : $db_url);  $db_user = isset($url['user']) ? urldecode($url['user']) : '';  $db_pass = isset($url['pass']) ? urldecode($url['pass']) : '';  $db_host = isset($url['host']) ? urldecode($url['host']) : '';  $db_port = isset($url['port']) ? urldecode($url['port']) : '';  $db_path = ltrim(urldecode($url['path']), '/');  $conf_path = './'. conf_path(FALSE, TRUE);  $settings_file = $conf_path .'/settings.php';  // We always need this because we want to run form_get_errors.  include_once './includes/form.inc';  install_task_list('database');  $output = drupal_get_form('install_settings_form', $profile, $install_locale, $settings_file, $db_url, $db_type, $db_prefix, $db_user, $db_pass, $db_host, $db_port, $db_path);  drupal_set_title(st('Database configuration'));  print theme('install_page', $output);  exit;}/** * Form API array definition for install_settings. */function install_settings_form(&$form_state, $profile, $install_locale, $settings_file, $db_url, $db_type, $db_prefix, $db_user, $db_pass, $db_host, $db_port, $db_path) {  if (empty($db_host)) {    $db_host = 'localhost';  }  $db_types = drupal_detect_database_types();  // If both 'mysql' and 'mysqli' are available, we disable 'mysql':  if (isset($db_types['mysqli'])) {    unset($db_types['mysql']);  }  if (count($db_types) == 0) {    $form['no_db_types'] = array(      '#value' => st('Your web server does not appear to support any common database types. Check with your hosting provider to see if they offer any databases that <a href="@drupal-databases">Drupal supports</a>.', array('@drupal-databases' => 'http://drupal.org/node/270#database')),    );  }  else {    $form['basic_options'] = array(      '#type' => 'fieldset',      '#title' => st('Basic options'),      '#description' => '<p>'. st('To set up your @drupal database, enter the following information.', array('@drupal' => drupal_install_profile_name())) .'</p>',    );    if (count($db_types) > 1) {      $form['basic_options']['db_type'] = array(        '#type' => 'radios',        '#title' => st('Database type'),        '#required' => TRUE,        '#options' => $db_types,        '#default_value' => ($db_type ? $db_type : current($db_types)),        '#description' => st('The type of database your @drupal data will be stored in.', array('@drupal' => drupal_install_profile_name())),      );      $db_path_description = st('The name of the database your @drupal data will be stored in. It must exist on your server before @drupal can be installed.', array('@drupal' => drupal_install_profile_name()));    }    else {      if (count($db_types) == 1) {        $db_types = array_values($db_types);        $form['basic_options']['db_type'] = array(          '#type' => 'hidden',          '#value' => $db_types[0],        );        $db_path_description = st('The name of the %db_type database your @drupal data will be stored in. It must exist on your server before @drupal can be installed.', array('%db_type' => $db_types[0], '@drupal' => drupal_install_profile_name()));      }    }    // Database name    $form['basic_options']['db_path'] = array(      '#type' => 'textfield',      '#title' => st('Database name'),      '#default_value' => $db_path,      '#size' => 45,      '#required' => TRUE,      '#description' => $db_path_description    );    // Database username    $form['basic_options']['db_user'] = array(      '#type' => 'textfield',      '#title' => st('Database username'),      '#default_value' => $db_user,      '#size' => 45,      '#required' => TRUE,    );    // Database username    $form['basic_options']['db_pass'] = array(      '#type' => 'password',      '#title' => st('Database password'),      '#default_value' => $db_pass,      '#size' => 45,    );    $form['advanced_options'] = array(      '#type' => 'fieldset',      '#title' => st('Advanced options'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#description' => st("These options are only necessary for some sites. If you're not sure what you should enter here, leave the default settings or check with your hosting provider.")    );    // Database host    $form['advanced_options']['db_host'] = array(      '#type' => 'textfield',      '#title' => st('Database host'),      '#default_value' => $db_host,      '#size' => 45,      // Hostnames can be 255 characters long.      '#maxlength' => 255,      '#required' => TRUE,      '#description' => st('If your database is located on a different server, change this.'),    );    // Database port    $form['advanced_options']['db_port'] = array(      '#type' => 'textfield',      '#title' => st('Database port'),      '#default_value' => $db_port,      '#size' => 45,      // The maximum port number is 65536, 5 digits.      '#maxlength' => 5,      '#description' => st('If your database server is listening to a non-standard port, enter its number.'),    );    // Table prefix    $prefix = ($profile == 'default') ? 'drupal_' : $profile .'_';    $form['advanced_options']['db_prefix'] = array(      '#type' => 'textfield',      '#title' => st('Table prefix'),      '#default_value' => $db_prefix,      '#size' => 45,      '#description' => st('If more than one application will be sharing this database, enter a table prefix such as %prefix for your @drupal site here.', array('@drupal' => drupal_install_profile_name(), '%prefix' => $prefix)),    );    $form['save'] = array(      '#type' => 'submit',      '#value' => st('Save and continue'),    );    $form['errors'] = array();    $form['settings_file'] = array('#type' => 'value', '#value' => $settings_file);    $form['_db_url'] = array('#type' => 'value');    $form['#action'] = "install.php?profile=$profile". ($install_locale ? "&locale=$install_locale" : '');    $form['#redirect'] = FALSE;  }  return $form;}/** * Form API validate for install_settings form. */function install_settings_form_validate($form, &$form_state) {  global $db_url;  _install_settings_form_validate($form_state['values']['db_prefix'], $form_state['values']['db_type'], $form_state['values']['db_user'], $form_state['values']['db_pass'], $form_state['values']['db_host'], $form_state['values']['db_port'], $form_state['values']['db_path'], $form_state['values']['settings_file'], $form_state, $form);}/** * Helper function for install_settings_validate. */function _install_settings_form_validate($db_prefix, $db_type, $db_user, $db_pass, $db_host, $db_port, $db_path, $settings_file, &$form_state, $form = NULL) {  global $db_url;  // Verify the table prefix  if (!empty($db_prefix) && is_string($db_prefix) && !preg_match('/^[A-Za-z0-9_.]+$/', $db_prefix)) {    form_set_error('db_prefix', st('The database table prefix you have entered, %db_prefix, is invalid. The table prefix can only contain alphanumeric characters, periods, or underscores.', array('%db_prefix' => $db_prefix)), 'error');  }  if (!empty($db_port) && !is_numeric($db_port)) {    form_set_error('db_port', st('Database port must be a number.'));  }  // Check database type  if (!isset($form)) {    $_db_url = is_array($db_url) ? $db_url['default'] : $db_url;    $db_type = substr($_db_url, 0, strpos($_db_url, '://'));  }  $databases = drupal_detect_database_types();  if (!in_array($db_type, $databases)) {    form_set_error('db_type', st("In your %settings_file file you have configured @drupal to use a %db_type server, however your PHP installation currently does not support this database type.", array('%settings_file' => $settings_file, '@drupal' => drupal_install_profile_name(), '%db_type' => $db_type)));  }  else {    // Verify    $db_url = $db_type .'://'. urlencode($db_user) . ($db_pass ? ':'. urlencode($db_pass) : '') .'@'. ($db_host ? urlencode($db_host) : 'localhost') . ($db_port ? ":$db_port" : '') .'/'. urlencode($db_path);    if (isset($form)) {      form_set_value($form['_db_url'], $db_url, $form_state);    }    $success = array();    $function = 'drupal_test_'. $db_type;    if (!$function($db_url, $success)) {      if (isset($success['CONNECT'])) {        form_set_error('db_type', st('In order for Drupal to work, and to continue with the installation process, you must resolve all permission issues reported above. We were able to verify that we have permission for the following commands: %commands. For more help with configuring your database server, see the <a href="http://drupal.org/node/258">Installation and upgrading handbook</a>. If you are unsure what any of this means you should probably contact your hosting provider.', array('%commands' => implode($success, ', '))));      }      else {        form_set_error('db_type', '');      }    }  }}/** * Form API submit for install_settings form. */function install_settings_form_submit($form, &$form_state) {  global $profile, $install_locale;  // Update global settings array and save  $settings['db_url'] = array(    'value'    => $form_state['values']['_db_url'],    'required' => TRUE,  );  $settings['db_prefix'] = array(    'value'    => $form_state['values']['db_prefix'],    'required' => TRUE,  );  drupal_rewrite_settings($settings);  // Continue to install profile step  install_goto("install.php?profile=$profile". ($install_locale ? "&locale=$install_locale" : ''));}/** * Find all .profile files. */function install_find_profiles() {  return file_scan_directory('./profiles', '\.profile$', array('.', '..', 'CVS'), 0, TRUE, 'name', 0);}/** * Allow admin to select which profile to install. * * @return *   The selected profile. */function install_select_profile() {  include_once './includes/form.inc';  $profiles = install_find_profiles();  // Don't need to choose profile if only one available.  if (sizeof($profiles) == 1) {    $profile = array_pop($profiles);    require_once $profile->filename;    return $profile->name;  }  elseif (sizeof($profiles) > 1) {    foreach ($profiles as $profile) {      if (!empty($_POST['profile']) && ($_POST['profile'] == $profile->name)) {        return $profile->name;      }    }    install_task_list('profile-select');    drupal_set_title(st('Select an installation profile'));    print theme('install_page', drupal_get_form('install_select_profile_form', $profiles));    exit;  }}/** * Form API array definition for the profile selection form. * * @param $form_state *   Array of metadata about state of form processing. * @param $profile_files *   Array of .profile files, as returned from file_scan_directory(). */function install_select_profile_form(&$form_state, $profile_files) {  $profiles = array();  $names = array();  foreach ($profile_files as $profile) {    include_once($profile->filename);    // Load profile details and store them for later retrieval.    $function = $profile->name .'_profile_details';    if (function_exists($function)) {      $details = $function();    }    $profiles[$profile->name] = $details;    // Determine the name of the profile; default to file name if defined name    // is unspecified.    $name = isset($details['name']) ? $details['name'] : $profile->name;    $names[$profile->name] = $name;  }  // Display radio buttons alphabetically by human-readable name.   natcasesort($names);  foreach ($names as $profile => $name) {    $form['profile'][$name] = array(      '#type' => 'radio',      '#value' => 'default',      '#return_value' => $profile,      '#title' => $name,      '#description' => isset($profiles[$profile]['description']) ? $profiles[$profile]['description'] : '',      '#parents' => array('profile'),    );  }  $form['submit'] =  array(    '#type' => 'submit',    '#value' => st('Save and continue'),  );  return $form;}/** * Find all .po files for the current profile. */function install_find_locales($profilename) {  $locales = file_scan_directory('./profiles/'. $profilename .'/translations', '\.po$', array('.', '..', 'CVS'), 0, FALSE);  array_unshift($locales, (object) array('name' => 'en'));  return $locales;}/** * Allow admin to select which locale to use for the current profile. * * @return *   The selected language. */function install_select_locale($profilename) {  include_once './includes/file.inc';  include_once './includes/form.inc';  // Find all available locales.  $locales = install_find_locales($profilename);  // If only the built-in (English) language is available,  // and we are using the default profile, inform the user  // that the installer can be localized. Otherwise we assume  // the user know what he is doing.  if (count($locales) == 1) {    if ($profilename == 'default') {      install_task_list('locale-select');      drupal_set_title(st('Choose language'));      if (!empty($_GET['localize'])) {        $output = '<p>'. st('With the addition of an appropriate translation package, this installer is capable of proceeding in another language of your choice. To install and use Drupal in a language other than English:') .'</p>';        $output .= '<ul><li>'. st('Determine if <a href="@translations" target="_blank">a translation of this Drupal version</a> is available in your language of choice. A translation is provided via a translation package; each translation package enables the display of a specific version of Drupal in a specific language. Not all languages are available for every version of Drupal.', array('@translations' => 'http://drupal.org/project/translations')) .'</li>';        $output .= '<li>'. st('If an alternative translation package of your choice is available, download and extract its contents to your Drupal root directory.') .'</li>';        $output .= '<li>'. st('Return to choose language using the second link below and select your desired language from the displayed list. Reloading the page allows the list to automatically adjust to the presence of new translation packages.') .'</li>';        $output .= '</ul><p>'. st('Alternatively, to install and use Drupal in English, or to defer the selection of an alternative language until after installation, select the first link below.') .'</p>';        $output .= '<p>'. st('How should the installation continue?') .'</p>';        $output .= '<ul><li><a href="install.php?profile='. $profilename .'&amp;locale=en">'. st('Continue installation in English') .'</a></li><li><a href="install.php?profile='. $profilename .'">'. st('Return to choose a language') .'</a></li></ul>';      }      else {        $output = '<ul><li><a href="install.php?profile='. $profilename .'&amp;locale=en">'. st('Install Drupal in English') .'</a></li><li><a href="install.php?profile='. $profilename .'&amp;localize=true">'. st('Learn how to install Drupal in other languages') .'</a></li></ul>';      }      print theme('install_page', $output);      exit;    }    // One language, but not the default profile, assume    // the user knows what he is doing.    return FALSE;  }  else {    // Allow profile to pre-select the language, skipping the selection.    $function = $profilename .'_profile_details';    if (function_exists($function)) {      $details = $function();      if (isset($details['language'])) {        foreach ($locales as $locale) {          if ($details['language'] == $locale->name) {            return $locale->name;          }        }      }    }    if (!empty($_POST['locale'])) {      foreach ($locales as $locale) {        if ($_POST['locale'] == $locale->name) {          return $locale->name;        }      }    }    install_task_list('locale-select');    drupal_set_title(st('Choose language'));    print theme('install_page', drupal_get_form('install_select_locale_form', $locales));    exit;  }}/** * Form API array definition for language selection. */function install_select_locale_form(&$form_state, $locales) {  include_once './includes/locale.inc';  $languages = _locale_get_predefined_list();  foreach ($locales as $locale) {    // Try to use verbose locale name    $name = $locale->name;    if (isset($languages[$name])) {      $name = $languages[$name][0] . (isset($languages[$name][1]) ? ' '. st('(@language)', array('@language' => $languages[$name][1])) : '');    }    $form['locale'][$locale->name] = array(      '#type' => 'radio',      '#return_value' => $locale->name,      '#default_value' => ($locale->name == 'en' ? TRUE : FALSE),      '#title' => $name . ($locale->name == 'en' ? ' '. st('(built-in)') : ''),      '#parents' => array('locale')    );  }  $form['submit'] =  array(    '#type' => 'submit',    '#value' => st('Select language'),  );  return $form;}/** * Show an error page when there are no profiles available. */function install_no_profile_error() {  install_task_list('profile-select');  drupal_set_title(st('No profiles available'));  print theme('install_page', '<p>'. st('We were unable to find any installer profiles. Installer profiles tell us what modules to enable and what schema to install in the database. A profile is necessary to continue with the installation process.') .'</p>');  exit;}/** * Show an error page when Drupal has already been installed. */function install_already_done_error() {  global $base_url;  drupal_set_title(st('Drupal already installed'));  print theme('install_page', st('<ul><li>To start over, you must empty your existing database.</li><li>To install to a different database, edit the appropriate <em>settings.php</em> file in the <em>sites</em> folder.</li><li>To upgrade an existing installation, proceed to the <a href="@base-url/update.php">update script</a>.</li><li>View your <a href="@base-url">existing site</a>.</li></ul>', array('@base-url' => $base_url)));  exit;}/** * Tasks performed after the database is initialized. */function install_tasks($profile, $task) {  global $base_url, $install_locale;  // Bootstrap newly installed Drupal, while preserving existing messages.  $messages = isset($_SESSION['messages']) ? $_SESSION['messages'] : '';  drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);  $_SESSION['messages'] = $messages;  // URL used to direct page requests.  $url = $base_url .'/install.php?locale='. $install_locale .'&profile='. $profile;  // Build a page for final tasks.  if (empty($task)) {    variable_set('install_task', 'profile-install');    $task = 'profile-install';  }  // We are using a list of if constructs here to allow for  // passing from one task to the other in the same request.  // Install profile modules.  if ($task == 'profile-install') {    $modules = variable_get('install_profile_modules', array());    $files = module_rebuild_cache();    variable_del('install_profile_modules');    $operations = array();    foreach ($modules as $module) {      $operations[] = array('_install_module_batch', array($module, $files[$module]->info['name']));    }    $batch = array(      'operations' => $operations,      'finished' => '_install_profile_batch_finished',      'title' => st('Installing @drupal', array('@drupal' => drupal_install_profile_name())),      'error_message' => st('The installation has encountered an error.'),    );    // Start a batch, switch to 'profile-install-batch' task. We need to    // set the variable here, because batch_process() redirects.    variable_set('install_task', 'profile-install-batch');    batch_set($batch);    batch_process($url, $url);  }  // We are running a batch install of the profile's modules.  // This might run in multiple HTTP requests, constantly redirecting  // to the same address, until the batch finished callback is invoked  // and the task advances to 'locale-initial-import'.  if ($task == 'profile-install-batch') {    include_once 'includes/batch.inc';    $output = _batch_page();  }  // Import interface translations for the enabled modules.  if ($task == 'locale-initial-import') {    if (!empty($install_locale) && ($install_locale != 'en')) {      include_once 'includes/locale.inc';      // Enable installation language as default site language.      locale_add_language($install_locale, NULL, NULL, NULL, NULL, NULL, 1, TRUE);      // Collect files to import for this language.      $batch = locale_batch_by_language($install_locale, '_install_locale_initial_batch_finished');      if (!empty($batch)) {        // Remember components we cover in this batch set.        variable_set('install_locale_batch_components', $batch['#components']);        // Start a batch, switch to 'locale-batch' task. We need to        // set the variable here, because batch_process() redirects.        variable_set('install_task', 'locale-initial-batch');        batch_set($batch);        batch_process($url, $url);      }    }    // Found nothing to import or not foreign language, go to next task.    $task = 'configure';  }  if ($task == 'locale-initial-batch') {    include_once 'includes/batch.inc';    include_once 'includes/locale.inc';    $output = _batch_page();  }  if ($task == 'configure') {    if (variable_get('site_name', FALSE) || variable_get('site_mail', FALSE)) {      // Site already configured: This should never happen, means re-running      // the installer, possibly by an attacker after the 'install_task' variable      // got accidentally blown somewhere. Stop it now.      install_already_done_error();    }    $form = drupal_get_form('install_configure_form', $url);    if (!variable_get('site_name', FALSE) && !variable_get('site_mail', FALSE)) {      // Not submitted yet: Prepare to display the form.      $output = $form;      drupal_set_title(st('Configure site'));      // Warn about settings.php permissions risk      $settings_dir = './'. conf_path();      $settings_file = $settings_dir .'/settings.php';      if (!drupal_verify_install_file($settings_file, FILE_EXIST|FILE_READABLE|FILE_NOT_WRITABLE) || !drupal_verify_install_file($settings_dir, FILE_NOT_WRITABLE, 'dir')) {        drupal_set_message(st('All necessary changes to %dir and %file have been made, so you should remove write permissions to them now in order to avoid security risks. If you are unsure how to do so, please consult the <a href="@handbook_url">on-line handbook</a>.', array('%dir' => $settings_dir, '%file' => $settings_file, '@handbook_url' => 'http://drupal.org/getting-started')), 'error');      }      else {        drupal_set_message(st('All necessary changes to %dir and %file have been made. They have been set to read-only for security.', array('%dir' => $settings_dir, '%file' => $settings_file)));      }      // Add JavaScript validation.      _user_password_dynamic_validation();      drupal_add_js(drupal_get_path('module', 'system') .'/system.js', 'module');      // We add these strings as settings because JavaScript translation does not      // work on install time.      drupal_add_js(array('copyFieldValue' => array('edit-site-mail' => array('edit-account-mail')), 'cleanURL' => array('success' => st('Your server has been successfully tested to support this feature.'), 'failure' => st('Your system configuration does not currently support this feature. The <a href="http://drupal.org/node/15365">handbook page on Clean URLs</a> has additional troubleshooting information.'), 'testing' => st('Testing clean URLs...'))), 'setting');      drupal_add_js('// Global Killswitchif (Drupal.jsEnabled) {  $(document).ready(function() {    Drupal.cleanURLsInstallCheck();    Drupal.setDefaultTimezone();  });}', 'inline');      // Build menu to allow clean URL check.      menu_rebuild();    }    else {      $task = 'profile';    }  }  // If found an unknown task or the 'profile' task, which is  // reserved for profiles, hand over the control to the profile,  // so it can run any number of custom tasks it defines.  if (!in_array($task, install_reserved_tasks())) {    $function = $profile .'_profile_tasks';    if (function_exists($function)) {      // The profile needs to run more code, maybe even more tasks.      // $task is sent through as a reference and may be changed!      $output = $function($task, $url);    }    // If the profile doesn't move on to a new task we assume    // that it is done.    if ($task == 'profile') {      $task = 'profile-finished';    }  }  // Profile custom tasks are done, so let the installer regain  // control and proceed with importing the remaining translations.  if ($task == 'profile-finished') {    if (!empty($install_locale) && ($install_locale != 'en')) {      include_once 'includes/locale.inc';      // Collect files to import for this language. Skip components      // already covered in the initial batch set.      $batch = locale_batch_by_language($install_locale, '_install_locale_remaining_batch_finished', variable_get('install_locale_batch_components', array()));      // Remove temporary variable.      variable_del('install_locale_batch_components');      if (!empty($batch)) {        // Start a batch, switch to 'locale-remaining-batch' task. We need to        // set the variable here, because batch_process() redirects.        variable_set('install_task', 'locale-remaining-batch');        batch_set($batch);        batch_process($url, $url);      }    }    // Found nothing to import or not foreign language, go to next task.    $task = 'finished';  }  if ($task == 'locale-remaining-batch') {    include_once 'includes/batch.inc';    include_once 'includes/locale.inc';    $output = _batch_page();  }  // Display a 'finished' page to user.  if ($task == 'finished') {    drupal_set_title(st('@drupal installation complete', array('@drupal' => drupal_install_profile_name())));    $messages = drupal_set_message();    $output = '<p>'. st('Congratulations, @drupal has been successfully installed.', array('@drupal' => drupal_install_profile_name())) .'</p>';    $output .= '<p>'. (isset($messages['error']) ? st('Please review the messages above before continuing on to <a href="@url">your new site</a>.', array('@url' => url(''))) : st('You may now visit <a href="@url">your new site</a>.', array('@url' => url('')))) .'</p>';    $task = 'done';  }  // The end of the install process. Remember profile used.  if ($task == 'done') {    // Rebuild menu to get content type links registered by the profile,    // and possibly any other menu items created through the tasks.    menu_rebuild();    // Register actions declared by any modules.    actions_synchronize();    // Randomize query-strings on css/js files, to hide the fact that    // this is a new install, not upgraded yet.    _drupal_flush_css_js();    variable_set('install_profile', $profile);  }  // Set task for user, and remember the task in the database.  install_task_list($task);  variable_set('install_task', $task);  // Output page, if some output was required. Otherwise it is possible  // that we are printing a JSON page and theme output should not be there.  if (isset($output)) {    print theme('maintenance_page', $output);  }}/** * Batch callback for batch installation of modules. */function _install_module_batch($module, $module_name, &$context) {  _drupal_install_module($module);  // We enable the installed module right away, so that the module will be  // loaded by drupal_bootstrap in subsequent batch requests, and other  // modules possibly depending on it can safely perform their installation  // steps.  module_enable(array($module));  $context['results'][] = $module;  $context['message'] = st('Installed %module module.', array('%module' => $module_name));}/** * Finished callback for the modules install batch. * * Advance installer task to language import. */function _install_profile_batch_finished($success, $results) {  variable_set('install_task', 'locale-initial-import');}/** * Finished callback for the first locale import batch. * * Advance installer task to the configure screen. */function _install_locale_initial_batch_finished($success, $results) {  variable_set('install_task', 'configure');}/** * Finished callback for the second locale import batch. * * Advance installer task to the finished screen. */function _install_locale_remaining_batch_finished($success, $results) {  variable_set('install_task', 'finished');}/** * The list of reserved tasks to run in the installer. */function install_reserved_tasks() {  return array('configure', 'profile-install', 'profile-install-batch', 'locale-initial-import', 'locale-initial-batch', 'profile-finished', 'locale-remaining-batch', 'finished', 'done');}/** * Check installation requirements and report any errors. */function install_check_requirements($profile, $verify) {  // If Drupal is not set up already, we need to create a settings file.  if (!$verify) {    $writable = FALSE;    $conf_path = './'. conf_path(FALSE, TRUE);    $settings_file = $conf_path .'/settings.php';    $file = $conf_path;    $exists = FALSE;    // Verify that the directory exists.    if (drupal_verify_install_file($conf_path, FILE_EXIST, 'dir')) {      // Check to make sure a settings.php already exists.      $file = $settings_file;      if (drupal_verify_install_file($settings_file, FILE_EXIST)) {        $exists = TRUE;        // If it does, make sure it is writable.        $writable = drupal_verify_install_file($settings_file, FILE_READABLE|FILE_WRITABLE);      }    }    if (!$exists) {      drupal_set_message(st('The @drupal installer requires that you create a settings file as part of the installation process.<ol><li>Copy the %default_file file to %file.</li><li>Change file permissions so that it is writable by the web server. If you are unsure how to grant file permissions, please consult the <a href="@handbook_url">on-line handbook</a>.</li></ol>More details about installing Drupal are available in INSTALL.txt.', array('@drupal' => drupal_install_profile_name(), '%file' => $file, '%default_file' => $conf_path .'/default.settings.php', '@handbook_url' => 'http://drupal.org/server-permissions')), 'error');    }    elseif (!$writable) {      drupal_set_message(st('The @drupal installer requires write permissions to %file during the installation process. If you are unsure how to grant file permissions, please consult the <a href="@handbook_url">on-line handbook</a>.', array('@drupal' => drupal_install_profile_name(), '%file' => $file, '@handbook_url' => 'http://drupal.org/server-permissions')), 'error');    }  }  // Check the other requirements.  $requirements = drupal_check_profile($profile);  $severity = drupal_requirements_severity($requirements);  // If there are issues, report them.  if ($severity == REQUIREMENT_ERROR) {    foreach ($requirements as $requirement) {      if (isset($requirement['severity']) && $requirement['severity'] == REQUIREMENT_ERROR) {        $message = $requirement['description'];        if (isset($requirement['value']) && $requirement['value']) {          $message .= ' ('. st('Currently using !item !version', array('!item' => $requirement['title'], '!version' => $requirement['value'])) .')';        }        drupal_set_message($message, 'error');      }    }  }  if ($severity == REQUIREMENT_WARNING) {    foreach ($requirements as $requirement) {      if (isset($requirement['severity']) && $requirement['severity'] == REQUIREMENT_WARNING) {        $message = $requirement['description'];        if (isset($requirement['value']) && $requirement['value']) {          $message .= ' ('. st('Currently using !item !version', array('!item' => $requirement['title'], '!version' => $requirement['value'])) .')';        }        drupal_set_message($message, 'warning');      }    }  } }/** * Add the installation task list to the current page. */function install_task_list($active = NULL) {  // Default list of tasks.  $tasks = array(    'profile-select'        => st('Choose profile'),    'locale-select'         => st('Choose language'),    'requirements'          => st('Verify requirements'),    'database'              => st('Set up database'),    'profile-install-batch' => st('Install profile'),    'locale-initial-batch'  => st('Set up translations'),    'configure'             => st('Configure site'),  );  $profiles = install_find_profiles();  $profile = isset($_GET['profile']) && isset($profiles[$_GET['profile']]) ? $_GET['profile'] : '.';  $locales = install_find_locales($profile);  // If we have only one profile, remove 'Choose profile'  // and rename 'Install profile'.  if (count($profiles) == 1) {    unset($tasks['profile-select']);    $tasks['profile-install-batch'] = st('Install site');  }  // Add tasks defined by the profile.  if ($profile) {    $function = $profile .'_profile_task_list';    if (function_exists($function)) {      $result = $function();      if (is_array($result)) {        $tasks += $result;      }    }  }  if (count($locales) < 2 || empty($_GET['locale']) || $_GET['locale'] == 'en') {    // If not required, remove translation import from the task list.    unset($tasks['locale-initial-batch']);  }  else {    // If required, add remaining translations import task.    $tasks += array('locale-remaining-batch' => st('Finish translations'));  }  // Add finished step as the last task.  $tasks += array(    'finished'     => st('Finished')  );  // Let the theming function know that 'finished' and 'done'  // include everything, so every step is completed.  if (in_array($active, array('finished', 'done'))) {    $active = NULL;  }  drupal_set_content('left', theme_task_list($tasks, $active));}/** * Form API array definition for site configuration. */function install_configure_form(&$form_state, $url) {  $form['intro'] = array(    '#value' => st('To configure your website, please provide the following information.'),    '#weight' => -10,  );  $form['site_information'] = array(    '#type' => 'fieldset',    '#title' => st('Site information'),    '#collapsible' => FALSE,  );  $form['site_information']['site_name'] = array(    '#type' => 'textfield',    '#title' => st('Site name'),    '#required' => TRUE,    '#weight' => -20,  );  $form['site_information']['site_mail'] = array(    '#type' => 'textfield',    '#title' => st('Site e-mail address'),    '#default_value' => ini_get('sendmail_from'),    '#description' => st("The <em>From</em> address in automated e-mails sent during registration and new password requests, and other notifications. (Use an address ending in your site's domain to help prevent this e-mail being flagged as spam.)"),    '#required' => TRUE,    '#weight' => -15,  );  $form['admin_account'] = array(    '#type' => 'fieldset',    '#title' => st('Administrator account'),    '#collapsible' => FALSE,  );  $form['admin_account']['account']['#tree'] = TRUE;  $form['admin_account']['markup'] = array(    '#value' => '<p class="description">'. st('The administrator account has complete access to the site; it will automatically be granted all permissions and can perform any administrative activity. This will be the only account that can perform certain activities, so keep its credentials safe.') .'</p>',    '#weight' => -10,  );  $form['admin_account']['account']['name'] = array('#type' => 'textfield',    '#title' => st('Username'),    '#maxlength' => USERNAME_MAX_LENGTH,    '#description' => st('Spaces are allowed; punctuation is not allowed except for periods, hyphens, and underscores.'),    '#required' => TRUE,    '#weight' => -10,  );  $form['admin_account']['account']['mail'] = array('#type' => 'textfield',    '#title' => st('E-mail address'),    '#maxlength' => EMAIL_MAX_LENGTH,    '#description' => st('All e-mails from the system will be sent to this address. The e-mail address is not made public and will only be used if you wish to receive a new password or wish to receive certain news or notifications by e-mail.'),    '#required' => TRUE,    '#weight' => -5,  );  $form['admin_account']['account']['pass'] = array(    '#type' => 'password_confirm',    '#required' => TRUE,    '#size' => 25,    '#weight' => 0,  );  $form['server_settings'] = array(    '#type' => 'fieldset',    '#title' => st('Server settings'),    '#collapsible' => FALSE,  );  $form['server_settings']['date_default_timezone'] = array(    '#type' => 'select',    '#title' => st('Default time zone'),    '#default_value' => 0,    '#options' => _system_zonelist(),    '#description' => st('By default, dates in this site will be displayed in the chosen time zone.'),    '#weight' => 5,  );  $form['server_settings']['clean_url'] = array(    '#type' => 'radios',    '#title' => st('Clean URLs'),    '#default_value' => 0,    '#options' => array(0 => st('Disabled'), 1 => st('Enabled')),    '#description' => st('This option makes Drupal emit "clean" URLs (i.e. without <code>?q=</code> in the URL).'),    '#disabled' => TRUE,    '#prefix' => '<div id="clean-url" class="install">',    '#suffix' => '</div>',    '#weight' => 10,  );  $form['server_settings']['update_status_module'] = array(    '#type' => 'checkboxes',    '#title' => st('Update notifications'),    '#options' => array(1 => st('Check for updates automatically')),    '#default_value' => array(1),    '#description' => st('With this option enabled, Drupal will notify you when new releases are available. This will significantly enhance your site\'s security and is <strong>highly recommended</strong>. This requires your site to periodically send anonymous information on its installed components to <a href="@drupal">drupal.org</a>. For more information please see the <a href="@update">update notification information</a>.', array('@drupal' => 'http://drupal.org', '@update' => 'http://drupal.org/handbook/modules/update')),    '#weight' => 15,  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => st('Save and continue'),    '#weight' => 15,  );  $form['#action'] = $url;  $form['#redirect'] = FALSE;  // Allow the profile to alter this form. $form_state isn't available  // here, but to conform to the hook_form_alter() signature, we pass  // an empty array.  $hook_form_alter = $_GET['profile'] .'_form_alter';  if (function_exists($hook_form_alter)) {    $hook_form_alter($form, array(), 'install_configure');  }  return $form;}/** * Form API validate for the site configuration form. */function install_configure_form_validate($form, &$form_state) {  if ($error = user_validate_name($form_state['values']['account']['name'])) {    form_error($form['admin_account']['account']['name'], $error);  }  if ($error = user_validate_mail($form_state['values']['account']['mail'])) {    form_error($form['admin_account']['account']['mail'], $error);  }  if ($error = user_validate_mail($form_state['values']['site_mail'])) {    form_error($form['site_information']['site_mail'], $error);  }}/** * Form API submit for the site configuration form. */function install_configure_form_submit($form, &$form_state) {  global $user;  variable_set('site_name', $form_state['values']['site_name']);  variable_set('site_mail', $form_state['values']['site_mail']);  variable_set('date_default_timezone', $form_state['values']['date_default_timezone']);  // Enable update.module if this option was selected.  if ($form_state['values']['update_status_module'][1]) {    drupal_install_modules(array('update'));  }  // Turn this off temporarily so that we can pass a password through.  variable_set('user_email_verification', FALSE);  $form_state['old_values'] = $form_state['values'];  $form_state['values'] = $form_state['values']['account'];  // We precreated user 1 with placeholder values. Let's save the real values.  $account = user_load(1);  $merge_data = array('init' => $form_state['values']['mail'], 'roles' => array(), 'status' => 1);  user_save($account, array_merge($form_state['values'], $merge_data));  // Log in the first user.  user_authenticate($form_state['values']);  $form_state['values'] = $form_state['old_values'];  unset($form_state['old_values']);  variable_set('user_email_verification', TRUE);  if (isset($form_state['values']['clean_url'])) {    variable_set('clean_url', $form_state['values']['clean_url']);  }  // The user is now logged in, but has no session ID yet, which  // would be required later in the request, so remember it.  $user->sid = session_id();  // Record when this install ran.  variable_set('install_time', time());}// Start the installer.install_main();
<?php// $Id$/** * @file * Administrative page callbacks for the forum module. */function forum_form_main($type, $edit = array()) {  if ((isset($_POST['op']) && $_POST['op'] == t('Delete')) || !empty($_POST['confirm'])) {    return drupal_get_form('forum_confirm_delete', $edit['tid']);  }  switch ($type) {    case 'forum':      return drupal_get_form('forum_form_forum', $edit);      break;    case 'container':      return drupal_get_form('forum_form_container', $edit);      break;  }}/** * Returns a form for adding a forum to the forum vocabulary * * @param $edit Associative array containing a forum term to be added or edited. * @ingroup forms * @see forum_form_submit() */function forum_form_forum(&$form_state, $edit = array()) {  $edit += array(    'name' => '',    'description' => '',    'tid' => NULL,    'weight' => 0,  );  $form['name'] = array('#type' => 'textfield',    '#title' => t('Forum name'),    '#default_value' => $edit['name'],    '#maxlength' => 255,    '#description' => t('Short but meaningful name for this collection of threaded discussions.'),    '#required' => TRUE,  );  $form['description'] = array('#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],    '#description' => t('Description and guidelines for discussions within this forum.'),  );  $form['parent']['#tree'] = TRUE;  $form['parent'][0] = _forum_parent_select($edit['tid'], t('Parent'), 'forum');  $form['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('Forums are displayed in ascending order by weight (forums with equal weights are displayed alphabetically).'),  );  $form['vid'] = array('#type' => 'hidden', '#value' => variable_get('forum_nav_vocabulary', ''));  $form['submit' ] = array('#type' => 'submit', '#value' => t('Save'));  if ($edit['tid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['tid'] = array('#type' => 'hidden', '#value' => $edit['tid']);  }  $form['#submit'][] = 'forum_form_submit';  $form['#theme'] = 'forum_form';  return $form;}/** * Process forum form and container form submissions. */function forum_form_submit($form, &$form_state) {  if ($form['form_id']['#value'] == 'forum_form_container') {    $container = TRUE;    $type = t('forum container');  }  else {    $container = FALSE;    $type = t('forum');  }  $status = taxonomy_save_term($form_state['values']);  switch ($status) {    case SAVED_NEW:      if ($container) {        $containers = variable_get('forum_containers', array());        $containers[] = $form_state['values']['tid'];        variable_set('forum_containers', $containers);      }      drupal_set_message(t('Created new @type %term.', array('%term' => $form_state['values']['name'], '@type' => $type)));      break;    case SAVED_UPDATED:      drupal_set_message(t('The @type %term has been updated.', array('%term' => $form_state['values']['name'], '@type' => $type)));      break;  }  $form_state['redirect'] = 'admin/content/forum';  return;}/** * Returns a form for adding a container to the forum vocabulary * * @param $edit Associative array containing a container term to be added or edited. * @ingroup forms * @see forum_form_submit() */function forum_form_container(&$form_state, $edit = array()) {  $edit += array(    'name' => '',    'description' => '',    'tid' => NULL,    'weight' => 0,  );  // Handle a delete operation.  $form['name'] = array(    '#title' => t('Container name'),    '#type' => 'textfield',    '#default_value' => $edit['name'],    '#maxlength' => 255,    '#description' => t('Short but meaningful name for this collection of related forums.'),    '#required' => TRUE  );  $form['description'] = array(    '#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $edit['description'],    '#description' => t('Description and guidelines for forums within this container.')  );  $form['parent']['#tree'] = TRUE;  $form['parent'][0] = _forum_parent_select($edit['tid'], t('Parent'), 'container');  $form['weight'] = array(    '#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $edit['weight'],    '#description' => t('Containers are displayed in ascending order by weight (containers with equal weights are displayed alphabetically).')  );  $form['vid'] = array(    '#type' => 'hidden',    '#value' => variable_get('forum_nav_vocabulary', ''),  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save')  );  if ($edit['tid']) {    $form['delete'] = array('#type' => 'submit', '#value' => t('Delete'));    $form['tid'] = array('#type' => 'value', '#value' => $edit['tid']);  }  $form['#submit'][] = 'forum_form_submit';  $form['#theme'] = 'forum_form';  return $form;}/** * Returns a confirmation page for deleting a forum taxonomy term. * * @param $tid ID of the term to be deleted */function forum_confirm_delete(&$form_state, $tid) {  $term = taxonomy_get_term($tid);  $form['tid'] = array('#type' => 'value', '#value' => $tid);  $form['name'] = array('#type' => 'value', '#value' => $term->name);  return confirm_form($form, t('Are you sure you want to delete the forum %name?', array('%name' => $term->name)), 'admin/content/forum', t('Deleting a forum or container will also delete its sub-forums, if any. To delete posts in this forum, visit <a href="@content">content administration</a> first. This action cannot be undone.', array('@content' => url('admin/content/node'))), t('Delete'), t('Cancel'));}/** * Implementation of forms api _submit call. Deletes a forum after confirmation. */function forum_confirm_delete_submit($form, &$form_state) {  taxonomy_del_term($form_state['values']['tid']);  drupal_set_message(t('The forum %term and all sub-forums and associated posts have been deleted.', array('%term' => $form_state['values']['name'])));  watchdog('content', 'forum: deleted %term and all its sub-forums and associated posts.', array('%term' => $form_state['values']['name']));  $form_state['redirect'] = 'admin/content/forum';  return;}/** * Form builder for the forum settings page. * * @see system_settings_form() */function forum_admin_settings() {  $form = array();  $number = drupal_map_assoc(array(5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 80, 100, 150, 200, 250, 300, 350, 400, 500));  $form['forum_hot_topic'] = array('#type' => 'select',    '#title' => t('Hot topic threshold'),    '#default_value' => variable_get('forum_hot_topic', 15),    '#options' => $number,    '#description' => t('The number of posts a topic must have to be considered "hot".'),  );  $number = drupal_map_assoc(array(10, 25, 50, 75, 100));  $form['forum_per_page'] = array('#type' => 'select',    '#title' => t('Topics per page'),    '#default_value' => variable_get('forum_per_page', 25),    '#options' => $number,    '#description' => t('Default number of forum topics displayed per page.'),  );  $forder = array(1 => t('Date - newest first'), 2 => t('Date - oldest first'), 3 => t('Posts - most active first'), 4 => t('Posts - least active first'));  $form['forum_order'] = array('#type' => 'radios',    '#title' => t('Default order'),    '#default_value' => variable_get('forum_order', '1'),    '#options' => $forder,    '#description' => t('Default display order for topics.'),  );  return system_settings_form($form);}/** * Returns an overview list of existing forums and containers */function forum_overview(&$form_state) {  module_load_include('inc', 'taxonomy', 'taxonomy.admin');  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  $form = taxonomy_overview_terms($form_state, $vocabulary);  foreach (element_children($form) as $key) {    if (isset($form[$key]['#term'])) {      $term = $form[$key]['#term'];      $form[$key]['view']['#value'] = l($term['name'], 'forum/'. $term['tid']);      if (in_array($form[$key]['#term']['tid'], variable_get('forum_containers', array()))) {        $form[$key]['edit']['#value'] = l(t('edit container'), 'admin/content/forum/edit/container/'. $term['tid']);      }      else {        $form[$key]['edit']['#value'] = l(t('edit forum'), 'admin/content/forum/edit/forum/'. $term['tid']);      }    }  }  // Remove the alphabetical reset.  unset($form['reset_alphabetical']);  // The form needs to have submit and validate handlers set explicitly.  $form['#theme'] = 'taxonomy_overview_terms';  $form['#submit'] = array('taxonomy_overview_terms_submit'); // Use the existing taxonomy overview submit handler.  $form['#validate'] = array('taxonomy_overview_terms_validate');  $form['#empty_text'] = '<em>'. t('There are no existing containers or forums. Containers and forums may be added using the <a href="@container">add container</a> and <a href="@forum">add forum</a> pages.', array('@container' => url('admin/content/forum/add/container'), '@forum' => url('admin/content/forum/add/forum'))) .'</em>';  return $form;}/** * Returns a select box for available parent terms * * @param $tid ID of the term which is being added or edited * @param $title Title to display the select box with * @param $child_type Whether the child is forum or container */function _forum_parent_select($tid, $title, $child_type) {  $parents = taxonomy_get_parents($tid);  if ($parents) {    $parent = array_shift($parents);    $parent = $parent->tid;  }  else {    $parent = 0;  }  $vid = variable_get('forum_nav_vocabulary', '');  $children = taxonomy_get_tree($vid, $tid);  // A term can't be the child of itself, nor of its children.  foreach ($children as $child) {    $exclude[] = $child->tid;  }  $exclude[] = $tid;  $tree = taxonomy_get_tree($vid);  $options[0] = '<'. t('root') .'>';  if ($tree) {    foreach ($tree as $term) {      if (!in_array($term->tid, $exclude)) {        $options[$term->tid] = str_repeat(' -- ', $term->depth) . $term->name;      }    }  }  if ($child_type == 'container') {    $description = t('Containers are usually placed at the top (root) level, but may also be placed inside another container or forum.');  }  else if ($child_type == 'forum') {    $description = t('Forums may be placed at the top (root) level, or inside another container or forum.');  }  return array('#type' => 'select', '#title' => $title, '#default_value' => $parent, '#options' => $options, '#description' => $description, '#required' => TRUE);}
<?php// $Id$/** * @file * Common functions that many Drupal modules will need to reference. * * The functions that are critical and need to be available even when serving * a cached page are instead located in bootstrap.inc. *//** * Return status for saving which involved creating a new item. */define('SAVED_NEW', 1);/** * Return status for saving which involved an update to an existing item. */define('SAVED_UPDATED', 2);/** * Return status for saving which deleted an existing item. */define('SAVED_DELETED', 3);/** * Create E_DEPRECATED constant for older PHP versions (<5.3). */if (!defined('E_DEPRECATED')) {  define('E_DEPRECATED', 8192);}/** * Set content for a specified region. * * @param $region *   Page region the content is assigned to. * @param $data *   Content to be set. */function drupal_set_content($region = NULL, $data = NULL) {  static $content = array();  if (!is_null($region) && !is_null($data)) {    $content[$region][] = $data;  }  return $content;}/** * Get assigned content. * * @param $region *   A specified region to fetch content for. If NULL, all regions will be *   returned. * @param $delimiter *   Content to be inserted between imploded array elements. */function drupal_get_content($region = NULL, $delimiter = ' ') {  $content = drupal_set_content();  if (isset($region)) {    if (isset($content[$region]) && is_array($content[$region])) {      return implode($delimiter, $content[$region]);    }  }  else {    foreach (array_keys($content) as $region) {      if (is_array($content[$region])) {        $content[$region] = implode($delimiter, $content[$region]);      }    }    return $content;  }}/** * Set the breadcrumb trail for the current page. * * @param $breadcrumb *   Array of links, starting with "home" and proceeding up to but not including *   the current page. */function drupal_set_breadcrumb($breadcrumb = NULL) {  static $stored_breadcrumb;  if (!is_null($breadcrumb)) {    $stored_breadcrumb = $breadcrumb;  }  return $stored_breadcrumb;}/** * Get the breadcrumb trail for the current page. */function drupal_get_breadcrumb() {  $breadcrumb = drupal_set_breadcrumb();  if (is_null($breadcrumb)) {    $breadcrumb = menu_get_active_breadcrumb();  }  return $breadcrumb;}/** * Add output to the head tag of the HTML page. * * This function can be called as long the headers aren't sent. */function drupal_set_html_head($data = NULL) {  static $stored_head = '';  if (!is_null($data)) {    $stored_head .= $data ."\n";  }  return $stored_head;}/** * Retrieve output to be displayed in the head tag of the HTML page. */function drupal_get_html_head() {  $output = "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n";  return $output . drupal_set_html_head();}/** * Reset the static variable which holds the aliases mapped for this request. */function drupal_clear_path_cache() {  drupal_lookup_path('wipe');}/** * Set an HTTP response header for the current page. * * Note: When sending a Content-Type header, always include a 'charset' type, * too. This is necessary to avoid security bugs (e.g. UTF-7 XSS). */function drupal_set_header($header = NULL) {  // We use an array to guarantee there are no leading or trailing delimiters.  // Otherwise, header('') could get called when serving the page later, which  // ends HTTP headers prematurely on some PHP versions.  static $stored_headers = array();  if (strlen($header)) {    header($header);    $stored_headers[] = $header;  }  return implode("\n", $stored_headers);}/** * Get the HTTP response headers for the current page. */function drupal_get_headers() {  return drupal_set_header();}/** * Make any final alterations to the rendered xhtml. */function drupal_final_markup($content) {  // Make sure that the charset is always specified as the first element of the  // head region to prevent encoding-based attacks.  return preg_replace('/<head[^>]*>/i', "\$0\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />", $content, 1);}/** * Add a feed URL for the current page. * * @param $url *   A url for the feed. * @param $title *   The title of the feed. */function drupal_add_feed($url = NULL, $title = '') {  static $stored_feed_links = array();  if (!is_null($url) && !isset($stored_feed_links[$url])) {    $stored_feed_links[$url] = theme('feed_icon', $url, $title);    drupal_add_link(array('rel' => 'alternate',                          'type' => 'application/rss+xml',                          'title' => $title,                          'href' => $url));  }  return $stored_feed_links;}/** * Get the feed URLs for the current page. * * @param $delimiter *   A delimiter to split feeds by. */function drupal_get_feeds($delimiter = "\n") {  $feeds = drupal_add_feed();  return implode($feeds, $delimiter);}/** * @name HTTP handling * @{ * Functions to properly handle HTTP responses. *//** * Parse an array into a valid urlencoded query string. * * @param $query *   The array to be processed e.g. $_GET. * @param $exclude *   The array filled with keys to be excluded. Use parent[child] to exclude *   nested items. * @param $parent *   Should not be passed, only used in recursive calls. * @return *   An urlencoded string which can be appended to/as the URL query string. */function drupal_query_string_encode($query, $exclude = array(), $parent = '') {  $params = array();  foreach ($query as $key => $value) {    $key = rawurlencode($key);    if ($parent) {      $key = $parent .'['. $key .']';    }    if (in_array($key, $exclude)) {      continue;    }    if (is_array($value)) {      $params[] = drupal_query_string_encode($value, $exclude, $key);    }    else {      $params[] = $key .'='. rawurlencode($value);    }  }  return implode('&', $params);}/** * Prepare a destination query string for use in combination with drupal_goto(). * * Used to direct the user back to the referring page after completing a form. * By default the current URL is returned. If a destination exists in the * previous request, that destination is returned. As such, a destination can * persist across multiple pages. * * @see drupal_goto() */function drupal_get_destination() {  if (isset($_REQUEST['destination'])) {    return 'destination='. urlencode($_REQUEST['destination']);  }  else {    // Use $_GET here to retrieve the original path in source form.    $path = isset($_GET['q']) ? $_GET['q'] : '';    $query = drupal_query_string_encode($_GET, array('q'));    if ($query != '') {      $path .= '?'. $query;    }    return 'destination='. urlencode($path);  }}/** * Send the user to a different Drupal page. * * This issues an on-site HTTP redirect. The function makes sure the redirected * URL is formatted correctly. * * Usually the redirected URL is constructed from this function's input * parameters. However you may override that behavior by setting a * destination in either the $_REQUEST-array (i.e. by using * the query string of an URI) or the $_REQUEST['edit']-array (i.e. by * using a hidden form field). This is used to direct the user back to * the proper page after completing a form. For example, after editing * a post on the 'admin/content/node'-page or after having logged on using the * 'user login'-block in a sidebar. The function drupal_get_destination() * can be used to help set the destination URL. * * Drupal will ensure that messages set by drupal_set_message() and other * session data are written to the database before the user is redirected. * * This function ends the request; use it rather than a print theme('page') * statement in your menu callback. * * @param $path *   A Drupal path or a full URL. * @param $query *   A query string component, if any. * @param $fragment *   A destination fragment identifier (named anchor). * @param $http_response_code *   Valid values for an actual "goto" as per RFC 2616 section 10.3 are: *   - 301 Moved Permanently (the recommended value for most redirects) *   - 302 Found (default in Drupal and PHP, sometimes used for spamming search *         engines) *   - 303 See Other *   - 304 Not Modified *   - 305 Use Proxy *   - 307 Temporary Redirect (alternative to "503 Site Down for Maintenance") *   Note: Other values are defined by RFC 2616, but are rarely used and poorly *   supported. * @see drupal_get_destination() */function drupal_goto($path = '', $query = NULL, $fragment = NULL, $http_response_code = 302) {  $destination = FALSE;  if (isset($_REQUEST['destination'])) {    $destination = $_REQUEST['destination'];  }  else if (isset($_REQUEST['edit']['destination'])) {    $destination = $_REQUEST['edit']['destination'];  }  if ($destination) {    // Do not redirect to an absolute URL originating from user input.    $colonpos = strpos($destination, ':');    $absolute = ($colonpos !== FALSE && !preg_match('![/?#]!', substr($destination, 0, $colonpos)));    if (!$absolute) {      extract(parse_url(urldecode($destination)));    }  }  $url = url($path, array('query' => $query, 'fragment' => $fragment, 'absolute' => TRUE));  // Remove newlines from the URL to avoid header injection attacks.  $url = str_replace(array("\n", "\r"), '', $url);  // Allow modules to react to the end of the page request before redirecting.  // We do not want this while running update.php.  if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {    module_invoke_all('exit', $url);  }  // Even though session_write_close() is registered as a shutdown function, we  // need all session data written to the database before redirecting.  session_write_close();  header('Location: '. $url, TRUE, $http_response_code);  // The "Location" header sends a redirect status code to the HTTP daemon. In  // some cases this can be wrong, so we make sure none of the code below the  // drupal_goto() call gets executed upon redirection.  exit();}/** * Generates a site off-line message. */function drupal_site_offline() {  drupal_maintenance_theme();  drupal_set_header('HTTP/1.1 503 Service unavailable');  drupal_set_title(t('Site off-line'));  print theme('maintenance_page', filter_xss_admin(variable_get('site_offline_message',    t('@site is currently under maintenance. We should be back shortly. Thank you for your patience.', array('@site' => variable_get('site_name', 'Drupal'))))));}/** * Generates a 404 error if the request can not be handled. */function drupal_not_found() {  drupal_set_header('HTTP/1.1 404 Not Found');  watchdog('page not found', check_plain($_GET['q']), NULL, WATCHDOG_WARNING);  // Keep old path for reference, and to allow forms to redirect to it.  if (!isset($_REQUEST['destination'])) {    $_REQUEST['destination'] = $_GET['q'];  }  $path = drupal_get_normal_path(variable_get('site_404', ''));  if ($path && $path != $_GET['q']) {    // Set the active item in case there are tabs to display, or other    // dependencies on the path.    menu_set_active_item($path);    $return = menu_execute_active_handler($path);  }  if (empty($return) || $return == MENU_NOT_FOUND || $return == MENU_ACCESS_DENIED) {    drupal_set_title(t('Page not found'));    $return = t('The requested page could not be found.');  }  // To conserve CPU and bandwidth, omit the blocks.  print theme('page', $return, FALSE);}/** * Generates a 403 error if the request is not allowed. */function drupal_access_denied() {  drupal_set_header('HTTP/1.1 403 Forbidden');  watchdog('access denied', check_plain($_GET['q']), NULL, WATCHDOG_WARNING);  // Keep old path for reference, and to allow forms to redirect to it.  if (!isset($_REQUEST['destination'])) {    $_REQUEST['destination'] = $_GET['q'];  }  $path = drupal_get_normal_path(variable_get('site_403', ''));  if ($path && $path != $_GET['q']) {    // Set the active item in case there are tabs to display or other    // dependencies on the path.    menu_set_active_item($path);    $return = menu_execute_active_handler($path);  }  if (empty($return) || $return == MENU_NOT_FOUND || $return == MENU_ACCESS_DENIED) {    drupal_set_title(t('Access denied'));    $return = t('You are not authorized to access this page.');  }  print theme('page', $return);}/** * Perform an HTTP request. * * This is a flexible and powerful HTTP client implementation. Correctly handles * GET, POST, PUT or any other HTTP requests. Handles redirects. * * @param $url *   A string containing a fully qualified URI. * @param $headers *   An array containing an HTTP header => value pair. * @param $method *   A string defining the HTTP request to use. * @param $data *   A string containing data to include in the request. * @param $retry *   An integer representing how many times to retry the request in case of a *   redirect. * @return *   An object containing the HTTP request headers, response code, headers, *   data and redirect status. */function drupal_http_request($url, $headers = array(), $method = 'GET', $data = NULL, $retry = 3) {  global $db_prefix;  $result = new stdClass();  // Parse the URL and make sure we can handle the schema.  $uri = parse_url($url);  if ($uri == FALSE) {    $result->error = 'unable to parse URL';    $result->code = -1001;    return $result;  }  if (!isset($uri['scheme'])) {    $result->error = 'missing schema';    $result->code = -1002;    return $result;  }  switch ($uri['scheme']) {    case 'http':      $port = isset($uri['port']) ? $uri['port'] : 80;      $host = $uri['host'] . ($port != 80 ? ':'. $port : '');      $fp = @fsockopen($uri['host'], $port, $errno, $errstr, 15);      break;    case 'https':      // Note: Only works for PHP 4.3 compiled with OpenSSL.      $port = isset($uri['port']) ? $uri['port'] : 443;      $host = $uri['host'] . ($port != 443 ? ':'. $port : '');      $fp = @fsockopen('ssl://'. $uri['host'], $port, $errno, $errstr, 20);      break;    default:      $result->error = 'invalid schema '. $uri['scheme'];      $result->code = -1003;      return $result;  }  // Make sure the socket opened properly.  if (!$fp) {    // When a network error occurs, we use a negative number so it does not    // clash with the HTTP status codes.    $result->code = -$errno;    $result->error = trim($errstr);    // Mark that this request failed. This will trigger a check of the web    // server's ability to make outgoing HTTP requests the next time that    // requirements checking is performed.    // @see system_requirements()    variable_set('drupal_http_request_fails', TRUE);    return $result;  }  // Construct the path to act on.  $path = isset($uri['path']) ? $uri['path'] : '/';  if (isset($uri['query'])) {    $path .= '?'. $uri['query'];  }  // Create HTTP request.  $defaults = array(    // RFC 2616: "non-standard ports MUST, default ports MAY be included".    // We don't add the port to prevent from breaking rewrite rules checking the    // host that do not take into account the port number.    'Host' => "Host: $host",    'User-Agent' => 'User-Agent: Drupal (+http://drupal.org/)',  );  // Only add Content-Length if we actually have any content or if it is a POST  // or PUT request. Some non-standard servers get confused by Content-Length in  // at least HEAD/GET requests, and Squid always requires Content-Length in  // POST/PUT requests.  $content_length = strlen($data);  if ($content_length > 0 || $method == 'POST' || $method == 'PUT') {    $defaults['Content-Length'] = 'Content-Length: '. $content_length;  }  // If the server url has a user then attempt to use basic authentication  if (isset($uri['user'])) {    $defaults['Authorization'] = 'Authorization: Basic '. base64_encode($uri['user'] . (!empty($uri['pass']) ? ":". $uri['pass'] : ''));  }  // If the database prefix is being used by SimpleTest to run the tests in a copied  // database then set the user-agent header to the database prefix so that any  // calls to other Drupal pages will run the SimpleTest prefixed database. The  // user-agent is used to ensure that multiple testing sessions running at the  // same time won't interfere with each other as they would if the database  // prefix were stored statically in a file or database variable.  if (is_string($db_prefix) && preg_match("/^simpletest\d+$/", $db_prefix, $matches)) {    $defaults['User-Agent'] = 'User-Agent: ' . $matches[0];  }  foreach ($headers as $header => $value) {    $defaults[$header] = $header .': '. $value;  }  $request = $method .' '. $path ." HTTP/1.0\r\n";  $request .= implode("\r\n", $defaults);  $request .= "\r\n\r\n";  $request .= $data;  $result->request = $request;  fwrite($fp, $request);  // Fetch response.  $response = '';  while (!feof($fp) && $chunk = fread($fp, 1024)) {    $response .= $chunk;  }  fclose($fp);  // Parse response.  list($split, $result->data) = explode("\r\n\r\n", $response, 2);  $split = preg_split("/\r\n|\n|\r/", $split);  list($protocol, $code, $text) = explode(' ', trim(array_shift($split)), 3);  $result->headers = array();  // Parse headers.  while ($line = trim(array_shift($split))) {    list($header, $value) = explode(':', $line, 2);    if (isset($result->headers[$header]) && $header == 'Set-Cookie') {      // RFC 2109: the Set-Cookie response header comprises the token Set-      // Cookie:, followed by a comma-separated list of one or more cookies.      $result->headers[$header] .= ','. trim($value);    }    else {      $result->headers[$header] = trim($value);    }  }  $responses = array(    100 => 'Continue', 101 => 'Switching Protocols',    200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content',    300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 307 => 'Temporary Redirect',    400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Time-out', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Large', 415 => 'Unsupported Media Type', 416 => 'Requested range not satisfiable', 417 => 'Expectation Failed',    500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Time-out', 505 => 'HTTP Version not supported'  );  // RFC 2616 states that all unknown HTTP codes must be treated the same as the  // base code in their class.  if (!isset($responses[$code])) {    $code = floor($code / 100) * 100;  }  switch ($code) {    case 200: // OK    case 304: // Not modified      break;    case 301: // Moved permanently    case 302: // Moved temporarily    case 307: // Moved temporarily      $location = $result->headers['Location'];      if ($retry) {        $result = drupal_http_request($result->headers['Location'], $headers, $method, $data, --$retry);        $result->redirect_code = $result->code;      }      $result->redirect_url = $location;      break;    default:      $result->error = $text;  }  $result->code = $code;  return $result;}/** * @} End of "HTTP handling". *//** * Log errors as defined by administrator. * * Error levels: * - 0 = Log errors to database. * - 1 = Log errors to database and to screen. */function drupal_error_handler($errno, $message, $filename, $line, $context) {  // If the @ error suppression operator was used, error_reporting will have  // been temporarily set to 0.  if (error_reporting() == 0) {    return;  }  if ($errno & (E_ALL ^ E_DEPRECATED ^ E_NOTICE)) {    $types = array(1 => 'error', 2 => 'warning', 4 => 'parse error', 8 => 'notice', 16 => 'core error', 32 => 'core warning', 64 => 'compile error', 128 => 'compile warning', 256 => 'user error', 512 => 'user warning', 1024 => 'user notice', 2048 => 'strict warning', 4096 => 'recoverable fatal error');    // For database errors, we want the line number/file name of the place that    // the query was originally called, not _db_query().    if (isset($context[DB_ERROR])) {      $backtrace = array_reverse(debug_backtrace());      // List of functions where SQL queries can originate.      $query_functions = array('db_query', 'pager_query', 'db_query_range', 'db_query_temporary', 'update_sql');      // Determine where query function was called, and adjust line/file      // accordingly.      foreach ($backtrace as $index => $function) {        if (in_array($function['function'], $query_functions)) {          $line = $backtrace[$index]['line'];          $filename = $backtrace[$index]['file'];          break;        }      }    }    $entry = $types[$errno] .': '. $message .' in '. $filename .' on line '. $line .'.';    // Force display of error messages in update.php.    if (variable_get('error_level', 1) == 1 || strstr($_SERVER['SCRIPT_NAME'], 'update.php')) {      drupal_set_message($entry, 'error');    }    watchdog('php', '%message in %file on line %line.', array('%error' => $types[$errno], '%message' => $message, '%file' => $filename, '%line' => $line), WATCHDOG_ERROR);  }}function _fix_gpc_magic(&$item) {  if (is_array($item)) {    array_walk($item, '_fix_gpc_magic');  }  else {    $item = stripslashes($item);  }}/** * Helper function to strip slashes from $_FILES skipping over the tmp_name keys * since PHP generates single backslashes for file paths on Windows systems. * * tmp_name does not have backslashes added see * http://php.net/manual/en/features.file-upload.php#42280 */function _fix_gpc_magic_files(&$item, $key) {  if ($key != 'tmp_name') {    if (is_array($item)) {      array_walk($item, '_fix_gpc_magic_files');    }    else {      $item = stripslashes($item);    }  }}/** * Fix double-escaping problems caused by "magic quotes" in some PHP installations. */function fix_gpc_magic() {  static $fixed = FALSE;  if (!$fixed && ini_get('magic_quotes_gpc')) {    array_walk($_GET, '_fix_gpc_magic');    array_walk($_POST, '_fix_gpc_magic');    array_walk($_COOKIE, '_fix_gpc_magic');    array_walk($_REQUEST, '_fix_gpc_magic');    array_walk($_FILES, '_fix_gpc_magic_files');    $fixed = TRUE;  }}/** * Translate strings to the page language or a given language. * * Human-readable text that will be displayed somewhere within a page should * be run through the t() function. * * Examples: * @code *   if (!$info || !$info['extension']) { *     form_set_error('picture_upload', t('The uploaded file was not an image.')); *   } * *   $form['submit'] = array( *     '#type' => 'submit', *     '#value' => t('Log in'), *   ); * @endcode * * Any text within t() can be extracted by translators and changed into * the equivalent text in their native language. * * Special variables called "placeholders" are used to signal dynamic * information in a string which should not be translated. Placeholders * can also be used for text that may change from time to time (such as * link paths) to be changed without requiring updates to translations. * * For example: * @code *   $output = t('There are currently %members and %visitors online.', array( *     '%members' => format_plural($total_users, '1 user', '@count users'), *     '%visitors' => format_plural($guests->count, '1 guest', '@count guests'))); * @endcode * * There are three styles of placeholders: * - !variable, which indicates that the text should be inserted as-is. This is *   useful for inserting variables into things like e-mail. *   @code *     $message[] = t("If you don't want to receive such e-mails, you can change your settings at !url.", array('!url' => url("user/$account->uid", array('absolute' => TRUE)))); *   @endcode * * - @variable, which indicates that the text should be run through *   check_plain, to escape HTML characters. Use this for any output that's *   displayed within a Drupal page. *   @code *     drupal_set_title($title = t("@name's blog", array('@name' => $account->name))); *   @endcode * * - %variable, which indicates that the string should be HTML escaped and *   highlighted with theme_placeholder() which shows up by default as *   <em>emphasized</em>. *   @code *     $message = t('%name-from sent %name-to an e-mail.', array('%name-from' => $user->name, '%name-to' => $account->name)); *   @endcode * * When using t(), try to put entire sentences and strings in one t() call. * This makes it easier for translators, as it provides context as to what * each word refers to. HTML markup within translation strings is allowed, but * should be avoided if possible. The exception are embedded links; link * titles add a context for translators, so should be kept in the main string. * * Here is an example of incorrect usage of t(): * @code *   $output .= t('<p>Go to the @contact-page.</p>', array('@contact-page' => l(t('contact page'), 'contact'))); * @endcode * * Here is an example of t() used correctly: * @code *   $output .= '<p>'. t('Go to the <a href="@contact-page">contact page</a>.', array('@contact-page' => url('contact'))) .'</p>'; * @endcode * * Avoid escaping quotation marks wherever possible. * * Incorrect: * @code *   $output .= t('Don\'t click me.'); * @endcode * * Correct: * @code *   $output .= t("Don't click me."); * @endcode * * Because t() is designed for handling code-based strings, in almost all * cases, the actual string and not a variable must be passed through t(). * * Extraction of translations is done based on the strings contained in t() * calls. If a variable is passed through t(), the content of the variable * cannot be extracted from the file for translation. * * Incorrect: * @code *   $message = 'An error occurred.'; *   drupal_set_message(t($message), 'error'); *   $output .= t($message); * @endcode * * Correct: * @code *   $message = t('An error occurred.'); *   drupal_set_message($message, 'error'); *   $output .= $message; * @endcode * * The only case in which variables can be passed safely through t() is when * code-based versions of the same strings will be passed through t() (or * otherwise extracted) elsewhere. * * In some cases, modules may include strings in code that can't use t() * calls. For example, a module may use an external PHP application that * produces strings that are loaded into variables in Drupal for output. * In these cases, module authors may include a dummy file that passes the * relevant strings through t(). This approach will allow the strings to be * extracted. * * Sample external (non-Drupal) code: * @code *   class Time { *     public $yesterday = 'Yesterday'; *     public $today = 'Today'; *     public $tomorrow = 'Tomorrow'; *   } * @endcode * * Sample dummy file. * @code *   // Dummy function included in example.potx.inc. *   function example_potx() { *     $strings = array( *       t('Yesterday'), *       t('Today'), *       t('Tomorrow'), *     ); *     // No return value needed, since this is a dummy function. *   } * @endcode * * Having passed strings through t() in a dummy function, it is then * okay to pass variables through t(). * * Correct (if a dummy file was used): * @code *   $time = new Time(); *   $output .= t($time->today); * @endcode * * However tempting it is, custom data from user input or other non-code * sources should not be passed through t(). Doing so leads to the following * problems and errors: *  - The t() system doesn't support updates to existing strings. When user *    data is updated, the next time it's passed through t() a new record is *    created instead of an update. The database bloats over time and any *    existing translations are orphaned with each update. *  - The t() system assumes any data it receives is in English. User data may *    be in another language, producing translation errors. *  - The "Built-in interface" text group in the locale system is used to *    produce translations for storage in .po files. When non-code strings are *    passed through t(), they are added to this text group, which is rendered *    inaccurate since it is a mix of actual interface strings and various user *    input strings of uncertain origin. * * Incorrect: * @code *   $item = item_load(); *   $output .= check_plain(t($item['title'])); * @endcode * * Instead, translation of these data can be done through the locale system, * either directly or through helper functions provided by contributed * modules. * @see hook_locale() * * During installation, st() is used in place of t(). Code that may be called * during installation or during normal operation should use the get_t() * helper function. * @see st() * @see get_t() * * @param $string *   A string containing the English string to translate. * @param $args *   An associative array of replacements to make after translation. Incidences *   of any key in this array are replaced with the corresponding value. Based *   on the first character of the key, the value is escaped and/or themed: *    - !variable: inserted as is *    - @variable: escape plain text to HTML (check_plain) *    - %variable: escape text and theme as a placeholder for user-submitted *      content (check_plain + theme_placeholder) * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   The translated string. */function t($string, $args = array(), $langcode = NULL) {  global $language;  static $custom_strings;  $langcode = isset($langcode) ? $langcode : $language->language;  // First, check for an array of customized strings. If present, use the array  // *instead of* database lookups. This is a high performance way to provide a  // handful of string replacements. See settings.php for examples.  // Cache the $custom_strings variable to improve performance.  if (!isset($custom_strings[$langcode])) {    $custom_strings[$langcode] = variable_get('locale_custom_strings_'. $langcode, array());  }  // Custom strings work for English too, even if locale module is disabled.  if (isset($custom_strings[$langcode][$string])) {    $string = $custom_strings[$langcode][$string];  }  // Translate with locale module if enabled.  elseif (function_exists('locale') && $langcode != 'en') {    $string = locale($string, $langcode);  }  if (empty($args)) {    return $string;  }  else {    // Transform arguments before inserting them.    foreach ($args as $key => $value) {      switch ($key[0]) {        case '@':          // Escaped only.          $args[$key] = check_plain($value);          break;        case '%':        default:          // Escaped and placeholder.          $args[$key] = theme('placeholder', $value);          break;        case '!':          // Pass-through.      }    }    return strtr($string, $args);  }}/** * @defgroup validation Input validation * @{ * Functions to validate user input. *//** * Verify the syntax of the given e-mail address. * * Empty e-mail addresses are allowed. See RFC 2822 for details. * * @param $mail *   A string containing an e-mail address. * @return *   TRUE if the address is in a valid format. */function valid_email_address($mail) {  $user = '[a-zA-Z0-9_\-\.\+\^!#\$%&*+\/\=\?\`\|\{\}~\']+';  $domain = '(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.?)+';  $ipv4 = '[0-9]{1,3}(\.[0-9]{1,3}){3}';  $ipv6 = '[0-9a-fA-F]{1,4}(\:[0-9a-fA-F]{1,4}){7}';  return preg_match("/^$user@($domain|(\[($ipv4|$ipv6)\]))$/", $mail);}/** * Verify the syntax of the given URL. * * This function should only be used on actual URLs. It should not be used for * Drupal menu paths, which can contain arbitrary characters. * Valid values per RFC 3986. * * @param $url *   The URL to verify. * @param $absolute *   Whether the URL is absolute (beginning with a scheme such as "http:"). * @return *   TRUE if the URL is in a valid format. */function valid_url($url, $absolute = FALSE) {  if ($absolute) {    return (bool)preg_match("      /^                                                      # Start at the beginning of the text      (?:ftp|https?):\/\/                                     # Look for ftp, http, or https schemes      (?:                                                     # Userinfo (optional) which is typically        (?:(?:[\w\.\-\+!$&'\(\)*\+,;=]|%[0-9a-f]{2})+:)*      # a username or a username and password        (?:[\w\.\-\+%!$&'\(\)*\+,;=]|%[0-9a-f]{2})+@          # combination      )?      (?:        (?:[a-z0-9\-\.]|%[0-9a-f]{2})+                        # A domain name or a IPv4 address        |(?:\[(?:[0-9a-f]{0,4}:)*(?:[0-9a-f]{0,4})\])         # or a well formed IPv6 address      )      (?::[0-9]+)?                                            # Server port number (optional)      (?:[\/|\?]        (?:[\w#!:\.\?\+=&@$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})   # The path and query (optional)      *)?    $/xi", $url);  }  else {    return (bool)preg_match("/^(?:[\w#!:\.\?\+=&@$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})+$/i", $url);  }}/** * @} End of "defgroup validation". *//** * Register an event for the current visitor (hostname/IP) to the flood control mechanism. * * @param $name *   The name of an event. */function flood_register_event($name) {  db_query("INSERT INTO {flood} (event, hostname, timestamp) VALUES ('%s', '%s', %d)", $name, ip_address(), time());}/** * Check if the current visitor (hostname/IP) is allowed to proceed with the specified event. * * The user is allowed to proceed if he did not trigger the specified event more * than $threshold times per hour. * * @param $name *   The name of the event. * @param $threshold *   The maximum number of the specified event per hour (per visitor). * @return *   True if the user did not exceed the hourly threshold. False otherwise. */function flood_is_allowed($name, $threshold) {  $number = db_result(db_query("SELECT COUNT(*) FROM {flood} WHERE event = '%s' AND hostname = '%s' AND timestamp > %d", $name, ip_address(), time() - 3600));  return ($number < $threshold ? TRUE : FALSE);}function check_file($filename) {  return is_uploaded_file($filename);}/** * Prepare a URL for use in an HTML attribute. Strips harmful protocols. */function check_url($uri) {  return filter_xss_bad_protocol($uri, FALSE);}/** * @defgroup format Formatting * @{ * Functions to format numbers, strings, dates, etc. *//** * Formats an RSS channel. * * Arbitrary elements may be added using the $args associative array. */function format_rss_channel($title, $link, $description, $items, $langcode = NULL, $args = array()) {  global $language;  $langcode = $langcode ? $langcode : $language->language;  $output = "<channel>\n";  $output .= ' <title>'. check_plain($title) ."</title>\n";  $output .= ' <link>'. check_url($link) ."</link>\n";  // The RSS 2.0 "spec" doesn't indicate HTML can be used in the description.  // We strip all HTML tags, but need to prevent double encoding from properly  // escaped source data (such as &amp becoming &amp;amp;).  $output .= ' <description>'. check_plain(decode_entities(strip_tags($description))) ."</description>\n";  $output .= ' <language>'. check_plain($langcode) ."</language>\n";  $output .= format_xml_elements($args);  $output .= $items;  $output .= "</channel>\n";  return $output;}/** * Format a single RSS item. * * Arbitrary elements may be added using the $args associative array. */function format_rss_item($title, $link, $description, $args = array()) {  $output = "<item>\n";  $output .= ' <title>'. check_plain($title) ."</title>\n";  $output .= ' <link>'. check_url($link) ."</link>\n";  $output .= ' <description>'. check_plain($description) ."</description>\n";  $output .= format_xml_elements($args);  $output .= "</item>\n";  return $output;}/** * Format XML elements. * * @param $array *   An array where each item represent an element and is either a: *   - (key => value) pair (<key>value</key>) *   - Associative array with fields: *     - 'key': element name *     - 'value': element contents *     - 'attributes': associative array of element attributes * * In both cases, 'value' can be a simple string, or it can be another array * with the same format as $array itself for nesting. */function format_xml_elements($array) {  $output = '';  foreach ($array as $key => $value) {    if (is_numeric($key)) {      if ($value['key']) {        $output .= ' <'. $value['key'];        if (isset($value['attributes']) && is_array($value['attributes'])) {          $output .= drupal_attributes($value['attributes']);        }        if (isset($value['value']) && $value['value'] != '') {          $output .= '>'. (is_array($value['value']) ? format_xml_elements($value['value']) : check_plain($value['value'])) .'</'. $value['key'] .">\n";        }        else {          $output .= " />\n";        }      }    }    else {      $output .= ' <'. $key .'>'. (is_array($value) ? format_xml_elements($value) : check_plain($value)) ."</$key>\n";    }  }  return $output;}/** * Format a string containing a count of items. * * This function ensures that the string is pluralized correctly. Since t() is * called by this function, make sure not to pass already-localized strings to * it. * * For example: * @code *   $output = format_plural($node->comment_count, '1 comment', '@count comments'); * @endcode * * Example with additional replacements: * @code *   $output = format_plural($update_count, *     'Changed the content type of 1 post from %old-type to %new-type.', *     'Changed the content type of @count posts from %old-type to %new-type.', *     array('%old-type' => $info->old_type, '%new-type' => $info->new_type))); * @endcode * * @param $count *   The item count to display. * @param $singular *   The string for the singular case. Please make sure it is clear this is *   singular, to ease translation (e.g. use "1 new comment" instead of "1 new"). *   Do not use @count in the singular string. * @param $plural *   The string for the plural case. Please make sure it is clear this is plural, *   to ease translation. Use @count in place of the item count, as in "@count *   new comments". * @param $args *   An associative array of replacements to make after translation. Incidences *   of any key in this array are replaced with the corresponding value. *   Based on the first character of the key, the value is escaped and/or themed: *    - !variable: inserted as is *    - @variable: escape plain text to HTML (check_plain) *    - %variable: escape text and theme as a placeholder for user-submitted *      content (check_plain + theme_placeholder) *   Note that you do not need to include @count in this array. *   This replacement is done automatically for the plural case. * @param $langcode *   Optional language code to translate to a language other than *   what is used to display the page. * @return *   A translated string. */function format_plural($count, $singular, $plural, $args = array(), $langcode = NULL) {  $args['@count'] = $count;  if ($count == 1) {    return t($singular, $args, $langcode);  }  // Get the plural index through the gettext formula.  $index = (function_exists('locale_get_plural')) ? locale_get_plural($count, $langcode) : -1;  // Backwards compatibility.  if ($index < 0) {    return t($plural, $args, $langcode);  }  else {    switch ($index) {      case "0":        return t($singular, $args, $langcode);      case "1":        return t($plural, $args, $langcode);      default:        unset($args['@count']);        $args['@count['. $index .']'] = $count;        return t(strtr($plural, array('@count' => '@count['. $index .']')), $args, $langcode);    }  }}/** * Parse a given byte count. * * @param $size *   A size expressed as a number of bytes with optional SI size and unit *   suffix (e.g. 2, 3K, 5MB, 10G). * @return *   An integer representation of the size. */function parse_size($size) {  $suffixes = array(    '' => 1,    'k' => 1024,    'm' => 1048576, // 1024 * 1024    'g' => 1073741824, // 1024 * 1024 * 1024  );  if (preg_match('/([0-9]+)\s*(k|m|g)?(b?(ytes?)?)/i', $size, $match)) {    return $match[1] * $suffixes[drupal_strtolower($match[2])];  }}/** * Generate a string representation for the given byte count. * * @param $size *   A size in bytes. * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   A translated string representation of the size. */function format_size($size, $langcode = NULL) {  if ($size < 1024) {    return format_plural($size, '1 byte', '@count bytes', array(), $langcode);  }  else {    $size = round($size / 1024, 2);    $suffix = t('KB', array(), $langcode);    if ($size >= 1024) {      $size = round($size / 1024, 2);      $suffix = t('MB', array(), $langcode);    }    return t('@size @suffix', array('@size' => $size, '@suffix' => $suffix), $langcode);  }}/** * Format a time interval with the requested granularity. * * @param $timestamp *   The length of the interval in seconds. * @param $granularity *   How many different units to display in the string. * @param $langcode *   Optional language code to translate to a language other than *   what is used to display the page. * @return *   A translated string representation of the interval. */function format_interval($timestamp, $granularity = 2, $langcode = NULL) {  $units = array('1 year|@count years' => 31536000, '1 week|@count weeks' => 604800, '1 day|@count days' => 86400, '1 hour|@count hours' => 3600, '1 min|@count min' => 60, '1 sec|@count sec' => 1);  $output = '';  foreach ($units as $key => $value) {    $key = explode('|', $key);    if ($timestamp >= $value) {      $output .= ($output ? ' ' : '') . format_plural(floor($timestamp / $value), $key[0], $key[1], array(), $langcode);      $timestamp %= $value;      $granularity--;    }    if ($granularity == 0) {      break;    }  }  return $output ? $output : t('0 sec', array(), $langcode);}/** * Format a date with the given configured format or a custom format string. * * Drupal allows administrators to select formatting strings for 'small', * 'medium' and 'large' date formats. This function can handle these formats, * as well as any custom format. * * @param $timestamp *   The exact date to format, as a UNIX timestamp. * @param $type *   The format to use. Can be "small", "medium" or "large" for the preconfigured *   date formats. If "custom" is specified, then $format is required as well. * @param $format *   A PHP date format string as required by date(). A backslash should be used *   before a character to avoid interpreting the character as part of a date *   format. * @param $timezone *   Time zone offset in seconds; if omitted, the user's time zone is used. * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   A translated date string in the requested format. */function format_date($timestamp, $type = 'medium', $format = '', $timezone = NULL, $langcode = NULL) {  if (!isset($timezone)) {    global $user;    if (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone)) {      $timezone = $user->timezone;    }    else {      $timezone = variable_get('date_default_timezone', 0);    }  }  $timestamp += $timezone;  switch ($type) {    case 'small':      $format = variable_get('date_format_short', 'm/d/Y - H:i');      break;    case 'large':      $format = variable_get('date_format_long', 'l, F j, Y - H:i');      break;    case 'custom':      // No change to format.      break;    case 'medium':    default:      $format = variable_get('date_format_medium', 'D, m/d/Y - H:i');  }  $max = strlen($format);  $date = '';  for ($i = 0; $i < $max; $i++) {    $c = $format[$i];    if (strpos('AaDlM', $c) !== FALSE) {      $date .= t(gmdate($c, $timestamp), array(), $langcode);    }    else if ($c == 'F') {      // Special treatment for long month names: May is both an abbreviation      // and a full month name in English, but other languages have      // different abbreviations.      $date .= trim(t('!long-month-name '. gmdate($c, $timestamp), array('!long-month-name' => ''), $langcode));    }    else if (strpos('BdgGhHiIjLmnsStTUwWYyz', $c) !== FALSE) {      $date .= gmdate($c, $timestamp);    }    else if ($c == 'r') {      $date .= format_date($timestamp - $timezone, 'custom', 'D, d M Y H:i:s O', $timezone, $langcode);    }    else if ($c == 'O') {      $date .= sprintf('%s%02d%02d', ($timezone < 0 ? '-' : '+'), abs($timezone / 3600), abs($timezone % 3600) / 60);    }    else if ($c == 'Z') {      $date .= $timezone;    }    else if ($c == '\\') {      $date .= $format[++$i];    }    else {      $date .= $c;    }  }  return $date;}/** * @} End of "defgroup format". *//** * Generate a URL from a Drupal menu path. Will also pass-through existing URLs. * * @param $path *   The Drupal path being linked to, such as "admin/content/node", or an *   existing URL like "http://drupal.org/".  The special path *   '<front>' may also be given and will generate the site's base URL. * @param $options *   An associative array of additional options, with the following keys: *   - 'query' *       A URL-encoded query string to append to the link, or an array of query *       key/value-pairs without any URL-encoding. *   - 'fragment' *       A fragment identifier (or named anchor) to append to the link. *       Do not include the '#' character. *   - 'absolute' (default FALSE) *       Whether to force the output to be an absolute link (beginning with *       http:). Useful for links that will be displayed outside the site, such *       as in an RSS feed. *   - 'alias' (default FALSE) *       Whether the given path is an alias already. *   - 'external' *       Whether the given path is an external URL. *   - 'language' *       An optional language object. Used to build the URL to link to and *       look up the proper alias for the link. *   - 'base_url' *       Only used internally, to modify the base URL when a language dependent *       URL requires so. *   - 'prefix' *       Only used internally, to modify the path when a language dependent URL *       requires so. * @return *   A string containing a URL to the given path. * * When creating links in modules, consider whether l() could be a better * alternative than url(). */function url($path = NULL, $options = array()) {  // Merge in defaults.  $options += array(    'fragment' => '',    'query' => '',    'absolute' => FALSE,    'alias' => FALSE,    'prefix' => ''  );  if (!isset($options['external'])) {    // Return an external link if $path contains an allowed absolute URL.    // Only call the slow filter_xss_bad_protocol if $path contains a ':' before    // any / ? or #.    $colonpos = strpos($path, ':');    $options['external'] = ($colonpos !== FALSE && !preg_match('![/?#]!', substr($path, 0, $colonpos)) && filter_xss_bad_protocol($path, FALSE) == check_plain($path));  }  // May need language dependent rewriting if language.inc is present.  if (function_exists('language_url_rewrite')) {    language_url_rewrite($path, $options);  }  if ($options['fragment']) {    $options['fragment'] = '#'. $options['fragment'];  }  if (is_array($options['query'])) {    $options['query'] = drupal_query_string_encode($options['query']);  }  if ($options['external']) {    // Split off the fragment.    if (strpos($path, '#') !== FALSE) {      list($path, $old_fragment) = explode('#', $path, 2);      if (isset($old_fragment) && !$options['fragment']) {        $options['fragment'] = '#'. $old_fragment;      }    }    // Append the query.    if ($options['query']) {      $path .= (strpos($path, '?') !== FALSE ? '&' : '?') . $options['query'];    }    // Reassemble.    return $path . $options['fragment'];  }  global $base_url;  static $script;  if (!isset($script)) {    // On some web servers, such as IIS, we can't omit "index.php". So, we    // generate "index.php?q=foo" instead of "?q=foo" on anything that is not    // Apache.    $script = (strpos($_SERVER['SERVER_SOFTWARE'], 'Apache') === FALSE) ? 'index.php' : '';  }  if (!isset($options['base_url'])) {    // The base_url might be rewritten from the language rewrite in domain mode.    $options['base_url'] = $base_url;  }  // Preserve the original path before aliasing.  $original_path = $path;  // The special path '<front>' links to the default front page.  if ($path == '<front>') {    $path = '';  }  elseif (!empty($path) && !$options['alias']) {    $path = drupal_get_path_alias($path, isset($options['language']) ? $options['language']->language : '');  }  if (function_exists('custom_url_rewrite_outbound')) {    // Modules may alter outbound links by reference.    custom_url_rewrite_outbound($path, $options, $original_path);  }  $base = $options['absolute'] ? $options['base_url'] .'/' : base_path();  $prefix = empty($path) ? rtrim($options['prefix'], '/') : $options['prefix'];  $path = drupal_urlencode($prefix . $path);  if (variable_get('clean_url', '0')) {    // With Clean URLs.    if ($options['query']) {      return $base . $path .'?'. $options['query'] . $options['fragment'];    }    else {      return $base . $path . $options['fragment'];    }  }  else {    // Without Clean URLs.    $variables = array();    if (!empty($path)) {      $variables[] = 'q='. $path;    }    if (!empty($options['query'])) {      $variables[] = $options['query'];    }    if ($query = join('&', $variables)) {      return $base . $script .'?'. $query . $options['fragment'];    }    else {      return $base . $options['fragment'];    }  }}/** * Format an attribute string to insert in a tag. * * @param $attributes *   An associative array of HTML attributes. * @return *   An HTML string ready for insertion in a tag. */function drupal_attributes($attributes = array()) {  if (is_array($attributes)) {    $t = '';    foreach ($attributes as $key => $value) {      $t .= " $key=".'"'. check_plain($value) .'"';    }    return $t;  }}/** * Format an internal Drupal link. * * This function correctly handles aliased paths, and allows themes to highlight * links to the current page correctly, so all internal links output by modules * should be generated by this function if possible. * * @param $text *   The text to be enclosed with the anchor tag. * @param $path *   The Drupal path being linked to, such as "admin/content/node". Can be an *   external or internal URL. *     - If you provide the full URL, it will be considered an external URL. *     - If you provide only the path (e.g. "admin/content/node"), it is *       considered an internal link. In this case, it must be a system URL *       as the url() function will generate the alias. *     - If you provide '<front>', it generates a link to the site's *       base URL (again via the url() function). *     - If you provide a path, and 'alias' is set to TRUE (see below), it is *       used as is. * @param $options *   An associative array of additional options, with the following keys: *     - 'attributes' *       An associative array of HTML attributes to apply to the anchor tag. *     - 'query' *       A query string to append to the link, or an array of query key/value *       properties. *     - 'fragment' *       A fragment identifier (named anchor) to append to the link. *       Do not include the '#' character. *     - 'absolute' (default FALSE) *       Whether to force the output to be an absolute link (beginning with *       http:). Useful for links that will be displayed outside the site, such *       as in an RSS feed. *     - 'html' (default FALSE) *       Whether the title is HTML, or just plain-text. For example for making *       an image a link, this must be set to TRUE, or else you will see the *       escaped HTML. *     - 'alias' (default FALSE) *       Whether the given path is an alias already. * @return *   an HTML string containing a link to the given path. */function l($text, $path, $options = array()) {  global $language;  // Merge in defaults.  $options += array(      'attributes' => array(),      'html' => FALSE,    );  // Append active class.  if (($path == $_GET['q'] || ($path == '<front>' && drupal_is_front_page())) &&      (empty($options['language']) || $options['language']->language == $language->language)) {    if (isset($options['attributes']['class'])) {      $options['attributes']['class'] .= ' active';    }    else {      $options['attributes']['class'] = 'active';    }  }  // Remove all HTML and PHP tags from a tooltip. For best performance, we act only  // if a quick strpos() pre-check gave a suspicion (because strip_tags() is expensive).  if (isset($options['attributes']['title']) && strpos($options['attributes']['title'], '<') !== FALSE) {    $options['attributes']['title'] = strip_tags($options['attributes']['title']);  }  return '<a href="'. check_url(url($path, $options)) .'"'. drupal_attributes($options['attributes']) .'>'. ($options['html'] ? $text : check_plain($text)) .'</a>';}/** * Perform end-of-request tasks. * * This function sets the page cache if appropriate, and allows modules to * react to the closing of the page by calling hook_exit(). */function drupal_page_footer() {  if (variable_get('cache', CACHE_DISABLED) != CACHE_DISABLED) {    page_set_cache();  }  module_invoke_all('exit');}/** * Form an associative array from a linear array. * * This function walks through the provided array and constructs an associative * array out of it. The keys of the resulting array will be the values of the * input array. The values will be the same as the keys unless a function is * specified, in which case the output of the function is used for the values * instead. * * @param $array *   A linear array. * @param $function *   A name of a function to apply to all values before output. * @result *   An associative array. */function drupal_map_assoc($array, $function = NULL) {  if (!isset($function)) {    $result = array();    foreach ($array as $value) {      $result[$value] = $value;    }    return $result;  }  elseif (function_exists($function)) {    $result = array();    foreach ($array as $value) {      $result[$value] = $function($value);    }    return $result;  }}/** * Evaluate a string of PHP code. * * This is a wrapper around PHP's eval(). It uses output buffering to capture both * returned and printed text. Unlike eval(), we require code to be surrounded by * <?php ?> tags; in other words, we evaluate the code as if it were a stand-alone * PHP file. * * Using this wrapper also ensures that the PHP code which is evaluated can not * overwrite any variables in the calling code, unlike a regular eval() call. * * @param $code *   The code to evaluate. * @return *   A string containing the printed output of the code, followed by the returned *   output of the code. */function drupal_eval($code) {  global $theme_path, $theme_info, $conf;  // Store current theme path.  $old_theme_path = $theme_path;  // Restore theme_path to the theme, as long as drupal_eval() executes,  // so code evaluted will not see the caller module as the current theme.  // If theme info is not initialized get the path from theme_default.  if (!isset($theme_info)) {    $theme_path = drupal_get_path('theme', $conf['theme_default']);  }  else {    $theme_path = dirname($theme_info->filename);  }  ob_start();  print eval('?>'. $code);  $output = ob_get_contents();  ob_end_clean();  // Recover original theme path.  $theme_path = $old_theme_path;  return $output;}/** * Returns the path to a system item (module, theme, etc.). * * @param $type *   The type of the item (i.e. theme, theme_engine, module). * @param $name *   The name of the item for which the path is requested. * * @return *   The path to the requested item. */function drupal_get_path($type, $name) {  return dirname(drupal_get_filename($type, $name));}/** * Returns the base URL path of the Drupal installation. * At the very least, this will always default to /. */function base_path() {  return $GLOBALS['base_path'];}/** * Provide a substitute clone() function for PHP4. */function drupal_clone($object) {  return version_compare(phpversion(), '5.0') < 0 ? $object : clone($object);}/** * Add a <link> tag to the page's HEAD. */function drupal_add_link($attributes) {  drupal_set_html_head('<link'. drupal_attributes($attributes) .' />');}/** * Adds a CSS file to the stylesheet queue. * * @param $path *   (optional) The path to the CSS file relative to the base_path(), e.g., *   /modules/devel/devel.css. * *   Modules should always prefix the names of their CSS files with the module *   name, for example: system-menus.css rather than simply menus.css. Themes *   can override module-supplied CSS files based on their filenames, and this *   prefixing helps prevent confusing name collisions for theme developers. *   See drupal_get_css where the overrides are performed. * *   If the direction of the current language is right-to-left (Hebrew, *   Arabic, etc.), the function will also look for an RTL CSS file and append *   it to the list. The name of this file should have an '-rtl.css' suffix. *   For example a CSS file called 'name.css' will have a 'name-rtl.css' *   file added to the list, if exists in the same directory. This CSS file *   should contain overrides for properties which should be reversed or *   otherwise different in a right-to-left display. * @param $type *   (optional) The type of stylesheet that is being added. Types are: module *   or theme. * @param $media *   (optional) The media type for the stylesheet, e.g., all, print, screen. * @param $preprocess *   (optional) Should this CSS file be aggregated and compressed if this *   feature has been turned on under the performance section? * *   What does this actually mean? *   CSS preprocessing is the process of aggregating a bunch of separate CSS *   files into one file that is then compressed by removing all extraneous *   white space. * *   The reason for merging the CSS files is outlined quite thoroughly here: *   http://www.die.net/musings/page_load_time/ *   "Load fewer external objects. Due to request overhead, one bigger file *   just loads faster than two smaller ones half its size." * *   However, you should *not* preprocess every file as this can lead to *   redundant caches. You should set $preprocess = FALSE when: * *     - Your styles are only used rarely on the site. This could be a special *       admin page, the homepage, or a handful of pages that does not represent *       the majority of the pages on your site. * *   Typical candidates for caching are for example styles for nodes across *   the site, or used in the theme. * @return *   An array of CSS files. */function drupal_add_css($path = NULL, $type = 'module', $media = 'all', $preprocess = TRUE) {  static $css = array();  global $language;  // Create an array of CSS files for each media type first, since each type needs to be served  // to the browser differently.  if (isset($path)) {    // This check is necessary to ensure proper cascading of styles and is faster than an asort().    if (!isset($css[$media])) {      $css[$media] = array('module' => array(), 'theme' => array());    }    $css[$media][$type][$path] = $preprocess;    // If the current language is RTL, add the CSS file with RTL overrides.    if ($language->direction == LANGUAGE_RTL) {      $rtl_path = str_replace('.css', '-rtl.css', $path);      if (file_exists($rtl_path)) {        $css[$media][$type][$rtl_path] = $preprocess;      }    }  }  return $css;}/** * Returns a themed representation of all stylesheets that should be attached to the page. * * It loads the CSS in order, with 'module' first, then 'theme' afterwards. * This ensures proper cascading of styles so themes can easily override * module styles through CSS selectors. * * Themes may replace module-defined CSS files by adding a stylesheet with the * same filename. For example, themes/garland/system-menus.css would replace * modules/system/system-menus.css. This allows themes to override complete * CSS files, rather than specific selectors, when necessary. * * If the original CSS file is being overridden by a theme, the theme is * responsible for supplying an accompanying RTL CSS file to replace the * module's. * * @param $css *   (optional) An array of CSS files. If no array is provided, the default *   stylesheets array is used instead. * @return *   A string of XHTML CSS tags. */function drupal_get_css($css = NULL) {  $output = '';  if (!isset($css)) {    $css = drupal_add_css();  }  $no_module_preprocess = '';  $no_theme_preprocess = '';  $preprocess_css = (variable_get('preprocess_css', FALSE) && (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update'));  $directory = file_directory_path();  $is_writable = is_dir($directory) && is_writable($directory) && (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC);  // A dummy query-string is added to filenames, to gain control over  // browser-caching. The string changes on every update or full cache  // flush, forcing browsers to load a new copy of the files, as the  // URL changed.  $query_string = '?'. substr(variable_get('css_js_query_string', '0'), 0, 1);  foreach ($css as $media => $types) {    // If CSS preprocessing is off, we still need to output the styles.    // Additionally, go through any remaining styles if CSS preprocessing is on and output the non-cached ones.    foreach ($types as $type => $files) {      if ($type == 'module') {        // Setup theme overrides for module styles.        $theme_styles = array();        foreach (array_keys($css[$media]['theme']) as $theme_style) {          $theme_styles[] = basename($theme_style);        }      }      foreach ($types[$type] as $file => $preprocess) {        // If the theme supplies its own style using the name of the module style, skip its inclusion.        // This includes any RTL styles associated with its main LTR counterpart.        if ($type == 'module' && in_array(str_replace('-rtl.css', '.css', basename($file)), $theme_styles)) {          // Unset the file to prevent its inclusion when CSS aggregation is enabled.          unset($types[$type][$file]);          continue;        }        // Only include the stylesheet if it exists.        if (file_exists($file)) {          if (!$preprocess || !($is_writable && $preprocess_css)) {            // If a CSS file is not to be preprocessed and it's a module CSS file, it needs to *always* appear at the *top*,            // regardless of whether preprocessing is on or off.            if (!$preprocess && $type == 'module') {              $no_module_preprocess .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }            // If a CSS file is not to be preprocessed and it's a theme CSS file, it needs to *always* appear at the *bottom*,            // regardless of whether preprocessing is on or off.            else if (!$preprocess && $type == 'theme') {              $no_theme_preprocess .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }            else {              $output .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }          }        }      }    }    if ($is_writable && $preprocess_css) {      // Prefix filename to prevent blocking by firewalls which reject files      // starting with "ad*".      $filename = 'css_'. md5(serialize($types) . $query_string) .'.css';      $preprocess_file = drupal_build_css_cache($types, $filename);      $output .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $preprocess_file .'" />'."\n";    }  }  return $no_module_preprocess . $output . $no_theme_preprocess;}/** * Aggregate and optimize CSS files, putting them in the files directory. * * @param $types *   An array of types of CSS files (e.g., screen, print) to aggregate and *   compress into one file. * @param $filename *   The name of the aggregate CSS file. * @return *   The name of the CSS file. */function drupal_build_css_cache($types, $filename) {  $data = '';  // Create the css/ within the files folder.  $csspath = file_create_path('css');  file_check_directory($csspath, FILE_CREATE_DIRECTORY);  if (!file_exists($csspath .'/'. $filename)) {    // Build aggregate CSS file.    foreach ($types as $type) {      foreach ($type as $file => $cache) {        if ($cache) {          $contents = drupal_load_stylesheet($file, TRUE);          // Return the path to where this CSS file originated from.          $base = base_path() . dirname($file) .'/';          _drupal_build_css_path(NULL, $base);          // Prefix all paths within this CSS file, ignoring external and absolute paths.          $data .= preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $contents);        }      }    }    // Per the W3C specification at http://www.w3.org/TR/REC-CSS2/cascade.html#at-import,    // @import rules must proceed any other style, so we move those to the top.    $regexp = '/@import[^;]+;/i';    preg_match_all($regexp, $data, $matches);    $data = preg_replace($regexp, '', $data);    $data = implode('', $matches[0]) . $data;    // Create the CSS file.    file_save_data($data, $csspath .'/'. $filename, FILE_EXISTS_REPLACE);  }  return $csspath .'/'. $filename;}/** * Helper function for drupal_build_css_cache(). * * This function will prefix all paths within a CSS file. */function _drupal_build_css_path($matches, $base = NULL) {  static $_base;  // Store base path for preg_replace_callback.  if (isset($base)) {    $_base = $base;  }  // Prefix with base and remove '../' segments where possible.  $path = $_base . $matches[1];  $last = '';  while ($path != $last) {    $last = $path;    $path = preg_replace('`(^|/)(?!\.\./)([^/]+)/\.\./`', '$1', $path);  }  return 'url('. $path .')';}/** * Loads the stylesheet and resolves all @import commands. * * Loads a stylesheet and replaces @import commands with the contents of the * imported file. Use this instead of file_get_contents when processing * stylesheets. * * The returned contents are compressed removing white space and comments only * when CSS aggregation is enabled. This optimization will not apply for * color.module enabled themes with CSS aggregation turned off. * * @param $file *   Name of the stylesheet to be processed. * @param $optimize *   Defines if CSS contents should be compressed or not. * @return *   Contents of the stylesheet including the imported stylesheets. */function drupal_load_stylesheet($file, $optimize = NULL) {  static $_optimize;  // Store optimization parameter for preg_replace_callback with nested @import loops.  if (isset($optimize)) {    $_optimize = $optimize;  }  $contents = '';  if (file_exists($file)) {    // Load the local CSS stylesheet.    $contents = file_get_contents($file);    // Change to the current stylesheet's directory.    $cwd = getcwd();    chdir(dirname($file));    // Replaces @import commands with the actual stylesheet content.    // This happens recursively but omits external files.    $contents = preg_replace_callback('/@import\s*(?:url\()?[\'"]?(?![a-z]+:)([^\'"\()]+)[\'"]?\)?;/', '_drupal_load_stylesheet', $contents);    // Remove multiple charset declarations for standards compliance (and fixing Safari problems).    $contents = preg_replace('/^@charset\s+[\'"](\S*)\b[\'"];/i', '', $contents);    if ($_optimize) {      // Perform some safe CSS optimizations.      $contents = preg_replace('<        \s*([@{}:;,]|\)\s|\s\()\s* |  # Remove whitespace around separators, but keep space around parentheses.        /\*([^*\\\\]|\*(?!/))+\*/     # Remove comments that are not CSS hacks.        >x', '\1', $contents);    }    // Change back directory.    chdir($cwd);  }  return $contents;}/** * Loads stylesheets recursively and returns contents with corrected paths. * * This function is used for recursive loading of stylesheets and * returns the stylesheet content with all url() paths corrected. */function _drupal_load_stylesheet($matches) {  $filename = $matches[1];  // Load the imported stylesheet and replace @import commands in there as well.  $file = drupal_load_stylesheet($filename);  // Alter all url() paths, but not external.  return preg_replace('/url\(([\'"]?)(?![a-z]+:)([^\'")]+)[\'"]?\)?;/i', 'url(\1'. dirname($filename) .'/', $file);}/** * Delete all cached CSS files. */function drupal_clear_css_cache() {  file_scan_directory(file_create_path('css'), '.*', array('.', '..', 'CVS'), 'file_delete', TRUE);}/** * Add a JavaScript file, setting or inline code to the page. * * The behavior of this function depends on the parameters it is called with. * Generally, it handles the addition of JavaScript to the page, either as * reference to an existing file or as inline code. The following actions can be * performed using this function: * * - Add a file ('core', 'module' and 'theme'): *   Adds a reference to a JavaScript file to the page. JavaScript files *   are placed in a certain order, from 'core' first, to 'module' and finally *   'theme' so that files, that are added later, can override previously added *   files with ease. * * - Add inline JavaScript code ('inline'): *   Executes a piece of JavaScript code on the current page by placing the code *   directly in the page. This can, for example, be useful to tell the user that *   a new message arrived, by opening a pop up, alert box etc. * * - Add settings ('setting'): *   Adds a setting to Drupal's global storage of JavaScript settings. Per-page *   settings are required by some modules to function properly. The settings *   will be accessible at Drupal.settings. * * @param $data *   (optional) If given, the value depends on the $type parameter: *   - 'core', 'module' or 'theme': Path to the file relative to base_path(). *   - 'inline': The JavaScript code that should be placed in the given scope. *   - 'setting': An array with configuration options as associative array. The *       array is directly placed in Drupal.settings. You might want to wrap your *       actual configuration settings in another variable to prevent the pollution *       of the Drupal.settings namespace. * @param $type *   (optional) The type of JavaScript that should be added to the page. Allowed *   values are 'core', 'module', 'theme', 'inline' and 'setting'. You *   can, however, specify any value. It is treated as a reference to a JavaScript *   file. Defaults to 'module'. * @param $scope *   (optional) The location in which you want to place the script. Possible *   values are 'header' and 'footer' by default. If your theme implements *   different locations, however, you can also use these. * @param $defer *   (optional) If set to TRUE, the defer attribute is set on the <script> tag. *   Defaults to FALSE. This parameter is not used with $type == 'setting'. * @param $cache *   (optional) If set to FALSE, the JavaScript file is loaded anew on every page *   call, that means, it is not cached. Defaults to TRUE. Used only when $type *   references a JavaScript file. * @param $preprocess *   (optional) Should this JS file be aggregated if this *   feature has been turned on under the performance section? * @return *   If the first parameter is NULL, the JavaScript array that has been built so *   far for $scope is returned. If the first three parameters are NULL, *   an array with all scopes is returned. */function drupal_add_js($data = NULL, $type = 'module', $scope = 'header', $defer = FALSE, $cache = TRUE, $preprocess = TRUE) {  static $javascript = array();  if (isset($data)) {    // Add jquery.js and drupal.js, as well as the basePath setting, the    // first time a Javascript file is added.    if (empty($javascript)) {      $javascript['header'] = array(        'core' => array(          'misc/jquery.js' => array('cache' => TRUE, 'defer' => FALSE, 'preprocess' => TRUE),          'misc/drupal.js' => array('cache' => TRUE, 'defer' => FALSE, 'preprocess' => TRUE),        ),        'module' => array(),        'theme' => array(),        'setting' => array(          array('basePath' => base_path()),        ),        'inline' => array(),      );    }    if (isset($scope) && !isset($javascript[$scope])) {      $javascript[$scope] = array('core' => array(), 'module' => array(), 'theme' => array(), 'setting' => array(), 'inline' => array());    }    if (isset($type) && isset($scope) && !isset($javascript[$scope][$type])) {      $javascript[$scope][$type] = array();    }    switch ($type) {      case 'setting':        $javascript[$scope][$type][] = $data;        break;      case 'inline':        $javascript[$scope][$type][] = array('code' => $data, 'defer' => $defer);        break;      default:        // If cache is FALSE, don't preprocess the JS file.        $javascript[$scope][$type][$data] = array('cache' => $cache, 'defer' => $defer, 'preprocess' => (!$cache ? FALSE : $preprocess));    }  }  if (isset($scope)) {    if (isset($javascript[$scope])) {      return $javascript[$scope];    }    else {      return array();    }  }  else {    return $javascript;  }}/** * Returns a themed presentation of all JavaScript code for the current page. * * References to JavaScript files are placed in a certain order: first, all * 'core' files, then all 'module' and finally all 'theme' JavaScript files * are added to the page. Then, all settings are output, followed by 'inline' * JavaScript code. If running update.php, all preprocessing is disabled. * * @param $scope *   (optional) The scope for which the JavaScript rules should be returned. *   Defaults to 'header'. * @param $javascript *   (optional) An array with all JavaScript code. Defaults to the default *   JavaScript array for the given scope. * @return *   All JavaScript code segments and includes for the scope as HTML tags. */function drupal_get_js($scope = 'header', $javascript = NULL) {  if ((!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') && function_exists('locale_update_js_files')) {    locale_update_js_files();  }  if (!isset($javascript)) {    $javascript = drupal_add_js(NULL, NULL, $scope);  }  if (empty($javascript)) {    return '';  }  $output = '';  $preprocessed = '';  $no_preprocess = array('core' => '', 'module' => '', 'theme' => '');  $files = array();  $preprocess_js = (variable_get('preprocess_js', FALSE) && (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update'));  $directory = file_directory_path();  $is_writable = is_dir($directory) && is_writable($directory) && (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC);  // A dummy query-string is added to filenames, to gain control over  // browser-caching. The string changes on every update or full cache  // flush, forcing browsers to load a new copy of the files, as the  // URL changed. Files that should not be cached (see drupal_add_js())  // get time() as query-string instead, to enforce reload on every  // page request.  $query_string = '?'. substr(variable_get('css_js_query_string', '0'), 0, 1);  // For inline Javascript to validate as XHTML, all Javascript containing  // XHTML needs to be wrapped in CDATA. To make that backwards compatible  // with HTML 4, we need to comment out the CDATA-tag.  $embed_prefix = "\n<!--//--><![CDATA[//><!--\n";  $embed_suffix = "\n//--><!]]>\n";  foreach ($javascript as $type => $data) {    if (!$data) continue;    switch ($type) {      case 'setting':        $output .= '<script type="text/javascript">' . $embed_prefix . 'jQuery.extend(Drupal.settings, ' . drupal_to_js(call_user_func_array('array_merge_recursive', $data)) . ");" . $embed_suffix . "</script>\n";        break;      case 'inline':        foreach ($data as $info) {          $output .= '<script type="text/javascript"' . ($info['defer'] ? ' defer="defer"' : '') . '>' . $embed_prefix . $info['code'] . $embed_suffix . "</script>\n";        }        break;      default:        // If JS preprocessing is off, we still need to output the scripts.        // Additionally, go through any remaining scripts if JS preprocessing is on and output the non-cached ones.        foreach ($data as $path => $info) {          if (!$info['preprocess'] || !$is_writable || !$preprocess_js) {            $no_preprocess[$type] .= '<script type="text/javascript"'. ($info['defer'] ? ' defer="defer"' : '') .' src="'. base_path() . $path . ($info['cache'] ? $query_string : '?'. time()) ."\"></script>\n";          }          else {            $files[$path] = $info;          }        }    }  }  // Aggregate any remaining JS files that haven't already been output.  if ($is_writable && $preprocess_js && count($files) > 0) {    // Prefix filename to prevent blocking by firewalls which reject files    // starting with "ad*".    $filename = 'js_'. md5(serialize($files) . $query_string) .'.js';    $preprocess_file = drupal_build_js_cache($files, $filename);    $preprocessed .= '<script type="text/javascript" src="'. base_path() . $preprocess_file .'"></script>'."\n";  }  // Keep the order of JS files consistent as some are preprocessed and others are not.  // Make sure any inline or JS setting variables appear last after libraries have loaded.  $output = $preprocessed . implode('', $no_preprocess) . $output;  return $output;}/** * Assist in adding the tableDrag JavaScript behavior to a themed table. * * Draggable tables should be used wherever an outline or list of sortable items * needs to be arranged by an end-user. Draggable tables are very flexible and * can manipulate the value of form elements placed within individual columns. * * To set up a table to use drag and drop in place of weight select-lists or * in place of a form that contains parent relationships, the form must be * themed into a table. The table must have an id attribute set. If using * theme_table(), the id may be set as such: * @code * $output = theme('table', $header, $rows, array('id' => 'my-module-table')); * return $output; * @endcode * * In the theme function for the form, a special class must be added to each * form element within the same column, "grouping" them together. * * In a situation where a single weight column is being sorted in the table, the * classes could be added like this (in the theme function): * @code * $form['my_elements'][$delta]['weight']['#attributes']['class'] = "my-elements-weight"; * @endcode * * Each row of the table must also have a class of "draggable" in order to enable the * drag handles: * @code * $row = array(...); * $rows[] = array( *   'data' => $row, *   'class' => 'draggable', * ); * @endcode * * When tree relationships are present, the two additional classes * 'tabledrag-leaf' and 'tabledrag-root' can be used to refine the behavior: * - Rows with the 'tabledrag-leaf' class cannot have child rows. * - Rows with the 'tabledrag-root' class cannot be nested under a parent row. * * Calling drupal_add_tabledrag() would then be written as such: * @code * drupal_add_tabledrag('my-module-table', 'order', 'sibling', 'my-elements-weight'); * @endcode * * In a more complex case where there are several groups in one column (such as * the block regions on the admin/build/block page), a separate subgroup class * must also be added to differentiate the groups. * @code * $form['my_elements'][$region][$delta]['weight']['#attributes']['class'] = "my-elements-weight my-elements-weight-". $region; * @endcode * * $group is still 'my-element-weight', and the additional $subgroup variable * will be passed in as 'my-elements-weight-'. $region. This also means that * you'll need to call drupal_add_tabledrag() once for every region added. * * @code * foreach ($regions as $region) { *   drupal_add_tabledrag('my-module-table', 'order', 'sibling', 'my-elements-weight', 'my-elements-weight-'. $region); * } * @endcode * * In a situation where tree relationships are present, adding multiple * subgroups is not necessary, because the table will contain indentations that * provide enough information about the sibling and parent relationships. * See theme_menu_overview_form() for an example creating a table containing * parent relationships. * * Please note that this function should be called from the theme layer, such as * in a .tpl.php file, theme_ function, or in a template_preprocess function, * not in a form declartion. Though the same JavaScript could be added to the * page using drupal_add_js() directly, this function helps keep template files * clean and readable. It also prevents tabledrag.js from being added twice * accidentally. * * @param $table_id *   String containing the target table's id attribute. If the table does not *   have an id, one will need to be set, such as <table id="my-module-table">. * @param $action *   String describing the action to be done on the form item. Either 'match' *   'depth', or 'order'. Match is typically used for parent relationships. *   Order is typically used to set weights on other form elements with the same *   group. Depth updates the target element with the current indentation. * @param $relationship *   String describing where the $action variable should be performed. Either *   'parent', 'sibling', 'group', or 'self'. Parent will only look for fields *   up the tree. Sibling will look for fields in the same group in rows above *   and below it. Self affects the dragged row itself. Group affects the *   dragged row, plus any children below it (the entire dragged group). * @param $group *   A class name applied on all related form elements for this action. * @param $subgroup *   (optional) If the group has several subgroups within it, this string should *   contain the class name identifying fields in the same subgroup. * @param $source *   (optional) If the $action is 'match', this string should contain the class *   name identifying what field will be used as the source value when matching *   the value in $subgroup. * @param $hidden *   (optional) The column containing the field elements may be entirely hidden *   from view dynamically when the JavaScript is loaded. Set to FALSE if the *   column should not be hidden. * @param $limit *   (optional) Limit the maximum amount of parenting in this table. * @see block-admin-display-form.tpl.php * @see theme_menu_overview_form() */function drupal_add_tabledrag($table_id, $action, $relationship, $group, $subgroup = NULL, $source = NULL, $hidden = TRUE, $limit = 0) {  static $js_added = FALSE;  if (!$js_added) {    drupal_add_js('misc/tabledrag.js', 'core');    $js_added = TRUE;  }  // If a subgroup or source isn't set, assume it is the same as the group.  $target = isset($subgroup) ? $subgroup : $group;  $source = isset($source) ? $source : $target;  $settings['tableDrag'][$table_id][$group][] = array(    'target' => $target,    'source' => $source,    'relationship' => $relationship,    'action' => $action,    'hidden' => $hidden,    'limit' => $limit,  );  drupal_add_js($settings, 'setting');}/** * Aggregate JS files, putting them in the files directory. * * @param $files *   An array of JS files to aggregate and compress into one file. * @param $filename *   The name of the aggregate JS file. * @return *   The name of the JS file. */function drupal_build_js_cache($files, $filename) {  $contents = '';  // Create the js/ within the files folder.  $jspath = file_create_path('js');  file_check_directory($jspath, FILE_CREATE_DIRECTORY);  if (!file_exists($jspath .'/'. $filename)) {    // Build aggregate JS file.    foreach ($files as $path => $info) {      if ($info['preprocess']) {        // Append a ';' after each JS file to prevent them from running together.        $contents .= file_get_contents($path) .';';      }    }    // Create the JS file.    file_save_data($contents, $jspath .'/'. $filename, FILE_EXISTS_REPLACE);  }  return $jspath .'/'. $filename;}/** * Delete all cached JS files. */function drupal_clear_js_cache() {  file_scan_directory(file_create_path('js'), '.*', array('.', '..', 'CVS'), 'file_delete', TRUE);  variable_set('javascript_parsed', array());}/** * Converts a PHP variable into its Javascript equivalent. * * We use HTML-safe strings, i.e. with <, > and & escaped. */function drupal_to_js($var) {  switch (gettype($var)) {    case 'boolean':      return $var ? 'true' : 'false'; // Lowercase necessary!    case 'integer':    case 'double':      return $var;    case 'resource':    case 'string':      return '"'. str_replace(array("\r", "\n", "<", ">", "&"),                              array('\r', '\n', '\x3c', '\x3e', '\x26'),                              addslashes($var)) .'"';    case 'array':      // Arrays in JSON can't be associative. If the array is empty or if it      // has sequential whole number keys starting with 0, it's not associative      // so we can go ahead and convert it as an array.      if (empty ($var) || array_keys($var) === range(0, sizeof($var) - 1)) {        $output = array();        foreach ($var as $v) {          $output[] = drupal_to_js($v);        }        return '[ '. implode(', ', $output) .' ]';      }      // Otherwise, fall through to convert the array as an object.    case 'object':      $output = array();      foreach ($var as $k => $v) {        $output[] = drupal_to_js(strval($k)) .': '. drupal_to_js($v);      }      return '{ '. implode(', ', $output) .' }';    default:      return 'null';  }}/** * Return data in JSON format. * * This function should be used for JavaScript callback functions returning * data in JSON format. It sets the header for JavaScript output. * * @param $var *   (optional) If set, the variable will be converted to JSON and output. */function drupal_json($var = NULL) {  // We are returning JavaScript, so tell the browser.  drupal_set_header('Content-Type: text/javascript; charset=utf-8');  if (isset($var)) {    echo drupal_to_js($var);  }}/** * Wrapper around urlencode() which avoids Apache quirks. * * Should be used when placing arbitrary data in an URL. Note that Drupal paths * are urlencoded() when passed through url() and do not require urlencoding() * of individual components. * * Notes: * - For esthetic reasons, we do not escape slashes. This also avoids a 'feature' *   in Apache where it 404s on any path containing '%2F'. * - mod_rewrite unescapes %-encoded ampersands, hashes, and slashes when clean *   URLs are used, which are interpreted as delimiters by PHP. These *   characters are double escaped so PHP will still see the encoded version. * - With clean URLs, Apache changes '//' to '/', so every second slash is *   double escaped. * - This function should only be used on paths, not on query string arguments, *   otherwise unwanted double encoding will occur. * * @param $text *   String to encode */function drupal_urlencode($text) {  if (variable_get('clean_url', '0')) {    return str_replace(array('%2F', '%26', '%23', '//'),                       array('/', '%2526', '%2523', '/%252F'),                       rawurlencode($text));  }  else {    return str_replace('%2F', '/', rawurlencode($text));  }}/** * Ensure the private key variable used to generate tokens is set. * * @return *   The private key. */function drupal_get_private_key() {  if (!($key = variable_get('drupal_private_key', 0))) {    $key = md5(uniqid(mt_rand(), true)) . md5(uniqid(mt_rand(), true));    variable_set('drupal_private_key', $key);  }  return $key;}/** * Generate a token based on $value, the current user session and private key. * * @param $value *   An additional value to base the token on. */function drupal_get_token($value = '') {  $private_key = drupal_get_private_key();  return md5(session_id() . $value . $private_key);}/** * Validate a token based on $value, the current user session and private key. * * @param $token *   The token to be validated. * @param $value *   An additional value to base the token on. * @param $skip_anonymous *   Set to true to skip token validation for anonymous users. * @return *   True for a valid token, false for an invalid token. When $skip_anonymous *   is true, the return value will always be true for anonymous users. */function drupal_valid_token($token, $value = '', $skip_anonymous = FALSE) {  global $user;  return (($skip_anonymous && $user->uid == 0) || ($token == md5(session_id() . $value . variable_get('drupal_private_key', ''))));}/** * Performs one or more XML-RPC request(s). * * @param $url *   An absolute URL of the XML-RPC endpoint. *     Example: *     http://www.example.com/xmlrpc.php * @param ... *   For one request: *     The method name followed by a variable number of arguments to the method. *   For multiple requests (system.multicall): *     An array of call arrays. Each call array follows the pattern of the single *     request: method name followed by the arguments to the method. * @return *   For one request: *     Either the return value of the method on success, or FALSE. *     If FALSE is returned, see xmlrpc_errno() and xmlrpc_error_msg(). *   For multiple requests: *     An array of results. Each result will either be the result *     returned by the method called, or an xmlrpc_error object if the call *     failed. See xmlrpc_error(). */function xmlrpc($url) {  require_once './includes/xmlrpc.inc';  $args = func_get_args();  return call_user_func_array('_xmlrpc', $args);}function _drupal_bootstrap_full() {  static $called;  if ($called) {    return;  }  $called = 1;  require_once './includes/theme.inc';  require_once './includes/pager.inc';  require_once './includes/menu.inc';  require_once './includes/tablesort.inc';  require_once './includes/file.inc';  require_once './includes/unicode.inc';  require_once './includes/image.inc';  require_once './includes/form.inc';  require_once './includes/mail.inc';  require_once './includes/actions.inc';  // Set the Drupal custom error handler.  set_error_handler('drupal_error_handler');  // Emit the correct charset HTTP header.  drupal_set_header('Content-Type: text/html; charset=utf-8');  // Detect string handling method  unicode_check();  // Undo magic quotes  fix_gpc_magic();  // Load all enabled modules  module_load_all();  // Let all modules take action before menu system handles the request  // We do not want this while running update.php.  if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {    module_invoke_all('init');  }}/** * Store the current page in the cache. * * We try to store a gzipped version of the cache. This requires the * PHP zlib extension (http://php.net/manual/en/ref.zlib.php). * Presence of the extension is checked by testing for the function * gzencode. There are two compression algorithms: gzip and deflate. * The majority of all modern browsers support gzip or both of them. * We thus only deal with the gzip variant and unzip the cache in case * the browser does not accept gzip encoding. * * @see drupal_page_header */function page_set_cache() {  global $user, $base_root;  if (!$user->uid && $_SERVER['REQUEST_METHOD'] == 'GET' && page_get_cache(TRUE)) {    // This will fail in some cases, see page_get_cache() for the explanation.    if ($data = ob_get_contents()) {      $cache = TRUE;      if (variable_get('page_compression', TRUE) && function_exists('gzencode')) {        // We do not store the data in case the zlib mode is deflate.        // This should be rarely happening.        if (zlib_get_coding_type() == 'deflate') {          $cache = FALSE;        }        else if (zlib_get_coding_type() == FALSE) {          $data = gzencode($data, 9, FORCE_GZIP);        }        // The remaining case is 'gzip' which means the data is        // already compressed and nothing left to do but to store it.      }      ob_end_flush();      if ($cache && $data) {        cache_set($base_root . request_uri(), $data, 'cache_page', CACHE_TEMPORARY, drupal_get_headers());      }    }  }}/** * Executes a cron run when called * @return * Returns TRUE if ran successfully */function drupal_cron_run() {  // Try to allocate enough time to run all the hook_cron implementations.  if (function_exists('set_time_limit')) {    @set_time_limit(240);  }  // Fetch the cron semaphore  $semaphore = variable_get('cron_semaphore', FALSE);  if ($semaphore) {    if (time() - $semaphore > 3600) {      // Either cron has been running for more than an hour or the semaphore      // was not reset due to a database error.      watchdog('cron', 'Cron has been running for more than an hour and is most likely stuck.', array(), WATCHDOG_ERROR);      // Release cron semaphore      variable_del('cron_semaphore');    }    else {      // Cron is still running normally.      watchdog('cron', 'Attempting to re-run cron while it is already running.', array(), WATCHDOG_WARNING);    }  }  else {    // Register shutdown callback    register_shutdown_function('drupal_cron_cleanup');    // Lock cron semaphore    variable_set('cron_semaphore', time());    // Iterate through the modules calling their cron handlers (if any):    module_invoke_all('cron');    // Record cron time    variable_set('cron_last', time());    watchdog('cron', 'Cron run completed.', array(), WATCHDOG_NOTICE);    // Release cron semaphore    variable_del('cron_semaphore');    // Return TRUE so other functions can check if it did run successfully    return TRUE;  }}/** * Shutdown function for cron cleanup. */function drupal_cron_cleanup() {  // See if the semaphore is still locked.  if (variable_get('cron_semaphore', FALSE)) {    watchdog('cron', 'Cron run exceeded the time limit and was aborted.', array(), WATCHDOG_WARNING);    // Release cron semaphore    variable_del('cron_semaphore');  }}/** * Return an array of system file objects. * * Returns an array of file objects of the given type from the site-wide * directory (i.e. modules/), the all-sites directory (i.e. * sites/all/modules/), the profiles directory, and site-specific directory * (i.e. sites/somesite/modules/). The returned array will be keyed using the * key specified (name, basename, filename). Using name or basename will cause * site-specific files to be prioritized over similar files in the default * directories. That is, if a file with the same name appears in both the * site-wide directory and site-specific directory, only the site-specific * version will be included. * * @param $mask *   The regular expression of the files to find. * @param $directory *   The subdirectory name in which the files are found. For example, *   'modules' will search in both modules/ and *   sites/somesite/modules/. * @param $key *   The key to be passed to file_scan_directory(). * @param $min_depth *   Minimum depth of directories to return files from. * * @return *   An array of file objects of the specified type. */function drupal_system_listing($mask, $directory, $key = 'name', $min_depth = 1) {  global $profile;  $config = conf_path();  // When this function is called during Drupal's initial installation process,  // the name of the profile that's about to be installed is stored in the global  // $profile variable. At all other times, the standard Drupal systems variable  // table contains the name of the current profile, and we can call variable_get()  // to determine what one is active.  if (!isset($profile)) {    $profile = variable_get('install_profile', 'default');  }  $searchdir = array($directory);  $files = array();  // The 'profiles' directory contains pristine collections of modules and  // themes as organized by a distribution.  It is pristine in the same way  // that /modules is pristine for core; users should avoid changing anything  // there in favor of sites/all or sites/<domain> directories.  if (file_exists("profiles/$profile/$directory")) {    $searchdir[] = "profiles/$profile/$directory";  }  // Always search sites/all/* as well as the global directories  $searchdir[] = 'sites/all/'. $directory;  if (file_exists("$config/$directory")) {    $searchdir[] = "$config/$directory";  }  // Get current list of items  foreach ($searchdir as $dir) {    $files = array_merge($files, file_scan_directory($dir, $mask, array('.', '..', 'CVS'), 0, TRUE, $key, $min_depth));  }  return $files;}/** * This dispatch function hands off structured Drupal arrays to type-specific * *_alter implementations. It ensures a consistent interface for all altering * operations. * * @param $type *   The data type of the structured array. 'form', 'links', *   'node_content', and so on are several examples. * @param $data *   The structured array to be altered. * @param ... *   Any additional params will be passed on to the called *   hook_$type_alter functions. */function drupal_alter($type, &$data) {  // PHP's func_get_args() always returns copies of params, not references, so  // drupal_alter() can only manipulate data that comes in via the required first  // param. For the edge case functions that must pass in an arbitrary number of  // alterable parameters (hook_form_alter() being the best example), an array of  // those params can be placed in the __drupal_alter_by_ref key of the $data  // array. This is somewhat ugly, but is an unavoidable consequence of a flexible  // drupal_alter() function, and the limitations of func_get_args().  // @todo: Remove this in Drupal 7.  if (is_array($data) && isset($data['__drupal_alter_by_ref'])) {    $by_ref_parameters = $data['__drupal_alter_by_ref'];    unset($data['__drupal_alter_by_ref']);  }  // Hang onto a reference to the data array so that it isn't blown away later.  // Also, merge in any parameters that need to be passed by reference.  $args = array(&$data);  if (isset($by_ref_parameters)) {    $args = array_merge($args, $by_ref_parameters);  }  // Now, use func_get_args() to pull in any additional parameters passed into  // the drupal_alter() call.  $additional_args = func_get_args();  array_shift($additional_args);  array_shift($additional_args);  $args = array_merge($args, $additional_args);  foreach (module_implements($type .'_alter') as $module) {    $function = $module .'_'. $type .'_alter';    call_user_func_array($function, $args);  }}/** * Renders HTML given a structured array tree. * * Recursively iterates over each of the array elements, generating HTML code. * This function is usually called from within a another function, like * drupal_get_form() or node_view(). * * @param $elements *   The structured array describing the data to be rendered. * @return *   The rendered HTML. */function drupal_render(&$elements) {  if (!isset($elements) || (isset($elements['#access']) && !$elements['#access'])) {    return NULL;  }  // If the default values for this element haven't been loaded yet, populate  // them.  if (!isset($elements['#defaults_loaded']) || !$elements['#defaults_loaded']) {    if ((!empty($elements['#type'])) && ($info = _element_info($elements['#type']))) {      $elements += $info;    }  }  // Make any final changes to the element before it is rendered. This means  // that the $element or the children can be altered or corrected before the  // element is rendered into the final text.  if (isset($elements['#pre_render'])) {    foreach ($elements['#pre_render'] as $function) {      if (function_exists($function)) {        $elements = $function($elements);      }    }  }  $content = '';  // Either the elements did not go through form_builder or one of the children  // has a #weight.  if (!isset($elements['#sorted'])) {    uasort($elements, "element_sort");  }  $elements += array('#title' => NULL, '#description' => NULL);  if (!isset($elements['#children'])) {    $children = element_children($elements);    // Render all the children that use a theme function.    if (isset($elements['#theme']) && empty($elements['#theme_used'])) {      $elements['#theme_used'] = TRUE;      $previous = array();      foreach (array('#value', '#type', '#prefix', '#suffix') as $key) {        $previous[$key] = isset($elements[$key]) ? $elements[$key] : NULL;      }      // If we rendered a single element, then we will skip the renderer.      if (empty($children)) {        $elements['#printed'] = TRUE;      }      else {        $elements['#value'] = '';      }      $elements['#type'] = 'markup';      unset($elements['#prefix'], $elements['#suffix']);      $content = theme($elements['#theme'], $elements);      foreach (array('#value', '#type', '#prefix', '#suffix') as $key) {        $elements[$key] = isset($previous[$key]) ? $previous[$key] : NULL;      }    }    // Render each of the children using drupal_render and concatenate them.    if (!isset($content) || $content === '') {      foreach ($children as $key) {        $content .= drupal_render($elements[$key]);      }    }  }  if (isset($content) && $content !== '') {    $elements['#children'] = $content;  }  // Until now, we rendered the children, here we render the element itself  if (!isset($elements['#printed'])) {    $content = theme(!empty($elements['#type']) ? $elements['#type'] : 'markup', $elements);    $elements['#printed'] = TRUE;  }  if (isset($content) && $content !== '') {    // Filter the outputted content and make any last changes before the    // content is sent to the browser. The changes are made on $content    // which allows the output'ed text to be filtered.    if (isset($elements['#post_render'])) {      foreach ($elements['#post_render'] as $function) {        if (function_exists($function)) {          $content = $function($content, $elements);        }      }    }    $prefix = isset($elements['#prefix']) ? $elements['#prefix'] : '';    $suffix = isset($elements['#suffix']) ? $elements['#suffix'] : '';    return $prefix . $content . $suffix;  }}/** * Function used by uasort to sort structured arrays by weight. */function element_sort($a, $b) {  $a_weight = (is_array($a) && isset($a['#weight'])) ? $a['#weight'] : 0;  $b_weight = (is_array($b) && isset($b['#weight'])) ? $b['#weight'] : 0;  if ($a_weight == $b_weight) {    return 0;  }  return ($a_weight < $b_weight) ? -1 : 1;}/** * Check if the key is a property. */function element_property($key) {  return $key[0] == '#';}/** * Get properties of a structured array element. Properties begin with '#'. */function element_properties($element) {  return array_filter(array_keys((array) $element), 'element_property');}/** * Check if the key is a child. */function element_child($key) {  return !isset($key[0]) || $key[0] != '#';}/** * Get keys of a structured array tree element that are not properties (i.e., do not begin with '#'). */function element_children($element) {  return array_filter(array_keys((array) $element), 'element_child');}/** * Provide theme registration for themes across .inc files. */function drupal_common_theme() {  return array(    // theme.inc    'placeholder' => array(      'arguments' => array('text' => NULL)    ),    'page' => array(      'arguments' => array('content' => NULL, 'show_blocks' => TRUE, 'show_messages' => TRUE),      'template' => 'page',    ),    'maintenance_page' => array(      'arguments' => array('content' => NULL, 'show_blocks' => TRUE, 'show_messages' => TRUE),      'template' => 'maintenance-page',    ),    'update_page' => array(      'arguments' => array('content' => NULL, 'show_messages' => TRUE),    ),    'install_page' => array(      'arguments' => array('content' => NULL),    ),    'task_list' => array(      'arguments' => array('items' => NULL, 'active' => NULL),    ),    'status_messages' => array(      'arguments' => array('display' => NULL),    ),    'links' => array(      'arguments' => array('links' => NULL, 'attributes' => array('class' => 'links')),    ),    'image' => array(      'arguments' => array('path' => NULL, 'alt' => '', 'title' => '', 'attributes' => NULL, 'getsize' => TRUE),    ),    'breadcrumb' => array(      'arguments' => array('breadcrumb' => NULL),    ),    'help' => array(      'arguments' => array(),    ),    'submenu' => array(      'arguments' => array('links' => NULL),    ),    'table' => array(      'arguments' => array('header' => NULL, 'rows' => NULL, 'attributes' => array(), 'caption' => NULL),    ),    'table_select_header_cell' => array(      'arguments' => array(),    ),    'tablesort_indicator' => array(      'arguments' => array('style' => NULL),    ),    'box' => array(      'arguments' => array('title' => NULL, 'content' => NULL, 'region' => 'main'),      'template' => 'box',    ),    'block' => array(      'arguments' => array('block' => NULL),      'template' => 'block',    ),    'mark' => array(      'arguments' => array('type' => MARK_NEW),    ),    'item_list' => array(      'arguments' => array('items' => array(), 'title' => NULL, 'type' => 'ul', 'attributes' => NULL),    ),    'more_help_link' => array(      'arguments' => array('url' => NULL),    ),    'xml_icon' => array(      'arguments' => array('url' => NULL),    ),    'feed_icon' => array(      'arguments' => array('url' => NULL, 'title' => NULL),    ),    'more_link' => array(      'arguments' => array('url' => NULL, 'title' => NULL)    ),    'closure' => array(      'arguments' => array('main' => 0),    ),    'blocks' => array(      'arguments' => array('region' => NULL),    ),    'username' => array(      'arguments' => array('object' => NULL),    ),    'progress_bar' => array(      'arguments' => array('percent' => NULL, 'message' => NULL),    ),    'indentation' => array(      'arguments' => array('size' => 1),    ),    // from pager.inc    'pager' => array(      'arguments' => array('tags' => array(), 'limit' => 10, 'element' => 0, 'parameters' => array()),    ),    'pager_first' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'parameters' => array()),    ),    'pager_previous' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'interval' => 1, 'parameters' => array()),    ),    'pager_next' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'interval' => 1, 'parameters' => array()),    ),    'pager_last' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'parameters' => array()),    ),    'pager_link' => array(      'arguments' => array('text' => NULL, 'page_new' => NULL, 'element' => NULL, 'parameters' => array(), 'attributes' => array()),    ),    // from locale.inc    'locale_admin_manage_screen' => array(      'arguments' => array('form' => NULL),    ),    // from menu.inc    'menu_item_link' => array(      'arguments' => array('item' => NULL),    ),    'menu_tree' => array(      'arguments' => array('tree' => NULL),    ),    'menu_item' => array(      'arguments' => array('link' => NULL, 'has_children' => NULL, 'menu' => ''),    ),    'menu_local_task' => array(      'arguments' => array('link' => NULL, 'active' => FALSE),    ),    'menu_local_tasks' => array(      'arguments' => array(),    ),    // from form.inc    'select' => array(      'arguments' => array('element' => NULL),    ),    'fieldset' => array(      'arguments' => array('element' => NULL),    ),    'radio' => array(      'arguments' => array('element' => NULL),    ),    'radios' => array(      'arguments' => array('element' => NULL),    ),    'password_confirm' => array(      'arguments' => array('element' => NULL),    ),    'date' => array(      'arguments' => array('element' => NULL),    ),    'item' => array(      'arguments' => array('element' => NULL),    ),    'checkbox' => array(      'arguments' => array('element' => NULL),    ),    'checkboxes' => array(      'arguments' => array('element' => NULL),    ),    'submit' => array(      'arguments' => array('element' => NULL),    ),    'button' => array(      'arguments' => array('element' => NULL),    ),    'image_button' => array(      'arguments' => array('element' => NULL),    ),    'hidden' => array(      'arguments' => array('element' => NULL),    ),    'token' => array(      'arguments' => array('element' => NULL),    ),    'textfield' => array(      'arguments' => array('element' => NULL),    ),    'form' => array(      'arguments' => array('element' => NULL),    ),    'textarea' => array(      'arguments' => array('element' => NULL),    ),    'markup' => array(      'arguments' => array('element' => NULL),    ),    'password' => array(      'arguments' => array('element' => NULL),    ),    'file' => array(      'arguments' => array('element' => NULL),    ),    'form_element' => array(      'arguments' => array('element' => NULL, 'value' => NULL),    ),  );}/** * @ingroup schemaapi * @{ *//** * Get the schema definition of a table, or the whole database schema. * * The returned schema will include any modifications made by any * module that implements hook_schema_alter(). * * @param $table *   The name of the table. If not given, the schema of all tables is returned. * @param $rebuild *   If true, the schema will be rebuilt instead of retrieved from the cache. */function drupal_get_schema($table = NULL, $rebuild = FALSE) {  static $schema = array();  if (empty($schema) || $rebuild) {    // Try to load the schema from cache.    if (!$rebuild && $cached = cache_get('schema')) {      $schema = $cached->data;    }    // Otherwise, rebuild the schema cache.    else {      $schema = array();      // Load the .install files to get hook_schema.      module_load_all_includes('install');      // Invoke hook_schema for all modules.      foreach (module_implements('schema') as $module) {        $current = module_invoke($module, 'schema');        _drupal_initialize_schema($module, $current);        $schema = array_merge($schema, $current);      }      drupal_alter('schema', $schema);      cache_set('schema', $schema);    }  }  if (!isset($table)) {    return $schema;  }  elseif (isset($schema[$table])) {    return $schema[$table];  }  else {    return FALSE;  }}/** * Create all tables that a module defines in its hook_schema(). * * Note: This function does not pass the module's schema through * hook_schema_alter(). The module's tables will be created exactly as the * module defines them. * * @param $module *   The module for which the tables will be created. * @return *   An array of arrays with the following key/value pairs: *    - success: a boolean indicating whether the query succeeded. *    - query: the SQL query(s) executed, passed through check_plain(). */function drupal_install_schema($module) {  $schema = drupal_get_schema_unprocessed($module);  _drupal_initialize_schema($module, $schema);  $ret = array();  foreach ($schema as $name => $table) {    db_create_table($ret, $name, $table);  }  return $ret;}/** * Remove all tables that a module defines in its hook_schema(). * * Note: This function does not pass the module's schema through * hook_schema_alter(). The module's tables will be created exactly as the * module defines them. * * @param $module *   The module for which the tables will be removed. * @return *   An array of arrays with the following key/value pairs: *    - success: a boolean indicating whether the query succeeded. *    - query: the SQL query(s) executed, passed through check_plain(). */function drupal_uninstall_schema($module) {  $schema = drupal_get_schema_unprocessed($module);  _drupal_initialize_schema($module, $schema);  $ret = array();  foreach ($schema as $table) {    db_drop_table($ret, $table['name']);  }  return $ret;}/** * Returns the unprocessed and unaltered version of a module's schema. * * Use this function only if you explicitly need the original * specification of a schema, as it was defined in a module's * hook_schema(). No additional default values will be set, * hook_schema_alter() is not invoked and these unprocessed * definitions won't be cached. * * This function can be used to retrieve a schema specification in * hook_schema(), so it allows you to derive your tables from existing * specifications. * * It is also used by drupal_install_schema() and * drupal_uninstall_schema() to ensure that a module's tables are * created exactly as specified without any changes introduced by a * module that implements hook_schema_alter(). * * @param $module *   The module to which the table belongs. * @param $table *   The name of the table. If not given, the module's complete schema *   is returned. */function drupal_get_schema_unprocessed($module, $table = NULL) {  // Load the .install file to get hook_schema.  module_load_include('install', $module);  $schema = module_invoke($module, 'schema');  if (!is_null($table) && isset($schema[$table])) {    return $schema[$table];  }  else {    return $schema;  }}/** * Fill in required default values for table definitions returned by hook_schema(). * * @param $module *   The module for which hook_schema() was invoked. * @param $schema *   The schema definition array as it was returned by the module's *   hook_schema(). */function _drupal_initialize_schema($module, &$schema) {  // Set the name and module key for all tables.  foreach ($schema as $name => $table) {    if (empty($table['module'])) {      $schema[$name]['module'] = $module;    }    if (!isset($table['name'])) {      $schema[$name]['name'] = $name;    }  }}/** * Retrieve a list of fields from a table schema. The list is suitable for use in a SQL query. * * @param $table *   The name of the table from which to retrieve fields. * @param *   An optional prefix to to all fields. * * @return An array of fields. **/function drupal_schema_fields_sql($table, $prefix = NULL) {  $schema = drupal_get_schema($table);  $fields = array_keys($schema['fields']);  if ($prefix) {    $columns = array();    foreach ($fields as $field) {      $columns[] = "$prefix.$field";    }    return $columns;  }  else {    return $fields;  }}/** * Save a record to the database based upon the schema. * * Default values are filled in for missing items, and 'serial' (auto increment) * types are filled in with IDs. * * @param $table *   The name of the table; this must exist in schema API. * @param $object *   The object to write. This is a reference, as defaults according to *   the schema may be filled in on the object, as well as ID on the serial *   type(s). Both array an object types may be passed. * @param $update *   If this is an update, specify the primary keys' field names. It is the *   caller's responsibility to know if a record for this object already *   exists in the database. If there is only 1 key, you may pass a simple string. * @return *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or *   SAVED_UPDATED is returned depending on the operation performed. The *   $object parameter contains values for any serial fields defined by *   the $table. For example, $object->nid will be populated after inserting *   a new node. */function drupal_write_record($table, &$object, $update = array()) {  // Standardize $update to an array.  if (is_string($update)) {    $update = array($update);  }  $schema = drupal_get_schema($table);  if (empty($schema)) {    return FALSE;  }  // Convert to an object if needed.  if (is_array($object)) {    $object = (object) $object;    $array = TRUE;  }  else {    $array = FALSE;  }  $fields = $defs = $values = $serials = $placeholders = array();  // Go through our schema, build SQL, and when inserting, fill in defaults for  // fields that are not set.  foreach ($schema['fields'] as $field => $info) {    // Special case -- skip serial types if we are updating.    if ($info['type'] == 'serial' && count($update)) {      continue;    }    // For inserts, populate defaults from Schema if not already provided    if (!isset($object->$field) && !count($update) && isset($info['default'])) {      $object->$field = $info['default'];    }    // Track serial fields so we can helpfully populate them after the query.    if ($info['type'] == 'serial') {      $serials[] = $field;      // Ignore values for serials when inserting data. Unsupported.      unset($object->$field);    }    // Build arrays for the fields, placeholders, and values in our query.    if (isset($object->$field)) {      $fields[] = $field;      $placeholders[] = db_type_placeholder($info['type']);      if (empty($info['serialize'])) {        $values[] = $object->$field;      }      else {        $values[] = serialize($object->$field);      }    }  }  // Build the SQL.  $query = '';  if (!count($update)) {    $query = "INSERT INTO {". $table ."} (". implode(', ', $fields) .') VALUES ('. implode(', ', $placeholders) .')';    $return = SAVED_NEW;  }  else {    $query = '';    foreach ($fields as $id => $field) {      if ($query) {        $query .= ', ';      }      $query .= $field .' = '. $placeholders[$id];    }    foreach ($update as $key){      $conditions[] = "$key = ". db_type_placeholder($schema['fields'][$key]['type']);      $values[] = $object->$key;    }    $query = "UPDATE {". $table ."} SET $query WHERE ". implode(' AND ', $conditions);    $return = SAVED_UPDATED;  }  // Execute the SQL.  if (db_query($query, $values)) {    if ($serials) {      // Get last insert ids and fill them in.      foreach ($serials as $field) {        $object->$field = db_last_insert_id($table, $field);      }    }  }  else {    $return = FALSE;  }  // If we began with an array, convert back so we don't surprise the caller.  if ($array) {    $object = (array) $object;  }  return $return;}/** * @} End of "ingroup schemaapi". *//** * Parse Drupal info file format. * * Files should use an ini-like format to specify values. * White-space generally doesn't matter, except inside values. * e.g. * * @code *   key = value *   key = "value" *   key = 'value' *   key = "multi-line * *   value" *   key = 'multi-line * *   value' *   key *   = *   'value' * @endcode * * Arrays are created using a GET-like syntax: * * @code *   key[] = "numeric array" *   key[index] = "associative array" *   key[index][] = "nested numeric array" *   key[index][index] = "nested associative array" * @endcode * * PHP constants are substituted in, but only when used as the entire value: * * Comments should start with a semi-colon at the beginning of a line. * * This function is NOT for placing arbitrary module-specific settings. Use * variable_get() and variable_set() for that. * * Information stored in the module.info file: * - name: The real name of the module for display purposes. * - description: A brief description of the module. * - dependencies: An array of shortnames of other modules this module depends on. * - package: The name of the package of modules this module belongs to. * * Example of .info file: * @code *   name = Forum *   description = Enables threaded discussions about general topics. *   dependencies[] = taxonomy *   dependencies[] = comment *   package = Core - optional *   version = VERSION * @endcode * * @param $filename *   The file we are parsing. Accepts file with relative or absolute path. * @return *   The info array. */function drupal_parse_info_file($filename) {  $info = array();  $constants = get_defined_constants();  if (!file_exists($filename)) {    return $info;  }  $data = file_get_contents($filename);  if (preg_match_all('    @^\s*                           # Start at the beginning of a line, ignoring leading whitespace    ((?:      [^=;\[\]]|                    # Key names cannot contain equal signs, semi-colons or square brackets,      \[[^\[\]]*\]                  # unless they are balanced and not nested    )+?)    \s*=\s*                         # Key/value pairs are separated by equal signs (ignoring white-space)    (?:      ("(?:[^"]|(?<=\\\\)")*")|     # Double-quoted string, which may contain slash-escaped quotes/slashes      (\'(?:[^\']|(?<=\\\\)\')*\')| # Single-quoted string, which may contain slash-escaped quotes/slashes      ([^\r\n]*?)                   # Non-quoted string    )\s*$                           # Stop at the next end of a line, ignoring trailing whitespace    @msx', $data, $matches, PREG_SET_ORDER)) {    foreach ($matches as $match) {      // Fetch the key and value string      $i = 0;      foreach (array('key', 'value1', 'value2', 'value3') as $var) {        $$var = isset($match[++$i]) ? $match[$i] : '';      }      $value = stripslashes(substr($value1, 1, -1)) . stripslashes(substr($value2, 1, -1)) . $value3;      // Parse array syntax      $keys = preg_split('/\]?\[/', rtrim($key, ']'));      $last = array_pop($keys);      $parent = &$info;      // Create nested arrays      foreach ($keys as $key) {        if ($key == '') {          $key = count($parent);        }        if (!isset($parent[$key]) || !is_array($parent[$key])) {          $parent[$key] = array();        }        $parent = &$parent[$key];      }      // Handle PHP constants.      if (isset($constants[$value])) {        $value = $constants[$value];      }      // Insert actual value      if ($last == '') {        $last = count($parent);      }      $parent[$last] = $value;    }  }  return $info;}/** * @return *   Array of the possible severity levels for log messages. * * @see watchdog */function watchdog_severity_levels() {  return array(    WATCHDOG_EMERG    => t('emergency'),    WATCHDOG_ALERT    => t('alert'),    WATCHDOG_CRITICAL => t('critical'),    WATCHDOG_ERROR    => t('error'),    WATCHDOG_WARNING  => t('warning'),    WATCHDOG_NOTICE   => t('notice'),    WATCHDOG_INFO     => t('info'),    WATCHDOG_DEBUG    => t('debug'),  );}/** * Explode a string of given tags into an array. */function drupal_explode_tags($tags) {  // This regexp allows the following types of user input:  // this, "somecompany, llc", "and ""this"" w,o.rks", foo bar  $regexp = '%(?:^|,\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^",]*))%x';  preg_match_all($regexp, $tags, $matches);  $typed_tags = array_unique($matches[1]);  $tags = array();  foreach ($typed_tags as $tag) {    // If a user has escaped a term (to demonstrate that it is a group,    // or includes a comma or quote character), we remove the escape    // formatting so to save the term into the database as the user intends.    $tag = trim(str_replace('""', '"', preg_replace('/^"(.*)"$/', '\1', $tag)));    if ($tag != "") {      $tags[] = $tag;    }  }  return $tags;}/** * Implode an array of tags into a string. */function drupal_implode_tags($tags) {  $encoded_tags = array();  foreach ($tags as $tag) {    // Commas and quotes in tag names are special cases, so encode them.    if (strpos($tag, ',') !== FALSE || strpos($tag, '"') !== FALSE) {      $tag = '"'. str_replace('"', '""', $tag) .'"';    }    $encoded_tags[] = $tag;  }  return implode(', ', $encoded_tags);}/** * Flush all cached data on the site. * * Empties cache tables, rebuilds the menu cache and theme registries, and * invokes a hook so that other modules' cache data can be cleared as well. */function drupal_flush_all_caches() {  // Change query-strings on css/js files to enforce reload for all users.  _drupal_flush_css_js();  drupal_clear_css_cache();  drupal_clear_js_cache();  // If invoked from update.php, we must not update the theme information in the  // database, or this will result in all themes being disabled.  if (defined('MAINTENANCE_MODE') && MAINTENANCE_MODE == 'update') {    _system_theme_data();  }  else {    system_theme_data();  }  drupal_rebuild_theme_registry();  menu_rebuild();  node_types_rebuild();  // Don't clear cache_form - in-progress form submissions may break.  // Ordered so clearing the page cache will always be the last action.  $core = array('cache', 'cache_block', 'cache_filter', 'cache_page');  $cache_tables = array_merge(module_invoke_all('flush_caches'), $core);  foreach ($cache_tables as $table) {    cache_clear_all('*', $table, TRUE);  }}/** * Helper function to change query-strings on css/js files. * * Changes the character added to all css/js files as dummy query-string, * so that all browsers are forced to reload fresh files. We keep * 20 characters history (FIFO) to avoid repeats, but only the first * (newest) character is actually used on urls, to keep them short. * This is also called from update.php. */function _drupal_flush_css_js() {  $string_history = variable_get('css_js_query_string', '00000000000000000000');  $new_character = $string_history[0];  // Not including 'q' to allow certain JavaScripts to re-use query string.  $characters = 'abcdefghijklmnoprstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';  while (strpos($string_history, $new_character) !== FALSE) {    $new_character = $characters[mt_rand(0, strlen($characters) - 1)];  }  variable_set('css_js_query_string', $new_character . substr($string_history, 0, 19));}
