<?php// $Id$/** * Implementation of hook_help(). */function color_help($path, $arg) {  switch ($path) {    case 'admin/help#color':      $output = '<p>'. t('The color module allows a site administrator to quickly and easily change the color scheme of certain themes. Although not all themes support color module, both Garland (the default theme) and Minnelli were designed to take advantage of its features. By using color module with a compatible theme, you can easily change the color of links, backgrounds, text, and other theme elements. Color module requires that your <a href="@url">file download method</a> be set to public.', array('@url' => url('admin/settings/file-system'))) .'</p>';      $output .= '<p>'. t("It is important to remember that color module saves a modified copy of the theme's specified stylesheets in the files directory. This means that if you make any manual changes to your theme's stylesheet, you must save your color settings again, even if they haven't changed. This causes the color module generated version of the stylesheets in the files directory to be recreated using the new version of the original file.") .'</p>';      $output .= '<p>'. t('To change the color settings for a compatible theme, select the "configure" link for the theme on the <a href="@themes">themes administration page</a>.', array('@themes' => url('admin/build/themes'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@color">Color module</a>.', array('@color' => 'http://drupal.org/handbook/modules/color/')) .'</p>';      return $output;  }}/** * Implementation of hook_theme(). */function color_theme() {  return array(    'color_scheme_form' => array(      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_form_alter(). */function color_form_alter(&$form, $form_state, $form_id) {  // Insert the color changer into the theme settings page.  if ($form_id == 'system_theme_settings' && color_get_info(arg(4)) && function_exists('gd_info')) {    if (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) != FILE_DOWNLOADS_PUBLIC) {      // Disables the color changer when the private download method is used.      // TODO: This should be solved in a different way. See issue #181003.      drupal_set_message(t('The color picker only works if the <a href="@url">download method</a> is set to public.', array('@url' => url('admin/settings/file-system'))), 'warning');    }    else {      $form['color'] = array(        '#type' => 'fieldset',        '#title' => t('Color scheme'),        '#weight' => -1,        '#attributes' => array('id' => 'color_scheme_form'),        '#theme' => 'color_scheme_form',      );      $form['color'] += color_scheme_form($form_state, arg(4));      $form['#submit'][] = 'color_scheme_form_submit';    }  }  // Use the generated screenshot in the theme list.  if ($form_id == 'system_theme_select_form' || $form_id == 'system_themes') {    $themes = list_themes();    foreach (element_children($form) as $theme) {      if ($screenshot = variable_get('color_'. $theme .'_screenshot', NULL)) {        if (isset($form[$theme]['screenshot'])) {          $form[$theme]['screenshot']['#value'] = theme('image', $screenshot, '', '', array('class' => 'screenshot'), FALSE);        }      }    }  }}/** * Callback for the theme to alter the resources used. */function _color_page_alter(&$vars) {  global $language, $theme_key;  // Override stylesheets.  $color_paths = variable_get('color_'. $theme_key .'_stylesheets', array());  if (!empty($color_paths)) {    // Loop over theme CSS files and try to rebuild CSS array with rewritten    // stylesheets. Keep the orginal order intact for CSS cascading.    $new_theme_css = array();    foreach ($vars['css']['all']['theme'] as $old_path => $old_preprocess) {      // Add the non-colored stylesheet first as we might not find a      // re-colored stylesheet for replacement later.      $new_theme_css[$old_path] = $old_preprocess;      // Loop over the path array with recolored CSS files to find matching      // paths which could replace the non-recolored paths.      foreach ($color_paths as $color_path) {        // Color module currently requires unique file names to be used,        // which allows us to compare different file paths.        if (basename($old_path) == basename($color_path)) {          // Pull out the non-colored and add rewritten stylesheet.          unset($new_theme_css[$old_path]);          $new_theme_css[$color_path] = $old_preprocess;          // If the current language is RTL and the CSS file had an RTL variant,          // pull out the non-colored and add rewritten RTL stylesheet.          if ($language->direction == LANGUAGE_RTL) {            $rtl_old_path = str_replace('.css', '-rtl.css', $old_path);            $rtl_color_path = str_replace('.css', '-rtl.css', $color_path);            if (file_exists($rtl_color_path)) {              unset($new_theme_css[$rtl_old_path]);              $new_theme_css[$rtl_color_path] = $old_preprocess;            }          }          break;        }      }    }    $vars['css']['all']['theme'] = $new_theme_css;    $vars['styles'] = drupal_get_css($vars['css']);  }  // Override logo.  $logo = variable_get('color_'. $theme_key .'_logo', NULL);  if ($logo && $vars['logo'] && preg_match('!'. $theme_key .'/logo.png$!', $vars['logo'])) {    $vars['logo'] = base_path() . $logo;  }}/** * Retrieve the color.module info for a particular theme. */function color_get_info($theme) {  $path = drupal_get_path('theme', $theme);  $file = $path .'/color/color.inc';  if ($path && file_exists($file)) {    include $file;    return $info;  }}/** * Helper function to retrieve the color palette for a particular theme. */function color_get_palette($theme, $default = false) {  // Fetch and expand default palette  $fields = array('base', 'link', 'top', 'bottom', 'text');  $info = color_get_info($theme);  $keys = array_keys($info['schemes']);  foreach (explode(',', array_shift($keys)) as $k => $scheme) {    $palette[$fields[$k]] = $scheme;  }  // Load variable  return $default ? $palette : variable_get('color_'. $theme .'_palette', $palette);}/** * Form callback. Returns the configuration form. */function color_scheme_form(&$form_state, $theme) {  $base = drupal_get_path('module', 'color');  $info = color_get_info($theme);  // Add Farbtastic color picker  drupal_add_css('misc/farbtastic/farbtastic.css', 'module', 'all', FALSE);  drupal_add_js('misc/farbtastic/farbtastic.js');  // Add custom CSS/JS  drupal_add_css($base .'/color.css', 'module', 'all', FALSE);  drupal_add_js($base .'/color.js');  drupal_add_js(array('color' => array(    'reference' => color_get_palette($theme, true)  )), 'setting');  // See if we're using a predefined scheme  $current = implode(',', variable_get('color_'. $theme .'_palette', array()));  // Note: we use the original theme when the default scheme is chosen.  $current = isset($info['schemes'][$current]) ? $current : ($current == '' ? reset($info['schemes']) : '');  // Add scheme selector  $info['schemes'][''] = t('Custom');  $form['scheme'] = array(    '#type' => 'select',    '#title' => t('Color set'),    '#options' => $info['schemes'],    '#default_value' => $current,  );  // Add palette fields  $palette = color_get_palette($theme);  $names = array(    'base' => t('Base color'),    'link' => t('Link color'),    'top' => t('Header top'),    'bottom' => t('Header bottom'),    'text' => t('Text color')  );  $form['palette']['#tree'] = true;  foreach ($palette as $name => $value) {    $form['palette'][$name] = array(      '#type' => 'textfield',      '#title' => $names[$name],      '#default_value' => $value,      '#size' => 8,    );  }  $form['theme'] = array('#type' => 'value', '#value' => arg(4));  $form['info'] = array('#type' => 'value', '#value' => $info);  return $form;}/** * Theme color form. * * @ingroup themeable */function theme_color_scheme_form($form) {  // Include stylesheet  $theme = $form['theme']['#value'];  $info = $form['info']['#value'];  $path = drupal_get_path('theme', $theme) .'/';  drupal_add_css($path . $info['preview_css']);  $output = '';  // Wrapper  $output .= '<div class="color-form clear-block">';  // Color schemes  $output .= drupal_render($form['scheme']);  // Palette  $output .= '<div id="palette" class="clear-block">';  foreach (element_children($form['palette']) as $name) {    $output .= drupal_render($form['palette'][$name]);  }  $output .= '</div>';  // Preview  $output .= drupal_render($form);  $output .= '<h2>'. t('Preview') .'</h2>';  $output .= '<div id="preview"><div id="text"><h2>Lorem ipsum dolor</h2><p>Sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud <a href="#">exercitation ullamco</a> laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p></div><div id="img" style="background-image: url('. base_path() . $path . $info['preview_image'] .')"></div></div>';  // Close wrapper  $output .= '</div>';  return $output;}/** * Submit handler for color change form. */function color_scheme_form_submit($form, &$form_state) {  // Get theme coloring info  if (!isset($form_state['values']['info'])) {    return;  }  $theme = $form_state['values']['theme'];  $info = $form_state['values']['info'];  // Resolve palette  $palette = $form_state['values']['palette'];  if ($form_state['values']['scheme'] != '') {    $scheme = explode(',', $form_state['values']['scheme']);    foreach ($palette as $k => $color) {      $palette[$k] = array_shift($scheme);    }  }  // Make sure enough memory is available, if PHP's memory limit is compiled in.  if (function_exists('memory_get_usage')) {    // Fetch source image dimensions.    $source = drupal_get_path('theme', $theme) .'/'. $info['base_image'];    list($width, $height) = getimagesize($source);    // We need at least a copy of the source and a target buffer of the same    // size (both at 32bpp).    $required = $width * $height * 8;    $usage = memory_get_usage();    $limit = parse_size(ini_get('memory_limit'));    if ($usage + $required > $limit) {      drupal_set_message(t('There is not enough memory available to PHP to change this theme\'s color scheme. You need at least %size more. Check the <a href="@url">PHP documentation</a> for more information.', array('%size' => format_size($usage + $required - $limit), '@url' => 'http://www.php.net/manual/en/ini.core.php#ini.sect.resource-limits')), 'error');      return;    }  }  // Delete old files  foreach (variable_get('color_'. $theme .'_files', array()) as $file) {    @unlink($file);  }  if (isset($file) && $file = dirname($file)) {    @rmdir($file);  }  // Don't render the default colorscheme, use the standard theme instead.  if (implode(',', color_get_palette($theme, true)) == implode(',', $palette)    || $form_state['values']['op'] == t('Reset to defaults')) {    variable_del('color_'. $theme .'_palette');    variable_del('color_'. $theme .'_stylesheets');    variable_del('color_'. $theme .'_logo');    variable_del('color_'. $theme .'_files');    variable_del('color_'. $theme .'_screenshot');    return;  }  // Prepare target locations for generated files.  $id = $theme .'-'. substr(md5(serialize($palette) . microtime()), 0, 8);  $paths['color'] = file_directory_path() .'/color';  $paths['target'] = $paths['color'] .'/'. $id;  foreach ($paths as $path) {    file_check_directory($path, FILE_CREATE_DIRECTORY);  }  $paths['target'] = $paths['target'] .'/';  $paths['id'] = $id;  $paths['source'] = drupal_get_path('theme', $theme) .'/';  $paths['files'] = $paths['map'] = array();  // Save palette and logo location.  variable_set('color_'. $theme .'_palette', $palette);  variable_set('color_'. $theme .'_logo', $paths['target'] .'logo.png');  // Copy over neutral images.  foreach ($info['copy'] as $file) {    $base = basename($file);    $source = $paths['source'] . $file;    file_copy($source, $paths['target'] . $base);    $paths['map'][$file] = $base;    $paths['files'][] = $paths['target'] . $base;  }  // Render new images, if image provided.  if ($info['base_image']) {    _color_render_images($theme, $info, $paths, $palette);  }  // Rewrite theme stylesheets.  $css = array();  foreach ($info['css'] as $stylesheet) {    // Build a temporary array with LTR and RTL files.    $files = array();    if (file_exists($paths['source'] . $stylesheet)) {      $files[] = $stylesheet;      $rtl_file = str_replace('.css', '-rtl.css', $stylesheet);      if (file_exists($paths['source'] . $rtl_file)) {        $files[] = $rtl_file;      }    }    foreach ($files as $file) {      // Aggregate @imports recursively for each configured top level CSS file      // without optimization. Aggregation and optimization will be      // handled by drupal_build_css_cache() only.      $style = drupal_load_stylesheet($paths['source'] . $file, FALSE);      // Return the path to where this CSS file originated from, stripping      // off the name of the file at the end of the path.      $base = base_path() . dirname($paths['source'] . $file) .'/';      _drupal_build_css_path(NULL, $base);      // Prefix all paths within this CSS file, ignoring absolute paths.      $style = preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $style);      // Rewrite stylesheet with new colors.      $style = _color_rewrite_stylesheet($theme, $info, $paths, $palette, $style);      $base_file = basename($file);      $css[] = $paths['target'] . $base_file;      _color_save_stylesheet($paths['target'] . $base_file, $style, $paths);    }  }  // Maintain list of files.  variable_set('color_'. $theme .'_stylesheets', $css);  variable_set('color_'. $theme .'_files', $paths['files']);}/** * Rewrite the stylesheet to match the colors in the palette. */function _color_rewrite_stylesheet($theme, &$info, &$paths, $palette, $style) {  $themes = list_themes();  // Prepare color conversion table  $conversion = $palette;  unset($conversion['base']);  foreach ($conversion as $k => $v) {    $conversion[$k] = drupal_strtolower($v);  }  $default = color_get_palette($theme, true);  // Split off the "Don't touch" section of the stylesheet.  $split = "Color Module: Don't touch";  if (strpos($style, $split) !== FALSE) {    list($style, $fixed) = explode($split, $style);  }  // Find all colors in the stylesheet and the chunks in between.  $style = preg_split('/(#[0-9a-f]{6}|#[0-9a-f]{3})/i', $style, -1, PREG_SPLIT_DELIM_CAPTURE);  $is_color = false;  $output = '';  $base = 'base';  // Iterate over all parts.  foreach ($style as $chunk) {    if ($is_color) {      $chunk = drupal_strtolower($chunk);      // Check if this is one of the colors in the default palette.      if ($key = array_search($chunk, $default)) {        $chunk = $conversion[$key];      }      // Not a pre-set color. Extrapolate from the base.      else {        $chunk = _color_shift($palette[$base], $default[$base], $chunk, $info['blend_target']);      }    }    else {      // Determine the most suitable base color for the next color.      // 'a' declarations. Use link.      if (preg_match('@[^a-z0-9_-](a)[^a-z0-9_-][^/{]*{[^{]+$@i', $chunk)) {        $base = 'link';      }      // 'color:' styles. Use text.      else if (preg_match('/(?<!-)color[^{:]*:[^{#]*$/i', $chunk)) {        $base = 'text';      }      // Reset back to base.      else {        $base = 'base';      }    }    $output .= $chunk;    $is_color = !$is_color;  }  // Append fixed colors segment.  if (isset($fixed)) {    $output .= $fixed;  }  // Replace paths to images.  foreach ($paths['map'] as $before => $after) {    $before = base_path() . $paths['source'] . $before;    $before = preg_replace('`(^|/)(?!../)([^/]+)/../`', '$1', $before);    $output = str_replace($before, $after, $output);  }  return $output;}/** * Save the rewritten stylesheet to disk. */function _color_save_stylesheet($file, $style, &$paths) {  // Write new stylesheet.  file_save_data($style, $file, FILE_EXISTS_REPLACE);  $paths['files'][] = $file;  // Set standard file permissions for webserver-generated files.  @chmod($file, 0664);}/** * Render images that match a given palette. */function _color_render_images($theme, &$info, &$paths, $palette) {  // Prepare template image.  $source = $paths['source'] .'/'. $info['base_image'];  $source = imagecreatefrompng($source);  $width = imagesx($source);  $height = imagesy($source);  // Prepare target buffer.  $target = imagecreatetruecolor($width, $height);  imagealphablending($target, true);  // Fill regions of solid color.  foreach ($info['fill'] as $color => $fill) {    imagefilledrectangle($target, $fill[0], $fill[1], $fill[0] + $fill[2], $fill[1] + $fill[3], _color_gd($target, $palette[$color]));  }  // Render gradient.  for ($y = 0; $y < $info['gradient'][3]; ++$y) {    $color = _color_blend($target, $palette['top'], $palette['bottom'], $y / ($info['gradient'][3] - 1));    imagefilledrectangle($target, $info['gradient'][0], $info['gradient'][1] + $y, $info['gradient'][0] + $info['gradient'][2], $info['gradient'][1] + $y + 1, $color);  }  // Blend over template.  imagecopy($target, $source, 0, 0, 0, 0, $width, $height);  // Clean up template image.  imagedestroy($source);  // Cut out slices.  foreach ($info['slices'] as $file => $coord) {    list($x, $y, $width, $height) = $coord;    $base = basename($file);    $image = $paths['target'] . $base;    // Cut out slice.    if ($file == 'screenshot.png') {      $slice = imagecreatetruecolor(150, 90);      imagecopyresampled($slice, $target, 0, 0, $x, $y, 150, 90, $width, $height);      variable_set('color_'. $theme .'_screenshot', $image);    }    else {      $slice = imagecreatetruecolor($width, $height);      imagecopy($slice, $target, 0, 0, $x, $y, $width, $height);    }    // Save image.    imagepng($slice, $image);    imagedestroy($slice);    $paths['files'][] = $image;    // Set standard file permissions for webserver-generated files    @chmod(realpath($image), 0664);    // Build before/after map of image paths.    $paths['map'][$file] = $base;  }  // Clean up target buffer.  imagedestroy($target);}/** * Shift a given color, using a reference pair and a target blend color. * * Note: this function is significantly different from the JS version, as it * is written to match the blended images perfectly. * * Constraint: if (ref2 == target + (ref1 - target) * delta) for some fraction delta *              then (return == target + (given - target) * delta) * * Loose constraint: Preserve relative positions in saturation and luminance *                   space. */function _color_shift($given, $ref1, $ref2, $target) {  // We assume that ref2 is a blend of ref1 and target and find  // delta based on the length of the difference vectors:  // delta = 1 - |ref2 - ref1| / |white - ref1|  $target = _color_unpack($target, true);  $ref1 = _color_unpack($ref1, true);  $ref2 = _color_unpack($ref2, true);  $numerator = 0;  $denominator = 0;  for ($i = 0; $i < 3; ++$i) {    $numerator += ($ref2[$i] - $ref1[$i]) * ($ref2[$i] - $ref1[$i]);    $denominator += ($target[$i] - $ref1[$i]) * ($target[$i] - $ref1[$i]);  }  $delta = ($denominator > 0) ? (1 - sqrt($numerator / $denominator)) : 0;  // Calculate the color that ref2 would be if the assumption was true.  for ($i = 0; $i < 3; ++$i) {    $ref3[$i] = $target[$i] + ($ref1[$i] - $target[$i]) * $delta;  }  // If the assumption is not true, there is a difference between ref2 and ref3.  // We measure this in HSL space. Notation: x' = hsl(x).  $ref2 = _color_rgb2hsl($ref2);  $ref3 = _color_rgb2hsl($ref3);  for ($i = 0; $i < 3; ++$i) {    $shift[$i] = $ref2[$i] - $ref3[$i];  }  // Take the given color, and blend it towards the target.  $given = _color_unpack($given, true);  for ($i = 0; $i < 3; ++$i) {    $result[$i] = $target[$i] + ($given[$i] - $target[$i]) * $delta;  }  // Finally, we apply the extra shift in HSL space.  // Note: if ref2 is a pure blend of ref1 and target, then |shift| = 0.  $result = _color_rgb2hsl($result);  for ($i = 0; $i < 3; ++$i) {    $result[$i] = min(1, max(0, $result[$i] + $shift[$i]));  }  $result = _color_hsl2rgb($result);  // Return hex color.  return _color_pack($result, true);}/** * Convert a hex triplet into a GD color. */function _color_gd($img, $hex) {  $c = array_merge(array($img), _color_unpack($hex));  return call_user_func_array('imagecolorallocate', $c);}/** * Blend two hex colors and return the GD color. */function _color_blend($img, $hex1, $hex2, $alpha) {  $in1 = _color_unpack($hex1);  $in2 = _color_unpack($hex2);  $out = array($img);  for ($i = 0; $i < 3; ++$i) {    $out[] = $in1[$i] + ($in2[$i] - $in1[$i]) * $alpha;  }  return call_user_func_array('imagecolorallocate', $out);}/** * Convert a hex color into an RGB triplet. */function _color_unpack($hex, $normalize = false) {  if (strlen($hex) == 4) {    $hex = $hex[1] . $hex[1] . $hex[2] . $hex[2] . $hex[3] . $hex[3];  }  $c = hexdec($hex);  for ($i = 16; $i >= 0; $i -= 8) {    $out[] = (($c >> $i) & 0xFF) / ($normalize ? 255 : 1);  }  return $out;}/** * Convert an RGB triplet to a hex color. */function _color_pack($rgb, $normalize = false) {  $out = 0;  foreach ($rgb as $k => $v) {    $out |= (($v * ($normalize ? 255 : 1)) << (16 - $k * 8));  }  return '#'. str_pad(dechex($out), 6, 0, STR_PAD_LEFT);}/** * Convert a HSL triplet into RGB */function _color_hsl2rgb($hsl) {  $h = $hsl[0];  $s = $hsl[1];  $l = $hsl[2];  $m2 = ($l <= 0.5) ? $l * ($s + 1) : $l + $s - $l*$s;  $m1 = $l * 2 - $m2;  return array(    _color_hue2rgb($m1, $m2, $h + 0.33333),    _color_hue2rgb($m1, $m2, $h),    _color_hue2rgb($m1, $m2, $h - 0.33333),  );}/** * Helper function for _color_hsl2rgb(). */function _color_hue2rgb($m1, $m2, $h) {  $h = ($h < 0) ? $h + 1 : (($h > 1) ? $h - 1 : $h);  if ($h * 6 < 1) return $m1 + ($m2 - $m1) * $h * 6;  if ($h * 2 < 1) return $m2;  if ($h * 3 < 2) return $m1 + ($m2 - $m1) * (0.66666 - $h) * 6;  return $m1;}/** * Convert an RGB triplet to HSL. */function _color_rgb2hsl($rgb) {  $r = $rgb[0];  $g = $rgb[1];  $b = $rgb[2];  $min = min($r, min($g, $b));  $max = max($r, max($g, $b));  $delta = $max - $min;  $l = ($min + $max) / 2;  $s = 0;  if ($l > 0 && $l < 1) {    $s = $delta / ($l < 0.5 ? (2 * $l) : (2 - 2 * $l));  }  $h = 0;  if ($delta > 0) {    if ($max == $r && $max != $g) $h += ($g - $b) / $delta;    if ($max == $g && $max != $b) $h += (2 + ($b - $r) / $delta);    if ($max == $b && $max != $r) $h += (4 + ($r - $g) / $delta);    $h /= 6;  }  return array($h, $s, $l);}
<?php// $Id$?><div id="block-<?php print $block->module .'-'. $block->delta; ?>" class="clear-block block block-<?php print $block->module ?>"><?php if (!empty($block->subject)): ?>  <h2><?php print $block->subject ?></h2><?php endif;?>  <div class="content"><?php print $block->content ?></div></div>
<?php// $Id$/** * Implementation of hook_install(). */function search_install() {  // Create tables.  drupal_install_schema('search');}/** * Implementation of hook_uninstall(). */function search_uninstall() {  // Remove tables.  drupal_uninstall_schema('search');  variable_del('minimum_word_size');  variable_del('overlap_cjk');  variable_del('search_cron_limit');}/** * Implementation of hook_schema(). */function search_schema() {  $schema['search_dataset'] = array(    'description' => 'Stores items that will be searched.',    'fields' => array(      'sid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Search item ID, e.g. node ID for nodes.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => FALSE,        'description' => 'Type of item, e.g. node.',      ),      'data' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'List of space-separated words from the item.',      ),      'reindex' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Set to force node reindexing.',      ),    ),    'unique keys' => array('sid_type' => array('sid', 'type')),  );  $schema['search_index'] = array(    'description' => 'Stores the search index, associating words, items and scores.',    'fields' => array(      'word' => array(        'type' => 'varchar',        'length' => 50,        'not null' => TRUE,        'default' => '',        'description' => 'The {search_total}.word that is associated with the search item.',      ),      'sid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {search_dataset}.sid of the searchable item to which the word belongs.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => FALSE,        'description' => 'The {search_dataset}.type of the searchable item to which the word belongs.',      ),      'score' => array(        'type' => 'float',        'not null' => FALSE,        'description' => 'The numeric score of the word, higher being more important.',      ),    ),    'indexes' => array(      'sid_type' => array('sid', 'type'),      'word' => array('word')    ),    'unique keys' => array('word_sid_type' => array('word', 'sid', 'type')),  );  $schema['search_total'] = array(    'description' => 'Stores search totals for words.',    'fields' => array(      'word' => array(        'description' => 'Primary Key: Unique word in the search index.',        'type' => 'varchar',        'length' => 50,        'not null' => TRUE,        'default' => '',      ),      'count' => array(        'description' => "The count of the word in the index using Zipf's law to equalize the probability distribution.",        'type' => 'float',        'not null' => FALSE,      ),    ),    'primary key' => array('word'),  );  $schema['search_node_links'] = array(    'description' => 'Stores items (like nodes) that link to other nodes, used to improve search scores for nodes that are frequently linked to.',    'fields' => array(      'sid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {search_dataset}.sid of the searchable item containing the link to the node.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => TRUE,        'default' => '',        'description' => 'The {search_dataset}.type of the searchable item containing the link to the node.',      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid that this item links to.',      ),      'caption' => array(        'type' => 'text',        'size' => 'big',        'not null' => FALSE,        'description' => 'The text used to link to the {node}.nid.',      ),    ),    'primary key' => array('sid', 'type', 'nid'),    'indexes' => array('nid' => array('nid')),  );  return $schema;}
<?php// $Id$/** * @file * Drupal XML-RPC library. Based on the IXR - The Incutio XML-RPC Library - (c) Incutio Ltd 2002-2005 * Version 1.7 (beta) - Simon Willison, 23rd May 2005 * Site:   http://scripts.incutio.com/xmlrpc/ * Manual: http://scripts.incutio.com/xmlrpc/manual.php * This version is made available under the GNU GPL License *//** * Recursively turn a data structure into objects with 'data' and 'type' attributes. * * @param $data *   The data structure. * @param  $type *   Optional type assign to $data. * @return *   Object. */function xmlrpc_value($data, $type = FALSE) {  $xmlrpc_value = new stdClass();  $xmlrpc_value->data = $data;  if (!$type) {    $type = xmlrpc_value_calculate_type($xmlrpc_value);  }  $xmlrpc_value->type = $type;  if ($type == 'struct') {    // Turn all the values in the array into new xmlrpc_values    foreach ($xmlrpc_value->data as $key => $value) {      $xmlrpc_value->data[$key] = xmlrpc_value($value);    }  }  if ($type == 'array') {    for ($i = 0, $j = count($xmlrpc_value->data); $i < $j; $i++) {      $xmlrpc_value->data[$i] = xmlrpc_value($xmlrpc_value->data[$i]);    }  }  return $xmlrpc_value;}/** * Map PHP type to XML-RPC type. * * @param $xmlrpc_value *   Variable whose type should be mapped. * @return *   XML-RPC type as string. * @see *   http://www.xmlrpc.com/spec#scalars */function xmlrpc_value_calculate_type(&$xmlrpc_value) {  // http://www.php.net/gettype: Never use gettype() to test for a certain type [...] Instead, use the is_* functions.  if (is_bool($xmlrpc_value->data)) {    return 'boolean';  }  if (is_double($xmlrpc_value->data)) {    return 'double';  }  if (is_int($xmlrpc_value->data)) {      return 'int';  }  if (is_array($xmlrpc_value->data)) {    // empty or integer-indexed arrays are 'array', string-indexed arrays 'struct'    return empty($xmlrpc_value->data) || range(0, count($xmlrpc_value->data) - 1) === array_keys($xmlrpc_value->data) ? 'array' : 'struct';  }  if (is_object($xmlrpc_value->data)) {    if ($xmlrpc_value->data->is_date) {      return 'date';    }    if ($xmlrpc_value->data->is_base64) {      return 'base64';    }    $xmlrpc_value->data = get_object_vars($xmlrpc_value->data);    return 'struct';  }  // default  return 'string';}/** * Generate XML representing the given value. * * @param $xmlrpc_value * @return *   XML representation of value. */function xmlrpc_value_get_xml($xmlrpc_value) {  switch ($xmlrpc_value->type) {    case 'boolean':      return '<boolean>'. (($xmlrpc_value->data) ? '1' : '0') .'</boolean>';      break;    case 'int':      return '<int>'. $xmlrpc_value->data .'</int>';      break;    case 'double':      return '<double>'. $xmlrpc_value->data .'</double>';      break;    case 'string':      // Note: we don't escape apostrophes because of the many blogging clients      // that don't support numerical entities (and XML in general) properly.      return '<string>'. htmlspecialchars($xmlrpc_value->data) .'</string>';      break;    case 'array':      $return = '<array><data>'."\n";      foreach ($xmlrpc_value->data as $item) {        $return .= '  <value>'. xmlrpc_value_get_xml($item) ."</value>\n";      }      $return .= '</data></array>';      return $return;      break;    case 'struct':      $return = '<struct>'."\n";      foreach ($xmlrpc_value->data as $name => $value) {        $return .= "  <member><name>". check_plain($name) ."</name><value>";        $return .= xmlrpc_value_get_xml($value) ."</value></member>\n";      }      $return .= '</struct>';      return $return;      break;    case 'date':      return xmlrpc_date_get_xml($xmlrpc_value->data);      break;    case 'base64':      return xmlrpc_base64_get_xml($xmlrpc_value->data);      break;  }  return FALSE;}/** * Construct an object representing an XML-RPC message. * * @param $message *   String containing XML as defined at http://www.xmlrpc.com/spec * @return *   Object */function xmlrpc_message($message) {  $xmlrpc_message = new stdClass();  $xmlrpc_message->array_structs = array();   // The stack used to keep track of the current array/struct  $xmlrpc_message->array_structs_types = array(); // The stack used to keep track of if things are structs or array  $xmlrpc_message->current_struct_name = array();  // A stack as well  $xmlrpc_message->message = $message;  return $xmlrpc_message;}/** * Parse an XML-RPC message. If parsing fails, the faultCode and faultString * will be added to the message object. * * @param $xmlrpc_message *   Object generated by xmlrpc_message() * @return *   TRUE if parsing succeeded; FALSE otherwise */function xmlrpc_message_parse(&$xmlrpc_message) {  // First remove the XML declaration  $xmlrpc_message->message = preg_replace('/<\?xml(.*)?\?'.'>/', '', $xmlrpc_message->message);  if (trim($xmlrpc_message->message) == '') {    return FALSE;  }  $xmlrpc_message->_parser = xml_parser_create();  // Set XML parser to take the case of tags into account.  xml_parser_set_option($xmlrpc_message->_parser, XML_OPTION_CASE_FOLDING, FALSE);  // Set XML parser callback functions  xml_set_element_handler($xmlrpc_message->_parser, 'xmlrpc_message_tag_open', 'xmlrpc_message_tag_close');  xml_set_character_data_handler($xmlrpc_message->_parser, 'xmlrpc_message_cdata');  xmlrpc_message_set($xmlrpc_message);  if (!xml_parse($xmlrpc_message->_parser, $xmlrpc_message->message)) {    return FALSE;  }  xml_parser_free($xmlrpc_message->_parser);  // Grab the error messages, if any  $xmlrpc_message = xmlrpc_message_get();  if ($xmlrpc_message->messagetype == 'fault') {    $xmlrpc_message->fault_code = $xmlrpc_message->params[0]['faultCode'];    $xmlrpc_message->fault_string = $xmlrpc_message->params[0]['faultString'];  }  return TRUE;}/** * Store a copy of the $xmlrpc_message object temporarily. * * @param $value *   Object * @return *   The most recently stored $xmlrpc_message */function xmlrpc_message_set($value = NULL) {  static $xmlrpc_message;  if ($value) {    $xmlrpc_message = $value;  }  return $xmlrpc_message;}function xmlrpc_message_get() {  return xmlrpc_message_set();}function xmlrpc_message_tag_open($parser, $tag, $attr) {  $xmlrpc_message = xmlrpc_message_get();  $xmlrpc_message->current_tag_contents = '';  $xmlrpc_message->last_open = $tag;  switch ($tag) {    case 'methodCall':    case 'methodResponse':    case 'fault':      $xmlrpc_message->messagetype = $tag;      break;    // Deal with stacks of arrays and structs    case 'data':      $xmlrpc_message->array_structs_types[] = 'array';      $xmlrpc_message->array_structs[] = array();      break;    case 'struct':      $xmlrpc_message->array_structs_types[] = 'struct';      $xmlrpc_message->array_structs[] = array();      break;  }  xmlrpc_message_set($xmlrpc_message);}function xmlrpc_message_cdata($parser, $cdata) {  $xmlrpc_message = xmlrpc_message_get();  $xmlrpc_message->current_tag_contents .= $cdata;  xmlrpc_message_set($xmlrpc_message);}function xmlrpc_message_tag_close($parser, $tag) {  $xmlrpc_message = xmlrpc_message_get();  $value_flag = FALSE;  switch ($tag) {    case 'int':    case 'i4':      $value = (int)trim($xmlrpc_message->current_tag_contents);      $value_flag = TRUE;      break;    case 'double':      $value = (double)trim($xmlrpc_message->current_tag_contents);      $value_flag = TRUE;      break;    case 'string':      $value = $xmlrpc_message->current_tag_contents;      $value_flag = TRUE;      break;    case 'dateTime.iso8601':      $value = xmlrpc_date(trim($xmlrpc_message->current_tag_contents));      // $value = $iso->getTimestamp();      $value_flag = TRUE;      break;    case 'value':      // If no type is indicated, the type is string      // We take special care for empty values      if (trim($xmlrpc_message->current_tag_contents) != '' || (isset($xmlrpc_message->last_open) && ($xmlrpc_message->last_open == 'value'))) {        $value = (string)$xmlrpc_message->current_tag_contents;        $value_flag = TRUE;      }      unset($xmlrpc_message->last_open);      break;    case 'boolean':      $value = (boolean)trim($xmlrpc_message->current_tag_contents);      $value_flag = TRUE;      break;    case 'base64':      $value = base64_decode(trim($xmlrpc_message->current_tag_contents));      $value_flag = TRUE;      break;    // Deal with stacks of arrays and structs    case 'data':    case 'struct':      $value = array_pop($xmlrpc_message->array_structs );      array_pop($xmlrpc_message->array_structs_types);      $value_flag = TRUE;      break;    case 'member':      array_pop($xmlrpc_message->current_struct_name);      break;    case 'name':      $xmlrpc_message->current_struct_name[] = trim($xmlrpc_message->current_tag_contents);      break;    case 'methodName':      $xmlrpc_message->methodname = trim($xmlrpc_message->current_tag_contents);      break;  }  if ($value_flag) {    if (count($xmlrpc_message->array_structs ) > 0) {      // Add value to struct or array      if ($xmlrpc_message->array_structs_types[count($xmlrpc_message->array_structs_types)-1] == 'struct') {        // Add to struct        $xmlrpc_message->array_structs [count($xmlrpc_message->array_structs )-1][$xmlrpc_message->current_struct_name[count($xmlrpc_message->current_struct_name)-1]] = $value;      }      else {        // Add to array        $xmlrpc_message->array_structs [count($xmlrpc_message->array_structs )-1][] = $value;      }    }    else {      // Just add as a parameter      $xmlrpc_message->params[] = $value;    }  }  if (!in_array($tag, array("data", "struct", "member"))) {    $xmlrpc_message->current_tag_contents = '';  }  xmlrpc_message_set($xmlrpc_message);}/** * Construct an object representing an XML-RPC request * * @param $method *   The name of the method to be called * @param $args *   An array of parameters to send with the method. * @return *   Object */function xmlrpc_request($method, $args) {  $xmlrpc_request = new stdClass();  $xmlrpc_request->method = $method;  $xmlrpc_request->args = $args;  $xmlrpc_request->xml = <<<EOD<?xml version="1.0"?><methodCall><methodName>{$xmlrpc_request->method}</methodName><params>EOD;  foreach ($xmlrpc_request->args as $arg) {    $xmlrpc_request->xml .= '<param><value>';    $v = xmlrpc_value($arg);    $xmlrpc_request->xml .= xmlrpc_value_get_xml($v);    $xmlrpc_request->xml .= "</value></param>\n";  }  $xmlrpc_request->xml .= '</params></methodCall>';  return $xmlrpc_request;}function xmlrpc_error($code = NULL, $message = NULL, $reset = FALSE) {  static $xmlrpc_error;  if (isset($code)) {    $xmlrpc_error = new stdClass();    $xmlrpc_error->is_error = TRUE;    $xmlrpc_error->code = $code;    $xmlrpc_error->message = $message;  }  elseif ($reset) {    $xmlrpc_error = NULL;  }  return $xmlrpc_error;}function xmlrpc_error_get_xml($xmlrpc_error) {  return <<<EOD<methodResponse>  <fault>  <value>    <struct>    <member>      <name>faultCode</name>      <value><int>{$xmlrpc_error->code}</int></value>    </member>    <member>      <name>faultString</name>      <value><string>{$xmlrpc_error->message}</string></value>    </member>    </struct>  </value>  </fault></methodResponse>EOD;}function xmlrpc_date($time) {  $xmlrpc_date = new stdClass();  $xmlrpc_date->is_date = TRUE;  // $time can be a PHP timestamp or an ISO one  if (is_numeric($time)) {    $xmlrpc_date->year = gmdate('Y', $time);    $xmlrpc_date->month = gmdate('m', $time);    $xmlrpc_date->day = gmdate('d', $time);    $xmlrpc_date->hour = gmdate('H', $time);    $xmlrpc_date->minute = gmdate('i', $time);    $xmlrpc_date->second = gmdate('s', $time);    $xmlrpc_date->iso8601 = gmdate('Ymd\TH:i:s', $time);  }  else {    $xmlrpc_date->iso8601 = $time;    $time = str_replace(array('-', ':'), '', $time);    $xmlrpc_date->year = substr($time, 0, 4);    $xmlrpc_date->month = substr($time, 4, 2);    $xmlrpc_date->day = substr($time, 6, 2);    $xmlrpc_date->hour = substr($time, 9, 2);    $xmlrpc_date->minute = substr($time, 11, 2);    $xmlrpc_date->second = substr($time, 13, 2);  }  return $xmlrpc_date;}function xmlrpc_date_get_xml($xmlrpc_date) {  return '<dateTime.iso8601>'. $xmlrpc_date->year . $xmlrpc_date->month . $xmlrpc_date->day .'T'. $xmlrpc_date->hour .':'. $xmlrpc_date->minute .':'. $xmlrpc_date->second .'</dateTime.iso8601>';}function xmlrpc_base64($data) {  $xmlrpc_base64 = new stdClass();  $xmlrpc_base64->is_base64 = TRUE;  $xmlrpc_base64->data = $data;  return $xmlrpc_base64;}function xmlrpc_base64_get_xml($xmlrpc_base64) {  return '<base64>'. base64_encode($xmlrpc_base64->data) .'</base64>';}/** * Execute an XML remote procedural call. This is private function; call xmlrpc() * in common.inc instead of this function. * * @return *   A $xmlrpc_message object if the call succeeded; FALSE if the call failed */function _xmlrpc() {  $args = func_get_args();  $url = array_shift($args);  xmlrpc_clear_error();  if (is_array($args[0])) {    $method = 'system.multicall';    $multicall_args = array();    foreach ($args[0] as $call) {      $multicall_args[] = array('methodName' => array_shift($call), 'params' => $call);    }    $args = array($multicall_args);  }  else {    $method = array_shift($args);  }  $xmlrpc_request = xmlrpc_request($method, $args);  $result = drupal_http_request($url, array("Content-Type" => "text/xml"), 'POST', $xmlrpc_request->xml);  if ($result->code != 200) {    xmlrpc_error($result->code, $result->error);    return FALSE;  }  $message = xmlrpc_message($result->data);  // Now parse what we've got back  if (!xmlrpc_message_parse($message)) {    // XML error    xmlrpc_error(-32700, t('Parse error. Not well formed'));    return FALSE;  }  // Is the message a fault?  if ($message->messagetype == 'fault') {    xmlrpc_error($message->fault_code, $message->fault_string);    return FALSE;  }  // Message must be OK  return $message->params[0];}/** * Returns the last XML-RPC client error number */function xmlrpc_errno() {  $error = xmlrpc_error();  return ($error != NULL ? $error->code : NULL);}/** * Returns the last XML-RPC client error message */function xmlrpc_error_msg() {  $error = xmlrpc_error();  return ($error != NULL ? $error->message : NULL);}/** * Clears any previous error. */function xmlrpc_clear_error() {  xmlrpc_error(NULL, NULL, TRUE);}
<?php// $Id$/** * Indicates an error during check for PHP unicode support. */define('UNICODE_ERROR', -1);/** * Indicates that standard PHP (emulated) unicode support is being used. */define('UNICODE_SINGLEBYTE', 0);/** * Indicates that full unicode support with the PHP mbstring extension is being * used. */define('UNICODE_MULTIBYTE', 1);/** * Wrapper around _unicode_check(). */function unicode_check() {  list($GLOBALS['multibyte']) = _unicode_check();}/** * Perform checks about Unicode support in PHP, and set the right settings if * needed. * * Because Drupal needs to be able to handle text in various encodings, we do * not support mbstring function overloading. HTTP input/output conversion must * be disabled for similar reasons. * * @param $errors *   Whether to report any fatal errors with form_set_error(). */function _unicode_check() {  // Ensure translations don't break at install time  $t = get_t();  // Set the standard C locale to ensure consistent, ASCII-only string handling.  setlocale(LC_CTYPE, 'C');  // Check for outdated PCRE library  // Note: we check if U+E2 is in the range U+E0 - U+E1. This test returns TRUE on old PCRE versions.  if (preg_match('/[-]/u', '')) {    return array(UNICODE_ERROR, $t('The PCRE library in your PHP installation is outdated. This will cause problems when handling Unicode text. If you are running PHP 4.3.3 or higher, make sure you are using the PCRE library supplied by PHP. Please refer to the <a href="@url">PHP PCRE documentation</a> for more information.', array('@url' => 'http://www.php.net/pcre')));  }  // Check for mbstring extension  if (!function_exists('mb_strlen')) {    return array(UNICODE_SINGLEBYTE, $t('Operations on Unicode strings are emulated on a best-effort basis. Install the <a href="@url">PHP mbstring extension</a> for improved Unicode support.', array('@url' => 'http://www.php.net/mbstring')));  }  // Check mbstring configuration  if (ini_get('mbstring.func_overload') != 0) {    return array(UNICODE_ERROR, $t('Multibyte string function overloading in PHP is active and must be disabled. Check the php.ini <em>mbstring.func_overload</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.encoding_translation') != 0) {    return array(UNICODE_ERROR, $t('Multibyte string input conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.encoding_translation</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.http_input') != 'pass') {    return array(UNICODE_ERROR, $t('Multibyte string input conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.http_input</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.http_output') != 'pass') {    return array(UNICODE_ERROR, $t('Multibyte string output conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.http_output</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  // Set appropriate configuration  mb_internal_encoding('utf-8');  mb_language('uni');  return array(UNICODE_MULTIBYTE, '');}/** * Return Unicode library status and errors. */function unicode_requirements() {  // Ensure translations don't break at install time  $t = get_t();  $libraries = array(    UNICODE_SINGLEBYTE => $t('Standard PHP'),    UNICODE_MULTIBYTE => $t('PHP Mbstring Extension'),    UNICODE_ERROR => $t('Error'),  );  $severities = array(    UNICODE_SINGLEBYTE => REQUIREMENT_WARNING,    UNICODE_MULTIBYTE => REQUIREMENT_OK,    UNICODE_ERROR => REQUIREMENT_ERROR,  );  list($library, $description) = _unicode_check();  $requirements['unicode'] = array(    'title' => $t('Unicode library'),    'value' => $libraries[$library],  );  if ($description) {    $requirements['unicode']['description'] = $description;  }  $requirements['unicode']['severity'] = $severities[$library];  return $requirements;}/** * Prepare a new XML parser. * * This is a wrapper around xml_parser_create() which extracts the encoding from * the XML data first and sets the output encoding to UTF-8. This function should * be used instead of xml_parser_create(), because PHP 4's XML parser doesn't * check the input encoding itself. "Starting from PHP 5, the input encoding is * automatically detected, so that the encoding parameter specifies only the * output encoding." * * This is also where unsupported encodings will be converted. Callers should * take this into account: $data might have been changed after the call. * * @param &$data *   The XML data which will be parsed later. * @return *   An XML parser object. */function drupal_xml_parser_create(&$data) {  // Default XML encoding is UTF-8  $encoding = 'utf-8';  $bom = FALSE;  // Check for UTF-8 byte order mark (PHP5's XML parser doesn't handle it).  if (!strncmp($data, "\xEF\xBB\xBF", 3)) {    $bom = TRUE;    $data = substr($data, 3);  }  // Check for an encoding declaration in the XML prolog if no BOM was found.  if (!$bom && ereg('^<\?xml[^>]+encoding="([^"]+)"', $data, $match)) {    $encoding = $match[1];  }  // Unsupported encodings are converted here into UTF-8.  $php_supported = array('utf-8', 'iso-8859-1', 'us-ascii');  if (!in_array(strtolower($encoding), $php_supported)) {    $out = drupal_convert_to_utf8($data, $encoding);    if ($out !== FALSE) {      $encoding = 'utf-8';      $data = ereg_replace('^(<\?xml[^>]+encoding)="([^"]+)"', '\\1="utf-8"', $out);    }    else {      watchdog('php', 'Could not convert XML encoding %s to UTF-8.', array('%s' => $encoding), WATCHDOG_WARNING);      return 0;    }  }  $xml_parser = xml_parser_create($encoding);  xml_parser_set_option($xml_parser, XML_OPTION_TARGET_ENCODING, 'utf-8');  return $xml_parser;}/** * Convert data to UTF-8 * * Requires the iconv, GNU recode or mbstring PHP extension. * * @param $data *   The data to be converted. * @param $encoding *   The encoding that the data is in * @return *   Converted data or FALSE. */function drupal_convert_to_utf8($data, $encoding) {  if (function_exists('iconv')) {    $out = @iconv($encoding, 'utf-8', $data);  }  else if (function_exists('mb_convert_encoding')) {    $out = @mb_convert_encoding($data, 'utf-8', $encoding);  }  else if (function_exists('recode_string')) {    $out = @recode_string($encoding .'..utf-8', $data);  }  else {    watchdog('php', 'Unsupported encoding %s. Please install iconv, GNU recode or mbstring for PHP.', array('%s' => $encoding), WATCHDOG_ERROR);    return FALSE;  }  return $out;}/** * Truncate a UTF-8-encoded string safely to a number of bytes. * * If the end position is in the middle of a UTF-8 sequence, it scans backwards * until the beginning of the byte sequence. * * Use this function whenever you want to chop off a string at an unsure * location. On the other hand, if you're sure that you're splitting on a * character boundary (e.g. after using strpos() or similar), you can safely use * substr() instead. * * @param $string *   The string to truncate. * @param $len *   An upper limit on the returned string length. * @return *   The truncated string. */function drupal_truncate_bytes($string, $len) {  if (strlen($string) <= $len) {    return $string;  }  if ((ord($string[$len]) < 0x80) || (ord($string[$len]) >= 0xC0)) {    return substr($string, 0, $len);  }  while (--$len >= 0 && ord($string[$len]) >= 0x80 && ord($string[$len]) < 0xC0) {};  return substr($string, 0, $len);}/** * Truncate a UTF-8-encoded string safely to a number of characters. * * @param $string *   The string to truncate. * @param $len *   An upper limit on the returned string length. * @param $wordsafe *   Flag to truncate at last space within the upper limit. Defaults to FALSE. * @param $dots *   Flag to add trailing dots. Defaults to FALSE. * @return *   The truncated string. */function truncate_utf8($string, $len, $wordsafe = FALSE, $dots = FALSE) {  if (drupal_strlen($string) <= $len) {    return $string;  }  if ($dots) {    $len -= 4;  }  if ($wordsafe) {    $string = drupal_substr($string, 0, $len + 1); // leave one more character    if ($last_space = strrpos($string, ' ')) { // space exists AND is not on position 0      $string = substr($string, 0, $last_space);    }    else {      $string = drupal_substr($string, 0, $len);    }  }  else {    $string = drupal_substr($string, 0, $len);  }  if ($dots) {    $string .= ' ...';  }  return $string;}/** * Encodes MIME/HTTP header values that contain non-ASCII, UTF-8 encoded * characters. * * For example, mime_header_encode('tst.txt') returns "=?UTF-8?B?dMOpc3QudHh0?=". * * See http://www.rfc-editor.org/rfc/rfc2047.txt for more information. * * Notes: * - Only encode strings that contain non-ASCII characters. * - We progressively cut-off a chunk with truncate_utf8(). This is to ensure *   each chunk starts and ends on a character boundary. * - Using \n as the chunk separator may cause problems on some systems and may *   have to be changed to \r\n or \r. */function mime_header_encode($string) {  if (preg_match('/[^\x20-\x7E]/', $string)) {    $chunk_size = 47; // floor((75 - strlen("=?UTF-8?B??=")) * 0.75);    $len = strlen($string);    $output = '';    while ($len > 0) {      $chunk = drupal_truncate_bytes($string, $chunk_size);      $output .= ' =?UTF-8?B?'. base64_encode($chunk) ."?=\n";      $c = strlen($chunk);      $string = substr($string, $c);      $len -= $c;    }    return trim($output);  }  return $string;}/** * Complement to mime_header_encode */function mime_header_decode($header) {  // First step: encoded chunks followed by other encoded chunks (need to collapse whitespace)  $header = preg_replace_callback('/=\?([^?]+)\?(Q|B)\?([^?]+|\?(?!=))\?=\s+(?==\?)/', '_mime_header_decode', $header);  // Second step: remaining chunks (do not collapse whitespace)  return preg_replace_callback('/=\?([^?]+)\?(Q|B)\?([^?]+|\?(?!=))\?=/', '_mime_header_decode', $header);}/** * Helper function to mime_header_decode */function _mime_header_decode($matches) {  // Regexp groups:  // 1: Character set name  // 2: Escaping method (Q or B)  // 3: Encoded data  $data = ($matches[2] == 'B') ? base64_decode($matches[3]) : str_replace('_', ' ', quoted_printable_decode($matches[3]));  if (strtolower($matches[1]) != 'utf-8') {    $data = drupal_convert_to_utf8($data, $matches[1]);  }  return $data;}/** * Decode all HTML entities (including numerical ones) to regular UTF-8 bytes. * Double-escaped entities will only be decoded once ("&amp;lt;" becomes "&lt;", not "<"). * * @param $text *   The text to decode entities in. * @param $exclude *   An array of characters which should not be decoded. For example, *   array('<', '&', '"'). This affects both named and numerical entities. */function decode_entities($text, $exclude = array()) {  static $table;  // We store named entities in a table for quick processing.  if (!isset($table)) {    // Get all named HTML entities.    $table = array_flip(get_html_translation_table(HTML_ENTITIES));    // PHP gives us ISO-8859-1 data, we need UTF-8.    $table = array_map('utf8_encode', $table);    // Add apostrophe (XML)    $table['&apos;'] = "'";  }  $newtable = array_diff($table, $exclude);  // Use a regexp to select all entities in one pass, to avoid decoding double-escaped entities twice.  return preg_replace('/&(#x?)?([A-Za-z0-9]+);/e', '_decode_entities("$1", "$2", "$0", $newtable, $exclude)', $text);}/** * Helper function for decode_entities */function _decode_entities($prefix, $codepoint, $original, &$table, &$exclude) {  // Named entity  if (!$prefix) {    if (isset($table[$original])) {      return $table[$original];    }    else {      return $original;    }  }  // Hexadecimal numerical entity  if ($prefix == '#x') {    $codepoint = base_convert($codepoint, 16, 10);  }  // Decimal numerical entity (strip leading zeros to avoid PHP octal notation)  else {    $codepoint = preg_replace('/^0+/', '', $codepoint);  }  // Encode codepoint as UTF-8 bytes  if ($codepoint < 0x80) {    $str = chr($codepoint);  }  else if ($codepoint < 0x800) {    $str = chr(0xC0 | ($codepoint >> 6))         . chr(0x80 | ($codepoint & 0x3F));  }  else if ($codepoint < 0x10000) {    $str = chr(0xE0 | ( $codepoint >> 12))         . chr(0x80 | (($codepoint >> 6) & 0x3F))         . chr(0x80 | ( $codepoint       & 0x3F));  }  else if ($codepoint < 0x200000) {    $str = chr(0xF0 | ( $codepoint >> 18))         . chr(0x80 | (($codepoint >> 12) & 0x3F))         . chr(0x80 | (($codepoint >> 6)  & 0x3F))         . chr(0x80 | ( $codepoint        & 0x3F));  }  // Check for excluded characters  if (in_array($str, $exclude)) {    return $original;  }  else {    return $str;  }}/** * Count the amount of characters in a UTF-8 string. This is less than or * equal to the byte count. */function drupal_strlen($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strlen($text);  }  else {    // Do not count UTF-8 continuation bytes.    return strlen(preg_replace("/[\x80-\xBF]/", '', $text));  }}/** * Uppercase a UTF-8 string. */function drupal_strtoupper($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strtoupper($text);  }  else {    // Use C-locale for ASCII-only uppercase    $text = strtoupper($text);    // Case flip Latin-1 accented letters    $text = preg_replace_callback('/\xC3[\xA0-\xB6\xB8-\xBE]/', '_unicode_caseflip', $text);    return $text;  }}/** * Lowercase a UTF-8 string. */function drupal_strtolower($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strtolower($text);  }  else {    // Use C-locale for ASCII-only lowercase    $text = strtolower($text);    // Case flip Latin-1 accented letters    $text = preg_replace_callback('/\xC3[\x80-\x96\x98-\x9E]/', '_unicode_caseflip', $text);    return $text;  }}/** * Helper function for case conversion of Latin-1. * Used for flipping U+C0-U+DE to U+E0-U+FD and back. */function _unicode_caseflip($matches) {  return $matches[0][0] . chr(ord($matches[0][1]) ^ 32);}/** * Capitalize the first letter of a UTF-8 string. */function drupal_ucfirst($text) {  // Note: no mbstring equivalent!  return drupal_strtoupper(drupal_substr($text, 0, 1)) . drupal_substr($text, 1);}/** * Cut off a piece of a string based on character indices and counts. Follows * the same behavior as PHP's own substr() function. * * Note that for cutting off a string at a known character/substring * location, the usage of PHP's normal strpos/substr is safe and * much faster. */function drupal_substr($text, $start, $length = NULL) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return $length === NULL ? mb_substr($text, $start) : mb_substr($text, $start, $length);  }  else {    $strlen = strlen($text);    // Find the starting byte offset    $bytes = 0;    if ($start > 0) {      // Count all the continuation bytes from the start until we have found      // $start characters      $bytes = -1; $chars = -1;      while ($bytes < $strlen && $chars < $start) {        $bytes++;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }    }    else if ($start < 0) {      // Count all the continuation bytes from the end until we have found      // abs($start) characters      $start = abs($start);      $bytes = $strlen; $chars = 0;      while ($bytes > 0 && $chars < $start) {        $bytes--;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }    }    $istart = $bytes;    // Find the ending byte offset    if ($length === NULL) {      $bytes = $strlen - 1;    }    else if ($length > 0) {      // Count all the continuation bytes from the starting index until we have      // found $length + 1 characters. Then backtrack one byte.      $bytes = $istart; $chars = 0;      while ($bytes < $strlen && $chars < $length) {        $bytes++;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }      $bytes--;    }    else if ($length < 0) {      // Count all the continuation bytes from the end until we have found      // abs($length) characters      $length = abs($length);      $bytes = $strlen - 1; $chars = 0;      while ($bytes >= 0 && $chars < $length) {        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }        $bytes--;      }    }    $iend = $bytes;    return substr($text, $istart, max(0, $iend - $istart + 1));  }}
<?php// $Id$/** * @file * User page callbacks for the profile module. *//** * Menu callback; display a list of user information. */function profile_browse() {  // Ensure that the path is converted to 3 levels always.  list(, $name, $value) = array_pad(explode('/', $_GET['q'], 3), 3, '');  $field = db_fetch_object(db_query("SELECT DISTINCT(fid), type, title, page, visibility FROM {profile_fields} WHERE name = '%s'", $name));  if ($name && $field->fid) {    // Only allow browsing of fields that have a page title set.    if (empty($field->page)) {      drupal_not_found();      return;    }    // Do not allow browsing of private and hidden fields by non-admins.    if (!user_access('administer users') && ($field->visibility == PROFILE_PRIVATE || $field->visibility == PROFILE_HIDDEN)) {      drupal_access_denied();      return;    }    // Compile a list of fields to show.    $fields = array();    $result = db_query('SELECT name, title, type, weight, page FROM {profile_fields} WHERE fid != %d AND visibility = %d ORDER BY weight', $field->fid, PROFILE_PUBLIC_LISTINGS);    while ($record = db_fetch_object($result)) {      $fields[] = $record;    }    // Determine what query to use:    $arguments = array($field->fid);    switch ($field->type) {      case 'checkbox':        $query = 'v.value = 1';        break;      case 'textfield':      case 'selection':        $query = "v.value = '%s'";        $arguments[] = $value;        break;      case 'list':        $query = "v.value LIKE '%%%s%%'";        $arguments[] = $value;        break;      default:        drupal_not_found();        return;    }    // Extract the affected users:    $result = pager_query("SELECT u.uid, u.access FROM {users} u INNER JOIN {profile_values} v ON u.uid = v.uid WHERE v.fid = %d AND $query AND u.access != 0 AND u.status != 0 ORDER BY u.access DESC", 20, 0, NULL, $arguments);    $content = '';    while ($account = db_fetch_object($result)) {      $account = user_load(array('uid' => $account->uid));      $profile = _profile_update_user_fields($fields, $account);      $content .= theme('profile_listing', $account, $profile);    }    $output = theme('profile_wrapper', $content);    $output .= theme('pager', NULL, 20);    if ($field->type == 'selection' || $field->type == 'list' || $field->type == 'textfield') {      $title = strtr(check_plain($field->page), array('%value' => theme('placeholder', $value)));    }    else {      $title = check_plain($field->page);    }    drupal_set_title($title);    return $output;  }  else if ($name && !$field->fid) {    drupal_not_found();  }  else {    // Compile a list of fields to show.    $fields = array();    $result = db_query('SELECT name, title, type, weight, page FROM {profile_fields} WHERE visibility = %d ORDER BY category, weight', PROFILE_PUBLIC_LISTINGS);    while ($record = db_fetch_object($result)) {      $fields[] = $record;    }    // Extract the affected users:    $result = pager_query('SELECT uid, access FROM {users} WHERE uid > 0 AND status != 0 AND access != 0 ORDER BY access DESC', 20, 0, NULL);    $content = '';    while ($account = db_fetch_object($result)) {      $account = user_load(array('uid' => $account->uid));      $profile = _profile_update_user_fields($fields, $account);      $content .= theme('profile_listing', $account, $profile);    }    $output = theme('profile_wrapper', $content);    $output .= theme('pager', NULL, 20);    drupal_set_title(t('User list'));    return $output;  }}/** * Callback to allow autocomplete of profile text fields. */function profile_autocomplete($field, $string) {  $matches = array();  if (db_result(db_query("SELECT COUNT(*) FROM {profile_fields} WHERE fid = %d AND autocomplete = 1", $field))) {    $result = db_query_range("SELECT value FROM {profile_values} WHERE fid = %d AND LOWER(value) LIKE LOWER('%s%%') GROUP BY value ORDER BY value ASC", $field, $string, 0, 10);    while ($data = db_fetch_object($result)) {      $matches[$data->value] = check_plain($data->value);    }  }  drupal_json($matches);}
<?php// $Id$/** * @file * Administrative page callbacks for menu module. *//** * Menu callback which shows an overview page of all the custom menus and their descriptions. */function menu_overview_page() {  $result = db_query("SELECT * FROM {menu_custom} ORDER BY title");  $content = array();  while ($menu = db_fetch_array($result)) {    $menu['href'] = 'admin/build/menu-customize/'. $menu['menu_name'];    $menu['localized_options'] = array();    $menu['description'] = filter_xss_admin($menu['description']);    $content[] = $menu;  }  return theme('admin_block_content', $content);}/** * Form for editing an entire menu tree at once. * * Shows for one menu the menu items accessible to the current user and * relevant operations. */function menu_overview_form(&$form_state, $menu) {  global $menu_admin;  $sql = "    SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*    FROM {menu_links} ml LEFT JOIN {menu_router} m ON m.path = ml.router_path    WHERE ml.menu_name = '%s'    ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC";  $result = db_query($sql, $menu['menu_name']);  $tree = menu_tree_data($result);  $node_links = array();  menu_tree_collect_node_links($tree, $node_links);  // We indicate that a menu administrator is running the menu access check.  $menu_admin = TRUE;  menu_tree_check_access($tree, $node_links);  $menu_admin = FALSE;  $form = _menu_overview_tree_form($tree);  $form['#menu'] =  $menu;  if (element_children($form)) {    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Save configuration'),    );  }  else {    $form['empty_menu'] = array('#value' => t('There are no menu items yet.'));  }  return $form;}/** * Recursive helper function for menu_overview_form(). */function _menu_overview_tree_form($tree) {  static $form = array('#tree' => TRUE);  foreach ($tree as $data) {    $title = '';    $item = $data['link'];    // Don't show callbacks; these have $item['hidden'] < 0.    if ($item && $item['hidden'] >= 0) {      $mlid = 'mlid:'. $item['mlid'];      $form[$mlid]['#item'] = $item;      $form[$mlid]['#attributes'] = $item['hidden'] ? array('class' => 'menu-disabled') : array('class' => 'menu-enabled');      $form[$mlid]['title']['#value'] = l($item['title'], $item['href'], $item['localized_options']) . ($item['hidden'] ? ' ('. t('disabled') .')' : '');      $form[$mlid]['hidden'] = array(        '#type' => 'checkbox',        '#default_value' => !$item['hidden'],      );      $form[$mlid]['expanded'] = array(        '#type' => 'checkbox',        '#default_value' => $item['expanded'],      );      $form[$mlid]['weight'] = array(        '#type' => 'weight',        '#delta' => 50,        '#default_value' => isset($form_state[$mlid]['weight']) ? $form_state[$mlid]['weight'] : $item['weight'],      );      $form[$mlid]['mlid'] = array(        '#type' => 'hidden',        '#value' => $item['mlid'],      );      $form[$mlid]['plid'] = array(        '#type' => 'textfield',        '#default_value' => isset($form_state[$mlid]['plid']) ? $form_state[$mlid]['plid'] : $item['plid'],        '#size' => 6,      );      // Build a list of operations.      $operations = array();      $operations['edit'] = l(t('edit'), 'admin/build/menu/item/'. $item['mlid'] .'/edit');      // Only items created by the menu module can be deleted.      if ($item['module'] == 'menu' || $item['updated'] == 1) {        $operations['delete'] = l(t('delete'), 'admin/build/menu/item/'. $item['mlid'] .'/delete');      }      // Set the reset column.      elseif ($item['module'] == 'system' && $item['customized']) {        $operations['reset'] = l(t('reset'), 'admin/build/menu/item/'. $item['mlid'] .'/reset');      }      $form[$mlid]['operations'] = array();      foreach ($operations as $op => $value) {        $form[$mlid]['operations'][$op] = array('#value' => $value);      }    }    if ($data['below']) {      _menu_overview_tree_form($data['below']);    }  }  return $form;}/** * Submit handler for the menu overview form. * * This function takes great care in saving parent items first, then items * underneath them. Saving items in the incorrect order can break the menu tree. * * @see menu_overview_form() */function menu_overview_form_submit($form, &$form_state) {  // When dealing with saving menu items, the order in which these items are  // saved is critical. If a changed child item is saved before its parent,  // the child item could be saved with an invalid path past its immediate  // parent. To prevent this, save items in the form in the same order they  // are sent by $_POST, ensuring parents are saved first, then their children.  // See http://drupal.org/node/181126#comment-632270  $order = array_flip(array_keys($form['#post'])); // Get the $_POST order.  $form = array_merge($order, $form); // Update our original form with the new order.  $updated_items = array();  $fields = array('expanded', 'weight', 'plid');  foreach (element_children($form) as $mlid) {    if (isset($form[$mlid]['#item'])) {      $element = $form[$mlid];      // Update any fields that have changed in this menu item.      foreach ($fields as $field) {        if ($element[$field]['#value'] != $element[$field]['#default_value']) {          $element['#item'][$field] = $element[$field]['#value'];          $updated_items[$mlid] = $element['#item'];        }      }      // Hidden is a special case, the value needs to be reversed.      if ($element['hidden']['#value'] != $element['hidden']['#default_value']) {        $element['#item']['hidden'] = !$element['hidden']['#value'];        $updated_items[$mlid] = $element['#item'];      }    }  }  // Save all our changed items to the database.  foreach ($updated_items as $item) {    $item['customized'] = 1;    menu_link_save($item);  }}/** * Theme the menu overview form into a table. * * @ingroup themeable */function theme_menu_overview_form($form) {  drupal_add_tabledrag('menu-overview', 'match', 'parent', 'menu-plid', 'menu-plid', 'menu-mlid', TRUE, MENU_MAX_DEPTH - 1);  drupal_add_tabledrag('menu-overview', 'order', 'sibling', 'menu-weight');  $header = array(    t('Menu item'),    array('data' => t('Enabled'), 'class' => 'checkbox'),    array('data' => t('Expanded'), 'class' => 'checkbox'),    t('Weight'),    array('data' => t('Operations'), 'colspan' => '3'),  );  $rows = array();  foreach (element_children($form) as $mlid) {    if (isset($form[$mlid]['hidden'])) {      $element = &$form[$mlid];      // Build a list of operations.      $operations = array();      foreach (element_children($element['operations']) as $op) {        $operations[] = drupal_render($element['operations'][$op]);      }      while (count($operations) < 2) {        $operations[] = '';      }      // Add special classes to be used for tabledrag.js.      $element['plid']['#attributes']['class'] = 'menu-plid';      $element['mlid']['#attributes']['class'] = 'menu-mlid';      $element['weight']['#attributes']['class'] = 'menu-weight';      // Change the parent field to a hidden. This allows any value but hides the field.      $element['plid']['#type'] = 'hidden';      $row = array();      $row[] = theme('indentation', $element['#item']['depth'] - 1) . drupal_render($element['title']);      $row[] = array('data' => drupal_render($element['hidden']), 'class' => 'checkbox');      $row[] = array('data' => drupal_render($element['expanded']), 'class' => 'checkbox');      $row[] = drupal_render($element['weight']) . drupal_render($element['plid']) . drupal_render($element['mlid']);      $row = array_merge($row, $operations);      $row = array_merge(array('data' => $row), $element['#attributes']);      $row['class'] = !empty($row['class']) ? $row['class'] .' draggable' : 'draggable';      $rows[] = $row;    }  }  $output = '';  if ($rows) {    $output .= theme('table', $header, $rows, array('id' => 'menu-overview'));  }  $output .= drupal_render($form);  return $output;}/** * Menu callback; Build the menu link editing form. */function menu_edit_item(&$form_state, $type, $item, $menu) {  $form['menu'] = array(    '#type' => 'fieldset',    '#title' => t('Menu settings'),    '#collapsible' => FALSE,    '#tree' => TRUE,    '#weight' => -2,    '#attributes' => array('class' => 'menu-item-form'),    '#item' => $item,  );  if ($type == 'add' || empty($item)) {    // This is an add form, initialize the menu link.    $item = array('link_title' => '', 'mlid' => 0, 'plid' => 0, 'menu_name' => $menu['menu_name'], 'weight' => 0, 'link_path' => '', 'options' => array(), 'module' => 'menu', 'expanded' => 0, 'hidden' => 0, 'has_children' => 0);  }  foreach (array('link_path', 'mlid', 'module', 'has_children', 'options') as $key) {    $form['menu'][$key] = array('#type' => 'value', '#value' => $item[$key]);  }  // Any item created or edited via this interface is considered "customized".  $form['menu']['customized'] = array('#type' => 'value', '#value' => 1);  $form['menu']['original_item'] = array('#type' => 'value', '#value' => $item);  $path = $item['link_path'];  if (isset($item['options']['query'])) {    $path .= '?'. $item['options']['query'];  }  if (isset($item['options']['fragment'])) {    $path .= '#'. $item['options']['fragment'];  }  if ($item['module'] == 'menu') {    $form['menu']['link_path'] = array(      '#type' => 'textfield',      '#title' => t('Path'),      '#default_value' => $path,      '#description' => t('The path this menu item links to. This can be an internal Drupal path such as %add-node or an external URL such as %drupal. Enter %front to link to the front page.', array('%front' => '<front>', '%add-node' => 'node/add', '%drupal' => 'http://drupal.org')),      '#required' => TRUE,    );    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete'),      '#access' => $item['mlid'],      '#submit' => array('menu_item_delete_submit'),      '#weight' => 10,    );  }  else {    $form['menu']['_path'] = array(      '#type' => 'item',      '#title' => t('Path'),      '#description' => l($item['link_title'], $item['href'], $item['options']),    );  }  $form['menu']['link_title'] = array('#type' => 'textfield',    '#title' => t('Menu link title'),    '#default_value' => $item['link_title'],    '#description' => t('The link text corresponding to this item that should appear in the menu.'),    '#required' => TRUE,  );  $form['menu']['description'] = array(    '#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => isset($item['options']['attributes']['title']) ? $item['options']['attributes']['title'] : '',    '#rows' => 1,    '#description' => t('The description displayed when hovering over a menu item.'),  );  $form['menu']['enabled'] = array(    '#type' => 'checkbox',    '#title' => t('Enabled'),    '#default_value' => !$item['hidden'],    '#description' => t('Menu items that are not enabled will not be listed in any menu.'),  );  $form['menu']['expanded'] = array(    '#type' => 'checkbox',    '#title' => t('Expanded'),    '#default_value' => $item['expanded'],    '#description' => t('If selected and this menu item has children, the menu will always appear expanded.'),  );  // Generate a list of possible parents (not including this item or descendants).  $options = menu_parent_options(menu_get_menus(), $item);  $default = $item['menu_name'] .':'. $item['plid'];  if (!isset($options[$default])) {    $default = 'navigation:0';  }  $form['menu']['parent'] = array(    '#type' => 'select',    '#title' => t('Parent item'),    '#default_value' => $default,    '#options' => $options,    '#description' => t('The maximum depth for an item and all its children is fixed at !maxdepth. Some menu items may not be available as parents if selecting them would exceed this limit.', array('!maxdepth' => MENU_MAX_DEPTH)),    '#attributes' => array('class' => 'menu-title-select'),  );  $form['menu']['weight'] = array(    '#type' => 'weight',    '#title' => t('Weight'),    '#delta' => 50,    '#default_value' => $item['weight'],    '#description' => t('Optional. In the menu, the heavier items will sink and the lighter items will be positioned nearer the top.'),  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));  return $form;}/** * Validate form values for a menu link being added or edited. */function menu_edit_item_validate($form, &$form_state) {  $item = &$form_state['values']['menu'];  $normal_path = drupal_get_normal_path($item['link_path']);  if ($item['link_path'] != $normal_path) {    drupal_set_message(t('The menu system stores system paths only, but will use the URL alias for display. %link_path has been stored as %normal_path', array('%link_path' => $item['link_path'], '%normal_path' => $normal_path)));    $item['link_path'] = $normal_path;  }  if (!menu_path_is_external($item['link_path'])) {    $parsed_link = parse_url($item['link_path']);    if (isset($parsed_link['query'])) {      $item['options']['query'] = $parsed_link['query'];    }    if (isset($parsed_link['fragment'])) {      $item['options']['fragment'] = $parsed_link['fragment'];    }    if ($item['link_path'] != $parsed_link['path']) {      $item['link_path'] = $parsed_link['path'];    }  }  if (!trim($item['link_path']) || !menu_valid_path($item)) {    form_set_error('link_path', t("The path '@link_path' is either invalid or you do not have access to it.", array('@link_path' => $item['link_path'])));  }}/** * Submit function for the delete button on the menu item editing form. */function menu_item_delete_submit($form, &$form_state) {  $form_state['redirect'] = 'admin/build/menu/item/'. $form_state['values']['menu']['mlid'] .'/delete';}/** * Process menu and menu item add/edit form submissions. */function menu_edit_item_submit($form, &$form_state) {  $item = &$form_state['values']['menu'];  // The value of "hidden" is the opposite of the value  // supplied by the "enabled" checkbox.  $item['hidden'] = (int) !$item['enabled'];  unset($item['enabled']);  $item['options']['attributes']['title'] = $item['description'];  list($item['menu_name'], $item['plid']) = explode(':', $item['parent']);  if (!menu_link_save($item)) {    drupal_set_message(t('There was an error saving the menu link.'), 'error');  }  $form_state['redirect'] = 'admin/build/menu-customize/'. $item['menu_name'];}/** * Menu callback; Build the form that handles the adding/editing of a custom menu. */function menu_edit_menu(&$form_state, $type, $menu = array()) {  if ($type == 'edit') {    $form['menu_name'] = array('#type' => 'value', '#value' => $menu['menu_name']);    $form['#insert'] = FALSE;    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete'),      '#access' => !in_array($menu['menu_name'], menu_list_system_menus()),      '#submit' => array('menu_custom_delete_submit'),      '#weight' => 10,    );  }  else {    $menu = array('menu_name' => '', 'title' => '', 'description' => '');    $form['menu_name'] = array(      '#type' => 'textfield',      '#title' => t('Menu name'),      '#maxsize' => MENU_MAX_MENU_NAME_LENGTH_UI,      '#description' => t('The machine-readable name of this menu. This text will be used for constructing the URL of the <em>menu overview</em> page for this menu. This name must contain only lowercase letters, numbers, and hyphens, and must be unique.'),      '#required' => TRUE,    );    $form['#insert'] = TRUE;  }  $form['#title'] = $menu['title'];  $form['title'] = array(    '#type' => 'textfield',    '#title' => t('Title'),    '#default_value' => $menu['title'],    '#required' => TRUE,  );  $form['description'] = array(    '#type' => 'textarea',    '#title' => t('Description'),    '#default_value' => $menu['description'],  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save'),  );  return $form;}/** * Submit function for the 'Delete' button on the menu editing form. */function menu_custom_delete_submit($form, &$form_state) {  $form_state['redirect'] = 'admin/build/menu-customize/'. $form_state['values']['menu_name'] .'/delete';}/** * Menu callback; check access and get a confirm form for deletion of a custom menu. */function menu_delete_menu_page($menu) {  // System-defined menus may not be deleted.  if (in_array($menu['menu_name'], menu_list_system_menus())) {    drupal_access_denied();    return;  }  return drupal_get_form('menu_delete_menu_confirm', $menu);}/** * Build a confirm form for deletion of a custom menu. */function menu_delete_menu_confirm(&$form_state, $menu) {  $form['#menu'] = $menu;  $caption = '';  $num_links = db_result(db_query("SELECT COUNT(*) FROM {menu_links} WHERE menu_name = '%s'", $menu['menu_name']));  if ($num_links) {    $caption .= '<p>'. format_plural($num_links, '<strong>Warning:</strong> There is currently 1 menu item in %title. It will be deleted (system-defined items will be reset).', '<strong>Warning:</strong> There are currently @count menu items in %title. They will be deleted (system-defined items will be reset).', array('%title' => $menu['title'])) .'</p>';  }  $caption .= '<p>'. t('This action cannot be undone.') .'</p>';  return confirm_form($form, t('Are you sure you want to delete the custom menu %title?', array('%title' => $menu['title'])), 'admin/build/menu-customize/'. $menu['menu_name'], $caption, t('Delete'));}/** * Delete a custom menu and all items in it. */function menu_delete_menu_confirm_submit($form, &$form_state) {  $menu = $form['#menu'];  $form_state['redirect'] = 'admin/build/menu';  // System-defined menus may not be deleted - only menus defined by this module.  if (in_array($menu['menu_name'], menu_list_system_menus())  || !db_result(db_query("SELECT COUNT(*) FROM {menu_custom} WHERE menu_name = '%s'", $menu['menu_name']))) {    return;  }  // Reset all the menu links defined by the system via hook_menu.  $result = db_query("SELECT * FROM {menu_links} ml INNER JOIN {menu_router} m ON ml.router_path = m.path WHERE ml.menu_name = '%s' AND ml.module = 'system' ORDER BY m.number_parts ASC", $menu['menu_name']);  while ($item = db_fetch_array($result)) {    menu_reset_item($item);  }  // Delete all links to the overview page for this menu.  $result = db_query("SELECT mlid FROM {menu_links} ml WHERE ml.link_path = '%s'", 'admin/build/menu-customize/'. $menu['menu_name']);  while ($m = db_fetch_array($result)) {    menu_link_delete($m['mlid']);  }  // Delete all the links in the menu and the menu from the list of custom menus.  db_query("DELETE FROM {menu_links} WHERE menu_name = '%s'", $menu['menu_name']);  db_query("DELETE FROM {menu_custom} WHERE menu_name = '%s'", $menu['menu_name']);  // Delete all the blocks for this menu.  db_query("DELETE FROM {blocks} WHERE module = 'menu' AND delta = '%s'", $menu['menu_name']);  db_query("DELETE FROM {blocks_roles} WHERE module = 'menu' AND delta = '%s'", $menu['menu_name']);  menu_cache_clear_all();  cache_clear_all();  $t_args = array('%title' => $menu['title']);  drupal_set_message(t('The custom menu %title has been deleted.', $t_args));  watchdog('menu', 'Deleted custom menu %title and all its menu items.', $t_args, WATCHDOG_NOTICE);}/** * Validates the human and machine-readable names when adding or editing a menu. */function menu_edit_menu_validate($form, &$form_state) {  $item = $form_state['values'];  if (preg_match('/[^a-z0-9-]/', $item['menu_name'])) {    form_set_error('menu_name', t('The menu name may only consist of lowercase letters, numbers, and hyphens.'));  }  if (strlen($item['menu_name']) > MENU_MAX_MENU_NAME_LENGTH_UI) {    form_set_error('menu_name', format_plural(MENU_MAX_MENU_NAME_LENGTH_UI, "The menu name can't be longer than 1 character.", "The menu name can't be longer than @count characters."));  }  if ($form['#insert']) {    // We will add 'menu-' to the menu name to help avoid name-space conflicts.    $item['menu_name'] = 'menu-'. $item['menu_name'];    if (db_result(db_query("SELECT menu_name FROM {menu_custom} WHERE menu_name = '%s'", $item['menu_name'])) ||      db_result(db_query_range("SELECT menu_name FROM {menu_links} WHERE menu_name = '%s'", $item['menu_name'], 0, 1))) {      form_set_error('menu_name', t('The menu already exists.'));    }  }}/** * Submit function for adding or editing a custom menu. */function menu_edit_menu_submit($form, &$form_state) {  $menu = $form_state['values'];  $path = 'admin/build/menu-customize/';  if ($form['#insert']) {    // Add 'menu-' to the menu name to help avoid name-space conflicts.    $menu['menu_name'] = 'menu-'. $menu['menu_name'];    $link['link_title'] = $menu['title'];    $link['link_path'] = $path . $menu['menu_name'];    $link['router_path'] = $path .'%';    $link['module'] = 'menu';    $link['plid'] = db_result(db_query("SELECT mlid FROM {menu_links} WHERE link_path = '%s' AND module = '%s'", 'admin/build/menu', 'system'));    menu_link_save($link);    db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menu['menu_name'], $menu['title'], $menu['description']);  }  else {    db_query("UPDATE {menu_custom} SET title = '%s', description = '%s' WHERE menu_name = '%s'", $menu['title'], $menu['description'], $menu['menu_name']);    $result = db_query("SELECT mlid FROM {menu_links} WHERE link_path = '%s'", $path . $menu['menu_name']);    while ($m = db_fetch_array($result)) {      $link = menu_link_load($m['mlid']);      $link['link_title'] = $menu['title'];      menu_link_save($link);    }  }  $form_state['redirect'] = $path . $menu['menu_name'];}/** * Menu callback; Check access and present a confirm form for deleting a menu link. */function menu_item_delete_page($item) {  // Links defined via hook_menu may not be deleted. Updated items are an  // exception, as they can be broken.  if ($item['module'] == 'system' && !$item['updated']) {    drupal_access_denied();    return;  }  return drupal_get_form('menu_item_delete_form', $item);}/** * Build a confirm form for deletion of a single menu link. */function menu_item_delete_form(&$form_state, $item) {  $form['#item'] = $item;  return confirm_form($form, t('Are you sure you want to delete the custom menu item %item?', array('%item' => $item['link_title'])), 'admin/build/menu-customize/'. $item['menu_name']);}/** * Process menu delete form submissions. */function menu_item_delete_form_submit($form, &$form_state) {  $item = $form['#item'];  menu_link_delete($item['mlid']);  $t_args = array('%title' => $item['link_title']);  drupal_set_message(t('The menu item %title has been deleted.', $t_args));  watchdog('menu', 'Deleted menu item %title.', $t_args, WATCHDOG_NOTICE);  $form_state['redirect'] = 'admin/build/menu-customize/'. $item['menu_name'];}/** * Menu callback; reset a single modified item. */function menu_reset_item_confirm(&$form_state, $item) {  $form['item'] = array('#type' => 'value', '#value' => $item);  return confirm_form($form, t('Are you sure you want to reset the item %item to its default values?', array('%item' => $item['link_title'])), 'admin/build/menu-customize/'. $item['menu_name'], t('Any customizations will be lost. This action cannot be undone.'), t('Reset'));}/** * Process menu reset item form submissions. */function menu_reset_item_confirm_submit($form, &$form_state) {  $item = $form_state['values']['item'];  $new_item = menu_reset_item($item);  drupal_set_message(t('The menu item was reset to its default settings.'));  $form_state['redirect'] = 'admin/build/menu-customize/'. $new_item['menu_name'];}/** * Menu callback; Build the form presenting menu configuration options. */function menu_configure() {  $form['intro'] = array(    '#type' => 'item',    '#value' => t('The menu module allows on-the-fly creation of menu links in the content authoring forms. The following option sets the default menu in which a new link will be added.'),  );  $menu_options = menu_get_menus();  $form['menu_default_node_menu'] = array(    '#type' => 'select',    '#title' => t('Default menu for content'),    '#default_value' => variable_get('menu_default_node_menu', 'primary-links'),    '#options' => $menu_options,    '#description' => t('Choose the menu to be the default in the menu options in the content authoring form.'),  );  $primary = variable_get('menu_primary_links_source', 'primary-links');  $primary_options = array_merge($menu_options, array('' => t('No primary links')));  $form['menu_primary_links_source'] = array(    '#type' => 'select',    '#title' => t('Source for the primary links'),    '#default_value' => $primary,    '#options' => $primary_options,    '#tree' => FALSE,    '#description' => t('Select what should be displayed as the primary links.'),  );  $secondary_options = array_merge($menu_options, array('' => t('No secondary links')));  $form["menu_secondary_links_source"] = array(    '#type' => 'select',    '#title' => t('Source for the secondary links'),    '#default_value' => variable_get('menu_secondary_links_source', 'secondary-links'),    '#options' => $secondary_options,    '#tree' => FALSE,    '#description' => t('Select what should be displayed as the secondary links. You can choose the same menu for secondary links as for primary links (currently %primary). If you do this, the children of the active primary menu link will be displayed as secondary links.', array('%primary' => $primary_options[$primary])),  );  return system_settings_form($form);}
<?php// $Id$/** * @file Batch processing API for processes to run in multiple HTTP requests. *//** * State-based dispatcher for the batch processing page. */function _batch_page() {  $batch =& batch_get();  // Retrieve the current state of batch from db.  if (isset($_REQUEST['id']) && $data = db_result(db_query("SELECT batch FROM {batch} WHERE bid = %d AND token = '%s'", $_REQUEST['id'], drupal_get_token($_REQUEST['id'])))) {    $batch = unserialize($data);  }  else {    return FALSE;  }  // Register database update for end of processing.  register_shutdown_function('_batch_shutdown');  $op = isset($_REQUEST['op']) ? $_REQUEST['op'] : '';  $output = NULL;  switch ($op) {    case 'start':      $output = _batch_start();      break;    case 'do':      // JS-version AJAX callback.      _batch_do();      break;    case 'do_nojs':      // Non-JS progress page.      $output = _batch_progress_page_nojs();      break;    case 'finished':      $output = _batch_finished();      break;  }  return $output;}/** * Initiate the batch processing */function _batch_start() {  // Choose between the JS and non-JS version.  // JS-enabled users are identified through the 'has_js' cookie set in drupal.js.  // If the user did not visit any JS enabled page during his browser session,  // he gets the non-JS version...  if (isset($_COOKIE['has_js']) && $_COOKIE['has_js']) {    return _batch_progress_page_js();  }  else {    return _batch_progress_page_nojs();  }}/** * Batch processing page with JavaScript support. */function _batch_progress_page_js() {  $batch = batch_get();  // The first batch set gets to set the page title  // and the initialization and error messages.  $current_set = _batch_current_set();  drupal_set_title($current_set['title']);  drupal_add_js('misc/progress.js', 'core', 'header', FALSE, FALSE);  $url = url($batch['url'], array('query' => array('id' => $batch['id'])));  $js_setting = array(    'batch' => array(      'errorMessage' => $current_set['error_message'] .'<br/>'. $batch['error_message'],      'initMessage' => $current_set['init_message'],      'uri' => $url,    ),  );  drupal_add_js($js_setting, 'setting');  drupal_add_js('misc/batch.js', 'core', 'header', FALSE, FALSE);  $output = '<div id="progress"></div>';  return $output;}/** * Do one pass of execution and inform back the browser about progression * (used for JavaScript-mode only). */function _batch_do() {  // HTTP POST required  if ($_SERVER['REQUEST_METHOD'] != 'POST') {    drupal_set_message(t('HTTP POST is required.'), 'error');    drupal_set_title(t('Error'));    return '';  }  // Perform actual processing.  list($percentage, $message) = _batch_process();  drupal_json(array('status' => TRUE, 'percentage' => $percentage, 'message' => $message));}/** * Batch processing page without JavaScript support. */function _batch_progress_page_nojs() {  $batch =& batch_get();  $current_set = _batch_current_set();  drupal_set_title($current_set['title']);  $new_op = 'do_nojs';  if (!isset($batch['running'])) {    // This is the first page so we return some output immediately.    $percentage = 0;    $message = $current_set['init_message'];    $batch['running'] = TRUE;  }  else {    // This is one of the later requests: do some processing first.    // Error handling: if PHP dies due to a fatal error (e.g. non-existant    // function), it will output whatever is in the output buffer,    // followed by the error message.    ob_start();    $fallback = $current_set['error_message'] .'<br/>'. $batch['error_message'];    $fallback = theme('maintenance_page', $fallback, FALSE, FALSE);    // We strip the end of the page using a marker in the template, so any    // additional HTML output by PHP shows up inside the page rather than    // below it. While this causes invalid HTML, the same would be true if    // we didn't, as content is not allowed to appear after </html> anyway.    list($fallback) = explode('<!--partial-->', $fallback);    print $fallback;    // Perform actual processing.    list($percentage, $message) = _batch_process($batch);    if ($percentage == 100) {      $new_op = 'finished';    }    // PHP did not die : remove the fallback output.    ob_end_clean();  }  $url = url($batch['url'], array('query' => array('id' => $batch['id'], 'op' => $new_op)));  drupal_set_html_head('<meta http-equiv="Refresh" content="0; URL='. $url .'">');  $output = theme('progress_bar', $percentage, $message);  return $output;}/** * Advance batch processing for 1 second (or process the whole batch if it * was not set for progressive execution - e.g forms submitted by drupal_execute). */function _batch_process() {  $batch =& batch_get();  $current_set =& _batch_current_set();  $set_changed = TRUE;  if ($batch['progressive']) {    timer_start('batch_processing');  }  while (!$current_set['success']) {    // If this is the first time we iterate this batch set in the current    // request, we check if it requires an additional file for functions    // definitions.    if ($set_changed && isset($current_set['file']) && is_file($current_set['file'])) {      include_once($current_set['file']);    }    $finished = 1;    $task_message = '';    if ((list($function, $args) = reset($current_set['operations'])) && function_exists($function)) {      // Build the 'context' array, execute the function call,      // and retrieve the user message.      $batch_context = array('sandbox' => &$current_set['sandbox'], 'results' => &$current_set['results'], 'finished' => &$finished, 'message' => &$task_message);      // Process the current operation.      call_user_func_array($function, array_merge($args, array(&$batch_context)));    }    if ($finished == 1) {      // Make sure this step isn't counted double when computing $current.      $finished = 0;      // Remove the operation and clear the sandbox.      array_shift($current_set['operations']);      $current_set['sandbox'] = array();    }    // If the batch set is completed, browse through the remaining sets,    // executing 'control sets' (stored form submit handlers) along the way -    // this might in turn insert new batch sets.    // Stop when we find a set that actually has operations.    $set_changed = FALSE;    $old_set = $current_set;    while (empty($current_set['operations']) && ($current_set['success'] = TRUE) && _batch_next_set()) {      $current_set =& _batch_current_set();      $set_changed = TRUE;    }    // At this point, either $current_set is a 'real' batch set (has operations),    // or all sets have been completed.    // If we're in progressive mode, stop after 1 second.    if ($batch['progressive'] && timer_read('batch_processing') > 1000) {      break;    }  }  if ($batch['progressive']) {    // Gather progress information.    // Reporting 100% progress will cause the whole batch to be considered    // processed. If processing was paused right after moving to a new set,    // we have to use the info from the new (unprocessed) one.    if ($set_changed && isset($current_set['operations'])) {      // Processing will continue with a fresh batch set.      $remaining = count($current_set['operations']);      $total = $current_set['total'];      $progress_message = $current_set['init_message'];      $task_message = '';    }    else {      $remaining = count($old_set['operations']);      $total = $old_set['total'];      $progress_message = $old_set['progress_message'];    }    $current    = $total - $remaining + $finished;    $percentage = $total ? floor($current / $total * 100) : 100;    $values = array(      '@remaining'  => $remaining,      '@total'      => $total,      '@current'    => floor($current),      '@percentage' => $percentage,      );    $message = strtr($progress_message, $values) .'<br/>';    $message .= $task_message ? $task_message : '&nbsp';    return array($percentage, $message);  }  else {    // If we're not in progressive mode, the whole batch has been processed by now.    return _batch_finished();  }}/** * Retrieve the batch set being currently processed. */function &_batch_current_set() {  $batch =& batch_get();  return $batch['sets'][$batch['current_set']];}/** * Move execution to the next batch set if any, executing the stored * form _submit handlers along the way (thus possibly inserting * additional batch sets). */function _batch_next_set() {  $batch =& batch_get();  if (isset($batch['sets'][$batch['current_set'] + 1])) {    $batch['current_set']++;    $current_set =& _batch_current_set();    if (isset($current_set['form_submit']) && ($function = $current_set['form_submit']) && function_exists($function)) {      // We use our stored copies of $form and $form_state, to account for      // possible alteration by the submit handlers.      $function($batch['form'], $batch['form_state']);    }    return TRUE;  }}/** * End the batch processing: * Call the 'finished' callbacks to allow custom handling of results, * and resolve page redirection. */function _batch_finished() {  $batch =& batch_get();  // Execute the 'finished' callbacks for each batch set.  foreach ($batch['sets'] as $key => $batch_set) {    if (isset($batch_set['finished'])) {      // Check if the set requires an additional file for functions definitions.      if (isset($batch_set['file']) && is_file($batch_set['file'])) {        include_once($batch_set['file']);      }      if (function_exists($batch_set['finished'])) {        $batch_set['finished']($batch_set['success'], $batch_set['results'], $batch_set['operations']);      }    }  }  // Cleanup the batch table and unset the global $batch variable.  if ($batch['progressive']) {    db_query("DELETE FROM {batch} WHERE bid = %d", $batch['id']);  }  $_batch = $batch;  $batch = NULL;  // Redirect if needed.  if ($_batch['progressive']) {    // Put back the 'destination' that was saved in batch_process().    if (isset($_batch['destination'])) {      $_REQUEST['destination'] = $_batch['destination'];    }    // Use $_batch['form_state']['redirect'], or $_batch['redirect'],    // or $_batch['source_page'].    if (isset($_batch['form_state']['redirect'])) {      $redirect = $_batch['form_state']['redirect'];    }    elseif (isset($_batch['redirect'])) {      $redirect = $_batch['redirect'];    }    else {      $redirect = $_batch['source_page'];    }    // Let drupal_redirect_form handle redirection logic.    $form = isset($batch['form']) ? $batch['form'] : array();    if (empty($_batch['form_state']['rebuild']) && empty($_batch['form_state']['storage'])) {      drupal_redirect_form($form, $redirect);    }    // We get here if $form['#redirect'] was FALSE, or if the form is a    // multi-step form. We save the final $form_state value to be retrieved    // by drupal_get_form, and we redirect to the originating page.    $_SESSION['batch_form_state'] = $_batch['form_state'];    drupal_goto($_batch['source_page']);  }}/** * Shutdown function: store the batch data for next request, * or clear the table if the batch is finished. */function _batch_shutdown() {  if ($batch = batch_get()) {    db_query("UPDATE {batch} SET batch = '%s' WHERE bid = %d", serialize($batch), $batch['id']);  }}
<?php// $Id$/** * @file maintenance-page.tpl.php * * This is an override of the default maintenance page. Used for Garland and * Minnelli, this file should not be moved or modified since the installation * and update pages depend on this file. * * This mirrors closely page.tpl.php for Garland in order to share the same * styles. */?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>">  <head>    <?php print $head ?>    <title><?php print $head_title ?></title>    <?php print $styles ?>    <?php print $scripts ?>    <!--[if lt IE 7]>      <?php print phptemplate_get_ie_styles(); ?>    <![endif]-->  </head>  <body<?php print phptemplate_body_class($left, $right); ?>><!-- Layout -->  <div id="header-region" class="clear-block"><?php print $header; ?></div>    <div id="wrapper">    <div id="container" class="clear-block">      <div id="header">        <div id="logo-floater">        <?php          // Prepare header          $site_fields = array();          if ($site_name) {            $site_fields[] = check_plain($site_name);          }          if ($site_slogan) {            $site_fields[] = check_plain($site_slogan);          }          $site_title = implode(' ', $site_fields);          if ($site_fields) {            $site_fields[0] = '<span>'. $site_fields[0] .'</span>';          }          $site_html = implode(' ', $site_fields);          if ($logo || $site_title) {            print '<h1><a href="'. check_url($base_path) .'" title="'. $site_title .'">';            if ($logo) {              print '<img src="'. check_url($logo) .'" alt="'. $site_title .'" id="logo" />';            }            print $site_html .'</a></h1>';          }        ?>        </div>      </div> <!-- /header -->      <?php if ($left): ?>        <div id="sidebar-left" class="sidebar">          <?php if ($search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $left ?>        </div>      <?php endif; ?>      <div id="center"><div id="squeeze"><div class="right-corner"><div class="left-corner">          <?php if ($title): print '<h2'. ($tabs ? ' class="with-tabs"' : '') .'>'. $title .'</h2>'; endif; ?>          <?php print $help; ?>          <?php print $messages; ?>          <div class="clear-block">            <?php print $content ?>          </div>          <div id="footer"><?php print $footer_message . $footer ?></div>      </div></div></div></div> <!-- /.left-corner, /.right-corner, /#squeeze, /#center -->      <?php if ($right): ?>        <div id="sidebar-right" class="sidebar">          <?php print $right ?>        </div>      <?php endif; ?>    </div> <!-- /container -->  </div><!-- /layout -->  </body></html>
<?php// $Id$/** * @file * Code required only when comparing available updates to existing data. *//** * Fetch an array of installed and enabled projects. * * This is only responsible for generating an array of projects (taking into * account projects that include more than one module or theme). Other * information like the specific version and install type (official release, * dev snapshot, etc) is handled later in update_process_project_info() since * that logic is only required when preparing the status report, not for * fetching the available release data. * * This array is fairly expensive to construct, since it involves a lot of * disk I/O, so we cache the results into the {cache_update} table using the * 'update_project_projects' cache ID. However, since this is not the data * about available updates fetched from the network, it is ok to invalidate it * somewhat quickly. If we keep this data for very long, site administrators * are more likely to see incorrect results if they upgrade to a newer version * of a module or theme but do not visit certain pages that automatically * clear this cache. * * @see update_process_project_info() * @see update_calculate_project_data() * @see update_project_cache() */function update_get_projects() {  static $projects = array();  if (empty($projects)) {    // Retrieve the projects from cache, if present.    $projects = update_project_cache('update_project_projects');    if (empty($projects)) {      // Still empty, so we have to rebuild the cache.      _update_process_info_list($projects, module_rebuild_cache(), 'module');      _update_process_info_list($projects, system_theme_data(), 'theme');      // Allow other modules to alter projects before fetching and comparing.      drupal_alter('update_projects', $projects);      // Cache the site's project data for at most 1 hour.      _update_cache_set('update_project_projects', $projects, time() + 3600);    }  }  return $projects;}/** * Populate an array of project data. */function _update_process_info_list(&$projects, $list, $project_type) {  foreach ($list as $file) {    // A disabled base theme of an enabled sub-theme still has all of its code    // run by the sub-theme, so we include it in our "enabled" projects list.    if (!$file->status && !empty($file->sub_themes)) {      foreach ($file->sub_themes as $key => $name) {        // Build a list of enabled sub-themes.        if ($list[$key]->status) {          $file->enabled_sub_themes[$key] = $name;        }      }      // If there are no enabled subthemes, we should ingore this theme and go      // on to the next one.      if (empty($file->enabled_sub_themes)) {        continue;      }    }    elseif (empty($file->status)) {      // Skip disabled modules or themes.      continue;    }    // Skip if the .info file is broken.    if (empty($file->info)) {      continue;    }    // If the .info doesn't define the 'project', try to figure it out.    if (!isset($file->info['project'])) {      $file->info['project'] = update_get_project_name($file);    }    // If we still don't know the 'project', give up.    if (empty($file->info['project'])) {      continue;    }    // If we don't already know it, grab the change time on the .info file    // itself. Note: we need to use the ctime, not the mtime (modification    // time) since many (all?) tar implementations will go out of their way to    // set the mtime on the files it creates to the timestamps recorded in the    // tarball. We want to see the last time the file was changed on disk,    // which is left alone by tar and correctly set to the time the .info file    // was unpacked.    if (!isset($file->info['_info_file_ctime'])) {      $info_filename = dirname($file->filename) .'/'. $file->name .'.info';      $file->info['_info_file_ctime'] = filectime($info_filename);    }    if (!isset($file->info['datestamp'])) {      $file->info['datestamp'] = 0;    }    $project_name = $file->info['project'];    // Add a list of sub-themes that "depend on" the project and a list of base    // themes that are "required by" the project.    if ($project_name == 'drupal') {      // Drupal core is always required, so this extra info would be noise.      $sub_themes = array();      $base_themes = array();    }    else {      // Add list of enabled sub-themes.      $sub_themes = !empty($file->enabled_sub_themes) ? $file->enabled_sub_themes : array();      // Add list of base themes.      $base_themes = !empty($file->base_themes) ? $file->base_themes : array();    }    if (!isset($projects[$project_name])) {      // Only process this if we haven't done this project, since a single      // project can have multiple modules or themes.      $projects[$project_name] = array(        'name' => $project_name,        // Only save attributes from the .info file we care about so we do not        // bloat our RAM usage needlessly.        'info' => update_filter_project_info($file->info),        'datestamp' => $file->info['datestamp'],        'includes' => array($file->name => $file->info['name']),        'project_type' => $project_name == 'drupal' ? 'core' : $project_type,        'sub_themes' => $sub_themes,        'base_themes' => $base_themes,      );    }    else {      $projects[$project_name]['includes'][$file->name] = $file->info['name'];      $projects[$project_name]['info']['_info_file_ctime'] = max($projects[$project_name]['info']['_info_file_ctime'], $file->info['_info_file_ctime']);      $projects[$project_name]['datestamp'] = max($projects[$project_name]['datestamp'], $file->info['datestamp']);      $projects[$project_name]['sub_themes'] = array_merge($projects[$project_name]['sub_themes'], $sub_themes);      $projects[$project_name]['base_themes'] = array_merge($projects[$project_name]['base_themes'], $base_themes);    }  }}/** * Given a $file object (as returned by system_get_files_database()), figure * out what project it belongs to. * * @see system_get_files_database() */function update_get_project_name($file) {  $project_name = '';  if (isset($file->info['project'])) {    $project_name = $file->info['project'];  }  elseif (isset($file->info['package']) && (strpos($file->info['package'], 'Core -') !== FALSE)) {    $project_name = 'drupal';  }  elseif (in_array($file->name, array('bluemarine', 'chameleon', 'garland', 'marvin', 'minnelli', 'pushbutton'))) {    // Unfortunately, there's no way to tell if a theme is part of core,    // so we must hard-code a list here.    $project_name = 'drupal';  }  return $project_name;}/** * Process the list of projects on the system to figure out the currently * installed versions, and other information that is required before we can * compare against the available releases to produce the status report. * * @param $projects *   Array of project information from update_get_projects(). */function update_process_project_info(&$projects) {  foreach ($projects as $key => $project) {    // Assume an official release until we see otherwise.    $install_type = 'official';    $info = $project['info'];    if (isset($info['version'])) {      // Check for development snapshots      if (preg_match('@(dev|HEAD)@', $info['version'])) {        $install_type = 'dev';      }      // Figure out what the currently installed major version is. We need      // to handle both contribution (e.g. "5.x-1.3", major = 1) and core      // (e.g. "5.1", major = 5) version strings.      $matches = array();      if (preg_match('/^(\d+\.x-)?(\d+)\..*$/', $info['version'], $matches)) {        $info['major'] = $matches[2];      }      elseif (!isset($info['major'])) {        // This would only happen for version strings that don't follow the        // drupal.org convention. We let contribs define "major" in their        // .info in this case, and only if that's missing would we hit this.        $info['major'] = -1;      }    }    else {      // No version info available at all.      $install_type = 'unknown';      $info['version'] = t('Unknown');      $info['major'] = -1;    }    // Finally, save the results we care about into the $projects array.    $projects[$key]['existing_version'] = $info['version'];    $projects[$key]['existing_major'] = $info['major'];    $projects[$key]['install_type'] = $install_type;  }}/** * Given the installed projects and the available release data retrieved from * remote servers, calculate the current status. * * This function is the heart of the update status feature. It iterates over * every currently installed project. For each one, it first checks if the * project has been flagged with a special status like "unsupported" or * "insecure", or if the project node itself has been unpublished. In any of * those cases, the project is marked with an error and the next project is * considered. * * If the project itself is valid, the function decides what major release * series to consider. The project defines what the currently supported major * versions are for each version of core, so the first step is to make sure * the current version is still supported. If so, that's the target version. * If the current version is unsupported, the project maintainer's recommended * major version is used. There's also a check to make sure that this function * never recommends an earlier release than the currently installed major * version. * * Given a target major version, it scans the available releases looking for * the specific release to recommend (avoiding beta releases and development * snapshots if possible). This is complicated to describe, but an example * will help clarify. For the target major version, find the highest patch * level. If there is a release at that patch level with no extra ("beta", * etc), then we recommend the release at that patch level with the most * recent release date. If every release at that patch level has extra (only * betas), then recommend the latest release from the previous patch * level. For example: * * 1.6-bugfix <-- recommended version because 1.6 already exists. * 1.6 * * or * * 1.6-beta * 1.5 <-- recommended version because no 1.6 exists. * 1.4 * * It also looks for the latest release from the same major version, even a * beta release, to display to the user as the "Latest version" option. * Additionally, it finds the latest official release from any higher major * versions that have been released to provide a set of "Also available" * options. * * Finally, and most importantly, it keeps scanning the release history until * it gets to the currently installed release, searching for anything marked * as a security update. If any security updates have been found between the * recommended release and the installed version, all of the releases that * included a security fix are recorded so that the site administrator can be * warned their site is insecure, and links pointing to the release notes for * each security update can be included (which, in turn, will link to the * official security announcements for each vulnerability). * * This function relies on the fact that the .xml release history data comes * sorted based on major version and patch level, then finally by release date * if there are multiple releases such as betas from the same major.patch * version (e.g. 5.x-1.5-beta1, 5.x-1.5-beta2, and 5.x-1.5). Development * snapshots for a given major version are always listed last. * * The results of this function are expensive to compute, especially on sites * with lots of modules or themes, since it involves a lot of comparisons and * other operations. Therefore, we cache the results into the {cache_update} * table using the 'update_project_data' cache ID. However, since this is not * the data about available updates fetched from the network, it is ok to * invalidate it somewhat quickly. If we keep this data for very long, site * administrators are more likely to see incorrect results if they upgrade to * a newer version of a module or theme but do not visit certain pages that * automatically clear this cache. * * @param $available *  Array of data about available project releases. * * @see update_get_available() * @see update_get_projects() * @see update_process_project_info() * @see update_project_cache() */function update_calculate_project_data($available) {  // Retrieve the projects from cache, if present.  $projects = update_project_cache('update_project_data');  // If $projects is empty, then the cache must be rebuilt.  // Otherwise, return the cached data and skip the rest of the function.  if (!empty($projects)) {    return $projects;  }  $projects = update_get_projects();  update_process_project_info($projects);  foreach ($projects as $project => $project_info) {    if (isset($available[$project])) {      // If the project status is marked as something bad, there's nothing      // else to consider.      if (isset($available[$project]['project_status'])) {        switch ($available[$project]['project_status']) {          case 'insecure':            $projects[$project]['status'] = UPDATE_NOT_SECURE;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-not-secure',              'label' => t('Project not secure'),              'data' => t('This project has been labeled insecure by the Drupal security team, and is no longer available for download. Immediately disabling everything included by this project is strongly recommended!'),            );            break;          case 'unpublished':          case 'revoked':            $projects[$project]['status'] = UPDATE_REVOKED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-revoked',              'label' => t('Project revoked'),              'data' => t('This project has been revoked, and is no longer available for download. Disabling everything included by this project is strongly recommended!'),            );            break;          case 'unsupported':            $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'project-not-supported',              'label' => t('Project not supported'),              'data' => t('This project is no longer supported, and is no longer available for download. Disabling everything included by this project is strongly recommended!'),            );            break;          case 'not-fetched':            $projects[$project]['status'] = UPDATE_NOT_FETCHED;            $projects[$project]['reason'] = t('Failed to fetch available update data');            break;          default:            // Assume anything else (e.g. 'published') is valid and we should            // perform the rest of the logic in this function.            break;        }      }      if (!empty($projects[$project]['status'])) {        // We already know the status for this project, so there's nothing        // else to compute. Just record everything else we fetched from the        // XML file into our projects array and move to the next project.        $projects[$project] += $available[$project];        continue;      }      // Figure out the target major version.      $existing_major = $project_info['existing_major'];      $supported_majors = array();      if (isset($available[$project]['supported_majors'])) {        $supported_majors = explode(',', $available[$project]['supported_majors']);      }      elseif (isset($available[$project]['default_major'])) {        // Older release history XML file without supported or recommended.        $supported_majors[] = $available[$project]['default_major'];      }      if (in_array($existing_major, $supported_majors)) {        // Still supported, stay at the current major version.        $target_major = $existing_major;      }      elseif (isset($available[$project]['recommended_major'])) {        // Since 'recommended_major' is defined, we know this is the new XML        // format. Therefore, we know the current release is unsupported since        // its major version was not in the 'supported_majors' list. We should        // find the best release from the recommended major version.        $target_major = $available[$project]['recommended_major'];        $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;      }      elseif (isset($available[$project]['default_major'])) {        // Older release history XML file without recommended, so recommend        // the currently defined "default_major" version.        $target_major = $available[$project]['default_major'];      }      else {        // Malformed XML file? Stick with the current version.        $target_major = $existing_major;      }      // Make sure we never tell the admin to downgrade. If we recommended an      // earlier version than the one they're running, they'd face an      // impossible data migration problem, since Drupal never supports a DB      // downgrade path. In the unfortunate case that what they're running is      // unsupported, and there's nothing newer for them to upgrade to, we      // can't print out a "Recommended version", but just have to tell them      // what they have is unsupported and let them figure it out.      $target_major = max($existing_major, $target_major);      $version_patch_changed = '';      $patch = '';      // Defend ourselves from XML history files that contain no releases.      if (empty($available[$project]['releases'])) {        $projects[$project]['status'] = UPDATE_UNKNOWN;        $projects[$project]['reason'] = t('No available releases found');        continue;      }      foreach ($available[$project]['releases'] as $version => $release) {        // First, if this is the existing release, check a few conditions.        if ($projects[$project]['existing_version'] === $version) {          if (isset($release['terms']['Release type']) &&              in_array('Insecure', $release['terms']['Release type'])) {            $projects[$project]['status'] = UPDATE_NOT_SECURE;          }          elseif ($release['status'] == 'unpublished') {            $projects[$project]['status'] = UPDATE_REVOKED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'release-revoked',              'label' => t('Release revoked'),              'data' => t('Your currently installed release has been revoked, and is no longer available for download. Disabling everything included in this release or upgrading is strongly recommended!'),            );          }          elseif (isset($release['terms']['Release type']) &&                  in_array('Unsupported', $release['terms']['Release type'])) {            $projects[$project]['status'] = UPDATE_NOT_SUPPORTED;            if (empty($projects[$project]['extra'])) {              $projects[$project]['extra'] = array();            }            $projects[$project]['extra'][] = array(              'class' => 'release-not-supported',              'label' => t('Release not supported'),              'data' => t('Your currently installed release is now unsupported, and is no longer available for download. Disabling everything included in this release or upgrading is strongly recommended!'),            );          }        }        // Otherwise, ignore unpublished, insecure, or unsupported releases.        if ($release['status'] == 'unpublished' ||            (isset($release['terms']['Release type']) &&             (in_array('Insecure', $release['terms']['Release type']) ||              in_array('Unsupported', $release['terms']['Release type'])))) {          continue;        }        // See if this is a higher major version than our target and yet still        // supported. If so, record it as an "Also available" release.        if ($release['version_major'] > $target_major) {          if (in_array($release['version_major'], $supported_majors)) {            if (!isset($available[$project]['also'])) {              $available[$project]['also'] = array();            }            if (!isset($available[$project]['also'][$release['version_major']])) {              $available[$project]['also'][$release['version_major']] = $version;            }          }          // Otherwise, this release can't matter to us, since it's neither          // from the release series we're currently using nor the recommended          // release. We don't even care about security updates for this          // branch, since if a project maintainer puts out a security release          // at a higher major version and not at the lower major version,          // they must remove the lower version from the supported major          // versions at the same time, in which case we won't hit this code.          continue;        }        // Look for the 'latest version' if we haven't found it yet. Latest is        // defined as the most recent version for the target major version.        if (!isset($available[$project]['latest_version'])            && $release['version_major'] == $target_major) {          $available[$project]['latest_version'] = $version;        }        // Look for the development snapshot release for this branch.        if (!isset($available[$project]['dev_version'])            && $release['version_major'] == $target_major            && isset($release['version_extra'])            && $release['version_extra'] == 'dev') {          $available[$project]['dev_version'] = $version;        }        // Look for the 'recommended' version if we haven't found it yet (see        // phpdoc at the top of this function for the definition).        if (!isset($available[$project]['recommended'])            && $release['version_major'] == $target_major            && isset($release['version_patch'])) {          if ($patch != $release['version_patch']) {            $patch = $release['version_patch'];            $version_patch_changed = $release['version'];          }          if (empty($release['version_extra']) && $patch == $release['version_patch']) {            $available[$project]['recommended'] = $version_patch_changed;          }        }        // Stop searching once we hit the currently installed version.        if ($projects[$project]['existing_version'] === $version) {          break;        }        // If we're running a dev snapshot and have a timestamp, stop        // searching for security updates once we hit an official release        // older than what we've got. Allow 100 seconds of leeway to handle        // differences between the datestamp in the .info file and the        // timestamp of the tarball itself (which are usually off by 1 or 2        // seconds) so that we don't flag that as a new release.        if ($projects[$project]['install_type'] == 'dev') {          if (empty($projects[$project]['datestamp'])) {            // We don't have current timestamp info, so we can't know.            continue;          }          elseif (isset($release['date']) && ($projects[$project]['datestamp'] + 100 > $release['date'])) {            // We're newer than this, so we can skip it.            continue;          }        }        // See if this release is a security update.        if (isset($release['terms']['Release type'])            && in_array('Security update', $release['terms']['Release type'])) {          $projects[$project]['security updates'][] = $release;        }      }      // If we were unable to find a recommended version, then make the latest      // version the recommended version if possible.      if (!isset($available[$project]['recommended']) && isset($available[$project]['latest_version'])) {        $available[$project]['recommended'] = $available[$project]['latest_version'];      }      // Stash the info about available releases into our $projects array.      $projects[$project] += $available[$project];      //      // Check to see if we need an update or not.      //      if (!empty($projects[$project]['security updates'])) {        // If we found security updates, that always trumps any other status.        $projects[$project]['status'] = UPDATE_NOT_SECURE;      }      if (isset($projects[$project]['status'])) {        // If we already know the status, we're done.        continue;      }      // If we don't know what to recommend, there's nothing we can report.      // Bail out early.      if (!isset($projects[$project]['recommended'])) {        $projects[$project]['status'] = UPDATE_UNKNOWN;        $projects[$project]['reason'] = t('No available releases found');        continue;      }      // If we're running a dev snapshot, compare the date of the dev snapshot      // with the latest official version, and record the absolute latest in      // 'latest_dev' so we can correctly decide if there's a newer release      // than our current snapshot.      if ($projects[$project]['install_type'] == 'dev') {        if (isset($available[$project]['dev_version']) && $available[$project]['releases'][$available[$project]['dev_version']]['date'] > $available[$project]['releases'][$available[$project]['latest_version']]['date']) {          $projects[$project]['latest_dev'] = $available[$project]['dev_version'];        }        else {          $projects[$project]['latest_dev'] = $available[$project]['latest_version'];        }      }      // Figure out the status, based on what we've seen and the install type.      switch ($projects[$project]['install_type']) {        case 'official':          if ($projects[$project]['existing_version'] === $projects[$project]['recommended'] || $projects[$project]['existing_version'] === $projects[$project]['latest_version']) {            $projects[$project]['status'] = UPDATE_CURRENT;          }          else {            $projects[$project]['status'] = UPDATE_NOT_CURRENT;          }          break;        case 'dev':          $latest = $available[$project]['releases'][$projects[$project]['latest_dev']];          if (empty($projects[$project]['datestamp'])) {            $projects[$project]['status'] = UPDATE_NOT_CHECKED;            $projects[$project]['reason'] = t('Unknown release date');          }          elseif (($projects[$project]['datestamp'] + 100 > $latest['date'])) {            $projects[$project]['status'] = UPDATE_CURRENT;          }          else {            $projects[$project]['status'] = UPDATE_NOT_CURRENT;          }          break;        default:          $projects[$project]['status'] = UPDATE_UNKNOWN;          $projects[$project]['reason'] = t('Invalid info');      }    }    else {      $projects[$project]['status'] = UPDATE_UNKNOWN;      $projects[$project]['reason'] = t('No available releases found');    }  }  // Give other modules a chance to alter the status (for example, to allow a  // contrib module to provide fine-grained settings to ignore specific  // projects or releases).  drupal_alter('update_status', $projects);  // Cache the site's update status for at most 1 hour.  _update_cache_set('update_project_data', $projects, time() + 3600);  return $projects;}/** * Retrieve data from {cache_update} or empty the cache when necessary. * * Two very expensive arrays computed by this module are the list of all * installed modules and themes (and .info data, project associations, etc), * and the current status of the site relative to the currently available * releases. These two arrays are cached in the {cache_update} table and used * whenever possible. The cache is cleared whenever the administrator visits * the status report, available updates report, or the module or theme * administration pages, since we should always recompute the most current * values on any of those pages. * * Note: while both of these arrays are expensive to compute (in terms of disk * I/O and some fairly heavy CPU processing), neither of these is the actual * data about available updates that we have to fetch over the network from * updates.drupal.org. That information is stored with the * 'update_available_releases' cache ID -- it needs to persist longer than 1 * hour and never get invalidated just by visiting a page on the site. * * @param $cid *   The cache id of data to return from the cache. Valid options are *   'update_project_data' and 'update_project_projects'. * * @return *   The cached value of the $projects array generated by *   update_calculate_project_data() or update_get_projects(), or an empty *   array when the cache is cleared. */function update_project_cache($cid) {  $projects = array();  // On certain paths, we should clear the cache and recompute the projects or  // update status of the site to avoid presenting stale information.  $q = $_GET['q'];  $paths = array('admin/build/modules', 'admin/build/themes', 'admin/reports', 'admin/reports/updates', 'admin/reports/status', 'admin/reports/updates/check');  if (in_array($q, $paths)) {    _update_cache_clear($cid);  }  else {    $cache = _update_cache_get($cid);    if (!empty($cache->data) && $cache->expire > time()) {      $projects = $cache->data;    }  }  return $projects;}/** * Filter the project .info data to only save attributes we need. * * @param array $info *   Array of .info file data as returned by drupal_parse_info_file(). * * @return *   Array of .info file data we need for the Update manager. * * @see _update_process_info_list() */function update_filter_project_info($info) {  $whitelist = array(    '_info_file_ctime',    'datestamp',    'major',    'name',    'package',    'project',    'project status url',    'version',   );  return array_intersect_key($info, drupal_map_assoc($whitelist));}
<?php// $Id$/** * @file * Multiple language handling functionality. *//** *  Choose a language for the page, based on language negotiation settings. */function language_initialize() {  global $user;  // Configured presentation language mode.  $mode = variable_get('language_negotiation', LANGUAGE_NEGOTIATION_NONE);  // Get a list of enabled languages.  $languages = language_list('enabled');  $languages = $languages[1];    switch ($mode) {    case LANGUAGE_NEGOTIATION_NONE:      return language_default();    case LANGUAGE_NEGOTIATION_DOMAIN:      foreach ($languages as $language) {        $parts = parse_url($language->domain);        if (!empty($parts['host']) && ($_SERVER['HTTP_HOST'] == $parts['host'])) {          return $language;        }      }      return language_default();    case LANGUAGE_NEGOTIATION_PATH_DEFAULT:    case LANGUAGE_NEGOTIATION_PATH:      // $_GET['q'] might not be available at this time, because      // path initialization runs after the language bootstrap phase.      $args = isset($_GET['q']) ? explode('/', $_GET['q']) : array();      $prefix = array_shift($args);      // Search prefix within enabled languages.      foreach ($languages as $language) {        if (!empty($language->prefix) && $language->prefix == $prefix) {          // Rebuild $GET['q'] with the language removed.          $_GET['q'] = implode('/', $args);          return $language;        }      }      if ($mode == LANGUAGE_NEGOTIATION_PATH_DEFAULT) {        // If we did not found the language by prefix, choose the default.        return language_default();      }      break;  }  // User language.  if ($user->uid && isset($languages[$user->language])) {    return $languages[$user->language];  }  // Browser accept-language parsing.  if ($language = language_from_browser()) {    return $language;  }  // Fall back on the default if everything else fails.  return language_default();}/** * Identify language from the Accept-language HTTP header we got. */function language_from_browser() {  // Specified by the user via the browser's Accept Language setting  // Samples: "hu, en-us;q=0.66, en;q=0.33", "hu,en-us;q=0.5"  $browser_langs = array();  if (isset($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {    $browser_accept = explode(",", $_SERVER['HTTP_ACCEPT_LANGUAGE']);    for ($i = 0; $i < count($browser_accept); $i++) {      // The language part is either a code or a code with a quality.      // We cannot do anything with a * code, so it is skipped.      // If the quality is missing, it is assumed to be 1 according to the RFC.      if (preg_match("!([a-z-]+)(;q=([0-9\\.]+))?!", trim($browser_accept[$i]), $found)) {        $browser_langs[$found[1]] = (isset($found[3]) ? (float) $found[3] : 1.0);      }    }  }  // Order the codes by quality  arsort($browser_langs);  // Try to find the first preferred language we have  $languages = language_list('enabled');  foreach ($browser_langs as $langcode => $q) {    if (isset($languages['1'][$langcode])) {      return $languages['1'][$langcode];    }  }}/** * Rewrite URL's with language based prefix. Parameters are the same * as those of the url() function. */function language_url_rewrite(&$path, &$options) {  global $language;  // Only modify relative (insite) URLs.  if (!$options['external']) {    // Language can be passed as an option, or we go for current language.    if (!isset($options['language'])) {      $options['language'] = $language;    }    switch (variable_get('language_negotiation', LANGUAGE_NEGOTIATION_NONE)) {      case LANGUAGE_NEGOTIATION_NONE:        // No language dependent path allowed in this mode.        unset($options['language']);        break;      case LANGUAGE_NEGOTIATION_DOMAIN:        if ($options['language']->domain) {          // Ask for an absolute URL with our modified base_url.          $options['absolute'] = TRUE;          $options['base_url'] = $options['language']->domain;        }        break;      case LANGUAGE_NEGOTIATION_PATH_DEFAULT:        $default = language_default();        if ($options['language']->language == $default->language) {          break;        }        // Intentionally no break here.      case LANGUAGE_NEGOTIATION_PATH:        if (!empty($options['language']->prefix)) {          $options['prefix'] = $options['language']->prefix .'/';        }        break;    }  }}
<?php// $Id$/** * @file * The "Update status" module checks for available updates of Drupal core and * any installed contributed modules and themes. It warns site administrators * if newer releases are available via the system status report * (admin/reports/status), the module and theme pages, and optionally via email. *//** * URL to check for updates, if a given project doesn't define its own. */define('UPDATE_DEFAULT_URL', 'http://updates.drupal.org/release-history');// These are internally used constants for this code, do not modify./** * Project is missing security update(s). */define('UPDATE_NOT_SECURE', 1);/** * Current release has been unpublished and is no longer available. */define('UPDATE_REVOKED', 2);/** * Current release is no longer supported by the project maintainer. */define('UPDATE_NOT_SUPPORTED', 3);/** * Project has a new release available, but it is not a security release. */define('UPDATE_NOT_CURRENT', 4);/** * Project is up to date. */define('UPDATE_CURRENT', 5);/** * Project's status cannot be checked. */define('UPDATE_NOT_CHECKED', -1);/** * No available update data was found for project. */define('UPDATE_UNKNOWN', -2);/** * There was a failure fetching available update data for this project. */define('UPDATE_NOT_FETCHED', -3);/** * Maximum number of attempts to fetch available update data from a given host. */define('UPDATE_MAX_FETCH_ATTEMPTS', 2);/** * Implementation of hook_help(). */function update_help($path, $arg) {  switch ($path) {    case 'admin/reports/updates':      $output = '<p>'. t('Here you can find information about available updates for your installed modules and themes. Note that each module or theme is part of a "project", which may or may not have the same name, and might include multiple modules or themes within it.') .'</p>';      $output .= '<p>'. t('To extend the functionality or to change the look of your site, a number of contributed <a href="@modules">modules</a> and <a href="@themes">themes</a> are available.', array('@modules' => 'http://drupal.org/project/modules', '@themes' => 'http://drupal.org/project/themes')) .'</p>';      return $output;    case 'admin/build/themes':    case 'admin/build/modules':      include_once './includes/install.inc';      $status = update_requirements('runtime');      foreach (array('core', 'contrib') as $report_type) {        $type = 'update_'. $report_type;        if (isset($status[$type]['severity'])) {          if ($status[$type]['severity'] == REQUIREMENT_ERROR) {            drupal_set_message($status[$type]['description'], 'error');          }          elseif ($status[$type]['severity'] == REQUIREMENT_WARNING) {            drupal_set_message($status[$type]['description'], 'warning');          }        }      }      return '<p>'. t('See the <a href="@available_updates">available updates</a> page for information on installed modules and themes with new versions released.', array('@available_updates' => url('admin/reports/updates'))) .'</p>';    case 'admin/reports/updates/settings':    case 'admin/reports/status':      // These two pages don't need additional nagging.      break;    case 'admin/help#update':      $output = '<p>'. t("The Update status module periodically checks for new versions of your site's software (including contributed modules and themes), and alerts you to available updates.") .'</p>';      $output .= '<p>'. t('The <a href="@update-report">report of available updates</a> will alert you when new releases are available for download. You may configure options for update checking frequency and notifications at the <a href="@update-settings">Update status module settings page</a>.', array('@update-report' => url('admin/reports/updates'), '@update-settings' => url('admin/reports/updates/settings'))) .'</p>';      $output .= '<p>'. t('Please note that in order to provide this information, anonymous usage statistics are sent to drupal.org. If desired, you may disable the Update status module from the <a href="@modules">module administration page</a>.', array('@modules' => url('admin/build/modules'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@update">Update status module</a>.', array('@update' => 'http://drupal.org/handbook/modules/update')) .'</p>';      return $output;    default:      // Otherwise, if we're on *any* admin page and there's a security      // update missing, print an error message about it.      if (arg(0) == 'admin' && strpos($path, '#') === FALSE          && user_access('administer site configuration')) {        include_once './includes/install.inc';        $status = update_requirements('runtime');        foreach (array('core', 'contrib') as $report_type) {          $type = 'update_'. $report_type;          if (isset($status[$type])              && isset($status[$type]['reason'])              && $status[$type]['reason'] === UPDATE_NOT_SECURE) {            drupal_set_message($status[$type]['description'], 'error');          }        }      }  }}/** * Implementation of hook_menu(). */function update_menu() {  $items = array();  $items['admin/reports/updates'] = array(    'title' => 'Available updates',    'description' => 'Get a status report about available updates for your installed modules and themes.',    'page callback' => 'update_status',    'access arguments' => array('administer site configuration'),    'file' => 'update.report.inc',    'weight' => 10,  );  $items['admin/reports/updates/list'] = array(    'title' => 'List',    'page callback' => 'update_status',    'access arguments' => array('administer site configuration'),    'file' => 'update.report.inc',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/reports/updates/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('update_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'update.settings.inc',    'type' => MENU_LOCAL_TASK,  );  $items['admin/reports/updates/check'] = array(    'title' => 'Manual update check',    'page callback' => 'update_manual_status',    'access arguments' => array('administer site configuration'),    'file' => 'update.fetch.inc',    'type' => MENU_CALLBACK,  );  return $items;}/** * Implementation of the hook_theme() registry. */function update_theme() {  return array(    'update_settings' => array(      'arguments' => array('form' => NULL),    ),    'update_report' => array(      'arguments' => array('data' => NULL),    ),    'update_version' => array(      'arguments' => array('version' => NULL, 'tag' => NULL, 'class' => NULL),    ),  );}/** * Implementation of hook_requirements(). * * @return *   An array describing the status of the site regarding available updates. *   If there is no update data, only one record will be returned, indicating *   that the status of core can't be determined. If data is available, there *   will be two records: one for core, and another for all of contrib *   (assuming there are any contributed modules or themes enabled on the *   site). In addition to the fields expected by hook_requirements ('value', *   'severity', and optionally 'description'), this array will contain a *   'reason' attribute, which is an integer constant to indicate why the *   given status is being returned (UPDATE_NOT_SECURE, UPDATE_NOT_CURRENT, or *   UPDATE_UNKNOWN). This is used for generating the appropriate e-mail *   notification messages during update_cron(), and might be useful for other *   modules that invoke update_requirements() to find out if the site is up *   to date or not. * * @see _update_message_text() * @see _update_cron_notify() */function update_requirements($phase) {  if ($phase == 'runtime') {    if ($available = update_get_available(FALSE)) {      module_load_include('inc', 'update', 'update.compare');      $data = update_calculate_project_data($available);      // First, populate the requirements for core:      $requirements['update_core'] = _update_requirement_check($data['drupal'], 'core');      // We don't want to check drupal a second time.      unset($data['drupal']);      if (!empty($data)) {        // Now, sort our $data array based on each project's status. The        // status constants are numbered in the right order of precedence, so        // we just need to make sure the projects are sorted in ascending        // order of status, and we can look at the first project we find.        uasort($data, '_update_project_status_sort');        $first_project = reset($data);        $requirements['update_contrib'] = _update_requirement_check($first_project, 'contrib');      }    }    else {      $requirements['update_core']['title'] = t('Drupal core update status');      $requirements['update_core']['value'] = t('No update data available');      $requirements['update_core']['severity'] = REQUIREMENT_WARNING;      $requirements['update_core']['reason'] = UPDATE_UNKNOWN;      $requirements['update_core']['description'] = _update_no_data();    }    return $requirements;  }}/** * Private helper method to fill in the requirements array. * * This is shared for both core and contrib to generate the right elements in * the array for hook_requirements(). * * @param $project *  Array of information about the project we're testing as returned by *  update_calculate_project_data(). * @param $type *  What kind of project is this ('core' or 'contrib'). * * @return *  An array to be included in the nested $requirements array. * * @see hook_requirements() * @see update_requirements() * @see update_calculate_project_data() */function _update_requirement_check($project, $type) {  $requirement = array();  if ($type == 'core') {    $requirement['title'] = t('Drupal core update status');  }  else {    $requirement['title'] = t('Module and theme update status');  }  $status = $project['status'];  if ($status != UPDATE_CURRENT) {    $requirement['reason'] = $status;    $requirement['description'] = _update_message_text($type, $status, TRUE);    $requirement['severity'] = REQUIREMENT_ERROR;  }  switch ($status) {    case UPDATE_NOT_SECURE:      $requirement_label = t('Not secure!');      break;    case UPDATE_REVOKED:      $requirement_label = t('Revoked!');      break;    case UPDATE_NOT_SUPPORTED:      $requirement_label = t('Unsupported release');      break;    case UPDATE_NOT_CURRENT:      $requirement_label = t('Out of date');      $requirement['severity'] = REQUIREMENT_WARNING;      break;    case UPDATE_UNKNOWN:    case UPDATE_NOT_CHECKED:    case UPDATE_NOT_FETCHED:      $requirement_label = isset($project['reason']) ? $project['reason'] : t('Can not determine status');      $requirement['severity'] = REQUIREMENT_WARNING;      break;    default:      $requirement_label = t('Up to date');  }  if ($status != UPDATE_CURRENT && $type == 'core' && isset($project['recommended'])) {    $requirement_label .= ' '. t('(version @version available)', array('@version' => $project['recommended']));  }  $requirement['value'] = l($requirement_label, 'admin/reports/updates');  return $requirement;}/** * Implementation of hook_cron(). */function update_cron() {  $frequency = variable_get('update_check_frequency', 1);  $interval = 60 * 60 * 24 * $frequency;  // Cron should check for updates if there is no update data cached or if the  // configured update interval has elapsed.  if (!_update_cache_get('update_available_releases') || ((time() - variable_get('update_last_check', 0)) > $interval)) {    update_refresh();    _update_cron_notify();  }}/** * Implementation of hook_form_alter(). * * Adds a submit handler to the system modules and themes forms, so that if a * site admin saves either form, we invalidate the cache of available updates. * * @see update_invalidate_cache() */function update_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'system_modules' || $form_id == 'system_themes_form' ) {    $form['#submit'][] = 'update_invalidate_cache';  }}/** * Prints a warning message when there is no data about available updates. */function _update_no_data() {  $destination = drupal_get_destination();  return t('No information is available about potential new releases for currently installed modules and themes. To check for updates, you may need to <a href="@run_cron">run cron</a> or you can <a href="@check_manually">check manually</a>. Please note that checking for available updates can take a long time, so please be patient.', array(    '@run_cron' => url('admin/reports/status/run-cron', array('query' => $destination)),    '@check_manually' => url('admin/reports/updates/check', array('query' => $destination)),  ));}/** * Internal helper to try to get the update information from the cache * if possible, and to refresh the cache when necessary. * * In addition to checking the cache lifetime, this function also ensures that * there are no .info files for enabled modules or themes that have a newer * modification timestamp than the last time we checked for available update * data. If any .info file was modified, it almost certainly means a new * version of something was installed. Without fresh available update data, * the logic in update_calculate_project_data() will be wrong and produce * confusing, bogus results. * * @param $refresh *   Boolean to indicate if this method should refresh the cache automatically *   if there's no data. * * @see update_refresh() * @see update_get_projects() */function update_get_available($refresh = FALSE) {  module_load_include('inc', 'update', 'update.compare');  $available = array();  // First, make sure that none of the .info files have a change time  // newer than the last time we checked for available updates.  $needs_refresh = FALSE;  $last_check = variable_get('update_last_check', 0);  $projects = update_get_projects();  foreach ($projects as $key => $project) {    if ($project['info']['_info_file_ctime'] > $last_check) {      $needs_refresh = TRUE;      break;    }  }  if (!$needs_refresh && ($cache = _update_cache_get('update_available_releases')) && $cache->expire > time()) {    $available = $cache->data;  }  elseif ($needs_refresh || $refresh) {    // If we need to refresh due to a newer .info file, ignore the argument    // and force the refresh (e.g., even for update_requirements()) to prevent    // bogus results.    $available = update_refresh();  }  return $available;}/** * Wrapper to load the include file and then refresh the release data. */function update_refresh() {  module_load_include('inc', 'update', 'update.fetch');  return _update_refresh();}/** * Implementation of hook_mail(). * * Constructs the email notification message when the site is out of date. * * @param $key *   Unique key to indicate what message to build, always 'status_notify'. * @param $message *   Reference to the message array being built. * @param $params *   Array of parameters to indicate what kind of text to include in the *   message body. This is a keyed array of message type ('core' or 'contrib') *   as the keys, and the status reason constant (UPDATE_NOT_SECURE, etc) for *   the values. * * @see drupal_mail() * @see _update_cron_notify() * @see _update_message_text() */function update_mail($key, &$message, $params) {  $language = $message['language'];  $langcode = $language->language;  $message['subject'] .= t('New release(s) available for !site_name', array('!site_name' => variable_get('site_name', 'Drupal')), $langcode);  foreach ($params as $msg_type => $msg_reason) {    $message['body'][] = _update_message_text($msg_type, $msg_reason, FALSE, $language);  }  $message['body'][] = t('See the available updates page for more information:', array(), $langcode) ."\n". url('admin/reports/updates', array('absolute' => TRUE, 'language' => $language));}/** * Helper function to return the appropriate message text when the site is out * of date or missing a security update. * * These error messages are shared by both update_requirements() for the * site-wide status report at admin/reports/status and in the body of the * notification emails generated by update_cron(). * * @param $msg_type *   String to indicate what kind of message to generate. Can be either *   'core' or 'contrib'. * @param $msg_reason *   Integer constant specifying why message is generated. * @param $report_link *   Boolean that controls if a link to the updates report should be added. * @param $language *   An optional language object to use. * @return *   The properly translated error message for the given key. */function _update_message_text($msg_type, $msg_reason, $report_link = FALSE, $language = NULL) {  $langcode = isset($language) ? $language->language : NULL;  $text = '';  switch ($msg_reason) {    case UPDATE_NOT_SECURE:      if ($msg_type == 'core') {        $text = t('There is a security update available for your version of Drupal. To ensure the security of your server, you should update immediately!', array(), $langcode);      }      else {        $text = t('There are security updates available for one or more of your modules or themes. To ensure the security of your server, you should update immediately!', array(), $langcode);      }      break;    case UPDATE_REVOKED:      if ($msg_type == 'core') {        $text = t('Your version of Drupal has been revoked and is no longer available for download. Upgrading is strongly recommended!', array(), $langcode);      }      else {        $text = t('The installed version of at least one of your modules or themes has been revoked and is no longer available for download. Upgrading or disabling is strongly recommended!', array(), $langcode);      }      break;    case UPDATE_NOT_SUPPORTED:      if ($msg_type == 'core') {        $text = t('Your version of Drupal is no longer supported. Upgrading is strongly recommended!', array(), $langcode);      }      else {        $text = t('The installed version of at least one of your modules or themes is no longer supported. Upgrading or disabling is strongly recommended! Please see the project homepage for more details.', array(), $langcode);      }      break;    case UPDATE_NOT_CURRENT:      if ($msg_type == 'core') {        $text = t('There are updates available for your version of Drupal. To ensure the proper functioning of your site, you should update as soon as possible.', array(), $langcode);      }      else {        $text = t('There are updates available for one or more of your modules or themes. To ensure the proper functioning of your site, you should update as soon as possible.', array(), $langcode);      }      break;    case UPDATE_UNKNOWN:    case UPDATE_NOT_CHECKED:    case UPDATE_NOT_FETCHED:      if ($msg_type == 'core') {        $text = t('There was a problem determining the status of available updates for your version of Drupal.', array(), $langcode);      }      else {        $text = t('There was a problem determining the status of available updates for one or more of your modules or themes.', array(), $langcode);      }      break;  }  if ($report_link) {    $text .= ' '. t('See the <a href="@available_updates">available updates</a> page for more information.', array('@available_updates' => url('admin/reports/updates', array('language' => $language))), $langcode);  }  return $text;}/** * Private sort function to order projects based on their status. * * @see update_requirements() * @see uasort() */function _update_project_status_sort($a, $b) {  // The status constants are numerically in the right order, so we can  // usually subtract the two to compare in the order we want. However,  // negative status values should be treated as if they are huge, since we  // always want them at the bottom of the list.  $a_status = $a['status'] > 0 ? $a['status'] : (-10 * $a['status']);  $b_status = $b['status'] > 0 ? $b['status'] : (-10 * $b['status']);  return $a_status - $b_status;}/** * @defgroup update_status_cache Private update status cache system * @{ * * We specifically do NOT use the core cache API for saving the fetched data * about available updates. It is vitally important that this cache is only * cleared when we're populating it after successfully fetching new available * update data. Usage of the core cache API results in all sorts of potential * problems that would result in attempting to fetch available update data all * the time, including if a site has a "minimum cache lifetime" (which is both * a minimum and a maximum) defined, or if a site uses memcache or another * plug-able cache system that assumes volatile caches. * * Update module still uses the {cache_update} table, but instead of using * cache_set(), cache_get(), and cache_clear_all(), there are private helper * functions that implement these same basic tasks but ensure that the cache * is not prematurely cleared, and that the data is always stored in the * database, even if memcache or another cache backend is in use. *//** * Store data in the private update status cache table. * * Note: this function completely ignores the {cache_update}.headers field * since that is meaningless for the kinds of data we're caching. * * @param $cid *   The cache ID to save the data with. * @param $data *   The data to store. * @param $expire *   One of the following values: *   - CACHE_PERMANENT: Indicates that the item should never be removed except *     by explicitly using _update_cache_clear() or update_invalidate_cache(). *   - A Unix timestamp: Indicates that the item should be kept at least until *     the given time, after which it will be invalidated. */function _update_cache_set($cid, $data, $expire) {  $serialized = 0;  if (is_object($data) || is_array($data)) {    $data = serialize($data);    $serialized = 1;  }  $created = time();  db_query("UPDATE {cache_update} SET data = %b, created = %d, expire = %d, serialized = %d WHERE cid = '%s'", $data, $created, $expire, $serialized, $cid);  if (!db_affected_rows()) {    @db_query("INSERT INTO {cache_update} (cid, data, created, expire, serialized) VALUES ('%s', %b, %d, %d, %d)", $cid, $data, $created, $expire, $serialized);  }}/** * Retrieve data from the private update status cache table. * * @param $cid *   The cache ID to retrieve. * @return *   The data for the given cache ID, or NULL if the ID was not found. */function _update_cache_get($cid) {  $cache = db_fetch_object(db_query("SELECT data, created, expire, serialized FROM {cache_update} WHERE cid = '%s'", $cid));  if (isset($cache->data)) {    $cache->data = db_decode_blob($cache->data);    if ($cache->serialized) {      $cache->data = unserialize($cache->data);    }  }  return $cache;}/** * Invalidates specific cached data relating to update status. * * @param $cid *   Optional cache ID of the record to clear from the private update module *   cache. If empty, all records will be cleared from the table. */function _update_cache_clear($cid = NULL) {  if (empty($cid)) {    db_query("TRUNCATE TABLE {cache_update}");  }  else {    db_query("DELETE FROM {cache_update} WHERE cid = '%s'", $cid);  }}/** * Implementation of hook_flush_caches(). * * Called from update.php (among others) to flush the caches. * Since we're running update.php, we are likely to install a new version of * something, in which case, we want to check for available update data again. * However, because we have our own caching system, we need to directly clear * the database table ourselves at this point and return nothing, for example, * on sites that use memcache where cache_clear_all() won't know how to purge * this data. * * However, we only want to do this from update.php, since otherwise, we'd * lose all the available update data on every cron run. So, we specifically * check if the site is in MAINTENANCE_MODE == 'update' (which indicates * update.php is running, not update module... alas for overloaded names). */function update_flush_caches() {  if (defined('MAINTENANCE_MODE') && MAINTENANCE_MODE == 'update') {    _update_cache_clear();  }  return array();}/** * Invalidates all cached data relating to update status. */function update_invalidate_cache() {  _update_cache_clear();}/** * @} End of "defgroup update_status_cache". */
<?php// $Id$/** * @file * Enables site-wide keyword searching. *//** * Matches Unicode character classes to exclude from the search index. * * See: http://www.unicode.org/Public/UNIDATA/UCD.html#General_Category_Values * * The index only contains the following character classes: * Lu     Letter, Uppercase * Ll     Letter, Lowercase * Lt     Letter, Titlecase * Lo     Letter, Other * Nd     Number, Decimal Digit * No     Number, Other */define('PREG_CLASS_SEARCH_EXCLUDE','\x{0}-\x{2f}\x{3a}-\x{40}\x{5b}-\x{60}\x{7b}-\x{bf}\x{d7}\x{f7}\x{2b0}-'.'\x{385}\x{387}\x{3f6}\x{482}-\x{489}\x{559}-\x{55f}\x{589}-\x{5c7}\x{5f3}-'.'\x{61f}\x{640}\x{64b}-\x{65e}\x{66a}-\x{66d}\x{670}\x{6d4}\x{6d6}-\x{6ed}'.'\x{6fd}\x{6fe}\x{700}-\x{70f}\x{711}\x{730}-\x{74a}\x{7a6}-\x{7b0}\x{901}-'.'\x{903}\x{93c}\x{93e}-\x{94d}\x{951}-\x{954}\x{962}-\x{965}\x{970}\x{981}-'.'\x{983}\x{9bc}\x{9be}-\x{9cd}\x{9d7}\x{9e2}\x{9e3}\x{9f2}-\x{a03}\x{a3c}-'.'\x{a4d}\x{a70}\x{a71}\x{a81}-\x{a83}\x{abc}\x{abe}-\x{acd}\x{ae2}\x{ae3}'.'\x{af1}-\x{b03}\x{b3c}\x{b3e}-\x{b57}\x{b70}\x{b82}\x{bbe}-\x{bd7}\x{bf0}-'.'\x{c03}\x{c3e}-\x{c56}\x{c82}\x{c83}\x{cbc}\x{cbe}-\x{cd6}\x{d02}\x{d03}'.'\x{d3e}-\x{d57}\x{d82}\x{d83}\x{dca}-\x{df4}\x{e31}\x{e34}-\x{e3f}\x{e46}-'.'\x{e4f}\x{e5a}\x{e5b}\x{eb1}\x{eb4}-\x{ebc}\x{ec6}-\x{ecd}\x{f01}-\x{f1f}'.'\x{f2a}-\x{f3f}\x{f71}-\x{f87}\x{f90}-\x{fd1}\x{102c}-\x{1039}\x{104a}-'.'\x{104f}\x{1056}-\x{1059}\x{10fb}\x{10fc}\x{135f}-\x{137c}\x{1390}-\x{1399}'.'\x{166d}\x{166e}\x{1680}\x{169b}\x{169c}\x{16eb}-\x{16f0}\x{1712}-\x{1714}'.'\x{1732}-\x{1736}\x{1752}\x{1753}\x{1772}\x{1773}\x{17b4}-\x{17db}\x{17dd}'.'\x{17f0}-\x{180e}\x{1843}\x{18a9}\x{1920}-\x{1945}\x{19b0}-\x{19c0}\x{19c8}'.'\x{19c9}\x{19de}-\x{19ff}\x{1a17}-\x{1a1f}\x{1d2c}-\x{1d61}\x{1d78}\x{1d9b}-'.'\x{1dc3}\x{1fbd}\x{1fbf}-\x{1fc1}\x{1fcd}-\x{1fcf}\x{1fdd}-\x{1fdf}\x{1fed}-'.'\x{1fef}\x{1ffd}-\x{2070}\x{2074}-\x{207e}\x{2080}-\x{2101}\x{2103}-\x{2106}'.'\x{2108}\x{2109}\x{2114}\x{2116}-\x{2118}\x{211e}-\x{2123}\x{2125}\x{2127}'.'\x{2129}\x{212e}\x{2132}\x{213a}\x{213b}\x{2140}-\x{2144}\x{214a}-\x{2b13}'.'\x{2ce5}-\x{2cff}\x{2d6f}\x{2e00}-\x{3005}\x{3007}-\x{303b}\x{303d}-\x{303f}'.'\x{3099}-\x{309e}\x{30a0}\x{30fb}-\x{30fe}\x{3190}-\x{319f}\x{31c0}-\x{31cf}'.'\x{3200}-\x{33ff}\x{4dc0}-\x{4dff}\x{a015}\x{a490}-\x{a716}\x{a802}\x{a806}'.'\x{a80b}\x{a823}-\x{a82b}\x{d800}-\x{f8ff}\x{fb1e}\x{fb29}\x{fd3e}\x{fd3f}'.'\x{fdfc}-\x{fe6b}\x{feff}-\x{ff0f}\x{ff1a}-\x{ff20}\x{ff3b}-\x{ff40}\x{ff5b}-'.'\x{ff65}\x{ff70}\x{ff9e}\x{ff9f}\x{ffe0}-\x{fffd}');/** * Matches all 'N' Unicode character classes (numbers) */define('PREG_CLASS_NUMBERS','\x{30}-\x{39}\x{b2}\x{b3}\x{b9}\x{bc}-\x{be}\x{660}-\x{669}\x{6f0}-\x{6f9}'.'\x{966}-\x{96f}\x{9e6}-\x{9ef}\x{9f4}-\x{9f9}\x{a66}-\x{a6f}\x{ae6}-\x{aef}'.'\x{b66}-\x{b6f}\x{be7}-\x{bf2}\x{c66}-\x{c6f}\x{ce6}-\x{cef}\x{d66}-\x{d6f}'.'\x{e50}-\x{e59}\x{ed0}-\x{ed9}\x{f20}-\x{f33}\x{1040}-\x{1049}\x{1369}-'.'\x{137c}\x{16ee}-\x{16f0}\x{17e0}-\x{17e9}\x{17f0}-\x{17f9}\x{1810}-\x{1819}'.'\x{1946}-\x{194f}\x{2070}\x{2074}-\x{2079}\x{2080}-\x{2089}\x{2153}-\x{2183}'.'\x{2460}-\x{249b}\x{24ea}-\x{24ff}\x{2776}-\x{2793}\x{3007}\x{3021}-\x{3029}'.'\x{3038}-\x{303a}\x{3192}-\x{3195}\x{3220}-\x{3229}\x{3251}-\x{325f}\x{3280}-'.'\x{3289}\x{32b1}-\x{32bf}\x{ff10}-\x{ff19}');/** * Matches all 'P' Unicode character classes (punctuation) */define('PREG_CLASS_PUNCTUATION','\x{21}-\x{23}\x{25}-\x{2a}\x{2c}-\x{2f}\x{3a}\x{3b}\x{3f}\x{40}\x{5b}-\x{5d}'.'\x{5f}\x{7b}\x{7d}\x{a1}\x{ab}\x{b7}\x{bb}\x{bf}\x{37e}\x{387}\x{55a}-\x{55f}'.'\x{589}\x{58a}\x{5be}\x{5c0}\x{5c3}\x{5f3}\x{5f4}\x{60c}\x{60d}\x{61b}\x{61f}'.'\x{66a}-\x{66d}\x{6d4}\x{700}-\x{70d}\x{964}\x{965}\x{970}\x{df4}\x{e4f}'.'\x{e5a}\x{e5b}\x{f04}-\x{f12}\x{f3a}-\x{f3d}\x{f85}\x{104a}-\x{104f}\x{10fb}'.'\x{1361}-\x{1368}\x{166d}\x{166e}\x{169b}\x{169c}\x{16eb}-\x{16ed}\x{1735}'.'\x{1736}\x{17d4}-\x{17d6}\x{17d8}-\x{17da}\x{1800}-\x{180a}\x{1944}\x{1945}'.'\x{2010}-\x{2027}\x{2030}-\x{2043}\x{2045}-\x{2051}\x{2053}\x{2054}\x{2057}'.'\x{207d}\x{207e}\x{208d}\x{208e}\x{2329}\x{232a}\x{23b4}-\x{23b6}\x{2768}-'.'\x{2775}\x{27e6}-\x{27eb}\x{2983}-\x{2998}\x{29d8}-\x{29db}\x{29fc}\x{29fd}'.'\x{3001}-\x{3003}\x{3008}-\x{3011}\x{3014}-\x{301f}\x{3030}\x{303d}\x{30a0}'.'\x{30fb}\x{fd3e}\x{fd3f}\x{fe30}-\x{fe52}\x{fe54}-\x{fe61}\x{fe63}\x{fe68}'.'\x{fe6a}\x{fe6b}\x{ff01}-\x{ff03}\x{ff05}-\x{ff0a}\x{ff0c}-\x{ff0f}\x{ff1a}'.'\x{ff1b}\x{ff1f}\x{ff20}\x{ff3b}-\x{ff3d}\x{ff3f}\x{ff5b}\x{ff5d}\x{ff5f}-'.'\x{ff65}');/** * Matches all CJK characters that are candidates for auto-splitting * (Chinese, Japanese, Korean). * Contains kana and BMP ideographs. */define('PREG_CLASS_CJK', '\x{3041}-\x{30ff}\x{31f0}-\x{31ff}\x{3400}-\x{4db5}'.'\x{4e00}-\x{9fbb}\x{f900}-\x{fad9}');/** * Implementation of hook_help(). */function search_help($path, $arg) {  switch ($path) {    case 'admin/help#search':      $output = '<p>'. t('The search module adds the ability to search for content by keywords. Search is often the only practical way to find content on a large site, and is useful for finding both users and posts.') .'</p>';      $output .= '<p>'. t('To provide keyword searching, the search engine maintains an index of words found in your site\'s content. To build and maintain this index, a correctly configured <a href="@cron">cron maintenance task</a> is required. Indexing behavior can be adjusted using the <a href="@searchsettings">search settings page</a>; for example, the <em>Number of items to index per cron run</em> sets the maximum number of items indexed in each pass of a <a href="@cron">cron maintenance task</a>. If necessary, reduce this number to prevent timeouts and memory errors when indexing.', array('@cron' => url('admin/reports/status'), '@searchsettings' => url('admin/settings/search'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@search">Search module</a>.', array('@search' => 'http://drupal.org/handbook/modules/search/')) .'</p>';      return $output;    case 'admin/settings/search':      return '<p>'. t('The search engine maintains an index of words found in your site\'s content. To build and maintain this index, a correctly configured <a href="@cron">cron maintenance task</a> is required. Indexing behavior can be adjusted using the settings below.', array('@cron' => url('admin/reports/status'))) .'</p>';    case 'search#noresults':      return t('<ul><li>Check if your spelling is correct.</li><li>Remove quotes around phrases to match each word individually: <em>"blue smurf"</em> will match less than <em>blue smurf</em>.</li><li>Consider loosening your query with <em>OR</em>: <em>blue smurf</em> will match less than <em>blue OR smurf</em>.</li></ul>');  }}/** * Implementation of hook_theme() */function search_theme() {  return array(    'search_theme_form' => array(      'arguments' => array('form' => NULL),      'template' => 'search-theme-form',    ),    'search_block_form' => array(      'arguments' => array('form' => NULL),      'template' => 'search-block-form',    ),    'search_result' => array(      'arguments' => array('result' => NULL, 'type' => NULL),      'file' => 'search.pages.inc',      'template' => 'search-result',    ),    'search_results' => array(      'arguments' => array('results' => NULL, 'type' => NULL),      'file' => 'search.pages.inc',      'template' => 'search-results',    ),  );}/** * Implementation of hook_perm(). */function search_perm() {  return array('search content', 'use advanced search', 'administer search');}/** * Implementation of hook_block(). */function search_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Search form');    // Not worth caching.    $blocks[0]['cache'] = BLOCK_NO_CACHE;    return $blocks;  }  else if ($op == 'view' && user_access('search content')) {    $block['content'] = drupal_get_form('search_block_form');    $block['subject'] = t('Search');    return $block;  }}/** * Implementation of hook_menu(). */function search_menu() {  $items['search'] = array(    'title' => 'Search',    'page callback' => 'search_view',    'access arguments' => array('search content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'search.pages.inc',  );  $items['admin/settings/search'] = array(    'title' => 'Search settings',    'description' => 'Configure relevance settings for search and other indexing options',    'page callback' => 'drupal_get_form',    'page arguments' => array('search_admin_settings'),    'access arguments' => array('administer search'),    'type' => MENU_NORMAL_ITEM,    'file' => 'search.admin.inc',  );  $items['admin/settings/search/wipe'] = array(    'title' => 'Clear index',    'page callback' => 'drupal_get_form',    'page arguments' => array('search_wipe_confirm'),    'access arguments' => array('administer search'),    'type' => MENU_CALLBACK,    'file' => 'search.admin.inc',  );  $items['admin/reports/search'] = array(    'title' => 'Top search phrases',    'description' => 'View most popular search phrases.',    'page callback' => 'dblog_top',    'page arguments' => array('search'),    'access arguments' => array('access site reports'),    'file' => 'dblog.admin.inc',    'file path' => drupal_get_path('module', 'dblog'),  );  foreach (module_implements('search') as $name) {    $items['search/'. $name .'/%menu_tail'] = array(      'title callback' => 'module_invoke',      'title arguments' => array($name, 'search', 'name', TRUE),      'page callback' => 'search_view',      'page arguments' => array($name),      'access callback' => '_search_menu',      'access arguments' => array($name),      'type' => MENU_LOCAL_TASK,      'parent' => 'search',      'file' => 'search.pages.inc',    );  }  return $items;}function _search_menu($name) {  return user_access('search content') && module_invoke($name, 'search', 'name');}/** * Wipes a part of or the entire search index. * * @param $sid *  (optional) The SID of the item to wipe. If specified, $type must be passed *  too. * @param $type *  (optional) The type of item to wipe. */function search_wipe($sid = NULL, $type = NULL, $reindex = FALSE) {  if ($type == NULL && $sid == NULL) {    module_invoke_all('search', 'reset');  }  else {    db_query("DELETE FROM {search_dataset} WHERE sid = %d AND type = '%s'", $sid, $type);    db_query("DELETE FROM {search_index} WHERE sid = %d AND type = '%s'", $sid, $type);    // Don't remove links if re-indexing.    if (!$reindex) {      db_query("DELETE FROM {search_node_links} WHERE sid = %d AND type = '%s'", $sid, $type);    }  }}/** * Marks a word as dirty (or retrieves the list of dirty words). This is used * during indexing (cron). Words which are dirty have outdated total counts in * the search_total table, and need to be recounted. */function search_dirty($word = NULL) {  static $dirty = array();  if ($word !== NULL) {    $dirty[$word] = TRUE;  }  else {    return $dirty;  }}/** * Implementation of hook_cron(). * * Fires hook_update_index() in all modules and cleans up dirty words (see * search_dirty). */function search_cron() {  // We register a shutdown function to ensure that search_total is always up  // to date.  register_shutdown_function('search_update_totals');  // Update word index  foreach (module_list() as $module) {    module_invoke($module, 'update_index');  }}/** * This function is called on shutdown to ensure that search_total is always * up to date (even if cron times out or otherwise fails). */function search_update_totals() {  // Update word IDF (Inverse Document Frequency) counts for new/changed words  foreach (search_dirty() as $word => $dummy) {    // Get total count    $total = db_result(db_query("SELECT SUM(score) FROM {search_index} WHERE word = '%s'", $word));    // Apply Zipf's law to equalize the probability distribution    $total = log10(1 + 1/(max(1, $total)));    db_query("UPDATE {search_total} SET count = %f WHERE word = '%s'", $total, $word);    if (!db_affected_rows()) {      db_query("INSERT INTO {search_total} (word, count) VALUES ('%s', %f)", $word, $total);    }  }  // Find words that were deleted from search_index, but are still in  // search_total. We use a LEFT JOIN between the two tables and keep only the  // rows which fail to join.  $result = db_query("SELECT t.word AS realword, i.word FROM {search_total} t LEFT JOIN {search_index} i ON t.word = i.word WHERE i.word IS NULL");  while ($word = db_fetch_object($result)) {    db_query("DELETE FROM {search_total} WHERE word = '%s'", $word->realword);  }}/** * Simplifies a string according to indexing rules. */function search_simplify($text) {  // Decode entities to UTF-8  $text = decode_entities($text);  // Lowercase  $text = drupal_strtolower($text);  // Call an external processor for word handling.  search_invoke_preprocess($text);  // Simple CJK handling  if (variable_get('overlap_cjk', TRUE)) {    $text = preg_replace_callback('/['. PREG_CLASS_CJK .']+/u', 'search_expand_cjk', $text);  }  // To improve searching for numerical data such as dates, IP addresses  // or version numbers, we consider a group of numerical characters  // separated only by punctuation characters to be one piece.  // This also means that searching for e.g. '20/03/1984' also returns  // results with '20-03-1984' in them.  // Readable regexp: ([number]+)[punctuation]+(?=[number])  $text = preg_replace('/(['. PREG_CLASS_NUMBERS .']+)['. PREG_CLASS_PUNCTUATION .']+(?=['. PREG_CLASS_NUMBERS .'])/u', '\1', $text);  // The dot, underscore and dash are simply removed. This allows meaningful  // search behavior with acronyms and URLs.  $text = preg_replace('/[._-]+/', '', $text);  // With the exception of the rules above, we consider all punctuation,  // marks, spacers, etc, to be a word boundary.  $text = preg_replace('/['. PREG_CLASS_SEARCH_EXCLUDE .']+/u', ' ', $text);  return $text;}/** * Basic CJK tokenizer. Simply splits a string into consecutive, overlapping * sequences of characters ('minimum_word_size' long). */function search_expand_cjk($matches) {  $min = variable_get('minimum_word_size', 3);  $str = $matches[0];  $l = drupal_strlen($str);  // Passthrough short words  if ($l <= $min) {    return ' '. $str .' ';  }  $tokens = ' ';  // FIFO queue of characters  $chars = array();  // Begin loop  for ($i = 0; $i < $l; ++$i) {    // Grab next character    $current = drupal_substr($str, 0, 1);    $str = substr($str, strlen($current));    $chars[] = $current;    if ($i >= $min - 1) {      $tokens .= implode('', $chars) .' ';      array_shift($chars);    }  }  return $tokens;}/** * Splits a string into tokens for indexing. */function search_index_split($text) {  static $last = NULL;  static $lastsplit = NULL;  if ($last == $text) {    return $lastsplit;  }  // Process words  $text = search_simplify($text);  $words = explode(' ', $text);  array_walk($words, '_search_index_truncate');  // Save last keyword result  $last = $text;  $lastsplit = $words;  return $words;}/** * Helper function for array_walk in search_index_split. */function _search_index_truncate(&$text) {  $text = truncate_utf8($text, 50);}/** * Invokes hook_search_preprocess() in modules. */function search_invoke_preprocess(&$text) {  foreach (module_implements('search_preprocess') as $module) {    $text = module_invoke($module, 'search_preprocess', $text);  }}/** * Update the full-text search index for a particular item. * * @param $sid *   A number identifying this particular item (e.g. node id). * * @param $type *   A string defining this type of item (e.g. 'node') * * @param $text *   The content of this item. Must be a piece of HTML text. * * @ingroup search */function search_index($sid, $type, $text) {  $minimum_word_size = variable_get('minimum_word_size', 3);  // Link matching  global $base_url;  $node_regexp = '@href=[\'"]?(?:'. preg_quote($base_url, '@') .'/|'. preg_quote(base_path(), '@') .')(?:\?q=)?/?((?![a-z]+:)[^\'">]+)[\'">]@i';  // Multipliers for scores of words inside certain HTML tags.  // Note: 'a' must be included for link ranking to work.  $tags = array('h1' => 25,                'h2' => 18,                'h3' => 15,                'h4' => 12,                'h5' => 9,                'h6' => 6,                'u' => 3,                'b' => 3,                'i' => 3,                'strong' => 3,                'em' => 3,                'a' => 10);  // Strip off all ignored tags to speed up processing, but insert space before/after  // them to keep word boundaries.  $text = str_replace(array('<', '>'), array(' <', '> '), $text);  $text = strip_tags($text, '<'. implode('><', array_keys($tags)) .'>');  // Split HTML tags from plain text.  $split = preg_split('/\s*<([^>]+?)>\s*/', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting $null as required).  $tag = FALSE; // Odd/even counter. Tag or no tag.  $link = FALSE; // State variable for link analyser  $score = 1; // Starting score per word  $accum = ' '; // Accumulator for cleaned up data  $tagstack = array(); // Stack with open tags  $tagwords = 0; // Counter for consecutive words  $focus = 1; // Focus state  $results = array(0 => array()); // Accumulator for words for index  foreach ($split as $value) {    if ($tag) {      // Increase or decrease score per word based on tag      list($tagname) = explode(' ', $value, 2);      $tagname = drupal_strtolower($tagname);      // Closing or opening tag?      if ($tagname[0] == '/') {        $tagname = substr($tagname, 1);        // If we encounter unexpected tags, reset score to avoid incorrect boosting.        if (!count($tagstack) || $tagstack[0] != $tagname) {          $tagstack = array();          $score = 1;        }        else {          // Remove from tag stack and decrement score          $score = max(1, $score - $tags[array_shift($tagstack)]);        }        if ($tagname == 'a') {          $link = FALSE;        }      }      else {        if (isset($tagstack[0]) && $tagstack[0] == $tagname) {          // None of the tags we look for make sense when nested identically.          // If they are, it's probably broken HTML.          $tagstack = array();          $score = 1;        }        else {          // Add to open tag stack and increment score          array_unshift($tagstack, $tagname);          $score += $tags[$tagname];        }        if ($tagname == 'a') {          // Check if link points to a node on this site          if (preg_match($node_regexp, $value, $match)) {            $path = drupal_get_normal_path($match[1]);            if (preg_match('!(?:node|book)/(?:view/)?([0-9]+)!i', $path, $match)) {              $linknid = $match[1];              if ($linknid > 0) {                // Note: ignore links to uncachable nodes to avoid redirect bugs.                $node = db_fetch_object(db_query('SELECT n.title, n.nid, n.vid, r.format FROM {node} n INNER JOIN {node_revisions} r ON n.vid = r.vid WHERE n.nid = %d', $linknid));                if (filter_format_allowcache($node->format)) {                  $link = TRUE;                  $linktitle = $node->title;                }              }            }          }        }      }      // A tag change occurred, reset counter.      $tagwords = 0;    }    else {      // Note: use of PREG_SPLIT_DELIM_CAPTURE above will introduce empty values      if ($value != '') {        if ($link) {          // Check to see if the node link text is its URL. If so, we use the target node title instead.          if (preg_match('!^https?://!i', $value)) {            $value = $linktitle;          }        }        $words = search_index_split($value);        foreach ($words as $word) {          // Add word to accumulator          $accum .= $word .' ';          $num = is_numeric($word);          // Check wordlength          if ($num || drupal_strlen($word) >= $minimum_word_size) {            // Normalize numbers            if ($num) {              $word = (int)ltrim($word, '-0');            }            // Links score mainly for the target.            if ($link) {              if (!isset($results[$linknid])) {                $results[$linknid] = array();              }              $results[$linknid][] = $word;              // Reduce score of the link caption in the source.              $focus *= 0.2;            }            // Fall-through            if (!isset($results[0][$word])) {              $results[0][$word] = 0;            }            $results[0][$word] += $score * $focus;            // Focus is a decaying value in terms of the amount of unique words up to this point.            // From 100 words and more, it decays, to e.g. 0.5 at 500 words and 0.3 at 1000 words.            $focus = min(1, .01 + 3.5 / (2 + count($results[0]) * .015));          }          $tagwords++;          // Too many words inside a single tag probably mean a tag was accidentally left open.          if (count($tagstack) && $tagwords >= 15) {            $tagstack = array();            $score = 1;          }        }      }    }    $tag = !$tag;  }  search_wipe($sid, $type, TRUE);  // Insert cleaned up data into dataset  db_query("INSERT INTO {search_dataset} (sid, type, data, reindex) VALUES (%d, '%s', '%s', %d)", $sid, $type, $accum, 0);  // Insert results into search index  foreach ($results[0] as $word => $score) {    // Try inserting first because this will succeed most times, but because    // the database collates similar words (accented and non-accented), the    // insert can fail, in which case we need to add the word scores together.    @db_query("INSERT INTO {search_index} (word, sid, type, score) VALUES ('%s', %d, '%s', %f)", $word, $sid, $type, $score);    if (!db_affected_rows()) {      db_query("UPDATE {search_index} SET score = score + %f WHERE word = '%s' AND sid = %d AND type = '%s'", $score, $word, $sid, $type);    }    search_dirty($word);  }  unset($results[0]);  // Get all previous links from this item.  $result = db_query("SELECT nid, caption FROM {search_node_links} WHERE sid = %d AND type = '%s'", $sid, $type);  $links = array();  while ($link = db_fetch_object($result)) {    $links[$link->nid] = $link->caption;  }  // Now store links to nodes.  foreach ($results as $nid => $words) {    $caption = implode(' ', $words);    if (isset($links[$nid])) {      if ($links[$nid] != $caption) {        // Update the existing link and mark the node for reindexing.        db_query("UPDATE {search_node_links} SET caption = '%s' WHERE sid = %d AND type = '%s' AND nid = %d", $caption, $sid, $type, $nid);        search_touch_node($nid);      }      // Unset the link to mark it as processed.      unset($links[$nid]);    }    else {      // Insert the existing link and mark the node for reindexing.      db_query("INSERT INTO {search_node_links} (caption, sid, type, nid) VALUES ('%s', %d, '%s', %d)", $caption, $sid, $type, $nid);      search_touch_node($nid);    }  }  // Any left-over links in $links no longer exist. Delete them and mark the nodes for reindexing.  foreach ($links as $nid => $caption) {    db_query("DELETE FROM {search_node_links} WHERE sid = %d AND type = '%s' AND nid = %d", $sid, $type, $nid);    search_touch_node($nid);  }}/** * Change a node's changed timestamp to 'now' to force reindexing. * * @param $nid *   The nid of the node that needs reindexing. */function search_touch_node($nid) {  db_query("UPDATE {search_dataset} SET reindex = %d WHERE sid = %d AND type = 'node'", time(), $nid);}/** * Implementation of hook_nodeapi(). */function search_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {  switch ($op) {    // Transplant links to a node into the target node.    case 'update index':      $result = db_query("SELECT caption FROM {search_node_links} WHERE nid = %d", $node->nid);      $output = array();      while ($link = db_fetch_object($result)) {        $output[] = $link->caption;      }      if (count($output)) {        return '<a>('. implode(', ', $output) .')</a>';      }      break;    // Reindex the node when it is updated.  The node is automatically indexed    // when it is added, simply by being added to the node table.    case 'update':      search_touch_node($node->nid);      break;  }}/** * Implementation of hook_comment(). */function search_comment($a1, $op) {  switch ($op) {    // Reindex the node when comments are added or changed    case 'insert':    case 'update':    case 'delete':    case 'publish':    case 'unpublish':      search_touch_node(is_array($a1) ? $a1['nid'] : $a1->nid);      break;  }}/** * Extract a module-specific search option from a search query. e.g. 'type:book' */function search_query_extract($keys, $option) {  if (preg_match('/(^| )'. $option .':([^ ]*)( |$)/i', $keys, $matches)) {    return $matches[2];  }}/** * Return a query with the given module-specific search option inserted in. * e.g. 'type:book'. */function search_query_insert($keys, $option, $value = '') {  if (search_query_extract($keys, $option)) {    $keys = trim(preg_replace('/(^| )'. $option .':[^ ]*/i', '', $keys));  }  if ($value != '') {    $keys .= ' '. $option .':'. $value;  }  return $keys;}/** * Parse a search query into SQL conditions. * * We build two queries that matches the dataset bodies. @See do_search for * more about these. * * @param $text *   The search keys. * @return *   A list of six elements. *    * A series of statements AND'd together which will be used to provide all *      possible matches. *    * Arguments for this query part. *    * A series of exact word matches OR'd together. *    * Arguments for this query part. *    * A bool indicating whether this is a simple query or not. Negative *      terms, presence of both AND / OR make this FALSE. *    * A bool indicating the presence of a lowercase or. Maybe the user *      wanted to use OR. */function search_parse_query($text) {  $keys = array('positive' => array(), 'negative' => array());  // Tokenize query string  preg_match_all('/ (-?)("[^"]+"|[^" ]+)/i', ' '. $text, $matches, PREG_SET_ORDER);  if (count($matches) < 1) {    return NULL;  }  // Classify tokens  $or = FALSE;  $warning = '';  $simple = TRUE;  foreach ($matches as $match) {    $phrase = FALSE;    // Strip off phrase quotes    if ($match[2]{0} == '"') {      $match[2] = substr($match[2], 1, -1);      $phrase = TRUE;      $simple = FALSE;    }    // Simplify keyword according to indexing rules and external preprocessors    $words = search_simplify($match[2]);    // Re-explode in case simplification added more words, except when matching a phrase    $words = $phrase ? array($words) : preg_split('/ /', $words, -1, PREG_SPLIT_NO_EMPTY);    // Negative matches    if ($match[1] == '-') {      $keys['negative'] = array_merge($keys['negative'], $words);    }    // OR operator: instead of a single keyword, we store an array of all    // OR'd keywords.    elseif ($match[2] == 'OR' && count($keys['positive'])) {      $last = array_pop($keys['positive']);      // Starting a new OR?      if (!is_array($last)) {        $last = array($last);      }      $keys['positive'][] = $last;      $or = TRUE;      continue;    }    // AND operator: implied, so just ignore it    elseif ($match[2] == 'AND' || $match[2] == 'and') {      $warning = $match[2];      continue;    }    // Plain keyword    else {      if ($match[2] == 'or') {        $warning = $match[2];      }      if ($or) {        // Add to last element (which is an array)        $keys['positive'][count($keys['positive']) - 1] = array_merge($keys['positive'][count($keys['positive']) - 1], $words);      }      else {        $keys['positive'] = array_merge($keys['positive'], $words);      }    }    $or = FALSE;  }  // Convert keywords into SQL statements.  $query = array();  $query2 = array();  $arguments = array();  $arguments2 = array();  $matches = 0;  $simple_and = FALSE;  $simple_or = FALSE;  // Positive matches  foreach ($keys['positive'] as $key) {    // Group of ORed terms    if (is_array($key) && count($key)) {      $simple_or = TRUE;      $queryor = array();      $any = FALSE;      foreach ($key as $or) {        list($q, $num_new_scores) = _search_parse_query($or, $arguments2);        $any |= $num_new_scores;        if ($q) {          $queryor[] = $q;          $arguments[] = $or;        }      }      if (count($queryor)) {        $query[] = '('. implode(' OR ', $queryor) .')';        // A group of OR keywords only needs to match once        $matches += ($any > 0);      }    }    // Single ANDed term    else {      $simple_and = TRUE;      list($q, $num_new_scores, $num_valid_words) = _search_parse_query($key, $arguments2);      if ($q) {        $query[] = $q;        $arguments[] = $key;        if (!$num_valid_words) {          $simple = FALSE;        }        // Each AND keyword needs to match at least once        $matches += $num_new_scores;      }    }  }  if ($simple_and && $simple_or) {    $simple = FALSE;  }  // Negative matches  foreach ($keys['negative'] as $key) {    list($q) = _search_parse_query($key, $arguments2, TRUE);    if ($q) {      $query[] = $q;      $arguments[] = $key;      $simple = FALSE;    }  }  $query = implode(' AND ', $query);  // Build word-index conditions for the first pass  $query2 = substr(str_repeat("i.word = '%s' OR ", count($arguments2)), 0, -4);  return array($query, $arguments, $query2, $arguments2, $matches, $simple, $warning);}/** * Helper function for search_parse_query(); */function _search_parse_query(&$word, &$scores, $not = FALSE) {  $num_new_scores = 0;  $num_valid_words = 0;  // Determine the scorewords of this word/phrase  if (!$not) {    $split = explode(' ', $word);    foreach ($split as $s) {      $num = is_numeric($s);      if ($num || drupal_strlen($s) >= variable_get('minimum_word_size', 3)) {        $s = $num ? ((int)ltrim($s, '-0')) : $s;        if (!isset($scores[$s])) {          $scores[$s] = $s;          $num_new_scores++;        }        $num_valid_words++;      }    }  }  // Return matching snippet and number of added words  return array("d.data ". ($not ? 'NOT ' : '') ."LIKE '%% %s %%'", $num_new_scores, $num_valid_words);}/** * Do a query on the full-text search index for a word or words. * * This function is normally only called by each module that support the * indexed search (and thus, implements hook_update_index()). * * Results are retrieved in two logical passes. However, the two passes are * joined together into a single query.  And in the case of most simple * queries the second pass is not even used. * * The first pass selects a set of all possible matches, which has the benefit * of also providing the exact result set for simple "AND" or "OR" searches. * * The second portion of the query further refines this set by verifying * advanced text conditions (such negative or phrase matches) * * @param $keywords *   A search string as entered by the user. * * @param $type *   A string identifying the calling module. * * @param $join1 *   (optional) Inserted into the JOIN part of the first SQL query. *   For example "INNER JOIN {node} n ON n.nid = i.sid". * * @param $where1 *   (optional) Inserted into the WHERE part of the first SQL query. *   For example "(n.status > %d)". * * @param $arguments1 *   (optional) Extra SQL arguments belonging to the first query. * * @param $columns2 *   (optional) Inserted into the SELECT pat of the second query. Must contain *   a column selected as 'score'. *   defaults to 'i.relevance AS score' * * @param $join2 *   (optional) Inserted into the JOIN par of the second SQL query. *   For example "INNER JOIN {node_comment_statistics} n ON n.nid = i.sid" * * @param $arguments2 *   (optional) Extra SQL arguments belonging to the second query parameter. * * @param $sort_parameters *   (optional) SQL arguments for sorting the final results. *              Default: 'ORDER BY score DESC' * * @return *   An array of SIDs for the search results. * * @ingroup search */function do_search($keywords, $type, $join1 = '', $where1 = '1 = 1', $arguments1 = array(), $columns2 = 'i.relevance AS score', $join2 = '', $arguments2 = array(), $sort_parameters = 'ORDER BY score DESC') {  $query = search_parse_query($keywords);  if ($query[2] == '') {    form_set_error('keys', t('You must include at least one positive keyword with @count characters or more.', array('@count' => variable_get('minimum_word_size', 3))));  }  if ($query[6]) {    if ($query[6] == 'or') {      drupal_set_message(t('Search for either of the two terms with uppercase <strong>OR</strong>. For example, <strong>cats OR dogs</strong>.'));    }  }  if ($query === NULL || $query[0] == '' || $query[2] == '') {    return array();  }  // Build query for keyword normalization.  $conditions = "$where1 AND ($query[2]) AND i.type = '%s'";  $arguments1 = array_merge($arguments1, $query[3], array($type));  $join = "INNER JOIN {search_total} t ON i.word = t.word $join1";  if (!$query[5]) {    $conditions .= " AND ($query[0])";    $arguments1 = array_merge($arguments1, $query[1]);    $join .= " INNER JOIN {search_dataset} d ON i.sid = d.sid AND i.type = d.type";  }  // Calculate maximum keyword relevance, to normalize it.  $select = "SELECT SUM(i.score * t.count) AS score FROM {search_index} i $join WHERE $conditions GROUP BY i.type, i.sid HAVING COUNT(*) >= %d ORDER BY score DESC";  $arguments = array_merge($arguments1, array($query[4]));  $normalize = db_result(db_query_range($select, $arguments, 0, 1));  if (!$normalize) {    return array();  }  $columns2 = str_replace('i.relevance', '('. (1.0 / $normalize) .' * SUM(i.score * t.count))', $columns2);  // Build query to retrieve results.  $select = "SELECT i.type, i.sid, $columns2 FROM {search_index} i $join $join2 WHERE $conditions GROUP BY i.type, i.sid HAVING COUNT(*) >= %d";  $count_select =  "SELECT COUNT(*) FROM ($select) n1";  $arguments = array_merge($arguments2, $arguments1, array($query[4]));  // Do actual search query  $result = pager_query("$select $sort_parameters", 10, 0, $count_select, $arguments);  $results = array();  while ($item = db_fetch_object($result)) {    $results[] = $item;  }  return $results;}/** * Helper function for grabbing search keys. */function search_get_keys() {  static $return;  if (!isset($return)) {    // Extract keys as remainder of path    // Note: support old GET format of searches for existing links.    $path = explode('/', $_GET['q'], 3);    $keys = empty($_REQUEST['keys']) ? '' : $_REQUEST['keys'];    $return = count($path) == 3 ? $path[2] : $keys;  }  return $return;}/** * @defgroup search Search interface * @{ * The Drupal search interface manages a global search mechanism. * * Modules may plug into this system to provide searches of different types of * data. Most of the system is handled by search.module, so this must be enabled * for all of the search features to work. * * There are three ways to interact with the search system: * - Specifically for searching nodes, you can implement nodeapi('update index') *   and nodeapi('search result'). However, note that the search system already *   indexes all visible output of a node, i.e. everything displayed normally *   by hook_view() and hook_nodeapi('view'). This is usually sufficient. *   You should only use this mechanism if you want additional, non-visible data *   to be indexed. * - Implement hook_search(). This will create a search tab for your module on *   the /search page with a simple keyword search form. You may optionally *   implement hook_search_item() to customize the display of your results. * - Implement hook_update_index(). This allows your module to use Drupal's *   HTML indexing mechanism for searching full text efficiently. * * If your module needs to provide a more complicated search form, then you need * to implement it yourself without hook_search(). In that case, you should * define it as a local task (tab) under the /search page (e.g. /search/mymodule) * so that users can easily find it. *//** * Render a search form. * * @param $action *   Form action. Defaults to "search". * @param $keys *   The search string entered by the user, containing keywords for the search. * @param $type *   The type of search to render the node for. Must be the name of module *   which implements hook_search(). Defaults to 'node'. * @param $prompt *   A piece of text to put before the form (e.g. "Enter your keywords") * @return *   An HTML string containing the search form. */function search_form(&$form_state, $action = '', $keys = '', $type = NULL, $prompt = NULL) {  // Add CSS  drupal_add_css(drupal_get_path('module', 'search') .'/search.css', 'module', 'all', FALSE);  if (!$action) {    $action = url('search/'. $type);  }  if (is_null($prompt)) {    $prompt = t('Enter your keywords');  }  $form = array(    '#action' => $action,    '#attributes' => array('class' => 'search-form'),  );  $form['module'] = array('#type' => 'value', '#value' => $type);  $form['basic'] = array('#type' => 'item', '#title' => $prompt);  $form['basic']['inline'] = array('#prefix' => '<div class="container-inline">', '#suffix' => '</div>');  $form['basic']['inline']['keys'] = array(    '#type' => 'textfield',    '#title' => '',    '#default_value' => $keys,    '#size' => $prompt ? 40 : 20,    '#maxlength' => 255,  );  // processed_keys is used to coordinate keyword passing between other forms  // that hook into the basic search form.  $form['basic']['inline']['processed_keys'] = array('#type' => 'value', '#value' => array());  $form['basic']['inline']['submit'] = array('#type' => 'submit', '#value' => t('Search'));  return $form;}/** * Form builder; Output a search form for the search block and the theme's search box. * * @ingroup forms * @see search_box_form_submit() * @see theme_search_box_form() */function search_box(&$form_state, $form_id) {  $form[$form_id] = array(    '#title' => t('Search this site'),    '#type' => 'textfield',    '#size' => 15,    '#default_value' => '',    '#attributes' => array('title' => t('Enter the terms you wish to search for.')),  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Search'));  $form['#submit'][] = 'search_box_form_submit';  return $form;}/** * Process a block search form submission. */function search_box_form_submit($form, &$form_state) {  // The search form relies on control of the redirect destination for its  // functionality, so we override any static destination set in the request,  // for example by drupal_access_denied() or drupal_not_found()  // (see http://drupal.org/node/292565).  if (isset($_REQUEST['destination'])) {    unset($_REQUEST['destination']);  }  if (isset($_REQUEST['edit']['destination'])) {    unset($_REQUEST['edit']['destination']);  }  $form_id = $form['form_id']['#value'];  $form_state['redirect'] = 'search/node/'. trim($form_state['values'][$form_id]);}/** * Process variables for search-theme-form.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see search-theme-form.tpl.php */function template_preprocess_search_theme_form(&$variables) {  $variables['search'] = array();  $hidden = array();  // Provide variables named after form keys so themers can print each element independently.  foreach (element_children($variables['form']) as $key) {    $type = $variables['form'][$key]['#type'];    if ($type == 'hidden' || $type == 'token') {      $hidden[] = drupal_render($variables['form'][$key]);    }    else {      $variables['search'][$key] = drupal_render($variables['form'][$key]);    }  }  // Hidden form elements have no value to themers. No need for separation.  $variables['search']['hidden'] = implode($hidden);  // Collect all form elements to make it easier to print the whole form.  $variables['search_form'] = implode($variables['search']);}/** * Process variables for search-block-form.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see search-block-form.tpl.php */function template_preprocess_search_block_form(&$variables) {  $variables['search'] = array();  $hidden = array();  // Provide variables named after form keys so themers can print each element independently.  foreach (element_children($variables['form']) as $key) {    $type = $variables['form'][$key]['#type'];    if ($type == 'hidden' || $type == 'token') {      $hidden[] = drupal_render($variables['form'][$key]);    }    else {      $variables['search'][$key] = drupal_render($variables['form'][$key]);    }  }  // Hidden form elements have no value to themers. No need for separation.  $variables['search']['hidden'] = implode($hidden);  // Collect all form elements to make it easier to print the whole form.  $variables['search_form'] = implode($variables['search']);}/** * Perform a standard search on the given keys, and return the formatted results. */function search_data($keys = NULL, $type = 'node') {  if (isset($keys)) {    if (module_hook($type, 'search')) {      $results = module_invoke($type, 'search', 'search', $keys);      if (isset($results) && is_array($results) && count($results)) {        if (module_hook($type, 'search_page')) {          return module_invoke($type, 'search_page', $results);        }        else {          return theme('search_results', $results, $type);        }      }    }  }}/** * Returns snippets from a piece of text, with certain keywords highlighted. * Used for formatting search results. * * @param $keys *   A string containing a search query. * * @param $text *   The text to extract fragments from. * * @return *   A string containing HTML for the excerpt. */function search_excerpt($keys, $text) {  // We highlight around non-indexable or CJK characters.  $boundary = '(?:(?<=['. PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK .'])|(?=['. PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK .']))';  // Extract positive keywords and phrases  preg_match_all('/ ("([^"]+)"|(?!OR)([^" ]+))/', ' '. $keys, $matches);  $keys = array_merge($matches[2], $matches[3]);  // Prepare text  $text = ' '. strip_tags(str_replace(array('<', '>'), array(' <', '> '), $text)) .' ';  array_walk($keys, '_search_excerpt_replace');  $workkeys = $keys;  // Extract a fragment per keyword for at most 4 keywords.  // First we collect ranges of text around each keyword, starting/ending  // at spaces.  // If the sum of all fragments is too short, we look for second occurrences.  $ranges = array();  $included = array();  $length = 0;  while ($length < 256 && count($workkeys)) {    foreach ($workkeys as $k => $key) {      if (strlen($key) == 0) {        unset($workkeys[$k]);        unset($keys[$k]);        continue;      }      if ($length >= 256) {        break;      }      // Remember occurrence of key so we can skip over it if more occurrences      // are desired.      if (!isset($included[$key])) {        $included[$key] = 0;      }      // Locate a keyword (position $p), then locate a space in front (position      // $q) and behind it (position $s)      if (preg_match('/'. $boundary . $key . $boundary .'/iu', $text, $match, PREG_OFFSET_CAPTURE, $included[$key])) {        $p = $match[0][1];        if (($q = strpos($text, ' ', max(0, $p - 60))) !== FALSE) {          $end = substr($text, $p, 80);          if (($s = strrpos($end, ' ')) !== FALSE) {            $ranges[$q] = $p + $s;            $length += $p + $s - $q;            $included[$key] = $p + 1;          }          else {            unset($workkeys[$k]);          }        }        else {          unset($workkeys[$k]);        }      }      else {        unset($workkeys[$k]);      }    }  }  // If we didn't find anything, return the beginning.  if (count($ranges) == 0) {    return truncate_utf8($text, 256) .' ...';  }  // Sort the text ranges by starting position.  ksort($ranges);  // Now we collapse overlapping text ranges into one. The sorting makes it O(n).  $newranges = array();  foreach ($ranges as $from2 => $to2) {    if (!isset($from1)) {      $from1 = $from2;      $to1 = $to2;      continue;    }    if ($from2 <= $to1) {      $to1 = max($to1, $to2);    }    else {      $newranges[$from1] = $to1;      $from1 = $from2;      $to1 = $to2;    }  }  $newranges[$from1] = $to1;  // Fetch text  $out = array();  foreach ($newranges as $from => $to) {    $out[] = substr($text, $from, $to - $from);  }  $text = (isset($newranges[0]) ? '' : '... ') . implode(' ... ', $out) .' ...';  // Highlight keywords. Must be done at once to prevent conflicts ('strong' and '<strong>').  $text = preg_replace('/'. $boundary .'('. implode('|', $keys) .')'. $boundary .'/iu', '<strong>\0</strong>', $text);  return $text;}/** * @} End of "defgroup search". *//** * Helper function for array_walk in search_except. */function _search_excerpt_replace(&$text) {  $text = preg_quote($text, '/');}function search_forms() {  $forms['search_theme_form']= array(    'callback' => 'search_box',    'callback arguments' => array('search_theme_form'),  );  $forms['search_block_form']= array(    'callback' => 'search_box',    'callback arguments' => array('search_block_form'),  );  return $forms;}
<?php// $Id$/** * @defgroup forms Form builder functions * @{ * Functions that build an abstract representation of a HTML form. * * All modules should declare their form builder functions to be in this * group and each builder function should reference its validate and submit * functions using \@see. Conversely, validate and submit functions should * reference the form builder function using \@see. For examples, of this see * system_modules_uninstall() or user_pass(), the latter of which has the * following in its doxygen documentation: * * \@ingroup forms * \@see user_pass_validate(). * \@see user_pass_submit(). * * @} End of "defgroup forms". *//** * @defgroup form_api Form generation * @{ * Functions to enable the processing and display of HTML forms. * * Drupal uses these functions to achieve consistency in its form processing and * presentation, while simplifying code and reducing the amount of HTML that * must be explicitly generated by modules. * * The drupal_get_form() function handles retrieving, processing, and * displaying a rendered HTML form for modules automatically. For example: * * @code * // Display the user registration form. * $output = drupal_get_form('user_register'); * @endcode * * Forms can also be built and submitted programmatically without any user input * using the drupal_execute() function. * * For information on the format of the structured arrays used to define forms, * and more detailed explanations of the Form API workflow, see the * @link http://api.drupal.org/api/file/developer/topics/forms_api_reference.html reference @endlink * and the @link http://api.drupal.org/api/file/developer/topics/forms_api.html quickstart guide. @endlink *//** * Retrieves a form from a constructor function, or from the cache if * the form was built in a previous page-load. The form is then passed * on for processing, after and rendered for display if necessary. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param ... *   Any additional arguments are passed on to the functions called by *   drupal_get_form(), including the unique form constructor function. *   For example, the node_edit form requires that a node object be passed *   in here when it is called. * @return *   The rendered form. */function drupal_get_form($form_id) {  $form_state = array('storage' => NULL, 'submitted' => FALSE);  $args = func_get_args();  $cacheable = FALSE;  if (isset($_SESSION['batch_form_state'])) {    // We've been redirected here after a batch processing : the form has    // already been processed, so we grab the post-process $form_state value    // and move on to form display. See _batch_finished() function.    $form_state = $_SESSION['batch_form_state'];    unset($_SESSION['batch_form_state']);  }  else {    // If the incoming $_POST contains a form_build_id, we'll check the    // cache for a copy of the form in question. If it's there, we don't    // have to rebuild the form to proceed. In addition, if there is stored    // form_state data from a previous step, we'll retrieve it so it can    // be passed on to the form processing code.    if (isset($_POST['form_id']) && $_POST['form_id'] == $form_id && !empty($_POST['form_build_id'])) {      $form = form_get_cache($_POST['form_build_id'], $form_state);    }    // If the previous bit of code didn't result in a populated $form    // object, we're hitting the form for the first time and we need    // to build it from scratch.    if (!isset($form)) {      $form_state['post'] = $_POST;      // Use a copy of the function's arguments for manipulation      $args_temp = $args;      $args_temp[0] = &$form_state;      array_unshift($args_temp, $form_id);      $form = call_user_func_array('drupal_retrieve_form', $args_temp);      $form_build_id = 'form-'. md5(uniqid(mt_rand(), true));      $form['#build_id'] = $form_build_id;      drupal_prepare_form($form_id, $form, $form_state);      // Store a copy of the unprocessed form for caching and indicate that it      // is cacheable if #cache will be set.      $original_form = $form;      $cacheable = TRUE;      unset($form_state['post']);    }    $form['#post'] = $_POST;    // Now that we know we have a form, we'll process it (validating,    // submitting, and handling the results returned by its submission    // handlers. Submit handlers accumulate data in the form_state by    // altering the $form_state variable, which is passed into them by    // reference.    drupal_process_form($form_id, $form, $form_state);    if ($cacheable && !empty($form['#cache'])) {      // Caching is done past drupal_process_form so #process callbacks can      // set #cache.      form_set_cache($form_build_id, $original_form, $form_state);    }  }  // Most simple, single-step forms will be finished by this point --  // drupal_process_form() usually redirects to another page (or to  // a 'fresh' copy of the form) once processing is complete. If one  // of the form's handlers has set $form_state['redirect'] to FALSE,  // the form will simply be re-rendered with the values still in its  // fields.  //  // If $form_state['storage'] or $form_state['rebuild'] has been set  // and input has been processed, we know that we're in a complex  // multi-part process of some sort and the form's workflow is NOT  // complete. We need to construct a fresh copy of the form, passing  // in the latest $form_state in addition to any other variables passed  // into drupal_get_form().  if ((!empty($form_state['storage']) || !empty($form_state['rebuild'])) && !empty($form_state['process_input']) && !form_get_errors()) {    $form = drupal_rebuild_form($form_id, $form_state, $args);  }  // If we haven't redirected to a new location by now, we want to  // render whatever form array is currently in hand.  return drupal_render_form($form_id, $form);}/** * Retrieves a form, caches it and processes it with an empty $_POST. * * This function clears $_POST and passes the empty $_POST to the form_builder. * To preserve some parts from $_POST, pass them in $form_state. * * If your AHAH callback simulates the pressing of a button, then your AHAH * callback will need to do the same as what drupal_get_form would do when the * button is pressed: get the form from the cache, run drupal_process_form over * it and then if it needs rebuild, run drupal_rebuild_form over it. Then send * back a part of the returned form. * $form_state['clicked_button']['#array_parents'] will help you to find which * part. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param $form_state *   A keyed array containing the current state of the form. Most *   important is the $form_state['storage'] collection. * @param $args *   Any additional arguments are passed on to the functions called by *   drupal_get_form(), plus the original form_state in the beginning. If you *   are getting a form from the cache, use $form['#parameters'] to shift off *   the $form_id from its beginning then the resulting array can be used as *   $arg here. * @param $form_build_id *   If the AHAH callback calling this function only alters part of the form, *   then pass in the existing form_build_id so we can re-cache with the same *   csid. * @return *   The newly built form. */function drupal_rebuild_form($form_id, &$form_state, $args, $form_build_id = NULL) {  // Remove the first argument. This is $form_id.when called from  // drupal_get_form and the original $form_state when called from some AHAH  // callback. Neither is needed. After that, put in the current state.  $args[0] = &$form_state;  // And the form_id.  array_unshift($args, $form_id);  $form = call_user_func_array('drupal_retrieve_form', $args);  if (!isset($form_build_id)) {    // We need a new build_id for the new version of the form.    $form_build_id = 'form-'. md5(mt_rand());  }  $form['#build_id'] = $form_build_id;  drupal_prepare_form($form_id, $form, $form_state);  // Now, we cache the form structure so it can be retrieved later for  // validation. If $form_state['storage'] is populated, we'll also cache  // it so that it can be used to resume complex multi-step processes.  form_set_cache($form_build_id, $form, $form_state);  // Clear out all post data, as we don't want the previous step's  // data to pollute this one and trigger validate/submit handling,  // then process the form for rendering.  $_POST = array();  $form['#post'] = array();  drupal_process_form($form_id, $form, $form_state);  return $form;}/** * Store a form in the cache. */function form_set_cache($form_build_id, $form, $form_state) {  global $user;  // 6 hours cache life time for forms should be plenty.  $expire = 21600;  if ($user->uid) {    $form['#cache_token'] = drupal_get_token();  }  cache_set('form_'. $form_build_id, $form, 'cache_form', time() + $expire);  if (!empty($form_state['storage'])) {    cache_set('storage_'. $form_build_id, $form_state['storage'], 'cache_form', time() + $expire);  }}/** * Fetch a form from cache. */function form_get_cache($form_build_id, &$form_state) {  global $user;  if ($cached = cache_get('form_'. $form_build_id, 'cache_form')) {    $form = $cached->data;    if ((isset($form['#cache_token']) && drupal_valid_token($form['#cache_token'])) || (!isset($form['#cache_token']) && !$user->uid)) {      if ($cached = cache_get('storage_'. $form_build_id, 'cache_form')) {        $form_state['storage'] = $cached->data;      }      return $form;    }  }}/** * Retrieves a form using a form_id, populates it with $form_state['values'], * processes it, and returns any validation errors encountered. This * function is the programmatic counterpart to drupal_get_form(). * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param $form_state *   A keyed array containing the current state of the form. Most *   important is the $form_state['values'] collection, a tree of data *   used to simulate the incoming $_POST information from a user's *   form submission. * @param ... *   Any additional arguments are passed on to the functions called by *   drupal_execute(), including the unique form constructor function. *   For example, the node_edit form requires that a node object be passed *   in here when it is called. * For example: * * @code * // register a new user * $form_state = array(); * $form_state['values']['name'] = 'robo-user'; * $form_state['values']['mail'] = 'robouser@example.com'; * $form_state['values']['pass']['pass1'] = 'password'; * $form_state['values']['pass']['pass2'] = 'password'; * $form_state['values']['op'] = t('Create new account'); * drupal_execute('user_register', $form_state); * * // Create a new node * $form_state = array(); * module_load_include('inc', 'node', 'node.pages'); * $node = array('type' => 'story'); * $form_state['values']['title'] = 'My node'; * $form_state['values']['body'] = 'This is the body text!'; * $form_state['values']['name'] = 'robo-user'; * $form_state['values']['op'] = t('Save'); * drupal_execute('story_node_form', $form_state, (object)$node); * @endcode */function drupal_execute($form_id, &$form_state) {  $args = func_get_args();  // Make sure $form_state is passed around by reference.  $args[1] = &$form_state;    $form = call_user_func_array('drupal_retrieve_form', $args);  $form['#post'] = $form_state['values'];  drupal_prepare_form($form_id, $form, $form_state);  drupal_process_form($form_id, $form, $form_state);}/** * Retrieves the structured array that defines a given form. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. * @param $form_state *   A keyed array containing the current state of the form. * @param ... *   Any additional arguments needed by the unique form constructor *   function. Generally, these are any arguments passed into the *   drupal_get_form() or drupal_execute() functions after the first *   argument. If a module implements hook_forms(), it can examine *   these additional arguments and conditionally return different *   builder functions as well. */function drupal_retrieve_form($form_id, &$form_state) {  static $forms;  // We save two copies of the incoming arguments: one for modules to use  // when mapping form ids to constructor functions, and another to pass to  // the constructor function itself. We shift out the first argument -- the  // $form_id itself -- from the list to pass into the constructor function,  // since it's already known.  $args = func_get_args();  $saved_args = $args;  array_shift($args);  if (isset($form_state)) {    array_shift($args);  }  // We first check to see if there's a function named after the $form_id.  // If there is, we simply pass the arguments on to it to get the form.  if (!function_exists($form_id)) {    // In cases where many form_ids need to share a central constructor function,    // such as the node editing form, modules can implement hook_forms(). It    // maps one or more form_ids to the correct constructor functions.    //    // We cache the results of that hook to save time, but that only works    // for modules that know all their form_ids in advance. (A module that    // adds a small 'rate this comment' form to each comment in a list    // would need a unique form_id for each one, for example.)    //    // So, we call the hook if $forms isn't yet populated, OR if it doesn't    // yet have an entry for the requested form_id.    if (!isset($forms) || !isset($forms[$form_id])) {      $forms = module_invoke_all('forms', $form_id, $args);    }    $form_definition = $forms[$form_id];    if (isset($form_definition['callback arguments'])) {      $args = array_merge($form_definition['callback arguments'], $args);    }    if (isset($form_definition['callback'])) {      $callback = $form_definition['callback'];    }  }  array_unshift($args, NULL);  $args[0] = &$form_state;  // If $callback was returned by a hook_forms() implementation, call it.  // Otherwise, call the function named after the form id.  $form = call_user_func_array(isset($callback) ? $callback : $form_id, $args);  // We store the original function arguments, rather than the final $arg  // value, so that form_alter functions can see what was originally  // passed to drupal_retrieve_form(). This allows the contents of #parameters  // to be saved and passed in at a later date to recreate the form.  $form['#parameters'] = $saved_args;  return $form;}/** * This function is the heart of form API. The form gets built, validated and in * appropriate cases, submitted. * * @param $form_id *   The unique string identifying the current form. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. This *   includes the current persistent storage data for the form, and *   any data passed along by earlier steps when displaying a *   multi-step form. Additional information, like the sanitized $_POST *   data, is also accumulated here. */function drupal_process_form($form_id, &$form, &$form_state) {  $form_state['values'] = array();  $form = form_builder($form_id, $form, $form_state);  // Only process the form if it is programmed or the form_id coming  // from the POST data is set and matches the current form_id.  if ((!empty($form['#programmed'])) || (!empty($form['#post']) && (isset($form['#post']['form_id']) && ($form['#post']['form_id'] == $form_id)))) {    $form_state['process_input'] = TRUE;    drupal_validate_form($form_id, $form, $form_state);    // form_clean_id() maintains a cache of element IDs it has seen,    // so it can prevent duplicates. We want to be sure we reset that    // cache when a form is processed, so scenerios that result in    // the form being built behind the scenes and again for the    // browser don't increment all the element IDs needlessly.    form_clean_id(NULL, TRUE);    if ((!empty($form_state['submitted'])) && !form_get_errors() && empty($form_state['rebuild'])) {      $form_state['redirect'] = NULL;      form_execute_handlers('submit', $form, $form_state);      // We'll clear out the cached copies of the form and its stored data      // here, as we've finished with them. The in-memory copies are still      // here, though.      if (variable_get('cache', CACHE_DISABLED) == CACHE_DISABLED && !empty($form_state['values']['form_build_id'])) {        cache_clear_all('form_'. $form_state['values']['form_build_id'], 'cache_form');        cache_clear_all('storage_'. $form_state['values']['form_build_id'], 'cache_form');      }      // If batches were set in the submit handlers, we process them now,      // possibly ending execution. We make sure we do not react to the batch      // that is already being processed (if a batch operation performs a      // drupal_execute).      if ($batch =& batch_get() && !isset($batch['current_set'])) {        // The batch uses its own copies of $form and $form_state for        // late execution of submit handers and post-batch redirection.        $batch['form'] = $form;        $batch['form_state'] = $form_state;        $batch['progressive'] = !$form['#programmed'];        batch_process();        // Execution continues only for programmatic forms.        // For 'regular' forms, we get redirected to the batch processing        // page. Form redirection will be handled in _batch_finished(),        // after the batch is processed.      }      // If no submit handlers have populated the $form_state['storage']      // bundle, and the $form_state['rebuild'] flag has not been set,      // we're finished and should redirect to a new destination page      // if one has been set (and a fresh, unpopulated copy of the form      // if one hasn't). If the form was called by drupal_execute(),      // however, we'll skip this and let the calling function examine      // the resulting $form_state bundle itself.      if (!$form['#programmed'] && empty($form_state['rebuild']) && empty($form_state['storage'])) {        drupal_redirect_form($form, $form_state['redirect']);      }    }  }}/** * Prepares a structured form array by adding required elements, * executing any hook_form_alter functions, and optionally inserting * a validation token to prevent tampering. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. Passed *   in here so that hook_form_alter() calls can use it, as well. */function drupal_prepare_form($form_id, &$form, &$form_state) {  global $user;  $form['#type'] = 'form';  $form['#programmed'] = isset($form['#post']);  if (isset($form['#build_id'])) {    $form['form_build_id'] = array(      '#type' => 'hidden',      '#value' => $form['#build_id'],      '#id' => $form['#build_id'],      '#name' => 'form_build_id',    );  }  // Add a token, based on either #token or form_id, to any form displayed to  // authenticated users. This ensures that any submitted form was actually  // requested previously by the user and protects against cross site request  // forgeries.  if (isset($form['#token'])) {    if ($form['#token'] === FALSE || $user->uid == 0 || $form['#programmed']) {      unset($form['#token']);    }    else {      $form['form_token'] = array('#type' => 'token', '#default_value' => drupal_get_token($form['#token']));    }  }  else if (isset($user->uid) && $user->uid && !$form['#programmed']) {    $form['#token'] = $form_id;    $form['form_token'] = array(      '#id' => form_clean_id('edit-'. $form_id .'-form-token'),      '#type' => 'token',      '#default_value' => drupal_get_token($form['#token']),    );  }  if (isset($form_id)) {    $form['form_id'] = array(      '#type' => 'hidden',      '#value' => $form_id,      '#id' => form_clean_id("edit-$form_id"),    );  }  if (!isset($form['#id'])) {    $form['#id'] = form_clean_id($form_id);  }  $form += _element_info('form');  if (!isset($form['#validate'])) {    if (function_exists($form_id .'_validate')) {      $form['#validate'] = array($form_id .'_validate');    }  }  if (!isset($form['#submit'])) {    if (function_exists($form_id .'_submit')) {      // We set submit here so that it can be altered.      $form['#submit'] = array($form_id .'_submit');    }  }  // Normally, we would call drupal_alter($form_id, $form, $form_state).  // However, drupal_alter() normally supports just one byref parameter. Using  // the __drupal_alter_by_ref key, we can store any additional parameters  // that need to be altered, and they'll be split out into additional params  // for the hook_form_alter() implementations.  // @todo: Remove this in Drupal 7.  $data = &$form;  $data['__drupal_alter_by_ref'] = array(&$form_state);  drupal_alter('form_'. $form_id, $data);  // __drupal_alter_by_ref is unset in the drupal_alter() function, we need  // to repopulate it to ensure both calls get the data.  $data['__drupal_alter_by_ref'] = array(&$form_state);  drupal_alter('form', $data, $form_id);}/** * Validates user-submitted form data from the $form_state using * the validate functions defined in a structured form array. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. The current *   user-submitted data is stored in $form_state['values'], though *   form validation functions are passed an explicit copy of the *   values for the sake of simplicity. Validation handlers can also *   $form_state to pass information on to submit handlers. For example: *     $form_state['data_for_submision'] = $data; *   This technique is useful when validation requires file parsing, *   web service requests, or other expensive requests that should *   not be repeated in the submission step. */function drupal_validate_form($form_id, $form, &$form_state) {  static $validated_forms = array();  if (isset($validated_forms[$form_id])) {    return;  }  // If the session token was set by drupal_prepare_form(), ensure that it  // matches the current user's session.  if (isset($form['#token'])) {    if (!drupal_valid_token($form_state['values']['form_token'], $form['#token'])) {      // Setting this error will cause the form to fail validation.      form_set_error('form_token', t('Validation error, please try again. If this error persists, please contact the site administrator.'));    }  }  _form_validate($form, $form_state, $form_id);  $validated_forms[$form_id] = TRUE;}/** * Renders a structured form array into themed HTML. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @return *   A string containing the themed HTML. */function drupal_render_form($form_id, &$form) {  // Don't override #theme if someone already set it.  if (!isset($form['#theme'])) {    init_theme();    $registry = theme_get_registry();    if (isset($registry[$form_id])) {      $form['#theme'] = $form_id;    }  }  $output = drupal_render($form);  return $output;}/** * Redirect the user to a URL after a form has been processed. * * @param $form *   An associative array containing the structure of the form. * @param $redirect *   An optional value containing the destination path to redirect *   to if none is specified by the form. */function drupal_redirect_form($form, $redirect = NULL) {  $goto = NULL;  if (isset($redirect)) {    $goto = $redirect;  }  if ($goto !== FALSE && isset($form['#redirect'])) {    $goto = $form['#redirect'];  }  if (!isset($goto) || ($goto !== FALSE)) {    if (isset($goto)) {      if (is_array($goto)) {        call_user_func_array('drupal_goto', $goto);      }      else {        drupal_goto($goto);      }    }    drupal_goto($_GET['q']);  }}/** * Performs validation on form elements. First ensures required fields are * completed, #maxlength is not exceeded, and selected options were in the * list of options given to the user. Then calls user-defined validators. * * @param $elements *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. The current *   user-submitted data is stored in $form_state['values'], though *   form validation functions are passed an explicit copy of the *   values for the sake of simplicity. Validation handlers can also *   $form_state to pass information on to submit handlers. For example: *     $form_state['data_for_submision'] = $data; *   This technique is useful when validation requires file parsing, *   web service requests, or other expensive requests that should *   not be repeated in the submission step. * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. */function _form_validate($elements, &$form_state, $form_id = NULL) {  static $complete_form;  // Also used in the installer, pre-database setup.  $t = get_t();  // Recurse through all children.  foreach (element_children($elements) as $key) {    if (isset($elements[$key]) && $elements[$key]) {      _form_validate($elements[$key], $form_state);    }  }  // Validate the current input.  if (!isset($elements['#validated']) || !$elements['#validated']) {    if (isset($elements['#needs_validation'])) {      // Make sure a value is passed when the field is required.      // A simple call to empty() will not cut it here as some fields, like      // checkboxes, can return a valid value of '0'. Instead, check the      // length if it's a string, and the item count if it's an array.      if ($elements['#required'] && (!count($elements['#value']) || (is_string($elements['#value']) && strlen(trim($elements['#value'])) == 0))) {        form_error($elements, $t('!name field is required.', array('!name' => $elements['#title'])));      }      // Verify that the value is not longer than #maxlength.      if (isset($elements['#maxlength']) && drupal_strlen($elements['#value']) > $elements['#maxlength']) {        form_error($elements, $t('!name cannot be longer than %max characters but is currently %length characters long.', array('!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title'], '%max' => $elements['#maxlength'], '%length' => drupal_strlen($elements['#value']))));      }      if (isset($elements['#options']) && isset($elements['#value'])) {        if ($elements['#type'] == 'select') {          $options = form_options_flatten($elements['#options']);        }        else {          $options = $elements['#options'];        }        if (is_array($elements['#value'])) {          $value = $elements['#type'] == 'checkboxes' ? array_keys(array_filter($elements['#value'])) : $elements['#value'];          foreach ($value as $v) {            if (!isset($options[$v])) {              form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));              watchdog('form', 'Illegal choice %choice in !name element.', array('%choice' => $v, '!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);            }          }        }        elseif (!isset($options[$elements['#value']])) {          form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));          watchdog('form', 'Illegal choice %choice in %name element.', array('%choice' => $elements['#value'], '%name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);        }      }    }    // Call user-defined form level validators and store a copy of the full    // form so that element-specific validators can examine the entire structure    // if necessary.    if (isset($form_id)) {      form_execute_handlers('validate', $elements, $form_state);      $complete_form = $elements;    }    // Call any element-specific validators. These must act on the element    // #value data.    elseif (isset($elements['#element_validate'])) {      foreach ($elements['#element_validate'] as $function) {        if (function_exists($function))  {          $function($elements, $form_state, $complete_form);        }      }    }    $elements['#validated'] = TRUE;  }}/** * A helper function used to execute custom validation and submission * handlers for a given form. Button-specific handlers are checked * first. If none exist, the function falls back to form-level handlers. * * @param $type *   The type of handler to execute. 'validate' or 'submit' are the *   defaults used by Form API. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. If the user *   submitted the form by clicking a button with custom handler functions *   defined, those handlers will be stored here. */function form_execute_handlers($type, &$form, &$form_state) {  $return = FALSE;  if (isset($form_state[$type .'_handlers'])) {    $handlers = $form_state[$type .'_handlers'];  }  elseif (isset($form['#'. $type])) {    $handlers = $form['#'. $type];  }  else {    $handlers = array();  }  foreach ($handlers as $function) {    if (function_exists($function))  {      // Check to see if a previous _submit handler has set a batch, but       // make sure we do not react to a batch that is already being processed       // (for instance if a batch operation performs a drupal_execute()).      if ($type == 'submit' && ($batch =& batch_get()) && !isset($batch['current_set'])) {        // Some previous _submit handler has set a batch. We store the call        // in a special 'control' batch set, for execution at the correct        // time during the batch processing workflow.        $batch['sets'][] = array('form_submit' => $function);      }      else {        $function($form, $form_state);      }      $return = TRUE;    }  }  return $return;}/** * File an error against a form element. * * @param $name *   The name of the form element. If the #parents property of your form *   element is array('foo', 'bar', 'baz') then you may set an error on 'foo' *   or 'foo][bar][baz'. Setting an error on 'foo' sets an error for every *   element where the #parents array starts with 'foo'. * @param $message *   The error message to present to the user. * @param $reset *   Reset the form errors static cache. * @return *   Never use the return value of this function, use form_get_errors and *   form_get_error instead. */function form_set_error($name = NULL, $message = '', $reset = FALSE) {  static $form = array();  if ($reset) {    $form = array();  }  if (isset($name) && !isset($form[$name])) {    $form[$name] = $message;    if ($message) {      drupal_set_message($message, 'error');    }  }  return $form;}/** * Return an associative array of all errors. */function form_get_errors() {  $form = form_set_error();  if (!empty($form)) {    return $form;  }}/** * Return the error message filed against the form with the specified name. */function form_get_error($element) {  $form = form_set_error();  $key = $element['#parents'][0];  if (isset($form[$key])) {    return $form[$key];  }  $key = implode('][', $element['#parents']);  if (isset($form[$key])) {    return $form[$key];  }}/** * Flag an element as having an error. */function form_error(&$element, $message = '') {  form_set_error(implode('][', $element['#parents']), $message);}/** * Walk through the structured form array, adding any required * properties to each element and mapping the incoming $_POST * data to the proper elements. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. In this *   context, it is used to accumulate information about which button *   was clicked when the form was submitted, as well as the sanitized *   $_POST data. */function form_builder($form_id, $form, &$form_state) {  static $complete_form, $cache;  // Initialize as unprocessed.  $form['#processed'] = FALSE;  // Use element defaults.  if ((!empty($form['#type'])) && ($info = _element_info($form['#type']))) {    // Overlay $info onto $form, retaining preexisting keys in $form.    $form += $info;  }  if (isset($form['#type']) && $form['#type'] == 'form') {    $cache = NULL;    $complete_form = $form;    if (!empty($form['#programmed'])) {      $form_state['submitted'] = TRUE;    }  }  if (isset($form['#input']) && $form['#input']) {    _form_builder_handle_input_element($form_id, $form, $form_state, $complete_form);  }  $form['#defaults_loaded'] = TRUE;  // We start off assuming all form elements are in the correct order.  $form['#sorted'] = TRUE;  // Recurse through all child elements.  $count = 0;  foreach (element_children($form) as $key) {    $form[$key]['#post'] = $form['#post'];    $form[$key]['#programmed'] = $form['#programmed'];    // Don't squash an existing tree value.    if (!isset($form[$key]['#tree'])) {      $form[$key]['#tree'] = $form['#tree'];    }    // Deny access to child elements if parent is denied.    if (isset($form['#access']) && !$form['#access']) {      $form[$key]['#access'] = FALSE;    }    // Don't squash existing parents value.    if (!isset($form[$key]['#parents'])) {      // Check to see if a tree of child elements is present. If so,      // continue down the tree if required.      $form[$key]['#parents'] = $form[$key]['#tree'] && $form['#tree'] ? array_merge($form['#parents'], array($key)) : array($key);      $array_parents = isset($form['#array_parents']) ? $form['#array_parents'] : array();      $array_parents[] = $key;      $form[$key]['#array_parents'] = $array_parents;    }    // Assign a decimal placeholder weight to preserve original array order.    if (!isset($form[$key]['#weight'])) {      $form[$key]['#weight'] = $count/1000;    }    else {      // If one of the child elements has a weight then we will need to sort      // later.      unset($form['#sorted']);    }    $form[$key] = form_builder($form_id, $form[$key], $form_state);    $count++;  }  // The #after_build flag allows any piece of a form to be altered  // after normal input parsing has been completed.  if (isset($form['#after_build']) && !isset($form['#after_build_done'])) {    foreach ($form['#after_build'] as $function) {      $form = $function($form, $form_state);      $form['#after_build_done'] = TRUE;    }  }  // Now that we've processed everything, we can go back to handle the funky  // Internet Explorer button-click scenario.  _form_builder_ie_cleanup($form, $form_state);  // We shoud keep the buttons array until the IE clean up function  // has recognized the submit button so the form has been marked  // as submitted. If we already know which button was submitted,  // we don't need the array.  if (!empty($form_state['submitted'])) {    unset($form_state['buttons']);  }  // If some callback set #cache, we need to flip a static flag so later it  // can be found.  if (!empty($form['#cache'])) {    $cache = $form['#cache'];  }  // We are on the top form, we can copy back #cache if it's set.  if (isset($form['#type']) && $form['#type'] == 'form' && isset($cache)) {    $form['#cache'] = TRUE;  }  return $form;}/** * Populate the #value and #name properties of input elements so they * can be processed and rendered. Also, execute any #process handlers * attached to a specific element. */function _form_builder_handle_input_element($form_id, &$form, &$form_state, $complete_form) {  if (!isset($form['#name'])) {    $name = array_shift($form['#parents']);    $form['#name'] = $name;    if ($form['#type'] == 'file') {      // To make it easier to handle $_FILES in file.inc, we place all      // file fields in the 'files' array. Also, we do not support      // nested file names.      $form['#name'] = 'files['. $form['#name'] .']';    }    elseif (count($form['#parents'])) {      $form['#name'] .= '['. implode('][', $form['#parents']) .']';    }    array_unshift($form['#parents'], $name);  }  if (!isset($form['#id'])) {    $form['#id'] = form_clean_id('edit-'. implode('-', $form['#parents']));  }  if (!empty($form['#disabled'])) {    $form['#attributes']['disabled'] = 'disabled';  }  if (!isset($form['#value']) && !array_key_exists('#value', $form)) {    $function = !empty($form['#value_callback']) ? $form['#value_callback'] : 'form_type_'. $form['#type'] .'_value';    if (($form['#programmed']) || ((!isset($form['#access']) || $form['#access']) && isset($form['#post']) && (isset($form['#post']['form_id']) && $form['#post']['form_id'] == $form_id))) {      $edit = $form['#post'];      foreach ($form['#parents'] as $parent) {        $edit = isset($edit[$parent]) ? $edit[$parent] : NULL;      }      if (!$form['#programmed'] || isset($edit)) {        // Call #type_value to set the form value;        if (function_exists($function)) {          $form['#value'] = $function($form, $edit);        }        if (!isset($form['#value']) && isset($edit)) {          $form['#value'] = $edit;        }      }      // Mark all posted values for validation.      if (isset($form['#value']) || (isset($form['#required']) && $form['#required'])) {        $form['#needs_validation'] = TRUE;      }    }    // Load defaults.    if (!isset($form['#value'])) {      // Call #type_value without a second argument to request default_value handling.      if (function_exists($function)) {        $form['#value'] = $function($form);      }      // Final catch. If we haven't set a value yet, use the explicit default value.      // Avoid image buttons (which come with garbage value), so we only get value      // for the button actually clicked.      if (!isset($form['#value']) && empty($form['#has_garbage_value'])) {        $form['#value'] = isset($form['#default_value']) ? $form['#default_value'] : '';      }    }  }  // Determine which button (if any) was clicked to submit the form.  // We compare the incoming values with the buttons defined in the form,  // and flag the one that matches. We have to do some funky tricks to  // deal with Internet Explorer's handling of single-button forms, though.  if (!empty($form['#post']) && isset($form['#executes_submit_callback'])) {    // First, accumulate a collection of buttons, divided into two bins:    // those that execute full submit callbacks and those that only validate.    $button_type = $form['#executes_submit_callback'] ? 'submit' : 'button';    $form_state['buttons'][$button_type][] = $form;    if (_form_button_was_clicked($form)) {      $form_state['submitted'] = $form_state['submitted'] || $form['#executes_submit_callback'];      // In most cases, we want to use form_set_value() to manipulate      // the global variables. In this special case, we want to make sure that      // the value of this element is listed in $form_variables under 'op'.      $form_state['values'][$form['#name']] = $form['#value'];      $form_state['clicked_button'] = $form;      if (isset($form['#validate'])) {        $form_state['validate_handlers'] = $form['#validate'];      }      if (isset($form['#submit'])) {        $form_state['submit_handlers'] = $form['#submit'];      }    }  }  // Allow for elements to expand to multiple elements, e.g., radios,  // checkboxes and files.  if (isset($form['#process']) && !$form['#processed']) {    foreach ($form['#process'] as $process) {      if (function_exists($process)) {        $form = $process($form, isset($edit) ? $edit : NULL, $form_state, $complete_form);      }    }    $form['#processed'] = TRUE;  }  form_set_value($form, $form['#value'], $form_state);}/** * Helper function to handle the sometimes-convoluted logic of button * click detection. * * In Internet Explorer, if ONLY one submit button is present, AND the * enter key is used to submit the form, no form value is sent for it * and we'll never detect a match. That special case is handled by * _form_builder_ie_cleanup(). */function _form_button_was_clicked($form) {  // First detect normal 'vanilla' button clicks. Traditionally, all  // standard buttons on a form share the same name (usually 'op'),  // and the specific return value is used to determine which was  // clicked. This ONLY works as long as $form['#name'] puts the  // value at the top level of the tree of $_POST data.  if (isset($form['#post'][$form['#name']]) && $form['#post'][$form['#name']] == $form['#value']) {    return TRUE;  }  // When image buttons are clicked, browsers do NOT pass the form element  // value in $_POST. Instead they pass an integer representing the  // coordinates of the click on the button image. This means that image  // buttons MUST have unique $form['#name'] values, but the details of  // their $_POST data should be ignored.  elseif (!empty($form['#has_garbage_value']) && isset($form['#value']) && $form['#value'] !== '') {    return TRUE;  }  return FALSE;}/** * In IE, if only one submit button is present, AND the enter key is * used to submit the form, no form value is sent for it and our normal * button detection code will never detect a match. We call this * function after all other button-detection is complete to check * for the proper conditions, and treat the single button on the form * as 'clicked' if they are met. */function _form_builder_ie_cleanup($form, &$form_state) {  // Quick check to make sure we're always looking at the full form  // and not a sub-element.  if (!empty($form['#type']) && $form['#type'] == 'form') {    // If we haven't recognized a submission yet, and there's a single    // submit button, we know that we've hit the right conditions. Grab    // the first one and treat it as the clicked button.    if (empty($form_state['submitted']) && !empty($form_state['buttons']['submit']) && empty($form_state['buttons']['button'])) {      $button = $form_state['buttons']['submit'][0];      // Set up all the $form_state information that would have been      // populated had the button been recognized earlier.      $form_state['submitted'] = TRUE;      $form_state['submit_handlers'] = empty($button['#submit']) ? NULL : $button['#submit'];      $form_state['validate_handlers'] = empty($button['#validate']) ? NULL : $button['#validate'];      $form_state['values'][$button['#name']] = $button['#value'];      $form_state['clicked_button'] = $button;    }  }}/** * Helper function to determine the value for an image button form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_image_button_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (!empty($edit)) {      // If we're dealing with Mozilla or Opera, we're lucky. It will      // return a proper value, and we can get on with things.      return $form['#return_value'];    }    else {      // Unfortunately, in IE we never get back a proper value for THIS      // form element. Instead, we get back two split values: one for the      // X and one for the Y coordinates on which the user clicked the      // button. We'll find this element in the #post data, and search      // in the same spot for its name, with '_x'.      $post = $form['#post'];      foreach (split('\[', $form['#name']) as $element_name) {        // chop off the ] that may exist.        if (substr($element_name, -1) == ']') {          $element_name = substr($element_name, 0, -1);        }        if (!isset($post[$element_name])) {          if (isset($post[$element_name .'_x'])) {            return $form['#return_value'];          }          return NULL;        }        $post = $post[$element_name];      }      return $form['#return_value'];    }  }}/** * Helper function to determine the value for a checkbox form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_checkbox_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (empty($form['#disabled'])) {      return !empty($edit) ? $form['#return_value'] : 0;    }    else {      return $form['#default_value'];    }  }}/** * Helper function to determine the value for a checkboxes form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_checkboxes_value($form, $edit = FALSE) {  if ($edit === FALSE) {    $value = array();    $form += array('#default_value' => array());    foreach ($form['#default_value'] as $key) {      $value[$key] = 1;    }    return $value;  }  elseif (!isset($edit)) {    return array();  }}/** * Helper function to determine the value for a password_confirm form * element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_password_confirm_value($form, $edit = FALSE) {  if ($edit === FALSE) {    $form += array('#default_value' => array());    return $form['#default_value'] + array('pass1' => '', 'pass2' => '');  }}/** * Helper function to determine the value for a select form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_select_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (isset($form['#multiple']) && $form['#multiple']) {      return (is_array($edit)) ? drupal_map_assoc($edit) : array();    }    else {      return $edit;    }  }}/** * Helper function to determine the value for a textfield form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_textfield_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    // Equate $edit to the form value to ensure it's marked for    // validation.    return str_replace(array("\r", "\n"), '', $edit);  }}/** * Helper function to determine the value for form's token value. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_token_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    return (string)$edit;  }}/** * Change submitted form values during the form processing cycle. * * Use this function to change the submitted value of a form item in the * validation phase so that it persists in $form_state through to the * submission handlers in the submission phase. * * Since $form_state['values'] can either be a flat array of values, or a tree * of nested values, some care must be taken when using this function. * Specifically, $form_item['#parents'] is an array that describes the branch of * the tree whose value should be updated. For example, if we wanted to update * $form_state['values']['one']['two'] to 'new value', we'd pass in * $form_item['#parents'] = array('one', 'two') and $value = 'new value'. * * @param $form_item *   The form item that should have its value updated. Keys used: #parents, *   #value. In most cases you can just pass in the right element from the $form *   array. * @param $value *   The new value for the form item. * @param $form_state *   The array where the value change should be recorded. */function form_set_value($form_item, $value, &$form_state) {  _form_set_value($form_state['values'], $form_item, $form_item['#parents'], $value);}/** * Helper function for form_set_value(). * * We iterate over $parents and create nested arrays for them * in $form_state['values'] if needed. Then we insert the value into * the right array. */function _form_set_value(&$form_values, $form_item, $parents, $value) {  $parent = array_shift($parents);  if (empty($parents)) {    $form_values[$parent] = $value;  }  else {    if (!isset($form_values[$parent])) {      $form_values[$parent] = array();    }    _form_set_value($form_values[$parent], $form_item, $parents, $value);  }}/** * Retrieve the default properties for the defined element type. */function _element_info($type, $refresh = NULL) {  static $cache;  $basic_defaults = array(    '#description' => NULL,    '#attributes' => array(),    '#required' => FALSE,    '#tree' => FALSE,    '#parents' => array()  );  if (!isset($cache) || $refresh) {    $cache = array();    foreach (module_implements('elements') as $module) {      $elements = module_invoke($module, 'elements');      if (isset($elements) && is_array($elements)) {        $cache = array_merge_recursive($cache, $elements);      }    }    if (sizeof($cache)) {      foreach ($cache as $element_type => $info) {        $cache[$element_type] = array_merge_recursive($basic_defaults, $info);      }    }  }  return $cache[$type];}function form_options_flatten($array, $reset = TRUE) {  static $return;  if ($reset) {    $return = array();  }  foreach ($array as $key => $value) {    if (is_object($value)) {      form_options_flatten($value->option, FALSE);    }    else if (is_array($value)) {      form_options_flatten($value, FALSE);    }    else {      $return[$key] = 1;    }  }  return $return;}/** * Format a dropdown menu or scrolling selection box. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, extra, multiple, required * @return *   A themed HTML string representing the form element. * * @ingroup themeable * * It is possible to group options together; to do this, change the format of * $options to an associative array in which the keys are group labels, and the * values are associative arrays in the normal $options format. */function theme_select($element) {  $select = '';  $size = $element['#size'] ? ' size="'. $element['#size'] .'"' : '';  _form_set_class($element, array('form-select'));  $multiple = $element['#multiple'];  return theme('form_element', $element, '<select name="'. $element['#name'] .''. ($multiple ? '[]' : '') .'"'. ($multiple ? ' multiple="multiple" ' : '') . drupal_attributes($element['#attributes']) .' id="'. $element['#id'] .'" '. $size .'>'. form_select_options($element) .'</select>');}function form_select_options($element, $choices = NULL) {  if (!isset($choices)) {    $choices = $element['#options'];  }  // array_key_exists() accommodates the rare event where $element['#value'] is NULL.  // isset() fails in this situation.  $value_valid = isset($element['#value']) || array_key_exists('#value', $element);  $value_is_array = is_array($element['#value']);  $options = '';  foreach ($choices as $key => $choice) {    if (is_array($choice)) {      $options .= '<optgroup label="'. $key .'">';      $options .= form_select_options($element, $choice);      $options .= '</optgroup>';    }    elseif (is_object($choice)) {      $options .= form_select_options($element, $choice->option);    }    else {      $key = (string)$key;      if ($value_valid && (!$value_is_array && (string)$element['#value'] === $key || ($value_is_array && in_array($key, $element['#value'])))) {        $selected = ' selected="selected"';      }      else {        $selected = '';      }      $options .= '<option value="'. check_plain($key) .'"'. $selected .'>'. check_plain($choice) .'</option>';    }  }  return $options;}/** * Traverses a select element's #option array looking for any values * that hold the given key. Returns an array of indexes that match. * * This function is useful if you need to modify the options that are * already in a form element; for example, to remove choices which are * not valid because of additional filters imposed by another module. * One example might be altering the choices in a taxonomy selector. * To correctly handle the case of a multiple hierarchy taxonomy, * #options arrays can now hold an array of objects, instead of a * direct mapping of keys to labels, so that multiple choices in the * selector can have the same key (and label). This makes it difficult * to manipulate directly, which is why this helper function exists. * * This function does not support optgroups (when the elements of the * #options array are themselves arrays), and will return FALSE if * arrays are found. The caller must either flatten/restore or * manually do their manipulations in this case, since returning the * index is not sufficient, and supporting this would make the * "helper" too complicated and cumbersome to be of any help. * * As usual with functions that can return array() or FALSE, do not * forget to use === and !== if needed. * * @param $element *   The select element to search. * @param $key *   The key to look for. * @return *   An array of indexes that match the given $key. Array will be *   empty if no elements were found. FALSE if optgroups were found. */function form_get_options($element, $key) {  $keys = array();  foreach ($element['#options'] as $index => $choice) {    if (is_array($choice)) {      return FALSE;    }    else if (is_object($choice)) {      if (isset($choice->option[$key])) {        $keys[] = $index;      }    }    else if ($index == $key) {      $keys[] = $index;    }  }  return $keys;}/** * Format a group of form items. * * @param $element *   An associative array containing the properties of the element. *   Properties used: attributes, title, value, description, children, collapsible, collapsed * @return *   A themed HTML string representing the form item group. * * @ingroup themeable */function theme_fieldset($element) {  if (!empty($element['#collapsible'])) {    drupal_add_js('misc/collapse.js');    if (!isset($element['#attributes']['class'])) {      $element['#attributes']['class'] = '';    }    $element['#attributes']['class'] .= ' collapsible';    if (!empty($element['#collapsed'])) {      $element['#attributes']['class'] .= ' collapsed';    }  }  return '<fieldset'. drupal_attributes($element['#attributes']) .'>'. ($element['#title'] ? '<legend>'. $element['#title'] .'</legend>' : '') . (isset($element['#description']) && $element['#description'] ? '<div class="description">'. $element['#description'] .'</div>' : '') . (!empty($element['#children']) ? $element['#children'] : '') . (isset($element['#value']) ? $element['#value'] : '') ."</fieldset>\n";}/** * Format a radio button. * * @param $element *   An associative array containing the properties of the element. *   Properties used: required, return_value, value, attributes, title, description * @return *   A themed HTML string representing the form item group. * * @ingroup themeable */function theme_radio($element) {  _form_set_class($element, array('form-radio'));  $output = '<input type="radio" ';  $output .= 'id="'. $element['#id'] .'" ';  $output .= 'name="'. $element['#name'] .'" ';  $output .= 'value="'. $element['#return_value'] .'" ';  $output .= (check_plain($element['#value']) == $element['#return_value']) ? ' checked="checked" ' : ' ';  $output .= drupal_attributes($element['#attributes']) .' />';  if (!is_null($element['#title'])) {    $output = '<label class="option" for="'. $element['#id'] .'">'. $output .' '. $element['#title'] .'</label>';  }  unset($element['#title']);  return theme('form_element', $element, $output);}/** * Format a set of radio buttons. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, required and attributes. * @return *   A themed HTML string representing the radio button set. * * @ingroup themeable */function theme_radios($element) {  $class = 'form-radios';  if (isset($element['#attributes']['class'])) {    $class .= ' '. $element['#attributes']['class'];  }  $element['#children'] = '<div class="'. $class .'">'. (!empty($element['#children']) ? $element['#children'] : '') .'</div>';  if ($element['#title'] || $element['#description']) {    unset($element['#id']);    return theme('form_element', $element, $element['#children']);  }  else {    return $element['#children'];  }}/** * Format a password_confirm item. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, id, required, error. * @return *   A themed HTML string representing the form item. * * @ingroup themeable */function theme_password_confirm($element) {  return theme('form_element', $element, $element['#children']);}/** * Expand a password_confirm field into two text boxes. */function expand_password_confirm($element) {  $element['pass1'] =  array(    '#type' => 'password',    '#title' => t('Password'),    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass1'],    '#required' => $element['#required'],    '#attributes' => array('class' => 'password-field'),  );  $element['pass2'] =  array(    '#type' => 'password',    '#title' => t('Confirm password'),    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass2'],    '#required' => $element['#required'],    '#attributes' => array('class' => 'password-confirm'),  );  $element['#element_validate'] = array('password_confirm_validate');  $element['#tree'] = TRUE;  if (isset($element['#size'])) {    $element['pass1']['#size'] = $element['pass2']['#size'] = $element['#size'];  }  return $element;}/** * Validate password_confirm element. */function password_confirm_validate($form, &$form_state) {  $pass1 = trim($form['pass1']['#value']);  if (!empty($pass1)) {    $pass2 = trim($form['pass2']['#value']);    if (strcmp($pass1, $pass2)) {      form_error($form, t('The specified passwords do not match.'));    }  }  elseif ($form['#required'] && !empty($form['#post'])) {    form_error($form, t('Password field is required.'));  }  // Password field must be converted from a two-element array into a single  // string regardless of validation results.  form_set_value($form['pass1'], NULL, $form_state);  form_set_value($form['pass2'], NULL, $form_state);  form_set_value($form, $pass1, $form_state);  return $form;}/** * Format a date selection element. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, required and attributes. * @return *   A themed HTML string representing the date selection boxes. * * @ingroup themeable */function theme_date($element) {  return theme('form_element', $element, '<div class="container-inline">'. $element['#children'] .'</div>');}/** * Roll out a single date element. */function expand_date($element) {  // Default to current date  if (empty($element['#value'])) {    $element['#value'] = array('day' => format_date(time(), 'custom', 'j'),                            'month' => format_date(time(), 'custom', 'n'),                            'year' => format_date(time(), 'custom', 'Y'));  }  $element['#tree'] = TRUE;  // Determine the order of day, month, year in the site's chosen date format.  $format = variable_get('date_format_short', 'm/d/Y - H:i');  $sort = array();  $sort['day'] = max(strpos($format, 'd'), strpos($format, 'j'));  $sort['month'] = max(strpos($format, 'm'), strpos($format, 'M'));  $sort['year'] = strpos($format, 'Y');  asort($sort);  $order = array_keys($sort);  // Output multi-selector for date.  foreach ($order as $type) {    switch ($type) {      case 'day':        $options = drupal_map_assoc(range(1, 31));        break;      case 'month':        $options = drupal_map_assoc(range(1, 12), 'map_month');        break;      case 'year':        $options = drupal_map_assoc(range(1900, 2050));        break;    }    $parents = $element['#parents'];    $parents[] = $type;    $element[$type] = array(      '#type' => 'select',      '#value' => $element['#value'][$type],      '#attributes' => $element['#attributes'],      '#options' => $options,    );  }  return $element;}/** * Validates the date type to stop dates like February 30, 2006. */function date_validate($form) {  if (!checkdate($form['#value']['month'], $form['#value']['day'], $form['#value']['year'])) {    form_error($form, t('The specified date is invalid.'));  }}/** * Helper function for usage with drupal_map_assoc to display month names. */function map_month($month) {  return format_date(gmmktime(0, 0, 0, $month, 2, 1970), 'custom', 'M', 0);}/** * If no default value is set for weight select boxes, use 0. */function weight_value(&$form) {  if (isset($form['#default_value'])) {    $form['#value'] = $form['#default_value'];  }  else {    $form['#value'] = 0;  }}/** * Roll out a single radios element to a list of radios, * using the options array as index. */function expand_radios($element) {  if (count($element['#options']) > 0) {    foreach ($element['#options'] as $key => $choice) {      if (!isset($element[$key])) {        // Generate the parents as the autogenerator does, so we will have a        // unique id for each radio button.        $parents_for_id = array_merge($element['#parents'], array($key));        $element[$key] = array(          '#type' => 'radio',          '#title' => $choice,          '#return_value' => check_plain($key),          '#default_value' => isset($element['#default_value']) ? $element['#default_value'] : NULL,          '#attributes' => $element['#attributes'],          '#parents' => $element['#parents'],          '#id' => form_clean_id('edit-'. implode('-', $parents_for_id)),          '#ahah' => isset($element['#ahah']) ? $element['#ahah'] : NULL,        );      }    }  }  return $element;}/** * Add AHAH information about a form element to the page to communicate with * javascript. If #ahah[path] is set on an element, this additional javascript is * added to the page header to attach the AHAH behaviors. See ahah.js for more * information. * * @param $element *   An associative array containing the properties of the element. *   Properties used: ahah_event, ahah_path, ahah_wrapper, ahah_parameters, *   ahah_effect. * @return *   None. Additional code is added to the header of the page using *   drupal_add_js. */function form_expand_ahah($element) {  static $js_added = array();  // Add a reasonable default event handler if none specified.  if (isset($element['#ahah']['path']) && !isset($element['#ahah']['event'])) {    switch ($element['#type']) {      case 'submit':      case 'button':      case 'image_button':        // Use the mousedown instead of the click event because form        // submission via pressing the enter key triggers a click event on        // submit inputs, inappropriately triggering AHAH behaviors.        $element['#ahah']['event'] = 'mousedown';        // Attach an additional event handler so that AHAH behaviours        // can be triggered still via keyboard input.        $element['#ahah']['keypress'] = TRUE;        break;      case 'password':      case 'textfield':      case 'textarea':        $element['#ahah']['event'] = 'blur';        break;      case 'radio':      case 'checkbox':      case 'select':        $element['#ahah']['event'] = 'change';        break;    }  }  // Adding the same javascript settings twice will cause a recursion error,  // we avoid the problem by checking if the javascript has already been added.  if (isset($element['#ahah']['path']) && isset($element['#ahah']['event']) && !isset($js_added[$element['#id']])) {    drupal_add_js('misc/jquery.form.js');    drupal_add_js('misc/ahah.js');    $ahah_binding = array(      'url'      => url($element['#ahah']['path']),      'event'    => $element['#ahah']['event'],      'keypress' => empty($element['#ahah']['keypress']) ? NULL : $element['#ahah']['keypress'],      'wrapper'  => empty($element['#ahah']['wrapper']) ? NULL : $element['#ahah']['wrapper'],      'selector' => empty($element['#ahah']['selector']) ? '#'. $element['#id'] : $element['#ahah']['selector'],      'effect'   => empty($element['#ahah']['effect']) ? 'none' : $element['#ahah']['effect'],      'method'   => empty($element['#ahah']['method']) ? 'replace' : $element['#ahah']['method'],      'progress' => empty($element['#ahah']['progress']) ? array('type' => 'throbber') : $element['#ahah']['progress'],      'button'   => isset($element['#executes_submit_callback']) ? array($element['#name'] => $element['#value']) : FALSE,    );    // Convert a simple #ahah[progress] type string into an array.    if (is_string($ahah_binding['progress'])) {      $ahah_binding['progress'] = array('type' => $ahah_binding['progress']);    }    // Change progress path to a full url.    if (isset($ahah_binding['progress']['path'])) {      $ahah_binding['progress']['url'] = url($ahah_binding['progress']['path']);    }    // Add progress.js if we're doing a bar display.    if ($ahah_binding['progress']['type'] == 'bar') {      drupal_add_js('misc/progress.js');    }    drupal_add_js(array('ahah' => array($element['#id'] => $ahah_binding)), 'setting');    $js_added[$element['#id']] = TRUE;    $element['#cache'] = TRUE;  }  return $element;}/** * Format a form item. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, required, error * @return *   A themed HTML string representing the form item. * * @ingroup themeable */function theme_item($element) {  return theme('form_element', $element, $element['#value'] . (!empty($element['#children']) ? $element['#children'] : ''));}/** * Format a checkbox. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, return_value, description, required * @return *   A themed HTML string representing the checkbox. * * @ingroup themeable */function theme_checkbox($element) {  _form_set_class($element, array('form-checkbox'));  $checkbox = '<input ';  $checkbox .= 'type="checkbox" ';  $checkbox .= 'name="'. $element['#name'] .'" ';  $checkbox .= 'id="'. $element['#id'] .'" ' ;  $checkbox .= 'value="'. $element['#return_value'] .'" ';  $checkbox .= $element['#value'] ? ' checked="checked" ' : ' ';  $checkbox .= drupal_attributes($element['#attributes']) .' />';  if (!is_null($element['#title'])) {    $checkbox = '<label class="option" for="'. $element['#id'] .'">'. $checkbox .' '. $element['#title'] .'</label>';  }  unset($element['#title']);  return theme('form_element', $element, $checkbox);}/** * Format a set of checkboxes. * * @param $element *   An associative array containing the properties of the element. * @return *   A themed HTML string representing the checkbox set. * * @ingroup themeable */function theme_checkboxes($element) {  $class = 'form-checkboxes';  if (isset($element['#attributes']['class'])) {    $class .= ' '. $element['#attributes']['class'];  }  $element['#children'] = '<div class="'. $class .'">'. (!empty($element['#children']) ? $element['#children'] : '') .'</div>';  if ($element['#title'] || $element['#description']) {    unset($element['#id']);    return theme('form_element', $element, $element['#children']);  }  else {    return $element['#children'];  }}function expand_checkboxes($element) {  $value = is_array($element['#value']) ? $element['#value'] : array();  $element['#tree'] = TRUE;  if (count($element['#options']) > 0) {    if (!isset($element['#default_value']) || $element['#default_value'] == 0) {      $element['#default_value'] = array();    }    foreach ($element['#options'] as $key => $choice) {      if (!isset($element[$key])) {        $element[$key] = array(          '#type' => 'checkbox',          '#processed' => TRUE,          '#title' => $choice,          '#return_value' => $key,          '#default_value' => isset($value[$key]),          '#attributes' => $element['#attributes'],          '#ahah' => isset($element['#ahah']) ? $element['#ahah'] : NULL,        );      }    }  }  return $element;}/** * Theme a form submit button. * * @ingroup themeable */function theme_submit($element) {  return theme('button', $element);}/** * Theme a form button. * * @ingroup themeable */function theme_button($element) {  // Make sure not to overwrite classes.  if (isset($element['#attributes']['class'])) {    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];  }  else {    $element['#attributes']['class'] = 'form-'. $element['#button_type'];  }  return '<input type="submit" '. (empty($element['#name']) ? '' : 'name="'. $element['#name'] .'" ') .'id="'. $element['#id'] .'" value="'. check_plain($element['#value']) .'" '. drupal_attributes($element['#attributes']) ." />\n";}/** * Theme a form image button. * * @ingroup themeable */function theme_image_button($element) {  // Make sure not to overwrite classes.  if (isset($element['#attributes']['class'])) {    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];  }  else {    $element['#attributes']['class'] = 'form-'. $element['#button_type'];  }  return '<input type="image" name="'. $element['#name'] .'" '.    (!empty($element['#value']) ? ('value="'. check_plain($element['#value']) .'" ') : '') .    'id="'. $element['#id'] .'" '.    drupal_attributes($element['#attributes']) .    ' src="'. base_path() . $element['#src'] .'" '.    (!empty($element['#title']) ? 'alt="'. check_plain($element['#title']) .'" title="'. check_plain($element['#title']) .'" ' : '' ) .    "/>\n";}/** * Format a hidden form field. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  value, edit * @return *   A themed HTML string representing the hidden form field. * * @ingroup themeable */function theme_hidden($element) {  return '<input type="hidden" name="'. $element['#name'] .'" id="'. $element['#id'] .'" value="'. check_plain($element['#value']) ."\" ". drupal_attributes($element['#attributes']) ." />\n";}/** * Format a form token. * * @ingroup themeable */function theme_token($element) {  return theme('hidden', $element);}/** * Format a textfield. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, size, maxlength, required, attributes autocomplete_path * @return *   A themed HTML string representing the textfield. * * @ingroup themeable */function theme_textfield($element) {  $size = empty($element['#size']) ? '' : ' size="'. $element['#size'] .'"';  $maxlength = empty($element['#maxlength']) ? '' : ' maxlength="'. $element['#maxlength'] .'"';  $class = array('form-text');  $extra = '';  $output = '';  if ($element['#autocomplete_path'] && menu_valid_path(array('link_path' => $element['#autocomplete_path']))) {    drupal_add_js('misc/autocomplete.js');    $class[] = 'form-autocomplete';    $extra =  '<input class="autocomplete" type="hidden" id="'. $element['#id'] .'-autocomplete" value="'. check_url(url($element['#autocomplete_path'], array('absolute' => TRUE))) .'" disabled="disabled" />';  }  _form_set_class($element, $class);  if (isset($element['#field_prefix'])) {    $output .= '<span class="field-prefix">'. $element['#field_prefix'] .'</span> ';  }  $output .= '<input type="text"'. $maxlength .' name="'. $element['#name'] .'" id="'. $element['#id'] .'"'. $size .' value="'. check_plain($element['#value']) .'"'. drupal_attributes($element['#attributes']) .' />';  if (isset($element['#field_suffix'])) {    $output .= ' <span class="field-suffix">'. $element['#field_suffix'] .'</span>';  }  return theme('form_element', $element, $output) . $extra;}/** * Format a form. * * @param $element *   An associative array containing the properties of the element. *   Properties used: action, method, attributes, children * @return *   A themed HTML string representing the form. * * @ingroup themeable */function theme_form($element) {  // Anonymous div to satisfy XHTML compliance.  $action = $element['#action'] ? 'action="'. check_url($element['#action']) .'" ' : '';  return '<form '. $action .' accept-charset="UTF-8" method="'. $element['#method'] .'" id="'. $element['#id'] .'"'. drupal_attributes($element['#attributes']) .">\n<div>". $element['#children'] ."\n</div></form>\n";}/** * Format a textarea. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, description, rows, cols, required, attributes * @return *   A themed HTML string representing the textarea. * * @ingroup themeable */function theme_textarea($element) {  $class = array('form-textarea');  // Add teaser behavior (must come before resizable)  if (!empty($element['#teaser'])) {    drupal_add_js('misc/teaser.js');    // Note: arrays are merged in drupal_get_js().    drupal_add_js(array('teaserCheckbox' => array($element['#id'] => $element['#teaser_checkbox'])), 'setting');    drupal_add_js(array('teaser' => array($element['#id'] => $element['#teaser'])), 'setting');    $class[] = 'teaser';  }  // Add resizable behavior  if ($element['#resizable'] !== FALSE) {    drupal_add_js('misc/textarea.js');    $class[] = 'resizable';  }  _form_set_class($element, $class);  return theme('form_element', $element, '<textarea cols="'. $element['#cols'] .'" rows="'. $element['#rows'] .'" name="'. $element['#name'] .'" id="'. $element['#id'] .'" '. drupal_attributes($element['#attributes']) .'>'. check_plain($element['#value']) .'</textarea>');}/** * Format HTML markup for use in forms. * * This is used in more advanced forms, such as theme selection and filter format. * * @param $element *   An associative array containing the properties of the element. *   Properties used: value, children. * @return *   A themed HTML string representing the HTML markup. * * @ingroup themeable */function theme_markup($element) {  return (isset($element['#value']) ? $element['#value'] : '') . (isset($element['#children']) ? $element['#children'] : '');}/** * Format a password field. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, size, maxlength, required, attributes * @return *   A themed HTML string representing the form. * * @ingroup themeable */function theme_password($element) {  $size = $element['#size'] ? ' size="'. $element['#size'] .'" ' : '';  $maxlength = $element['#maxlength'] ? ' maxlength="'. $element['#maxlength'] .'" ' : '';  _form_set_class($element, array('form-text'));  $output = '<input type="password" name="'. $element['#name'] .'" id="'. $element['#id'] .'" '. $maxlength . $size . drupal_attributes($element['#attributes']) .' />';  return theme('form_element', $element, $output);}/** * Expand weight elements into selects. */function process_weight($element) {  for ($n = (-1 * $element['#delta']); $n <= $element['#delta']; $n++) {    $weights[$n] = $n;  }  $element['#options'] = $weights;  $element['#type'] = 'select';  $element['#is_weight'] = TRUE;  $element += _element_info('select');  return $element;}/** * Format a file upload field. * * @param $title *   The label for the file upload field. * @param $name *   The internal name used to refer to the field. * @param $size *   A measure of the visible size of the field (passed directly to HTML). * @param $description *   Explanatory text to display after the form item. * @param $required *   Whether the user must upload a file to the field. * @return *   A themed HTML string representing the field. * * @ingroup themeable * * For assistance with handling the uploaded file correctly, see the API * provided by file.inc. */function theme_file($element) {  _form_set_class($element, array('form-file'));  return theme('form_element', $element, '<input type="file" name="'. $element['#name'] .'"'. ($element['#attributes'] ? ' '. drupal_attributes($element['#attributes']) : '') .' id="'. $element['#id'] .'" size="'. $element['#size'] ."\" />\n");}/** * Return a themed form element. * * @param element *   An associative array containing the properties of the element. *   Properties used: title, description, id, required * @param $value *   The form element's data. * @return *   A string representing the form element. * * @ingroup themeable */function theme_form_element($element, $value) {  // This is also used in the installer, pre-database setup.  $t = get_t();  $output = '<div class="form-item"';  if (!empty($element['#id'])) {    $output .= ' id="'. $element['#id'] .'-wrapper"';  }  $output .= ">\n";  $required = !empty($element['#required']) ? '<span class="form-required" title="'. $t('This field is required.') .'">*</span>' : '';  if (!empty($element['#title'])) {    $title = $element['#title'];    if (!empty($element['#id'])) {      $output .= ' <label for="'. $element['#id'] .'">'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";    }    else {      $output .= ' <label>'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";    }  }  $output .= " $value\n";  if (!empty($element['#description'])) {    $output .= ' <div class="description">'. $element['#description'] ."</div>\n";  }  $output .= "</div>\n";  return $output;}/** * Sets a form element's class attribute. * * Adds 'required' and 'error' classes as needed. * * @param &$element *   The form element. * @param $name *   Array of new class names to be added. */function _form_set_class(&$element, $class = array()) {  if ($element['#required']) {    $class[] = 'required';  }  if (form_get_error($element)) {    $class[] = 'error';  }  if (isset($element['#attributes']['class'])) {    $class[] = $element['#attributes']['class'];  }  $element['#attributes']['class'] = implode(' ', $class);}/** * Prepare an HTML ID attribute string for a form item. * * Remove invalid characters and guarantee uniqueness. * * @param $id *   The ID to clean. * @param $flush *   If set to TRUE, the function will flush and reset the static array *   which is built to test the uniqueness of element IDs. This is only *   used if a form has completed the validation process. This parameter *   should never be set to TRUE if this function is being called to *   assign an ID to the #ID element. * @return *   The cleaned ID. */function form_clean_id($id = NULL, $flush = FALSE) {  static $seen_ids = array();  if ($flush) {    $seen_ids = array();    return;  }  $id = str_replace(array('][', '_', ' '), '-', $id);  // Ensure IDs are unique. The first occurrence is held but left alone.  // Subsequent occurrences get a number appended to them. This incrementing  // will almost certainly break code that relies on explicit HTML IDs in  // forms that appear more than once on the page, but the alternative is  // outputting duplicate IDs, which would break JS code and XHTML  // validity anyways. For now, it's an acceptable stopgap solution.  if (isset($seen_ids[$id])) {    $id = $id .'-'. $seen_ids[$id]++;  }  else {    $seen_ids[$id] = 1;  }  return $id;}/** * @} End of "defgroup form_api". *//** * @defgroup batch Batch operations * @{ * Functions allowing forms processing to be spread out over several page * requests, thus ensuring that the processing does not get interrupted * because of a PHP timeout, while allowing the user to receive feedback * on the progress of the ongoing operations. * * The API is primarily designed to integrate nicely with the Form API * workflow, but can also be used by non-FAPI scripts (like update.php) * or even simple page callbacks (which should probably be used sparingly). * * Example: * @code * $batch = array( *   'title' => t('Exporting'), *   'operations' => array( *     array('my_function_1', array($account->uid, 'story')), *     array('my_function_2', array()), *   ), *   'finished' => 'my_finished_callback', *   'file' => 'path_to_file_containing_myfunctions', * ); * batch_set($batch); * // only needed if not inside a form _submit handler : * batch_process(); * @endcode * * Note: if the batch 'title', 'init_message', 'progress_message', or * 'error_message' could contain any user input, it is the responsibility of * the code calling batch_set() to sanitize them first with a function like * check_plain() or filter_xss(). * * Sample batch operations: * @code * // Simple and artificial: load a node of a given type for a given user * function my_function_1($uid, $type, &$context) { *   // The $context array gathers batch context information about the execution (read), *   // as well as 'return values' for the current operation (write) *   // The following keys are provided : *   // 'results' (read / write): The array of results gathered so far by *   //   the batch processing, for the current operation to append its own. *   // 'message' (write): A text message displayed in the progress page. *   // The following keys allow for multi-step operations : *   // 'sandbox' (read / write): An array that can be freely used to *   //   store persistent data between iterations. It is recommended to *   //   use this instead of $_SESSION, which is unsafe if the user *   //   continues browsing in a separate window while the batch is processing. *   // 'finished' (write): A float number between 0 and 1 informing *   //   the processing engine of the completion level for the operation. *   //   1 (or no value explicitly set) means the operation is finished *   //   and the batch processing can continue to the next operation. * *   $node = node_load(array('uid' => $uid, 'type' => $type)); *   $context['results'][] = $node->nid .' : '. $node->title; *   $context['message'] = $node->title; * } * * // More advanced example: multi-step operation - load all nodes, five by five * function my_function_2(&$context) { *   if (empty($context['sandbox'])) { *     $context['sandbox']['progress'] = 0; *     $context['sandbox']['current_node'] = 0; *     $context['sandbox']['max'] = db_result(db_query('SELECT COUNT(DISTINCT nid) FROM {node}')); *   } *   $limit = 5; *   $result = db_query_range("SELECT nid FROM {node} WHERE nid > %d ORDER BY nid ASC", $context['sandbox']['current_node'], 0, $limit); *   while ($row = db_fetch_array($result)) { *     $node = node_load($row['nid'], NULL, TRUE); *     $context['results'][] = $node->nid .' : '. $node->title; *     $context['sandbox']['progress']++; *     $context['sandbox']['current_node'] = $node->nid; *     $context['message'] = $node->title; *   } *   if ($context['sandbox']['progress'] != $context['sandbox']['max']) { *     $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max']; *   } * } * @endcode * * Sample 'finished' callback: * @code * function batch_test_finished($success, $results, $operations) { *   if ($success) { *     $message = format_plural(count($results), 'One post processed.', '@count posts processed.'); *   } *   else { *     $message = t('Finished with an error.'); *   } *   drupal_set_message($message); *   // Providing data for the redirected page is done through $_SESSION. *   foreach ($results as $result) { *     $items[] = t('Loaded node %title.', array('%title' => $result)); *   } *   $_SESSION['my_batch_results'] = $items; * } * @endcode *//** * Opens a new batch. * * @param $batch *   An array defining the batch. The following keys can be used -- only *   'operations' is required, and batch_init() provides default values for *   the messages. *   - 'operations': Array of function calls to be performed. *     Example: *     @code *     array( *       array('my_function_1', array($arg1)), *       array('my_function_2', array($arg2_1, $arg2_2)), *     ) *     @endcode *   - 'title': Title for the progress page. Only safe strings should be passed. *     Defaults to t('Processing'). *   - 'init_message': Message displayed while the processing is initialized. *     Defaults to t('Initializing.'). *   - 'progress_message': Message displayed while processing the batch. *     Available placeholders are @current, @remaining, @total, @percentage, *     @estimate and @elapsed. Defaults to t('Completed @current of @total.'). *   - 'error_message': Message displayed if an error occurred while processing *     the batch. Defaults to t('An error has occurred.'). *   - 'finished': Name of a function to be executed after the batch has *     completed. This should be used to perform any result massaging that *     may be needed, and possibly save data in $_SESSION for display after *     final page redirection. *   - 'file': Path to the file containing the definitions of the *     'operations' and 'finished' functions, for instance if they don't *     reside in the main .module file. The path should be relative to *     base_path(), and thus should be built using drupal_get_path(). * * Operations are added as new batch sets. Batch sets are used to ensure * clean code independence, ensuring that several batches submitted by * different parts of the code (core / contrib modules) can be processed * correctly while not interfering or having to cope with each other. Each * batch set gets to specify his own UI messages, operates on its own set * of operations and results, and triggers its own 'finished' callback. * Batch sets are processed sequentially, with the progress bar starting * fresh for every new set. */function batch_set($batch_definition) {  if ($batch_definition) {    $batch =& batch_get();    // Initialize the batch    if (empty($batch)) {      $batch = array(        'sets' => array(),      );    }    $init = array(      'sandbox' => array(),      'results' => array(),      'success' => FALSE,    );    // Use get_t() to allow batches at install time.    $t = get_t();    $defaults = array(      'title' => $t('Processing'),      'init_message' => $t('Initializing.'),      'progress_message' => $t('Remaining @remaining of @total.'),      'error_message' => $t('An error has occurred.'),    );    $batch_set = $init + $batch_definition + $defaults;    // Tweak init_message to avoid the bottom of the page flickering down after init phase.    $batch_set['init_message'] .= '<br/>&nbsp;';    $batch_set['total'] = count($batch_set['operations']);    // If the batch is being processed (meaning we are executing a stored submit handler),    // insert the new set after the current one.    if (isset($batch['current_set'])) {      // array_insert does not exist...      $slice1 = array_slice($batch['sets'], 0, $batch['current_set'] + 1);      $slice2 = array_slice($batch['sets'], $batch['current_set'] + 1);      $batch['sets'] = array_merge($slice1, array($batch_set), $slice2);    }    else {      $batch['sets'][] = $batch_set;    }  }}/** * Processes the batch. * * Unless the batch has been marked with 'progressive' = FALSE, the function * issues a drupal_goto and thus ends page execution. * * This function is not needed in form submit handlers; Form API takes care * of batches that were set during form submission. * * @param $redirect *   (optional) Path to redirect to when the batch has finished processing. * @param $url *   (optional - should only be used for separate scripts like update.php) *   URL of the batch processing page. */function batch_process($redirect = NULL, $url = NULL) {  $batch =& batch_get();  if (isset($batch)) {    // Add process information    $url = isset($url) ? $url : 'batch';    $process_info = array(      'current_set' => 0,      'progressive' => TRUE,      'url' => isset($url) ? $url : 'batch',      'source_page' => $_GET['q'],      'redirect' => $redirect,    );    $batch += $process_info;    if ($batch['progressive']) {      // Clear the way for the drupal_goto redirection to the batch processing      // page, by saving and unsetting the 'destination' if any, on both places      // drupal_goto looks for it.      if (isset($_REQUEST['destination'])) {        $batch['destination'] = $_REQUEST['destination'];        unset($_REQUEST['destination']);      }      elseif (isset($_REQUEST['edit']['destination'])) {        $batch['destination'] = $_REQUEST['edit']['destination'];        unset($_REQUEST['edit']['destination']);      }      // Initiate db storage in order to get a batch id. We have to provide      // at least an empty string for the (not null) 'token' column.      db_query("INSERT INTO {batch} (token, timestamp) VALUES ('', %d)", time());      $batch['id'] = db_last_insert_id('batch', 'bid');      // Now that we have a batch id, we can generate the redirection link in      // the generic error message.      $t = get_t();      $batch['error_message'] = $t('Please continue to <a href="@error_url">the error page</a>', array('@error_url' => url($url, array('query' => array('id' => $batch['id'], 'op' => 'finished')))));      // Actually store the batch data and the token generated form the batch id.      db_query("UPDATE {batch} SET token = '%s', batch = '%s' WHERE bid = %d", drupal_get_token($batch['id']), serialize($batch), $batch['id']);      drupal_goto($batch['url'], 'op=start&id='. $batch['id']);    }    else {      // Non-progressive execution: bypass the whole progressbar workflow      // and execute the batch in one pass.      require_once './includes/batch.inc';      _batch_process();    }  }}/** * Retrieves the current batch. */function &batch_get() {  static $batch = array();  return $batch;}/** * @} End of "defgroup batch". */
<?php// $Id$/** * @file * Administrative page callbacks for the dblog module. *//** * dblog module settings form. * * @ingroup forms * @see system_settings_form() */function dblog_admin_settings() {  $form['dblog_row_limit'] = array(    '#type' => 'select',    '#title' => t('Discard log entries above the following row limit'),    '#default_value' => variable_get('dblog_row_limit', 1000),    '#options' => drupal_map_assoc(array(100, 1000, 10000, 100000, 1000000)),    '#description' => t('The maximum number of rows to keep in the database log. Older entries will be automatically discarded. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status')))  );  return system_settings_form($form);}/** * Menu callback; displays a listing of log messages. */function dblog_overview() {  $filter = dblog_build_filter_query();  $rows = array();  $icons = array(    WATCHDOG_DEBUG    => '',    WATCHDOG_INFO     => '',    WATCHDOG_NOTICE   => '',    WATCHDOG_WARNING  => theme('image', 'misc/watchdog-warning.png', t('warning'), t('warning')),    WATCHDOG_ERROR    => theme('image', 'misc/watchdog-error.png', t('error'), t('error')),    WATCHDOG_CRITICAL => theme('image', 'misc/watchdog-error.png', t('critical'), t('critical')),    WATCHDOG_ALERT    => theme('image', 'misc/watchdog-error.png', t('alert'), t('alert')),    WATCHDOG_EMERG    => theme('image', 'misc/watchdog-error.png', t('emergency'), t('emergency')),  );  $classes = array(    WATCHDOG_DEBUG    => 'dblog-debug',    WATCHDOG_INFO     => 'dblog-info',    WATCHDOG_NOTICE   => 'dblog-notice',    WATCHDOG_WARNING  => 'dblog-warning',    WATCHDOG_ERROR    => 'dblog-error',    WATCHDOG_CRITICAL => 'dblog-critical',    WATCHDOG_ALERT    => 'dblog-alert',    WATCHDOG_EMERG    => 'dblog-emerg',  );  $output = drupal_get_form('dblog_filter_form');  $header = array(    ' ',    array('data' => t('Type'), 'field' => 'w.type'),    array('data' => t('Date'), 'field' => 'w.wid', 'sort' => 'desc'),    t('Message'),    array('data' => t('User'), 'field' => 'u.name'),    array('data' => t('Operations')),  );  $sql = "SELECT w.wid, w.uid, w.severity, w.type, w.timestamp, w.message, w.variables, w.link, u.name FROM {watchdog} w INNER JOIN {users} u ON w.uid = u.uid";  $tablesort = tablesort_sql($header);  if (!empty($filter['where'])) {    $result = pager_query($sql ." WHERE ". $filter['where'] . $tablesort, 50, 0, NULL, $filter['args']);  }  else {    $result = pager_query($sql . $tablesort, 50);  }  while ($dblog = db_fetch_object($result)) {    $rows[] = array('data' =>      array(        // Cells        $icons[$dblog->severity],        t($dblog->type),        format_date($dblog->timestamp, 'small'),        l(truncate_utf8(_dblog_format_message($dblog), 56, TRUE, TRUE), 'admin/reports/event/'. $dblog->wid, array('html' => TRUE)),        theme('username', $dblog),        $dblog->link,      ),      // Attributes for tr      'class' => "dblog-". preg_replace('/[^a-z]/i', '-', $dblog->type) .' '. $classes[$dblog->severity]    );  }  if (!$rows) {    $rows[] = array(array('data' => t('No log messages available.'), 'colspan' => 6));  }  $output .= theme('table', $header, $rows, array('id' => 'admin-dblog'));  $output .= theme('pager', NULL, 50, 0);  return $output;}/** * Menu callback; generic function to display a page of the most frequent * dblog events of a specified type. */function dblog_top($type) {  $header = array(    array('data' => t('Count'), 'field' => 'count', 'sort' => 'desc'),    array('data' => t('Message'), 'field' => 'message')  );  $result = pager_query("SELECT COUNT(wid) AS count, message, variables FROM {watchdog} WHERE type = '%s' GROUP BY message, variables ". tablesort_sql($header), 30, 0, "SELECT COUNT(DISTINCT(message)) FROM {watchdog} WHERE type = '%s'", $type);  $rows = array();  while ($dblog = db_fetch_object($result)) {    $rows[] = array($dblog->count, truncate_utf8(_dblog_format_message($dblog), 56, TRUE, TRUE));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No log messages available.'), 'colspan' => 2));  }  $output  = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; displays details about a log message. */function dblog_event($id) {  $severity = watchdog_severity_levels();  $output = '';  $result = db_query('SELECT w.*, u.name, u.uid FROM {watchdog} w INNER JOIN {users} u ON w.uid = u.uid WHERE w.wid = %d', $id);  if ($dblog = db_fetch_object($result)) {    $rows = array(      array(        array('data' => t('Type'), 'header' => TRUE),        t($dblog->type),      ),      array(        array('data' => t('Date'), 'header' => TRUE),        format_date($dblog->timestamp, 'large'),      ),      array(        array('data' => t('User'), 'header' => TRUE),        theme('username', $dblog),      ),      array(        array('data' => t('Location'), 'header' => TRUE),        l($dblog->location, $dblog->location),      ),      array(        array('data' => t('Referrer'), 'header' => TRUE),        l($dblog->referer, $dblog->referer),      ),      array(        array('data' => t('Message'), 'header' => TRUE),        _dblog_format_message($dblog),      ),      array(        array('data' => t('Severity'), 'header' => TRUE),        $severity[$dblog->severity],      ),      array(        array('data' => t('Hostname'), 'header' => TRUE),        check_plain($dblog->hostname),      ),      array(        array('data' => t('Operations'), 'header' => TRUE),        $dblog->link,      ),    );    $attributes = array('class' => 'dblog-event');    $output = theme('table', array(), $rows, $attributes);  }  return $output;}/** * Build query for dblog administration filters based on session. */function dblog_build_filter_query() {  if (empty($_SESSION['dblog_overview_filter'])) {    return;  }  $filters = dblog_filters();  // Build query  $where = $args = array();  foreach ($_SESSION['dblog_overview_filter'] as $key => $filter) {    $filter_where = array();    foreach ($filter as $value) {      $filter_where[] = $filters[$key]['where'];      $args[] = $value;    }    if (!empty($filter_where)) {      $where[] = '('. implode(' OR ', $filter_where) .')';    }  }  $where = !empty($where) ? implode(' AND ', $where) : '';  return array(    'where' => $where,    'args' => $args,  );}/** * List dblog administration filters that can be applied. */function dblog_filters() {  $filters = array();  foreach (_dblog_get_message_types() as $type) {    $types[$type] = $type;  }  if (!empty($types)) {    $filters['type'] = array(      'title' => t('Type'),      'where' => "w.type = '%s'",      'options' => $types,    );  }  $filters['severity'] = array(    'title' => t('Severity'),    'where' => 'w.severity = %d',    'options' => watchdog_severity_levels(),  );  return $filters;}/** * Formats a log message for display. * * @param $dblog *   An object with at least the message and variables properties */function _dblog_format_message($dblog) {  // Legacy messages and user specified text  if ($dblog->variables === 'N;') {    return $dblog->message;  }  // Message to translate with injected variables  else {    return t($dblog->message, unserialize($dblog->variables));  }}/** * Return form for dblog administration filters. * * @ingroup forms * @see dblog_filter_form_submit() * @see dblog_filter_form_validate() */function dblog_filter_form() {  $session = &$_SESSION['dblog_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = dblog_filters();  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Filter log messages'),    '#theme' => 'dblog_filters',    '#collapsible' => TRUE,    '#collapsed' => empty($session),  );  foreach ($filters as $key => $filter) {    $form['filters']['status'][$key] = array(      '#title' => $filter['title'],      '#type' => 'select',      '#multiple' => TRUE,      '#size' => 8,      '#options' => $filter['options'],    );    if (!empty($session[$key])) {      $form['filters']['status'][$key]['#default_value'] = $session[$key];    }  }  $form['filters']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Filter'),  );  if (!empty($session)) {    $form['filters']['buttons']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset')    );  }  return $form;}/** * Validate result from dblog administration filter form. */function dblog_filter_form_validate($form, &$form_state) {  if ($form_state['values']['op'] == t('Filter') && empty($form_state['values']['type']) && empty($form_state['values']['severity'])) {    form_set_error('type', t('You must select something to filter by.'));  }}/** * Process result from dblog administration filter form. */function dblog_filter_form_submit($form, &$form_state) {  $op = $form_state['values']['op'];  $filters = dblog_filters();  switch ($op) {    case t('Filter'):      foreach ($filters as $name => $filter) {        if (isset($form_state['values'][$name])) {          $_SESSION['dblog_overview_filter'][$name] = $form_state['values'][$name];        }      }      break;    case t('Reset'):      $_SESSION['dblog_overview_filter'] = array();      break;  }  return 'admin/reports/dblog';}
<?php// $Id$/** * @file * User page callbacks for the translation module. *//** * Overview page for a node's translations. * * @param $node *   Node object. */function translation_node_overview($node) {  if ($node->tnid) {    // Already part of a set, grab that set.    $tnid = $node->tnid;    $translations = translation_node_get_translations($node->tnid);  }  else {    // We have no translation source nid, this could be a new set, emulate that.    $tnid = $node->nid;    $translations = array($node->language => $node);  }  $header = array(t('Language'), t('Title'), t('Status'), t('Operations'));  foreach (language_list() as $language) {    $options = array();    $language_name = $language->name;    if (isset($translations[$language->language])) {      // Existing translation in the translation set: display status.      // We load the full node to check whether the user can edit it.      $translation_node = node_load($translations[$language->language]->nid);      $title = l($translation_node->title, 'node/'. $translation_node->nid);      if (node_access('update', $translation_node)) {        $options[] = l(t('edit'), "node/$translation_node->nid/edit");      }      $status = $translation_node->status ? t('Published') : t('Not published');      $status .= $translation_node->translate ? ' - <span class="marker">'. t('outdated') .'</span>' : '';      if ($translation_node->nid == $tnid) {        $language_name = t('<strong>@language_name</strong> (source)', array('@language_name' => $language_name));      }    }    else {      // No such translation in the set yet: help user to create it.      $title = t('n/a');      if (node_access('create', $node)) {        $options[] = l(t('add translation'), 'node/add/'. str_replace('_', '-', $node->type), array('query' => "translation=$node->nid&language=$language->language"));      }      $status = t('Not translated');    }    $rows[] = array($language_name, $title, $status, implode(" | ", $options));  }  drupal_set_title(t('Translations of %title', array('%title' => $node->title)));  return theme('table', $header, $rows);}
<?php// $Id$?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>">  <head>    <?php print $head ?>    <title><?php print $head_title ?></title>    <?php print $styles ?>    <?php print $scripts ?>    <!--[if lt IE 7]>      <?php print phptemplate_get_ie_styles(); ?>    <![endif]-->  </head>  <body<?php print phptemplate_body_class($left, $right); ?>><!-- Layout -->  <div id="header-region" class="clear-block"><?php print $header; ?></div>    <div id="wrapper">    <div id="container" class="clear-block">      <div id="header">        <div id="logo-floater">        <?php          // Prepare header          $site_fields = array();          if ($site_name) {            $site_fields[] = check_plain($site_name);          }          if ($site_slogan) {            $site_fields[] = check_plain($site_slogan);          }          $site_title = implode(' ', $site_fields);          if ($site_fields) {            $site_fields[0] = '<span>'. $site_fields[0] .'</span>';          }          $site_html = implode(' ', $site_fields);          if ($logo || $site_title) {            print '<h1><a href="'. check_url($front_page) .'" title="'. $site_title .'">';            if ($logo) {              print '<img src="'. check_url($logo) .'" alt="'. $site_title .'" id="logo" />';            }            print $site_html .'</a></h1>';          }        ?>        </div>        <?php if (isset($primary_links)) : ?>          <?php print theme('links', $primary_links, array('class' => 'links primary-links')) ?>        <?php endif; ?>        <?php if (isset($secondary_links)) : ?>          <?php print theme('links', $secondary_links, array('class' => 'links secondary-links')) ?>        <?php endif; ?>      </div> <!-- /header -->      <?php if ($left): ?>        <div id="sidebar-left" class="sidebar">          <?php if ($search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $left ?>        </div>      <?php endif; ?>      <div id="center"><div id="squeeze"><div class="right-corner"><div class="left-corner">          <?php print $breadcrumb; ?>          <?php if ($mission): print '<div id="mission">'. $mission .'</div>'; endif; ?>          <?php if ($tabs): print '<div id="tabs-wrapper" class="clear-block">'; endif; ?>          <?php if ($title): print '<h2'. ($tabs ? ' class="with-tabs"' : '') .'>'. $title .'</h2>'; endif; ?>          <?php if ($tabs): print '<ul class="tabs primary">'. $tabs .'</ul></div>'; endif; ?>          <?php if ($tabs2): print '<ul class="tabs secondary">'. $tabs2 .'</ul>'; endif; ?>          <?php if ($show_messages && $messages): print $messages; endif; ?>          <?php print $help; ?>          <div class="clear-block">            <?php print $content ?>          </div>          <?php print $feed_icons ?>          <div id="footer"><?php print $footer_message . $footer ?></div>      </div></div></div></div> <!-- /.left-corner, /.right-corner, /#squeeze, /#center -->      <?php if ($right): ?>        <div id="sidebar-right" class="sidebar">          <?php if (!$left && $search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $right ?>        </div>      <?php endif; ?>    </div> <!-- /container -->  </div><!-- /layout -->  <?php print $closure ?>  </body></html>
<?php// $Id$/** * @file * The theme system, which controls the output of Drupal. * * The theme system allows for nearly all output of the Drupal system to be * customized by user themes. * * @ingroup themeable *//** * @name Content markers * @{ * Markers used by theme_mark() and node_mark() to designate content. * @see theme_mark(), node_mark() */define('MARK_READ',    0);define('MARK_NEW',     1);define('MARK_UPDATED', 2);/** * @} End of "Content markers". *//** * Initialize the theme system by loading the theme. */function init_theme() {  global $theme, $user, $custom_theme, $theme_key;  // If $theme is already set, assume the others are set, too, and do nothing  if (isset($theme)) {    return;  }  drupal_bootstrap(DRUPAL_BOOTSTRAP_DATABASE);  $themes = list_themes();  // Only select the user selected theme if it is available in the  // list of enabled themes.  $theme = !empty($user->theme) && !empty($themes[$user->theme]->status) ? $user->theme : variable_get('theme_default', 'garland');  // Allow modules to override the present theme... only select custom theme  // if it is available in the list of installed themes.  $theme = $custom_theme && $themes[$custom_theme] ? $custom_theme : $theme;  // Store the identifier for retrieving theme settings with.  $theme_key = $theme;  // Find all our ancestor themes and put them in an array.  $base_theme = array();  $ancestor = $theme;  while ($ancestor && isset($themes[$ancestor]->base_theme)) {    $base_theme[] = $new_base_theme = $themes[$themes[$ancestor]->base_theme];    $ancestor = $themes[$ancestor]->base_theme;  }  _init_theme($themes[$theme], array_reverse($base_theme));}/** * Initialize the theme system given already loaded information. This * function is useful to initialize a theme when no database is present. * * @param $theme *   An object with the following information: *     filename *       The .info file for this theme. The 'path' to *       the theme will be in this file's directory. (Required) *     owner *       The path to the .theme file or the .engine file to load for *       the theme. (Required) *     stylesheet *       The primary stylesheet for the theme. (Optional) *     engine *       The name of theme engine to use. (Optional) * @param $base_theme *    An optional array of objects that represent the 'base theme' if the *    theme is meant to be derivative of another theme. It requires *    the same information as the $theme object. It should be in *    'oldest first' order, meaning the top level of the chain will *    be first. * @param $registry_callback *   The callback to invoke to set the theme registry. */function _init_theme($theme, $base_theme = array(), $registry_callback = '_theme_load_registry') {  global $theme_info, $base_theme_info, $theme_engine, $theme_path;  $theme_info = $theme;  $base_theme_info = $base_theme;  $theme_path = dirname($theme->filename);  // Prepare stylesheets from this theme as well as all ancestor themes.  // We work it this way so that we can have child themes override parent  // theme stylesheets easily.  $final_stylesheets = array();  // Grab stylesheets from base theme  foreach ($base_theme as $base) {    if (!empty($base->stylesheets)) {      foreach ($base->stylesheets as $media => $stylesheets) {        foreach ($stylesheets as $name => $stylesheet) {          $final_stylesheets[$media][$name] = $stylesheet;        }      }    }  }  // Add stylesheets used by this theme.  if (!empty($theme->stylesheets)) {    foreach ($theme->stylesheets as $media => $stylesheets) {      foreach ($stylesheets as $name => $stylesheet) {        $final_stylesheets[$media][$name] = $stylesheet;      }    }  }  // And now add the stylesheets properly  foreach ($final_stylesheets as $media => $stylesheets) {    foreach ($stylesheets as $stylesheet) {      drupal_add_css($stylesheet, 'theme', $media);    }  }  // Do basically the same as the above for scripts  $final_scripts = array();  // Grab scripts from base theme  foreach ($base_theme as $base) {    if (!empty($base->scripts)) {      foreach ($base->scripts as $name => $script) {        $final_scripts[$name] = $script;      }    }  }  // Add scripts used by this theme.  if (!empty($theme->scripts)) {    foreach ($theme->scripts as $name => $script) {      $final_scripts[$name] = $script;    }  }  // Add scripts used by this theme.  foreach ($final_scripts as $script) {    drupal_add_js($script, 'theme');  }  $theme_engine = NULL;  // Initialize the theme.  if (isset($theme->engine)) {    // Include the engine.    include_once './'. $theme->owner;    $theme_engine = $theme->engine;    if (function_exists($theme_engine .'_init')) {      foreach ($base_theme as $base) {        call_user_func($theme_engine .'_init', $base);      }      call_user_func($theme_engine .'_init', $theme);    }  }  else {    // include non-engine theme files    foreach ($base_theme as $base) {      // Include the theme file or the engine.      if (!empty($base->owner)) {        include_once './'. $base->owner;      }    }    // and our theme gets one too.    if (!empty($theme->owner)) {      include_once './'. $theme->owner;    }  }  $registry_callback($theme, $base_theme, $theme_engine);}/** * Retrieve the stored theme registry. If the theme registry is already * in memory it will be returned; otherwise it will attempt to load the * registry from cache. If this fails, it will construct the registry and * cache it. */function theme_get_registry($registry = NULL) {  static $theme_registry = NULL;  if (isset($registry)) {    $theme_registry = $registry;  }  return $theme_registry;}/** * Store the theme registry in memory. */function _theme_set_registry($registry) {  // Pass through for setting of static variable.  return theme_get_registry($registry);}/** * Get the theme_registry cache from the database; if it doesn't exist, build * it. * * @param $theme *   The loaded $theme object. * @param $base_theme *   An array of loaded $theme objects representing the ancestor themes in *   oldest first order. * @param theme_engine *   The name of the theme engine. */function _theme_load_registry($theme, $base_theme = NULL, $theme_engine = NULL) {  // Check the theme registry cache; if it exists, use it.  $cache = cache_get("theme_registry:$theme->name", 'cache');  if (isset($cache->data)) {    $registry = $cache->data;  }  else {    // If not, build one and cache it.    $registry = _theme_build_registry($theme, $base_theme, $theme_engine);    _theme_save_registry($theme, $registry);  }  _theme_set_registry($registry);}/** * Write the theme_registry cache into the database. */function _theme_save_registry($theme, $registry) {  cache_set("theme_registry:$theme->name", $registry);}/** * Force the system to rebuild the theme registry; this should be called * when modules are added to the system, or when a dynamic system needs * to add more theme hooks. */function drupal_rebuild_theme_registry() {  cache_clear_all('theme_registry', 'cache', TRUE);}/** * Process a single invocation of the theme hook. $type will be one * of 'module', 'theme_engine', 'base_theme_engine', 'theme', or 'base_theme' * and it tells us some important information. * * Because $cache is a reference, the cache will be continually * expanded upon; new entries will replace old entries in the * array_merge, but we are careful to ensure some data is carried * forward, such as the arguments a theme hook needs. * * An override flag can be set for preprocess functions. When detected the * cached preprocessors for the hook will not be merged with the newly set. * This can be useful to themes and theme engines by giving them more control * over how and when the preprocess functions are run. */function _theme_process_registry(&$cache, $name, $type, $theme, $path) {  $result = array();  $function = $name .'_theme';  if (function_exists($function)) {    $result = $function($cache, $type, $theme, $path);    foreach ($result as $hook => $info) {      $result[$hook]['type'] = $type;      $result[$hook]['theme path'] = $path;      // if function and file are left out, default to standard naming      // conventions.      if (!isset($info['template']) && !isset($info['function'])) {        $result[$hook]['function'] = ($type == 'module' ? 'theme_' : $name .'_') . $hook;      }      // Make sure include files is set so we don't generate notices later.      if (!isset($info['include files'])) {        $result[$hook]['include files'] = array();      }      // If a path is set in the info, use what was set. Otherwise use the      // default path. This is mostly so system.module can declare theme      // functions on behalf of core .include files.      // All files are included to be safe. Conditionally included      // files can prevent them from getting registered.      if (isset($info['file']) && !isset($info['path'])) {        // First, check to see if the fully qualified file exists.        $filename = './'. $path .'/'. $info['file'];        if (file_exists($filename)) {          require_once $filename;          $result[$hook]['include files'][] = $filename;        }        else {          $filename = './'. $info['file'];          if (file_exists($filename)) {            require_once $filename;            $result[$hook]['include files'][] = $filename;          }        }      }      elseif (isset($info['file']) && isset($info['path'])) {        $filename = './'. $info['path'] .'/'. $info['file'];        if (file_exists($filename)) {          require_once $filename;          $result[$hook]['include files'][] = $filename;        }      }      if (isset($info['template']) && !isset($info['path'])) {        $result[$hook]['template'] = $path .'/'. $info['template'];      }      // If 'arguments' have been defined previously, carry them forward.      // This should happen if a theme overrides a Drupal defined theme      // function, for example.      if (!isset($info['arguments']) && isset($cache[$hook])) {        $result[$hook]['arguments'] = $cache[$hook]['arguments'];      }      // Likewise with theme paths. These are used for template naming suggestions.      // Theme implementations can occur in multiple paths. Suggestions should follow.      if (!isset($info['theme paths']) && isset($cache[$hook])) {        $result[$hook]['theme paths'] = $cache[$hook]['theme paths'];      }      // Check for sub-directories.      $result[$hook]['theme paths'][] = isset($info['path']) ? $info['path'] : $path;      // Check for default _preprocess_ functions. Ensure arrayness.      if (!isset($info['preprocess functions']) || !is_array($info['preprocess functions'])) {        $info['preprocess functions'] = array();        $prefixes = array();        if ($type == 'module') {          // Default preprocessor prefix.          $prefixes[] = 'template';          // Add all modules so they can intervene with their own preprocessors. This allows them          // to provide preprocess functions even if they are not the owner of the current hook.          $prefixes += module_list();        }        elseif ($type == 'theme_engine' || $type == 'base_theme_engine') {          // Theme engines get an extra set that come before the normally named preprocessors.          $prefixes[] = $name .'_engine';          // The theme engine also registers on behalf of the theme. The theme or engine name can be used.          $prefixes[] = $name;          $prefixes[] = $theme;        }        else {          // This applies when the theme manually registers their own preprocessors.          $prefixes[] = $name;        }        foreach ($prefixes as $prefix) {          if (function_exists($prefix .'_preprocess')) {            $info['preprocess functions'][] = $prefix .'_preprocess';          }          if (function_exists($prefix .'_preprocess_'. $hook)) {            $info['preprocess functions'][] = $prefix .'_preprocess_'. $hook;          }          if (!empty($info['original hook']) && function_exists($prefix .'_preprocess_'. $info['original hook'])) {            $info['preprocess functions'][] = $prefix .'_preprocess_'. $info['original hook'];          }        }      }      // Check for the override flag and prevent the cached preprocess functions from being used.      // This allows themes or theme engines to remove preprocessors set earlier in the registry build.      if (!empty($info['override preprocess functions'])) {        // Flag not needed inside the registry.        unset($result[$hook]['override preprocess functions']);      }      elseif (isset($cache[$hook]['preprocess functions']) && is_array($cache[$hook]['preprocess functions'])) {        $info['preprocess functions'] = array_merge($cache[$hook]['preprocess functions'], $info['preprocess functions']);      }      elseif (isset($info['original hook']) && isset($cache[$info['original hook']]['preprocess functions']) && is_array($cache[$info['original hook']]['preprocess functions'])) {        $info['preprocess functions'] = array_merge($cache[$info['original hook']]['preprocess functions'], $info['preprocess functions']);      }      $result[$hook]['preprocess functions'] = $info['preprocess functions'];    }    // Merge the newly created theme hooks into the existing cache.    $cache = array_merge($cache, $result);  }  // Let themes have preprocess functions even if they didn't register a template.  if ($type == 'theme' || $type == 'base_theme') {    foreach ($cache as $hook => $info) {      // Check only if it's a template and not registered by the theme or engine.      if (!empty($info['template']) && empty($result[$hook])) {        if (!isset($info['preprocess functions'])) {          $cache[$hook]['preprocess functions'] = array();        }        if (function_exists($name .'_preprocess')) {          $cache[$hook]['preprocess functions'][] = $name .'_preprocess';        }        if (function_exists($name .'_preprocess_'. $hook)) {          $cache[$hook]['preprocess functions'][] = $name .'_preprocess_'. $hook;        }        // Ensure uniqueness.        $cache[$hook]['preprocess functions'] = array_unique($cache[$hook]['preprocess functions']);      }    }  }}/** * Rebuild the hook theme_registry cache. * * @param $theme *   The loaded $theme object. * @param $base_theme *   An array of loaded $theme objects representing the ancestor themes in *   oldest first order. * @param theme_engine *   The name of the theme engine. */function _theme_build_registry($theme, $base_theme, $theme_engine) {  $cache = array();  // First, process the theme hooks advertised by modules. This will  // serve as the basic registry.  foreach (module_implements('theme') as $module) {    _theme_process_registry($cache, $module, 'module', $module, drupal_get_path('module', $module));  }  // Process each base theme.  foreach ($base_theme as $base) {    // If the base theme uses a theme engine, process its hooks.    $base_path = dirname($base->filename);    if ($theme_engine) {      _theme_process_registry($cache, $theme_engine, 'base_theme_engine', $base->name, $base_path);    }    _theme_process_registry($cache, $base->name, 'base_theme', $base->name, $base_path);  }  // And then the same thing, but for the theme.  if ($theme_engine) {    _theme_process_registry($cache, $theme_engine, 'theme_engine', $theme->name, dirname($theme->filename));  }  // Finally, hooks provided by the theme itself.  _theme_process_registry($cache, $theme->name, 'theme', $theme->name, dirname($theme->filename));  // Let modules alter the registry  drupal_alter('theme_registry', $cache);  return $cache;}/** * Provides a list of currently available themes. * * If the database is active then it will be retrieved from the database. * Otherwise it will retrieve a new list. * * @param $refresh *   Whether to reload the list of themes from the database. * @return *   An array of the currently available themes. */function list_themes($refresh = FALSE) {  static $list = array();  if ($refresh) {    $list = array();  }  if (empty($list)) {    $list = array();    $themes = array();    // Extract from the database only when it is available.    // Also check that the site is not in the middle of an install or update.    if (db_is_active() && !defined('MAINTENANCE_MODE')) {      $result = db_query("SELECT * FROM {system} WHERE type = '%s'", 'theme');      while ($theme = db_fetch_object($result)) {        if (file_exists($theme->filename)) {          $theme->info = unserialize($theme->info);          $themes[] = $theme;        }      }    }    else {      // Scan the installation when the database should not be read.      $themes = _system_theme_data();    }    foreach ($themes as $theme) {      foreach ($theme->info['stylesheets'] as $media => $stylesheets) {        foreach ($stylesheets as $stylesheet => $path) {          $theme->stylesheets[$media][$stylesheet] = $path;        }      }      foreach ($theme->info['scripts'] as $script => $path) {        if (file_exists($path)) {          $theme->scripts[$script] = $path;        }      }      if (isset($theme->info['engine'])) {        $theme->engine = $theme->info['engine'];      }      if (isset($theme->info['base theme'])) {        $theme->base_theme = $theme->info['base theme'];      }      // Status is normally retrieved from the database. Add zero values when      // read from the installation directory to prevent notices.      if (!isset($theme->status)) {        $theme->status = 0;      }      $list[$theme->name] = $theme;    }  }  return $list;}/** * Generate the themed output. * * All requests for theme hooks must go through this function. It examines * the request and routes it to the appropriate theme function. The theme * registry is checked to determine which implementation to use, which may * be a function or a template. * * If the implementation is a function, it is executed and its return value * passed along. * * If the implementation is a template, the arguments are converted to a * $variables array. This array is then modified by the module implementing * the hook, theme engine (if applicable) and the theme. The following * functions may be used to modify the $variables array. They are processed in * this order when available: * * - template_preprocess(&$variables) *   This sets a default set of variables for all template implementations. * * - template_preprocess_HOOK(&$variables) *   This is the first preprocessor called specific to the hook; it should be *   implemented by the module that registers it. * * - MODULE_preprocess(&$variables) *   This will be called for all templates; it should only be used if there *   is a real need. It's purpose is similar to template_preprocess(). * * - MODULE_preprocess_HOOK(&$variables) *   This is for modules that want to alter or provide extra variables for *   theming hooks not registered to itself. For example, if a module named *   "foo" wanted to alter the $submitted variable for the hook "node" a *   preprocess function of foo_preprocess_node() can be created to intercept *   and alter the variable. * * - ENGINE_engine_preprocess(&$variables) *   This function should only be implemented by theme engines and exists *   so that it can set necessary variables for all hooks. * * - ENGINE_engine_preprocess_HOOK(&$variables) *   This is the same as the previous function, but it is called for a single *   theming hook. * * - ENGINE_preprocess(&$variables) *   This is meant to be used by themes that utilize a theme engine. It is *   provided so that the preprocessor is not locked into a specific theme. *   This makes it easy to share and transport code but theme authors must be *   careful to prevent fatal re-declaration errors when using sub-themes that *   have their own preprocessor named exactly the same as its base theme. In *   the default theme engine (PHPTemplate), sub-themes will load their own *   template.php file in addition to the one used for its parent theme. This *   increases the risk for these errors. A good practice is to use the engine *   name for the base theme and the theme name for the sub-themes to minimize *   this possibility. * * - ENGINE_preprocess_HOOK(&$variables) *   The same applies from the previous function, but it is called for a *   specific hook. * * - THEME_preprocess(&$variables) *   These functions are based upon the raw theme; they should primarily be *   used by themes that do not use an engine or by sub-themes. It serves the *   same purpose as ENGINE_preprocess(). * * - THEME_preprocess_HOOK(&$variables) *   The same applies from the previous function, but it is called for a *   specific hook. * * There are two special variables that these hooks can set: *   'template_file' and 'template_files'. These will be merged together *   to form a list of 'suggested' alternate template files to use, in *   reverse order of priority. template_file will always be a higher *   priority than items in template_files. theme() will then look for these *   files, one at a time, and use the first one *   that exists. * @param $hook *   The name of the theme function to call. May be an array, in which *   case the first hook that actually has an implementation registered *   will be used. This can be used to choose 'fallback' theme implementations, *   so that if the specific theme hook isn't implemented anywhere, a more *   generic one will be used. This can allow themes to create specific theme *   implementations for named objects. * @param ... *   Additional arguments to pass along to the theme function. * @return *   An HTML string that generates the themed output. */function theme() {  $args = func_get_args();  $hook = array_shift($args);  static $hooks = NULL;  if (!isset($hooks)) {    init_theme();    $hooks = theme_get_registry();  }  if (is_array($hook)) {    foreach ($hook as $candidate) {      if (isset($hooks[$candidate])) {        break;      }    }    $hook = $candidate;  }  if (!isset($hooks[$hook])) {    return;  }  $info = $hooks[$hook];  global $theme_path;  $temp = $theme_path;  // point path_to_theme() to the currently used theme path:  $theme_path = $hooks[$hook]['theme path'];  // Include a file if the theme function or preprocess function is held elsewhere.  if (!empty($info['include files'])) {    foreach ($info['include files'] as $include_file) {      include_once($include_file);    }  }  // Handle compatibility with theme_registry_alters to prevent failures.  if (!empty($info['file'])) {    static $included_files = array();    $include_file = $info['file'];    if (!empty($info['path'])) {      $include_file = $info['path'] .'/'. $include_file;    }    if (empty($included_files[$include_file])) {      // Statically cache files we've already tried to include so we don't      // run unnecessary file_exists calls.      $included_files[$include_file] = TRUE;      if (file_exists('./'. $include_file)) {        include_once('./'. $include_file);      }    }  }  if (isset($info['function'])) {    // The theme call is a function.    $output = call_user_func_array($info['function'], $args);  }  else {    // The theme call is a template.    $variables = array(      'template_files' => array()    );    if (!empty($info['arguments'])) {      $count = 0;      foreach ($info['arguments'] as $name => $default) {        $variables[$name] = isset($args[$count]) ? $args[$count] : $default;        $count++;      }    }    // default render function and extension.    $render_function = 'theme_render_template';    $extension = '.tpl.php';    // Run through the theme engine variables, if necessary    global $theme_engine;    if (isset($theme_engine)) {      // If theme or theme engine is implementing this, it may have      // a different extension and a different renderer.      if ($hooks[$hook]['type'] != 'module') {        if (function_exists($theme_engine .'_render_template')) {          $render_function = $theme_engine .'_render_template';        }        $extension_function = $theme_engine .'_extension';        if (function_exists($extension_function)) {          $extension = $extension_function();        }      }    }    if (isset($info['preprocess functions']) && is_array($info['preprocess functions'])) {      // This construct ensures that we can keep a reference through      // call_user_func_array.      $args = array(&$variables, $hook);      foreach ($info['preprocess functions'] as $preprocess_function) {        if (function_exists($preprocess_function)) {          call_user_func_array($preprocess_function, $args);        }      }    }    // Get suggestions for alternate templates out of the variables    // that were set. This lets us dynamically choose a template    // from a list. The order is FILO, so this array is ordered from    // least appropriate first to most appropriate last.    $suggestions = array();    if (isset($variables['template_files'])) {      $suggestions = $variables['template_files'];    }    if (isset($variables['template_file'])) {      $suggestions[] = $variables['template_file'];    }    if ($suggestions) {      $template_file = drupal_discover_template($info['theme paths'], $suggestions, $extension);    }    if (empty($template_file)) {      $template_file = $hooks[$hook]['template'] . $extension;      if (isset($hooks[$hook]['path'])) {        $template_file = $hooks[$hook]['path'] .'/'. $template_file;      }    }    $output = $render_function($template_file, $variables);  }  // restore path_to_theme()  $theme_path = $temp;  // Add final markup to the full page.  if ($hook == 'page' || $hook == 'book_export_html') {    $output = drupal_final_markup($output);  }  return $output;}/** * Choose which template file to actually render. These are all suggested * templates from themes and modules. Theming implementations can occur on * multiple levels. All paths are checked to account for this. */function drupal_discover_template($paths, $suggestions, $extension = '.tpl.php') {  global $theme_engine;  // Remove slashes or null to prevent files from being included from  // an unexpected location (especially on Windows servers).  $extension = str_replace(array("/", "\\", "\0"), '', $extension);  // Loop through all paths and suggestions in FIFO order.  $suggestions = array_reverse($suggestions);  $paths = array_reverse($paths);  foreach ($suggestions as $suggestion) {    if (!empty($suggestion)) {      $suggestion = str_replace(array("/", "\\", "\0"), '', $suggestion);      foreach ($paths as $path) {        if (file_exists($file = $path .'/'. $suggestion . $extension)) {          return $file;        }      }    }  }}/** * Return the path to the current themed element. * * It can point to the active theme or the module handling a themed implementation. * For example, when invoked within the scope of a theming call it will depend * on where the theming function is handled. If implemented from a module, it * will point to the module. If implemented from the active theme, it will point * to the active theme. When called outside the scope of a theming call, it will * always point to the active theme. */function path_to_theme() {  global $theme_path;  if (!isset($theme_path)) {    init_theme();  }  return $theme_path;}/** * Find overridden theme functions. Called by themes and/or theme engines to * easily discover theme functions. * * @param $cache *   The existing cache of theme hooks to test against. * @param $prefixes *   An array of prefixes to test, in reverse order of importance. * * @return $templates *   The functions found, suitable for returning from hook_theme; */function drupal_find_theme_functions($cache, $prefixes) {  $templates = array();  $functions = get_defined_functions();  foreach ($cache as $hook => $info) {    foreach ($prefixes as $prefix) {      if (!empty($info['pattern'])) {        $matches = preg_grep('/^'. $prefix .'_'. $info['pattern'] .'/', $functions['user']);        if ($matches) {          foreach ($matches as $match) {            $new_hook = str_replace($prefix .'_', '', $match);            $templates[$new_hook] = array(              'function' => $match,              'arguments' => $info['arguments'],              'original hook' => $hook,              'include files' => $info['include files'],            );          }        }      }      if (function_exists($prefix .'_'. $hook)) {        $templates[$hook] = array(          'function' => $prefix .'_'. $hook,          'include files' => $info['include files'],        );        // Ensure that the pattern is maintained from base themes to its sub-themes.        // Each sub-theme will have their functions scanned so the pattern must be        // held for subsequent runs.        if (isset($info['pattern'])) {          $templates[$hook]['pattern'] = $info['pattern'];        }        // Also ensure that the 'file' property is maintained, because it probably        // contains the preprocess.      }    }  }  return $templates;}/** * Find overridden theme templates. Called by themes and/or theme engines to * easily discover templates. * * @param $cache *   The existing cache of theme hooks to test against. * @param $extension *   The extension that these templates will have. * @param $path *   The path to search. */function drupal_find_theme_templates($cache, $extension, $path) {  $templates = array();  // Collect paths to all sub-themes grouped by base themes. These will be  // used for filtering. This allows base themes to have sub-themes in its  // folder hierarchy without affecting the base themes template discovery.  $theme_paths = array();  foreach (list_themes() as $theme_info) {    if (!empty($theme_info->base_theme)) {      $theme_paths[$theme_info->base_theme][$theme_info->name] = dirname($theme_info->filename);    }  }  foreach ($theme_paths as $basetheme => $subthemes) {    foreach ($subthemes as $subtheme => $subtheme_path) {      if (isset($theme_paths[$subtheme])) {        $theme_paths[$basetheme] = array_merge($theme_paths[$basetheme], $theme_paths[$subtheme]);      }    }  }  global $theme;  $subtheme_paths = isset($theme_paths[$theme]) ? $theme_paths[$theme] : array();  // Escape the periods in the extension.  $regex = str_replace('.', '\.', $extension) .'$';  // Because drupal_system_listing works the way it does, we check for real  // templates separately from checking for patterns.  $files = drupal_system_listing($regex, $path, 'name', 0);  foreach ($files as $template => $file) {    // Ignore sub-theme templates for the current theme.    if (strpos($file->filename, str_replace($subtheme_paths, '', $file->filename)) !== 0) {      continue;    }    // Chop off the remaining extensions if there are any. $template already    // has the rightmost extension removed, but there might still be more,    // such as with .tpl.php, which still has .tpl in $template at this point.    if (($pos = strpos($template, '.')) !== FALSE) {      $template = substr($template, 0, $pos);    }    // Transform - in filenames to _ to match function naming scheme    // for the purposes of searching.    $hook = strtr($template, '-', '_');    if (isset($cache[$hook])) {      $templates[$hook] = array(        'template' => $template,        'path' => dirname($file->filename),        'include files' => $cache[$hook]['include files'],      );    }    // Ensure that the pattern is maintained from base themes to its sub-themes.    // Each sub-theme will have their templates scanned so the pattern must be    // held for subsequent runs.    if (isset($cache[$hook]['pattern'])) {      $templates[$hook]['pattern'] = $cache[$hook]['pattern'];    }  }  $patterns = array_keys($files);  foreach ($cache as $hook => $info) {    if (!empty($info['pattern'])) {      // Transform _ in pattern to - to match file naming scheme      // for the purposes of searching.      $pattern = strtr($info['pattern'], '_', '-');      $matches = preg_grep('/^'. $pattern .'/', $patterns);      if ($matches) {        foreach ($matches as $match) {          $file = substr($match, 0, strpos($match, '.'));          // Put the underscores back in for the hook name and register this pattern.          $templates[strtr($file, '-', '_')] = array(            'template' => $file,            'path' => dirname($files[$match]->filename),            'arguments' => $info['arguments'],            'original hook' => $hook,            'include files' => $info['include files'],          );        }      }    }  }  return $templates;}/** * Retrieve an associative array containing the settings for a theme. * * The final settings are arrived at by merging the default settings, * the site-wide settings, and the settings defined for the specific theme. * If no $key was specified, only the site-wide theme defaults are retrieved. * * The default values for each of settings are also defined in this function. * To add new settings, add their default values here, and then add form elements * to system_theme_settings() in system.module. * * @param $key *  The template/style value for a given theme. * * @return *   An associative array containing theme settings. */function theme_get_settings($key = NULL) {  $defaults = array(    'mission'                       =>  '',    'default_logo'                  =>  1,    'logo_path'                     =>  '',    'default_favicon'               =>  1,    'favicon_path'                  =>  '',    'primary_links'                 =>  1,    'secondary_links'               =>  1,    'toggle_logo'                   =>  1,    'toggle_favicon'                =>  1,    'toggle_name'                   =>  1,    'toggle_search'                 =>  1,    'toggle_slogan'                 =>  0,    'toggle_mission'                =>  1,    'toggle_node_user_picture'      =>  0,    'toggle_comment_user_picture'   =>  0,    'toggle_primary_links'          =>  1,    'toggle_secondary_links'        =>  1,  );  if (module_exists('node')) {    foreach (node_get_types() as $type => $name) {      $defaults['toggle_node_info_'. $type] = 1;    }  }  $settings = array_merge($defaults, variable_get('theme_settings', array()));  if ($key) {    $settings = array_merge($settings, variable_get(str_replace('/', '_', 'theme_'. $key .'_settings'), array()));  }  // Only offer search box if search.module is enabled.  if (!module_exists('search') || !user_access('search content')) {    $settings['toggle_search'] = 0;  }  return $settings;}/** * Retrieve a setting for the current theme. * This function is designed for use from within themes & engines * to determine theme settings made in the admin interface. * * Caches values for speed (use $refresh = TRUE to refresh cache) * * @param $setting_name *  The name of the setting to be retrieved. * * @param $refresh *  Whether to reload the cache of settings. * * @return *   The value of the requested setting, NULL if the setting does not exist. */function theme_get_setting($setting_name, $refresh = FALSE) {  global $theme_key;  static $settings;  if (empty($settings) || $refresh) {    $settings = theme_get_settings($theme_key);    $themes = list_themes();    $theme_object = $themes[$theme_key];    if ($settings['mission'] == '') {      $settings['mission'] = variable_get('site_mission', '');    }    if (!$settings['toggle_mission']) {      $settings['mission'] = '';    }    if ($settings['toggle_logo']) {      if ($settings['default_logo']) {        $settings['logo'] = base_path() . dirname($theme_object->filename) .'/logo.png';      }      elseif ($settings['logo_path']) {        $settings['logo'] = base_path() . $settings['logo_path'];      }    }    if ($settings['toggle_favicon']) {      if ($settings['default_favicon']) {        if (file_exists($favicon = dirname($theme_object->filename) .'/favicon.ico')) {          $settings['favicon'] = base_path() . $favicon;        }        else {          $settings['favicon'] = base_path() .'misc/favicon.ico';        }      }      elseif ($settings['favicon_path']) {        $settings['favicon'] = base_path() . $settings['favicon_path'];      }      else {        $settings['toggle_favicon'] = FALSE;      }    }  }  return isset($settings[$setting_name]) ? $settings[$setting_name] : NULL;}/** * Render a system default template, which is essentially a PHP template. * * @param $template_file *   The filename of the template to render. Note that this will overwrite *   anything stored in $variables['template_file'] if using a preprocess hook. * @param $variables *   A keyed array of variables that will appear in the output. * * @return *   The output generated by the template. */function theme_render_template($template_file, $variables) {  extract($variables, EXTR_SKIP);  // Extract the variables to a local namespace  ob_start();                      // Start output buffering  include "./$template_file";      // Include the template file  $contents = ob_get_contents();   // Get the contents of the buffer  ob_end_clean();                  // End buffering and discard  return $contents;                // Return the contents}/** * @defgroup themeable Default theme implementations * @{ * Functions and templates that present output to the user, and can be * implemented by themes. * * Drupal's presentation layer is a pluggable system known as the theme * layer. Each theme can take control over most of Drupal's output, and * has complete control over the CSS. * * Inside Drupal, the theme layer is utilized by the use of the theme() * function, which is passed the name of a component (the theme hook) * and several arguments. For example, theme('table', $header, $rows); * Additionally, the theme() function can take an array of theme * hooks, which can be used to provide 'fallback' implementations to * allow for more specific control of output. For example, the function: * theme(array('table__foo', 'table'), $header, $rows) would look to see if * 'table__foo' is registered anywhere; if it is not, it would 'fall back' * to the generic 'table' implementation. This can be used to attach specific * theme functions to named objects, allowing the themer more control over * specific types of output. * * As of Drupal 6, every theme hook is required to be registered by the * module that owns it, so that Drupal can tell what to do with it and * to make it simple for themes to identify and override the behavior * for these calls. * * The theme hooks are registered via hook_theme(), which returns an * array of arrays with information about the hook. It describes the * arguments the function or template will need, and provides * defaults for the template in case they are not filled in. If the default * implementation is a function, by convention it is named theme_HOOK(). * * Each module should provide a default implementation for theme_hooks that * it registers. This implementation may be either a function or a template; * if it is a function it must be specified via hook_theme(). By convention, * default implementations of theme hooks are named theme_HOOK. Default * template implementations are stored in the module directory. * * Drupal's default template renderer is a simple PHP parsing engine that * includes the template and stores the output. Drupal's theme engines * can provide alternate template engines, such as XTemplate, Smarty and * PHPTal. The most common template engine is PHPTemplate (included with * Drupal and implemented in phptemplate.engine, which uses Drupal's default * template renderer. * * In order to create theme-specific implementations of these hooks, * themes can implement their own version of theme hooks, either as functions * or templates. These implementations will be used instead of the default * implementation. If using a pure .theme without an engine, the .theme is * required to implement its own version of hook_theme() to tell Drupal what * it is implementing; themes utilizing an engine will have their well-named * theming functions automatically registered for them. While this can vary * based upon the theme engine, the standard set by phptemplate is that theme * functions should be named either phptemplate_HOOK or THEMENAME_HOOK. For * example, for Drupal's default theme (Garland) to implement the 'table' hook, * the phptemplate.engine would find phptemplate_table() or garland_table(). * The ENGINE_HOOK() syntax is preferred, as this can be used by sub-themes * (which are themes that share code but use different stylesheets). * * The theme system is described and defined in theme.inc. * * @see theme() * @see hook_theme() *//** * Formats text for emphasized display in a placeholder inside a sentence. * Used automatically by t(). * * @param $text *   The text to format (plain-text). * @return *   The formatted text (html). */function theme_placeholder($text) {  return '<em>'. check_plain($text) .'</em>';}/** * Return a themed set of status and/or error messages. The messages are grouped * by type. * * @param $display *   (optional) Set to 'status' or 'error' to display only messages of that type. * * @return *   A string containing the messages. */function theme_status_messages($display = NULL) {  $output = '';  foreach (drupal_get_messages($display) as $type => $messages) {    $output .= "<div class=\"messages $type\">\n";    if (count($messages) > 1) {      $output .= " <ul>\n";      foreach ($messages as $message) {        $output .= '  <li>'. $message ."</li>\n";      }      $output .= " </ul>\n";    }    else {      $output .= $messages[0];    }    $output .= "</div>\n";  }  return $output;}/** * Return a themed set of links. * * @param $links *   A keyed array of links to be themed. * @param $attributes *   A keyed array of attributes * @return *   A string containing an unordered list of links. */function theme_links($links, $attributes = array('class' => 'links')) {  global $language;  $output = '';  if (count($links) > 0) {    $output = '<ul'. drupal_attributes($attributes) .'>';    $num_links = count($links);    $i = 1;    foreach ($links as $key => $link) {      $class = $key;      // Add first, last and active classes to the list of links to help out themers.      if ($i == 1) {        $class .= ' first';      }      if ($i == $num_links) {        $class .= ' last';      }      if (isset($link['href']) && ($link['href'] == $_GET['q'] || ($link['href'] == '<front>' && drupal_is_front_page()))          && (empty($link['language']) || $link['language']->language == $language->language)) {        $class .= ' active';      }      $output .= '<li'. drupal_attributes(array('class' => $class)) .'>';      if (isset($link['href'])) {        // Pass in $link as $options, they share the same keys.        $output .= l($link['title'], $link['href'], $link);      }      else if (!empty($link['title'])) {        // Some links are actually not links, but we wrap these in <span> for adding title and class attributes        if (empty($link['html'])) {          $link['title'] = check_plain($link['title']);        }        $span_attributes = '';        if (isset($link['attributes'])) {          $span_attributes = drupal_attributes($link['attributes']);        }        $output .= '<span'. $span_attributes .'>'. $link['title'] .'</span>';      }      $i++;      $output .= "</li>\n";    }    $output .= '</ul>';  }  return $output;}/** * Return a themed image. * * @param $path *   Either the path of the image file (relative to base_path()) or a full URL. * @param $alt *   The alternative text for text-based browsers. * @param $title *   The title text is displayed when the image is hovered in some popular browsers. * @param $attributes *   Associative array of attributes to be placed in the img tag. * @param $getsize *   If set to TRUE, the image's dimension are fetched and added as width/height attributes. * @return *   A string containing the image tag. */function theme_image($path, $alt = '', $title = '', $attributes = NULL, $getsize = TRUE) {  if (!$getsize || (is_file($path) && (list($width, $height, $type, $image_attributes) = @getimagesize($path)))) {    $attributes = drupal_attributes($attributes);    $url = (url($path) == $path) ? $path : (base_path() . $path);    return '<img src="'. check_url($url) .'" alt="'. check_plain($alt) .'" title="'. check_plain($title) .'" '. (isset($image_attributes) ? $image_attributes : '') . $attributes .' />';  }}/** * Return a themed breadcrumb trail. * * @param $breadcrumb *   An array containing the breadcrumb links. * @return a string containing the breadcrumb output. */function theme_breadcrumb($breadcrumb) {  if (!empty($breadcrumb)) {    return '<div class="breadcrumb">'. implode('  ', $breadcrumb) .'</div>';  }}/** * Return a themed help message. * * @return a string containing the helptext for the current page. */function theme_help() {  if ($help = menu_get_active_help()) {    return '<div class="help">'. $help .'</div>';  }}/** * Return a themed submenu, typically displayed under the tabs. * * @param $links *   An array of links. */function theme_submenu($links) {  return '<div class="submenu">'. implode(' | ', $links) .'</div>';}/** * Return a themed table. * * @param $header *   An array containing the table headers. Each element of the array can be *   either a localized string or an associative array with the following keys: *   - "data": The localized title of the table column. *   - "field": The database field represented in the table column (required if *     user is to be able to sort on this column). *   - "sort": A default sort order for this column ("asc" or "desc"). *   - Any HTML attributes, such as "colspan", to apply to the column header cell. * @param $rows *   An array of table rows. Every row is an array of cells, or an associative *   array with the following keys: *   - "data": an array of cells *   - Any HTML attributes, such as "class", to apply to the table row. * *   Each cell can be either a string or an associative array with the following keys: *   - "data": The string to display in the table cell. *   - "header": Indicates this cell is a header. *   - Any HTML attributes, such as "colspan", to apply to the table cell. * *   Here's an example for $rows: *   @code *   $rows = array( *     // Simple row *     array( *       'Cell 1', 'Cell 2', 'Cell 3' *     ), *     // Row with attributes on the row and some of its cells. *     array( *       'data' => array('Cell 1', array('data' => 'Cell 2', 'colspan' => 2)), 'class' => 'funky' *     ) *   ); *   @endcode * * @param $attributes *   An array of HTML attributes to apply to the table tag. * @param $caption *   A localized string to use for the <caption> tag. * @return *   An HTML string representing the table. */function theme_table($header, $rows, $attributes = array(), $caption = NULL) {  // Add sticky headers, if applicable.  if (count($header)) {    drupal_add_js('misc/tableheader.js');    // Add 'sticky-enabled' class to the table to identify it for JS.    // This is needed to target tables constructed by this function.    $attributes['class'] = empty($attributes['class']) ? 'sticky-enabled' : ($attributes['class'] .' sticky-enabled');  }  $output = '<table'. drupal_attributes($attributes) .">\n";  if (isset($caption)) {    $output .= '<caption>'. $caption ."</caption>\n";  }  // Format the table header:  if (count($header)) {    $ts = tablesort_init($header);    // HTML requires that the thead tag has tr tags in it followed by tbody    // tags. Using ternary operator to check and see if we have any rows.    $output .= (count($rows) ? ' <thead><tr>' : ' <tr>');    foreach ($header as $cell) {      $cell = tablesort_header($cell, $header, $ts);      $output .= _theme_table_cell($cell, TRUE);    }    // Using ternary operator to close the tags based on whether or not there are rows    $output .= (count($rows) ? " </tr></thead>\n" : "</tr>\n");  }  else {    $ts = array();  }  // Format the table rows:  if (count($rows)) {    $output .= "<tbody>\n";    $flip = array('even' => 'odd', 'odd' => 'even');    $class = 'even';    foreach ($rows as $number => $row) {      $attributes = array();      // Check if we're dealing with a simple or complex row      if (isset($row['data'])) {        foreach ($row as $key => $value) {          if ($key == 'data') {            $cells = $value;          }          else {            $attributes[$key] = $value;          }        }      }      else {        $cells = $row;      }      if (count($cells)) {        // Add odd/even class        $class = $flip[$class];        if (isset($attributes['class'])) {          $attributes['class'] .= ' '. $class;        }        else {          $attributes['class'] = $class;        }        // Build row        $output .= ' <tr'. drupal_attributes($attributes) .'>';        $i = 0;        foreach ($cells as $cell) {          $cell = tablesort_cell($cell, $header, $ts, $i++);          $output .= _theme_table_cell($cell);        }        $output .= " </tr>\n";      }    }    $output .= "</tbody>\n";  }  $output .= "</table>\n";  return $output;}/** * Returns a header cell for tables that have a select all functionality. */function theme_table_select_header_cell() {  drupal_add_js('misc/tableselect.js');  return array('class' => 'select-all');}/** * Return a themed sort icon. * * @param $style *   Set to either asc or desc. This sets which icon to show. * @return *   A themed sort icon. */function theme_tablesort_indicator($style) {  if ($style == "asc") {    return theme('image', 'misc/arrow-asc.png', t('sort icon'), t('sort ascending'));  }  else {    return theme('image', 'misc/arrow-desc.png', t('sort icon'), t('sort descending'));  }}/** * Return a themed box. * * @param $title *   The subject of the box. * @param $content *   The content of the box. * @param $region *   The region in which the box is displayed. * @return *   A string containing the box output. */function theme_box($title, $content, $region = 'main') {  $output = '<h2 class="title">'. $title .'</h2><div>'. $content .'</div>';  return $output;}/** * Return a themed marker, useful for marking new or updated * content. * * @param $type *   Number representing the marker type to display * @see MARK_NEW, MARK_UPDATED, MARK_READ * @return *   A string containing the marker. */function theme_mark($type = MARK_NEW) {  global $user;  if ($user->uid) {    if ($type == MARK_NEW) {      return ' <span class="marker">'. t('new') .'</span>';    }    else if ($type == MARK_UPDATED) {      return ' <span class="marker">'. t('updated') .'</span>';    }  }}/** * Return a themed list of items. * * @param $items *   An array of items to be displayed in the list. If an item is a string, *   then it is used as is. If an item is an array, then the "data" element of *   the array is used as the contents of the list item. If an item is an array *   with a "children" element, those children are displayed in a nested list. *   All other elements are treated as attributes of the list item element. * @param $title *   The title of the list. * @param $type *   The type of list to return (e.g. "ul", "ol") * @param $attributes *   The attributes applied to the list element. * @return *   A string containing the list output. */function theme_item_list($items = array(), $title = NULL, $type = 'ul', $attributes = NULL) {  $output = '<div class="item-list">';  if (isset($title)) {    $output .= '<h3>'. $title .'</h3>';  }  if (!empty($items)) {    $output .= "<$type". drupal_attributes($attributes) .'>';    $num_items = count($items);    foreach ($items as $i => $item) {      $attributes = array();      $children = array();      if (is_array($item)) {        foreach ($item as $key => $value) {          if ($key == 'data') {            $data = $value;          }          elseif ($key == 'children') {            $children = $value;          }          else {            $attributes[$key] = $value;          }        }      }      else {        $data = $item;      }      if (count($children) > 0) {        $data .= theme_item_list($children, NULL, $type, $attributes); // Render nested list      }      if ($i == 0) {        $attributes['class'] = empty($attributes['class']) ? 'first' : ($attributes['class'] .' first');      }      if ($i == $num_items - 1) {        $attributes['class'] = empty($attributes['class']) ? 'last' : ($attributes['class'] .' last');      }      $output .= '<li'. drupal_attributes($attributes) .'>'. $data ."</li>\n";    }    $output .= "</$type>";  }  $output .= '</div>';  return $output;}/** * Returns code that emits the 'more help'-link. */function theme_more_help_link($url) {  return '<div class="more-help-link">'. t('[<a href="@link">more help...</a>]', array('@link' => check_url($url))) .'</div>';}/** * Return code that emits an XML icon. * * For most use cases, this function has been superseded by theme_feed_icon(). * * @see theme_feed_icon() * @param $url *   The url of the feed. */function theme_xml_icon($url) {  if ($image = theme('image', 'misc/xml.png', t('XML feed'), t('XML feed'))) {    return '<a href="'. check_url($url) .'" class="xml-icon">'. $image .'</a>';  }}/** * Return code that emits an feed icon. * * @param $url *   The url of the feed. * @param $title *   A descriptive title of the feed.  */function theme_feed_icon($url, $title) {  if ($image = theme('image', 'misc/feed.png', t('Syndicate content'), $title)) {    return '<a href="'. check_url($url) .'" class="feed-icon">'. $image .'</a>';  }}/** * Returns code that emits the 'more' link used on blocks. * * @param $url *   The url of the main page * @param $title *   A descriptive verb for the link, like 'Read more' */function theme_more_link($url, $title) {  return '<div class="more-link">'. t('<a href="@link" title="@title">more</a>', array('@link' => check_url($url), '@title' => $title)) .'</div>';}/** * Execute hook_footer() which is run at the end of the page right before the * close of the body tag. * * @param $main (optional) *   Whether the current page is the front page of the site. * @return *   A string containing the results of the hook_footer() calls. */function theme_closure($main = 0) {  $footer = module_invoke_all('footer', $main);  return implode("\n", $footer) . drupal_get_js('footer');}/** * Return a set of blocks available for the current user. * * @param $region *   Which set of blocks to retrieve. * @return *   A string containing the themed blocks for this region. */function theme_blocks($region) {  $output = '';  if ($list = block_list($region)) {    foreach ($list as $key => $block) {      // $key == <i>module</i>_<i>delta</i>      $output .= theme('block', $block);    }  }  // Add any content assigned to this region through drupal_set_content() calls.  $output .= drupal_get_content($region);  return $output;}/** * Format a username. * * @param $object *   The user object to format, usually returned from user_load(). * @return *   A string containing an HTML link to the user's page if the passed object *   suggests that this is a site user. Otherwise, only the username is returned. */function theme_username($object) {  if ($object->uid && $object->name) {    // Shorten the name when it is too long or it will break many tables.    if (drupal_strlen($object->name) > 20) {      $name = drupal_substr($object->name, 0, 15) .'...';    }    else {      $name = $object->name;    }    if (user_access('access user profiles')) {      $output = l($name, 'user/'. $object->uid, array('attributes' => array('title' => t('View user profile.'))));    }    else {      $output = check_plain($name);    }  }  else if ($object->name) {    // Sometimes modules display content composed by people who are    // not registered members of the site (e.g. mailing list or news    // aggregator modules). This clause enables modules to display    // the true author of the content.    if (!empty($object->homepage)) {      $output = l($object->name, $object->homepage, array('attributes' => array('rel' => 'nofollow')));    }    else {      $output = check_plain($object->name);    }    $output .= ' ('. t('not verified') .')';  }  else {    $output = check_plain(variable_get('anonymous', t('Anonymous')));  }  return $output;}/** * Return a themed progress bar. * * @param $percent *   The percentage of the progress. * @param $message *   A string containing information to be displayed. * @return *   A themed HTML string representing the progress bar. */function theme_progress_bar($percent, $message) {  $output = '<div id="progress" class="progress">';  $output .= '<div class="bar"><div class="filled" style="width: '. $percent .'%"></div></div>';  $output .= '<div class="percentage">'. $percent .'%</div>';  $output .= '<div class="message">'. $message .'</div>';  $output .= '</div>';  return $output;}/** * Create a standard indentation div. Used for drag and drop tables. * * @param $size *   Optional. The number of indentations to create. * @return *   A string containing indentations. */function theme_indentation($size = 1) {  $output = '';  for ($n = 0; $n < $size; $n++) {    $output .= '<div class="indentation">&nbsp;</div>';  }  return $output;}/** * @} End of "defgroup themeable". */function _theme_table_cell($cell, $header = FALSE) {  $attributes = '';  if (is_array($cell)) {    $data = isset($cell['data']) ? $cell['data'] : '';    $header |= isset($cell['header']);    unset($cell['data']);    unset($cell['header']);    $attributes = drupal_attributes($cell);  }  else {    $data = $cell;  }  if ($header) {    $output = "<th$attributes>$data</th>";  }  else {    $output = "<td$attributes>$data</td>";  }  return $output;}/** * Adds a default set of helper variables for preprocess functions and * templates. This comes in before any other preprocess function which makes * it possible to be used in default theme implementations (non-overriden * theme functions). */function template_preprocess(&$variables, $hook) {  global $user;  static $count = array();  // Track run count for each hook to provide zebra striping.  // See "template_preprocess_block()" which provides the same feature specific to blocks.  $count[$hook] = isset($count[$hook]) && is_int($count[$hook]) ? $count[$hook] : 1;  $variables['zebra'] = ($count[$hook] % 2) ? 'odd' : 'even';  $variables['id'] = $count[$hook]++;  // Tell all templates where they are located.  $variables['directory'] = path_to_theme();  // Set default variables that depend on the database.  $variables['is_admin']            = FALSE;  $variables['is_front']            = FALSE;  $variables['logged_in']           = FALSE;  if ($variables['db_is_active'] = db_is_active()  && !defined('MAINTENANCE_MODE')) {    // Check for administrators.    if (user_access('access administration pages')) {      $variables['is_admin'] = TRUE;    }    // Flag front page status.    $variables['is_front'] = drupal_is_front_page();    // Tell all templates by which kind of user they're viewed.    $variables['logged_in'] = ($user->uid > 0);    // Provide user object to all templates    $variables['user'] = $user;  }}/** * Process variables for page.tpl.php * * Most themes utilize their own copy of page.tpl.php. The default is located * inside "modules/system/page.tpl.php". Look in there for the full list of * variables. * * Uses the arg() function to generate a series of page template suggestions * based on the current path. * * Any changes to variables in this preprocessor should also be changed inside * template_preprocess_maintenance_page() to keep all them consistent. * * The $variables array contains the following arguments: * - $content * - $show_blocks * * @see page.tpl.php */function template_preprocess_page(&$variables) {  // Add favicon  if (theme_get_setting('toggle_favicon')) {    drupal_set_html_head('<link rel="shortcut icon" href="'. check_url(theme_get_setting('favicon')) .'" type="image/x-icon" />');  }  global $theme;  // Populate all block regions.  $regions = system_region_list($theme);  // Load all region content assigned via blocks.  foreach (array_keys($regions) as $region) {    // Prevent left and right regions from rendering blocks when 'show_blocks' == FALSE.    if (!(!$variables['show_blocks'] && ($region == 'left' || $region == 'right'))) {      $blocks = theme('blocks', $region);    }    else {      $blocks = '';    }    // Assign region to a region variable.    isset($variables[$region]) ? $variables[$region] .= $blocks : $variables[$region] = $blocks;  }  // Set up layout variable.  $variables['layout'] = 'none';  if (!empty($variables['left'])) {    $variables['layout'] = 'left';  }  if (!empty($variables['right'])) {    $variables['layout'] = ($variables['layout'] == 'left') ? 'both' : 'right';  }  // Set mission when viewing the frontpage.  if (drupal_is_front_page()) {    $mission = filter_xss_admin(theme_get_setting('mission'));  }  // Construct page title  if (drupal_get_title()) {    $head_title = array(strip_tags(drupal_get_title()), variable_get('site_name', 'Drupal'));  }  else {    $head_title = array(variable_get('site_name', 'Drupal'));    if (variable_get('site_slogan', '')) {      $head_title[] = variable_get('site_slogan', '');    }  }  $variables['head_title']        = implode(' | ', $head_title);  $variables['base_path']         = base_path();  $variables['front_page']        = url();  $variables['breadcrumb']        = theme('breadcrumb', drupal_get_breadcrumb());  $variables['feed_icons']        = drupal_get_feeds();  $variables['footer_message']    = filter_xss_admin(variable_get('site_footer', FALSE));  $variables['head']              = drupal_get_html_head();  $variables['help']              = theme('help');  $variables['language']          = $GLOBALS['language'];  $variables['language']->dir     = $GLOBALS['language']->direction ? 'rtl' : 'ltr';  $variables['logo']              = theme_get_setting('logo');  $variables['messages']          = $variables['show_messages'] ? theme('status_messages') : '';  $variables['mission']           = isset($mission) ? $mission : '';  $variables['primary_links']     = theme_get_setting('toggle_primary_links') ? menu_primary_links() : array();  $variables['secondary_links']   = theme_get_setting('toggle_secondary_links') ? menu_secondary_links() : array();  $variables['search_box']        = (theme_get_setting('toggle_search') ? drupal_get_form('search_theme_form') : '');  $variables['site_name']         = (theme_get_setting('toggle_name') ? filter_xss_admin(variable_get('site_name', 'Drupal')) : '');  $variables['site_slogan']       = (theme_get_setting('toggle_slogan') ? filter_xss_admin(variable_get('site_slogan', '')) : '');  $variables['css']               = drupal_add_css();  $variables['styles']            = drupal_get_css();  $variables['scripts']           = drupal_get_js();  $variables['tabs']              = theme('menu_local_tasks');  $variables['title']             = drupal_get_title();  // Closure should be filled last.  $variables['closure']           = theme('closure');  if ($node = menu_get_object()) {    $variables['node'] = $node;  }  // Compile a list of classes that are going to be applied to the body element.  // This allows advanced theming based on context (home page, node of certain type, etc.).  $body_classes = array();  // Add a class that tells us whether we're on the front page or not.  $body_classes[] = $variables['is_front'] ? 'front' : 'not-front';  // Add a class that tells us whether the page is viewed by an authenticated user or not.  $body_classes[] = $variables['logged_in'] ? 'logged-in' : 'not-logged-in';  // Add arg(0) to make it possible to theme the page depending on the current page  // type (e.g. node, admin, user, etc.). To avoid illegal characters in the class,  // we're removing everything disallowed. We are not using 'a-z' as that might leave  // in certain international characters (e.g. German umlauts).  $body_classes[] = preg_replace('![^abcdefghijklmnopqrstuvwxyz0-9-_]+!s', '', 'page-'. form_clean_id(drupal_strtolower(arg(0))));  // If on an individual node page, add the node type.  if (isset($variables['node']) && $variables['node']->type) {    $body_classes[] = 'node-type-'. form_clean_id($variables['node']->type);  }  // Add information about the number of sidebars.  if ($variables['layout'] == 'both') {    $body_classes[] = 'two-sidebars';  }  elseif ($variables['layout'] == 'none') {    $body_classes[] = 'no-sidebars';  }  else {    $body_classes[] = 'one-sidebar sidebar-'. $variables['layout'];  }  // Implode with spaces.  $variables['body_classes'] = implode(' ', $body_classes);  // Build a list of suggested template files in order of specificity. One  // suggestion is made for every element of the current path, though  // numeric elements are not carried to subsequent suggestions. For example,  // http://www.example.com/node/1/edit would result in the following  // suggestions:  //  // page-node-edit.tpl.php  // page-node-1.tpl.php  // page-node.tpl.php  // page.tpl.php  $i = 0;  $suggestion = 'page';  $suggestions = array();  while ($arg = arg($i++)) {    $arg = str_replace(array("/", "\\", "\0"), '', $arg);    $suggestions[] = $suggestion .'-'. $arg;    if (!is_numeric($arg)) {      $suggestion .= '-'. $arg;    }  }  if (drupal_is_front_page()) {    $suggestions[] = 'page-front';  }  if ($suggestions) {    $variables['template_files'] = $suggestions;  }}/** * Process variables for node.tpl.php * * Most themes utilize their own copy of node.tpl.php. The default is located * inside "modules/node/node.tpl.php". Look in there for the full list of * variables. * * The $variables array contains the following arguments: * - $node * - $teaser * - $page * * @see node.tpl.php */function template_preprocess_node(&$variables) {  $node = $variables['node'];  if (module_exists('taxonomy')) {    $variables['taxonomy'] = taxonomy_link('taxonomy terms', $node);  }  else {    $variables['taxonomy'] = array();  }  if ($variables['teaser'] && $node->teaser) {    $variables['content'] = $node->teaser;  }  elseif (isset($node->body)) {    $variables['content'] = $node->body;  }  else {    $variables['content'] = '';  }  $variables['date']      = format_date($node->created);  $variables['links']     = !empty($node->links) ? theme('links', $node->links, array('class' => 'links inline')) : '';  $variables['name']      = theme('username', $node);  $variables['node_url']  = url('node/'. $node->nid);  $variables['terms']     = theme('links', $variables['taxonomy'], array('class' => 'links inline'));  $variables['title']     = check_plain($node->title);  // Flatten the node object's member fields.  $variables = array_merge((array)$node, $variables);  // Display info only on certain node types.  if (theme_get_setting('toggle_node_info_'. $node->type)) {    $variables['submitted'] = theme('node_submitted', $node);    $variables['picture'] = theme_get_setting('toggle_node_user_picture') ? theme('user_picture', $node) : '';  }  else {    $variables['submitted'] = '';    $variables['picture'] = '';  }  // Clean up name so there are no underscores.  $variables['template_files'][] = 'node-'. $node->type;}/** * Process variables for block.tpl.php * * Prepare the values passed to the theme_block function to be passed * into a pluggable template engine. Uses block properties to generate a * series of template file suggestions. If none are found, the default * block.tpl.php is used. * * Most themes utilize their own copy of block.tpl.php. The default is located * inside "modules/system/block.tpl.php". Look in there for the full list of * variables. * * The $variables array contains the following arguments: * - $block * * @see block.tpl.php */function template_preprocess_block(&$variables) {  static $block_counter = array();  // All blocks get an independent counter for each region.  if (!isset($block_counter[$variables['block']->region])) {    $block_counter[$variables['block']->region] = 1;  }  // Same with zebra striping.  $variables['block_zebra'] = ($block_counter[$variables['block']->region] % 2) ? 'odd' : 'even';  $variables['block_id'] = $block_counter[$variables['block']->region]++;  $variables['template_files'][] = 'block-'. $variables['block']->region;  $variables['template_files'][] = 'block-'. $variables['block']->module;  $variables['template_files'][] = 'block-'. $variables['block']->module .'-'. $variables['block']->delta;}
<?php// $Id$/** * Implementation of hook_schema(). */function filter_schema() {  $schema['filters'] = array(    'description' => 'Table that maps filters (HTML corrector) to input formats (Filtered HTML).',    'fields' => array(      'fid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Auto-incrementing filter ID.',      ),      'format' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Foreign key: The {filter_formats}.format to which this filter is assigned.',      ),      'module' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'The origin module of the filter.',      ),      'delta' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'ID to identify which filter within module is being referenced.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Weight of filter within format.',      )    ),    'primary key' => array('fid'),    'unique keys' => array(      'fmd' => array('format', 'module', 'delta'),    ),    'indexes' => array(      'list' => array('format', 'weight', 'module', 'delta'),    ),  );  $schema['filter_formats'] = array(    'description' => 'Stores input formats: custom groupings of filters, such as Filtered HTML.',    'fields' => array(      'format' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique ID for format.',      ),      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Name of the input format (Filtered HTML).',      ),      'roles' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'A comma-separated string of roles; references {role}.rid.', // This is bad since you can't use joins, nor index.      ),      'cache' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate whether format is cachable. (1 = cachable, 0 = not cachable)',      ),    ),    'primary key' => array('format'),    'unique keys' => array('name' => array('name')),  );  $schema['cache_filter'] = drupal_get_schema_unprocessed('system', 'cache');  $schema['cache_filter']['description'] = 'Cache table for the Filter module to store already filtered pieces of text, identified by input format and md5 hash of the text.';  return $schema;}
<?php// $Id$/** * Implementation of hook_install(). */function contact_install() {  // Create tables.  drupal_install_schema('contact');}/** * Implementation of hook_uninstall(). */function contact_uninstall() {  // Remove tables.  drupal_uninstall_schema('contact');  variable_del('contact_default_status');  variable_del('contact_form_information');  variable_del('contact_hourly_threshold');}/** * Implementation of hook_schema(). */function contact_schema() {  $schema['contact'] = array(    'description' => 'Contact form category settings.',    'fields' => array(      'cid' => array(        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'Primary Key: Unique category ID.',      ),      'category' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Category name.',      ),      'recipients' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Comma-separated list of recipient e-mail addresses.',      ),      'reply' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Text of the auto-reply message.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => "The category's weight.",      ),      'selected' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Flag to indicate whether or not category is selected by default. (1 = Yes, 0 = No)',      ),    ),    'primary key' => array('cid'),    'unique keys' => array(      'category' => array('category'),    ),    'indexes' => array(      'list' => array('weight', 'category'),    ),  );  return $schema;}
<?php// $Id$/** * @file * User page callbacks for the search module. *//** * Menu callback; presents the search form and/or search results. */function search_view($type = 'node') {  // Search form submits with POST but redirects to GET. This way we can keep  // the search query URL clean as a whistle:  // search/type/keyword+keyword  if (!isset($_POST['form_id'])) {    if ($type == '') {      // Note: search/node can not be a default tab because it would take on the      // path of its parent (search). It would prevent remembering keywords when      // switching tabs. This is why we drupal_goto to it from the parent instead.      drupal_goto('search/node');    }    $keys = search_get_keys();    // Only perform search if there is non-whitespace search term:    $results = '';    if (trim($keys)) {      // Log the search keys:      watchdog('search', '%keys (@type).', array('%keys' => $keys, '@type' => module_invoke($type, 'search', 'name')), WATCHDOG_NOTICE, l(t('results'), 'search/'. $type .'/'. $keys));      // Collect the search results:      $results = search_data($keys, $type);      if ($results) {        $results = theme('box', t('Search results'), $results);      }      else {        $results = theme('box', t('Your search yielded no results'), search_help('search#noresults', drupal_help_arg()));      }    }    // Construct the search form.    $output = drupal_get_form('search_form', NULL, $keys, $type);    $output .= $results;    return $output;  }  return drupal_get_form('search_form', NULL, empty($keys) ? '' : $keys, $type);}/** * Process variables for search-results.tpl.php. * * The $variables array contains the following arguments: * - $results * - $type * * @see search-results.tpl.php */function template_preprocess_search_results(&$variables) {  $variables['search_results'] = '';  foreach ($variables['results'] as $result) {    $variables['search_results'] .= theme('search_result', $result, $variables['type']);  }  $variables['pager'] = theme('pager', NULL, 10, 0);  // Provide alternate search results template.  $variables['template_files'][] = 'search-results-'. $variables['type'];}/** * Process variables for search-result.tpl.php. * * The $variables array contains the following arguments: * - $result * - $type * * @see search-result.tpl.php */function template_preprocess_search_result(&$variables) {  $result = $variables['result'];  $variables['url'] = check_url($result['link']);  $variables['title'] = check_plain($result['title']);  $info = array();  if (!empty($result['type'])) {    $info['type'] = check_plain($result['type']);  }  if (!empty($result['user'])) {    $info['user'] = $result['user'];  }  if (!empty($result['date'])) {    $info['date'] = format_date($result['date'], 'small');  }  if (isset($result['extra']) && is_array($result['extra'])) {    $info = array_merge($info, $result['extra']);  }  // Check for existence. User search does not include snippets.  $variables['snippet'] = isset($result['snippet']) ? $result['snippet'] : '';  // Provide separated and grouped meta information..  $variables['info_split'] = $info;  $variables['info'] = implode(' - ', $info);  // Provide alternate search result template.  $variables['template_files'][] = 'search-result-'. $variables['type'];}/** * As the search form collates keys from other modules hooked in via * hook_form_alter, the validation takes place in _submit. * search_form_validate() is used solely to set the 'processed_keys' form * value for the basic search form. */function search_form_validate($form, &$form_state) {  form_set_value($form['basic']['inline']['processed_keys'], trim($form_state['values']['keys']), $form_state);}/** * Process a search form submission. */function search_form_submit($form, &$form_state) {  $keys = $form_state['values']['processed_keys'];  if ($keys == '') {    form_set_error('keys', t('Please enter some keywords.'));    // Fall through to the drupal_goto() call.  }  $type = $form_state['values']['module'] ? $form_state['values']['module'] : 'node';  $form_state['redirect'] = 'search/'. $type .'/'. $keys;  return;}
<?php// $Id$/** * @file * Functions to handle paths in Drupal, including path aliasing. * * These functions are not loaded for cached pages, but modules that need * to use them in hook_init() or hook exit() can make them available, by * executing "drupal_bootstrap(DRUPAL_BOOTSTRAP_PATH);". *//** * Initialize the $_GET['q'] variable to the proper normal path. */function drupal_init_path() {  if (!empty($_GET['q'])) {    $_GET['q'] = drupal_get_normal_path(trim($_GET['q'], '/'));  }  else {    $_GET['q'] = drupal_get_normal_path(variable_get('site_frontpage', 'node'));  }}/** * Given an alias, return its Drupal system URL if one exists. Given a Drupal * system URL return one of its aliases if such a one exists. Otherwise, * return FALSE. * * @param $action *   One of the following values: *   - wipe: delete the alias cache. *   - alias: return an alias for a given Drupal system path (if one exists). *   - source: return the Drupal system URL for a path alias (if one exists). * @param $path *   The path to investigate for corresponding aliases or system URLs. * @param $path_language *   Optional language code to search the path with. Defaults to the page language. *   If there's no path defined for that language it will search paths without *   language. * * @return *   Either a Drupal system path, an aliased path, or FALSE if no path was *   found. */function drupal_lookup_path($action, $path = '', $path_language = '') {  global $language;  // $map is an array with language keys, holding arrays of Drupal paths to alias relations  static $map = array(), $no_src = array(), $count;  $path_language = $path_language ? $path_language : $language->language;  // Use $count to avoid looking up paths in subsequent calls if there simply are no aliases  if (!isset($count)) {    $count = db_result(db_query('SELECT COUNT(pid) FROM {url_alias}'));  }  if ($action == 'wipe') {    $map = array();    $no_src = array();    $count = NULL;  }  elseif ($count > 0 && $path != '') {    if ($action == 'alias') {      if (isset($map[$path_language][$path])) {        return $map[$path_language][$path];      }      // Get the most fitting result falling back with alias without language      $alias = db_result(db_query("SELECT dst FROM {url_alias} WHERE src = '%s' AND language IN('%s', '') ORDER BY language DESC, pid DESC", $path, $path_language));      $map[$path_language][$path] = $alias;      return $alias;    }    // Check $no_src for this $path in case we've already determined that there    // isn't a path that has this alias    elseif ($action == 'source' && !isset($no_src[$path_language][$path])) {      // Look for the value $path within the cached $map      $src = '';      if (!isset($map[$path_language]) || !($src = array_search($path, $map[$path_language]))) {        // Get the most fitting result falling back with alias without language        if ($src = db_result(db_query("SELECT src FROM {url_alias} WHERE dst = '%s' AND language IN('%s', '') ORDER BY language DESC, pid DESC", $path, $path_language))) {          $map[$path_language][$src] = $path;        }        else {          // We can't record anything into $map because we do not have a valid          // index and there is no need because we have not learned anything          // about any Drupal path. Thus cache to $no_src.          $no_src[$path_language][$path] = TRUE;        }      }      return $src;    }  }  return FALSE;}/** * Given an internal Drupal path, return the alias set by the administrator. * * @param $path *   An internal Drupal path. * @param $path_language *   An optional language code to look up the path in. * * @return *   An aliased path if one was found, or the original path if no alias was *   found. */function drupal_get_path_alias($path, $path_language = '') {  $result = $path;  if ($alias = drupal_lookup_path('alias', $path, $path_language)) {    $result = $alias;  }  return $result;}/** * Given a path alias, return the internal path it represents. * * @param $path *   A Drupal path alias. * @param $path_language *   An optional language code to look up the path in. * * @return *   The internal path represented by the alias, or the original alias if no *   internal path was found. */function drupal_get_normal_path($path, $path_language = '') {  $result = $path;  if ($src = drupal_lookup_path('source', $path, $path_language)) {    $result = $src;  }  if (function_exists('custom_url_rewrite_inbound')) {    // Modules may alter the inbound request path by reference.    custom_url_rewrite_inbound($result, $path, $path_language);  }  return $result;}/** * Return a component of the current Drupal path. * * When viewing a page at the path "admin/content/types", for example, arg(0) * would return "admin", arg(1) would return "content", and arg(2) would return * "types". * * Avoid use of this function where possible, as resulting code is hard to read. * Instead, attempt to use named arguments in menu callback functions. See the * explanation in menu.inc for how to construct callbacks that take arguments. * * @param $index *   The index of the component, where each component is separated by a '/' *   (forward-slash), and where the first component has an index of 0 (zero). * * @return *   The component specified by $index, or NULL if the specified component was *   not found. */function arg($index = NULL, $path = NULL) {  static $arguments;  if (!isset($path)) {    $path = $_GET['q'];  }  if (!isset($arguments[$path])) {    $arguments[$path] = explode('/', $path);  }  if (!isset($index)) {    return $arguments[$path];  }  if (isset($arguments[$path][$index])) {    return $arguments[$path][$index];  }}/** * Get the title of the current page, for display on the page and in the title bar. * * @return *   The current page's title. */function drupal_get_title() {  $title = drupal_set_title();  // during a bootstrap, menu.inc is not included and thus we cannot provide a title  if (!isset($title) && function_exists('menu_get_active_title')) {    $title = check_plain(menu_get_active_title());  }  return $title;}/** * Set the title of the current page, for display on the page and in the title bar. * * @param $title *   Optional string value to assign to the page title; or if set to NULL *   (default), leaves the current title unchanged. * * @return *   The updated title of the current page. */function drupal_set_title($title = NULL) {  static $stored_title;  if (isset($title)) {    $stored_title = $title;  }  return $stored_title;}/** * Check if the current page is the front page. * * @return *   Boolean value: TRUE if the current page is the front page; FALSE if otherwise. */function drupal_is_front_page() {  // As drupal_init_path updates $_GET['q'] with the 'site_frontpage' path,  // we can check it against the 'site_frontpage' variable.  return $_GET['q'] == drupal_get_normal_path(variable_get('site_frontpage', 'node'));}/** * Check if a path matches any pattern in a set of patterns. * * @param $path *   The path to match. * @param $patterns *   String containing a set of patterns separated by \n, \r or \r\n. * * @return *   1 if there is a match, 0 if there is not a match. */function drupal_match_path($path, $patterns) {  static $regexps;  if (!isset($regexps[$patterns])) {    $regexps[$patterns] = '/^('. preg_replace(array('/(\r\n?|\n)/', '/\\\\\*/', '/(^|\|)\\\\<front\\\\>($|\|)/'), array('|', '.*', '\1'. preg_quote(variable_get('site_frontpage', 'node'), '/') .'\2'), preg_quote($patterns, '/')) .')$/';  }  return preg_match($regexps[$patterns], $path);}
<?php// $Id$/** * @file * User page callbacks for the forum module. *//** * Menu callback; prints a forum listing. */function forum_page($tid = 0) {  if (!is_numeric($tid)) {    return MENU_NOT_FOUND;  }  $tid = (int)$tid;  $topics = '';  $forum_per_page = variable_get('forum_per_page', 25);  $sortby = variable_get('forum_order', 1);  $forums = forum_get_forums($tid);  $parents = taxonomy_get_parents_all($tid);  if ($tid && !in_array($tid, variable_get('forum_containers', array()))) {    $topics = forum_get_topics($tid, $sortby, $forum_per_page);  }  return theme('forums', $forums, $topics, $parents, $tid, $sortby, $forum_per_page);}
<?php// $Id$/** * @file * Additional filter for PHP input. *//** * Implementation of hook_help(). */function php_help($path, $arg) {  switch ($path) {    case 'admin/help#php':      $output = '<p>'. t('The PHP filter adds the ability to include PHP code in posts. PHP is a general-purpose scripting language widely-used for web development; the content management system used by this website has been developed using PHP.') .'</p>';      $output .= '<p>'. t('Through the PHP filter, users with the proper permission may include custom PHP code within a page of the site. While this is a powerful and flexible feature if used by a trusted user with PHP experience, it is a significant and dangerous security risk in the hands of a malicious user. Even a trusted user may accidentally compromise the site by entering malformed or incorrect PHP code. Only the most trusted users should be granted permission to use the PHP filter, and all PHP code added through the PHP filter should be carefully examined before use.') .'</p>';      $output .= '<p>'. t('<a href="@drupal">Drupal.org</a> offers <a href="@php-snippets">some example PHP snippets</a>, or you can create your own with some PHP experience and knowledge of the Drupal system.', array('@drupal' => url('http://drupal.org'), '@php-snippets' => url('http://drupal.org/handbook/customization/php-snippets'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@php">PHP module</a>.', array('@php' => 'http://drupal.org/handbook/modules/php/')) .'</p>';      return $output;  }}/** * Implementation of hook_filter_tips(). */function php_filter_tips($delta, $format, $long = false) {  global $base_url;  if ($delta == 0) {    switch ($long) {      case 0:        return t('You may post PHP code. You should include &lt;?php ?&gt; tags.');      case 1:        $output = '<h4>'. t('Using custom PHP code') .'</h4>';        $output .= '<p>'. t('Custom PHP code may be embedded in some types of site content, including posts and blocks. While embedding PHP code inside a post or block is a powerful and flexible feature when used by a trusted user with PHP experience, it is a significant and dangerous security risk when used improperly. Even a small mistake when posting PHP code may accidentally compromise your site.') .'</p>';        $output .= '<p>'. t('If you are unfamiliar with PHP, SQL, or Drupal, avoid using custom PHP code within posts. Experimenting with PHP may corrupt your database, render your site inoperable, or significantly compromise security.') .'</p>';        $output .= '<p>'. t('Notes:') .'</p>';        $output .= '<ul><li>'. t('Remember to double-check each line for syntax and logic errors <strong>before</strong> saving.') .'</li>';        $output .= '<li>'. t('Statements must be correctly terminated with semicolons.') .'</li>';        $output .= '<li>'. t('Global variables used within your PHP code retain their values after your script executes.') .'</li>';        $output .= '<li>'. t('<code>register_globals</code> is <strong>turned off</strong>. If you need to use forms, understand and use the functions in <a href="@formapi">the Drupal Form API</a>.', array('@formapi' => url('http://api.drupal.org/api/group/form_api/6'))) .'</li>';        $output .= '<li>'. t('Use a <code>print</code> or <code>return</code> statement in your code to output content.') .'</li>';        $output .= '<li>'. t('Develop and test your PHP code using a separate test script and sample database before deploying on a production site.') .'</li>';        $output .= '<li>'. t('Consider including your custom PHP code within a site-specific module or <code>template.php</code> file rather than embedding it directly into a post or block.') .'</li>';        $output .= '<li>'. t('Be aware that the ability to embed PHP code within content is provided by the PHP Filter module. If this module is disabled or deleted, then blocks and posts with embedded PHP may display, rather than execute, the PHP code.') .'</li></ul>';        $output .= '<p>'. t('A basic example: <em>Creating a "Welcome" block that greets visitors with a simple message.</em>') .'</p>';        $output .= '<ul><li>'. t('<p>Add a custom block to your site, named "Welcome". With its input format set to "PHP code" (or another format supporting PHP input), add the following in the Block body:</p><pre>print t(\'Welcome visitor! Thank you for visiting.\');</pre>') .'</li>';        $output .= '<li>'. t('<p>To display the name of a registered user, use this instead:</p><pre>global $user;if ($user->uid) {  print t(\'Welcome @name! Thank you for visiting.\', array(\'@name\' => $user->name));}else {  print t(\'Welcome visitor! Thank you for visiting.\');}</pre>') .'</li></ul>';        $output .= '<p>'. t('<a href="@drupal">Drupal.org</a> offers <a href="@php-snippets">some example PHP snippets</a>, or you can create your own with some PHP experience and knowledge of the Drupal system.', array('@drupal' => url('http://drupal.org'), '@php-snippets' => url('http://drupal.org/handbook/customization/php-snippets'))) .'</p>';        return $output;    }  }}/** * Implementation of hook_filter(). Contains a basic PHP evaluator. * * Executes PHP code. Use with care. */function php_filter($op, $delta = 0, $format = -1, $text = '') {  switch ($op) {    case 'list':      return array(0 => t('PHP evaluator'));    case 'no cache':      // No caching for the PHP evaluator.      return $delta == 0;    case 'description':      return t('Executes a piece of PHP code. The usage of this filter should be restricted to administrators only!');    case 'process':      return drupal_eval($text);    default:      return $text;  }}
<?php// $Id$/** * @file * Allows users to structure the pages of a site in a hierarchy or outline. *//** * Implementation of hook_theme() */function book_theme() {  return array(    'book_navigation' => array(      'arguments' => array('book_link' => NULL),      'template' => 'book-navigation',    ),    'book_export_html' => array(      'arguments' => array('title' => NULL, 'contents' => NULL, 'depth' => NULL),      'template' => 'book-export-html',    ),    'book_admin_table' => array(      'arguments' => array('form' => NULL),    ),    'book_title_link' => array(      'arguments' => array('link' => NULL),    ),    'book_all_books_block' => array(      'arguments' => array('book_menus' => array()),      'template' => 'book-all-books-block',    ),    'book_node_export_html' => array(      'arguments' => array('node' => NULL, 'children' => NULL),      'template' => 'book-node-export-html',    ),  );}/** * Implementation of hook_perm(). */function book_perm() {  return array('add content to books', 'administer book outlines', 'create new books', 'access printer-friendly version');}/** * Implementation of hook_link(). */function book_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && isset($node->book)) {    if (!$teaser) {      $child_type = variable_get('book_child_type', 'book');      if ((user_access('add content to books') || user_access('administer book outlines')) && node_access('create', $child_type) && $node->status == 1 && $node->book['depth'] < MENU_MAX_DEPTH) {        $links['book_add_child'] = array(          'title' => t('Add child page'),          'href' => "node/add/". str_replace('_', '-', $child_type),          'query' => "parent=". $node->book['mlid'],        );      }      if (user_access('access printer-friendly version')) {        $links['book_printer'] = array(          'title' => t('Printer-friendly version'),          'href' => 'book/export/html/'. $node->nid,          'attributes' => array('title' => t('Show a printer-friendly version of this book page and its sub-pages.'))        );      }    }  }  return $links;}/** * Implementation of hook_menu(). */function book_menu() {  $items['admin/content/book'] = array(    'title' => 'Books',    'description' => "Manage your site's book outlines.",    'page callback' => 'book_admin_overview',    'access arguments' => array('administer book outlines'),    'file' => 'book.admin.inc',  );  $items['admin/content/book/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/content/book/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_admin_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_LOCAL_TASK,    'weight' => 8,    'file' => 'book.admin.inc',  );  $items['admin/content/book/%node'] = array(    'title' => 'Re-order book pages and change titles',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_admin_edit', 3),    'access callback' => '_book_outline_access',    'access arguments' => array(3),    'type' => MENU_CALLBACK,    'file' => 'book.admin.inc',  );  $items['book'] = array(    'title' => 'Books',    'page callback' => 'book_render',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'book.pages.inc',  );  $items['book/export/%/%'] = array(    'page callback' => 'book_export',    'page arguments' => array(2, 3),    'access arguments' => array('access printer-friendly version'),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  $items['node/%node/outline'] = array(    'title' => 'Outline',    'page callback' => 'book_outline',    'page arguments' => array(1),    'access callback' => '_book_outline_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'book.pages.inc',  );  $items['node/%node/outline/remove'] = array(    'title' => 'Remove from outline',    'page callback' => 'drupal_get_form',    'page arguments' => array('book_remove_form', 1),    'access callback' => '_book_outline_remove_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  $items['book/js/form'] = array(    'page callback' => 'book_form_update',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'book.pages.inc',  );  return $items;}/** * Menu item access callback - determine if the outline tab is accessible. */function _book_outline_access($node) {  return user_access('administer book outlines') && node_access('view', $node);}/** * Menu item access callback - determine if the user can remove nodes from the outline. */function _book_outline_remove_access($node) {  return isset($node->book) && ($node->book['bid'] != $node->nid) && _book_outline_access($node);}/** * Implementation of hook_init(). Add's the book module's CSS. */function book_init() {  drupal_add_css(drupal_get_path('module', 'book') .'/book.css');}/** * Implementation of hook_block(). * * Displays the book table of contents in a block when the current page is a * single-node view of a book node. */function book_block($op = 'list', $delta = 0, $edit = array()) {  $block = array();  switch ($op) {    case 'list':      $block[0]['info'] = t('Book navigation');      $block[0]['cache'] = BLOCK_CACHE_PER_PAGE | BLOCK_CACHE_PER_ROLE;      return $block;    case 'view':      $current_bid = 0;      if ($node = menu_get_object()) {        $current_bid = empty($node->book['bid']) ? 0 : $node->book['bid'];      }      if (variable_get('book_block_mode', 'all pages') == 'all pages') {        $block['subject'] = t('Book navigation');        $book_menus = array();        $pseudo_tree = array(0 => array('below' => FALSE));        foreach (book_get_books() as $book_id => $book) {          if ($book['bid'] == $current_bid) {            // If the current page is a node associated with a book, the menu            // needs to be retrieved.            $book_menus[$book_id] = menu_tree_output(menu_tree_all_data($node->book['menu_name'], $node->book));          }          else {            // Since we know we will only display a link to the top node, there            // is no reason to run an additional menu tree query for each book.            $book['in_active_trail'] = FALSE;            $pseudo_tree[0]['link'] = $book;            $book_menus[$book_id] = menu_tree_output($pseudo_tree);          }        }        $block['content'] = theme('book_all_books_block', $book_menus);      }      elseif ($current_bid) {        // Only display this block when the user is browsing a book.        $title = db_result(db_query(db_rewrite_sql('SELECT n.title FROM {node} n WHERE n.nid = %d'), $node->book['bid']));        // Only show the block if the user has view access for the top-level node.        if ($title) {          $tree = menu_tree_all_data($node->book['menu_name'], $node->book);          // There should only be one element at the top level.          $data = array_shift($tree);          $block['subject'] = theme('book_title_link', $data['link']);          $block['content'] = ($data['below']) ? menu_tree_output($data['below']) : '';        }      }      return $block;    case 'configure':      $options = array(        'all pages' => t('Show block on all pages'),        'book pages' => t('Show block only on book pages'),      );      $form['book_block_mode'] = array(        '#type' => 'radios',        '#title' => t('Book navigation block display'),        '#options' => $options,        '#default_value' => variable_get('book_block_mode', 'all pages'),        '#description' => t("If <em>Show block on all pages</em> is selected, the block will contain the automatically generated menus for all of the site's books. If <em>Show block only on book pages</em> is selected, the block will contain only the one menu corresponding to the current page's book. In this case, if the current page is not in a book, no block will be displayed. The <em>Page specific visibility settings</em> or other visibility settings can be used in addition to selectively display this block."),        );      return $form;    case 'save':      variable_set('book_block_mode', $edit['book_block_mode']);      break;  }}/** * Generate the HTML output for a link to a book title when used as a block title. * * @ingroup themeable */function theme_book_title_link($link) {  $link['options']['attributes']['class'] =  'book-title';  return l($link['title'], $link['href'], $link['options']);}/** * Returns an array of all books. * * This list may be used for generating a list of all the books, or for building * the options for a form select. */function book_get_books() {  static $all_books;  if (!isset($all_books)) {    $all_books = array();    $result = db_query("SELECT DISTINCT(bid) FROM {book}");    $nids = array();    while ($book = db_fetch_array($result)) {      $nids[] = $book['bid'];    }    if ($nids) {      $result2 = db_query(db_rewrite_sql("SELECT n.type, n.title, b.*, ml.* FROM {book} b INNER JOIN {node} n on b.nid = n.nid INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE n.nid IN (". implode(',', $nids) .") AND n.status = 1 ORDER BY ml.weight, ml.link_title"));      while ($link = db_fetch_array($result2)) {        $link['href'] = $link['link_path'];        $link['options'] = unserialize($link['options']);        $all_books[$link['bid']] = $link;      }    }  }  return $all_books;}/** * Implementation of hook_form_alter(). Adds the book fieldset to the node form. * * @see book_pick_book_submit() * @see book_submit() */function book_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {    // Add elements to the node form    $node = $form['#node'];    $access = user_access('administer book outlines');    if (!$access) {      if (user_access('add content to books') && ((!empty($node->book['mlid']) && !empty($node->nid)) || book_type_is_allowed($node->type))) {        // Already in the book hierarchy or this node type is allowed        $access = TRUE;      }    }    if ($access) {      _book_add_form_elements($form, $node);      $form['book']['pick-book'] = array(        '#type' => 'submit',        '#value' => t('Change book (update list of parents)'),         // Submit the node form so the parent select options get updated.         // This is typically only used when JS is disabled.  Since the parent options         // won't be changed via AJAX, a button is provided in the node form to submit         // the form and generate options in the parent select corresponding to the         // selected book.  This is similar to what happens during a node preview.        '#submit' => array('node_form_submit_build_node'),        '#weight' => 20,      );    }  }}/** * Build the parent selection form element for the node form or outline tab * * This function is also called when generating a new set of options during the * AJAX callback, so an array is returned that can be used to replace an existing * form element. */function _book_parent_select($book_link) {  if (variable_get('menu_override_parent_selector', FALSE)) {    return array();  }  // Offer a message or a drop-down to choose a different parent page.  $form = array(    '#type' => 'hidden',    '#value' => -1,    '#prefix' => '<div id="edit-book-plid-wrapper">',    '#suffix' => '</div>',  );  if ($book_link['nid'] === $book_link['bid']) {    // This is a book - at the top level.    if ($book_link['original_bid'] === $book_link['bid']) {      $form['#prefix'] .= '<em>'. t('This is the top-level page in this book.') .'</em>';    }    else {      $form['#prefix'] .= '<em>'. t('This will be the top-level page in this book.') .'</em>';    }  }  elseif (!$book_link['bid']) {    $form['#prefix'] .= '<em>'. t('No book selected.') .'</em>';  }  else {    $form = array(      '#type' => 'select',      '#title' => t('Parent item'),      '#default_value' => $book_link['plid'],      '#description' => t('The parent page in the book. The maximum depth for a book and all child pages is !maxdepth. Some pages in the selected book may not be available as parents if selecting them would exceed this limit.', array('!maxdepth' => MENU_MAX_DEPTH)),      '#options' => book_toc($book_link['bid'], array($book_link['mlid']), $book_link['parent_depth_limit']),      '#attributes' => array('class' => 'book-title-select'),    );  }  return $form;}/** * Build the common elements of the book form for the node and outline forms. */function _book_add_form_elements(&$form, $node) {  // Need this for AJAX.  $form['#cache'] = TRUE;  drupal_add_js("if (Drupal.jsEnabled) { $(document).ready(function() { $('#edit-book-pick-book').css('display', 'none'); }); }", 'inline');  $form['book'] = array(    '#type' => 'fieldset',    '#title' => t('Book outline'),    '#weight' => 10,    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#tree' => TRUE,    '#attributes' => array('class' => 'book-outline-form'),  );  foreach (array('menu_name', 'mlid', 'nid', 'router_path', 'has_children', 'options', 'module', 'original_bid', 'parent_depth_limit') as $key) {    $form['book'][$key] = array(      '#type' => 'value',      '#value' => $node->book[$key],    );  }  $form['book']['plid'] = _book_parent_select($node->book);  $form['book']['weight'] = array(    '#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $node->book['weight'],    '#delta' => 15,    '#weight' => 5,    '#description' => t('Pages at a given level are ordered first by weight and then by title.'),  );  $options = array();  $nid = isset($node->nid) ? $node->nid : 'new';  if (isset($node->nid) && ($nid == $node->book['original_bid']) && ($node->book['parent_depth_limit'] == 0)) {    // This is the top level node in a maximum depth book and thus cannot be moved.    $options[$node->nid] = $node->title;  }  else {    foreach (book_get_books() as $book) {      $options[$book['nid']] = $book['title'];    }  }  if (user_access('create new books') && ($nid == 'new' || ($nid != $node->book['original_bid']))) {    // The node can become a new book, if it is not one already.    $options = array($nid => '<'. t('create a new book') .'>') + $options;  }  if (!$node->book['mlid']) {    // The node is not currently in a the hierarchy.    $options = array(0 => '<'. t('none') .'>') + $options;  }  // Add a drop-down to select the destination book.  $form['book']['bid'] = array(    '#type' => 'select',    '#title' => t('Book'),    '#default_value' => $node->book['bid'],    '#options' => $options,    '#access' => (bool)$options,    '#description' => t('Your page will be a part of the selected book.'),    '#weight' => -5,    '#attributes' => array('class' => 'book-title-select'),    '#ahah' => array(      'path' => 'book/js/form',      'wrapper' => 'edit-book-plid-wrapper',      'effect' => 'slide',    ),  );}/** * Common helper function to handles additions and updates to the book outline. * * Performs all additions and updates to the book outline through node addition, * node editing, node deletion, or the outline tab. */function _book_update_outline(&$node) {  if (empty($node->book['bid'])) {    return FALSE;  }  $new = empty($node->book['mlid']);  $node->book['link_path'] = 'node/'. $node->nid;  $node->book['link_title'] = $node->title;  $node->book['parent_mismatch'] = FALSE; // The normal case.  if ($node->book['bid'] == $node->nid) {    $node->book['plid'] = 0;    $node->book['menu_name'] = book_menu_name($node->nid);  }  else {    // Check in case the parent is not is this book; the book takes precedence.    if (!empty($node->book['plid'])) {      $parent = db_fetch_array(db_query("SELECT * FROM {book} WHERE mlid = %d", $node->book['plid']));    }    if (empty($node->book['plid']) || !$parent || $parent['bid'] != $node->book['bid']) {      $node->book['plid'] = db_result(db_query("SELECT mlid FROM {book} WHERE nid = %d", $node->book['bid']));      $node->book['parent_mismatch'] = TRUE; // Likely when JS is disabled.    }  }  if (menu_link_save($node->book)) {    if ($new) {      // Insert new.      db_query("INSERT INTO {book} (nid, mlid, bid) VALUES (%d, %d, %d)", $node->nid, $node->book['mlid'], $node->book['bid']);    }    else {      if ($node->book['bid'] != db_result(db_query("SELECT bid FROM {book} WHERE nid = %d", $node->nid))) {        // Update the bid for this page and all children.        book_update_bid($node->book);      }    }    return TRUE;  }  // Failed to save the menu link  return FALSE;}/** * Update the bid for a page and its children when it is moved to a new book. * * @param $book_link *   A fully loaded menu link that is part of the book hierarchy. */function book_update_bid($book_link) {  for ($i = 1; $i <= MENU_MAX_DEPTH && $book_link["p$i"]; $i++) {    $match[] = "p$i = %d";    $args[] = $book_link["p$i"];  }  $result = db_query("SELECT mlid FROM {menu_links} WHERE ". implode(' AND ', $match), $args);  $mlids = array();  while ($a = db_fetch_array($result)) {    $mlids[] = $a['mlid'];  }  if ($mlids) {    db_query("UPDATE {book} SET bid = %d WHERE mlid IN (". implode(',', $mlids) .")", $book_link['bid']);  }}/** * Get the book menu tree for a page, and return it as a linear array. * * @param $book_link *   A fully loaded menu link that is part of the book hierarchy. * @return *   A linear array of menu links in the order that the links are shown in the *   menu, so the previous and next pages are the elements before and after the *   element corresponding to $node.  The children of $node (if any) will come *   immediately after it in the array. */function book_get_flat_menu($book_link) {  static $flat = array();  if (!isset($flat[$book_link['mlid']])) {    // Call menu_tree_all_data() to take advantage of the menu system's caching.    $tree = menu_tree_all_data($book_link['menu_name'], $book_link);    $flat[$book_link['mlid']] = array();    _book_flatten_menu($tree, $flat[$book_link['mlid']]);  }  return $flat[$book_link['mlid']];}/** * Recursive helper function for book_get_flat_menu(). */function _book_flatten_menu($tree, &$flat) {  foreach ($tree as $data) {    if (!$data['link']['hidden']) {      $flat[$data['link']['mlid']] = $data['link'];      if ($data['below']) {        _book_flatten_menu($data['below'], $flat);      }    }  }}/** * Fetches the menu link for the previous page of the book. */function book_prev($book_link) {  // If the parent is zero, we are at the start of a book.  if ($book_link['plid'] == 0) {    return NULL;  }  $flat = book_get_flat_menu($book_link);  // Assigning the array to $flat resets the array pointer for use with each().  $curr = NULL;  do {    $prev = $curr;    list($key, $curr) = each($flat);  } while ($key && $key != $book_link['mlid']);  if ($key == $book_link['mlid']) {    // The previous page in the book may be a child of the previous visible link.    if ($prev['depth'] == $book_link['depth'] && $prev['has_children']) {      // The subtree will have only one link at the top level - get its data.      $data = array_shift(book_menu_subtree_data($prev));      // The link of interest is the last child - iterate to find the deepest one.      while ($data['below']) {        $data = end($data['below']);      }      return $data['link'];    }    else {      return $prev;    }  }}/** * Fetches the menu link for the next page of the book. */function book_next($book_link) {  $flat = book_get_flat_menu($book_link);  // Assigning the array to $flat resets the array pointer for use with each().  do {    list($key, $curr) = each($flat);  } while ($key && $key != $book_link['mlid']);  if ($key == $book_link['mlid']) {    return current($flat);  }}/** * Format the menu links for the child pages of the current page. */function book_children($book_link) {  $flat = book_get_flat_menu($book_link);  $children = array();  if ($book_link['has_children']) {    // Walk through the array until we find the current page.    do {      $link = array_shift($flat);    } while ($link && ($link['mlid'] != $book_link['mlid']));    // Continue though the array and collect the links whose parent is this page.    while (($link = array_shift($flat)) && $link['plid'] == $book_link['mlid']) {      $data['link'] = $link;      $data['below'] = '';      $children[] = $data;    }  }  return $children ? menu_tree_output($children) : '';}/** * Generate the corresponding menu name from a book ID. */function book_menu_name($bid) {  return 'book-toc-'. $bid;}/** * Build an active trail to show in the breadcrumb. */function book_build_active_trail($book_link) {  static $trail;  if (!isset($trail)) {    $trail = array();    $trail[] = array('title' => t('Home'), 'href' => '<front>', 'localized_options' => array());    $tree = menu_tree_all_data($book_link['menu_name'], $book_link);    $curr = array_shift($tree);    while ($curr) {      if ($curr['link']['href'] == $book_link['href']) {        $trail[] = $curr['link'];        $curr = FALSE;      }      else {        if ($curr['below'] && $curr['link']['in_active_trail']) {          $trail[] = $curr['link'];          $tree = $curr['below'];        }        $curr = array_shift($tree);      }    }  }  return $trail;}/** * Implementation of hook_nodeapi(). * * Appends book navigation to all nodes in the book, and handles book outline * insertions and updates via the node form. */function book_nodeapi(&$node, $op, $teaser, $page) {  switch ($op) {    case 'load':      // Note - we cannot use book_link_load() because it will call node_load()      $info['book'] = db_fetch_array(db_query('SELECT * FROM {book} b INNER JOIN {menu_links} ml ON b.mlid = ml.mlid WHERE b.nid = %d', $node->nid));      if ($info['book']) {        $info['book']['href'] = $info['book']['link_path'];        $info['book']['title'] = $info['book']['link_title'];        $info['book']['options'] = unserialize($info['book']['options']);        return $info;      }      break;    case 'view':    if (!$teaser) {        if (!empty($node->book['bid']) && $node->build_mode == NODE_BUILD_NORMAL) {          $node->content['book_navigation'] = array(            '#value' => theme('book_navigation', $node->book),            '#weight' => 100,          );          if ($page) {            menu_set_active_trail(book_build_active_trail($node->book));            menu_set_active_menu_name($node->book['menu_name']);          }        }      }      break;    case 'presave':      // Always save a revision for non-administrators.      if (!empty($node->book['bid']) && !user_access('administer nodes')) {        $node->revision = 1;      }      // Make sure a new node gets a new menu link.      if (empty($node->nid)) {        $node->book['mlid'] = NULL;      }      break;    case 'insert':    case 'update':      if (!empty($node->book['bid'])) {        if ($node->book['bid'] == 'new') {          // New nodes that are their own book.          $node->book['bid'] = $node->nid;        }        $node->book['nid'] = $node->nid;        $node->book['menu_name'] = book_menu_name($node->book['bid']);        _book_update_outline($node);      }      break;    case 'delete':      if (!empty($node->book['bid'])) {        if ($node->nid == $node->book['bid']) {          // Handle deletion of a top-level post.          $result = db_query("SELECT b.nid FROM {menu_links} ml INNER JOIN {book} b on b.mlid = ml.mlid WHERE ml.plid = %d", $node->book['mlid']);          while ($child = db_fetch_array($result)) {            $child_node = node_load($child['nid']);            $child_node->book['bid'] = $child_node->nid;            _book_update_outline($child_node);          }        }        menu_link_delete($node->book['mlid']);        db_query('DELETE FROM {book} WHERE mlid = %d', $node->book['mlid']);      }      break;    case 'prepare':      // Prepare defaults for the add/edit form.      if (empty($node->book) && (user_access('add content to books') || user_access('administer book outlines'))) {        $node->book = array();        if (empty($node->nid) && isset($_GET['parent']) && is_numeric($_GET['parent'])) {          // Handle "Add child page" links:          $parent = book_link_load($_GET['parent']);          if ($parent && $parent['access']) {            $node->book['bid'] = $parent['bid'];            $node->book['plid'] = $parent['mlid'];            $node->book['menu_name'] = $parent['menu_name'];          }        }        // Set defaults.        $node->book += _book_link_defaults(!empty($node->nid) ? $node->nid : 'new');      }      else {        if (isset($node->book['bid']) && !isset($node->book['original_bid'])) {          $node->book['original_bid'] = $node->book['bid'];        }      }      // Find the depth limit for the parent select.      if (isset($node->book['bid']) && !isset($node->book['parent_depth_limit'])) {        $node->book['parent_depth_limit'] = _book_parent_depth_limit($node->book);      }      break;  }}/** * Find the depth limit for items in the parent select. */function _book_parent_depth_limit($book_link) {  return MENU_MAX_DEPTH - 1 - (($book_link['mlid'] && $book_link['has_children']) ? menu_link_children_relative_depth($book_link) : 0);}/** * Form altering function for the confirm form for a single node deletion. */function book_form_node_delete_confirm_alter(&$form, $form_state) {  $node = node_load($form['nid']['#value']);  if (isset($node->book) && $node->book['has_children']) {    $form['book_warning'] = array(      '#value' => '<p>'. t('%title is part of a book outline, and has associated child pages. If you proceed with deletion, the child pages will be relocated automatically.', array('%title' => $node->title)) .'</p>',      '#weight' => -10,    );  }}/** * Return an array with default values for a book link. */function _book_link_defaults($nid) {  return array('original_bid' => 0, 'menu_name' => '', 'nid' => $nid, 'bid' => 0, 'router_path' => 'node/%', 'plid' => 0, 'mlid' => 0, 'has_children' => 0, 'weight' => 0, 'module' => 'book', 'options' => array());}/** * Process variables for book-navigation.tpl.php. * * The $variables array contains the following arguments: * - $book_link * * @see book-navigation.tpl.php */function template_preprocess_book_navigation(&$variables) {  $book_link = $variables['book_link'];  // Provide extra variables for themers. Not needed by default.  $variables['book_id'] = $book_link['bid'];  $variables['book_title'] = check_plain($book_link['link_title']);  $variables['book_url'] = 'node/'. $book_link['bid'];  $variables['current_depth'] = $book_link['depth'];  $variables['tree'] = '';  if ($book_link['mlid']) {    $variables['tree'] = book_children($book_link);    if ($prev = book_prev($book_link)) {      $prev_href = url($prev['href']);      drupal_add_link(array('rel' => 'prev', 'href' => $prev_href));      $variables['prev_url'] = $prev_href;      $variables['prev_title'] = check_plain($prev['title']);    }    if ($book_link['plid'] && $parent = book_link_load($book_link['plid'])) {      $parent_href = url($parent['href']);      drupal_add_link(array('rel' => 'up', 'href' => $parent_href));      $variables['parent_url'] = $parent_href;      $variables['parent_title'] = check_plain($parent['title']);    }    if ($next = book_next($book_link)) {      $next_href = url($next['href']);      drupal_add_link(array('rel' => 'next', 'href' => $next_href));      $variables['next_url'] = $next_href;      $variables['next_title'] = check_plain($next['title']);    }  }  $variables['has_links'] = FALSE;  // Link variables to filter for values and set state of the flag variable.  $links = array('prev_url', 'prev_title', 'parent_url', 'parent_title', 'next_url', 'next_title');  foreach ($links as $link) {    if (isset($variables[$link])) {      // Flag when there is a value.      $variables['has_links'] = TRUE;    }    else {      // Set empty to prevent notices.      $variables[$link] = '';    }  }}/** * A recursive helper function for book_toc(). */function _book_toc_recurse($tree, $indent, &$toc, $exclude, $depth_limit) {  foreach ($tree as $data) {    if ($data['link']['depth'] > $depth_limit) {      // Don't iterate through any links on this level.      break;    }    if (!in_array($data['link']['mlid'], $exclude)) {      $toc[$data['link']['mlid']] = $indent .' '. truncate_utf8($data['link']['title'], 30, TRUE, TRUE);      if ($data['below']) {        _book_toc_recurse($data['below'], $indent .'--', $toc, $exclude, $depth_limit);      }    }  }}/** * Returns an array of book pages in table of contents order. * * @param $bid *   The ID of the book whose pages are to be listed. * @param $exclude *   Optional array of mlid values.  Any link whose mlid is in this array *   will be excluded (along with its children). * @param $depth_limit *   Any link deeper than this value will be excluded (along with its children). * @return *   An array of mlid, title pairs for use as options for selecting a book page. */function book_toc($bid, $exclude = array(), $depth_limit) {  $tree = menu_tree_all_data(book_menu_name($bid));  $toc = array();  _book_toc_recurse($tree, '', $toc, $exclude, $depth_limit);  return $toc;}/** * Process variables for book-export-html.tpl.php. * * The $variables array contains the following arguments: * - $title * - $contents * - $depth * * @see book-export-html.tpl.php */function template_preprocess_book_export_html(&$variables) {  global $base_url, $language;  $variables['title'] = check_plain($variables['title']);  $variables['base_url'] = $base_url;  $variables['language'] = $language;  $variables['language_rtl'] = ($language->direction == LANGUAGE_RTL);  $variables['head'] = drupal_get_html_head();}/** * Traverse the book tree to build printable or exportable output. * * During the traversal, the $visit_func() callback is applied to each * node, and is called recursively for each child of the node (in weight, * title order). * * @param $tree *   A subtree of the book menu hierarchy, rooted at the current page. * @param $visit_func *   A function callback to be called upon visiting a node in the tree. * @return *   The output generated in visiting each node. */function book_export_traverse($tree, $visit_func) {  $output = '';  foreach ($tree as $data) {    // Note- access checking is already performed when building the tree.    if ($node = node_load($data['link']['nid'], FALSE)) {      $children = '';      if ($data['below']) {        $children = book_export_traverse($data['below'], $visit_func);      }      if (function_exists($visit_func)) {        $output .= call_user_func($visit_func, $node, $children);      }      else {        // Use the default function.        $output .= book_node_export($node, $children);      }    }  }  return $output;}/** * Generates printer-friendly HTML for a node. * * @see book_export_traverse() * * @param $node *   The node to generate output for. * @param $children *   All the rendered child nodes within the current node. * @return *   The HTML generated for the given node. */function book_node_export($node, $children = '') {  $node->build_mode = NODE_BUILD_PRINT;  $node = node_build_content($node, FALSE, FALSE);  $node->body = drupal_render($node->content);  return theme('book_node_export_html', $node, $children);}/** * Process variables for book-node-export-html.tpl.php. * * The $variables array contains the following arguments: * - $node * - $children * * @see book-node-export-html.tpl.php */function template_preprocess_book_node_export_html(&$variables) {  $variables['depth'] = $variables['node']->book['depth'];  $variables['title'] = check_plain($variables['node']->title);  $variables['content'] = $variables['node']->body;}/** * Determine if a given node type is in the list of types allowed for books. */function book_type_is_allowed($type) {  return in_array($type, variable_get('book_allowed_types', array('book')));}/** * Implementation of hook_node_type(). * * Update book module's persistent variables if the machine-readable name of a * node type is changed. */function book_node_type($op, $type) {  switch ($op) {    case 'update':      if (!empty($type->old_type) && $type->old_type != $type->type) {        // Update the list of node types that are allowed to be added to books.        $allowed_types = variable_get('book_allowed_types', array('book'));        $key = array_search($type->old_type, $allowed_types);        if ($key !== FALSE) {          $allowed_types[$type->type] = $allowed_types[$key] ? $type->type : 0;          unset($allowed_types[$key]);          variable_set('book_allowed_types', $allowed_types);        }        // Update the setting for the "Add child page" link.        if (variable_get('book_child_type', 'book') == $type->old_type) {          variable_set('book_child_type', $type->type);        }      }      break;  }}/** * Implementation of hook_help(). */function book_help($path, $arg) {  switch ($path) {    case 'admin/help#book':      $output = '<p>'. t('The book module is suited for creating structured, multi-page hypertexts such as site resource guides, manuals, and Frequently Asked Questions (FAQs). It permits a document to have chapters, sections, subsections, etc. Authors with suitable permissions can add pages to a collaborative book, placing them into the existing document by adding them to a table of contents menu.') .'</p>';      $output .= '<p>'. t('Pages in the book hierarchy have navigation elements at the bottom of the page for moving through the text. These links lead to the previous and next pages in the book, and to the level above the current page in the book\'s structure. More comprehensive navigation may be provided by enabling the <em>book navigation block</em> on the <a href="@admin-block">blocks administration page</a>.', array('@admin-block' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('Users can select the <em>printer-friendly version</em> link visible at the bottom of a book page to generate a printer-friendly display of the page and all of its subsections. ') .'</p>';      $output .= '<p>'. t("Users with the <em>administer book outlines</em> permission can add a post of any content type to a book, by selecting the appropriate book while editing the post or by using the interface available on the post's <em>outline</em> tab.") .'</p>';      $output .= '<p>'. t('Administrators can view a list of all books on the <a href="@admin-node-book">book administration page</a>. The <em>Outline</em> page for each book allows section titles to be edited or rearranged.', array('@admin-node-book' => url('admin/content/book'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@book">Book module</a>.', array('@book' => 'http://drupal.org/handbook/modules/book/')) .'</p>';      return $output;    case 'admin/content/book':      return '<p>'. t('The book module offers a means to organize a collection of related posts, collectively known as a book. When viewed, these posts automatically display links to adjacent book pages, providing a simple navigation system for creating and reviewing structured content.') .'</p>';    case 'node/%/outline':      return '<p>'. t('The outline feature allows you to include posts in the <a href="@book">book hierarchy</a>, as well as move them within the hierarchy or to <a href="@book-admin">reorder an entire book</a>.', array('@book' => url('book'), '@book-admin' => url('admin/content/book'))) .'</p>';  }}/** * Like menu_link_load(), but adds additional data from the {book} table. * * Do not call when loading a node, since this function may call node_load(). */function book_link_load($mlid) {  if ($item = db_fetch_array(db_query("SELECT * FROM {menu_links} ml INNER JOIN {book} b ON b.mlid = ml.mlid LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = %d", $mlid))) {    _menu_link_translate($item);    return $item;  }  return FALSE;}/** * Get the data representing a subtree of the book hierarchy. * * The root of the subtree will be the link passed as a parameter, so the * returned tree will contain this item and all its descendents in the menu tree. * * @param $item *   A fully loaded menu link. * @return *   An subtree of menu links in an array, in the order they should be rendered. */function book_menu_subtree_data($item) {  static $tree = array();  // Generate a cache ID (cid) specific for this $menu_name and $item.  $cid = 'links:'. $item['menu_name'] .':subtree-cid:'. $item['mlid'];  if (!isset($tree[$cid])) {    $cache = cache_get($cid, 'cache_menu');    if ($cache && isset($cache->data)) {      // If the cache entry exists, it will just be the cid for the actual data.      // This avoids duplication of large amounts of data.      $cache = cache_get($cache->data, 'cache_menu');      if ($cache && isset($cache->data)) {        $data = $cache->data;      }    }    // If the subtree data was not in the cache, $data will be NULL.    if (!isset($data)) {      $match = array("menu_name = '%s'");      $args = array($item['menu_name']);      $i = 1;      while ($i <= MENU_MAX_DEPTH && $item["p$i"]) {        $match[] = "p$i = %d";        $args[] = $item["p$i"];        $i++;      }      $sql = "        SELECT b.*, m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, ml.*        FROM {menu_links} ml INNER JOIN {menu_router} m ON m.path = ml.router_path        INNER JOIN {book} b ON ml.mlid = b.mlid        WHERE ". implode(' AND ', $match) ."        ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC";      $data['tree'] = menu_tree_data(db_query($sql, $args), array(), $item['depth']);      $data['node_links'] = array();      menu_tree_collect_node_links($data['tree'], $data['node_links']);      // Compute the real cid for book subtree data.      $tree_cid = 'links:'. $item['menu_name'] .':subtree-data:'. md5(serialize($data));      // Cache the data, if it is not already in the cache.      if (!cache_get($tree_cid, 'cache_menu')) {        cache_set($tree_cid, $data, 'cache_menu');      }      // Cache the cid of the (shared) data using the menu and item-specific cid.      cache_set($cid, $tree_cid, 'cache_menu');    }    // Check access for the current user to each item in the tree.    menu_tree_check_access($data['tree'], $data['node_links']);    $tree[$cid] = $data['tree'];  }  return $tree[$cid];}
<?php// $Id$/** * @file * User page callbacks for the book module. *//** * Menu callback; prints a listing of all books. */function book_render() {  $book_list = array();  foreach (book_get_books() as $book) {    $book_list[] = l($book['title'], $book['href'], $book['options']);  }  return theme('item_list', $book_list);}/** * Menu callback; Generates various representation of a book page and its children. * * The function delegates the generation of output to helper functions. * The function name is derived by prepending 'book_export_' to the * given output type. So, e.g., a type of 'html' results in a call to * the function book_export_html(). * * @param $type *   A string encoding the type of output requested. The following *   types are currently supported in book module: * *   - html: HTML (printer friendly output) * *   Other types may be supported in contributed modules. * @param $nid *   An integer representing the node id (nid) of the node to export * @return *   A string representing the node and its children in the book hierarchy *   in a format determined by the $type parameter. */function book_export($type, $nid) {  $type = drupal_strtolower($type);  $export_function = 'book_export_'. $type;  if (function_exists($export_function)) {    print call_user_func($export_function, $nid);  }  else {    drupal_set_message(t('Unknown export format.'));    drupal_not_found();  }}/** * This function is called by book_export() to generate HTML for export. * * The given node is /embedded to its absolute depth in a top level * section/. For example, a child node with depth 2 in the hierarchy * is contained in (otherwise empty) &lt;div&gt; elements * corresponding to depth 0 and depth 1. This is intended to support * WYSIWYG output - e.g., level 3 sections always look like level 3 * sections, no matter their depth relative to the node selected to be * exported as printer-friendly HTML. * * @param $nid *   An integer representing the node id (nid) of the node to export. * @return *   A string containing HTML representing the node and its children in *   the book hierarchy. */function book_export_html($nid) {  if (user_access('access printer-friendly version')) {    $export_data = array();    $node = node_load($nid);    if (isset($node->book)) {      $tree = book_menu_subtree_data($node->book);      $contents = book_export_traverse($tree, 'book_node_export');    }    return theme('book_export_html', $node->title, $contents, $node->book['depth']);  }  else {    drupal_access_denied();  }}/** * Menu callback; show the outline form for a single node. */function book_outline($node) {  drupal_set_title(check_plain($node->title));  return drupal_get_form('book_outline_form', $node);}/** * Build the form to handle all book outline operations via the outline tab. * * @see book_outline_form_submit() * @see book_remove_button_submit() * * @ingroup forms */function book_outline_form(&$form_state, $node) {  if (!isset($node->book)) {    // The node is not part of any book yet - set default options.    $node->book = _book_link_defaults($node->nid);  }  else {    $node->book['original_bid'] = $node->book['bid'];  }  // Find the depth limit for the parent select.  if (!isset($node->book['parent_depth_limit'])) {    $node->book['parent_depth_limit'] = _book_parent_depth_limit($node->book);  }  $form['#node'] = $node;  $form['#id'] = 'book-outline';  _book_add_form_elements($form, $node);  $form['book']['#collapsible'] = FALSE;  $form['update'] = array(    '#type' => 'submit',    '#value' => $node->book['original_bid'] ? t('Update book outline') : t('Add to book outline'),    '#weight' => 15,  );  $form['remove'] = array(    '#type' => 'submit',    '#value' => t('Remove from book outline'),    '#access' => $node->nid != $node->book['bid'] && $node->book['bid'],    '#weight' => 20,    '#submit' => array('book_remove_button_submit'),  );  return $form;}/** * Button submit function to redirect to removal confirm form. * * @see book_outline_form() */function book_remove_button_submit($form, &$form_state) {  $form_state['redirect'] = 'node/'. $form['#node']->nid .'/outline/remove';}/** * Handles book outline form submissions from the outline tab. * * @see book_outline_form() */function book_outline_form_submit($form, &$form_state) {  $node = $form['#node'];  $form_state['redirect'] = "node/". $node->nid;  $book_link = $form_state['values']['book'];  if (!$book_link['bid']) {    drupal_set_message(t('No changes were made'));    return;  }  $book_link['menu_name'] = book_menu_name($book_link['bid']);  $node->book = $book_link;  if (_book_update_outline($node)) {    if ($node->book['parent_mismatch']) {      // This will usually only happen when JS is disabled.      drupal_set_message(t('The post has been added to the selected book. You may now position it relative to other pages.'));      $form_state['redirect'] = "node/". $node->nid ."/outline";    }    else {      drupal_set_message(t('The book outline has been updated.'));    }  }  else {    drupal_set_message(t('There was an error adding the post to the book.'), 'error');  }}/** * Menu callback; builds a form to confirm removal of a node from the book. * * @see book_remove_form_submit() * * @ingroup forms */function book_remove_form(&$form_state, $node) {  $form['#node'] = $node;  $title = array('%title' => $node->title);  if ($node->book['has_children']) {    $description = t('%title has associated child pages, which will be relocated automatically to maintain their connection to the book. To recreate the hierarchy (as it was before removing this page), %title may be added again using the Outline tab, and each of its former child pages will need to be relocated manually.', $title);  }  else {    $description = t('%title may be added to hierarchy again using the Outline tab.', $title);  }  return confirm_form($form, t('Are you sure you want to remove %title from the book hierarchy?', $title), 'node/'. $node->nid, $description, t('Remove'));}/** * Confirm form submit function to remove a node from the book. * * @see book_remove_form() */function book_remove_form_submit($form, &$form_state) {  $node = $form['#node'];  if ($node->nid != $node->book['bid']) {    // Only allowed when this is not a book (top-level page).    menu_link_delete($node->book['mlid']);    db_query('DELETE FROM {book} WHERE nid = %d', $node->nid);    drupal_set_message(t('The post has been removed from the book.'));  }  $form_state['redirect'] = 'node/'. $node->nid;}/** * AJAX callback to replace the book parent select options. * * This function is called when the selected book is changed.  It updates the * cached form (either the node form or the book outline form) and returns * rendered output to be used to replace the select containing the possible * parent pages in the newly selected book. * * @param $build_id *   The form's build_id. * @param $bid *   A bid from from among those in the form's book select. * @return *   Prints the replacement HTML in JSON format. */function book_form_update() {  $bid = $_POST['book']['bid'];  if ($form = form_get_cache($_POST['form_build_id'], $form_state)) {    // Validate the bid.    if (isset($form['book']['bid']['#options'][$bid])) {      $book_link = $form['#node']->book;      $book_link['bid'] = $bid;      // Get the new options and update the cache.      $form['book']['plid'] = _book_parent_select($book_link);      form_set_cache($_POST['form_build_id'], $form, $form_state);      // Build and render the new select element, then return it in JSON format.      $form_state = array();      $form['#post'] = array();      $form = form_builder($form['form_id']['#value'] , $form, $form_state);      $output = drupal_render($form['book']['plid']);      drupal_json(array('status' => TRUE, 'data' => $output));    }    else {      drupal_json(array('status' => FALSE, 'data' => ''));    }  }  else {    drupal_json(array('status' => FALSE, 'data' => ''));  }  exit();}
<?php// $Id$/** * @file * Admin page callbacks for the book module. *//** * Returns an administrative overview of all books. */function book_admin_overview() {  $rows = array();  foreach (book_get_books() as $book) {    $rows[] = array(l($book['title'], $book['href'], $book['options']), l(t('edit order and titles'), "admin/content/book/". $book['nid']));  }  $headers = array(t('Book'), t('Operations'));  return theme('table', $headers, $rows);}/** * Builds and returns the book settings form. * * @see book_admin_settings_validate() * * @ingroup forms */function book_admin_settings() {  $types = node_get_types('names');  $form['book_allowed_types'] = array(    '#type' => 'checkboxes',    '#title' => t('Allowed book outline types'),    '#default_value' => variable_get('book_allowed_types', array('book')),    '#options' => $types,    '#description' => t('Select content types which users with the %add-perm permission will be allowed to add to the book hierarchy. Users with the %outline-perm permission can add all content types.', array('%add-perm' => t('add content to books'),  '%outline-perm' => t('administer book outlines'))),    '#required' => TRUE,  );  $form['book_child_type'] = array(    '#type' => 'radios',    '#title' => t('Default child page type'),    '#default_value' => variable_get('book_child_type', 'book'),    '#options' => $types,    '#description' => t('The content type for the %add-child link must be one of those selected as an allowed book outline type.', array('%add-child' => t('Add child page'))),    '#required' => TRUE,  );  $form['array_filter'] = array('#type' => 'value', '#value' => TRUE);  $form['#validate'][] = 'book_admin_settings_validate';  return system_settings_form($form);}/** * Validate the book settings form. * * @see book_admin_settings() */function book_admin_settings_validate($form, &$form_state) {  $child_type = $form_state['values']['book_child_type'];  if (empty($form_state['values']['book_allowed_types'][$child_type])) {    form_set_error('book_child_type', t('The content type for the %add-child link must be one of those selected as an allowed book outline type.', array('%add-child' => t('Add child page'))));  }}/** * Build the form to administrate the hierarchy of a single book. * * @see book_admin_edit_submit() * * @ingroup forms. */function book_admin_edit($form_state, $node) {  drupal_set_title(check_plain($node->title));  $form = array();  $form['#node'] = $node;  _book_admin_table($node, $form);  $form['save'] = array(    '#type' => 'submit',    '#value' => t('Save book pages'),  );  return $form;}/** * Check that the book has not been changed while using the form. * * @see book_admin_edit() */function book_admin_edit_validate($form, &$form_state) {  if ($form_state['values']['tree_hash'] != $form_state['values']['tree_current_hash']) {    form_set_error('', t('This book has been modified by another user, the changes could not be saved.'));    $form_state['rebuild'] = TRUE;  }}/** * Handle submission of the book administrative page form. * * This function takes care to save parent menu items before their children. * Saving menu items in the incorrect order can break the menu tree. * * @see book_admin_edit() * @see menu_overview_form_submit() */function book_admin_edit_submit($form, &$form_state) {  // Save elements in the same order as defined in post rather than the form.  // This ensures parents are updated before their children, preventing orphans.  $order = array_flip(array_keys($form['#post']['table']));  $form['table'] = array_merge($order, $form['table']);  foreach (element_children($form['table']) as $key) {    if ($form['table'][$key]['#item']) {      $row = $form['table'][$key];      $values = $form_state['values']['table'][$key];      // Update menu item if moved.      if ($row['plid']['#default_value'] != $values['plid'] || $row['weight']['#default_value'] != $values['weight']) {        $row['#item']['plid'] = $values['plid'];        $row['#item']['weight'] = $values['weight'];        menu_link_save($row['#item']);      }      // Update the title if changed.      if ($row['title']['#default_value'] != $values['title']) {        $node = node_load($values['nid'], FALSE);        $node->title = $values['title'];        $node->book['link_title'] = $values['title'];        $node->revision = 1;        $node->log = t('Title changed from %original to %current.', array('%original' => $node->title, '%current' => $values['title']));        node_save($node);        watchdog('content', 'book: updated %title.', array('%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), 'node/'. $node->nid));      }    }  }  drupal_set_message(t('Updated book %title.', array('%title' => $form['#node']->title)));}/** * Build the table portion of the form for the book administration page. * * @see book_admin_edit() */function _book_admin_table($node, &$form) {  $form['table'] = array(    '#theme' => 'book_admin_table',    '#tree' => TRUE,  );  $tree = book_menu_subtree_data($node->book);  $tree = array_shift($tree); // Do not include the book item itself.  if ($tree['below']) {    $hash = sha1(serialize($tree['below']));    // Store the hash value as a hidden form element so that we can detect    // if another user changed the book hierarchy.    $form['tree_hash'] = array(      '#type' => 'hidden',      '#default_value' => $hash,    );    $form['tree_current_hash'] = array(      '#type' => 'value',      '#value' => $hash,    );    _book_admin_table_tree($tree['below'], $form['table']);  }}/** * Recursive helper to build the main table in the book administration page form. * * @see book_admin_edit() */function _book_admin_table_tree($tree, &$form) {  foreach ($tree as $data) {    $form['book-admin-'. $data['link']['nid']] = array(      '#item' => $data['link'],      'nid' => array('#type' => 'value', '#value' => $data['link']['nid']),      'depth' => array('#type' => 'value', '#value' => $data['link']['depth']),      'href' => array('#type' => 'value', '#value' => $data['link']['href']),      'title' => array(        '#type' => 'textfield',        '#default_value' => $data['link']['link_title'],        '#maxlength' => 255,        '#size' => 40,      ),      'weight' => array(        '#type' => 'weight',        '#default_value' => $data['link']['weight'],        '#delta' => 15,      ),      'plid' => array(        '#type' => 'textfield',        '#default_value' => $data['link']['plid'],        '#size' => 6,      ),      'mlid' => array(        '#type' => 'hidden',        '#default_value' => $data['link']['mlid'],      ),    );    if ($data['below']) {      _book_admin_table_tree($data['below'], $form);    }  }  return $form;}/** * Theme function for the book administration page form. * * @ingroup themeable * @see book_admin_table() */function theme_book_admin_table($form) {  drupal_add_tabledrag('book-outline', 'match', 'parent', 'book-plid', 'book-plid', 'book-mlid', TRUE, MENU_MAX_DEPTH - 2);  drupal_add_tabledrag('book-outline', 'order', 'sibling', 'book-weight');  $header = array(t('Title'), t('Weight'), t('Parent'), array('data' => t('Operations'), 'colspan' => '3'));  $rows = array();  $destination = drupal_get_destination();  $access = user_access('administer nodes');  foreach (element_children($form) as $key) {    $nid = $form[$key]['nid']['#value'];    $href = $form[$key]['href']['#value'];    // Add special classes to be used with tabledrag.js.    $form[$key]['plid']['#attributes']['class'] = 'book-plid';    $form[$key]['mlid']['#attributes']['class'] = 'book-mlid';    $form[$key]['weight']['#attributes']['class'] = 'book-weight';    $data = array(      theme('indentation', $form[$key]['depth']['#value'] - 2) . drupal_render($form[$key]['title']),      drupal_render($form[$key]['weight']),      drupal_render($form[$key]['plid']) . drupal_render($form[$key]['mlid']),      l(t('view'), $href),      $access ? l(t('edit'), 'node/'. $nid .'/edit', array('query' => $destination)) : '&nbsp',      $access ? l(t('delete'), 'node/'. $nid .'/delete', array('query' => $destination) )  : '&nbsp',    );    $row = array('data' => $data);    if (isset($form[$key]['#attributes'])) {      $row = array_merge($row, $form[$key]['#attributes']);    }    $row['class'] = empty($row['class']) ? 'draggable' : $row['class'] .' draggable';    $rows[] = $row;  }  return theme('table', $header, $rows, array('id' => 'book-outline'));}
<?php// $Id$require_once './includes/install.inc';define('MAINTENANCE_MODE', 'install');/** * The Drupal installation happens in a series of steps. We begin by verifying * that the current environment meets our minimum requirements. We then go * on to verify that settings.php is properly configured. From there we * connect to the configured database and verify that it meets our minimum * requirements. Finally we can allow the user to select an installation * profile and complete the installation process. * * @param $phase *   The installation phase we should proceed to. */function install_main() {  require_once './includes/bootstrap.inc';  drupal_bootstrap(DRUPAL_BOOTSTRAP_CONFIGURATION);  // This must go after drupal_bootstrap(), which unsets globals!  global $profile, $install_locale, $conf;  require_once './modules/system/system.install';  require_once './includes/file.inc';  // Ensure correct page headers are sent (e.g. caching)  drupal_page_header();  // Set up $language, so t() caller functions will still work.  drupal_init_language();  // Load module basics (needed for hook invokes).  include_once './includes/module.inc';  $module_list['system']['filename'] = 'modules/system/system.module';  $module_list['filter']['filename'] = 'modules/filter/filter.module';  module_list(TRUE, FALSE, FALSE, $module_list);  drupal_load('module', 'system');  drupal_load('module', 'filter');  // Install profile chosen, set the global immediately.  // This needs to be done before the theme cache gets   // initialized in drupal_maintenance_theme().  if (!empty($_GET['profile'])) {    $profile = preg_replace('/[^a-zA-Z_0-9]/', '', $_GET['profile']);  }  // Set up theme system for the maintenance page.  drupal_maintenance_theme();  // Check existing settings.php.  $verify = install_verify_settings();  if ($verify) {    // Since we have a database connection, we use the normal cache system.    // This is important, as the installer calls into the Drupal system for    // the clean URL checks, so we should maintain the cache properly.    require_once './includes/cache.inc';    $conf['cache_inc'] = './includes/cache.inc';    // Establish a connection to the database.    require_once './includes/database.inc';    db_set_active();    // Check if Drupal is installed.    $task = install_verify_drupal();    if ($task == 'done') {      install_already_done_error();    }  }  else {    // Since no persistent storage is available yet, and functions that check    // for cached data will fail, we temporarily replace the normal cache    // system with a stubbed-out version that short-circuits the actual    // caching process and avoids any errors.    require_once './includes/cache-install.inc';    $conf['cache_inc'] = './includes/cache-install.inc';    $task = NULL;  }  // No profile was passed in GET, ask the user.  if (empty($_GET['profile'])) {    if ($profile = install_select_profile()) {      install_goto("install.php?profile=$profile");    }    else {      install_no_profile_error();    }  }  // Load the profile.  require_once "./profiles/$profile/$profile.profile";  // Locale selection  if (!empty($_GET['locale'])) {    $install_locale = preg_replace('/[^a-zA-Z_0-9\-]/', '', $_GET['locale']);  }  elseif (($install_locale = install_select_locale($profile)) !== FALSE) {    install_goto("install.php?profile=$profile&locale=$install_locale");  }  // Tasks come after the database is set up  if (!$task) {    global $db_url;    if (!$verify && !empty($db_url)) {      // Do not install over a configured settings.php.      install_already_done_error();    }    // Check the installation requirements for Drupal and this profile.    install_check_requirements($profile, $verify);    // Verify existence of all required modules.    $modules = drupal_verify_profile($profile, $install_locale);    // If any error messages are set now, it means a requirement problem.    $messages = drupal_set_message();    if (!empty($messages['error'])) {      install_task_list('requirements');      drupal_set_title(st('Requirements problem'));      print theme('install_page', '');      exit;    }    // Change the settings.php information if verification failed earlier.    // Note: will trigger a redirect if database credentials change.    if (!$verify) {      install_change_settings($profile, $install_locale);    }    // Install system.module.    drupal_install_system();    // Save the list of other modules to install for the 'profile-install'    // task. variable_set() can be used now that system.module is installed    // and drupal is bootstrapped.    variable_set('install_profile_modules', array_diff($modules, array('system')));  }  // The database is set up, turn to further tasks.  install_tasks($profile, $task);}/** * Verify if Drupal is installed. */function install_verify_drupal() {  // Read the variable manually using the @ so we don't trigger an error if it fails.  $result = @db_query("SELECT value FROM {variable} WHERE name = '%s'", 'install_task');  if ($result) {    return unserialize(db_result($result));  }}/** * Verify existing settings.php */function install_verify_settings() {  global $db_prefix, $db_type, $db_url;  // Verify existing settings (if any).  if (!empty($db_url)) {    // We need this because we want to run form_get_errors.    include_once './includes/form.inc';    $url = parse_url(is_array($db_url) ? $db_url['default'] : $db_url);    $db_user = urldecode($url['user']);    $db_pass = isset($url['pass']) ? urldecode($url['pass']) : NULL;    $db_host = urldecode($url['host']);    $db_port = isset($url['port']) ? urldecode($url['port']) : '';    $db_path = ltrim(urldecode($url['path']), '/');    $settings_file = './'. conf_path(FALSE, TRUE) .'/settings.php';    $form_state = array();    _install_settings_form_validate($db_prefix, $db_type, $db_user, $db_pass, $db_host, $db_port, $db_path, $settings_file, $form_state);    if (!form_get_errors()) {      return TRUE;    }  }  return FALSE;}/** * Configure and rewrite settings.php. */function install_change_settings($profile = 'default', $install_locale = '') {  global $db_url, $db_type, $db_prefix;  $url = parse_url(is_array($db_url) ? $db_url['default'] : $db_url);  $db_user = isset($url['user']) ? urldecode($url['user']) : '';  $db_pass = isset($url['pass']) ? urldecode($url['pass']) : '';  $db_host = isset($url['host']) ? urldecode($url['host']) : '';  $db_port = isset($url['port']) ? urldecode($url['port']) : '';  $db_path = ltrim(urldecode($url['path']), '/');  $conf_path = './'. conf_path(FALSE, TRUE);  $settings_file = $conf_path .'/settings.php';  // We always need this because we want to run form_get_errors.  include_once './includes/form.inc';  install_task_list('database');  $output = drupal_get_form('install_settings_form', $profile, $install_locale, $settings_file, $db_url, $db_type, $db_prefix, $db_user, $db_pass, $db_host, $db_port, $db_path);  drupal_set_title(st('Database configuration'));  print theme('install_page', $output);  exit;}/** * Form API array definition for install_settings. */function install_settings_form(&$form_state, $profile, $install_locale, $settings_file, $db_url, $db_type, $db_prefix, $db_user, $db_pass, $db_host, $db_port, $db_path) {  if (empty($db_host)) {    $db_host = 'localhost';  }  $db_types = drupal_detect_database_types();  // If both 'mysql' and 'mysqli' are available, we disable 'mysql':  if (isset($db_types['mysqli'])) {    unset($db_types['mysql']);  }  if (count($db_types) == 0) {    $form['no_db_types'] = array(      '#value' => st('Your web server does not appear to support any common database types. Check with your hosting provider to see if they offer any databases that <a href="@drupal-databases">Drupal supports</a>.', array('@drupal-databases' => 'http://drupal.org/node/270#database')),    );  }  else {    $form['basic_options'] = array(      '#type' => 'fieldset',      '#title' => st('Basic options'),      '#description' => '<p>'. st('To set up your @drupal database, enter the following information.', array('@drupal' => drupal_install_profile_name())) .'</p>',    );    if (count($db_types) > 1) {      $form['basic_options']['db_type'] = array(        '#type' => 'radios',        '#title' => st('Database type'),        '#required' => TRUE,        '#options' => $db_types,        '#default_value' => ($db_type ? $db_type : current($db_types)),        '#description' => st('The type of database your @drupal data will be stored in.', array('@drupal' => drupal_install_profile_name())),      );      $db_path_description = st('The name of the database your @drupal data will be stored in. It must exist on your server before @drupal can be installed.', array('@drupal' => drupal_install_profile_name()));    }    else {      if (count($db_types) == 1) {        $db_types = array_values($db_types);        $form['basic_options']['db_type'] = array(          '#type' => 'hidden',          '#value' => $db_types[0],        );        $db_path_description = st('The name of the %db_type database your @drupal data will be stored in. It must exist on your server before @drupal can be installed.', array('%db_type' => $db_types[0], '@drupal' => drupal_install_profile_name()));      }    }    // Database name    $form['basic_options']['db_path'] = array(      '#type' => 'textfield',      '#title' => st('Database name'),      '#default_value' => $db_path,      '#size' => 45,      '#required' => TRUE,      '#description' => $db_path_description    );    // Database username    $form['basic_options']['db_user'] = array(      '#type' => 'textfield',      '#title' => st('Database username'),      '#default_value' => $db_user,      '#size' => 45,      '#required' => TRUE,    );    // Database username    $form['basic_options']['db_pass'] = array(      '#type' => 'password',      '#title' => st('Database password'),      '#default_value' => $db_pass,      '#size' => 45,    );    $form['advanced_options'] = array(      '#type' => 'fieldset',      '#title' => st('Advanced options'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#description' => st("These options are only necessary for some sites. If you're not sure what you should enter here, leave the default settings or check with your hosting provider.")    );    // Database host    $form['advanced_options']['db_host'] = array(      '#type' => 'textfield',      '#title' => st('Database host'),      '#default_value' => $db_host,      '#size' => 45,      // Hostnames can be 255 characters long.      '#maxlength' => 255,      '#required' => TRUE,      '#description' => st('If your database is located on a different server, change this.'),    );    // Database port    $form['advanced_options']['db_port'] = array(      '#type' => 'textfield',      '#title' => st('Database port'),      '#default_value' => $db_port,      '#size' => 45,      // The maximum port number is 65536, 5 digits.      '#maxlength' => 5,      '#description' => st('If your database server is listening to a non-standard port, enter its number.'),    );    // Table prefix    $prefix = ($profile == 'default') ? 'drupal_' : $profile .'_';    $form['advanced_options']['db_prefix'] = array(      '#type' => 'textfield',      '#title' => st('Table prefix'),      '#default_value' => $db_prefix,      '#size' => 45,      '#description' => st('If more than one application will be sharing this database, enter a table prefix such as %prefix for your @drupal site here.', array('@drupal' => drupal_install_profile_name(), '%prefix' => $prefix)),    );    $form['save'] = array(      '#type' => 'submit',      '#value' => st('Save and continue'),    );    $form['errors'] = array();    $form['settings_file'] = array('#type' => 'value', '#value' => $settings_file);    $form['_db_url'] = array('#type' => 'value');    $form['#action'] = "install.php?profile=$profile". ($install_locale ? "&locale=$install_locale" : '');    $form['#redirect'] = FALSE;  }  return $form;}/** * Form API validate for install_settings form. */function install_settings_form_validate($form, &$form_state) {  global $db_url;  _install_settings_form_validate($form_state['values']['db_prefix'], $form_state['values']['db_type'], $form_state['values']['db_user'], $form_state['values']['db_pass'], $form_state['values']['db_host'], $form_state['values']['db_port'], $form_state['values']['db_path'], $form_state['values']['settings_file'], $form_state, $form);}/** * Helper function for install_settings_validate. */function _install_settings_form_validate($db_prefix, $db_type, $db_user, $db_pass, $db_host, $db_port, $db_path, $settings_file, &$form_state, $form = NULL) {  global $db_url;  // Verify the table prefix  if (!empty($db_prefix) && is_string($db_prefix) && !preg_match('/^[A-Za-z0-9_.]+$/', $db_prefix)) {    form_set_error('db_prefix', st('The database table prefix you have entered, %db_prefix, is invalid. The table prefix can only contain alphanumeric characters, periods, or underscores.', array('%db_prefix' => $db_prefix)), 'error');  }  if (!empty($db_port) && !is_numeric($db_port)) {    form_set_error('db_port', st('Database port must be a number.'));  }  // Check database type  if (!isset($form)) {    $_db_url = is_array($db_url) ? $db_url['default'] : $db_url;    $db_type = substr($_db_url, 0, strpos($_db_url, '://'));  }  $databases = drupal_detect_database_types();  if (!in_array($db_type, $databases)) {    form_set_error('db_type', st("In your %settings_file file you have configured @drupal to use a %db_type server, however your PHP installation currently does not support this database type.", array('%settings_file' => $settings_file, '@drupal' => drupal_install_profile_name(), '%db_type' => $db_type)));  }  else {    // Verify    $db_url = $db_type .'://'. urlencode($db_user) . ($db_pass ? ':'. urlencode($db_pass) : '') .'@'. ($db_host ? urlencode($db_host) : 'localhost') . ($db_port ? ":$db_port" : '') .'/'. urlencode($db_path);    if (isset($form)) {      form_set_value($form['_db_url'], $db_url, $form_state);    }    $success = array();    $function = 'drupal_test_'. $db_type;    if (!$function($db_url, $success)) {      if (isset($success['CONNECT'])) {        form_set_error('db_type', st('In order for Drupal to work, and to continue with the installation process, you must resolve all permission issues reported above. We were able to verify that we have permission for the following commands: %commands. For more help with configuring your database server, see the <a href="http://drupal.org/node/258">Installation and upgrading handbook</a>. If you are unsure what any of this means you should probably contact your hosting provider.', array('%commands' => implode($success, ', '))));      }      else {        form_set_error('db_type', '');      }    }  }}/** * Form API submit for install_settings form. */function install_settings_form_submit($form, &$form_state) {  global $profile, $install_locale;  // Update global settings array and save  $settings['db_url'] = array(    'value'    => $form_state['values']['_db_url'],    'required' => TRUE,  );  $settings['db_prefix'] = array(    'value'    => $form_state['values']['db_prefix'],    'required' => TRUE,  );  drupal_rewrite_settings($settings);  // Continue to install profile step  install_goto("install.php?profile=$profile". ($install_locale ? "&locale=$install_locale" : ''));}/** * Find all .profile files. */function install_find_profiles() {  return file_scan_directory('./profiles', '\.profile$', array('.', '..', 'CVS'), 0, TRUE, 'name', 0);}/** * Allow admin to select which profile to install. * * @return *   The selected profile. */function install_select_profile() {  include_once './includes/form.inc';  $profiles = install_find_profiles();  // Don't need to choose profile if only one available.  if (sizeof($profiles) == 1) {    $profile = array_pop($profiles);    require_once $profile->filename;    return $profile->name;  }  elseif (sizeof($profiles) > 1) {    foreach ($profiles as $profile) {      if (!empty($_POST['profile']) && ($_POST['profile'] == $profile->name)) {        return $profile->name;      }    }    install_task_list('profile-select');    drupal_set_title(st('Select an installation profile'));    print theme('install_page', drupal_get_form('install_select_profile_form', $profiles));    exit;  }}/** * Form API array definition for the profile selection form. * * @param $form_state *   Array of metadata about state of form processing. * @param $profile_files *   Array of .profile files, as returned from file_scan_directory(). */function install_select_profile_form(&$form_state, $profile_files) {  $profiles = array();  $names = array();  foreach ($profile_files as $profile) {    include_once($profile->filename);    // Load profile details and store them for later retrieval.    $function = $profile->name .'_profile_details';    if (function_exists($function)) {      $details = $function();    }    $profiles[$profile->name] = $details;    // Determine the name of the profile; default to file name if defined name    // is unspecified.    $name = isset($details['name']) ? $details['name'] : $profile->name;    $names[$profile->name] = $name;  }  // Display radio buttons alphabetically by human-readable name.   natcasesort($names);  foreach ($names as $profile => $name) {    $form['profile'][$name] = array(      '#type' => 'radio',      '#value' => 'default',      '#return_value' => $profile,      '#title' => $name,      '#description' => isset($profiles[$profile]['description']) ? $profiles[$profile]['description'] : '',      '#parents' => array('profile'),    );  }  $form['submit'] =  array(    '#type' => 'submit',    '#value' => st('Save and continue'),  );  return $form;}/** * Find all .po files for the current profile. */function install_find_locales($profilename) {  $locales = file_scan_directory('./profiles/'. $profilename .'/translations', '\.po$', array('.', '..', 'CVS'), 0, FALSE);  array_unshift($locales, (object) array('name' => 'en'));  return $locales;}/** * Allow admin to select which locale to use for the current profile. * * @return *   The selected language. */function install_select_locale($profilename) {  include_once './includes/file.inc';  include_once './includes/form.inc';  // Find all available locales.  $locales = install_find_locales($profilename);  // If only the built-in (English) language is available,  // and we are using the default profile, inform the user  // that the installer can be localized. Otherwise we assume  // the user know what he is doing.  if (count($locales) == 1) {    if ($profilename == 'default') {      install_task_list('locale-select');      drupal_set_title(st('Choose language'));      if (!empty($_GET['localize'])) {        $output = '<p>'. st('With the addition of an appropriate translation package, this installer is capable of proceeding in another language of your choice. To install and use Drupal in a language other than English:') .'</p>';        $output .= '<ul><li>'. st('Determine if <a href="@translations" target="_blank">a translation of this Drupal version</a> is available in your language of choice. A translation is provided via a translation package; each translation package enables the display of a specific version of Drupal in a specific language. Not all languages are available for every version of Drupal.', array('@translations' => 'http://drupal.org/project/translations')) .'</li>';        $output .= '<li>'. st('If an alternative translation package of your choice is available, download and extract its contents to your Drupal root directory.') .'</li>';        $output .= '<li>'. st('Return to choose language using the second link below and select your desired language from the displayed list. Reloading the page allows the list to automatically adjust to the presence of new translation packages.') .'</li>';        $output .= '</ul><p>'. st('Alternatively, to install and use Drupal in English, or to defer the selection of an alternative language until after installation, select the first link below.') .'</p>';        $output .= '<p>'. st('How should the installation continue?') .'</p>';        $output .= '<ul><li><a href="install.php?profile='. $profilename .'&amp;locale=en">'. st('Continue installation in English') .'</a></li><li><a href="install.php?profile='. $profilename .'">'. st('Return to choose a language') .'</a></li></ul>';      }      else {        $output = '<ul><li><a href="install.php?profile='. $profilename .'&amp;locale=en">'. st('Install Drupal in English') .'</a></li><li><a href="install.php?profile='. $profilename .'&amp;localize=true">'. st('Learn how to install Drupal in other languages') .'</a></li></ul>';      }      print theme('install_page', $output);      exit;    }    // One language, but not the default profile, assume    // the user knows what he is doing.    return FALSE;  }  else {    // Allow profile to pre-select the language, skipping the selection.    $function = $profilename .'_profile_details';    if (function_exists($function)) {      $details = $function();      if (isset($details['language'])) {        foreach ($locales as $locale) {          if ($details['language'] == $locale->name) {            return $locale->name;          }        }      }    }    if (!empty($_POST['locale'])) {      foreach ($locales as $locale) {        if ($_POST['locale'] == $locale->name) {          return $locale->name;        }      }    }    install_task_list('locale-select');    drupal_set_title(st('Choose language'));    print theme('install_page', drupal_get_form('install_select_locale_form', $locales));    exit;  }}/** * Form API array definition for language selection. */function install_select_locale_form(&$form_state, $locales) {  include_once './includes/locale.inc';  $languages = _locale_get_predefined_list();  foreach ($locales as $locale) {    // Try to use verbose locale name    $name = $locale->name;    if (isset($languages[$name])) {      $name = $languages[$name][0] . (isset($languages[$name][1]) ? ' '. st('(@language)', array('@language' => $languages[$name][1])) : '');    }    $form['locale'][$locale->name] = array(      '#type' => 'radio',      '#return_value' => $locale->name,      '#default_value' => ($locale->name == 'en' ? TRUE : FALSE),      '#title' => $name . ($locale->name == 'en' ? ' '. st('(built-in)') : ''),      '#parents' => array('locale')    );  }  $form['submit'] =  array(    '#type' => 'submit',    '#value' => st('Select language'),  );  return $form;}/** * Show an error page when there are no profiles available. */function install_no_profile_error() {  install_task_list('profile-select');  drupal_set_title(st('No profiles available'));  print theme('install_page', '<p>'. st('We were unable to find any installer profiles. Installer profiles tell us what modules to enable and what schema to install in the database. A profile is necessary to continue with the installation process.') .'</p>');  exit;}/** * Show an error page when Drupal has already been installed. */function install_already_done_error() {  global $base_url;  drupal_set_title(st('Drupal already installed'));  print theme('install_page', st('<ul><li>To start over, you must empty your existing database.</li><li>To install to a different database, edit the appropriate <em>settings.php</em> file in the <em>sites</em> folder.</li><li>To upgrade an existing installation, proceed to the <a href="@base-url/update.php">update script</a>.</li><li>View your <a href="@base-url">existing site</a>.</li></ul>', array('@base-url' => $base_url)));  exit;}/** * Tasks performed after the database is initialized. */function install_tasks($profile, $task) {  global $base_url, $install_locale;  // Bootstrap newly installed Drupal, while preserving existing messages.  $messages = isset($_SESSION['messages']) ? $_SESSION['messages'] : '';  drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);  $_SESSION['messages'] = $messages;  // URL used to direct page requests.  $url = $base_url .'/install.php?locale='. $install_locale .'&profile='. $profile;  // Build a page for final tasks.  if (empty($task)) {    variable_set('install_task', 'profile-install');    $task = 'profile-install';  }  // We are using a list of if constructs here to allow for  // passing from one task to the other in the same request.  // Install profile modules.  if ($task == 'profile-install') {    $modules = variable_get('install_profile_modules', array());    $files = module_rebuild_cache();    variable_del('install_profile_modules');    $operations = array();    foreach ($modules as $module) {      $operations[] = array('_install_module_batch', array($module, $files[$module]->info['name']));    }    $batch = array(      'operations' => $operations,      'finished' => '_install_profile_batch_finished',      'title' => st('Installing @drupal', array('@drupal' => drupal_install_profile_name())),      'error_message' => st('The installation has encountered an error.'),    );    // Start a batch, switch to 'profile-install-batch' task. We need to    // set the variable here, because batch_process() redirects.    variable_set('install_task', 'profile-install-batch');    batch_set($batch);    batch_process($url, $url);  }  // We are running a batch install of the profile's modules.  // This might run in multiple HTTP requests, constantly redirecting  // to the same address, until the batch finished callback is invoked  // and the task advances to 'locale-initial-import'.  if ($task == 'profile-install-batch') {    include_once 'includes/batch.inc';    $output = _batch_page();  }  // Import interface translations for the enabled modules.  if ($task == 'locale-initial-import') {    if (!empty($install_locale) && ($install_locale != 'en')) {      include_once 'includes/locale.inc';      // Enable installation language as default site language.      locale_add_language($install_locale, NULL, NULL, NULL, NULL, NULL, 1, TRUE);      // Collect files to import for this language.      $batch = locale_batch_by_language($install_locale, '_install_locale_initial_batch_finished');      if (!empty($batch)) {        // Remember components we cover in this batch set.        variable_set('install_locale_batch_components', $batch['#components']);        // Start a batch, switch to 'locale-batch' task. We need to        // set the variable here, because batch_process() redirects.        variable_set('install_task', 'locale-initial-batch');        batch_set($batch);        batch_process($url, $url);      }    }    // Found nothing to import or not foreign language, go to next task.    $task = 'configure';  }  if ($task == 'locale-initial-batch') {    include_once 'includes/batch.inc';    include_once 'includes/locale.inc';    $output = _batch_page();  }  if ($task == 'configure') {    if (variable_get('site_name', FALSE) || variable_get('site_mail', FALSE)) {      // Site already configured: This should never happen, means re-running      // the installer, possibly by an attacker after the 'install_task' variable      // got accidentally blown somewhere. Stop it now.      install_already_done_error();    }    $form = drupal_get_form('install_configure_form', $url);    if (!variable_get('site_name', FALSE) && !variable_get('site_mail', FALSE)) {      // Not submitted yet: Prepare to display the form.      $output = $form;      drupal_set_title(st('Configure site'));      // Warn about settings.php permissions risk      $settings_dir = './'. conf_path();      $settings_file = $settings_dir .'/settings.php';      if (!drupal_verify_install_file($settings_file, FILE_EXIST|FILE_READABLE|FILE_NOT_WRITABLE) || !drupal_verify_install_file($settings_dir, FILE_NOT_WRITABLE, 'dir')) {        drupal_set_message(st('All necessary changes to %dir and %file have been made, so you should remove write permissions to them now in order to avoid security risks. If you are unsure how to do so, please consult the <a href="@handbook_url">on-line handbook</a>.', array('%dir' => $settings_dir, '%file' => $settings_file, '@handbook_url' => 'http://drupal.org/getting-started')), 'error');      }      else {        drupal_set_message(st('All necessary changes to %dir and %file have been made. They have been set to read-only for security.', array('%dir' => $settings_dir, '%file' => $settings_file)));      }      // Add JavaScript validation.      _user_password_dynamic_validation();      drupal_add_js(drupal_get_path('module', 'system') .'/system.js', 'module');      // We add these strings as settings because JavaScript translation does not      // work on install time.      drupal_add_js(array('copyFieldValue' => array('edit-site-mail' => array('edit-account-mail')), 'cleanURL' => array('success' => st('Your server has been successfully tested to support this feature.'), 'failure' => st('Your system configuration does not currently support this feature. The <a href="http://drupal.org/node/15365">handbook page on Clean URLs</a> has additional troubleshooting information.'), 'testing' => st('Testing clean URLs...'))), 'setting');      drupal_add_js('// Global Killswitchif (Drupal.jsEnabled) {  $(document).ready(function() {    Drupal.cleanURLsInstallCheck();    Drupal.setDefaultTimezone();  });}', 'inline');      // Build menu to allow clean URL check.      menu_rebuild();    }    else {      $task = 'profile';    }  }  // If found an unknown task or the 'profile' task, which is  // reserved for profiles, hand over the control to the profile,  // so it can run any number of custom tasks it defines.  if (!in_array($task, install_reserved_tasks())) {    $function = $profile .'_profile_tasks';    if (function_exists($function)) {      // The profile needs to run more code, maybe even more tasks.      // $task is sent through as a reference and may be changed!      $output = $function($task, $url);    }    // If the profile doesn't move on to a new task we assume    // that it is done.    if ($task == 'profile') {      $task = 'profile-finished';    }  }  // Profile custom tasks are done, so let the installer regain  // control and proceed with importing the remaining translations.  if ($task == 'profile-finished') {    if (!empty($install_locale) && ($install_locale != 'en')) {      include_once 'includes/locale.inc';      // Collect files to import for this language. Skip components      // already covered in the initial batch set.      $batch = locale_batch_by_language($install_locale, '_install_locale_remaining_batch_finished', variable_get('install_locale_batch_components', array()));      // Remove temporary variable.      variable_del('install_locale_batch_components');      if (!empty($batch)) {        // Start a batch, switch to 'locale-remaining-batch' task. We need to        // set the variable here, because batch_process() redirects.        variable_set('install_task', 'locale-remaining-batch');        batch_set($batch);        batch_process($url, $url);      }    }    // Found nothing to import or not foreign language, go to next task.    $task = 'finished';  }  if ($task == 'locale-remaining-batch') {    include_once 'includes/batch.inc';    include_once 'includes/locale.inc';    $output = _batch_page();  }  // Display a 'finished' page to user.  if ($task == 'finished') {    drupal_set_title(st('@drupal installation complete', array('@drupal' => drupal_install_profile_name())));    $messages = drupal_set_message();    $output = '<p>'. st('Congratulations, @drupal has been successfully installed.', array('@drupal' => drupal_install_profile_name())) .'</p>';    $output .= '<p>'. (isset($messages['error']) ? st('Please review the messages above before continuing on to <a href="@url">your new site</a>.', array('@url' => url(''))) : st('You may now visit <a href="@url">your new site</a>.', array('@url' => url('')))) .'</p>';    $task = 'done';  }  // The end of the install process. Remember profile used.  if ($task == 'done') {    // Rebuild menu to get content type links registered by the profile,    // and possibly any other menu items created through the tasks.    menu_rebuild();    // Register actions declared by any modules.    actions_synchronize();    // Randomize query-strings on css/js files, to hide the fact that    // this is a new install, not upgraded yet.    _drupal_flush_css_js();    variable_set('install_profile', $profile);  }  // Set task for user, and remember the task in the database.  install_task_list($task);  variable_set('install_task', $task);  // Output page, if some output was required. Otherwise it is possible  // that we are printing a JSON page and theme output should not be there.  if (isset($output)) {    print theme('maintenance_page', $output);  }}/** * Batch callback for batch installation of modules. */function _install_module_batch($module, $module_name, &$context) {  _drupal_install_module($module);  // We enable the installed module right away, so that the module will be  // loaded by drupal_bootstrap in subsequent batch requests, and other  // modules possibly depending on it can safely perform their installation  // steps.  module_enable(array($module));  $context['results'][] = $module;  $context['message'] = st('Installed %module module.', array('%module' => $module_name));}/** * Finished callback for the modules install batch. * * Advance installer task to language import. */function _install_profile_batch_finished($success, $results) {  variable_set('install_task', 'locale-initial-import');}/** * Finished callback for the first locale import batch. * * Advance installer task to the configure screen. */function _install_locale_initial_batch_finished($success, $results) {  variable_set('install_task', 'configure');}/** * Finished callback for the second locale import batch. * * Advance installer task to the finished screen. */function _install_locale_remaining_batch_finished($success, $results) {  variable_set('install_task', 'finished');}/** * The list of reserved tasks to run in the installer. */function install_reserved_tasks() {  return array('configure', 'profile-install', 'profile-install-batch', 'locale-initial-import', 'locale-initial-batch', 'profile-finished', 'locale-remaining-batch', 'finished', 'done');}/** * Check installation requirements and report any errors. */function install_check_requirements($profile, $verify) {  // If Drupal is not set up already, we need to create a settings file.  if (!$verify) {    $writable = FALSE;    $conf_path = './'. conf_path(FALSE, TRUE);    $settings_file = $conf_path .'/settings.php';    $file = $conf_path;    $exists = FALSE;    // Verify that the directory exists.    if (drupal_verify_install_file($conf_path, FILE_EXIST, 'dir')) {      // Check to make sure a settings.php already exists.      $file = $settings_file;      if (drupal_verify_install_file($settings_file, FILE_EXIST)) {        $exists = TRUE;        // If it does, make sure it is writable.        $writable = drupal_verify_install_file($settings_file, FILE_READABLE|FILE_WRITABLE);      }    }    if (!$exists) {      drupal_set_message(st('The @drupal installer requires that you create a settings file as part of the installation process.<ol><li>Copy the %default_file file to %file.</li><li>Change file permissions so that it is writable by the web server. If you are unsure how to grant file permissions, please consult the <a href="@handbook_url">on-line handbook</a>.</li></ol>More details about installing Drupal are available in INSTALL.txt.', array('@drupal' => drupal_install_profile_name(), '%file' => $file, '%default_file' => $conf_path .'/default.settings.php', '@handbook_url' => 'http://drupal.org/server-permissions')), 'error');    }    elseif (!$writable) {      drupal_set_message(st('The @drupal installer requires write permissions to %file during the installation process. If you are unsure how to grant file permissions, please consult the <a href="@handbook_url">on-line handbook</a>.', array('@drupal' => drupal_install_profile_name(), '%file' => $file, '@handbook_url' => 'http://drupal.org/server-permissions')), 'error');    }  }  // Check the other requirements.  $requirements = drupal_check_profile($profile);  $severity = drupal_requirements_severity($requirements);  // If there are issues, report them.  if ($severity == REQUIREMENT_ERROR) {    foreach ($requirements as $requirement) {      if (isset($requirement['severity']) && $requirement['severity'] == REQUIREMENT_ERROR) {        $message = $requirement['description'];        if (isset($requirement['value']) && $requirement['value']) {          $message .= ' ('. st('Currently using !item !version', array('!item' => $requirement['title'], '!version' => $requirement['value'])) .')';        }        drupal_set_message($message, 'error');      }    }  }  if ($severity == REQUIREMENT_WARNING) {    foreach ($requirements as $requirement) {      if (isset($requirement['severity']) && $requirement['severity'] == REQUIREMENT_WARNING) {        $message = $requirement['description'];        if (isset($requirement['value']) && $requirement['value']) {          $message .= ' ('. st('Currently using !item !version', array('!item' => $requirement['title'], '!version' => $requirement['value'])) .')';        }        drupal_set_message($message, 'warning');      }    }  } }/** * Add the installation task list to the current page. */function install_task_list($active = NULL) {  // Default list of tasks.  $tasks = array(    'profile-select'        => st('Choose profile'),    'locale-select'         => st('Choose language'),    'requirements'          => st('Verify requirements'),    'database'              => st('Set up database'),    'profile-install-batch' => st('Install profile'),    'locale-initial-batch'  => st('Set up translations'),    'configure'             => st('Configure site'),  );  $profiles = install_find_profiles();  $profile = isset($_GET['profile']) && isset($profiles[$_GET['profile']]) ? $_GET['profile'] : '.';  $locales = install_find_locales($profile);  // If we have only one profile, remove 'Choose profile'  // and rename 'Install profile'.  if (count($profiles) == 1) {    unset($tasks['profile-select']);    $tasks['profile-install-batch'] = st('Install site');  }  // Add tasks defined by the profile.  if ($profile) {    $function = $profile .'_profile_task_list';    if (function_exists($function)) {      $result = $function();      if (is_array($result)) {        $tasks += $result;      }    }  }  if (count($locales) < 2 || empty($_GET['locale']) || $_GET['locale'] == 'en') {    // If not required, remove translation import from the task list.    unset($tasks['locale-initial-batch']);  }  else {    // If required, add remaining translations import task.    $tasks += array('locale-remaining-batch' => st('Finish translations'));  }  // Add finished step as the last task.  $tasks += array(    'finished'     => st('Finished')  );  // Let the theming function know that 'finished' and 'done'  // include everything, so every step is completed.  if (in_array($active, array('finished', 'done'))) {    $active = NULL;  }  drupal_set_content('left', theme_task_list($tasks, $active));}/** * Form API array definition for site configuration. */function install_configure_form(&$form_state, $url) {  $form['intro'] = array(    '#value' => st('To configure your website, please provide the following information.'),    '#weight' => -10,  );  $form['site_information'] = array(    '#type' => 'fieldset',    '#title' => st('Site information'),    '#collapsible' => FALSE,  );  $form['site_information']['site_name'] = array(    '#type' => 'textfield',    '#title' => st('Site name'),    '#required' => TRUE,    '#weight' => -20,  );  $form['site_information']['site_mail'] = array(    '#type' => 'textfield',    '#title' => st('Site e-mail address'),    '#default_value' => ini_get('sendmail_from'),    '#description' => st("The <em>From</em> address in automated e-mails sent during registration and new password requests, and other notifications. (Use an address ending in your site's domain to help prevent this e-mail being flagged as spam.)"),    '#required' => TRUE,    '#weight' => -15,  );  $form['admin_account'] = array(    '#type' => 'fieldset',    '#title' => st('Administrator account'),    '#collapsible' => FALSE,  );  $form['admin_account']['account']['#tree'] = TRUE;  $form['admin_account']['markup'] = array(    '#value' => '<p class="description">'. st('The administrator account has complete access to the site; it will automatically be granted all permissions and can perform any administrative activity. This will be the only account that can perform certain activities, so keep its credentials safe.') .'</p>',    '#weight' => -10,  );  $form['admin_account']['account']['name'] = array('#type' => 'textfield',    '#title' => st('Username'),    '#maxlength' => USERNAME_MAX_LENGTH,    '#description' => st('Spaces are allowed; punctuation is not allowed except for periods, hyphens, and underscores.'),    '#required' => TRUE,    '#weight' => -10,  );  $form['admin_account']['account']['mail'] = array('#type' => 'textfield',    '#title' => st('E-mail address'),    '#maxlength' => EMAIL_MAX_LENGTH,    '#description' => st('All e-mails from the system will be sent to this address. The e-mail address is not made public and will only be used if you wish to receive a new password or wish to receive certain news or notifications by e-mail.'),    '#required' => TRUE,    '#weight' => -5,  );  $form['admin_account']['account']['pass'] = array(    '#type' => 'password_confirm',    '#required' => TRUE,    '#size' => 25,    '#weight' => 0,  );  $form['server_settings'] = array(    '#type' => 'fieldset',    '#title' => st('Server settings'),    '#collapsible' => FALSE,  );  $form['server_settings']['date_default_timezone'] = array(    '#type' => 'select',    '#title' => st('Default time zone'),    '#default_value' => 0,    '#options' => _system_zonelist(),    '#description' => st('By default, dates in this site will be displayed in the chosen time zone.'),    '#weight' => 5,  );  $form['server_settings']['clean_url'] = array(    '#type' => 'radios',    '#title' => st('Clean URLs'),    '#default_value' => 0,    '#options' => array(0 => st('Disabled'), 1 => st('Enabled')),    '#description' => st('This option makes Drupal emit "clean" URLs (i.e. without <code>?q=</code> in the URL).'),    '#disabled' => TRUE,    '#prefix' => '<div id="clean-url" class="install">',    '#suffix' => '</div>',    '#weight' => 10,  );  $form['server_settings']['update_status_module'] = array(    '#type' => 'checkboxes',    '#title' => st('Update notifications'),    '#options' => array(1 => st('Check for updates automatically')),    '#default_value' => array(1),    '#description' => st('With this option enabled, Drupal will notify you when new releases are available. This will significantly enhance your site\'s security and is <strong>highly recommended</strong>. This requires your site to periodically send anonymous information on its installed components to <a href="@drupal">drupal.org</a>. For more information please see the <a href="@update">update notification information</a>.', array('@drupal' => 'http://drupal.org', '@update' => 'http://drupal.org/handbook/modules/update')),    '#weight' => 15,  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => st('Save and continue'),    '#weight' => 15,  );  $form['#action'] = $url;  $form['#redirect'] = FALSE;  // Allow the profile to alter this form. $form_state isn't available  // here, but to conform to the hook_form_alter() signature, we pass  // an empty array.  $hook_form_alter = $_GET['profile'] .'_form_alter';  if (function_exists($hook_form_alter)) {    $hook_form_alter($form, array(), 'install_configure');  }  return $form;}/** * Form API validate for the site configuration form. */function install_configure_form_validate($form, &$form_state) {  if ($error = user_validate_name($form_state['values']['account']['name'])) {    form_error($form['admin_account']['account']['name'], $error);  }  if ($error = user_validate_mail($form_state['values']['account']['mail'])) {    form_error($form['admin_account']['account']['mail'], $error);  }  if ($error = user_validate_mail($form_state['values']['site_mail'])) {    form_error($form['site_information']['site_mail'], $error);  }}/** * Form API submit for the site configuration form. */function install_configure_form_submit($form, &$form_state) {  global $user;  variable_set('site_name', $form_state['values']['site_name']);  variable_set('site_mail', $form_state['values']['site_mail']);  variable_set('date_default_timezone', $form_state['values']['date_default_timezone']);  // Enable update.module if this option was selected.  if ($form_state['values']['update_status_module'][1]) {    drupal_install_modules(array('update'));  }  // Turn this off temporarily so that we can pass a password through.  variable_set('user_email_verification', FALSE);  $form_state['old_values'] = $form_state['values'];  $form_state['values'] = $form_state['values']['account'];  // We precreated user 1 with placeholder values. Let's save the real values.  $account = user_load(1);  $merge_data = array('init' => $form_state['values']['mail'], 'roles' => array(), 'status' => 1);  user_save($account, array_merge($form_state['values'], $merge_data));  // Log in the first user.  user_authenticate($form_state['values']);  $form_state['values'] = $form_state['old_values'];  unset($form_state['old_values']);  variable_set('user_email_verification', TRUE);  if (isset($form_state['values']['clean_url'])) {    variable_set('clean_url', $form_state['values']['clean_url']);  }  // The user is now logged in, but has no session ID yet, which  // would be required later in the request, so remember it.  $user->sid = session_id();  // Record when this install ran.  variable_set('install_time', time());}// Start the installer.install_main();
<?php// $Id$/** * Test and report Drupal installation requirements. * * @param $phase *   The current system installation phase. * @return *   An array of system requirements. */function system_requirements($phase) {  $requirements = array();  // Ensure translations don't break at install time  $t = get_t();  // Report Drupal version  if ($phase == 'runtime') {    $requirements['drupal'] = array(      'title' => $t('Drupal'),      'value' => VERSION,      'severity' => REQUIREMENT_INFO,      'weight' => -10,    );  }  // Web server information.  $software = $_SERVER['SERVER_SOFTWARE'];  $requirements['webserver'] = array(    'title' => $t('Web server'),    'value' => $software,  );  // Test PHP version  $requirements['php'] = array(    'title' => $t('PHP'),    'value' => ($phase == 'runtime') ? l(phpversion(), 'admin/reports/status/php') : phpversion(),  );  if (version_compare(phpversion(), DRUPAL_MINIMUM_PHP) < 0) {    $requirements['php']['description'] = $t('Your PHP installation is too old. Drupal requires at least PHP %version.', array('%version' => DRUPAL_MINIMUM_PHP));    $requirements['php']['severity'] = REQUIREMENT_ERROR;  }  // Test PHP register_globals setting.  $requirements['php_register_globals'] = array(    'title' => $t('PHP register globals'),  );  $register_globals = trim(ini_get('register_globals'));  // Unfortunately, ini_get() may return many different values, and we can't  // be certain which values mean 'on', so we instead check for 'not off'  // since we never want to tell the user that their site is secure  // (register_globals off), when it is in fact on. We can only guarantee  // register_globals is off if the value returned is 'off', '', or 0.  if (!empty($register_globals) && strtolower($register_globals) != 'off') {    $requirements['php_register_globals']['description'] = $t('<em>register_globals</em> is enabled. Drupal requires this configuration directive to be disabled. Your site may not be secure when <em>register_globals</em> is enabled. The PHP manual has instructions for <a href="http://php.net/configuration.changes">how to change configuration settings</a>.');    $requirements['php_register_globals']['severity'] = REQUIREMENT_ERROR;    $requirements['php_register_globals']['value'] = $t("Enabled ('@value')", array('@value' => $register_globals));  }  else {    $requirements['php_register_globals']['value'] = $t('Disabled');  }  // Test PHP memory_limit  $memory_limit = ini_get('memory_limit');  $requirements['php_memory_limit'] = array(    'title' => $t('PHP memory limit'),    'value' => $memory_limit == -1 ? t('-1 (Unlimited)') : $memory_limit,  );  if ($memory_limit && $memory_limit != -1 && parse_size($memory_limit) < parse_size(DRUPAL_MINIMUM_PHP_MEMORY_LIMIT)) {    $description = '';    if ($phase == 'install') {      $description = $t('Consider increasing your PHP memory limit to %memory_minimum_limit to help prevent errors in the installation process.', array('%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));    }    elseif ($phase == 'update') {      $description = $t('Consider increasing your PHP memory limit to %memory_minimum_limit to help prevent errors in the update process.', array('%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));    }    elseif ($phase == 'runtime') {      $description = $t('Depending on your configuration, Drupal can run with a %memory_limit PHP memory limit. However, a %memory_minimum_limit PHP memory limit or above is recommended, especially if your site uses additional custom or contributed modules.', array('%memory_limit' => $memory_limit, '%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));    }    if (!empty($description)) {      if ($php_ini_path = get_cfg_var('cfg_file_path')) {        $description .= ' '. $t('Increase the memory limit by editing the memory_limit parameter in the file %configuration-file and then restart your web server (or contact your system administrator or hosting provider for assistance).', array('%configuration-file' => $php_ini_path));      }      else {        $description .= ' '. $t('Contact your system administrator or hosting provider for assistance with increasing your PHP memory limit.');      }      $requirements['php_memory_limit']['description'] = $description .' '. $t('See the <a href="@url">Drupal requirements</a> for more information.', array('@url' => 'http://drupal.org/requirements'));      $requirements['php_memory_limit']['severity'] = REQUIREMENT_WARNING;    }  }  // Test DB version  global $db_type;  if (function_exists('db_status_report')) {    $requirements += db_status_report($phase);  }  // Test settings.php file writability  if ($phase == 'runtime') {    $conf_dir = drupal_verify_install_file(conf_path(), FILE_NOT_WRITABLE, 'dir');    $conf_file = drupal_verify_install_file(conf_path() .'/settings.php', FILE_EXIST|FILE_READABLE|FILE_NOT_WRITABLE);    if (!$conf_dir || !$conf_file) {      $requirements['settings.php'] = array(        'value' => $t('Not protected'),        'severity' => REQUIREMENT_ERROR,        'description' => '',      );      if (!$conf_dir) {        $requirements['settings.php']['description'] .= $t('The directory %file is not protected from modifications and poses a security risk. You must change the directory\'s permissions to be non-writable. ', array('%file' => conf_path()));      }      if (!$conf_file) {        $requirements['settings.php']['description'] .= $t('The file %file is not protected from modifications and poses a security risk. You must change the file\'s permissions to be non-writable.', array('%file' => conf_path() .'/settings.php'));      }    }    else {      $requirements['settings.php'] = array(        'value' => $t('Protected'),      );    }    $requirements['settings.php']['title'] = $t('Configuration file');  }  // Report cron status.  if ($phase == 'runtime') {    // Cron warning threshold defaults to two days.    $threshold_warning = variable_get('cron_threshold_warning', 172800);    // Cron error threshold defaults to two weeks.    $threshold_error = variable_get('cron_threshold_error', 1209600);    // Cron configuration help text.    $help = $t('For more information, see the online handbook entry for <a href="@cron-handbook">configuring cron jobs</a>.', array('@cron-handbook' => 'http://drupal.org/cron'));    // Determine when cron last ran. If never, use the install time to    // determine the warning or error status.    $cron_last = variable_get('cron_last', NULL);    $never_run = FALSE;    if (!is_numeric($cron_last)) {      $never_run = TRUE;      $cron_last = variable_get('install_time', 0);    }    // Determine severity based on time since cron last ran.    $severity = REQUIREMENT_OK;    if (time() - $cron_last > $threshold_error) {      $severity = REQUIREMENT_ERROR;    }    else if ($never_run || (time() - $cron_last > $threshold_warning)) {      $severity = REQUIREMENT_WARNING;    }    // If cron hasn't been run, and the user is viewing the main    // administration page, instead of an error, we display a helpful reminder    // to configure cron jobs.    if ($never_run && $severity != REQUIREMENT_ERROR && $_GET['q'] == 'admin' && user_access('administer site configuration')) {      drupal_set_message($t('Cron has not run. Please visit the <a href="@status">status report</a> for more information.', array('@status' => url('admin/reports/status'))));    }    // Set summary and description based on values determined above.    if ($never_run) {      $summary = $t('Never run');      $description = $t('Cron has not run.') .' '. $help;    }    else {      $summary = $t('Last run !time ago', array('!time' => format_interval(time() - $cron_last)));      $description = '';      if ($severity != REQUIREMENT_OK) {        $description = $t('Cron has not run recently.') .' '. $help;      }    }    $requirements['cron'] = array(      'title' => $t('Cron maintenance tasks'),      'severity' => $severity,      'value' => $summary,      'description' => $description .' '. $t('You can <a href="@cron">run cron manually</a>.', array('@cron' => url('admin/reports/status/run-cron'))),    );  }  // Test files directory  $directory = file_directory_path();  $requirements['file system'] = array(    'title' => $t('File system'),  );  // For installer, create the directory if possible.  if ($phase == 'install' && !is_dir($directory) && @mkdir($directory)) {    @chmod($directory, 0775); // Necessary for non-webserver users.  }  $is_writable = is_writable($directory);  $is_directory = is_dir($directory);  if (!$is_writable || !$is_directory) {    $description = '';    $requirements['file system']['value'] = $t('Not writable');    if (!$is_directory) {      $error = $t('The directory %directory does not exist.', array('%directory' => $directory));    }    else {      $error = $t('The directory %directory is not writable.', array('%directory' => $directory));    }    // The files directory requirement check is done only during install and runtime.    if ($phase == 'runtime') {      $description = $error .' '. $t('You may need to set the correct directory at the <a href="@admin-file-system">file system settings page</a> or change the current directory\'s permissions so that it is writable.', array('@admin-file-system' => url('admin/settings/file-system')));    }    elseif ($phase == 'install') {      // For the installer UI, we need different wording. 'value' will      // be treated as version, so provide none there.      $description = $error .' '. $t('An automated attempt to create this directory failed, possibly due to a permissions problem. To proceed with the installation, either create the directory and modify its permissions manually, or ensure that the installer has the permissions to create it automatically. For more information, please see INSTALL.txt or the <a href="@handbook_url">on-line handbook</a>.', array('@handbook_url' => 'http://drupal.org/server-permissions'));      $requirements['file system']['value'] = '';    }    if (!empty($description)) {      $requirements['file system']['description'] = $description;      $requirements['file system']['severity'] = REQUIREMENT_ERROR;    }  }  else {    if (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC) {      $requirements['file system']['value'] = $t('Writable (<em>public</em> download method)');    }    else {      $requirements['file system']['value'] = $t('Writable (<em>private</em> download method)');    }  }  // See if updates are available in update.php.  if ($phase == 'runtime') {    $requirements['update'] = array(      'title' => $t('Database updates'),      'severity' => REQUIREMENT_OK,      'value' => $t('Up to date'),    );    // Check installed modules.    foreach (module_list() as $module) {      $updates = drupal_get_schema_versions($module);      if ($updates !== FALSE) {        $default = drupal_get_installed_schema_version($module);        if (max($updates) > $default) {          $requirements['update']['severity'] = REQUIREMENT_ERROR;          $requirements['update']['value'] = $t('Out of date');          $requirements['update']['description'] = $t('Some modules have database schema updates to install. You should run the <a href="@update">database update script</a> immediately.', array('@update' => base_path() .'update.php'));          break;        }      }    }  }  // Verify the update.php access setting  if ($phase == 'runtime') {    if (!empty($GLOBALS['update_free_access'])) {      $requirements['update access'] = array(        'value' => $t('Not protected'),        'severity' => REQUIREMENT_ERROR,        'description' => $t('The update.php script is accessible to everyone without authentication check, which is a security risk. You must change the $update_free_access value in your settings.php back to FALSE.'),      );    }    else {      $requirements['update access'] = array(        'value' => $t('Protected'),      );    }    $requirements['update access']['title'] = $t('Access to update.php');  }  // Test Unicode library  include_once './includes/unicode.inc';  $requirements = array_merge($requirements, unicode_requirements());  if ($phase == 'runtime') {    // Check for update status module.    if (!module_exists('update')) {      $requirements['update status'] = array(        'value' => $t('Not enabled'),        'severity' => REQUIREMENT_WARNING,        'description' => $t('Update notifications are not enabled. It is <strong>highly recommended</strong> that you enable the update status module from the <a href="@module">module administration page</a> in order to stay up-to-date on new releases. For more information please read the <a href="@update">Update status handbook page</a>.', array('@update' => 'http://drupal.org/handbook/modules/update', '@module' => url('admin/build/modules'))),      );    }    else {      $requirements['update status'] = array(        'value' => $t('Enabled'),      );    }    $requirements['update status']['title'] = $t('Update notifications');    // Check that Drupal can issue HTTP requests.    if (variable_get('drupal_http_request_fails', TRUE) && !system_check_http_request()) {      $requirements['http requests'] = array(        'title' => $t('HTTP request status'),        'value' => $t('Fails'),        'severity' => REQUIREMENT_ERROR,        'description' => $t('Your system or network configuration does not allow Drupal to access web pages, resulting in reduced functionality. This could be due to your webserver configuration or PHP settings, and should be resolved in order to download information about available updates, fetch aggregator feeds, sign in via OpenID, or use other network-dependent services.'),      );    }  }  return $requirements;}/** * Implementation of hook_install(). */function system_install() {  if ($GLOBALS['db_type'] == 'pgsql') {    // We create some custom types and functions using global names instead of    // prefixing them like we do with table names. If this function is ever    // called again (for example, by the test framework when creating prefixed    // test databases), the global names will already exist. We therefore avoid    // trying to create them again in that case.    // Create unsigned types.    if (!db_result(db_query("SELECT COUNT(*) FROM pg_constraint WHERE conname = 'int_unsigned_check'"))) {      db_query("CREATE DOMAIN int_unsigned integer CHECK (VALUE >= 0)");    }    if (!db_result(db_query("SELECT COUNT(*) FROM pg_constraint WHERE conname = 'smallint_unsigned_check'"))) {      db_query("CREATE DOMAIN smallint_unsigned smallint CHECK (VALUE >= 0)");    }    if (!db_result(db_query("SELECT COUNT(*) FROM pg_constraint WHERE conname = 'bigint_unsigned_check'"))) {      db_query("CREATE DOMAIN bigint_unsigned bigint CHECK (VALUE >= 0)");    }    // Create functions.    db_query('CREATE OR REPLACE FUNCTION "greatest"(numeric, numeric) RETURNS numeric AS      \'SELECT CASE WHEN (($1 > $2) OR ($2 IS NULL)) THEN $1 ELSE $2 END;\'      LANGUAGE \'sql\''    );    db_query('CREATE OR REPLACE FUNCTION "greatest"(numeric, numeric, numeric) RETURNS numeric AS      \'SELECT greatest($1, greatest($2, $3));\'      LANGUAGE \'sql\''    );    if (!db_result(db_query("SELECT COUNT(*) FROM pg_proc WHERE proname = 'rand'"))) {      db_query('CREATE OR REPLACE FUNCTION "rand"() RETURNS float AS        \'SELECT random();\'        LANGUAGE \'sql\''      );    }    if (!db_result(db_query("SELECT COUNT(*) FROM pg_proc WHERE proname = 'concat'"))) {      db_query('CREATE OR REPLACE FUNCTION "concat"(text, text) RETURNS text AS        \'SELECT $1 || $2;\'        LANGUAGE \'sql\''      );    }    db_query('CREATE OR REPLACE FUNCTION "if"(boolean, text, text) RETURNS text AS      \'SELECT CASE WHEN $1 THEN $2 ELSE $3 END;\'      LANGUAGE \'sql\''    );    db_query('CREATE OR REPLACE FUNCTION "if"(boolean, integer, integer) RETURNS integer AS      \'SELECT CASE WHEN $1 THEN $2 ELSE $3 END;\'      LANGUAGE \'sql\''    );  }  // Create tables.  $modules = array('system', 'filter', 'block', 'user', 'node', 'comment', 'taxonomy');  foreach ($modules as $module) {    drupal_install_schema($module);  }  // Clear out module list and hook implementation statics before calling  // system_theme_data().  module_list(TRUE, FALSE);  module_implements('', FALSE, TRUE);  // Load system theme data appropriately.  system_theme_data();  // Inserting uid 0 here confuses MySQL -- the next user might be created as  // uid 2 which is not what we want. So we insert the first user here, the  // anonymous user. uid is 1 here for now, but very soon it will be changed  // to 0.  db_query("INSERT INTO {users} (name, mail) VALUES('%s', '%s')", '', '');  // We need some placeholders here as name and mail are uniques and data is  // presumed to be a serialized array. Install will change uid 1 immediately  // anyways. So we insert the superuser here, the uid is 2 here for now, but  // very soon it will be changed to 1.  db_query("INSERT INTO {users} (name, mail, created, data) VALUES('%s', '%s', %d, '%s')", 'placeholder-for-uid-1', 'placeholder-for-uid-1', time(), serialize(array()));  // This sets the above two users uid 0 (anonymous). We avoid an explicit 0  // otherwise MySQL might insert the next auto_increment value.  db_query("UPDATE {users} SET uid = uid - uid WHERE name = '%s'", '');  // This sets uid 1 (superuser). We skip uid 2 but that's not a big problem.  db_query("UPDATE {users} SET uid = 1 WHERE name = '%s'", 'placeholder-for-uid-1');  db_query("INSERT INTO {role} (name) VALUES ('%s')", 'anonymous user');  db_query("INSERT INTO {role} (name) VALUES ('%s')", 'authenticated user');  db_query("INSERT INTO {permission} (rid, perm, tid) VALUES (%d, '%s', %d)", 1, 'access content', 0);  db_query("INSERT INTO {permission} (rid, perm, tid) VALUES (%d, '%s', %d)", 2, 'access comments, access content, post comments, post comments without approval', 0);  db_query("INSERT INTO {variable} (name, value) VALUES ('%s', '%s')", 'theme_default', 's:7:"garland";');  db_query("UPDATE {system} SET status = %d WHERE type = '%s' AND name = '%s'", 1, 'theme', 'garland');  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, pages, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', '%s', %d)", 'user', '0', 'garland', 1, 0, 'left', '', -1);  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, pages, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', '%s', %d)", 'user', '1', 'garland', 1, 0, 'left', '', -1);  db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, pages, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', '%s', %d)", 'system', '0', 'garland', 1, 10, 'footer', '', -1);  db_query("INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, '%s', %d, %d, %d)", 0, 0, 'all', 1, 0, 0);  // Add input formats.  db_query("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('%s', '%s', %d)", 'Filtered HTML', ',1,2,', 1);  db_query("INSERT INTO {filter_formats} (name, roles, cache) VALUES ('%s', '%s', %d)", 'Full HTML', '', 1);  // Enable filters for each input format.  // Filtered HTML:  // URL filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 2, 0);  // HTML filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 0, 1);  // Line break filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 1, 2);  // HTML corrector filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 1, 'filter', 3, 10);  // Full HTML:  // URL filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 2, 'filter', 2, 0);  // Line break filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 2, 'filter', 1, 1);  // HTML corrector filter.  db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", 2, 'filter', 3, 10);  db_query("INSERT INTO {variable} (name, value) VALUES ('%s','%s')", 'filter_html_1', 'i:1;');  db_query("INSERT INTO {variable} (name, value) VALUES ('%s', '%s')", 'node_options_forum', 'a:1:{i:0;s:6:"status";}');}/** * Implementation of hook_schema(). */function system_schema() {  // NOTE: {variable} needs to be created before all other tables, as  // some database drivers, e.g. Oracle and DB2, will require variable_get()  // and variable_set() for overcoming some database specific limitations.  $schema['variable'] = array(    'description' => 'Named variable/value pairs created by Drupal core or any other module or theme. All variables are cached in memory at the start of every Drupal request so developers should not be careless about what is stored here.',    'fields' => array(      'name' => array(        'description' => 'The name of the variable.',        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => ''),      'value' => array(        'description' => 'The value of the variable.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      ),    'primary key' => array('name'),    );  $schema['actions'] = array(    'description' => 'Stores action information.',    'fields' => array(      'aid' => array(        'description' => 'Primary Key: Unique actions ID.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '0'),      'type' => array(        'description' => 'The object that that action acts on (node, user, comment, system or custom types.)',        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => ''),      'callback' => array(        'description' => 'The callback function that executes when the action runs.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'parameters' => array(        'description' => 'Parameters to be passed to the callback function.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'description' => array(        'description' => 'Description of the action.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '0'),      ),    'primary key' => array('aid'),    );  $schema['actions_aid'] = array(    'description' => 'Stores action IDs for non-default actions.',    'fields' => array(      'aid' => array(        'description' => 'Primary Key: Unique actions ID.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      ),    'primary key' => array('aid'),    );  $schema['batch'] = array(    'description' => t('Stores details about batches (processes that run in multiple HTTP requests).'),    'fields' => array(      'bid' => array(        'description' => 'Primary Key: Unique batch ID.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'token' => array(        'description' => "A string token generated against the current user's session id and the batch id, used to ensure that only the user who submitted the batch can effectively access it.",        'type' => 'varchar',        'length' => 64,        'not null' => TRUE),      'timestamp' => array(        'description' => 'A Unix timestamp indicating when this batch was submitted for processing. Stale batches are purged at cron time.',        'type' => 'int',        'not null' => TRUE),      'batch' => array(        'description' => 'A serialized array containing the processing data for the batch.',        'type' => 'text',        'not null' => FALSE,        'size' => 'big')      ),    'primary key' => array('bid'),    'indexes' => array('token' => array('token')),    );  $schema['cache'] = array(    'description' => 'Generic cache table for caching things not separated out into their own tables. Contributed modules may also use this to store cached items.',    'fields' => array(      'cid' => array(        'description' => 'Primary Key: Unique cache ID.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'data' => array(        'description' => 'A collection of data to cache.',        'type' => 'blob',        'not null' => FALSE,        'size' => 'big'),      'expire' => array(        'description' => 'A Unix timestamp indicating when the cache entry should expire, or 0 for never.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'created' => array(        'description' => 'A Unix timestamp indicating when the cache entry was created.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'headers' => array(        'description' => 'Any custom HTTP headers to be added to cached data.',        'type' => 'text',        'not null' => FALSE),      'serialized' => array(        'description' => 'A flag to indicate whether content is serialized (1) or not (0).',        'type' => 'int',        'size' => 'small',        'not null' => TRUE,        'default' => 0)      ),    'indexes' => array('expire' => array('expire')),    'primary key' => array('cid'),    );  $schema['cache_form'] = $schema['cache'];  $schema['cache_form']['description'] = 'Cache table for the form system to store recently built forms and their storage data, to be used in subsequent page requests.';  $schema['cache_page'] = $schema['cache'];  $schema['cache_page']['description'] = 'Cache table used to store compressed pages for anonymous users, if page caching is enabled.';  $schema['cache_menu'] = $schema['cache'];  $schema['cache_menu']['description'] = 'Cache table for the menu system to store router information as well as generated link trees for various menu/page/user combinations.';  $schema['files'] = array(    'description' => 'Stores information for uploaded files.',    'fields' => array(      'fid' => array(        'description' => 'Primary Key: Unique files ID.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'uid' => array(        'description' => 'The {users}.uid of the user who is associated with the file.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'filename' => array(        'description' => 'Name of the file.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'filepath' => array(        'description' => 'Path of the file relative to Drupal root.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'filemime' => array(        'description' => 'The file MIME type.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'filesize' => array(        'description' => 'The size of the file in bytes.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'status' => array(        'description' => 'A flag indicating whether file is temporary (1) or permanent (0).',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'timestamp' => array(        'description' => 'UNIX timestamp for when the file was added.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      ),    'indexes' => array(      'uid' => array('uid'),      'status' => array('status'),      'timestamp' => array('timestamp'),      ),    'primary key' => array('fid'),    );  $schema['flood'] = array(    'description' => 'Flood controls the threshold of events, such as the number of contact attempts.',    'fields' => array(      'fid' => array(        'description' => 'Unique flood event ID.',        'type' => 'serial',        'not null' => TRUE),      'event' => array(        'description' => 'Name of event (e.g. contact).',        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => ''),      'hostname' => array(        'description' => 'Hostname of the visitor.',        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => ''),      'timestamp' => array(        'description' => 'Timestamp of the event.',        'type' => 'int',        'not null' => TRUE,        'default' => 0)      ),    'primary key' => array('fid'),    'indexes' => array(      'allow' => array('event', 'hostname', 'timestamp'),    ),    );  $schema['history'] = array(    'description' => 'A record of which {users} have read which {node}s.',    'fields' => array(      'uid' => array(        'description' => 'The {users}.uid that read the {node} nid.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'nid' => array(        'description' => 'The {node}.nid that was read.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'timestamp' => array(        'description' => 'The Unix timestamp at which the read occurred.',        'type' => 'int',        'not null' => TRUE,        'default' => 0)      ),    'primary key' => array('uid', 'nid'),    'indexes' => array(      'nid' => array('nid'),    ),    );  $schema['menu_router'] = array(    'description' => 'Maps paths to various callbacks (access, page and title)',    'fields' => array(      'path' => array(        'description' => 'Primary Key: the Drupal path this entry describes',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'load_functions' => array(        'description' => 'A serialized array of function names (like node_load) to be called to load an object corresponding to a part of the current path.',        'type' => 'text',        'not null' => TRUE,),      'to_arg_functions' => array(        'description' => 'A serialized array of function names (like user_uid_optional_to_arg) to be called to replace a part of the router path with another string.',        'type' => 'text',        'not null' => TRUE,),      'access_callback' => array(        'description' => 'The callback which determines the access to this router path. Defaults to user_access.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'access_arguments' => array(        'description' => 'A serialized array of arguments for the access callback.',        'type' => 'text',        'not null' => FALSE),      'page_callback' => array(        'description' => 'The name of the function that renders the page.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'page_arguments' => array(        'description' => 'A serialized array of arguments for the page callback.',        'type' => 'text',        'not null' => FALSE),      'fit' => array(        'description' => 'A numeric representation of how specific the path is.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'number_parts' => array(        'description' => 'Number of parts in this router path.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'tab_parent' => array(        'description' => 'Only for local tasks (tabs) - the router path of the parent page (which may also be a local task).',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'tab_root' => array(        'description' => 'Router path of the closest non-tab parent page. For pages that are not local tasks, this will be the same as the path.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'title' => array(        'description' => 'The title for the current page, or the title for the tab if this is a local task.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'title_callback' => array(        'description' => 'A function which will alter the title. Defaults to t()',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'title_arguments' => array(        'description' => 'A serialized array of arguments for the title callback. If empty, the title will be used as the sole argument for the title callback.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'type' => array(        'description' => 'Numeric representation of the type of the menu item, like MENU_LOCAL_TASK.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'block_callback' => array(        'description' => 'Name of a function used to render the block on the system administration page for this item.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'description' => array(        'description' => 'A description of this item.',        'type' => 'text',        'not null' => TRUE),      'position' => array(        'description' => 'The position of the block (left or right) on the system administration page for this item.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'weight' => array(        'description' => 'Weight of the element. Lighter weights are higher up, heavier weights go down.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'file' => array(        'description' => 'The file to include for this element, usually the page callback function lives in this file.',        'type' => 'text',        'size' => 'medium')      ),    'indexes' => array(      'fit' => array('fit'),      'tab_parent' => array('tab_parent'),      'tab_root_weight_title' => array(array('tab_root', 64), 'weight', 'title'),            ),    'primary key' => array('path'),    );  $schema['menu_links'] = array(    'description' => 'Contains the individual links within a menu.',    'fields' => array(     'menu_name' => array(        'description' => "The menu name. All links with the same menu name (such as 'navigation') are part of the same menu.",        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => ''),      'mlid' => array(        'description' => 'The menu link ID (mlid) is the integer primary key.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'plid' => array(        'description' => 'The parent link ID (plid) is the mlid of the link above in the hierarchy, or zero if the link is at the top level in its menu.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'link_path' => array(        'description' => 'The Drupal path or external path this link points to.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'router_path' => array(        'description' => 'For links corresponding to a Drupal path (external = 0), this connects the link to a {menu_router}.path for joins.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'link_title' => array(      'description' => 'The text displayed for the link, which may be modified by a title callback stored in {menu_router}.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'options' => array(        'description' => 'A serialized array of options to be passed to the url() or l() function, such as a query string or HTML attributes.',        'type' => 'text',        'not null' => FALSE),      'module' => array(        'description' => 'The name of the module that generated this link.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => 'system'),      'hidden' => array(        'description' => 'A flag for whether the link should be rendered in menus. (1 = a disabled menu item that may be shown on admin screens, -1 = a menu callback, 0 = a normal, visible link)',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'external' => array(        'description' => 'A flag to indicate if the link points to a full URL starting with a protocol, like http:// (1 = external, 0 = internal).',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'has_children' => array(        'description' => 'Flag indicating whether any links have this link as a parent (1 = children exist, 0 = no children).',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'expanded' => array(        'description' => 'Flag for whether this link should be rendered as expanded in menus - expanded links always have their child links displayed, instead of only when the link is in the active trail (1 = expanded, 0 = not expanded)',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'weight' => array(        'description' => 'Link weight among links in the same menu at the same depth.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'depth' => array(        'description' => 'The depth relative to the top level. A link with plid == 0 will have depth == 1.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'customized' => array(        'description' => 'A flag to indicate that the user has manually created or edited the link (1 = customized, 0 = not customized).',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      'p1' => array(        'description' => 'The first mlid in the materialized path. If N = depth, then pN must equal the mlid. If depth > 1 then p(N-1) must equal the plid. All pX where X > depth must equal zero. The columns p1 .. p9 are also called the parents.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p2' => array(        'description' => 'The second mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p3' => array(        'description' => 'The third mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p4' => array(        'description' => 'The fourth mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p5' => array(        'description' => 'The fifth mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p6' => array(        'description' => 'The sixth mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p7' => array(        'description' => 'The seventh mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p8' => array(        'description' => 'The eighth mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'p9' => array(        'description' => 'The ninth mlid in the materialized path. See p1.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'updated' => array(        'description' => 'Flag that indicates that this link was generated during the update from Drupal 5.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'small'),      ),    'indexes' => array(      'path_menu' => array(array('link_path', 128), 'menu_name'),      'menu_plid_expand_child' => array(        'menu_name', 'plid', 'expanded', 'has_children'),      'menu_parents' => array(        'menu_name', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7', 'p8', 'p9'),      'router_path' => array(array('router_path', 128)),      ),    'primary key' => array('mlid'),    );  $schema['semaphore'] = array(    'description' => 'Table for holding semaphores, locks, flags, etc. that cannot be stored as Drupal variables since they must not be cached.',    'fields' => array(      'name' => array(        'description' => 'Primary Key: Unique name.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'value' => array(        'description' => 'A value.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'expire' => array(        'description' => 'A Unix timestamp with microseconds indicating when the semaphore should expire.',        'type' => 'float',        'size' => 'big',        'not null' => TRUE),      ),    'indexes' => array('expire' => array('expire')),    'primary key' => array('name'),    );  $schema['sessions'] = array(    'description' => "Drupal's session handlers read and write into the sessions table. Each record represents a user session, either anonymous or authenticated.",    'fields' => array(      'uid' => array(        'description' => 'The {users}.uid corresponding to a session, or 0 for anonymous user.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE),      'sid' => array(        'description' => "Primary key: A session ID. The value is generated by PHP's Session API.",        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => ''),      'hostname' => array(        'description' => 'The IP address that last used this session ID (sid).',        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => ''),      'timestamp' => array(        'description' => 'The Unix timestamp when this session last requested a page. Old records are purged by PHP automatically.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'cache' => array(        'description' => "The time of this user's last post. This is used when the site has specified a minimum_cache_lifetime. See cache_get().",        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'session' => array(        'description' => 'The serialized contents of $_SESSION, an array of name/value pairs that persists across page requests by this session ID. Drupal loads $_SESSION from here at the start of each request and saves it at the end.',        'type' => 'text',        'not null' => FALSE,        'size' => 'big')      ),    'primary key' => array('sid'),    'indexes' => array(      'timestamp' => array('timestamp'),      'uid' => array('uid')      ),    );  $schema['system'] = array(    'description' => "A list of all modules, themes, and theme engines that are or have been installed in Drupal's file system.",    'fields' => array(      'filename' => array(        'description' => 'The path of the primary file for this item, relative to the Drupal root; e.g. modules/node/node.module.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'name' => array(        'description' => 'The name of the item; e.g. node.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'type' => array(        'description' => 'The type of the item, either module, theme, or theme_engine.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'owner' => array(        'description' => "A theme's 'parent'. Can be either a theme or an engine.",        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'status' => array(        'description' => 'Boolean indicating whether or not this item is enabled.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'throttle' => array(        'description' => 'Boolean indicating whether this item is disabled when the throttle.module disables throttleable items.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'bootstrap' => array(        'description' => "Boolean indicating whether this module is loaded during Drupal's early bootstrapping phase (e.g. even before the page cache is consulted).",        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'schema_version' => array(        'description' => "The module's database schema version number. -1 if the module is not installed (its tables do not exist); 0 or the largest N of the module's hook_update_N() function that has either been run or existed when the module was first installed.",        'type' => 'int',        'not null' => TRUE,        'default' => -1,        'size' => 'small'),      'weight' => array(        'description' => "The order in which this module's hooks should be invoked relative to other modules. Equal-weighted modules are ordered by name.",        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'info' => array(        'description' => "A serialized array containing information from the module's .info file; keys can include name, description, package, version, core, dependencies, dependents, and php.",        'type' => 'text',        'not null' => FALSE)      ),    'primary key' => array('filename'),    'indexes' =>      array(        'modules' => array(array('type', 12), 'status', 'weight', 'filename'),        'bootstrap' => array(array('type', 12), 'status', 'bootstrap', 'weight', 'filename'),        'type_name' => array(array('type', 12), 'name'),      ),    );  $schema['url_alias'] = array(    'description' => 'A list of URL aliases for Drupal paths; a user may visit either the source or destination path.',    'fields' => array(      'pid' => array(        'description' => 'A unique path alias identifier.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'src' => array(        'description' => 'The Drupal path this alias is for; e.g. node/12.',        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => ''),      'dst' => array(        'description' => 'The alias for this path; e.g. title-of-the-story.',        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => ''),      'language' => array(        'description' => 'The language this alias is for; if blank, the alias will be used for unknown languages. Each Drupal path can have an alias for each supported language.',        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => '')      ),    'unique keys' => array('dst_language_pid' => array('dst', 'language', 'pid')),    'primary key' => array('pid'),    'indexes' => array('src_language_pid' => array('src', 'language', 'pid')),    );  return $schema;}// Updates for core.function system_update_last_removed() {  return 1021;}/** * @defgroup updates-5.x-extra Extra system updates for 5.x * @{ *//** * Add index on users created column. */function system_update_1022() {  $ret = array();  db_add_index($ret, 'users', 'created', array('created'));  // Also appears as system_update_6004(). Ensure we don't update twice.  variable_set('system_update_1022', TRUE);  return $ret;}/** * @} End of "defgroup updates-5.x-extra" *//** * @defgroup updates-5.x-to-6.x System updates from 5.x to 6.x * @{ *//** * Remove auto_increment from {boxes} to allow adding custom blocks with * visibility settings. */function system_update_6000() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'mysql':    case 'mysqli':      $max = (int)db_result(db_query('SELECT MAX(bid) FROM {boxes}'));      $ret[] = update_sql('ALTER TABLE {boxes} CHANGE COLUMN bid bid int NOT NULL');      $ret[] = update_sql("REPLACE INTO {sequences} VALUES ('{boxes}_bid', $max)");      break;  }  return $ret;}/** * Add version id column to {term_node} to allow taxonomy module to use revisions. */function system_update_6001() {  $ret = array();  // Add vid to term-node relation.  The schema says it is unsigned.  db_add_field($ret, 'term_node', 'vid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_drop_primary_key($ret, 'term_node');  db_add_primary_key($ret, 'term_node', array('vid', 'tid', 'nid'));  db_add_index($ret, 'term_node', 'vid', array('vid'));  db_query('UPDATE {term_node} SET vid = (SELECT vid FROM {node} n WHERE {term_node}.nid = n.nid)');  return $ret;}/** * Increase the maximum length of variable names from 48 to 128. */function system_update_6002() {  $ret = array();  db_drop_primary_key($ret, 'variable');  db_change_field($ret, 'variable', 'name', 'name', array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''));  db_add_primary_key($ret, 'variable', array('name'));  return $ret;}/** * Add index on comments status column. */function system_update_6003() {  $ret = array();  db_add_index($ret, 'comments', 'status', array('status'));  return $ret;}/** * This update used to add an index on users created column (#127941). * However, system_update_1022() does the same thing.  This update * tried to detect if 1022 had already run but failed to do so, * resulting in an "index already exists" error. * * Adding the index here is never necessary.  Sites installed before * 1022 will run 1022, getting the update.  Sites installed on/after 1022 * got the index when the table was first created.  Therefore, this * function is now a no-op. */function system_update_6004() {  return array();}/** * Add language to url_alias table and modify indexes. */function system_update_6005() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      db_add_column($ret, 'url_alias', 'language', 'varchar(12)', array('default' => "''", 'not null' => TRUE));      // As of system.install:1.85 (before the new language      // subsystem), new installs got a unique key named      // url_alias_dst_key on url_alias.dst.  Unfortunately,      // system_update_162 created a unique key inconsistently named      // url_alias_dst_idx on url_alias.dst (keys should have the _key      // suffix, indexes the _idx suffix).  Therefore, sites installed      // before system_update_162 have a unique key with a different      // name than sites installed after system_update_162().  Now, we      // want to drop the unique key on dst which may have either one      // of two names and create a new unique key on (dst, language).      // There is no way to know which key name exists so we have to      // drop both, causing an SQL error.  Thus, we just hide the      // error and only report the update_sql results that work.      $err = error_reporting(0);      $ret1 = update_sql('DROP INDEX {url_alias}_dst_idx');      if ($ret1['success']) {  $ret[] = $ret1;      }      $ret1 = array();      db_drop_unique_key($ret, 'url_alias', 'dst');      foreach ($ret1 as $r) {  if ($r['success']) {    $ret[] = $r;  }      }      error_reporting($err);      $ret[] = update_sql('CREATE UNIQUE INDEX {url_alias}_dst_language_idx ON {url_alias}(dst, language)');      break;    case 'mysql':    case 'mysqli':      $ret[] = update_sql("ALTER TABLE {url_alias} ADD language varchar(12) NOT NULL default ''");      $ret[] = update_sql("ALTER TABLE {url_alias} DROP INDEX dst");      $ret[] = update_sql("ALTER TABLE {url_alias} ADD UNIQUE dst_language (dst, language)");      break;  }  return $ret;}/** * Drop useless indices on node_counter table. */function system_update_6006() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      $ret[] = update_sql('DROP INDEX {node_counter}_daycount_idx');      $ret[] = update_sql('DROP INDEX {node_counter}_totalcount_idx');      $ret[] = update_sql('DROP INDEX {node_counter}_timestamp_idx');      break;    case 'mysql':    case 'mysqli':      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX daycount");      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX totalcount");      $ret[] = update_sql("ALTER TABLE {node_counter} DROP INDEX timestamp");      break;  }  return $ret;}/** * Change the severity column in the watchdog table to the new values. */function system_update_6007() {  $ret = array();  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_NOTICE ." WHERE severity = 0");  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_WARNING ." WHERE severity = 1");  $ret[] = update_sql("UPDATE {watchdog} SET severity = ". WATCHDOG_ERROR ." WHERE severity = 2");  return $ret;}/** * Add info files to themes.  The info and owner columns are added by * update_fix_d6_requirements() in update.php to avoid a large number * of error messages from update.php.  All we need to do here is copy * description to owner and then drop description. */function system_update_6008() {  $ret = array();  $ret[] = update_sql('UPDATE {system} SET owner = description');  db_drop_field($ret, 'system', 'description');  // Rebuild system table contents.  module_rebuild_cache();  system_theme_data();  return $ret;}/** * The PHP filter is now a separate module. */function system_update_6009() {  $ret = array();  // If any input format used the Drupal 5 PHP filter.  if (db_result(db_query("SELECT COUNT(format) FROM {filters} WHERE module = 'filter' AND delta = 1"))) {    // Enable the PHP filter module.    $ret[] = update_sql("UPDATE {system} SET status = 1 WHERE name = 'php' AND type = 'module'");    // Update the input filters.    $ret[] = update_sql("UPDATE {filters} SET delta = 0, module = 'php' WHERE module = 'filter' AND delta = 1");  }  // With the removal of the PHP evaluator filter, the deltas of the line break  // and URL filter have changed.  $ret[] = update_sql("UPDATE {filters} SET delta = 1 WHERE module = 'filter' AND delta = 2");  $ret[] = update_sql("UPDATE {filters} SET delta = 2 WHERE module = 'filter' AND delta = 3");  return $ret;}/** * Add variable replacement for watchdog messages. * * The variables field is NOT NULL and does not have a default value. * Existing log messages should not be translated in the new system, * so we insert 'N;' (serialize(NULL)) as the temporary default but * then remove the default value to match the schema. */function system_update_6010() {  $ret = array();  db_add_field($ret, 'watchdog', 'variables', array('type' => 'text', 'size' => 'big', 'not null' => TRUE, 'initial' => 'N;'));  return $ret;}/** * Add language support to nodes */function system_update_6011() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      db_add_column($ret, 'node', 'language', 'varchar(12)', array('default' => "''", 'not null' => TRUE));      break;    case 'mysql':    case 'mysqli':      $ret[] = update_sql("ALTER TABLE {node} ADD language varchar(12) NOT NULL default ''");      break;  }  return $ret;}/** * Add serialized field to cache tables.  This is now handled directly * by update.php, so this function is a no-op. */function system_update_6012() {  return array();}/** * Rebuild cache data for theme system changes */function system_update_6013() {  // Rebuild system table contents.  module_rebuild_cache();  system_theme_data();  return array(array('success' => TRUE, 'query' => 'Cache rebuilt.'));}/** * Record that the installer is done, so it is not * possible to run the installer on upgraded sites. */function system_update_6014() {  variable_set('install_task', 'done');  return array(array('success' => TRUE, 'query' => "variable_set('install_task')"));}/** * Add the form cache table. */function system_update_6015() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      $ret[] = update_sql("CREATE TABLE {cache_form} (        cid varchar(255) NOT NULL default '',        data bytea,        expire int NOT NULL default '0',        created int NOT NULL default '0',        headers text,        serialized smallint NOT NULL default '0',        PRIMARY KEY (cid)    )");      $ret[] = update_sql("CREATE INDEX {cache_form}_expire_idx ON {cache_form} (expire)");      break;    case 'mysql':    case 'mysqli':      $ret[] = update_sql("CREATE TABLE {cache_form} (        cid varchar(255) NOT NULL default '',        data longblob,        expire int NOT NULL default '0',        created int NOT NULL default '0',        headers text,        serialized int(1) NOT NULL default '0',        PRIMARY KEY (cid),        INDEX expire (expire)      ) /*!40100 DEFAULT CHARACTER SET UTF8 */ ");      break;  }  return $ret;}/** * Make {node}'s primary key be nid, change nid,vid to a unique key. * Add primary keys to block, filters, flood, permission, and term_relation. */function system_update_6016() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      $ret[] = update_sql("ALTER TABLE {node} ADD CONSTRAINT {node}_nid_vid_key UNIQUE (nid, vid)");      db_add_column($ret, 'blocks', 'bid', 'serial');      $ret[] = update_sql("ALTER TABLE {blocks} ADD PRIMARY KEY (bid)");      db_add_column($ret, 'filters', 'fid', 'serial');      $ret[] = update_sql("ALTER TABLE {filters} ADD PRIMARY KEY (fid)");      db_add_column($ret, 'flood', 'fid', 'serial');      $ret[] = update_sql("ALTER TABLE {flood} ADD PRIMARY KEY (fid)");      db_add_column($ret, 'permission', 'pid', 'serial');      $ret[] = update_sql("ALTER TABLE {permission} ADD PRIMARY KEY (pid)");      db_add_column($ret, 'term_relation', 'trid', 'serial');      $ret[] = update_sql("ALTER TABLE {term_relation} ADD PRIMARY KEY (trid)");      db_add_column($ret, 'term_synonym', 'tsid', 'serial');      $ret[] = update_sql("ALTER TABLE {term_synonym} ADD PRIMARY KEY (tsid)");      break;    case 'mysql':    case 'mysqli':      $ret[] = update_sql('ALTER TABLE {node} ADD UNIQUE KEY nid_vid (nid, vid)');      $ret[] = update_sql("ALTER TABLE {blocks} ADD bid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      $ret[] = update_sql("ALTER TABLE {filters} ADD fid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      $ret[] = update_sql("ALTER TABLE {flood} ADD fid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      $ret[] = update_sql("ALTER TABLE {permission} ADD pid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      $ret[] = update_sql("ALTER TABLE {term_relation} ADD trid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      $ret[] = update_sql("ALTER TABLE {term_synonym} ADD tsid int NOT NULL AUTO_INCREMENT PRIMARY KEY");      break;  }  return $ret;}/** * Rename settings related to user.module email notifications. */function system_update_6017() {  $ret = array();  // Maps old names to new ones.  $var_names = array(    'admin'    => 'register_admin_created',    'approval' => 'register_pending_approval',    'welcome'  => 'register_no_approval_required',    'pass'     => 'password_reset',  );  foreach ($var_names as $old => $new) {    foreach (array('_subject', '_body') as $suffix) {      $old_name = 'user_mail_'. $old . $suffix;      $new_name = 'user_mail_'. $new . $suffix;      if ($old_val = variable_get($old_name, FALSE)) {        variable_set($new_name, $old_val);        variable_del($old_name);        $ret[] = array('success' => TRUE, 'query' => "variable_set($new_name)");        $ret[] = array('success' => TRUE, 'query' => "variable_del($old_name)");        if ($old_name == 'user_mail_approval_body') {          drupal_set_message('Saving an old value of the welcome message body for users that are pending administrator approval. However, you should consider modifying this text, since Drupal can now be configured to automatically notify users and send them their login information when their accounts are approved. See the <a href="'. url('admin/user/settings') .'">User settings</a> page for details.');        }      }    }  }  return $ret;}/** * Add HTML corrector to HTML formats or replace the old module if it was in use. */function system_update_6018() {  $ret = array();  // Disable htmlcorrector.module, if it exists and replace its filter.  if (module_exists('htmlcorrector')) {    module_disable(array('htmlcorrector'));    $ret[] = update_sql("UPDATE {filter_formats} SET module = 'filter', delta = 3 WHERE module = 'htmlcorrector'");    $ret[] = array('success' => TRUE, 'query' => 'HTML Corrector module was disabled; this functionality has now been added to core.');    return $ret;  }  // Otherwise, find any format with 'HTML' in its name and add the filter at the end.  $result = db_query("SELECT format, name FROM {filter_formats} WHERE name LIKE '%HTML%'");  while ($format = db_fetch_object($result)) {    $weight = db_result(db_query("SELECT MAX(weight) FROM {filters} WHERE format = %d", $format->format));    db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $format->format, 'filter', 3, max(10, $weight + 1));    $ret[] = array('success' => TRUE, 'query' => "HTML corrector filter added to the '". $format->name ."' input format.");  }  return $ret;}/** * Reconcile small differences in the previous, manually created mysql * and pgsql schemas so they are the same and can be represented by a * single schema structure. * * Note that the mysql and pgsql cases make different changes.  This * is because each schema needs to be tweaked in different ways to * conform to the new schema structure.  Also, since they operate on * tables defined by many optional core modules which may not ever * have been installed, they must test each table for existence.  If * the modules are first installed after this update exists the tables * will be created from the schema structure and will start out * correct. */function system_update_6019() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'pgsql':      // Remove default ''.      if (db_table_exists('aggregator_feed')) {        db_field_set_no_default($ret, 'aggregator_feed', 'description');        db_field_set_no_default($ret, 'aggregator_feed', 'image');      }      db_field_set_no_default($ret, 'blocks', 'pages');      if (db_table_exists('contact')) {        db_field_set_no_default($ret, 'contact', 'recipients');        db_field_set_no_default($ret, 'contact', 'reply');      }      db_field_set_no_default($ret, 'watchdog', 'location');      db_field_set_no_default($ret, 'node_revisions', 'body');      db_field_set_no_default($ret, 'node_revisions', 'teaser');      db_field_set_no_default($ret, 'node_revisions', 'log');      // Update from pgsql 'float' (which means 'double precision') to      // schema 'float' (which in pgsql means 'real').      if (db_table_exists('search_index')) {        db_change_field($ret, 'search_index', 'score', 'score', array('type' => 'float'));      }      if (db_table_exists('search_total')) {        db_change_field($ret, 'search_total', 'count', 'count', array('type' => 'float'));      }      // Replace unique index dst_language with a unique constraint.  The      // result is the same but the unique key fits our current schema      // structure.  Also, the postgres documentation implies that      // unique constraints are preferable to unique indexes.  See      // http://www.postgresql.org/docs/8.2/interactive/indexes-unique.html.      if (db_table_exists('url_alias')) {        db_drop_index($ret, 'url_alias', 'dst_language');        db_add_unique_key($ret, 'url_alias', 'dst_language',          array('dst', 'language'));      }      // Fix term_node pkey: mysql and pgsql code had different orders.      if (db_table_exists('term_node')) {        db_drop_primary_key($ret, 'term_node');        db_add_primary_key($ret, 'term_node', array('vid', 'tid', 'nid'));      }      // Make boxes.bid unsigned.      db_drop_primary_key($ret, 'boxes');      db_change_field($ret, 'boxes', 'bid', 'bid', array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array('bid')));      // Fix primary key      db_drop_primary_key($ret, 'node');      db_add_primary_key($ret, 'node', array('nid'));      break;    case 'mysql':    case 'mysqli':      // Rename key 'link' to 'url'.      if (db_table_exists('aggregator_feed')) {        db_drop_unique_key($ret, 'aggregator_feed', 'link');        db_add_unique_key($ret, 'aggregator_feed', 'url', array('url'));      }      // Change to size => small.      if (db_table_exists('boxes')) {        db_change_field($ret, 'boxes', 'format', 'format', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));      }      // Change to size => small.      // Rename index 'lid' to 'nid'.      if (db_table_exists('comments')) {        db_change_field($ret, 'comments', 'format', 'format', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));        db_drop_index($ret, 'comments', 'lid');        db_add_index($ret, 'comments', 'nid', array('nid'));      }      // Change to size => small.      db_change_field($ret, 'cache', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));      db_change_field($ret, 'cache_filter', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));      db_change_field($ret, 'cache_page', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));      db_change_field($ret, 'cache_form', 'serialized', 'serialized', array('type' => 'int', 'size' => 'small', 'not null' => TRUE, 'default' => 0));      // Remove default => 0, set auto increment.      $new_uid = 1 + db_result(db_query('SELECT MAX(uid) FROM {users}'));      $ret[] = update_sql('UPDATE {users} SET uid = '. $new_uid .' WHERE uid = 0');      db_drop_primary_key($ret, 'users');      db_change_field($ret, 'users', 'uid', 'uid', array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array('uid')));      $ret[] = update_sql('UPDATE {users} SET uid = 0 WHERE uid = '. $new_uid);      // Special field names.      $map = array('node_revisions' => 'vid');      // Make sure these tables have proper auto_increment fields.      foreach (array('boxes', 'files', 'node', 'node_revisions') as $table) {        $field = isset($map[$table]) ? $map[$table] : $table[0] .'id';        db_drop_primary_key($ret, $table);        db_change_field($ret, $table, $field, $field, array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), array('primary key' => array($field)));      }      break;  }  return $ret;}/** * Create the tables for the new menu system. */function system_update_6020() {  $ret = array();  $schema['menu_router'] = array(    'fields' => array(      'path'             => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'load_functions'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'to_arg_functions' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'access_callback'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'access_arguments' => array('type' => 'text', 'not null' => FALSE),      'page_callback'    => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'page_arguments'   => array('type' => 'text', 'not null' => FALSE),      'fit'              => array('type' => 'int', 'not null' => TRUE, 'default' => 0),      'number_parts'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'tab_parent'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'tab_root'         => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'title'            => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'title_callback'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'title_arguments'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'type'             => array('type' => 'int', 'not null' => TRUE, 'default' => 0),      'block_callback'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'description'      => array('type' => 'text', 'not null' => TRUE),      'position'         => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'weight'           => array('type' => 'int', 'not null' => TRUE, 'default' => 0),      'file'             => array('type' => 'text', 'size' => 'medium')    ),    'indexes' => array(      'fit'        => array('fit'),      'tab_parent' => array('tab_parent')    ),    'primary key' => array('path'),  );  $schema['menu_links'] = array(    'fields' => array(      'menu_name'    => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),      'mlid'         => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE),      'plid'         => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'link_path'    => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'router_path'  => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'link_title'   => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'options'      => array('type' => 'text', 'not null' => FALSE),      'module'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => 'system'),      'hidden'       => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'external'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'has_children' => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'expanded'     => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'weight'       => array('type' => 'int', 'not null' => TRUE, 'default' => 0),      'depth'        => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'customized'   => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),      'p1'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p2'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p3'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p4'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p5'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p6'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p7'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p8'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'p9'           => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      'updated'      => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'small'),    ),    'indexes' => array(      'path_menu'              => array(array('link_path', 128), 'menu_name'),      'menu_plid_expand_child' => array('menu_name', 'plid', 'expanded', 'has_children'),      'menu_parents'           => array('menu_name', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7', 'p8', 'p9'),      'router_path'            => array(array('router_path', 128)),    ),    'primary key' => array('mlid'),  );  foreach ($schema as $name => $table) {    db_create_table($ret, $name, $table);  }  return $ret;}/** * Migrate the menu items from the old menu system to the new menu_links table. */function system_update_6021() {  $ret = array('#finished' => 0);  $menus = array(    'navigation' => array(      'menu_name' => 'navigation',      'title' => 'Navigation',      'description' => 'The navigation menu is provided by Drupal and is the main interactive menu for any site. It is usually the only menu that contains personalized links for authenticated users, and is often not even visible to anonymous users.',    ),    'primary-links' => array(      'menu_name' => 'primary-links',      'title' => 'Primary links',      'description' => 'Primary links are often used at the theme layer to show the major sections of a site. A typical representation for primary links would be tabs along the top.',    ),    'secondary-links' => array(      'menu_name' => 'secondary-links',      'title' => 'Secondary links',      'description' => 'Secondary links are often used for pages like legal notices, contact details, and other secondary navigation items that play a lesser role than primary links.',    ),  );  // Multi-part update  if (!isset($_SESSION['system_update_6021'])) {    db_add_field($ret, 'menu', 'converted', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0, 'size' => 'tiny'));    $_SESSION['system_update_6021_max'] = db_result(db_query('SELECT COUNT(*) FROM {menu}'));    $_SESSION['menu_menu_map'] = array(1 => 'navigation');    // 0 => FALSE is for new menus, 1 => FALSE is for the navigation.    $_SESSION['menu_item_map'] = array(0 => FALSE, 1 => FALSE);    $table = array(      'fields' => array(        'menu_name'   => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),        'title'       => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),        'description' => array('type' => 'text', 'not null' => FALSE),      ),      'primary key' => array('menu_name'),    );    db_create_table($ret, 'menu_custom', $table);    db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menus['navigation']);    $_SESSION['system_update_6021'] = 0;  }  $limit = 50;  while ($limit-- && ($item = db_fetch_array(db_query_range('SELECT * FROM {menu} WHERE converted = 0', 0, 1)))) {    // If it's not a menu...    if ($item['pid']) {      // Let's climb up until we find an item with a converted parent.      $item_original = $item;      while ($item && !isset($_SESSION['menu_item_map'][$item['pid']])) {        $item = db_fetch_array(db_query('SELECT * FROM {menu} WHERE mid = %d', $item['pid']));      }      // This can only occur if the menu entry is a leftover in the menu table.      // These do not appear in Drupal 5 anyways, so we skip them.      if (!$item) {        db_query('UPDATE {menu} SET converted = %d WHERE mid = %d', 1, $item_original['mid']);        $_SESSION['system_update_6021']++;        continue;      }    }    // We need to recheck because item might have changed.    if ($item['pid']) {      // Fill the new fields.      $item['link_title'] = $item['title'];      $item['link_path'] = drupal_get_normal_path($item['path']);      // We know the parent is already set. If it's not FALSE then it's an item.      if ($_SESSION['menu_item_map'][$item['pid']]) {        // The new menu system parent link id.        $item['plid'] = $_SESSION['menu_item_map'][$item['pid']]['mlid'];        // The new menu system menu name.        $item['menu_name'] = $_SESSION['menu_item_map'][$item['pid']]['menu_name'];      }      else {        // This a top level element.        $item['plid'] = 0;        // The menu name is stored among the menus.        $item['menu_name'] = $_SESSION['menu_menu_map'][$item['pid']];      }      // Is the element visible in the menu block?      $item['hidden'] = !($item['type'] & MENU_VISIBLE_IN_TREE);      // Is it a custom(ized) element?      if ($item['type'] & (MENU_CREATED_BY_ADMIN | MENU_MODIFIED_BY_ADMIN)) {        $item['customized'] = TRUE;      }      // Items created via the menu module need to be assigned to it.      if ($item['type'] & MENU_CREATED_BY_ADMIN) {        $item['module'] = 'menu';        $item['router_path'] = '';        $item['updated'] = TRUE;      }      else {        $item['module'] = 'system';        $item['router_path'] = $item['path'];        $item['updated'] = FALSE;      }      if ($item['description']) {        $item['options']['attributes']['title'] = $item['description'];      }                  // Save the link.      menu_link_save($item);      $_SESSION['menu_item_map'][$item['mid']] = array('mlid' => $item['mlid'], 'menu_name' => $item['menu_name']);    }    elseif (!isset($_SESSION['menu_menu_map'][$item['mid']])) {      $item['menu_name'] = 'menu-'. preg_replace('/[^a-zA-Z0-9]/', '-', strtolower($item['title']));      $item['menu_name'] = substr($item['menu_name'], 0, 20);      $original_menu_name = $item['menu_name'];      $i = 0;      while (db_result(db_query("SELECT menu_name FROM {menu_custom} WHERE menu_name = '%s'", $item['menu_name']))) {        $item['menu_name'] = $original_menu_name . ($i++);      }      if ($item['path']) {        // Another bunch of bogus entries. Apparently, these are leftovers        // from Drupal 4.7 .        $_SESSION['menu_bogus_menus'][] = $item['menu_name'];      }      else {        // Add this menu to the list of custom menus.        db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '')", $item['menu_name'], $item['title']);      }      $_SESSION['menu_menu_map'][$item['mid']] = $item['menu_name'];      $_SESSION['menu_item_map'][$item['mid']] = FALSE;    }    db_query('UPDATE {menu} SET converted = %d WHERE mid = %d', 1, $item['mid']);    $_SESSION['system_update_6021']++;  }  if ($_SESSION['system_update_6021'] >= $_SESSION['system_update_6021_max']) {    if (!empty($_SESSION['menu_bogus_menus'])) {      // Remove entries in bogus menus. This is secure because we deleted      // every non-alpanumeric character from the menu name.      $ret[] = update_sql("DELETE FROM {menu_links} WHERE menu_name IN ('". implode("', '", $_SESSION['menu_bogus_menus']) ."')");    }    $menu_primary_menu = variable_get('menu_primary_menu', 0);    // Ensure that we wind up with a system menu named 'primary-links'.    if (isset($_SESSION['menu_menu_map'][2])) {      // The primary links menu that ships with Drupal 5 has mid = 2.  If this      // menu hasn't been deleted by the site admin, we use that.      $updated_primary_links_menu = 2;    }    elseif (isset($_SESSION['menu_menu_map'][$menu_primary_menu]) && $menu_primary_menu > 1) {      // Otherwise, we use the menu that is currently assigned to the primary      // links region of the theme, as long as it exists and isn't the      // Navigation menu.      $updated_primary_links_menu = $menu_primary_menu;    }    else {      // As a last resort, create 'primary-links' as a new menu.      $updated_primary_links_menu = 0;      db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menus['primary-links']);    }    if ($updated_primary_links_menu) {      // Change the existing menu name to 'primary-links'.      $replace = array('%new_name' => 'primary-links', '%desc' => $menus['primary-links']['description'], '%old_name' => $_SESSION['menu_menu_map'][$updated_primary_links_menu]);      $ret[] = update_sql(strtr("UPDATE {menu_custom} SET menu_name = '%new_name', description = '%desc' WHERE menu_name = '%old_name'", $replace));      $ret[] = update_sql("UPDATE {menu_links} SET menu_name = 'primary-links' WHERE menu_name = '". $_SESSION['menu_menu_map'][$updated_primary_links_menu] ."'");      $_SESSION['menu_menu_map'][$updated_primary_links_menu] = 'primary-links';    }    $menu_secondary_menu = variable_get('menu_secondary_menu', 0);    // Ensure that we wind up with a system menu named 'secondary-links'.    if (isset($_SESSION['menu_menu_map'][$menu_secondary_menu]) && $menu_secondary_menu > 1 && $menu_secondary_menu != $updated_primary_links_menu) {      // We use the menu that is currently assigned to the secondary links      // region of the theme, as long as (a) it exists, (b) it isn't the      // Navigation menu, (c) it isn't the same menu we assigned as the      // system 'primary-links' menu above, and (d) it isn't the same menu      // assigned to the primary links region of the theme.      $updated_secondary_links_menu = $menu_secondary_menu;    }    else {      // Otherwise, create 'secondary-links' as a new menu.      $updated_secondary_links_menu = 0;      db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", $menus['secondary-links']);    }    if ($updated_secondary_links_menu) {      // Change the existing menu name to 'secondary-links'.      $replace = array('%new_name' => 'secondary-links', '%desc' => $menus['secondary-links']['description'], '%old_name' => $_SESSION['menu_menu_map'][$updated_secondary_links_menu]);      $ret[] = update_sql(strtr("UPDATE {menu_custom} SET menu_name = '%new_name', description = '%desc' WHERE menu_name = '%old_name'", $replace));      $ret[] = update_sql("UPDATE {menu_links} SET menu_name = 'secondary-links' WHERE menu_name = '". $_SESSION['menu_menu_map'][$updated_secondary_links_menu] ."'");      $_SESSION['menu_menu_map'][$updated_secondary_links_menu] = 'secondary-links';    }    // Update menu OTF preferences.    $mid = variable_get('menu_parent_items', 0);    $menu_name = ($mid && isset($_SESSION['menu_menu_map'][$mid])) ? $_SESSION['menu_menu_map'][$mid] : 'navigation';    variable_set('menu_default_node_menu', $menu_name);    variable_del('menu_parent_items');    // Update the source of the primary and secondary links.    $menu_name = ($menu_primary_menu && isset($_SESSION['menu_menu_map'][$menu_primary_menu])) ? $_SESSION['menu_menu_map'][$menu_primary_menu] : '';    variable_set('menu_primary_links_source', $menu_name);    variable_del('menu_primary_menu');    $menu_name = ($menu_secondary_menu && isset($_SESSION['menu_menu_map'][$menu_secondary_menu])) ? $_SESSION['menu_menu_map'][$menu_secondary_menu] : '';    variable_set('menu_secondary_links_source', $menu_name);    variable_del('menu_secondary_menu');    // Skip the navigation menu - it is handled by the user module.    unset($_SESSION['menu_menu_map'][1]);    // Update the deltas for all menu module blocks.    foreach ($_SESSION['menu_menu_map'] as $mid => $menu_name) {      // This is again secure because we deleted every non-alpanumeric      // character from the menu name.      $ret[] = update_sql("UPDATE {blocks} SET delta = '". $menu_name ."' WHERE module = 'menu' AND delta = '". $mid ."'");      $ret[] = update_sql("UPDATE {blocks_roles} SET delta = '". $menu_name ."' WHERE module = 'menu' AND delta = '". $mid ."'");    }    $ret[] = array('success' => TRUE, 'query' => 'Relocated '. $_SESSION['system_update_6021'] .' existing items to the new menu system.');    $ret[] = update_sql("DROP TABLE {menu}");    unset($_SESSION['system_update_6021'], $_SESSION['system_update_6021_max'], $_SESSION['menu_menu_map'], $_SESSION['menu_item_map'], $_SESSION['menu_bogus_menus']);    // Create the menu overview links - also calls menu_rebuild(). If menu is    // disabled, then just call menu_rebuild.    if (function_exists('menu_enable')) {      menu_enable();    }    else {      menu_rebuild();    }    $ret['#finished'] = 1;  }  else {    $ret['#finished'] = $_SESSION['system_update_6021'] / $_SESSION['system_update_6021_max'];  }  return $ret;}/** * Update files tables to associate files to a uid by default instead of a nid. * Rename file_revisions to upload since it should only be used by the upload * module used by upload to link files to nodes. */function system_update_6022() {  $ret = array();  // Rename the nid field to vid, add status and timestamp fields, and indexes.  db_drop_index($ret, 'files', 'nid');  db_change_field($ret, 'files', 'nid', 'uid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_add_field($ret, 'files', 'status', array('type' => 'int', 'not null' => TRUE, 'default' => 0));  db_add_field($ret, 'files', 'timestamp', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_add_index($ret, 'files', 'uid', array('uid'));  db_add_index($ret, 'files', 'status', array('status'));  db_add_index($ret, 'files', 'timestamp', array('timestamp'));  // Rename the file_revisions table to upload then add nid column. Since we're  // changing the table name we need to drop and re-add the indexes and  // the primary key so both mysql and pgsql end up with the correct index  // names.  db_drop_primary_key($ret, 'file_revisions');  db_drop_index($ret, 'file_revisions', 'vid');  db_rename_table($ret, 'file_revisions', 'upload');  db_add_field($ret, 'upload', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_add_index($ret, 'upload', 'nid', array('nid'));  db_add_primary_key($ret, 'upload', array('vid', 'fid'));  db_add_index($ret, 'upload', 'fid', array('fid'));  // The nid column was renamed to uid. Use the old nid to find the node's uid.  update_sql('UPDATE {files} SET uid = (SELECT n.uid FROM {node} n WHERE {files}.uid = n.nid)');  update_sql('UPDATE {upload} SET nid = (SELECT r.nid FROM {node_revisions} r WHERE {upload}.vid = r.vid)');  // Mark all existing files as FILE_STATUS_PERMANENT.  $ret[] = update_sql('UPDATE {files} SET status = 1');  return $ret;}function system_update_6023() {  $ret = array();  // nid is DEFAULT 0  db_drop_index($ret, 'node_revisions', 'nid');  db_change_field($ret, 'node_revisions', 'nid', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_add_index($ret, 'node_revisions', 'nid', array('nid'));  return $ret;}/** * Add translation fields to nodes used by translation module. */function system_update_6024() {  $ret = array();  db_add_field($ret, 'node', 'tnid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));  db_add_field($ret, 'node', 'translate', array('type' => 'int', 'not null' => TRUE, 'default' => 0));  db_add_index($ret, 'node', 'tnid', array('tnid'));  db_add_index($ret, 'node', 'translate', array('translate'));  return $ret;}/** * Increase the maximum length of node titles from 128 to 255. */function system_update_6025() {  $ret = array();  db_drop_index($ret, 'node', 'node_title_type');  db_change_field($ret, 'node', 'title', 'title', array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''));  db_add_index($ret, 'node', 'node_title_type', array('title', array('type', 4)));  db_change_field($ret, 'node_revisions', 'title', 'title', array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''));  return $ret;}/** * Display warning about new Update status module. */function system_update_6026() {  $ret = array();  // Notify user that new update module exists.  drupal_set_message('Drupal can check periodically for important bug fixes and security releases using the new update status module. This module can be turned on from the <a href="'. url('admin/build/modules') .'">modules administration page</a>. For more information please read the <a href="http://drupal.org/handbook/modules/update">Update status handbook page</a>.');  return $ret;}/** * Add block cache. */function system_update_6027() {  $ret = array();  // Create the blocks.cache column.  db_add_field($ret, 'blocks', 'cache', array('type' => 'int', 'not null' => TRUE, 'default' => 1, 'size' => 'tiny'));  // The cache_block table is created in update_fix_d6_requirements() since  // calls to cache_clear_all() would otherwise cause warnings.  // Fill in the values for the new 'cache' column in the {blocks} table.  foreach (module_list() as $module) {    if ($module_blocks = module_invoke($module, 'block', 'list')) {      foreach ($module_blocks as $delta => $block) {        if (isset($block['cache'])) {          db_query("UPDATE {blocks} SET cache = %d WHERE module = '%s' AND delta = '%s'", $block['cache'], $module, $delta);        }      }    }  }  return $ret;}/** * Add the node load cache table. */function system_update_6028() {  // Removed node_load cache to discuss it more for Drupal 7.  return array();}/** * Enable the dblog module on sites that upgrade, since otherwise * watchdog logging will stop unexpectedly. */function system_update_6029() {  // The watchdog table is now owned by dblog, which is not yet  // "installed" according to the system table, but the table already  // exists.  We set the module as "installed" here to avoid an error  // later.  //  // Although not the case for the initial D6 release, it is likely  // that dblog.install will have its own update functions eventually.  // However, dblog did not exist in D5 and this update is part of the  // initial D6 release, so we know that dblog is not installed yet.  // It is therefore correct to install it as version 0.  If  // dblog updates exist, the next run of update.php will get them.  drupal_set_installed_schema_version('dblog', 0);  module_enable(array('dblog'));  menu_rebuild();  return array(array('success' => TRUE, 'query' => "'dblog' module enabled."));}/** * Add the tables required by actions.inc. */function system_update_6030() {  $ret = array();  // Rename the old contrib actions table if it exists so the contrib version  // of the module can do something with the old data.  if (db_table_exists('actions')) {    db_rename_table($ret, 'actions', 'actions_old_contrib');  }  $schema['actions'] = array(    'fields' => array(      'aid' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => '0'),      'type' => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''),      'callback' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => ''),      'parameters' => array('type' => 'text', 'not null' => TRUE, 'size' => 'big'),      'description' => array('type' => 'varchar', 'length' => 255, 'not null' => TRUE, 'default' => '0'),    ),    'primary key' => array('aid'),  );  $schema['actions_aid'] = array(    'fields' => array(      'aid' => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE),    ),    'primary key' => array('aid'),  );  db_create_table($ret, 'actions', $schema['actions']);  db_create_table($ret, 'actions_aid', $schema['actions_aid']);  return $ret;}/** * Ensure that installer cannot be run again after updating from Drupal 5.x to 6.x * Actually, this is already done by system_update_6014(), so this is now a no-op. */function system_update_6031() {  return array();}/** * profile_fields.name used to be nullable but is part of a unique key * and so shouldn't be. */function system_update_6032() {  $ret = array();  if (db_table_exists('profile_fields')) {    db_drop_unique_key($ret, 'profile_fields', 'name');    db_change_field($ret, 'profile_fields', 'name', 'name', array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''));    db_add_unique_key($ret, 'profile_fields', 'name', array('name'));  }  return $ret;}/** * Change node_comment_statistics to be not autoincrement. */function system_update_6033() {  $ret = array();  if (db_table_exists('node_comment_statistics')) {    // On pgsql but not mysql, db_change_field() drops all keys    // involving the changed field, which in this case is the primary    // key.  The normal approach is explicitly drop the pkey, change the    // field, and re-create the pkey.    //    // Unfortunately, in this case that won't work on mysql; we CANNOT    // drop the pkey because on mysql auto-increment fields must be    // included in at least one key or index.    //    // Since we cannot drop the pkey before db_change_field(), after    // db_change_field() we may or may not still have a pkey.  The    // simple way out is to re-create the pkey only when using pgsql.    // Realistic requirements trump idealistic purity.    db_change_field($ret, 'node_comment_statistics', 'nid', 'nid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));    if ($GLOBALS['db_type'] == 'pgsql') {      db_add_primary_key($ret, 'node_comment_statistics', array('nid'));    }  }  return $ret;}/** * Rename permission "administer access control" to "administer permissions". */function system_update_6034() {  $ret = array();  $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");  while ($role = db_fetch_object($result)) {    $renamed_permission = preg_replace('/administer access control/', 'administer permissions', $role->perm);    if ($renamed_permission != $role->perm) {      $ret[] = update_sql("UPDATE {permission} SET perm = '$renamed_permission' WHERE rid = $role->rid");    }  }  return $ret;}/** * Change index on system table for better performance. */function system_update_6035() {  $ret = array();  db_drop_index($ret, 'system', 'weight');  db_add_index($ret, 'system', 'modules', array(array('type', 12), 'status', 'weight', 'filename'));  db_add_index($ret, 'system', 'bootstrap', array(array('type', 12), 'status', 'bootstrap', 'weight', 'filename'));  return $ret;}/** * Change the search schema and indexing. * * The table data is preserved where possible in MYSQL and MYSQLi using * ALTER IGNORE. Other databases don't support that, so for them the * tables are dropped and re-created, and will need to be re-indexed * from scratch. */function system_update_6036() {  $ret = array();  if (db_table_exists('search_index')) {    // Create the search_dataset.reindex column.    db_add_field($ret, 'search_dataset', 'reindex', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0));    // Drop the search_index.from fields which are no longer used.    db_drop_index($ret, 'search_index', 'from_sid_type');    db_drop_field($ret, 'search_index', 'fromsid');    db_drop_field($ret, 'search_index', 'fromtype');    // Drop the search_dataset.sid_type index, so that it can be made unique.    db_drop_index($ret, 'search_dataset', 'sid_type');    // Create the search_node_links Table.    $search_node_links_schema = array(      'fields' => array(        'sid'      => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'type'     => array('type' => 'varchar', 'length' => 16, 'not null' => TRUE, 'default' => ''),        'nid'      => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'caption'    => array('type' => 'text', 'size' => 'big', 'not null' => FALSE),      ),      'primary key' => array('sid', 'type', 'nid'),      'indexes' => array('nid' => array('nid')),    );    db_create_table($ret, 'search_node_links', $search_node_links_schema);    // with the change to search_dataset.reindex, the search queue is handled differently,    // and this is no longer needed    variable_del('node_cron_last');    // Add a unique index for the search_index.    if ($GLOBALS['db_type'] == 'mysql' || $GLOBALS['db_type'] == 'mysqli') {      // Since it's possible that some existing sites have duplicates,      // create the index using the IGNORE keyword, which ignores duplicate errors.      // However, pgsql doesn't support it      $ret[] = update_sql("ALTER IGNORE TABLE {search_index} ADD UNIQUE KEY word_sid_type (word, sid, type)");      $ret[] = update_sql("ALTER IGNORE TABLE {search_dataset} ADD UNIQUE KEY sid_type (sid, type)");      // Everything needs to be reindexed.      $ret[] = update_sql("UPDATE {search_dataset} SET reindex = 1");    }    else {      // Delete the existing tables if there are duplicate values      if (db_result(db_query("SELECT sid FROM {search_dataset} GROUP BY sid, type HAVING COUNT(*) > 1")) || db_result(db_query("SELECT sid FROM {search_index} GROUP BY word, sid, type HAVING COUNT(*) > 1"))) {        $ret[] = update_sql('DELETE FROM {search_dataset}');        $ret[] = update_sql('DELETE FROM {search_index}');        $ret[] = update_sql('DELETE FROM {search_total}');      }      else {        // Everything needs to be reindexed.        $ret[] = update_sql("UPDATE {search_dataset} SET reindex = 1");      }      // create the new indexes      db_add_unique_key($ret, 'search_index', 'word_sid_type', array('word', 'sid', 'type'));      db_add_unique_key($ret, 'search_dataset', 'sid_type', array('sid', 'type'));    }  }  return $ret;}/** * Create consistent empty region for disabled blocks. */function system_update_6037() {  $ret = array();  db_change_field($ret, 'blocks', 'region', 'region', array('type' => 'varchar', 'length' => 64, 'not null' => TRUE, 'default' => ''));  $ret[] = update_sql("UPDATE {blocks} SET region = '' WHERE status = 0");  return $ret;}/** * Ensure that "Account" is not used as a Profile category. */function system_update_6038() {  $ret = array();  if (db_table_exists('profile_fields')) {    $ret[] = update_sql("UPDATE {profile_fields} SET category = 'Account settings' WHERE LOWER(category) = 'account'");    if ($affectedrows = db_affected_rows()) {      drupal_set_message('There were '. $affectedrows .' profile fields that used a reserved category name. They have been assigned to the category "Account settings".');    }  }  return $ret;}/** * Rename permissions "edit foo content" to "edit any foo content". * Also update poll module permission "create polls" to "create * poll content". */function system_update_6039() {  $ret = array();  $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");  while ($role = db_fetch_object($result)) {    $renamed_permission = preg_replace('/(?<=^|,\ )edit\ ([a-zA-Z0-9_\-]+)\ content(?=,|$)/', 'edit any $1 content', $role->perm);    $renamed_permission = preg_replace('/(?<=^|,\ )create\ polls(?=,|$)/', 'create poll content', $renamed_permission);    if ($renamed_permission != $role->perm) {      $ret[] = update_sql("UPDATE {permission} SET perm = '$renamed_permission' WHERE rid = $role->rid");    }  }  return $ret;}/** * Add a weight column to the upload table. */function system_update_6040() {  $ret = array();  if (db_table_exists('upload')) {    db_add_field($ret, 'upload', 'weight', array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'tiny'));  }  return $ret;}/** * Change forum vocabulary not to be required by default and set the weight of the forum.module 1 higher than the taxonomy.module. */function system_update_6041() {  $weight = intval((db_result(db_query("SELECT weight FROM {system} WHERE name = 'taxonomy'"))) + 1);  $ret = array();  $vid = intval(variable_get('forum_nav_vocabulary', ''));  if (db_table_exists('vocabulary') && $vid) {    $ret[] = update_sql("UPDATE {vocabulary} SET required = 0 WHERE vid = " . $vid);    $ret[] = update_sql("UPDATE {system} SET weight = ". $weight ." WHERE name = 'forum'");  }  return $ret;}/** * Upgrade recolored theme stylesheets to new array structure. */function system_update_6042() {  foreach (list_themes() as $theme) {    $stylesheet = variable_get('color_'. $theme->name .'_stylesheet', NULL);    if (!empty($stylesheet)) {      variable_set('color_'. $theme->name .'_stylesheets', array($stylesheet));      variable_del('color_'. $theme->name .'_stylesheet');    }  }  return array();}/** * Update table indices to make them more rational and useful. */function system_update_6043() {  $ret = array();  // Required modules first.  // Add new system module indexes.  db_add_index($ret, 'flood', 'allow', array('event', 'hostname', 'timestamp'));  db_add_index($ret, 'history', 'nid', array('nid'));  // Change length of theme field in {blocks} to be consistent with module, and  // to avoid a MySQL error regarding a too-long index.  Also add new indices.  db_change_field($ret, 'blocks', 'theme', 'theme', array('type' => 'varchar', 'length' => 64, 'not null' => TRUE, 'default' => ''),array(                  'unique keys' => array('tmd' => array('theme', 'module', 'delta'),),                  'indexes' => array('list' => array('theme', 'status', 'region', 'weight', 'module'),),));  db_add_index($ret, 'blocks_roles', 'rid', array('rid'));  // Improve filter module indices.  db_drop_index($ret, 'filters', 'weight');  db_add_unique_key($ret, 'filters', 'fmd', array('format', 'module', 'delta'));  db_add_index($ret, 'filters', 'list', array('format', 'weight', 'module', 'delta'));  // Drop unneeded keys form the node table.  db_drop_index($ret, 'node', 'status');  db_drop_unique_key($ret, 'node', 'nid_vid');  // Improve user module indices.  db_add_index($ret, 'users', 'mail', array('mail'));  db_add_index($ret, 'users_roles', 'rid', array('rid'));  // Optional modules - need to check if the tables exist.  // Alter aggregator module's tables primary keys to make them more useful.  if (db_table_exists('aggregator_category_feed')) {    db_drop_primary_key($ret, 'aggregator_category_feed');    db_add_primary_key($ret, 'aggregator_category_feed', array('cid', 'fid'));    db_add_index($ret, 'aggregator_category_feed', 'fid', array('fid'));  }  if (db_table_exists('aggregator_category_item')) {    db_drop_primary_key($ret, 'aggregator_category_item');    db_add_primary_key($ret, 'aggregator_category_item', array('cid', 'iid'));    db_add_index($ret, 'aggregator_category_item', 'iid', array('iid'));  }  // Alter contact module's table to add an index.  if (db_table_exists('contact')) {    db_add_index($ret, 'contact', 'list', array('weight', 'category'));  }  // Alter locale table to add a primary key, drop an index.  if (db_table_exists('locales_target')) {    db_add_primary_key($ret, 'locales_target', array('language', 'lid', 'plural'));  }  // Alter a poll module table to add a primary key.  if (db_table_exists('poll_votes')) {    db_drop_index($ret, 'poll_votes', 'nid');    db_add_primary_key($ret, 'poll_votes', array('nid', 'uid', 'hostname'));  }  // Alter a profile module table to add a primary key.  if (db_table_exists('profile_values')) {    db_drop_index($ret, 'profile_values', 'uid');    db_drop_index($ret, 'profile_values', 'fid');    db_change_field($ret,'profile_values' ,'fid', 'fid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0,), array('indexes' => array('fid' => array('fid'),)));    db_change_field($ret,'profile_values' ,'uid', 'uid', array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0,));    db_add_primary_key($ret, 'profile_values', array('uid', 'fid'));  }  // Alter a statistics module table to add an index.  if (db_table_exists('accesslog')) {    db_add_index($ret, 'accesslog', 'uid', array('uid'));  }  // Alter taxonomy module's tables.  if (db_table_exists('term_data')) {    db_drop_index($ret, 'term_data', 'vid');    db_add_index($ret, 'term_data', 'vid_name', array('vid', 'name'));    db_add_index($ret, 'term_data', 'taxonomy_tree', array('vid', 'weight', 'name'));  }  if (db_table_exists('term_node')) {    db_drop_primary_key($ret, 'term_node');    db_drop_index($ret, 'term_node', 'tid');    db_add_primary_key($ret, 'term_node', array('tid', 'vid'));  }  if (db_table_exists('term_relation')) {    db_drop_index($ret, 'term_relation', 'tid1');    db_add_unique_key($ret, 'term_relation', 'tid1_tid2', array('tid1', 'tid2'));  }  if (db_table_exists('term_synonym')) {    db_drop_index($ret, 'term_synonym', 'name');    db_add_index($ret, 'term_synonym', 'name_tid', array('name', 'tid'));  }  if (db_table_exists('vocabulary')) {    db_add_index($ret, 'vocabulary', 'list', array('weight', 'name'));  }  if (db_table_exists('vocabulary_node_types')) {    db_drop_primary_key($ret, 'vocabulary_node_types');    db_add_primary_key($ret, 'vocabulary_node_types', array('type', 'vid'));    db_add_index($ret, 'vocabulary_node_types', 'vid', array('vid'));  }  // If we updated in RC1 or before ensure we don't update twice.  variable_set('system_update_6043_RC2', TRUE);  return $ret;}/** * RC1 to RC2 index cleanup. */function system_update_6044() {  $ret = array();  // Delete invalid entries in {term_node} after system_update_6001.  $ret[] = update_sql("DELETE FROM {term_node} WHERE vid = 0");  // Only execute the rest of this function if 6043 was run in RC1 or before.  if (variable_get('system_update_6043_RC2', FALSE)) {    variable_del('system_update_6043_RC2');    return $ret;  }  // User module indices.  db_drop_unique_key($ret, 'users', 'mail');  db_add_index($ret, 'users', 'mail', array('mail'));  // Optional modules - need to check if the tables exist.  // Alter taxonomy module's tables.  if (db_table_exists('term_data')) {    db_drop_unique_key($ret, 'term_data', 'vid_name');    db_add_index($ret, 'term_data', 'vid_name', array('vid', 'name'));  }  if (db_table_exists('term_synonym')) {    db_drop_unique_key($ret, 'term_synonym', 'name_tid', array('name', 'tid'));    db_add_index($ret, 'term_synonym', 'name_tid', array('name', 'tid'));  }  return $ret;}/** * Update blog, book and locale module permissions. * * Blog module got "edit own blog" replaced with the more granular "create * blog entries", "edit own blog entries" and "delete own blog entries" * permissions. We grant create and edit to previously privileged users, but * delete is not granted to be in line with other permission changes in Drupal 6. * * Book module's "edit book pages" was upgraded to the bogus "edit book content" * in Drupal 6 RC1 instead of "edit any book content", which would be correct. * * Locale module introduced "administer languages" and "translate interface" * in place of "administer locales". * * Modeled after system_update_6039(). */function system_update_6045() {  $ret = array();  $result = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");  while ($role = db_fetch_object($result)) {    $renamed_permission = preg_replace('/(?<=^|,\ )edit\ own\ blog(?=,|$)/', 'create blog entries, edit own blog entries', $role->perm);    $renamed_permission = preg_replace('/(?<=^|,\ )edit\ book\ content(?=,|$)/', 'edit any book content', $renamed_permission);    $renamed_permission = preg_replace('/(?<=^|,\ )administer\ locales(?=,|$)/', 'administer languages, translate interface', $renamed_permission);    if ($renamed_permission != $role->perm) {      $ret[] = update_sql("UPDATE {permission} SET perm = '$renamed_permission' WHERE rid = $role->rid");    }  }  // Notify user that delete permissions may have been changed. This was in  // effect since system_update_6039(), but there was no user notice.  drupal_set_message('Drupal now has separate edit and delete permissions. Previously, users who were able to edit content were automatically allowed to delete it. For added security, delete permissions for individual core content types have been <strong>removed</strong> from all roles on your site (only roles with the "administer nodes" permission can now delete these types of content). If you would like to reenable any individual delete permissions, you can do this at the <a href="'. url('admin/user/permissions', array('fragment' => 'module-node')) .'">permissions page</a>.');  return $ret;}/** * Ensure that the file_directory_path variable is set (using the old 5.x * default, if necessary), so that the changed 6.x default won't break * existing sites. */function system_update_6046() {  $ret = array();  if (!variable_get('file_directory_path', FALSE)) {    variable_set('file_directory_path', 'files');    $ret[] = array('success' => TRUE, 'query' => "variable_set('file_directory_path')");  }  return $ret;}/** * Fix cache mode for blocks inserted in system_install() in fresh installs of previous RC. */function system_update_6047() {  $ret = array();  $ret[] = update_sql("UPDATE {blocks} SET cache = -1 WHERE module = 'user' AND delta IN ('0', '1')");  $ret[] = update_sql("UPDATE {blocks} SET cache = -1 WHERE module = 'system' AND delta = '0'");  return $ret;}/** * @} End of "defgroup updates-5.x-to-6.x" *//** * @defgroup updates-6.x-extra Extra system updates for 6.x * @{ *//*** Increase the size of the 'load_functions' and 'to_arg_functions' fields in table 'menu_router'.*/function system_update_6048() {  $ret = array();  db_change_field($ret, 'menu_router', 'load_functions', 'load_functions', array('type' => 'text', 'not null' => TRUE,));  db_change_field($ret, 'menu_router', 'to_arg_functions', 'to_arg_functions', array('type' => 'text', 'not null' => TRUE,));  return $ret;}/** * Replace src index on the {url_alias} table with src, language. */function system_update_6049() {  $ret = array();  db_drop_index($ret, 'url_alias', 'src');  db_add_index($ret, 'url_alias', 'src_language', array('src', 'language'));  return $ret;}/** * Clear any menu router blobs stored in the cache table. */function system_update_6050() {  $ret = array();  cache_clear_all('router:', 'cache_menu', TRUE);  return $ret;}/** * Create a signature_format column. */function system_update_6051() {  $ret = array();  if (!db_column_exists('users', 'signature_format')) {    // Set future input formats to FILTER_FORMAT_DEFAULT to ensure a safe default    // when incompatible modules insert into the users table. An actual format    // will be assigned when users save their signature.    $schema = array(      'type' => 'int',      'size' => 'small',      'not null' => TRUE,      'default' => FILTER_FORMAT_DEFAULT,      'description' => 'The {filter_formats}.format of the signature.',    );    db_add_field($ret, 'users', 'signature_format', $schema);    // Set the format of existing signatures to the current default input format.    if ($current_default_filter = variable_get('filter_default_format', 0)) {      $ret[] = update_sql("UPDATE {users} SET signature_format = ". $current_default_filter);    }    drupal_set_message("User signatures no longer inherit comment input formats. Each user's signature now has its own associated format that can be selected on the user's account page. Existing signatures have been set to your site's default input format.");  }  return $ret;}/** * Add a missing index on the {menu_router} table. */function system_update_6052() {  $ret = array();  db_add_index($ret, 'menu_router', 'tab_root_weight_title', array(array('tab_root', 64), 'weight', 'title'));  return $ret;}/** * Add a {system} index on type and name. */function system_update_6053() {  $ret = array();  db_add_index($ret, 'system', 'type_name', array(array('type', 12), 'name'));  return $ret;}/** * Add semaphore table. */function system_update_6054() {  $ret = array();  $schema['semaphore'] = array(    'fields' => array(      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'value' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'expire' => array(        'type' => 'float',        'size' => 'big',        'not null' => TRUE),      ),    'indexes' => array('expire' => array('expire')),    'primary key' => array('name'),  );  db_create_table($ret, 'semaphore', $schema['semaphore']);  return $ret;}/** * Improve indexes on the {url_alias} table. */function system_update_6055() {  $ret = array();  db_drop_index($ret, 'url_alias', 'src_language');  db_drop_unique_key($ret, 'url_alias', 'dst_language');  db_add_index($ret, 'url_alias', 'src_language_pid', array('src', 'language', 'pid'));  db_add_unique_key($ret, 'url_alias', 'dst_language_pid', array('dst', 'language', 'pid'));  return $ret;}/** * @} End of "defgroup updates-6.x-extra" * The next series of updates should start at 7000. */
<?php// $Id$/** * @file * Redirects logging messages to syslog. */if (defined('LOG_LOCAL0')) {  define('DEFAULT_SYSLOG_FACILITY', LOG_LOCAL0);}else {  define('DEFAULT_SYSLOG_FACILITY', LOG_USER);}/** * Implementation of hook_help(). */function syslog_help($path, $arg) {  switch ($path) {    case 'admin/help#syslog':      $output = '<p>'. t("The syslog module enables Drupal to send messages to the operating system's logging facility.") .'</p>';      $output .= '<p>'. t('Syslog is an operating system administrative logging tool, and provides valuable information for use in system management and security auditing. Most suited to medium and large sites, syslog provides filtering tools that allow messages to be routed by type and severity. On UNIX/Linux systems, the file /etc/syslog.conf defines this routing configuration; on Microsoft Windows, all messages are sent to the Event Log. For more information on syslog facilities, severity levels, and how to set up a syslog.conf file, see <a href="@syslog_conf">UNIX/Linux syslog.conf</a> and PHP\'s <a href="@php_openlog">openlog</a> and <a href="@php_syslog">syslog</a> functions.', array('@syslog_conf' => url('http://www.rt.com/man/syslog.5.html'), '@php_openlog' => url('http://www.php.net/manual/en/function.openlog.php'), '@php_syslog' => url('http://www.php.net/manual/en/function.syslog.php'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@syslog">Syslog module</a>.', array('@syslog' => 'http://drupal.org/handbook/modules/syslog')) .'</p>';      return $output;  }}function syslog_menu() {  $items['admin/settings/logging/syslog'] = array(    'title'          => 'Syslog',    'description'    => 'Settings for syslog logging. Syslog is an operating system administrative logging tool used in systems management and security auditing. Most suited to medium and large sites, syslog provides filtering tools that allow messages to be routed by type and severity.',    'page callback'  => 'drupal_get_form',    'page arguments' => array('syslog_admin_settings'),    'access arguments' => array('administer site configuration'),  );  return $items;}function syslog_admin_settings() {  $form['syslog_facility'] = array(    '#type'          => 'select',    '#title'         => t('Send events to this syslog facility'),    '#default_value' => variable_get('syslog_facility', DEFAULT_SYSLOG_FACILITY),    '#options'       => syslog_facility_list(),    '#description'   => t('Select the syslog facility code under which Drupal\'s messages should be sent. On UNIX/Linux systems, Drupal can flag its messages with the code LOG_LOCAL0 through LOG_LOCAL7; for Microsoft Windows, all messages are flagged with the code LOG_USER. Depending on the system configuration, syslog and other logging tools use this code to identify or filter Drupal messages from within the entire system log. For more information on syslog, see <a href="@syslog_help">Syslog help</a>.', array(      '@syslog_help' => url('admin/help/syslog'))),  );  return system_settings_form($form);}function syslog_facility_list() {  $facility_list = array(    LOG_USER   => t('LOG_USER - User level messages. Use this for Windows.'),  );  if (defined('LOG_LOCAL0')) {    $facility_list += array(      LOG_LOCAL0 => t('LOG_LOCAL0 - Local 0'),      LOG_LOCAL1 => t('LOG_LOCAL1 - Local 1'),      LOG_LOCAL2 => t('LOG_LOCAL2 - Local 2'),      LOG_LOCAL3 => t('LOG_LOCAL3 - Local 3'),      LOG_LOCAL4 => t('LOG_LOCAL4 - Local 4'),      LOG_LOCAL5 => t('LOG_LOCAL5 - Local 5'),      LOG_LOCAL6 => t('LOG_LOCAL6 - Local 6'),      LOG_LOCAL7 => t('LOG_LOCAL7 - Local 7'),    );  }  return $facility_list;}function syslog_watchdog($entry) {  static $log_init = FALSE;  if (!$log_init) {    $log_init = TRUE;    openlog('drupal', LOG_NDELAY, variable_get('syslog_facility', DEFAULT_SYSLOG_FACILITY));  }  syslog($entry['severity'], theme('syslog_format', $entry));}function syslog_theme() {  return array(    'syslog_format' => array(      'arguments' => array('entry' => NULL),    ),  );}/** * Format a system log entry. * * @ingroup themeable */function theme_syslog_format($entry) {  global $base_url;  $message  = $base_url;  $message .= '|'. $entry['timestamp'];  $message .= '|'. $entry['type'];  $message .= '|'. $entry['ip'];  $message .= '|'. $entry['request_uri'];  $message .= '|'. $entry['referer'];  $message .= '|'. $entry['user']->uid;  $message .= '|'. strip_tags($entry['link']);  $message .= '|'. strip_tags(is_null($entry['variables']) ? $entry['message'] : strtr($entry['message'], $entry['variables']));  return $message;}
<?php// $Id$/** * Implementation of hook_install(). */function profile_install() {  // Create tables.  drupal_install_schema('profile');}/** * Implementation of hook_uninstall(). */function profile_uninstall() {  // Remove tables  drupal_uninstall_schema('profile');  variable_del('profile_block_author_fields');}/** * Implementation of hook_schema(). */function profile_schema() {  $schema['profile_fields'] = array(    'description' => 'Stores profile field information.',    'fields' => array(      'fid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique profile field ID.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => 'Title of the field shown to the end user.',      ),      'name' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Internal name of the field used in the form HTML and URLs.',      ),      'explanation' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'Explanation of the field to end users.',      ),      'category' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => 'Profile category that the field will be grouped under.',      ),      'page' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => "Title of page used for browsing by the field's value",      ),      'type' => array(        'type' => 'varchar',        'length' => 128,        'not null' => FALSE,        'description' => 'Type of form field.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Weight of field in relation to other profile fields.',      ),      'required' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether the user is required to enter a value. (0 = no, 1 = yes)',      ),      'register' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether the field is visible in the user registration form. (1 = yes, 0 = no)',      ),      'visibility' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The level of visibility for the field. (0 = hidden, 1 = private, 2 = public on profile but not member list pages, 3 = public on profile and list pages)',      ),      'autocomplete' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether form auto-completion is enabled. (0 = disabled, 1 = enabled)',      ),      'options' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'List of options to be used in a list selection field.',      ),    ),    'indexes' => array('category' => array('category')),    'unique keys' => array('name' => array('name')),    'primary key' => array('fid'),  );  $schema['profile_values'] = array(    'description' => 'Stores values for profile fields.',    'fields' => array(      'fid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {profile_fields}.fid of the field.',      ),      'uid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {users}.uid of the profile user.',      ),      'value' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'The value for the field.',      ),    ),    'primary key' => array('uid', 'fid'),    'indexes' => array(      'fid' => array('fid'),    ),  );  return $schema;}
<?php// $Id$/** * Implementation of hook_install(). */function openid_install() {  // Create table.  drupal_install_schema('openid');}/** * Implementation of hook_uninstall(). */function openid_uninstall() {  // Remove table.  drupal_uninstall_schema('openid');}/** * Implementation of hook_schema(). */function openid_schema() {  $schema['openid_association'] = array(    'description' => 'Stores temporary shared key association information for OpenID authentication.',    'fields' => array(      'idp_endpoint_uri' => array(        'type' => 'varchar',        'length' => 255,        'description' => 'URI of the OpenID Provider endpoint.',      ),      'assoc_handle' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'description' => 'Primary Key: Used to refer to this association in subsequent messages.',      ),      'assoc_type' => array(        'type' => 'varchar',        'length' => 32,        'description' => 'The signature algorithm used: one of HMAC-SHA1 or HMAC-SHA256.',      ),      'session_type' => array(        'type' => 'varchar',        'length' => 32,        'description' => 'Valid association session types: "no-encryption", "DH-SHA1", and "DH-SHA256".',      ),      'mac_key' => array(        'type' => 'varchar',        'length' => 255,        'description' => 'The MAC key (shared secret) for this association.',      ),      'created' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'UNIX timestamp for when the association was created.',      ),      'expires_in' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The lifetime, in seconds, of this association.',      ),    ),    'primary key' => array('assoc_handle'),  );  return $schema;}
<?php// $Id$/** * @file forum-icon.tpl.php * Display an appropriate icon for a forum post. * * Available variables: * - $new_posts: Indicates whether or not the topic contains new posts. * - $icon: The icon to display. May be one of 'hot', 'hot-new', 'new', *   'default', 'closed', or 'sticky'. * * @see template_preprocess_forum_icon() * @see theme_forum_icon() */?><?php if ($new_posts): ?>  <a name="new"><?php endif; ?><?php print theme('image', "misc/forum-$icon.png") ?><?php if ($new_posts): ?>  </a><?php endif; ?>
<?php// $Id$/** * @file * Enables users to comment on published content. * * When enabled, the Drupal comment module creates a discussion * board for each Drupal node. Users can post comments to discuss * a forum topic, weblog post, story, collaborative book page, etc. *//** * Comment is published. */define('COMMENT_PUBLISHED', 0);/** * Comment is awaiting approval. */define('COMMENT_NOT_PUBLISHED', 1);/** * Comments are displayed in a flat list - collapsed. */define('COMMENT_MODE_FLAT_COLLAPSED', 1);/** * Comments are displayed in a flat list - expanded. */define('COMMENT_MODE_FLAT_EXPANDED', 2);/** * Comments are displayed as a threaded list - collapsed. */define('COMMENT_MODE_THREADED_COLLAPSED', 3);/** * Comments are displayed as a threaded list - expanded. */define('COMMENT_MODE_THREADED_EXPANDED', 4);/** * Comments are ordered by date - newest first. */define('COMMENT_ORDER_NEWEST_FIRST', 1);/** * Comments are ordered by date - oldest first. */define('COMMENT_ORDER_OLDEST_FIRST', 2);/** * Comment controls should be shown above the comment list. */define('COMMENT_CONTROLS_ABOVE', 0);/** * Comment controls should be shown below the comment list. */define('COMMENT_CONTROLS_BELOW', 1);/** * Comment controls should be shown both above and below the comment list. */define('COMMENT_CONTROLS_ABOVE_BELOW', 2);/** * Comment controls are hidden. */define('COMMENT_CONTROLS_HIDDEN', 3);/** * Anonymous posters may not enter their contact information. */define('COMMENT_ANONYMOUS_MAYNOT_CONTACT', 0);/** * Anonymous posters may leave their contact information. */define('COMMENT_ANONYMOUS_MAY_CONTACT', 1);/** * Anonymous posters must leave their contact information. */define('COMMENT_ANONYMOUS_MUST_CONTACT', 2);/** * Comment form should be displayed on a separate page. */define('COMMENT_FORM_SEPARATE_PAGE', 0);/** * Comment form should be shown below post or list of comments. */define('COMMENT_FORM_BELOW', 1);/** * Comments for this node are disabled. */define('COMMENT_NODE_DISABLED', 0);/** * Comments for this node are locked. */define('COMMENT_NODE_READ_ONLY', 1);/** * Comments are enabled on this node. */define('COMMENT_NODE_READ_WRITE', 2);/** * Comment preview is optional. */define('COMMENT_PREVIEW_OPTIONAL', 0);/** * Comment preview is required. */define('COMMENT_PREVIEW_REQUIRED', 1);/** * Implementation of hook_help(). */function comment_help($path, $arg) {  switch ($path) {    case 'admin/help#comment':      $output = '<p>'. t('The comment module allows visitors to comment on your posts, creating ad hoc discussion boards. Any <a href="@content-type">content type</a> may have its <em>Default comment setting</em> set to <em>Read/Write</em> to allow comments, or <em>Disabled</em>, to prevent comments. Comment display settings and other controls may also be customized for each content type (some display settings are customizable by individual users).', array('@content-type' => url('admin/content/types'))) .'</p>';      $output .= '<p>'. t('Comment permissions are assigned to user roles, and are used to determine whether anonymous users (or other roles) are allowed to comment on posts. If anonymous users are allowed to comment, their individual contact information may be retained in cookies stored on their local computer for use in later comment submissions. When a comment has no replies, it may be (optionally) edited by its author. The comment module uses the same input formats and HTML tags available when creating other forms of content.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@comment">Comment module</a>.', array('@comment' => 'http://drupal.org/handbook/modules/comment/')) .'</p>';      return $output;    case 'admin/content/comment':      return '<p>'. t("Below is a list of the latest comments posted to your site. Click on a subject to see the comment, the author's name to edit the author's user information, 'edit' to modify the text, and 'delete' to remove their submission.") .'</p>';    case 'admin/content/comment/approval':      return '<p>'. t("Below is a list of the comments posted to your site that need approval. To approve a comment, click on 'edit' and then change its 'moderation status' to Approved. Click on a subject to see the comment, the author's name to edit the author's user information, 'edit' to modify the text, and 'delete' to remove their submission.") .'</p>';  }}/** * Implementation of hook_theme(). */function comment_theme() {  return array(    'comment_block' => array(      'arguments' => array(),    ),    'comment_admin_overview' => array(      'arguments' => array('form' => NULL),    ),    'comment_preview' => array(      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array(), 'visible' => 1),    ),    'comment_view' => array(      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array(), 'visible' => 1),    ),    'comment_controls' => array(      'arguments' => array('form' => NULL),    ),    'comment' => array(      'template' => 'comment',      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array()),    ),    'comment_folded' => array(      'template' => 'comment-folded',      'arguments' => array('comment' => NULL),    ),    'comment_flat_collapsed' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_flat_expanded' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_thread_collapsed' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_thread_expanded' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_post_forbidden' => array(      'arguments' => array('nid' => NULL),    ),    'comment_wrapper' => array(      'template' => 'comment-wrapper',      'arguments' => array('content' => NULL, 'node' => NULL),    ),    'comment_submitted' => array(      'arguments' => array('comment' => NULL),    ),  );}/** * Implementation of hook_menu(). */function comment_menu() {  $items['admin/content/comment'] = array(    'title' => 'Comments',    'description' => 'List and edit site comments and the comment moderation queue.',    'page callback' => 'comment_admin',    'access arguments' => array('administer comments'),    'file' => 'comment.admin.inc',  );  // Tabs:  $items['admin/content/comment/new'] = array(    'title' => 'Published comments',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/comment/approval'] = array(    'title' => 'Approval queue',    'page arguments' => array('approval'),    'access arguments' => array('administer comments'),    'type' => MENU_LOCAL_TASK,    'file' => 'comment.admin.inc',  );  $items['comment/delete'] = array(    'title' => 'Delete comment',    'page callback' => 'comment_delete',    'access arguments' => array('administer comments'),    'type' => MENU_CALLBACK,    'file' => 'comment.admin.inc',  );  $items['comment/edit'] = array(    'title' => 'Edit comment',    'page callback' => 'comment_edit',    'access arguments' => array('post comments'),    'type' => MENU_CALLBACK,    'file' => 'comment.pages.inc',  );  $items['comment/reply/%node'] = array(    'title' => 'Reply to comment',    'page callback' => 'comment_reply',    'page arguments' => array(2),    'access callback' => 'node_access',    'access arguments' => array('view', 2),    'type' => MENU_CALLBACK,    'file' => 'comment.pages.inc',  );  return $items;}/** * Implementation of hook_node_type(). */function comment_node_type($op, $info) {  $settings = array(    'comment',    'comment_default_mode',    'comment_default_order',    'comment_default_per_page',    'comment_controls',    'comment_anonymous',    'comment_subject_field',    'comment_preview',    'comment_form_location',  );  switch ($op) {    case 'delete':      foreach ($settings as $setting) {        variable_del($setting .'_'. $info->type);      }      break;  }}/** * Implementation of hook_perm(). */function comment_perm() {  return array('access comments', 'post comments', 'administer comments', 'post comments without approval');}/** * Implementation of hook_block(). * * Generates a block with the most recent comments. */function comment_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Recent comments');    return $blocks;  }  else if ($op == 'view' && user_access('access comments')) {    $block['subject'] = t('Recent comments');    $block['content'] = theme('comment_block');    return $block;  }}/** * Find a number of recent comments. This is done in two steps. *   1. Find the n (specified by $number) nodes that have the most recent *      comments.  This is done by querying node_comment_statistics which has *      an index on last_comment_timestamp, and is thus a fast query. *   2. Loading the information from the comments table based on the nids found *      in step 1. * * @param $number *   (optional) The maximum number of comments to find. * @return *   An array of comment objects each containing a nid, *   subject, cid, and timestamp, or an empty array if there are no recent *   comments visible to the current user. */function comment_get_recent($number = 10) {  // Select the $number nodes (visible to the current user) with the most  // recent comments. This is efficient due to the index on  // last_comment_timestamp.  $result = db_query_range(db_rewrite_sql("SELECT nc.nid FROM {node_comment_statistics} nc WHERE nc.comment_count > 0 ORDER BY nc.last_comment_timestamp DESC", 'nc'), 0, $number);  $nids = array();  while ($row = db_fetch_object($result)) {    $nids[] = $row->nid;  }  $comments = array();  if (!empty($nids)) {    // From among the comments on the nodes selected in the first query,    // find the $number most recent comments.    $result = db_query_range('SELECT c.nid, c.subject, c.cid, c.timestamp FROM {comments} c INNER JOIN {node} n ON n.nid = c.nid WHERE c.nid IN ('. implode(',', $nids) .') AND n.status = 1 AND c.status = %d ORDER BY c.cid DESC', COMMENT_PUBLISHED, 0, $number);    while ($comment = db_fetch_object($result)) {      $comments[] = $comment;    }  }  return $comments;}/** * Calculate page number for first new comment. * * @param $num_comments *   Number of comments. * @param $new_replies *   Number of new replies. * @param $node *   The first new comment node. * @return *   "page=X" if the page number is greater than zero; empty string otherwise. */function comment_new_page_count($num_comments, $new_replies, $node) {  $comments_per_page = _comment_get_display_setting('comments_per_page', $node);  $mode = _comment_get_display_setting('mode', $node);  $order = _comment_get_display_setting('sort', $node);  $pagenum = NULL;  $flat = in_array($mode, array(COMMENT_MODE_FLAT_COLLAPSED, COMMENT_MODE_FLAT_EXPANDED));  if ($num_comments <= $comments_per_page || ($flat && $order == COMMENT_ORDER_NEWEST_FIRST)) {    // Only one page of comments or flat forum and newest first.    // First new comment will always be on first page.    $pageno = 0;  }  else {    if ($flat) {      // Flat comments and oldest first.      $count = $num_comments - $new_replies;    }    else {      // Threaded comments. See the documentation for comment_render().      if ($order == COMMENT_ORDER_NEWEST_FIRST) {        // Newest first: find the last thread with new comment        $result = db_query('SELECT thread FROM (SELECT thread FROM {comments} WHERE nid = %d AND status = 0 ORDER BY timestamp DESC LIMIT %d) AS thread ORDER BY thread DESC LIMIT 1', $node->nid, $new_replies);        $thread = db_result($result);        $result_count = db_query("SELECT COUNT(*) FROM {comments} WHERE nid = %d AND status = 0 AND thread > '". $thread ."'", $node->nid);      }      else {        // Oldest first: find the first thread with new comment        $result = db_query('SELECT thread FROM (SELECT thread FROM {comments} WHERE nid = %d AND status = 0 ORDER BY timestamp DESC LIMIT %d) AS thread ORDER BY SUBSTRING(thread, 1, (LENGTH(thread) - 1)) LIMIT 1', $node->nid, $new_replies);        $thread = substr(db_result($result), 0, -1);        $result_count = db_query("SELECT COUNT(*) FROM {comments} WHERE nid = %d AND status = 0 AND SUBSTRING(thread, 1, (LENGTH(thread) - 1)) < '". $thread ."'", $node->nid);      }      $count = db_result($result_count);    }    $pageno =  $count / $comments_per_page;  }  if ($pageno >= 1) {    $pagenum = "page=". intval($pageno);  }  return $pagenum;}/** * Returns a formatted list of recent comments to be displayed in the comment block. * * @return *   The comment list HTML. * @ingroup themeable */function theme_comment_block() {  $items = array();  foreach (comment_get_recent() as $comment) {    $items[] = l($comment->subject, 'node/'. $comment->nid, array('fragment' => 'comment-'. $comment->cid)) .'<br />'. t('@time ago', array('@time' => format_interval(time() - $comment->timestamp)));  }  if ($items) {    return theme('item_list', $items);  }}/** * Implementation of hook_link(). */function comment_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && $node->comment) {    if ($teaser) {      // Main page: display the number of comments that have been posted.      if (user_access('access comments')) {        $all = comment_num_all($node->nid);        if ($all) {          $links['comment_comments'] = array(            'title' => format_plural($all, '1 comment', '@count comments'),            'href' => "node/$node->nid",            'attributes' => array('title' => t('Jump to the first comment of this posting.')),            'fragment' => 'comments'          );          $new = comment_num_new($node->nid);          if ($new) {            $links['comment_new_comments'] = array(              'title' => format_plural($new, '1 new comment', '@count new comments'),              'href' => "node/$node->nid",              'query' => comment_new_page_count($all, $new, $node),              'attributes' => array('title' => t('Jump to the first new comment of this posting.')),              'fragment' => 'new'            );          }        }        else {          if ($node->comment == COMMENT_NODE_READ_WRITE) {            if (user_access('post comments')) {              $links['comment_add'] = array(                'title' => t('Add new comment'),                'href' => "comment/reply/$node->nid",                'attributes' => array('title' => t('Add a new comment to this page.')),                'fragment' => 'comment-form'              );            }            else {              $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);            }          }        }      }    }    else {      // Node page: add a "post comment" link if the user is allowed to      // post comments, if this node is not read-only, and if the comment form isn't already shown      if ($node->comment == COMMENT_NODE_READ_WRITE) {        if (user_access('post comments')) {          if (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_SEPARATE_PAGE) {            $links['comment_add'] = array(              'title' => t('Add new comment'),              'href' => "comment/reply/$node->nid",              'attributes' => array('title' => t('Share your thoughts and opinions related to this posting.')),              'fragment' => 'comment-form'            );          }        }        else {          $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);        }      }    }  }  if ($type == 'comment') {    $links = comment_links($node, $teaser);  }  if (isset($links['comment_forbidden'])) {    $links['comment_forbidden']['html'] = TRUE;  }  return $links;}/** * Implementation of hook_form_alter(). */function comment_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {    $form['comment'] = array(      '#type' => 'fieldset',      '#title' => t('Comment settings'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,    );    $form['comment']['comment'] = array(      '#type' => 'radios',      '#title' => t('Default comment setting'),      '#default_value' => variable_get('comment_'. $form['#node_type']->type, COMMENT_NODE_READ_WRITE),      '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),      '#description' => t('Users with the <em>administer comments</em> permission will be able to override this setting.'),    );    $form['comment']['comment_default_mode'] = array(      '#type' => 'radios',      '#title' => t('Default display mode'),      '#default_value' => variable_get('comment_default_mode_'. $form['#node_type']->type, COMMENT_MODE_THREADED_EXPANDED),      '#options' => _comment_get_modes(),      '#description' => t('The default view for comments. Expanded views display the body of the comment. Threaded views keep replies together.'),    );    $form['comment']['comment_default_order'] = array(      '#type' => 'radios',      '#title' => t('Default display order'),      '#default_value' => variable_get('comment_default_order_'. $form['#node_type']->type, COMMENT_ORDER_NEWEST_FIRST),      '#options' => _comment_get_orders(),      '#description' => t('The default sorting for new users and anonymous users while viewing comments. These users may change their view using the comment control panel. For registered users, this change is remembered as a persistent user preference.'),    );    $form['comment']['comment_default_per_page'] = array(      '#type' => 'select',      '#title' => t('Default comments per page'),      '#default_value' => variable_get('comment_default_per_page_'. $form['#node_type']->type, 50),      '#options' => _comment_per_page(),      '#description' => t('Default number of comments for each page: more comments are distributed in several pages.'),    );    $form['comment']['comment_controls'] = array(      '#type' => 'radios',      '#title' => t('Comment controls'),      '#default_value' => variable_get('comment_controls_'. $form['#node_type']->type, COMMENT_CONTROLS_HIDDEN),      '#options' => array(        t('Display above the comments'),        t('Display below the comments'),        t('Display above and below the comments'),        t('Do not display')),      '#description' => t('Position of the comment controls box. The comment controls let the user change the default display mode and display order of comments.'),    );    $form['comment']['comment_anonymous'] = array(      '#type' => 'radios',      '#title' => t('Anonymous commenting'),      '#default_value' => variable_get('comment_anonymous_'. $form['#node_type']->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT),      '#options' => array(        COMMENT_ANONYMOUS_MAYNOT_CONTACT => t('Anonymous posters may not enter their contact information'),        COMMENT_ANONYMOUS_MAY_CONTACT => t('Anonymous posters may leave their contact information'),        COMMENT_ANONYMOUS_MUST_CONTACT => t('Anonymous posters must leave their contact information')),      '#description' => t('This option is enabled when anonymous users have permission to post comments on the <a href="@url">permissions page</a>.', array('@url' => url('admin/user/permissions', array('fragment' => 'module-comment')))),    );    if (!user_access('post comments', drupal_anonymous_user())) {      $form['comment']['comment_anonymous']['#disabled'] = TRUE;    }    $form['comment']['comment_subject_field'] = array(      '#type' => 'radios',      '#title' => t('Comment subject field'),      '#default_value' => variable_get('comment_subject_field_'. $form['#node_type']->type, 1),      '#options' => array(t('Disabled'), t('Enabled')),      '#description' => t('Can users provide a unique subject for their comments?'),    );    $form['comment']['comment_preview'] = array(      '#type' => 'radios',      '#title' => t('Preview comment'),      '#default_value' => variable_get('comment_preview_'. $form['#node_type']->type, COMMENT_PREVIEW_REQUIRED),      '#options' => array(t('Optional'), t('Required')),      '#description' => t("Forces a user to look at their comment by clicking on a 'Preview' button before they can actually add the comment"),    );    $form['comment']['comment_form_location'] = array(      '#type' => 'radios',      '#title' => t('Location of comment submission form'),      '#default_value' => variable_get('comment_form_location_'. $form['#node_type']->type, COMMENT_FORM_SEPARATE_PAGE),      '#options' => array(t('Display on separate page'), t('Display below post or comments')),    );  }  elseif (isset($form['type']) && isset($form['#node'])) {    if ($form['type']['#value'] .'_node_form' == $form_id) {      $node = $form['#node'];      $form['comment_settings'] = array(        '#type' => 'fieldset',        '#access' => user_access('administer comments'),        '#title' => t('Comment settings'),        '#collapsible' => TRUE,        '#collapsed' => TRUE,        '#weight' => 30,      );      $form['comment_settings']['comment'] = array(        '#type' => 'radios',        '#parents' => array('comment'),        '#default_value' => $node->comment,        '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),      );    }  }}/** * Implementation of hook_nodeapi(). */function comment_nodeapi(&$node, $op, $arg = 0) {  switch ($op) {    case 'load':      return db_fetch_array(db_query("SELECT last_comment_timestamp, last_comment_name, comment_count FROM {node_comment_statistics} WHERE nid = %d", $node->nid));      break;    case 'prepare':      if (!isset($node->comment)) {        $node->comment = variable_get("comment_$node->type", COMMENT_NODE_READ_WRITE);      }      break;    case 'insert':      db_query('INSERT INTO {node_comment_statistics} (nid, last_comment_timestamp, last_comment_name, last_comment_uid, comment_count) VALUES (%d, %d, NULL, %d, 0)', $node->nid, $node->changed, $node->uid);      break;    case 'delete':      db_query('DELETE FROM {comments} WHERE nid = %d', $node->nid);      db_query('DELETE FROM {node_comment_statistics} WHERE nid = %d', $node->nid);      break;    case 'update index':      $text = '';      $comments = db_query('SELECT subject, comment, format FROM {comments} WHERE nid = %d AND status = %d', $node->nid, COMMENT_PUBLISHED);      while ($comment = db_fetch_object($comments)) {        $text .= '<h2>'. check_plain($comment->subject) .'</h2>'. check_markup($comment->comment, $comment->format, FALSE);      }      return $text;    case 'search result':      $comments = db_result(db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = %d', $node->nid));      return format_plural($comments, '1 comment', '@count comments');    case 'rss item':      if ($node->comment != COMMENT_NODE_DISABLED) {        return array(array('key' => 'comments', 'value' => url('node/'. $node->nid, array('fragment' => 'comments', 'absolute' => TRUE))));      }      else {        return array();      }  }}/** * Implementation of hook_user(). */function comment_user($type, $edit, &$user, $category = NULL) {  if ($type == 'delete') {    db_query('UPDATE {comments} SET uid = 0 WHERE uid = %d', $user->uid);    db_query('UPDATE {node_comment_statistics} SET last_comment_uid = 0 WHERE last_comment_uid = %d', $user->uid);  }}/** * This is *not* a hook_access() implementation. This function is called * to determine whether the current user has access to a particular comment. * * Authenticated users can edit their comments as long they have not been * replied to. This prevents people from changing or revising their * statements based on the replies to their posts. * * @param $op *   The operation that is to be performed on the comment. Only 'edit' is recognized now. * @param $comment *   The comment object. * @return *   TRUE if the current user has acces to the comment, FALSE otherwise. */function comment_access($op, $comment) {  global $user;  if ($op == 'edit') {    return ($user->uid && $user->uid == $comment->uid && comment_num_replies($comment->cid) == 0) || user_access('administer comments');  }}/** * A simple helper function. * * @return *   The 0th and the 1st path components joined by a slash. */function comment_node_url() {  return arg(0) .'/'. arg(1);}/** * Accepts a submission of new or changed comment content. * * @param $edit *   A comment array. * * @return *   If the comment is successfully saved the comment ID is returned. If the comment *   is not saved, FALSE is returned. */function comment_save($edit) {  global $user;  if (user_access('post comments') && (user_access('administer comments') || node_comment_mode($edit['nid']) == COMMENT_NODE_READ_WRITE)) {    if (!form_get_errors()) {      $edit += array(        'mail' => '',        'homepage' => '',        'name' => '',        'status' => user_access('post comments without approval') ? COMMENT_PUBLISHED : COMMENT_NOT_PUBLISHED,      );      if ($edit['cid']) {        // Update the comment in the database.        db_query("UPDATE {comments} SET status = %d, timestamp = %d, subject = '%s', comment = '%s', format = %d, uid = %d, name = '%s', mail = '%s', homepage = '%s' WHERE cid = %d", $edit['status'], $edit['timestamp'], $edit['subject'], $edit['comment'], $edit['format'], $edit['uid'], $edit['name'], $edit['mail'], $edit['homepage'], $edit['cid']);        // Allow modules to respond to the updating of a comment.        comment_invoke_comment($edit, 'update');        // Add an entry to the watchdog log.        watchdog('content', 'Comment: updated %subject.', array('%subject' => $edit['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $edit['nid'], array('fragment' => 'comment-'. $edit['cid'])));      }      else {        // Add the comment to database.        // Here we are building the thread field. See the documentation for        // comment_render().        if ($edit['pid'] == 0) {          // This is a comment with no parent comment (depth 0): we start          // by retrieving the maximum thread level.          $max = db_result(db_query('SELECT MAX(thread) FROM {comments} WHERE nid = %d', $edit['nid']));          // Strip the "/" from the end of the thread.          $max = rtrim($max, '/');          // Finally, build the thread field for this new comment.          $thread = int2vancode(vancode2int($max) + 1) .'/';        }        else {          // This is comment with a parent comment: we increase          // the part of the thread value at the proper depth.          // Get the parent comment:          $parent = _comment_load($edit['pid']);          // Strip the "/" from the end of the parent thread.          $parent->thread = (string) rtrim((string) $parent->thread, '/');          // Get the max value in _this_ thread.          $max = db_result(db_query("SELECT MAX(thread) FROM {comments} WHERE thread LIKE '%s.%%' AND nid = %d", $parent->thread, $edit['nid']));          if ($max == '') {            // First child of this parent.            $thread = $parent->thread .'.'. int2vancode(0) .'/';          }          else {            // Strip the "/" at the end of the thread.            $max = rtrim($max, '/');            // We need to get the value at the correct depth.            $parts = explode('.', $max);            $parent_depth = count(explode('.', $parent->thread));            $last = $parts[$parent_depth];            // Finally, build the thread field for this new comment.            $thread = $parent->thread .'.'. int2vancode(vancode2int($last) + 1) .'/';          }        }        if (empty($edit['timestamp'])) {          $edit['timestamp'] = time();        }        if ($edit['uid'] === $user->uid && isset($user->name)) { // '===' Need to modify anonymous users as well.          $edit['name'] = $user->name;        }        db_query("INSERT INTO {comments} (nid, pid, uid, subject, comment, format, hostname, timestamp, status, thread, name, mail, homepage) VALUES (%d, %d, %d, '%s', '%s', %d, '%s', %d, %d, '%s', '%s', '%s', '%s')", $edit['nid'], $edit['pid'], $edit['uid'], $edit['subject'], $edit['comment'], $edit['format'], ip_address(), $edit['timestamp'], $edit['status'], $thread, $edit['name'], $edit['mail'], $edit['homepage']);        $edit['cid'] = db_last_insert_id('comments', 'cid');        // Tell the other modules a new comment has been submitted.        comment_invoke_comment($edit, 'insert');        // Add an entry to the watchdog log.        watchdog('content', 'Comment: added %subject.', array('%subject' => $edit['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $edit['nid'], array('fragment' => 'comment-'. $edit['cid'])));      }      _comment_update_node_statistics($edit['nid']);      // Clear the cache so an anonymous user can see his comment being added.      cache_clear_all();      // Explain the approval queue if necessary, and then      // redirect the user to the node he's commenting on.      if ($edit['status'] == COMMENT_NOT_PUBLISHED) {        drupal_set_message(t('Your comment has been queued for moderation by site administrators and will be published after approval.'));      }      else {        comment_invoke_comment($edit, 'publish');      }      return $edit['cid'];    }    else {      return FALSE;    }  }  else {    watchdog('content', 'Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $edit['subject']), WATCHDOG_WARNING);    drupal_set_message(t('Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $edit['subject'])), 'error');    return FALSE;  }}/** * Build command links for a comment (e.g.\ edit, reply, delete) with respect to the current user's access permissions. * * @param $comment *   The comment to which the links will be related. * @param $return *   Not used. * @return *   An associative array containing the links. */function comment_links($comment, $return = 1) {  global $user;  $links = array();  // If we are viewing just this comment, we link back to the node.  if ($return) {    $links['comment_parent'] = array(      'title' => t('parent'),      'href' => comment_node_url(),      'fragment' => "comment-$comment->cid"    );  }  if (node_comment_mode($comment->nid) == COMMENT_NODE_READ_WRITE) {    if (user_access('administer comments') && user_access('post comments')) {      $links['comment_delete'] = array(        'title' => t('delete'),        'href' => "comment/delete/$comment->cid"      );      $links['comment_edit'] = array(        'title' => t('edit'),        'href' => "comment/edit/$comment->cid"      );      $links['comment_reply'] = array(        'title' => t('reply'),        'href' => "comment/reply/$comment->nid/$comment->cid"      );    }    else if (user_access('post comments')) {      if (comment_access('edit', $comment)) {        $links['comment_edit'] = array(          'title' => t('edit'),          'href' => "comment/edit/$comment->cid"        );      }      $links['comment_reply'] = array(        'title' => t('reply'),        'href' => "comment/reply/$comment->nid/$comment->cid"      );    }    else {      $node = node_load($comment->nid);      $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);    }  }  return $links;}/** * Renders comment(s). * * @param $node *   The node which comment(s) needs rendering. * @param $cid *   Optional, if given, only one comment is rendered. * * To display threaded comments in the correct order we keep a 'thread' field * and order by that value. This field keeps this data in * a way which is easy to update and convenient to use. * * A "thread" value starts at "1". If we add a child (A) to this comment, * we assign it a "thread" = "1.1". A child of (A) will have "1.1.1". Next * brother of (A) will get "1.2". Next brother of the parent of (A) will get * "2" and so on. * * First of all note that the thread field stores the depth of the comment: * depth 0 will be "X", depth 1 "X.X", depth 2 "X.X.X", etc. * * Now to get the ordering right, consider this example: * * 1 * 1.1 * 1.1.1 * 1.2 * 2 * * If we "ORDER BY thread ASC" we get the above result, and this is the * natural order sorted by time. However, if we "ORDER BY thread DESC" * we get: * * 2 * 1.2 * 1.1.1 * 1.1 * 1 * * Clearly, this is not a natural way to see a thread, and users will get * confused. The natural order to show a thread by time desc would be: * * 2 * 1 * 1.2 * 1.1 * 1.1.1 * * which is what we already did before the standard pager patch. To achieve * this we simply add a "/" at the end of each "thread" value. This way out * thread fields will look like depicted below: * * 1/ * 1.1/ * 1.1.1/ * 1.2/ * 2/ * * we add "/" since this char is, in ASCII, higher than every number, so if * now we "ORDER BY thread DESC" we get the correct order. However this would * spoil the reverse ordering, "ORDER BY thread ASC" -- here, we do not need * to consider the trailing "/" so we use a substring only. */function comment_render($node, $cid = 0) {  global $user;  $output = '';  if (user_access('access comments')) {    // Pre-process variables.    $nid = $node->nid;    if (empty($nid)) {      $nid = 0;    }    $mode = _comment_get_display_setting('mode', $node);    $order = _comment_get_display_setting('sort', $node);    $comments_per_page = _comment_get_display_setting('comments_per_page', $node);    if ($cid && is_numeric($cid)) {      // Single comment view.      $query = 'SELECT c.cid, c.pid, c.nid, c.subject, c.comment, c.format, c.timestamp, c.name, c.mail, c.homepage, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data, c.status FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d';      $query_args = array($cid);      if (!user_access('administer comments')) {        $query .= ' AND c.status = %d';        $query_args[] = COMMENT_PUBLISHED;      }      $query = db_rewrite_sql($query, 'c', 'cid');      $result = db_query($query, $query_args);      if ($comment = db_fetch_object($result)) {        $comment->name = $comment->uid ? $comment->registered_name : $comment->name;        $links = module_invoke_all('link', 'comment', $comment, 1);        drupal_alter('link', $links, $node);        $output .= theme('comment_view', $comment, $node, $links);      }    }    else {      // Multiple comment view      $query_count = 'SELECT COUNT(*) FROM {comments} c WHERE c.nid = %d';      $query = 'SELECT c.cid as cid, c.pid, c.nid, c.subject, c.comment, c.format, c.timestamp, c.name, c.mail, c.homepage, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data, c.thread, c.status FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.nid = %d';      $query_args = array($nid);      if (!user_access('administer comments')) {        $query .= ' AND c.status = %d';        $query_count .= ' AND c.status = %d';        $query_args[] = COMMENT_PUBLISHED;      }      if ($order == COMMENT_ORDER_NEWEST_FIRST) {        if ($mode == COMMENT_MODE_FLAT_COLLAPSED || $mode == COMMENT_MODE_FLAT_EXPANDED) {          $query .= ' ORDER BY c.cid DESC';        }        else {          $query .= ' ORDER BY c.thread DESC';        }      }      else if ($order == COMMENT_ORDER_OLDEST_FIRST) {        if ($mode == COMMENT_MODE_FLAT_COLLAPSED || $mode == COMMENT_MODE_FLAT_EXPANDED) {          $query .= ' ORDER BY c.cid';        }        else {          // See comment above. Analysis reveals that this doesn't cost too          // much. It scales much much better than having the whole comment          // structure.          $query .= ' ORDER BY SUBSTRING(c.thread, 1, (LENGTH(c.thread) - 1))';        }      }      $query = db_rewrite_sql($query, 'c', 'cid');      $query_count = db_rewrite_sql($query_count, 'c', 'cid');      // Start a form, for use with comment control.      $result = pager_query($query, $comments_per_page, 0, $query_count, $query_args);      $divs = 0;      $num_rows = FALSE;      $comments = '';      drupal_add_css(drupal_get_path('module', 'comment') .'/comment.css');      while ($comment = db_fetch_object($result)) {        $comment = drupal_unpack($comment);        $comment->name = $comment->uid ? $comment->registered_name : $comment->name;        $comment->depth = count(explode('.', $comment->thread)) - 1;        if ($mode == COMMENT_MODE_THREADED_COLLAPSED || $mode == COMMENT_MODE_THREADED_EXPANDED) {          if ($comment->depth > $divs) {            $divs++;            $comments .= '<div class="indented">';          }          else {            while ($comment->depth < $divs) {              $divs--;              $comments .= '</div>';            }          }        }        if ($mode == COMMENT_MODE_FLAT_COLLAPSED) {          $comments .= theme('comment_flat_collapsed', $comment, $node);        }        else if ($mode == COMMENT_MODE_FLAT_EXPANDED) {          $comments .= theme('comment_flat_expanded', $comment, $node);        }        else if ($mode == COMMENT_MODE_THREADED_COLLAPSED) {          $comments .= theme('comment_thread_collapsed', $comment, $node);        }        else if ($mode == COMMENT_MODE_THREADED_EXPANDED) {          $comments .= theme('comment_thread_expanded', $comment, $node);        }        $num_rows = TRUE;      }      while ($divs-- > 0) {        $comments .= '</div>';      }      $comment_controls = variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN);      if ($num_rows && ($comment_controls == COMMENT_CONTROLS_ABOVE || $comment_controls == COMMENT_CONTROLS_ABOVE_BELOW)) {        $output .= drupal_get_form('comment_controls', $mode, $order, $comments_per_page);      }      $output .= $comments;      $output .= theme('pager', NULL, $comments_per_page, 0);      if ($num_rows && ($comment_controls == COMMENT_CONTROLS_BELOW || $comment_controls == COMMENT_CONTROLS_ABOVE_BELOW)) {        $output .= drupal_get_form('comment_controls', $mode, $order, $comments_per_page);      }    }    // If enabled, show new comment form if it's not already being displayed.    $reply = arg(0) == 'comment' && arg(1) == 'reply';    if (user_access('post comments') && node_comment_mode($nid) == COMMENT_NODE_READ_WRITE && (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_BELOW) && !$reply) {      $output .= comment_form_box(array('nid' => $nid), t('Post new comment'));    }    if ($output) {      $output = theme('comment_wrapper', $output, $node);    }  }  return $output;}/** * Comment operations. We offer different update operations depending on * which comment administration page we're on. * * @param $action *   The comment administration page. * @return *   An associative array containing the offered operations. */function comment_operations($action = NULL) {  if ($action == 'publish') {    $operations = array(      'publish' => array(t('Publish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  else if ($action == 'unpublish') {    $operations = array(      'unpublish' => array(t('Unpublish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  else {    $operations = array(      'publish' => array(t('Publish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d'),      'unpublish' => array(t('Unpublish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  return $operations;}/** * Misc functions: helpers, privates, history *//** * Load the entire comment by cid. * * @param $cid *   The identifying comment id. * @return *   The comment object. */function _comment_load($cid) {  return db_fetch_object(db_query('SELECT * FROM {comments} WHERE cid = %d', $cid));}/** * Get comment count for a node. * * @param $nid *   The node id. * @return *   The comment count. */function comment_num_all($nid) {  static $cache;  if (!isset($cache[$nid])) {    $cache[$nid] = db_result(db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = %d', $nid));  }  return $cache[$nid];}/** * Get replies count for a comment. * * @param $pid *   The comment id. * @return *   The replies count. */function comment_num_replies($pid) {  static $cache;  if (!isset($cache[$pid])) {    $cache[$pid] = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE pid = %d AND status = %d', $pid, COMMENT_PUBLISHED));  }  return $cache[$pid];}/** * Get number of new comments for current user and specified node. * * @param $nid *   node-id to count comments for * @param $timestamp *   time to count from (defaults to time of last user access *   to node) */function comment_num_new($nid, $timestamp = 0) {  global $user;  if ($user->uid) {    // Retrieve the timestamp at which the current user last viewed the    // specified node.    if (!$timestamp) {      $timestamp = node_last_viewed($nid);    }    $timestamp = ($timestamp > NODE_NEW_LIMIT ? $timestamp : NODE_NEW_LIMIT);    // Use the timestamp to retrieve the number of new comments.    $result = db_result(db_query('SELECT COUNT(c.cid) FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid WHERE n.nid = %d AND timestamp > %d AND c.status = %d', $nid, $timestamp, COMMENT_PUBLISHED));    return $result;  }  else {    return 0;  }}/** * Validate comment data. * * @param $edit *   An associative array containig the comment data. * @return *   The original $edit. */function comment_validate($edit) {  global $user;  // Invoke other validation handlers  comment_invoke_comment($edit, 'validate');  if (isset($edit['date'])) {    // As of PHP 5.1.0, strtotime returns FALSE upon failure instead of -1.    if (strtotime($edit['date']) <= 0) {      form_set_error('date', t('You have to specify a valid date.'));    }  }  if (isset($edit['author']) && !$account = user_load(array('name' => $edit['author']))) {    form_set_error('author', t('You have to specify a valid author.'));  }  // Check validity of name, mail and homepage (if given)  if (!$user->uid || isset($edit['is_anonymous'])) {    $node = node_load($edit['nid']);    if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) > COMMENT_ANONYMOUS_MAYNOT_CONTACT) {      if ($edit['name']) {        $taken = db_result(db_query("SELECT COUNT(uid) FROM {users} WHERE LOWER(name) = '%s'", $edit['name']));        if ($taken != 0) {          form_set_error('name', t('The name you used belongs to a registered user.'));        }      }      else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {        form_set_error('name', t('You have to leave your name.'));      }      if ($edit['mail']) {        if (!valid_email_address($edit['mail'])) {          form_set_error('mail', t('The e-mail address you specified is not valid.'));        }      }      else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {        form_set_error('mail', t('You have to leave an e-mail address.'));      }      if ($edit['homepage']) {        if (!valid_url($edit['homepage'], TRUE)) {          form_set_error('homepage', t('The URL of your homepage is not valid. Remember that it must be fully qualified, i.e. of the form <code>http://example.com/directory</code>.'));        }      }    }  }  return $edit;}/** * Generate the basic commenting form, for appending to a node or display on a separate page. * * @param $title *   Not used. * @ingroup forms * @see comment_form_validate() * @see comment_form_submit() */function comment_form(&$form_state, $edit, $title = NULL) {  global $user;  $op = isset($_POST['op']) ? $_POST['op'] : '';  $node = node_load($edit['nid']);  if (!$user->uid && variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) != COMMENT_ANONYMOUS_MAYNOT_CONTACT) {    drupal_add_js(drupal_get_path('module', 'comment') .'/comment.js');  }  $edit += array('name' => '', 'mail' => '', 'homepage' => '');  if ($user->uid) {    if (!empty($edit['cid']) && user_access('administer comments')) {      if (!empty($edit['author'])) {        $author = $edit['author'];      }      elseif (!empty($edit['name'])) {        $author = $edit['name'];      }      else {        $author = $edit['registered_name'];      }      if (!empty($edit['status'])) {        $status = $edit['status'];      }      else {        $status = 0;      }      if (!empty($edit['date'])) {        $date = $edit['date'];      }      else {        $date = format_date($edit['timestamp'], 'custom', 'Y-m-d H:i O');      }      $form['admin'] = array(        '#type' => 'fieldset',        '#title' => t('Administration'),        '#collapsible' => TRUE,        '#collapsed' => TRUE,        '#weight' => -2,      );      if ($edit['registered_name'] != '') {        // The comment is by a registered user        $form['admin']['author'] = array(          '#type' => 'textfield',          '#title' => t('Authored by'),          '#size' => 30,          '#maxlength' => 60,          '#autocomplete_path' => 'user/autocomplete',          '#default_value' => $author,          '#weight' => -1,        );      }      else {        // The comment is by an anonymous user        $form['is_anonymous'] = array(          '#type' => 'value',          '#value' => TRUE,        );        $form['admin']['name'] = array(          '#type' => 'textfield',          '#title' => t('Authored by'),          '#size' => 30,          '#maxlength' => 60,          '#default_value' => $author,          '#weight' => -1,        );        $form['admin']['mail'] = array(          '#type' => 'textfield',          '#title' => t('E-mail'),          '#maxlength' => 64,          '#size' => 30,          '#default_value' => $edit['mail'],          '#description' => t('The content of this field is kept private and will not be shown publicly.'),        );        $form['admin']['homepage'] = array(          '#type' => 'textfield',          '#title' => t('Homepage'),          '#maxlength' => 255,          '#size' => 30,          '#default_value' => $edit['homepage'],        );      }      $form['admin']['date'] = array('#type' => 'textfield', '#parents' => array('date'), '#title' => t('Authored on'), '#size' => 20, '#maxlength' => 25, '#default_value' => $date, '#weight' => -1);      $form['admin']['status'] = array('#type' => 'radios', '#parents' => array('status'), '#title' => t('Status'), '#default_value' =>  $status, '#options' => array(t('Published'), t('Not published')), '#weight' => -1);    }    else {      $form['_author'] = array('#type' => 'item', '#title' => t('Your name'), '#value' => theme('username', $user)      );      $form['author'] = array('#type' => 'value', '#value' => $user->name);    }  }  else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MAY_CONTACT) {    $form['name'] = array('#type' => 'textfield', '#title' => t('Your name'), '#maxlength' => 60, '#size' => 30, '#default_value' => $edit['name'] ? $edit['name'] : variable_get('anonymous', t('Anonymous'))    );    $form['mail'] = array('#type' => 'textfield', '#title' => t('E-mail'), '#maxlength' => 64, '#size' => 30, '#default_value' => $edit['mail'], '#description' => t('The content of this field is kept private and will not be shown publicly.')    );    $form['homepage'] = array('#type' => 'textfield', '#title' => t('Homepage'), '#maxlength' => 255, '#size' => 30, '#default_value' => $edit['homepage']);  }  else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {    $form['name'] = array('#type' => 'textfield', '#title' => t('Your name'), '#maxlength' => 60, '#size' => 30, '#default_value' => $edit['name'] ? $edit['name'] : variable_get('anonymous', t('Anonymous')), '#required' => TRUE);    $form['mail'] = array('#type' => 'textfield', '#title' => t('E-mail'), '#maxlength' => 64, '#size' => 30, '#default_value' => $edit['mail'], '#description' => t('The content of this field is kept private and will not be shown publicly.'), '#required' => TRUE);    $form['homepage'] = array('#type' => 'textfield', '#title' => t('Homepage'), '#maxlength' => 255, '#size' => 30, '#default_value' => $edit['homepage']);  }  if (variable_get('comment_subject_field_'. $node->type, 1) == 1) {    $form['subject'] = array('#type' => 'textfield', '#title' => t('Subject'), '#maxlength' => 64, '#default_value' => !empty($edit['subject']) ? $edit['subject'] : '');  }  if (!empty($edit['comment'])) {    $default = $edit['comment'];  }  else {    $default = '';  }  $form['comment_filter']['comment'] = array(    '#type' => 'textarea',    '#title' => t('Comment'),    '#rows' => 15,    '#default_value' => $default,    '#required' => TRUE,  );  if (!isset($edit['format'])) {    $edit['format'] = FILTER_FORMAT_DEFAULT;  }  $form['comment_filter']['format'] = filter_form($edit['format']);  $form['cid'] = array('#type' => 'value', '#value' => !empty($edit['cid']) ? $edit['cid'] : NULL);  $form['pid'] = array('#type' => 'value', '#value' => !empty($edit['pid']) ? $edit['pid'] : NULL);  $form['nid'] = array('#type' => 'value', '#value' => $edit['nid']);  $form['uid'] = array('#type' => 'value', '#value' => !empty($edit['uid']) ? $edit['uid'] : 0);  // Only show save button if preview is optional or if we are in preview mode.  // We show the save button in preview mode even if there are form errors so that  // optional form elements (e.g., captcha) can be updated in preview mode.  if (!form_get_errors() && ((variable_get('comment_preview_'. $node->type, COMMENT_PREVIEW_REQUIRED) == COMMENT_PREVIEW_OPTIONAL) || ($op == t('Preview')) || ($op == t('Save')))) {    $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 19);  }  $form['preview'] = array('#type' => 'button', '#value' => t('Preview'), '#weight' => 20);  $form['#token'] = 'comment'. $edit['nid'] . (isset($edit['pid']) ? $edit['pid'] : '');  if ($op == t('Preview')) {    $form['#after_build'] = array('comment_form_add_preview');  }  if (empty($edit['cid']) && empty($edit['pid'])) {    $form['#action'] = url('comment/reply/'. $edit['nid']);  }  return $form;}/** * Theme the comment form box. * * @param $edit *   The form structure. * @param $title *   The form title. */function comment_form_box($edit, $title = NULL) {  return theme('box', $title, drupal_get_form('comment_form', $edit, $title));}/** * Form builder; Generate and validate a comment preview form. * * @ingroup forms */function comment_form_add_preview($form, &$form_state) {  global $user;  $edit = $form_state['values'];  drupal_set_title(t('Preview comment'));  $output = '';  $node = node_load($edit['nid']);  // Invoke full validation for the form, to protect against cross site  // request forgeries (CSRF) and setting arbitrary values for fields such as  // the input format. Preview the comment only when form validation does not  // set any errors.  drupal_validate_form($form['form_id']['#value'], $form, $form_state);  if (!form_get_errors()) {    _comment_form_submit($edit);    $comment = (object)$edit;    // Attach the user and time information.    if (!empty($edit['author'])) {      $account = user_load(array('name' => $edit['author']));    }    elseif ($user->uid && !isset($edit['is_anonymous'])) {      $account = $user;    }    if (!empty($account)) {      $comment->uid = $account->uid;      $comment->name = check_plain($account->name);    }    elseif (empty($comment->name)) {      $comment->name = variable_get('anonymous', t('Anonymous'));    }    $comment->timestamp = !empty($edit['timestamp']) ? $edit['timestamp'] : time();    $output .= theme('comment_view', $comment, $node);  }  $form['comment_preview'] = array(    '#value' => $output,    '#weight' => -100,    '#prefix' => '<div class="preview">',    '#suffix' => '</div>',  );  $output = '';  if ($edit['pid']) {    $comment = db_fetch_object(db_query('SELECT c.*, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status = %d', $edit['pid'], COMMENT_PUBLISHED));    $comment = drupal_unpack($comment);    $comment->name = $comment->uid ? $comment->registered_name : $comment->name;    $output .= theme('comment_view', $comment, $node);  }  else {    $suffix = empty($form['#suffix']) ? '' : $form['#suffix'];    $form['#suffix'] = $suffix . node_view($node);    $edit['pid'] = 0;  }  $form['comment_preview_below'] = array('#value' => $output, '#weight' => 100);  return $form;}/** * Validate comment form submissions. */function comment_form_validate($form, &$form_state) {  global $user;  if ($user->uid === 0) {    foreach (array('name', 'homepage', 'mail') as $field) {      // Set cookie for 365 days.      if (isset($form_state['values'][$field])) {        setcookie('comment_info_'. $field, $form_state['values'][$field], time() + 31536000, '/');      }    }  }  comment_validate($form_state['values']);}/** * Prepare a comment for submission. * * @param $comment_values *   An associative array containing the comment data. */function _comment_form_submit(&$comment_values) {  $comment_values += array('subject' => '');  if (!isset($comment_values['date'])) {    $comment_values['date'] = 'now';  }  $comment_values['timestamp'] = strtotime($comment_values['date']);  if (isset($comment_values['author'])) {    $account = user_load(array('name' => $comment_values['author']));    $comment_values['uid'] = $account->uid;    $comment_values['name'] = $comment_values['author'];  }  // Validate the comment's subject. If not specified, extract  // one from the comment's body.  if (trim($comment_values['subject']) == '') {    // The body may be in any format, so we:    // 1) Filter it into HTML    // 2) Strip out all HTML tags    // 3) Convert entities back to plain-text.    // Note: format is checked by check_markup().    $comment_values['subject'] = truncate_utf8(trim(decode_entities(strip_tags(check_markup($comment_values['comment'], $comment_values['format'])))), 29, TRUE);    // Edge cases where the comment body is populated only by HTML tags will    // require a default subject.    if ($comment_values['subject'] == '') {      $comment_values['subject'] = t('(No subject)');    }  }}/** * Process comment form submissions; prepare the comment, store it, and set a redirection target. */function comment_form_submit($form, &$form_state) {  _comment_form_submit($form_state['values']);  if ($cid = comment_save($form_state['values'])) {    $node = node_load($form_state['values']['nid']);    // Add 1 to existing $node->comment count to include new comment being added.    $comment_count = $node->comment_count + 1;    $page = comment_new_page_count($comment_count, 1, $node);    $form_state['redirect'] = array('node/'. $node->nid, $page, "comment-$cid");    return;  }}/** * Themes a single comment and related items. * * @param $comment *   The comment object. * @param $node *   The comment node. * @param $links *   An associative array containing control links suitable for passing into *   theme_links(). These are generated by modules implementing hook_link() with *   $type='comment'. Typical examples are links for editing and deleting *   comments. * @param $visible *   Switches between folded/unfolded view. If TRUE the comments are visible, if *   FALSE the comments are folded. * @ingroup themeable */function theme_comment_view($comment, $node, $links = array(), $visible = TRUE) {  static $first_new = TRUE;  $output = '';  $comment->new = node_mark($comment->nid, $comment->timestamp);  if ($first_new && $comment->new != MARK_READ) {    // Assign the anchor only for the first new comment. This avoids duplicate    // id attributes on a page.    $first_new = FALSE;    $output .= "<a id=\"new\"></a>\n";  }  $output .= "<a id=\"comment-$comment->cid\"></a>\n";  // Switch to folded/unfolded view of the comment  if ($visible) {    $comment->comment = check_markup($comment->comment, $comment->format, FALSE);    // Comment API hook    comment_invoke_comment($comment, 'view');    $output .= theme('comment', $comment, $node, $links);  }  else {    $output .= theme('comment_folded', $comment);  }  return $output;}/** * Build a comment control form. * * @param $mode *   Comment display mode. * @param $order *   Comment order mode. * @param $comments_per_page *   Comments per page. * @ingroup forms */function comment_controls(&$form_state, $mode = COMMENT_MODE_THREADED_EXPANDED, $order = COMMENT_ORDER_NEWEST_FIRST, $comments_per_page = 50) {  $form['mode'] = array('#type' => 'select',    '#default_value' => $mode,    '#options' => _comment_get_modes(),    '#weight' => 1,  );  $form['order'] = array(    '#type' => 'select',    '#default_value' => $order,    '#options' => _comment_get_orders(),    '#weight' => 2,  );  foreach (_comment_per_page() as $i) {    $options[$i] = t('!a comments per page', array('!a' => $i));  }  $form['comments_per_page'] = array('#type' => 'select',    '#default_value' => $comments_per_page,    '#options' => $options,    '#weight' => 3,  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Save settings'),    '#weight' => 20,  );  return $form;}/** * Theme comment controls box where the user can change the default display mode and display order of comments. * * @param $form *   The form structure. * @ingroup themeable */function theme_comment_controls($form) {  $output = '<div class="container-inline">';  $output .=  drupal_render($form);  $output .= '</div>';  $output .= '<div class="description">'. t('Select your preferred way to display the comments and click "Save settings" to activate your changes.') .'</div>';  return theme('box', t('Comment viewing options'), $output);}/** * Process comment_controls form submissions. */function comment_controls_submit($form, &$form_state) {  global $user;  $mode = $form_state['values']['mode'];  $order = $form_state['values']['order'];  $comments_per_page = $form_state['values']['comments_per_page'];  if ($user->uid) {    $account = user_save($user, array('mode' => $mode, 'sort' => $order, 'comments_per_page' => $comments_per_page));    // Terminate if an error occured during user_save().    if (!$account) {      drupal_set_message(t("Error saving user account."), 'error');      return;    }    $user = $account;  }  else {    $_SESSION['comment_mode'] = $mode;    $_SESSION['comment_sort'] = $order;    $_SESSION['comment_comments_per_page'] = $comments_per_page;  }}/** * Process variables for comment.tpl.php. * * @see comment.tpl.php * @see theme_comment() */function template_preprocess_comment(&$variables) {  $comment = $variables['comment'];  $node = $variables['node'];  $variables['author']    = theme('username', $comment);  $variables['content']   = $comment->comment;  $variables['date']      = format_date($comment->timestamp);  $variables['links']     = isset($variables['links']) ? theme('links', $variables['links']) : '';  $variables['new']       = $comment->new ? t('new') : '';  $variables['picture']   = theme_get_setting('toggle_comment_user_picture') ? theme('user_picture', $comment) : '';  $variables['signature'] = $comment->signature;  $variables['submitted'] = theme('comment_submitted', $comment);  $variables['title']     = l($comment->subject, $_GET['q'], array('fragment' => "comment-$comment->cid"));  $variables['template_files'][] = 'comment-'. $node->type;  // set status to a string representation of comment->status.  if (isset($comment->preview)) {    $variables['status']  = 'comment-preview';  }  else {    $variables['status']  = ($comment->status == COMMENT_NOT_PUBLISHED) ? 'comment-unpublished' : 'comment-published';  }}/** * Process variables for comment-folded.tpl.php. * * @see comment-folded.tpl.php * @see theme_comment_folded() */function template_preprocess_comment_folded(&$variables) {  $comment = $variables['comment'];  $variables['author'] = theme('username', $comment);  $variables['date']   = format_date($comment->timestamp);  $variables['new']    = $comment->new ? t('new') : '';  $variables['title']  = l($comment->subject, comment_node_url() .'/'. $comment->cid, array('fragment' => "comment-$comment->cid"));}/** * Theme comment flat collapsed view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_flat_collapsed($comment, $node) {  return theme('comment_view', $comment, $node, '', 0);}/** * Theme comment flat expanded view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_flat_expanded($comment, $node) {  $links = module_invoke_all('link', 'comment', $comment, 0);  drupal_alter('link', $links, $node);  return theme('comment_view', $comment, $node, $links);}/** * Theme comment thread collapsed view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_thread_collapsed($comment, $node) {  return theme('comment_view', $comment, $node, '', 0);}/** * Theme comment thread expanded view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_thread_expanded($comment, $node) {  $links = module_invoke_all('link', 'comment', $comment, 0);  drupal_alter('link', $links, $node);  return theme('comment_view', $comment, $node, $links);}/** * Theme a "you can't post comments" notice. * * @param $node *   The comment node. * @ingroup themeable */function theme_comment_post_forbidden($node) {  global $user;  static $authenticated_post_comments;  if (!$user->uid) {    if (!isset($authenticated_post_comments)) {      // We only output any link if we are certain, that users get permission      // to post comments by logging in. We also locally cache this information.      $authenticated_post_comments = array_key_exists(DRUPAL_AUTHENTICATED_RID, user_roles(TRUE, 'post comments') + user_roles(TRUE, 'post comments without approval'));    }    if ($authenticated_post_comments) {      // We cannot use drupal_get_destination() because these links      // sometimes appear on /node and taxonomy listing pages.      if (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_SEPARATE_PAGE) {        $destination = 'destination='. rawurlencode("comment/reply/$node->nid#comment-form");      }      else {        $destination = 'destination='. rawurlencode("node/$node->nid#comment-form");      }      if (variable_get('user_register', 1)) {        // Users can register themselves.        return t('<a href="@login">Login</a> or <a href="@register">register</a> to post comments', array('@login' => url('user/login', array('query' => $destination)), '@register' => url('user/register', array('query' => $destination))));      }      else {        // Only admins can add new users, no public registration.        return t('<a href="@login">Login</a> to post comments', array('@login' => url('user/login', array('query' => $destination))));      }    }  }}/** * Process variables for comment-wrapper.tpl.php. * * @see comment-wrapper.tpl.php * @see theme_comment_wrapper() */function template_preprocess_comment_wrapper(&$variables) {  // Provide contextual information.  $variables['display_mode']  = _comment_get_display_setting('mode', $variables['node']);  $variables['display_order'] = _comment_get_display_setting('sort', $variables['node']);  $variables['comment_controls_state'] = variable_get('comment_controls_'. $variables['node']->type, COMMENT_CONTROLS_HIDDEN);  $variables['template_files'][] = 'comment-wrapper-'. $variables['node']->type;}/** * Theme a "Submitted by ..." notice. * * @param $comment *   The comment. * @ingroup themeable */function theme_comment_submitted($comment) {  return t('Submitted by !username on @datetime.',    array(      '!username' => theme('username', $comment),      '@datetime' => format_date($comment->timestamp)    ));}/** * Return an array of viewing modes for comment listings. * * We can't use a global variable array because the locale system * is not initialized yet when the comment module is loaded. */function _comment_get_modes() {  return array(    COMMENT_MODE_FLAT_COLLAPSED => t('Flat list - collapsed'),    COMMENT_MODE_FLAT_EXPANDED => t('Flat list - expanded'),    COMMENT_MODE_THREADED_COLLAPSED => t('Threaded list - collapsed'),    COMMENT_MODE_THREADED_EXPANDED => t('Threaded list - expanded')  );}/** * Return an array of viewing orders for comment listings. * * We can't use a global variable array because the locale system * is not initialized yet when the comment module is loaded. */function _comment_get_orders() {  return array(    COMMENT_ORDER_NEWEST_FIRST => t('Date - newest first'),    COMMENT_ORDER_OLDEST_FIRST => t('Date - oldest first')  );}/** * Return an array of "comments per page" settings from which the user * can choose. */function _comment_per_page() {  return drupal_map_assoc(array(10, 30, 50, 70, 90, 150, 200, 250, 300));}/** * Return a current comment display setting * * @param $setting *   can be one of these: 'mode', 'sort', 'comments_per_page' * @param $node *   The comment node in question. */function _comment_get_display_setting($setting, $node) {  global $user;  if (isset($_GET[$setting])) {    $value = $_GET[$setting];  }  else {    // get the setting's site default    switch ($setting) {      case 'mode':        $default = variable_get('comment_default_mode_'. $node->type, COMMENT_MODE_THREADED_EXPANDED);        break;      case 'sort':        $default = variable_get('comment_default_order_'. $node->type, COMMENT_ORDER_NEWEST_FIRST);        break;      case 'comments_per_page':        $default = variable_get('comment_default_per_page_'. $node->type, 50);    }    if (variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN) == COMMENT_CONTROLS_HIDDEN) {      // if comment controls are disabled use site default      $value = $default;    }    else {      // otherwise use the user's setting if set      if (isset($user->$setting) && $user->$setting) {        $value = $user->$setting;      }      else if (isset($_SESSION['comment_'. $setting]) && $_SESSION['comment_'. $setting]) {        $value = $_SESSION['comment_'. $setting];      }      else {        $value = $default;      }    }  }  return $value;}/** * Updates the comment statistics for a given node. This should be called any * time a comment is added, deleted, or updated. * * The following fields are contained in the node_comment_statistics table. * - last_comment_timestamp: the timestamp of the last comment for this node or the node create stamp if no comments exist for the node. * - last_comment_name: the name of the anonymous poster for the last comment * - last_comment_uid: the uid of the poster for the last comment for this node or the node authors uid if no comments exists for the node. * - comment_count: the total number of approved/published comments on this node. */function _comment_update_node_statistics($nid) {  $count = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE nid = %d AND status = %d', $nid, COMMENT_PUBLISHED));  // comments exist  if ($count > 0) {    $last_reply = db_fetch_object(db_query_range('SELECT cid, name, timestamp, uid FROM {comments} WHERE nid = %d AND status = %d ORDER BY cid DESC', $nid, COMMENT_PUBLISHED, 0, 1));    db_query("UPDATE {node_comment_statistics} SET comment_count = %d, last_comment_timestamp = %d, last_comment_name = '%s', last_comment_uid = %d WHERE nid = %d", $count, $last_reply->timestamp, $last_reply->uid ? '' : $last_reply->name, $last_reply->uid, $nid);  }  // no comments  else {    $node = db_fetch_object(db_query("SELECT uid, created FROM {node} WHERE nid = %d", $nid));    db_query("UPDATE {node_comment_statistics} SET comment_count = 0, last_comment_timestamp = %d, last_comment_name = '', last_comment_uid = %d WHERE nid = %d", $node->created, $node->uid, $nid);  }}/** * Invoke a hook_comment() operation in all modules. * * @param &$comment *   A comment object. * @param $op *   A string containing the name of the comment operation. * @return *   The returned value of the invoked hooks. */function comment_invoke_comment(&$comment, $op) {  $return = array();  foreach (module_implements('comment') as $name) {    $function = $name .'_comment';    $result = $function($comment, $op);    if (isset($result) && is_array($result)) {      $return = array_merge($return, $result);    }    else if (isset($result)) {      $return[] = $result;    }  }  return $return;}/** * Generate vancode. * * Consists of a leading character indicating length, followed by N digits * with a numerical value in base 36. Vancodes can be sorted as strings * without messing up numerical order. * * It goes: * 00, 01, 02, ..., 0y, 0z, * 110, 111, ... , 1zy, 1zz, * 2100, 2101, ..., 2zzy, 2zzz, * 31000, 31001, ... */function int2vancode($i = 0) {  $num = base_convert((int)$i, 10, 36);  $length = strlen($num);  return chr($length + ord('0') - 1) . $num;}/** * Decode vancode back to an integer. */function vancode2int($c = '00') {  return base_convert(substr($c, 1), 36, 10);}/** * Implementation of hook_hook_info(). */function comment_hook_info() {  return array(    'comment' => array(      'comment' => array(        'insert' => array(          'runs when' => t('After saving a new comment'),        ),        'update' => array(          'runs when' => t('After saving an updated comment'),        ),        'delete' => array(          'runs when' => t('After deleting a comment')        ),        'view' => array(          'runs when' => t('When a comment is being viewed by an authenticated user')        ),      ),    ),  );}/** * Implementation of hook_action_info(). */function comment_action_info() {  return array(    'comment_unpublish_action' => array(      'description' => t('Unpublish comment'),      'type' => 'comment',      'configurable' => FALSE,      'hooks' => array(        'comment' => array('insert', 'update'),      )    ),    'comment_unpublish_by_keyword_action' => array(      'description' => t('Unpublish comment containing keyword(s)'),      'type' => 'comment',      'configurable' => TRUE,      'hooks' => array(        'comment' => array('insert', 'update'),      )    )  );}/** * Drupal action to unpublish a comment. * * @param $context *   Keyed array. Must contain the id of the comment if $comment is not passed. * @param $comment *   An optional comment object. */function comment_unpublish_action($comment, $context = array()) {  if (isset($comment->cid)) {    $cid = $comment->cid;    $subject = $comment->subject;  }  else {    $cid = $context['cid'];    $subject = db_result(db_query("SELECT subject FROM {comments} WHERE cid = %d", $cid));  }  db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_NOT_PUBLISHED, $cid);  watchdog('action', 'Unpublished comment %subject.', array('%subject' => $subject));}/** * Form builder; Prepare a form for blacklisted keywords. * * @ingroup forms */function comment_unpublish_by_keyword_action_form($context) {  $form['keywords'] = array(    '#title' => t('Keywords'),    '#type' => 'textarea',    '#description' => t('The comment will be unpublished if it contains any of the character sequences above. Use a comma-separated list of character sequences. Example: funny, bungee jumping, "Company, Inc.". Character sequences are case-sensitive.'),    '#default_value' => isset($context['keywords']) ? drupal_implode_tags($context['keywords']) : '',  );  return $form;}/** * Process comment_unpublish_by_keyword_action_form form submissions. */function comment_unpublish_by_keyword_action_submit($form, $form_state) {  return array('keywords' => drupal_explode_tags($form_state['values']['keywords']));}/** * Implementation of a configurable Drupal action. * Unpublish a comment if it contains a certain string. * * @param $context *   An array providing more information about the context of the call to this action. *   Unused here since this action currently only supports the insert and update ops of *   the comment hook, both of which provide a complete $comment object. * @param $comment *   A comment object. */function comment_unpublish_by_keyword_action($comment, $context) {  foreach ($context['keywords'] as $keyword) {    if (strstr($comment->comment, $keyword) || strstr($comment->subject, $keyword)) {      db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_NOT_PUBLISHED, $comment->cid);      watchdog('action', 'Unpublished comment %subject.', array('%subject' => $comment->subject));      break;    }  }}
<?php// $Id$/** * @file * Content type editing UI. *//** * Displays the content type admin overview page. */function node_overview_types() {  $types = node_get_types();  $names = node_get_types('names');  $header = array(t('Name'), t('Type'), t('Description'), array('data' => t('Operations'), 'colspan' => '2'));  $rows = array();  foreach ($names as $key => $name) {    $type = $types[$key];    if (node_hook($type, 'form')) {      $type_url_str = str_replace('_', '-', $type->type);      $row = array(        l($name, 'admin/content/node-type/'. $type_url_str),        check_plain($type->type),        filter_xss_admin($type->description),      );      // Set the edit column.      $row[] = array('data' => l(t('edit'), 'admin/content/node-type/'. $type_url_str));      // Set the delete column.      if ($type->custom) {        $row[] = array('data' => l(t('delete'), 'admin/content/node-type/'. $type_url_str .'/delete'));      }      else {        $row[] = array('data' => '');      }      $rows[] = $row;    }  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No content types available.'), 'colspan' => '5', 'class' => 'message'));  }  return theme('table', $header, $rows);}/** * Generates the node type editing form. */function node_type_form(&$form_state, $type = NULL) {  if (!isset($type->type)) {    $type = new stdClass();    $type->type = $type->name = $type->module = $type->description = $type->help = '';    $type->min_word_count = 0;    $type->has_title = TRUE;    $type->has_body = TRUE;    $type->title_label = t('Title');    $type->body_label = t('Body');    $type->custom = TRUE;    $type->modified = FALSE;    $type->locked = FALSE;  }  $form['#node_type'] = $type; // Make the type object available to implementations of hook_form_alter.  $form['identity'] = array(    '#type' => 'fieldset',    '#title' => t('Identification'),  );  $form['identity']['name'] = array(    '#title' => t('Name'),    '#type' => 'textfield',    '#default_value' => $type->name,    '#description' => t('The human-readable name of this content type. This text will be displayed as part of the list on the <em>create content</em> page. It is recommended that this name begin with a capital letter and contain only letters, numbers, and <strong>spaces</strong>. This name must be unique.'),    '#required' => TRUE,  );  if (!$type->locked) {    $form['identity']['type'] = array(      '#title' => t('Type'),      '#type' => 'textfield',      '#default_value' => $type->type,      '#maxlength' => 32,      '#required' => TRUE,      '#description' => t('The machine-readable name of this content type. This text will be used for constructing the URL of the <em>create content</em> page for this content type. This name must contain only lowercase letters, numbers, and underscores. Underscores will be converted into hyphens when constructing the URL of the <em>create content</em> page. This name must be unique.'),    );  }  else {    $form['identity']['type'] = array(      '#type' => 'value',      '#value' => $type->type,    );    $form['identity']['type_display'] = array(      '#title' => t('Type'),      '#type' => 'item',      '#value' => theme('placeholder', $type->type),      '#description' => t('The machine-readable name of this content type. This field cannot be modified for system-defined content types.'),    );  }  $form['identity']['description'] = array(    '#title' => t('Description'),    '#type' => 'textarea',    '#default_value' => $type->description,    '#description' => t('A brief description of this content type. This text will be displayed as part of the list on the <em>create content</em> page.'),    );  $form['submission'] = array(    '#type' => 'fieldset',    '#title' => t('Submission form settings'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,  );  $form['submission']['title_label'] = array(    '#title' => t('Title field label'),    '#type' => 'textfield',    '#default_value' => $type->title_label,    '#required' => TRUE,  );  if (!$type->has_title) {    // Avoid overwriting a content type that intentionally does not have a    // title field.    $form['submission']['title_label']['#attributes'] = array('disabled' => 'disabled');    $form['submission']['title_label']['#description'] = t('This content type does not have a title field.');    $form['submission']['title_label']['#required'] = FALSE;  }  $form['submission']['body_label'] = array(    '#title' => t('Body field label'),    '#type' => 'textfield',    '#default_value' => isset($type->body_label) ? $type->body_label : '',    '#description' => t('To omit the body field for this content type, remove any text and leave this field blank.'),  );  $form['submission']['min_word_count'] = array(    '#type' => 'select',    '#title' => t('Minimum number of words'),    '#default_value' => $type->min_word_count,    '#options' => drupal_map_assoc(array(0, 1, 10, 25, 50, 75, 100, 125, 150, 175, 200)),    '#description' => t('The minimum number of words for the body field to be considered valid for this content type. This can be useful to rule out submissions that do not meet the site\'s standards, such as short test posts.')  );  $form['submission']['help']  = array(    '#type' => 'textarea',    '#title' => t('Explanation or submission guidelines'),    '#default_value' => $type->help,    '#description' => t('This text will be displayed at the top of the submission form for this content type. It is useful for helping or instructing your users.')  );  $form['workflow'] = array(    '#type' => 'fieldset',    '#title' => t('Workflow settings'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,  );  $form['workflow']['node_options'] = array('#type' => 'checkboxes',    '#title' => t('Default options'),    '#default_value' => variable_get('node_options_'. $type->type, array('status', 'promote')),    '#options' => array(      'status' => t('Published'),      'promote' => t('Promoted to front page'),      'sticky' => t('Sticky at top of lists'),      'revision' => t('Create new revision'),    ),    '#description' => t('Users with the <em>administer nodes</em> permission will be able to override these options.'),  );  $form['old_type'] = array(    '#type' => 'value',    '#value' => $type->type,  );  $form['orig_type'] = array(    '#type' => 'value',    '#value' => isset($type->orig_type) ? $type->orig_type : '',  );  $form['module'] = array(    '#type' => 'value',    '#value' => $type->module,  );  $form['custom'] = array(    '#type' => 'value',    '#value' => $type->custom,  );  $form['modified'] = array(    '#type' => 'value',    '#value' => $type->modified,  );  $form['locked'] = array(    '#type' => 'value',    '#value' => $type->locked,  );  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Save content type'),    '#weight' => 40,  );  if ($type->custom) {    if (!empty($type->type)) {      $form['delete'] = array(        '#type' => 'submit',        '#value' => t('Delete content type'),        '#weight' => 45,      );    }  }  else {    $form['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset to defaults'),      '#weight' => 50,    );  }  return $form;}/** * Validates the content type submission form generated by node_type_form(). */function node_type_form_validate($form, &$form_state) {  $type = new stdClass();  $type->type = trim($form_state['values']['type']);  $type->name = trim($form_state['values']['name']);  // Work out what the type was before the user submitted this form  $old_type = trim($form_state['values']['old_type']);  $types = node_get_types('names');  if (!$form_state['values']['locked']) {    if (isset($types[$type->type]) && $type->type != $old_type) {      form_set_error('type', t('The machine-readable name %type is already taken.', array('%type' => $type->type)));    }    if (!preg_match('!^[a-z0-9_]+$!', $type->type)) {      form_set_error('type', t('The machine-readable name must contain only lowercase letters, numbers, and underscores.'));    }    // 'theme' conflicts with theme_node_form().    // '0' is invalid, since elsewhere we check it using empty().    if (in_array($type->type, array('0', 'theme'))) {      form_set_error('type', t("Invalid machine-readable name. Please enter a name other than %invalid.", array('%invalid' => $type->type)));    }  }  $names = array_flip($types);  if (isset($names[$type->name]) && $names[$type->name] != $old_type) {    form_set_error('name', t('The human-readable name %name is already taken.', array('%name' => $type->name)));  }}/** * Implementation of hook_form_submit(). */function node_type_form_submit($form, &$form_state) {  $op = isset($form_state['values']['op']) ? $form_state['values']['op'] : '';  $type = new stdClass();  $type->type = trim($form_state['values']['type']);  $type->name = trim($form_state['values']['name']);  $type->orig_type = trim($form_state['values']['orig_type']);  $type->old_type = isset($form_state['values']['old_type']) ? $form_state['values']['old_type'] : $type->type;  $type->description = $form_state['values']['description'];  $type->help = $form_state['values']['help'];  $type->min_word_count = $form_state['values']['min_word_count'];  $type->title_label = $form_state['values']['title_label'];  $type->body_label = $form_state['values']['body_label'];  // title_label is required in core; has_title will always be true, unless a  // module alters the title field.  $type->has_title = ($type->title_label != '');  $type->has_body = ($type->body_label != '');  $type->module = !empty($form_state['values']['module']) ? $form_state['values']['module'] : 'node';  $type->custom = $form_state['values']['custom'];  $type->modified = TRUE;  $type->locked = $form_state['values']['locked'];  if ($op == t('Reset to defaults')) {    node_type_reset($type);  }  elseif ($op == t('Delete content type')) {    $form_state['redirect'] = 'admin/content/node-type/'. str_replace('_', '-', $type->old_type) .'/delete';    return;  }  $status = node_type_save($type);  $variables = $form_state['values'];  // Remove everything that's been saved already - whatever's left is assumed  // to be a persistent variable.  foreach ($variables as $key => $value) {    if (isset($type->$key)) {      unset($variables[$key]);    }  }  unset($variables['form_token'], $variables['op'], $variables['submit'], $variables['delete'], $variables['reset'], $variables['form_id']);  // Save or reset persistent variable values.  foreach ($variables as $key => $value) {    $variable_new = $key .'_'. $type->type;    $variable_old = $key .'_'. $type->old_type;    if ($op == t('Reset to defaults')) {      variable_del($variable_old);    }    else {      if (is_array($value)) {        $value = array_keys(array_filter($value));      }      variable_set($variable_new, $value);      if ($variable_new != $variable_old) {        variable_del($variable_old);      }    }  }  node_types_rebuild();  menu_rebuild();  $t_args = array('%name' => $type->name);  if ($op == t('Reset to defaults')) {    drupal_set_message(t('The content type %name has been reset to its default values.', $t_args));    return;  }  if ($status == SAVED_UPDATED) {    drupal_set_message(t('The content type %name has been updated.', $t_args));  }  elseif ($status == SAVED_NEW) {    drupal_set_message(t('The content type %name has been added.', $t_args));    watchdog('node', 'Added content type %name.', $t_args, WATCHDOG_NOTICE, l(t('view'), 'admin/content/types'));  }  $form_state['redirect'] = 'admin/content/types';  return;}/** * Implementation of hook_node_type(). */function node_node_type($op, $info) {  if ($op != 'delete' && !empty($info->old_type) && $info->old_type != $info->type) {    $update_count = node_type_update_nodes($info->old_type, $info->type);    if ($update_count) {      drupal_set_message(format_plural($update_count, 'Changed the content type of 1 post from %old-type to %type.', 'Changed the content type of @count posts from %old-type to %type.', array('%old-type' => $info->old_type, '%type' => $info->type)));    }  }}/** * Resets all of the relevant fields of a module-defined node type to their * default values. * * @param &$type *   The node type to reset. The node type is passed back by reference with its *   resetted values. If there is no module-defined info for this node type, *   then nothing happens. */function node_type_reset(&$type) {  $info_array = module_invoke_all('node_info');  if (isset($info_array[$type->orig_type])) {    $info_array[$type->orig_type]['type'] = $type->orig_type;     $info = _node_type_set_defaults($info_array[$type->orig_type]);    foreach ($info as $field => $value) {      $type->$field = $value;    }  }}/** * Menu callback; delete a single content type. */function node_type_delete_confirm(&$form_state, $type) {  $form['type'] = array('#type' => 'value', '#value' => $type->type);  $form['name'] = array('#type' => 'value', '#value' => $type->name);  $message = t('Are you sure you want to delete the content type %type?', array('%type' => $type->name));  $caption = '';  $num_nodes = db_result(db_query("SELECT COUNT(*) FROM {node} WHERE type = '%s'", $type->type));  if ($num_nodes) {    $caption .= '<p>'. format_plural($num_nodes, '<strong>Warning:</strong> there is currently 1 %type post on your site. It may not be able to be displayed or edited correctly, once you have removed this content type.', '<strong>Warning:</strong> there are currently @count %type posts on your site. They may not be able to be displayed or edited correctly, once you have removed this content type.', array('%type' => $type->name)) .'</p>';  }  $caption .= '<p>'. t('This action cannot be undone.') .'</p>';  return confirm_form($form, $message, 'admin/content/types', $caption, t('Delete'));}/** * Process content type delete confirm submissions. */function node_type_delete_confirm_submit($form, &$form_state) {  node_type_delete($form_state['values']['type']);  $t_args = array('%name' => $form_state['values']['name']);  drupal_set_message(t('The content type %name has been deleted.', $t_args));  watchdog('menu', 'Deleted content type %name.', $t_args, WATCHDOG_NOTICE);  node_types_rebuild();  menu_rebuild();  $form_state['redirect'] = 'admin/content/types';  return;}
<?php// $Id$/** * @file * Enables the user registration and login system. */define('USERNAME_MAX_LENGTH', 60);define('EMAIL_MAX_LENGTH', 64);/** * Invokes hook_user() in every module. * * We cannot use module_invoke() for this, because the arguments need to * be passed by reference. */function user_module_invoke($type, &$array, &$user, $category = NULL) {  foreach (module_list() as $module) {    $function = $module .'_user';    if (function_exists($function)) {      $function($type, $array, $user, $category);    }  }}/** * Implementation of hook_theme(). */function user_theme() {  return array(    'user_picture' => array(      'arguments' => array('account' => NULL),      'template' => 'user-picture',    ),    'user_profile' => array(      'arguments' => array('account' => NULL),      'template' => 'user-profile',      'file' => 'user.pages.inc',    ),    'user_profile_category' => array(      'arguments' => array('element' => NULL),      'template' => 'user-profile-category',      'file' => 'user.pages.inc',    ),    'user_profile_item' => array(      'arguments' => array('element' => NULL),      'template' => 'user-profile-item',      'file' => 'user.pages.inc',    ),    'user_list' => array(      'arguments' => array('users' => NULL, 'title' => NULL),    ),    'user_admin_perm' => array(      'arguments' => array('form' => NULL),      'file' => 'user.admin.inc',    ),    'user_admin_new_role' => array(      'arguments' => array('form' => NULL),      'file' => 'user.admin.inc',    ),    'user_admin_account' => array(      'arguments' => array('form' => NULL),      'file' => 'user.admin.inc',    ),    'user_filter_form' => array(      'arguments' => array('form' => NULL),      'file' => 'user.admin.inc',    ),    'user_filters' => array(      'arguments' => array('form' => NULL),      'file' => 'user.admin.inc',    ),    'user_signature' => array(      'arguments' => array('signature' => NULL),    ),  );}function user_external_load($authname) {  $result = db_query("SELECT uid FROM {authmap} WHERE authname = '%s'", $authname);  if ($user = db_fetch_array($result)) {    return user_load($user);  }  else {    return 0;  }}/** * Perform standard Drupal login operations for a user object. * * The user object must already be authenticated. This function verifies * that the user account is not blocked/denied and then performs the login, * updates the login timestamp in the database, invokes hook_user('login'), * and regenerates the session. * * @param $account *    An authenticated user object to be set as the currently logged *    in user. * @param $edit *    The array of form values submitted by the user, if any. *    This array is passed to hook_user op login. * @return boolean *    TRUE if the login succeeds, FALSE otherwise. */function user_external_login($account, $edit = array()) {  $form = drupal_get_form('user_login');  $state['values'] = $edit;  if (empty($state['values']['name'])) {    $state['values']['name'] = $account->name;  }  // Check if user is blocked or denied by access rules.  user_login_name_validate($form, $state, (array)$account);  if (form_get_errors()) {    // Invalid login.    return FALSE;  }  // Valid login.  global $user;  $user = $account;  user_authenticate_finalize($state['values']);  return TRUE;}/** * Fetch a user object. * * @param $array *   An associative array of attributes to search for in selecting the *   user, such as user name or e-mail address. * * @return *   A fully-loaded $user object upon successful user load or FALSE if user *   cannot be loaded. */function user_load($array = array()) {  // Dynamically compose a SQL query:  $query = array();  $params = array();  if (is_numeric($array)) {    $array = array('uid' => $array);  }  elseif (!is_array($array)) {    return FALSE;  }  foreach ($array as $key => $value) {    if ($key == 'uid' || $key == 'status') {      $query[] = "$key = %d";      $params[] = $value;    }    else if ($key == 'pass') {      $query[] = "pass = '%s'";      $params[] = md5($value);    }    else {      $query[]= "LOWER($key) = LOWER('%s')";      $params[] = $value;    }  }  $result = db_query('SELECT * FROM {users} u WHERE '. implode(' AND ', $query), $params);  if ($user = db_fetch_object($result)) {    $user = drupal_unpack($user);    $user->roles = array();    if ($user->uid) {      $user->roles[DRUPAL_AUTHENTICATED_RID] = 'authenticated user';    }    else {      $user->roles[DRUPAL_ANONYMOUS_RID] = 'anonymous user';    }    $result = db_query('SELECT r.rid, r.name FROM {role} r INNER JOIN {users_roles} ur ON ur.rid = r.rid WHERE ur.uid = %d', $user->uid);    while ($role = db_fetch_object($result)) {      $user->roles[$role->rid] = $role->name;    }    user_module_invoke('load', $array, $user);  }  else {    $user = FALSE;  }  return $user;}/** * Save changes to a user account or add a new user. * * @param $account *   The $user object for the user to modify or add. If $user->uid is *   omitted, a new user will be added. * * @param $array *   (optional) An array of fields and values to save. For example, *   array('name' => 'My name'); Setting a field to NULL deletes it from *   the data column. * * @param $category *   (optional) The category for storing profile information in. * * @return *   A fully-loaded $user object upon successful save or FALSE if the save failed. */function user_save($account, $array = array(), $category = 'account') {  // Dynamically compose a SQL query:  $user_fields = user_fields();  if (is_object($account) && $account->uid) {    user_module_invoke('update', $array, $account, $category);    $query = '';    $data = unserialize(db_result(db_query('SELECT data FROM {users} WHERE uid = %d', $account->uid)));    // Consider users edited by an administrator as logged in, if they haven't    // already, so anonymous users can view the profile (if allowed).    if (empty($array['access']) && empty($account->access) && user_access('administer users')) {      $array['access'] = time();    }    foreach ($array as $key => $value) {      if ($key == 'pass' && !empty($value)) {        $query .= "$key = '%s', ";        $v[] = md5($value);      }      else if ((substr($key, 0, 4) !== 'auth') && ($key != 'pass')) {        if (in_array($key, $user_fields)) {          // Save standard fields.          $query .= "$key = '%s', ";          $v[] = $value;        }        else if ($key != 'roles') {          // Roles is a special case: it used below.          if ($value === NULL) {            unset($data[$key]);          }          else {            $data[$key] = $value;          }        }      }    }    $query .= "data = '%s' ";    $v[] = serialize($data);    $success = db_query("UPDATE {users} SET $query WHERE uid = %d", array_merge($v, array($account->uid)));    if (!$success) {      // The query failed - better to abort the save than risk further data loss.      return FALSE;    }    // Reload user roles if provided.    if (isset($array['roles']) && is_array($array['roles'])) {      db_query('DELETE FROM {users_roles} WHERE uid = %d', $account->uid);      foreach (array_keys($array['roles']) as $rid) {        if (!in_array($rid, array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID))) {          db_query('INSERT INTO {users_roles} (uid, rid) VALUES (%d, %d)', $account->uid, $rid);        }      }    }    // Delete a blocked user's sessions to kick them if they are online.    if (isset($array['status']) && $array['status'] == 0) {      sess_destroy_uid($account->uid);    }    // If the password changed, delete all open sessions and recreate    // the current one.    if (!empty($array['pass'])) {      sess_destroy_uid($account->uid);      if ($account->uid == $GLOBALS['user']->uid) {        sess_regenerate();      }    }    // Refresh user object.    $user = user_load(array('uid' => $account->uid));    // Send emails after we have the new user object.    if (isset($array['status']) && $array['status'] != $account->status) {      // The user's status is changing; conditionally send notification email.      $op = $array['status'] == 1 ? 'status_activated' : 'status_blocked';      _user_mail_notify($op, $user);    }    user_module_invoke('after_update', $array, $user, $category);  }  else {    // Allow 'created' to be set by the caller.    if (!isset($array['created'])) {      $array['created'] = time();    }    // Consider users created by an administrator as already logged in, so    // anonymous users can view the profile (if allowed).    if (empty($array['access']) && user_access('administer users')) {      $array['access'] = time();    }    // Note: we wait to save the data column to prevent module-handled    // fields from being saved there. We cannot invoke hook_user('insert') here    // because we don't have a fully initialized user object yet.    foreach ($array as $key => $value) {      switch ($key) {        case 'pass':          $fields[] = $key;          $values[] = md5($value);          $s[] = "'%s'";          break;        case 'mode':       case 'sort':     case 'timezone':        case 'threshold':  case 'created':  case 'access':        case 'login':      case 'status':          $fields[] = $key;          $values[] = $value;          $s[] = "%d";          break;        default:          if (substr($key, 0, 4) !== 'auth' && in_array($key, $user_fields)) {            $fields[] = $key;            $values[] = $value;            $s[] = "'%s'";          }          break;      }    }    $success = db_query('INSERT INTO {users} ('. implode(', ', $fields) .') VALUES ('. implode(', ', $s) .')', $values);    if (!$success) {      // On a failed INSERT some other existing user's uid may be returned.      // We must abort to avoid overwriting their account.      return FALSE;    }    // Build the initial user object.    $array['uid'] = db_last_insert_id('users', 'uid');    $user = user_load(array('uid' => $array['uid']));    user_module_invoke('insert', $array, $user, $category);    // Build and save the serialized data field now.    $data = array();    foreach ($array as $key => $value) {      if ((substr($key, 0, 4) !== 'auth') && ($key != 'roles') && (!in_array($key, $user_fields)) && ($value !== NULL)) {        $data[$key] = $value;      }    }    db_query("UPDATE {users} SET data = '%s' WHERE uid = %d", serialize($data), $user->uid);    // Save user roles (delete just to be safe).    if (isset($array['roles']) && is_array($array['roles'])) {      db_query('DELETE FROM {users_roles} WHERE uid = %d', $array['uid']);      foreach (array_keys($array['roles']) as $rid) {        if (!in_array($rid, array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID))) {          db_query('INSERT INTO {users_roles} (uid, rid) VALUES (%d, %d)', $array['uid'], $rid);        }      }    }    // Build the finished user object.    $user = user_load(array('uid' => $array['uid']));  }  // Save distributed authentication mappings.  $authmaps = array();  foreach ($array as $key => $value) {    if (substr($key, 0, 4) == 'auth') {      $authmaps[$key] = $value;    }  }  if (sizeof($authmaps) > 0) {    user_set_authmaps($user, $authmaps);  }  return $user;}/** * Verify the syntax of the given name. */function user_validate_name($name) {  if (!strlen($name)) return t('You must enter a username.');  if (substr($name, 0, 1) == ' ') return t('The username cannot begin with a space.');  if (substr($name, -1) == ' ') return t('The username cannot end with a space.');  if (strpos($name, '  ') !== FALSE) return t('The username cannot contain multiple spaces in a row.');  if (ereg("[^\x80-\xF7 [:alnum:]@_.-]", $name)) return t('The username contains an illegal character.');  if (preg_match('/[\x{80}-\x{A0}'.          // Non-printable ISO-8859-1 + NBSP                   '\x{AD}'.                 // Soft-hyphen                   '\x{2000}-\x{200F}'.      // Various space characters                   '\x{2028}-\x{202F}'.      // Bidirectional text overrides                   '\x{205F}-\x{206F}'.      // Various text hinting characters                   '\x{FEFF}'.               // Byte order mark                   '\x{FF01}-\x{FF60}'.      // Full-width latin                   '\x{FFF9}-\x{FFFD}'.      // Replacement characters                   '\x{0}]/u',               // NULL byte                   $name)) {    return t('The username contains an illegal character.');  }  if (strpos($name, '@') !== FALSE && !eregi('@([0-9a-z](-?[0-9a-z])*.)+[a-z]{2}([zmuvtg]|fo|me)?$', $name)) return t('The username is not a valid authentication ID.');  if (strlen($name) > USERNAME_MAX_LENGTH) return t('The username %name is too long: it must be %max characters or less.', array('%name' => $name, '%max' => USERNAME_MAX_LENGTH));}function user_validate_mail($mail) {  if (!$mail) return t('You must enter an e-mail address.');  if (!valid_email_address($mail)) {    return t('The e-mail address %mail is not valid.', array('%mail' => $mail));  }}function user_validate_picture(&$form, &$form_state) {  // If required, validate the uploaded picture.  $validators = array(    'file_validate_is_image' => array(),    'file_validate_image_resolution' => array(variable_get('user_picture_dimensions', '85x85')),    'file_validate_size' => array(variable_get('user_picture_file_size', '30') * 1024),  );  if ($file = file_save_upload('picture_upload', $validators)) {    // Remove the old picture.    if (isset($form_state['values']['_account']->picture) && file_exists($form_state['values']['_account']->picture)) {      file_delete($form_state['values']['_account']->picture);    }    // The image was saved using file_save_upload() and was added to the    // files table as a temporary file. We'll make a copy and let the garbage    // collector delete the original upload.    $info = image_get_info($file->filepath);    $destination = variable_get('user_picture_path', 'pictures') .'/picture-'. $form['#uid'] .'.'. $info['extension'];    if (file_copy($file, $destination, FILE_EXISTS_REPLACE)) {      $form_state['values']['picture'] = $file->filepath;    }    else {      form_set_error('picture_upload', t("Failed to upload the picture image; the %directory directory doesn't exist or is not writable.", array('%directory' => variable_get('user_picture_path', 'pictures'))));    }  }}/** * Generate a random alphanumeric password. */function user_password($length = 10) {  // This variable contains the list of allowable characters for the  // password. Note that the number 0 and the letter 'O' have been  // removed to avoid confusion between the two. The same is true  // of 'I', 1, and 'l'.  $allowable_characters = 'abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789';  // Zero-based count of characters in the allowable list:  $len = strlen($allowable_characters) - 1;  // Declare the password as a blank string.  $pass = '';  // Loop the number of times specified by $length.  for ($i = 0; $i < $length; $i++) {    // Each iteration, pick a random character from the    // allowable string and append it to the password:    $pass .= $allowable_characters[mt_rand(0, $len)];  }  return $pass;}/** * Determine whether the user has a given privilege. * * @param $string *   The permission, such as "administer nodes", being checked for. * @param $account *   (optional) The account to check, if not given use currently logged in user. * @param $reset *   (optional) Resets the user's permissions cache, which will result in a *   recalculation of the user's permissions. This is necessary to support *   dynamically added user roles. * * @return *   Boolean TRUE if the current user has the requested permission. * * All permission checks in Drupal should go through this function. This * way, we guarantee consistent behavior, and ensure that the superuser * can perform all actions. */function user_access($string, $account = NULL, $reset = FALSE) {  global $user;  static $perm = array();  if ($reset) {    $perm = array();  }  if (!isset($account)) {    $account = $user;  }  // User #1 has all privileges:  if ($account->uid == 1) {    return TRUE;  }  // To reduce the number of SQL queries, we cache the user's permissions  // in a static variable.  if (!isset($perm[$account->uid])) {    $result = db_query("SELECT p.perm FROM {role} r INNER JOIN {permission} p ON p.rid = r.rid WHERE r.rid IN (". db_placeholders($account->roles) .")", array_keys($account->roles));    $perms = array();    while ($row = db_fetch_object($result)) {      $perms += array_flip(explode(', ', $row->perm));    }    $perm[$account->uid] = $perms;  }  return isset($perm[$account->uid][$string]);}/** * Checks for usernames blocked by user administration. * * @return boolean TRUE for blocked users, FALSE for active. */function user_is_blocked($name) {  $deny = db_fetch_object(db_query("SELECT name FROM {users} WHERE status = 0 AND name = LOWER('%s')", $name));  return $deny;}function user_fields() {  static $fields;  if (!$fields) {    $result = db_query('SELECT * FROM {users} WHERE uid = 1');    if ($field = db_fetch_array($result)) {      $fields = array_keys($field);    }    else {      // Make sure we return the default fields at least.      $fields = array('uid', 'name', 'pass', 'mail', 'picture', 'mode', 'sort', 'threshold', 'theme', 'signature', 'signature_format', 'created', 'access', 'login', 'status', 'timezone', 'language', 'init', 'data');    }  }  return $fields;}/** * Implementation of hook_perm(). */function user_perm() {  return array('administer permissions', 'administer users', 'access user profiles', 'change own username');}/** * Implementation of hook_file_download(). * * Ensure that user pictures (avatars) are always downloadable. */function user_file_download($file) {  if (strpos($file, variable_get('user_picture_path', 'pictures') .'/picture-') === 0) {    $info = image_get_info(file_create_path($file));    return array('Content-type: '. $info['mime_type']);  }}/** * Implementation of hook_search(). */function user_search($op = 'search', $keys = NULL, $skip_access_check = FALSE) {  switch ($op) {    case 'name':      if ($skip_access_check || user_access('access user profiles')) {        return t('Users');      }    case 'search':      if (user_access('access user profiles')) {        $find = array();        // Replace wildcards with MySQL/PostgreSQL wildcards.        $keys = preg_replace('!\*+!', '%', $keys);        if (user_access('administer users')) {          // Administrators can also search in the otherwise private email field.          $result = pager_query("SELECT name, uid, mail FROM {users} WHERE LOWER(name) LIKE LOWER('%%%s%%') OR LOWER(mail) LIKE LOWER('%%%s%%')", 15, 0, NULL, $keys, $keys);          while ($account = db_fetch_object($result)) {            $find[] = array('title' => $account->name .' ('. $account->mail .')', 'link' => url('user/'. $account->uid, array('absolute' => TRUE)));          }        }        else {          $result = pager_query("SELECT name, uid FROM {users} WHERE LOWER(name) LIKE LOWER('%%%s%%')", 15, 0, NULL, $keys);          while ($account = db_fetch_object($result)) {            $find[] = array('title' => $account->name, 'link' => url('user/'. $account->uid, array('absolute' => TRUE)));          }        }        return $find;      }  }}/** * Implementation of hook_elements(). */function user_elements() {  return array(    'user_profile_category' => array(),    'user_profile_item' => array(),  );}/** * Implementation of hook_user(). */function user_user($type, &$edit, &$account, $category = NULL) {  if ($type == 'view') {    $account->content['user_picture'] = array(      '#value' => theme('user_picture', $account),      '#weight' => -10,    );    if (!isset($account->content['summary'])) {      $account->content['summary'] = array();    }    $account->content['summary'] += array(      '#type' => 'user_profile_category',      '#attributes' => array('class' => 'user-member'),      '#weight' => 5,      '#title' => t('History'),    );    $account->content['summary']['member_for'] = array(      '#type' => 'user_profile_item',      '#title' => t('Member for'),      '#value' => format_interval(time() - $account->created),    );  }  if ($type == 'form' && $category == 'account') {    $form_state = array();    return user_edit_form($form_state, (isset($account->uid) ? $account->uid : FALSE), $edit);  }  if ($type == 'validate' && $category == 'account') {    return _user_edit_validate((isset($account->uid) ? $account->uid : FALSE), $edit);  }  if ($type == 'submit' && $category == 'account') {    return _user_edit_submit((isset($account->uid) ? $account->uid : FALSE), $edit);  }  if ($type == 'categories') {    return array(array('name' => 'account', 'title' => t('Account settings'), 'weight' => 1));  }}function user_login_block() {  $form = array(    '#action' => url($_GET['q'], array('query' => drupal_get_destination())),    '#id' => 'user-login-form',    '#validate' => user_login_default_validators(),    '#submit' => array('user_login_submit'),  );  $form['name'] = array('#type' => 'textfield',    '#title' => t('Username'),    '#maxlength' => USERNAME_MAX_LENGTH,    '#size' => 15,    '#required' => TRUE,  );  $form['pass'] = array('#type' => 'password',    '#title' => t('Password'),    '#maxlength' => 60,    '#size' => 15,    '#required' => TRUE,  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Log in'),  );  $items = array();  if (variable_get('user_register', 1)) {    $items[] = l(t('Create new account'), 'user/register', array('attributes' => array('title' => t('Create a new user account.'))));  }  $items[] = l(t('Request new password'), 'user/password', array('attributes' => array('title' => t('Request new password via e-mail.'))));  $form['links'] = array('#value' => theme('item_list', $items));  return $form;}/** * Implementation of hook_block(). */function user_block($op = 'list', $delta = 0, $edit = array()) {  global $user;  if ($op == 'list') {    $blocks[0]['info'] = t('User login');    // Not worth caching.    $blocks[0]['cache'] = BLOCK_NO_CACHE;    $blocks[1]['info'] = t('Navigation');    // Menu blocks can't be cached because each menu item can have    // a custom access callback. menu.inc manages its own caching.    $blocks[1]['cache'] = BLOCK_NO_CACHE;    $blocks[2]['info'] = t('Who\'s new');    // Too dynamic to cache.    $blocks[3]['info'] = t('Who\'s online');    $blocks[3]['cache'] = BLOCK_NO_CACHE;    return $blocks;  }  else if ($op == 'configure' && $delta == 2) {    $form['user_block_whois_new_count'] = array(      '#type' => 'select',      '#title' => t('Number of users to display'),      '#default_value' => variable_get('user_block_whois_new_count', 5),      '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)),    );    return $form;  }  else if ($op == 'configure' && $delta == 3) {    $period = drupal_map_assoc(array(30, 60, 120, 180, 300, 600, 900, 1800, 2700, 3600, 5400, 7200, 10800, 21600, 43200, 86400), 'format_interval');    $form['user_block_seconds_online'] = array('#type' => 'select', '#title' => t('User activity'), '#default_value' => variable_get('user_block_seconds_online', 900), '#options' => $period, '#description' => t('A user is considered online for this long after they have last viewed a page.'));    $form['user_block_max_list_count'] = array('#type' => 'select', '#title' => t('User list length'), '#default_value' => variable_get('user_block_max_list_count', 10), '#options' => drupal_map_assoc(array(0, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100)), '#description' => t('Maximum number of currently online users to display.'));    return $form;  }  else if ($op == 'save' && $delta == 2) {    variable_set('user_block_whois_new_count', $edit['user_block_whois_new_count']);  }  else if ($op == 'save' && $delta == 3) {    variable_set('user_block_seconds_online', $edit['user_block_seconds_online']);    variable_set('user_block_max_list_count', $edit['user_block_max_list_count']);  }  else if ($op == 'view') {    $block = array();    switch ($delta) {      case 0:        // For usability's sake, avoid showing two login forms on one page.        if (!$user->uid && !(arg(0) == 'user' && !is_numeric(arg(1)))) {          $block['subject'] = t('User login');          $block['content'] = drupal_get_form('user_login_block');        }        return $block;      case 1:        if ($menu = menu_tree()) {          $block['subject'] = $user->uid ? check_plain($user->name) : t('Navigation');          $block['content'] = $menu;        }        return $block;      case 2:        if (user_access('access content')) {          // Retrieve a list of new users who have subsequently accessed the site successfully.          $result = db_query_range('SELECT uid, name FROM {users} WHERE status != 0 AND access != 0 ORDER BY created DESC', 0, variable_get('user_block_whois_new_count', 5));          while ($account = db_fetch_object($result)) {            $items[] = $account;          }          $output = theme('user_list', $items);          $block['subject'] = t('Who\'s new');          $block['content'] = $output;        }        return $block;      case 3:        if (user_access('access content')) {          // Count users active within the defined period.          $interval = time() - variable_get('user_block_seconds_online', 900);          // Perform database queries to gather online user lists.  We use s.timestamp          // rather than u.access because it is much faster.          $anonymous_count = sess_count($interval);          $authenticated_users = db_query('SELECT DISTINCT u.uid, u.name, s.timestamp FROM {users} u INNER JOIN {sessions} s ON u.uid = s.uid WHERE s.timestamp >= %d AND s.uid > 0 ORDER BY s.timestamp DESC', $interval);          $authenticated_count = 0;          $max_users = variable_get('user_block_max_list_count', 10);          $items = array();          while ($account = db_fetch_object($authenticated_users)) {            if ($max_users > 0) {              $items[] = $account;              $max_users--;            }            $authenticated_count++;          }          // Format the output with proper grammar.          if ($anonymous_count == 1 && $authenticated_count == 1) {            $output = t('There is currently %members and %visitors online.', array('%members' => format_plural($authenticated_count, '1 user', '@count users'), '%visitors' => format_plural($anonymous_count, '1 guest', '@count guests')));          }          else {            $output = t('There are currently %members and %visitors online.', array('%members' => format_plural($authenticated_count, '1 user', '@count users'), '%visitors' => format_plural($anonymous_count, '1 guest', '@count guests')));          }          // Display a list of currently online users.          $max_users = variable_get('user_block_max_list_count', 10);          if ($authenticated_count && $max_users) {            $output .= theme('user_list', $items, t('Online users'));          }          $block['subject'] = t('Who\'s online');          $block['content'] = $output;        }        return $block;    }  }}/** * Process variables for user-picture.tpl.php. * * The $variables array contains the following arguments: * - $account * * @see user-picture.tpl.php */function template_preprocess_user_picture(&$variables) {  $variables['picture'] = '';  if (variable_get('user_pictures', 0)) {    $account = $variables['account'];    if (!empty($account->picture) && file_exists($account->picture)) {      $picture = file_create_url($account->picture);    }    else if (variable_get('user_picture_default', '')) {      $picture = variable_get('user_picture_default', '');    }    if (isset($picture)) {      $alt = t("@user's picture", array('@user' => $account->name ? $account->name : variable_get('anonymous', t('Anonymous'))));      $variables['picture'] = theme('image', $picture, $alt, $alt, '', FALSE);      if (!empty($account->uid) && user_access('access user profiles')) {        $attributes = array('attributes' => array('title' => t('View user profile.')), 'html' => TRUE);        $variables['picture'] = l($variables['picture'], "user/$account->uid", $attributes);      }    }  }}/** * Make a list of users. * * @param $users *   An array with user objects. Should contain at least the name and uid. * @param $title *  (optional) Title to pass on to theme_item_list(). * * @ingroup themeable */function theme_user_list($users, $title = NULL) {  if (!empty($users)) {    foreach ($users as $user) {      $items[] = theme('username', $user);    }  }  return theme('item_list', $items, $title);}function user_is_anonymous() {  // Menu administrators can see items for anonymous when administering.  return !$GLOBALS['user']->uid || !empty($GLOBALS['menu_admin']);}function user_is_logged_in() {  return (bool)$GLOBALS['user']->uid;}function user_register_access() {  return user_is_anonymous() && variable_get('user_register', 1);}function user_view_access($account) {  return $account && $account->uid &&    (      // Always let users view their own profile.      ($GLOBALS['user']->uid == $account->uid) ||      // Administrators can view all accounts.      user_access('administer users') ||      // The user is not blocked and logged in at least once.      ($account->access && $account->status && user_access('access user profiles'))    );}/** * Access callback for user account editing. */function user_edit_access($account) {  return (($GLOBALS['user']->uid == $account->uid) || user_access('administer users')) && $account->uid > 0;}function user_load_self($arg) {  $arg[1] = user_load($GLOBALS['user']->uid);  return $arg;}/** * Implementation of hook_menu(). */function user_menu() {  $items['user/autocomplete'] = array(    'title' => 'User autocomplete',    'page callback' => 'user_autocomplete',    'access callback' => 'user_access',    'access arguments' => array('access user profiles'),    'type' => MENU_CALLBACK,    'file' => 'user.pages.inc',  );  // Registration and login pages.  $items['user'] = array(    'title' => 'User account',    'page callback' => 'user_page',    'access callback' => TRUE,    'type' => MENU_CALLBACK,    'file' => 'user.pages.inc',  );  $items['user/login'] = array(    'title' => 'Log in',    'access callback' => 'user_is_anonymous',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['user/register'] = array(    'title' => 'Create new account',    'page callback' => 'drupal_get_form',    'page arguments' => array('user_register'),    'access callback' => 'user_register_access',    'type' => MENU_LOCAL_TASK,    'file' => 'user.pages.inc',  );  $items['user/password'] = array(    'title' => 'Request new password',    'page callback' => 'drupal_get_form',    'page arguments' => array('user_pass'),    'access callback' => 'user_is_anonymous',    'type' => MENU_LOCAL_TASK,    'file' => 'user.pages.inc',  );  $items['user/reset/%/%/%'] = array(    'title' => 'Reset password',    'page callback' => 'drupal_get_form',    'page arguments' => array('user_pass_reset', 2, 3, 4),    'access callback' => TRUE,    'type' => MENU_CALLBACK,    'file' => 'user.pages.inc',  );  // Admin user pages.  $items['admin/user'] = array(    'title' => 'User management',    'description' => "Manage your site's users, groups and access to site features.",    'position' => 'left',    'page callback' => 'system_admin_menu_block_page',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',    'file path' => drupal_get_path('module', 'system'),  );  $items['admin/user/user'] = array(    'title' => 'Users',    'description' => 'List, add, and edit users.',    'page callback' => 'user_admin',    'page arguments' => array('list'),    'access arguments' => array('administer users'),    'file' => 'user.admin.inc',  );  $items['admin/user/user/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/user/user/create'] = array(    'title' => 'Add user',    'page arguments' => array('create'),    'access arguments' => array('administer users'),    'type' => MENU_LOCAL_TASK,    'file' => 'user.admin.inc',  );  $items['admin/user/settings'] = array(    'title' => 'User settings',    'description' => 'Configure default behavior of users, including registration requirements, e-mails, and user pictures.',    'page callback' => 'drupal_get_form',    'page arguments' => array('user_admin_settings'),    'access arguments' => array('administer users'),    'file' => 'user.admin.inc',  );  // Admin access pages.  $items['admin/user/permissions'] = array(    'title' => 'Permissions',    'description' => 'Determine access to features by selecting permissions for roles.',    'page callback' => 'drupal_get_form',    'page arguments' => array('user_admin_perm'),    'access arguments' => array('administer permissions'),    'file' => 'user.admin.inc',  );  $items['admin/user/roles'] = array(    'title' => 'Roles',    'description' => 'List, edit, or add user roles.',    'page callback' => 'drupal_get_form',    'page arguments' => array('user_admin_new_role'),    'access arguments' => array('administer permissions'),    'file' => 'user.admin.inc',  );  $items['admin/user/roles/edit'] = array(    'title' => 'Edit role',    'page arguments' => array('user_admin_role'),    'access arguments' => array('administer permissions'),    'type' => MENU_CALLBACK,    'file' => 'user.admin.inc',  );  $items['admin/user/rules'] = array(    'title' => 'Access rules',    'description' => 'List and create rules to disallow usernames, e-mail addresses, and IP addresses.',    'page callback' => 'user_admin_access',    'access arguments' => array('administer permissions'),    'file' => 'user.admin.inc',  );  $items['admin/user/rules/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/user/rules/add'] = array(    'title' => 'Add rule',    'page callback' => 'user_admin_access_add',    'access arguments' => array('administer permissions'),    'type' => MENU_LOCAL_TASK,    'file' => 'user.admin.inc',  );  $items['admin/user/rules/check'] = array(    'title' => 'Check rules',    'page callback' => 'user_admin_access_check',    'access arguments' => array('administer permissions'),    'type' => MENU_LOCAL_TASK,    'file' => 'user.admin.inc',  );  $items['admin/user/rules/edit'] = array(    'title' => 'Edit rule',    'page callback' => 'user_admin_access_edit',    'access arguments' => array('administer permissions'),    'type' => MENU_CALLBACK,    'file' => 'user.admin.inc',  );  $items['admin/user/rules/delete'] = array(    'title' => 'Delete rule',    'page callback' => 'drupal_get_form',    'page arguments' => array('user_admin_access_delete_confirm'),    'access arguments' => array('administer permissions'),    'type' => MENU_CALLBACK,    'file' => 'user.admin.inc',  );  $items['logout'] = array(    'title' => 'Log out',    'access callback' => 'user_is_logged_in',    'page callback' => 'user_logout',    'weight' => 10,    'file' => 'user.pages.inc',  );  $items['user/%user_uid_optional'] = array(    'title' => 'My account',    'title callback' => 'user_page_title',    'title arguments' => array(1),    'page callback' => 'user_view',    'page arguments' => array(1),    'access callback' => 'user_view_access',    'access arguments' => array(1),    'parent' => '',    'file' => 'user.pages.inc',  );  $items['user/%user/view'] = array(    'title' => 'View',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['user/%user/delete'] = array(    'title' => 'Delete',    'page callback' => 'drupal_get_form',    'page arguments' => array('user_confirm_delete', 1),    'access callback' => 'user_access',    'access arguments' => array('administer users'),    'type' => MENU_CALLBACK,    'file' => 'user.pages.inc',  );  $items['user/%user_category/edit'] = array(    'title' => 'Edit',    'page callback' => 'user_edit',    'page arguments' => array(1),    'access callback' => 'user_edit_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'load arguments' => array('%map', '%index'),    'file' => 'user.pages.inc',  );  $items['user/%user_category/edit/account'] = array(    'title' => 'Account',    'type' => MENU_DEFAULT_LOCAL_TASK,    'load arguments' => array('%map', '%index'),  );  $empty_account = new stdClass();  if (($categories = _user_categories($empty_account)) && (count($categories) > 1)) {    foreach ($categories as $key => $category) {      // 'account' is already handled by the MENU_DEFAULT_LOCAL_TASK.      if ($category['name'] != 'account') {        $items['user/%user_category/edit/'. $category['name']] = array(          'title callback' => 'check_plain',          'title arguments' => array($category['title']),          'page callback' => 'user_edit',          'page arguments' => array(1, 3),          'access callback' => isset($category['access callback']) ? $category['access callback'] : 'user_edit_access',          'access arguments' => isset($category['access arguments']) ? $category['access arguments'] : array(1),          'type' => MENU_LOCAL_TASK,          'weight' => $category['weight'],          'load arguments' => array('%map', '%index'),          'tab_parent' => 'user/%/edit',          'file' => 'user.pages.inc',        );      }    }  }  return $items;}/** * Implementation of hook_init(). */function user_init() {  drupal_add_css(drupal_get_path('module', 'user') .'/user.css', 'module');}/** * Load either a specified or the current user account. * * @param $uid *   An optional user ID of the user to load. If not provided, the current *   user's ID will be used. * @return *   A fully-loaded $user object upon successful user load, FALSE if user *   cannot be loaded. * * @see user_load() */function user_uid_optional_load($uid = NULL) {  if (!isset($uid)) {    $uid = $GLOBALS['user']->uid;  }  return user_load($uid);}/** * Return a user object after checking if any profile category in the path exists. */function user_category_load($uid, &$map, $index) {  static $user_categories, $accounts;  // Cache $account - this load function will get called for each profile tab.  if (!isset($accounts[$uid])) {    $accounts[$uid] = user_load($uid);  }  $valid = TRUE;  if ($account = $accounts[$uid]) {    // Since the path is like user/%/edit/category_name, the category name will    // be at a position 2 beyond the index corresponding to the % wildcard.    $category_index = $index + 2;    // Valid categories may contain slashes, and hence need to be imploded.    $category_path = implode('/', array_slice($map, $category_index));    if ($category_path) {      // Check that the requested category exists.      $valid = FALSE;      if (!isset($user_categories)) {        $empty_account = new stdClass();        $user_categories = _user_categories($empty_account);      }      foreach ($user_categories as $category) {        if ($category['name'] == $category_path) {          $valid = TRUE;          // Truncate the map array in case the category name had slashes.          $map = array_slice($map, 0, $category_index);          // Assign the imploded category name to the last map element.          $map[$category_index] = $category_path;          break;        }      }    }  }  return $valid ? $account : FALSE;}/** * Returns the user id of the currently logged in user. */function user_uid_optional_to_arg($arg) {  // Give back the current user uid when called from eg. tracker, aka.  // with an empty arg. Also use the current user uid when called from  // the menu with a % for the current account link.  return empty($arg) || $arg == '%' ? $GLOBALS['user']->uid : $arg;}/** * Menu item title callback - use the user name if it's not the current user. */function user_page_title($account) {  if ($account->uid == $GLOBALS['user']->uid) {    return t('My account');  }  return $account->name;}/** * Discover which external authentication module(s) authenticated a username. * * @param $authname *   A username used by an external authentication module. * @return *   An associative array with module as key and username as value. */function user_get_authmaps($authname = NULL) {  $result = db_query("SELECT authname, module FROM {authmap} WHERE authname = '%s'", $authname);  $authmaps = array();  $has_rows = FALSE;  while ($authmap = db_fetch_object($result)) {    $authmaps[$authmap->module] = $authmap->authname;    $has_rows = TRUE;  }  return $has_rows ? $authmaps : 0;}/** * Save mappings of which external authentication module(s) authenticated * a user. Maps external usernames to user ids in the users table. * * @param $account *   A user object. * @param $authmaps *   An associative array with a compound key and the username as the value. *   The key is made up of 'authname_' plus the name of the external authentication *   module. * @see user_external_login_register() */function user_set_authmaps($account, $authmaps) {  foreach ($authmaps as $key => $value) {    $module = explode('_', $key, 2);    if ($value) {      db_query("UPDATE {authmap} SET authname = '%s' WHERE uid = %d AND module = '%s'", $value, $account->uid, $module[1]);      if (!db_affected_rows()) {        db_query("INSERT INTO {authmap} (authname, uid, module) VALUES ('%s', %d, '%s')", $value, $account->uid, $module[1]);      }    }    else {      db_query("DELETE FROM {authmap} WHERE uid = %d AND module = '%s'", $account->uid, $module[1]);    }  }}/** * Form builder; the main user login form. * * @ingroup forms */function user_login(&$form_state) {  global $user;  // If we are already logged on, go to the user page instead.  if ($user->uid) {    drupal_goto('user/'. $user->uid);  }  // Display login form:  $form['name'] = array('#type' => 'textfield',    '#title' => t('Username'),    '#size' => 60,    '#maxlength' => USERNAME_MAX_LENGTH,    '#required' => TRUE,  );  $form['name']['#description'] = t('Enter your @s username.', array('@s' => variable_get('site_name', 'Drupal')));  $form['pass'] = array('#type' => 'password',    '#title' => t('Password'),    '#description' => t('Enter the password that accompanies your username.'),    '#required' => TRUE,  );  $form['#validate'] = user_login_default_validators();  $form['submit'] = array('#type' => 'submit', '#value' => t('Log in'), '#weight' => 2);  return $form;}/** * Set up a series for validators which check for blocked/denied users, * then authenticate against local database, then return an error if * authentication fails. Distributed authentication modules are welcome * to use hook_form_alter() to change this series in order to * authenticate against their user database instead of the local users * table. * * We use three validators instead of one since external authentication * modules usually only need to alter the second validator. * * @see user_login_name_validate() * @see user_login_authenticate_validate() * @see user_login_final_validate() * @return array *   A simple list of validate functions. */function user_login_default_validators() {  return array('user_login_name_validate', 'user_login_authenticate_validate', 'user_login_final_validate');}/** * A FAPI validate handler. Sets an error if supplied username has been blocked * or denied access. */function user_login_name_validate($form, &$form_state) {  if (isset($form_state['values']['name'])) {    if (user_is_blocked($form_state['values']['name'])) {      // blocked in user administration      form_set_error('name', t('The username %name has not been activated or is blocked.', array('%name' => $form_state['values']['name'])));    }    else if (drupal_is_denied('user', $form_state['values']['name'])) {      // denied by access controls      form_set_error('name', t('The name %name is a reserved username.', array('%name' => $form_state['values']['name'])));    }  }}/** * A validate handler on the login form. Check supplied username/password * against local users table. If successful, sets the global $user object. */function user_login_authenticate_validate($form, &$form_state) {  user_authenticate($form_state['values']);}/** * A validate handler on the login form. Should be the last validator. Sets an * error if user has not been authenticated yet. */function user_login_final_validate($form, &$form_state) {  global $user;  if (!$user->uid) {    form_set_error('name', t('Sorry, unrecognized username or password. <a href="@password">Have you forgotten your password?</a>', array('@password' => url('user/password'))));    watchdog('user', 'Login attempt failed for %user.', array('%user' => $form_state['values']['name']));  }}/** * Try to log in the user locally. * * @param $form_values *   Form values with at least 'name' and 'pass' keys, as well as anything else *   which should be passed along to hook_user op 'login'. * * @return *  A $user object, if successful. */function user_authenticate($form_values = array()) {  global $user;  // Load the account to check if the e-mail is denied by an access rule.  // Doing this check here saves us a user_load() in user_login_name_validate()  // and introduces less code change for a security fix.  $account = user_load(array('name' => $form_values['name'], 'pass' => trim($form_values['pass']), 'status' => 1));  if ($account && drupal_is_denied('mail', $account->mail)) {    form_set_error('name', t('The name %name is registered using a reserved e-mail address and therefore could not be logged in.', array('%name' => $account->name)));  }  // Name and pass keys are required.  // The user is about to be logged in, so make sure no error was previously  // encountered in the validation process.  if (!form_get_errors() && !empty($form_values['name']) && !empty($form_values['pass']) && $account) {    $user = $account;    user_authenticate_finalize($form_values);    return $user;  }}/** * Finalize the login process. Must be called when logging in a user. * * The function records a watchdog message about the new session, saves the * login timestamp, calls hook_user op 'login' and generates a new session. * * $param $edit *   This array is passed to hook_user op login. */function user_authenticate_finalize(&$edit) {  global $user;  watchdog('user', 'Session opened for %name.', array('%name' => $user->name));  // Update the user table timestamp noting user has logged in.  // This is also used to invalidate one-time login links.  $user->login = time();  db_query("UPDATE {users} SET login = %d WHERE uid = %d", $user->login, $user->uid);  // Regenerate the session ID to prevent against session fixation attacks.  sess_regenerate();  user_module_invoke('login', $edit, $user);}/** * Submit handler for the login form. Redirects the user to a page. * * The user is redirected to the My Account page. Setting the destination in * the query string (as done by the user login block) overrides the redirect. */function user_login_submit($form, &$form_state) {  global $user;  if ($user->uid) {    $form_state['redirect'] = 'user/'. $user->uid;    return;  }}/** * Helper function for authentication modules. Either login in or registers * the current user, based on username. Either way, the global $user object is * populated based on $name. */function user_external_login_register($name, $module) {  global $user;  $existing_user = user_load(array('name' => $name));  if (isset($existing_user->uid)) {    $user = $existing_user;  }  else {    // Register this new user.    $userinfo = array(      'name' => $name,      'pass' => user_password(),      'init' => $name,      'status' => 1,      "authname_$module" => $name,      'access' => time()    );    $account = user_save('', $userinfo);    // Terminate if an error occured during user_save().    if (!$account) {      drupal_set_message(t("Error saving user account."), 'error');      return;    }    $user = $account;    watchdog('user', 'New external user: %name using module %module.', array('%name' => $name, '%module' => $module), WATCHDOG_NOTICE, l(t('edit'), 'user/'. $user->uid .'/edit'));  }}function user_pass_reset_url($account) {  $timestamp = time();  return url("user/reset/$account->uid/$timestamp/". user_pass_rehash($account->pass, $timestamp, $account->login), array('absolute' => TRUE));}function user_pass_rehash($password, $timestamp, $login) {  return md5($timestamp . $password . $login);}function user_edit_form(&$form_state, $uid, $edit, $register = FALSE) {  _user_password_dynamic_validation();  $admin = user_access('administer users');  // Account information:  $form['account'] = array('#type' => 'fieldset',    '#title' => t('Account information'),    '#weight' => -10,  );  // Only show name field when: registration page; or user is editing own account and can change username; or an admin user.  if ($register || ($GLOBALS['user']->uid == $uid && user_access('change own username')) || $admin) {    $form['account']['name'] = array('#type' => 'textfield',      '#title' => t('Username'),      '#default_value' => $edit['name'],      '#maxlength' => USERNAME_MAX_LENGTH,      '#description' => t('Spaces are allowed; punctuation is not allowed except for periods, hyphens, and underscores.'),      '#required' => TRUE,    );  }  $form['account']['mail'] = array('#type' => 'textfield',    '#title' => t('E-mail address'),    '#default_value' => $edit['mail'],    '#maxlength' => EMAIL_MAX_LENGTH,    '#description' => t('A valid e-mail address. All e-mails from the system will be sent to this address. The e-mail address is not made public and will only be used if you wish to receive a new password or wish to receive certain news or notifications by e-mail.'),    '#required' => TRUE,  );  if (!$register) {    $form['account']['pass'] = array('#type' => 'password_confirm',      '#description' => t('To change the current user password, enter the new password in both fields.'),      '#size' => 25,    );  }  elseif (!variable_get('user_email_verification', TRUE) || $admin) {    $form['account']['pass'] = array(      '#type' => 'password_confirm',      '#description' => t('Provide a password for the new account in both fields.'),      '#required' => TRUE,      '#size' => 25,    );  }  if ($admin) {    $form['account']['status'] = array(      '#type' => 'radios',      '#title' => t('Status'),      '#default_value' => isset($edit['status']) ? $edit['status'] : 1,      '#options' => array(t('Blocked'), t('Active'))    );  }  if (user_access('administer permissions')) {    $roles = user_roles(TRUE);    // The disabled checkbox subelement for the 'authenticated user' role    // must be generated separately and added to the checkboxes element,    // because of a limitation in D6 FormAPI not supporting a single disabled    // checkbox within a set of checkboxes.    // TODO: This should be solved more elegantly. See issue #119038.    $checkbox_authenticated = array(      '#type' => 'checkbox',      '#title' => $roles[DRUPAL_AUTHENTICATED_RID],      '#default_value' => TRUE,      '#disabled' => TRUE,    );    unset($roles[DRUPAL_AUTHENTICATED_RID]);    if ($roles) {      $default = empty($edit['roles']) ? array() : array_keys($edit['roles']);      $form['account']['roles'] = array(        '#type' => 'checkboxes',        '#title' => t('Roles'),        '#default_value' => $default,        '#options' => $roles,        DRUPAL_AUTHENTICATED_RID => $checkbox_authenticated,      );    }  }  // Signature:  if (variable_get('user_signatures', 0) && module_exists('comment') && !$register) {    $form['signature_settings'] = array(      '#type' => 'fieldset',      '#title' => t('Signature settings'),      '#weight' => 1,    );    $form['signature_settings']['signature'] = array(      '#type' => 'textarea',      '#title' => t('Signature'),      '#default_value' => $edit['signature'],      '#description' => t('Your signature will be publicly displayed at the end of your comments.'),    );    // Prevent a "validation error" message when the user attempts to save with a default value they    // do not have access to.    if (!filter_access($edit['signature_format']) && empty($_POST)) {      drupal_set_message(t("The signature input format has been set to a format you don't have access to. It will be changed to a format you have access to when you save this page."));      $edit['signature_format'] = FILTER_FORMAT_DEFAULT;    }    $form['signature_settings']['signature_format'] = filter_form($edit['signature_format'], NULL, array('signature_format'));  }  // Picture/avatar:  if (variable_get('user_pictures', 0) && !$register) {    $form['picture'] = array('#type' => 'fieldset', '#title' => t('Picture'), '#weight' => 1);    $picture = theme('user_picture', (object)$edit);    if ($edit['picture']) {      $form['picture']['current_picture'] = array('#value' => $picture);      $form['picture']['picture_delete'] = array('#type' => 'checkbox', '#title' => t('Delete picture'), '#description' => t('Check this box to delete your current picture.'));    }    else {      $form['picture']['picture_delete'] = array('#type' => 'hidden');    }    $form['picture']['picture_upload'] = array('#type' => 'file', '#title' => t('Upload picture'), '#size' => 48, '#description' => t('Your virtual face or picture. Maximum dimensions are %dimensions and the maximum size is %size kB.', array('%dimensions' => variable_get('user_picture_dimensions', '85x85'), '%size' => variable_get('user_picture_file_size', '30'))) .' '. variable_get('user_picture_guidelines', ''));    $form['#validate'][] = 'user_profile_form_validate';    $form['#validate'][] = 'user_validate_picture';  }  $form['#uid'] = $uid;  return $form;}function _user_edit_validate($uid, &$edit) {  // Validate the username when: new user account; or user is editing own account and can change username; or an admin user.  if (!$uid || ($GLOBALS['user']->uid == $uid && user_access('change own username')) || user_access('administer users')) {    if ($error = user_validate_name($edit['name'])) {      form_set_error('name', $error);    }    else if (db_result(db_query("SELECT COUNT(*) FROM {users} WHERE uid != %d AND LOWER(name) = LOWER('%s')", $uid, $edit['name'])) > 0) {      form_set_error('name', t('The name %name is already taken.', array('%name' => $edit['name'])));    }    else if (drupal_is_denied('user', $edit['name'])) {      form_set_error('name', t('The name %name has been denied access.', array('%name' => $edit['name'])));    }  }  // Validate the e-mail address:  if ($error = user_validate_mail($edit['mail'])) {    form_set_error('mail', $error);  }  else if (db_result(db_query("SELECT COUNT(*) FROM {users} WHERE uid != %d AND LOWER(mail) = LOWER('%s')", $uid, $edit['mail'])) > 0) {    form_set_error('mail', t('The e-mail address %email is already registered. <a href="@password">Have you forgotten your password?</a>', array('%email' => $edit['mail'], '@password' => url('user/password'))));  }  else if (drupal_is_denied('mail', $edit['mail'])) {    form_set_error('mail', t('The e-mail address %email has been denied access.', array('%email' => $edit['mail'])));  }}function _user_edit_submit($uid, &$edit) {  $account = user_load($uid);  // Delete picture if requested, and if no replacement picture was given.  if (!empty($edit['picture_delete'])) {    if ($account->picture && file_exists($account->picture)) {      file_delete($account->picture);    }    $edit['picture'] = '';  }  if (isset($edit['roles'])) {    $edit['roles'] = array_filter($edit['roles']);  }}/** * Delete a user. * * @param $edit An array of submitted form values. * @param $uid The user ID of the user to delete. */function user_delete($edit, $uid) {  $account = user_load(array('uid' => $uid));  sess_destroy_uid($uid);  _user_mail_notify('status_deleted', $account);  db_query('DELETE FROM {users} WHERE uid = %d', $uid);  db_query('DELETE FROM {users_roles} WHERE uid = %d', $uid);  db_query('DELETE FROM {authmap} WHERE uid = %d', $uid);  $variables = array('%name' => $account->name, '%email' => '<'. $account->mail .'>');  watchdog('user', 'Deleted user: %name %email.', $variables, WATCHDOG_NOTICE);  user_module_invoke('delete', $edit, $account);}/** * Builds a structured array representing the profile content. * * @param $account *   A user object. * * @return *   A structured array containing the individual elements of the profile. */function user_build_content(&$account) {  $edit = NULL;  user_module_invoke('view', $edit, $account);  // Allow modules to modify the fully-built profile.  drupal_alter('profile', $account);  return $account->content;}/** * Implementation of hook_mail(). */function user_mail($key, &$message, $params) {  $language = $message['language'];  $variables = user_mail_tokens($params['account'], $language);  $message['subject'] .= _user_mail_text($key .'_subject', $language, $variables);  $message['body'][] = _user_mail_text($key .'_body', $language, $variables);}/** * Returns a mail string for a variable name. * * Used by user_mail() and the settings forms to retrieve strings. */function _user_mail_text($key, $language = NULL, $variables = array()) {  $langcode = isset($language) ? $language->language : NULL;  if ($admin_setting = variable_get('user_mail_'. $key, FALSE)) {    // An admin setting overrides the default string.    return strtr($admin_setting, $variables);  }  else {    // No override, return default string.    switch ($key) {      case 'register_no_approval_required_subject':        return t('Account details for !username at !site', $variables, $langcode);      case 'register_no_approval_required_body':        return t("!username,\n\nThank you for registering at !site. You may now log in to !login_uri using the following username and password:\n\nusername: !username\npassword: !password\n\nYou may also log in by clicking on this link or copying and pasting it in your browser:\n\n!login_url\n\nThis is a one-time login, so it can be used only once.\n\nAfter logging in, you will be redirected to !edit_uri so you can change your password.\n\n\n--  !site team", $variables, $langcode);      case 'register_admin_created_subject':        return t('An administrator created an account for you at !site', $variables, $langcode);      case 'register_admin_created_body':        return t("!username,\n\nA site administrator at !site has created an account for you. You may now log in to !login_uri using the following username and password:\n\nusername: !username\npassword: !password\n\nYou may also log in by clicking on this link or copying and pasting it in your browser:\n\n!login_url\n\nThis is a one-time login, so it can be used only once.\n\nAfter logging in, you will be redirected to !edit_uri so you can change your password.\n\n\n--  !site team", $variables, $langcode);      case 'register_pending_approval_subject':      case 'register_pending_approval_admin_subject':        return t('Account details for !username at !site (pending admin approval)', $variables, $langcode);      case 'register_pending_approval_body':        return t("!username,\n\nThank you for registering at !site. Your application for an account is currently pending approval. Once it has been approved, you will receive another e-mail containing information about how to log in, set your password, and other details.\n\n\n--  !site team", $variables, $langcode);      case 'register_pending_approval_admin_body':        return t("!username has applied for an account.\n\n!edit_uri", $variables, $langcode);      case 'password_reset_subject':        return t('Replacement login information for !username at !site', $variables, $langcode);      case 'password_reset_body':        return t("!username,\n\nA request to reset the password for your account has been made at !site.\n\nYou may now log in to !uri_brief by clicking on this link or copying and pasting it in your browser:\n\n!login_url\n\nThis is a one-time login, so it can be used only once. It expires after one day and nothing will happen if it's not used.\n\nAfter logging in, you will be redirected to !edit_uri so you can change your password.", $variables, $langcode);      case 'status_activated_subject':        return t('Account details for !username at !site (approved)', $variables, $langcode);      case 'status_activated_body':        return t("!username,\n\nYour account at !site has been activated.\n\nYou may now log in by clicking on this link or copying and pasting it in your browser:\n\n!login_url\n\nThis is a one-time login, so it can be used only once.\n\nAfter logging in, you will be redirected to !edit_uri so you can change your password.\n\nOnce you have set your own password, you will be able to log in to !login_uri in the future using:\n\nusername: !username\n", $variables, $langcode);      case 'status_blocked_subject':        return t('Account details for !username at !site (blocked)', $variables, $langcode);      case 'status_blocked_body':        return t("!username,\n\nYour account on !site has been blocked.", $variables, $langcode);      case 'status_deleted_subject':        return t('Account details for !username at !site (deleted)', $variables, $langcode);      case 'status_deleted_body':        return t("!username,\n\nYour account on !site has been deleted.", $variables, $langcode);    }  }}/*** Administrative features ***********************************************//** * Retrieve an array of roles matching specified conditions. * * @param $membersonly *   Set this to TRUE to exclude the 'anonymous' role. * @param $permission *   A string containing a permission. If set, only roles containing that *   permission are returned. * * @return *   An associative array with the role id as the key and the role name as *   value. */function user_roles($membersonly = FALSE, $permission = NULL) {  // System roles take the first two positions.  $roles = array(    DRUPAL_ANONYMOUS_RID => NULL,    DRUPAL_AUTHENTICATED_RID => NULL,  );  if (!empty($permission)) {    $result = db_query("SELECT r.* FROM {role} r INNER JOIN {permission} p ON r.rid = p.rid WHERE p.perm LIKE '%%%s%%' ORDER BY r.name", $permission);  }  else {    $result = db_query('SELECT * FROM {role} ORDER BY name');  }  while ($role = db_fetch_object($result)) {    switch ($role->rid) {      // We only translate the built in role names      case DRUPAL_ANONYMOUS_RID:        if (!$membersonly) {          $roles[$role->rid] = t($role->name);        }        break;      case DRUPAL_AUTHENTICATED_RID:        $roles[$role->rid] = t($role->name);        break;      default:        $roles[$role->rid] = $role->name;    }  }  // Filter to remove unmatched system roles.  return array_filter($roles);}/** * Implementation of hook_user_operations(). */function user_user_operations($form_state = array()) {  $operations = array(    'unblock' => array(      'label' => t('Unblock the selected users'),      'callback' => 'user_user_operations_unblock',    ),    'block' => array(      'label' => t('Block the selected users'),      'callback' => 'user_user_operations_block',    ),    'delete' => array(      'label' => t('Delete the selected users'),    ),  );  if (user_access('administer permissions')) {    $roles = user_roles(TRUE);    unset($roles[DRUPAL_AUTHENTICATED_RID]);  // Can't edit authenticated role.    $add_roles = array();    foreach ($roles as $key => $value) {      $add_roles['add_role-'. $key] = $value;    }    $remove_roles = array();    foreach ($roles as $key => $value) {      $remove_roles['remove_role-'. $key] = $value;    }    if (count($roles)) {      $role_operations = array(        t('Add a role to the selected users') => array(          'label' => $add_roles,        ),        t('Remove a role from the selected users') => array(          'label' => $remove_roles,        ),      );      $operations += $role_operations;    }  }  // If the form has been posted, we need to insert the proper data for  // role editing if necessary.  if (!empty($form_state['submitted'])) {    $operation_rid = explode('-', $form_state['values']['operation']);    $operation = $operation_rid[0];    if ($operation == 'add_role' || $operation == 'remove_role') {      $rid = $operation_rid[1];      if (user_access('administer permissions')) {        $operations[$form_state['values']['operation']] = array(          'callback' => 'user_multiple_role_edit',          'callback arguments' => array($operation, $rid),        );      }      else {        watchdog('security', 'Detected malicious attempt to alter protected user fields.', array(), WATCHDOG_WARNING);        return;      }    }  }  return $operations;}/** * Callback function for admin mass unblocking users. */function user_user_operations_unblock($accounts) {  foreach ($accounts as $uid) {    $account = user_load(array('uid' => (int)$uid));    // Skip unblocking user if they are already unblocked.    if ($account !== FALSE && $account->status == 0) {      user_save($account, array('status' => 1));    }  }}/** * Callback function for admin mass blocking users. */function user_user_operations_block($accounts) {  foreach ($accounts as $uid) {    $account = user_load(array('uid' => (int)$uid));    // Skip blocking user if they are already blocked.    if ($account !== FALSE && $account->status == 1) {      user_save($account, array('status' => 0));    }  }}/** * Callback function for admin mass adding/deleting a user role. */function user_multiple_role_edit($accounts, $operation, $rid) {  // The role name is not necessary as user_save() will reload the user  // object, but some modules' hook_user() may look at this first.  $role_name = db_result(db_query('SELECT name FROM {role} WHERE rid = %d', $rid));  switch ($operation) {    case 'add_role':      foreach ($accounts as $uid) {        $account = user_load(array('uid' => (int)$uid));        // Skip adding the role to the user if they already have it.        if ($account !== FALSE && !isset($account->roles[$rid])) {          $roles = $account->roles + array($rid => $role_name);          user_save($account, array('roles' => $roles));        }      }      break;    case 'remove_role':      foreach ($accounts as $uid) {        $account = user_load(array('uid' => (int)$uid));        // Skip removing the role from the user if they already don't have it.        if ($account !== FALSE && isset($account->roles[$rid])) {          $roles = array_diff($account->roles, array($rid => $role_name));          user_save($account, array('roles' => $roles));        }      }      break;  }}function user_multiple_delete_confirm(&$form_state) {  $edit = $form_state['post'];  $form['accounts'] = array('#prefix' => '<ul>', '#suffix' => '</ul>', '#tree' => TRUE);  // array_filter() returns only elements with TRUE values.  foreach (array_filter($edit['accounts']) as $uid => $value) {    $user = db_result(db_query('SELECT name FROM {users} WHERE uid = %d', $uid));    $form['accounts'][$uid] = array('#type' => 'hidden', '#value' => $uid, '#prefix' => '<li>', '#suffix' => check_plain($user) ."</li>\n");  }  $form['operation'] = array('#type' => 'hidden', '#value' => 'delete');  return confirm_form($form,                      t('Are you sure you want to delete these users?'),                      'admin/user/user', t('This action cannot be undone.'),                      t('Delete all'), t('Cancel'));}function user_multiple_delete_confirm_submit($form, &$form_state) {  if ($form_state['values']['confirm']) {    foreach ($form_state['values']['accounts'] as $uid => $value) {      user_delete($form_state['values'], $uid);    }    drupal_set_message(t('The users have been deleted.'));  }  $form_state['redirect'] = 'admin/user/user';  return;}/** * Implementation of hook_help(). */function user_help($path, $arg) {  global $user;  switch ($path) {    case 'admin/help#user':      $output = '<p>'. t('The user module allows users to register, login, and log out. Users benefit from being able to sign on because it associates content they create with their account and allows various permissions to be set for their roles. The user module supports user roles which establish fine grained permissions allowing each role to do only what the administrator wants them to. Each user is assigned to one or more roles. By default there are two roles <em>anonymous</em> - a user who has not logged in, and <em>authenticated</em> a user who has signed up and who has been authorized.') .'</p>';      $output .= '<p>'. t("Users can use their own name or handle and can specify personal configuration settings through their individual <em>My account</em> page. Users must authenticate by supplying a local username and password or through their OpenID, an optional and secure method for logging into many websites with a single username and password. In some configurations, users may authenticate using a username and password from another Drupal site, or through some other site-specific mechanism.") .'</p>';      $output .= '<p>'. t('A visitor accessing your website is assigned a unique ID, or session ID, which is stored in a cookie. The cookie does not contain personal information, but acts as a key to retrieve information from your site. Users should have cookies enabled in their web browser when using your site.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@user">User module</a>.', array('@user' => 'http://drupal.org/handbook/modules/user/')) .'</p>';      return $output;    case 'admin/user/user':      return '<p>'. t('Drupal allows users to register, login, log out, maintain user profiles, etc. Users of the site may not use their own names to post content until they have signed up for a user account.') .'</p>';    case 'admin/user/user/create':    case 'admin/user/user/account/create':      return '<p>'. t("This web page allows administrators to register new users. Users' e-mail addresses and usernames must be unique.") .'</p>';    case 'admin/user/rules':      return '<p>'. t('Set up username and e-mail address access rules for new <em>and</em> existing accounts (currently logged in accounts will not be logged out). If a username or e-mail address for an account matches any deny rule, but not an allow rule, then the account will not be allowed to be created or to log in. A host rule is effective for every page view, not just registrations.') .'</p>';    case 'admin/user/permissions':      return '<p>'. t('Permissions let you control what users can do on your site. Each user role (defined on the <a href="@role">user roles page</a>) has its own set of permissions. For example, you could give users classified as "Administrators" permission to "administer nodes" but deny this power to ordinary, "authenticated" users. You can use permissions to reveal new features to privileged users (those with subscriptions, for example). Permissions also allow trusted users to share the administrative burden of running a busy site.', array('@role' => url('admin/user/roles'))) .'</p>';    case 'admin/user/roles':      return t('<p>Roles allow you to fine tune the security and administration of Drupal. A role defines a group of users that have certain privileges as defined in <a href="@permissions">user permissions</a>. Examples of roles include: anonymous user, authenticated user, moderator, administrator and so on. In this area you will define the <em>role names</em> of the various roles. To delete a role choose "edit".</p><p>By default, Drupal comes with two user roles:</p>      <ul>      <li>Anonymous user: this role is used for users that don\'t have a user account or that are not authenticated.</li>      <li>Authenticated user: this role is automatically granted to all logged in users.</li>      </ul>', array('@permissions' => url('admin/user/permissions')));    case 'admin/user/search':      return '<p>'. t('Enter a simple pattern ("*" may be used as a wildcard match) to search for a username or e-mail address. For example, one may search for "br" and Drupal might return "brian", "brad", and "brenda@example.com".') .'</p>';  }}/** * Retrieve a list of all user setting/information categories and sort them by weight. */function _user_categories($account) {  $categories = array();  // Only variables can be passed by reference workaround.  $null = NULL;  foreach (module_list() as $module) {    $function = $module .'_user';    // $null and $account need to be passed by reference.    if (function_exists($function) && ($data = $function('categories', $null, $account, ''))) {      $categories = array_merge($data, $categories);    }  }  usort($categories, '_user_sort');  return $categories;}function _user_sort($a, $b) {  $a = (array)$a + array('weight' => 0, 'title' => '');  $b = (array)$b + array('weight' => 0, 'title' => '');  return $a['weight'] < $b['weight'] ? -1 : ($a['weight'] > $b['weight'] ? 1 : ($a['title'] < $b['title'] ? -1 : 1));}/** * List user administration filters that can be applied. */function user_filters() {  // Regular filters  $filters = array();  $roles = user_roles(TRUE);  unset($roles[DRUPAL_AUTHENTICATED_RID]); // Don't list authorized role.  if (count($roles)) {    $filters['role'] = array(      'title' => t('role'),      'where' => "ur.rid = %d",      'options' => $roles,      'join' => '',    );  }  $options = array();  foreach (module_list() as $module) {    if ($permissions = module_invoke($module, 'perm')) {      asort($permissions);      foreach ($permissions as $permission) {        $options[t('@module module', array('@module' => $module))][$permission] = t($permission);      }    }  }  ksort($options);  $filters['permission'] = array(    'title' => t('permission'),    'join' => 'LEFT JOIN {permission} p ON ur.rid = p.rid',    'where' => " ((p.perm IS NOT NULL AND p.perm LIKE '%%%s%%') OR u.uid = 1) ",    'options' => $options,  );  $filters['status'] = array(    'title' => t('status'),    'where' => 'u.status = %d',    'join' => '',    'options' => array(1 => t('active'), 0 => t('blocked')),  );  return $filters;}/** * Build query for user administration filters based on session. */function user_build_filter_query() {  $filters = user_filters();  // Build query  $where = $args = $join = array();  foreach ($_SESSION['user_overview_filter'] as $filter) {    list($key, $value) = $filter;    // This checks to see if this permission filter is an enabled permission for    // the authenticated role. If so, then all users would be listed, and we can    // skip adding it to the filter query.    if ($key == 'permission') {      $account = new stdClass();      $account->uid = 'user_filter';      $account->roles = array(DRUPAL_AUTHENTICATED_RID => 1);      if (user_access($value, $account)) {        continue;      }    }    $where[] = $filters[$key]['where'];    $args[] = $value;    $join[] = $filters[$key]['join'];  }  $where = !empty($where) ? 'AND '. implode(' AND ', $where) : '';  $join = !empty($join) ? ' '. implode(' ', array_unique($join)) : '';  return array('where' => $where,           'join' => $join,           'args' => $args,         );}/** * Implementation of hook_forms(). */function user_forms() {  $forms['user_admin_access_add_form']['callback'] = 'user_admin_access_form';  $forms['user_admin_access_edit_form']['callback'] = 'user_admin_access_form';  $forms['user_admin_new_role']['callback'] = 'user_admin_role';  return $forms;}/** * Implementation of hook_comment(). */function user_comment(&$comment, $op) {  // Validate signature.  if ($op == 'view') {    if (variable_get('user_signatures', 0) && !empty($comment->signature)) {      $comment->signature = check_markup($comment->signature, $comment->signature_format, FALSE);    }    else {      $comment->signature = '';    }  }}/** * Theme output of user signature. * * @ingroup themeable */function theme_user_signature($signature) {  $output = '';  if ($signature) {    $output .= '<div class="clear">';    $output .= '<div></div>';    $output .= $signature;    $output .= '</div>';  }  return $output;}/** * Return an array of token to value mappings for user e-mail messages. * * @param $account *  The user object of the account being notified.  Must contain at *  least the fields 'uid', 'name', and 'mail'. * @param $language *  Language object to generate the tokens with. * @return *  Array of mappings from token names to values (for use with strtr()). */function user_mail_tokens($account, $language) {  global $base_url;  $tokens = array(    '!username' => $account->name,    '!site' => variable_get('site_name', 'Drupal'),    '!login_url' => user_pass_reset_url($account),    '!uri' => $base_url,    '!uri_brief' => preg_replace('!^https?://!', '', $base_url),    '!mailto' => $account->mail,    '!date' => format_date(time(), 'medium', '', NULL, $language->language),    '!login_uri' => url('user', array('absolute' => TRUE, 'language' => $language)),    '!edit_uri' => url('user/'. $account->uid .'/edit', array('absolute' => TRUE, 'language' => $language)),  );  if (!empty($account->password)) {    $tokens['!password'] = $account->password;  }  return $tokens;}/** * Get the language object preferred by the user. This user preference can * be set on the user account editing page, and is only available if there * are more than one languages enabled on the site. If the user did not * choose a preferred language, or is the anonymous user, the $default * value, or if it is not set, the site default language will be returned. * * @param $account *   User account to look up language for. * @param $default *   Optional default language object to return if the account *   has no valid language. */function user_preferred_language($account, $default = NULL) {  $language_list = language_list();  if (!empty($account->language) && isset($language_list[$account->language])) {    return $language_list[$account->language];  }  else {    return $default ? $default : language_default();  }}/** * Conditionally create and send a notification email when a certain * operation happens on the given user account. * * @see user_mail_tokens() * @see drupal_mail() * * @param $op *  The operation being performed on the account.  Possible values: *  'register_admin_created': Welcome message for user created by the admin *  'register_no_approval_required': Welcome message when user self-registers *  'register_pending_approval': Welcome message, user pending admin approval *  'password_reset': Password recovery request *  'status_activated': Account activated *  'status_blocked': Account blocked *  'status_deleted': Account deleted * * @param $account *  The user object of the account being notified.  Must contain at *  least the fields 'uid', 'name', and 'mail'. * @param $language *  Optional language to use for the notification, overriding account language. * @return *  The return value from drupal_mail_send(), if ends up being called. */function _user_mail_notify($op, $account, $language = NULL) {  // By default, we always notify except for deleted and blocked.  $default_notify = ($op != 'status_deleted' && $op != 'status_blocked');  $notify = variable_get('user_mail_'. $op .'_notify', $default_notify);  if ($notify) {    $params['account'] = $account;    $language = $language ? $language : user_preferred_language($account);    $mail = drupal_mail('user', $op, $account->mail, $language, $params);    if ($op == 'register_pending_approval') {      // If a user registered requiring admin approval, notify the admin, too.      // We use the site default language for this.      drupal_mail('user', 'register_pending_approval_admin', variable_get('site_mail', ini_get('sendmail_from')), language_default(), $params);    }  }  return empty($mail) ? NULL : $mail['result'];}/** * Add javascript and string translations for dynamic password validation * (strength and confirmation checking). * * This is an internal function that makes it easier to manage the translation * strings that need to be passed to the javascript code. */function _user_password_dynamic_validation() {  static $complete = FALSE;  global $user;  // Only need to do once per page.  if (!$complete) {    drupal_add_js(drupal_get_path('module', 'user') .'/user.js', 'module');    drupal_add_js(array(      'password' => array(        'strengthTitle' => t('Password strength:'),        'lowStrength' => t('Low'),        'mediumStrength' => t('Medium'),        'highStrength' => t('High'),        'tooShort' => t('It is recommended to choose a password that contains at least six characters. It should include numbers, punctuation, and both upper and lowercase letters.'),        'needsMoreVariation' => t('The password does not include enough variation to be secure. Try:'),        'addLetters' => t('Adding both upper and lowercase letters.'),        'addNumbers' => t('Adding numbers.'),        'addPunctuation' => t('Adding punctuation.'),        'sameAsUsername' => t('It is recommended to choose a password different from the username.'),        'confirmSuccess' => t('Yes'),        'confirmFailure' => t('No'),        'confirmTitle' => t('Passwords match:'),        'username' => (isset($user->name) ? $user->name : ''))),      'setting');    $complete = TRUE;  }}/** * Implementation of hook_hook_info(). */function user_hook_info() {  return array(    'user' => array(      'user' => array(        'insert' => array(          'runs when' => t('After a user account has been created'),        ),        'update' => array(          'runs when' => t("After a user's profile has been updated"),        ),        'delete' => array(          'runs when' => t('After a user has been deleted')        ),        'login' => array(          'runs when' => t('After a user has logged in')        ),        'logout' => array(          'runs when' => t('After a user has logged out')        ),        'view' => array(          'runs when' => t("When a user's profile is being viewed")        ),      ),    ),  );}/** * Implementation of hook_action_info(). */function user_action_info() {  return array(    'user_block_user_action' => array(      'description' => t('Block current user'),      'type' => 'user',      'configurable' => FALSE,      'hooks' => array(),    ),    'user_block_ip_action' => array(      'description' => t('Ban IP address of current user'),      'type' => 'user',      'configurable' => FALSE,      'hooks' => array(),    ),  );}/** * Implementation of a Drupal action. * Blocks the current user. */function user_block_user_action(&$object, $context = array()) {  if (isset($object->uid)) {    $uid = $object->uid;  }  elseif (isset($context['uid'])) {    $uid = $context['uid'];  }  else {    global $user;    $uid = $user->uid;  }  db_query("UPDATE {users} SET status = 0 WHERE uid = %d", $uid);  sess_destroy_uid($uid);  watchdog('action', 'Blocked user %name.', array('%name' => check_plain($user->name)));}/** * Implementation of a Drupal action. * Adds an access rule that blocks the user's IP address. */function user_block_ip_action() {  $ip = ip_address();  db_query("INSERT INTO {access} (mask, type, status) VALUES ('%s', '%s', %d)", $ip, 'host', 0);  watchdog('action', 'Banned IP address %ip', array('%ip' => $ip));}/** * Submit handler for the user registration form. * * This function is shared by the installation form and the normal registration form, * which is why it can't be in the user.pages.inc file. */function user_register_submit($form, &$form_state) {  global $base_url;  $admin = user_access('administer users');  $mail = $form_state['values']['mail'];  $name = $form_state['values']['name'];  if (!variable_get('user_email_verification', TRUE) || $admin) {    $pass = $form_state['values']['pass'];  }  else {    $pass = user_password();  };  $notify = isset($form_state['values']['notify']) ? $form_state['values']['notify'] : NULL;  $from = variable_get('site_mail', ini_get('sendmail_from'));  if (isset($form_state['values']['roles'])) {    // Remove unset roles.    $roles = array_filter($form_state['values']['roles']);  }  else {    $roles = array();  }  if (!$admin && array_intersect(array_keys($form_state['values']), array('uid', 'roles', 'init', 'session', 'status'))) {    watchdog('security', 'Detected malicious attempt to alter protected user fields.', array(), WATCHDOG_WARNING);    $form_state['redirect'] = 'user/register';    return;  }  // The unset below is needed to prevent these form values from being saved as  // user data.  unset($form_state['values']['form_token'], $form_state['values']['submit'], $form_state['values']['op'], $form_state['values']['notify'], $form_state['values']['form_id'], $form_state['values']['affiliates'], $form_state['values']['destination']);  $merge_data = array('pass' => $pass, 'init' => $mail, 'roles' => $roles);  if (!$admin) {    // Set the user's status because it was not displayed in the form.    $merge_data['status'] = variable_get('user_register', 1) == 1;  }  $account = user_save('', array_merge($form_state['values'], $merge_data));  // Terminate if an error occured during user_save().  if (!$account) {    drupal_set_message(t("Error saving user account."), 'error');    $form_state['redirect'] = '';    return;  }  $form_state['user'] = $account;  watchdog('user', 'New user: %name (%email).', array('%name' => $name, '%email' => $mail), WATCHDOG_NOTICE, l(t('edit'), 'user/'. $account->uid .'/edit'));  // The first user may login immediately, and receives a customized welcome e-mail.  if ($account->uid == 1) {    drupal_set_message(t('Welcome to Drupal. You are now logged in as user #1, which gives you full control over your website.'));    if (variable_get('user_email_verification', TRUE)) {      drupal_set_message(t('</p><p> Your password is <strong>%pass</strong>. You may change your password below.</p>', array('%pass' => $pass)));    }    user_authenticate(array_merge($form_state['values'], $merge_data));    $form_state['redirect'] = 'user/1/edit';    return;  }  else {    // Add plain text password into user account to generate mail tokens.    $account->password = $pass;    if ($admin && !$notify) {      drupal_set_message(t('Created a new user account for <a href="@url">%name</a>. No e-mail has been sent.', array('@url' => url("user/$account->uid"), '%name' => $account->name)));    }    else if (!variable_get('user_email_verification', TRUE) && $account->status && !$admin) {      // No e-mail verification is required, create new user account, and login      // user immediately.      _user_mail_notify('register_no_approval_required', $account);      if (user_authenticate(array_merge($form_state['values'], $merge_data))) {        drupal_set_message(t('Registration successful. You are now logged in.'));      }      $form_state['redirect'] = '';      return;    }    else if ($account->status || $notify) {      // Create new user account, no administrator approval required.      $op = $notify ? 'register_admin_created' : 'register_no_approval_required';      _user_mail_notify($op, $account);      if ($notify) {        drupal_set_message(t('Password and further instructions have been e-mailed to the new user <a href="@url">%name</a>.', array('@url' => url("user/$account->uid"), '%name' => $account->name)));      }      else {        drupal_set_message(t('Your password and further instructions have been sent to your e-mail address.'));        $form_state['redirect'] = '';        return;      }    }    else {      // Create new user account, administrator approval required.      _user_mail_notify('register_pending_approval', $account);      drupal_set_message(t('Thank you for applying for an account. Your account is currently pending approval by the site administrator.<br />In the meantime, a welcome message with further instructions has been sent to your e-mail address.'));      $form_state['redirect'] = '';      return;    }  }}/** * Form builder; The user registration form. * * @ingroup forms * @see user_register_validate() * @see user_register_submit() */function user_register() {  global $user;  $admin = user_access('administer users');  // If we aren't admin but already logged on, go to the user page instead.  if (!$admin && $user->uid) {    drupal_goto('user/'. $user->uid);  }  $form = array();  // Display the registration form.  if (!$admin) {    $form['user_registration_help'] = array(      '#value' => filter_xss_admin(variable_get('user_registration_help', '')),      // Ensure that user registration help appears above profile fields.      '#weight' => -20,    );  }  // Merge in the default user edit fields.  $form = array_merge($form, user_edit_form($form_state, NULL, NULL, TRUE));  if ($admin) {    $form['account']['notify'] = array(     '#type' => 'checkbox',     '#title' => t('Notify user of new account')    );    // Redirect back to page which initiated the create request;    // usually admin/user/user/create.    $form['destination'] = array('#type' => 'hidden', '#value' => $_GET['q']);  }  // Create a dummy variable for pass-by-reference parameters.  $null = NULL;  $extra = _user_forms($null, NULL, NULL, 'register');  // Remove form_group around default fields if there are no other groups.  if (!$extra) {    foreach (array('name', 'mail', 'pass', 'status', 'roles', 'notify') as $key) {      if (isset($form['account'][$key])) {        $form[$key] = $form['account'][$key];      }    }    unset($form['account']);  }  else {    $form = array_merge($form, $extra);  }  if (variable_get('configurable_timezones', 1)) {    // Override field ID, so we only change timezone on user registration,    // and never touch it on user edit pages.    $form['timezone'] = array(      '#type' => 'hidden',      '#default_value' => variable_get('date_default_timezone', NULL),      '#id' => 'edit-user-register-timezone',    );    // Add the JavaScript callback to automatically set the timezone.    drupal_add_js('// Global Killswitchif (Drupal.jsEnabled) {  $(document).ready(function() {    Drupal.setDefaultTimezone();  });}', 'inline');  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Create new account'), '#weight' => 30);  $form['#validate'][] = 'user_register_validate';  return $form;}function user_register_validate($form, &$form_state) {  user_module_invoke('validate', $form_state['values'], $form_state['values'], 'account');}/** * Retrieve a list of all form elements for the specified category. */function _user_forms(&$edit, $account, $category, $hook = 'form') {  $groups = array();  foreach (module_list() as $module) {    $function = $module .'_user';    // $edit and $account need to be passed by reference.    if (function_exists($function) && ($data = $function($hook, $edit, $account, $category))) {      $groups = array_merge_recursive($data, $groups);    }  }  uasort($groups, '_user_sort');  return empty($groups) ? FALSE : $groups;}
<?php// $Id$/** * @file *   Add language handling functionality and enables the translation of the *   user interface to languages other than English. * *   When enabled, multiple languages can be set up. The site interface *   can be displayed in different languages, as well as nodes can have languages *   assigned. The setup of languages and translations is completely web based. *   Gettext portable object files are supported. */// ---------------------------------------------------------------------------------// Hook implementations/** * Implementation of hook_help(). */function locale_help($path, $arg) {  switch ($path) {    case 'admin/help#locale':      $output = '<p>'. t('The locale module allows your Drupal site to be presented in languages other than the default English, a defining feature of multi-lingual websites. The locale module works by examining text as it is about to be displayed: when a translation of the text is available in the language to be displayed, the translation is displayed rather than the original text. When a translation is unavailable, the original text is displayed, and then stored for later review by a translator.') .'</p>';      $output .= '<p>'. t('Beyond translation of the Drupal interface, the locale module provides a feature set tailored to the needs of a multi-lingual site. Language negotiation allows your site to automatically change language based on the domain or path used for each request. Users may (optionally) select their preferred language on their <em>My account</em> page, and your site can be configured to honor a web browser\'s preferred language settings. Your site content can be created in (and translated to) any enabled language, and each post may have a language-appropriate alias for each of its translations. The locale module works in concert with the <a href="@content-help">content translation module</a> to manage translated content.', array('@content-help' => url('admin/help/translation'))) .'</p>';      $output .= '<p>'. t('Translations may be provided by:') .'</p>';      $output .= '<ul><li>'. t("translating the original text via the locale module's integrated web interface, or") .'</li>';      $output .= '<li>'. t('importing files from a set of existing translations, known as a translation package. A translation package enables the display of a specific version of Drupal in a specific language, and contain files in the Gettext Portable Object (<em>.po</em>) format. Although not all languages are available for every version of Drupal, translation packages for many languages are available for download from the <a href="@translations">Drupal translation page</a>.', array('@translations' => 'http://drupal.org/project/translations')) .'</li></ul>';      $output .= '<p>'. t('If an existing translation package does not meet your needs, the Gettext Portable Object (<em>.po</em>) files within a package may be modified, or new <em>.po</em> files may be created, using a desktop Gettext editor. The locale module\'s <a href="@import">import</a> feature allows the translated strings from a new or modified <em>.po</em> file to be added to your site. The locale module\'s <a href="@export">export</a> feature generates files from your site\'s translated strings, that can either be shared with others or edited offline by a Gettext translation editor.', array('@import' => url('admin/build/translate/import'), '@export' => url('admin/build/translate/export'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@locale">Locale module</a>.', array('@locale' => 'http://drupal.org/handbook/modules/locale/')) .'</p>';      return $output;    case 'admin/settings/language':      $output = '<p>'. t("This page provides an overview of your site's enabled languages. If multiple languages are available and enabled, the text on your site interface may be translated, registered users may select their preferred language on the <em>My account</em> page, and site authors may indicate a specific language when creating posts. The site's default language is used for anonymous visitors and for users who have not selected a preferred language.") .'</p>';      $output .= '<p>'. t('For each language available on the site, use the <em>edit</em> link to configure language details, including name, an optional language-specific path or domain, and whether the language is natively presented either left-to-right or right-to-left. These languages also appear in the <em>Language</em> selection when creating a post of a content type with multilingual support.') .'</p>';      $output .= '<p>'. t('Use the <a href="@add-language">add language page</a> to enable additional languages (and automatically import files from a translation package, if available), the <a href="@search">translate interface page</a> to locate strings for manual translation, or the <a href="@import">import page</a> to add translations from individual <em>.po</em> files. A number of contributed translation packages containing <em>.po</em> files are available on the <a href="@translations">Drupal.org translations page</a>.', array('@add-language' => url('admin/settings/language/add'), '@search' => url('admin/build/translate/search'), '@import' => url('admin/build/translate/import'), '@translations' => 'http://drupal.org/project/translations')) .'</p>';      return $output;    case 'admin/settings/language/add':      return '<p>'. t('Add all languages to be supported by your site. If your desired language is not available in the <em>Language name</em> drop-down, click <em>Custom language</em> and provide a language code and other details manually. When providing a language code manually, be sure to enter a standardized language code, since this code may be used by browsers to determine an appropriate display language.') .'</p>';    case 'admin/settings/language/configure':      $output = '<p>'. t("Language negotiation settings determine the site's presentation language. Available options include:") .'</p>';      $output .= '<ul><li>'. t('<strong>None.</strong> The default language is used for site presentation, though users may (optionally) select a preferred language on the <em>My Account</em> page. (User language preferences will be used for site e-mails, if available.)') .'</li>';      $output .= '<li>'. t('<strong>Path prefix only.</strong> The presentation language is determined by examining the path for a language code or other custom string that matches the path prefix (if any) specified for each language. If a suitable prefix is not identified, the default language is used. <em>Example: "example.com/de/contact" sets presentation language to German based on the use of "de" within the path.</em>') .'</li>';      $output .= '<li>'. t("<strong>Path prefix with language fallback.</strong> The presentation language is determined by examining the path for a language code or other custom string that matches the path prefix (if any) specified for each language. If a suitable prefix is not identified, the display language is determined by the user's language preferences from the <em>My Account</em> page, or by the browser's language settings. If a presentation language cannot be determined, the default language is used.") .'</li>';      $output .= '<li>'. t('<strong>Domain name only.</strong> The presentation language is determined by examining the domain used to access the site, and comparing it to the language domain (if any) specified for each language. If a match is not identified, the default language is used. <em>Example: "http://de.example.com/contact" sets presentation language to German based on the use of "http://de.example.com" in the domain.</em>') .'</li></ul>';      $output .= '<p>'. t('The path prefix or domain name for a language may be set by editing the <a href="@languages">available languages</a>. In the absence of an appropriate match, the site is displayed in the <a href="@languages">default language</a>.', array('@languages' => url('admin/settings/language'))) .'</p>';      return $output;    case 'admin/build/translate':      $output = '<p>'. t('This page provides an overview of available translatable strings. Drupal displays translatable strings in text groups; modules may define additional text groups containing other translatable strings. Because text groups provide a method of grouping related strings, they are often used to focus translation efforts on specific areas of the Drupal interface.') .'</p>';      $output .= '<p>'. t('Review the <a href="@languages">languages page</a> for more information on adding support for additional languages.', array('@languages' => url('admin/settings/language'))) .'</p>';      return $output;    case 'admin/build/translate/import':      $output = '<p>'. t('This page imports the translated strings contained in an individual Gettext Portable Object (<em>.po</em>) file. Normally distributed as part of a translation package (each translation package may contain several <em>.po</em> files), a <em>.po</em> file may need to be imported after off-line editing in a Gettext translation editor. Importing an individual <em>.po</em> file may be a lengthy process.') .'</p>';      $output .= '<p>'. t('Note that the <em>.po</em> files within a translation package are imported automatically (if available) when new modules or themes are enabled, or as new languages are added. Since this page only allows the import of one <em>.po</em> file at a time, it may be simpler to download and extract a translation package into your Drupal installation directory and <a href="@language-add">add the language</a> (which automatically imports all <em>.po</em> files within the package). Translation packages are available for download on the <a href="@translations">Drupal translation page</a>.', array('@language-add' => url('admin/settings/language/add'), '@translations' => 'http://drupal.org/project/translations')) .'</p>';      return $output;    case 'admin/build/translate/export':      return '<p>'. t('This page exports the translated strings used by your site. An export file may be in Gettext Portable Object (<em>.po</em>) form, which includes both the original string and the translation (used to share translations with others), or in Gettext Portable Object Template (<em>.pot</em>) form, which includes the original strings only (used to create new translations with a Gettext translation editor).') .'</p>';    case 'admin/build/translate/search':      return '<p>'. t('This page allows a translator to search for specific translated and untranslated strings, and is used when creating or editing translations. (Note: For translation tasks involving many strings, it may be more convenient to <a href="@export">export</a> strings for off-line editing in a desktop Gettext translation editor.) Searches may be limited to strings found within a specific text group or in a specific language.', array('@export' => url('admin/build/translate/export'))) .'</p>';    case 'admin/build/block/configure':      if ($arg[4] == 'locale' && $arg[5] == 0) {        return '<p>'. t('This block is only shown if <a href="@languages">at least two languages are enabled</a> and <a href="@configuration">language negotiation</a> is set to something other than <em>None</em>.', array('@languages' => url('admin/settings/language'), '@configuration' => url('admin/settings/language/configure'))) .'</p>';      }      break;  }}/** * Implementation of hook_menu(). * * Locale module only provides administrative menu items, so all * menu items are invoked through locale_inc_callback(). */function locale_menu() {  // Manage languages  $items['admin/settings/language'] = array(    'title' => 'Languages',    'description' => 'Configure languages for content and the user interface.',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_languages_overview_form'),    'access arguments' => array('administer languages'),  );  $items['admin/settings/language/overview'] = array(    'title' => 'List',    'weight' => 0,    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/settings/language/add'] = array(    'title' => 'Add language',    'page callback' => 'locale_inc_callback',    'page arguments' => array('locale_languages_add_screen'), // two forms concatenated    'access arguments' => array('administer languages'),    'weight' => 5,    'type' => MENU_LOCAL_TASK,  );  $items['admin/settings/language/configure'] = array(    'title' => 'Configure',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_languages_configure_form'),    'access arguments' => array('administer languages'),    'weight' => 10,    'type' => MENU_LOCAL_TASK,  );  $items['admin/settings/language/edit/%'] = array(    'title' => 'Edit language',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_languages_edit_form', 4),    'access arguments' => array('administer languages'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/language/delete/%'] = array(    'title' => 'Confirm',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_languages_delete_form', 4),    'access arguments' => array('administer languages'),    'type' => MENU_CALLBACK,  );  // Translation functionality  $items['admin/build/translate'] = array(    'title' => 'Translate interface',    'description' => 'Translate the built in interface and optionally other text.',    'page callback' => 'locale_inc_callback',    'page arguments' => array('locale_translate_overview_screen'), // not a form, just a table    'access arguments' => array('translate interface'),  );  $items['admin/build/translate/overview'] = array(    'title' => 'Overview',    'weight' => 0,    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/build/translate/search'] = array(    'title' => 'Search',    'weight' => 10,    'type' => MENU_LOCAL_TASK,    'page callback' => 'locale_inc_callback',    'page arguments' => array('locale_translate_seek_screen'), // search results and form concatenated    'access arguments' => array('translate interface'),  );  $items['admin/build/translate/import'] = array(    'title' => 'Import',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_translate_import_form'),    'access arguments' => array('translate interface'),    'weight' => 20,    'type' => MENU_LOCAL_TASK,  );  $items['admin/build/translate/export'] = array(    'title' => 'Export',    'page callback' => 'locale_inc_callback',    'page arguments' => array('locale_translate_export_screen'), // possibly multiple forms concatenated    'access arguments' => array('translate interface'),    'weight' => 30,    'type' => MENU_LOCAL_TASK,  );  $items['admin/build/translate/edit/%'] = array(    'title' => 'Edit string',    'page callback' => 'locale_inc_callback',    'page arguments' => array('drupal_get_form', 'locale_translate_edit_form', 4),    'access arguments' => array('translate interface'),    'type' => MENU_CALLBACK,  );  $items['admin/build/translate/delete/%'] = array(    'title' => 'Delete string',    'page callback' => 'locale_inc_callback',    'page arguments' => array('locale_translate_delete_page', 4),    'access arguments' => array('translate interface'),    'type' => MENU_CALLBACK,  );  return $items;}/** * Wrapper function to be able to set callbacks in locale.inc */function locale_inc_callback() {  $args = func_get_args();  $function = array_shift($args);  include_once './includes/locale.inc';  return call_user_func_array($function, $args);}/** * Implementation of hook_perm(). */function locale_perm() {  return array('administer languages', 'translate interface');}/** * Implementation of hook_locale(). */function locale_locale($op = 'groups') {  switch ($op) {    case 'groups':      return array('default' => t('Built-in interface'));  }}/** * Implementation of hook_user(). */function locale_user($type, $edit, &$user, $category = NULL) {  global $language;  // If we have more then one language and either creating a user on the  // admin interface or edit the user, show the language selector.  if (variable_get('language_count', 1) > 1 && ($type == 'register' && user_access('administer users') || $type == 'form' && $category == 'account' )) {    $languages = language_list('enabled');    $languages = $languages[1];    // If the user is being created, we set the user language to the page language.    $user_preferred_language = $user ? user_preferred_language($user) : $language;    $names = array();    foreach ($languages as $langcode => $item) {      $name = t($item->name);      $names[check_plain($langcode)] = check_plain($name . ($item->native != $name ? ' ('. $item->native .')' : ''));    }    $form['locale'] = array(      '#type' => 'fieldset',      '#title' => t('Language settings'),      '#weight' => 1,    );    // Get language negotiation settings.    $mode = variable_get('language_negotiation', LANGUAGE_NEGOTIATION_NONE);    $form['locale']['language'] = array(      '#type' => (count($names) <= 5 ? 'radios' : 'select'),      '#title' => t('Language'),      '#default_value' => check_plain($user_preferred_language->language),      '#options' => $names,      '#description' => ($mode == LANGUAGE_NEGOTIATION_PATH) ? t("This account's default language for e-mails, and preferred language for site presentation.") : t("This account's default language for e-mails."),    );    return $form;  }}/** * Implementation of hook_form_alter(). Adds language fields to forms. */function locale_form_alter(&$form, $form_state, $form_id) {  switch ($form_id) {    // Language field for paths    case 'path_admin_form':      $form['language'] = array(        '#type' => 'select',        '#title' => t('Language'),        '#options' => array('' => t('All languages')) + locale_language_list('name'),        '#default_value' => $form['language']['#value'],        '#weight' => -10,        '#description' => t('A path alias set for a specific language will always be used when displaying this page in that language, and takes precedence over path aliases set for <em>All languages</em>.'),      );      break;    // Language setting for content types    case 'node_type_form':      if (isset($form['identity']['type'])) {        $form['workflow']['language_content_type'] = array(          '#type' => 'radios',          '#title' => t('Multilingual support'),          '#default_value' => variable_get('language_content_type_'. $form['#node_type']->type, 0),          '#options' => array(t('Disabled'), t('Enabled')),          '#description' => t('Enable multilingual support for this content type. If enabled, a language selection field will be added to the editing form, allowing you to select from one of the <a href="!languages">enabled languages</a>. If disabled, new posts are saved with the default language. Existing content will not be affected by changing this option.', array('!languages' => url('admin/settings/language'))),        );      }      break;    // Language field for nodes    default:      if (isset($form['#id']) && $form['#id'] == 'node-form') {        if (isset($form['#node']->type) && variable_get('language_content_type_'. $form['#node']->type, 0)) {          $form['language'] = array(            '#type' => 'select',            '#title' => t('Language'),            '#default_value' => (isset($form['#node']->language) ? $form['#node']->language : ''),            '#options' => array('' => t('Language neutral')) + locale_language_list('name'),          );        }        // Node type without language selector: assign the default for new nodes        elseif (!isset($form['#node']->nid)) {          $default = language_default();          $form['language'] = array(            '#type' => 'value',            '#value' => $default->language          );        }      }  }}/** * Implementation of hook_theme() */function locale_theme() {  return array(    'locale_languages_overview_form' => array(      'arguments' => array('form' => array()),    ),  );}/** * Implementation of hook_node_type(). */function locale_node_type($op, $info) {  if ($op == 'delete') {    variable_del('language_content_type_'. $info->type);  }}// ---------------------------------------------------------------------------------// Locale core functionality/** * Provides interface translation services. * * This function is called from t() to translate a string if needed. * * @param $string *   A string to look up translation for. If omitted, all the *   cached strings will be returned in all languages already *   used on the page. * @param $langcode *   Language code to use for the lookup. * @param $reset *   Set to TRUE to reset the in-memory cache. */function locale($string = NULL, $langcode = NULL, $reset = FALSE) {  global $language;  static $locale_t;  if ($reset) {    // Reset in-memory cache.    $locale_t = NULL;  }  if (!isset($string)) {    // Return all cached strings if no string was specified    return $locale_t;  }  $langcode = isset($langcode) ? $langcode : $language->language;  // Store database cached translations in a static var.  if (!isset($locale_t[$langcode])) {    $locale_t[$langcode] = array();    // Disabling the usage of string caching allows a module to watch for    // the exact list of strings used on a page. From a performance    // perspective that is a really bad idea, so we have no user    // interface for this. Be careful when turning this option off!    if (variable_get('locale_cache_strings', 1) == 1) {      if ($cache = cache_get('locale:'. $langcode, 'cache')) {        $locale_t[$langcode] = $cache->data;      }      elseif (lock_acquire('locale_cache_' . $langcode)) {        // Refresh database stored cache of translations for given language.        // We only store short strings used in current version, to improve        // performance and consume less memory.        $result = db_query("SELECT s.source, t.translation, t.language FROM {locales_source} s LEFT JOIN {locales_target} t ON s.lid = t.lid AND t.language = '%s' WHERE s.textgroup = 'default' AND s.version = '%s' AND LENGTH(s.source) < 75", $langcode, VERSION);        while ($data = db_fetch_object($result)) {          $locale_t[$langcode][$data->source] = (empty($data->translation) ? TRUE : $data->translation);        }        cache_set('locale:'. $langcode, $locale_t[$langcode]);        lock_release('locale_cache_' . $langcode);      }    }  }  // If we have the translation cached, skip checking the database  if (!isset($locale_t[$langcode][$string])) {    // We do not have this translation cached, so get it from the DB.    $translation = db_fetch_object(db_query("SELECT s.lid, t.translation, s.version FROM {locales_source} s LEFT JOIN {locales_target} t ON s.lid = t.lid AND t.language = '%s' WHERE s.source = '%s' AND s.textgroup = 'default'", $langcode, $string));    if ($translation) {      // We have the source string at least.      // Cache translation string or TRUE if no translation exists.      $locale_t[$langcode][$string] = (empty($translation->translation) ? TRUE : $translation->translation);      if ($translation->version != VERSION) {        // This is the first use of this string under current Drupal version. Save version        // and clear cache, to include the string into caching next time. Saved version is        // also a string-history information for later pruning of the tables.        db_query("UPDATE {locales_source} SET version = '%s' WHERE lid = %d", VERSION, $translation->lid);        cache_clear_all('locale:', 'cache', TRUE);      }    }    else {      // We don't have the source string, cache this as untranslated.      db_query("INSERT INTO {locales_source} (location, source, textgroup, version) VALUES ('%s', '%s', 'default', '%s')", request_uri(), $string, VERSION);      $locale_t[$langcode][$string] = TRUE;      // Clear locale cache so this string can be added in a later request.      cache_clear_all('locale:', 'cache', TRUE);    }  }  return ($locale_t[$langcode][$string] === TRUE ? $string : $locale_t[$langcode][$string]);}/** * Returns plural form index for a specific number. * * The index is computed from the formula of this language. * * @param $count *   Number to return plural for. * @param $langcode *   Optional language code to translate to a language other than *   what is used to display the page. */function locale_get_plural($count, $langcode = NULL) {  global $language;  static $locale_formula, $plurals = array();  $langcode = $langcode ? $langcode : $language->language;  if (!isset($plurals[$langcode][$count])) {    if (!isset($locale_formula)) {      $language_list = language_list();      $locale_formula[$langcode] = $language_list[$langcode]->formula;    }    if ($locale_formula[$langcode]) {      $n = $count;      $plurals[$langcode][$count] = @eval('return intval('. $locale_formula[$langcode] .');');      return $plurals[$langcode][$count];    }    else {      $plurals[$langcode][$count] = -1;      return -1;    }  }  return $plurals[$langcode][$count];}/** * Returns a language name */function locale_language_name($lang) {  static $list = NULL;  if (!isset($list)) {    $list = locale_language_list();  }  return ($lang && isset($list[$lang])) ? $list[$lang] : t('All');}/** * Returns array of language names * * @param $field *   'name' => names in current language, localized *   'native' => native names * @param $all *   Boolean to return all languages or only enabled ones */function locale_language_list($field = 'name', $all = FALSE) {  if ($all) {    $languages = language_list();  }  else {    $languages = language_list('enabled');    $languages = $languages[1];  }  $list = array();  foreach ($languages as $language) {    $list[$language->language] = ($field == 'name') ? t($language->name) : $language->$field;  }  return $list;}/** * Imports translations when new modules or themes are installed or enabled. * * This function will either import translation for the component change * right away, or start a batch if more files need to be imported. * * @param $components *   An array of component (theme and/or module) names to import *   translations for. */function locale_system_update($components) {  include_once 'includes/locale.inc';  if ($batch = locale_batch_by_component($components)) {    batch_set($batch);  }}/** * Update JavaScript translation file, if required, and add it to the page. * * This function checks all JavaScript files currently added via drupal_add_js() * and invokes parsing if they have not yet been parsed for Drupal.t() * and Drupal.formatPlural() calls. Also refreshes the JavaScript translation * file if necessary, and adds it to the page. */function locale_update_js_files() {  global $language;  $dir = file_create_path(variable_get('locale_js_directory', 'languages'));  $parsed = variable_get('javascript_parsed', array());  // The first three parameters are NULL in order to get an array with all  // scopes. This is necessary to prevent recreation of JS translation files  // when new files are added for example in the footer.  $javascript = drupal_add_js(NULL, NULL, NULL);  $files = $new_files = FALSE;  foreach ($javascript as $scope) {    foreach ($scope as $type => $data) {      if ($type != 'setting' && $type != 'inline') {        foreach ($data as $filepath => $info) {          $files = TRUE;          if (!in_array($filepath, $parsed)) {            // Don't parse our own translations files.            if (substr($filepath, 0, strlen($dir)) != $dir) {              locale_inc_callback('_locale_parse_js_file', $filepath);              $parsed[] = $filepath;              $new_files = TRUE;            }          }        }      }    }  }  // If there are any new source files we parsed, invalidate existing  // JavaScript translation files for all languages, adding the refresh  // flags into the existing array.  if ($new_files) {    $parsed += locale_inc_callback('_locale_invalidate_js');  }  // If necessary, rebuild the translation file for the current language.  if (!empty($parsed['refresh:'. $language->language])) {    // Don't clear the refresh flag on failure, so that another try will    // be performed later.    if (locale_inc_callback('_locale_rebuild_js')) {      unset($parsed['refresh:'. $language->language]);    }    // Store any changes after refresh was attempted.    variable_set('javascript_parsed', $parsed);  }  // If no refresh was attempted, but we have new source files, we need  // to store them too. This occurs if current page is in English.  else if ($new_files) {    variable_set('javascript_parsed', $parsed);  }  // Add the translation JavaScript file to the page.  if ($files && !empty($language->javascript)) {    drupal_add_js($dir .'/'. $language->language .'_'. $language->javascript .'.js', 'core');  }}// ---------------------------------------------------------------------------------// Language switcher block/** * Implementation of hook_block(). * Displays a language switcher. Translation links may be provided by other modules. */function locale_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $block[0]['info'] = t('Language switcher');    // Not worth caching.    $block[0]['cache'] = BLOCK_NO_CACHE;    return $block;  }  // Only show if we have at least two languages and language dependent  // web addresses, so we can actually link to other language versions.  elseif ($op == 'view' && variable_get('language_count', 1) > 1 && variable_get('language_negotiation', LANGUAGE_NEGOTIATION_NONE) != LANGUAGE_NEGOTIATION_NONE) {    $path = drupal_is_front_page() ? '<front>' : $_GET['q'];    $languages = language_list('enabled');    $links = array();    foreach ($languages[1] as $language) {      $links[$language->language] = array(        'href'       => $path,        'title'      => $language->native,        'language'   => $language,        'attributes' => array('class' => 'language-link'),      );    }    // Allow modules to provide translations for specific links.    // A translation link may need to point to a different path or use    // a translated link text before going through l(), which will just    // handle the path aliases.    drupal_alter('translation_link', $links, $path);    $block['subject'] = t('Languages');    $block['content'] = theme('links', $links, array());    return $block;  }}
<?php// $Id$/** * Implementation of hook_enable(). */function comment_enable() {  // Insert records into the node_comment_statistics for nodes that are missing.  db_query("INSERT INTO {node_comment_statistics} (nid, last_comment_timestamp, last_comment_name, last_comment_uid, comment_count) SELECT n.nid, n.changed, NULL, n.uid, 0 FROM {node} n LEFT JOIN {node_comment_statistics} c ON n.nid = c.nid WHERE c.comment_count IS NULL");}/** * Changed node_comment_statistics to use node->changed to avoid future timestamps. */function comment_update_1() {  // Change any future last comment timestamps to now.  db_query('UPDATE {node_comment_statistics} SET last_comment_timestamp = %d WHERE last_comment_timestamp > %d', time(), time());  // Unstuck node indexing timestamp if needed.  if (($last = variable_get('node_cron_last', FALSE)) !== FALSE) {    variable_set('node_cron_last', min(time(), $last));  }  return array();}function comment_update_6001() {  $ret[] = update_sql("ALTER TABLE {comments} DROP score");  $ret[] = update_sql("ALTER TABLE {comments} DROP users");  return $ret;}/** * Changed comment settings from global to per-node -- copy global * settings to all node types. */function comment_update_6002() {  // Comment module might not be enabled when this is run, but we need the  // constants defined by the module for this update.  drupal_load('module', 'comment');  $settings = array(    'comment_default_mode' => COMMENT_MODE_THREADED_EXPANDED,    'comment_default_order' => COMMENT_ORDER_NEWEST_FIRST,    'comment_default_per_page' => 50,    'comment_controls' => COMMENT_CONTROLS_HIDDEN,    'comment_anonymous' => COMMENT_ANONYMOUS_MAYNOT_CONTACT,    'comment_subject_field' => 1,    'comment_preview' => COMMENT_PREVIEW_REQUIRED,    'comment_form_location' => COMMENT_FORM_SEPARATE_PAGE,  );  $types = node_get_types();  foreach ($settings as $setting => $default) {    $value = variable_get($setting, $default);    foreach ($types as $type => $object) {      variable_set($setting .'_'. $type, $value);    }    variable_del($setting);  }  return array(array('success' => TRUE, 'query' => 'Global comment settings copied to all node types.'));}/** * Add index to parent ID field. */function comment_update_6003() {  $ret = array();  db_add_index($ret, 'comments', 'pid', array('pid'));  return $ret;}/** * Implementation of hook_schema(). */function comment_schema() {  $schema['comments'] = array(    'description' => 'Stores comments and associated data.',    'fields' => array(      'cid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique comment ID.',      ),      'pid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {comments}.cid to which this comment is a reply. If set to 0, this comment is not a reply to an existing comment.',      ),      'nid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid to which this comment is a reply.',      ),      'uid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {users}.uid who authored the comment. If set to 0, this comment was created by an anonymous user.',      ),      'subject' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'The comment title.',      ),      'comment' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'The comment body.',      ),      'hostname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => "The author's host name.",      ),      'timestamp' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The time that the comment was created, or last edited by its author, as a Unix timestamp.',      ),      'status' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The published status of a comment. (0 = Published, 1 = Not Published)',      ),      'format' => array(        'type' => 'int',        'size' => 'small',        'not null' => TRUE,        'default' => 0,        'description' => 'The {filter_formats}.format of the comment body.',      ),      'thread' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'description' => "The vancode representation of the comment's place in a thread.",      ),      'name' => array(        'type' => 'varchar',        'length' => 60,        'not null' => FALSE,        'description' => "The comment author's name. Uses {users}.name if the user is logged in, otherwise uses the value typed into the comment form.",      ),      'mail' => array(        'type' => 'varchar',        'length' => 64,        'not null' => FALSE,        'description' => "The comment author's e-mail address from the comment form, if user is anonymous, and the 'Anonymous users may/must leave their contact information' setting is turned on.",      ),      'homepage' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => "The comment author's home page address from the comment form, if user is anonymous, and the 'Anonymous users may/must leave their contact information' setting is turned on.",      )    ),    'indexes' => array(      'pid'    => array('pid'),      'nid'    => array('nid'),      'status' => array('status'), // This index is probably unused    ),    'primary key' => array('cid'),  );  $schema['node_comment_statistics'] = array(    'description' => 'Maintains statistics of node and comments posts to show "new" and "updated" flags.',    'fields' => array(      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid for which the statistics are compiled.',      ),      'last_comment_timestamp' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The Unix timestamp of the last comment that was posted within this node, from {comments}.timestamp.',      ),      'last_comment_name' => array(        'type' => 'varchar',        'length' => 60,        'not null' => FALSE,        'description' => 'The name of the latest author to post a comment on this node, from {comments}.name.',      ),      'last_comment_uid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The user ID of the latest author to post a comment on this node, from {comments}.uid.',      ),      'comment_count' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The total number of comments on this node.',      ),    ),    'primary key' => array('nid'),    'indexes' => array(      'node_comment_timestamp' => array('last_comment_timestamp')    ),  );  return $schema;}
<?php// $Id$/** * Implementation of hook_install(). */function book_install() {  // Create tables.  drupal_install_schema('book');  // Add the node type.  _book_install_type_create();}/** * Implementation of hook_uninstall(). */function book_uninstall() {  // Delete menu links.  db_query("DELETE FROM {menu_links} WHERE module = 'book'");  menu_cache_clear_all();  // Remove tables.  drupal_uninstall_schema('book');}function _book_install_type_create() {  // Create an additional node type  $book_node_type = array(    'type' => 'book',    'name' => t('Book page'),    'module' => 'node',    'description' => t('A <em>book page</em> is a page of content, organized into a collection of related entries collectively known as a <em>book</em>. A <em>book page</em> automatically displays links to adjacent pages, providing a simple navigation system for organizing and reviewing structured content.'),    'custom' => TRUE,    'modified' => TRUE,    'locked' => FALSE,  );  $book_node_type = (object)_node_type_set_defaults($book_node_type);  node_type_save($book_node_type);  // Default to not promoted.  variable_set('node_options_book', array('status'));  // Use this default type for adding content to books.  variable_set('book_allowed_types', array('book'));  variable_set('book_child_type', 'book');}/** * Drupal 5.x to 6.x update. * * This function moves any existing book hierarchy into the new structure used * in the 6.x module.  Rather than storing the hierarchy in the {book} table, * the menu API is used to store the hierarchy in the {menu_links} table and the * {book} table serves to uniquely connect a node to a menu link. * * In order to accomplish this, the current hierarchy is processed using a stack. * The stack insures that each parent is processed before any of its children * in the book hierarchy, and is compatible with batched update processing. * */function book_update_6000() {  $ret = array();  // Set up for a multi-part update.  if (!isset($_SESSION['book_update_6000'])) {    $schema['book'] = array(      'fields' => array(        'mlid'    => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'nid'     => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'bid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      ),      'primary key' => array('mlid'),      'unique keys' => array(        'nid' => array('nid'),      ),      'indexes' => array(        'bid' => array('bid'),      ),    );    // Add the node type.    _book_install_type_create();    // Fix role permissions to account for the changed names    // Setup the array holding strings to match and the corresponding    // strings to replace them with.    $replace = array(      'outline posts in books' => 'administer book outlines',      'create book pages' => 'create book content',      'edit book pages' => 'edit any book content',      'edit own book pages' => 'edit own book content',      'see printer-friendly version' => 'access printer-friendly version',    );    // Loop over all the roles, and do the necessary transformations.    $query = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");    while ($role = db_fetch_object($query)) {      // Replace all the old permissions with the corresponding new permissions.      $fixed_perm = strtr($role->perm, $replace);      // If the user could previously create book pages, they should get the new      // 'add content to books' permission.      if (strpos($role->perm, 'create book pages') !== FALSE) {        $fixed_perm .= ', add content to books';      }      // Only save if the permissions have changed.      if ($fixed_perm != $role->perm) {        $ret[] = update_sql("UPDATE {permission} SET perm = '$fixed_perm' WHERE rid = $role->rid");      }    }    // Determine whether there are any existing nodes in the book hierarchy.    if (db_result(db_query("SELECT COUNT(*) FROM {book}"))) {      // Temporary table for the old book hierarchy; we'll discard revision info.      $schema['book_temp'] = array(        'fields' => array(          'nid'    => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),          'parent' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),          'weight' => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'tiny')        ),        'indexes' => array(          'parent' => array('parent')        ),        'primary key' => array('nid'),      );      db_create_table($ret, 'book_temp', $schema['book_temp']);      // Insert each node in the old table into the temporary table.      $ret[] = update_sql("INSERT INTO {book_temp} (nid, parent, weight) SELECT b.nid, b.parent, b.weight FROM {book} b INNER JOIN {node} n on b.vid = n.vid");      $ret[] = update_sql("DROP TABLE {book}");      db_create_table($ret, 'book', $schema['book']);      $_SESSION['book_update_6000_orphans']['from'] = 0;      $_SESSION['book_update_6000'] = array();      $result = db_query("SELECT * from {book_temp} WHERE parent = 0");      // Collect all books - top-level nodes.      while ($a = db_fetch_array($result)) {        $_SESSION['book_update_6000'][] = $a;      }      $ret['#finished'] = FALSE;      return $ret;    }    else {      // No exising nodes in the hierarchy, so drop the table and re-create it.      $ret[] = update_sql("DROP TABLE {book}");      db_create_table($ret, 'book', $schema['book']);      return $ret;    }  }  elseif ($_SESSION['book_update_6000_orphans']) {    // Do the first batched part of the update - collect orphans.    $update_count = 400; // Update this many at a time    $result = db_query_range("SELECT * FROM {book_temp}", $_SESSION['book_update_6000_orphans']['from'], $update_count);    $has_rows = FALSE;    // Go through the next $update_count book pages and locate the orphans.    while ($book = db_fetch_array($result)) {      $has_rows = TRUE;      // Orphans are defined as nodes whose parent does not exist in the table.      if ($book['parent'] && !db_result(db_query("SELECT COUNT(*) FROM {book_temp} WHERE nid = %d", $book['parent']))) {        if (empty($_SESSION['book_update_6000_orphans']['book'])) {          // The first orphan becomes the parent for all other orphans.          $book['parent'] = 0;          $_SESSION['book_update_6000_orphans']['book'] = $book;          $ret[] = array('success' => TRUE, 'query' => 'Relocated orphan book pages.');        }        else {          // Re-assign the parent value of the book, and add it to the stack.          $book['parent'] = $_SESSION['book_update_6000_orphans']['book']['nid'];          $_SESSION['book_update_6000'][] = $book;        }      }    }    if ($has_rows) {      $_SESSION['book_update_6000_orphans']['from'] += $update_count;    }    else {      // Done with this part      if (!empty($_SESSION['book_update_6000_orphans']['book'])) {        // The orphans' parent is added last, so it will be processed first.        $_SESSION['book_update_6000'][] = $_SESSION['book_update_6000_orphans']['book'];      }      $_SESSION['book_update_6000_orphans'] = FALSE;    }    $ret['#finished'] = FALSE;    return $ret;  }  else {    // Do the next batched part of the update    $update_count = 100; // Update this many at a time    while ($update_count && $_SESSION['book_update_6000']) {      // Get the last node off the stack.      $book = array_pop($_SESSION['book_update_6000']);      // Add all of this node's children to the stack      $result = db_query("SELECT * FROM {book_temp} WHERE parent = %d", $book['nid']);      while ($a = db_fetch_array($result)) {        $_SESSION['book_update_6000'][] = $a;      }      if ($book['parent']) {        // If its not a top level page, get its parent's mlid.        $parent = db_fetch_array(db_query("SELECT b.mlid AS plid, b.bid FROM {book} b WHERE b.nid = %d", $book['parent']));        $book = array_merge($book, $parent);      }      else {        // There is not a parent - this is a new book.        $book['plid'] = 0;        $book['bid'] = $book['nid'];      }      $book += array(        'module' => 'book',        'link_path' => 'node/'. $book['nid'],        'router_path' => 'node/%',        'menu_name' => 'book-toc-'. $book['bid'],      );      $book = array_merge($book, db_fetch_array(db_query("SELECT title AS link_title FROM {node} WHERE nid = %d", $book['nid'])));      // Items with depth > MENU_MAX_DEPTH cannot be saved.      if (menu_link_save($book)) {        db_query("INSERT INTO {book} (mlid, nid, bid) VALUES (%d, %d, %d)", $book['mlid'], $book['nid'], $book['bid']);      }      else {        // The depth was greater then MENU_MAX_DEPTH, so attach it to the        // closest valid parent.        $book['plid'] = db_result(db_query("SELECT plid FROM {menu_links} WHERE mlid = %d", $book['plid']));        if (menu_link_save($book)) {          db_query("INSERT INTO {book} (mlid, nid, bid) VALUES (%d, %d, %d)", $book['mlid'], $book['nid'], $book['bid']);        }      }      $update_count--;    }    $ret['#finished'] = FALSE;  }  if (empty($_SESSION['book_update_6000'])) {    $ret['#finished'] = TRUE;    $ret[] = array('success' => TRUE, 'query' => 'Relocated existing book pages.');    $ret[] = update_sql("DROP TABLE {book_temp}");    unset($_SESSION['book_update_6000']);    unset($_SESSION['book_update_6000_orphans']);  }  return $ret;}/** * Implementation of hook_schema(). */function book_schema() {  $schema['book'] = array(  'description' => 'Stores book outline information. Uniquely connects each node in the outline to a link in {menu_links}',    'fields' => array(      'mlid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book page's {menu_links}.mlid.",      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book page's {node}.nid.",      ),      'bid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book ID is the {book}.nid of the top-level page.",      ),    ),    'primary key' => array('mlid'),    'unique keys' => array(      'nid' => array('nid'),    ),    'indexes' => array(      'bid' => array('bid'),    ),  );  return $schema;}
<?php// $Id$/** * @file * Enables users to rename URLs. *//** * Implementation of hook_help(). */function path_help($path, $arg) {  switch ($path) {    case 'admin/help#path':      $output = '<p>'. t('The path module allows you to specify aliases for Drupal URLs. Such aliases improve readability of URLs for your users and may help internet search engines to index your content more effectively. More than one alias may be created for a given page.') .'</p>';      $output .= t('<p>Some examples of URL aliases are:</p><ul><li>user/login =&gt; login</li><li>image/tid/16 =&gt; store</li><li>taxonomy/term/7+19+20+21 =&gt; store/products/whirlygigs</li><li>node/3 =&gt; contact</li></ul>');      $output .= '<p>'. t('The path module enables appropriately permissioned users to specify an optional alias in all node input and editing forms, and provides an interface to view and edit all URL aliases. The two permissions related to URL aliasing are <em>administer url aliases</em> and <em>create url aliases</em>. ') .'</p>';      $output .= '<p>'. t('This module also provides user-defined mass URL aliasing capabilities, which is useful if you wish to uniformly use URLs different from the default. For example, you may want to have your URLs presented in a different language. Access to the Drupal source code on the web server is required to set up mass URL aliasing. ') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@path">Path module</a>.', array('@path' => 'http://drupal.org/handbook/modules/path/')) .'</p>';      return $output;    case 'admin/build/path':      return '<p>'. t("Drupal provides complete control over URLs through aliasing, which is often used to make URLs more readable or easy to remember. For example, the alias 'about' may be mapped onto the post at the system path 'node/1', creating a more meaningful URL. Each system path can have multiple aliases.") .'</p>';    case 'admin/build/path/add':      return '<p>'. t('Enter the path you wish to create the alias for, followed by the name of the new alias.') .'</p>';  }}/** * Implementation of hook_menu(). */function path_menu() {  $items['admin/build/path'] = array(    'title' => 'URL aliases',    'description' => "Change your site's URL paths by aliasing them.",    'page callback' => 'path_admin_overview',    'access arguments' => array('administer url aliases'),    'file' => 'path.admin.inc',  );  $items['admin/build/path/edit'] = array(    'title' => 'Edit alias',    'page callback' => 'path_admin_edit',    'access arguments' => array('administer url aliases'),    'type' => MENU_CALLBACK,    'file' => 'path.admin.inc',  );  $items['admin/build/path/delete'] = array(    'title' => 'Delete alias',    'page callback' => 'drupal_get_form',    'page arguments' => array('path_admin_delete_confirm'),    'access arguments' => array('administer url aliases'),    'type' => MENU_CALLBACK,    'file' => 'path.admin.inc',  );  $items['admin/build/path/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/build/path/add'] = array(    'title' => 'Add alias',    'page callback' => 'path_admin_edit',    'access arguments' => array('administer url aliases'),    'type' => MENU_LOCAL_TASK,    'file' => 'path.admin.inc',  );  return $items;}/** * Post-confirmation; delete an URL alias. */function path_admin_delete($pid = 0) {  db_query('DELETE FROM {url_alias} WHERE pid = %d', $pid);  drupal_set_message(t('The alias has been deleted.'));}/** * Set an aliased path for a given Drupal path, preventing duplicates. */function path_set_alias($path = NULL, $alias = NULL, $pid = NULL, $language = '') {  $path = urldecode($path);  $alias = urldecode($alias);  // First we check if we deal with an existing alias and delete or modify it based on pid.  if ($pid) {    // An existing alias.    if (!$path || !$alias) {      // Delete the alias based on pid.      db_query('DELETE FROM {url_alias} WHERE pid = %d', $pid);    }    else {      // Update the existing alias.      db_query("UPDATE {url_alias} SET src = '%s', dst = '%s', language = '%s' WHERE pid = %d", $path, $alias, $language, $pid);    }  }  else if ($path && $alias) {    // Check for existing aliases.    if ($alias == drupal_get_path_alias($path, $language)) {      // There is already such an alias, neutral or in this language.      // Update the alias based on alias; setting the language if not yet done.      db_query("UPDATE {url_alias} SET src = '%s', dst = '%s', language = '%s' WHERE dst = '%s'", $path, $alias, $language, $alias);    }    else {      // A new alias. Add it to the database.      db_query("INSERT INTO {url_alias} (src, dst, language) VALUES ('%s', '%s', '%s')", $path, $alias, $language);    }  }  else {    // Delete the alias.    if ($alias) {      db_query("DELETE FROM {url_alias} WHERE dst = '%s'", $alias);    }    else {      db_query("DELETE FROM {url_alias} WHERE src = '%s'", $path);    }  }  drupal_clear_path_cache();}/** * Implementation of hook_nodeapi(). * * Allows URL aliases for nodes to be specified at node edit time rather * than through the administrative interface. */function path_nodeapi(&$node, $op, $arg) {  // Permissions are required for everything except node loading.  if (user_access('create url aliases') || user_access('administer url aliases') || ($op == 'load')) {    $language = isset($node->language) ? $node->language : '';    switch ($op) {      case 'validate':        if (isset($node->path)) {          $node->path = trim($node->path);          if (db_result(db_query("SELECT COUNT(dst) FROM {url_alias} WHERE dst = '%s' AND src != '%s' AND language = '%s'", $node->path, "node/$node->nid", $language))) {            form_set_error('path', t('The path is already in use.'));          }        }        break;      case 'load':        $path = 'node/'. $node->nid;        $alias = drupal_get_path_alias($path, $language);        if ($path != $alias) {          $node->path = $alias;        }        break;      case 'insert':        // Don't try to insert if path is NULL. We may have already set        // the alias ahead of time.        if (isset($node->path)) {          path_set_alias('node/'. $node->nid, $node->path, NULL, $language);        }        break;      case 'update':        path_set_alias('node/'. $node->nid, isset($node->path) ? $node->path : NULL, isset($node->pid) ? $node->pid : NULL, $language);        break;      case 'delete':        $path = 'node/'. $node->nid;        if (drupal_get_path_alias($path) != $path) {          path_set_alias($path);        }        break;    }  }}/** * Implementation of hook_form_alter(). */function path_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id) {    $path = isset($form['#node']->path) ? $form['#node']->path : NULL;    $form['path'] = array(      '#type' => 'fieldset',      '#title' => t('URL path settings'),      '#collapsible' => TRUE,      '#collapsed' => empty($path),      '#access' => user_access('create url aliases'),      '#weight' => 30,    );    $form['path']['path'] = array(      '#type' => 'textfield',      '#default_value' => $path,      '#maxlength' => 128,      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#description' => t('Optionally specify an alternative URL by which this node can be accessed. For example, type "about" when writing an about page. Use a relative path and don\'t add a trailing slash or the URL alias won\'t work.'),    );    if ($path) {      $form['path']['pid'] = array(        '#type' => 'value',        '#value' => db_result(db_query("SELECT pid FROM {url_alias} WHERE dst = '%s' AND language = '%s'", $path, $form['#node']->language))      );    }  }}/** * Implementation of hook_perm(). */function path_perm() {  return array('create url aliases', 'administer url aliases');}/** * Fetch a specific URL alias from the database. */function path_load($pid) {  return db_fetch_array(db_query('SELECT * FROM {url_alias} WHERE pid = %d', $pid));}
<?php// $Id$/** * @file * A database-mediated implementation of a locking mechanism. *//** * @defgroup lock Functions to coordinate long-running operations across requests. * @{ * In most environments, multiple Drupal page requests (a.k.a. threads or * processes) will execute in parallel. This leads to potential conflicts or * race conditions when two requests execute the same code at the same time. A * common example of this is a rebuild like menu_rebuild() where we invoke many * hook implementations to get and process data from all active modules, and * then delete the current data in the database to insert the new afterwards. * * This is a cooperative, advisory lock system. Any long-running operation * that could potentially be attempted in parallel by multiple requests should * try to acquire a lock before proceeding. By obtaiing a lock, one request * notifies any other requests that a specific opertation is in progress which * must not be executed in parallel. * * To use this API, pick a unique name for the lock. A sensible choice is the * name of the function performing the operation. A very simple example use of * this API: * @code * function mymodule_long_operation() { *   if (lock_acquire('mymodule_long_operation')) { *     // Do the long operation here. *     // ... *     lock_release('mymodule_long_operation'); *   } * } * @endcode * * If a function acquires a lock it should always release it when the * operation is complete by calling lock_release(), as in the example. * * A function that has acquired a lock may attempt to renew a lock (extend the * duration of the lock) by calling lock_acquire() again during the operation. * Failure to renew a lock is indicative that another request has acquired * the lock, and that the current operation may need to be aborted. * * If a function fails to acquire a lock it may either immediately return, or * it may call lock_wait() if the rest of the current page request requires * that the operation in question be complete.  After lock_wait() returns, * the function may again attempt to acquire the lock, or may simply allow the * page request to proceed on the  assumption that a parallel request completed * the operation. * * lock_acquire() and lock_wait() will automatically break (delete) a lock * whose duration has exceeded the timeout specified when it was acquired. * * A function that has acquired a lock may attempt to renew a lock (extend the * duration of the lock) by calling lock_acquire() again during the operation. * Failure to renew a lock is indicative that another request has acquired * the lock, and that the current operation may need to be aborted. * * Alternative implementations of this API (such as APC) may be substituted * by setting the 'lock_inc' variable to an alternate include filepath.  Since * this is an API intended to support alternative implementations, code using * this API should never rely upon specific implementation details (for example * no code should look for or directly modify a lock in the {semaphore} table). *//** * Initialize the locking system. */function lock_init() {  global $locks;  $locks = array();}/** * Helper function to get this request's unique id. */function _lock_id() {  static $lock_id;  if (!isset($lock_id)) {    // Assign a unique id.    $lock_id = uniqid(mt_rand(), TRUE);    // We only register a shutdown function if a lock is used.    register_shutdown_function('lock_release_all', $lock_id);  }  return $lock_id;}/** * Acquire (or renew) a lock, but do not block if it fails. * * @param $name *   The name of the lock. * @param $timeout *   A number of seconds (float) before the lock expires. * @return *   TRUE if the lock was acquired, FALSE if it failed. */function lock_acquire($name, $timeout = 30.0) {  global $locks;  // Insure that the timeout is at least 1 ms.  $timeout = max($timeout, 0.001);  list($usec, $sec) = explode(' ', microtime());  $expire = (float)$usec + (float)$sec + $timeout;  if (isset($locks[$name])) {    // Try to extend the expiration of a lock we already acquired.    if (!db_result(db_query("UPDATE {semaphore} SET expire = %f WHERE name = '%s' AND value = '%s'", $expire, $name, _lock_id()))) {      // The lock was broken.      unset($locks[$name]);    }  }  else {    // Optimistically try to acquire the lock, then retry once if it fails.    // The first time through the loop cannot be a retry.    $retry = FALSE;    // We always want to do this code at least once.    do {      if (@db_query("INSERT INTO {semaphore} (name, value, expire) VALUES ('%s', '%s', %f)", $name, _lock_id(), $expire)) {        // We track all acquired locks in the global variable.        $locks[$name] = TRUE;        // We never need to try again.        $retry = FALSE;      }      else {        // Suppress the error. If this is our first pass through the loop,        // then $retry is FALSE. In this case, the insert must have failed        // meaning some other request acquired the lock but did not release it.        // We decide whether to retry by checking lock_may_be_available()        // Since this will break the lock in case it is expired.        $retry = $retry ? FALSE : lock_may_be_available($name);      }      // We only retry in case the first attempt failed, but we then broke      // an expired lock.    } while ($retry);  }  return isset($locks[$name]);}/** * Check if lock acquired by a different process may be available. * * If an existing lock has expired, it is removed. * * @param $name *   The name of the lock. * @return *   TRUE if there is no lock or it was removed, FALSE otherwise. */function lock_may_be_available($name) {  $lock = db_fetch_array(db_query("SELECT expire, value FROM {semaphore} WHERE name = '%s'", $name));  if (!$lock) {    return TRUE;  }  $expire = (float) $lock['expire'];  list($usec, $sec) = explode(' ', microtime());  $now = (float)$usec + (float)$sec;  if ($now > $lock['expire']) {    // We check two conditions to prevent a race condition where another    // request acquired the lock and set a new expire time.  We add a small    // number to $expire to avoid errors with float to string conversion.    db_query("DELETE FROM {semaphore} WHERE name = '%s' AND value = '%s' AND expire <= %f", $name, $lock['value'], 0.0001 + $expire);    return (bool)db_affected_rows();  }  return FALSE;}/** * Wait for a lock to be available. * * This function may be called in a request that fails to acquire a desired * lock. This will block further execution until the lock is available or the * specified delay in seconds is reached.  This should not be used with locks * that are acquired very frequently, since the lock is likely to be acquired * again by a different request during the sleep(). * * @param $name *   The name of the lock. * @param $delay *   The maximum number of seconds to wait, as an integer. * @return *   TRUE if the lock holds, FALSE if it is available. */function lock_wait($name, $delay = 30) {  while ($delay--) {    // This function should only be called by a request that failed to get a    // lock, so we sleep first to give the parallel request a chance to finish    // and release the lock.    sleep(1);    if (lock_may_be_available($name)) {      // No longer need to wait.      return FALSE;    }  }  // The caller must still wait longer to get the lock.  return TRUE;}/** * Release a lock previously acquired by lock_acquire(). * * This will release the named lock if it is still held by the current request. * * @param $name *   The name of the lock. */function lock_release($name) {  global $locks;  unset($locks[$name]);  db_query("DELETE FROM {semaphore} WHERE name = '%s' AND value = '%s'", $name, _lock_id());}/** * Release all previously acquired locks. */function lock_release_all($lock_id = NULL) {  global $locks;  $locks = array();  if (empty($lock_id)) {    $lock_id = _lock_id();  }  db_query("DELETE FROM {semaphore} WHERE value = '%s'", _lock_id());}/** * @} End of "defgroup locks". */
<?php// $Id$/** * @file * User page callbacks for the tracker module. *//** * Menu callback. Prints a listing of active nodes on the site. */function tracker_page($account = NULL, $set_title = FALSE) {  // Add CSS  drupal_add_css(drupal_get_path('module', 'tracker') .'/tracker.css', 'module', 'all', FALSE);  if ($account) {    if ($set_title) {      // When viewed from user/%user/track, display the name of the user      // as page title -- the tab title remains Track so this needs to be done      // here and not in the menu definiton.      drupal_set_title(check_plain($account->name));    }  // TODO: These queries are very expensive, see http://drupal.org/node/105639    $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.changed, n.uid, u.name, GREATEST(n.changed, l.last_comment_timestamp) AS last_updated, l.comment_count FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {users} u ON n.uid = u.uid LEFT JOIN {comments} c ON n.nid = c.nid AND (c.status = %d OR c.status IS NULL) WHERE n.status = 1 AND (n.uid = %d OR c.uid = %d) ORDER BY last_updated DESC';    $sql = db_rewrite_sql($sql);    $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n LEFT JOIN {comments} c ON n.nid = c.nid AND (c.status = %d OR c.status IS NULL) WHERE n.status = 1 AND (n.uid = %d OR c.uid = %d)';    $sql_count = db_rewrite_sql($sql_count);    $result = pager_query($sql, 25, 0, $sql_count, COMMENT_PUBLISHED, $account->uid, $account->uid);  }  else {    $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.changed, n.uid, u.name, GREATEST(n.changed, l.last_comment_timestamp) AS last_updated, l.comment_count FROM {node} n INNER JOIN {users} u ON n.uid = u.uid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 ORDER BY last_updated DESC';    $sql = db_rewrite_sql($sql);    $sql_count = 'SELECT COUNT(n.nid) FROM {node} n WHERE n.status = 1';    $sql_count = db_rewrite_sql($sql_count);    $result = pager_query($sql, 25, 0, $sql_count);  }  $rows = array();  while ($node = db_fetch_object($result)) {    // Determine the number of comments:    $comments = 0;    if ($node->comment_count) {      $comments = $node->comment_count;      if ($new = comment_num_new($node->nid)) {        $comments .= '<br />';        $comments .= l(format_plural($new, '1 new', '@count new'), "node/$node->nid", array('query' => comment_new_page_count($node->comment_count, $new, $node), 'fragment' => 'new'));      }    }    $rows[] = array(      check_plain(node_get_types('name', $node->type)),      l($node->title, "node/$node->nid") .' '. theme('mark', node_mark($node->nid, $node->changed)),      theme('username', $node),      array('class' => 'replies', 'data' => $comments),      t('!time ago', array('!time' => format_interval(time() - $node->last_updated)))    );  }  if (!$rows) {    $rows[] = array(array('data' => t('No posts available.'), 'colspan' => '5'));  }  $header = array(t('Type'), t('Post'), t('Author'), t('Replies'), t('Last updated'));  $output = '<div id="tracker">';  $output .= theme('table', $header, $rows);  $output .= theme('pager', NULL, 25, 0);  $output .= '</div>';  return $output;}
<?php// $Id$/** * @file * Admin page callbacks for the filter module. *//** * Menu callback; Displays a list of all input formats and which * one is the default. * * @ingroup forms * @see filter_admin_overview_submit() */function filter_admin_overview() {  // Overview of all formats.  $formats = filter_formats();  $error = FALSE;  foreach ($formats as $id => $format) {    $roles = array();    foreach (user_roles() as $rid => $name) {      // Prepare a roles array with roles that may access the filter.      if (strstr($format->roles, ",$rid,")) {        $roles[] = $name;      }    }    $default = ($id == variable_get('filter_default_format', 1));    $options[$id] = '';    $form[$format->name]['id'] = array('#value' => $id);    $form[$format->name]['roles'] = array('#value' => $default ? t('All roles may use default format') : ($roles ? implode(', ', $roles) : t('No roles may use this format')));    $form[$format->name]['configure'] = array('#value' => l(t('configure'), 'admin/settings/filters/'. $id));    $form[$format->name]['delete'] = array('#value' => $default ? '' : l(t('delete'), 'admin/settings/filters/delete/'. $id));  }  $form['default'] = array('#type' => 'radios', '#options' => $options, '#default_value' => variable_get('filter_default_format', 1));  $form['submit'] = array('#type' => 'submit', '#value' => t('Set default format'));  return $form;}function filter_admin_overview_submit($form, &$form_state) {  // Process form submission to set the default format.  if (is_numeric($form_state['values']['default'])) {    drupal_set_message(t('Default format updated.'));    variable_set('filter_default_format', $form_state['values']['default']);  }}/** * Theme the admin overview form. * * @ingroup themeable */function theme_filter_admin_overview($form) {  $rows = array();  foreach ($form as $name => $element) {    if (isset($element['roles']) && is_array($element['roles'])) {      $rows[] = array(        drupal_render($form['default'][$element['id']['#value']]),        check_plain($name),        drupal_render($element['roles']),        drupal_render($element['configure']),        drupal_render($element['delete'])      );      unset($form[$name]);    }  }  $header = array(t('Default'), t('Name'), t('Roles'), array('data' => t('Operations'), 'colspan' => 2));  $output = theme('table', $header, $rows);  $output .= drupal_render($form);  return $output;}/** * Menu callback; Display a filter format form. */function filter_admin_format_page($format = NULL) {  if (!isset($format->name)) {    drupal_set_title(t("Add input format"));    $format = (object)array('name' => '', 'roles' => '', 'format' => '');  }  return drupal_get_form('filter_admin_format_form', $format);}/** * Generate a filter format form. * * @ingroup forms * @see filter_admin_format_form_validate() * @see filter_admin_format_form_submit() */function filter_admin_format_form(&$form_state, $format) {  $default = ($format->format == variable_get('filter_default_format', 1));  if ($default) {    $help = t('All roles for the default format must be enabled and cannot be changed.');    $form['default_format'] = array('#type' => 'hidden', '#value' => 1);  }  $form['name'] = array('#type' => 'textfield',    '#title' => t('Name'),    '#default_value' => $format->name,    '#description' => t('Specify a unique name for this filter format.'),    '#required' => TRUE,  );  // Add a row of checkboxes for form group.  $form['roles'] = array('#type' => 'fieldset',    '#title' => t('Roles'),    '#description' => $default ? $help : t('Choose which roles may use this filter format. Note that roles with the "administer filters" permission can always use all the filter formats.'),    '#tree' => TRUE,  );  foreach (user_roles() as $rid => $name) {    $checked = strstr($format->roles, ",$rid,");    $form['roles'][$rid] = array('#type' => 'checkbox',      '#title' => $name,      '#default_value' => ($default || $checked),    );    if ($default) {      $form['roles'][$rid]['#disabled'] = TRUE;    }  }  // Table with filters  $all = filter_list_all();  $enabled = filter_list_format($format->format);  $form['filters'] = array('#type' => 'fieldset',    '#title' => t('Filters'),    '#description' => t('Choose the filters that will be used in this filter format.'),    '#tree' => TRUE,  );  foreach ($all as $id => $filter) {    $form['filters'][$id] = array('#type' => 'checkbox',      '#title' => $filter->name,      '#default_value' => isset($enabled[$id]),      '#description' => module_invoke($filter->module, 'filter', 'description', $filter->delta),    );  }  if (!empty($format->format)) {    $form['format'] = array('#type' => 'hidden', '#value' => $format->format);    // Composition tips (guidelines)    $tips = _filter_tips($format->format, FALSE);    $extra = '<p>'. l(t('More information about formatting options'), 'filter/tips') .'</p>';    $tiplist = theme('filter_tips', $tips, FALSE, $extra);    if (!$tiplist) {      $tiplist = '<p>'. t('No guidelines available.') .'</p>';    }    $group = '<p>'. t('These are the guidelines that users will see for posting in this input format. They are automatically generated from the filter settings.') .'</p>';    $group .= $tiplist;    $form['tips'] = array('#value' => '<h2>'. t('Formatting guidelines') .'</h2>'. $group);  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save configuration'));  return $form;}/** * Validate filter format form submissions. */function filter_admin_format_form_validate($form, &$form_state) {  if (!isset($form_state['values']['format'])) {    $name = trim($form_state['values']['name']);    $result = db_fetch_object(db_query("SELECT format FROM {filter_formats} WHERE name='%s'", $name));    if ($result) {      form_set_error('name', t('Filter format names need to be unique. A format named %name already exists.', array('%name' => $name)));    }  }}/** * Process filter format form submissions. */function filter_admin_format_form_submit($form, &$form_state) {  $format = isset($form_state['values']['format']) ? $form_state['values']['format'] : NULL;  $current = filter_list_format($format);  $name = trim($form_state['values']['name']);  $cache = TRUE;  // Add a new filter format.  if (!$format) {    $new = TRUE;    db_query("INSERT INTO {filter_formats} (name) VALUES ('%s')", $name);    $format = db_result(db_query("SELECT MAX(format) AS format FROM {filter_formats}"));    drupal_set_message(t('Added input format %format.', array('%format' => $name)));  }  else {    drupal_set_message(t('The input format settings have been updated.'));  }  db_query("DELETE FROM {filters} WHERE format = %d", $format);  foreach ($form_state['values']['filters'] as $id => $checked) {    if ($checked) {      list($module, $delta) = explode('/', $id);      // Add new filters to the bottom.      $weight = isset($current[$id]->weight) ? $current[$id]->weight : 10;      db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $format, $module, $delta, $weight);      // Check if there are any 'no cache' filters.      $cache &= !module_invoke($module, 'filter', 'no cache', $delta);    }  }  // We store the roles as a string for ease of use.  // We should always set all roles to TRUE when saving a default role.  // We use leading and trailing comma's to allow easy substring matching.  $roles = array();  if (isset($form_state['values']['roles'])) {    foreach ($form_state['values']['roles'] as $id => $checked) {      if ($checked) {        $roles[] = $id;      }    }  }  if (!empty($form_state['values']['default_format'])) {    $roles = ','. implode(',', array_keys(user_roles())) .',';  }  else {    $roles = ','. implode(',', $roles) .',';  }  db_query("UPDATE {filter_formats} SET cache = %d, name='%s', roles = '%s' WHERE format = %d", $cache, $name, $roles, $format);  cache_clear_all($format .':', 'cache_filter', TRUE);  // If a new filter was added, return to the main list of filters. Otherwise, stay on edit filter page to show new changes.  $return = 'admin/settings/filters';  if (!empty($new)) {    $return .= '/'. $format;  }  $form_state['redirect'] = $return;  return;}/** * Menu callback; confirm deletion of a format. * * @ingroup forms * @see filter_admin_delete_submit() */function filter_admin_delete() {  $format = arg(4);  $format = db_fetch_object(db_query('SELECT * FROM {filter_formats} WHERE format = %d', $format));  if ($format) {    if ($format->format != variable_get('filter_default_format', 1)) {      $form['format'] = array('#type' => 'hidden', '#value' => $format->format);      $form['name'] = array('#type' => 'hidden', '#value' => $format->name);      return confirm_form($form, t('Are you sure you want to delete the input format %format?', array('%format' => $format->name)), 'admin/settings/filters', t('If you have any content left in this input format, it will be switched to the default input format. This action cannot be undone.'), t('Delete'), t('Cancel'));    }    else {      drupal_set_message(t('The default format cannot be deleted.'));      drupal_goto('admin/settings/filters');    }  }  else {    drupal_not_found();  }}/** * Process filter delete form submission. */function filter_admin_delete_submit($form, &$form_state) {  db_query("DELETE FROM {filter_formats} WHERE format = %d", $form_state['values']['format']);  db_query("DELETE FROM {filters} WHERE format = %d", $form_state['values']['format']);  $default = variable_get('filter_default_format', 1);  // Replace existing instances of the deleted format with the default format.  db_query("UPDATE {node_revisions} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  db_query("UPDATE {comments} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  db_query("UPDATE {boxes} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);  drupal_set_message(t('Deleted input format %format.', array('%format' => $form_state['values']['name'])));  $form_state['redirect'] = 'admin/settings/filters';  return;}/** * Menu callback; display settings defined by a format's filters. */function filter_admin_configure_page($format) {  drupal_set_title(t("Configure %format", array('%format' => $format->name)));  return drupal_get_form('filter_admin_configure', $format);}/** * Build a form to change the settings for a format's filters. * * @ingroup forms */function filter_admin_configure(&$form_state, $format) {  $list = filter_list_format($format->format);  $form = array();  foreach ($list as $filter) {    $form_module = module_invoke($filter->module, 'filter', 'settings', $filter->delta, $format->format);    if (isset($form_module) && is_array($form_module)) {      $form = array_merge($form, $form_module);    }  }  if (!empty($form)) {    $form = system_settings_form($form);  }  else {    $form['error'] = array('#value' => t('No settings are available.'));  }  $form['format'] = array('#type' => 'hidden', '#value' => $format->format);  $form['#submit'][] = 'filter_admin_configure_submit';  return $form;}/** * Clear the filter's cache when configuration settings are saved. */function filter_admin_configure_submit($form, &$form_state) {  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);}/** * Menu callback; display form for ordering filters for a format. */function filter_admin_order_page($format) {  drupal_set_title(t("Rearrange %format", array('%format' => $format->name)));  return drupal_get_form('filter_admin_order', $format);}/** * Build the form for ordering filters for a format. * * @ingroup forms * @see theme_filter_admin_order() * @see filter_admin_order_submit() */function filter_admin_order(&$form_state, $format = NULL) {  // Get list (with forced refresh).  $filters = filter_list_format($format->format);  $form['weights'] = array('#tree' => TRUE);  foreach ($filters as $id => $filter) {    $form['names'][$id] = array('#value' => $filter->name);    $form['weights'][$id] = array('#type' => 'weight', '#default_value' => $filter->weight);  }  $form['format'] = array('#type' => 'hidden', '#value' => $format->format);  $form['submit'] = array('#type' => 'submit', '#value' => t('Save configuration'));  return $form;}/** * Theme filter order configuration form. * * @ingroup themeable */function theme_filter_admin_order($form) {  $header = array(t('Name'), t('Weight'));  $rows = array();  foreach (element_children($form['names']) as $id) {    // Don't take form control structures.    if (is_array($form['names'][$id])) {      $form['weights'][$id]['#attributes']['class'] = 'filter-order-weight';      $rows[] = array(        'data' => array(drupal_render($form['names'][$id]), drupal_render($form['weights'][$id])),        'class' => 'draggable',      );    }  }  $output = theme('table', $header, $rows, array('id' => 'filter-order'));  $output .= drupal_render($form);  drupal_add_tabledrag('filter-order', 'order', 'sibling', 'filter-order-weight', NULL, NULL, FALSE);  return $output;}/** * Process filter order configuration form submission. */function filter_admin_order_submit($form, &$form_state) {  foreach ($form_state['values']['weights'] as $id => $weight) {    list($module, $delta) = explode('/', $id);    db_query("UPDATE {filters} SET weight = %d WHERE format = %d AND module = '%s' AND delta = %d", $weight, $form_state['values']['format'], $module, $delta);  }  drupal_set_message(t('The filter ordering has been saved.'));  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);}
<?php// $Id$/** * @file page.tpl.php * * Theme implementation to display a single Drupal page. * * Available variables: * * General utility variables: * - $base_path: The base URL path of the Drupal installation. At the very *   least, this will always default to /. * - $css: An array of CSS files for the current page. * - $directory: The directory the theme is located in, e.g. themes/garland or *   themes/garland/minelli. * - $is_front: TRUE if the current page is the front page. Used to toggle the mission statement. * - $logged_in: TRUE if the user is registered and signed in. * - $is_admin: TRUE if the user has permission to access administration pages. * * Page metadata: * - $language: (object) The language the site is being displayed in. *   $language->language contains its textual representation. *   $language->dir contains the language direction. It will either be 'ltr' or 'rtl'. * - $head_title: A modified version of the page title, for use in the TITLE tag. * - $head: Markup for the HEAD section (including meta tags, keyword tags, and *   so on). * - $styles: Style tags necessary to import all CSS files for the page. * - $scripts: Script tags necessary to load the JavaScript files and settings *   for the page. * - $body_classes: A set of CSS classes for the BODY tag. This contains flags *   indicating the current layout (multiple columns, single column), the current *   path, whether the user is logged in, and so on. * * Site identity: * - $front_page: The URL of the front page. Use this instead of $base_path, *   when linking to the front page. This includes the language domain or prefix. * - $logo: The path to the logo image, as defined in theme configuration. * - $site_name: The name of the site, empty when display has been disabled *   in theme settings. * - $site_slogan: The slogan of the site, empty when display has been disabled *   in theme settings. * - $mission: The text of the site mission, empty when display has been disabled *   in theme settings. * * Navigation: * - $search_box: HTML to display the search box, empty if search has been disabled. * - $primary_links (array): An array containing primary navigation links for the *   site, if they have been configured. * - $secondary_links (array): An array containing secondary navigation links for *   the site, if they have been configured. * * Page content (in order of occurrance in the default page.tpl.php): * - $left: The HTML for the left sidebar. * * - $breadcrumb: The breadcrumb trail for the current page. * - $title: The page title, for use in the actual HTML content. * - $help: Dynamic help text, mostly for admin pages. * - $messages: HTML for status and error messages. Should be displayed prominently. * - $tabs: Tabs linking to any sub-pages beneath the current page (e.g., the view *   and edit tabs when displaying a node). * * - $content: The main content of the current Drupal page. * * - $right: The HTML for the right sidebar. * * Footer/closing data: * - $feed_icons: A string of all feed icons for the current page. * - $footer_message: The footer message as defined in the admin settings. * - $footer : The footer region. * - $closure: Final closing markup from any modules that have altered the page. *   This variable should always be output last, after all other dynamic content. * * @see template_preprocess() * @see template_preprocess_page() */?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>"><head>  <?php print $head; ?>  <title><?php print $head_title; ?></title>  <?php print $styles; ?>  <?php print $scripts; ?>  <script type="text/javascript"><?php /* Needed to avoid Flash of Unstyled Content in IE */ ?> </script></head><body class="<?php print $body_classes; ?>">  <div id="page">    <div id="header">      <div id="logo-title">        <?php if (!empty($logo)): ?>          <a href="<?php print $front_page; ?>" title="<?php print t('Home'); ?>" rel="home" id="logo">            <img src="<?php print $logo; ?>" alt="<?php print t('Home'); ?>" />          </a>        <?php endif; ?>        <div id="name-and-slogan">          <?php if (!empty($site_name)): ?>            <h1 id="site-name">              <a href="<?php print $front_page ?>" title="<?php print t('Home'); ?>" rel="home"><span><?php print $site_name; ?></span></a>            </h1>          <?php endif; ?>          <?php if (!empty($site_slogan)): ?>            <div id="site-slogan"><?php print $site_slogan; ?></div>          <?php endif; ?>        </div> <!-- /name-and-slogan -->      </div> <!-- /logo-title -->      <?php if (!empty($search_box)): ?>        <div id="search-box"><?php print $search_box; ?></div>      <?php endif; ?>      <?php if (!empty($header)): ?>        <div id="header-region">          <?php print $header; ?>        </div>      <?php endif; ?>    </div> <!-- /header -->    <div id="container" class="clear-block">      <div id="navigation" class="menu <?php if (!empty($primary_links)) { print "withprimary"; } if (!empty($secondary_links)) { print " withsecondary"; } ?> ">        <?php if (!empty($primary_links)): ?>          <div id="primary" class="clear-block">            <?php print theme('links', $primary_links, array('class' => 'links primary-links')); ?>          </div>        <?php endif; ?>        <?php if (!empty($secondary_links)): ?>          <div id="secondary" class="clear-block">            <?php print theme('links', $secondary_links, array('class' => 'links secondary-links')); ?>          </div>        <?php endif; ?>      </div> <!-- /navigation -->      <?php if (!empty($left)): ?>        <div id="sidebar-left" class="column sidebar">          <?php print $left; ?>        </div> <!-- /sidebar-left -->      <?php endif; ?>      <div id="main" class="column"><div id="main-squeeze">        <?php if (!empty($breadcrumb)): ?><div id="breadcrumb"><?php print $breadcrumb; ?></div><?php endif; ?>        <?php if (!empty($mission)): ?><div id="mission"><?php print $mission; ?></div><?php endif; ?>        <div id="content">          <?php if (!empty($title)): ?><h1 class="title" id="page-title"><?php print $title; ?></h1><?php endif; ?>          <?php if (!empty($tabs)): ?><div class="tabs"><?php print $tabs; ?></div><?php endif; ?>          <?php if (!empty($messages)): print $messages; endif; ?>          <?php if (!empty($help)): print $help; endif; ?>          <div id="content-content" class="clear-block">            <?php print $content; ?>          </div> <!-- /content-content -->          <?php print $feed_icons; ?>        </div> <!-- /content -->      </div></div> <!-- /main-squeeze /main -->      <?php if (!empty($right)): ?>        <div id="sidebar-right" class="column sidebar">          <?php print $right; ?>        </div> <!-- /sidebar-right -->      <?php endif; ?>    </div> <!-- /container -->    <div id="footer-wrapper">      <div id="footer">        <?php print $footer_message; ?>        <?php if (!empty($footer)): print $footer; endif; ?>      </div> <!-- /footer -->    </div> <!-- /footer-wrapper -->    <?php print $closure; ?>  </div> <!-- /page --></body></html>
<?php// $Id$/** * @file * Enable users to post using applications that support XML-RPC blog APIs. *//** * Implementation of hook_help(). */function blogapi_help($path, $arg) {  switch ($path) {    case 'admin/help#blogapi':      $output = '<p>'. t("The Blog API module allows your site's users to access and post to their blogs from external blogging clients. External blogging clients are available for a wide range of desktop operating systems, and generally provide a feature-rich graphical environment for creating and editing posts.") .'</p>';      $output .= '<p>'. t('<a href="@ecto-link">Ecto</a>, a blogging client available for both Mac OS X and Microsoft Windows, can be used with Blog API. Blog API also supports <a href="@blogger-api">Blogger API</a>, <a href="@metaweblog-api">MetaWeblog API</a>, and most of the <a href="@movabletype-api">Movable Type API</a>. Blogging clients and other services (e.g. <a href="@flickr">Flickr\'s</a> "post to blog") that support these APIs may also be compatible.', array('@ecto-link' => url('http://infinite-sushi.com/software/ecto/'), '@blogger-api' => url('http://www.blogger.com/developers/api/1_docs/'), '@metaweblog-api' => url('http://www.xmlrpc.com/metaWeblogApi'), '@movabletype-api' => url('http://www.movabletype.org/docs/mtmanual_programmatic.html'), '@flickr' => url('http://www.flickr.com'))) .'</p>';      $output .= '<p>'. t('Select the content types available to external clients on the <a href="@blogapi-settings">Blog API settings page</a>. If supported and available, each content type will be displayed as a separate "blog" by the external client.', array('@blogapi-settings' => url('admin/settings/blogapi'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@blogapi">Blog API module</a>.', array('@blogapi' => url('http://drupal.org/handbook/modules/blogapi/'))) .'</p>';      return $output;  }}/** * Implementation of hook_perm(). */function blogapi_perm() {  return array('administer content with blog api');}/** * Implementation of hook_xmlrpc(). */function blogapi_xmlrpc() {  return array(    array(      'blogger.getUsersBlogs',      'blogapi_blogger_get_users_blogs',      array('array', 'string', 'string', 'string'),      t('Returns a list of blogs to which an author has posting privileges.')),    array(      'blogger.getUserInfo',      'blogapi_blogger_get_user_info',      array('struct', 'string', 'string', 'string'),      t('Returns information about an author in the system.')),    array(      'blogger.newPost',      'blogapi_blogger_new_post',      array('string', 'string', 'string', 'string', 'string', 'string', 'boolean'),      t('Creates a new post, and optionally publishes it.')),    array(      'blogger.editPost',      'blogapi_blogger_edit_post',      array('boolean', 'string', 'string', 'string', 'string', 'string', 'boolean'),      t('Updates the information about an existing post.')),    array(      'blogger.getPost',      'blogapi_blogger_get_post',      array('struct', 'string', 'string', 'string', 'string'),      t('Returns information about a specific post.')),    array(      'blogger.deletePost',      'blogapi_blogger_delete_post',      array('boolean', 'string', 'string', 'string', 'string', 'boolean'),      t('Deletes a post.')),    array(      'blogger.getRecentPosts',      'blogapi_blogger_get_recent_posts',      array('array', 'string', 'string', 'string', 'string', 'int'),      t('Returns a list of the most recent posts in the system.')),    array(      'metaWeblog.newPost',      'blogapi_metaweblog_new_post',      array('string', 'string', 'string', 'string', 'struct', 'boolean'),      t('Creates a new post, and optionally publishes it.')),    array(      'metaWeblog.editPost',      'blogapi_metaweblog_edit_post',      array('boolean', 'string', 'string', 'string', 'struct', 'boolean'),      t('Updates information about an existing post.')),    array(      'metaWeblog.getPost',      'blogapi_metaweblog_get_post',      array('struct', 'string', 'string', 'string'),      t('Returns information about a specific post.')),    array(      'metaWeblog.newMediaObject',      'blogapi_metaweblog_new_media_object',      array('string', 'string', 'string', 'string', 'struct'),      t('Uploads a file to your webserver.')),    array(      'metaWeblog.getCategories',      'blogapi_metaweblog_get_category_list',      array('struct', 'string', 'string', 'string'),      t('Returns a list of all categories to which the post is assigned.')),    array(      'metaWeblog.getRecentPosts',      'blogapi_metaweblog_get_recent_posts',      array('array', 'string', 'string', 'string', 'int'),      t('Returns a list of the most recent posts in the system.')),    array(      'mt.getRecentPostTitles',      'blogapi_mt_get_recent_post_titles',      array('array', 'string', 'string', 'string', 'int'),      t('Returns a bandwidth-friendly list of the most recent posts in the system.')),    array(      'mt.getCategoryList',      'blogapi_mt_get_category_list',      array('array', 'string', 'string', 'string'),      t('Returns a list of all categories defined in the blog.')),    array(      'mt.getPostCategories',      'blogapi_mt_get_post_categories',      array('array', 'string', 'string', 'string'),      t('Returns a list of all categories to which the post is assigned.')),    array(      'mt.setPostCategories',      'blogapi_mt_set_post_categories',      array('boolean', 'string', 'string', 'string', 'array'),      t('Sets the categories for a post.')),    array(      'mt.supportedMethods',      'xmlrpc_server_list_methods',      array('array'),      t('Retrieve information about the XML-RPC methods supported by the server.')),    array(      'mt.supportedTextFilters',      'blogapi_mt_supported_text_filters',      array('array'),      t('Retrieve information about the text formatting plugins supported by the server.')),    array(      'mt.publishPost',      'blogapi_mt_publish_post',      array('boolean', 'string', 'string', 'string'),      t('Publish (rebuild) all of the static files related to an entry from your blog. Equivalent to saving an entry in the system (but without the ping).')));}/** * Blogging API callback. Finds the URL of a user's blog. */function blogapi_blogger_get_users_blogs($appid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if ($user->uid) {    $types = _blogapi_get_node_types();    $structs = array();    foreach ($types as $type) {      $structs[] = array('url' => url('blog/'. $user->uid, array('absolute' => TRUE)), 'blogid' => $type, 'blogName' => $user->name .": ". $type);    }    return $structs;  }  else {    return blogapi_error($user);  }}/** * Blogging API callback. Returns profile information about a user. */function blogapi_blogger_get_user_info($appkey, $username, $password) {  $user = blogapi_validate_user($username, $password);  if ($user->uid) {    $name = explode(' ', $user->realname ? $user->realname : $user->name, 2);    return array(      'userid' => $user->uid,      'lastname' => $name[1],      'firstname' => $name[0],      'nickname' => $user->name,      'email' => $user->mail,      'url' => url('blog/'. $user->uid, array('absolute' => TRUE)));  }  else {    return blogapi_error($user);  }}/** * Blogging API callback. Inserts a new blog post as a node. */function blogapi_blogger_new_post($appkey, $blogid, $username, $password, $content, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  $edit = array();  $edit['type'] = $blogid;  // get the node type defaults  $node_type_default = variable_get('node_options_'. $edit['type'], array('status', 'promote'));  $edit['uid'] = $user->uid;  $edit['name'] = $user->name;  $edit['promote'] = in_array('promote', $node_type_default);  $edit['comment'] = variable_get('comment_'. $edit['type'], 2);  $edit['revision'] = in_array('revision', $node_type_default);  $edit['format'] = FILTER_FORMAT_DEFAULT;  $edit['status'] = $publish;  // check for bloggerAPI vs. metaWeblogAPI  if (is_array($content)) {    $edit['title'] = $content['title'];    $edit['body'] = $content['description'];    _blogapi_mt_extra($edit, $content);  }  else {    $edit['title'] = blogapi_blogger_title($content);    $edit['body'] = $content;  }  if (!node_access('create', $edit['type'])) {    return blogapi_error(t('You do not have permission to create this type of post.'));  }  if (user_access('administer nodes') && !isset($edit['date'])) {    $edit['date'] = format_date(time(), 'custom', 'Y-m-d H:i:s O');  }  node_invoke_nodeapi($edit, 'blogapi new');  $valid = blogapi_status_error_check($edit, $publish);  if ($valid !== TRUE) {    return $valid;  }  node_validate($edit);  if ($errors = form_get_errors()) {    return blogapi_error(implode("\n", $errors));  }  $node = node_submit($edit);  node_save($node);  if ($node->nid) {    watchdog('content', '@type: added %title using blog API.', array('@type' => $node->type, '%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), "node/$node->nid"));    // blogger.newPost returns a string so we cast the nid to a string by putting it in double quotes:    return "$node->nid";  }  return blogapi_error(t('Error storing post.'));}/** * Blogging API callback. Modifies the specified blog node. */function blogapi_blogger_edit_post($appkey, $postid, $username, $password, $content, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  if (!$node) {    return blogapi_error(t('n/a'));  }  // Let the teaser be re-generated.  unset($node->teaser);  if (!node_access('update', $node)) {    return blogapi_error(t('You do not have permission to update this post.'));  }  // Save the original status for validation of permissions.  $original_status = $node->status;  $node->status = $publish;  // check for bloggerAPI vs. metaWeblogAPI  if (is_array($content)) {    $node->title = $content['title'];    $node->body = $content['description'];    _blogapi_mt_extra($node, $content);  }  else {    $node->title = blogapi_blogger_title($content);    $node->body = $content;  }  node_invoke_nodeapi($node, 'blogapi edit');  $valid = blogapi_status_error_check($node, $original_status);  if ($valid !== TRUE) {    return $valid;  }  node_validate($node);  if ($errors = form_get_errors()) {    return blogapi_error(implode("\n", $errors));  }  if (user_access('administer nodes') && !isset($edit['date'])) {    $node->date = format_date($node->created, 'custom', 'Y-m-d H:i:s O');  }  $node = node_submit($node);  node_save($node);  if ($node->nid) {    watchdog('content', '@type: updated %title using Blog API.', array('@type' => $node->type, '%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), "node/$node->nid"));    return TRUE;  }  return blogapi_error(t('Error storing post.'));}/** * Blogging API callback. Returns a specified blog node. */function blogapi_blogger_get_post($appkey, $postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  return _blogapi_get_post($node, TRUE);}/** * Check that the user has permission to save the node with the chosen status. * * @return *   TRUE if no error, or the blogapi_error(). */function blogapi_status_error_check($node, $original_status) {    $node = (object) $node;  $node_type_default = variable_get('node_options_'. $node->type, array('status', 'promote'));  // If we don't have the 'administer nodes' permission and the status is  // changing or for a new node the status is not the content type's default,  // then return an error.  if (!user_access('administer nodes') && (($node->status != $original_status) || (empty($node->nid) && $node->status != in_array('status', $node_type_default)))) {    if ($node->status) {      return blogapi_error(t('You do not have permission to publish this type of post. Please save it as a draft instead.'));    }    else {      return blogapi_error(t('You do not have permission to save this post as a draft. Please publish it instead.'));    }  }  return TRUE;}/** * Blogging API callback. Removes the specified blog node. */function blogapi_blogger_delete_post($appkey, $postid, $username, $password, $publish) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  node_delete($postid);  return TRUE;}/** * Blogging API callback. Returns the latest few postings in a user's blog. $bodies TRUE * <a href="http://movabletype.org/docs/mtmanual_programmatic.html#item_mt%2EgetRecentPostTitles"> * returns a bandwidth-friendly list</a>. */function blogapi_blogger_get_recent_posts($appkey, $blogid, $username, $password, $number_of_posts, $bodies = TRUE) {  // Remove unused appkey (from bloggerAPI).  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  if ($bodies) {    $result = db_query_range("SELECT n.nid, n.title, r.body, r.format, n.comment, n.created, u.name FROM {node} n, {node_revisions} r, {users} u WHERE n.uid = u.uid AND n.vid = r.vid AND n.type = '%s' AND n.uid = %d ORDER BY n.created DESC",  $blogid, $user->uid, 0, $number_of_posts);  }  else {    $result = db_query_range("SELECT n.nid, n.title, n.created, u.name FROM {node} n, {users} u WHERE n.uid = u.uid AND n.type = '%s' AND n.uid = %d ORDER BY n.created DESC", $blogid, $user->uid, 0, $number_of_posts);  }  $blogs = array();  while ($blog = db_fetch_object($result)) {    $blogs[] = _blogapi_get_post($blog, $bodies);  }  return $blogs;}function blogapi_metaweblog_new_post($blogid, $username, $password, $content, $publish) {  return blogapi_blogger_new_post('0123456789ABCDEF', $blogid, $username, $password, $content, $publish);}function blogapi_metaweblog_edit_post($postid, $username, $password, $content, $publish) {  return blogapi_blogger_edit_post('0123456789ABCDEF', $postid, $username, $password, $content, $publish);}function blogapi_metaweblog_get_post($postid, $username, $password) {  return blogapi_blogger_get_post('01234567890ABCDEF', $postid, $username, $password);}/** * Blogging API callback. Inserts a file into Drupal. */function blogapi_metaweblog_new_media_object($blogid, $username, $password, $file) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $usersize = 0;  $uploadsize = 0;  $roles = array_intersect(user_roles(FALSE, 'administer content with blog api'), $user->roles);  foreach ($roles as $rid => $name) {    $extensions .= ' '. strtolower(variable_get("blogapi_extensions_$rid", variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp')));    $usersize= max($usersize, variable_get("blogapi_usersize_$rid", variable_get('blogapi_usersize_default', 1)) * 1024 * 1024);    $uploadsize = max($uploadsize, variable_get("blogapi_uploadsize_$rid", variable_get('blogapi_uploadsize_default', 1)) * 1024 * 1024);  }  $filesize = strlen($file['bits']);  if ($filesize > $uploadsize) {    return blogapi_error(t('It is not possible to upload the file, because it exceeded the maximum filesize of @maxsize.', array('@maxsize' => format_size($uploadsize))));  }  if (_blogapi_space_used($user->uid) + $filesize > $usersize) {    return blogapi_error(t('The file can not be attached to this post, because the disk quota of @quota has been reached.', array('@quota' => format_size($usersize))));  }  // Only allow files with whitelisted extensions and convert remaining dots to  // underscores to prevent attacks via non-terminal executable extensions with  // files such as exploit.php.jpg.  $whitelist = array_unique(explode(' ', trim($extensions)));  $name = basename($file['name']);  if ($extension_position = strrpos($name, '.')) {    $filename = drupal_substr($name, 0, $extension_position);    $final_extension = drupal_substr($name, $extension_position + 1);    if (!in_array(strtolower($final_extension), $whitelist)) {      return blogapi_error(t('It is not possible to upload the file, because it is only possible to upload files with the following extensions: @extensions', array('@extensions' => implode(' ', $whitelist))));    }    $filename = str_replace('.', '_', $filename);    $filename .= '.'. $final_extension;  }  $data = $file['bits'];  if (!$data) {    return blogapi_error(t('No file sent.'));  }  if (!$file = file_save_data($data, $filename)) {    return blogapi_error(t('Error storing file.'));  }  $row = new stdClass();  $row->uid = $user->uid;  $row->filepath = $file;  $row->filesize = $filesize;  drupal_write_record('blogapi_files', $row);  // Return the successful result.  return array('url' => file_create_url($file), 'struct');}/** * Blogging API callback. Returns a list of the taxonomy terms that can be * associated with a blog node. */function blogapi_metaweblog_get_category_list($blogid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  if (($error = _blogapi_validate_blogid($blogid)) !== TRUE) {    // Return an error if not configured type.    return $error;  }  $vocabularies = module_invoke('taxonomy', 'get_vocabularies', $blogid, 'vid');  $categories = array();  if ($vocabularies) {    foreach ($vocabularies as $vocabulary) {      $terms = module_invoke('taxonomy', 'get_tree', $vocabulary->vid, 0, -1);      foreach ($terms as $term) {        $term_name = $term->name;        foreach (module_invoke('taxonomy', 'get_parents', $term->tid, 'tid') as $parent) {          $term_name = $parent->name .'/'. $term_name;        }        $categories[] = array('categoryName' => $term_name, 'categoryId' => $term->tid);      }    }  }  return $categories;}function blogapi_metaweblog_get_recent_posts($blogid, $username, $password, $number_of_posts) {  return blogapi_blogger_get_recent_posts('0123456789ABCDEF', $blogid, $username, $password, $number_of_posts, TRUE);}function blogapi_mt_get_recent_post_titles($blogid, $username, $password, $number_of_posts) {  return blogapi_blogger_get_recent_posts('0123456789ABCDEF', $blogid, $username, $password, $number_of_posts, FALSE);}function blogapi_mt_get_category_list($blogid, $username, $password) {  return blogapi_metaweblog_get_category_list($blogid, $username, $password);}/** * Blogging API callback. Returns a list of the taxonomy terms that are * assigned to a particular node. */function blogapi_mt_get_post_categories($postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  $terms = module_invoke('taxonomy', 'node_get_terms', $node, 'tid');  $categories = array();  foreach ($terms as $term) {    $term_name = $term->name;    foreach (module_invoke('taxonomy', 'get_parents', $term->tid, 'tid') as $parent) {      $term_name = $parent->name .'/'. $term_name;    }    $categories[] = array('categoryName' => $term_name, 'categoryId' => $term->tid, 'isPrimary' => TRUE);  }  return $categories;}/** * Blogging API callback. Assigns taxonomy terms to a particular node. */function blogapi_mt_set_post_categories($postid, $username, $password, $categories) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  $node->taxonomy = array();  foreach ($categories as $category) {    $node->taxonomy[] = $category['categoryId'];  }  $validated = blogapi_mt_validate_terms($node);  if ($validated !== TRUE) {    return $validated;  }  node_save($node);  return TRUE;}/** * Blogging API helper - find allowed taxonomy terms for a node type. */function blogapi_mt_validate_terms($node) {  // We do a lot of heavy lifting here since taxonomy module doesn't have a  // stand-alone validation function.  if (module_exists('taxonomy')) {    $found_terms = array();    if (!empty($node->taxonomy)) {      $term_list = array_unique($node->taxonomy);      $params = $term_list;      $params[] = $node->type;      $result = db_query(db_rewrite_sql("SELECT t.tid, t.vid FROM {term_data} t INNER JOIN {vocabulary_node_types} n ON t.vid = n.vid WHERE t.tid IN (". db_placeholders($term_list) .") AND n.type = '%s'", 't', 'tid'), $params);      $found_terms = array();      $found_count = 0;      while ($term = db_fetch_object($result)) {        $found_terms[$term->vid][$term->tid] = $term->tid;        $found_count++;      }      // If the counts don't match, some terms are invalid or not accessible to this user.      if (count($term_list) != $found_count) {        return blogapi_error(t('Invalid categories submitted.'));      }    }    // Look up all the vocabularies for this node type.    $result2 = db_query(db_rewrite_sql("SELECT v.vid, v.name, v.required, v.multiple FROM {vocabulary} v INNER JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s'", 'v', 'vid'), $node->type);    // Check each vocabulary associated with this node type.    while ($vocabulary = db_fetch_object($result2)) {      // Required vocabularies must have at least one term.      if ($vocabulary->required && empty($found_terms[$vocabulary->vid])) {        return blogapi_error(t('A category from the @vocabulary_name vocabulary is required.', array('@vocabulary_name' => $vocabulary->name)));      }      // Vocabularies that don't allow multiple terms may have at most one.      if (!($vocabulary->multiple) && (isset($found_terms[$vocabulary->vid]) && count($found_terms[$vocabulary->vid]) > 1)) {        return blogapi_error(t('You may only choose one category from the @vocabulary_name vocabulary.'), array('@vocabulary_name' => $vocabulary->name));      }    }  }  elseif (!empty($node->taxonomy)) {    return blogapi_error(t('Error saving categories. This feature is not available.'));  }  return TRUE;}/** * Blogging API callback. Sends a list of available input formats. */function blogapi_mt_supported_text_filters() {  // NOTE: we're only using anonymous' formats because the MT spec  // does not allow for per-user formats.  $formats = filter_formats();  $filters = array();  foreach ($formats as $format) {    $filter['key'] = $format->format;    $filter['label'] = $format->name;    $filters[] = $filter;  }  return $filters;}/** * Blogging API callback. Publishes the given node */function blogapi_mt_publish_post($postid, $username, $password) {  $user = blogapi_validate_user($username, $password);  if (!$user->uid) {    return blogapi_error($user);  }  $node = node_load($postid);  if (!$node) {    return blogapi_error(t('Invalid post.'));  }  // Nothing needs to be done if already published.  if ($node->status) {    return;  }  if (!node_access('update', $node) || !user_access('administer nodes')) {    return blogapi_error(t('You do not have permission to update this post.'));  }  $node->status = 1;  node_save($node);  return TRUE;}/** * Prepare an error message for returning to the XMLRPC caller. */function blogapi_error($message) {  static $xmlrpcusererr;  if (!is_array($message)) {    $message = array($message);  }  $message = implode(' ', $message);  return xmlrpc_error($xmlrpcusererr + 1, strip_tags($message));}/** * Ensure that the given user has permission to edit a blog. */function blogapi_validate_user($username, $password) {  global $user;  $user = user_authenticate(array('name' => $username, 'pass' => $password));  if ($user->uid) {    if (user_access('administer content with blog api', $user)) {      return $user;    }    else {      return t('You do not have permission to edit this blog.');    }  }  else {    return t('Wrong username or password.');  }}/** * For the blogger API, extract the node title from the contents field. */function blogapi_blogger_title(&$contents) {  if (eregi('<title>([^<]*)</title>', $contents, $title)) {    $title = strip_tags($title[0]);    $contents = ereg_replace('<title>[^<]*</title>', '', $contents);  }  else {    list($title, $contents) = explode("\n", $contents, 2);  }  return $title;}function blogapi_admin_settings() {  $node_types = array_map('check_plain', node_get_types('names'));  $defaults = isset($node_types['blog']) ? array('blog' => 1) : array();  $form['blogapi_node_types'] = array(    '#type' => 'checkboxes',    '#title' => t('Enable for external blogging clients'),    '#required' => TRUE,    '#default_value' => variable_get('blogapi_node_types', $defaults),    '#options' => $node_types,    '#description' => t('Select the content types available to external blogging clients via Blog API. If supported, each enabled content type will be displayed as a separate "blog" by the external client.')  );  $blogapi_extensions_default = variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp');  $blogapi_uploadsize_default = variable_get('blogapi_uploadsize_default', 1);  $blogapi_usersize_default = variable_get('blogapi_usersize_default', 1);  $form['settings_general'] = array(    '#type' => 'fieldset',    '#title' => t('File settings'),    '#collapsible' => TRUE,  );  $form['settings_general']['blogapi_extensions_default'] = array(    '#type' => 'textfield',    '#title' => t('Default permitted file extensions'),    '#default_value' => $blogapi_extensions_default,    '#maxlength' => 255,    '#description' => t('Default extensions that users can upload. Separate extensions with a space and do not include the leading dot.'),  );  $form['settings_general']['blogapi_uploadsize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default maximum file size per upload'),    '#default_value' => $blogapi_uploadsize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum file size a user can upload.'),    '#field_suffix' => t('MB')  );  $form['settings_general']['blogapi_usersize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default total file size per user'),    '#default_value' => $blogapi_usersize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum size of all files a user can have on the site.'),    '#field_suffix' => t('MB')  );  $form['settings_general']['upload_max_size'] = array('#value' => '<p>'. t('Your PHP settings limit the maximum file size per upload to %size.', array('%size' => format_size(file_upload_max_size()))).'</p>');  $roles = user_roles(0, 'administer content with blog api');  $form['roles'] = array('#type' => 'value', '#value' => $roles);  foreach ($roles as $rid => $role) {    $form['settings_role_'. $rid] = array(      '#type' => 'fieldset',      '#title' => t('Settings for @role', array('@role' => $role)),      '#collapsible' => TRUE,      '#collapsed' => TRUE,    );    $form['settings_role_'. $rid]['blogapi_extensions_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Permitted file extensions'),      '#default_value' => variable_get('blogapi_extensions_'. $rid, $blogapi_extensions_default),      '#maxlength' => 255,      '#description' => t('Extensions that users in this role can upload. Separate extensions with a space and do not include the leading dot.'),    );    $form['settings_role_'. $rid]['blogapi_uploadsize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Maximum file size per upload'),      '#default_value' => variable_get('blogapi_uploadsize_'. $rid, $blogapi_uploadsize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of a file a user can upload (in megabytes).'),    );    $form['settings_role_'. $rid]['blogapi_usersize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Total file size per user'),      '#default_value' => variable_get('blogapi_usersize_'. $rid, $blogapi_usersize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of all files a user can have on the site (in megabytes).'),    );  }  return system_settings_form($form);}function blogapi_menu() {  $items['blogapi/rsd'] = array(    'title' => 'RSD',    'page callback' => 'blogapi_rsd',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/blogapi'] = array(    'title' => 'Blog API',    'description' => 'Configure the content types available to external blogging clients.',    'page callback' => 'drupal_get_form',    'page arguments' => array('blogapi_admin_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_NORMAL_ITEM,  );  return $items;}function blogapi_init() {  if (drupal_is_front_page()) {    drupal_add_link(array('rel' => 'EditURI',                          'type' => 'application/rsd+xml',                          'title' => t('RSD'),                          'href' => url('blogapi/rsd', array('absolute' => TRUE))));  }}function blogapi_rsd() {  global $base_url;  $xmlrpc = $base_url .'/xmlrpc.php';  $base = url('', array('absolute' => TRUE));  $blogid = 1; # until we figure out how to handle multiple bloggers  drupal_set_header('Content-Type: application/rsd+xml; charset=utf-8');  print <<<__RSD__<?xml version="1.0"?><rsd version="1.0" xmlns="http://archipelago.phrasewise.com/rsd">  <service>    <engineName>Drupal</engineName>    <engineLink>http://drupal.org/</engineLink>    <homePageLink>$base</homePageLink>    <apis>      <api name="MetaWeblog" preferred="false" apiLink="$xmlrpc" blogID="$blogid" />      <api name="Blogger" preferred="false" apiLink="$xmlrpc" blogID="$blogid" />      <api name="MovableType" preferred="true" apiLink="$xmlrpc" blogID="$blogid" />    </apis>  </service></rsd>__RSD__;}/** * Handles extra information sent by clients according to MovableType's spec. */function _blogapi_mt_extra(&$node, $struct) {  if (is_array($node)) {    $was_array = TRUE;    $node = (object)$node;  }  // mt_allow_comments  if (array_key_exists('mt_allow_comments', $struct)) {    switch ($struct['mt_allow_comments']) {      case 0:        $node->comment = COMMENT_NODE_DISABLED;        break;      case 1:        $node->comment = COMMENT_NODE_READ_WRITE;        break;      case 2:        $node->comment = COMMENT_NODE_READ_ONLY;        break;    }  }  // merge the 3 body sections (description, mt_excerpt, mt_text_more) into  // one body  if ($struct['mt_excerpt']) {    $node->body = $struct['mt_excerpt'] .'<!--break-->'. $node->body;  }  if ($struct['mt_text_more']) {    $node->body = $node->body .'<!--extended-->'. $struct['mt_text_more'];  }  // mt_convert_breaks  if ($struct['mt_convert_breaks']) {    $node->format = $struct['mt_convert_breaks'];  }  // dateCreated  if ($struct['dateCreated']) {    $node->date = format_date(mktime($struct['dateCreated']->hour, $struct['dateCreated']->minute, $struct['dateCreated']->second, $struct['dateCreated']->month, $struct['dateCreated']->day, $struct['dateCreated']->year), 'custom', 'Y-m-d H:i:s O');  }  if ($was_array) {    $node = (array)$node;  }}function _blogapi_get_post($node, $bodies = TRUE) {  $xmlrpcval = array(    'userid' => $node->name,    'dateCreated' => xmlrpc_date($node->created),    'title' => $node->title,    'postid' => $node->nid,    'link' => url('node/'. $node->nid, array('absolute' => TRUE)),    'permaLink' => url('node/'. $node->nid, array('absolute' => TRUE)),  );  if ($bodies) {    if ($node->comment == 1) {      $comment = 2;    }    else if ($node->comment == 2) {      $comment = 1;    }    $xmlrpcval['content'] = "<title>$node->title</title>$node->body";    $xmlrpcval['description'] = $node->body;    // Add MT specific fields    $xmlrpcval['mt_allow_comments'] = (int) $comment;    $xmlrpcval['mt_convert_breaks'] = $node->format;  }  return $xmlrpcval;}/** * Validate blog ID, which maps to a content type in Drupal. * * Only content types configured to work with Blog API are supported. * * @return *   TRUE if the content type is supported and the user has permission *   to post, or a blogapi_error() XML construct otherwise. */function _blogapi_validate_blogid($blogid) {  $types = _blogapi_get_node_types();  if (in_array($blogid, $types, TRUE)) {    return TRUE;  }  return blogapi_error(t("Blog API module is not configured to support the %type content type, or you don't have sufficient permissions to post this type of content.", array('%type' => $blogid)));}function _blogapi_get_node_types() {  $available_types = array_keys(array_filter(variable_get('blogapi_node_types', array('blog' => 1))));  $types = array();  foreach (node_get_types() as $type => $name) {    if (node_access('create', $type) && in_array($type, $available_types)) {      $types[] = $type;    }  }  return $types;}function _blogapi_space_used($uid) {  return db_result(db_query('SELECT SUM(filesize) FROM {blogapi_files} f WHERE f.uid = %d', $uid));}
<?php// $Id$/** * @file comment.tpl.php * Default theme implementation for comments. * * Available variables: * - $author: Comment author. Can be link or plain text. * - $content: Body of the post. * - $date: Date and time of posting. * - $links: Various operational links. * - $new: New comment marker. * - $picture: Authors picture. * - $signature: Authors signature. * - $status: Comment status. Possible values are: *   comment-unpublished, comment-published or comment-preview. * - $submitted: By line with date and time. * - $title: Linked title. * * These two variables are provided for context. * - $comment: Full comment object. * - $node: Node object the comments are attached to. * * @see template_preprocess_comment() * @see theme_comment() */?><div class="comment<?php print ($comment->new) ? ' comment-new' : ''; print ' '. $status ?> clear-block">  <?php print $picture ?>  <?php if ($comment->new): ?>    <span class="new"><?php print $new ?></span>  <?php endif; ?>  <h3><?php print $title ?></h3>  <div class="submitted">    <?php print $submitted ?>  </div>  <div class="content">    <?php print $content ?>    <?php if ($signature): ?>    <div class="user-signature clear-block">      <?php print $signature ?>    </div>    <?php endif; ?>  </div>  <?php print $links ?></div>
<?php// $Id$/** * @file * Admin page callback file for the user module. */function user_admin($callback_arg = '') {  $op = isset($_POST['op']) ? $_POST['op'] : $callback_arg;  switch ($op) {    case t('Create new account'):    case 'create':      $output = drupal_get_form('user_register');      break;    default:      if (!empty($_POST['accounts']) && isset($_POST['operation']) && ($_POST['operation'] == 'delete')) {        $output = drupal_get_form('user_multiple_delete_confirm');      }      else {        $output = drupal_get_form('user_filter_form');        $output .= drupal_get_form('user_admin_account');      }  }  return $output;}/** * Form builder; Return form for user administration filters. * * @ingroup forms * @see user_filter_form_submit() */function user_filter_form() {  $session = &$_SESSION['user_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = user_filters();  $i = 0;  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Show only users where'),    '#theme' => 'user_filters',  );  foreach ($session as $filter) {    list($type, $value) = $filter;    // Merge an array of arrays into one if necessary.    $options = $type == 'permission' ? call_user_func_array('array_merge', $filters[$type]['options']) : $filters[$type]['options'];    $params = array('%property' => $filters[$type]['title'] , '%value' => $options[$value]);    if ($i++ > 0) {      $form['filters']['current'][] = array('#value' => t('<em>and</em> where <strong>%property</strong> is <strong>%value</strong>', $params));    }    else {      $form['filters']['current'][] = array('#value' => t('<strong>%property</strong> is <strong>%value</strong>', $params));    }  }  foreach ($filters as $key => $filter) {    $names[$key] = $filter['title'];    $form['filters']['status'][$key] = array(      '#type' => 'select',      '#options' => $filter['options'],    );  }  $form['filters']['filter'] = array(    '#type' => 'radios',    '#options' => $names,  );  $form['filters']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => (count($session) ? t('Refine') : t('Filter')),  );  if (count($session)) {    $form['filters']['buttons']['undo'] = array(      '#type' => 'submit',      '#value' => t('Undo'),    );    $form['filters']['buttons']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset'),    );  }  drupal_add_js('misc/form.js', 'core');  return $form;}/** * Process result from user administration filter form. */function user_filter_form_submit($form, &$form_state) {  $op = $form_state['values']['op'];  $filters = user_filters();  switch ($op) {    case t('Filter'): case t('Refine'):      if (isset($form_state['values']['filter'])) {        $filter = $form_state['values']['filter'];        // Merge an array of arrays into one if necessary.        $options = $filter == 'permission' ? call_user_func_array('array_merge', $filters[$filter]['options']) : $filters[$filter]['options'];        if (isset($options[$form_state['values'][$filter]])) {          $_SESSION['user_overview_filter'][] = array($filter, $form_state['values'][$filter]);        }      }      break;    case t('Undo'):      array_pop($_SESSION['user_overview_filter']);      break;    case t('Reset'):      $_SESSION['user_overview_filter'] = array();      break;    case t('Update'):      return;  }  $form_state['redirect'] = 'admin/user/user';  return;}/** * Form builder; User administration page. * * @ingroup forms * @see user_admin_account_validate() * @see user_admin_account_submit() */function user_admin_account() {  $filter = user_build_filter_query();  $header = array(    array(),    array('data' => t('Username'), 'field' => 'u.name'),    array('data' => t('Status'), 'field' => 'u.status'),    t('Roles'),    array('data' => t('Member for'), 'field' => 'u.created', 'sort' => 'desc'),    array('data' => t('Last access'), 'field' => 'u.access'),    t('Operations')  );  if ($filter['join'] != "") {    $sql = 'SELECT DISTINCT u.uid, u.name, u.status, u.created, u.access FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid '. $filter['join'] .' WHERE u.uid != 0 '. $filter['where'];    $query_count = 'SELECT COUNT(DISTINCT u.uid) FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid '. $filter['join'] .' WHERE u.uid != 0 '. $filter['where'];  }  else {    $sql = 'SELECT u.uid, u.name, u.status, u.created, u.access FROM {users} u WHERE u.uid != 0 '. $filter['where'];    $query_count = 'SELECT COUNT(u.uid) FROM {users} u WHERE u.uid != 0 '. $filter['where'];  }    $sql .= tablesort_sql($header);  $result = pager_query($sql, 50, 0, $query_count, $filter['args']);  $form['options'] = array(    '#type' => 'fieldset',    '#title' => t('Update options'),    '#prefix' => '<div class="container-inline">',    '#suffix' => '</div>',  );  $options = array();  foreach (module_invoke_all('user_operations') as $operation => $array) {    $options[$operation] = $array['label'];  }  $form['options']['operation'] = array(    '#type' => 'select',    '#options' => $options,    '#default_value' => 'unblock',  );  $form['options']['submit'] = array(    '#type' => 'submit',    '#value' => t('Update'),  );  $destination = drupal_get_destination();  $status = array(t('blocked'), t('active'));  $roles = user_roles(TRUE);  $accounts = array();  while ($account = db_fetch_object($result)) {    $accounts[$account->uid] = '';    $form['name'][$account->uid] = array('#value' => theme('username', $account));    $form['status'][$account->uid] =  array('#value' => $status[$account->status]);    $users_roles = array();    $roles_result = db_query('SELECT rid FROM {users_roles} WHERE uid = %d', $account->uid);    while ($user_role = db_fetch_object($roles_result)) {      $users_roles[] = $roles[$user_role->rid];    }    asort($users_roles);    $form['roles'][$account->uid][0] = array('#value' => theme('item_list', $users_roles));    $form['member_for'][$account->uid] = array('#value' => format_interval(time() - $account->created));    $form['last_access'][$account->uid] =  array('#value' => $account->access ? t('@time ago', array('@time' => format_interval(time() - $account->access))) : t('never'));    $form['operations'][$account->uid] = array('#value' => l(t('edit'), "user/$account->uid/edit", array('query' => $destination)));  }  $form['accounts'] = array(    '#type' => 'checkboxes',    '#options' => $accounts  );  $form['pager'] = array('#value' => theme('pager', NULL, 50, 0));  return $form;}/** * Submit the user administration update form. */function user_admin_account_submit($form, &$form_state) {  $operations = module_invoke_all('user_operations', $form_state);  $operation = $operations[$form_state['values']['operation']];  // Filter out unchecked accounts.  $accounts = array_filter($form_state['values']['accounts']);  if ($function = $operation['callback']) {    // Add in callback arguments if present.    if (isset($operation['callback arguments'])) {      $args = array_merge(array($accounts), $operation['callback arguments']);    }    else {      $args = array($accounts);    }    call_user_func_array($function, $args);    drupal_set_message(t('The update has been performed.'));  }}function user_admin_account_validate($form, &$form_state) {  $form_state['values']['accounts'] = array_filter($form_state['values']['accounts']);  if (count($form_state['values']['accounts']) == 0) {    form_set_error('', t('No users selected.'));  }}/** * Form builder; Configure user settings for this site. * * @ingroup forms * @see system_settings_form() */function user_admin_settings() {  // User registration settings.  $form['registration'] = array('#type' => 'fieldset', '#title' => t('User registration settings'));  $form['registration']['user_register'] = array('#type' => 'radios', '#title' => t('Public registrations'), '#default_value' => variable_get('user_register', 1), '#options' => array(t('Only site administrators can create new user accounts.'), t('Visitors can create accounts and no administrator approval is required.'), t('Visitors can create accounts but administrator approval is required.')));  $form['registration']['user_email_verification'] = array('#type' => 'checkbox', '#title' => t('Require e-mail verification when a visitor creates an account'), '#default_value' => variable_get('user_email_verification', TRUE), '#description' => t('If this box is checked, new users will be required to validate their e-mail address prior to logging into the site, and will be assigned a system-generated password. With it unchecked, users will be logged in immediately upon registering, and may select their own passwords during registration.'));  $form['registration']['user_registration_help'] = array('#type' => 'textarea', '#title' => t('User registration guidelines'), '#default_value' => variable_get('user_registration_help', ''), '#description' => t('This text is displayed at the top of the user registration form and is useful for helping or instructing your users.'));  // User e-mail settings.  $form['email'] = array(    '#type' => 'fieldset',    '#title' => t('User e-mail settings'),    '#description' => t('Drupal sends emails whenever new users register on your site, and optionally, may also notify users after other account actions. Using a simple set of content templates, notification e-mails can be customized to fit the specific needs of your site.'),  );  // These email tokens are shared for all settings, so just define  // the list once to help ensure they stay in sync.  $email_token_help = t('Available variables are:') .' !username, !site, !password, !uri, !uri_brief, !mailto, !date, !login_uri, !edit_uri, !login_url.';  $form['email']['admin_created'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, new user created by administrator'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 0),    '#description' => t('Customize welcome e-mail messages sent to new member accounts created by an administrator.') .' '. $email_token_help,  );  $form['email']['admin_created']['user_mail_register_admin_created_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_admin_created_subject'),    '#maxlength' => 180,  );  $form['email']['admin_created']['user_mail_register_admin_created_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_admin_created_body'),    '#rows' => 15,  );  $form['email']['no_approval_required'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, no approval required'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 1),    '#description' => t('Customize welcome e-mail messages sent to new members upon registering, when no administrator approval is required.') .' '. $email_token_help  );  $form['email']['no_approval_required']['user_mail_register_no_approval_required_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_no_approval_required_subject'),    '#maxlength' => 180,  );  $form['email']['no_approval_required']['user_mail_register_no_approval_required_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_no_approval_required_body'),    '#rows' => 15,  );  $form['email']['pending_approval'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, awaiting administrator approval'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 2),    '#description' => t('Customize welcome e-mail messages sent to new members upon registering, when administrative approval is required.') .' '. $email_token_help,  );  $form['email']['pending_approval']['user_mail_register_pending_approval_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_pending_approval_subject'),    '#maxlength' => 180,  );  $form['email']['pending_approval']['user_mail_register_pending_approval_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_pending_approval_body'),    '#rows' => 8,  );  $form['email']['password_reset'] = array(    '#type' => 'fieldset',    '#title' => t('Password recovery email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Customize e-mail messages sent to users who request a new password.') .' '. $email_token_help,  );  $form['email']['password_reset']['user_mail_password_reset_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('password_reset_subject'),    '#maxlength' => 180,  );  $form['email']['password_reset']['user_mail_password_reset_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('password_reset_body'),    '#rows' => 12,  );  $form['email']['activated'] = array(    '#type' => 'fieldset',    '#title' => t('Account activation email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users upon account activation (when an administrator activates an account of a user who has already registered, on a site where administrative approval is required).') .' '. $email_token_help,  );  $form['email']['activated']['user_mail_status_activated_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is activated.'),    '#default_value' => variable_get('user_mail_status_activated_notify', TRUE),  );  $form['email']['activated']['user_mail_status_activated_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_activated_subject'),    '#maxlength' => 180,  );  $form['email']['activated']['user_mail_status_activated_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_activated_body'),    '#rows' => 15,  );  $form['email']['blocked'] = array(    '#type' => 'fieldset',    '#title' => t('Account blocked email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users when their accounts are blocked.') .' '. $email_token_help,  );  $form['email']['blocked']['user_mail_status_blocked_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is blocked.'),    '#default_value' => variable_get('user_mail_status_blocked_notify', FALSE),  );  $form['email']['blocked']['user_mail_status_blocked_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_blocked_subject'),    '#maxlength' => 180,  );  $form['email']['blocked']['user_mail_status_blocked_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_blocked_body'),    '#rows' => 3,  );  $form['email']['deleted'] = array(    '#type' => 'fieldset',    '#title' => t('Account deleted email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users when their accounts are deleted.') .' '. $email_token_help,  );  $form['email']['deleted']['user_mail_status_deleted_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is deleted.'),    '#default_value' => variable_get('user_mail_status_deleted_notify', FALSE),  );  $form['email']['deleted']['user_mail_status_deleted_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_deleted_subject'),    '#maxlength' => 180,  );  $form['email']['deleted']['user_mail_status_deleted_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_deleted_body'),    '#rows' => 3,  );  // User signatures.  $form['signatures'] = array(    '#type' => 'fieldset',    '#title' => t('Signatures'),  );  $form['signatures']['user_signatures'] = array(    '#type' => 'radios',    '#title' => t('Signature support'),    '#default_value' => variable_get('user_signatures', 0),    '#options' => array(t('Disabled'), t('Enabled')),  );  // If picture support is enabled, check whether the picture directory exists:  if (variable_get('user_pictures', 0)) {    $picture_path = file_create_path(variable_get('user_picture_path', 'pictures'));    file_check_directory($picture_path, 1, 'user_picture_path');  }  $form['pictures'] = array(    '#type' => 'fieldset',    '#title' => t('Pictures'),  );  $picture_support = variable_get('user_pictures', 0);  $form['pictures']['user_pictures'] = array(    '#type' => 'radios',    '#title' => t('Picture support'),    '#default_value' => $picture_support,    '#options' => array(t('Disabled'), t('Enabled')),    '#prefix' => '<div class="user-admin-picture-radios">',    '#suffix' => '</div>',  );  drupal_add_js(drupal_get_path('module', 'user') .'/user.js');  // If JS is enabled, and the radio is defaulting to off, hide all  // the settings on page load via .css using the js-hide class so  // that there's no flicker.  $css_class = 'user-admin-picture-settings';  if (!$picture_support) {    $css_class .= ' js-hide';  }  $form['pictures']['settings'] = array(    '#prefix' => '<div class="'. $css_class .'">',    '#suffix' => '</div>',  );  $form['pictures']['settings']['user_picture_path'] = array(    '#type' => 'textfield',    '#title' => t('Picture image path'),    '#default_value' => variable_get('user_picture_path', 'pictures'),    '#size' => 30,    '#maxlength' => 255,    '#description' => t('Subdirectory in the directory %dir where pictures will be stored.', array('%dir' => file_directory_path() .'/')),  );  $form['pictures']['settings']['user_picture_default'] = array(    '#type' => 'textfield',    '#title' => t('Default picture'),    '#default_value' => variable_get('user_picture_default', ''),    '#size' => 30,    '#maxlength' => 255,    '#description' => t('URL of picture to display for users with no custom picture selected. Leave blank for none.'),  );  $form['pictures']['settings']['user_picture_dimensions'] = array(    '#type' => 'textfield',    '#title' => t('Picture maximum dimensions'),    '#default_value' => variable_get('user_picture_dimensions', '85x85'),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('Maximum dimensions for pictures, in pixels.'),  );  $form['pictures']['settings']['user_picture_file_size'] = array(    '#type' => 'textfield',    '#title' => t('Picture maximum file size'),    '#default_value' => variable_get('user_picture_file_size', '30'),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('Maximum file size for pictures, in kB.'),  );  $form['pictures']['settings']['user_picture_guidelines'] = array(    '#type' => 'textarea',    '#title' => t('Picture guidelines'),    '#default_value' => variable_get('user_picture_guidelines', ''),    '#description' => t("This text is displayed at the picture upload form in addition to the default guidelines. It's useful for helping or instructing your users."),  );  return system_settings_form($form);}/** * Menu callback: administer permissions. * * @ingroup forms * @see user_admin_perm_submit() * @see theme_user_admin_perm() */function user_admin_perm($form_state, $rid = NULL) {  if (is_numeric($rid)) {    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid WHERE r.rid = %d', $rid);  }  else {    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid ORDER BY name');  }  // Compile role array:  // Add a comma at the end so when searching for a permission, we can  // always search for "$perm," to make sure we do not confuse  // permissions that are substrings of each other.  while ($role = db_fetch_object($result)) {    $role_permissions[$role->rid] = $role->perm .',';  }  // Retrieve role names for columns.  $role_names = user_roles();  if (is_numeric($rid)) {    $role_names = array($rid => $role_names[$rid]);  }  // Render role/permission overview:  $options = array();  foreach (module_list(FALSE, FALSE, TRUE) as $module) {    if ($permissions = module_invoke($module, 'perm')) {      $form['permission'][] = array(        '#value' => $module,      );      asort($permissions);      foreach ($permissions as $perm) {        $options[$perm] = '';        $form['permission'][$perm] = array('#value' => t($perm));        foreach ($role_names as $rid => $name) {          // Builds arrays for checked boxes for each role          if (strpos($role_permissions[$rid], $perm .',') !== FALSE) {            $status[$rid][] = $perm;          }        }      }    }  }  // Have to build checkboxes here after checkbox arrays are built  foreach ($role_names as $rid => $name) {    $form['checkboxes'][$rid] = array('#type' => 'checkboxes', '#options' => $options, '#default_value' => isset($status[$rid]) ? $status[$rid] : array());    $form['role_names'][$rid] = array('#value' => $name, '#tree' => TRUE);  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save permissions'));  return $form;}function user_admin_perm_submit($form, &$form_state) {  // Save permissions:  $result = db_query('SELECT * FROM {role}');  while ($role = db_fetch_object($result)) {    if (isset($form_state['values'][$role->rid])) {      // Delete, so if we clear every checkbox we reset that role;      // otherwise permissions are active and denied everywhere.      db_query('DELETE FROM {permission} WHERE rid = %d', $role->rid);      $form_state['values'][$role->rid] = array_filter($form_state['values'][$role->rid]);      if (count($form_state['values'][$role->rid])) {        db_query("INSERT INTO {permission} (rid, perm) VALUES (%d, '%s')", $role->rid, implode(', ', array_keys($form_state['values'][$role->rid])));      }    }  }  drupal_set_message(t('The changes have been saved.'));  // Clear the cached pages  cache_clear_all();}/** * Theme the administer permissions page. * * @ingroup themeable */function theme_user_admin_perm($form) {  $roles = user_roles();  foreach (element_children($form['permission']) as $key) {    // Don't take form control structures    if (is_array($form['permission'][$key])) {      $row = array();      // Module name      if (is_numeric($key)) {        $row[] = array('data' => t('@module module', array('@module' => drupal_render($form['permission'][$key]))), 'class' => 'module', 'id' => 'module-'. $form['permission'][$key]['#value'], 'colspan' => count($form['role_names']) + 1);      }      else {        $row[] = array('data' => drupal_render($form['permission'][$key]), 'class' => 'permission');        foreach (element_children($form['checkboxes']) as $rid) {          if (is_array($form['checkboxes'][$rid])) {            $row[] = array('data' => drupal_render($form['checkboxes'][$rid][$key]), 'class' => 'checkbox', 'title' => $roles[$rid] .' : '. t($key));          }        }      }      $rows[] = $row;    }  }  $header[] = (t('Permission'));  foreach (element_children($form['role_names']) as $rid) {    if (is_array($form['role_names'][$rid])) {      $header[] = array('data' => drupal_render($form['role_names'][$rid]), 'class' => 'checkbox');    }  }  $output = theme('table', $header, $rows, array('id' => 'permissions'));  $output .= drupal_render($form);  return $output;}/** * Menu callback: administer roles. * * @ingroup forms * @see user_admin_role_validate() * @see user_admin_role_submit() * @see theme_user_admin_new_role() */function user_admin_role() {  $rid = arg(4);  if ($rid) {    if ($rid == DRUPAL_ANONYMOUS_RID || $rid == DRUPAL_AUTHENTICATED_RID) {      drupal_goto('admin/user/roles');    }    // Display the edit role form.    $role = db_fetch_object(db_query('SELECT * FROM {role} WHERE rid = %d', $rid));    $form['name'] = array(      '#type' => 'textfield',      '#title' => t('Role name'),      '#default_value' => $role->name,      '#size' => 30,      '#required' => TRUE,      '#maxlength' => 64,      '#description' => t('The name for this role. Example: "moderator", "editorial board", "site architect".'),    );    $form['rid'] = array(      '#type' => 'value',      '#value' => $rid,    );    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Save role'),    );    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete role'),    );  }  else {    $form['name'] = array(      '#type' => 'textfield',      '#size' => 32,      '#maxlength' => 64,    );    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Add role'),    );    $form['#submit'][] = 'user_admin_role_submit';    $form['#validate'][] = 'user_admin_role_validate';  }  return $form;}function user_admin_role_validate($form, &$form_state) {  if ($form_state['values']['name']) {    if ($form_state['values']['op'] == t('Save role')) {      if (db_result(db_query("SELECT COUNT(*) FROM {role} WHERE name = '%s' AND rid != %d", $form_state['values']['name'], $form_state['values']['rid']))) {        form_set_error('name', t('The role name %name already exists. Please choose another role name.', array('%name' => $form_state['values']['name'])));      }    }    else if ($form_state['values']['op'] == t('Add role')) {      if (db_result(db_query("SELECT COUNT(*) FROM {role} WHERE name = '%s'", $form_state['values']['name']))) {        form_set_error('name', t('The role name %name already exists. Please choose another role name.', array('%name' => $form_state['values']['name'])));      }    }  }  else {    form_set_error('name', t('You must specify a valid role name.'));  }}function user_admin_role_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Save role')) {    db_query("UPDATE {role} SET name = '%s' WHERE rid = %d", $form_state['values']['name'], $form_state['values']['rid']);    drupal_set_message(t('The role has been renamed.'));  }  else if ($form_state['values']['op'] == t('Delete role')) {    db_query('DELETE FROM {role} WHERE rid = %d', $form_state['values']['rid']);    db_query('DELETE FROM {permission} WHERE rid = %d', $form_state['values']['rid']);    // Update the users who have this role set:    db_query('DELETE FROM {users_roles} WHERE rid = %d', $form_state['values']['rid']);    drupal_set_message(t('The role has been deleted.'));  }  else if ($form_state['values']['op'] == t('Add role')) {    db_query("INSERT INTO {role} (name) VALUES ('%s')", $form_state['values']['name']);    drupal_set_message(t('The role has been added.'));  }  $form_state['redirect'] = 'admin/user/roles';  return;}/** * Menu callback: list all access rules */function user_admin_access_check() {  $output = drupal_get_form('user_admin_check_user');  $output .= drupal_get_form('user_admin_check_mail');  $output .= drupal_get_form('user_admin_check_host');  return $output;}/** * Menu callback: add an access rule. */function user_admin_access_add($mask = NULL, $type = NULL) {  $edit = array();  $edit['aid'] = 0;  $edit['mask'] = $mask;  $edit['type'] = $type;  return drupal_get_form('user_admin_access_add_form', $edit, t('Add rule'));}/** * Menu callback: edit an access rule. */function user_admin_access_edit($aid = 0) {  $edit = db_fetch_array(db_query('SELECT aid, type, status, mask FROM {access} WHERE aid = %d', $aid));  return drupal_get_form('user_admin_access_edit_form', $edit, t('Save rule'));}/** * Form builder; Configure access rules. * * @ingroup forms */function user_admin_access_form(&$form_state, $edit, $submit) {  $form = array();  $form['aid'] = array(    '#type' => 'value',    '#value' => $edit['aid'],  );  $form['status'] = array(    '#type' => 'radios',    '#title' => t('Access type'),    '#default_value' => isset($edit['status']) ? $edit['status'] : 0,    '#options' => array('1' => t('Allow'), '0' => t('Deny')),  );  $type_options = array('user' => t('Username'), 'mail' => t('E-mail'), 'host' => t('Host'));  $form['type'] = array(    '#type' => 'radios',    '#title' => t('Rule type'),    '#default_value' => (isset($type_options[$edit['type']]) ? $edit['type'] : 'user'),    '#options' => $type_options,  );  $form['mask'] = array(    '#type' => 'textfield',    '#title' => t('Mask'),    '#size' => 30,    '#maxlength' => 64,    '#default_value' => $edit['mask'],    '#description' => '%: '. t('Matches any number of characters, even zero characters') .'.<br />_: '. t('Matches exactly one character.'),    '#required' => TRUE,  );  $form['submit'] = array('#type' => 'submit', '#value' => $submit);  $form['#submit'] = array('user_admin_access_form_submit');  return $form;}/** * Submit callback for user_admin_access_form(). */function user_admin_access_form_submit($form, &$form_state) {  $edit = $form_state['values'];  if ($edit['aid']) {    db_query("UPDATE {access} SET mask = '%s', type = '%s', status = '%s' WHERE aid = %d", $edit['mask'], $edit['type'], $edit['status'], $edit['aid']);    drupal_set_message(t('The access rule has been saved.'));  }  else {    db_query("INSERT INTO {access} (mask, type, status) VALUES ('%s', '%s', %d)", $edit['mask'], $edit['type'], $edit['status']);    drupal_set_message(t('The access rule has been added.'));  }  $form_state['redirect'] = 'admin/user/rules';}function user_admin_access_check_validate($form, &$form_state) {  if (empty($form_state['values']['test'])) {    form_set_error($form_state['values']['type'], t('No value entered. Please enter a test string and try again.'));  }}function user_admin_check_user() {  $form['user'] = array('#type' => 'fieldset', '#title' => t('Username'));  $form['user']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter a username to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => USERNAME_MAX_LENGTH);  $form['user']['type'] = array('#type' => 'hidden', '#value' => 'user');  $form['user']['submit'] = array('#type' => 'submit', '#value' => t('Check username'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_check_mail() {  $form['mail'] = array('#type' => 'fieldset', '#title' => t('E-mail'));  $form['mail']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter an e-mail address to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => EMAIL_MAX_LENGTH);  $form['mail']['type'] = array('#type' => 'hidden', '#value' => 'mail');  $form['mail']['submit'] = array('#type' => 'submit', '#value' => t('Check e-mail'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_check_host() {  $form['host'] = array('#type' => 'fieldset', '#title' => t('Hostname'));  $form['host']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter a hostname or IP address to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => 64);  $form['host']['type'] = array('#type' => 'hidden', '#value' => 'host');  $form['host']['submit'] = array('#type' => 'submit', '#value' => t('Check hostname'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_access_check_submit($form, &$form_state) {  switch ($form_state['values']['type']) {    case 'user':      if (drupal_is_denied('user', $form_state['values']['test'])) {        drupal_set_message(t('The username %name is not allowed.', array('%name' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The username %name is allowed.', array('%name' => $form_state['values']['test'])));      }      break;    case 'mail':      if (drupal_is_denied('mail', $form_state['values']['test'])) {        drupal_set_message(t('The e-mail address %mail is not allowed.', array('%mail' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The e-mail address %mail is allowed.', array('%mail' => $form_state['values']['test'])));      }      break;    case 'host':      if (drupal_is_denied('host', $form_state['values']['test'])) {        drupal_set_message(t('The hostname %host is not allowed.', array('%host' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The hostname %host is allowed.', array('%host' => $form_state['values']['test'])));      }      break;    default:      break;  }}/** * Menu callback: delete an access rule * * @ingroup forms * @see user_admin_access_delete_confirm_submit() */function user_admin_access_delete_confirm($form_state, $aid = 0) {  $access_types = array('user' => t('username'), 'mail' => t('e-mail'), 'host' => t('host'));  $edit = db_fetch_object(db_query('SELECT aid, type, status, mask FROM {access} WHERE aid = %d', $aid));  $form = array();  $form['aid'] = array('#type' => 'hidden', '#value' => $aid);  $output = confirm_form($form,                  t('Are you sure you want to delete the @type rule for %rule?', array('@type' => $access_types[$edit->type], '%rule' => $edit->mask)),                  'admin/user/rules',                  t('This action cannot be undone.'),                  t('Delete'),                  t('Cancel'));  return $output;}function user_admin_access_delete_confirm_submit($form, &$form_state) {  db_query('DELETE FROM {access} WHERE aid = %d', $form_state['values']['aid']);  drupal_set_message(t('The access rule has been deleted.'));  $form_state['redirect'] = 'admin/user/rules';  return;}/** * Menu callback: list all access rules */function user_admin_access() {  $header = array(array('data' => t('Access type'), 'field' => 'status'), array('data' => t('Rule type'), 'field' => 'type'), array('data' => t('Mask'), 'field' => 'mask'), array('data' => t('Operations'), 'colspan' => 2));  $result = db_query("SELECT aid, type, status, mask FROM {access}". tablesort_sql($header));  $access_types = array('user' => t('username'), 'mail' => t('e-mail'), 'host' => t('host'));  $rows = array();  while ($rule = db_fetch_object($result)) {    $rows[] = array($rule->status ? t('allow') : t('deny'), $access_types[$rule->type], $rule->mask, l(t('edit'), 'admin/user/rules/edit/'. $rule->aid), l(t('delete'), 'admin/user/rules/delete/'. $rule->aid));  }  if (empty($rows)) {    $rows[] = array(array('data' => '<em>'. t('There are currently no access rules.') .'</em>', 'colspan' => 5));  }  return theme('table', $header, $rows);}/** * Theme user administration overview. * * @ingroup themeable */function theme_user_admin_account($form) {  // Overview table:  $header = array(    theme('table_select_header_cell'),    array('data' => t('Username'), 'field' => 'u.name'),    array('data' => t('Status'), 'field' => 'u.status'),    t('Roles'),    array('data' => t('Member for'), 'field' => 'u.created', 'sort' => 'desc'),    array('data' => t('Last access'), 'field' => 'u.access'),    t('Operations')  );  $output = drupal_render($form['options']);  if (isset($form['name']) && is_array($form['name'])) {    foreach (element_children($form['name']) as $key) {      $rows[] = array(        drupal_render($form['accounts'][$key]),        drupal_render($form['name'][$key]),        drupal_render($form['status'][$key]),        drupal_render($form['roles'][$key]),        drupal_render($form['member_for'][$key]),        drupal_render($form['last_access'][$key]),        drupal_render($form['operations'][$key]),      );    }  }  else {    $rows[] = array(array('data' => t('No users available.'), 'colspan' => '7'));  }  $output .= theme('table', $header, $rows);  if ($form['pager']['#value']) {    $output .= drupal_render($form['pager']);  }  $output .= drupal_render($form);  return $output;}/** * Theme the new-role form. * * @ingroup themeable */function theme_user_admin_new_role($form) {  $header = array(t('Name'), array('data' => t('Operations'), 'colspan' => 2));  foreach (user_roles() as $rid => $name) {    $edit_permissions = l(t('edit permissions'), 'admin/user/permissions/'. $rid);    if (!in_array($rid, array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID))) {      $rows[] = array($name, l(t('edit role'), 'admin/user/roles/edit/'. $rid), $edit_permissions);    }    else {      $rows[] = array($name, t('locked'), $edit_permissions);    }  }  $rows[] = array(drupal_render($form['name']), array('data' => drupal_render($form['submit']), 'colspan' => 2));  $output = drupal_render($form);  $output .= theme('table', $header, $rows);  return $output;}/** * Theme user administration filter form. * * @ingroup themeable */function theme_user_filter_form($form) {  $output = '<div id="user-admin-filter">';  $output .= drupal_render($form['filters']);  $output .= '</div>';  $output .= drupal_render($form);  return $output;}/** * Theme user administration filter selector. * * @ingroup themeable */function theme_user_filters($form) {  $output = '<ul class="clear-block">';  if (!empty($form['current'])) {    foreach (element_children($form['current']) as $key) {      $output .= '<li>'. drupal_render($form['current'][$key]) .'</li>';    }  }  $output .= '<li><dl class="multiselect">'. (!empty($form['current']) ? '<dt><em>'. t('and') .'</em> '. t('where') .'</dt>' : '') .'<dd class="a">';  foreach (element_children($form['filter']) as $key) {    $output .= drupal_render($form['filter'][$key]);  }  $output .= '</dd>';  $output .= '<dt>'. t('is') .'</dt><dd class="b">';  foreach (element_children($form['status']) as $key) {    $output .= drupal_render($form['status'][$key]);  }  $output .= '</dd>';  $output .= '</dl>';  $output .= '<div class="container-inline" id="user-admin-buttons">'. drupal_render($form['buttons']) .'</div>';  $output .= '</li></ul>';  return $output;}
<?php// $Id$/** * @file * Enables the organization of content into categories. *//** * Implementation of hook_perm(). */function taxonomy_perm() {  return array('administer taxonomy');}/** * Implementation of hook_theme() */function taxonomy_theme() {  return array(    'taxonomy_term_select' => array(      'arguments' => array('element' => NULL),    ),    'taxonomy_term_page' => array(      'arguments' => array('tids' => array(), 'result' => NULL),    ),    'taxonomy_overview_vocabularies' => array(      'arguments' => array('form' => array()),    ),    'taxonomy_overview_terms' => array(      'arguments' => array('form' => array()),    ),  );}/** * Implementation of hook_link(). * * This hook is extended with $type = 'taxonomy terms' to allow themes to * print lists of terms associated with a node. Themes can print taxonomy * links with: * * if (module_exists('taxonomy')) { *   $terms = taxonomy_link('taxonomy terms', $node); *   print theme('links', $terms); * } */function taxonomy_link($type, $node = NULL) {  if ($type == 'taxonomy terms' && $node != NULL) {    $links = array();    // If previewing, the terms must be converted to objects first.    if (isset($node->build_mode) && $node->build_mode == NODE_BUILD_PREVIEW) {      $node->taxonomy = taxonomy_preview_terms($node);    }    if (!empty($node->taxonomy)) {      foreach ($node->taxonomy as $term) {        // During preview the free tagging terms are in an array unlike the        // other terms which are objects. So we have to check if a $term        // is an object or not.        if (is_object($term)) {          $links['taxonomy_term_'. $term->tid] = array(            'title' => $term->name,            'href' => taxonomy_term_path($term),            'attributes' => array('rel' => 'tag', 'title' => strip_tags($term->description))          );        }        // Previewing free tagging terms; we don't link them because the        // term-page might not exist yet.        else {          foreach ($term as $free_typed) {            $typed_terms = drupal_explode_tags($free_typed);            foreach ($typed_terms as $typed_term) {              $links['taxonomy_preview_term_'. $typed_term] = array(                'title' => $typed_term,              );            }          }        }      }    }    // We call this hook again because some modules and themes    // call taxonomy_link('taxonomy terms') directly.    drupal_alter('link', $links, $node);    return $links;  }}/** * For vocabularies not maintained by taxonomy.module, give the maintaining * module a chance to provide a path for terms in that vocabulary. * * @param $term *   A term object. * @return *   An internal Drupal path. */function taxonomy_term_path($term) {  $vocabulary = taxonomy_vocabulary_load($term->vid);  if ($vocabulary->module != 'taxonomy' && $path = module_invoke($vocabulary->module, 'term_path', $term)) {    return $path;  }  return 'taxonomy/term/'. $term->tid;}/** * Implementation of hook_menu(). */function taxonomy_menu() {  $items['admin/content/taxonomy'] = array(    'title' => 'Taxonomy',    'description' => 'Manage tagging, categorization, and classification of your content.',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_overview_vocabularies'),    'access arguments' => array('administer taxonomy'),    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/taxonomy/add/vocabulary'] = array(    'title' => 'Add vocabulary',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_form_vocabulary'),    'access arguments' => array('administer taxonomy'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/taxonomy',    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/edit/vocabulary/%taxonomy_vocabulary'] = array(    'title' => 'Edit vocabulary',    'page callback' => 'taxonomy_admin_vocabulary_edit',    'page arguments' => array(5),    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/edit/term'] = array(    'title' => 'Edit term',    'page callback' => 'taxonomy_admin_term_edit',    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['taxonomy/term/%'] = array(    'title' => 'Taxonomy term',    'page callback' => 'taxonomy_term_page',    'page arguments' => array(2),    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.pages.inc',  );  $items['taxonomy/autocomplete'] = array(    'title' => 'Autocomplete taxonomy',    'page callback' => 'taxonomy_autocomplete',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.pages.inc',  );  $items['admin/content/taxonomy/%taxonomy_vocabulary'] = array(    'title' => 'List terms',    'page callback' => 'drupal_get_form',    'page arguments' => array('taxonomy_overview_terms', 3),    'access arguments' => array('administer taxonomy'),    'type' => MENU_CALLBACK,    'file' => 'taxonomy.admin.inc',  );  $items['admin/content/taxonomy/%taxonomy_vocabulary/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/taxonomy/%taxonomy_vocabulary/add/term'] = array(    'title' => 'Add term',    'page callback' => 'taxonomy_add_term_page',    'page arguments' => array(3),    'access arguments' => array('administer taxonomy'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/taxonomy/%taxonomy_vocabulary',    'file' => 'taxonomy.admin.inc',  );  return $items;}function taxonomy_save_vocabulary(&$edit) {  $edit['nodes'] = empty($edit['nodes']) ? array() : $edit['nodes'];  if (!isset($edit['module'])) {    $edit['module'] = 'taxonomy';  }  if (!empty($edit['vid']) && !empty($edit['name'])) {    drupal_write_record('vocabulary', $edit, 'vid');    db_query("DELETE FROM {vocabulary_node_types} WHERE vid = %d", $edit['vid']);    foreach ($edit['nodes'] as $type => $selected) {      db_query("INSERT INTO {vocabulary_node_types} (vid, type) VALUES (%d, '%s')", $edit['vid'], $type);    }    module_invoke_all('taxonomy', 'update', 'vocabulary', $edit);    $status = SAVED_UPDATED;  }  else if (!empty($edit['vid'])) {    $status = taxonomy_del_vocabulary($edit['vid']);  }  else {    drupal_write_record('vocabulary', $edit);    foreach ($edit['nodes'] as $type => $selected) {      db_query("INSERT INTO {vocabulary_node_types} (vid, type) VALUES (%d, '%s')", $edit['vid'], $type);    }    module_invoke_all('taxonomy', 'insert', 'vocabulary', $edit);    $status = SAVED_NEW;  }  cache_clear_all();  return $status;}/** * Delete a vocabulary. * * @param $vid *   A vocabulary ID. * @return *   Constant indicating items were deleted. */function taxonomy_del_vocabulary($vid) {  $vocabulary = (array) taxonomy_vocabulary_load($vid);  db_query('DELETE FROM {vocabulary} WHERE vid = %d', $vid);  db_query('DELETE FROM {vocabulary_node_types} WHERE vid = %d', $vid);  $result = db_query('SELECT tid FROM {term_data} WHERE vid = %d', $vid);  while ($term = db_fetch_object($result)) {    taxonomy_del_term($term->tid);  }  module_invoke_all('taxonomy', 'delete', 'vocabulary', $vocabulary);  cache_clear_all();  return SAVED_DELETED;}/** * Dynamically check and update the hierarachy flag of a vocabulary. * * Checks the current parents of all terms in a vocabulary and updates the * vocabularies hierarchy setting to the lowest possible level. A hierarchy with * no parents in any of its terms will be given a hierarchy of 0. If terms * contain at most a single parent, the vocabulary will be given a hierarchy of * 1. If any term contain multiple parents, the vocabulary will be given a * hieararchy of 2. * * @param $vocabulary *   An array of the vocabulary structure. * @param $changed_term *   An array of the term structure that was updated. */function taxonomy_check_vocabulary_hierarchy($vocabulary, $changed_term) {  $tree = taxonomy_get_tree($vocabulary['vid']);  $hierarchy = 0;  foreach ($tree as $term) {    // Update the changed term with the new parent value before comparision.    if ($term->tid == $changed_term['tid']) {      $term = (object)$changed_term;      $term->parents = $term->parent;    }    // Check this term's parent count.    if (count($term->parents) > 1) {      $hierarchy = 2;      break;    }    elseif (count($term->parents) == 1 && 0 !== array_shift($term->parents)) {      $hierarchy = 1;    }  }  if ($hierarchy != $vocabulary['hierarchy']) {    $vocabulary['hierarchy'] = $hierarchy;    taxonomy_save_vocabulary($vocabulary);  }  return $hierarchy;}/** * Helper function for taxonomy_form_term_submit(). * * @param $form_state['values'] * @return *   Status constant indicating if term was inserted or updated. */function taxonomy_save_term(&$form_values) {  $form_values += array(    'description' => '',    'weight' => 0  );  if (!empty($form_values['tid']) && $form_values['name']) {    drupal_write_record('term_data', $form_values, 'tid');    $hook = 'update';    $status = SAVED_UPDATED;  }  else if (!empty($form_values['tid'])) {    return taxonomy_del_term($form_values['tid']);  }  else {    drupal_write_record('term_data', $form_values);    $hook = 'insert';    $status = SAVED_NEW;  }  db_query('DELETE FROM {term_relation} WHERE tid1 = %d OR tid2 = %d', $form_values['tid'], $form_values['tid']);  if (!empty($form_values['relations'])) {    foreach ($form_values['relations'] as $related_id) {      if ($related_id != 0) {        db_query('INSERT INTO {term_relation} (tid1, tid2) VALUES (%d, %d)', $form_values['tid'], $related_id);      }    }  }  db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $form_values['tid']);  if (!isset($form_values['parent']) || empty($form_values['parent'])) {    $form_values['parent'] = array(0);  }  if (is_array($form_values['parent'])) {    foreach ($form_values['parent'] as $parent) {      if (is_array($parent)) {        foreach ($parent as $tid) {          db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $tid);        }      }      else {        db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $parent);      }    }  }  else {    db_query('INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)', $form_values['tid'], $form_values['parent']);  }  db_query('DELETE FROM {term_synonym} WHERE tid = %d', $form_values['tid']);  if (!empty($form_values['synonyms'])) {    foreach (explode ("\n", str_replace("\r", '', $form_values['synonyms'])) as $synonym) {      if ($synonym) {        db_query("INSERT INTO {term_synonym} (tid, name) VALUES (%d, '%s')", $form_values['tid'], chop($synonym));      }    }  }  if (isset($hook)) {    module_invoke_all('taxonomy', $hook, 'term', $form_values);  }  cache_clear_all();  return $status;}/** * Delete a term. * * @param $tid *   The term ID. * @return *   Status constant indicating deletion. */function taxonomy_del_term($tid) {  $tids = array($tid);  while ($tids) {    $children_tids = $orphans = array();    foreach ($tids as $tid) {      // See if any of the term's children are about to be become orphans:      if ($children = taxonomy_get_children($tid)) {        foreach ($children as $child) {          // If the term has multiple parents, we don't delete it.          $parents = taxonomy_get_parents($child->tid);          if (count($parents) == 1) {            $orphans[] = $child->tid;          }        }      }      $term = (array) taxonomy_get_term($tid);      db_query('DELETE FROM {term_data} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_relation} WHERE tid1 = %d OR tid2 = %d', $tid, $tid);      db_query('DELETE FROM {term_synonym} WHERE tid = %d', $tid);      db_query('DELETE FROM {term_node} WHERE tid = %d', $tid);      module_invoke_all('taxonomy', 'delete', 'term', $term);    }    $tids = $orphans;  }  cache_clear_all();  return SAVED_DELETED;}/** * Generate a form element for selecting terms from a vocabulary. */function taxonomy_form($vid, $value = 0, $help = NULL, $name = 'taxonomy') {  $vocabulary = taxonomy_vocabulary_load($vid);  $help = ($help) ? $help : filter_xss_admin($vocabulary->help);  if (!$vocabulary->multiple) {    $blank = ($vocabulary->required) ? t('- Please choose -') : t('- None selected -');  }  else {    $blank = ($vocabulary->required) ? 0 : t('- None -');  }  return _taxonomy_term_select(check_plain($vocabulary->name), $name, $value, $vid, $help, intval($vocabulary->multiple), $blank);}/** * Generate a set of options for selecting a term from all vocabularies. */function taxonomy_form_all($free_tags = 0) {  $vocabularies = taxonomy_get_vocabularies();  $options = array();  foreach ($vocabularies as $vid => $vocabulary) {    if ($vocabulary->tags && !$free_tags) { continue; }    $tree = taxonomy_get_tree($vid);    if ($tree && (count($tree) > 0)) {      $options[$vocabulary->name] = array();      foreach ($tree as $term) {        $options[$vocabulary->name][$term->tid] = str_repeat('-', $term->depth) . $term->name;      }    }  }  return $options;}/** * Return an array of all vocabulary objects. * * @param $type *   If set, return only those vocabularies associated with this node type. */function taxonomy_get_vocabularies($type = NULL) {  if ($type) {    $result = db_query(db_rewrite_sql("SELECT v.vid, v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s' ORDER BY v.weight, v.name", 'v', 'vid'), $type);  }  else {    $result = db_query(db_rewrite_sql('SELECT v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid ORDER BY v.weight, v.name', 'v', 'vid'));  }  $vocabularies = array();  $node_types = array();  while ($voc = db_fetch_object($result)) {    // If no node types are associated with a vocabulary, the LEFT JOIN will    // return a NULL value for type.    if (isset($voc->type)) {      $node_types[$voc->vid][$voc->type] = $voc->type;      unset($voc->type);      $voc->nodes = $node_types[$voc->vid];    }    elseif (!isset($voc->nodes)) {      $voc->nodes = array();    }    $vocabularies[$voc->vid] = $voc;  }  return $vocabularies;}/** * Implementation of hook_form_alter(). * Generate a form for selecting terms to associate with a node. * We check for taxonomy_override_selector before loading the full * vocabulary, so contrib modules can intercept before hook_form_alter *  and provide scalable alternatives. */function taxonomy_form_alter(&$form, $form_state, $form_id) {  if (isset($form['type']) && isset($form['#node']) && (!variable_get('taxonomy_override_selector', FALSE)) && $form['type']['#value'] .'_node_form' == $form_id) {    $node = $form['#node'];    if (!isset($node->taxonomy)) {      $terms = empty($node->nid) ? array() : taxonomy_node_get_terms($node);    }    else {      // After preview the terms must be converted to objects.      if (isset($form_state['node_preview'])) {        $node->taxonomy = taxonomy_preview_terms($node);      }      $terms = $node->taxonomy;    }    $c = db_query(db_rewrite_sql("SELECT v.* FROM {vocabulary} v INNER JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE n.type = '%s' ORDER BY v.weight, v.name", 'v', 'vid'), $node->type);    while ($vocabulary = db_fetch_object($c)) {      if ($vocabulary->tags) {        if (isset($form_state['node_preview'])) {          // Typed string can be changed by the user before preview,          // so we just insert the tags directly as provided in the form.          $typed_string = $node->taxonomy['tags'][$vocabulary->vid];        }        else {          $typed_string = taxonomy_implode_tags($terms, $vocabulary->vid) . (array_key_exists('tags', $terms) ? $terms['tags'][$vocabulary->vid] : NULL);        }        if ($vocabulary->help) {          $help = filter_xss_admin($vocabulary->help);        }        else {          $help = t('A comma-separated list of terms describing this content. Example: funny, bungee jumping, "Company, Inc.".');        }        $form['taxonomy']['tags'][$vocabulary->vid] = array('#type' => 'textfield',          '#title' => $vocabulary->name,          '#description' => $help,          '#required' => $vocabulary->required,          '#default_value' => $typed_string,          '#autocomplete_path' => 'taxonomy/autocomplete/'. $vocabulary->vid,          '#weight' => $vocabulary->weight,          '#maxlength' => 1024,        );      }      else {        // Extract terms belonging to the vocabulary in question.        $default_terms = array();        foreach ($terms as $term) {          // Free tagging has no default terms and also no vid after preview.          if (isset($term->vid) && $term->vid == $vocabulary->vid) {            $default_terms[$term->tid] = $term;          }        }        $form['taxonomy'][$vocabulary->vid] = taxonomy_form($vocabulary->vid, array_keys($default_terms), filter_xss_admin($vocabulary->help));        $form['taxonomy'][$vocabulary->vid]['#weight'] = $vocabulary->weight;        $form['taxonomy'][$vocabulary->vid]['#required'] = $vocabulary->required;      }    }    if (!empty($form['taxonomy']) && is_array($form['taxonomy'])) {      if (count($form['taxonomy']) > 1) {        // Add fieldset only if form has more than 1 element.        $form['taxonomy'] += array(          '#type' => 'fieldset',          '#title' => t('Vocabularies'),          '#collapsible' => TRUE,          '#collapsed' => FALSE,        );      }      $form['taxonomy']['#weight'] = -3;      $form['taxonomy']['#tree'] = TRUE;    }  }}/** * Helper function to convert terms after a preview. * * After preview the tags are an array instead of proper objects. This function * converts them back to objects with the exception of 'free tagging' terms, * because new tags can be added by the user before preview and those do not * yet exist in the database. We therefore save those tags as a string so * we can fill the form again after the preview. */function taxonomy_preview_terms($node) {  $taxonomy = array();  if (isset($node->taxonomy)) {    foreach ($node->taxonomy as $key => $term) {      unset($node->taxonomy[$key]);      // A 'Multiple select' and a 'Free tagging' field returns an array.      if (is_array($term)) {        foreach ($term as $tid) {          if ($key == 'tags') {            // Free tagging; the values will be saved for later as strings            // instead of objects to fill the form again.            $taxonomy['tags'] = $term;          }          else {            $taxonomy[$tid] = taxonomy_get_term($tid);          }        }      }      // A 'Single select' field returns the term id.      elseif ($term) {        $taxonomy[$term] = taxonomy_get_term($term);      }    }  }  return $taxonomy;}/** * Find all terms associated with the given node, within one vocabulary. */function taxonomy_node_get_terms_by_vocabulary($node, $vid, $key = 'tid') {  $result = db_query(db_rewrite_sql('SELECT t.tid, t.* FROM {term_data} t INNER JOIN {term_node} r ON r.tid = t.tid WHERE t.vid = %d AND r.vid = %d ORDER BY weight', 't', 'tid'), $vid, $node->vid);  $terms = array();  while ($term = db_fetch_object($result)) {    $terms[$term->$key] = $term;  }  return $terms;}/** * Find all terms associated with the given node, ordered by vocabulary and term weight. */function taxonomy_node_get_terms($node, $key = 'tid') {  static $terms;  if (!isset($terms[$node->vid][$key])) {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_node} r INNER JOIN {term_data} t ON r.tid = t.tid INNER JOIN {vocabulary} v ON t.vid = v.vid WHERE r.vid = %d ORDER BY v.weight, t.weight, t.name', 't', 'tid'), $node->vid);    $terms[$node->vid][$key] = array();    while ($term = db_fetch_object($result)) {      $terms[$node->vid][$key][$term->$key] = $term;    }  }  return $terms[$node->vid][$key];}/** * Make sure incoming vids are free tagging enabled. */function taxonomy_node_validate(&$node) {  if (!empty($node->taxonomy)) {    $terms = $node->taxonomy;    if (!empty($terms['tags'])) {      foreach ($terms['tags'] as $vid => $vid_value) {        $vocabulary = taxonomy_vocabulary_load($vid);        if (empty($vocabulary->tags)) {          // see form_get_error $key = implode('][', $element['#parents']);          // on why this is the key          form_set_error("taxonomy][tags][$vid", t('The %name vocabulary can not be modified in this way.', array('%name' => $vocabulary->name)));        }      }    }  }}/** * Save term associations for a given node. */function taxonomy_node_save($node, $terms) {  taxonomy_node_delete_revision($node);  // Free tagging vocabularies do not send their tids in the form,  // so we'll detect them here and process them independently.  if (isset($terms['tags'])) {    $typed_input = $terms['tags'];    unset($terms['tags']);    foreach ($typed_input as $vid => $vid_value) {      $typed_terms = drupal_explode_tags($vid_value);      $inserted = array();      foreach ($typed_terms as $typed_term) {        // See if the term exists in the chosen vocabulary        // and return the tid; otherwise, add a new record.        $possibilities = taxonomy_get_term_by_name($typed_term);        $typed_term_tid = NULL; // tid match, if any.        foreach ($possibilities as $possibility) {          if ($possibility->vid == $vid) {            $typed_term_tid = $possibility->tid;          }        }        if (!$typed_term_tid) {          $edit = array('vid' => $vid, 'name' => $typed_term);          $status = taxonomy_save_term($edit);          $typed_term_tid = $edit['tid'];        }        // Defend against duplicate, differently cased tags        if (!isset($inserted[$typed_term_tid])) {          db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $typed_term_tid);          $inserted[$typed_term_tid] = TRUE;        }      }    }  }  if (is_array($terms)) {    foreach ($terms as $term) {      if (is_array($term)) {        foreach ($term as $tid) {          if ($tid) {            db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $tid);          }        }      }      else if (is_object($term)) {        db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $term->tid);      }      else if ($term) {        db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $node->nid, $node->vid, $term);      }    }  }}/** * Remove associations of a node to its terms. */function taxonomy_node_delete($node) {  db_query('DELETE FROM {term_node} WHERE nid = %d', $node->nid);}/** * Remove associations of a node to its terms. */function taxonomy_node_delete_revision($node) {  db_query('DELETE FROM {term_node} WHERE vid = %d', $node->vid);}/** * Implementation of hook_node_type(). */function taxonomy_node_type($op, $info) {  if ($op == 'update' && !empty($info->old_type) && $info->type != $info->old_type) {    db_query("UPDATE {vocabulary_node_types} SET type = '%s' WHERE type = '%s'", $info->type, $info->old_type);  }  elseif ($op == 'delete') {    db_query("DELETE FROM {vocabulary_node_types} WHERE type = '%s'", $info->type);  }}/** * Find all term objects related to a given term ID. */function taxonomy_get_related($tid, $key = 'tid') {  if ($tid) {    $result = db_query('SELECT t.*, tid1, tid2 FROM {term_relation}, {term_data} t WHERE (t.tid = tid1 OR t.tid = tid2) AND (tid1 = %d OR tid2 = %d) AND t.tid != %d ORDER BY weight, name', $tid, $tid, $tid);    $related = array();    while ($term = db_fetch_object($result)) {      $related[$term->$key] = $term;    }    return $related;  }  else {    return array();  }}/** * Find all parents of a given term ID. */function taxonomy_get_parents($tid, $key = 'tid') {  if ($tid) {    $result = db_query(db_rewrite_sql('SELECT t.tid, t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.parent = t.tid WHERE h.tid = %d ORDER BY weight, name', 't', 'tid'), $tid);    $parents = array();    while ($parent = db_fetch_object($result)) {      $parents[$parent->$key] = $parent;    }    return $parents;  }  else {    return array();  }}/** * Find all ancestors of a given term ID. */function taxonomy_get_parents_all($tid) {  $parents = array();  if ($tid) {    $parents[] = taxonomy_get_term($tid);    $n = 0;    while ($parent = taxonomy_get_parents($parents[$n]->tid)) {      $parents = array_merge($parents, $parent);      $n++;    }  }  return $parents;}/** * Find all children of a term ID. */function taxonomy_get_children($tid, $vid = 0, $key = 'tid') {  if ($vid) {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.tid = t.tid WHERE t.vid = %d AND h.parent = %d ORDER BY weight, name', 't', 'tid'), $vid, $tid);  }  else {    $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_data} t INNER JOIN {term_hierarchy} h ON h.tid = t.tid WHERE parent = %d ORDER BY weight, name', 't', 'tid'), $tid);  }  $children = array();  while ($term = db_fetch_object($result)) {    $children[$term->$key] = $term;  }  return $children;}/** * Create a hierarchical representation of a vocabulary. * * @param $vid *   Which vocabulary to generate the tree for. * * @param $parent *   The term ID under which to generate the tree. If 0, generate the tree *   for the entire vocabulary. * * @param $depth *   Internal use only. * * @param $max_depth *   The number of levels of the tree to return. Leave NULL to return all levels. * * @return *   An array of all term objects in the tree. Each term object is extended *   to have "depth" and "parents" attributes in addition to its normal ones. *   Results are statically cached. */function taxonomy_get_tree($vid, $parent = 0, $depth = -1, $max_depth = NULL) {  static $children, $parents, $terms;  $depth++;  // We cache trees, so it's not CPU-intensive to call get_tree() on a term  // and its children, too.  if (!isset($children[$vid])) {    $children[$vid] = array();    $result = db_query(db_rewrite_sql('SELECT t.tid, t.*, parent FROM {term_data} t INNER JOIN {term_hierarchy} h ON t.tid = h.tid WHERE t.vid = %d ORDER BY weight, name', 't', 'tid'), $vid);    while ($term = db_fetch_object($result)) {      $children[$vid][$term->parent][] = $term->tid;      $parents[$vid][$term->tid][] = $term->parent;      $terms[$vid][$term->tid] = $term;    }  }  $max_depth = (is_null($max_depth)) ? count($children[$vid]) : $max_depth;  $tree = array();  if ($max_depth > $depth && !empty($children[$vid][$parent])) {    foreach ($children[$vid][$parent] as $child) {      $term = drupal_clone($terms[$vid][$child]);      $term->depth = $depth;      // The "parent" attribute is not useful, as it would show one parent only.      unset($term->parent);      $term->parents = $parents[$vid][$child];      $tree[] = $term;      if (!empty($children[$vid][$child])) {        $tree = array_merge($tree, taxonomy_get_tree($vid, $child, $depth, $max_depth));      }    }  }  return $tree;}/** * Return an array of synonyms of the given term ID. */function taxonomy_get_synonyms($tid) {  if ($tid) {    $synonyms = array();    $result = db_query('SELECT name FROM {term_synonym} WHERE tid = %d', $tid);    while ($synonym = db_fetch_array($result)) {      $synonyms[] = $synonym['name'];    }    return $synonyms;  }  else {    return array();  }}/** * Return the term object that has the given string as a synonym. */function taxonomy_get_synonym_root($synonym) {  return db_fetch_object(db_query("SELECT * FROM {term_synonym} s, {term_data} t WHERE t.tid = s.tid AND s.name = '%s'", $synonym));}/** * Count the number of published nodes classified by a term. * * @param $tid *   The term's ID * * @param $type *   The $node->type. If given, taxonomy_term_count_nodes only counts *   nodes of $type that are classified with the term $tid. * * @return int *   An integer representing a number of nodes. *   Results are statically cached. */function taxonomy_term_count_nodes($tid, $type = 0) {  static $count;  if (!isset($count[$type])) {    // $type == 0 always evaluates TRUE if $type is a string    if (is_numeric($type)) {      $result = db_query(db_rewrite_sql('SELECT t.tid, COUNT(n.nid) AS c FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.status = 1 GROUP BY t.tid'));    }    else {      $result = db_query(db_rewrite_sql("SELECT t.tid, COUNT(n.nid) AS c FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.status = 1 AND n.type = '%s' GROUP BY t.tid"), $type);    }    $count[$type] = array();    while ($term = db_fetch_object($result)) {      $count[$type][$term->tid] = $term->c;    }  }  $children_count = 0;  foreach (_taxonomy_term_children($tid) as $c) {    $children_count += taxonomy_term_count_nodes($c, $type);  }  return $children_count + (isset($count[$type][$tid]) ? $count[$type][$tid] : 0);}/** * Helper for taxonomy_term_count_nodes(). Used to find out * which terms are children of a parent term. * * @param $tid *   The parent term's ID * * @return array *   An array of term IDs representing the children of $tid. *   Results are statically cached. * */function _taxonomy_term_children($tid) {  static $children;  if (!isset($children)) {    $result = db_query('SELECT tid, parent FROM {term_hierarchy}');    while ($term = db_fetch_object($result)) {      $children[$term->parent][] = $term->tid;    }  }  return isset($children[$tid]) ? $children[$tid] : array();}/** * Try to map a string to an existing term, as for glossary use. * * Provides a case-insensitive and trimmed mapping, to maximize the * likelihood of a successful match. * * @param name *   Name of the term to search for. * * @return *   An array of matching term objects. */function taxonomy_get_term_by_name($name) {  $db_result = db_query(db_rewrite_sql("SELECT t.tid, t.* FROM {term_data} t WHERE LOWER(t.name) = LOWER('%s')", 't', 'tid'), trim($name));  $result = array();  while ($term = db_fetch_object($db_result)) {    $result[] = $term;  }  return $result;}/** * Return the vocabulary object matching a vocabulary ID. * * @param $vid *   The vocabulary's ID * @param $reset *   Whether to reset the internal taxonomy_vocabulary_load cache. * * @return *   The vocabulary object with all of its metadata, if exists, FALSE otherwise. *   Results are statically cached. */function taxonomy_vocabulary_load($vid, $reset = FALSE) {  static $vocabularies = array();  if ($reset) {    $vocabularies = array();  }  if (!isset($vocabularies[$vid])) {    // Initialize so if this vocabulary does not exist, we have    // that cached, and we will not try to load this later.    $vocabularies[$vid] = FALSE;    // Try to load the data and fill up the object.    $result = db_query('SELECT v.*, n.type FROM {vocabulary} v LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid WHERE v.vid = %d', $vid);    $node_types = array();    while ($voc = db_fetch_object($result)) {      if (!empty($voc->type)) {        $node_types[$voc->type] = $voc->type;      }      unset($voc->type);      $voc->nodes = $node_types;      $vocabularies[$vid] = $voc;    }  }  // Return FALSE if this vocabulary does not exist.  return !empty($vocabularies[$vid]) ? $vocabularies[$vid] : FALSE;}/** * Return the term object matching a term ID. * * @param $tid *   A term's ID * @param $reset *   Whether to reset the internal taxonomy_get_term cache. * * @return Object *   A term object. Results are statically cached. */function taxonomy_get_term($tid, $reset = FALSE) {  static $terms = array();  if ($reset) {    $terms = array();  }  if (!isset($terms[$tid])) {    $terms[$tid] = db_fetch_object(db_query('SELECT * FROM {term_data} WHERE tid = %d', $tid));  }  return $terms[$tid];}/** * Create a select form element for a given taxonomy vocabulary. * * NOTE: This function expects input that has already been sanitized and is * safe for display. Callers must properly sanitize the $title and * $description arguments to prevent XSS vulnerabilities. * * @param $title *   The title of the vocabulary. This MUST be sanitized by the caller. * @param $name *   Ignored. * @param $value *   The currently selected terms from this vocabulary, if any. * @param $vocabulary_id *   The vocabulary ID to build the form element for. * @param $description *   Help text for the form element. This MUST be sanitized by the caller. * @param $multiple *   Boolean to control if the form should use a single or multiple select. * @param $blank *   Optional form choice to use when no value has been selected. * @param $exclude *   Optional array of term ids to exclude in the selector. * @return *   A FAPI form array to select terms from the given vocabulary. * * @see taxonomy_form() * @see taxonomy_form_term() */function _taxonomy_term_select($title, $name, $value, $vocabulary_id, $description, $multiple, $blank, $exclude = array()) {  $tree = taxonomy_get_tree($vocabulary_id);  $options = array();  if ($blank) {    $options[''] = $blank;  }  if ($tree) {    foreach ($tree as $term) {      if (!in_array($term->tid, $exclude)) {        $choice = new stdClass();        $choice->option = array($term->tid => str_repeat('-', $term->depth) . $term->name);        $options[] = $choice;      }    }  }  return array('#type' => 'select',    '#title' => $title,    '#default_value' => $value,    '#options' => $options,    '#description' => $description,    '#multiple' => $multiple,    '#size' => $multiple ? min(9, count($options)) : 0,    '#weight' => -15,    '#theme' => 'taxonomy_term_select',  );}/** * Format the selection field for choosing terms * (by deafult the default selection field is used). * * @ingroup themeable */function theme_taxonomy_term_select($element) {  return theme('select', $element);}/** * Finds all nodes that match selected taxonomy conditions. * * @param $tids *   An array of term IDs to match. * @param $operator *   How to interpret multiple IDs in the array. Can be "or" or "and". * @param $depth *   How many levels deep to traverse the taxonomy tree. Can be a nonnegative *   integer or "all". * @param $pager *   Whether the nodes are to be used with a pager (the case on most Drupal *   pages) or not (in an XML feed, for example). * @param $order *   The order clause for the query that retrieve the nodes. * @return *   A resource identifier pointing to the query results. */function taxonomy_select_nodes($tids = array(), $operator = 'or', $depth = 0, $pager = TRUE, $order = 'n.sticky DESC, n.created DESC') {  if (count($tids) > 0) {    // For each term ID, generate an array of descendant term IDs to the right depth.    $descendant_tids = array();    if ($depth === 'all') {      $depth = NULL;    }    foreach ($tids as $index => $tid) {      $term = taxonomy_get_term($tid);      $tree = taxonomy_get_tree($term->vid, $tid, -1, $depth);      $descendant_tids[] = array_merge(array($tid), array_map('_taxonomy_get_tid_from_term', $tree));    }    if ($operator == 'or') {      $args = call_user_func_array('array_merge', $descendant_tids);      $placeholders = db_placeholders($args, 'int');      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN ('. $placeholders .') AND n.status = 1 ORDER BY '. $order;      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid WHERE tn.tid IN ('. $placeholders .') AND n.status = 1';    }    else {      $joins = '';      $wheres = '';      $args = array();      foreach ($descendant_tids as $index => $tids) {        $joins .= ' INNER JOIN {term_node} tn'. $index .' ON n.vid = tn'. $index .'.vid';        $wheres .= ' AND tn'. $index .'.tid IN ('. db_placeholders($tids, 'int') .')';        $args = array_merge($args, $tids);      }      $sql = 'SELECT DISTINCT(n.nid), n.sticky, n.title, n.created FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres .' ORDER BY '. $order;      $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n '. $joins .' WHERE n.status = 1 '. $wheres;    }    $sql = db_rewrite_sql($sql);    $sql_count = db_rewrite_sql($sql_count);    if ($pager) {      $result = pager_query($sql, variable_get('default_nodes_main', 10), 0, $sql_count, $args);    }    else {      $result = db_query_range($sql, $args, 0, variable_get('feed_default_items', 10));    }  }  return $result;}/** * Accepts the result of a pager_query() call, such as that performed by * taxonomy_select_nodes(), and formats each node along with a pager. */function taxonomy_render_nodes($result) {  $output = '';  $has_rows = FALSE;  while ($node = db_fetch_object($result)) {    $output .= node_view(node_load($node->nid), 1);    $has_rows = TRUE;  }  if ($has_rows) {    $output .= theme('pager', NULL, variable_get('default_nodes_main', 10), 0);  }  else {    $output .= '<p>'. t('There are currently no posts in this category.') .'</p>';  }  return $output;}/** * Implementation of hook_nodeapi(). */function taxonomy_nodeapi($node, $op, $arg = 0) {  switch ($op) {    case 'load':      $output['taxonomy'] = taxonomy_node_get_terms($node);      return $output;    case 'insert':      if (!empty($node->taxonomy)) {        taxonomy_node_save($node, $node->taxonomy);      }      break;    case 'update':      if (!empty($node->taxonomy)) {        taxonomy_node_save($node, $node->taxonomy);      }      break;    case 'delete':      taxonomy_node_delete($node);      break;    case 'delete revision':      taxonomy_node_delete_revision($node);      break;    case 'validate':      taxonomy_node_validate($node);      break;    case 'rss item':      return taxonomy_rss_item($node);    case 'update index':      return taxonomy_node_update_index($node);  }}/** * Implementation of hook_nodeapi('update_index'). */function taxonomy_node_update_index(&$node) {  $output = array();  foreach ($node->taxonomy as $term) {    $output[] = $term->name;  }  if (count($output)) {    return '<strong>('. implode(', ', $output) .')</strong>';  }}/** * Parses a comma or plus separated string of term IDs. * * @param $str_tids *   A string of term IDs, separated by plus or comma. *   comma (,) means AND *   plus (+) means OR * * @return an associative array with an operator key (either 'and' *   or 'or') and a tid key containing an array of the term ids. */function taxonomy_terms_parse_string($str_tids) {  $terms = array('operator' => '', 'tids' => array());  if (preg_match('/^([0-9]+[+ ])+[0-9]+$/', $str_tids)) {    $terms['operator'] = 'or';    // The '+' character in a query string may be parsed as ' '.    $terms['tids'] = preg_split('/[+ ]/', $str_tids);  }  else if (preg_match('/^([0-9]+,)*[0-9]+$/', $str_tids)) {    $terms['operator'] = 'and';    $terms['tids'] = explode(',', $str_tids);  }  return $terms;}/** * Provides category information for RSS feeds. */function taxonomy_rss_item($node) {  $output = array();  foreach ($node->taxonomy as $term) {    $output[] = array('key'   => 'category',                      'value' => $term->name,                      'attributes' => array('domain' => url('taxonomy/term/'. $term->tid, array('absolute' => TRUE))));  }  return $output;}/** * Implementation of hook_help(). */function taxonomy_help($path, $arg) {  switch ($path) {    case 'admin/help#taxonomy':      $output = '<p>'. t('The taxonomy module allows you to categorize content using various systems of classification. Free-tagging vocabularies are created by users on the fly when they submit posts (as commonly found in blogs and social bookmarking applications). Controlled vocabularies allow for administrator-defined short lists of terms as well as complex hierarchies with multiple relationships between different terms. These methods can be applied to different content types and combined together to create a powerful and flexible method of classifying and presenting your content.') .'</p>';      $output .= '<p>'. t('For example, when creating a recipe site, you might want to classify posts by both the type of meal and preparation time. A vocabulary for each allows you to categorize using each criteria independently instead of creating a tag for every possible combination.') .'</p>';      $output .= '<p>'. t('Type of Meal: <em>Appetizer, Main Course, Salad, Dessert</em>') .'</p>';      $output .= '<p>'. t('Preparation Time: <em>0-30mins, 30-60mins, 1-2 hrs, 2hrs+</em>') .'</p>';      $output .= '<p>'. t("Each taxonomy term (often called a 'category' or 'tag' in other systems) automatically provides lists of posts and a corresponding RSS feed. These taxonomy/term URLs can be manipulated to generate AND and OR lists of posts classified with terms. In our recipe site example, it then becomes easy to create pages displaying 'Main courses', '30 minute recipes', or '30 minute main courses and appetizers' by using terms on their own or in combination with others. There are a significant number of contributed modules which you to alter and extend the behavior of the core module for both display and organization of terms.") .'</p>';      $output .= '<p>'. t("Terms can also be organized in parent/child relationships from the admin interface. An example would be a vocabulary grouping countries under their parent geo-political regions. The taxonomy module also enables advanced implementations of hierarchy, for example placing Turkey in both the 'Middle East' and 'Europe'.") .'</p>';      $output .= '<p>'. t('The taxonomy module supports the use of both synonyms and related terms, but does not directly use this functionality. However, optional contributed or custom modules may make full use of these advanced features.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@taxonomy">Taxonomy module</a>.', array('@taxonomy' => 'http://drupal.org/handbook/modules/taxonomy/')) .'</p>';      return $output;    case 'admin/content/taxonomy':      $output = '<p>'. t("The taxonomy module allows you to categorize your content using both tags and administrator defined terms. It is a flexible tool for classifying content with many advanced features. To begin, create a 'Vocabulary' to hold one set of terms or tags. You can create one free-tagging vocabulary for everything, or separate controlled vocabularies to define the various properties of your content, for example 'Countries' or 'Colors'.") .'</p>';      $output .= '<p>'. t('Use the list below to configure and review the vocabularies defined on your site, or to list and manage the terms (tags) they contain. A vocabulary may (optionally) be tied to specific content types as shown in the <em>Type</em> column and, if so, will be displayed when creating or editing posts of that type. Multiple vocabularies tied to the same content type will be displayed in the order shown below. To change the order of a vocabulary, grab a drag-and-drop handle under the <em>Name</em> column and drag it to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save</em> button at the bottom of the page.') .'</p>';      return $output;    case 'admin/content/taxonomy/%':      $vocabulary = taxonomy_vocabulary_load($arg[3]);      if ($vocabulary->tags) {        return '<p>'. t('%capital_name is a free-tagging vocabulary. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name))) .'</p>';      }      switch ($vocabulary->hierarchy) {        case 0:          return '<p>'. t('%capital_name is a flat vocabulary. You may organize the terms in the %name vocabulary by using the handles on the left side of the table. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name)) .'</p>';        case 1:          return '<p>'. t('%capital_name is a single hierarchy vocabulary. You may organize the terms in the %name vocabulary by using the handles on the left side of the table. To change the name or description of a term, click the <em>edit</em> link next to the term.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name)) .'</p>';        case 2:          return '<p>'. t('%capital_name is a multiple hierarchy vocabulary. To change the name or description of a term, click the <em>edit</em> link next to the term. Drag and drop of multiple hierarchies is not supported, but you can re-enable drag and drop support by editing each term to include only a single parent.', array('%capital_name' => drupal_ucfirst($vocabulary->name))) .'</p>';      }    case 'admin/content/taxonomy/add/vocabulary':      return '<p>'. t('Define how your vocabulary will be presented to administrators and users, and which content types to categorize with it. Tags allows users to create terms when submitting posts by typing a comma separated list. Otherwise terms are chosen from a select list and can only be created by users with the "administer taxonomy" permission.') .'</p>';  }}/** * Helper function for array_map purposes. */function _taxonomy_get_tid_from_term($term) {  return $term->tid;}/** * Implode a list of tags of a certain vocabulary into a string. */function taxonomy_implode_tags($tags, $vid = NULL) {  $typed_tags = array();  foreach ($tags as $tag) {    // Extract terms belonging to the vocabulary in question.    if (is_null($vid) || $tag->vid == $vid) {      // Commas and quotes in tag names are special cases, so encode 'em.      if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {        $tag->name = '"'. str_replace('"', '""', $tag->name) .'"';      }      $typed_tags[] = $tag->name;    }  }  return implode(', ', $typed_tags);}/** * Implementation of hook_hook_info(). */function taxonomy_hook_info() {  return array(    'taxonomy' => array(      'taxonomy' => array(        'insert' => array(          'runs when' => t('After saving a new term to the database'),        ),        'update' => array(          'runs when' => t('After saving an updated term to the database'),        ),        'delete' => array(          'runs when' => t('After deleting a term')        ),      ),    ),  );}
<?php// $Id$/** * @file node.tpl.php * * Theme implementation to display a node. * * Available variables: * - $title: the (sanitized) title of the node. * - $content: Node body or teaser depending on $teaser flag. * - $picture: The authors picture of the node output from *   theme_user_picture(). * - $date: Formatted creation date (use $created to reformat with *   format_date()). * - $links: Themed links like "Read more", "Add new comment", etc. output *   from theme_links(). * - $name: Themed username of node author output from theme_username(). * - $node_url: Direct url of the current node. * - $terms: the themed list of taxonomy term links output from theme_links(). * - $submitted: themed submission information output from *   theme_node_submitted(). * * Other variables: * - $node: Full node object. Contains data that may not be safe. * - $type: Node type, i.e. story, page, blog, etc. * - $comment_count: Number of comments attached to the node. * - $uid: User ID of the node author. * - $created: Time the node was published formatted in Unix timestamp. * - $zebra: Outputs either "even" or "odd". Useful for zebra striping in *   teaser listings. * - $id: Position of the node. Increments each time it's output. * * Node status variables: * - $teaser: Flag for the teaser state. * - $page: Flag for the full page state. * - $promote: Flag for front page promotion state. * - $sticky: Flags for sticky post setting. * - $status: Flag for published status. * - $comment: State of comment settings for the node. * - $readmore: Flags true if the teaser content of the node cannot hold the *   main body content. * - $is_front: Flags true when presented in the front page. * - $logged_in: Flags true when the current user is a logged-in member. * - $is_admin: Flags true when the current user is an administrator. * * @see template_preprocess() * @see template_preprocess_node() */?><div id="node-<?php print $node->nid; ?>" class="node<?php if ($sticky) { print ' sticky'; } ?><?php if (!$status) { print ' node-unpublished'; } ?> clear-block"><?php print $picture ?><?php if (!$page): ?>  <h2><a href="<?php print $node_url ?>" title="<?php print $title ?>"><?php print $title ?></a></h2><?php endif; ?>  <div class="meta">  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted ?></span>  <?php endif; ?>  <?php if ($terms): ?>    <div class="terms terms-inline"><?php print $terms ?></div>  <?php endif;?>  </div>  <div class="content">    <?php print $content ?>  </div>  <?php print $links; ?></div>
<?php// $Id$/** * @file * Admin page callbacks for the contact module. *//** * Categories/list tab. */function contact_admin_categories() {  $result = db_query('SELECT cid, category, recipients, selected FROM {contact} ORDER BY weight, category');  $rows = array();  while ($category = db_fetch_object($result)) {    $rows[] = array(check_plain($category->category), check_plain($category->recipients), ($category->selected ? t('Yes') : t('No')), l(t('edit'), 'admin/build/contact/edit/'. $category->cid), l(t('delete'), 'admin/build/contact/delete/'. $category->cid));  }  $header = array(t('Category'), t('Recipients'), t('Selected'), array('data' => t('Operations'), 'colspan' => 2));  return theme('table', $header, $rows);}/** * Category edit page. */function contact_admin_edit($form_state = array(), $op, $contact = NULL) {  if (empty($contact) || $op == 'add') {    $contact = array(      'category' => '',      'recipients' => '',      'reply' => '',      'weight' => 0,      'selected' => 0,      'cid' => NULL,    );  }  $form['contact_op'] = array('#type' => 'value', '#value' => $op);  $form['category'] = array('#type' => 'textfield',    '#title' => t('Category'),    '#maxlength' => 255,    '#default_value' => $contact['category'],    '#description' => t("Example: 'website feedback' or 'product information'."),    '#required' => TRUE,  );  $form['recipients'] = array('#type' => 'textarea',    '#title' => t('Recipients'),    '#default_value' => $contact['recipients'],    '#description' => t("Example: 'webmaster@example.com' or 'sales@example.com,support@example.com'. To specify multiple recipients, separate each e-mail address with a comma."),    '#required' => TRUE,  );  $form['reply'] = array('#type' => 'textarea',    '#title' => t('Auto-reply'),    '#default_value' => $contact['reply'],    '#description' => t('Optional auto-reply. Leave empty if you do not want to send the user an auto-reply message.'),  );  $form['weight'] = array('#type' => 'weight',    '#title' => t('Weight'),    '#default_value' => $contact['weight'],    '#description' => t('When listing categories, those with lighter (smaller) weights get listed before categories with heavier (larger) weights. Categories with equal weights are sorted alphabetically.'),  );  $form['selected'] = array('#type' => 'select',    '#title' => t('Selected'),    '#options' => array('0' => t('No'), '1' => t('Yes')),    '#default_value' => $contact['selected'],    '#description' => t('Set this to <em>Yes</em> if you would like this category to be selected by default.'),  );  $form['cid'] = array('#type' => 'value',    '#value' => $contact['cid'],  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Save'),  );  return $form;}/** * Validate the contact category edit page form submission. */function contact_admin_edit_validate($form, &$form_state) {  if (empty($form_state['values']['category'])) {    form_set_error('category', t('You must enter a category.'));  }  if (empty($form_state['values']['recipients'])) {    form_set_error('recipients', t('You must enter one or more recipients.'));  }  else {    $recipients = explode(',', $form_state['values']['recipients']);    foreach ($recipients as $recipient) {      if (!valid_email_address(trim($recipient))) {        form_set_error('recipients', t('%recipient is an invalid e-mail address.', array('%recipient' => $recipient)));      }    }  }}/** * Process the contact category edit page form submission. */function contact_admin_edit_submit($form, &$form_state) {  if ($form_state['values']['selected']) {    // Unselect all other contact categories.    db_query('UPDATE {contact} SET selected = 0');  }  $recipients = explode(',', $form_state['values']['recipients']);  foreach ($recipients as $key => $recipient) {    // E-mail address validation has already been done in _validate.    $recipients[$key] = trim($recipient);  }  $form_state['values']['recipients'] = implode(',', $recipients);  if (empty($form_state['values']['cid']) || $form_state['values']['contact_op'] == 'add') {    drupal_write_record('contact', $form_state['values']);    drupal_set_message(t('Category %category has been added.', array('%category' => $form_state['values']['category'])));    watchdog('mail', 'Contact form: category %category added.', array('%category' => $form_state['values']['category']), WATCHDOG_NOTICE, l(t('view'), 'admin/build/contact'));  }  else {    drupal_write_record('contact', $form_state['values'], 'cid');    drupal_set_message(t('Category %category has been updated.', array('%category' => $form_state['values']['category'])));    watchdog('mail', 'Contact form: category %category updated.', array('%category' => $form_state['values']['category']), WATCHDOG_NOTICE, l(t('view'), 'admin/build/contact'));  }  $form_state['redirect'] = 'admin/build/contact';  return;}/** * Category delete page. */function contact_admin_delete(&$form_state, $contact) {  $form['contact'] = array(    '#type' => 'value',    '#value' => $contact,  );  return confirm_form($form, t('Are you sure you want to delete %category?', array('%category' => $contact['category'])), 'admin/build/contact', t('This action cannot be undone.'), t('Delete'), t('Cancel'));}/** * Process category delete form submission. */function contact_admin_delete_submit($form, &$form_state) {  $contact = $form_state['values']['contact'];  db_query("DELETE FROM {contact} WHERE cid = %d", $contact['cid']);  drupal_set_message(t('Category %category has been deleted.', array('%category' => $contact['category'])));  watchdog('mail', 'Contact form: category %category deleted.', array('%category' => $contact['category']), WATCHDOG_NOTICE);  $form_state['redirect'] = 'admin/build/contact';  return;}function contact_admin_settings() {  $form['contact_form_information'] = array('#type' => 'textarea',    '#title' => t('Additional information'),    '#default_value' => variable_get('contact_form_information', t('You can leave a message using the contact form below.')),    '#description' => t('Information to show on the <a href="@form">contact page</a>. Can be anything from submission guidelines to your postal address or telephone number.', array('@form' => url('contact'))),  );  $form['contact_hourly_threshold'] = array('#type' => 'select',    '#title' => t('Hourly threshold'),    '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 20, 30, 40, 50)),    '#default_value' => variable_get('contact_hourly_threshold', 3),    '#description' => t('The maximum number of contact form submissions a user can perform per hour.'),  );  $form['contact_default_status'] = array(    '#type' => 'checkbox',    '#title' => t('Enable personal contact form by default'),    '#default_value' => variable_get('contact_default_status', 1),    '#description' => t('Default status of the personal contact form for new users.'),  );  return system_settings_form($form);}
<?php// $Id$/** * @file * Enables your site to capture votes on different topics in the form of multiple * choice questions. *//** * Implementation of hook_help(). */function poll_help($path, $arg) {  switch ($path) {    case 'admin/help#poll':      $output = '<p>'. t('The poll module can be used to create simple polls for site users. A poll is a simple, multiple choice questionnaire which displays the cumulative results of the answers to the poll. Having polls on the site is a good way to receive feedback from community members.') .'</p>';      $output .= '<p>'. t('When creating a poll, enter the question being posed, as well as the potential choices (and beginning vote counts for each choice). The status and duration (length of time the poll remains active for new votes) can also be specified. Use the <a href="@poll">poll</a> menu item to view all current polls. To vote in or view the results of a specific poll, click on the poll itself.', array('@poll' => url('poll'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@poll">Poll module</a>.', array('@poll' => 'http://drupal.org/handbook/modules/poll/')) .'</p>';      return $output;  }}/** * Implementation of hook_init(). */function poll_init() {  drupal_add_css(drupal_get_path('module', 'poll') .'/poll.css');}/** * Implementation of hook_theme() */function poll_theme() {  return array(    'poll_vote' => array(      'template' => 'poll-vote',      'arguments' => array('form' => NULL),    ),    'poll_choices' => array(      'arguments' => array('form' => NULL),    ),    'poll_results' => array(      'template' => 'poll-results',      'arguments' => array('raw_title' => NULL, 'results' => NULL, 'votes' => NULL, 'raw_links' => NULL, 'block' => NULL, 'nid' => NULL, 'vote' => NULL),    ),    'poll_bar' => array(      'template' => 'poll-bar',      'arguments' => array('title' => NULL, 'votes' => NULL, 'total_votes' => NULL, 'vote' => NULL, 'block' => NULL),    ),  );}/** * Implementation of hook_perm(). */function poll_perm() {  return array('create poll content', 'delete own poll content', 'delete any poll content', 'edit any poll content', 'edit own poll content', 'vote on polls', 'cancel own vote', 'inspect all votes');}/** * Implementation of hook_access(). */function poll_access($op, $node, $account) {  switch ($op) {    case 'create':      return user_access('create poll content', $account) ? TRUE : NULL;    case 'update':      return user_access('edit any poll content', $account) || (user_access('edit own poll content', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;    case 'delete':      return user_access('delete any poll content', $account) || (user_access('delete own poll content', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;  }}/** * Implementation of hook_menu(). */function poll_menu() {  $items['poll'] = array(    'title' => 'Polls',    'page callback' => 'poll_page',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'poll.pages.inc',  );  $items['node/%node/votes'] = array(    'title' => 'Votes',    'page callback' => 'poll_votes',    'page arguments' => array(1),    'access callback' => '_poll_menu_access',    'access arguments' => array(1, 'inspect all votes', FALSE),    'weight' => 3,    'type' => MENU_LOCAL_TASK,    'file' => 'poll.pages.inc',  );  $items['node/%node/results'] = array(    'title' => 'Results',    'page callback' => 'poll_results',    'page arguments' => array(1),    'access callback' => '_poll_menu_access',    'access arguments' => array(1, 'access content', TRUE),    'weight' => 3,    'type' => MENU_LOCAL_TASK,    'file' => 'poll.pages.inc',  );  $items['poll/js'] = array(    'title' => 'Javascript Choice Form',    'page callback' => 'poll_choice_js',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,  );  return $items;}/** * Callback function to see if a node is acceptable for poll menu items. */function _poll_menu_access($node, $perm, $inspect_allowvotes) {  return user_access($perm) && ($node->type == 'poll') && ($node->allowvotes || !$inspect_allowvotes);}/** * Implementation of hook_block(). * * Generates a block containing the latest poll. */function poll_block($op = 'list', $delta = 0) {  if (user_access('access content')) {    if ($op == 'list') {      $blocks[0]['info'] = t('Most recent poll');      return $blocks;    }    else if ($op == 'view') {      // Retrieve the latest poll.      $sql = db_rewrite_sql("SELECT MAX(n.created) FROM {node} n INNER JOIN {poll} p ON p.nid = n.nid WHERE n.status = 1 AND p.active = 1");      $timestamp = db_result(db_query($sql));      if ($timestamp) {        $poll = node_load(array('type' => 'poll', 'created' => $timestamp, 'status' => 1));        if ($poll->nid) {          $poll = poll_view($poll, TRUE, FALSE, TRUE);        }      }      $block['subject'] = t('Poll');      $block['content'] = drupal_render($poll->content);      return $block;    }  }}/** * Implementation of hook_cron(). * * Closes polls that have exceeded their allowed runtime. */function poll_cron() {  $result = db_query('SELECT p.nid FROM {poll} p INNER JOIN {node} n ON p.nid = n.nid WHERE (n.created + p.runtime) < '. time() .' AND p.active = 1 AND p.runtime != 0');  while ($poll = db_fetch_object($result)) {    db_query("UPDATE {poll} SET active = 0 WHERE nid = %d", $poll->nid);  }}/** * Implementation of hook_node_info(). */function poll_node_info() {  return array(    'poll' => array(      'name' => t('Poll'),      'module' => 'poll',      'description' => t('A <em>poll</em> is a question with a set of possible responses. A <em>poll</em>, once created, automatically provides a simple running count of the number of votes received for each response.'),      'title_label' => t('Question'),      'has_body' => FALSE,    )  );}/** * Implementation of hook_form(). */function poll_form(&$node, $form_state) {  global $user;  $admin = user_access('administer nodes') || user_access('edit any poll content') || (user_access('edit own poll content') && $user->uid == $node->uid);  $type = node_get_types('type', $node);  $form = array(    '#cache' => TRUE,  );  $form['title'] = array(    '#type' => 'textfield',    '#title' => check_plain($type->title_label),    '#required' => TRUE,    '#default_value' => $node->title,    '#weight' => -5,  );  if (isset($form_state['choice_count'])) {    $choice_count = $form_state['choice_count'];  }  else {    $choice_count = max(2, empty($node->choice) ? 2 : count($node->choice));  }  // Add a wrapper for the choices and more button.  $form['choice_wrapper'] = array(    '#tree' => FALSE,    '#weight' => -4,    '#prefix' => '<div class="clear-block" id="poll-choice-wrapper">',    '#suffix' => '</div>',  );  // Container for just the poll choices.  $form['choice_wrapper']['choice'] = array(    '#prefix' => '<div id="poll-choices">',    '#suffix' => '</div>',    '#theme' => 'poll_choices',  );  // Add the current choices to the form.  for ($delta = 0; $delta < $choice_count; $delta++) {    $text = isset($node->choice[$delta]['chtext']) ? $node->choice[$delta]['chtext'] : '';    $votes = isset($node->choice[$delta]['chvotes']) ? $node->choice[$delta]['chvotes'] : 0;    $form['choice_wrapper']['choice'][$delta] = _poll_choice_form($delta, $text, $votes);  }  // We name our button 'poll_more' to avoid conflicts with other modules using  // AHAH-enabled buttons with the id 'more'.  $form['choice_wrapper']['poll_more'] = array(    '#type' => 'submit',    '#value' => t('More choices'),    '#description' => t("If the amount of boxes above isn't enough, click here to add more choices."),    '#weight' => 1,    '#submit' => array('poll_more_choices_submit'), // If no javascript action.    '#ahah' => array(      'path' => 'poll/js',      'wrapper' => 'poll-choices',      'method' => 'replace',      'effect' => 'fade',    ),  );  // Poll attributes  $_duration = array(0 => t('Unlimited')) + drupal_map_assoc(array(86400, 172800, 345600, 604800, 1209600, 2419200, 4838400, 9676800, 31536000), "format_interval");  $_active = array(0 => t('Closed'), 1 => t('Active'));  if ($admin) {    $form['settings'] = array(      '#type' => 'fieldset',      '#collapsible' => TRUE,      '#title' => t('Poll settings'),      '#weight' => -3,    );    $form['settings']['active'] = array(      '#type' => 'radios',      '#title' => t('Poll status'),      '#default_value' => isset($node->active) ? $node->active : 1,      '#options' => $_active,      '#description' => t('When a poll is closed, visitors can no longer vote for it.')    );  }  $form['settings']['runtime'] = array(    '#type' => 'select',    '#title' => t('Poll duration'),    '#default_value' => isset($node->runtime) ? $node->runtime : 0,    '#options' => $_duration,    '#description' => t('After this period, the poll will be closed automatically.'),  );  return $form;}/** * Submit handler to add more choices to a poll form. This handler is used when * javascript is not available. It makes changes to the form state and the * entire form is rebuilt during the page reload. */function poll_more_choices_submit($form, &$form_state) {  // Set the form to rebuild and run submit handlers.  node_form_submit_build_node($form, $form_state);  // Make the changes we want to the form state.  if ($form_state['values']['poll_more']) {    $n = $_GET['q'] == 'poll/js' ? 1 : 5;    $form_state['choice_count'] = count($form_state['values']['choice']) + $n;  }}function _poll_choice_form($delta, $value = '', $votes = 0) {  $admin = user_access('administer nodes');  $form = array(    '#tree' => TRUE,  );  // We'll manually set the #parents property of these fields so that  // their values appear in the $form_state['values']['choice'] array.  $form['chtext'] = array(    '#type' => 'textfield',    '#title' => t('Choice @n', array('@n' => ($delta + 1))),    '#default_value' => $value,    '#parents' => array('choice', $delta, 'chtext'),  );  if ($admin) {    $form['chvotes'] = array(      '#type' => 'textfield',      '#title' => t('Votes for choice @n', array('@n' => ($delta + 1))),      '#default_value' => $votes,      '#size' => 5,      '#maxlength' => 7,      '#parents' => array('choice', $delta, 'chvotes'),    );  }  return $form;}/** * Menu callback for AHAH additions. */function poll_choice_js() {  include_once 'modules/node/node.pages.inc';  $form_state = array('storage' => NULL, 'submitted' => FALSE);  $form_build_id = $_POST['form_build_id'];  // Get the form from the cache.  $form = form_get_cache($form_build_id, $form_state);  $args = $form['#parameters'];  $form_id = array_shift($args);  // We will run some of the submit handlers so we need to disable redirecting.  $form['#redirect'] = FALSE;  // We need to process the form, prepare for that by setting a few internals  // variables.  $form['#post'] = $_POST;  $form['#programmed'] = FALSE;  $form_state['post'] = $_POST;  // Build, validate and if possible, submit the form.  drupal_process_form($form_id, $form, $form_state);  // This call recreates the form relying solely on the form_state that the  // drupal_process_form set up.  $form = drupal_rebuild_form($form_id, $form_state, $args, $form_build_id);  // Render the new output.  $choice_form = $form['choice_wrapper']['choice'];  unset($choice_form['#prefix'], $choice_form['#suffix']); // Prevent duplicate wrappers.  $output = theme('status_messages') . drupal_render($choice_form);  drupal_json(array('status' => TRUE, 'data' => $output));}/** * Renumbers fields and creates a teaser when a poll node is submitted. */function poll_node_form_submit(&$form, &$form_state) {  // Renumber fields  $form_state['values']['choice'] = array_values($form_state['values']['choice']);  $form_state['values']['teaser'] = poll_teaser((object)$form_state['values']);}/** * Implementation of hook_validate(). */function poll_validate($node) {  if (isset($node->title)) {    // Check for at least two options and validate amount of votes:    $realchoices = 0;    // Renumber fields    $node->choice = array_values($node->choice);    foreach ($node->choice as $i => $choice) {      if ($choice['chtext'] != '') {        $realchoices++;      }      if (isset($choice['chvotes']) && $choice['chvotes'] < 0) {        form_set_error("choice][$i][chvotes", t('Negative values are not allowed.'));      }    }    if ($realchoices < 2) {      form_set_error("choice][$realchoices][chtext", t('You must fill in at least two choices.'));    }  }}/** * Implementation of hook_load(). */function poll_load($node) {  global $user;  $poll = db_fetch_object(db_query("SELECT runtime, active FROM {poll} WHERE nid = %d", $node->nid));  // Load the appropriate choices into the $poll object.  $result = db_query("SELECT chtext, chvotes, chorder FROM {poll_choices} WHERE nid = %d ORDER BY chorder", $node->nid);  while ($choice = db_fetch_array($result)) {    $poll->choice[$choice['chorder']] = $choice;  }  // Determine whether or not this user is allowed to vote.  $poll->allowvotes = FALSE;  if (user_access('vote on polls') && $poll->active) {    if ($user->uid) {      $result = db_fetch_object(db_query('SELECT chorder FROM {poll_votes} WHERE nid = %d AND uid = %d', $node->nid, $user->uid));    }    else {      $result = db_fetch_object(db_query("SELECT chorder FROM {poll_votes} WHERE nid = %d AND hostname = '%s'", $node->nid, ip_address()));    }    if (isset($result->chorder)) {      $poll->vote = $result->chorder;    }    else {      $poll->vote = -1;      $poll->allowvotes = TRUE;    }  }  return $poll;}/** * Implementation of hook_insert(). */function poll_insert($node) {  if (!user_access('administer nodes')) {    // Make sure all votes are 0 initially    foreach ($node->choice as $i => $choice) {      $node->choice[$i]['chvotes'] = 0;    }    $node->active = 1;  }  db_query("INSERT INTO {poll} (nid, runtime, active) VALUES (%d, %d, %d)", $node->nid, $node->runtime, $node->active);  $i = 0;  foreach ($node->choice as $choice) {    if ($choice['chtext'] != '') {      db_query("INSERT INTO {poll_choices} (nid, chtext, chvotes, chorder) VALUES (%d, '%s', %d, %d)", $node->nid, $choice['chtext'], $choice['chvotes'], $i++);    }  }}/** * Implementation of hook_update(). */function poll_update($node) {  // Update poll settings.  db_query('UPDATE {poll} SET runtime = %d, active = %d WHERE nid = %d', $node->runtime, $node->active, $node->nid);  // Clean poll choices.  db_query('DELETE FROM {poll_choices} WHERE nid = %d', $node->nid);  // Poll choices come in the same order with the same numbers as they are in  // the database, but some might have an empty title, which signifies that  // they should be removed. We remove all votes to the removed options, so  // people who voted on them can vote again.  $new_chorder = 0;  foreach ($node->choice as $old_chorder => $choice) {    $chvotes = isset($choice['chvotes']) ? (int)$choice['chvotes'] : 0;    $chtext = $choice['chtext'];    if (!empty($chtext)) {      db_query("INSERT INTO {poll_choices} (nid, chtext, chvotes, chorder) VALUES (%d, '%s', %d, %d)", $node->nid, $chtext, $chvotes, $new_chorder);      if ($new_chorder != $old_chorder) {        // We can only remove items in the middle, not add, so        // new_chorder is always <= old_chorder, making this safe.        db_query("UPDATE {poll_votes} SET chorder = %d WHERE nid = %d AND chorder = %d", $new_chorder, $node->nid, $old_chorder);      }      $new_chorder++;    }    else {      db_query("DELETE FROM {poll_votes} WHERE nid = %d AND chorder = %d", $node->nid, $old_chorder);    }  }}/** * Implementation of hook_delete(). */function poll_delete($node) {  db_query("DELETE FROM {poll} WHERE nid = %d", $node->nid);  db_query("DELETE FROM {poll_choices} WHERE nid = %d", $node->nid);  db_query("DELETE FROM {poll_votes} WHERE nid = %d", $node->nid);}/** * Implementation of hook_view(). * * @param $block *   An extra parameter that adapts the hook to display a block-ready *   rendering of the poll. */function poll_view($node, $teaser = FALSE, $page = FALSE, $block = FALSE) {  global $user;  $output = '';  // Special display for side-block  if ($block) {    // No 'read more' link    $node->readmore = FALSE;    $links = module_invoke_all('link', 'node', $node, 1);    $links[] = array('title' => t('Older polls'), 'href' => 'poll', 'attributes' => array('title' => t('View the list of polls on this site.')));    if ($node->allowvotes && $block) {      $links[] = array('title' => t('Results'), 'href' => 'node/'. $node->nid .'/results', 'attributes' => array('title' => t('View the current poll results.')));    }    $node->links = $links;  }  if (!empty($node->allowvotes) && ($block || empty($node->show_results))) {    $node->content['body'] = array(      '#value' => drupal_get_form('poll_view_voting', $node, $block),    );  }  else {    $node->content['body'] = array(      '#value' => poll_view_results($node, $teaser, $page, $block),    );  }  return $node;}/** * Creates a simple teaser that lists all the choices. * * This is primarily used for RSS. */function poll_teaser($node) {  $teaser = NULL;  if (is_array($node->choice)) {    foreach ($node->choice as $k => $choice) {      if ($choice['chtext'] != '') {        $teaser .= '* '. check_plain($choice['chtext']) ."\n";      }    }  }  return $teaser;}/** * Generates the voting form for a poll. * * @ingroup forms * @see poll_vote() * @see phptemplate_preprocess_poll_vote() */function poll_view_voting(&$form_state, $node, $block) {  if ($node->choice) {    $list = array();    foreach ($node->choice as $i => $choice) {      $list[$i] = check_plain($choice['chtext']);    }    $form['choice'] = array(      '#type' => 'radios',      '#default_value' => -1,      '#options' => $list,    );  }  $form['vote'] = array(    '#type' => 'submit',    '#value' => t('Vote'),    '#submit' => array('poll_vote'),  );  // Store the node so we can get to it in submit functions.  $form['#node'] = $node;  $form['#block'] = $block;  // Set form caching because we could have multiple of these forms on  // the same page, and we want to ensure the right one gets picked.  $form['#cache'] = TRUE;  // Provide a more cleanly named voting form theme.  $form['#theme'] = 'poll_vote';  return $form;}/** * Validation function for processing votes */function poll_view_voting_validate($form, &$form_state) {  if ($form_state['values']['choice'] == -1) {    form_set_error( 'choice', t('Your vote could not be recorded because you did not select any of the choices.'));  }}/** * Submit handler for processing a vote */function poll_vote($form, &$form_state) {  $node = $form['#node'];  $choice = $form_state['values']['choice'];  global $user;  if ($user->uid) {    db_query('INSERT INTO {poll_votes} (nid, chorder, uid) VALUES (%d, %d, %d)', $node->nid, $choice, $user->uid);  }  else {    db_query("INSERT INTO {poll_votes} (nid, chorder, hostname) VALUES (%d, %d, '%s')", $node->nid, $choice, ip_address());  }  // Add one to the votes.  db_query("UPDATE {poll_choices} SET chvotes = chvotes + 1 WHERE nid = %d AND chorder = %d", $node->nid, $choice);  cache_clear_all();  drupal_set_message(t('Your vote was recorded.'));  // Return the user to whatever page they voted from.}/** * Themes the voting form for a poll. * * Inputs: $form */function template_preprocess_poll_vote(&$variables) {  $form = $variables['form'];  $variables['choice'] = drupal_render($form['choice']);  $variables['title'] = check_plain($form['#node']->title);  $variables['vote'] = drupal_render($form['vote']);  $variables['rest'] = drupal_render($form);  $variables['block'] = $form['#block'];  // If this is a block, allow a different tpl.php to be used.  if ($variables['block']) {    $variables['template_files'][] = 'poll-vote-block';  }}/** * Generates a graphical representation of the results of a poll. */function poll_view_results(&$node, $teaser, $page, $block) {  // Count the votes and find the maximum  $total_votes = 0;  $max_votes = 0;  foreach ($node->choice as $choice) {    if (isset($choice['chvotes'])) {      $total_votes += $choice['chvotes'];      $max_votes = max($max_votes, $choice['chvotes']);    }  }  $poll_results = '';  foreach ($node->choice as $i => $choice) {    if (!empty($choice['chtext'])) {      $chvotes = isset($choice['chvotes']) ? $choice['chvotes'] : NULL;      $poll_results .= theme('poll_bar', $choice['chtext'], $chvotes, $total_votes, isset($node->vote) && $node->vote == $i, $block);    }  }  return theme('poll_results', $node->title, $poll_results, $total_votes, isset($node->links) ? $node->links : array(), $block, $node->nid, isset($node->vote) ? $node->vote : NULL);}/** * Theme the admin poll form for choices. * * @ingroup themeable */function theme_poll_choices($form) {  // Change the button title to reflect the behavior when using JavaScript.  drupal_add_js('if (Drupal.jsEnabled) { $(document).ready(function() { $("#edit-poll-more").val("'. t('Add another choice') .'"); }); }', 'inline');  $rows = array();  $headers = array(    t('Choice'),    t('Vote count'),  );  foreach (element_children($form) as $key) {    // No need to print the field title every time.    unset($form[$key]['chtext']['#title'], $form[$key]['chvotes']['#title']);    // Build the table row.    $row = array(      'data' => array(        array('data' => drupal_render($form[$key]['chtext']), 'class' => 'poll-chtext'),        array('data' => drupal_render($form[$key]['chvotes']), 'class' => 'poll-chvotes'),      ),    );    // Add additional attributes to the row, such as a class for this row.    if (isset($form[$key]['#attributes'])) {      $row = array_merge($row, $form[$key]['#attributes']);    }    $rows[] = $row;  }  $output = theme('table', $headers, $rows);  $output .= drupal_render($form);  return $output;}/** * Preprocess the poll_results theme hook. * * Inputs: $raw_title, $results, $votes, $raw_links, $block, $nid, $vote. The * $raw_* inputs to this are naturally unsafe; often safe versions are * made to simply overwrite the raw version, but in this case it seems likely * that the title and the links may be overridden by the theme layer, so they * are left in with a different name for that purpose. * * @see poll-results.tpl.php * @see poll-results-block.tpl.php * @see theme_poll_results() */function template_preprocess_poll_results(&$variables) {  $variables['links'] = theme('links', $variables['raw_links']);  if (isset($variables['vote']) && $variables['vote'] > -1 && user_access('cancel own vote')) {    $variables['cancel_form'] = drupal_get_form('poll_cancel_form', $variables['nid']);  }  $variables['title'] = check_plain($variables['raw_title']);  // If this is a block, allow a different tpl.php to be used.  if ($variables['block']) {    $variables['template_files'][] = 'poll-results-block';  }}/** * Preprocess the poll_bar theme hook. * * Inputs: $title, $votes, $total_votes, $voted, $block * * @see poll-bar.tpl.php * @see poll-bar-block.tpl.php * @see theme_poll_bar() */function template_preprocess_poll_bar(&$variables) {  if ($variables['block']) {    $variables['template_files'][] = 'poll-bar-block';  }  $variables['title'] = check_plain($variables['title']);  $variables['percentage'] = round($variables['votes'] * 100 / max($variables['total_votes'], 1));}/** * Builds the cancel form for a poll. * * @ingroup forms * @see poll_cancel() */function poll_cancel_form(&$form_state, $nid) {  // Store the nid so we can get to it in submit functions.  $form['#nid'] = $nid;  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Cancel your vote'),    '#submit' => array('poll_cancel')  );  $form['#cache'] = TRUE;  return $form;}/** * Submit callback for poll_cancel_form */function poll_cancel($form, &$form_state) {  $node = node_load($form['#nid']);  global $user;  if ($user->uid) {    db_query('DELETE FROM {poll_votes} WHERE nid = %d and uid = %d', $node->nid, $user->uid);  }  else {    db_query("DELETE FROM {poll_votes} WHERE nid = %d and hostname = '%s'", $node->nid, ip_address());  }  // Subtract from the votes.  db_query("UPDATE {poll_choices} SET chvotes = chvotes - 1 WHERE nid = %d AND chorder = %d", $node->nid, $node->vote);}/** * Implementation of hook_user(). */function poll_user($op, &$edit, &$user) {  if ($op == 'delete') {    db_query('UPDATE {poll_votes} SET uid = 0 WHERE uid = %d', $user->uid);  }}
<?php// $Id$/** * @file * Enables keeping an easily and regularly updated web page or a blog. *//** * Implementation of hook_node_info(). */function blog_node_info() {  return array(    'blog' => array(      'name' => t('Blog entry'),      'module' => 'blog',      'description' => t('A <em>blog entry</em> is a single post to an online journal, or <em>blog</em>.'),    )  );}/** * Implementation of hook_perm(). */function blog_perm() {  return array('create blog entries', 'delete own blog entries', 'delete any blog entry', 'edit own blog entries', 'edit any blog entry');}/** * Implementation of hook_access(). */function blog_access($op, $node, $account) {  switch ($op) {    case 'create':      // Anonymous users cannot post even if they have the permission.       return user_access('create blog entries', $account) && $account->uid ? TRUE : NULL;    case 'update':      return user_access('edit any blog entry', $account) || (user_access('edit own blog entries', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;    case 'delete':      return user_access('delete any blog entry', $account) || (user_access('delete own blog entries', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;  }}/** * Implementation of hook_user(). */function blog_user($type, &$edit, &$user) {  if ($type == 'view' && user_access('create blog entries', $user)) {    $user->content['summary']['blog'] =  array(      '#type' => 'user_profile_item',      '#title' => t('Blog'),      // l() escapes the attributes, so we should not escape !username here.      '#value' => l(t('View recent blog entries'), "blog/$user->uid", array('attributes' => array('title' => t("Read !username's latest blog entries.", array('!username' => $user->name))))),      '#attributes' => array('class' => 'blog'),    );  }}/** * Implementation of hook_help(). */function blog_help($path, $arg) {  switch ($path) {    case 'admin/help#blog':      $output = '<p>'. t('The blog module allows registered users to maintain an online journal, or <em>blog</em>. Blogs are made up of individual <em>blog entries</em>, and the blog entries are most often displayed in descending order by creation time.') .'</p>';      $output .= '<p>'. t('There is an (optional) <em>Blogs</em> menu item added to the Navigation menu, which displays all blogs available on your site, and a <em>My blog</em> item displaying the current user\'s blog entries. The <em>Blog entry</em> menu item under <em>Create content</em> allows new blog entries to be created.') .'</p>';      $output .= '<p>'. t('Each blog entry is displayed with an automatic link to other blogs created by the same user. By default, blog entries have comments enabled and are automatically promoted to the site front page. The blog module also creates a <em>Recent blog posts</em> block that may be enabled at the <a href="@blocks">blocks administration page</a>.', array('@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('When using the aggregator module an automatic <em>blog it</em> icon is displayed next to the items in a feed\'s <em>latest items</em> block. Clicking this icon populates a <em>blog entry</em> with a title (the title of the feed item) and body (a link to the source item on its original site and illustrative content suitable for use in a block quote). Blog authors can use this feature to easily comment on items of interest that appear in aggregator feeds from other sites. To use this feature, be sure to <a href="@modules">enable</a> the aggregator module, <a href="@feeds">add and configure</a> a feed from another site, and <a href="@blocks">position</a> the feed\'s <em>latest items</em> block.', array('@modules' => url('admin/build/modules'), '@feeds' => url('admin/content/aggregator'), '@blocks' => url('admin/build/block'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@blog">Blog module</a>.', array('@blog' => 'http://drupal.org/handbook/modules/blog/')) .'</p>';      return $output;  }}/** * Implementation of hook_form(). */function blog_form(&$node) {  global $nid;  $iid = isset($_GET['iid']) ? (int)$_GET['iid'] : 0;  $type = node_get_types('type', $node);  if (empty($node->body)) {    // If the user clicked a "blog it" link, we load the data from the    // database and quote it in the blog.    if ($nid && $blog = node_load($nid)) {      $node->body = '<em>'. $blog->body .'</em> ['. l($blog->name, "node/$nid") .']';    }    if ($iid && $item = db_fetch_object(db_query('SELECT i.*, f.title as ftitle, f.link as flink FROM {aggregator_item} i, {aggregator_feed} f WHERE i.iid = %d AND i.fid = f.fid', $iid))) {      $node->title = $item->title;      // Note: $item->description has been validated on aggregation.      $node->body = '<a href="'. check_url($item->link) .'">'. check_plain($item->title) .'</a> - <em>'. $item->description .'</em> [<a href="'. check_url($item->flink) .'">'. check_plain($item->ftitle) ."</a>]\n";    }  }  $form['title'] = array('#type' => 'textfield', '#title' => check_plain($type->title_label), '#required' => TRUE, '#default_value' => !empty($node->title) ? $node->title : NULL, '#weight' => -5);  $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);  return $form;}/** * Implementation of hook_view(). */function blog_view($node, $teaser = FALSE, $page = FALSE) {  if ($page) {    // Breadcrumb navigation. l() escapes the title, so we should not escape !name.     drupal_set_breadcrumb(array(l(t('Home'), NULL), l(t('Blogs'), 'blog'), l(t("!name's blog", array('!name' => $node->name)), 'blog/'. $node->uid)));  }  return node_prepare($node, $teaser);}/** * Implementation of hook_link(). */function blog_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && $node->type == 'blog') {    if (arg(0) != 'blog' || arg(1) != $node->uid) {      // This goes to l() and therefore escapes !username in both the title and attributes.      $links['blog_usernames_blog'] = array(        'title' => t("!username's blog", array('!username' => $node->name)),        'href' => "blog/$node->uid",        'attributes' => array('title' => t("Read !username's latest blog entries.", array('!username' => $node->name)))      );    }  }  return $links;}/** * Implementation of hook_menu(). */function blog_menu() {  $items['blog'] = array(    'title' => 'Blogs',    'page callback' => 'blog_page_last',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'blog.pages.inc',  );  $items['blog/%user_uid_optional'] = array(    'title' => 'My blog',    'page callback' => 'blog_page_user',    'page arguments' => array(1),    'access callback' => 'blog_page_user_access',    'access arguments' => array(1),    'file' => 'blog.pages.inc',  );  $items['blog/%user/feed'] = array(    'title' => 'Blogs',    'page callback' => 'blog_feed_user',    'page arguments' => array(1),    'access callback' => 'blog_page_user_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,    'file' => 'blog.pages.inc',  );  $items['blog/feed'] = array(    'title' => 'Blogs',    'page callback' => 'blog_feed_last',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,    'file' => 'blog.pages.inc',  );  return $items;}/** * Access callback for user blog pages. */function blog_page_user_access($account) {  // The visitor must be able to access the site's content.  // For a blog to 'exist' the user must either be able to  // create new blog entries, or it must have existing posts.  return $account->uid && user_access('access content') && (user_access('create blog entries', $account) || _blog_post_exists($account));}/** * Helper function to determine if a user has blog posts already. */function _blog_post_exists($account) {  return (bool)db_result(db_query_range(db_rewrite_sql("SELECT 1 FROM {node} n WHERE n.type = 'blog' AND n.uid = %d AND n.status = 1"), $account->uid, 0, 1));}/** * Implementation of hook_block(). * * Displays the most recent 10 blog titles. */function blog_block($op = 'list', $delta = 0) {  global $user;  if ($op == 'list') {    $block[0]['info'] = t('Recent blog posts');    return $block;  }  else if ($op == 'view') {    if (user_access('access content')) {      $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, n.created FROM {node} n WHERE n.type = 'blog' AND n.status = 1 ORDER BY n.created DESC"), 0, 10);      if ($node_title_list = node_title_list($result)) {        $block['content'] = $node_title_list;        $block['content'] .= theme('more_link', url('blog'), t('Read the latest blog entries.'));        $block['subject'] = t('Recent blog posts');        return $block;      }    }  }}
<?php// $Id$/** * @file * Enables the use of personal and site-wide contact forms. *//** * Implementation of hook_help(). */function contact_help($path, $arg) {  switch ($path) {    case 'admin/help#contact':      $output = '<p>'. t('The contact module facilitates communication via e-mail, by allowing your site\'s visitors to contact one another (personal contact forms), and by providing a simple way to direct messages to a set of administrator-defined recipients (the <a href="@contact">contact page</a>). With either form, users specify a subject, write their message, and (optionally) have a copy of their message sent to their own e-mail address.', array('@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t("Personal contact forms allow users to be contacted via e-mail, while keeping recipient e-mail addresses private. Users may enable or disable their personal contact forms by editing their <em>My account</em> page. If enabled, a <em>Contact</em> tab leading to their personal contact form is available on their user profile. Site administrators have access to all personal contact forms (even if they have been disabled). The <em>Contact</em> tab is only visible when viewing another user's profile (users do not see their own <em>Contact</em> tab).") .'</p>';      $output .= '<p>'. t('The <a href="@contact">contact page</a> provides a simple form for visitors to leave comments, feedback, or other requests. Messages are routed by selecting a category from a list of administrator-defined options; each category has its own set of e-mail recipients. Common categories for a business site include, for example, "Website feedback" (messages are forwarded to web site administrators) and "Product information" (messages are forwarded to members of the sales department). The actual e-mail addresses defined within a category are not displayed. Only users in roles with the <em>access site-wide contact form</em> permission may access the <a href="@contact">contact page</a>.', array('@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t('A link to your site\'s <a href="@contact">contact page</a> from the main <em>Navigation</em> menu is created, but is disabled by default. Create a similar link on another menu by adding a menu item pointing to the path "contact"', array('@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t('Customize the <a href="@contact">contact page</a> with additional information (like physical location, mailing address, and telephone number) using the <a href="@contact-settings">contact form settings page</a>. The <a href="@contact-settings">settings page</a> also provides configuration options for the maximum number of contact form submissions a user may perform per hour, and the default status of users\' personal contact forms.', array('@contact-settings' => url('admin/build/contact/settings'), '@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@contact">Contact module</a>.', array('@contact' => url('http://drupal.org/handbook/modules/contact/', array('absolute' => TRUE)))) .'</p>';      return $output;    case 'admin/build/contact':      $output = '<p>'. t('This page lets you set up <a href="@form">your site-wide contact form</a>. To do so, add one or more categories. You can associate different recipients with each category to route e-mails to different people. For example, you can route website feedback to the webmaster and direct product information requests to the sales department. On the <a href="@settings">settings page</a>, you can customize the information shown above the contact form. This can be useful to provide additional contact information such as your postal address and telephone number.', array('@settings' => url('admin/build/contact/settings'), '@form' => url('contact'))) .'</p>';      if (!module_exists('menu')) {        $menu_note = t('The menu item can be customized and configured only once the menu module has been <a href="@modules-page">enabled</a>.', array('@modules-page' => url('admin/settings/modules')));      }      else {        $menu_note = '';      }      $output .= '<p>'. t('The contact module also adds a <a href="@menu-settings">menu item</a> (disabled by default) to the navigation block.', array('@menu-settings' => url('admin/build/menu'))) .' '. $menu_note .'</p>';      return $output;  }}/** * Implementation of hook_perm */function contact_perm() {  return array('access site-wide contact form', 'administer site-wide contact form');}/** * Implementation of hook_menu(). */function contact_menu() {  $items['admin/build/contact'] = array(    'title' => 'Contact form',    'description' => 'Create a system contact form and set up categories for the form to use.',    'page callback' => 'contact_admin_categories',    'access arguments' => array('administer site-wide contact form'),    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/list'] = array(    'title' => 'List',    'page callback' => 'contact_admin_categories',    'type' => MENU_DEFAULT_LOCAL_TASK,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/add'] = array(    'title' => 'Add category',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_edit', 3),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/edit/%contact'] = array(    'title' => 'Edit contact category',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_edit', 3, 4),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_CALLBACK,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/delete/%contact'] = array(    'title' => 'Delete contact',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_delete', 4),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_CALLBACK,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_settings'),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'contact.admin.inc',  );  $items['contact'] = array(    'title' => 'Contact',    'page callback' => 'contact_site_page',    'access arguments' => array('access site-wide contact form'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'contact.pages.inc',  );  $items['user/%user/contact'] = array(    'title' => 'Contact',    'page callback' => 'contact_user_page',    'page arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'access callback' => '_contact_user_tab_access',    'access arguments' => array(1),    'weight' => 2,    'file' => 'contact.pages.inc',  );  return $items;}/** * Menu access callback for a user's personal contact form. * * @param $account *   A user account object. * @return *   TRUE if the current user has access to the requested user's contact form, *   or FALSE otherwise. */function _contact_user_tab_access($account) {  global $user;  // Anonymous users cannot use or have contact forms.  if (!$user->uid || !$account->uid) {    return FALSE;  }  // User administrators should always have access to personal contact forms.  if (user_access('administer users')) {    return TRUE;  }  // Users may not contact themselves.  if ($user->uid == $account->uid) {    return FALSE;  }  // If the requested user has disabled their contact form, or this preference  // has not yet been saved, do not allow users to contact them.  if (empty($account->contact)) {    return FALSE;  }  return TRUE;}/** * Load the data for a single contact category. */function contact_load($cid) {  $contact = db_fetch_array(db_query("SELECT * FROM {contact} WHERE cid = %d", $cid));  return empty($contact) ? FALSE : $contact;}/** * Implementation of hook_user(). * * Allows the user the option of enabling/disabling his personal contact form. */function contact_user($type, &$edit, &$user, $category = NULL) {  if ($type == 'form' && $category == 'account') {    $form['contact'] = array('#type' => 'fieldset',      '#title' => t('Contact settings'),      '#weight' => 5,      '#collapsible' => TRUE,    );    $form['contact']['contact'] = array('#type' => 'checkbox',      '#title' => t('Personal contact form'),      '#default_value' => !empty($edit['contact']) ? $edit['contact'] : FALSE,      '#description' => t('Allow other users to contact you by e-mail via <a href="@url">your personal contact form</a>. Note that while your e-mail address is not made public to other members of the community, privileged users such as site administrators are able to contact you even if you choose not to enable this feature.', array('@url' => url("user/$user->uid/contact"))),    );    return $form;  }  elseif ($type == 'validate') {    return array('contact' => isset($edit['contact']) ? $edit['contact'] : FALSE);  }  elseif ($type == 'insert') {    $edit['contact'] = variable_get('contact_default_status', 1);  }}/** * Implementation of hook_mail(). */function contact_mail($key, &$message, $params) {  $language = $message['language'];  switch ($key) {    case 'page_mail':    case 'page_copy':      $contact = $params['contact'];      $message['subject'] .= t('[!category] !subject', array('!category' => $contact['category'], '!subject' => $params['subject']), $language->language);      $message['body'][] = t("!name sent a message using the contact form at !form.", array('!name' => $params['name'], '!form' => url($_GET['q'], array('absolute' => TRUE, 'language' => $language))), $language->language);      $message['body'][] = $params['message'];      break;    case 'page_autoreply':      $contact = $params['contact'];      $message['subject'] .= t('[!category] !subject', array('!category' => $contact['category'], '!subject' => $params['subject']), $language->language);      $message['body'][] = $contact['reply'];      break;    case 'user_mail':    case 'user_copy':      $user = $params['user'];      $account = $params['account'];      $message['subject'] .= '['. variable_get('site_name', 'Drupal') .'] '. $params['subject'];      $message['body'][] = "$account->name,";      $message['body'][] = t("!name (!name-url) has sent you a message via your contact form (!form-url) at !site.", array('!name' => $user->name, '!name-url' => url("user/$user->uid", array('absolute' => TRUE, 'language' => $language)), '!form-url' => url($_GET['q'], array('absolute' => TRUE, 'language' => $language)), '!site' => variable_get('site_name', 'Drupal')), $language->language);      $message['body'][] = t("If you don't want to receive such e-mails, you can change your settings at !url.", array('!url' => url("user/$account->uid", array('absolute' => TRUE, 'language' => $language))), $language->language);      $message['body'][] = t('Message:', NULL, $language->language);      $message['body'][] = $params['message'];      break;  }}
<?php// $Id$/** * @file * Implement OpenID Relying Party support for Drupal *//** * Implementation of hook_menu. */function openid_menu() {  $items['openid/authenticate'] = array(    'title' => 'OpenID Login',    'page callback' => 'openid_authentication_page',    'access callback' => 'user_is_anonymous',    'type' => MENU_CALLBACK,    'file' => 'openid.pages.inc',  );  $items['user/%user/openid'] = array(    'title' => 'OpenID identities',    'page callback' => 'openid_user_identities',    'page arguments' => array(1),    'access callback' => 'user_edit_access',    'access arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'file' => 'openid.pages.inc',  );  $items['user/%user/openid/delete'] = array(    'title' => 'Delete OpenID',    'page callback' => 'drupal_get_form',    'page arguments' => array('openid_user_delete_form', 1),    'access callback' => 'user_edit_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,    'file' => 'openid.pages.inc',  );  return $items;}/** * Implementation of hook_help(). */function openid_help($path, $arg) {  switch ($path) {    case 'user/%/openid':      $output = '<p>'. t('This site supports <a href="@openid-net">OpenID</a>, a secure way to log into many websites using a single username and password. OpenID can reduce the necessity of managing many usernames and passwords for many websites.', array('@openid-net' => 'http://openid.net')) .'</p>';      $output .= '<p>'. t('To use OpenID you must first establish an identity on a public or private OpenID server. If you do not have an OpenID and would like one, look into one of the <a href="@openid-providers">free public providers</a>. You can find out more about OpenID at <a href="@openid-net">this website</a>.', array('@openid-providers' => 'http://openid.net/get/', '@openid-net' => 'http://openid.net')) .'</p>';      $output .= '<p>'. t('If you already have an OpenID, enter the URL to your OpenID server below (e.g. myusername.openidprovider.com). Next time you login, you will be able to use this URL instead of a regular username and password. You can have multiple OpenID servers if you like; just keep adding them here.') .'</p>';      return $output;    case 'admin/help#openid':      $output = '<p>'. t('OpenID is a secure method for logging into many websites with a single username and password. It does not require special software, and it does not share passwords with any site to which it is associated; including your site.') .'</p>';      $output .= '<p>'. t('Users can create accounts using their OpenID, assign one or more OpenIDs to an existing account, and log in using an OpenID. This lowers the barrier to registration, which is good for the site, and offers convenience and security to the users. OpenID is not a trust system, so email verification is still necessary. The benefit stems from the fact that users can have a single password that they can use on many websites. This means they can easily update their single password from a centralized location, rather than having to change dozens of passwords individually.') .'</p>';      $output .= '<p>'. t('The basic concept is as follows: A user has an account on an OpenID server. This account provides them with a unique URL (such as myusername.openidprovider.com). When the user comes to your site, they are presented with the option of entering this URL. Your site then communicates with the OpenID server, asking it to verify the identity of the user. If the user is logged into their OpenID server, the server communicates back to your site, verifying the user. If they are not logged in, the OpenID server will ask the user for their password. At no point does your site record, or need to record the user\'s password.') .'</p>';      $output .= '<p>'. t('More information on OpenID is available at <a href="@openid-net">OpenID.net</a>.', array('@openid-net' => url('http://openid.net'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@handbook">OpenID module</a>.', array('@handbook' => 'http://drupal.org/handbook/modules/openid')) .'</p>';      return $output;  }}/** * Implementation of hook_user(). */function openid_user($op, &$edit, &$account, $category = NULL) {  if ($op == 'insert' && isset($_SESSION['openid']['values'])) {    // The user has registered after trying to login via OpenID.    if (variable_get('user_email_verification', TRUE)) {      drupal_set_message(t('Once you have verified your email address, you may log in via OpenID.'));    }    unset($_SESSION['openid']);  }}/** * Implementation of hook_form_alter : adds OpenID login to the login forms. */function openid_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'user_login_block' || $form_id == 'user_login') {    drupal_add_css(drupal_get_path('module', 'openid') .'/openid.css', 'module');    drupal_add_js(drupal_get_path('module', 'openid') .'/openid.js');    if (!empty($form_state['post']['openid_identifier'])) {      $form['name']['#required'] = FALSE;      $form['pass']['#required'] = FALSE;      unset($form['#submit']);      $form['#validate'] = array('openid_login_validate');    }    $items = array();    $items[] = array(      'data' => l(t('Log in using OpenID'), '#'),      'class' => 'openid-link',    );    $items[] = array(      'data' => l(t('Cancel OpenID login'), '#'),      'class' => 'user-link',    );        $form['openid_links'] = array(      '#value' => theme('item_list', $items),      '#weight' => 1,    );    $form['links']['#weight'] = 2;    $form['openid_identifier'] = array(      '#type' => 'textfield',      '#title' => t('Log in using OpenID'),      '#size' => ($form_id == 'user_login') ? 58 : 13,      '#maxlength' => 255,      '#weight' => -1,      '#description' => l(t('What is OpenID?'), 'http://openid.net/', array('external' => TRUE)),    );    $form['openid.return_to'] = array('#type' => 'hidden', '#value' => url('openid/authenticate', array('absolute' => TRUE, 'query' => drupal_get_destination())));  }  elseif ($form_id == 'user_register' && isset($_SESSION['openid']['values'])) {    // We were unable to auto-register a new user. Prefill the registration    // form with the values we have.    $form['name']['#default_value'] = $_SESSION['openid']['values']['name'];    $form['mail']['#default_value'] = $_SESSION['openid']['values']['mail'];    // If user_email_verification is off, hide the password field and just fill    // with random password to avoid confusion.    if (!variable_get('user_email_verification', TRUE)) {      $form['pass']['#type'] = 'hidden';      $form['pass']['#value'] = user_password();    }    $form['auth_openid'] = array('#type' => 'hidden', '#value' => $_SESSION['openid']['values']['auth_openid']);    $form['openid_display'] = array(      '#type' => 'item',      '#title' => t('Your OpenID'),      '#description' => t('This OpenID will be attached to your account after registration.'),      '#value' => check_plain($_SESSION['openid']['values']['auth_openid']),    );  }  return $form;}/** * Login form _validate hook */function openid_login_validate($form, &$form_state) {  $return_to = $form_state['values']['openid.return_to'];  if (empty($return_to)) {    $return_to = url('', array('absolute' => TRUE));  }  openid_begin($form_state['values']['openid_identifier'], $return_to, $form_state['values']);}/** * The initial step of OpenID authentication responsible for the following: *  - Perform discovery on the claimed OpenID. *  - If possible, create an association with the Provider's endpoint. *  - Create the authentication request. *  - Perform the appropriate redirect. * * @param $claimed_id The OpenID to authenticate * @param $return_to The endpoint to return to from the OpenID Provider */function openid_begin($claimed_id, $return_to = '', $form_values = array()) {  module_load_include('inc', 'openid');  $claimed_id = _openid_normalize($claimed_id);  $services = openid_discovery($claimed_id);  if (count($services) == 0) {    form_set_error('openid_identifier', t('Sorry, that is not a valid OpenID. Please ensure you have spelled your ID correctly.'));    return;  }  // Store discovered information in the users' session so we don't have to rediscover.  $_SESSION['openid']['service'] = $services[0];  // Store the claimed id  $_SESSION['openid']['claimed_id'] = $claimed_id;  // Store the login form values so we can pass them to  // user_exteral_login later.  $_SESSION['openid']['user_login_values'] = $form_values;  $op_endpoint = $services[0]['uri'];  // If bcmath is present, then create an association  $assoc_handle = '';  if (function_exists('bcadd')) {    $assoc_handle = openid_association($op_endpoint);  }  // Now that there is an association created, move on  // to request authentication from the IdP  // First check for LocalID. If not found, check for Delegate. Fall  // back to $claimed_id if neither is found.  if (!empty($services[0]['localid'])) {    $identity = $services[0]['localid'];  }  else if (!empty($services[0]['delegate'])) {    $identity = $services[0]['delegate'];  }  else {    $identity = $claimed_id;  }  if (isset($services[0]['types']) && is_array($services[0]['types']) && in_array(OPENID_NS_2_0 .'/server', $services[0]['types'])) {    $claimed_id = $identity = 'http://specs.openid.net/auth/2.0/identifier_select';  }  $authn_request = openid_authentication_request($claimed_id, $identity, $return_to, $assoc_handle, $services[0]['version']);  if ($services[0]['version'] == 2) {    openid_redirect($op_endpoint, $authn_request);  }  else {    openid_redirect_http($op_endpoint, $authn_request);  }}/** * Completes OpenID authentication by validating returned data from the OpenID * Provider. * * @param $response Array of returned values from the OpenID Provider. * * @return $response Response values for further processing with *   $response['status'] set to one of 'success', 'failed' or 'cancel'. */function openid_complete($response = array()) {  module_load_include('inc', 'openid');  if (count($response) == 0) {    $response = _openid_response();  }    // Default to failed response  $response['status'] = 'failed';  if (isset($_SESSION['openid']['service']['uri']) && isset($_SESSION['openid']['claimed_id'])) {    $service = $_SESSION['openid']['service'];    $claimed_id = $_SESSION['openid']['claimed_id'];    unset($_SESSION['openid']['service']);    unset($_SESSION['openid']['claimed_id']);    if (isset($response['openid.mode'])) {      if ($response['openid.mode'] == 'cancel') {        $response['status'] = 'cancel';      }      else {        if (openid_verify_assertion($service['uri'], $response)) {          // If the returned claimed_id is different from the session claimed_id,          // then we need to do discovery and make sure the op_endpoint matches.          if ($service['version'] == 2 && $response['openid.claimed_id'] != $claimed_id) {            $disco = openid_discovery($response['openid.claimed_id']);            if ($disco[0]['uri'] != $service['uri']) {              return $response;            }          }          else {            $response['openid.claimed_id'] = $claimed_id;          }          $response['status'] = 'success';        }      }    }  }  return $response;}/** * Perform discovery on a claimed ID to determine the OpenID provider endpoint. * * @param $claimed_id The OpenID URL to perform discovery on. * * @return Array of services discovered (including OpenID version, endpoint * URI, etc). */function openid_discovery($claimed_id) {  module_load_include('inc', 'openid');  module_load_include('inc', 'openid', 'xrds');  $services = array();  $xrds_url = $claimed_id;  if (_openid_is_xri($claimed_id)) {    $xrds_url = 'http://xri.net/'. $claimed_id;  }  $url = @parse_url($xrds_url);  if ($url['scheme'] == 'http' || $url['scheme'] == 'https') {    // For regular URLs, try Yadis resolution first, then HTML-based discovery    $headers = array('Accept' => 'application/xrds+xml');    $result = drupal_http_request($xrds_url, $headers);    if (!isset($result->error)) {      if (isset($result->headers['Content-Type']) && preg_match("/application\/xrds\+xml/", $result->headers['Content-Type'])) {        // Parse XML document to find URL        $services = xrds_parse($result->data);      }      else {        $xrds_url = NULL;        if (isset($result->headers['X-XRDS-Location'])) {          $xrds_url = $result->headers['X-XRDS-Location'];        }        else {          // Look for meta http-equiv link in HTML head          $xrds_url = _openid_meta_httpequiv('X-XRDS-Location', $result->data);        }        if (!empty($xrds_url)) {          $headers = array('Accept' => 'application/xrds+xml');          $xrds_result = drupal_http_request($xrds_url, $headers);          if (!isset($xrds_result->error)) {            $services = xrds_parse($xrds_result->data);          }        }      }      // Check for HTML delegation      if (count($services) == 0) {        // Look for 2.0 links        $uri = _openid_link_href('openid2.provider', $result->data);        $delegate = _openid_link_href('openid2.local_id', $result->data);        $version = 2;        // 1.0 links        if (empty($uri)) {          $uri = _openid_link_href('openid.server', $result->data);          $delegate = _openid_link_href('openid.delegate', $result->data);          $version = 1;        }        if (!empty($uri)) {          $services[] = array('uri' => $uri, 'delegate' => $delegate, 'version' => $version);        }      }    }  }  return $services;}/** * Attempt to create a shared secret with the OpenID Provider. * * @param $op_endpoint URL of the OpenID Provider endpoint. * * @return $assoc_handle The association handle. */function openid_association($op_endpoint) {  module_load_include('inc', 'openid');  // Remove Old Associations:  db_query("DELETE FROM {openid_association} WHERE created + expires_in < %d", time());  // Check to see if we have an association for this IdP already  $assoc_handle = db_result(db_query("SELECT assoc_handle FROM {openid_association} WHERE idp_endpoint_uri = '%s'", $op_endpoint));  if (empty($assoc_handle)) {    $mod = OPENID_DH_DEFAULT_MOD;    $gen = OPENID_DH_DEFAULT_GEN;    $r = _openid_dh_rand($mod);    $private = bcadd($r, 1);    $public = bcpowmod($gen, $private, $mod);    // If there is no existing association, then request one    $assoc_request = openid_association_request($public);    $assoc_message = _openid_encode_message(_openid_create_message($assoc_request));    $assoc_headers = array('Content-Type' => 'application/x-www-form-urlencoded; charset=utf-8');    $assoc_result = drupal_http_request($op_endpoint, $assoc_headers, 'POST', $assoc_message);    if (isset($assoc_result->error)) {      return FALSE;    }    $assoc_response = _openid_parse_message($assoc_result->data);    if (isset($assoc_response['mode']) && $assoc_response['mode'] == 'error') {      return FALSE;    }    if ($assoc_response['session_type'] == 'DH-SHA1') {      $spub = _openid_dh_base64_to_long($assoc_response['dh_server_public']);      $enc_mac_key = base64_decode($assoc_response['enc_mac_key']);      $shared = bcpowmod($spub, $private, $mod);      $assoc_response['mac_key'] = base64_encode(_openid_dh_xorsecret($shared, $enc_mac_key));    }    db_query("INSERT INTO {openid_association} (idp_endpoint_uri, session_type, assoc_handle, assoc_type, expires_in, mac_key, created) VALUES('%s', '%s', '%s', '%s', %d, '%s', %d)",             $op_endpoint, $assoc_response['session_type'], $assoc_response['assoc_handle'], $assoc_response['assoc_type'], $assoc_response['expires_in'], $assoc_response['mac_key'], time());    $assoc_handle = $assoc_response['assoc_handle'];  }  return $assoc_handle;}/** * Authenticate a user or attempt registration. * * @param $response Response values from the OpenID Provider. */function openid_authentication($response) {  module_load_include('inc', 'openid');  $identity = $response['openid.claimed_id'];  $account = user_external_load($identity);  if (isset($account->uid)) {    if (!variable_get('user_email_verification', TRUE) || $account->login) {      user_external_login($account, $_SESSION['openid']['user_login_values']);    }    else {      drupal_set_message(t('You must validate your email address for this account before logging in via OpenID'));    }  }  elseif (variable_get('user_register', 1)) {    // Register new user    $form_state['redirect'] = NULL;    $form_state['values']['name'] = (empty($response['openid.sreg.nickname'])) ? '' : $response['openid.sreg.nickname'];    $form_state['values']['mail'] = (empty($response['openid.sreg.email'])) ? '' : $response['openid.sreg.email'];    $form_state['values']['pass']  = user_password();    $form_state['values']['status'] = variable_get('user_register', 1) == 1;    $form_state['values']['response'] = $response;    $form_state['values']['auth_openid'] = $identity;    if (empty($response['openid.sreg.email']) && empty($response['openid.sreg.nickname'])) {      drupal_set_message(t('Please complete the registration by filling out the form below. If you already have an account, you can <a href="@login">log in</a> now and add your OpenID under "My account".', array('@login' => url('user/login'))), 'warning');      $success = FALSE;    }    else {      $form = drupal_retrieve_form('user_register', $form_state);      drupal_prepare_form('user_register', $form, $form_state);      drupal_validate_form('user_register', $form, $form_state);      $success = !form_get_errors();      if (!$success) {        drupal_set_message(t('Account registration using the information provided by your OpenID provider failed due to the reasons listed below. Please complete the registration by filling out the form below. If you already have an account, you can <a href="@login">log in</a> now and add your OpenID under "My account".', array('@login' => url('user/login'))), 'warning');        // Append form validation errors below the above warning.        $messages = drupal_get_messages('error');        foreach ($messages['error'] as $message) {          drupal_set_message( $message, 'error');        }      }    }    if (!$success) {      // We were unable to register a valid new user, redirect to standard      // user/register and prefill with the values we received.      $_SESSION['openid']['values'] = $form_state['values'];      // We'll want to redirect back to the same place.      $destination = drupal_get_destination();      unset($_REQUEST['destination']);      drupal_goto('user/register', $destination);    }    else {      unset($form_state['values']['response']);      $account = user_save('', $form_state['values']);      // Terminate if an error occured during user_save().      if (!$account) {        drupal_set_message(t("Error saving user account."), 'error');        drupal_goto();      }      user_external_login($account);    }    drupal_redirect_form($form, $form_state['redirect']);  }  else {    drupal_set_message(t('Only site administrators can create new user accounts.'), 'error');  }  drupal_goto();}function openid_association_request($public) {  module_load_include('inc', 'openid');  $request = array(    'openid.ns' => OPENID_NS_2_0,    'openid.mode' => 'associate',    'openid.session_type' => 'DH-SHA1',    'openid.assoc_type' => 'HMAC-SHA1'  );  if ($request['openid.session_type'] == 'DH-SHA1' || $request['openid.session_type'] == 'DH-SHA256') {    $cpub = _openid_dh_long_to_base64($public);    $request['openid.dh_consumer_public'] = $cpub;  }  return $request;}function openid_authentication_request($claimed_id, $identity, $return_to = '', $assoc_handle = '', $version = 2) {  module_load_include('inc', 'openid');  $ns = ($version == 2) ? OPENID_NS_2_0 : OPENID_NS_1_0;  $request =  array(    'openid.ns' => $ns,    'openid.mode' => 'checkid_setup',    'openid.identity' => $identity,    'openid.claimed_id' => $claimed_id,    'openid.assoc_handle' => $assoc_handle,    'openid.return_to' => $return_to,  );  if ($version == 2) {    $request['openid.realm'] = url('', array('absolute' => TRUE));  }  else {    $request['openid.trust_root'] = url('', array('absolute' => TRUE));  }  // Simple Registration  $request['openid.sreg.required'] = 'nickname,email';  $request['openid.ns.sreg'] = "http://openid.net/extensions/sreg/1.1";  $request = array_merge($request, module_invoke_all('openid', 'request', $request));  return $request;}/** * Attempt to verify the response received from the OpenID Provider. * * @param $op_endpoint The OpenID Provider URL. * @param $response Array of repsonse values from the provider. * * @return boolean */function openid_verify_assertion($op_endpoint, $response) {  module_load_include('inc', 'openid');  $valid = FALSE;  $association = db_fetch_object(db_query("SELECT * FROM {openid_association} WHERE assoc_handle = '%s'", $response['openid.assoc_handle']));  if ($association && isset($association->session_type)) {    $keys_to_sign = explode(',', $response['openid.signed']);    $self_sig = _openid_signature($association, $response, $keys_to_sign);    if ($self_sig == $response['openid.sig']) {      $valid = TRUE;    }    else {      $valid = FALSE;    }  }  else {    $request = $response;    $request['openid.mode'] = 'check_authentication';    $message = _openid_create_message($request);    $headers = array('Content-Type' => 'application/x-www-form-urlencoded; charset=utf-8');    $result = drupal_http_request($op_endpoint, $headers, 'POST', _openid_encode_message($message));    if (!isset($result->error)) {      $response = _openid_parse_message($result->data);      if (strtolower(trim($response['is_valid'])) == 'true') {        $valid = TRUE;      }      else {        $valid = FALSE;      }    }  }  return $valid;}
<?php// $Id$/** * @file * User page callbacks for the openid module. *//** * Menu callback; Process an OpenID authentication. */function openid_authentication_page() {  $result = openid_complete();  switch ($result['status']) {    case 'success':      return openid_authentication($result);    case 'failed':      drupal_set_message(t('OpenID login failed.'), 'error');      break;    case 'cancel':      drupal_set_message(t('OpenID login cancelled.'));      break;  }  drupal_goto();}/** * Menu callback; Manage OpenID identities for the specified user. */function openid_user_identities($account) {  drupal_set_title(check_plain($account->name));  drupal_add_css(drupal_get_path('module', 'openid') .'/openid.css', 'module');  // Check to see if we got a response  $result = openid_complete();  if ($result['status'] == 'success') {    $identity = $result['openid.claimed_id'];    db_query("INSERT INTO {authmap} (uid, authname, module) VALUES (%d, '%s','openid')", $account->uid, $identity);    drupal_set_message(t('Successfully added %identity', array('%identity' => $identity)));  }  $header = array(t('OpenID'), t('Operations'));  $rows = array();  $result = db_query("SELECT * FROM {authmap} WHERE module='openid' AND uid=%d", $account->uid);  while ($identity = db_fetch_object($result)) {    $rows[] = array(check_plain($identity->authname), l(t('Delete'), 'user/'. $account->uid .'/openid/delete/'. $identity->aid));  }  $output = theme('table', $header, $rows);  $output .= drupal_get_form('openid_user_add');  return $output;}/** * Form builder; Add an OpenID identity. * * @ingroup forms * @see openid_user_add_validate() */function openid_user_add() {  $form['openid_identifier'] = array(    '#type' => 'textfield',    '#title' => t('OpenID'),  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Add an OpenID'));  return $form;}function openid_user_add_validate($form, &$form_state) {  // Check for existing entries.  $claimed_id = _openid_normalize($form_state['values']['openid_identifier']);  if (db_result(db_query("SELECT authname FROM {authmap} WHERE authname='%s'", $claimed_id))) {    form_set_error('openid_identifier', t('That OpenID is already in use on this site.'));  }}function openid_user_add_submit($form, &$form_state) {  $return_to = url('user/'. arg(1) .'/openid', array('absolute' => TRUE));  openid_begin($form_state['values']['openid_identifier'], $return_to);}/** * Present a confirmation form to delete the specified OpenID identity from the system. * * @ingroup forms * @see openid_user_delete_form_submit() */function openid_user_delete_form($form_state, $account, $aid = 0) {  $authname = db_result(db_query('SELECT authname FROM {authmap} WHERE uid = %d AND aid = %d', $account->uid, $aid));  $form = array();  $form['uid'] = array(    '#type' => 'value',    '#value' => $account->uid,  );  $form['aid'] = array(    '#type' => 'value',    '#value' => $aid,  );  return confirm_form($form, t('Are you sure you want to delete the OpenID %authname for %user?', array('%authname' => $authname, '%user' => $account->name)), 'user/'. $account->uid .'/openid');}function openid_user_delete_form_submit($form, &$form_state) {  db_query("DELETE FROM {authmap} WHERE uid = %d AND aid = %d AND module = 'openid'", $form_state['values']['uid'], $form_state['values']['aid']);  if (db_affected_rows()) {    drupal_set_message(t('OpenID deleted.'));  }  $form_state['redirect'] = 'user/'. $form_state['values']['uid'] .'/openid';}
<?php// $Id$/** * @file * OpenID utility functions. */// Diffie-Hellman Key Exchange Default Value.define('OPENID_DH_DEFAULT_MOD', '155172898181473697471232257763715539915724801'.       '966915404479707795314057629378541917580651227423698188993727816152646631'.       '438561595825688188889951272158842675419950341258706556549803580104870537'.       '681476726513255747040765857479291291572334510643245094715007229621094194'.       '349783925984760375594985848253359305585439638443');// Constants for Diffie-Hellman key exchange computations.define('OPENID_DH_DEFAULT_GEN', '2');define('OPENID_SHA1_BLOCKSIZE', 64);define('OPENID_RAND_SOURCE', '/dev/urandom');// OpenID namespace URLsdefine('OPENID_NS_2_0', 'http://specs.openid.net/auth/2.0');define('OPENID_NS_1_1', 'http://openid.net/signon/1.1');define('OPENID_NS_1_0', 'http://openid.net/signon/1.0');/** * Performs an HTTP 302 redirect (for the 1.x protocol). */function openid_redirect_http($url, $message) {  $query = array();  foreach ($message as $key => $val) {    $query[] = $key .'='. urlencode($val);  }  $sep = (strpos($url, '?') === FALSE) ? '?' : '&';  header('Location: '. $url . $sep . implode('&', $query), TRUE, 302);  exit;}/** * Creates a js auto-submit redirect for (for the 2.x protocol) */function openid_redirect($url, $message) {  $output = '<html><head><title>'. t('OpenID redirect') ."</title></head>\n<body>";  $output .= drupal_get_form('openid_redirect_form', $url, $message);  $output .= '<script type="text/javascript">document.getElementById("openid-redirect-form").submit();</script>';  $output .= "</body></html>\n";  print $output;  exit;}function openid_redirect_form(&$form_state, $url, $message) {  $form = array();  $form['#action'] = $url;  $form['#method'] = "post";  foreach ($message as $key => $value) {    $form[$key] = array(      '#type' => 'hidden',      '#name' => $key,      '#value' => $value,    );  }  $form['submit'] = array(    '#type' => 'submit',    '#prefix' => '<noscript>',    '#suffix' => '</noscript>',    '#value' => t('Send'),  );  return $form;}/** * Determine if the given identifier is an XRI ID. */function _openid_is_xri($identifier) {  // Strip the xri:// scheme from the identifier if present.  if (strpos(strtolower($identifier), 'xri://') !== FALSE) {    $identifier = substr($identifier, 6);  }  // Test whether the identifier starts with an XRI global context symbol or (.  $firstchar = substr($identifier, 0, 1);  if (strpos("=@+$!(", $firstchar) !== FALSE) {    return TRUE;  }  return FALSE;}/** * Normalize the given identifier as per spec. */function _openid_normalize($identifier) {  if (_openid_is_xri($identifier)) {    return _openid_normalize_xri($identifier);  }  else {    return _openid_normalize_url($identifier);  }}function _openid_normalize_xri($xri) {  $normalized_xri = $xri;  if (stristr($xri, 'xri://') !== FALSE) {    $normalized_xri = substr($xri, 6);  }  return $normalized_xri;}function _openid_normalize_url($url) {  $normalized_url = $url;  if (stristr($url, '://') === FALSE) {    $normalized_url = 'http://'. $url;  }  // Strip the fragment and fragment delimiter if present.  $normalized_url = strtok($normalized_url, '#');  if (substr_count($normalized_url, '/') < 3) {    $normalized_url .= '/';  }  return $normalized_url;}/** * Create a serialized message packet as per spec: $key:$value\n . */function _openid_create_message($data) {  $serialized = '';  foreach ($data as $key => $value) {    if ((strpos($key, ':') !== FALSE) || (strpos($key, "\n") !== FALSE) || (strpos($value, "\n") !== FALSE)) {      return null;    }    $serialized .= "$key:$value\n";  }  return $serialized;}/** * Encode a message from _openid_create_message for HTTP Post */function _openid_encode_message($message) {  $encoded_message = '';  $items = explode("\n", $message);  foreach ($items as $item) {    $parts = explode(':', $item, 2);    if (count($parts) == 2) {      if ($encoded_message != '') {        $encoded_message .= '&';      }      $encoded_message .= rawurlencode(trim($parts[0])) .'='. rawurlencode(trim($parts[1]));    }  }  return $encoded_message;}/** * Convert a direct communication message * into an associative array. */function _openid_parse_message($message) {  $parsed_message = array();  $items = explode("\n", $message);  foreach ($items as $item) {    $parts = explode(':', $item, 2);    if (count($parts) == 2) {      $parsed_message[$parts[0]] = $parts[1];    }  }  return $parsed_message;}/** * Return a nonce value - formatted per OpenID spec. */function _openid_nonce() {  // YYYY-MM-DDThh:mm:ssTZD UTC, plus some optional extra unique chars  return gmstrftime('%Y-%m-%dT%H:%M:%S%Z') .    chr(mt_rand(0, 25) + 65) .    chr(mt_rand(0, 25) + 65) .    chr(mt_rand(0, 25) + 65) .    chr(mt_rand(0, 25) + 65);}/** * Pull the href attribute out of an html link element. */function _openid_link_href($rel, $html) {  $rel = preg_quote($rel);  preg_match('|<link\s+rel=["\'](.*)'. $rel .'(.*)["\'](.*)/?>|iUs', $html, $matches);  if (isset($matches[3])) {    preg_match('|href=["\']([^"]+)["\']|iU', $matches[3], $href);    return trim($href[1]);  }  return FALSE;}/** * Pull the http-equiv attribute out of an html meta element */function _openid_meta_httpequiv($equiv, $html) {  preg_match('|<meta\s+http-equiv=["\']'. $equiv .'["\'](.*)/?>|iUs', $html, $matches);  if (isset($matches[1])) {    preg_match('|content=["\']([^"]+)["\']|iUs', $matches[1], $content);    if (isset($content[1])) {      return $content[1];    }  }  return FALSE;}/** * Sign certain keys in a message * @param $association - object loaded from openid_association or openid_server_association table *              - important fields are ->assoc_type and ->mac_key * @param $message_array - array of entire message about to be sent * @param $keys_to_sign - keys in the message to include in signature (without *  'openid.' appended) */function _openid_signature($association, $message_array, $keys_to_sign) {  $signature = '';  $sign_data = array();  foreach ($keys_to_sign as $key) {    if (isset($message_array['openid.'. $key])) {      $sign_data[$key] = $message_array['openid.'. $key];    }  }  $message = _openid_create_message($sign_data);  $secret = base64_decode($association->mac_key);  $signature = _openid_hmac($secret, $message);  return base64_encode($signature);}function _openid_hmac($key, $text) {  if (strlen($key) > OPENID_SHA1_BLOCKSIZE) {    $key = _openid_sha1($key, true);  }  $key = str_pad($key, OPENID_SHA1_BLOCKSIZE, chr(0x00));  $ipad = str_repeat(chr(0x36), OPENID_SHA1_BLOCKSIZE);  $opad = str_repeat(chr(0x5c), OPENID_SHA1_BLOCKSIZE);  $hash1 = _openid_sha1(($key ^ $ipad) . $text, true);  $hmac = _openid_sha1(($key ^ $opad) . $hash1, true);  return $hmac;}function _openid_sha1($text) {  $hex = sha1($text);  $raw = '';  for ($i = 0; $i < 40; $i += 2) {    $hexcode = substr($hex, $i, 2);    $charcode = (int)base_convert($hexcode, 16, 10);    $raw .= chr($charcode);  }  return $raw;}function _openid_dh_base64_to_long($str) {  $b64 = base64_decode($str);  return _openid_dh_binary_to_long($b64);}function _openid_dh_long_to_base64($str) {  return base64_encode(_openid_dh_long_to_binary($str));}function _openid_dh_binary_to_long($str) {  $bytes = array_merge(unpack('C*', $str));  $n = 0;  foreach ($bytes as $byte) {    $n = bcmul($n, pow(2, 8));    $n = bcadd($n, $byte);  }  return $n;}function _openid_dh_long_to_binary($long) {  $cmp = bccomp($long, 0);  if ($cmp < 0) {    return FALSE;  }  if ($cmp == 0) {    return "\x00";  }  $bytes = array();  while (bccomp($long, 0) > 0) {    array_unshift($bytes, bcmod($long, 256));    $long = bcdiv($long, pow(2, 8));  }  if ($bytes && ($bytes[0] > 127)) {    array_unshift($bytes, 0);  }  $string = '';  foreach ($bytes as $byte) {    $string .= pack('C', $byte);  }  return $string;}function _openid_dh_xorsecret($shared, $secret) {  $dh_shared_str = _openid_dh_long_to_binary($shared);  $sha1_dh_shared = _openid_sha1($dh_shared_str);  $xsecret = "";  for ($i = 0; $i < strlen($secret); $i++) {    $xsecret .= chr(ord($secret[$i]) ^ ord($sha1_dh_shared[$i]));  }  return $xsecret;}function _openid_dh_rand($stop) {  static $duplicate_cache = array();  // Used as the key for the duplicate cache  $rbytes = _openid_dh_long_to_binary($stop);  if (array_key_exists($rbytes, $duplicate_cache)) {    list($duplicate, $nbytes) = $duplicate_cache[$rbytes];  }  else {    if ($rbytes[0] == "\x00") {      $nbytes = strlen($rbytes) - 1;    }    else {      $nbytes = strlen($rbytes);    }    $mxrand = bcpow(256, $nbytes);    // If we get a number less than this, then it is in the    // duplicated range.    $duplicate = bcmod($mxrand, $stop);    if (count($duplicate_cache) > 10) {      $duplicate_cache = array();    }    $duplicate_cache[$rbytes] = array($duplicate, $nbytes);  }  do {    $bytes = "\x00". _openid_get_bytes($nbytes);    $n = _openid_dh_binary_to_long($bytes);    // Keep looping if this value is in the low duplicated range.  } while (bccomp($n, $duplicate) < 0);  return bcmod($n, $stop);}function _openid_get_bytes($num_bytes) {  static $f = null;  $bytes = '';  if (!isset($f)) {    $f = @fopen(OPENID_RAND_SOURCE, "r");  }  if (!$f) {    // pseudorandom used    $bytes = '';    for ($i = 0; $i < $num_bytes; $i += 4) {      $bytes .= pack('L', mt_rand());    }    $bytes = substr($bytes, 0, $num_bytes);  }  else {    $bytes = fread($f, $num_bytes);  }  return $bytes;}function _openid_response($str = NULL) {  $data = array();    if (isset($_SERVER['REQUEST_METHOD'])) {    $data = _openid_get_params($_SERVER['QUERY_STRING']);    if ($_SERVER['REQUEST_METHOD'] == 'POST') {      $str = file_get_contents('php://input');      $post = array();      if ($str !== false) {        $post = _openid_get_params($str);      }      $data = array_merge($data, $post);    }  }  return $data;}function _openid_get_params($str) {  $chunks = explode("&", $str);  $data = array();  foreach ($chunks as $chunk) {    $parts = explode("=", $chunk, 2);    if (count($parts) == 2) {      list($k, $v) = $parts;      $data[$k] = urldecode($v);    }  }  return $data;}/** * Provide bcpowmod support for PHP4. */if (!function_exists('bcpowmod')) {  function bcpowmod($base, $exp, $mod) {    $square = bcmod($base, $mod);    $result = 1;    while (bccomp($exp, 0) > 0) {      if (bcmod($exp, 2)) {        $result = bcmod(bcmul($result, $square), $mod);      }      $square = bcmod(bcmul($square, $square), $mod);      $exp = bcdiv($exp, 2);    }    return $result;  }}
<?php// $Id$/** * Implementation of hook_install(). */function dblog_install() {  // Create tables.  drupal_install_schema('dblog');}/** * Implementation of hook_uninstall(). */function dblog_uninstall() {  // Remove tables.  drupal_uninstall_schema('dblog');}/** * Implementation of hook_schema(). */function dblog_schema() {  $schema['watchdog'] = array(    'description' => 'Table that contains logs of all system events.',    'fields' => array(      'wid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique watchdog event ID.',      ),      'uid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {users}.uid of the user who triggered the event.',      ),      'type' => array(        'type' => 'varchar',        'length' => 16,        'not null' => TRUE,        'default' => '',        'description' => 'Type of log message, for example "user" or "page not found."',      ),      'message' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Text of log message to be passed into the t() function.',      ),      'variables' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Serialized array of variables that match the message string and that is passed into the t() function.',      ),      'severity' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The severity level of the event; ranges from 0 (Emergency) to 7 (Debug)',      ),      'link' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Link to view the result of the event.',      ),      'location'  => array(        'type' => 'text',        'not null' => TRUE,        'description' => 'URL of the origin of the event.',      ),      'referer' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'URL of referring page.',      ),      'hostname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Hostname of the user who triggered the event.',      ),      'timestamp' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Unix timestamp of when event occurred.',      ),    ),    'primary key' => array('wid'),    'indexes' => array('type' => array('type')),  );  return $schema;}/** * @defgroup updates-6.x-extra Extra database logging updates for 6.x * @{ *//** * Allow longer referrers. */function dblog_update_6000() {  $ret = array();  db_change_field($ret, 'watchdog', 'referer', 'referer', array('type' => 'text', 'not null' => FALSE));  return $ret;}/** * @} End of "defgroup updates-6.x-extra" * The next series of updates should start at 7000. */
<?php// $Id$/** * Implementation of hook_schema(). */function taxonomy_schema() {  $schema['term_data'] = array(    'description' => 'Stores term information.',    'fields' => array(      'tid' => array(        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'Primary Key: Unique term ID.',      ),      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {vocabulary}.vid of the vocabulary to which the term is assigned.',      ),      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'The term name.',      ),      'description' => array(        'type' => 'text',        'not null' => FALSE,        'size' => 'big',        'description' => 'A description of the term.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The weight of this term in relation to other terms.',      ),    ),    'primary key' => array('tid'),    'indexes' => array(      'taxonomy_tree' => array('vid', 'weight', 'name'),      'vid_name' => array('vid', 'name'),    ),  );  $schema['term_hierarchy'] = array(    'description' => 'Stores the hierarchical relationship between terms.',    'fields' => array(      'tid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {term_data}.tid of the term.',      ),      'parent' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "Primary Key: The {term_data}.tid of the term's parent. 0 indicates no parent.",      ),    ),    'indexes' => array(      'parent' => array('parent'),    ),    'primary key' => array('tid', 'parent'),  );  $schema['term_node'] = array(    'description' => 'Stores the relationship of terms to nodes.',    'fields' => array(      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {node}.nid of the node.',      ),      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {node}.vid of the node.',      ),      'tid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {term_data}.tid of a term assigned to the node.',      ),    ),    'indexes' => array(      'vid' => array('vid'),      'nid' => array('nid'),    ),    'primary key' => array('tid', 'vid'),  );  $schema['term_relation'] = array(    'description' => 'Stores non-hierarchical relationships between terms.',    'fields' => array(      'trid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique term relation ID.',      ),      'tid1' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {term_data}.tid of the first term in a relationship.',      ),      'tid2' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {term_data}.tid of the second term in a relationship.',      ),    ),    'unique keys' => array(      'tid1_tid2' => array('tid1', 'tid2'),    ),    'indexes' => array(      'tid2' => array('tid2'),    ),    'primary key' => array('trid'),  );  $schema['term_synonym'] = array(    'description' => 'Stores term synonyms.',    'fields' => array(      'tsid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique term synonym ID.',      ),      'tid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {term_data}.tid of the term.',      ),      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'The name of the synonym.',      ),    ),    'indexes' => array(      'tid' => array('tid'),      'name_tid' => array('name', 'tid'),    ),    'primary key' => array('tsid'),  );  $schema['vocabulary'] = array(    'description' => 'Stores vocabulary information.',    'fields' => array(      'vid' => array(        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'Primary Key: Unique vocabulary ID.',      ),      'name' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Name of the vocabulary.',      ),      'description' => array(        'type' => 'text',        'not null' => FALSE,        'size' => 'big',        'description' => 'Description of the vocabulary.',      ),      'help' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Help text to display for the vocabulary.',      ),      'relations' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether or not related terms are enabled within the vocabulary. (0 = disabled, 1 = enabled)',      ),      'hierarchy' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The type of hierarchy allowed within the vocabulary. (0 = disabled, 1 = single, 2 = multiple)',      ),      'multiple' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether or not multiple terms from this vocabulary may be assigned to a node. (0 = disabled, 1 = enabled)',      ),      'required' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether or not terms are required for nodes using this vocabulary. (0 = disabled, 1 = enabled)',      ),      'tags' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether or not free tagging is enabled for the vocabulary. (0 = disabled, 1 = enabled)',      ),      'module' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'The module which created the vocabulary.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The weight of the vocabulary in relation to other vocabularies.',      ),    ),    'primary key' => array('vid'),    'indexes' => array(      'list' => array('weight', 'name'),    ),  );  $schema['vocabulary_node_types'] = array(    'description' => 'Stores which node types vocabularies may be used with.',    'fields' => array(      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: the {vocabulary}.vid of the vocabulary.',      ),      'type' => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '',        'description' => 'The {node}.type of the node type for which the vocabulary may be used.',      ),    ),    'primary key' => array('type', 'vid'),    'indexes' => array(      'vid' => array('vid'),    ),  );  return $schema;}
<?php// $Id$/** * @file * Common functions that many Drupal modules will need to reference. * * The functions that are critical and need to be available even when serving * a cached page are instead located in bootstrap.inc. *//** * Return status for saving which involved creating a new item. */define('SAVED_NEW', 1);/** * Return status for saving which involved an update to an existing item. */define('SAVED_UPDATED', 2);/** * Return status for saving which deleted an existing item. */define('SAVED_DELETED', 3);/** * Create E_DEPRECATED constant for older PHP versions (<5.3). */if (!defined('E_DEPRECATED')) {  define('E_DEPRECATED', 8192);}/** * Set content for a specified region. * * @param $region *   Page region the content is assigned to. * @param $data *   Content to be set. */function drupal_set_content($region = NULL, $data = NULL) {  static $content = array();  if (!is_null($region) && !is_null($data)) {    $content[$region][] = $data;  }  return $content;}/** * Get assigned content. * * @param $region *   A specified region to fetch content for. If NULL, all regions will be *   returned. * @param $delimiter *   Content to be inserted between imploded array elements. */function drupal_get_content($region = NULL, $delimiter = ' ') {  $content = drupal_set_content();  if (isset($region)) {    if (isset($content[$region]) && is_array($content[$region])) {      return implode($delimiter, $content[$region]);    }  }  else {    foreach (array_keys($content) as $region) {      if (is_array($content[$region])) {        $content[$region] = implode($delimiter, $content[$region]);      }    }    return $content;  }}/** * Set the breadcrumb trail for the current page. * * @param $breadcrumb *   Array of links, starting with "home" and proceeding up to but not including *   the current page. */function drupal_set_breadcrumb($breadcrumb = NULL) {  static $stored_breadcrumb;  if (!is_null($breadcrumb)) {    $stored_breadcrumb = $breadcrumb;  }  return $stored_breadcrumb;}/** * Get the breadcrumb trail for the current page. */function drupal_get_breadcrumb() {  $breadcrumb = drupal_set_breadcrumb();  if (is_null($breadcrumb)) {    $breadcrumb = menu_get_active_breadcrumb();  }  return $breadcrumb;}/** * Add output to the head tag of the HTML page. * * This function can be called as long the headers aren't sent. */function drupal_set_html_head($data = NULL) {  static $stored_head = '';  if (!is_null($data)) {    $stored_head .= $data ."\n";  }  return $stored_head;}/** * Retrieve output to be displayed in the head tag of the HTML page. */function drupal_get_html_head() {  $output = "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n";  return $output . drupal_set_html_head();}/** * Reset the static variable which holds the aliases mapped for this request. */function drupal_clear_path_cache() {  drupal_lookup_path('wipe');}/** * Set an HTTP response header for the current page. * * Note: When sending a Content-Type header, always include a 'charset' type, * too. This is necessary to avoid security bugs (e.g. UTF-7 XSS). */function drupal_set_header($header = NULL) {  // We use an array to guarantee there are no leading or trailing delimiters.  // Otherwise, header('') could get called when serving the page later, which  // ends HTTP headers prematurely on some PHP versions.  static $stored_headers = array();  if (strlen($header)) {    header($header);    $stored_headers[] = $header;  }  return implode("\n", $stored_headers);}/** * Get the HTTP response headers for the current page. */function drupal_get_headers() {  return drupal_set_header();}/** * Make any final alterations to the rendered xhtml. */function drupal_final_markup($content) {  // Make sure that the charset is always specified as the first element of the  // head region to prevent encoding-based attacks.  return preg_replace('/<head[^>]*>/i', "\$0\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />", $content, 1);}/** * Add a feed URL for the current page. * * @param $url *   A url for the feed. * @param $title *   The title of the feed. */function drupal_add_feed($url = NULL, $title = '') {  static $stored_feed_links = array();  if (!is_null($url) && !isset($stored_feed_links[$url])) {    $stored_feed_links[$url] = theme('feed_icon', $url, $title);    drupal_add_link(array('rel' => 'alternate',                          'type' => 'application/rss+xml',                          'title' => $title,                          'href' => $url));  }  return $stored_feed_links;}/** * Get the feed URLs for the current page. * * @param $delimiter *   A delimiter to split feeds by. */function drupal_get_feeds($delimiter = "\n") {  $feeds = drupal_add_feed();  return implode($feeds, $delimiter);}/** * @name HTTP handling * @{ * Functions to properly handle HTTP responses. *//** * Parse an array into a valid urlencoded query string. * * @param $query *   The array to be processed e.g. $_GET. * @param $exclude *   The array filled with keys to be excluded. Use parent[child] to exclude *   nested items. * @param $parent *   Should not be passed, only used in recursive calls. * @return *   An urlencoded string which can be appended to/as the URL query string. */function drupal_query_string_encode($query, $exclude = array(), $parent = '') {  $params = array();  foreach ($query as $key => $value) {    $key = rawurlencode($key);    if ($parent) {      $key = $parent .'['. $key .']';    }    if (in_array($key, $exclude)) {      continue;    }    if (is_array($value)) {      $params[] = drupal_query_string_encode($value, $exclude, $key);    }    else {      $params[] = $key .'='. rawurlencode($value);    }  }  return implode('&', $params);}/** * Prepare a destination query string for use in combination with drupal_goto(). * * Used to direct the user back to the referring page after completing a form. * By default the current URL is returned. If a destination exists in the * previous request, that destination is returned. As such, a destination can * persist across multiple pages. * * @see drupal_goto() */function drupal_get_destination() {  if (isset($_REQUEST['destination'])) {    return 'destination='. urlencode($_REQUEST['destination']);  }  else {    // Use $_GET here to retrieve the original path in source form.    $path = isset($_GET['q']) ? $_GET['q'] : '';    $query = drupal_query_string_encode($_GET, array('q'));    if ($query != '') {      $path .= '?'. $query;    }    return 'destination='. urlencode($path);  }}/** * Send the user to a different Drupal page. * * This issues an on-site HTTP redirect. The function makes sure the redirected * URL is formatted correctly. * * Usually the redirected URL is constructed from this function's input * parameters. However you may override that behavior by setting a * destination in either the $_REQUEST-array (i.e. by using * the query string of an URI) or the $_REQUEST['edit']-array (i.e. by * using a hidden form field). This is used to direct the user back to * the proper page after completing a form. For example, after editing * a post on the 'admin/content/node'-page or after having logged on using the * 'user login'-block in a sidebar. The function drupal_get_destination() * can be used to help set the destination URL. * * Drupal will ensure that messages set by drupal_set_message() and other * session data are written to the database before the user is redirected. * * This function ends the request; use it rather than a print theme('page') * statement in your menu callback. * * @param $path *   A Drupal path or a full URL. * @param $query *   A query string component, if any. * @param $fragment *   A destination fragment identifier (named anchor). * @param $http_response_code *   Valid values for an actual "goto" as per RFC 2616 section 10.3 are: *   - 301 Moved Permanently (the recommended value for most redirects) *   - 302 Found (default in Drupal and PHP, sometimes used for spamming search *         engines) *   - 303 See Other *   - 304 Not Modified *   - 305 Use Proxy *   - 307 Temporary Redirect (alternative to "503 Site Down for Maintenance") *   Note: Other values are defined by RFC 2616, but are rarely used and poorly *   supported. * @see drupal_get_destination() */function drupal_goto($path = '', $query = NULL, $fragment = NULL, $http_response_code = 302) {  $destination = FALSE;  if (isset($_REQUEST['destination'])) {    $destination = $_REQUEST['destination'];  }  else if (isset($_REQUEST['edit']['destination'])) {    $destination = $_REQUEST['edit']['destination'];  }  if ($destination) {    // Do not redirect to an absolute URL originating from user input.    $colonpos = strpos($destination, ':');    $absolute = ($colonpos !== FALSE && !preg_match('![/?#]!', substr($destination, 0, $colonpos)));    if (!$absolute) {      extract(parse_url(urldecode($destination)));    }  }  $url = url($path, array('query' => $query, 'fragment' => $fragment, 'absolute' => TRUE));  // Remove newlines from the URL to avoid header injection attacks.  $url = str_replace(array("\n", "\r"), '', $url);  // Allow modules to react to the end of the page request before redirecting.  // We do not want this while running update.php.  if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {    module_invoke_all('exit', $url);  }  // Even though session_write_close() is registered as a shutdown function, we  // need all session data written to the database before redirecting.  session_write_close();  header('Location: '. $url, TRUE, $http_response_code);  // The "Location" header sends a redirect status code to the HTTP daemon. In  // some cases this can be wrong, so we make sure none of the code below the  // drupal_goto() call gets executed upon redirection.  exit();}/** * Generates a site off-line message. */function drupal_site_offline() {  drupal_maintenance_theme();  drupal_set_header('HTTP/1.1 503 Service unavailable');  drupal_set_title(t('Site off-line'));  print theme('maintenance_page', filter_xss_admin(variable_get('site_offline_message',    t('@site is currently under maintenance. We should be back shortly. Thank you for your patience.', array('@site' => variable_get('site_name', 'Drupal'))))));}/** * Generates a 404 error if the request can not be handled. */function drupal_not_found() {  drupal_set_header('HTTP/1.1 404 Not Found');  watchdog('page not found', check_plain($_GET['q']), NULL, WATCHDOG_WARNING);  // Keep old path for reference, and to allow forms to redirect to it.  if (!isset($_REQUEST['destination'])) {    $_REQUEST['destination'] = $_GET['q'];  }  $path = drupal_get_normal_path(variable_get('site_404', ''));  if ($path && $path != $_GET['q']) {    // Set the active item in case there are tabs to display, or other    // dependencies on the path.    menu_set_active_item($path);    $return = menu_execute_active_handler($path);  }  if (empty($return) || $return == MENU_NOT_FOUND || $return == MENU_ACCESS_DENIED) {    drupal_set_title(t('Page not found'));    $return = t('The requested page could not be found.');  }  // To conserve CPU and bandwidth, omit the blocks.  print theme('page', $return, FALSE);}/** * Generates a 403 error if the request is not allowed. */function drupal_access_denied() {  drupal_set_header('HTTP/1.1 403 Forbidden');  watchdog('access denied', check_plain($_GET['q']), NULL, WATCHDOG_WARNING);  // Keep old path for reference, and to allow forms to redirect to it.  if (!isset($_REQUEST['destination'])) {    $_REQUEST['destination'] = $_GET['q'];  }  $path = drupal_get_normal_path(variable_get('site_403', ''));  if ($path && $path != $_GET['q']) {    // Set the active item in case there are tabs to display or other    // dependencies on the path.    menu_set_active_item($path);    $return = menu_execute_active_handler($path);  }  if (empty($return) || $return == MENU_NOT_FOUND || $return == MENU_ACCESS_DENIED) {    drupal_set_title(t('Access denied'));    $return = t('You are not authorized to access this page.');  }  print theme('page', $return);}/** * Perform an HTTP request. * * This is a flexible and powerful HTTP client implementation. Correctly handles * GET, POST, PUT or any other HTTP requests. Handles redirects. * * @param $url *   A string containing a fully qualified URI. * @param $headers *   An array containing an HTTP header => value pair. * @param $method *   A string defining the HTTP request to use. * @param $data *   A string containing data to include in the request. * @param $retry *   An integer representing how many times to retry the request in case of a *   redirect. * @return *   An object containing the HTTP request headers, response code, headers, *   data and redirect status. */function drupal_http_request($url, $headers = array(), $method = 'GET', $data = NULL, $retry = 3) {  global $db_prefix;  $result = new stdClass();  // Parse the URL and make sure we can handle the schema.  $uri = parse_url($url);  if ($uri == FALSE) {    $result->error = 'unable to parse URL';    $result->code = -1001;    return $result;  }  if (!isset($uri['scheme'])) {    $result->error = 'missing schema';    $result->code = -1002;    return $result;  }  switch ($uri['scheme']) {    case 'http':      $port = isset($uri['port']) ? $uri['port'] : 80;      $host = $uri['host'] . ($port != 80 ? ':'. $port : '');      $fp = @fsockopen($uri['host'], $port, $errno, $errstr, 15);      break;    case 'https':      // Note: Only works for PHP 4.3 compiled with OpenSSL.      $port = isset($uri['port']) ? $uri['port'] : 443;      $host = $uri['host'] . ($port != 443 ? ':'. $port : '');      $fp = @fsockopen('ssl://'. $uri['host'], $port, $errno, $errstr, 20);      break;    default:      $result->error = 'invalid schema '. $uri['scheme'];      $result->code = -1003;      return $result;  }  // Make sure the socket opened properly.  if (!$fp) {    // When a network error occurs, we use a negative number so it does not    // clash with the HTTP status codes.    $result->code = -$errno;    $result->error = trim($errstr);    // Mark that this request failed. This will trigger a check of the web    // server's ability to make outgoing HTTP requests the next time that    // requirements checking is performed.    // @see system_requirements()    variable_set('drupal_http_request_fails', TRUE);    return $result;  }  // Construct the path to act on.  $path = isset($uri['path']) ? $uri['path'] : '/';  if (isset($uri['query'])) {    $path .= '?'. $uri['query'];  }  // Create HTTP request.  $defaults = array(    // RFC 2616: "non-standard ports MUST, default ports MAY be included".    // We don't add the port to prevent from breaking rewrite rules checking the    // host that do not take into account the port number.    'Host' => "Host: $host",    'User-Agent' => 'User-Agent: Drupal (+http://drupal.org/)',  );  // Only add Content-Length if we actually have any content or if it is a POST  // or PUT request. Some non-standard servers get confused by Content-Length in  // at least HEAD/GET requests, and Squid always requires Content-Length in  // POST/PUT requests.  $content_length = strlen($data);  if ($content_length > 0 || $method == 'POST' || $method == 'PUT') {    $defaults['Content-Length'] = 'Content-Length: '. $content_length;  }  // If the server url has a user then attempt to use basic authentication  if (isset($uri['user'])) {    $defaults['Authorization'] = 'Authorization: Basic '. base64_encode($uri['user'] . (!empty($uri['pass']) ? ":". $uri['pass'] : ''));  }  // If the database prefix is being used by SimpleTest to run the tests in a copied  // database then set the user-agent header to the database prefix so that any  // calls to other Drupal pages will run the SimpleTest prefixed database. The  // user-agent is used to ensure that multiple testing sessions running at the  // same time won't interfere with each other as they would if the database  // prefix were stored statically in a file or database variable.  if (is_string($db_prefix) && preg_match("/^simpletest\d+$/", $db_prefix, $matches)) {    $defaults['User-Agent'] = 'User-Agent: ' . $matches[0];  }  foreach ($headers as $header => $value) {    $defaults[$header] = $header .': '. $value;  }  $request = $method .' '. $path ." HTTP/1.0\r\n";  $request .= implode("\r\n", $defaults);  $request .= "\r\n\r\n";  $request .= $data;  $result->request = $request;  fwrite($fp, $request);  // Fetch response.  $response = '';  while (!feof($fp) && $chunk = fread($fp, 1024)) {    $response .= $chunk;  }  fclose($fp);  // Parse response.  list($split, $result->data) = explode("\r\n\r\n", $response, 2);  $split = preg_split("/\r\n|\n|\r/", $split);  list($protocol, $code, $text) = explode(' ', trim(array_shift($split)), 3);  $result->headers = array();  // Parse headers.  while ($line = trim(array_shift($split))) {    list($header, $value) = explode(':', $line, 2);    if (isset($result->headers[$header]) && $header == 'Set-Cookie') {      // RFC 2109: the Set-Cookie response header comprises the token Set-      // Cookie:, followed by a comma-separated list of one or more cookies.      $result->headers[$header] .= ','. trim($value);    }    else {      $result->headers[$header] = trim($value);    }  }  $responses = array(    100 => 'Continue', 101 => 'Switching Protocols',    200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content',    300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 307 => 'Temporary Redirect',    400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Time-out', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Large', 415 => 'Unsupported Media Type', 416 => 'Requested range not satisfiable', 417 => 'Expectation Failed',    500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Time-out', 505 => 'HTTP Version not supported'  );  // RFC 2616 states that all unknown HTTP codes must be treated the same as the  // base code in their class.  if (!isset($responses[$code])) {    $code = floor($code / 100) * 100;  }  switch ($code) {    case 200: // OK    case 304: // Not modified      break;    case 301: // Moved permanently    case 302: // Moved temporarily    case 307: // Moved temporarily      $location = $result->headers['Location'];      if ($retry) {        $result = drupal_http_request($result->headers['Location'], $headers, $method, $data, --$retry);        $result->redirect_code = $result->code;      }      $result->redirect_url = $location;      break;    default:      $result->error = $text;  }  $result->code = $code;  return $result;}/** * @} End of "HTTP handling". *//** * Log errors as defined by administrator. * * Error levels: * - 0 = Log errors to database. * - 1 = Log errors to database and to screen. */function drupal_error_handler($errno, $message, $filename, $line, $context) {  // If the @ error suppression operator was used, error_reporting will have  // been temporarily set to 0.  if (error_reporting() == 0) {    return;  }  if ($errno & (E_ALL ^ E_DEPRECATED ^ E_NOTICE)) {    $types = array(1 => 'error', 2 => 'warning', 4 => 'parse error', 8 => 'notice', 16 => 'core error', 32 => 'core warning', 64 => 'compile error', 128 => 'compile warning', 256 => 'user error', 512 => 'user warning', 1024 => 'user notice', 2048 => 'strict warning', 4096 => 'recoverable fatal error');    // For database errors, we want the line number/file name of the place that    // the query was originally called, not _db_query().    if (isset($context[DB_ERROR])) {      $backtrace = array_reverse(debug_backtrace());      // List of functions where SQL queries can originate.      $query_functions = array('db_query', 'pager_query', 'db_query_range', 'db_query_temporary', 'update_sql');      // Determine where query function was called, and adjust line/file      // accordingly.      foreach ($backtrace as $index => $function) {        if (in_array($function['function'], $query_functions)) {          $line = $backtrace[$index]['line'];          $filename = $backtrace[$index]['file'];          break;        }      }    }    $entry = $types[$errno] .': '. $message .' in '. $filename .' on line '. $line .'.';    // Force display of error messages in update.php.    if (variable_get('error_level', 1) == 1 || strstr($_SERVER['SCRIPT_NAME'], 'update.php')) {      drupal_set_message($entry, 'error');    }    watchdog('php', '%message in %file on line %line.', array('%error' => $types[$errno], '%message' => $message, '%file' => $filename, '%line' => $line), WATCHDOG_ERROR);  }}function _fix_gpc_magic(&$item) {  if (is_array($item)) {    array_walk($item, '_fix_gpc_magic');  }  else {    $item = stripslashes($item);  }}/** * Helper function to strip slashes from $_FILES skipping over the tmp_name keys * since PHP generates single backslashes for file paths on Windows systems. * * tmp_name does not have backslashes added see * http://php.net/manual/en/features.file-upload.php#42280 */function _fix_gpc_magic_files(&$item, $key) {  if ($key != 'tmp_name') {    if (is_array($item)) {      array_walk($item, '_fix_gpc_magic_files');    }    else {      $item = stripslashes($item);    }  }}/** * Fix double-escaping problems caused by "magic quotes" in some PHP installations. */function fix_gpc_magic() {  static $fixed = FALSE;  if (!$fixed && ini_get('magic_quotes_gpc')) {    array_walk($_GET, '_fix_gpc_magic');    array_walk($_POST, '_fix_gpc_magic');    array_walk($_COOKIE, '_fix_gpc_magic');    array_walk($_REQUEST, '_fix_gpc_magic');    array_walk($_FILES, '_fix_gpc_magic_files');    $fixed = TRUE;  }}/** * Translate strings to the page language or a given language. * * Human-readable text that will be displayed somewhere within a page should * be run through the t() function. * * Examples: * @code *   if (!$info || !$info['extension']) { *     form_set_error('picture_upload', t('The uploaded file was not an image.')); *   } * *   $form['submit'] = array( *     '#type' => 'submit', *     '#value' => t('Log in'), *   ); * @endcode * * Any text within t() can be extracted by translators and changed into * the equivalent text in their native language. * * Special variables called "placeholders" are used to signal dynamic * information in a string which should not be translated. Placeholders * can also be used for text that may change from time to time (such as * link paths) to be changed without requiring updates to translations. * * For example: * @code *   $output = t('There are currently %members and %visitors online.', array( *     '%members' => format_plural($total_users, '1 user', '@count users'), *     '%visitors' => format_plural($guests->count, '1 guest', '@count guests'))); * @endcode * * There are three styles of placeholders: * - !variable, which indicates that the text should be inserted as-is. This is *   useful for inserting variables into things like e-mail. *   @code *     $message[] = t("If you don't want to receive such e-mails, you can change your settings at !url.", array('!url' => url("user/$account->uid", array('absolute' => TRUE)))); *   @endcode * * - @variable, which indicates that the text should be run through *   check_plain, to escape HTML characters. Use this for any output that's *   displayed within a Drupal page. *   @code *     drupal_set_title($title = t("@name's blog", array('@name' => $account->name))); *   @endcode * * - %variable, which indicates that the string should be HTML escaped and *   highlighted with theme_placeholder() which shows up by default as *   <em>emphasized</em>. *   @code *     $message = t('%name-from sent %name-to an e-mail.', array('%name-from' => $user->name, '%name-to' => $account->name)); *   @endcode * * When using t(), try to put entire sentences and strings in one t() call. * This makes it easier for translators, as it provides context as to what * each word refers to. HTML markup within translation strings is allowed, but * should be avoided if possible. The exception are embedded links; link * titles add a context for translators, so should be kept in the main string. * * Here is an example of incorrect usage of t(): * @code *   $output .= t('<p>Go to the @contact-page.</p>', array('@contact-page' => l(t('contact page'), 'contact'))); * @endcode * * Here is an example of t() used correctly: * @code *   $output .= '<p>'. t('Go to the <a href="@contact-page">contact page</a>.', array('@contact-page' => url('contact'))) .'</p>'; * @endcode * * Avoid escaping quotation marks wherever possible. * * Incorrect: * @code *   $output .= t('Don\'t click me.'); * @endcode * * Correct: * @code *   $output .= t("Don't click me."); * @endcode * * Because t() is designed for handling code-based strings, in almost all * cases, the actual string and not a variable must be passed through t(). * * Extraction of translations is done based on the strings contained in t() * calls. If a variable is passed through t(), the content of the variable * cannot be extracted from the file for translation. * * Incorrect: * @code *   $message = 'An error occurred.'; *   drupal_set_message(t($message), 'error'); *   $output .= t($message); * @endcode * * Correct: * @code *   $message = t('An error occurred.'); *   drupal_set_message($message, 'error'); *   $output .= $message; * @endcode * * The only case in which variables can be passed safely through t() is when * code-based versions of the same strings will be passed through t() (or * otherwise extracted) elsewhere. * * In some cases, modules may include strings in code that can't use t() * calls. For example, a module may use an external PHP application that * produces strings that are loaded into variables in Drupal for output. * In these cases, module authors may include a dummy file that passes the * relevant strings through t(). This approach will allow the strings to be * extracted. * * Sample external (non-Drupal) code: * @code *   class Time { *     public $yesterday = 'Yesterday'; *     public $today = 'Today'; *     public $tomorrow = 'Tomorrow'; *   } * @endcode * * Sample dummy file. * @code *   // Dummy function included in example.potx.inc. *   function example_potx() { *     $strings = array( *       t('Yesterday'), *       t('Today'), *       t('Tomorrow'), *     ); *     // No return value needed, since this is a dummy function. *   } * @endcode * * Having passed strings through t() in a dummy function, it is then * okay to pass variables through t(). * * Correct (if a dummy file was used): * @code *   $time = new Time(); *   $output .= t($time->today); * @endcode * * However tempting it is, custom data from user input or other non-code * sources should not be passed through t(). Doing so leads to the following * problems and errors: *  - The t() system doesn't support updates to existing strings. When user *    data is updated, the next time it's passed through t() a new record is *    created instead of an update. The database bloats over time and any *    existing translations are orphaned with each update. *  - The t() system assumes any data it receives is in English. User data may *    be in another language, producing translation errors. *  - The "Built-in interface" text group in the locale system is used to *    produce translations for storage in .po files. When non-code strings are *    passed through t(), they are added to this text group, which is rendered *    inaccurate since it is a mix of actual interface strings and various user *    input strings of uncertain origin. * * Incorrect: * @code *   $item = item_load(); *   $output .= check_plain(t($item['title'])); * @endcode * * Instead, translation of these data can be done through the locale system, * either directly or through helper functions provided by contributed * modules. * @see hook_locale() * * During installation, st() is used in place of t(). Code that may be called * during installation or during normal operation should use the get_t() * helper function. * @see st() * @see get_t() * * @param $string *   A string containing the English string to translate. * @param $args *   An associative array of replacements to make after translation. Incidences *   of any key in this array are replaced with the corresponding value. Based *   on the first character of the key, the value is escaped and/or themed: *    - !variable: inserted as is *    - @variable: escape plain text to HTML (check_plain) *    - %variable: escape text and theme as a placeholder for user-submitted *      content (check_plain + theme_placeholder) * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   The translated string. */function t($string, $args = array(), $langcode = NULL) {  global $language;  static $custom_strings;  $langcode = isset($langcode) ? $langcode : $language->language;  // First, check for an array of customized strings. If present, use the array  // *instead of* database lookups. This is a high performance way to provide a  // handful of string replacements. See settings.php for examples.  // Cache the $custom_strings variable to improve performance.  if (!isset($custom_strings[$langcode])) {    $custom_strings[$langcode] = variable_get('locale_custom_strings_'. $langcode, array());  }  // Custom strings work for English too, even if locale module is disabled.  if (isset($custom_strings[$langcode][$string])) {    $string = $custom_strings[$langcode][$string];  }  // Translate with locale module if enabled.  elseif (function_exists('locale') && $langcode != 'en') {    $string = locale($string, $langcode);  }  if (empty($args)) {    return $string;  }  else {    // Transform arguments before inserting them.    foreach ($args as $key => $value) {      switch ($key[0]) {        case '@':          // Escaped only.          $args[$key] = check_plain($value);          break;        case '%':        default:          // Escaped and placeholder.          $args[$key] = theme('placeholder', $value);          break;        case '!':          // Pass-through.      }    }    return strtr($string, $args);  }}/** * @defgroup validation Input validation * @{ * Functions to validate user input. *//** * Verify the syntax of the given e-mail address. * * Empty e-mail addresses are allowed. See RFC 2822 for details. * * @param $mail *   A string containing an e-mail address. * @return *   TRUE if the address is in a valid format. */function valid_email_address($mail) {  $user = '[a-zA-Z0-9_\-\.\+\^!#\$%&*+\/\=\?\`\|\{\}~\']+';  $domain = '(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.?)+';  $ipv4 = '[0-9]{1,3}(\.[0-9]{1,3}){3}';  $ipv6 = '[0-9a-fA-F]{1,4}(\:[0-9a-fA-F]{1,4}){7}';  return preg_match("/^$user@($domain|(\[($ipv4|$ipv6)\]))$/", $mail);}/** * Verify the syntax of the given URL. * * This function should only be used on actual URLs. It should not be used for * Drupal menu paths, which can contain arbitrary characters. * Valid values per RFC 3986. * * @param $url *   The URL to verify. * @param $absolute *   Whether the URL is absolute (beginning with a scheme such as "http:"). * @return *   TRUE if the URL is in a valid format. */function valid_url($url, $absolute = FALSE) {  if ($absolute) {    return (bool)preg_match("      /^                                                      # Start at the beginning of the text      (?:ftp|https?):\/\/                                     # Look for ftp, http, or https schemes      (?:                                                     # Userinfo (optional) which is typically        (?:(?:[\w\.\-\+!$&'\(\)*\+,;=]|%[0-9a-f]{2})+:)*      # a username or a username and password        (?:[\w\.\-\+%!$&'\(\)*\+,;=]|%[0-9a-f]{2})+@          # combination      )?      (?:        (?:[a-z0-9\-\.]|%[0-9a-f]{2})+                        # A domain name or a IPv4 address        |(?:\[(?:[0-9a-f]{0,4}:)*(?:[0-9a-f]{0,4})\])         # or a well formed IPv6 address      )      (?::[0-9]+)?                                            # Server port number (optional)      (?:[\/|\?]        (?:[\w#!:\.\?\+=&@$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})   # The path and query (optional)      *)?    $/xi", $url);  }  else {    return (bool)preg_match("/^(?:[\w#!:\.\?\+=&@$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})+$/i", $url);  }}/** * @} End of "defgroup validation". *//** * Register an event for the current visitor (hostname/IP) to the flood control mechanism. * * @param $name *   The name of an event. */function flood_register_event($name) {  db_query("INSERT INTO {flood} (event, hostname, timestamp) VALUES ('%s', '%s', %d)", $name, ip_address(), time());}/** * Check if the current visitor (hostname/IP) is allowed to proceed with the specified event. * * The user is allowed to proceed if he did not trigger the specified event more * than $threshold times per hour. * * @param $name *   The name of the event. * @param $threshold *   The maximum number of the specified event per hour (per visitor). * @return *   True if the user did not exceed the hourly threshold. False otherwise. */function flood_is_allowed($name, $threshold) {  $number = db_result(db_query("SELECT COUNT(*) FROM {flood} WHERE event = '%s' AND hostname = '%s' AND timestamp > %d", $name, ip_address(), time() - 3600));  return ($number < $threshold ? TRUE : FALSE);}function check_file($filename) {  return is_uploaded_file($filename);}/** * Prepare a URL for use in an HTML attribute. Strips harmful protocols. */function check_url($uri) {  return filter_xss_bad_protocol($uri, FALSE);}/** * @defgroup format Formatting * @{ * Functions to format numbers, strings, dates, etc. *//** * Formats an RSS channel. * * Arbitrary elements may be added using the $args associative array. */function format_rss_channel($title, $link, $description, $items, $langcode = NULL, $args = array()) {  global $language;  $langcode = $langcode ? $langcode : $language->language;  $output = "<channel>\n";  $output .= ' <title>'. check_plain($title) ."</title>\n";  $output .= ' <link>'. check_url($link) ."</link>\n";  // The RSS 2.0 "spec" doesn't indicate HTML can be used in the description.  // We strip all HTML tags, but need to prevent double encoding from properly  // escaped source data (such as &amp becoming &amp;amp;).  $output .= ' <description>'. check_plain(decode_entities(strip_tags($description))) ."</description>\n";  $output .= ' <language>'. check_plain($langcode) ."</language>\n";  $output .= format_xml_elements($args);  $output .= $items;  $output .= "</channel>\n";  return $output;}/** * Format a single RSS item. * * Arbitrary elements may be added using the $args associative array. */function format_rss_item($title, $link, $description, $args = array()) {  $output = "<item>\n";  $output .= ' <title>'. check_plain($title) ."</title>\n";  $output .= ' <link>'. check_url($link) ."</link>\n";  $output .= ' <description>'. check_plain($description) ."</description>\n";  $output .= format_xml_elements($args);  $output .= "</item>\n";  return $output;}/** * Format XML elements. * * @param $array *   An array where each item represent an element and is either a: *   - (key => value) pair (<key>value</key>) *   - Associative array with fields: *     - 'key': element name *     - 'value': element contents *     - 'attributes': associative array of element attributes * * In both cases, 'value' can be a simple string, or it can be another array * with the same format as $array itself for nesting. */function format_xml_elements($array) {  $output = '';  foreach ($array as $key => $value) {    if (is_numeric($key)) {      if ($value['key']) {        $output .= ' <'. $value['key'];        if (isset($value['attributes']) && is_array($value['attributes'])) {          $output .= drupal_attributes($value['attributes']);        }        if (isset($value['value']) && $value['value'] != '') {          $output .= '>'. (is_array($value['value']) ? format_xml_elements($value['value']) : check_plain($value['value'])) .'</'. $value['key'] .">\n";        }        else {          $output .= " />\n";        }      }    }    else {      $output .= ' <'. $key .'>'. (is_array($value) ? format_xml_elements($value) : check_plain($value)) ."</$key>\n";    }  }  return $output;}/** * Format a string containing a count of items. * * This function ensures that the string is pluralized correctly. Since t() is * called by this function, make sure not to pass already-localized strings to * it. * * For example: * @code *   $output = format_plural($node->comment_count, '1 comment', '@count comments'); * @endcode * * Example with additional replacements: * @code *   $output = format_plural($update_count, *     'Changed the content type of 1 post from %old-type to %new-type.', *     'Changed the content type of @count posts from %old-type to %new-type.', *     array('%old-type' => $info->old_type, '%new-type' => $info->new_type))); * @endcode * * @param $count *   The item count to display. * @param $singular *   The string for the singular case. Please make sure it is clear this is *   singular, to ease translation (e.g. use "1 new comment" instead of "1 new"). *   Do not use @count in the singular string. * @param $plural *   The string for the plural case. Please make sure it is clear this is plural, *   to ease translation. Use @count in place of the item count, as in "@count *   new comments". * @param $args *   An associative array of replacements to make after translation. Incidences *   of any key in this array are replaced with the corresponding value. *   Based on the first character of the key, the value is escaped and/or themed: *    - !variable: inserted as is *    - @variable: escape plain text to HTML (check_plain) *    - %variable: escape text and theme as a placeholder for user-submitted *      content (check_plain + theme_placeholder) *   Note that you do not need to include @count in this array. *   This replacement is done automatically for the plural case. * @param $langcode *   Optional language code to translate to a language other than *   what is used to display the page. * @return *   A translated string. */function format_plural($count, $singular, $plural, $args = array(), $langcode = NULL) {  $args['@count'] = $count;  if ($count == 1) {    return t($singular, $args, $langcode);  }  // Get the plural index through the gettext formula.  $index = (function_exists('locale_get_plural')) ? locale_get_plural($count, $langcode) : -1;  // Backwards compatibility.  if ($index < 0) {    return t($plural, $args, $langcode);  }  else {    switch ($index) {      case "0":        return t($singular, $args, $langcode);      case "1":        return t($plural, $args, $langcode);      default:        unset($args['@count']);        $args['@count['. $index .']'] = $count;        return t(strtr($plural, array('@count' => '@count['. $index .']')), $args, $langcode);    }  }}/** * Parse a given byte count. * * @param $size *   A size expressed as a number of bytes with optional SI size and unit *   suffix (e.g. 2, 3K, 5MB, 10G). * @return *   An integer representation of the size. */function parse_size($size) {  $suffixes = array(    '' => 1,    'k' => 1024,    'm' => 1048576, // 1024 * 1024    'g' => 1073741824, // 1024 * 1024 * 1024  );  if (preg_match('/([0-9]+)\s*(k|m|g)?(b?(ytes?)?)/i', $size, $match)) {    return $match[1] * $suffixes[drupal_strtolower($match[2])];  }}/** * Generate a string representation for the given byte count. * * @param $size *   A size in bytes. * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   A translated string representation of the size. */function format_size($size, $langcode = NULL) {  if ($size < 1024) {    return format_plural($size, '1 byte', '@count bytes', array(), $langcode);  }  else {    $size = round($size / 1024, 2);    $suffix = t('KB', array(), $langcode);    if ($size >= 1024) {      $size = round($size / 1024, 2);      $suffix = t('MB', array(), $langcode);    }    return t('@size @suffix', array('@size' => $size, '@suffix' => $suffix), $langcode);  }}/** * Format a time interval with the requested granularity. * * @param $timestamp *   The length of the interval in seconds. * @param $granularity *   How many different units to display in the string. * @param $langcode *   Optional language code to translate to a language other than *   what is used to display the page. * @return *   A translated string representation of the interval. */function format_interval($timestamp, $granularity = 2, $langcode = NULL) {  $units = array('1 year|@count years' => 31536000, '1 week|@count weeks' => 604800, '1 day|@count days' => 86400, '1 hour|@count hours' => 3600, '1 min|@count min' => 60, '1 sec|@count sec' => 1);  $output = '';  foreach ($units as $key => $value) {    $key = explode('|', $key);    if ($timestamp >= $value) {      $output .= ($output ? ' ' : '') . format_plural(floor($timestamp / $value), $key[0], $key[1], array(), $langcode);      $timestamp %= $value;      $granularity--;    }    if ($granularity == 0) {      break;    }  }  return $output ? $output : t('0 sec', array(), $langcode);}/** * Format a date with the given configured format or a custom format string. * * Drupal allows administrators to select formatting strings for 'small', * 'medium' and 'large' date formats. This function can handle these formats, * as well as any custom format. * * @param $timestamp *   The exact date to format, as a UNIX timestamp. * @param $type *   The format to use. Can be "small", "medium" or "large" for the preconfigured *   date formats. If "custom" is specified, then $format is required as well. * @param $format *   A PHP date format string as required by date(). A backslash should be used *   before a character to avoid interpreting the character as part of a date *   format. * @param $timezone *   Time zone offset in seconds; if omitted, the user's time zone is used. * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   A translated date string in the requested format. */function format_date($timestamp, $type = 'medium', $format = '', $timezone = NULL, $langcode = NULL) {  if (!isset($timezone)) {    global $user;    if (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone)) {      $timezone = $user->timezone;    }    else {      $timezone = variable_get('date_default_timezone', 0);    }  }  $timestamp += $timezone;  switch ($type) {    case 'small':      $format = variable_get('date_format_short', 'm/d/Y - H:i');      break;    case 'large':      $format = variable_get('date_format_long', 'l, F j, Y - H:i');      break;    case 'custom':      // No change to format.      break;    case 'medium':    default:      $format = variable_get('date_format_medium', 'D, m/d/Y - H:i');  }  $max = strlen($format);  $date = '';  for ($i = 0; $i < $max; $i++) {    $c = $format[$i];    if (strpos('AaDlM', $c) !== FALSE) {      $date .= t(gmdate($c, $timestamp), array(), $langcode);    }    else if ($c == 'F') {      // Special treatment for long month names: May is both an abbreviation      // and a full month name in English, but other languages have      // different abbreviations.      $date .= trim(t('!long-month-name '. gmdate($c, $timestamp), array('!long-month-name' => ''), $langcode));    }    else if (strpos('BdgGhHiIjLmnsStTUwWYyz', $c) !== FALSE) {      $date .= gmdate($c, $timestamp);    }    else if ($c == 'r') {      $date .= format_date($timestamp - $timezone, 'custom', 'D, d M Y H:i:s O', $timezone, $langcode);    }    else if ($c == 'O') {      $date .= sprintf('%s%02d%02d', ($timezone < 0 ? '-' : '+'), abs($timezone / 3600), abs($timezone % 3600) / 60);    }    else if ($c == 'Z') {      $date .= $timezone;    }    else if ($c == '\\') {      $date .= $format[++$i];    }    else {      $date .= $c;    }  }  return $date;}/** * @} End of "defgroup format". *//** * Generate a URL from a Drupal menu path. Will also pass-through existing URLs. * * @param $path *   The Drupal path being linked to, such as "admin/content/node", or an *   existing URL like "http://drupal.org/".  The special path *   '<front>' may also be given and will generate the site's base URL. * @param $options *   An associative array of additional options, with the following keys: *   - 'query' *       A URL-encoded query string to append to the link, or an array of query *       key/value-pairs without any URL-encoding. *   - 'fragment' *       A fragment identifier (or named anchor) to append to the link. *       Do not include the '#' character. *   - 'absolute' (default FALSE) *       Whether to force the output to be an absolute link (beginning with *       http:). Useful for links that will be displayed outside the site, such *       as in an RSS feed. *   - 'alias' (default FALSE) *       Whether the given path is an alias already. *   - 'external' *       Whether the given path is an external URL. *   - 'language' *       An optional language object. Used to build the URL to link to and *       look up the proper alias for the link. *   - 'base_url' *       Only used internally, to modify the base URL when a language dependent *       URL requires so. *   - 'prefix' *       Only used internally, to modify the path when a language dependent URL *       requires so. * @return *   A string containing a URL to the given path. * * When creating links in modules, consider whether l() could be a better * alternative than url(). */function url($path = NULL, $options = array()) {  // Merge in defaults.  $options += array(    'fragment' => '',    'query' => '',    'absolute' => FALSE,    'alias' => FALSE,    'prefix' => ''  );  if (!isset($options['external'])) {    // Return an external link if $path contains an allowed absolute URL.    // Only call the slow filter_xss_bad_protocol if $path contains a ':' before    // any / ? or #.    $colonpos = strpos($path, ':');    $options['external'] = ($colonpos !== FALSE && !preg_match('![/?#]!', substr($path, 0, $colonpos)) && filter_xss_bad_protocol($path, FALSE) == check_plain($path));  }  // May need language dependent rewriting if language.inc is present.  if (function_exists('language_url_rewrite')) {    language_url_rewrite($path, $options);  }  if ($options['fragment']) {    $options['fragment'] = '#'. $options['fragment'];  }  if (is_array($options['query'])) {    $options['query'] = drupal_query_string_encode($options['query']);  }  if ($options['external']) {    // Split off the fragment.    if (strpos($path, '#') !== FALSE) {      list($path, $old_fragment) = explode('#', $path, 2);      if (isset($old_fragment) && !$options['fragment']) {        $options['fragment'] = '#'. $old_fragment;      }    }    // Append the query.    if ($options['query']) {      $path .= (strpos($path, '?') !== FALSE ? '&' : '?') . $options['query'];    }    // Reassemble.    return $path . $options['fragment'];  }  global $base_url;  static $script;  if (!isset($script)) {    // On some web servers, such as IIS, we can't omit "index.php". So, we    // generate "index.php?q=foo" instead of "?q=foo" on anything that is not    // Apache.    $script = (strpos($_SERVER['SERVER_SOFTWARE'], 'Apache') === FALSE) ? 'index.php' : '';  }  if (!isset($options['base_url'])) {    // The base_url might be rewritten from the language rewrite in domain mode.    $options['base_url'] = $base_url;  }  // Preserve the original path before aliasing.  $original_path = $path;  // The special path '<front>' links to the default front page.  if ($path == '<front>') {    $path = '';  }  elseif (!empty($path) && !$options['alias']) {    $path = drupal_get_path_alias($path, isset($options['language']) ? $options['language']->language : '');  }  if (function_exists('custom_url_rewrite_outbound')) {    // Modules may alter outbound links by reference.    custom_url_rewrite_outbound($path, $options, $original_path);  }  $base = $options['absolute'] ? $options['base_url'] .'/' : base_path();  $prefix = empty($path) ? rtrim($options['prefix'], '/') : $options['prefix'];  $path = drupal_urlencode($prefix . $path);  if (variable_get('clean_url', '0')) {    // With Clean URLs.    if ($options['query']) {      return $base . $path .'?'. $options['query'] . $options['fragment'];    }    else {      return $base . $path . $options['fragment'];    }  }  else {    // Without Clean URLs.    $variables = array();    if (!empty($path)) {      $variables[] = 'q='. $path;    }    if (!empty($options['query'])) {      $variables[] = $options['query'];    }    if ($query = join('&', $variables)) {      return $base . $script .'?'. $query . $options['fragment'];    }    else {      return $base . $options['fragment'];    }  }}/** * Format an attribute string to insert in a tag. * * @param $attributes *   An associative array of HTML attributes. * @return *   An HTML string ready for insertion in a tag. */function drupal_attributes($attributes = array()) {  if (is_array($attributes)) {    $t = '';    foreach ($attributes as $key => $value) {      $t .= " $key=".'"'. check_plain($value) .'"';    }    return $t;  }}/** * Format an internal Drupal link. * * This function correctly handles aliased paths, and allows themes to highlight * links to the current page correctly, so all internal links output by modules * should be generated by this function if possible. * * @param $text *   The text to be enclosed with the anchor tag. * @param $path *   The Drupal path being linked to, such as "admin/content/node". Can be an *   external or internal URL. *     - If you provide the full URL, it will be considered an external URL. *     - If you provide only the path (e.g. "admin/content/node"), it is *       considered an internal link. In this case, it must be a system URL *       as the url() function will generate the alias. *     - If you provide '<front>', it generates a link to the site's *       base URL (again via the url() function). *     - If you provide a path, and 'alias' is set to TRUE (see below), it is *       used as is. * @param $options *   An associative array of additional options, with the following keys: *     - 'attributes' *       An associative array of HTML attributes to apply to the anchor tag. *     - 'query' *       A query string to append to the link, or an array of query key/value *       properties. *     - 'fragment' *       A fragment identifier (named anchor) to append to the link. *       Do not include the '#' character. *     - 'absolute' (default FALSE) *       Whether to force the output to be an absolute link (beginning with *       http:). Useful for links that will be displayed outside the site, such *       as in an RSS feed. *     - 'html' (default FALSE) *       Whether the title is HTML, or just plain-text. For example for making *       an image a link, this must be set to TRUE, or else you will see the *       escaped HTML. *     - 'alias' (default FALSE) *       Whether the given path is an alias already. * @return *   an HTML string containing a link to the given path. */function l($text, $path, $options = array()) {  global $language;  // Merge in defaults.  $options += array(      'attributes' => array(),      'html' => FALSE,    );  // Append active class.  if (($path == $_GET['q'] || ($path == '<front>' && drupal_is_front_page())) &&      (empty($options['language']) || $options['language']->language == $language->language)) {    if (isset($options['attributes']['class'])) {      $options['attributes']['class'] .= ' active';    }    else {      $options['attributes']['class'] = 'active';    }  }  // Remove all HTML and PHP tags from a tooltip. For best performance, we act only  // if a quick strpos() pre-check gave a suspicion (because strip_tags() is expensive).  if (isset($options['attributes']['title']) && strpos($options['attributes']['title'], '<') !== FALSE) {    $options['attributes']['title'] = strip_tags($options['attributes']['title']);  }  return '<a href="'. check_url(url($path, $options)) .'"'. drupal_attributes($options['attributes']) .'>'. ($options['html'] ? $text : check_plain($text)) .'</a>';}/** * Perform end-of-request tasks. * * This function sets the page cache if appropriate, and allows modules to * react to the closing of the page by calling hook_exit(). */function drupal_page_footer() {  if (variable_get('cache', CACHE_DISABLED) != CACHE_DISABLED) {    page_set_cache();  }  module_invoke_all('exit');}/** * Form an associative array from a linear array. * * This function walks through the provided array and constructs an associative * array out of it. The keys of the resulting array will be the values of the * input array. The values will be the same as the keys unless a function is * specified, in which case the output of the function is used for the values * instead. * * @param $array *   A linear array. * @param $function *   A name of a function to apply to all values before output. * @result *   An associative array. */function drupal_map_assoc($array, $function = NULL) {  if (!isset($function)) {    $result = array();    foreach ($array as $value) {      $result[$value] = $value;    }    return $result;  }  elseif (function_exists($function)) {    $result = array();    foreach ($array as $value) {      $result[$value] = $function($value);    }    return $result;  }}/** * Evaluate a string of PHP code. * * This is a wrapper around PHP's eval(). It uses output buffering to capture both * returned and printed text. Unlike eval(), we require code to be surrounded by * <?php ?> tags; in other words, we evaluate the code as if it were a stand-alone * PHP file. * * Using this wrapper also ensures that the PHP code which is evaluated can not * overwrite any variables in the calling code, unlike a regular eval() call. * * @param $code *   The code to evaluate. * @return *   A string containing the printed output of the code, followed by the returned *   output of the code. */function drupal_eval($code) {  global $theme_path, $theme_info, $conf;  // Store current theme path.  $old_theme_path = $theme_path;  // Restore theme_path to the theme, as long as drupal_eval() executes,  // so code evaluted will not see the caller module as the current theme.  // If theme info is not initialized get the path from theme_default.  if (!isset($theme_info)) {    $theme_path = drupal_get_path('theme', $conf['theme_default']);  }  else {    $theme_path = dirname($theme_info->filename);  }  ob_start();  print eval('?>'. $code);  $output = ob_get_contents();  ob_end_clean();  // Recover original theme path.  $theme_path = $old_theme_path;  return $output;}/** * Returns the path to a system item (module, theme, etc.). * * @param $type *   The type of the item (i.e. theme, theme_engine, module). * @param $name *   The name of the item for which the path is requested. * * @return *   The path to the requested item. */function drupal_get_path($type, $name) {  return dirname(drupal_get_filename($type, $name));}/** * Returns the base URL path of the Drupal installation. * At the very least, this will always default to /. */function base_path() {  return $GLOBALS['base_path'];}/** * Provide a substitute clone() function for PHP4. */function drupal_clone($object) {  return version_compare(phpversion(), '5.0') < 0 ? $object : clone($object);}/** * Add a <link> tag to the page's HEAD. */function drupal_add_link($attributes) {  drupal_set_html_head('<link'. drupal_attributes($attributes) .' />');}/** * Adds a CSS file to the stylesheet queue. * * @param $path *   (optional) The path to the CSS file relative to the base_path(), e.g., *   /modules/devel/devel.css. * *   Modules should always prefix the names of their CSS files with the module *   name, for example: system-menus.css rather than simply menus.css. Themes *   can override module-supplied CSS files based on their filenames, and this *   prefixing helps prevent confusing name collisions for theme developers. *   See drupal_get_css where the overrides are performed. * *   If the direction of the current language is right-to-left (Hebrew, *   Arabic, etc.), the function will also look for an RTL CSS file and append *   it to the list. The name of this file should have an '-rtl.css' suffix. *   For example a CSS file called 'name.css' will have a 'name-rtl.css' *   file added to the list, if exists in the same directory. This CSS file *   should contain overrides for properties which should be reversed or *   otherwise different in a right-to-left display. * @param $type *   (optional) The type of stylesheet that is being added. Types are: module *   or theme. * @param $media *   (optional) The media type for the stylesheet, e.g., all, print, screen. * @param $preprocess *   (optional) Should this CSS file be aggregated and compressed if this *   feature has been turned on under the performance section? * *   What does this actually mean? *   CSS preprocessing is the process of aggregating a bunch of separate CSS *   files into one file that is then compressed by removing all extraneous *   white space. * *   The reason for merging the CSS files is outlined quite thoroughly here: *   http://www.die.net/musings/page_load_time/ *   "Load fewer external objects. Due to request overhead, one bigger file *   just loads faster than two smaller ones half its size." * *   However, you should *not* preprocess every file as this can lead to *   redundant caches. You should set $preprocess = FALSE when: * *     - Your styles are only used rarely on the site. This could be a special *       admin page, the homepage, or a handful of pages that does not represent *       the majority of the pages on your site. * *   Typical candidates for caching are for example styles for nodes across *   the site, or used in the theme. * @return *   An array of CSS files. */function drupal_add_css($path = NULL, $type = 'module', $media = 'all', $preprocess = TRUE) {  static $css = array();  global $language;  // Create an array of CSS files for each media type first, since each type needs to be served  // to the browser differently.  if (isset($path)) {    // This check is necessary to ensure proper cascading of styles and is faster than an asort().    if (!isset($css[$media])) {      $css[$media] = array('module' => array(), 'theme' => array());    }    $css[$media][$type][$path] = $preprocess;    // If the current language is RTL, add the CSS file with RTL overrides.    if ($language->direction == LANGUAGE_RTL) {      $rtl_path = str_replace('.css', '-rtl.css', $path);      if (file_exists($rtl_path)) {        $css[$media][$type][$rtl_path] = $preprocess;      }    }  }  return $css;}/** * Returns a themed representation of all stylesheets that should be attached to the page. * * It loads the CSS in order, with 'module' first, then 'theme' afterwards. * This ensures proper cascading of styles so themes can easily override * module styles through CSS selectors. * * Themes may replace module-defined CSS files by adding a stylesheet with the * same filename. For example, themes/garland/system-menus.css would replace * modules/system/system-menus.css. This allows themes to override complete * CSS files, rather than specific selectors, when necessary. * * If the original CSS file is being overridden by a theme, the theme is * responsible for supplying an accompanying RTL CSS file to replace the * module's. * * @param $css *   (optional) An array of CSS files. If no array is provided, the default *   stylesheets array is used instead. * @return *   A string of XHTML CSS tags. */function drupal_get_css($css = NULL) {  $output = '';  if (!isset($css)) {    $css = drupal_add_css();  }  $no_module_preprocess = '';  $no_theme_preprocess = '';  $preprocess_css = (variable_get('preprocess_css', FALSE) && (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update'));  $directory = file_directory_path();  $is_writable = is_dir($directory) && is_writable($directory) && (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC);  // A dummy query-string is added to filenames, to gain control over  // browser-caching. The string changes on every update or full cache  // flush, forcing browsers to load a new copy of the files, as the  // URL changed.  $query_string = '?'. substr(variable_get('css_js_query_string', '0'), 0, 1);  foreach ($css as $media => $types) {    // If CSS preprocessing is off, we still need to output the styles.    // Additionally, go through any remaining styles if CSS preprocessing is on and output the non-cached ones.    foreach ($types as $type => $files) {      if ($type == 'module') {        // Setup theme overrides for module styles.        $theme_styles = array();        foreach (array_keys($css[$media]['theme']) as $theme_style) {          $theme_styles[] = basename($theme_style);        }      }      foreach ($types[$type] as $file => $preprocess) {        // If the theme supplies its own style using the name of the module style, skip its inclusion.        // This includes any RTL styles associated with its main LTR counterpart.        if ($type == 'module' && in_array(str_replace('-rtl.css', '.css', basename($file)), $theme_styles)) {          // Unset the file to prevent its inclusion when CSS aggregation is enabled.          unset($types[$type][$file]);          continue;        }        // Only include the stylesheet if it exists.        if (file_exists($file)) {          if (!$preprocess || !($is_writable && $preprocess_css)) {            // If a CSS file is not to be preprocessed and it's a module CSS file, it needs to *always* appear at the *top*,            // regardless of whether preprocessing is on or off.            if (!$preprocess && $type == 'module') {              $no_module_preprocess .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }            // If a CSS file is not to be preprocessed and it's a theme CSS file, it needs to *always* appear at the *bottom*,            // regardless of whether preprocessing is on or off.            else if (!$preprocess && $type == 'theme') {              $no_theme_preprocess .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }            else {              $output .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }          }        }      }    }    if ($is_writable && $preprocess_css) {      // Prefix filename to prevent blocking by firewalls which reject files      // starting with "ad*".      $filename = 'css_'. md5(serialize($types) . $query_string) .'.css';      $preprocess_file = drupal_build_css_cache($types, $filename);      $output .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $preprocess_file .'" />'."\n";    }  }  return $no_module_preprocess . $output . $no_theme_preprocess;}/** * Aggregate and optimize CSS files, putting them in the files directory. * * @param $types *   An array of types of CSS files (e.g., screen, print) to aggregate and *   compress into one file. * @param $filename *   The name of the aggregate CSS file. * @return *   The name of the CSS file. */function drupal_build_css_cache($types, $filename) {  $data = '';  // Create the css/ within the files folder.  $csspath = file_create_path('css');  file_check_directory($csspath, FILE_CREATE_DIRECTORY);  if (!file_exists($csspath .'/'. $filename)) {    // Build aggregate CSS file.    foreach ($types as $type) {      foreach ($type as $file => $cache) {        if ($cache) {          $contents = drupal_load_stylesheet($file, TRUE);          // Return the path to where this CSS file originated from.          $base = base_path() . dirname($file) .'/';          _drupal_build_css_path(NULL, $base);          // Prefix all paths within this CSS file, ignoring external and absolute paths.          $data .= preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $contents);        }      }    }    // Per the W3C specification at http://www.w3.org/TR/REC-CSS2/cascade.html#at-import,    // @import rules must proceed any other style, so we move those to the top.    $regexp = '/@import[^;]+;/i';    preg_match_all($regexp, $data, $matches);    $data = preg_replace($regexp, '', $data);    $data = implode('', $matches[0]) . $data;    // Create the CSS file.    file_save_data($data, $csspath .'/'. $filename, FILE_EXISTS_REPLACE);  }  return $csspath .'/'. $filename;}/** * Helper function for drupal_build_css_cache(). * * This function will prefix all paths within a CSS file. */function _drupal_build_css_path($matches, $base = NULL) {  static $_base;  // Store base path for preg_replace_callback.  if (isset($base)) {    $_base = $base;  }  // Prefix with base and remove '../' segments where possible.  $path = $_base . $matches[1];  $last = '';  while ($path != $last) {    $last = $path;    $path = preg_replace('`(^|/)(?!\.\./)([^/]+)/\.\./`', '$1', $path);  }  return 'url('. $path .')';}/** * Loads the stylesheet and resolves all @import commands. * * Loads a stylesheet and replaces @import commands with the contents of the * imported file. Use this instead of file_get_contents when processing * stylesheets. * * The returned contents are compressed removing white space and comments only * when CSS aggregation is enabled. This optimization will not apply for * color.module enabled themes with CSS aggregation turned off. * * @param $file *   Name of the stylesheet to be processed. * @param $optimize *   Defines if CSS contents should be compressed or not. * @return *   Contents of the stylesheet including the imported stylesheets. */function drupal_load_stylesheet($file, $optimize = NULL) {  static $_optimize;  // Store optimization parameter for preg_replace_callback with nested @import loops.  if (isset($optimize)) {    $_optimize = $optimize;  }  $contents = '';  if (file_exists($file)) {    // Load the local CSS stylesheet.    $contents = file_get_contents($file);    // Change to the current stylesheet's directory.    $cwd = getcwd();    chdir(dirname($file));    // Replaces @import commands with the actual stylesheet content.    // This happens recursively but omits external files.    $contents = preg_replace_callback('/@import\s*(?:url\()?[\'"]?(?![a-z]+:)([^\'"\()]+)[\'"]?\)?;/', '_drupal_load_stylesheet', $contents);    // Remove multiple charset declarations for standards compliance (and fixing Safari problems).    $contents = preg_replace('/^@charset\s+[\'"](\S*)\b[\'"];/i', '', $contents);    if ($_optimize) {      // Perform some safe CSS optimizations.      $contents = preg_replace('<        \s*([@{}:;,]|\)\s|\s\()\s* |  # Remove whitespace around separators, but keep space around parentheses.        /\*([^*\\\\]|\*(?!/))+\*/     # Remove comments that are not CSS hacks.        >x', '\1', $contents);    }    // Change back directory.    chdir($cwd);  }  return $contents;}/** * Loads stylesheets recursively and returns contents with corrected paths. * * This function is used for recursive loading of stylesheets and * returns the stylesheet content with all url() paths corrected. */function _drupal_load_stylesheet($matches) {  $filename = $matches[1];  // Load the imported stylesheet and replace @import commands in there as well.  $file = drupal_load_stylesheet($filename);  // Alter all url() paths, but not external.  return preg_replace('/url\(([\'"]?)(?![a-z]+:)([^\'")]+)[\'"]?\)?;/i', 'url(\1'. dirname($filename) .'/', $file);}/** * Delete all cached CSS files. */function drupal_clear_css_cache() {  file_scan_directory(file_create_path('css'), '.*', array('.', '..', 'CVS'), 'file_delete', TRUE);}/** * Add a JavaScript file, setting or inline code to the page. * * The behavior of this function depends on the parameters it is called with. * Generally, it handles the addition of JavaScript to the page, either as * reference to an existing file or as inline code. The following actions can be * performed using this function: * * - Add a file ('core', 'module' and 'theme'): *   Adds a reference to a JavaScript file to the page. JavaScript files *   are placed in a certain order, from 'core' first, to 'module' and finally *   'theme' so that files, that are added later, can override previously added *   files with ease. * * - Add inline JavaScript code ('inline'): *   Executes a piece of JavaScript code on the current page by placing the code *   directly in the page. This can, for example, be useful to tell the user that *   a new message arrived, by opening a pop up, alert box etc. * * - Add settings ('setting'): *   Adds a setting to Drupal's global storage of JavaScript settings. Per-page *   settings are required by some modules to function properly. The settings *   will be accessible at Drupal.settings. * * @param $data *   (optional) If given, the value depends on the $type parameter: *   - 'core', 'module' or 'theme': Path to the file relative to base_path(). *   - 'inline': The JavaScript code that should be placed in the given scope. *   - 'setting': An array with configuration options as associative array. The *       array is directly placed in Drupal.settings. You might want to wrap your *       actual configuration settings in another variable to prevent the pollution *       of the Drupal.settings namespace. * @param $type *   (optional) The type of JavaScript that should be added to the page. Allowed *   values are 'core', 'module', 'theme', 'inline' and 'setting'. You *   can, however, specify any value. It is treated as a reference to a JavaScript *   file. Defaults to 'module'. * @param $scope *   (optional) The location in which you want to place the script. Possible *   values are 'header' and 'footer' by default. If your theme implements *   different locations, however, you can also use these. * @param $defer *   (optional) If set to TRUE, the defer attribute is set on the <script> tag. *   Defaults to FALSE. This parameter is not used with $type == 'setting'. * @param $cache *   (optional) If set to FALSE, the JavaScript file is loaded anew on every page *   call, that means, it is not cached. Defaults to TRUE. Used only when $type *   references a JavaScript file. * @param $preprocess *   (optional) Should this JS file be aggregated if this *   feature has been turned on under the performance section? * @return *   If the first parameter is NULL, the JavaScript array that has been built so *   far for $scope is returned. If the first three parameters are NULL, *   an array with all scopes is returned. */function drupal_add_js($data = NULL, $type = 'module', $scope = 'header', $defer = FALSE, $cache = TRUE, $preprocess = TRUE) {  static $javascript = array();  if (isset($data)) {    // Add jquery.js and drupal.js, as well as the basePath setting, the    // first time a Javascript file is added.    if (empty($javascript)) {      $javascript['header'] = array(        'core' => array(          'misc/jquery.js' => array('cache' => TRUE, 'defer' => FALSE, 'preprocess' => TRUE),          'misc/drupal.js' => array('cache' => TRUE, 'defer' => FALSE, 'preprocess' => TRUE),        ),        'module' => array(),        'theme' => array(),        'setting' => array(          array('basePath' => base_path()),        ),        'inline' => array(),      );    }    if (isset($scope) && !isset($javascript[$scope])) {      $javascript[$scope] = array('core' => array(), 'module' => array(), 'theme' => array(), 'setting' => array(), 'inline' => array());    }    if (isset($type) && isset($scope) && !isset($javascript[$scope][$type])) {      $javascript[$scope][$type] = array();    }    switch ($type) {      case 'setting':        $javascript[$scope][$type][] = $data;        break;      case 'inline':        $javascript[$scope][$type][] = array('code' => $data, 'defer' => $defer);        break;      default:        // If cache is FALSE, don't preprocess the JS file.        $javascript[$scope][$type][$data] = array('cache' => $cache, 'defer' => $defer, 'preprocess' => (!$cache ? FALSE : $preprocess));    }  }  if (isset($scope)) {    if (isset($javascript[$scope])) {      return $javascript[$scope];    }    else {      return array();    }  }  else {    return $javascript;  }}/** * Returns a themed presentation of all JavaScript code for the current page. * * References to JavaScript files are placed in a certain order: first, all * 'core' files, then all 'module' and finally all 'theme' JavaScript files * are added to the page. Then, all settings are output, followed by 'inline' * JavaScript code. If running update.php, all preprocessing is disabled. * * @param $scope *   (optional) The scope for which the JavaScript rules should be returned. *   Defaults to 'header'. * @param $javascript *   (optional) An array with all JavaScript code. Defaults to the default *   JavaScript array for the given scope. * @return *   All JavaScript code segments and includes for the scope as HTML tags. */function drupal_get_js($scope = 'header', $javascript = NULL) {  if ((!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') && function_exists('locale_update_js_files')) {    locale_update_js_files();  }  if (!isset($javascript)) {    $javascript = drupal_add_js(NULL, NULL, $scope);  }  if (empty($javascript)) {    return '';  }  $output = '';  $preprocessed = '';  $no_preprocess = array('core' => '', 'module' => '', 'theme' => '');  $files = array();  $preprocess_js = (variable_get('preprocess_js', FALSE) && (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update'));  $directory = file_directory_path();  $is_writable = is_dir($directory) && is_writable($directory) && (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC);  // A dummy query-string is added to filenames, to gain control over  // browser-caching. The string changes on every update or full cache  // flush, forcing browsers to load a new copy of the files, as the  // URL changed. Files that should not be cached (see drupal_add_js())  // get time() as query-string instead, to enforce reload on every  // page request.  $query_string = '?'. substr(variable_get('css_js_query_string', '0'), 0, 1);  // For inline Javascript to validate as XHTML, all Javascript containing  // XHTML needs to be wrapped in CDATA. To make that backwards compatible  // with HTML 4, we need to comment out the CDATA-tag.  $embed_prefix = "\n<!--//--><![CDATA[//><!--\n";  $embed_suffix = "\n//--><!]]>\n";  foreach ($javascript as $type => $data) {    if (!$data) continue;    switch ($type) {      case 'setting':        $output .= '<script type="text/javascript">' . $embed_prefix . 'jQuery.extend(Drupal.settings, ' . drupal_to_js(call_user_func_array('array_merge_recursive', $data)) . ");" . $embed_suffix . "</script>\n";        break;      case 'inline':        foreach ($data as $info) {          $output .= '<script type="text/javascript"' . ($info['defer'] ? ' defer="defer"' : '') . '>' . $embed_prefix . $info['code'] . $embed_suffix . "</script>\n";        }        break;      default:        // If JS preprocessing is off, we still need to output the scripts.        // Additionally, go through any remaining scripts if JS preprocessing is on and output the non-cached ones.        foreach ($data as $path => $info) {          if (!$info['preprocess'] || !$is_writable || !$preprocess_js) {            $no_preprocess[$type] .= '<script type="text/javascript"'. ($info['defer'] ? ' defer="defer"' : '') .' src="'. base_path() . $path . ($info['cache'] ? $query_string : '?'. time()) ."\"></script>\n";          }          else {            $files[$path] = $info;          }        }    }  }  // Aggregate any remaining JS files that haven't already been output.  if ($is_writable && $preprocess_js && count($files) > 0) {    // Prefix filename to prevent blocking by firewalls which reject files    // starting with "ad*".    $filename = 'js_'. md5(serialize($files) . $query_string) .'.js';    $preprocess_file = drupal_build_js_cache($files, $filename);    $preprocessed .= '<script type="text/javascript" src="'. base_path() . $preprocess_file .'"></script>'."\n";  }  // Keep the order of JS files consistent as some are preprocessed and others are not.  // Make sure any inline or JS setting variables appear last after libraries have loaded.  $output = $preprocessed . implode('', $no_preprocess) . $output;  return $output;}/** * Assist in adding the tableDrag JavaScript behavior to a themed table. * * Draggable tables should be used wherever an outline or list of sortable items * needs to be arranged by an end-user. Draggable tables are very flexible and * can manipulate the value of form elements placed within individual columns. * * To set up a table to use drag and drop in place of weight select-lists or * in place of a form that contains parent relationships, the form must be * themed into a table. The table must have an id attribute set. If using * theme_table(), the id may be set as such: * @code * $output = theme('table', $header, $rows, array('id' => 'my-module-table')); * return $output; * @endcode * * In the theme function for the form, a special class must be added to each * form element within the same column, "grouping" them together. * * In a situation where a single weight column is being sorted in the table, the * classes could be added like this (in the theme function): * @code * $form['my_elements'][$delta]['weight']['#attributes']['class'] = "my-elements-weight"; * @endcode * * Each row of the table must also have a class of "draggable" in order to enable the * drag handles: * @code * $row = array(...); * $rows[] = array( *   'data' => $row, *   'class' => 'draggable', * ); * @endcode * * When tree relationships are present, the two additional classes * 'tabledrag-leaf' and 'tabledrag-root' can be used to refine the behavior: * - Rows with the 'tabledrag-leaf' class cannot have child rows. * - Rows with the 'tabledrag-root' class cannot be nested under a parent row. * * Calling drupal_add_tabledrag() would then be written as such: * @code * drupal_add_tabledrag('my-module-table', 'order', 'sibling', 'my-elements-weight'); * @endcode * * In a more complex case where there are several groups in one column (such as * the block regions on the admin/build/block page), a separate subgroup class * must also be added to differentiate the groups. * @code * $form['my_elements'][$region][$delta]['weight']['#attributes']['class'] = "my-elements-weight my-elements-weight-". $region; * @endcode * * $group is still 'my-element-weight', and the additional $subgroup variable * will be passed in as 'my-elements-weight-'. $region. This also means that * you'll need to call drupal_add_tabledrag() once for every region added. * * @code * foreach ($regions as $region) { *   drupal_add_tabledrag('my-module-table', 'order', 'sibling', 'my-elements-weight', 'my-elements-weight-'. $region); * } * @endcode * * In a situation where tree relationships are present, adding multiple * subgroups is not necessary, because the table will contain indentations that * provide enough information about the sibling and parent relationships. * See theme_menu_overview_form() for an example creating a table containing * parent relationships. * * Please note that this function should be called from the theme layer, such as * in a .tpl.php file, theme_ function, or in a template_preprocess function, * not in a form declartion. Though the same JavaScript could be added to the * page using drupal_add_js() directly, this function helps keep template files * clean and readable. It also prevents tabledrag.js from being added twice * accidentally. * * @param $table_id *   String containing the target table's id attribute. If the table does not *   have an id, one will need to be set, such as <table id="my-module-table">. * @param $action *   String describing the action to be done on the form item. Either 'match' *   'depth', or 'order'. Match is typically used for parent relationships. *   Order is typically used to set weights on other form elements with the same *   group. Depth updates the target element with the current indentation. * @param $relationship *   String describing where the $action variable should be performed. Either *   'parent', 'sibling', 'group', or 'self'. Parent will only look for fields *   up the tree. Sibling will look for fields in the same group in rows above *   and below it. Self affects the dragged row itself. Group affects the *   dragged row, plus any children below it (the entire dragged group). * @param $group *   A class name applied on all related form elements for this action. * @param $subgroup *   (optional) If the group has several subgroups within it, this string should *   contain the class name identifying fields in the same subgroup. * @param $source *   (optional) If the $action is 'match', this string should contain the class *   name identifying what field will be used as the source value when matching *   the value in $subgroup. * @param $hidden *   (optional) The column containing the field elements may be entirely hidden *   from view dynamically when the JavaScript is loaded. Set to FALSE if the *   column should not be hidden. * @param $limit *   (optional) Limit the maximum amount of parenting in this table. * @see block-admin-display-form.tpl.php * @see theme_menu_overview_form() */function drupal_add_tabledrag($table_id, $action, $relationship, $group, $subgroup = NULL, $source = NULL, $hidden = TRUE, $limit = 0) {  static $js_added = FALSE;  if (!$js_added) {    drupal_add_js('misc/tabledrag.js', 'core');    $js_added = TRUE;  }  // If a subgroup or source isn't set, assume it is the same as the group.  $target = isset($subgroup) ? $subgroup : $group;  $source = isset($source) ? $source : $target;  $settings['tableDrag'][$table_id][$group][] = array(    'target' => $target,    'source' => $source,    'relationship' => $relationship,    'action' => $action,    'hidden' => $hidden,    'limit' => $limit,  );  drupal_add_js($settings, 'setting');}/** * Aggregate JS files, putting them in the files directory. * * @param $files *   An array of JS files to aggregate and compress into one file. * @param $filename *   The name of the aggregate JS file. * @return *   The name of the JS file. */function drupal_build_js_cache($files, $filename) {  $contents = '';  // Create the js/ within the files folder.  $jspath = file_create_path('js');  file_check_directory($jspath, FILE_CREATE_DIRECTORY);  if (!file_exists($jspath .'/'. $filename)) {    // Build aggregate JS file.    foreach ($files as $path => $info) {      if ($info['preprocess']) {        // Append a ';' after each JS file to prevent them from running together.        $contents .= file_get_contents($path) .';';      }    }    // Create the JS file.    file_save_data($contents, $jspath .'/'. $filename, FILE_EXISTS_REPLACE);  }  return $jspath .'/'. $filename;}/** * Delete all cached JS files. */function drupal_clear_js_cache() {  file_scan_directory(file_create_path('js'), '.*', array('.', '..', 'CVS'), 'file_delete', TRUE);  variable_set('javascript_parsed', array());}/** * Converts a PHP variable into its Javascript equivalent. * * We use HTML-safe strings, i.e. with <, > and & escaped. */function drupal_to_js($var) {  switch (gettype($var)) {    case 'boolean':      return $var ? 'true' : 'false'; // Lowercase necessary!    case 'integer':    case 'double':      return $var;    case 'resource':    case 'string':      return '"'. str_replace(array("\r", "\n", "<", ">", "&"),                              array('\r', '\n', '\x3c', '\x3e', '\x26'),                              addslashes($var)) .'"';    case 'array':      // Arrays in JSON can't be associative. If the array is empty or if it      // has sequential whole number keys starting with 0, it's not associative      // so we can go ahead and convert it as an array.      if (empty ($var) || array_keys($var) === range(0, sizeof($var) - 1)) {        $output = array();        foreach ($var as $v) {          $output[] = drupal_to_js($v);        }        return '[ '. implode(', ', $output) .' ]';      }      // Otherwise, fall through to convert the array as an object.    case 'object':      $output = array();      foreach ($var as $k => $v) {        $output[] = drupal_to_js(strval($k)) .': '. drupal_to_js($v);      }      return '{ '. implode(', ', $output) .' }';    default:      return 'null';  }}/** * Return data in JSON format. * * This function should be used for JavaScript callback functions returning * data in JSON format. It sets the header for JavaScript output. * * @param $var *   (optional) If set, the variable will be converted to JSON and output. */function drupal_json($var = NULL) {  // We are returning JavaScript, so tell the browser.  drupal_set_header('Content-Type: text/javascript; charset=utf-8');  if (isset($var)) {    echo drupal_to_js($var);  }}/** * Wrapper around urlencode() which avoids Apache quirks. * * Should be used when placing arbitrary data in an URL. Note that Drupal paths * are urlencoded() when passed through url() and do not require urlencoding() * of individual components. * * Notes: * - For esthetic reasons, we do not escape slashes. This also avoids a 'feature' *   in Apache where it 404s on any path containing '%2F'. * - mod_rewrite unescapes %-encoded ampersands, hashes, and slashes when clean *   URLs are used, which are interpreted as delimiters by PHP. These *   characters are double escaped so PHP will still see the encoded version. * - With clean URLs, Apache changes '//' to '/', so every second slash is *   double escaped. * - This function should only be used on paths, not on query string arguments, *   otherwise unwanted double encoding will occur. * * @param $text *   String to encode */function drupal_urlencode($text) {  if (variable_get('clean_url', '0')) {    return str_replace(array('%2F', '%26', '%23', '//'),                       array('/', '%2526', '%2523', '/%252F'),                       rawurlencode($text));  }  else {    return str_replace('%2F', '/', rawurlencode($text));  }}/** * Ensure the private key variable used to generate tokens is set. * * @return *   The private key. */function drupal_get_private_key() {  if (!($key = variable_get('drupal_private_key', 0))) {    $key = md5(uniqid(mt_rand(), true)) . md5(uniqid(mt_rand(), true));    variable_set('drupal_private_key', $key);  }  return $key;}/** * Generate a token based on $value, the current user session and private key. * * @param $value *   An additional value to base the token on. */function drupal_get_token($value = '') {  $private_key = drupal_get_private_key();  return md5(session_id() . $value . $private_key);}/** * Validate a token based on $value, the current user session and private key. * * @param $token *   The token to be validated. * @param $value *   An additional value to base the token on. * @param $skip_anonymous *   Set to true to skip token validation for anonymous users. * @return *   True for a valid token, false for an invalid token. When $skip_anonymous *   is true, the return value will always be true for anonymous users. */function drupal_valid_token($token, $value = '', $skip_anonymous = FALSE) {  global $user;  return (($skip_anonymous && $user->uid == 0) || ($token == md5(session_id() . $value . variable_get('drupal_private_key', ''))));}/** * Performs one or more XML-RPC request(s). * * @param $url *   An absolute URL of the XML-RPC endpoint. *     Example: *     http://www.example.com/xmlrpc.php * @param ... *   For one request: *     The method name followed by a variable number of arguments to the method. *   For multiple requests (system.multicall): *     An array of call arrays. Each call array follows the pattern of the single *     request: method name followed by the arguments to the method. * @return *   For one request: *     Either the return value of the method on success, or FALSE. *     If FALSE is returned, see xmlrpc_errno() and xmlrpc_error_msg(). *   For multiple requests: *     An array of results. Each result will either be the result *     returned by the method called, or an xmlrpc_error object if the call *     failed. See xmlrpc_error(). */function xmlrpc($url) {  require_once './includes/xmlrpc.inc';  $args = func_get_args();  return call_user_func_array('_xmlrpc', $args);}function _drupal_bootstrap_full() {  static $called;  if ($called) {    return;  }  $called = 1;  require_once './includes/theme.inc';  require_once './includes/pager.inc';  require_once './includes/menu.inc';  require_once './includes/tablesort.inc';  require_once './includes/file.inc';  require_once './includes/unicode.inc';  require_once './includes/image.inc';  require_once './includes/form.inc';  require_once './includes/mail.inc';  require_once './includes/actions.inc';  // Set the Drupal custom error handler.  set_error_handler('drupal_error_handler');  // Emit the correct charset HTTP header.  drupal_set_header('Content-Type: text/html; charset=utf-8');  // Detect string handling method  unicode_check();  // Undo magic quotes  fix_gpc_magic();  // Load all enabled modules  module_load_all();  // Let all modules take action before menu system handles the request  // We do not want this while running update.php.  if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {    module_invoke_all('init');  }}/** * Store the current page in the cache. * * We try to store a gzipped version of the cache. This requires the * PHP zlib extension (http://php.net/manual/en/ref.zlib.php). * Presence of the extension is checked by testing for the function * gzencode. There are two compression algorithms: gzip and deflate. * The majority of all modern browsers support gzip or both of them. * We thus only deal with the gzip variant and unzip the cache in case * the browser does not accept gzip encoding. * * @see drupal_page_header */function page_set_cache() {  global $user, $base_root;  if (!$user->uid && $_SERVER['REQUEST_METHOD'] == 'GET' && page_get_cache(TRUE)) {    // This will fail in some cases, see page_get_cache() for the explanation.    if ($data = ob_get_contents()) {      $cache = TRUE;      if (variable_get('page_compression', TRUE) && function_exists('gzencode')) {        // We do not store the data in case the zlib mode is deflate.        // This should be rarely happening.        if (zlib_get_coding_type() == 'deflate') {          $cache = FALSE;        }        else if (zlib_get_coding_type() == FALSE) {          $data = gzencode($data, 9, FORCE_GZIP);        }        // The remaining case is 'gzip' which means the data is        // already compressed and nothing left to do but to store it.      }      ob_end_flush();      if ($cache && $data) {        cache_set($base_root . request_uri(), $data, 'cache_page', CACHE_TEMPORARY, drupal_get_headers());      }    }  }}/** * Executes a cron run when called * @return * Returns TRUE if ran successfully */function drupal_cron_run() {  // Try to allocate enough time to run all the hook_cron implementations.  if (function_exists('set_time_limit')) {    @set_time_limit(240);  }  // Fetch the cron semaphore  $semaphore = variable_get('cron_semaphore', FALSE);  if ($semaphore) {    if (time() - $semaphore > 3600) {      // Either cron has been running for more than an hour or the semaphore      // was not reset due to a database error.      watchdog('cron', 'Cron has been running for more than an hour and is most likely stuck.', array(), WATCHDOG_ERROR);      // Release cron semaphore      variable_del('cron_semaphore');    }    else {      // Cron is still running normally.      watchdog('cron', 'Attempting to re-run cron while it is already running.', array(), WATCHDOG_WARNING);    }  }  else {    // Register shutdown callback    register_shutdown_function('drupal_cron_cleanup');    // Lock cron semaphore    variable_set('cron_semaphore', time());    // Iterate through the modules calling their cron handlers (if any):    module_invoke_all('cron');    // Record cron time    variable_set('cron_last', time());    watchdog('cron', 'Cron run completed.', array(), WATCHDOG_NOTICE);    // Release cron semaphore    variable_del('cron_semaphore');    // Return TRUE so other functions can check if it did run successfully    return TRUE;  }}/** * Shutdown function for cron cleanup. */function drupal_cron_cleanup() {  // See if the semaphore is still locked.  if (variable_get('cron_semaphore', FALSE)) {    watchdog('cron', 'Cron run exceeded the time limit and was aborted.', array(), WATCHDOG_WARNING);    // Release cron semaphore    variable_del('cron_semaphore');  }}/** * Return an array of system file objects. * * Returns an array of file objects of the given type from the site-wide * directory (i.e. modules/), the all-sites directory (i.e. * sites/all/modules/), the profiles directory, and site-specific directory * (i.e. sites/somesite/modules/). The returned array will be keyed using the * key specified (name, basename, filename). Using name or basename will cause * site-specific files to be prioritized over similar files in the default * directories. That is, if a file with the same name appears in both the * site-wide directory and site-specific directory, only the site-specific * version will be included. * * @param $mask *   The regular expression of the files to find. * @param $directory *   The subdirectory name in which the files are found. For example, *   'modules' will search in both modules/ and *   sites/somesite/modules/. * @param $key *   The key to be passed to file_scan_directory(). * @param $min_depth *   Minimum depth of directories to return files from. * * @return *   An array of file objects of the specified type. */function drupal_system_listing($mask, $directory, $key = 'name', $min_depth = 1) {  global $profile;  $config = conf_path();  // When this function is called during Drupal's initial installation process,  // the name of the profile that's about to be installed is stored in the global  // $profile variable. At all other times, the standard Drupal systems variable  // table contains the name of the current profile, and we can call variable_get()  // to determine what one is active.  if (!isset($profile)) {    $profile = variable_get('install_profile', 'default');  }  $searchdir = array($directory);  $files = array();  // The 'profiles' directory contains pristine collections of modules and  // themes as organized by a distribution.  It is pristine in the same way  // that /modules is pristine for core; users should avoid changing anything  // there in favor of sites/all or sites/<domain> directories.  if (file_exists("profiles/$profile/$directory")) {    $searchdir[] = "profiles/$profile/$directory";  }  // Always search sites/all/* as well as the global directories  $searchdir[] = 'sites/all/'. $directory;  if (file_exists("$config/$directory")) {    $searchdir[] = "$config/$directory";  }  // Get current list of items  foreach ($searchdir as $dir) {    $files = array_merge($files, file_scan_directory($dir, $mask, array('.', '..', 'CVS'), 0, TRUE, $key, $min_depth));  }  return $files;}/** * This dispatch function hands off structured Drupal arrays to type-specific * *_alter implementations. It ensures a consistent interface for all altering * operations. * * @param $type *   The data type of the structured array. 'form', 'links', *   'node_content', and so on are several examples. * @param $data *   The structured array to be altered. * @param ... *   Any additional params will be passed on to the called *   hook_$type_alter functions. */function drupal_alter($type, &$data) {  // PHP's func_get_args() always returns copies of params, not references, so  // drupal_alter() can only manipulate data that comes in via the required first  // param. For the edge case functions that must pass in an arbitrary number of  // alterable parameters (hook_form_alter() being the best example), an array of  // those params can be placed in the __drupal_alter_by_ref key of the $data  // array. This is somewhat ugly, but is an unavoidable consequence of a flexible  // drupal_alter() function, and the limitations of func_get_args().  // @todo: Remove this in Drupal 7.  if (is_array($data) && isset($data['__drupal_alter_by_ref'])) {    $by_ref_parameters = $data['__drupal_alter_by_ref'];    unset($data['__drupal_alter_by_ref']);  }  // Hang onto a reference to the data array so that it isn't blown away later.  // Also, merge in any parameters that need to be passed by reference.  $args = array(&$data);  if (isset($by_ref_parameters)) {    $args = array_merge($args, $by_ref_parameters);  }  // Now, use func_get_args() to pull in any additional parameters passed into  // the drupal_alter() call.  $additional_args = func_get_args();  array_shift($additional_args);  array_shift($additional_args);  $args = array_merge($args, $additional_args);  foreach (module_implements($type .'_alter') as $module) {    $function = $module .'_'. $type .'_alter';    call_user_func_array($function, $args);  }}/** * Renders HTML given a structured array tree. * * Recursively iterates over each of the array elements, generating HTML code. * This function is usually called from within a another function, like * drupal_get_form() or node_view(). * * @param $elements *   The structured array describing the data to be rendered. * @return *   The rendered HTML. */function drupal_render(&$elements) {  if (!isset($elements) || (isset($elements['#access']) && !$elements['#access'])) {    return NULL;  }  // If the default values for this element haven't been loaded yet, populate  // them.  if (!isset($elements['#defaults_loaded']) || !$elements['#defaults_loaded']) {    if ((!empty($elements['#type'])) && ($info = _element_info($elements['#type']))) {      $elements += $info;    }  }  // Make any final changes to the element before it is rendered. This means  // that the $element or the children can be altered or corrected before the  // element is rendered into the final text.  if (isset($elements['#pre_render'])) {    foreach ($elements['#pre_render'] as $function) {      if (function_exists($function)) {        $elements = $function($elements);      }    }  }  $content = '';  // Either the elements did not go through form_builder or one of the children  // has a #weight.  if (!isset($elements['#sorted'])) {    uasort($elements, "element_sort");  }  $elements += array('#title' => NULL, '#description' => NULL);  if (!isset($elements['#children'])) {    $children = element_children($elements);    // Render all the children that use a theme function.    if (isset($elements['#theme']) && empty($elements['#theme_used'])) {      $elements['#theme_used'] = TRUE;      $previous = array();      foreach (array('#value', '#type', '#prefix', '#suffix') as $key) {        $previous[$key] = isset($elements[$key]) ? $elements[$key] : NULL;      }      // If we rendered a single element, then we will skip the renderer.      if (empty($children)) {        $elements['#printed'] = TRUE;      }      else {        $elements['#value'] = '';      }      $elements['#type'] = 'markup';      unset($elements['#prefix'], $elements['#suffix']);      $content = theme($elements['#theme'], $elements);      foreach (array('#value', '#type', '#prefix', '#suffix') as $key) {        $elements[$key] = isset($previous[$key]) ? $previous[$key] : NULL;      }    }    // Render each of the children using drupal_render and concatenate them.    if (!isset($content) || $content === '') {      foreach ($children as $key) {        $content .= drupal_render($elements[$key]);      }    }  }  if (isset($content) && $content !== '') {    $elements['#children'] = $content;  }  // Until now, we rendered the children, here we render the element itself  if (!isset($elements['#printed'])) {    $content = theme(!empty($elements['#type']) ? $elements['#type'] : 'markup', $elements);    $elements['#printed'] = TRUE;  }  if (isset($content) && $content !== '') {    // Filter the outputted content and make any last changes before the    // content is sent to the browser. The changes are made on $content    // which allows the output'ed text to be filtered.    if (isset($elements['#post_render'])) {      foreach ($elements['#post_render'] as $function) {        if (function_exists($function)) {          $content = $function($content, $elements);        }      }    }    $prefix = isset($elements['#prefix']) ? $elements['#prefix'] : '';    $suffix = isset($elements['#suffix']) ? $elements['#suffix'] : '';    return $prefix . $content . $suffix;  }}/** * Function used by uasort to sort structured arrays by weight. */function element_sort($a, $b) {  $a_weight = (is_array($a) && isset($a['#weight'])) ? $a['#weight'] : 0;  $b_weight = (is_array($b) && isset($b['#weight'])) ? $b['#weight'] : 0;  if ($a_weight == $b_weight) {    return 0;  }  return ($a_weight < $b_weight) ? -1 : 1;}/** * Check if the key is a property. */function element_property($key) {  return $key[0] == '#';}/** * Get properties of a structured array element. Properties begin with '#'. */function element_properties($element) {  return array_filter(array_keys((array) $element), 'element_property');}/** * Check if the key is a child. */function element_child($key) {  return !isset($key[0]) || $key[0] != '#';}/** * Get keys of a structured array tree element that are not properties (i.e., do not begin with '#'). */function element_children($element) {  return array_filter(array_keys((array) $element), 'element_child');}/** * Provide theme registration for themes across .inc files. */function drupal_common_theme() {  return array(    // theme.inc    'placeholder' => array(      'arguments' => array('text' => NULL)    ),    'page' => array(      'arguments' => array('content' => NULL, 'show_blocks' => TRUE, 'show_messages' => TRUE),      'template' => 'page',    ),    'maintenance_page' => array(      'arguments' => array('content' => NULL, 'show_blocks' => TRUE, 'show_messages' => TRUE),      'template' => 'maintenance-page',    ),    'update_page' => array(      'arguments' => array('content' => NULL, 'show_messages' => TRUE),    ),    'install_page' => array(      'arguments' => array('content' => NULL),    ),    'task_list' => array(      'arguments' => array('items' => NULL, 'active' => NULL),    ),    'status_messages' => array(      'arguments' => array('display' => NULL),    ),    'links' => array(      'arguments' => array('links' => NULL, 'attributes' => array('class' => 'links')),    ),    'image' => array(      'arguments' => array('path' => NULL, 'alt' => '', 'title' => '', 'attributes' => NULL, 'getsize' => TRUE),    ),    'breadcrumb' => array(      'arguments' => array('breadcrumb' => NULL),    ),    'help' => array(      'arguments' => array(),    ),    'submenu' => array(      'arguments' => array('links' => NULL),    ),    'table' => array(      'arguments' => array('header' => NULL, 'rows' => NULL, 'attributes' => array(), 'caption' => NULL),    ),    'table_select_header_cell' => array(      'arguments' => array(),    ),    'tablesort_indicator' => array(      'arguments' => array('style' => NULL),    ),    'box' => array(      'arguments' => array('title' => NULL, 'content' => NULL, 'region' => 'main'),      'template' => 'box',    ),    'block' => array(      'arguments' => array('block' => NULL),      'template' => 'block',    ),    'mark' => array(      'arguments' => array('type' => MARK_NEW),    ),    'item_list' => array(      'arguments' => array('items' => array(), 'title' => NULL, 'type' => 'ul', 'attributes' => NULL),    ),    'more_help_link' => array(      'arguments' => array('url' => NULL),    ),    'xml_icon' => array(      'arguments' => array('url' => NULL),    ),    'feed_icon' => array(      'arguments' => array('url' => NULL, 'title' => NULL),    ),    'more_link' => array(      'arguments' => array('url' => NULL, 'title' => NULL)    ),    'closure' => array(      'arguments' => array('main' => 0),    ),    'blocks' => array(      'arguments' => array('region' => NULL),    ),    'username' => array(      'arguments' => array('object' => NULL),    ),    'progress_bar' => array(      'arguments' => array('percent' => NULL, 'message' => NULL),    ),    'indentation' => array(      'arguments' => array('size' => 1),    ),    // from pager.inc    'pager' => array(      'arguments' => array('tags' => array(), 'limit' => 10, 'element' => 0, 'parameters' => array()),    ),    'pager_first' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'parameters' => array()),    ),    'pager_previous' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'interval' => 1, 'parameters' => array()),    ),    'pager_next' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'interval' => 1, 'parameters' => array()),    ),    'pager_last' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'parameters' => array()),    ),    'pager_link' => array(      'arguments' => array('text' => NULL, 'page_new' => NULL, 'element' => NULL, 'parameters' => array(), 'attributes' => array()),    ),    // from locale.inc    'locale_admin_manage_screen' => array(      'arguments' => array('form' => NULL),    ),    // from menu.inc    'menu_item_link' => array(      'arguments' => array('item' => NULL),    ),    'menu_tree' => array(      'arguments' => array('tree' => NULL),    ),    'menu_item' => array(      'arguments' => array('link' => NULL, 'has_children' => NULL, 'menu' => ''),    ),    'menu_local_task' => array(      'arguments' => array('link' => NULL, 'active' => FALSE),    ),    'menu_local_tasks' => array(      'arguments' => array(),    ),    // from form.inc    'select' => array(      'arguments' => array('element' => NULL),    ),    'fieldset' => array(      'arguments' => array('element' => NULL),    ),    'radio' => array(      'arguments' => array('element' => NULL),    ),    'radios' => array(      'arguments' => array('element' => NULL),    ),    'password_confirm' => array(      'arguments' => array('element' => NULL),    ),    'date' => array(      'arguments' => array('element' => NULL),    ),    'item' => array(      'arguments' => array('element' => NULL),    ),    'checkbox' => array(      'arguments' => array('element' => NULL),    ),    'checkboxes' => array(      'arguments' => array('element' => NULL),    ),    'submit' => array(      'arguments' => array('element' => NULL),    ),    'button' => array(      'arguments' => array('element' => NULL),    ),    'image_button' => array(      'arguments' => array('element' => NULL),    ),    'hidden' => array(      'arguments' => array('element' => NULL),    ),    'token' => array(      'arguments' => array('element' => NULL),    ),    'textfield' => array(      'arguments' => array('element' => NULL),    ),    'form' => array(      'arguments' => array('element' => NULL),    ),    'textarea' => array(      'arguments' => array('element' => NULL),    ),    'markup' => array(      'arguments' => array('element' => NULL),    ),    'password' => array(      'arguments' => array('element' => NULL),    ),    'file' => array(      'arguments' => array('element' => NULL),    ),    'form_element' => array(      'arguments' => array('element' => NULL, 'value' => NULL),    ),  );}/** * @ingroup schemaapi * @{ *//** * Get the schema definition of a table, or the whole database schema. * * The returned schema will include any modifications made by any * module that implements hook_schema_alter(). * * @param $table *   The name of the table. If not given, the schema of all tables is returned. * @param $rebuild *   If true, the schema will be rebuilt instead of retrieved from the cache. */function drupal_get_schema($table = NULL, $rebuild = FALSE) {  static $schema = array();  if (empty($schema) || $rebuild) {    // Try to load the schema from cache.    if (!$rebuild && $cached = cache_get('schema')) {      $schema = $cached->data;    }    // Otherwise, rebuild the schema cache.    else {      $schema = array();      // Load the .install files to get hook_schema.      module_load_all_includes('install');      // Invoke hook_schema for all modules.      foreach (module_implements('schema') as $module) {        $current = module_invoke($module, 'schema');        _drupal_initialize_schema($module, $current);        $schema = array_merge($schema, $current);      }      drupal_alter('schema', $schema);      cache_set('schema', $schema);    }  }  if (!isset($table)) {    return $schema;  }  elseif (isset($schema[$table])) {    return $schema[$table];  }  else {    return FALSE;  }}/** * Create all tables that a module defines in its hook_schema(). * * Note: This function does not pass the module's schema through * hook_schema_alter(). The module's tables will be created exactly as the * module defines them. * * @param $module *   The module for which the tables will be created. * @return *   An array of arrays with the following key/value pairs: *    - success: a boolean indicating whether the query succeeded. *    - query: the SQL query(s) executed, passed through check_plain(). */function drupal_install_schema($module) {  $schema = drupal_get_schema_unprocessed($module);  _drupal_initialize_schema($module, $schema);  $ret = array();  foreach ($schema as $name => $table) {    db_create_table($ret, $name, $table);  }  return $ret;}/** * Remove all tables that a module defines in its hook_schema(). * * Note: This function does not pass the module's schema through * hook_schema_alter(). The module's tables will be created exactly as the * module defines them. * * @param $module *   The module for which the tables will be removed. * @return *   An array of arrays with the following key/value pairs: *    - success: a boolean indicating whether the query succeeded. *    - query: the SQL query(s) executed, passed through check_plain(). */function drupal_uninstall_schema($module) {  $schema = drupal_get_schema_unprocessed($module);  _drupal_initialize_schema($module, $schema);  $ret = array();  foreach ($schema as $table) {    db_drop_table($ret, $table['name']);  }  return $ret;}/** * Returns the unprocessed and unaltered version of a module's schema. * * Use this function only if you explicitly need the original * specification of a schema, as it was defined in a module's * hook_schema(). No additional default values will be set, * hook_schema_alter() is not invoked and these unprocessed * definitions won't be cached. * * This function can be used to retrieve a schema specification in * hook_schema(), so it allows you to derive your tables from existing * specifications. * * It is also used by drupal_install_schema() and * drupal_uninstall_schema() to ensure that a module's tables are * created exactly as specified without any changes introduced by a * module that implements hook_schema_alter(). * * @param $module *   The module to which the table belongs. * @param $table *   The name of the table. If not given, the module's complete schema *   is returned. */function drupal_get_schema_unprocessed($module, $table = NULL) {  // Load the .install file to get hook_schema.  module_load_include('install', $module);  $schema = module_invoke($module, 'schema');  if (!is_null($table) && isset($schema[$table])) {    return $schema[$table];  }  else {    return $schema;  }}/** * Fill in required default values for table definitions returned by hook_schema(). * * @param $module *   The module for which hook_schema() was invoked. * @param $schema *   The schema definition array as it was returned by the module's *   hook_schema(). */function _drupal_initialize_schema($module, &$schema) {  // Set the name and module key for all tables.  foreach ($schema as $name => $table) {    if (empty($table['module'])) {      $schema[$name]['module'] = $module;    }    if (!isset($table['name'])) {      $schema[$name]['name'] = $name;    }  }}/** * Retrieve a list of fields from a table schema. The list is suitable for use in a SQL query. * * @param $table *   The name of the table from which to retrieve fields. * @param *   An optional prefix to to all fields. * * @return An array of fields. **/function drupal_schema_fields_sql($table, $prefix = NULL) {  $schema = drupal_get_schema($table);  $fields = array_keys($schema['fields']);  if ($prefix) {    $columns = array();    foreach ($fields as $field) {      $columns[] = "$prefix.$field";    }    return $columns;  }  else {    return $fields;  }}/** * Save a record to the database based upon the schema. * * Default values are filled in for missing items, and 'serial' (auto increment) * types are filled in with IDs. * * @param $table *   The name of the table; this must exist in schema API. * @param $object *   The object to write. This is a reference, as defaults according to *   the schema may be filled in on the object, as well as ID on the serial *   type(s). Both array an object types may be passed. * @param $update *   If this is an update, specify the primary keys' field names. It is the *   caller's responsibility to know if a record for this object already *   exists in the database. If there is only 1 key, you may pass a simple string. * @return *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or *   SAVED_UPDATED is returned depending on the operation performed. The *   $object parameter contains values for any serial fields defined by *   the $table. For example, $object->nid will be populated after inserting *   a new node. */function drupal_write_record($table, &$object, $update = array()) {  // Standardize $update to an array.  if (is_string($update)) {    $update = array($update);  }  $schema = drupal_get_schema($table);  if (empty($schema)) {    return FALSE;  }  // Convert to an object if needed.  if (is_array($object)) {    $object = (object) $object;    $array = TRUE;  }  else {    $array = FALSE;  }  $fields = $defs = $values = $serials = $placeholders = array();  // Go through our schema, build SQL, and when inserting, fill in defaults for  // fields that are not set.  foreach ($schema['fields'] as $field => $info) {    // Special case -- skip serial types if we are updating.    if ($info['type'] == 'serial' && count($update)) {      continue;    }    // For inserts, populate defaults from Schema if not already provided    if (!isset($object->$field) && !count($update) && isset($info['default'])) {      $object->$field = $info['default'];    }    // Track serial fields so we can helpfully populate them after the query.    if ($info['type'] == 'serial') {      $serials[] = $field;      // Ignore values for serials when inserting data. Unsupported.      unset($object->$field);    }    // Build arrays for the fields, placeholders, and values in our query.    if (isset($object->$field)) {      $fields[] = $field;      $placeholders[] = db_type_placeholder($info['type']);      if (empty($info['serialize'])) {        $values[] = $object->$field;      }      else {        $values[] = serialize($object->$field);      }    }  }  // Build the SQL.  $query = '';  if (!count($update)) {    $query = "INSERT INTO {". $table ."} (". implode(', ', $fields) .') VALUES ('. implode(', ', $placeholders) .')';    $return = SAVED_NEW;  }  else {    $query = '';    foreach ($fields as $id => $field) {      if ($query) {        $query .= ', ';      }      $query .= $field .' = '. $placeholders[$id];    }    foreach ($update as $key){      $conditions[] = "$key = ". db_type_placeholder($schema['fields'][$key]['type']);      $values[] = $object->$key;    }    $query = "UPDATE {". $table ."} SET $query WHERE ". implode(' AND ', $conditions);    $return = SAVED_UPDATED;  }  // Execute the SQL.  if (db_query($query, $values)) {    if ($serials) {      // Get last insert ids and fill them in.      foreach ($serials as $field) {        $object->$field = db_last_insert_id($table, $field);      }    }  }  else {    $return = FALSE;  }  // If we began with an array, convert back so we don't surprise the caller.  if ($array) {    $object = (array) $object;  }  return $return;}/** * @} End of "ingroup schemaapi". *//** * Parse Drupal info file format. * * Files should use an ini-like format to specify values. * White-space generally doesn't matter, except inside values. * e.g. * * @code *   key = value *   key = "value" *   key = 'value' *   key = "multi-line * *   value" *   key = 'multi-line * *   value' *   key *   = *   'value' * @endcode * * Arrays are created using a GET-like syntax: * * @code *   key[] = "numeric array" *   key[index] = "associative array" *   key[index][] = "nested numeric array" *   key[index][index] = "nested associative array" * @endcode * * PHP constants are substituted in, but only when used as the entire value: * * Comments should start with a semi-colon at the beginning of a line. * * This function is NOT for placing arbitrary module-specific settings. Use * variable_get() and variable_set() for that. * * Information stored in the module.info file: * - name: The real name of the module for display purposes. * - description: A brief description of the module. * - dependencies: An array of shortnames of other modules this module depends on. * - package: The name of the package of modules this module belongs to. * * Example of .info file: * @code *   name = Forum *   description = Enables threaded discussions about general topics. *   dependencies[] = taxonomy *   dependencies[] = comment *   package = Core - optional *   version = VERSION * @endcode * * @param $filename *   The file we are parsing. Accepts file with relative or absolute path. * @return *   The info array. */function drupal_parse_info_file($filename) {  $info = array();  $constants = get_defined_constants();  if (!file_exists($filename)) {    return $info;  }  $data = file_get_contents($filename);  if (preg_match_all('    @^\s*                           # Start at the beginning of a line, ignoring leading whitespace    ((?:      [^=;\[\]]|                    # Key names cannot contain equal signs, semi-colons or square brackets,      \[[^\[\]]*\]                  # unless they are balanced and not nested    )+?)    \s*=\s*                         # Key/value pairs are separated by equal signs (ignoring white-space)    (?:      ("(?:[^"]|(?<=\\\\)")*")|     # Double-quoted string, which may contain slash-escaped quotes/slashes      (\'(?:[^\']|(?<=\\\\)\')*\')| # Single-quoted string, which may contain slash-escaped quotes/slashes      ([^\r\n]*?)                   # Non-quoted string    )\s*$                           # Stop at the next end of a line, ignoring trailing whitespace    @msx', $data, $matches, PREG_SET_ORDER)) {    foreach ($matches as $match) {      // Fetch the key and value string      $i = 0;      foreach (array('key', 'value1', 'value2', 'value3') as $var) {        $$var = isset($match[++$i]) ? $match[$i] : '';      }      $value = stripslashes(substr($value1, 1, -1)) . stripslashes(substr($value2, 1, -1)) . $value3;      // Parse array syntax      $keys = preg_split('/\]?\[/', rtrim($key, ']'));      $last = array_pop($keys);      $parent = &$info;      // Create nested arrays      foreach ($keys as $key) {        if ($key == '') {          $key = count($parent);        }        if (!isset($parent[$key]) || !is_array($parent[$key])) {          $parent[$key] = array();        }        $parent = &$parent[$key];      }      // Handle PHP constants.      if (isset($constants[$value])) {        $value = $constants[$value];      }      // Insert actual value      if ($last == '') {        $last = count($parent);      }      $parent[$last] = $value;    }  }  return $info;}/** * @return *   Array of the possible severity levels for log messages. * * @see watchdog */function watchdog_severity_levels() {  return array(    WATCHDOG_EMERG    => t('emergency'),    WATCHDOG_ALERT    => t('alert'),    WATCHDOG_CRITICAL => t('critical'),    WATCHDOG_ERROR    => t('error'),    WATCHDOG_WARNING  => t('warning'),    WATCHDOG_NOTICE   => t('notice'),    WATCHDOG_INFO     => t('info'),    WATCHDOG_DEBUG    => t('debug'),  );}/** * Explode a string of given tags into an array. */function drupal_explode_tags($tags) {  // This regexp allows the following types of user input:  // this, "somecompany, llc", "and ""this"" w,o.rks", foo bar  $regexp = '%(?:^|,\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^",]*))%x';  preg_match_all($regexp, $tags, $matches);  $typed_tags = array_unique($matches[1]);  $tags = array();  foreach ($typed_tags as $tag) {    // If a user has escaped a term (to demonstrate that it is a group,    // or includes a comma or quote character), we remove the escape    // formatting so to save the term into the database as the user intends.    $tag = trim(str_replace('""', '"', preg_replace('/^"(.*)"$/', '\1', $tag)));    if ($tag != "") {      $tags[] = $tag;    }  }  return $tags;}/** * Implode an array of tags into a string. */function drupal_implode_tags($tags) {  $encoded_tags = array();  foreach ($tags as $tag) {    // Commas and quotes in tag names are special cases, so encode them.    if (strpos($tag, ',') !== FALSE || strpos($tag, '"') !== FALSE) {      $tag = '"'. str_replace('"', '""', $tag) .'"';    }    $encoded_tags[] = $tag;  }  return implode(', ', $encoded_tags);}/** * Flush all cached data on the site. * * Empties cache tables, rebuilds the menu cache and theme registries, and * invokes a hook so that other modules' cache data can be cleared as well. */function drupal_flush_all_caches() {  // Change query-strings on css/js files to enforce reload for all users.  _drupal_flush_css_js();  drupal_clear_css_cache();  drupal_clear_js_cache();  // If invoked from update.php, we must not update the theme information in the  // database, or this will result in all themes being disabled.  if (defined('MAINTENANCE_MODE') && MAINTENANCE_MODE == 'update') {    _system_theme_data();  }  else {    system_theme_data();  }  drupal_rebuild_theme_registry();  menu_rebuild();  node_types_rebuild();  // Don't clear cache_form - in-progress form submissions may break.  // Ordered so clearing the page cache will always be the last action.  $core = array('cache', 'cache_block', 'cache_filter', 'cache_page');  $cache_tables = array_merge(module_invoke_all('flush_caches'), $core);  foreach ($cache_tables as $table) {    cache_clear_all('*', $table, TRUE);  }}/** * Helper function to change query-strings on css/js files. * * Changes the character added to all css/js files as dummy query-string, * so that all browsers are forced to reload fresh files. We keep * 20 characters history (FIFO) to avoid repeats, but only the first * (newest) character is actually used on urls, to keep them short. * This is also called from update.php. */function _drupal_flush_css_js() {  $string_history = variable_get('css_js_query_string', '00000000000000000000');  $new_character = $string_history[0];  // Not including 'q' to allow certain JavaScripts to re-use query string.  $characters = 'abcdefghijklmnoprstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';  while (strpos($string_history, $new_character) !== FALSE) {    $new_character = $characters[mt_rand(0, strlen($characters) - 1)];  }  variable_set('css_js_query_string', $new_character . substr($string_history, 0, 19));}
<?php// $Id$/** * @file * Code required only when fetching information about available updates. *//** * Callback to manually check the update status without cron. */function update_manual_status() {  if (_update_refresh()) {    drupal_set_message(t('Attempted to fetch information about all available new releases and updates.'));  }  else {    drupal_set_message(t('Unable to fetch any information about available new releases and updates.'), 'error');  }  drupal_goto('admin/reports/updates');}/** * Fetch project info via XML from a central server. */function _update_refresh() {  static $fail = array();  global $base_url;  module_load_include('inc', 'update', 'update.compare');  // Since we're fetching new available update data, we want to clear  // our cache of both the projects we care about, and the current update  // status of the site. We do *not* want to clear the cache of available  // releases just yet, since that data (even if it's stale) can be useful  // during update_get_projects(); for example, to modules that implement  // hook_system_info_alter() such as cvs_deploy.  _update_cache_clear('update_project_projects');  _update_cache_clear('update_project_data');  $available = array();  $data = array();  $site_key = md5($base_url . drupal_get_private_key());  $projects = update_get_projects();  // Now that we have the list of projects, we should also clear our cache of  // available release data, since even if we fail to fetch new data, we need  // to clear out the stale data at this point.  _update_cache_clear('update_available_releases');  $max_fetch_attempts = variable_get('update_max_fetch_attempts', UPDATE_MAX_FETCH_ATTEMPTS);    foreach ($projects as $key => $project) {    $url = _update_build_fetch_url($project, $site_key);    $fetch_url_base = _update_get_fetch_url_base($project);    if (empty($fail[$fetch_url_base]) || count($fail[$fetch_url_base]) < $max_fetch_attempts) {      $xml = drupal_http_request($url);      if (isset($xml->data)) {        $data[] = $xml->data;      }      else {        // Connection likely broken; prepare to give up.        $fail[$fetch_url_base][$key] = 1;      }    }    else {      // Didn't bother trying to fetch.      $fail[$fetch_url_base][$key] = 1;    }  }  if ($data) {    $parser = new update_xml_parser;    $available = $parser->parse($data);  }  if (!empty($available) && is_array($available)) {    // Record the projects where we failed to fetch data.    foreach ($fail as $fetch_url_base => $failures) {      foreach ($failures as $key => $value) {        $available[$key]['project_status'] = 'not-fetched';      }    }    $frequency = variable_get('update_check_frequency', 1);    _update_cache_set('update_available_releases', $available, time() + (60 * 60 * 24 * $frequency));    watchdog('update', 'Attempted to fetch information about all available new releases and updates.', array(), WATCHDOG_NOTICE, l(t('view'), 'admin/reports/updates'));  }  else {    watchdog('update', 'Unable to fetch any information about available new releases and updates.', array(), WATCHDOG_ERROR, l(t('view'), 'admin/reports/updates'));  }  // Whether this worked or not, we did just (try to) check for updates.  variable_set('update_last_check', time());  return $available;}/** * Generates the URL to fetch information about project updates. * * This figures out the right URL to use, based on the project's .info file * and the global defaults. Appends optional query arguments when the site is * configured to report usage stats. * * @param $project *   The array of project information from update_get_projects(). * @param $site_key *   The anonymous site key hash (optional). * * @see update_refresh() * @see update_get_projects() */function _update_build_fetch_url($project, $site_key = '') {  $name = $project['name'];  $url = _update_get_fetch_url_base($project);  $url .= '/'. $name .'/'. DRUPAL_CORE_COMPATIBILITY;  // Only append a site_key and the version information if we have a site_key  // in the first place, and if this is not a disabled module or theme. We do  // not want to record usage statistics for disabled code.  if (!empty($site_key) && (strpos($project['project_type'], 'disabled') === FALSE)) {    $url .= (strpos($url, '?') === TRUE) ? '&' : '?';    $url .= 'site_key=';    $url .= rawurlencode($site_key);    if (!empty($project['info']['version'])) {      $url .= '&version=';      $url .= rawurlencode($project['info']['version']);    }  }  return $url;}/** * Return the base of the URL to fetch available update data for a project. * * @param $project *   The array of project information from update_get_projects(). * @return *   The base of the URL used for fetching available update data. This does *   not include the path elements to specify a particular project, version, *   site_key, etc. * * @see _update_build_fetch_url() */function _update_get_fetch_url_base($project) {  return isset($project['info']['project status url']) ? $project['info']['project status url'] : variable_get('update_fetch_url', UPDATE_DEFAULT_URL);}/** * Perform any notifications that should be done once cron fetches new data. * * This method checks the status of the site using the new data and depending * on the configuration of the site, notifies administrators via email if there * are new releases or missing security updates. * * @see update_requirements() */function _update_cron_notify() {  include_once './includes/install.inc';  $status = update_requirements('runtime');  $params = array();  $notify_all = (variable_get('update_notification_threshold', 'all') == 'all');  foreach (array('core', 'contrib') as $report_type) {    $type = 'update_'. $report_type;    if (isset($status[$type]['severity'])        && ($status[$type]['severity'] == REQUIREMENT_ERROR || ($notify_all && $status[$type]['reason'] == UPDATE_NOT_CURRENT))) {      $params[$report_type] = $status[$type]['reason'];    }  }  if (!empty($params)) {    $notify_list = variable_get('update_notify_emails', '');    if (!empty($notify_list)) {      $default_language = language_default();      foreach ($notify_list as $target) {        if ($target_user = user_load(array('mail' => $target))) {          $target_language = user_preferred_language($target_user);        }        else {          $target_language = $default_language;        }        drupal_mail('update', 'status_notify', $target, $target_language, $params);      }    }  }}/** * XML Parser object to read Drupal's release history info files. * This uses PHP4's lame XML parsing, but it works. */class update_xml_parser {  var $projects = array();  var $current_project;  var $current_release;  var $current_term;  var $current_tag;  var $current_object;  /**   * Parse an array of XML data files.   */  function parse($data) {    foreach ($data as $datum) {      $parser = xml_parser_create();      xml_set_object($parser, $this);      xml_set_element_handler($parser, 'start', 'end');      xml_set_character_data_handler($parser, "data");      xml_parse($parser, $datum);      xml_parser_free($parser);    }    return $this->projects;  }  function start($parser, $name, $attr) {    $this->current_tag = $name;    switch ($name) {      case 'PROJECT':        unset($this->current_object);        $this->current_project = array();        $this->current_object = &$this->current_project;        break;      case 'RELEASE':        unset($this->current_object);        $this->current_release = array();        $this->current_object = &$this->current_release;        break;      case 'TERM':        unset($this->current_object);        $this->current_term = array();        $this->current_object = &$this->current_term;        break;    }  }  function end($parser, $name) {    switch ($name) {      case 'PROJECT':        unset($this->current_object);        $this->projects[$this->current_project['short_name']] = $this->current_project;        $this->current_project = array();        break;      case 'RELEASE':        unset($this->current_object);        $this->current_project['releases'][$this->current_release['version']] = $this->current_release;        break;      case 'RELEASES':        $this->current_object = &$this->current_project;        break;      case 'TERM':        unset($this->current_object);        $term_name = $this->current_term['name'];        if (!isset($this->current_release['terms'])) {          $this->current_release['terms'] = array();        }        if (!isset($this->current_release['terms'][$term_name])) {          $this->current_release['terms'][$term_name] = array();        }        $this->current_release['terms'][$term_name][] = $this->current_term['value'];        break;      case 'TERMS':        $this->current_object = &$this->current_release;        break;      default:        $this->current_object[strtolower($this->current_tag)] = trim($this->current_object[strtolower($this->current_tag)]);        $this->current_tag = '';    }  }  function data($parser, $data) {    if ($this->current_tag && !in_array($this->current_tag, array('PROJECT', 'RELEASE', 'RELEASES', 'TERM', 'TERMS'))) {      $tag = strtolower($this->current_tag);      if (isset($this->current_object[$tag])) {        $this->current_object[$tag] .= $data;      }      else {        $this->current_object[$tag] = $data;      }    }  }}
<?php// $Id$/** * @file * User page callback file for the user module. *//** * Menu callback; Retrieve a JSON object containing autocomplete suggestions for existing users. */function user_autocomplete($string = '') {  $matches = array();  if ($string) {    $result = db_query_range("SELECT name FROM {users} WHERE LOWER(name) LIKE LOWER('%s%%')", $string, 0, 10);    while ($user = db_fetch_object($result)) {      $matches[$user->name] = check_plain($user->name);    }  }  drupal_json($matches);}/** * Form builder; Request a password reset. * * @ingroup forms * @see user_pass_validate() * @see user_pass_submit() */function user_pass() {  $form['name'] = array(    '#type' => 'textfield',    '#title' => t('Username or e-mail address'),    '#size' => 60,    '#maxlength' => max(USERNAME_MAX_LENGTH, EMAIL_MAX_LENGTH),    '#required' => TRUE,  );  $form['submit'] = array('#type' => 'submit', '#value' => t('E-mail new password'));  return $form;}function user_pass_validate($form, &$form_state) {  $name = trim($form_state['values']['name']);    // Blocked accounts cannot request a new password,  // check provided username and email against access rules.  if (drupal_is_denied('user', $name) || drupal_is_denied('mail', $name)) {    form_set_error('name', t('%name is not allowed to request a new password.', array('%name' => $name)));  }  // Try to load by email.  $account = user_load(array('mail' => $name, 'status' => 1));  if (!$account) {    // No success, try to load by name.    $account = user_load(array('name' => $name, 'status' => 1));  }  if (isset($account->uid)) {    form_set_value(array('#parents' => array('account')), $account, $form_state);  }  else {    form_set_error('name', t('Sorry, %name is not recognized as a user name or an e-mail address.', array('%name' => $name)));  }}function user_pass_submit($form, &$form_state) {  global $language;  $account = $form_state['values']['account'];  // Mail one time login URL and instructions using current language.  _user_mail_notify('password_reset', $account, $language);  watchdog('user', 'Password reset instructions mailed to %name at %email.', array('%name' => $account->name, '%email' => $account->mail));  drupal_set_message(t('Further instructions have been sent to your e-mail address.'));  $form_state['redirect'] = 'user';  return;}/** * Menu callback; process one time login link and redirects to the user page on success. */function user_pass_reset(&$form_state, $uid, $timestamp, $hashed_pass, $action = NULL) {  global $user;  // Check if the user is already logged in. The back button is often the culprit here.  if ($user->uid) {    drupal_set_message(t('You have already used this one-time login link. It is not necessary to use this link to login anymore. You are already logged in.'));    drupal_goto();  }  else {    // Time out, in seconds, until login URL expires. 24 hours = 86400 seconds.    $timeout = 86400;    $current = time();    // Some redundant checks for extra security ?    if ($timestamp < $current && $account = user_load(array('uid' => $uid, 'status' => 1)) ) {      // Deny one-time login to blocked accounts.      if (drupal_is_denied('user', $account->name) || drupal_is_denied('mail', $account->mail)) {        drupal_set_message(t('You have tried to use a one-time login for an account which has been blocked.'), 'error');        drupal_goto();      }      // No time out for first time login.      if ($account->login && $current - $timestamp > $timeout) {        drupal_set_message(t('You have tried to use a one-time login link that has expired. Please request a new one using the form below.'));        drupal_goto('user/password');      }      else if ($account->uid && $timestamp > $account->login && $timestamp < $current && $hashed_pass == user_pass_rehash($account->pass, $timestamp, $account->login)) {        // First stage is a confirmation form, then login        if ($action == 'login') {          watchdog('user', 'User %name used one-time login link at time %timestamp.', array('%name' => $account->name, '%timestamp' => $timestamp));          // Set the new user.          $user = $account;          // user_authenticate_finalize() also updates the login timestamp of the          // user, which invalidates further use of the one-time login link.          user_authenticate_finalize($form_state['values']);          drupal_set_message(t('You have just used your one-time login link. It is no longer necessary to use this link to login. Please change your password.'));          drupal_goto('user/'. $user->uid .'/edit');        }        else {          $form['message'] = array('#value' => t('<p>This is a one-time login for %user_name and will expire on %expiration_date.</p><p>Click on this button to login to the site and change your password.</p>', array('%user_name' => $account->name, '%expiration_date' => format_date($timestamp + $timeout))));          $form['help'] = array('#value' => '<p>'. t('This login can be used only once.') .'</p>');          $form['submit'] = array('#type' => 'submit', '#value' => t('Log in'));          $form['#action'] = url("user/reset/$uid/$timestamp/$hashed_pass/login");          return $form;        }      }      else {        drupal_set_message(t('You have tried to use a one-time login link which has either been used or is no longer valid. Please request a new one using the form below.'));        drupal_goto('user/password');      }    }    else {      // Deny access, no more clues.      // Everything will be in the watchdog's URL for the administrator to check.      drupal_access_denied();    }  }}/** * Menu callback; logs the current user out, and redirects to the home page. */function user_logout() {  global $user;  watchdog('user', 'Session closed for %name.', array('%name' => $user->name));  // Destroy the current session:  session_destroy();  // Only variables can be passed by reference workaround.  $null = NULL;  user_module_invoke('logout', $null, $user);  // Load the anonymous user  $user = drupal_anonymous_user();  drupal_goto();}/** * Menu callback; Displays a user or user profile page. */function user_view($account) {  drupal_set_title(check_plain($account->name));  // Retrieve all profile fields and attach to $account->content.  user_build_content($account);  // To theme user profiles, copy modules/user/user_profile.tpl.php  // to your theme directory, and edit it as instructed in that file's comments.  return theme('user_profile', $account);}/** * Process variables for user-profile.tpl.php. * * The $variables array contains the following arguments: * - $account * * @see user-picture.tpl.php */function template_preprocess_user_profile(&$variables) {  $variables['profile'] = array();  // Sort sections by weight  uasort($variables['account']->content, 'element_sort');  // Provide keyed variables so themers can print each section independantly.  foreach (element_children($variables['account']->content) as $key) {    $variables['profile'][$key] = drupal_render($variables['account']->content[$key]);  }  // Collect all profiles to make it easier to print all items at once.  $variables['user_profile'] = implode($variables['profile']);}/** * Process variables for user-profile-item.tpl.php. * * The $variables array contains the following arguments: * - $element * * @see user-profile-item.tpl.php */function template_preprocess_user_profile_item(&$variables) {  $variables['title'] = $variables['element']['#title'];  $variables['value'] = $variables['element']['#value'];  $variables['attributes'] = '';  if (isset($variables['element']['#attributes'])) {    $variables['attributes'] = drupal_attributes($variables['element']['#attributes']);  }}/** * Process variables for user-profile-category.tpl.php. * * The $variables array contains the following arguments: * - $element * * @see user-profile-category.tpl.php */function template_preprocess_user_profile_category(&$variables) {  $variables['title'] = check_plain($variables['element']['#title']);  $variables['profile_items'] = $variables['element']['#children'];  $variables['attributes'] = '';  if (isset($variables['element']['#attributes'])) {    $variables['attributes'] = drupal_attributes($variables['element']['#attributes']);  }}/** * Form builder; Present the form to edit a given user or profile category. * * @ingroup forms * @see user_edit_validate() * @see user_edit_submit() */function user_edit($account, $category = 'account') {  drupal_set_title(check_plain($account->name));  return drupal_get_form('user_profile_form', $account, $category);}/** * Form builder; edit a user account or one of their profile categories. * * @ingroup forms * @see user_profile_form_validate() * @see user_profile_form_submit() * @see user_edit_delete_submit() */function user_profile_form($form_state, $account, $category = 'account') {  $edit = (empty($form_state['values'])) ? (array)$account : $form_state['values'];  $form = _user_forms($edit, $account, $category);  $form['_category'] = array('#type' => 'value', '#value' => $category);  $form['_account'] = array('#type' => 'value', '#value' => $account);  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 30);  if (user_access('administer users')) {    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete'),      '#weight' => 31,      '#submit' => array('user_edit_delete_submit'),    );  }  $form['#attributes']['enctype'] = 'multipart/form-data';  return $form;}/** * Validation function for the user account and profile editing form. */function user_profile_form_validate($form, &$form_state) {  user_module_invoke('validate', $form_state['values'], $form_state['values']['_account'], $form_state['values']['_category']);  // Validate input to ensure that non-privileged users can't alter protected data.  if ((!user_access('administer users') && array_intersect(array_keys($form_state['values']), array('uid', 'init', 'session'))) || (!user_access('administer permissions') && isset($form_state['values']['roles']))) {    watchdog('security', 'Detected malicious attempt to alter protected user fields.', array(), WATCHDOG_WARNING);    // set this to a value type field    form_set_error('category', t('Detected malicious attempt to alter protected user fields.'));  }}/** * Submit function for the user account and profile editing form. */function user_profile_form_submit($form, &$form_state) {  $account = $form_state['values']['_account'];  $category = $form_state['values']['_category'];  unset($form_state['values']['_account'], $form_state['values']['op'], $form_state['values']['submit'], $form_state['values']['delete'], $form_state['values']['form_token'], $form_state['values']['form_id'], $form_state['values']['_category']);  user_module_invoke('submit', $form_state['values'], $account, $category);  user_save($account, $form_state['values'], $category);  // Clear the page cache because pages can contain usernames and/or profile information:  cache_clear_all();  drupal_set_message(t('The changes have been saved.'));  return;}/** * Submit function for the 'Delete' button on the user edit form. */function user_edit_delete_submit($form, &$form_state) {  $destination = '';  if (isset($_REQUEST['destination'])) {    $destination = drupal_get_destination();    unset($_REQUEST['destination']);  }  // Note: We redirect from user/uid/edit to user/uid/delete to make the tabs disappear.  $form_state['redirect'] = array("user/". $form_state['values']['_account']->uid ."/delete", $destination);}/** * Form builder; confirm form for user deletion. * * @ingroup forms * @see user_confirm_delete_submit() */function user_confirm_delete(&$form_state, $account) {  $form['_account'] = array('#type' => 'value', '#value' => $account);  return confirm_form($form,    t('Are you sure you want to delete the account %name?', array('%name' => $account->name)),    'user/'. $account->uid,    t('All submissions made by this user will be attributed to the anonymous account. This action cannot be undone.'),    t('Delete'), t('Cancel'));}/** * Submit function for the confirm form for user deletion. */function user_confirm_delete_submit($form, &$form_state) {  user_delete($form_state['values'], $form_state['values']['_account']->uid);  drupal_set_message(t('%name has been deleted.', array('%name' => $form_state['values']['_account']->name)));  if (!isset($_REQUEST['destination'])) {    $form_state['redirect'] = 'admin/user/user';  }}function user_edit_validate($form, &$form_state) {  user_module_invoke('validate', $form_state['values'], $form_state['values']['_account'], $form_state['values']['_category']);  // Validate input to ensure that non-privileged users can't alter protected data.  if ((!user_access('administer users') && array_intersect(array_keys($form_state['values']), array('uid', 'init', 'session'))) || (!user_access('administer permissions') && isset($form_state['values']['roles']))) {    watchdog('security', 'Detected malicious attempt to alter protected user fields.', array(), WATCHDOG_WARNING);    // set this to a value type field    form_set_error('category', t('Detected malicious attempt to alter protected user fields.'));  }}function user_edit_submit($form, &$form_state) {  $account = $form_state['values']['_account'];  $category = $form_state['values']['_category'];  unset($form_state['values']['_account'], $form_state['values']['op'], $form_state['values']['submit'], $form_state['values']['delete'], $form_state['values']['form_token'], $form_state['values']['form_id'], $form_state['values']['_category']);  user_module_invoke('submit', $form_state['values'], $account, $category);  user_save($account, $form_state['values'], $category);  // Clear the page cache because pages can contain usernames and/or profile information:  cache_clear_all();  drupal_set_message(t('The changes have been saved.'));  return;}/** * Access callback for path /user. * * Displays user profile if user is logged in, or login form for anonymous * users. */function user_page() {  global $user;  if ($user->uid) {    menu_set_active_item('user/'. $user->uid);    return menu_execute_active_handler();  }  else {    return drupal_get_form('user_login');  }}
<?php// $Id$/** * Implementation of hook_schema(). */function user_schema() {  $schema['access'] = array(    'description' => 'Stores site access rules.',    'fields' => array(      'aid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique access ID.',      ),      'mask' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Text mask used for filtering access.',      ),      'type' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Type of access rule: name, mail or host.',      ),      'status' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether rule is to allow(1) or deny(0) access.',      ),    ),    'primary key' => array('aid'),  );  $schema['authmap'] = array(    'description' => 'Stores distributed authentication mapping.',    'fields' => array(      'aid' => array(        'description' => 'Primary Key: Unique authmap ID.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,      ),      'uid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => "User's {users}.uid.",      ),      'authname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Unique authentication name.',      ),      'module' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Module which is controlling the authentication.',      ),    ),    'unique keys' => array('authname' => array('authname')),    'primary key' => array('aid'),  );  $schema['permission'] = array(    'description' => 'Stores permissions for users.',    'fields' => array(      'pid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique permission ID.',      ),      'rid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {role}.rid to which the permissions are assigned.',      ),      'perm' => array(        'type' => 'text',        'not null' => FALSE,        'size' => 'big',        'description' => 'List of permissions being assigned.',      ),      'tid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Originally intended for taxonomy-based permissions, but never used.',      ),    ),    'primary key' => array('pid'),    'indexes' => array('rid' => array('rid')),  );  $schema['role'] = array(    'description' => 'Stores user roles.',    'fields' => array(      'rid' => array(        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'Primary Key: Unique role id.',      ),      'name' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Unique role name.',      ),    ),    'unique keys' => array('name' => array('name')),    'primary key' => array('rid'),  );  $schema['users'] = array(    'description' => 'Stores user data.',    'fields' => array(      'uid' => array(        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'Primary Key: Unique user ID.',      ),      'name' => array(        'type' => 'varchar',        'length' => 60,        'not null' => TRUE,        'default' => '',        'description' => 'Unique user name.',      ),      'pass' => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '',        'description' => "User's password (md5 hash).",      ),      'mail' => array(        'type' => 'varchar',        'length' => 64,        'not null' => FALSE,        'default' => '',        'description' => "User's email address.",      ),      'mode' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Per-user comment display mode (threaded vs. flat), used by the {comment} module.',      ),      'sort' => array(        'type' => 'int',        'not null' => FALSE,        'default' => 0,        'size' => 'tiny',        'description' => 'Per-user comment sort order (newest vs. oldest first), used by the {comment} module.',      ),      'threshold' => array(        'type' => 'int',        'not null' => FALSE,        'default' => 0,        'size' => 'tiny',        'description' => 'Previously used by the {comment} module for per-user preferences; no longer used.',      ),      'theme' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => "User's default theme.",      ),      'signature' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => "User's signature.",      ),      'signature_format' => array(        'type' => 'int',        'size' => 'small',        'not null' => TRUE,        'default' => 0,        'description' => 'The {filter_formats}.format of the signature.',      ),      'created' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Timestamp for when user was created.',      ),      'access' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Timestamp for previous time user accessed the site.',      ),      'login' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => "Timestamp for user's last login.",      ),      'status' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether the user is active(1) or blocked(0).',      ),      'timezone' => array(        'type' => 'varchar',        'length' => 8,        'not null' => FALSE,        'description' => "User's timezone.",      ),      'language' => array(        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => '',        'description' => "User's default language.",      ),      'picture' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => "Path to the user's uploaded picture.",      ),      'init' => array(        'type' => 'varchar',        'length' => 64,        'not null' => FALSE,        'default' => '',        'description' => 'Email address used for initial account creation.',      ),      'data' => array(        'type' => 'text',        'not null' => FALSE,        'size' => 'big',        'description' => 'A serialized array of name value pairs that are related to the user. Any form values posted during user edit are stored and are loaded into the $user object during user_load(). Use of this field is discouraged and it will likely disappear in a future version of Drupal.',      ),    ),    'indexes' => array(      'access' => array('access'),      'created' => array('created'),      'mail' => array('mail'),    ),    'unique keys' => array(      'name' => array('name'),    ),    'primary key' => array('uid'),  );  $schema['users_roles'] = array(    'description' => 'Maps users to roles.',    'fields' => array(      'uid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: {users}.uid for user.',      ),      'rid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: {role}.rid for role.',      ),    ),    'primary key' => array('uid', 'rid'),    'indexes' => array(      'rid' => array('rid'),    ),  );  return $schema;}
<?php// $Id$/** * Compose and optionally send an e-mail message. * * Sending an e-mail works with defining an e-mail template (subject, text * and possibly e-mail headers) and the replacement values to use in the * appropriate places in the template. Processed e-mail templates are * requested from hook_mail() from the module sending the e-mail. Any module * can modify the composed e-mail message array using hook_mail_alter(). * Finally drupal_mail_send() sends the e-mail, which can be reused * if the exact same composed e-mail is to be sent to multiple recipients. * * Finding out what language to send the e-mail with needs some consideration. * If you send e-mail to a user, her preferred language should be fine, so * use user_preferred_language(). If you send email based on form values * filled on the page, there are two additional choices if you are not * sending the e-mail to a user on the site. You can either use the language * used to generate the page ($language global variable) or the site default * language. See language_default(). The former is good if sending e-mail to * the person filling the form, the later is good if you send e-mail to an * address previously set up (like contact addresses in a contact form). * * Taking care of always using the proper language is even more important * when sending e-mails in a row to multiple users. Hook_mail() abstracts * whether the mail text comes from an administrator setting or is * static in the source code. It should also deal with common mail tokens, * only receiving $params which are unique to the actual e-mail at hand. * * An example: * * @code *   function example_notify($accounts) { *     foreach ($accounts as $account) { *       $params['account'] = $account; *       // example_mail() will be called based on the first drupal_mail() parameter. *       drupal_mail('example', 'notice', $account->mail, user_preferred_language($account), $params); *     } *   } * *   function example_mail($key, &$message, $params) { *     $language = $message['language']; *     $variables = user_mail_tokens($params['account'], $language); *     switch($key) { *       case 'notice': *         $message['subject'] = t('Notification from !site', $variables, $language->language); *         $message['body'][] = t("Dear !username\n\nThere is new content available on the site.", $variables, $language->language); *         break; *     } *   } * @endcode * * @param $module *   A module name to invoke hook_mail() on. The {$module}_mail() hook will be *   called to complete the $message structure which will already contain common *   defaults. * @param $key *   A key to identify the e-mail sent. The final e-mail id for e-mail altering *   will be {$module}_{$key}. * @param $to *   The e-mail address or addresses where the message will be sent to. The *   formatting of this string must comply with RFC 2822. Some examples are: *    user@example.com *    user@example.com, anotheruser@example.com *    User <user@example.com> *    User <user@example.com>, Another User <anotheruser@example.com> * @param $language *   Language object to use to compose the e-mail. * @param $params *   Optional parameters to build the e-mail. * @param $from *   Sets From to this value, if given. * @param $send *   Send the message directly, without calling drupal_mail_send() manually. * @return *   The $message array structure containing all details of the *   message. If already sent ($send = TRUE), then the 'result' element *   will contain the success indicator of the e-mail, failure being already *   written to the watchdog. (Success means nothing more than the message being *   accepted at php-level, which still doesn't guarantee it to be delivered.) */function drupal_mail($module, $key, $to, $language, $params = array(), $from = NULL, $send = TRUE) {  $default_from = variable_get('site_mail', ini_get('sendmail_from'));  // Bundle up the variables into a structured array for altering.  $message = array(    'id'       => $module .'_'. $key,    'to'       => $to,    'from'     => isset($from) ? $from : $default_from,    'language' => $language,    'params'   => $params,    'subject'  => '',    'body'     => array()  );  // Build the default headers  $headers = array(    'MIME-Version'              => '1.0',    'Content-Type'              => 'text/plain; charset=UTF-8; format=flowed; delsp=yes',    'Content-Transfer-Encoding' => '8Bit',    'X-Mailer'                  => 'Drupal'  );  if ($default_from) {    // To prevent e-mail from looking like spam, the addresses in the Sender and    // Return-Path headers should have a domain authorized to use the originating    // SMTP server. Errors-To is redundant, but shouldn't hurt.    $headers['From'] = $headers['Sender'] = $headers['Return-Path'] = $headers['Errors-To'] = $default_from;  }  if ($from) {    $headers['From'] = $from;  }  $message['headers'] = $headers;  // Build the e-mail (get subject and body, allow additional headers) by  // invoking hook_mail() on this module. We cannot use module_invoke() as  // we need to have $message by reference in hook_mail().  if (function_exists($function = $module .'_mail')) {    $function($key, $message, $params);  }  // Invoke hook_mail_alter() to allow all modules to alter the resulting e-mail.  drupal_alter('mail', $message);  // Concatenate and wrap the e-mail body.  $message['body'] = is_array($message['body']) ? drupal_wrap_mail(implode("\n\n", $message['body'])) : drupal_wrap_mail($message['body']);  // Optionally send e-mail.  if ($send) {    $message['result'] = drupal_mail_send($message);    // Log errors    if (!$message['result']) {      watchdog('mail', 'Error sending e-mail (from %from to %to).', array('%from' => $message['from'], '%to' => $message['to']), WATCHDOG_ERROR);      drupal_set_message(t('Unable to send e-mail. Please contact the site administrator if the problem persists.'), 'error');    }  }  return $message;}/** * Send an e-mail message, using Drupal variables and default settings. * More information in the <a href="http://php.net/manual/en/function.mail.php"> * PHP function reference for mail()</a>. See drupal_mail() for information on * how $message is composed. * * @param $message *  Message array with at least the following elements: *   - id *      A unique identifier of the e-mail type. Examples: 'contact_user_copy', *      'user_password_reset'. *   - to *      The mail address or addresses where the message will be sent to. The *      formatting of this string must comply with RFC 2822. Some examples are: *       user@example.com *       user@example.com, anotheruser@example.com *       User <user@example.com> *       User <user@example.com>, Another User <anotheruser@example.com> *   - subject *      Subject of the e-mail to be sent. This must not contain any newline *      characters, or the mail may not be sent properly. *   - body *      Message to be sent. Accepts both CRLF and LF line-endings. *      E-mail bodies must be wrapped. You can use drupal_wrap_mail() for *      smart plain text wrapping. *   - headers *      Associative array containing all mail headers. * @return *   Returns TRUE if the mail was successfully accepted for delivery, *   FALSE otherwise. */function drupal_mail_send($message) {  // Allow for a custom mail backend.  if (variable_get('smtp_library', '') && file_exists(variable_get('smtp_library', ''))) {    include_once './'. variable_get('smtp_library', '');    return drupal_mail_wrapper($message);  }  else {    $mimeheaders = array();    foreach ($message['headers'] as $name => $value) {      $mimeheaders[] = $name .': '. mime_header_encode($value);    }    return mail(      $message['to'],      mime_header_encode($message['subject']),      // Note: e-mail uses CRLF for line-endings, but PHP's API requires LF.      // They will appear correctly in the actual e-mail that is sent.      str_replace("\r", '', $message['body']),      // For headers, PHP's API suggests that we use CRLF normally,      // but some MTAs incorrecly replace LF with CRLF. See #234403.      join("\n", $mimeheaders)    );  }}/** * Perform format=flowed soft wrapping for mail (RFC 3676). * * We use delsp=yes wrapping, but only break non-spaced languages when * absolutely necessary to avoid compatibility issues. * * We deliberately use LF rather than CRLF, see drupal_mail(). * * @param $text *   The plain text to process. * @param $indent (optional) *   A string to indent the text with. Only '>' characters are repeated on *   subsequent wrapped lines. Others are replaced by spaces. */function drupal_wrap_mail($text, $indent = '') {  // Convert CRLF into LF.  $text = str_replace("\r", '', $text);  // See if soft-wrapping is allowed.  $clean_indent = _drupal_html_to_text_clean($indent);  $soft = strpos($clean_indent, ' ') === FALSE;  // Check if the string has line breaks.  if (strpos($text, "\n") !== FALSE) {    // Remove trailing spaces to make existing breaks hard.    $text = preg_replace('/ +\n/m', "\n", $text);    // Wrap each line at the needed width.    $lines = explode("\n", $text);    array_walk($lines, '_drupal_wrap_mail_line', array('soft' => $soft, 'length' => strlen($indent)));    $text = implode("\n", $lines);  }  else {    // Wrap this line.    _drupal_wrap_mail_line($text, 0, array('soft' => $soft, 'length' => strlen($indent)));  }  // Empty lines with nothing but spaces.  $text = preg_replace('/^ +\n/m', "\n", $text);  // Space-stuff special lines.  $text = preg_replace('/^(>| |From)/m', ' $1', $text);  // Apply indentation. We only include non-'>' indentation on the first line.  $text = $indent . substr(preg_replace('/^/m', $clean_indent, $text), strlen($indent));  return $text;}/** * Transform an HTML string into plain text, preserving the structure of the * markup. Useful for preparing the body of a node to be sent by e-mail. * * The output will be suitable for use as 'format=flowed; delsp=yes' text * (RFC 3676) and can be passed directly to drupal_mail() for sending. * * We deliberately use LF rather than CRLF, see drupal_mail(). * * This function provides suitable alternatives for the following tags: * <a> <em> <i> <strong> <b> <br> <p> <blockquote> <ul> <ol> <li> <dl> <dt> * <dd> <h1> <h2> <h3> <h4> <h5> <h6> <hr> * * @param $string *   The string to be transformed. * @param $allowed_tags (optional) *   If supplied, a list of tags that will be transformed. If omitted, all *   all supported tags are transformed. * @return *   The transformed string. */function drupal_html_to_text($string, $allowed_tags = NULL) {  // Cache list of supported tags.  static $supported_tags;  if (empty($supported_tags)) {    $supported_tags = array('a', 'em', 'i', 'strong', 'b', 'br', 'p', 'blockquote', 'ul', 'ol', 'li', 'dl', 'dt', 'dd', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr');  }  // Make sure only supported tags are kept.  $allowed_tags = isset($allowed_tags) ? array_intersect($supported_tags, $allowed_tags) : $supported_tags;  // Make sure tags, entities and attributes are well-formed and properly nested.  $string = _filter_htmlcorrector(filter_xss($string, $allowed_tags));  // Apply inline styles.  $string = preg_replace('!</?(em|i)((?> +)[^>]*)?>!i', '/', $string);  $string = preg_replace('!</?(strong|b)((?> +)[^>]*)?>!i', '*', $string);  // Replace inline <a> tags with the text of link and a footnote.  // 'See <a href="http://drupal.org">the Drupal site</a>' becomes  // 'See the Drupal site [1]' with the URL included as a footnote.  _drupal_html_to_mail_urls(NULL, TRUE);  $pattern = '@(<a[^>]+?href="([^"]*)"[^>]*?>(.+?)</a>)@i';  $string = preg_replace_callback($pattern, '_drupal_html_to_mail_urls', $string);  $urls = _drupal_html_to_mail_urls();  $footnotes = '';  if (count($urls)) {    $footnotes .= "\n";    for ($i = 0, $max = count($urls); $i < $max; $i++) {      $footnotes .= '['. ($i + 1) .'] '. $urls[$i] ."\n";    }  }  // Split tags from text.  $split = preg_split('/<([^>]+?)>/', $string, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting $null as required).  $tag = FALSE; // Odd/even counter (tag or no tag)  $casing = NULL; // Case conversion function  $output = '';  $indent = array(); // All current indentation string chunks  $lists = array(); // Array of counters for opened lists  foreach ($split as $value) {    $chunk = NULL; // Holds a string ready to be formatted and output.    // Process HTML tags (but don't output any literally).    if ($tag) {      list($tagname) = explode(' ', strtolower($value), 2);      switch ($tagname) {        // List counters        case 'ul':          array_unshift($lists, '*');          break;        case 'ol':          array_unshift($lists, 1);          break;        case '/ul':        case '/ol':          array_shift($lists);          $chunk = ''; // Ensure blank new-line.          break;        // Quotation/list markers, non-fancy headers        case 'blockquote':          // Format=flowed indentation cannot be mixed with lists.          $indent[] = count($lists) ? ' "' : '>';          break;        case 'li':          $indent[] = is_numeric($lists[0]) ? ' '. $lists[0]++ .') ' : ' * ';          break;        case 'dd':          $indent[] = '    ';          break;        case 'h3':          $indent[] = '.... ';          break;        case 'h4':          $indent[] = '.. ';          break;        case '/blockquote':          if (count($lists)) {            // Append closing quote for inline quotes (immediately).            $output = rtrim($output, "> \n") ."\"\n";            $chunk = ''; // Ensure blank new-line.          }          // Fall-through        case '/li':        case '/dd':          array_pop($indent);          break;        case '/h3':        case '/h4':          array_pop($indent);        case '/h5':        case '/h6':          $chunk = ''; // Ensure blank new-line.          break;        // Fancy headers        case 'h1':          $indent[] = '======== ';          $casing = 'drupal_strtoupper';          break;        case 'h2':          $indent[] = '-------- ';          $casing = 'drupal_strtoupper';          break;        case '/h1':        case '/h2':          $casing = NULL;          // Pad the line with dashes.          $output = _drupal_html_to_text_pad($output, ($tagname == '/h1') ? '=' : '-', ' ');          array_pop($indent);          $chunk = ''; // Ensure blank new-line.          break;        // Horizontal rulers        case 'hr':          // Insert immediately.          $output .= drupal_wrap_mail('', implode('', $indent)) ."\n";          $output = _drupal_html_to_text_pad($output, '-');          break;        // Paragraphs and definition lists        case '/p':        case '/dl':          $chunk = ''; // Ensure blank new-line.          break;      }    }    // Process blocks of text.    else {      // Convert inline HTML text to plain text.      $value = trim(preg_replace('/\s+/', ' ', decode_entities($value)));      if (strlen($value)) {        $chunk = $value;      }    }    // See if there is something waiting to be output.    if (isset($chunk)) {      // Apply any necessary case conversion.      if (isset($casing)) {        $chunk = $casing($chunk);      }      // Format it and apply the current indentation.      $output .= drupal_wrap_mail($chunk, implode('', $indent)) ."\n";      // Remove non-quotation markers from indentation.      $indent = array_map('_drupal_html_to_text_clean', $indent);    }    $tag = !$tag;  }  return $output . $footnotes;}/** * Helper function for array_walk in drupal_wrap_mail(). * * Wraps words on a single line. */function _drupal_wrap_mail_line(&$line, $key, $values) {  // Use soft-breaks only for purely quoted or unindented text.  $line = wordwrap($line, 77 - $values['length'], $values['soft'] ? "  \n" : "\n");  // Break really long words at the maximum width allowed.  $line = wordwrap($line, 996 - $values['length'], $values['soft'] ? " \n" : "\n");}/** * Helper function for drupal_html_to_text(). * * Keeps track of URLs and replaces them with placeholder tokens. */function _drupal_html_to_mail_urls($match = NULL, $reset = FALSE) {  global $base_url, $base_path;  static $urls = array(), $regexp;  if ($reset) {    // Reset internal URL list.    $urls = array();  }  else {    if (empty($regexp)) {      $regexp = '@^'. preg_quote($base_path, '@') .'@';    }    if ($match) {      list(, , $url, $label) = $match;      // Ensure all URLs are absolute.      $urls[] = strpos($url, '://') ? $url : preg_replace($regexp, $base_url .'/', $url);      return $label .' ['. count($urls) .']';    }  }  return $urls;}/** * Helper function for drupal_wrap_mail() and drupal_html_to_text(). * * Replace all non-quotation markers from a given piece of indentation with spaces. */function _drupal_html_to_text_clean($indent) {  return preg_replace('/[^>]/', ' ', $indent);}/** * Helper function for drupal_html_to_text(). * * Pad the last line with the given character. */function _drupal_html_to_text_pad($text, $pad, $prefix = '') {  // Remove last line break.  $text = substr($text, 0, -1);  // Calculate needed padding space and add it.  if (($p = strrpos($text, "\n")) === FALSE) {    $p = -1;  }  $n = max(0, 79 - (strlen($text) - $p));  // Add prefix and padding, and restore linebreak.  return $text . $prefix . str_repeat($pad, $n - strlen($prefix)) ."\n";}
<?php// $Id$/** * @file * API for handling file uploads and server file management. *//** * @defgroup file File interface * @{ * Common file handling functions. */define('FILE_DOWNLOADS_PUBLIC', 1);define('FILE_DOWNLOADS_PRIVATE', 2);define('FILE_CREATE_DIRECTORY', 1);define('FILE_MODIFY_PERMISSIONS', 2);define('FILE_EXISTS_RENAME', 0);define('FILE_EXISTS_REPLACE', 1);define('FILE_EXISTS_ERROR', 2);/** * A files status can be one of two values: temporary or permanent. The status * for each file Drupal manages is stored in the {files} tables. If the status * is temporary Drupal's file garbage collection will delete the file and * remove it from the files table after a set period of time. * * If you wish to add custom statuses for use by contrib modules please expand as * binary flags and consider the first 8 bits reserved. (0,1,2,4,8,16,32,64,128) */define('FILE_STATUS_TEMPORARY', 0);define('FILE_STATUS_PERMANENT', 1);/** * Create the download path to a file. * * @param $path A string containing the path of the file to generate URL for. * @return A string containing a URL that can be used to download the file. */function file_create_url($path) {  // Strip file_directory_path from $path. We only include relative paths in urls.  if (strpos($path, file_directory_path() .'/') === 0) {    $path = trim(substr($path, strlen(file_directory_path())), '\\/');  }  switch (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC)) {    case FILE_DOWNLOADS_PUBLIC:      return $GLOBALS['base_url'] .'/'. file_directory_path() .'/'. str_replace('\\', '/', $path);    case FILE_DOWNLOADS_PRIVATE:      return url('system/files/'. $path, array('absolute' => TRUE));  }}/** * Make sure the destination is a complete path and resides in the file system * directory, if it is not prepend the file system directory. * * @param $dest A string containing the path to verify. If this value is *   omitted, Drupal's 'files' directory will be used. * @return A string containing the path to file, with file system directory *   appended if necessary, or FALSE if the path is invalid (i.e. outside the *   configured 'files' or temp directories). */function file_create_path($dest = 0) {  $file_path = file_directory_path();  if (!$dest) {    return $file_path;  }  // file_check_location() checks whether the destination is inside the Drupal files directory.  if (file_check_location($dest, $file_path)) {    return $dest;  }  // check if the destination is instead inside the Drupal temporary files directory.  else if (file_check_location($dest, file_directory_temp())) {    return $dest;  }  // Not found, try again with prefixed directory path.  else if (file_check_location($file_path .'/'. $dest, $file_path)) {    return $file_path .'/'. $dest;  }  // File not found.  return FALSE;}/** * Check that the directory exists and is writable. Directories need to * have execute permissions to be considered a directory by FTP servers, etc. * * @param $directory A string containing the name of a directory path. * @param $mode A Boolean value to indicate if the directory should be created *   if it does not exist or made writable if it is read-only. * @param $form_item An optional string containing the name of a form item that *   any errors will be attached to. This is useful for settings forms that *   require the user to specify a writable directory. If it can't be made to *   work, a form error will be set preventing them from saving the settings. * @return FALSE when directory not found, or TRUE when directory exists. */function file_check_directory(&$directory, $mode = 0, $form_item = NULL) {  $directory = rtrim($directory, '/\\');  // Check if directory exists.  if (!is_dir($directory)) {    if (($mode & FILE_CREATE_DIRECTORY) && @mkdir($directory)) {      drupal_set_message(t('The directory %directory has been created.', array('%directory' => $directory)));      @chmod($directory, 0775); // Necessary for non-webserver users.    }    else {      if ($form_item) {        form_set_error($form_item, t('The directory %directory does not exist.', array('%directory' => $directory)));      }      return FALSE;    }  }  // Check to see if the directory is writable.  if (!is_writable($directory)) {    if (($mode & FILE_MODIFY_PERMISSIONS) && @chmod($directory, 0775)) {      drupal_set_message(t('The permissions of directory %directory have been changed to make it writable.', array('%directory' => $directory)));    }    else {      form_set_error($form_item, t('The directory %directory is not writable', array('%directory' => $directory)));      watchdog('file system', 'The directory %directory is not writable, because it does not have the correct permissions set.', array('%directory' => $directory), WATCHDOG_ERROR);      return FALSE;    }  }  if ((file_directory_path() == $directory || file_directory_temp() == $directory) && !is_file("$directory/.htaccess")) {    $htaccess_lines = "SetHandler Drupal_Security_Do_Not_Remove_See_SA_2006_006\nOptions None\nOptions +FollowSymLinks";    if (($fp = fopen("$directory/.htaccess", 'w')) && fputs($fp, $htaccess_lines)) {      fclose($fp);      chmod($directory .'/.htaccess', 0664);    }    else {      $variables = array('%directory' => $directory, '!htaccess' => '<br />'. nl2br(check_plain($htaccess_lines)));      form_set_error($form_item, t("Security warning: Couldn't write .htaccess file. Please create a .htaccess file in your %directory directory which contains the following lines: <code>!htaccess</code>", $variables));      watchdog('security', "Security warning: Couldn't write .htaccess file. Please create a .htaccess file in your %directory directory which contains the following lines: <code>!htaccess</code>", $variables, WATCHDOG_ERROR);    }  }  return TRUE;}/** * Checks path to see if it is a directory, or a dir/file. * * @param $path A string containing a file path. This will be set to the *   directory's path. * @return If the directory is not in a Drupal writable directory, FALSE is *   returned. Otherwise, the base name of the path is returned. */function file_check_path(&$path) {  // Check if path is a directory.  if (file_check_directory($path)) {    return '';  }  // Check if path is a possible dir/file.  $filename = basename($path);  $path = dirname($path);  if (file_check_directory($path)) {    return $filename;  }  return FALSE;}/** * Check if a file is really located inside $directory. Should be used to make * sure a file specified is really located within the directory to prevent * exploits. * * @code *   // Returns FALSE: *   file_check_location('/www/example.com/files/../../../etc/passwd', '/www/example.com/files'); * @endcode * * @param $source A string set to the file to check. * @param $directory A string where the file should be located. * @return 0 for invalid path or the real path of the source. */function file_check_location($source, $directory = '') {  $check = realpath($source);  if ($check) {    $source = $check;  }  else {    // This file does not yet exist    $source = realpath(dirname($source)) .'/'. basename($source);  }  $directory = realpath($directory);  if ($directory && strpos($source, $directory) !== 0) {    return 0;  }  return $source;}/** * Copies a file to a new location. This is a powerful function that in many ways * performs like an advanced version of copy(). * - Checks if $source and $dest are valid and readable/writable. * - Performs a file copy if $source is not equal to $dest. * - If file already exists in $dest either the call will error out, replace the *   file or rename the file based on the $replace parameter. * * @param $source A string specifying the file location of the original file. *   This parameter will contain the resulting destination filename in case of *   success. * @param $dest A string containing the directory $source should be copied to. *   If this value is omitted, Drupal's 'files' directory will be used. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return True for success, FALSE for failure. */function file_copy(&$source, $dest = 0, $replace = FILE_EXISTS_RENAME) {  $dest = file_create_path($dest);  $directory = $dest;  $basename = file_check_path($directory);  // Make sure we at least have a valid directory.  if ($basename === FALSE) {    $source = is_object($source) ? $source->filepath : $source;    drupal_set_message(t('The selected file %file could not be uploaded, because the destination %directory is not properly configured.', array('%file' => $source, '%directory' => $dest)), 'error');    watchdog('file system', 'The selected file %file could not be uploaded, because the destination %directory could not be found, or because its permissions do not allow the file to be written.', array('%file' => $source, '%directory' => $dest), WATCHDOG_ERROR);    return 0;  }  // Process a file upload object.  if (is_object($source)) {    $file = $source;    $source = $file->filepath;    if (!$basename) {      $basename = $file->filename;    }  }  $source = realpath($source);  if (!file_exists($source)) {    drupal_set_message(t('The selected file %file could not be copied, because no file by that name exists. Please check that you supplied the correct filename.', array('%file' => $source)), 'error');    return 0;  }  // If the destination file is not specified then use the filename of the source file.  $basename = $basename ? $basename : basename($source);  $dest = $directory .'/'. $basename;  // Make sure source and destination filenames are not the same, makes no sense  // to copy it if they are. In fact copying the file will most likely result in  // a 0 byte file. Which is bad. Real bad.  if ($source != realpath($dest)) {    if (!$dest = file_destination($dest, $replace)) {      drupal_set_message(t('The selected file %file could not be copied, because a file by that name already exists in the destination.', array('%file' => $source)), 'error');      return FALSE;    }    if (!@copy($source, $dest)) {      drupal_set_message(t('The selected file %file could not be copied.', array('%file' => $source)), 'error');      return 0;    }    // Give everyone read access so that FTP'd users or    // non-webserver users can see/read these files,    // and give group write permissions so group members    // can alter files uploaded by the webserver.    @chmod($dest, 0664);  }  if (isset($file) && is_object($file)) {    $file->filename = $basename;    $file->filepath = $dest;    $source = $file;  }  else {    $source = $dest;  }  return 1; // Everything went ok.}/** * Determines the destination path for a file depending on how replacement of * existing files should be handled. * * @param $destination A string specifying the desired path. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is *     unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return The destination file path or FALSE if the file already exists and *   FILE_EXISTS_ERROR was specified. */function file_destination($destination, $replace) {  if (file_exists($destination)) {    switch ($replace) {      case FILE_EXISTS_RENAME:        $basename = basename($destination);        $directory = dirname($destination);        $destination = file_create_filename($basename, $directory);        break;      case FILE_EXISTS_ERROR:        drupal_set_message(t('The selected file %file could not be copied, because a file by that name already exists in the destination.', array('%file' => $destination)), 'error');        return FALSE;    }  }  return $destination;}/** * Moves a file to a new location. * - Checks if $source and $dest are valid and readable/writable. * - Performs a file move if $source is not equal to $dest. * - If file already exists in $dest either the call will error out, replace the *   file or rename the file based on the $replace parameter. * * @param $source A string specifying the file location of the original file. *   This parameter will contain the resulting destination filename in case of *   success. * @param $dest A string containing the directory $source should be copied to. *   If this value is omitted, Drupal's 'files' directory will be used. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return True for success, FALSE for failure. */function file_move(&$source, $dest = 0, $replace = FILE_EXISTS_RENAME) {  $path_original = is_object($source) ? $source->filepath : $source;  if (file_copy($source, $dest, $replace)) {    $path_current = is_object($source) ? $source->filepath : $source;    if ($path_original == $path_current || file_delete($path_original)) {      return 1;    }    drupal_set_message(t('The removal of the original file %file has failed.', array('%file' => $path_original)), 'error');  }  return 0;}/** * Modify a filename as needed for security purposes. * * Dangerous file names will be altered; for instance, the file name * "exploit.php.pps" will become "exploit.php_.pps". All extensions that are * between 2 and 5 characters in length, internal to the file name, and not * included in $extensions will be altered by adding an underscore. If variable * 'allow_insecure_uploads' evaluates to TRUE, no alterations will be made. * * @param $filename *   File name to modify. * @param $extensions *   A space-separated list of extensions that should not be altered. * @param $alerts *   If TRUE, drupal_set_message() will be called to display a message if the *   file name was changed. * * @return *   The potentially modified $filename. */function file_munge_filename($filename, $extensions, $alerts = TRUE) {  $original = $filename;  // Allow potentially insecure uploads for very savvy users and admin  if (!variable_get('allow_insecure_uploads', 0)) {    $whitelist = array_unique(explode(' ', trim($extensions)));    // Split the filename up by periods. The first part becomes the basename    // the last part the final extension.    $filename_parts = explode('.', $filename);    $new_filename = array_shift($filename_parts); // Remove file basename.    $final_extension = array_pop($filename_parts); // Remove final extension.    // Loop through the middle parts of the name and add an underscore to the    // end of each section that could be a file extension but isn't in the list    // of allowed extensions.    foreach ($filename_parts as $filename_part) {      $new_filename .= '.'. $filename_part;      if (!in_array($filename_part, $whitelist) && preg_match("/^[a-zA-Z]{2,5}\d?$/", $filename_part)) {        $new_filename .= '_';      }    }    $filename = $new_filename .'.'. $final_extension;    if ($alerts && $original != $filename) {      drupal_set_message(t('For security reasons, your upload has been renamed to %filename.', array('%filename' => $filename)));    }  }  return $filename;}/** * Undo the effect of upload_munge_filename(). * * @param $filename string filename * @return string */function file_unmunge_filename($filename) {  return str_replace('_.', '.', $filename);}/** * Create a full file path from a directory and filename. If a file with the * specified name already exists, an alternative will be used. * * @param $basename string filename * @param $directory string directory * @return */function file_create_filename($basename, $directory) {  $dest = $directory .'/'. $basename;  if (file_exists($dest)) {    // Destination file already exists, generate an alternative.    if ($pos = strrpos($basename, '.')) {      $name = substr($basename, 0, $pos);      $ext = substr($basename, $pos);    }    else {      $name = $basename;    }    $counter = 0;    do {      $dest = $directory .'/'. $name .'_'. $counter++ . $ext;    } while (file_exists($dest));  }  return $dest;}/** * Delete a file. * * @param $path A string containing a file path. * @return TRUE for success, FALSE for failure. */function file_delete($path) {  if (is_file($path)) {    return unlink($path);  }}/** * Determine total disk space used by a single user or the whole filesystem. * * @param $uid *   An optional user id. A NULL value returns the total space used *   by all files. */function file_space_used($uid = NULL) {  if (isset($uid)) {    return (int) db_result(db_query('SELECT SUM(filesize) FROM {files} WHERE uid = %d', $uid));  }  return (int) db_result(db_query('SELECT SUM(filesize) FROM {files}'));}/** * Saves a file upload to a new location. The source file is validated as a * proper upload and handled as such. * * The file will be added to the files table as a temporary file. Temporary files * are periodically cleaned. To make the file permanent file call * file_set_status() to change its status. * * @param $source *   A string specifying the name of the upload field to save. * @param $validators *   An optional, associative array of callback functions used to validate the *   file. The keys are function names and the values arrays of callback *   parameters which will be passed in after the file object. The *   functions should return an array of error messages; an empty array *   indicates that the file passed validation. The functions will be called in *   the order specified. * @param $dest *   A string containing the directory $source should be copied to. If this is *   not provided or is not writable, the temporary directory will be used. * @param $replace *   A boolean indicating whether an existing file of the same name in the *   destination directory should overwritten. A false value will generate a *   new, unique filename in the destination directory. * @return *   An object containing the file information, or 0 in the event of an error. */function file_save_upload($source, $validators = array(), $dest = FALSE, $replace = FILE_EXISTS_RENAME) {  global $user;  static $upload_cache;  // Add in our check of the the file name length.  $validators['file_validate_name_length'] = array();  // Return cached objects without processing since the file will have  // already been processed and the paths in _FILES will be invalid.  if (isset($upload_cache[$source])) {    return $upload_cache[$source];  }  // If a file was uploaded, process it.  if (isset($_FILES['files']) && $_FILES['files']['name'][$source] && is_uploaded_file($_FILES['files']['tmp_name'][$source])) {    // Check for file upload errors and return FALSE if a    // lower level system error occurred.    switch ($_FILES['files']['error'][$source]) {      // @see http://php.net/manual/en/features.file-upload.errors.php      case UPLOAD_ERR_OK:        break;      case UPLOAD_ERR_INI_SIZE:      case UPLOAD_ERR_FORM_SIZE:        drupal_set_message(t('The file %file could not be saved, because it exceeds %maxsize, the maximum allowed size for uploads.', array('%file' => $source, '%maxsize' => format_size(file_upload_max_size()))), 'error');        return 0;      case UPLOAD_ERR_PARTIAL:      case UPLOAD_ERR_NO_FILE:        drupal_set_message(t('The file %file could not be saved, because the upload did not complete.', array('%file' => $source)), 'error');        return 0;        // Unknown error      default:        drupal_set_message(t('The file %file could not be saved. An unknown error has occurred.', array('%file' => $source)), 'error');        return 0;    }    // Build the list of non-munged extensions.    // @todo: this should not be here. we need to figure out the right place.    $extensions = '';    foreach ($user->roles as $rid => $name) {      $extensions .= ' '. variable_get("upload_extensions_$rid",      variable_get('upload_extensions_default', 'jpg jpeg gif png txt html doc xls pdf ppt pps odt ods odp'));    }    // Begin building file object.    $file = new stdClass();    $file->filename = file_munge_filename(trim(basename($_FILES['files']['name'][$source]), '.'), $extensions);    $file->filepath = $_FILES['files']['tmp_name'][$source];    $file->filemime = file_get_mimetype($file->filename);    // If the destination is not provided, or is not writable, then use the    // temporary directory.    if (empty($dest) || file_check_path($dest) === FALSE) {      $dest = file_directory_temp();    }    $file->source = $source;    $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), $replace);    $file->filesize = $_FILES['files']['size'][$source];    // Call the validation functions.    $errors = array();    foreach ($validators as $function => $args) {      array_unshift($args, $file);      // Make sure $file is passed around by reference.      $args[0] = &$file;      $errors = array_merge($errors, call_user_func_array($function, $args));    }    // Rename potentially executable files, to help prevent exploits.    if (preg_match('/\.(php|pl|py|cgi|asp|js)$/i', $file->filename) && (substr($file->filename, -4) != '.txt')) {            $file->filemime = 'text/plain';      $file->filepath .= '.txt';      $file->filename .= '.txt';      // As the file may be named example.php.txt, we need to munge again to      // convert to example.php_.txt, then create the correct destination.      $file->filename = file_munge_filename($file->filename, $extensions);      $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), $replace);    }    // Check for validation errors.    if (!empty($errors)) {      $message = t('The selected file %name could not be uploaded.', array('%name' => $file->filename));      if (count($errors) > 1) {        $message .= '<ul><li>'. implode('</li><li>', $errors) .'</li></ul>';      }      else {        $message .= ' '. array_pop($errors);      }      form_set_error($source, $message);      return 0;    }    // Move uploaded files from PHP's upload_tmp_dir to Drupal's temporary directory.    // This overcomes open_basedir restrictions for future file operations.    $file->filepath = $file->destination;    if (!move_uploaded_file($_FILES['files']['tmp_name'][$source], $file->filepath)) {      form_set_error($source, t('File upload error. Could not move uploaded file.'));      watchdog('file', 'Upload error. Could not move uploaded file %file to destination %destination.', array('%file' => $file->filename, '%destination' => $file->filepath));      return 0;    }    // If we made it this far it's safe to record this file in the database.    $file->uid = $user->uid;    $file->status = FILE_STATUS_TEMPORARY;    $file->timestamp = time();    drupal_write_record('files', $file);    // Add file to the cache.    $upload_cache[$source] = $file;    return $file;  }  return 0;}/** * Check for files with names longer than we can store in the database. * * @param $file *   A Drupal file object. * @return *   An array. If the file name is too long, it will contain an error message. */function file_validate_name_length($file) {  $errors = array();  if (strlen($file->filename) > 255) {    $errors[] = t('Its name exceeds the 255 characters limit. Please rename the file and try again.');  }  return $errors;}/** * Check that the filename ends with an allowed extension. This check is not * enforced for the user #1. * * @param $file *   A Drupal file object. * @param $extensions *   A string with a space separated * @return *   An array. If the file extension is not allowed, it will contain an error message. */function file_validate_extensions($file, $extensions) {  global $user;  $errors = array();  // Bypass validation for uid  = 1.  if ($user->uid != 1) {    $regex = '/\.('. ereg_replace(' +', '|', preg_quote($extensions)) .')$/i';    if (!preg_match($regex, $file->filename)) {      $errors[] = t('Only files with the following extensions are allowed: %files-allowed.', array('%files-allowed' => $extensions));    }  }  return $errors;}/** * Check that the file's size is below certain limits. This check is not * enforced for the user #1. * * @param $file *   A Drupal file object. * @param $file_limit *   An integer specifying the maximum file size in bytes. Zero indicates that *   no limit should be enforced. * @param $user_limit *   An integer specifying the maximum number of bytes the user is allowed. Zero *   indicates that no limit should be enforced. * @return *   An array. If the file size exceeds limits, it will contain an error message. */function file_validate_size($file, $file_limit = 0, $user_limit = 0) {  global $user;  $errors = array();  // Bypass validation for uid  = 1.  if ($user->uid != 1) {    if ($file_limit && $file->filesize > $file_limit) {      $errors[] = t('The file is %filesize exceeding the maximum file size of %maxsize.', array('%filesize' => format_size($file->filesize), '%maxsize' => format_size($file_limit)));    }    // Save a query by only calling file_space_used() when a limit is provided.    if ($user_limit && (file_space_used($user->uid) + $file->filesize) > $user_limit) {      $errors[] = t('The file is %filesize which would exceed your disk quota of %quota.', array('%filesize' => format_size($file->filesize), '%quota' => format_size($user_limit)));    }  }  return $errors;}/** * Check that the file is recognized by image_get_info() as an image. * * @param $file *   A Drupal file object. * @return *   An array. If the file is not an image, it will contain an error message. */function file_validate_is_image(&$file) {  $errors = array();  $info = image_get_info($file->filepath);  if (!$info || empty($info['extension'])) {    $errors[] = t('Only JPEG, PNG and GIF images are allowed.');  }  return $errors;}/** * If the file is an image verify that its dimensions are within the specified * maximum and minimum dimensions. Non-image files will be ignored. * * @param $file *   A Drupal file object. This function may resize the file affecting its size. * @param $maximum_dimensions *   An optional string in the form WIDTHxHEIGHT e.g. '640x480' or '85x85'. If *   an image toolkit is installed the image will be resized down to these *   dimensions. A value of 0 indicates no restriction on size, so resizing *   will be attempted. * @param $minimum_dimensions *   An optional string in the form WIDTHxHEIGHT. This will check that the image *   meets a minimum size. A value of 0 indicates no restriction. * @return *   An array. If the file is an image and did not meet the requirements, it *   will contain an error message. */function file_validate_image_resolution(&$file, $maximum_dimensions = 0, $minimum_dimensions = 0) {  $errors = array();  // Check first that the file is an image.  if ($info = image_get_info($file->filepath)) {    if ($maximum_dimensions) {      // Check that it is smaller than the given dimensions.      list($width, $height) = explode('x', $maximum_dimensions);      if ($info['width'] > $width || $info['height'] > $height) {        // Try to resize the image to fit the dimensions.        if (image_get_toolkit() && image_scale($file->filepath, $file->filepath, $width, $height)) {          drupal_set_message(t('The image was resized to fit within the maximum allowed dimensions of %dimensions pixels.', array('%dimensions' => $maximum_dimensions)));          // Clear the cached filesize and refresh the image information.          clearstatcache();          $info = image_get_info($file->filepath);          $file->filesize = $info['file_size'];        }        else {          $errors[] = t('The image is too large; the maximum dimensions are %dimensions pixels.', array('%dimensions' => $maximum_dimensions));        }      }    }    if ($minimum_dimensions) {      // Check that it is larger than the given dimensions.      list($width, $height) = explode('x', $minimum_dimensions);      if ($info['width'] < $width || $info['height'] < $height) {        $errors[] = t('The image is too small; the minimum dimensions are %dimensions pixels.', array('%dimensions' => $minimum_dimensions));      }    }  }  return $errors;}/** * Save a string to the specified destination. * * @param $data A string containing the contents of the file. * @param $dest A string containing the destination location. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * * @return A string containing the resulting filename or 0 on error */function file_save_data($data, $dest, $replace = FILE_EXISTS_RENAME) {  $temp = file_directory_temp();  // On Windows, tempnam() requires an absolute path, so we use realpath().  $file = tempnam(realpath($temp), 'file');  if (!$fp = fopen($file, 'wb')) {    drupal_set_message(t('The file could not be created.'), 'error');    return 0;  }  fwrite($fp, $data);  fclose($fp);  if (!file_move($file, $dest, $replace)) {    return 0;  }  return $file;}/** * Set the status of a file. * * @param file A Drupal file object * @param status A status value to set the file to. * @return FALSE on failure, TRUE on success and $file->status will contain the *     status. */function file_set_status(&$file, $status) {  if (db_query('UPDATE {files} SET status = %d WHERE fid = %d', $status, $file->fid)) {    $file->status = $status;    return TRUE;  }  return FALSE;}/** * Transfer file using http to client. Pipes a file through Drupal to the * client. * * @param $source File to transfer. * @param $headers An array of http headers to send along with file. */function file_transfer($source, $headers) {  if (ob_get_level()) {    ob_end_clean();  }  foreach ($headers as $header) {    // To prevent HTTP header injection, we delete new lines that are    // not followed by a space or a tab.    // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2    $header = preg_replace('/\r?\n(?!\t| )/', '', $header);    drupal_set_header($header);  }  $source = file_create_path($source);  // Transfer file in 1024 byte chunks to save memory usage.  if ($fd = fopen($source, 'rb')) {    while (!feof($fd)) {      print fread($fd, 1024);    }    fclose($fd);  }  else {    drupal_not_found();  }  exit();}/** * Call modules that implement hook_file_download() to find out if a file is * accessible and what headers it should be transferred with. If a module * returns -1 drupal_access_denied() will be returned. If one or more modules * returned headers the download will start with the returned headers. If no * modules respond drupal_not_found() will be returned. */function file_download() {  // Merge remainder of arguments from GET['q'], into relative file path.  $args = func_get_args();  $filepath = implode('/', $args);  // Maintain compatibility with old ?file=paths saved in node bodies.  if (isset($_GET['file'])) {    $filepath =  $_GET['file'];  }  if (file_exists(file_create_path($filepath))) {    $headers = module_invoke_all('file_download', $filepath);    if (in_array(-1, $headers)) {      return drupal_access_denied();    }    if (count($headers)) {      file_transfer($filepath, $headers);    }  }  return drupal_not_found();}/** * Finds all files that match a given mask in a given directory. * Directories and files beginning with a period are excluded; this * prevents hidden files and directories (such as SVN working directories) * from being scanned. * * @param $dir *   The base directory for the scan, without trailing slash. * @param $mask *   The regular expression of the files to find. * @param $nomask *   An array of files/directories to ignore. * @param $callback *   The callback function to call for each match. * @param $recurse *   When TRUE, the directory scan will recurse the entire tree *   starting at the provided directory. * @param $key *   The key to be used for the returned array of files. Possible *   values are "filename", for the path starting with $dir, *   "basename", for the basename of the file, and "name" for the name *   of the file without an extension. * @param $min_depth *   Minimum depth of directories to return files from. * @param $depth *   Current depth of recursion. This parameter is only used internally and should not be passed. * * @return *   An associative array (keyed on the provided key) of objects with *   "path", "basename", and "name" members corresponding to the *   matching files. */function file_scan_directory($dir, $mask, $nomask = array('.', '..', 'CVS'), $callback = 0, $recurse = TRUE, $key = 'filename', $min_depth = 0, $depth = 0) {  $key = (in_array($key, array('filename', 'basename', 'name')) ? $key : 'filename');  $files = array();  if (is_dir($dir) && $handle = opendir($dir)) {    while (FALSE !== ($file = readdir($handle))) {      if (!in_array($file, $nomask) && $file[0] != '.') {        if (is_dir("$dir/$file") && $recurse) {          // Give priority to files in this folder by merging them in after any subdirectory files.          $files = array_merge(file_scan_directory("$dir/$file", $mask, $nomask, $callback, $recurse, $key, $min_depth, $depth + 1), $files);        }        elseif ($depth >= $min_depth && ereg($mask, $file)) {          // Always use this match over anything already set in $files with the same $$key.          $filename = "$dir/$file";          $basename = basename($file);          $name = substr($basename, 0, strrpos($basename, '.'));          $files[$$key] = new stdClass();          $files[$$key]->filename = $filename;          $files[$$key]->basename = $basename;          $files[$$key]->name = $name;          if ($callback) {            $callback($filename);          }        }      }    }    closedir($handle);  }  return $files;}/** * Determine the default temporary directory. * * @return A string containing a temp directory. */function file_directory_temp() {  $temporary_directory = variable_get('file_directory_temp', NULL);  if (is_null($temporary_directory)) {    $directories = array();    // Has PHP been set with an upload_tmp_dir?    if (ini_get('upload_tmp_dir')) {      $directories[] = ini_get('upload_tmp_dir');    }    // Operating system specific dirs.    if (substr(PHP_OS, 0, 3) == 'WIN') {      $directories[] = 'c:\\windows\\temp';      $directories[] = 'c:\\winnt\\temp';      $path_delimiter = '\\';    }    else {      $directories[] = '/tmp';      $path_delimiter = '/';    }    foreach ($directories as $directory) {      if (!$temporary_directory && is_dir($directory)) {        $temporary_directory = $directory;      }    }    // if a directory has been found, use it, otherwise default to 'files/tmp' or 'files\\tmp';    $temporary_directory = $temporary_directory ? $temporary_directory : file_directory_path() . $path_delimiter .'tmp';    variable_set('file_directory_temp', $temporary_directory);  }  return $temporary_directory;}/** * Determine the default 'files' directory. * * @return A string containing the path to Drupal's 'files' directory. */function file_directory_path() {  return variable_get('file_directory_path', conf_path() .'/files');}/** * Determine the maximum file upload size by querying the PHP settings. * * @return *   A file size limit in bytes based on the PHP upload_max_filesize and post_max_size */function file_upload_max_size() {  static $max_size = -1;  if ($max_size < 0) {    $upload_max = parse_size(ini_get('upload_max_filesize'));    $post_max = parse_size(ini_get('post_max_size'));    $max_size = ($upload_max < $post_max) ? $upload_max : $post_max;  }  return $max_size;}/** * Determine an Internet Media Type, or MIME type from a filename. * * @param $filename *   Name of the file, including extension. * @param $mapping *   An optional array of extension to media type mappings in the form *   'extension1|extension2|...' => 'type'. * * @return *   The internet media type registered for the extension or application/octet-stream for unknown extensions. */function file_get_mimetype($filename, $mapping = NULL) {  if (!is_array($mapping)) {    $mapping = variable_get('mime_extension_mapping', array(      'ez' => 'application/andrew-inset',      'atom' => 'application/atom',      'atomcat' => 'application/atomcat+xml',      'atomsrv' => 'application/atomserv+xml',      'cap|pcap' => 'application/cap',      'cu' => 'application/cu-seeme',      'tsp' => 'application/dsptype',      'spl' => 'application/x-futuresplash',      'hta' => 'application/hta',      'jar' => 'application/java-archive',      'ser' => 'application/java-serialized-object',      'class' => 'application/java-vm',      'hqx' => 'application/mac-binhex40',      'cpt' => 'image/x-corelphotopaint',      'nb' => 'application/mathematica',      'mdb' => 'application/msaccess',      'doc|dot' => 'application/msword',      'bin' => 'application/octet-stream',      'oda' => 'application/oda',      'ogg|ogx' => 'application/ogg',      'pdf' => 'application/pdf',      'key' => 'application/pgp-keys',      'pgp' => 'application/pgp-signature',      'prf' => 'application/pics-rules',      'ps|ai|eps' => 'application/postscript',      'rar' => 'application/rar',      'rdf' => 'application/rdf+xml',      'rss' => 'application/rss+xml',      'rtf' => 'application/rtf',      'smi|smil' => 'application/smil',      'wpd' => 'application/wordperfect',      'wp5' => 'application/wordperfect5.1',      'xhtml|xht' => 'application/xhtml+xml',      'xml|xsl' => 'application/xml',      'zip' => 'application/zip',      'cdy' => 'application/vnd.cinderella',      'kml' => 'application/vnd.google-earth.kml+xml',      'kmz' => 'application/vnd.google-earth.kmz',      'xul' => 'application/vnd.mozilla.xul+xml',      'xls|xlb|xlt' => 'application/vnd.ms-excel',      'cat' => 'application/vnd.ms-pki.seccat',      'stl' => 'application/vnd.ms-pki.stl',      'ppt|pps' => 'application/vnd.ms-powerpoint',      'odc' => 'application/vnd.oasis.opendocument.chart',      'odb' => 'application/vnd.oasis.opendocument.database',      'odf' => 'application/vnd.oasis.opendocument.formula',      'odg' => 'application/vnd.oasis.opendocument.graphics',      'otg' => 'application/vnd.oasis.opendocument.graphics-template',      'odi' => 'application/vnd.oasis.opendocument.image',      'odp' => 'application/vnd.oasis.opendocument.presentation',      'otp' => 'application/vnd.oasis.opendocument.presentation-template',      'ods' => 'application/vnd.oasis.opendocument.spreadsheet',      'ots' => 'application/vnd.oasis.opendocument.spreadsheet-template',      'odt' => 'application/vnd.oasis.opendocument.text',      'odm' => 'application/vnd.oasis.opendocument.text-master',      'ott' => 'application/vnd.oasis.opendocument.text-template',      'oth' => 'application/vnd.oasis.opendocument.text-web',      'docm' => 'application/vnd.ms-word.document.macroEnabled.12',      'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',      'dotm' => 'application/vnd.ms-word.template.macroEnabled.12',      'dotx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',      'potm' => 'application/vnd.ms-powerpoint.template.macroEnabled.12',      'potx' => 'application/vnd.openxmlformats-officedocument.presentationml.template',      'ppam' => 'application/vnd.ms-powerpoint.addin.macroEnabled.12',      'ppsm' => 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',      'ppsx' => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',      'pptm' => 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',      'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',      'xlam' => 'application/vnd.ms-excel.addin.macroEnabled.12',      'xlsb' => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',      'xlsm' => 'application/vnd.ms-excel.sheet.macroEnabled.12',      'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',      'xltm' => 'application/vnd.ms-excel.template.macroEnabled.12',      'xltx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',      'cod' => 'application/vnd.rim.cod',      'mmf' => 'application/vnd.smaf',      'sdc' => 'application/vnd.stardivision.calc',      'sds' => 'application/vnd.stardivision.chart',      'sda' => 'application/vnd.stardivision.draw',      'sdd' => 'application/vnd.stardivision.impress',      'sdf' => 'application/vnd.stardivision.math',      'sdw' => 'application/vnd.stardivision.writer',      'sgl' => 'application/vnd.stardivision.writer-global',      'sxc' => 'application/vnd.sun.xml.calc',      'stc' => 'application/vnd.sun.xml.calc.template',      'sxd' => 'application/vnd.sun.xml.draw',      'std' => 'application/vnd.sun.xml.draw.template',      'sxi' => 'application/vnd.sun.xml.impress',      'sti' => 'application/vnd.sun.xml.impress.template',      'sxm' => 'application/vnd.sun.xml.math',      'sxw' => 'application/vnd.sun.xml.writer',      'sxg' => 'application/vnd.sun.xml.writer.global',      'stw' => 'application/vnd.sun.xml.writer.template',      'sis' => 'application/vnd.symbian.install',      'vsd' => 'application/vnd.visio',      'wbxml' => 'application/vnd.wap.wbxml',      'wmlc' => 'application/vnd.wap.wmlc',      'wmlsc' => 'application/vnd.wap.wmlscriptc',      'wk' => 'application/x-123',      '7z' => 'application/x-7z-compressed',      'abw' => 'application/x-abiword',      'dmg' => 'application/x-apple-diskimage',      'bcpio' => 'application/x-bcpio',      'torrent' => 'application/x-bittorrent',      'cab' => 'application/x-cab',      'cbr' => 'application/x-cbr',      'cbz' => 'application/x-cbz',      'cdf' => 'application/x-cdf',      'vcd' => 'application/x-cdlink',      'pgn' => 'application/x-chess-pgn',      'cpio' => 'application/x-cpio',      'csh' => 'text/x-csh',      'deb|udeb' => 'application/x-debian-package',      'dcr|dir|dxr' => 'application/x-director',      'dms' => 'application/x-dms',      'wad' => 'application/x-doom',      'dvi' => 'application/x-dvi',      'rhtml' => 'application/x-httpd-eruby',      'flac' => 'application/x-flac',      'pfa|pfb|gsf|pcf|pcf.Z' => 'application/x-font',      'mm' => 'application/x-freemind',      'gnumeric' => 'application/x-gnumeric',      'sgf' => 'application/x-go-sgf',      'gcf' => 'application/x-graphing-calculator',      'gtar|tgz|taz' => 'application/x-gtar',      'hdf' => 'application/x-hdf',      'phtml|pht|php' => 'application/x-httpd-php',      'phps' => 'application/x-httpd-php-source',      'php3' => 'application/x-httpd-php3',      'php3p' => 'application/x-httpd-php3-preprocessed',      'php4' => 'application/x-httpd-php4',      'ica' => 'application/x-ica',      'ins|isp' => 'application/x-internet-signup',      'iii' => 'application/x-iphone',      'iso' => 'application/x-iso9660-image',      'jnlp' => 'application/x-java-jnlp-file',      'js' => 'application/x-javascript',      'jmz' => 'application/x-jmol',      'chrt' => 'application/x-kchart',      'kil' => 'application/x-killustrator',      'skp|skd|skt|skm' => 'application/x-koan',      'kpr|kpt' => 'application/x-kpresenter',      'ksp' => 'application/x-kspread',      'kwd|kwt' => 'application/x-kword',      'latex' => 'application/x-latex',      'lha' => 'application/x-lha',      'lyx' => 'application/x-lyx',      'lzh' => 'application/x-lzh',      'lzx' => 'application/x-lzx',      'frm|maker|frame|fm|fb|book|fbdoc' => 'application/x-maker',      'mif' => 'application/x-mif',      'wmd' => 'application/x-ms-wmd',      'wmz' => 'application/x-ms-wmz',      'com|exe|bat|dll' => 'application/x-msdos-program',      'msi' => 'application/x-msi',      'nc' => 'application/x-netcdf',      'pac' => 'application/x-ns-proxy-autoconfig',      'nwc' => 'application/x-nwc',      'o' => 'application/x-object',      'oza' => 'application/x-oz-application',      'p7r' => 'application/x-pkcs7-certreqresp',      'crl' => 'application/x-pkcs7-crl',      'pyc|pyo' => 'application/x-python-code',      'qtl' => 'application/x-quicktimeplayer',      'rpm' => 'application/x-redhat-package-manager',      'sh' => 'text/x-sh',      'shar' => 'application/x-shar',      'swf|swfl' => 'application/x-shockwave-flash',      'sit|sitx' => 'application/x-stuffit',      'sv4cpio' => 'application/x-sv4cpio',      'sv4crc' => 'application/x-sv4crc',      'tar' => 'application/x-tar',      'tcl' => 'application/x-tcl',      'gf' => 'application/x-tex-gf',      'pk' => 'application/x-tex-pk',      'texinfo|texi' => 'application/x-texinfo',      '~|%|bak|old|sik' => 'application/x-trash',      't|tr|roff' => 'application/x-troff',      'man' => 'application/x-troff-man',      'me' => 'application/x-troff-me',      'ms' => 'application/x-troff-ms',      'ustar' => 'application/x-ustar',      'src' => 'application/x-wais-source',      'wz' => 'application/x-wingz',      'crt' => 'application/x-x509-ca-cert',      'xcf' => 'application/x-xcf',      'fig' => 'application/x-xfig',      'xpi' => 'application/x-xpinstall',      'au|snd' => 'audio/basic',      'mid|midi|kar' => 'audio/midi',      'mpga|mpega|mp2|mp3|m4a' => 'audio/mpeg',      'f4a|f4b' => 'audio/mp4',      'm3u' => 'audio/x-mpegurl',      'oga|spx' => 'audio/ogg',      'sid' => 'audio/prs.sid',      'aif|aiff|aifc' => 'audio/x-aiff',      'gsm' => 'audio/x-gsm',      'wma' => 'audio/x-ms-wma',      'wax' => 'audio/x-ms-wax',      'ra|rm|ram' => 'audio/x-pn-realaudio',      'ra' => 'audio/x-realaudio',      'pls' => 'audio/x-scpls',      'sd2' => 'audio/x-sd2',      'wav' => 'audio/x-wav',      'alc' => 'chemical/x-alchemy',      'cac|cache' => 'chemical/x-cache',      'csf' => 'chemical/x-cache-csf',      'cbin|cascii|ctab' => 'chemical/x-cactvs-binary',      'cdx' => 'chemical/x-cdx',      'cer' => 'chemical/x-cerius',      'c3d' => 'chemical/x-chem3d',      'chm' => 'chemical/x-chemdraw',      'cif' => 'chemical/x-cif',      'cmdf' => 'chemical/x-cmdf',      'cml' => 'chemical/x-cml',      'cpa' => 'chemical/x-compass',      'bsd' => 'chemical/x-crossfire',      'csml|csm' => 'chemical/x-csml',      'ctx' => 'chemical/x-ctx',      'cxf|cef' => 'chemical/x-cxf',      'emb|embl' => 'chemical/x-embl-dl-nucleotide',      'spc' => 'chemical/x-galactic-spc',      'inp|gam|gamin' => 'chemical/x-gamess-input',      'fch|fchk' => 'chemical/x-gaussian-checkpoint',      'cub' => 'chemical/x-gaussian-cube',      'gau|gjc|gjf' => 'chemical/x-gaussian-input',      'gal' => 'chemical/x-gaussian-log',      'gcg' => 'chemical/x-gcg8-sequence',      'gen' => 'chemical/x-genbank',      'hin' => 'chemical/x-hin',      'istr|ist' => 'chemical/x-isostar',      'jdx|dx' => 'chemical/x-jcamp-dx',      'kin' => 'chemical/x-kinemage',      'mcm' => 'chemical/x-macmolecule',      'mmd|mmod' => 'chemical/x-macromodel-input',      'mol' => 'chemical/x-mdl-molfile',      'rd' => 'chemical/x-mdl-rdfile',      'rxn' => 'chemical/x-mdl-rxnfile',      'sd|sdf' => 'chemical/x-mdl-sdfile',      'tgf' => 'chemical/x-mdl-tgf',      'mcif' => 'chemical/x-mmcif',      'mol2' => 'chemical/x-mol2',      'b' => 'chemical/x-molconn-Z',      'gpt' => 'chemical/x-mopac-graph',      'mop|mopcrt|mpc|dat|zmt' => 'chemical/x-mopac-input',      'moo' => 'chemical/x-mopac-out',      'mvb' => 'chemical/x-mopac-vib',      'asn' => 'chemical/x-ncbi-asn1-spec',      'prt|ent' => 'chemical/x-ncbi-asn1-ascii',      'val|aso' => 'chemical/x-ncbi-asn1-binary',      'pdb|ent' => 'chemical/x-pdb',      'ros' => 'chemical/x-rosdal',      'sw' => 'chemical/x-swissprot',      'vms' => 'chemical/x-vamas-iso14976',      'vmd' => 'chemical/x-vmd',      'xtel' => 'chemical/x-xtel',      'xyz' => 'chemical/x-xyz',      'gif' => 'image/gif',      'ief' => 'image/ief',      'jpeg|jpg|jpe' => 'image/jpeg',      'pcx' => 'image/pcx',      'png' => 'image/png',      'svg|svgz' => 'image/svg+xml',      'tiff|tif' => 'image/tiff',      'djvu|djv' => 'image/vnd.djvu',      'wbmp' => 'image/vnd.wap.wbmp',      'ras' => 'image/x-cmu-raster',      'cdr' => 'image/x-coreldraw',      'pat' => 'image/x-coreldrawpattern',      'cdt' => 'image/x-coreldrawtemplate',      'ico' => 'image/x-icon',      'art' => 'image/x-jg',      'jng' => 'image/x-jng',      'bmp' => 'image/x-ms-bmp',      'psd' => 'image/x-photoshop',      'pnm' => 'image/x-portable-anymap',      'pbm' => 'image/x-portable-bitmap',      'pgm' => 'image/x-portable-graymap',      'ppm' => 'image/x-portable-pixmap',      'rgb' => 'image/x-rgb',      'xbm' => 'image/x-xbitmap',      'xpm' => 'image/x-xpixmap',      'xwd' => 'image/x-xwindowdump',      'eml' => 'message/rfc822',      'igs|iges' => 'model/iges',      'msh|mesh|silo' => 'model/mesh',      'wrl|vrml' => 'model/vrml',      'ics|icz' => 'text/calendar',      'css' => 'text/css',      'csv' => 'text/csv',      '323' => 'text/h323',      'html|htm|shtml' => 'text/html',      'uls' => 'text/iuls',      'mml' => 'text/mathml',      'asc|txt|text|pot' => 'text/plain',      'rtx' => 'text/richtext',      'sct|wsc' => 'text/scriptlet',      'tm|ts' => 'text/texmacs',      'tsv' => 'text/tab-separated-values',      'jad' => 'text/vnd.sun.j2me.app-descriptor',      'wml' => 'text/vnd.wap.wml',      'wmls' => 'text/vnd.wap.wmlscript',      'bib' => 'text/x-bibtex',      'boo' => 'text/x-boo',      'h++|hpp|hxx|hh' => 'text/x-c++hdr',      'c++|cpp|cxx|cc' => 'text/x-c++src',      'h' => 'text/x-chdr',      'htc' => 'text/x-component',      'c' => 'text/x-csrc',      'd' => 'text/x-dsrc',      'diff|patch' => 'text/x-diff',      'hs' => 'text/x-haskell',      'java' => 'text/x-java',      'lhs' => 'text/x-literate-haskell',      'moc' => 'text/x-moc',      'p|pas' => 'text/x-pascal',      'gcd' => 'text/x-pcs-gcd',      'pl|pm' => 'text/x-perl',      'py' => 'text/x-python',      'etx' => 'text/x-setext',      'tcl|tk' => 'text/x-tcl',      'tex|ltx|sty|cls' => 'text/x-tex',      'vcs' => 'text/x-vcalendar',      'vcf' => 'text/x-vcard',      '3gp' => 'video/3gpp',      'dl' => 'video/dl',      'dif|dv' => 'video/dv',      'fli' => 'video/fli',      'gl' => 'video/gl',      'mpeg|mpg|mpe' => 'video/mpeg',      'mp4|f4v|f4p' => 'video/mp4',      'flv' => 'video/x-flv',      'ogv' => 'video/ogg',      'qt|mov' => 'video/quicktime',      'mxu' => 'video/vnd.mpegurl',      'lsf|lsx' => 'video/x-la-asf',      'mng' => 'video/x-mng',      'asf|asx' => 'video/x-ms-asf',      'wm' => 'video/x-ms-wm',      'wmv' => 'video/x-ms-wmv',      'wmx' => 'video/x-ms-wmx',      'wvx' => 'video/x-ms-wvx',      'avi' => 'video/x-msvideo',      'movie' => 'video/x-sgi-movie',      'ice' => 'x-conference/x-cooltalk',      'sisx' => 'x-epoc/x-sisx-app',      'vrm|vrml|wrl' => 'x-world/x-vrml',      'xps' => 'application/vnd.ms-xpsdocument',    ));  }  foreach ($mapping as $ext_preg => $mime_match) {    if (preg_match('!\.('. $ext_preg .')$!i', $filename)) {      return $mime_match;    }  }  return 'application/octet-stream';}/** * @} End of "defgroup file". */
<?php// $Id$/** * @file forum-topic-list.tpl.php * Theme implementation to display a list of forum topics. * * Available variables: * - $header: The table header. This is pre-generated with click-sorting *   information. If you need to change this, @see template_preprocess_forum_topic_list(). * - $pager: The pager to display beneath the table. * - $topics: An array of topics to be displayed. * - $topic_id: Numeric id for the current forum topic. * * Each $topic in $topics contains: * - $topic->icon: The icon to display. * - $topic->moved: A flag to indicate whether the topic has been moved to *   another forum. * - $topic->title: The title of the topic. Safe to output. * - $topic->message: If the topic has been moved, this contains an *   explanation and a link. * - $topic->zebra: 'even' or 'odd' string used for row class. * - $topic->num_comments: The number of replies on this topic. * - $topic->new_replies: A flag to indicate whether there are unread comments. * - $topic->new_url: If there are unread replies, this is a link to them. * - $topic->new_text: Text containing the translated, properly pluralized count. * - $topic->created: An outputtable string represented when the topic was posted. * - $topic->last_reply: An outputtable string representing when the topic was *   last replied to. * - $topic->timestamp: The raw timestamp this topic was posted. * * @see template_preprocess_forum_topic_list() * @see theme_forum_topic_list() */?><table id="forum-topic-<?php print $topic_id; ?>">  <thead>    <tr><?php print $header; ?></tr>  </thead>  <tbody>  <?php foreach ($topics as $topic): ?>    <tr class="<?php print $topic->zebra;?>">      <td class="icon"><?php print $topic->icon; ?></td>      <td class="title"><?php print $topic->title; ?></td>    <?php if ($topic->moved): ?>      <td colspan="3"><?php print $topic->message; ?></td>    <?php else: ?>      <td class="replies">        <?php print $topic->num_comments; ?>        <?php if ($topic->new_replies): ?>          <br />          <a href="<?php print $topic->new_url; ?>"><?php print $topic->new_text; ?></a>        <?php endif; ?>      </td>      <td class="created"><?php print $topic->created; ?></td>      <td class="last-reply"><?php print $topic->last_reply; ?></td>    <?php endif; ?>    </tr>  <?php endforeach; ?>  </tbody></table><?php print $pager; ?>
<?php// $Id$/** * Form API callback to validate the upload settings form. */function upload_admin_settings_validate($form, &$form_state) {  if (($form_state['values']['upload_max_resolution'] != '0')) {    if (!preg_match('/^[0-9]+x[0-9]+$/', $form_state['values']['upload_max_resolution'])) {      form_set_error('upload_max_resolution', t('The maximum allowed image size expressed as WIDTHxHEIGHT (e.g. 640x480). Set to 0 for no restriction.'));    }  }  $default_uploadsize = $form_state['values']['upload_uploadsize_default'];  $default_usersize = $form_state['values']['upload_usersize_default'];  $exceed_max_msg = t('Your PHP settings limit the maximum file size per upload to %size.', array('%size' => format_size(file_upload_max_size()))) .'<br/>';  $more_info = t("Depending on your server environment, these settings may be changed in the system-wide php.ini file, a php.ini file in your Drupal root directory, in your Drupal site's settings.php file, or in the .htaccess file in your Drupal root directory.");  if (!is_numeric($default_uploadsize) || ($default_uploadsize <= 0)) {    form_set_error('upload_uploadsize_default', t('The %role file size limit must be a number and greater than zero.', array('%role' => t('default'))));  }  if (!is_numeric($default_usersize) || ($default_usersize <= 0)) {    form_set_error('upload_usersize_default', t('The %role file size limit must be a number and greater than zero.', array('%role' => t('default'))));  }  if ($default_uploadsize * 1024 * 1024 > file_upload_max_size()) {    form_set_error('upload_uploadsize_default', $exceed_max_msg . $more_info);    $more_info = '';  }  if ($default_uploadsize > $default_usersize) {    form_set_error('upload_uploadsize_default', t('The %role maximum file size per upload is greater than the total file size allowed per user', array('%role' => t('default'))));  }  foreach ($form_state['values']['roles'] as $rid => $role) {    $uploadsize = $form_state['values']['upload_uploadsize_'. $rid];    $usersize = $form_state['values']['upload_usersize_'. $rid];    if (!is_numeric($uploadsize) || ($uploadsize <= 0)) {      form_set_error('upload_uploadsize_'. $rid, t('The %role file size limit must be a number and greater than zero.', array('%role' => $role)));    }    if (!is_numeric($usersize) || ($usersize <= 0)) {      form_set_error('upload_usersize_'. $rid, t('The %role file size limit must be a number and greater than zero.', array('%role' => $role)));    }    if ($uploadsize * 1024 * 1024 > file_upload_max_size()) {      form_set_error('upload_uploadsize_'. $rid, $exceed_max_msg . $more_info);      $more_info = '';    }    if ($uploadsize > $usersize) {      form_set_error('upload_uploadsize_'. $rid, t('The %role maximum file size per upload is greater than the total file size allowed per user', array('%role' => $role)));    }  }}/** * Menu callback for the upload settings form. */function upload_admin_settings() {  $upload_extensions_default = variable_get('upload_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp');  $upload_uploadsize_default = variable_get('upload_uploadsize_default', 1);  $upload_usersize_default = variable_get('upload_usersize_default', 1);  $form['settings_general'] = array(    '#type' => 'fieldset',    '#title' => t('General settings'),    '#collapsible' => TRUE,  );  $form['settings_general']['upload_max_resolution'] = array(    '#type' => 'textfield',    '#title' => t('Maximum resolution for uploaded images'),    '#default_value' => variable_get('upload_max_resolution', 0),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('The maximum allowed image size (e.g. 640x480). Set to 0 for no restriction. If an <a href="!image-toolkit-link">image toolkit</a> is installed, files exceeding this value will be scaled down to fit.', array('!image-toolkit-link' => url('admin/settings/image-toolkit'))),    '#field_suffix' => '<kbd>'. t('WIDTHxHEIGHT') .'</kbd>'  );  $form['settings_general']['upload_list_default'] = array(    '#type' => 'select',    '#title' => t('List files by default'),    '#default_value' => variable_get('upload_list_default', 1),    '#options' => array(0 => t('No'), 1 => t('Yes')),    '#description' => t('Display attached files when viewing a post.'),  );  $form['settings_general']['upload_extensions_default'] = array(    '#type' => 'textfield',    '#title' => t('Default permitted file extensions'),    '#default_value' => $upload_extensions_default,    '#maxlength' => 255,    '#description' => t('Default extensions that users can upload. Separate extensions with a space and do not include the leading dot.'),  );  $form['settings_general']['upload_uploadsize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default maximum file size per upload'),    '#default_value' => $upload_uploadsize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum file size a user can upload. If an image is uploaded and a maximum resolution is set, the size will be checked after the file has been resized.'),    '#field_suffix' => t('MB'),  );  $form['settings_general']['upload_usersize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default total file size per user'),    '#default_value' => $upload_usersize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum size of all files a user can have on the site.'),    '#field_suffix' => t('MB'),  );  $form['settings_general']['upload_max_size'] = array('#value' => '<p>'. t('Your PHP settings limit the maximum file size per upload to %size.', array('%size' => format_size(file_upload_max_size()))) .'</p>');  $roles = user_roles(FALSE, 'upload files');  $form['roles'] = array('#type' => 'value', '#value' => $roles);  foreach ($roles as $rid => $role) {    $form['settings_role_'. $rid] = array(      '#type' => 'fieldset',      '#title' => t('Settings for @role', array('@role' => $role)),      '#collapsible' => TRUE,      '#collapsed' => TRUE,    );    $form['settings_role_'. $rid]['upload_extensions_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Permitted file extensions'),      '#default_value' => variable_get('upload_extensions_'. $rid, $upload_extensions_default),      '#maxlength' => 255,      '#description' => t('Extensions that users in this role can upload. Separate extensions with a space and do not include the leading dot.'),    );    $form['settings_role_'. $rid]['upload_uploadsize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Maximum file size per upload'),      '#default_value' => variable_get('upload_uploadsize_'. $rid, $upload_uploadsize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of a file a user can upload. If an image is uploaded and a maximum resolution is set, the size will be checked after the file has been resized.'),      '#field_suffix' => t('MB'),    );    $form['settings_role_'. $rid]['upload_usersize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Total file size per user'),      '#default_value' => variable_get('upload_usersize_'. $rid, $upload_usersize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of all files a user can have on the site.'),      '#field_suffix' => t('MB'),    );  }  $form['#validate'] = array('upload_admin_settings_validate');  return system_settings_form($form);}
<?php// $Id$/** * Implementation of hook_install(). */function poll_install() {  // Create tables.  drupal_install_schema('poll');}/** * Implementation of hook_uninstall(). */function poll_uninstall() {  // Remove tables.  drupal_uninstall_schema('poll');}/** * Implementation of hook_schema(). */function poll_schema() {  $schema['poll'] = array(    'description' => 'Stores poll-specific information for poll nodes.',    'fields' => array(      'nid'     => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The poll's {node}.nid."        ),      'runtime' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The number of seconds past {node}.created during which the poll is open.'        ),      'active'  => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Boolean indicating whether or not the poll is open.',        ),      ),    'primary key' => array('nid'),    );  $schema['poll_choices'] = array(    'description' => 'Stores information about all choices for all {poll}s.',    'fields' => array(      'chid'    => array(        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'Unique identifier for a poll choice.',        ),      'nid'     => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid this choice belongs to.',        ),      'chtext'  => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'The text for this choice.',        ),      'chvotes' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The total number of votes this choice has received by all users.',        ),      'chorder' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The sort order of this choice among all choices for the same node.',        )      ),    'indexes' => array(      'nid' => array('nid')      ),    'primary key' => array('chid'),    );  $schema['poll_votes'] = array(    'description' => 'Stores per-{users} votes for each {poll}.',    'fields' => array(      'nid'      => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'The {poll} node this vote is for.',        ),      'uid'      => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {users}.uid this vote is from unless the voter was anonymous.',        ),      'chorder'  => array(        'type' => 'int',        'not null' => TRUE,        'default' => -1,        'description' => "The {users}'s vote for this poll.",        ),      'hostname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'The IP address this vote is from unless the voter was logged in.',        ),      ),    'primary key' => array('nid', 'uid', 'hostname'),    'indexes' => array(      'hostname' => array('hostname'),      'uid'      => array('uid'),      ),    );  return $schema;}
<?php// $Id$/** * @file * Admin page callbacks for the trigger module. *//** * Build the form that allows users to assign actions to hooks. * * @param $type *   Name of hook. * @return *   HTML form. */function trigger_assign($type = NULL) {  // If no type is specified we default to node actions, since they  // are the most common.  if (!isset($type)) {    drupal_goto('admin/build/trigger/node');  }  if ($type == 'node') {    $type = 'nodeapi';  }  $output = '';  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $hook) {    if (isset($hook[$type])) {      foreach ($hook[$type] as $op => $description) {        $form_id = 'trigger_'. $type .'_'. $op .'_assign_form';        $output .= drupal_get_form($form_id, $type, $op, $description['runs when']);      }    }  }  return $output;}/** * Confirm removal of an assigned action. * * @param $hook * @param $op * @param $aid *   The action ID. * @ingroup forms * @see trigger_unassign_submit() */function trigger_unassign($form_state, $hook = NULL, $op = NULL, $aid = NULL) {  if (!($hook && $op && $aid)) {    drupal_goto('admin/build/trigger/assign');  }  $form['hook'] = array(    '#type' => 'value',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'value',    '#value' => $op,  );  $form['aid'] = array(    '#type' => 'value',    '#value' => $aid,  );  $action = actions_function_lookup($aid);  $actions = actions_get_all_actions();  $destination = 'admin/build/trigger/'. ($hook == 'nodeapi' ? 'node' : $hook);  return confirm_form($form,    t('Are you sure you want to unassign the action %title?', array('%title' => $actions[$action]['description'])),    $destination,    t('You can assign it again later if you wish.'),    t('Unassign'), t('Cancel')  );}function trigger_unassign_submit($form, &$form_state) {  $form_values = $form_state['values'];  if ($form_values['confirm'] == 1) {    $aid = actions_function_lookup($form_values['aid']);    db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid);    $actions = actions_get_all_actions();    watchdog('actions', 'Action %action has been unassigned.',  array('%action' => check_plain($actions[$aid]['description'])));    drupal_set_message(t('Action %action has been unassigned.', array('%action' => $actions[$aid]['description'])));    $hook = $form_values['hook'] == 'nodeapi' ? 'node' : $form_values['hook'];    $form_state['redirect'] = 'admin/build/trigger/'. $hook;  }  else {    drupal_goto('admin/build/trigger');  }}/** * Create the form definition for assigning an action to a hook-op combination. * * @param $form_state *   Information about the current form. * @param $hook *   The name of the hook, e.g., 'nodeapi'. * @param $op *   The name of the hook operation, e.g., 'insert'. * @param $description *   A plain English description of what this hook operation does. * @return * * @ingoup forms * @see trigger_assign_form_validate() * @see trigger_assign_form_submit() */function trigger_assign_form($form_state, $hook, $op, $description) {  $form['hook'] = array(    '#type' => 'hidden',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'hidden',    '#value' => $op,  );  // All of these forms use the same validate and submit functions.  $form['#validate'][] = 'trigger_assign_form_validate';  $form['#submit'][] = 'trigger_assign_form_submit';  $options = array();  $functions = array();  // Restrict the options list to actions that declare support for this hook-op  // combination.  foreach (actions_list() as $func => $metadata) {    if (isset($metadata['hooks']['any']) || (isset($metadata['hooks'][$hook]) && is_array($metadata['hooks'][$hook]) && (in_array($op, $metadata['hooks'][$hook])))) {      $functions[] = $func;    }  }  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {    if (in_array($action['callback'], $functions)) {      $options[$action['type']][$aid] = $action['description'];    }  }  $form[$op] = array(    '#type' => 'fieldset',    '#title' => t('Trigger: ') . $description,    '#theme' => 'trigger_display'    );  // Retrieve actions that are already assigned to this hook-op combination.  $actions = _trigger_get_hook_actions($hook, $op);  $form[$op]['assigned']['#type'] = 'value';  $form[$op]['assigned']['#value'] = array();  foreach ($actions as $aid => $description) {    $form[$op]['assigned']['#value'][$aid] = array(      'description' => $description,      'link' => l(t('unassign'), "admin/build/trigger/unassign/$hook/$op/". md5($aid))    );  }  $form[$op]['parent'] = array(    '#prefix' => "<div class='container-inline'>",    '#suffix' => '</div>',  );  // List possible actions that may be assigned.  if (count($options) != 0) {    array_unshift($options, t('Choose an action'));    $form[$op]['parent']['aid'] = array(      '#type' => 'select',      '#options' => $options,    );    $form[$op]['parent']['submit'] = array(      '#type' => 'submit',      '#value' => t('Assign')    );  }  else {    $form[$op]['none'] = array(      '#value' => t('No available actions for this trigger.')    );  }  return $form;}/** * Validation function for trigger_assign_form(). * * Makes sure that the user is not re-assigning an action to an event. */function trigger_assign_form_validate($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    if (db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid))) {      form_set_error($form_values['operation'], t('The action you chose is already assigned to that trigger.'));    }  }}/** * Submit function for trigger_assign_form(). */function trigger_assign_form_submit($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    $weight = db_result(db_query("SELECT MAX(weight) FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s'", $form_values['hook'], $form_values['operation']));    db_query("INSERT INTO {trigger_assignments} values ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], $aid, $weight + 1);    // If this action changes a node property, we need to save the node    // so the change will persist.    $actions = actions_list();    if (isset($actions[$aid]['behavior']) && in_array('changes_node_property', $actions[$aid]['behavior']) && ($form_values['operation'] != 'presave')) {      // Delete previous node_save_action if it exists, and re-add a new one at a higher weight.      $save_post_action_assigned = db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']));      if ($save_post_action_assigned) {        db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']);      }      db_query("INSERT INTO {trigger_assignments} VALUES ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], 'node_save_action', $weight + 2);      if (!$save_post_action_assigned) {        drupal_set_message(t('You have added an action that changes a the property of a post. A Save post action has been added so that the property change will be saved.'));      }    }  }}/** * Display actions assigned to this hook-op combination in a table. * * @param array $element *   The fieldset including all assigned actions. * @return *   The rendered form with the table prepended. * * @ingroup themeable */function theme_trigger_display($element) {  $header = array();  $rows = array();  if (count($element['assigned']['#value'])) {    $header = array(array('data' => t('Name')), array('data' => t('Operation')));    $rows = array();    foreach ($element['assigned']['#value'] as $aid => $info) {      $rows[] = array(        $info['description'],        $info['link']      );    }  }  if (count($rows)) {    $output = theme('table', $header, $rows) . drupal_render($element);  }  else {    $output = drupal_render($element);  }  return $output;}/** * Get the actions that have already been defined for this * type-hook-op combination. * * @param $type *   One of 'node', 'user', 'comment'. * @param $hook *   The name of the hook for which actions have been assigned, *   e.g. 'nodeapi'. * @param $op *   The hook operation for which the actions have been assigned, *   e.g., 'view'. * @return *   An array of action descriptions keyed by action IDs. */function _trigger_get_hook_actions($hook, $op, $type = NULL) {  $actions = array();  if ($type) {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE a.type = '%s' AND h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $type, $hook, $op);  }  else {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $hook, $op);  }  while ($action = db_fetch_object($result)) {    $actions[$action->aid] = $action->description;  }  return $actions;}
<?php// $Id$/** * Implementation of hook_schema(). */function node_schema() {  $schema['node'] = array(    'description' => 'The base table for nodes.',    'fields' => array(      'nid' => array(        'description' => 'The primary identifier for a node.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'vid' => array(        'description' => 'The current {node_revisions}.vid version identifier.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'type' => array(        'description' => 'The {node_type}.type of this node.',        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => ''),      'language' => array(        'description' => 'The {languages}.language of this node.',        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => ''),      'title' => array(        'description' => 'The title of this node, always treated as non-markup plain text.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'uid' => array(        'description' => 'The {users}.uid that owns this node; initially, this is the user that created it.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'status' => array(        'description' => 'Boolean indicating whether the node is published (visible to non-administrators).',        'type' => 'int',        'not null' => TRUE,        'default' => 1),      'created' => array(        'description' => 'The Unix timestamp when the node was created.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'changed' => array(        'description' => 'The Unix timestamp when the node was most recently saved.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'comment' => array(        'description' => 'Whether comments are allowed on this node: 0 = no, 1 = read only, 2 = read/write.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'promote' => array(        'description' => 'Boolean indicating whether the node should be displayed on the front page.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'moderate' => array(        'description' => 'Previously, a boolean indicating whether the node was "in moderation"; mostly no longer used.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'sticky' => array(        'description' => 'Boolean indicating whether the node should be displayed at the top of lists in which it appears.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'tnid' => array(        'description' => 'The translation set id for this node, which equals the node id of the source post in each set.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'translate' => array(        'description' => 'A boolean indicating whether this translation page needs to be updated.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      ),    'indexes' => array(      'node_changed'        => array('changed'),      'node_created'        => array('created'),      'node_moderate'       => array('moderate'),      'node_promote_status' => array('promote', 'status'),      'node_status_type'    => array('status', 'type', 'nid'),      'node_title_type'     => array('title', array('type', 4)),      'node_type'           => array(array('type', 4)),      'uid'                 => array('uid'),      'tnid'                => array('tnid'),      'translate'           => array('translate'),      ),    'unique keys' => array(      'vid'     => array('vid')      ),    'primary key' => array('nid'),    );  $schema['node_access'] = array(    'description' => 'Identifies which realm/grant pairs a user must possess in order to view, update, or delete specific nodes.',    'fields' => array(      'nid' => array(        'description' => 'The {node}.nid this record affects.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'gid' => array(        'description' => "The grant ID a user must possess in the specified realm to gain this row's privileges on the node.",        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'realm' => array(        'description' => 'The realm in which the user must possess the grant ID. Each node access node can define one or more realms.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'grant_view' => array(        'description' => 'Boolean indicating whether a user with the realm/grant pair can view this node.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'grant_update' => array(        'description' => 'Boolean indicating whether a user with the realm/grant pair can edit this node.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'grant_delete' => array(        'description' => 'Boolean indicating whether a user with the realm/grant pair can delete this node.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny')      ),    'primary key' => array('nid', 'gid', 'realm'),    );  $schema['node_counter'] = array(    'description' => 'Access statistics for {node}s.',    'fields' => array(      'nid' => array(        'description' => 'The {node}.nid for these statistics.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'totalcount' => array(        'description' => 'The total number of times the {node} has been viewed.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'big'),      'daycount' => array(        'description' => 'The total number of times the {node} has been viewed today.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'medium'),      'timestamp' => array(        'description' => 'The most recent time the {node} has been viewed.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0)      ),    'primary key' => array('nid'),    );  $schema['node_revisions'] = array(    'description' => 'Stores information about each saved version of a {node}.',    'fields' => array(      'nid' => array(        'description' => 'The {node} this version belongs to.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'vid' => array(        'description' => 'The primary identifier for this version.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'uid' => array(        'description' => 'The {users}.uid that created this version.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'title' => array(        'description' => 'The title of this version.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'body' => array(        'description' => 'The body of this version.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'teaser' => array(        'description' => 'The teaser of this version.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'log' => array(        'description' => 'The log entry explaining the changes in this version.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'timestamp' => array(        'description' => 'A Unix timestamp indicating when this version was created.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'format' => array(        'description' => "The input format used by this version's body.",        'type' => 'int',        'not null' => TRUE,        'default' => 0)      ),    'indexes' => array(      'nid' => array('nid'),      'uid' => array('uid')      ),    'primary key' => array('vid'),    );  $schema['node_type'] = array(    'description' => 'Stores information about all defined {node} types.',    'fields' => array(      'type' => array(        'description' => 'The machine-readable name of this type.',        'type' => 'varchar',        'length' => 32,        'not null' => TRUE),      'name' => array(        'description' => 'The human-readable name of this type.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'module' => array(        'description' => 'The base string used to construct callbacks corresponding to this node type.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE),      'description'    => array(        'description' => 'A brief description of this type.',        'type' => 'text',        'not null' => TRUE,        'size' => 'medium'),      'help' => array(        'description' => 'Help information shown to the user when creating a {node} of this type.',        'type' => 'text',        'not null' => TRUE,        'size' => 'medium'),      'has_title' => array(        'description' => 'Boolean indicating whether this type uses the {node}.title field.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'size' => 'tiny'),      'title_label' => array(        'description' => 'The label displayed for the title field on the edit form.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'has_body' => array(        'description' => 'Boolean indicating whether this type uses the {node_revisions}.body field.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'size' => 'tiny'),      'body_label' => array(        'description' => 'The label displayed for the body field on the edit form.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'min_word_count' => array(        'description' => 'The minimum number of words the body must contain.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'size' => 'small'),      'custom' => array(        'description' => 'A boolean indicating whether this type is defined by a module (FALSE) or by a user via a module like the Content Construction Kit (TRUE).',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'modified' => array(        'description' => 'A boolean indicating whether this type has been modified by an administrator; currently not used in any way.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'locked' => array(        'description' => 'A boolean indicating whether the administrator can change the machine name of this type.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'orig_type' => array(        'description' => 'The original machine-readable name of this node type. This may be different from the current type name if the locked field is 0.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '')      ),    'primary key' => array('type'),    );  return $schema;}
<?php// $Id$/** * @file * API for loading and interacting with Drupal modules. *//** * Load all the modules that have been enabled in the system table. */function module_load_all() {  foreach (module_list(TRUE, FALSE) as $module) {    drupal_load('module', $module);  }}/** * Call a function repeatedly with each module in turn as an argument. */function module_iterate($function, $argument = '') {  foreach (module_list() as $name) {    $function($name, $argument);  }}/** * Collect a list of all loaded modules. During the bootstrap, return only * vital modules. See bootstrap.inc * * @param $refresh *   Whether to force the module list to be regenerated (such as after the *   administrator has changed the system settings). * @param $bootstrap *   Whether to return the reduced set of modules loaded in "bootstrap mode" *   for cached pages. See bootstrap.inc. * @param $sort *   By default, modules are ordered by weight and filename, settings this option *   to TRUE, module list will be ordered by module name. * @param $fixed_list *   (Optional) Override the module list with the given modules. Stays until the *   next call with $refresh = TRUE. * @return *   An associative array whose keys and values are the names of all loaded *   modules. */function module_list($refresh = FALSE, $bootstrap = TRUE, $sort = FALSE, $fixed_list = NULL) {  static $list, $sorted_list;  if ($refresh || $fixed_list) {    $list = array();    $sorted_list = NULL;    if ($fixed_list) {      foreach ($fixed_list as $name => $module) {        drupal_get_filename('module', $name, $module['filename']);        $list[$name] = $name;      }    }    else {      if ($bootstrap) {        $result = db_query("SELECT name, filename, throttle FROM {system} WHERE type = 'module' AND status = 1 AND bootstrap = 1 ORDER BY weight ASC, filename ASC");      }      else {        $result = db_query("SELECT name, filename, throttle FROM {system} WHERE type = 'module' AND status = 1 ORDER BY weight ASC, filename ASC");      }      while ($module = db_fetch_object($result)) {        if (file_exists($module->filename)) {          // Determine the current throttle status and see if the module should be          // loaded based on server load. We have to directly access the throttle          // variables, since throttle.module may not be loaded yet.          $throttle = ($module->throttle && variable_get('throttle_level', 0) > 0);          if (!$throttle) {            drupal_get_filename('module', $module->name, $module->filename);            $list[$module->name] = $module->name;          }        }      }    }  }  if ($sort) {    if (!isset($sorted_list)) {      $sorted_list = $list;      ksort($sorted_list);    }    return $sorted_list;  }  return $list;}/** * Rebuild the database cache of module files. * * @return *   The array of filesystem objects used to rebuild the cache. */function module_rebuild_cache() {  // Get current list of modules  $files = drupal_system_listing('\.module$', 'modules', 'name', 0);  // Extract current files from database.  system_get_files_database($files, 'module');  ksort($files);  // Set defaults for module info  $defaults = array(    'dependencies' => array(),    'dependents' => array(),    'description' => '',    'version' => NULL,    'php' => DRUPAL_MINIMUM_PHP,  );  foreach ($files as $filename => $file) {    // Look for the info file.    $file->info = drupal_parse_info_file(dirname($file->filename) .'/'. $file->name .'.info');    // Skip modules that don't provide info.    if (empty($file->info)) {      unset($files[$filename]);      continue;    }    // Merge in defaults and save.    $files[$filename]->info = $file->info + $defaults;    // Invoke hook_system_info_alter() to give installed modules a chance to    // modify the data in the .info files if necessary.    drupal_alter('system_info', $files[$filename]->info, $files[$filename]);    // Log the critical hooks implemented by this module.    $bootstrap = 0;    foreach (bootstrap_hooks() as $hook) {      if (module_hook($file->name, $hook)) {        $bootstrap = 1;        break;      }    }    // Update the contents of the system table:    if (isset($file->status) || (isset($file->old_filename) && $file->old_filename != $file->filename)) {      db_query("UPDATE {system} SET info = '%s', name = '%s', filename = '%s', bootstrap = %d WHERE filename = '%s'", serialize($files[$filename]->info), $file->name, $file->filename, $bootstrap, $file->old_filename);    }    else {      // This is a new module.      $files[$filename]->status = 0;      $files[$filename]->throttle = 0;      db_query("INSERT INTO {system} (name, info, type, filename, status, throttle, bootstrap) VALUES ('%s', '%s', '%s', '%s', %d, %d, %d)", $file->name, serialize($files[$filename]->info), 'module', $file->filename, 0, 0, $bootstrap);    }  }  $files = _module_build_dependencies($files);  return $files;}/** * Find dependencies any level deep and fill in dependents information too. * * If module A depends on B which in turn depends on C then this function will * add C to the list of modules A depends on. This will be repeated until * module A has a list of all modules it depends on. If it depends on itself, * called a circular dependency, that's marked by adding a nonexistent module, * called -circular- to this list of modules. Because this does not exist, * it'll be impossible to switch module A on. * * Also we fill in a dependents array in $file->info. Using the names above, * the dependents array of module B lists A. * * @param $files *   The array of filesystem objects used to rebuild the cache. * @return *   The same array with dependencies and dependents added where applicable. */function _module_build_dependencies($files) {  do {    $new_dependency = FALSE;    foreach ($files as $filename => $file) {      // We will modify this object (module A, see doxygen for module A, B, C).      $file = &$files[$filename];      if (isset($file->info['dependencies']) && is_array($file->info['dependencies'])) {        foreach ($file->info['dependencies'] as $dependency_name) {          // This is a nonexistent module.          if ($dependency_name == '-circular-' || !isset($files[$dependency_name])) {            continue;          }          // $dependency_name is module B (again, see doxygen).          $files[$dependency_name]->info['dependents'][$filename] = $filename;          $dependency = $files[$dependency_name];          if (isset($dependency->info['dependencies']) && is_array($dependency->info['dependencies'])) {            // Let's find possible C modules.            foreach ($dependency->info['dependencies'] as $candidate) {              if (array_search($candidate, $file->info['dependencies']) === FALSE) {                // Is this a circular dependency?                if ($candidate == $filename) {                  // As a module name can not contain dashes, this makes                  // impossible to switch on the module.                  $candidate = '-circular-';                  // Do not display the message or add -circular- more than once.                  if (array_search($candidate, $file->info['dependencies']) !== FALSE) {                    continue;                  }                  drupal_set_message(t('%module is part of a circular dependency. This is not supported and you will not be able to switch it on.', array('%module' => $file->info['name'])), 'error');                }                else {                  // We added a new dependency to module A. The next loop will                  // be able to use this as "B module" thus finding even                  // deeper dependencies.                  $new_dependency = TRUE;                }                $file->info['dependencies'][] = $candidate;              }            }          }        }      }      // Don't forget to break the reference.      unset($file);    }  } while ($new_dependency);  return $files;}/** * Determine whether a given module exists. * * @param $module *   The name of the module (without the .module extension). * @return *   TRUE if the module is both installed and enabled. */function module_exists($module) {  $list = module_list();  return array_key_exists($module, $list);}/** * Load a module's installation hooks. */function module_load_install($module) {  // Make sure the installation API is available  include_once './includes/install.inc';  module_load_include('install', $module);}/** * Load a module include file. *  * Examples: * @code *   // Load node.admin.inc from the node module. *   module_load_include('inc', 'node', 'node.admin'); *   // Load content_types.inc from the node module. *   module_load_include('inc', 'node', 'content_types');   * @endcode *  * Do not use this function to load an install file. Use module_load_install() * instead. * * @param $type *   The include file's type (file extension). * @param $module *   The module to which the include file belongs. * @param $name *   Optionally, specify the base file name (without the $type extension).  *   If not set, $module is used. */function module_load_include($type, $module, $name = NULL) {  if (empty($name)) {    $name = $module;  }  $file = './'. drupal_get_path('module', $module) ."/$name.$type";  if (is_file($file)) {    require_once $file;  }  else {    return FALSE;  }}/** * Load an include file for each of the modules that have been enabled in * the system table. */function module_load_all_includes($type, $name = NULL) {  $modules = module_list();  foreach ($modules as $module) {    module_load_include($type, $module, $name);  }}/** * Enable a given list of modules. * * @param $module_list *   An array of module names. */function module_enable($module_list) {  $invoke_modules = array();  foreach ($module_list as $module) {    $existing = db_fetch_object(db_query("SELECT status FROM {system} WHERE type = '%s' AND name = '%s'", 'module', $module));    if ($existing->status == 0) {      module_load_install($module);      db_query("UPDATE {system} SET status = %d, throttle = %d WHERE type = '%s' AND name = '%s'", 1, 0, 'module', $module);      drupal_load('module', $module);      $invoke_modules[] = $module;    }  }  if (!empty($invoke_modules)) {    // Refresh the module list to include the new enabled module.    module_list(TRUE, FALSE);    // Force to regenerate the stored list of hook implementations.    module_implements('', FALSE, TRUE);  }  foreach ($invoke_modules as $module) {    module_invoke($module, 'enable');    // Check if node_access table needs rebuilding.    // We check for the existence of node_access_needs_rebuild() since    // at install time, module_enable() could be called while node.module    // is not enabled yet.    if (function_exists('node_access_needs_rebuild') && !node_access_needs_rebuild() && module_hook($module, 'node_grants')) {      node_access_needs_rebuild(TRUE);    }  }}/** * Disable a given set of modules. * * @param $module_list *   An array of module names. */function module_disable($module_list) {  $invoke_modules = array();  foreach ($module_list as $module) {    if (module_exists($module)) {      // Check if node_access table needs rebuilding.      if (!node_access_needs_rebuild() && module_hook($module, 'node_grants')) {        node_access_needs_rebuild(TRUE);      }      module_load_install($module);      module_invoke($module, 'disable');      db_query("UPDATE {system} SET status = %d, throttle = %d WHERE type = '%s' AND name = '%s'", 0, 0, 'module', $module);      $invoke_modules[] = $module;    }  }  if (!empty($invoke_modules)) {    // Refresh the module list to exclude the disabled modules.    module_list(TRUE, FALSE);    // Force to regenerate the stored list of hook implementations.    module_implements('', FALSE, TRUE);  }  // If there remains no more node_access module, rebuilding will be  // straightforward, we can do it right now.  if (node_access_needs_rebuild() && count(module_implements('node_grants')) == 0) {    node_access_rebuild();  }}/** * @defgroup hooks Hooks * @{ * Allow modules to interact with the Drupal core. * * Drupal's module system is based on the concept of "hooks". A hook is a PHP * function that is named foo_bar(), where "foo" is the name of the module * (whose filename is thus foo.module) and "bar" is the name of the hook. Each * hook has a defined set of parameters and a specified result type. * * To extend Drupal, a module need simply implement a hook. When Drupal wishes * to allow intervention from modules, it determines which modules implement a * hook and calls that hook in all enabled modules that implement it. * * The available hooks to implement are explained here in the Hooks section of * the developer documentation. The string "hook" is used as a placeholder for * the module name in the hook definitions. For example, if the module file is * called example.module, then hook_help() as implemented by that module would * be defined as example_help(). *//** * Determine whether a module implements a hook. * * @param $module *   The name of the module (without the .module extension). * @param $hook *   The name of the hook (e.g. "help" or "menu"). * @return *   TRUE if the module is both installed and enabled, and the hook is *   implemented in that module. */function module_hook($module, $hook) {  return function_exists($module .'_'. $hook);}/** * Determine which modules are implementing a hook. * * @param $hook *   The name of the hook (e.g. "help" or "menu"). * @param $sort *   By default, modules are ordered by weight and filename, settings this option *   to TRUE, module list will be ordered by module name. * @param $refresh *   For internal use only: Whether to force the stored list of hook *   implementations to be regenerated (such as after enabling a new module, *   before processing hook_enable). * @return *   An array with the names of the modules which are implementing this hook. */function module_implements($hook, $sort = FALSE, $refresh = FALSE) {  static $implementations;  if ($refresh) {    $implementations = array();    return;  }  if (!isset($implementations[$hook])) {    $implementations[$hook] = array();    $list = module_list(FALSE, TRUE, $sort);    foreach ($list as $module) {      if (module_hook($module, $hook)) {        $implementations[$hook][] = $module;      }    }  }  // The explicit cast forces a copy to be made. This is needed because  // $implementations[$hook] is only a reference to an element of  // $implementations and if there are nested foreaches (due to nested node  // API calls, for example), they would both manipulate the same array's  // references, which causes some modules' hooks not to be called.  // See also http://www.zend.com/zend/art/ref-count.php.  return (array)$implementations[$hook];}/** * Invoke a hook in a particular module. * * @param $module *   The name of the module (without the .module extension). * @param $hook *   The name of the hook to invoke. * @param ... *   Arguments to pass to the hook implementation. * @return *   The return value of the hook implementation. */function module_invoke() {  $args = func_get_args();  $module = $args[0];  $hook = $args[1];  unset($args[0], $args[1]);  $function = $module .'_'. $hook;  if (module_hook($module, $hook)) {    return call_user_func_array($function, $args);  }}/** * Invoke a hook in all enabled modules that implement it. * * @param $hook *   The name of the hook to invoke. * @param ... *   Arguments to pass to the hook. * @return *   An array of return values of the hook implementations. If modules return *   arrays from their implementations, those are merged into one array. */function module_invoke_all() {  $args = func_get_args();  $hook = $args[0];  unset($args[0]);  $return = array();  foreach (module_implements($hook) as $module) {    $function = $module .'_'. $hook;    $result = call_user_func_array($function, $args);    if (isset($result) && is_array($result)) {      $return = array_merge_recursive($return, $result);    }    else if (isset($result)) {      $return[] = $result;    }  }  return $return;}/** * @} End of "defgroup hooks". *//** * Array of modules required by core. */function drupal_required_modules() {  return array('block', 'filter', 'node', 'system', 'user');}
<?php// $Id$/** * Implementation of hook_install(). */function statistics_install() {  // Create tables.  drupal_install_schema('statistics');}/** * Changes session ID  field to VARCHAR(64) to add support for SHA-1 hashes. */function statistics_update_1000() {  $ret = array();  switch ($GLOBALS['db_type']) {    case 'mysql':    case 'mysqli':      $ret[] = update_sql("ALTER TABLE {accesslog} CHANGE COLUMN sid sid varchar(64) NOT NULL default ''");      break;    case 'pgsql':      db_change_column($ret, 'accesslog', 'sid', 'sid', 'varchar(64)', array('not null' => TRUE, 'default' => "''"));      break;  }  return $ret;}/** * Implementation of hook_uninstall(). */function statistics_uninstall() {  // Remove tables.  drupal_uninstall_schema('statistics');  variable_del('statistics_count_content_views');  variable_del('statistics_enable_access_log');  variable_del('statistics_flush_accesslog_timer');  variable_del('statistics_day_timestamp');  variable_del('statistics_block_top_day_num');  variable_del('statistics_block_top_all_num');  variable_del('statistics_block_top_last_num');}/** * Implementation of hook_schema(). */function statistics_schema() {  $schema['accesslog'] = array(    'description' => 'Stores site access information for statistics.',    'fields' => array(      'aid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique accesslog ID.',      ),      'sid' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Browser session ID of user that visited page.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => 'Title of page visited.',      ),      'path' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => 'Internal path to page visited (relative to Drupal root.)',      ),      'url' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'Referrer URI.',      ),      'hostname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => FALSE,        'description' => 'Hostname of user that visited the page.',      ),      'uid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => FALSE,        'default' => 0,        'description' => 'User {users}.uid that visited the page.',      ),      'timer' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Time in milliseconds that the page took to load.',      ),      'timestamp' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Timestamp of when the page was visited.',      ),    ),    'indexes' => array(      'accesslog_timestamp' => array('timestamp'),      'uid' => array('uid'),    ),    'primary key' => array('aid'),  );  return $schema;}/** * @defgroup updates-6.x-extra Extra statistics updates for 6.x * @{ *//** * Allow longer referrers. */function statistics_update_6000() {  $ret = array();  db_change_field($ret, 'accesslog', 'url', 'url', array('type' => 'text', 'not null' => FALSE));  return $ret;}/** * @} End of "defgroup updates-6.x-extra" * The next series of updates should start at 7000. */
<?php// $Id$/** * @file * Logs access statistics for your site. *//** * Implementation of hook_help(). */function statistics_help($path, $arg) {  switch ($path) {    case 'admin/help#statistics':      $output = '<p>'. t('The statistics module keeps track of numerous site usage statistics, including the number of times, and from where, each of your posts is viewed. These statistics are useful in determining how users are interacting with each other and with your site, and are required for the display of some Drupal blocks.') .'</p>';      $output .= '<p>'. t('The statistics module provides:') .'</p>';      $output .= '<ul><li>'. t('a counter for each post on your site that increments each time the post is viewed. (Enable <em>Count content views</em> on the <a href="@accesslog">access log settings page</a>, and determine if the post access counters should be visible to any user roles on the <a href="@permissions">permissions page</a>.)', array('@accesslog' => url('admin/reports/settings'), '@permissions' => url('admin/user/permissions'))) .'</li>';      $output .= '<li>'. t('a <a href="@recent-hits">recent hits</a> log that displays information about the latest activity on your site, including the URL and title of the page accessed, the user name (if available) and IP address of the accessing party.', array('@recent-hits' => url('admin/reports/hits'))) .'</li>';      $output .= '<li>'. t('a <a href="@top-referrers">top referrers</a> log that displays the referring parties for your site visits (where your visitors came from).', array('@top-referrers' => url('admin/reports/referrers'))) .'</li>';      $output .= '<li>'. t('a <a href="@top-pages">top pages</a> log that displays site content in descending order by number of views.', array('@top-pages' => url('admin/reports/pages'))) .'</li>';      $output .= '<li>'. t('a <a href="@top-visitors">top visitors</a> log that displays the most active users on your site.', array('@top-visitors' => url('admin/reports/visitors'))) .'</li>';      $output .= '<li>'. t('a <em>Popular content</em> block that displays the day\'s most viewed content, the all-time most viewed content, and the last content viewed. (Enable the <em>Popular content</em> block on the <a href="@blocks">blocks administration page</a>.)', array('@blocks' => url('admin/build/block'))) .'</li></ul>';      $output .= '<p>'. t('Configuring the statistics module') .'</p>';      $output .= '<ul><li>'. t('When the <em>Enable access log</em> setting on the <a href="@accesslog">access log settings page</a> is enabled, data about every page accessed (including the remote host\'s IP address, referrer, node accessed, and user name) is stored in the access log. The access log must be enabled for the <a href="@recent-hits">recent hits</a>, <a href="@top-referrers">top referrers</a>, <a href="@top-pages">top pages</a>, and <a href="@top-visitors">top visitors</a> log pages to function. Enabling the access log adds one additional database call per page displayed by Drupal.', array('@accesslog' => url('admin/reports/settings'), '@recent-hits' => url('admin/reports/hits'), '@top-referrers' => url('admin/reports/referrers'), '@top-pages' => url('admin/reports/pages'), '@top-visitors' => url('admin/reports/visitors'))) .'</li>';      $output .= '<li>'. t('The <em>Discard access logs older than</em> setting on the <a href="@accesslog">access log settings page</a> specifies the length of time entries are retained in the access log before they are deleted. Automatic access log entry deletion requires a correctly configured <a href="@cron">cron maintenance task</a>.', array('@accesslog' => url('admin/reports/settings'), '@cron' => url('admin/reports/status'))) .'</li>';      $output .= '<li>'. t('The <em>Count content views</em> setting on the <a href="@accesslog">access log settings page</a> enables a counter for each post on your site that increments each time the post is viewed. This option must be enabled to provide post-specific access counts. Enabling this option adds one additional database call per each post displayed by Drupal.', array('@accesslog' => url('admin/reports/settings'))) .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@statistics">Statistics module</a>.', array('@statistics' => 'http://drupal.org/handbook/modules/statistics/')) .'</p>';      return $output;    case 'admin/reports/settings':      return '<p>'. t('Settings for the statistical information that Drupal will keep about the site. See <a href="@statistics">site statistics</a> for the actual information.', array('@statistics' => url('admin/reports/hits'))) .'</p>';    case 'admin/reports/hits':      return '<p>'. t("This page displays the site's most recent hits.") .'</p>';    case 'admin/reports/referrers':      return '<p>'. t('This page displays all external referrers, or external references to your website.') .'</p>';    case 'admin/reports/visitors':      return '<p>'. t("When you ban a visitor, you prevent the visitor's IP address from accessing your site. Unlike blocking a user, banning a visitor works even for anonymous users. This is most commonly used to block resource-intensive bots or web crawlers.") .'</p>';  }}/** * Implementation of hook_exit(). * * This is where statistics are gathered on page accesses. */function statistics_exit() {  global $user, $recent_activity;  drupal_bootstrap(DRUPAL_BOOTSTRAP_PATH);  if (variable_get('statistics_count_content_views', 0)) {    // We are counting content views.    if ((arg(0) == 'node') && is_numeric(arg(1)) && arg(2) == '') {      // A node has been viewed, so update the node's counters.      db_query('UPDATE {node_counter} SET daycount = daycount + 1, totalcount = totalcount + 1, timestamp = %d WHERE nid = %d', time(), arg(1));      // If we affected 0 rows, this is the first time viewing the node.      if (!db_affected_rows()) {        // We must create a new row to store counters for the new node.        db_query('INSERT INTO {node_counter} (nid, daycount, totalcount, timestamp) VALUES (%d, 1, 1, %d)', arg(1), time());      }    }  }  if ((variable_get('statistics_enable_access_log', 0)) && (module_invoke('throttle', 'status') == 0)) {    // Log this page access.    db_query("INSERT INTO {accesslog} (title, path, url, hostname, uid, sid, timer, timestamp) values('%s', '%s', '%s', '%s', %d, '%s', %d, %d)", strip_tags(drupal_get_title()), $_GET['q'], referer_uri(), ip_address(), $user->uid, session_id(), timer_read('page'), time());  }}/** * Implementation of hook_perm(). */function statistics_perm() {  return array('access statistics', 'view post access counter');}/** * Implementation of hook_link(). */function statistics_link($type, $node = NULL, $teaser = FALSE) {  global $id;  $links = array();  if ($type == 'node' && user_access('view post access counter')) {    $statistics = statistics_get($node->nid);    if ($statistics) {      $links['statistics_counter']['title'] = format_plural($statistics['totalcount'], '1 read', '@count reads');    }  }  return $links;}/** * Implementation of hook_menu(). */function statistics_menu() {  $items['admin/reports/hits'] = array(    'title' => 'Recent hits',    'description' => 'View pages that have recently been visited.',    'page callback' => 'statistics_recent_hits',    'access arguments' => array('access statistics'),    'file' => 'statistics.admin.inc',  );  $items['admin/reports/pages'] = array(    'title' => 'Top pages',    'description' => 'View pages that have been hit frequently.',    'page callback' => 'statistics_top_pages',    'access arguments' => array('access statistics'),    'weight' => 1,    'file' => 'statistics.admin.inc',  );  $items['admin/reports/visitors'] = array(    'title' => 'Top visitors',    'description' => 'View visitors that hit many pages.',    'page callback' => 'statistics_top_visitors',    'access arguments' => array('access statistics'),    'weight' => 2,    'file' => 'statistics.admin.inc',  );  $items['admin/reports/referrers'] = array(    'title' => 'Top referrers',    'description' => 'View top referrers.',    'page callback' => 'statistics_top_referrers',    'access arguments' => array('access statistics'),    'file' => 'statistics.admin.inc',  );  $items['admin/reports/access/%'] = array(    'title' => 'Details',    'description' => 'View access log.',    'page callback' => 'statistics_access_log',    'page arguments' => array(3),    'access arguments' => array('access statistics'),    'type' => MENU_CALLBACK,    'file' => 'statistics.admin.inc',  );  $items['admin/reports/settings'] = array(    'title' => 'Access log settings',    'description' => 'Control details about what and how your site logs.',    'page callback' => 'drupal_get_form',    'page arguments' => array('statistics_access_logging_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_NORMAL_ITEM,    'weight' => 3,    'file' => 'statistics.admin.inc',  );  $items['user/%user/track/navigation'] = array(    'title' => 'Track page visits',    'page callback' => 'statistics_user_tracker',    'access callback' => 'user_access',    'access arguments' => array('access statistics'),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'statistics.pages.inc',  );  $items['node/%node/track'] = array(    'title' => 'Track',    'page callback' => 'statistics_node_tracker',    'access callback' => 'user_access',    'access arguments' => array('access statistics'),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'statistics.pages.inc',  );  return $items;}/** * Implementation of hook_user(). */function statistics_user($op, &$edit, &$user) {  if ($op == 'delete') {    db_query('UPDATE {accesslog} SET uid = 0 WHERE uid = %d', $user->uid);  }}/** * Implementation of hook_cron(). */function statistics_cron() {  $statistics_timestamp = variable_get('statistics_day_timestamp', '');  if ((time() - $statistics_timestamp) >= 86400) {    // Reset day counts.    db_query('UPDATE {node_counter} SET daycount = 0');    variable_set('statistics_day_timestamp', time());  }  // Clean up expired access logs.  db_query('DELETE FROM {accesslog} WHERE timestamp < %d', time() - variable_get('statistics_flush_accesslog_timer', 259200));}/** * Returns all time or today top or last viewed node(s). * * @param $dbfield *   one of *   - 'totalcount': top viewed content of all time. *   - 'daycount': top viewed content for today. *   - 'timestamp': last viewed node. * * @param $dbrows *   number of rows to be returned. * * @return *   A query result containing n.nid, n.title, u.uid, u.name of the selected node(s) *   or FALSE if the query could not be executed correctly. */function statistics_title_list($dbfield, $dbrows) {  if (in_array($dbfield, array('totalcount', 'daycount', 'timestamp'))) {    return db_query_range(db_rewrite_sql("SELECT n.nid, n.title, u.uid, u.name FROM {node} n INNER JOIN {node_counter} s ON n.nid = s.nid INNER JOIN {users} u ON n.uid = u.uid WHERE s.". $dbfield ." != 0 AND n.status = 1 ORDER BY s.". $dbfield ." DESC"), 0, $dbrows);  }  return FALSE;}/** * Retrieves a node's "view statistics". * * @param $nid *   node ID * * @return *   An array with three entries: [0]=totalcount, [1]=daycount, [2]=timestamp *   - totalcount: count of the total number of times that node has been viewed. *   - daycount: count of the total number of times that node has been viewed "today". *     For the daycount to be reset, cron must be enabled. *   - timestamp: timestamp of when that node was last viewed. */function statistics_get($nid) {  if ($nid > 0) {    // Retrieve an array with both totalcount and daycount.    $statistics = db_fetch_array(db_query('SELECT totalcount, daycount, timestamp FROM {node_counter} WHERE nid = %d', $nid));  }  return $statistics;}/** * Implementation of hook_block(). */function statistics_block($op = 'list', $delta = 0, $edit = array()) {  switch ($op) {    case 'list':      if (variable_get('statistics_count_content_views', 0)) {        $blocks[0]['info'] = t('Popular content');        // Too dynamic to cache.        $blocks[0]['cache'] = BLOCK_NO_CACHE;        return $blocks;      }      break;    case 'configure':      // Popular content block settings      $numbers = array('0' => t('Disabled')) + drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 40));      $form['statistics_block_top_day_num'] = array('#type' => 'select', '#title' => t("Number of day's top views to display"), '#default_value' => variable_get('statistics_block_top_day_num', 0), '#options' => $numbers, '#description' => t('How many content items to display in "day" list.'));      $form['statistics_block_top_all_num'] = array('#type' => 'select', '#title' => t('Number of all time views to display'), '#default_value' => variable_get('statistics_block_top_all_num', 0), '#options' => $numbers, '#description' => t('How many content items to display in "all time" list.'));      $form['statistics_block_top_last_num'] = array('#type' => 'select', '#title' => t('Number of most recent views to display'), '#default_value' => variable_get('statistics_block_top_last_num', 0), '#options' => $numbers, '#description' => t('How many content items to display in "recently viewed" list.'));      return $form;    case 'save':      variable_set('statistics_block_top_day_num', $edit['statistics_block_top_day_num']);      variable_set('statistics_block_top_all_num', $edit['statistics_block_top_all_num']);      variable_set('statistics_block_top_last_num', $edit['statistics_block_top_last_num']);      break;    case 'view':      if (user_access('access content')) {        $content = array();        $daytop = variable_get('statistics_block_top_day_num', 0);        if ($daytop && ($result = statistics_title_list('daycount', $daytop)) && ($node_title_list = node_title_list($result, t("Today's:")))) {          $content[] = $node_title_list;        }        $alltimetop = variable_get('statistics_block_top_all_num', 0);        if ($alltimetop && ($result = statistics_title_list('totalcount', $alltimetop)) && ($node_title_list = node_title_list($result, t('All time:')))) {          $content[] = $node_title_list;        }        $lasttop = variable_get('statistics_block_top_last_num', 0);        if ($lasttop && ($result = statistics_title_list('timestamp', $lasttop)) && ($node_title_list = node_title_list($result, t('Last viewed:')))) {          $content[] = $node_title_list;        }        if (count($content)) {          $block['content'] = implode('<br />', $content);          $block['subject'] = t('Popular content');          return $block;        }      }  }}/** * It is possible to adjust the width of columns generated by the * statistics module. */function _statistics_link($path, $width = 35) {  $title = drupal_get_path_alias($path);  $title = truncate_utf8($title, $width, FALSE, TRUE);  return l($title, $path);}function _statistics_format_item($title, $path) {  $path = ($path ? $path : '/');  $output  = ($title ? "$title<br />" : '');  $output .= _statistics_link($path);  return $output;}/** * Implementation of hook_nodeapi(). */function statistics_nodeapi(&$node, $op, $arg = 0) {  switch ($op) {    case 'delete':      // clean up statistics table when node is deleted      db_query('DELETE FROM {node_counter} WHERE nid = %d', $node->nid);  }}
<?php// $Id$/** * @file maintenance-page.tpl.php * * Theme implementation to display a single Drupal page while off-line. * * All the available variables are mirrored in page.tpl.php. Some may be left * blank but they are provided for consistency. * * * @see template_preprocess() * @see template_preprocess_maintenance_page() */?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>"><head>  <?php print $head; ?>  <title><?php print $head_title; ?></title>  <?php print $styles; ?>  <?php print $scripts; ?>  <script type="text/javascript"><?php /* Needed to avoid Flash of Unstyled Content in IE */ ?> </script></head><body class="<?php print $body_classes; ?>">  <div id="page">    <div id="header">      <div id="logo-title">        <?php if (!empty($logo)): ?>          <a href="<?php print $base_path; ?>" title="<?php print t('Home'); ?>" rel="home" id="logo">            <img src="<?php print $logo; ?>" alt="<?php print t('Home'); ?>" />          </a>        <?php endif; ?>        <div id="name-and-slogan">          <?php if (!empty($site_name)): ?>            <h1 id="site-name">              <a href="<?php print $base_path ?>" title="<?php print t('Home'); ?>" rel="home"><span><?php print $site_name; ?></span></a>            </h1>          <?php endif; ?>          <?php if (!empty($site_slogan)): ?>            <div id="site-slogan"><?php print $site_slogan; ?></div>          <?php endif; ?>        </div> <!-- /name-and-slogan -->      </div> <!-- /logo-title -->      <?php if (!empty($header)): ?>        <div id="header-region">          <?php print $header; ?>        </div>      <?php endif; ?>    </div> <!-- /header -->    <div id="container" class="clear-block">      <?php if (!empty($left)): ?>        <div id="sidebar-left" class="column sidebar">          <?php print $left; ?>        </div> <!-- /sidebar-left -->      <?php endif; ?>      <div id="main" class="column"><div id="main-squeeze">        <div id="content">          <?php if (!empty($title)): ?><h1 class="title" id="page-title"><?php print $title; ?></h1><?php endif; ?>          <?php if (!empty($messages)): print $messages; endif; ?>          <div id="content-content" class="clear-block">            <?php print $content; ?>          </div> <!-- /content-content -->        </div> <!-- /content -->      </div></div> <!-- /main-squeeze /main -->      <?php if (!empty($right)): ?>        <div id="sidebar-right" class="column sidebar">          <?php print $right; ?>        </div> <!-- /sidebar-right -->      <?php endif; ?>    </div> <!-- /container -->    <div id="footer-wrapper">      <div id="footer">        <?php print $footer_message; ?>        <?php if (!empty($footer)): print $footer; endif; ?>      </div> <!-- /footer -->    </div> <!-- /footer-wrapper -->  </div> <!-- /page --></body></html>
<?php// $Id$/** * @file * Used to aggregate syndicated content (RSS, RDF, and Atom). *//** * Implementation of hook_help(). */function aggregator_help($path, $arg) {  switch ($path) {    case 'admin/help#aggregator':      $output = '<p>'. t('The aggregator is a powerful on-site syndicator and news reader that gathers fresh content from RSS-, RDF-, and Atom-based feeds made available across the web. Thousands of sites (particularly news sites and blogs) publish their latest headlines and posts in feeds, using a number of standardized XML-based formats. Formats supported by the aggregator include <a href="@rss">RSS</a>, <a href="@rdf">RDF</a>, and <a href="@atom">Atom</a>.', array('@rss' => 'http://cyber.law.harvard.edu/rss/', '@rdf' => 'http://www.w3.org/RDF/', '@atom' => 'http://www.atomenabled.org')) .'</p>';      $output .= '<p>'. t('Feeds contain feed items, or individual posts published by the site providing the feed. Feeds may be grouped in categories, generally by topic. Users view feed items in the <a href="@aggregator">main aggregator display</a> or by <a href="@aggregator-sources">their source</a>. Administrators can <a href="@feededit">add, edit and delete feeds</a> and choose how often to check each feed for newly updated items. The most recent items in either a feed or category can be displayed as a block through the <a href="@admin-block">blocks administration page</a>. A <a href="@aggregator-opml">machine-readable OPML file</a> of all feeds is available. A correctly configured <a href="@cron">cron maintenance task</a> is required to update feeds automatically.', array('@aggregator' => url('aggregator'), '@aggregator-sources' => url('aggregator/sources'), '@feededit' => url('admin/content/aggregator'), '@admin-block' => url('admin/build/block'), '@aggregator-opml' => url('aggregator/opml'), '@cron' => url('admin/reports/status'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@aggregator">Aggregator module</a>.', array('@aggregator' => 'http://drupal.org/handbook/modules/aggregator/')) .'</p>';      return $output;    case 'admin/content/aggregator':      $output = '<p>'. t('Thousands of sites (particularly news sites and blogs) publish their latest headlines and posts in feeds, using a number of standardized XML-based formats. Formats supported by the aggregator include <a href="@rss">RSS</a>, <a href="@rdf">RDF</a>, and <a href="@atom">Atom</a>.', array('@rss' => 'http://cyber.law.harvard.edu/rss/', '@rdf' => 'http://www.w3.org/RDF/', '@atom' => 'http://www.atomenabled.org')) .'</p>';      $output .= '<p>'. t('Current feeds are listed below, and <a href="@addfeed">new feeds may be added</a>. For each feed or feed category, the <em>latest items</em> block may be enabled at the <a href="@block">blocks administration page</a>.', array('@addfeed' => url('admin/content/aggregator/add/feed'), '@block' => url('admin/build/block'))) .'</p>';      return $output;    case 'admin/content/aggregator/add/feed':      return '<p>'. t('Add a feed in RSS, RDF or Atom format. A feed may only have one entry.') .'</p>';    case 'admin/content/aggregator/add/category':      return '<p>'. t('Categories allow feed items from different feeds to be grouped together. For example, several sport-related feeds may belong to a category named <em>Sports</em>. Feed items may be grouped automatically (by selecting a category when creating or editing a feed) or manually (via the <em>Categorize</em> page available from feed item listings). Each category provides its own feed page and block.') .'</p>';  }}/** * Implementation of hook_theme() */function aggregator_theme() {  return array(    'aggregator_wrapper' => array(      'arguments' => array('content' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-wrapper',    ),    'aggregator_categorize_items' => array(      'arguments' => array('form' => NULL),      'file' => 'aggregator.pages.inc',    ),    'aggregator_feed_source' => array(      'arguments' => array('feed' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-feed-source',    ),    'aggregator_block_item' => array(      'arguments' => array('item' => NULL, 'feed' => 0),    ),    'aggregator_summary_items' => array(      'arguments' => array('summary_items' => NULL, 'source' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-summary-items',    ),    'aggregator_summary_item' => array(      'arguments' => array('item' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-summary-item',    ),    'aggregator_item' => array(      'arguments' => array('item' => NULL),      'file' => 'aggregator.pages.inc',      'template' => 'aggregator-item',    ),    'aggregator_page_opml' => array(      'arguments' => array('feeds' => NULL),      'file' => 'aggregator.pages.inc',    ),    'aggregator_page_rss' => array(      'arguments' => array('feeds' => NULL, 'category' => NULL),      'file' => 'aggregator.pages.inc',    ),  );}/** * Implementation of hook_menu(). */function aggregator_menu() {  $items['admin/content/aggregator'] = array(    'title' => 'Feed aggregator',    'description' => "Configure which content your site aggregates from other sites, how often it polls them, and how they're categorized.",    'page callback' => 'aggregator_admin_overview',    'access arguments' => array('administer news feeds'),    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/add/feed'] = array(    'title' => 'Add feed',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_feed'),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/aggregator',    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/add/category'] = array(    'title' => 'Add category',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_category'),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/aggregator',    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/remove/%aggregator_feed'] = array(    'title' => 'Remove items',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_admin_remove_feed', 4),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/update/%aggregator_feed'] = array(    'title' => 'Update items',    'page callback' => 'aggregator_admin_refresh_feed',    'page arguments' => array(4),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/aggregator/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_admin_settings'),    'type' => MENU_LOCAL_TASK,    'weight' => 10,    'access arguments' => array('administer news feeds'),    'file' => 'aggregator.admin.inc',  );  $items['aggregator'] = array(    'title' => 'Feed aggregator',    'page callback' => 'aggregator_page_last',    'access arguments' => array('access news feeds'),    'weight' => 5,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/sources'] = array(    'title' => 'Sources',    'page callback' => 'aggregator_page_sources',    'access arguments' => array('access news feeds'),    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories'] = array(    'title' => 'Categories',    'page callback' => 'aggregator_page_categories',    'access callback' => '_aggregator_has_categories',    'file' => 'aggregator.pages.inc',  );  $items['aggregator/rss'] = array(    'title' => 'RSS feed',    'page callback' => 'aggregator_page_rss',    'access arguments' => array('access news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/opml'] = array(    'title' => 'OPML feed',    'page callback' => 'aggregator_page_opml',    'access arguments' => array('access news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories/%aggregator_category'] = array(    'title callback' => '_aggregator_category_title',    'title arguments' => array(2),    'page callback' => 'aggregator_page_category',    'page arguments' => array(2),    'access callback' => 'user_access',    'access arguments' => array('access news feeds'),    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories/%aggregator_category/view'] = array(    'title' => 'View',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['aggregator/categories/%aggregator_category/categorize'] = array(    'title' => 'Categorize',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_page_category', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/categories/%aggregator_category/configure'] = array(    'title' => 'Configure',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_category', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'aggregator.admin.inc',  );  $items['aggregator/sources/%aggregator_feed'] = array(    'page callback' => 'aggregator_page_source',    'page arguments' => array(2),    'access arguments' => array('access news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/sources/%aggregator_feed/view'] = array(    'title' => 'View',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['aggregator/sources/%aggregator_feed/categorize'] = array(    'title' => 'Categorize',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_page_source', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'file' => 'aggregator.pages.inc',  );  $items['aggregator/sources/%aggregator_feed/configure'] = array(    'title' => 'Configure',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_feed', 2),    'access arguments' => array('administer news feeds'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/edit/feed/%aggregator_feed'] = array(    'title' => 'Edit feed',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_feed', 5),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  $items['admin/content/aggregator/edit/category/%aggregator_category'] = array(    'title' => 'Edit category',    'page callback' => 'drupal_get_form',    'page arguments' => array('aggregator_form_category', 5),    'access arguments' => array('administer news feeds'),    'type' => MENU_CALLBACK,    'file' => 'aggregator.admin.inc',  );  return $items;}/** * Menu callback. * * @return *   An aggregator category title. */function _aggregator_category_title($category) {  return $category['title'];}/** * Implementation of hook_init(). */function aggregator_init() {  drupal_add_css(drupal_get_path('module', 'aggregator') .'/aggregator.css');}/** * Find out whether there are any aggregator categories. * * @return *   TRUE if there is at least one category and the user has access to them, FALSE otherwise. */function _aggregator_has_categories() {  return user_access('access news feeds') && db_result(db_query('SELECT COUNT(*) FROM {aggregator_category}'));}/** * Implementation of hook_perm(). */function aggregator_perm() {  return array('administer news feeds', 'access news feeds');}/** * Implementation of hook_cron(). * * Checks news feeds for updates once their refresh interval has elapsed. */function aggregator_cron() {  $result = db_query('SELECT * FROM {aggregator_feed} WHERE checked + refresh < %d', time());  while ($feed = db_fetch_array($result)) {    aggregator_refresh($feed);  }}/** * Implementation of hook_block(). * * Generates blocks for the latest news items in each category and feed. */function aggregator_block($op = 'list', $delta = 0, $edit = array()) {  if (user_access('access news feeds')) {    if ($op == 'list') {      $result = db_query('SELECT cid, title FROM {aggregator_category} ORDER BY title');      while ($category = db_fetch_object($result)) {        $block['category-'. $category->cid]['info'] = t('!title category latest items', array('!title' => $category->title));      }      $result = db_query('SELECT fid, title FROM {aggregator_feed} ORDER BY fid');      while ($feed = db_fetch_object($result)) {        $block['feed-'. $feed->fid]['info'] = t('!title feed latest items', array('!title' => $feed->title));      }    }    else if ($op == 'configure') {      list($type, $id) = explode('-', $delta);      if ($type == 'category') {        $value = db_result(db_query('SELECT block FROM {aggregator_category} WHERE cid = %d', $id));      }      else {        $value = db_result(db_query('SELECT block FROM {aggregator_feed} WHERE fid = %d', $id));      }      $form['block'] = array('#type' => 'select', '#title' => t('Number of news items in block'), '#default_value' => $value, '#options' => drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)));      return $form;    }    else if ($op == 'save') {      list($type, $id) = explode('-', $delta);      if ($type == 'category') {        $value = db_query('UPDATE {aggregator_category} SET block = %d WHERE cid = %d', $edit['block'], $id);      }      else {        $value = db_query('UPDATE {aggregator_feed} SET block = %d WHERE fid = %d', $edit['block'], $id);      }    }    else if ($op == 'view') {      list($type, $id) = explode('-', $delta);      switch ($type) {        case 'feed':          if ($feed = db_fetch_object(db_query('SELECT fid, title, block FROM {aggregator_feed} WHERE fid = %d', $id))) {            $block['subject'] = check_plain($feed->title);            $result = db_query_range('SELECT * FROM {aggregator_item} WHERE fid = %d ORDER BY timestamp DESC, iid DESC', $feed->fid, 0, $feed->block);            $read_more = theme('more_link', url('aggregator/sources/'. $feed->fid), t("View this feed's recent news."));          }          break;        case 'category':          if ($category = db_fetch_object(db_query('SELECT cid, title, block FROM {aggregator_category} WHERE cid = %d', $id))) {            $block['subject'] = check_plain($category->title);            $result = db_query_range('SELECT i.* FROM {aggregator_category_item} ci LEFT JOIN {aggregator_item} i ON ci.iid = i.iid WHERE ci.cid = %d ORDER BY i.timestamp DESC, i.iid DESC', $category->cid, 0, $category->block);            $read_more = theme('more_link', url('aggregator/categories/'. $category->cid), t("View this category's recent news."));          }          break;      }      $items = array();      while ($item = db_fetch_object($result)) {        $items[] = theme('aggregator_block_item', $item);      }      // Only display the block if there are items to show.      if (count($items) > 0) {        $block['content'] = theme('item_list', $items) . $read_more;      }    }    if (isset($block)) {      return $block;    }  }}/** * Add/edit/delete aggregator categories. * * @param $edit *   An associative array describing the category to be added/edited/deleted. */function aggregator_save_category($edit) {  $link_path = 'aggregator/categories/';  if (!empty($edit['cid'])) {    $link_path .= $edit['cid'];    if (!empty($edit['title'])) {      db_query("UPDATE {aggregator_category} SET title = '%s', description = '%s' WHERE cid = %d", $edit['title'], $edit['description'], $edit['cid']);      $op = 'update';    }    else {      db_query('DELETE FROM {aggregator_category} WHERE cid = %d', $edit['cid']);      // Make sure there is no active block for this category.      db_query("DELETE FROM {blocks} WHERE module = '%s' AND delta = '%s'", 'aggregator', 'category-' . $edit['cid']);      $edit['title'] = '';      $op = 'delete';    }  }  else if (!empty($edit['title'])) {    // A single unique id for bundles and feeds, to use in blocks    db_query("INSERT INTO {aggregator_category} (title, description, block) VALUES ('%s', '%s', 5)", $edit['title'], $edit['description']);    $link_path .= db_last_insert_id('aggregator_category', 'cid');    $op = 'insert';  }  if (isset($op)) {    menu_link_maintain('aggregator', $op, $link_path, $edit['title']);  }}/** * Add/edit/delete an aggregator feed. * * @param $edit *   An associative array describing the feed to be added/edited/deleted. */function aggregator_save_feed($edit) {  if (!empty($edit['fid'])) {    // An existing feed is being modified, delete the category listings.    db_query('DELETE FROM {aggregator_category_feed} WHERE fid = %d', $edit['fid']);  }  if (!empty($edit['fid']) && !empty($edit['title'])) {    db_query("UPDATE {aggregator_feed} SET title = '%s', url = '%s', refresh = %d WHERE fid = %d", $edit['title'], $edit['url'], $edit['refresh'], $edit['fid']);  }  else if (!empty($edit['fid'])) {    $items = array();    $result = db_query('SELECT iid FROM {aggregator_item} WHERE fid = %d', $edit['fid']);    while ($item = db_fetch_object($result)) {      $items[] = "iid = $item->iid";    }    if (!empty($items)) {      db_query('DELETE FROM {aggregator_category_item} WHERE '. implode(' OR ', $items));    }    db_query('DELETE FROM {aggregator_feed} WHERE fid = %d', $edit['fid']);    db_query('DELETE FROM {aggregator_item} WHERE fid = %d', $edit['fid']);    // Make sure there is no active block for this feed.    db_query("DELETE FROM {blocks} WHERE module = '%s' AND delta = '%s'", 'aggregator', 'feed-' . $edit['fid']);  }  else if (!empty($edit['title'])) {    db_query("INSERT INTO {aggregator_feed} (title, url, refresh, block, description, image) VALUES ('%s', '%s', %d, 5, '', '')", $edit['title'], $edit['url'], $edit['refresh']);    // A single unique id for bundles and feeds, to use in blocks.    $edit['fid'] = db_last_insert_id('aggregator_feed', 'fid');  }  if (!empty($edit['title'])) {    // The feed is being saved, save the categories as well.    if (!empty($edit['category'])) {      foreach ($edit['category'] as $cid => $value) {        if ($value) {          db_query('INSERT INTO {aggregator_category_feed} (fid, cid) VALUES (%d, %d)', $edit['fid'], $cid);        }      }    }  }}/** * Removes all items from a feed. * * @param $feed *   An associative array describing the feed to be cleared. */function aggregator_remove($feed) {  $result = db_query('SELECT iid FROM {aggregator_item} WHERE fid = %d', $feed['fid']);  while ($item = db_fetch_object($result)) {    $items[] = "iid = $item->iid";  }  if (!empty($items)) {    db_query('DELETE FROM {aggregator_category_item} WHERE '. implode(' OR ', $items));  }  db_query('DELETE FROM {aggregator_item} WHERE fid = %d', $feed['fid']);  db_query("UPDATE {aggregator_feed} SET checked = 0, etag = '', modified = 0 WHERE fid = %d", $feed['fid']);  drupal_set_message(t('The news items from %site have been removed.', array('%site' => $feed['title'])));}/** * Call-back function used by the XML parser. */function aggregator_element_start($parser, $name, $attributes) {  global $item, $element, $tag, $items, $channel;  switch ($name) {    case 'IMAGE':    case 'TEXTINPUT':    case 'CONTENT':    case 'SUMMARY':    case 'TAGLINE':    case 'SUBTITLE':    case 'LOGO':    case 'INFO':      $element = $name;      break;    case 'ID':      if ($element != 'ITEM') {        $element = $name;      }    case 'LINK':      if (!empty($attributes['REL']) && $attributes['REL'] == 'alternate') {        if ($element == 'ITEM') {          $items[$item]['LINK'] = $attributes['HREF'];        }        else {          $channel['LINK'] = $attributes['HREF'];        }      }      break;    case 'ITEM':      $element = $name;      $item += 1;      break;    case 'ENTRY':      $element = 'ITEM';      $item += 1;      break;  }  $tag = $name;}/** * Call-back function used by the XML parser. */function aggregator_element_end($parser, $name) {  global $element;  switch ($name) {    case 'IMAGE':    case 'TEXTINPUT':    case 'ITEM':    case 'ENTRY':    case 'CONTENT':    case 'INFO':      $element = '';      break;    case 'ID':      if ($element == 'ID') {        $element = '';      }  }}/** * Call-back function used by the XML parser. */function aggregator_element_data($parser, $data) {  global $channel, $element, $items, $item, $image, $tag;  $items += array($item => array());  switch ($element) {    case 'ITEM':      $items[$item] += array($tag => '');      $items[$item][$tag] .= $data;      break;    case 'IMAGE':    case 'LOGO':      $image += array($tag => '');      $image[$tag] .= $data;      break;    case 'LINK':      if ($data) {        $items[$item] += array($tag => '');        $items[$item][$tag] .= $data;      }      break;    case 'CONTENT':      $items[$item] += array('CONTENT' => '');      $items[$item]['CONTENT'] .= $data;      break;    case 'SUMMARY':      $items[$item] += array('SUMMARY' => '');      $items[$item]['SUMMARY'] .= $data;      break;    case 'TAGLINE':    case 'SUBTITLE':      $channel += array('DESCRIPTION' => '');      $channel['DESCRIPTION'] .= $data;      break;    case 'INFO':    case 'ID':    case 'TEXTINPUT':      // The sub-element is not supported. However, we must recognize      // it or its contents will end up in the item array.      break;    default:      $channel += array($tag => '');      $channel[$tag] .= $data;  }}/** * Checks a news feed for new items. * * @param $feed *   An associative array describing the feed to be refreshed. */function aggregator_refresh($feed) {  global $channel, $image;  // Generate conditional GET headers.  $headers = array();  if ($feed['etag']) {    $headers['If-None-Match'] = $feed['etag'];  }  if ($feed['modified']) {    $headers['If-Modified-Since'] = gmdate('D, d M Y H:i:s', $feed['modified']) .' GMT';  }  // Request feed.  $result = drupal_http_request($feed['url'], $headers);  // Process HTTP response code.  switch ($result->code) {    case 304:      db_query('UPDATE {aggregator_feed} SET checked = %d WHERE fid = %d', time(), $feed['fid']);      drupal_set_message(t('There is no new syndicated content from %site.', array('%site' => $feed['title'])));      break;    case 301:      $feed['url'] = $result->redirect_url;      watchdog('aggregator', 'Updated URL for feed %title to %url.', array('%title' => $feed['title'], '%url' => $feed['url']));      // Deliberate no break.    case 200:    case 302:    case 307:      // Filter the input data:      if (aggregator_parse_feed($result->data, $feed)) {        $modified = empty($result->headers['Last-Modified']) ? 0 : strtotime($result->headers['Last-Modified']);        // Prepare the channel data.        foreach ($channel as $key => $value) {          $channel[$key] = trim($value);        }        // Prepare the image data (if any).        foreach ($image as $key => $value) {          $image[$key] = trim($value);        }        if (!empty($image['LINK']) && !empty($image['URL']) && !empty($image['TITLE'])) {          // Note, we should really use theme_image() here but that only works with local images it won't work with images fetched with a URL unless PHP version > 5          $image = '<a href="'. check_url($image['LINK']) .'" class="feed-image"><img src="'. check_url($image['URL']) .'" alt="'. check_plain($image['TITLE']) .'" /></a>';        }        else {          $image = NULL;        }        $etag = empty($result->headers['ETag']) ? '' : $result->headers['ETag'];        // Update the feed data.        db_query("UPDATE {aggregator_feed} SET url = '%s', checked = %d, link = '%s', description = '%s', image = '%s', etag = '%s', modified = %d WHERE fid = %d", $feed['url'], time(), $channel['LINK'], $channel['DESCRIPTION'], $image, $etag, $modified, $feed['fid']);        // Clear the cache.        cache_clear_all();        watchdog('aggregator', 'There is new syndicated content from %site.', array('%site' => $feed['title']));        drupal_set_message(t('There is new syndicated content from %site.', array('%site' => $feed['title'])));        break;      }      $result->error = t('feed not parseable');      // Deliberate no break.    default:      watchdog('aggregator', 'The feed from %site seems to be broken, due to "%error".', array('%site' => $feed['title'], '%error' => $result->code .' '. $result->error), WATCHDOG_WARNING);      drupal_set_message(t('The feed from %site seems to be broken, because of error "%error".', array('%site' => $feed['title'], '%error' => $result->code .' '. $result->error)));  }}/** * Parse the W3C date/time format, a subset of ISO 8601. PHP date parsing * functions do not handle this format. * See http://www.w3.org/TR/NOTE-datetime for more information. * Originally from MagpieRSS (http://magpierss.sourceforge.net/). * * @param $date_str *   A string with a potentially W3C DTF date. * @return *   A timestamp if parsed successfully or FALSE if not. */function aggregator_parse_w3cdtf($date_str) {  if (preg_match('/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(:(\d{2}))?(?:([-+])(\d{2}):?(\d{2})|(Z))?/', $date_str, $match)) {    list($year, $month, $day, $hours, $minutes, $seconds) = array($match[1], $match[2], $match[3], $match[4], $match[5], $match[6]);    // calc epoch for current date assuming GMT    $epoch = gmmktime($hours, $minutes, $seconds, $month, $day, $year);    if ($match[10] != 'Z') { // Z is zulu time, aka GMT      list($tz_mod, $tz_hour, $tz_min) = array($match[8], $match[9], $match[10]);      // zero out the variables      if (!$tz_hour) {        $tz_hour = 0;      }      if (!$tz_min) {        $tz_min = 0;      }      $offset_secs = (($tz_hour * 60) + $tz_min) * 60;      // is timezone ahead of GMT?  then subtract offset      if ($tz_mod == '+') {        $offset_secs *= -1;      }      $epoch += $offset_secs;    }    return $epoch;  }  else {    return FALSE;  }}/** * Parse a feed and store its items. * * @param $data *   The feed data. * @param $feed *   An associative array describing the feed to be parsed. * @return *   0 on error, 1 otherwise. */function aggregator_parse_feed(&$data, $feed) {  global $items, $image, $channel;  // Unset the global variables before we use them:  unset($GLOBALS['element'], $GLOBALS['item'], $GLOBALS['tag']);  $items = array();  $image = array();  $channel = array();  // parse the data:  $xml_parser = drupal_xml_parser_create($data);  xml_set_element_handler($xml_parser, 'aggregator_element_start', 'aggregator_element_end');  xml_set_character_data_handler($xml_parser, 'aggregator_element_data');  if (!xml_parse($xml_parser, $data, 1)) {    watchdog('aggregator', 'The feed from %site seems to be broken, due to an error "%error" on line %line.', array('%site' => $feed['title'], '%error' => xml_error_string(xml_get_error_code($xml_parser)), '%line' => xml_get_current_line_number($xml_parser)), WATCHDOG_WARNING);    drupal_set_message(t('The feed from %site seems to be broken, because of error "%error" on line %line.', array('%site' => $feed['title'], '%error' => xml_error_string(xml_get_error_code($xml_parser)), '%line' => xml_get_current_line_number($xml_parser))), 'error');    return 0;  }  xml_parser_free($xml_parser);  // We reverse the array such that we store the first item last, and the last  // item first. In the database, the newest item should be at the top.  $items = array_reverse($items);  // Initialize variables.  $title = $link = $author = $description = $guid = NULL;  foreach ($items as $item) {    unset($title, $link, $author, $description, $guid);    // Prepare the item:    foreach ($item as $key => $value) {      $item[$key] = trim($value);    }    // Resolve the item's title. If no title is found, we use up to 40    // characters of the description ending at a word boundary but not    // splitting potential entities.    if (!empty($item['TITLE'])) {      $title = $item['TITLE'];    }    elseif (!empty($item['DESCRIPTION'])) {      $title = preg_replace('/^(.*)[^\w;&].*?$/', "\\1", truncate_utf8($item['DESCRIPTION'], 40));    }    else {      $title = '';    }    // Resolve the items link.    if (!empty($item['LINK'])) {      $link = $item['LINK'];    }    else {      $link = $feed['link'];    }    $guid = isset($item['GUID']) ? $item['GUID'] : '';    // Atom feeds have a CONTENT and/or SUMMARY tag instead of a DESCRIPTION tag.    if (!empty($item['CONTENT:ENCODED'])) {      $item['DESCRIPTION'] = $item['CONTENT:ENCODED'];    }    else if (!empty($item['SUMMARY'])) {      $item['DESCRIPTION'] = $item['SUMMARY'];    }    else if (!empty($item['CONTENT'])) {      $item['DESCRIPTION'] = $item['CONTENT'];    }    // Try to resolve and parse the item's publication date. If no date is    // found, we use the current date instead.    $date = 'now';    foreach (array('PUBDATE', 'DC:DATE', 'DCTERMS:ISSUED', 'DCTERMS:CREATED', 'DCTERMS:MODIFIED', 'ISSUED', 'CREATED', 'MODIFIED', 'PUBLISHED', 'UPDATED') as $key) {      if (!empty($item[$key])) {        $date = $item[$key];        break;      }    }    $timestamp = strtotime($date); // As of PHP 5.1.0, strtotime returns FALSE on failure instead of -1.    if ($timestamp <= 0) {      $timestamp = aggregator_parse_w3cdtf($date); // Returns FALSE on failure      if (!$timestamp) {        $timestamp = time(); // better than nothing      }    }    // Save this item. Try to avoid duplicate entries as much as possible. If    // we find a duplicate entry, we resolve it and pass along its ID is such    // that we can update it if needed.    if (!empty($guid)) {      $entry = db_fetch_object(db_query("SELECT iid FROM {aggregator_item} WHERE fid = %d AND guid = '%s'", $feed['fid'], $guid));    }    else if ($link && $link != $feed['link'] && $link != $feed['url']) {      $entry = db_fetch_object(db_query("SELECT iid FROM {aggregator_item} WHERE fid = %d AND link = '%s'", $feed['fid'], $link));    }    else {      $entry = db_fetch_object(db_query("SELECT iid FROM {aggregator_item} WHERE fid = %d AND title = '%s'", $feed['fid'], $title));    }    $item += array('AUTHOR' => '', 'DESCRIPTION' => '');    aggregator_save_item(array('iid' => (isset($entry->iid) ? $entry->iid:  ''), 'fid' => $feed['fid'], 'timestamp' => $timestamp, 'title' => $title, 'link' => $link, 'author' => $item['AUTHOR'], 'description' => $item['DESCRIPTION'], 'guid' => $guid));  }  // Remove all items that are older than flush item timer.  $age = time() - variable_get('aggregator_clear', 9676800);  $result = db_query('SELECT iid FROM {aggregator_item} WHERE fid = %d AND timestamp < %d', $feed['fid'], $age);  $items = array();  $num_rows = FALSE;  while ($item = db_fetch_object($result)) {    $items[] = $item->iid;    $num_rows = TRUE;  }  if ($num_rows) {    db_query('DELETE FROM {aggregator_category_item} WHERE iid IN ('. implode(', ', $items) .')');    db_query('DELETE FROM {aggregator_item} WHERE fid = %d AND timestamp < %d', $feed['fid'], $age);  }  return 1;}/** * Add/edit/delete an aggregator item. * * @param $edit *   An associative array describing the item to be added/edited/deleted. */function aggregator_save_item($edit) {  if ($edit['iid'] && $edit['title']) {    db_query("UPDATE {aggregator_item} SET title = '%s', link = '%s', author = '%s', description = '%s', guid = '%s', timestamp = %d WHERE iid = %d", $edit['title'], $edit['link'], $edit['author'], $edit['description'], $edit['guid'], $edit['timestamp'], $edit['iid']);  }  else if ($edit['iid']) {    db_query('DELETE FROM {aggregator_item} WHERE iid = %d', $edit['iid']);    db_query('DELETE FROM {aggregator_category_item} WHERE iid = %d', $edit['iid']);  }  else if ($edit['title'] && $edit['link']) {    db_query("INSERT INTO {aggregator_item} (fid, title, link, author, description, timestamp, guid) VALUES (%d, '%s', '%s', '%s', '%s', %d, '%s')", $edit['fid'], $edit['title'], $edit['link'], $edit['author'], $edit['description'], $edit['timestamp'], $edit['guid']);    $edit['iid'] = db_last_insert_id('aggregator_item', 'iid');    // file the items in the categories indicated by the feed    $categories = db_query('SELECT cid FROM {aggregator_category_feed} WHERE fid = %d', $edit['fid']);    while ($category = db_fetch_object($categories)) {      db_query('INSERT INTO {aggregator_category_item} (cid, iid) VALUES (%d, %d)', $category->cid, $edit['iid']);    }  }}/** * Load an aggregator feed. * * @param $fid *   The feed id. * @return *   An associative array describing the feed. */function aggregator_feed_load($fid) {  static $feeds;  if (!isset($feeds[$fid])) {    $feeds[$fid] = db_fetch_array(db_query('SELECT * FROM {aggregator_feed} WHERE fid = %d', $fid));  }  return $feeds[$fid];}/** * Load an aggregator category. * * @param $cid *   The category id. * @return *   An associative array describing the category. */function aggregator_category_load($cid) {  static $categories;  if (!isset($categories[$cid])) {    $categories[$cid] = db_fetch_array(db_query('SELECT * FROM {aggregator_category} WHERE cid = %d', $cid));  }  return $categories[$cid];}/** * Format an individual feed item for display in the block. * * @param $item *   The item to be displayed. * @param $feed *   Not used. * @return *   The item HTML. * @ingroup themeable */function theme_aggregator_block_item($item, $feed = 0) {  global $user;  $output = '';  if ($user->uid && module_exists('blog') && user_access('create blog entries')) {    if ($image = theme('image', 'misc/blog.png', t('blog it'), t('blog it'))) {      $output .= '<div class="icon">'. l($image, 'node/add/blog', array('attributes' => array('title' => t('Comment on this news item in your personal blog.'), 'class' => 'blog-it'), 'query' => "iid=$item->iid", 'html' => TRUE)) .'</div>';    }  }  // Display the external link to the item.  $output .= '<a href="'. check_url($item->link) .'">'. check_plain($item->title) ."</a>\n";  return $output;}/** * Safely render HTML content, as allowed. * * @param $value *   The content to be filtered. * @return *   The filtered content. */function aggregator_filter_xss($value) {  return filter_xss($value, preg_split('/\s+|<|>/', variable_get('aggregator_allowed_html_tags', '<a> <b> <br> <dd> <dl> <dt> <em> <i> <li> <ol> <p> <strong> <u> <ul>'), -1, PREG_SPLIT_NO_EMPTY));}/** * Helper function for drupal_map_assoc. * * @param $count *   Items count. * @return *   Plural-formatted "@count items" */function _aggregator_items($count) {  return format_plural($count, '1 item', '@count items');}
<?php// $Id$?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="<?php print $language->language ?>" xml:lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>"><head>  <?php print $head ?>  <title><?php print $head_title ?></title>  <?php print $styles ?>  <?php print $scripts ?>  <script type="text/javascript"><?php /* Needed to avoid Flash of Unstyle Content in IE */ ?> </script></head><body><table border="0" cellpadding="0" cellspacing="0" id="header">  <tr>    <td id="logo">      <?php if ($logo) { ?><a href="<?php print $front_page ?>" title="<?php print t('Home') ?>"><img src="<?php print $logo ?>" alt="<?php print t('Home') ?>" /></a><?php } ?>      <?php if ($site_name) { ?><h1 class='site-name'><a href="<?php print $front_page ?>" title="<?php print t('Home') ?>"><?php print $site_name ?></a></h1><?php } ?>      <?php if ($site_slogan) { ?><div class='site-slogan'><?php print $site_slogan ?></div><?php } ?>    </td>    <td id="menu">      <?php if (isset($secondary_links)) { ?><?php print theme('links', $secondary_links, array('class' => 'links', 'id' => 'subnavlist')) ?><?php } ?>      <?php if (isset($primary_links)) { ?><?php print theme('links', $primary_links, array('class' => 'links', 'id' => 'navlist')) ?><?php } ?>      <?php print $search_box ?>    </td>  </tr>  <tr>    <td colspan="2"><div><?php print $header ?></div></td>  </tr></table><table border="0" cellpadding="0" cellspacing="0" id="content">  <tr>    <?php if ($left) { ?><td id="sidebar-left">      <?php print $left ?>    </td><?php } ?>    <td valign="top">      <?php if ($mission) { ?><div id="mission"><?php print $mission ?></div><?php } ?>      <div id="main">        <?php print $breadcrumb ?>        <h1 class="title"><?php print $title ?></h1>        <div class="tabs"><?php print $tabs ?></div>        <?php if ($show_messages) { print $messages; } ?>        <?php print $help ?>        <?php print $content; ?>        <?php print $feed_icons; ?>      </div>    </td>    <?php if ($right) { ?><td id="sidebar-right">      <?php print $right ?>    </td><?php } ?>  </tr></table><div id="footer">  <?php print $footer_message ?>  <?php print $footer ?></div><?php print $closure ?></body></html>
<?php// $Id$/** * @file * Page callbacks for the taxonomy module. *//** * Menu callback; displays all nodes associated with a term. */function taxonomy_term_page($str_tids = '', $depth = 0, $op = 'page') {  $terms = taxonomy_terms_parse_string($str_tids);  if ($terms['operator'] != 'and' && $terms['operator'] != 'or') {    drupal_not_found();  }  if ($terms['tids']) {    $result = db_query(db_rewrite_sql('SELECT t.tid, t.name FROM {term_data} t WHERE t.tid IN ('. db_placeholders($terms['tids']) .')', 't', 'tid'), $terms['tids']);    $tids = array(); // we rebuild the $tids-array so it only contains terms the user has access to.    $names = array();    while ($term = db_fetch_object($result)) {      $tids[] = $term->tid;      $names[] = $term->name;    }    if ($names) {      $title = implode(', ', $names);      drupal_set_title(check_plain($title));      switch ($op) {        case 'page':          // Build breadcrumb based on first hierarchy of first term:          $current->tid = $tids[0];          $breadcrumb = array();          while ($parents = taxonomy_get_parents($current->tid)) {            $current = array_shift($parents);            $breadcrumb[] = l($current->name, 'taxonomy/term/'. $current->tid);          }          $breadcrumb[] = l(t('Home'), NULL);          $breadcrumb = array_reverse($breadcrumb);          drupal_set_breadcrumb($breadcrumb);          $output = theme('taxonomy_term_page', $tids, taxonomy_select_nodes($tids, $terms['operator'], $depth, TRUE));          drupal_add_feed(url('taxonomy/term/'. $str_tids .'/'. $depth .'/feed'), 'RSS - '. $title);          return $output;          break;        case 'feed':          $channel['link'] = url('taxonomy/term/'. $str_tids .'/'. $depth, array('absolute' => TRUE));          $channel['title'] = variable_get('site_name', 'Drupal') .' - '. $title;          // Only display the description if we have a single term, to avoid clutter and confusion.          if (count($tids) == 1) {            $term = taxonomy_get_term($tids[0]);            // HTML will be removed from feed description, so no need to filter here.            $channel['description'] = $term->description;          }          $result = taxonomy_select_nodes($tids, $terms['operator'], $depth, FALSE);          $items = array();           while ($row = db_fetch_object($result)) {            $items[] = $row->nid;          }          node_feed($items, $channel);          break;        default:          drupal_not_found();      }    }    else {      drupal_not_found();    }  }}/** * Render a taxonomy term page HTML output. * * @param $tids *   An array of term ids. * @param $result *   A pager_query() result, such as that performed by taxonomy_select_nodes(). * * @ingroup themeable */function theme_taxonomy_term_page($tids, $result) {  drupal_add_css(drupal_get_path('module', 'taxonomy') .'/taxonomy.css');  $output = '';  // Only display the description if we have a single term, to avoid clutter and confusion.  if (count($tids) == 1) {    $term = taxonomy_get_term($tids[0]);    $description = $term->description;    // Check that a description is set.    if (!empty($description)) {      $output .= '<div class="taxonomy-term-description">';      $output .= filter_xss_admin($description);      $output .= '</div>';    }  }  $output .= taxonomy_render_nodes($result);  return $output;}/** * Helper function for autocompletion */function taxonomy_autocomplete($vid, $string = '') {  // The user enters a comma-separated list of tags. We only autocomplete the last tag.  $array = drupal_explode_tags($string);  // Fetch last tag  $last_string = trim(array_pop($array));  $matches = array();  if ($last_string != '') {    $result = db_query_range(db_rewrite_sql("SELECT t.tid, t.name FROM {term_data} t WHERE t.vid = %d AND LOWER(t.name) LIKE LOWER('%%%s%%')", 't', 'tid'), $vid, $last_string, 0, 10);    $prefix = count($array) ? implode(', ', $array) .', ' : '';    while ($tag = db_fetch_object($result)) {      $n = $tag->name;      // Commas and quotes in terms are special cases, so encode 'em.      if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {        $n = '"'. str_replace('"', '""', $tag->name) .'"';      }      $matches[$prefix . $n] = check_plain($tag->name);    }  }  drupal_json($matches);}
<?php// $Id$/** * @file * User page callbacks for the contact module. *//** * Site-wide contact page. */function contact_site_page() {  global $user;  if (!flood_is_allowed('contact', variable_get('contact_hourly_threshold', 3))) {    $output = t("You cannot send more than %number messages per hour. Please try again later.", array('%number' => variable_get('contact_hourly_threshold', 3)));  }  else {    $output = drupal_get_form('contact_mail_page');  }  return $output;}function contact_mail_page() {  global $user;  $form = $categories = array();  $result = db_query('SELECT cid, category, selected FROM {contact} ORDER BY weight, category');  while ($category = db_fetch_object($result)) {    $categories[$category->cid] = $category->category;    if ($category->selected) {      $default_category = $category->cid;    }  }  if (count($categories) > 0) {    $form['#token'] = $user->uid ? $user->name . $user->mail : '';    $form['contact_information'] = array('#value' => filter_xss_admin(variable_get('contact_form_information', t('You can leave a message using the contact form below.'))));    $form['name'] = array('#type' => 'textfield',      '#title' => t('Your name'),      '#maxlength' => 255,      '#default_value' => $user->uid ? $user->name : '',      '#required' => TRUE,    );    $form['mail'] = array('#type' => 'textfield',      '#title' => t('Your e-mail address'),      '#maxlength' => 255,      '#default_value' => $user->uid ? $user->mail : '',      '#required' => TRUE,    );    $form['subject'] = array('#type' => 'textfield',      '#title' => t('Subject'),      '#maxlength' => 255,      '#required' => TRUE,    );    if (count($categories) > 1) {      // If there is more than one category available and no default category has been selected,      // prepend a default placeholder value.      if (!isset($default_category)) {        $default_category = t('- Please choose -');        $categories = array($default_category) + $categories;      }      $form['cid'] = array('#type' => 'select',        '#title' => t('Category'),        '#default_value' => $default_category,        '#options' => $categories,        '#required' => TRUE,      );    }    else {      // If there is only one category, store its cid.      $category_keys = array_keys($categories);      $form['cid'] = array('#type' => 'value',        '#value' => array_shift($category_keys),      );    }    $form['message'] = array('#type' => 'textarea',      '#title' => t('Message'),      '#required' => TRUE,    );    // We do not allow anonymous users to send themselves a copy    // because it can be abused to spam people.    if ($user->uid) {      $form['copy'] = array('#type' => 'checkbox',        '#title' => t('Send yourself a copy.'),      );    }    else {      $form['copy'] = array('#type' => 'value', '#value' => FALSE);    }    $form['submit'] = array('#type' => 'submit',      '#value' => t('Send e-mail'),    );  }  else {    drupal_set_message(t('The contact form has not been configured. <a href="@add">Add one or more categories</a> to the form.', array('@add' => url('admin/build/contact/add'))), 'error');  }  return $form;}/** * Validate the site-wide contact page form submission. */function contact_mail_page_validate($form, &$form_state) {  if (!$form_state['values']['cid']) {    form_set_error('cid', t('You must select a valid category.'));  }  if (!valid_email_address($form_state['values']['mail'])) {    form_set_error('mail', t('You must enter a valid e-mail address.'));  }}/** * Process the site-wide contact page form submission. */function contact_mail_page_submit($form, &$form_state) {  global $language;  $values = $form_state['values'];  // E-mail address of the sender: as the form field is a text field,  // all instances of \r and \n have been automatically stripped from it.  $from = $values['mail'];  // Load category properties and save form values for email composition.  $contact = contact_load($values['cid']);  $values['contact'] = $contact;  // Send the e-mail to the recipients using the site default language.  drupal_mail('contact', 'page_mail', $contact['recipients'], language_default(), $values, $from);  // If the user requests it, send a copy using the current language.  if ($values['copy']) {    drupal_mail('contact', 'page_copy', $from, $language, $values, $from);  }  // Send an auto-reply if necessary using the current language.  if ($contact['reply']) {    drupal_mail('contact', 'page_autoreply', $from, $language, $values, $contact['recipients']);  }  flood_register_event('contact');  watchdog('mail', '%name-from sent an e-mail regarding %category.', array('%name-from' => $values['name'] ." [$from]", '%category' => $contact['category']));  drupal_set_message(t('Your message has been sent.'));  // Jump to home page rather than back to contact page to avoid  // contradictory messages if flood control has been activated.  $form_state['redirect'] = '';}/** * Personal contact page. */function contact_user_page($account) {  global $user;  if (!valid_email_address($user->mail)) {    $output = t('You need to provide a valid e-mail address to contact other users. Please update your <a href="@url">user information</a> and try again.', array('@url' => url("user/$user->uid/edit")));  }  else if (!flood_is_allowed('contact', variable_get('contact_hourly_threshold', 3))) {    $output = t('You cannot contact more than %number users per hour. Please try again later.', array('%number' => variable_get('contact_hourly_threshold', 3)));  }  else {    drupal_set_title(check_plain($account->name));    $output = drupal_get_form('contact_mail_user', $account);  }  return $output;}function contact_mail_user(&$form_state, $recipient) {  global $user;  $form['#token'] = $user->name . $user->mail;  $form['recipient'] = array('#type' => 'value', '#value' => $recipient);  $form['from'] = array('#type' => 'item',    '#title' => t('From'),    '#value' => theme('username', $user) .' &lt;'. check_plain($user->mail) .'&gt;',  );  $form['to'] = array('#type' => 'item',    '#title' => t('To'),    '#value' => theme('username', $recipient),  );  $form['subject'] = array('#type' => 'textfield',    '#title' => t('Subject'),    '#maxlength' => 50,    '#required' => TRUE,  );  $form['message'] = array('#type' => 'textarea',    '#title' => t('Message'),    '#rows' => 15,    '#required' => TRUE,  );  $form['copy'] = array('#type' => 'checkbox',    '#title' => t('Send yourself a copy.'),  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Send e-mail'),  );  return $form;}/** * Process the personal contact page form submission. */function contact_mail_user_submit($form, &$form_state) {  global $user, $language;  $account = $form_state['values']['recipient'];  // Send from the current user to the requested user.  $to = $account->mail;  $from = $user->mail;  // Save both users and all form values for email composition.  $values = $form_state['values'];  $values['account'] = $account;  $values['user'] = $user;  // Send the e-mail in the requested user language.  drupal_mail('contact', 'user_mail', $to, user_preferred_language($account), $values, $from);  // Send a copy if requested, using current page language.  if ($form_state['values']['copy']) {    drupal_mail('contact', 'user_copy', $from, $language, $values, $from);  }  flood_register_event('contact');  watchdog('mail', '%name-from sent %name-to an e-mail.', array('%name-from' => $user->name, '%name-to' => $account->name));  drupal_set_message(t('The message has been sent.'));  // Back to the requested users profile page.  $form_state['redirect'] = "user/$account->uid";}
<?php// $Id$/** * Implementation of hook_install(). */function forum_install() {  // Create tables.  drupal_install_schema('forum');  // Set the weight of the forum.module to 1 so it is loaded after the taxonomy.module.  db_query("UPDATE {system} SET weight = 1 WHERE name = 'forum'");}function forum_enable() {  if ($vocabulary = taxonomy_vocabulary_load(variable_get('forum_nav_vocabulary', 0))) {    // Existing install. Add back forum node type, if the forums    // vocabulary still exists. Keep all other node types intact there.    $vocabulary = (array) $vocabulary;    $vocabulary['nodes']['forum'] = 1;    taxonomy_save_vocabulary($vocabulary);  }  else {    // Create the forum vocabulary if it does not exist. Assign the vocabulary    // a low weight so it will appear first in forum topic create and edit    // forms.    $vocabulary = array(      'name' => t('Forums'),      'multiple' => 0,      'required' => 0,      'hierarchy' => 1,      'relations' => 0,      'module' => 'forum',      'weight' => -10,      'nodes' => array('forum' => 1),    );    taxonomy_save_vocabulary($vocabulary);    variable_set('forum_nav_vocabulary', $vocabulary['vid']);  }}/** * Implementation of hook_uninstall(). */function forum_uninstall() {  // Load the dependent Taxonomy module, in case it has been disabled.  drupal_load('module', 'taxonomy');  // Delete the vocabulary.  $vid = variable_get('forum_nav_vocabulary', '');  taxonomy_del_vocabulary($vid);  db_query('DROP TABLE {forum}');  variable_del('forum_containers');  variable_del('forum_nav_vocabulary');  variable_del('forum_hot_topic');  variable_del('forum_per_page');  variable_del('forum_order');  variable_del('forum_block_num_0');  variable_del('forum_block_num_1');}/** * Implementation of hook_schema(). */function forum_schema() {  $schema['forum'] = array(    'description' => 'Stores the relationship of nodes to forum terms.',    'fields' => array(      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid of the node.',      ),      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {node}.vid of the node.',      ),      'tid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {term_data}.tid of the forum term assigned to the node.',      ),    ),    'indexes' => array(      'nid' => array('nid'),      'tid' => array('tid')    ),    'primary key' => array('vid'),  );  return $schema;}/** * Create the forum vocabulary if does not exist. Assign the * vocabulary a low weight so it will appear first in forum topic * create and edit forms.  Do not just call forum_enable() because in * future versions it might do something different. */function forum_update_6000() {  $ret = array();  $vid = variable_get('forum_nav_vocabulary', 0);  $vocabularies = taxonomy_get_vocabularies();  if (!isset($vocabularies[$vid])) {    $vocabulary = array(      'name' => t('Forums'),      'multiple' => 0,      'required' => 0,      'hierarchy' => 1,      'relations' => 0,      'module' => 'forum',      'weight' => -10,      'nodes' => array('forum' => 1),    );    taxonomy_save_vocabulary($vocabulary);    variable_set('forum_nav_vocabulary', $vocabulary['vid']);  }  return $ret;}
<?php// $Id$/** * @file * Admin page callbacks for the system module. *//** * Menu callback; Provide the administration overview page. */function system_main_admin_page($arg = NULL) {  // If we received an argument, they probably meant some other page.  // Let's 404 them since the menu system cannot be told we do not  // accept arguments.  if (isset($arg) && substr($arg, 0, 3) != 'by-') {    return drupal_not_found();  }  // Check for status report errors.  if (system_status(TRUE) && user_access('administer site configuration')) {    drupal_set_message(t('One or more problems were detected with your Drupal installation. Check the <a href="@status">status report</a> for more information.', array('@status' => url('admin/reports/status'))), 'error');  }  $blocks = array();  if ($admin = db_fetch_array(db_query("SELECT menu_name, mlid FROM {menu_links} WHERE link_path = 'admin' AND module = 'system'"))) {    $result = db_query("      SELECT m.*, ml.*      FROM {menu_links} ml      INNER JOIN {menu_router} m ON ml.router_path = m.path      WHERE ml.link_path != 'admin/help' AND menu_name = '%s' AND ml.plid = %d AND hidden = 0", $admin);    while ($item = db_fetch_array($result)) {      _menu_link_translate($item);      if (!$item['access']) {        continue;      }      // The link 'description' either derived from the hook_menu 'description'      // or entered by the user via menu module is saved as the title attribute.      if (!empty($item['localized_options']['attributes']['title'])) {        $item['description'] = $item['localized_options']['attributes']['title'];      }      $block = $item;      $block['content'] = '';      if ($item['block_callback'] && function_exists($item['block_callback'])) {        $function = $item['block_callback'];        $block['content'] .= $function();      }      $block['content'] .= theme('admin_block_content', system_admin_menu_block($item));      // Prepare for sorting as in function _menu_tree_check_access().      // The weight is offset so it is always positive, with a uniform 5-digits.      $blocks[(50000 + $item['weight']) .' '. $item['title'] .' '. $item['mlid']] = $block;    }  }  if ($blocks) {    ksort($blocks);    return theme('admin_page', $blocks);  }  else {    return t('You do not have any administrative items.');  }}/** * Provide a single block from the administration menu as a page. * This function is often a destination for these blocks. * For example, 'admin/content/types' needs to have a destination to be valid * in the Drupal menu system, but too much information there might be * hidden, so we supply the contents of the block. * * @return *   The output HTML. */function system_admin_menu_block_page() {  $item = menu_get_item();  if ($content = system_admin_menu_block($item)) {    $output = theme('admin_block_content', $content);  }  else {    $output = t('You do not have any administrative items.');  }  return $output;}/** * Menu callback; Sets whether the admin menu is in compact mode or not. * * @param $mode *   Valid values are 'on' and 'off'. */function system_admin_compact_page($mode = 'off') {  global $user;  user_save($user, array('admin_compact_mode' => ($mode == 'on')));  drupal_goto('admin');}/** * Menu callback; prints a listing of admin tasks for each installed module. */function system_admin_by_module() {  $modules = module_rebuild_cache();  $menu_items = array();  $help_arg = module_exists('help') ? drupal_help_arg() : FALSE;  foreach ($modules as $file) {    $module = $file->name;    if ($module == 'help') {      continue;    }    $admin_tasks = system_get_module_admin_tasks($module);    // Only display a section if there are any available tasks.    if (count($admin_tasks)) {      // Check for help links.      if ($help_arg && module_invoke($module, 'help', "admin/help#$module", $help_arg)) {        $admin_tasks[100] = l(t('Get help'), "admin/help/$module");      }      // Sort.      ksort($admin_tasks);      $menu_items[$file->info['name']] = array($file->info['description'], $admin_tasks);    }  }  return theme('system_admin_by_module', $menu_items);}/** * Menu callback; displays a module's settings page. */function system_settings_overview() {  // Check database setup if necessary  if (function_exists('db_check_setup') && empty($_POST)) {    db_check_setup();  }  $item = menu_get_item('admin/settings');  $content = system_admin_menu_block($item);  $output = theme('admin_block_content', $content);  return $output;}/** * Form builder; This function allows selection of the theme to show in administration sections. * * @ingroup forms * @see system_settings_form() */function system_admin_theme_settings() {  $themes = system_theme_data();  uasort($themes, 'system_sort_modules_by_info_name');  $options[0] = '<'. t('System default') .'>';  foreach ($themes as $theme) {    $options[$theme->name] = $theme->info['name'];  }  $form['admin_theme'] = array(    '#type' => 'select',    '#options' => $options,    '#title' => t('Administration theme'),    '#description' => t('Choose which theme the administration pages should display in. If you choose "System default" the administration pages will use the same theme as the rest of the site.'),    '#default_value' => variable_get('admin_theme', '0'),  );  $form['node_admin_theme'] = array(    '#type' => 'checkbox',    '#title' => t('Use administration theme for content editing'),    '#description' => t('Use the administration theme when editing existing posts or creating new ones.'),    '#default_value' => variable_get('node_admin_theme', '0'),  );  $form['#submit'][] = 'system_admin_theme_submit';  return system_settings_form($form);}/** * Menu callback; displays a listing of all themes. * * @ingroup forms * @see system_themes_form_submit() */function system_themes_form() {  $themes = system_theme_data();  uasort($themes, 'system_sort_modules_by_info_name');  $status = array();  $incompatible_core = array();  $incompatible_php = array();  foreach ($themes as $theme) {    $screenshot = NULL;    // Create a list which includes the current theme and all its base themes.    if (isset($themes[$theme->name]->base_themes)) {      $theme_keys = array_keys($themes[$theme->name]->base_themes);      $theme_keys[] = $theme->name;    }    else {      $theme_keys = array($theme->name);    }    // Look for a screenshot in the current theme or in its closest ancestor.    foreach (array_reverse($theme_keys) as $theme_key) {      if (isset($themes[$theme_key]) && file_exists($themes[$theme_key]->info['screenshot'])) {        $screenshot = $themes[$theme_key]->info['screenshot'];        break;      }    }    $screenshot = $screenshot ? theme('image', $screenshot, t('Screenshot for %theme theme', array('%theme' => $theme->info['name'])), '', array('class' => 'screenshot'), FALSE) : t('no screenshot');    $form[$theme->name]['screenshot'] = array('#value' => $screenshot);    $form[$theme->name]['info'] = array(      '#type' => 'value',      '#value' => $theme->info,    );    $options[$theme->name] = '';    if (!empty($theme->status) || $theme->name == variable_get('admin_theme', '0')) {      $form[$theme->name]['operations'] = array('#value' => l(t('configure'), 'admin/build/themes/settings/'. $theme->name) );    }    else {      // Dummy element for drupal_render. Cleaner than adding a check in the theme function.      $form[$theme->name]['operations'] = array();    }    if (!empty($theme->status)) {      $status[] = $theme->name;    }    else {      // Ensure this theme is compatible with this version of core.      if (!isset($theme->info['core']) || $theme->info['core'] != DRUPAL_CORE_COMPATIBILITY) {        $incompatible_core[] = $theme->name;      }      if (version_compare(phpversion(), $theme->info['php']) < 0) {        $incompatible_php[$theme->name] = $theme->info['php'];      }    }  }  $form['status'] = array(    '#type' => 'checkboxes',    '#options' => $options,    '#default_value' => $status,    '#incompatible_themes_core' => drupal_map_assoc($incompatible_core),    '#incompatible_themes_php' => $incompatible_php,  );  $form['theme_default'] = array(    '#type' => 'radios',    '#options' => $options,    '#default_value' => variable_get('theme_default', 'garland'),  );  $form['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Save configuration'),  );  $form['buttons']['reset'] = array(    '#type' => 'submit',    '#value' => t('Reset to defaults'),  );  return $form;}/** * Process system_themes_form form submissions. */function system_themes_form_submit($form, &$form_state) {  drupal_clear_css_cache();  // Store list of previously enabled themes and disable all themes  $old_theme_list = $new_theme_list = array();  foreach (list_themes() as $theme) {    if ($theme->status) {      $old_theme_list[] = $theme->name;    }  }  db_query("UPDATE {system} SET status = 0 WHERE type = 'theme'");  if ($form_state['values']['op'] == t('Save configuration')) {    if (is_array($form_state['values']['status'])) {      foreach ($form_state['values']['status'] as $key => $choice) {        // Always enable the default theme, despite its status checkbox being checked:        if ($choice || $form_state['values']['theme_default'] == $key) {          system_initialize_theme_blocks($key);          $new_theme_list[] = $key;          db_query("UPDATE {system} SET status = 1 WHERE type = 'theme' and name = '%s'", $key);        }      }    }    if (($admin_theme = variable_get('admin_theme', '0')) != '0' && $admin_theme != $form_state['values']['theme_default']) {      drupal_set_message(t('Please note that the <a href="!admin_theme_page">administration theme</a> is still set to the %admin_theme theme; consequently, the theme on this page remains unchanged. All non-administrative sections of the site, however, will show the selected %selected_theme theme by default.', array(        '!admin_theme_page' => url('admin/settings/admin'),        '%admin_theme' => $admin_theme,        '%selected_theme' => $form_state['values']['theme_default'],      )));    }    variable_set('theme_default', $form_state['values']['theme_default']);  }  else {    // Revert to defaults: only Garland is enabled.    variable_del('theme_default');    db_query("UPDATE {system} SET status = 1 WHERE type = 'theme' AND name = 'garland'");    $new_theme_list = array('garland');  }  list_themes(TRUE);  menu_rebuild();  drupal_rebuild_theme_registry();  drupal_set_message(t('The configuration options have been saved.'));  $form_state['redirect'] = 'admin/build/themes';  // Notify locale module about new themes being enabled, so translations can  // be imported. This might start a batch, and only return to the redirect  // path after that.  module_invoke('locale', 'system_update', array_diff($new_theme_list, $old_theme_list));  return;}/** * Form builder; display theme configuration for entire site and individual themes. * * @param $key *   A theme name. * @return *   The form structure. * @ingroup forms * @see system_theme_settings_submit() */function system_theme_settings(&$form_state, $key = '') {  $directory_path = file_directory_path();  file_check_directory($directory_path, FILE_CREATE_DIRECTORY, 'file_directory_path');  // Default settings are defined in theme_get_settings() in includes/theme.inc  if ($key) {    $settings = theme_get_settings($key);    $var = str_replace('/', '_', 'theme_'. $key .'_settings');    $themes = system_theme_data();    $features = $themes[$key]->info['features'];  }  else {    $settings = theme_get_settings('');    $var = 'theme_settings';  }  $form['var'] = array('#type' => 'hidden', '#value' => $var);  // Check for a new uploaded logo, and use that instead.  if ($file = file_save_upload('logo_upload', array('file_validate_is_image' => array()))) {    $parts = pathinfo($file->filename);    $filename = ($key) ? str_replace('/', '_', $key) .'_logo.'. $parts['extension'] : 'logo.'. $parts['extension'];    // The image was saved using file_save_upload() and was added to the    // files table as a temporary file. We'll make a copy and let the garbage    // collector delete the original upload.    if (file_copy($file, $filename, FILE_EXISTS_REPLACE)) {      $_POST['default_logo'] = 0;      $_POST['logo_path'] = $file->filepath;      $_POST['toggle_logo'] = 1;    }  }  // Check for a new uploaded favicon, and use that instead.  if ($file = file_save_upload('favicon_upload')) {    $parts = pathinfo($file->filename);    $filename = ($key) ? str_replace('/', '_', $key) .'_favicon.'. $parts['extension'] : 'favicon.'. $parts['extension'];    // The image was saved using file_save_upload() and was added to the    // files table as a temporary file. We'll make a copy and let the garbage    // collector delete the original upload.    if (file_copy($file, $filename)) {      $_POST['default_favicon'] = 0;      $_POST['favicon_path'] = $file->filepath;      $_POST['toggle_favicon'] = 1;    }  }  // Toggle settings  $toggles = array(    'logo'                 => t('Logo'),    'name'                 => t('Site name'),    'slogan'               => t('Site slogan'),    'mission'              => t('Mission statement'),    'node_user_picture'    => t('User pictures in posts'),    'comment_user_picture' => t('User pictures in comments'),    'search'               => t('Search box'),    'favicon'              => t('Shortcut icon'),    'primary_links'        => t('Primary links'),    'secondary_links'      => t('Secondary links'),  );  // Some features are not always available  $disabled = array();  if (!variable_get('user_pictures', 0)) {    $disabled['toggle_node_user_picture'] = TRUE;    $disabled['toggle_comment_user_picture'] = TRUE;  }  if (!module_exists('search')) {    $disabled['toggle_search'] = TRUE;  }  $form['theme_settings'] = array(    '#type' => 'fieldset',    '#title' => t('Toggle display'),    '#description' => t('Enable or disable the display of certain page elements.'),  );  foreach ($toggles as $name => $title) {    if ((!$key) || in_array($name, $features)) {      $form['theme_settings']['toggle_'. $name] = array('#type' => 'checkbox', '#title' => $title, '#default_value' => $settings['toggle_'. $name]);      // Disable checkboxes for features not supported in the current configuration.      if (isset($disabled['toggle_'. $name])) {        $form['theme_settings']['toggle_'. $name]['#disabled'] = TRUE;      }    }  }  // System wide only settings.  if (!$key) {    // Create neat 2-column layout for the toggles    $form['theme_settings'] += array(      '#prefix' => '<div class="theme-settings-left">',      '#suffix' => '</div>',    );    // Toggle node display.    $node_types = node_get_types('names');    if ($node_types) {      $form['node_info'] = array(        '#type' => 'fieldset',        '#title' => t('Display post information on'),        '#description' => t('Enable or disable the <em>submitted by Username on date</em> text when displaying posts of the following type.'),        '#prefix' => '<div class="theme-settings-right">',        '#suffix' => '</div>',      );      foreach ($node_types as $type => $name) {        $form['node_info']["toggle_node_info_$type"] = array('#type' => 'checkbox', '#title' => check_plain($name), '#default_value' => $settings["toggle_node_info_$type"]);      }    }  }  elseif (!element_children($form['theme_settings'])) {    // If there is no element in the theme settings fieldset then do not show    // it -- but keep it in the form if another module wants to alter.    $form['theme_settings']['#access'] = FALSE;  }  // Logo settings  if ((!$key) || in_array('logo', $features)) {    $form['logo'] = array(      '#type' => 'fieldset',      '#title' => t('Logo image settings'),      '#description' => t('If toggled on, the following logo will be displayed.'),      '#attributes' => array('class' => 'theme-settings-bottom'),    );    $form['logo']["default_logo"] = array(      '#type' => 'checkbox',      '#title' => t('Use the default logo'),      '#default_value' => $settings['default_logo'],      '#tree' => FALSE,      '#description' => t('Check here if you want the theme to use the logo supplied with it.')    );    $form['logo']['logo_path'] = array(      '#type' => 'textfield',      '#title' => t('Path to custom logo'),      '#default_value' => $settings['logo_path'],      '#description' => t('The path to the file you would like to use as your logo file instead of the default logo.'));    $form['logo']['logo_upload'] = array(      '#type' => 'file',      '#title' => t('Upload logo image'),      '#maxlength' => 40,      '#description' => t("If you don't have direct file access to the server, use this field to upload your logo.")    );  }  if ((!$key) || in_array('favicon', $features)) {    $form['favicon'] = array(      '#type' => 'fieldset',      '#title' => t('Shortcut icon settings'),      '#description' => t("Your shortcut icon, or 'favicon', is displayed in the address bar and bookmarks of most browsers.")    );    $form['favicon']['default_favicon'] = array(      '#type' => 'checkbox',      '#title' => t('Use the default shortcut icon.'),      '#default_value' => $settings['default_favicon'],      '#description' => t('Check here if you want the theme to use the default shortcut icon.')    );    $form['favicon']['favicon_path'] = array(      '#type' => 'textfield',      '#title' => t('Path to custom icon'),      '#default_value' => $settings['favicon_path'],      '#description' => t('The path to the image file you would like to use as your custom shortcut icon.')    );    $form['favicon']['favicon_upload'] = array(      '#type' => 'file',      '#title' => t('Upload icon image'),      '#description' => t("If you don't have direct file access to the server, use this field to upload your shortcut icon.")    );  }  if ($key) {    // Include the theme's theme-settings.php file    $filename = './'. str_replace("/$key.info", '', $themes[$key]->filename) .'/theme-settings.php';    if (!file_exists($filename) and !empty($themes[$key]->info['base theme'])) {      // If the theme doesn't have a theme-settings.php file, use the base theme's.      $base = $themes[$key]->info['base theme'];      $filename = './'. str_replace("/$base.info", '', $themes[$base]->filename) .'/theme-settings.php';    }    if (file_exists($filename)) {      require_once $filename;    }    // Call engine-specific settings.    $function = $themes[$key]->prefix .'_engine_settings';    if (function_exists($function)) {      $group = $function($settings);      if (!empty($group)) {        $form['engine_specific'] = array('#type' => 'fieldset', '#title' => t('Theme-engine-specific settings'), '#description' => t('These settings only exist for all the templates and styles based on the %engine theme engine.', array('%engine' => $themes[$key]->prefix)));        $form['engine_specific'] = array_merge($form['engine_specific'], $group);      }    }    // Call theme-specific settings.    $function = $key .'_settings';    if (!function_exists($function)) {      $function = $themes[$key]->prefix .'_settings';    }    if (function_exists($function)) {      $group = $function($settings);      if (!empty($group)) {        $form['theme_specific'] = array('#type' => 'fieldset', '#title' => t('Theme-specific settings'), '#description' => t('These settings only exist for the %theme theme and all the styles based on it.', array('%theme' => $themes[$key]->info['name'])));        $form['theme_specific'] = array_merge($form['theme_specific'], $group);      }    }  }  $form['#attributes'] = array('enctype' => 'multipart/form-data');  $form = system_settings_form($form);  // We don't want to call system_settings_form_submit(), so change #submit.  $form['#submit'] = array('system_theme_settings_submit');  return $form;}/** * Process system_theme_settings form submissions. */function system_theme_settings_submit($form, &$form_state) {  $values = $form_state['values'];  $key = $values['var'];  if ($values['op'] == t('Reset to defaults')) {    variable_del($key);    drupal_set_message(t('The configuration options have been reset to their default values.'));  }  else {    // Exclude unnecessary elements before saving.    unset($values['var'], $values['submit'], $values['reset'], $values['form_id'], $values['op'], $values['form_build_id'], $values['form_token']);    variable_set($key, $values);    drupal_set_message(t('The configuration options have been saved.'));  }  cache_clear_all();}/** * Recursively check compatibility. * * @param $incompatible *   An associative array which at the end of the check contains all incompatible files as the keys, their values being TRUE. * @param $files *   The set of files that will be tested. * @param $file *   The file at which the check starts. * @return *   Returns TRUE if an incompatible file is found, NULL (no return value) otherwise. */function _system_is_incompatible(&$incompatible, $files, $file) {  static $seen;  // We need to protect ourselves in case of a circular dependency.  if (isset($seen[$file->name])) {    return isset($incompatible[$file->name]);  }  $seen[$file->name] = TRUE;  if (isset($incompatible[$file->name])) {    return TRUE;  }  // The 'dependencies' key in .info files was a string in Drupal 5, but changed  // to an array in Drupal 6. If it is not an array, the module is not  // compatible and we can skip the check below which requires an array.  if (!is_array($file->info['dependencies'])) {    $file->info['dependencies'] = array();    $incompatible[$file->name] = TRUE;    return TRUE;  }  // Recursively traverse the dependencies, looking for incompatible modules  foreach ($file->info['dependencies'] as $dependency) {    if (isset($files[$dependency]) && _system_is_incompatible($incompatible, $files, $files[$dependency])) {      $incompatible[$file->name] = TRUE;      return TRUE;    }  }}/** * Menu callback; provides module enable/disable interface. * * Modules can be enabled or disabled and set for throttling if the throttle module is enabled. * The list of modules gets populated by module.info files, which contain each module's name, * description and dependencies. * @see drupal_parse_info_file for information on module.info descriptors. * * Dependency checking is performed to ensure that a module cannot be enabled if the module has * disabled dependencies and also to ensure that the module cannot be disabled if the module has * enabled dependents. * * @param $form_state *   An associative array containing the current state of the form. * @ingroup forms * @see theme_system_modules() * @see system_modules_submit() * @return *   The form array. */function system_modules($form_state = array()) {  // Get current list of modules.  $files = module_rebuild_cache();  uasort($files, 'system_sort_modules_by_info_name');  if (!empty($form_state['storage'])) {    return system_modules_confirm_form($files, $form_state['storage']);  }  $dependencies = array();  // Store module list for validation callback.  $form['validation_modules'] = array('#type' => 'value', '#value' => $files);  // Create storage for disabled modules as browser will disable checkboxes.  $form['disabled_modules'] = array('#type' => 'value', '#value' => array());  // Traverse the files, checking for compatibility  $incompatible_core = array();  $incompatible_php = array();  foreach ($files as $filename => $file) {    // Ensure this module is compatible with this version of core.    if (!isset($file->info['core']) || $file->info['core'] != DRUPAL_CORE_COMPATIBILITY) {      $incompatible_core[$file->name] = $file->name;    }    // Ensure this module is compatible with the currently installed version of PHP.    if (version_compare(phpversion(), $file->info['php']) < 0) {      $incompatible_php[$file->name] = $file->info['php'];    }  }  // Array for disabling checkboxes in callback system_module_disable.  $disabled = array();  $throttle = array();  // Traverse the files retrieved and build the form.  foreach ($files as $filename => $file) {    $form['name'][$filename] = array('#value' => $file->info['name']);    $form['version'][$filename] = array('#value' => $file->info['version']);    $form['description'][$filename] = array('#value' => t($file->info['description']));    $options[$filename] = '';    // Ensure this module is compatible with this version of core and php.    if (_system_is_incompatible($incompatible_core, $files, $file) || _system_is_incompatible($incompatible_php, $files, $file)) {      $disabled[] = $file->name;      // Nothing else in this loop matters, so move to the next module.      continue;    }    if ($file->status) {      $status[] = $file->name;    }    if ($file->throttle) {      $throttle[] = $file->name;    }    $dependencies = array();    // Check for missing dependencies.    if (is_array($file->info['dependencies'])) {      foreach ($file->info['dependencies'] as $dependency) {        if (!isset($files[$dependency]) || !$files[$dependency]->status) {          if (isset($files[$dependency])) {            $dependencies[] = t('@module (<span class="admin-disabled">disabled</span>)', array('@module' => $files[$dependency]->info['name']));          }          else {            $dependencies[] = t('@module (<span class="admin-missing">missing</span>)', array('@module' => drupal_ucfirst($dependency)));            $disabled[] = $filename;            $form['disabled_modules']['#value'][$filename] = FALSE;          }        }        else {          $dependencies[] = t('@module (<span class="admin-enabled">enabled</span>)', array('@module' => $files[$dependency]->info['name']));        }      }      // Add text for dependencies.      if (!empty($dependencies)) {        $form['description'][$filename]['dependencies'] = array(          '#value' => t('Depends on: !dependencies', array('!dependencies' => implode(', ', $dependencies))),          '#prefix' => '<div class="admin-dependencies">',          '#suffix' => '</div>',        );      }    }    // Mark dependents disabled so user can not remove modules being depended on.    $dependents = array();    foreach ($file->info['dependents'] as $dependent) {      if ($files[$dependent]->status == 1) {        $dependents[] = t('@module (<span class="admin-enabled">enabled</span>)', array('@module' => $files[$dependent]->info['name']));        $disabled[] = $filename;        $form['disabled_modules']['#value'][$filename] = TRUE;      }      else {        $dependents[] = t('@module (<span class="admin-disabled">disabled</span>)', array('@module' => $files[$dependent]->info['name']));      }    }    // Add text for enabled dependents.    if (!empty($dependents)) {      $form['description'][$filename]['required'] = array(        '#value' => t('Required by: !required', array('!required' => implode(', ', $dependents))),        '#prefix' => '<div class="admin-required">',        '#suffix' => '</div>',      );    }  }  $modules_required = drupal_required_modules();  // Merge in required modules.  foreach ($modules_required as $required) {    $disabled[] = $required;    $form['disabled_modules']['#value'][$required] = TRUE;  }  // Handle status checkboxes, including overriding  // the generated checkboxes for required modules.  $form['status'] = array(    '#type' => 'checkboxes',    '#default_value' => $status,    '#options' => $options,    '#process' => array(      'expand_checkboxes',      'system_modules_disable',    ),    '#disabled_modules' => $disabled,    '#incompatible_modules_core' => $incompatible_core,    '#incompatible_modules_php' => $incompatible_php,  );  // Handle throttle checkboxes, including overriding the  // generated checkboxes for required modules.  if (module_exists('throttle')) {    $form['throttle'] = array(      '#type' => 'checkboxes',      '#default_value' => $throttle,      '#options' => $options,      '#process' => array(        'expand_checkboxes',        'system_modules_disable',      ),      '#disabled_modules' => array_merge($modules_required, array('throttle')),    );  }  $form['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Save configuration'),  );  $form['#action'] = url('admin/build/modules/list/confirm');  return $form;}/** * Array sorting callback; sorts modules or themes by their name. */function system_sort_modules_by_info_name($a, $b) {  return strcasecmp($a->info['name'], $b->info['name']);}/** * Form process callback function to disable check boxes. * * @param $form *   The form structure. * @param $edit *   Not used. * @ingroup forms * @return *   The form structure. */function system_modules_disable($form, $edit) {  foreach ($form['#disabled_modules'] as $key) {    $form[$key]['#attributes']['disabled'] = 'disabled';  }  return $form;}/** * Display confirmation form for dependencies. * * @param $modules *   Array of module file objects as returned from module_rebuild_cache(). * @param $storage *   The contents of $form_state['storage']; an array with two *   elements: the list of dependencies and the list of status *   form field values from the previous screen. * @ingroup forms */function system_modules_confirm_form($modules, $storage) {  $form = array();  $items = array();  list($dependencies, $status) = $storage;  $form['validation_modules'] = array('#type' => 'value', '#value' => $modules);  $form['status']['#tree'] = TRUE;  // Remember list of modules selected on the module listing page already.  foreach ($status as $key => $choice) {    $form['status'][$key] = array('#type' => 'value', '#value' => $choice);  }  foreach ($dependencies as $name => $missing_dependencies) {    $form['status'][$name] = array('#type' => 'hidden', '#value' => 1);    foreach ($missing_dependencies as $k => $dependency) {      $form['status'][$dependency] = array('#type' => 'hidden', '#value' => 1);      $info = $modules[$dependency]->info;      $missing_dependencies[$k] = $info['name'] ? $info['name'] : drupal_ucfirst($dependency);    }    $t_argument = array(      '@module' => $modules[$name]->info['name'],      '@dependencies' => implode(', ', $missing_dependencies),    );    $items[] = format_plural(count($missing_dependencies), 'You must enable the @dependencies module to install @module.', 'You must enable the @dependencies modules to install @module.', $t_argument);  }  $form['text'] = array('#value' => theme('item_list', $items));  if ($form) {    // Set some default form values    $form = confirm_form(      $form,      t('Some required modules must be enabled'),      'admin/build/modules',      t('Would you like to continue with enabling the above?'),      t('Continue'),      t('Cancel'));    return $form;  }}/** * Submit callback; handles modules form submission. */function system_modules_submit($form, &$form_state) {  include_once './includes/install.inc';  $new_modules = array();  // If we are coming from the confirm form...  if (!isset($form_state['storage'])) {    // Merge in disabled active modules since they should be enabled.    // They don't appear because disabled checkboxes are not submitted    // by browsers.    $form_state['values']['status'] = array_merge($form_state['values']['status'], $form_state['values']['disabled_modules']);    // Check values for dependency that we can't install.    if ($dependencies = system_module_build_dependencies($form_state['values']['validation_modules'], $form_state['values'])) {      // These are the modules that depend on existing modules.      foreach (array_keys($dependencies) as $name) {        $form_state['values']['status'][$name] = 0;      }    }  }  else {    $dependencies = NULL;  }  // Update throttle settings, if present  if (isset($form_state['values']['throttle'])) {    foreach ($form_state['values']['throttle'] as $key => $choice) {      db_query("UPDATE {system} SET throttle = %d WHERE type = 'module' and name = '%s'", $choice ? 1 : 0, $key);    }  }  // If there where unmet dependencies and they haven't confirmed don't process  // the submission yet. Store the form submission data needed later.  if ($dependencies) {    if (!isset($form_state['values']['confirm'])) {      $form_state['storage'] = array($dependencies, $form_state['values']['status']);      return;    }    else {      $form_state['values']['status'] = array_merge($form_state['values']['status'], $form_storage[1]);    }  }  // If we have no dependencies, or the dependencies are confirmed  // to be installed, we don't need the temporary storage anymore.  unset($form_state['storage']);  $enable_modules = array();  $disable_modules = array();  foreach ($form_state['values']['status'] as $key => $choice) {    if ($choice) {      if (drupal_get_installed_schema_version($key) == SCHEMA_UNINSTALLED) {        $new_modules[] = $key;      }      else {        $enable_modules[] = $key;      }    }    else {      $disable_modules[] = $key;    }  }  $old_module_list = module_list();  if (!empty($enable_modules)) {    module_enable($enable_modules);  }  if (!empty($disable_modules)) {    module_disable($disable_modules);  }  // Install new modules.  foreach ($new_modules as $key => $module) {    if (!drupal_check_module($module)) {      unset($new_modules[$key]);    }  }  drupal_install_modules($new_modules);  $current_module_list = module_list(TRUE, FALSE);  if ($old_module_list != $current_module_list) {    drupal_set_message(t('The configuration options have been saved.'));  }  drupal_rebuild_theme_registry();  node_types_rebuild();  menu_rebuild();  cache_clear_all('schema', 'cache');  drupal_clear_css_cache();  drupal_clear_js_cache();  $form_state['redirect'] = 'admin/build/modules';  // Notify locale module about module changes, so translations can be  // imported. This might start a batch, and only return to the redirect  // path after that.  module_invoke('locale', 'system_update', $new_modules);  // Synchronize to catch any actions that were added or removed.  actions_synchronize();  return;}/** * Generate a list of dependencies for modules that are going to be switched on. * * @param $modules *   The list of modules to check. * @param $form_values *   Submitted form values used to determine what modules have been enabled. * @return *   An array of dependencies. */function system_module_build_dependencies($modules, $form_values) {  static $dependencies;  if (!isset($dependencies) && isset($form_values)) {    $dependencies = array();    foreach ($modules as $name => $module) {      // If the module is disabled, will be switched on and it has dependencies.      if (!$module->status && $form_values['status'][$name] && isset($module->info['dependencies'])) {        foreach ($module->info['dependencies'] as $dependency) {          if (!$form_values['status'][$dependency] && isset($modules[$dependency])) {            if (!isset($dependencies[$name])) {              $dependencies[$name] = array();            }            $dependencies[$name][] = $dependency;          }        }      }    }  }  return $dependencies;}/** * Uninstall functions *//** * Builds a form of currently disabled modules. * * @ingroup forms * @see system_modules_uninstall_validate() * @see system_modules_uninstall_submit() * @param $form_state['values'] *   Submitted form values. * @return *   A form array representing the currently disabled modules. */function system_modules_uninstall($form_state = NULL) {  // Make sure the install API is available.  include_once './includes/install.inc';  // Display the confirm form if any modules have been submitted.  if (isset($form_state) && $confirm_form = system_modules_uninstall_confirm_form($form_state['storage'])) {    return $confirm_form;  }  $form = array();  // Pull all disabled modules from the system table.  $disabled_modules = db_query("SELECT name, filename, info FROM {system} WHERE type = 'module' AND status = 0 AND schema_version > %d ORDER BY name", SCHEMA_UNINSTALLED);  while ($module = db_fetch_object($disabled_modules)) {    // Grab the module info    $info = unserialize($module->info);    // Load the .install file, and check for an uninstall hook.    // If the hook exists, the module can be uninstalled.    module_load_install($module->name);    if (module_hook($module->name, 'uninstall')) {      $form['modules'][$module->name]['name'] = array('#value' => $info['name'] ? $info['name'] : $module->name);      $form['modules'][$module->name]['description'] = array('#value' => t($info['description']));      $options[$module->name] = '';    }  }  // Only build the rest of the form if there are any modules available to uninstall.  if (!empty($options)) {    $form['uninstall'] = array(      '#type' => 'checkboxes',      '#options' => $options,    );    $form['buttons']['submit'] = array(      '#type' => 'submit',      '#value' => t('Uninstall'),    );    $form['#action'] = url('admin/build/modules/uninstall/confirm');  }  else {    $form['modules'] = array();  }  return $form;}/** * Confirm uninstall of selected modules. * * @ingroup forms * @param $storage *   An associative array of modules selected to be uninstalled. * @return *   A form array representing modules to confirm. */function system_modules_uninstall_confirm_form($storage) {  // Nothing to build.  if (!isset($storage)) {    return;  }  // Construct the hidden form elements and list items.  foreach (array_filter($storage['uninstall']) as $module => $value) {    $info = drupal_parse_info_file(dirname(drupal_get_filename('module', $module)) .'/'. $module .'.info');    $uninstall[] = $info['name'];    $form['uninstall'][$module] = array('#type' => 'hidden',      '#value' => 1,    );  }  // Display a confirm form if modules have been selected.  if (isset($uninstall)) {    $form['#confirmed'] = TRUE;    $form['uninstall']['#tree'] = TRUE;    $form['modules'] = array('#value' => '<p>'. t('The following modules will be completely uninstalled from your site, and <em>all data from these modules will be lost</em>!') .'</p>'. theme('item_list', $uninstall));    $form = confirm_form(      $form,      t('Confirm uninstall'),      'admin/build/modules/uninstall',      t('Would you like to continue with uninstalling the above?'),      t('Uninstall'),      t('Cancel'));    return $form;  }}/** * Validates the submitted uninstall form. */function system_modules_uninstall_validate($form, &$form_state) {  // Form submitted, but no modules selected.  if (!count(array_filter($form_state['values']['uninstall']))) {    drupal_set_message(t('No modules selected.'), 'error');    drupal_goto('admin/build/modules/uninstall');  }}/** * Processes the submitted uninstall form. */function system_modules_uninstall_submit($form, &$form_state) {  // Make sure the install API is available.  include_once './includes/install.inc';  if (!empty($form['#confirmed'])) {    // Call the uninstall routine for each selected module.    foreach (array_filter($form_state['values']['uninstall']) as $module => $value) {      drupal_uninstall_module($module);    }    drupal_set_message(t('The selected modules have been uninstalled.'));    unset($form_state['storage']);    $form_state['redirect'] = 'admin/build/modules/uninstall';  }  else {    $form_state['storage'] = $form_state['values'];  }}/** * Form builder; The general site information form. * * @ingroup forms * @see system_settings_form() */function system_site_information_settings() {  $form['site_name'] = array(    '#type' => 'textfield',    '#title' => t('Name'),    '#default_value' => variable_get('site_name', 'Drupal'),    '#description' => t('The name of this website.'),    '#required' => TRUE  );  $form['site_mail'] = array(    '#type' => 'textfield',    '#title' => t('E-mail address'),    '#default_value' => variable_get('site_mail', ini_get('sendmail_from')),    '#description' => t("The <em>From</em> address in automated e-mails sent during registration and new password requests, and other notifications. (Use an address ending in your site's domain to help prevent this e-mail being flagged as spam.)"),    '#required' => TRUE,  );  $form['site_slogan'] = array(    '#type' => 'textfield',    '#title' => t('Slogan'),    '#default_value' => variable_get('site_slogan', ''),    '#description' => t("Your site's motto, tag line, or catchphrase (often displayed alongside the title of the site).")  );  $form['site_mission'] = array(    '#type' => 'textarea',    '#title' => t('Mission'),    '#default_value' => variable_get('site_mission', ''),    '#description' => t("Your site's mission or focus statement (often prominently displayed on the front page).")  );  $form['site_footer'] = array(    '#type' => 'textarea',    '#title' => t('Footer message'),    '#default_value' => variable_get('site_footer', ''),    '#description' => t('This text will be displayed at the bottom of each page. Useful for adding a copyright notice to your pages.')  );  $form['anonymous'] = array(    '#type' => 'textfield',    '#title' => t('Anonymous user'),    '#default_value' => variable_get('anonymous', t('Anonymous')),    '#description' => t('The name used to indicate anonymous users.'),    '#required' => TRUE,  );  $form['site_frontpage'] = array(    '#type' => 'textfield',    '#title' => t('Default front page'),    '#default_value' => variable_get('site_frontpage', 'node'),    '#size' => 40,    '#description' => t('The home page displays content from this relative URL. If unsure, specify "node".'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q='),    '#required' => TRUE,  );  $form['#validate'][] = 'system_site_information_settings_validate';  return system_settings_form($form);}/** * Validate the submitted site-information form. */function system_site_information_settings_validate($form, &$form_state) {  // Validate the e-mail address.  if ($error = user_validate_mail($form_state['values']['site_mail'])) {    form_set_error('site_mail', $error);  }  // Validate front page path.  $item = array('link_path' => $form_state['values']['site_frontpage']);  $normal_path = drupal_get_normal_path($item['link_path']);  if ($item['link_path'] != $normal_path) {    drupal_set_message(t('The menu system stores system paths only, but will use the URL alias for display. %link_path has been stored as %normal_path', array('%link_path' => $item['link_path'], '%normal_path' => $normal_path)));    $item['link_path'] = $normal_path;  }  if (!empty($item) && !menu_valid_path($item)) {    form_set_error('site_frontpage', t("The path '@path' is either invalid or you do not have access to it.", array('@path' => $item['link_path'])));  }}/** * Form builder; Configure error reporting settings. * * @ingroup forms * @see system_settings_form() */function system_error_reporting_settings() {  $form['site_403'] = array(    '#type' => 'textfield',    '#title' => t('Default 403 (access denied) page'),    '#default_value' => variable_get('site_403', ''),    '#size' => 40,    '#description' => t('This page is displayed when the requested document is denied to the current user. If unsure, specify nothing.'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q=')  );  $form['site_404'] = array(    '#type' => 'textfield',    '#title' => t('Default 404 (not found) page'),    '#default_value' => variable_get('site_404', ''),    '#size' => 40,    '#description' => t('This page is displayed when no other content matches the requested document. If unsure, specify nothing.'),    '#field_prefix' => url(NULL, array('absolute' => TRUE)) . (variable_get('clean_url', 0) ? '' : '?q=')  );  $form['error_level'] = array(    '#type' => 'select', '#title' => t('Error reporting'), '#default_value' => variable_get('error_level', 1),    '#options' => array(t('Write errors to the log'), t('Write errors to the log and to the screen')),    '#description' => t('Specify where Drupal, PHP and SQL errors are logged. While it is recommended that a site running in a production environment write errors to the log only, in a development or testing environment it may be helpful to write errors both to the log and to the screen.')  );  return system_settings_form($form);}/** * Menu callback; Menu page for the various logging options. */function system_logging_overview() {  $item = menu_get_item('admin/settings/logging');  $content = system_admin_menu_block($item);  $output = theme('admin_block_content', $content);  return $output;}/** * Form builder; Configure site performance settings. * * @ingroup forms * @see system_settings_form() */function system_performance_settings() {  $description = '<p>'. t("The normal cache mode is suitable for most sites and does not cause any side effects. The aggressive cache mode causes Drupal to skip the loading (boot) and unloading (exit) of enabled modules when serving a cached page. This results in an additional performance boost but can cause unwanted side effects.") .'</p>';  $problem_modules = array_unique(array_merge(module_implements('boot'), module_implements('exit')));  sort($problem_modules);  if (count($problem_modules) > 0) {    $description .= '<p>'. t('<strong class="error">The following enabled modules are incompatible with aggressive mode caching and will not function properly: %modules</strong>', array('%modules' => implode(', ', $problem_modules))) .'.</p>';  }  else {    $description .= '<p>'. t('<strong class="ok">Currently, all enabled modules are compatible with the aggressive caching policy.</strong> Please note, if you use aggressive caching and enable new modules, you will need to check this page again to ensure compatibility.') .'</p>';  }  $form['page_cache'] = array(    '#type' => 'fieldset',    '#title' => t('Page cache'),    '#description' => t('Enabling the page cache will offer a significant performance boost. Drupal can store and send compressed cached pages requested by <em>anonymous</em> users. By caching a web page, Drupal does not have to construct the page each time it is viewed.'),  );  $form['page_cache']['cache'] = array(    '#type' => 'radios',    '#title' => t('Caching mode'),    '#default_value' => variable_get('cache', CACHE_DISABLED),    '#options' => array(CACHE_DISABLED => t('Disabled'), CACHE_NORMAL => t('Normal (recommended for production sites, no side effects)'), CACHE_AGGRESSIVE => t('Aggressive (experts only, possible side effects)')),    '#description' => $description  );  $period = drupal_map_assoc(array(0, 60, 180, 300, 600, 900, 1800, 2700, 3600, 10800, 21600, 32400, 43200, 86400), 'format_interval');  $period[0] = '<'. t('none') .'>';  $form['page_cache']['cache_lifetime'] = array(    '#type' => 'select',    '#title' => t('Minimum cache lifetime'),    '#default_value' => variable_get('cache_lifetime', 0),    '#options' => $period,    '#description' => t('On high-traffic sites, it may be necessary to enforce a minimum cache lifetime. The minimum cache lifetime is the minimum amount of time that will elapse before the cache is emptied and recreated, and is applied to both page and block caches. A larger minimum cache lifetime offers better performance, but users will not see new content for a longer period of time.')  );  $form['page_cache']['page_compression'] = array(    '#type' => 'radios',    '#title' => t('Page compression'),    '#default_value' => variable_get('page_compression', TRUE),    '#options' => array(t('Disabled'), t('Enabled')),    '#description' => t("By default, Drupal compresses the pages it caches in order to save bandwidth and improve download times. This option should be disabled when using a webserver that performs compression."),  );  $form['block_cache'] = array(    '#type' => 'fieldset',    '#title' => t('Block cache'),    '#description' => t('Enabling the block cache can offer a performance increase for all users by preventing blocks from being reconstructed on each page load. If the page cache is also enabled, performance increases from enabling the block cache will mainly benefit authenticated users.'),  );  $form['block_cache']['block_cache'] = array(    '#type' => 'radios',    '#title' => t('Block cache'),    '#default_value' => variable_get('block_cache', CACHE_DISABLED),    '#options' => array(CACHE_DISABLED => t('Disabled'), CACHE_NORMAL => t('Enabled (recommended)')),    '#disabled' => count(module_implements('node_grants')),    '#description' => t('Note that block caching is inactive when modules defining content access restrictions are enabled.'),  );  $form['bandwidth_optimizations'] = array(    '#type' => 'fieldset',    '#title' => t('Bandwidth optimizations'),    '#description' => t('<p>Drupal can automatically optimize external resources like CSS and JavaScript, which can reduce both the size and number of requests made to your website. CSS files can be aggregated and compressed into a single file, while JavaScript files are aggregated (but not compressed). These optional optimizations may reduce server load, bandwidth requirements, and page loading times.</p><p>These options are disabled if you have not set up your files directory, or if your download method is set to private.</p>')  );  $directory = file_directory_path();  $is_writable = is_dir($directory) && is_writable($directory) && (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC);  $form['bandwidth_optimizations']['preprocess_css'] = array(    '#type' => 'radios',    '#title' => t('Optimize CSS files'),    '#default_value' => intval(variable_get('preprocess_css', 0) && $is_writable),    '#disabled' => !$is_writable,    '#options' => array(t('Disabled'), t('Enabled')),    '#description' => t('This option can interfere with theme development and should only be enabled in a production environment.'),  );  $form['bandwidth_optimizations']['preprocess_js'] = array(    '#type' => 'radios',    '#title' => t('Optimize JavaScript files'),    '#default_value' => intval(variable_get('preprocess_js', 0) && $is_writable),    '#disabled' => !$is_writable,    '#options' => array(t('Disabled'), t('Enabled')),    '#description' => t('This option can interfere with module development and should only be enabled in a production environment.'),  );  $form['clear_cache'] = array(    '#type' => 'fieldset',    '#title' => t('Clear cached data'),    '#description' => t('Caching data improves performance, but may cause problems while troubleshooting new modules, themes, or translations, if outdated information has been cached. To refresh all cached data on your site, click the button below. <em>Warning: high-traffic sites will experience performance slowdowns while cached data is rebuilt.</em>'),  );  $form['clear_cache']['clear'] = array(    '#type' => 'submit',    '#value' => t('Clear cached data'),    '#submit' => array('system_clear_cache_submit'),  );  $form['#submit'][] = 'drupal_clear_css_cache';  $form['#submit'][] = 'drupal_clear_js_cache';  return system_settings_form($form);}/** * Submit callback; clear system caches. * * @ingroup forms */function system_clear_cache_submit($form, &$form_state) {  drupal_flush_all_caches();  drupal_set_message(t('Caches cleared.'));}/** * Form builder; Configure the site file handling. * * @ingroup forms * @see system_settings_form() */function system_file_system_settings() {  $form['file_directory_path'] = array(    '#type' => 'textfield',    '#title' => t('File system path'),    '#default_value' => file_directory_path(),    '#maxlength' => 255,    '#description' => t('A file system path where the files will be stored. This directory must exist and be writable by Drupal. If the download method is set to public, this directory must be relative to the Drupal installation directory and be accessible over the web. If the download method is set to private, this directory should not be accessible over the web. Changing this location will modify all download paths and may cause unexpected problems on an existing site.'),    '#after_build' => array('system_check_directory'),  );  $form['file_directory_temp'] = array(    '#type' => 'textfield',    '#title' => t('Temporary directory'),    '#default_value' => file_directory_temp(),    '#maxlength' => 255,    '#description' => t('A file system path where uploaded files will be stored during previews.'),    '#after_build' => array('system_check_directory'),  );  $form['file_downloads'] = array(    '#type' => 'radios',    '#title' => t('Download method'),    '#default_value' => variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC),    '#options' => array(FILE_DOWNLOADS_PUBLIC => t('Public - files are available using HTTP directly.'), FILE_DOWNLOADS_PRIVATE => t('Private - files are transferred by Drupal.')),    '#description' => t('Choose the <em>Public download</em> method unless you wish to enforce fine-grained access controls over file downloads. Changing the download method will modify all download paths and may cause unexpected problems on an existing site.')  );  return system_settings_form($form);}/** * Form builder; Configure site image toolkit usage. * * @ingroup forms * @see system_settings_form() */function system_image_toolkit_settings() {  $toolkits_available = image_get_available_toolkits();  if (count($toolkits_available) > 1) {    $form['image_toolkit'] = array(      '#type' => 'radios',      '#title' => t('Select an image processing toolkit'),      '#default_value' => variable_get('image_toolkit', image_get_toolkit()),      '#options' => $toolkits_available    );  }  elseif (count($toolkits_available) == 1) {    variable_set('image_toolkit', key($toolkits_available));  }  $form['image_toolkit_settings'] = image_toolkit_invoke('settings');  return system_settings_form($form);}/** * Form builder; Configure how the site handles RSS feeds. * * @ingroup forms * @see system_settings_form() */function system_rss_feeds_settings() {  $form['feed_default_items'] = array(    '#type' => 'select',    '#title' => t('Number of items in each feed'),    '#default_value' => variable_get('feed_default_items', 10),    '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30)),    '#description' => t('Default number of items to include in each feed.')  );  $form['feed_item_length'] = array(    '#type' => 'select',    '#title' => t('Feed content'),    '#default_value' => variable_get('feed_item_length', 'teaser'),    '#options' => array('title' => t('Titles only'), 'teaser' => t('Titles plus teaser'), 'fulltext' => t('Full text')),    '#description' => t('Global setting for the default display of content items in each feed.')  );  return system_settings_form($form);}/** * Form builder; Configure the site date and time settings. * * @ingroup forms * @see system_settings_form() * @see system_date_time_settings_submit() */function system_date_time_settings() {  drupal_add_js(drupal_get_path('module', 'system') .'/system.js', 'module');  drupal_add_js(array('dateTime' => array('lookup' => url('admin/settings/date-time/lookup'))), 'setting');  // Date settings:  $zones = _system_zonelist();  // Date settings: possible date formats  $date_short = array('Y-m-d H:i', 'm/d/Y - H:i', 'd/m/Y - H:i', 'Y/m/d - H:i',           'd.m.Y - H:i', 'm/d/Y - g:ia', 'd/m/Y - g:ia', 'Y/m/d - g:ia',           'M j Y - H:i', 'j M Y - H:i', 'Y M j - H:i',           'M j Y - g:ia', 'j M Y - g:ia', 'Y M j - g:ia');  $date_medium = array('D, Y-m-d H:i', 'D, m/d/Y - H:i', 'D, d/m/Y - H:i',          'D, Y/m/d - H:i', 'F j, Y - H:i', 'j F, Y - H:i', 'Y, F j - H:i',          'D, m/d/Y - g:ia', 'D, d/m/Y - g:ia', 'D, Y/m/d - g:ia',          'F j, Y - g:ia', 'j F Y - g:ia', 'Y, F j - g:ia', 'j. F Y - G:i');  $date_long = array('l, F j, Y - H:i', 'l, j F, Y - H:i', 'l, Y, F j - H:i',        'l, F j, Y - g:ia', 'l, j F Y - g:ia', 'l, Y, F j - g:ia', 'l, j. F Y - G:i');  // Date settings: construct choices for user  foreach ($date_short as $f) {    $date_short_choices[$f] = format_date(time(), 'custom', $f);  }  foreach ($date_medium as $f) {    $date_medium_choices[$f] = format_date(time(), 'custom', $f);  }  foreach ($date_long as $f) {    $date_long_choices[$f] = format_date(time(), 'custom', $f);  }  $date_long_choices['custom'] = $date_medium_choices['custom'] = $date_short_choices['custom'] = t('Custom format');  $form['locale'] = array(    '#type' => 'fieldset',    '#title' => t('Locale settings'),  );  $form['locale']['date_default_timezone'] = array(    '#type' => 'select',    '#title' => t('Default time zone'),    '#default_value' => variable_get('date_default_timezone', 0),    '#options' => $zones,    '#description' => t('Select the default site time zone.')  );  $form['locale']['configurable_timezones'] = array(    '#type' => 'radios',    '#title' => t('User-configurable time zones'),    '#default_value' => variable_get('configurable_timezones', 1),    '#options' => array(t('Disabled'), t('Enabled')),    '#description' => t('When enabled, users can set their own time zone and dates will be displayed accordingly.')  );  $form['locale']['date_first_day'] = array(    '#type' => 'select',    '#title' => t('First day of week'),    '#default_value' => variable_get('date_first_day', 0),    '#options' => array(0 => t('Sunday'), 1 => t('Monday'), 2 => t('Tuesday'), 3 => t('Wednesday'), 4 => t('Thursday'), 5 => t('Friday'), 6 => t('Saturday')),    '#description' => t('The first day of the week for calendar views.')  );  $form['date_formats'] = array(    '#type' => 'fieldset',    '#title' => t('Formatting'),  );  $date_format_short = variable_get('date_format_short', $date_short[1]);  $form['date_formats']['date_format_short'] = array(    '#prefix' => '<div class="date-container"><div class="select-container">',    '#suffix' => '</div>',    '#type' => 'select',    '#title' => t('Short date format'),    '#attributes' => array('class' => 'date-format'),    '#default_value' => (isset($date_short_choices[$date_format_short]) ? $date_format_short : 'custom'),    '#options' => $date_short_choices,    '#description' => t('The short format of date display.'),  );  $default_short_custom = variable_get('date_format_short_custom', (isset($date_short_choices[$date_format_short]) ? $date_format_short : ''));  $form['date_formats']['date_format_short_custom'] = array(    '#prefix' => '<div class="custom-container">',    '#suffix' => '</div></div>',    '#type' => 'textfield',    '#title' => t('Custom short date format'),    '#attributes' => array('class' => 'custom-format'),    '#default_value' => $default_short_custom,    '#description' => t('A user-defined short date format. See the <a href="@url">PHP manual</a> for available options. This format is currently set to display as <span>%date</span>.', array('@url' => 'http://php.net/manual/function.date.php', '%date' => format_date(time(), 'custom', $default_short_custom))),  );  $date_format_medium = variable_get('date_format_medium', $date_medium[1]);  $form['date_formats']['date_format_medium'] = array(    '#prefix' => '<div class="date-container"><div class="select-container">',    '#suffix' => '</div>',    '#type' => 'select',    '#title' => t('Medium date format'),    '#attributes' => array('class' => 'date-format'),    '#default_value' => (isset($date_medium_choices[$date_format_medium]) ? $date_format_medium : 'custom'),    '#options' => $date_medium_choices,    '#description' => t('The medium sized date display.'),  );  $default_medium_custom = variable_get('date_format_medium_custom', (isset($date_medium_choices[$date_format_medium]) ? $date_format_medium : ''));  $form['date_formats']['date_format_medium_custom'] = array(    '#prefix' => '<div class="custom-container">',    '#suffix' => '</div></div>',    '#type' => 'textfield',    '#title' => t('Custom medium date format'),    '#attributes' => array('class' => 'custom-format'),    '#default_value' => $default_medium_custom,    '#description' => t('A user-defined medium date format. See the <a href="@url">PHP manual</a> for available options. This format is currently set to display as <span>%date</span>.', array('@url' => 'http://php.net/manual/function.date.php', '%date' => format_date(time(), 'custom', $default_medium_custom))),  );  $date_format_long = variable_get('date_format_long', $date_long[0]);  $form['date_formats']['date_format_long'] = array(    '#prefix' => '<div class="date-container"><div class="select-container">',    '#suffix' => '</div>',    '#type' => 'select',    '#title' => t('Long date format'),    '#attributes' => array('class' => 'date-format'),    '#default_value' => (isset($date_long_choices[$date_format_long]) ? $date_format_long : 'custom'),    '#options' => $date_long_choices,    '#description' => t('Longer date format used for detailed display.')  );  $default_long_custom = variable_get('date_format_long_custom', (isset($date_long_choices[$date_format_long]) ? $date_format_long : ''));  $form['date_formats']['date_format_long_custom'] = array(    '#prefix' => '<div class="custom-container">',    '#suffix' => '</div></div>',    '#type' => 'textfield',    '#title' => t('Custom long date format'),    '#attributes' => array('class' => 'custom-format'),    '#default_value' => $default_long_custom,    '#description' => t('A user-defined long date format. See the <a href="@url">PHP manual</a> for available options. This format is currently set to display as <span>%date</span>.', array('@url' => 'http://php.net/manual/function.date.php', '%date' => format_date(time(), 'custom', $default_long_custom))),  );  $form = system_settings_form($form);  // We will call system_settings_form_submit() manually, so remove it for now.  unset($form['#submit']);  return $form;}/** * Process system_date_time_settings form submissions. */function system_date_time_settings_submit($form, &$form_state) {  if ($form_state['values']['date_format_short'] == 'custom') {    $form_state['values']['date_format_short'] = $form_state['values']['date_format_short_custom'];  }  if ($form_state['values']['date_format_medium'] == 'custom') {    $form_state['values']['date_format_medium'] = $form_state['values']['date_format_medium_custom'];  }  if ($form_state['values']['date_format_long'] == 'custom') {    $form_state['values']['date_format_long'] = $form_state['values']['date_format_long_custom'];  }  return system_settings_form_submit($form, $form_state);}/** * Return the date for a given format string via Ajax. */function system_date_time_lookup() {  $result = format_date(time(), 'custom', $_GET['format']);  drupal_json($result);}/** * Form builder; Configure the site's maintenance status. * * @ingroup forms * @see system_settings_form() */function system_site_maintenance_settings() {  $form['site_offline'] = array(    '#type' => 'radios',    '#title' => t('Site status'),    '#default_value' => variable_get('site_offline', 0),    '#options' => array(t('Online'), t('Off-line')),    '#description' => t('When set to "Online", all visitors will be able to browse your site normally. When set to "Off-line", only users with the "administer site configuration" permission will be able to access your site to perform maintenance; all other visitors will see the site off-line message configured below. Authorized users can log in during "Off-line" mode directly via the <a href="@user-login">user login</a> page.', array('@user-login' => url('user'))),  );  $form['site_offline_message'] = array(    '#type' => 'textarea',    '#title' => t('Site off-line message'),    '#default_value' => variable_get('site_offline_message', t('@site is currently under maintenance. We should be back shortly. Thank you for your patience.', array('@site' => variable_get('site_name', 'Drupal')))),    '#description' => t('Message to show visitors when the site is in off-line mode.')  );  return system_settings_form($form);}/** * Form builder; Configure Clean URL settings. * * @ingroup forms * @see system_settings_form() */function system_clean_url_settings() {  $form['clean_url'] = array(    '#type' => 'radios',    '#title' => t('Clean URLs'),    '#default_value' => variable_get('clean_url', 0),    '#options' => array(t('Disabled'), t('Enabled')),    '#description' => t('This option makes Drupal emit "clean" URLs (i.e. without <code>?q=</code> in the URL).'),  );  if (!variable_get('clean_url', 0)) {    if (strpos(request_uri(), '?q=') !== FALSE) {      drupal_add_js(drupal_get_path('module', 'system') .'/system.js', 'module');      $form['clean_url']['#description'] .= ' <span>'. t('Before enabling clean URLs, you must perform a test to determine if your server is properly configured. If you are able to see this page again after clicking the "Run the clean URL test" link, the test has succeeded and the radio buttons above will be available. If instead you are directed to a "Page not found" error, you will need to change the configuration of your server. The <a href="@handbook">handbook page on Clean URLs</a> has additional troubleshooting information.', array('@handbook' => 'http://drupal.org/node/15365')) .'</span>';      $form['clean_url']['#disabled'] = TRUE;      $form['clean_url']['#prefix'] = '<div id="clean-url">';      $form['clean_url']['#suffix'] = '<p>'. t('<a href="@clean_url">Run the clean url test</a>.', array('@clean_url' => base_path() .'admin/settings/clean-urls')) .'</p></div>';    }    else {      $form['clean_url']['#description'] .= ' <div class="ok">'. t('Your server has been successfully tested to support this feature.') .'</div>';    }  }  return system_settings_form($form);}/** * Menu callback: displays the site status report. Can also be used as a pure check. * * @param $check *   If true, only returns a boolean whether there are system status errors. */function system_status($check = FALSE) {  // Load .install files  include_once './includes/install.inc';  drupal_load_updates();  // Check run-time requirements and status information.  $requirements = module_invoke_all('requirements', 'runtime');  usort($requirements, '_system_sort_requirements');  if ($check) {    return drupal_requirements_severity($requirements) == REQUIREMENT_ERROR;  }  // MySQL import might have set the uid of the anonymous user to autoincrement  // value. Let's try fixing it. See http://drupal.org/node/204411  db_query("UPDATE {users} SET uid = uid - uid WHERE name = '' AND pass = '' AND status = 0");  return theme('status_report', $requirements);}/** * Menu callback: run cron manually. */function system_run_cron() {  // Run cron manually  if (drupal_cron_run()) {    drupal_set_message(t('Cron ran successfully.'));  }  else {    drupal_set_message(t('Cron run failed.'), 'error');  }  drupal_goto('admin/reports/status');}/** * Menu callback: return information about PHP. */function system_php() {  phpinfo();  exit();}/** * Theme a SQL result table. * * @param $data *   The actual table data. * @param $keys *   Data keys and descriptions. * @return *   The output HTML. */function _system_sql($data, $keys) {  $rows = array();  foreach ($keys as $key => $explanation) {    if (isset($data[$key])) {      $rows[] = array(check_plain($key), check_plain($data[$key]), $explanation);    }  }  return theme('table', array(t('Variable'), t('Value'), t('Description')), $rows);}/** * Menu callback: return information about the database. */function system_sql() {  $result = db_query("SHOW STATUS");  while ($entry = db_fetch_object($result)) {    // 'SHOW STATUS' returns fields named 'Variable_name' and 'Value',    // case is important.    $data[$entry->Variable_name] = $entry->Value;  }  $output  = '<h2>'. t('Command counters') .'</h2>';  $output .= _system_sql($data, array(   'Com_select' => t('The number of <code>SELECT</code>-statements.'),   'Com_insert' => t('The number of <code>INSERT</code>-statements.'),   'Com_update' => t('The number of <code>UPDATE</code>-statements.'),   'Com_delete' => t('The number of <code>DELETE</code>-statements.'),   'Com_lock_tables' => t('The number of table locks.'),   'Com_unlock_tables' => t('The number of table unlocks.')  ));  $output .= '<h2>'. t('Query performance') .'</h2>';  $output .= _system_sql($data, array(   'Select_full_join' => t('The number of joins without an index; should be zero.'),   'Select_range_check' => t('The number of joins without keys that check for key usage after each row; should be zero.'),   'Sort_scan' => t('The number of sorts done without using an index; should be zero.'),   'Table_locks_immediate' => t('The number of times a lock could be acquired immediately.'),   'Table_locks_waited' => t('The number of times the server had to wait for a lock.')  ));  $output .= '<h2>'. t('Query cache information') .'</h2>';  $output .= '<p>'. t('The MySQL query cache can improve performance of your site by storing the result of queries. Then, if an identical query is received later, the MySQL server retrieves the result from the query cache rather than parsing and executing the statement again.') .'</p>';  $output .= _system_sql($data, array(   'Qcache_queries_in_cache' => t('The number of queries in the query cache.'),   'Qcache_hits' => t('The number of times MySQL found previous results in the cache.'),   'Qcache_inserts' => t('The number of times MySQL added a query to the cache (misses).'),   'Qcache_lowmem_prunes' => t('The number of times MySQL had to remove queries from the cache because it ran out of memory. Ideally should be zero.')  ));  return $output;}/** * Default page callback for batches. */function system_batch_page() {  require_once './includes/batch.inc';  $output = _batch_page();  if ($output === FALSE) {    drupal_access_denied();  }  elseif (isset($output)) {    // Force a page without blocks or messages to    // display a list of collected messages later.    print theme('page', $output, FALSE, FALSE);  }}/** * This function formats an administrative block for display. * * @param $block *   An array containing information about the block. It should *   include a 'title', a 'description' and a formatted 'content'. * @ingroup themeable */function theme_admin_block($block) {  // Don't display the block if it has no content to display.  if (empty($block['content'])) {    return '';  }  $output = <<< EOT  <div class="admin-panel">    <h3>      $block[title]    </h3>    <div class="body">      <p class="description">        $block[description]      </p>      $block[content]    </div>  </div>EOT;  return $output;}/** * This function formats the content of an administrative block. * * @param $content *   An array containing information about the block. It should *   include a 'title', a 'description' and a formatted 'content'. * @ingroup themeable */function theme_admin_block_content($content) {  if (!$content) {    return '';  }  if (system_admin_compact_mode()) {    $output = '<ul class="menu">';    foreach ($content as $item) {      $output .= '<li class="leaf">'. l($item['title'], $item['href'], $item['localized_options']) .'</li>';    }    $output .= '</ul>';  }  else {    $output = '<dl class="admin-list">';    foreach ($content as $item) {      $output .= '<dt>'. l($item['title'], $item['href'], $item['localized_options']) .'</dt>';      $output .= '<dd>'. $item['description'] .'</dd>';    }    $output .= '</dl>';  }  return $output;}/** * This function formats an administrative page for viewing. * * @param $blocks *   An array of blocks to display. Each array should include a *   'title', a 'description', a formatted 'content' and a *   'position' which will control which container it will be *   in. This is usually 'left' or 'right'. * @ingroup themeable */function theme_admin_page($blocks) {  $stripe = 0;  $container = array();  foreach ($blocks as $block) {    if ($block_output = theme('admin_block', $block)) {      if (empty($block['position'])) {        // perform automatic striping.        $block['position'] = ++$stripe % 2 ? 'left' : 'right';      }      if (!isset($container[$block['position']])) {        $container[$block['position']] = '';      }      $container[$block['position']] .= $block_output;    }  }  $output = '<div class="admin clear-block">';  $output .= '<div class="compact-link">';  if (system_admin_compact_mode()) {    $output .= l(t('Show descriptions'), 'admin/compact/off', array('attributes' => array('title' => t('Expand layout to include descriptions.'))));  }  else {    $output .= l(t('Hide descriptions'), 'admin/compact/on', array('attributes' => array('title' => t('Compress layout by hiding descriptions.'))));  }  $output .= '</div>';  foreach ($container as $id => $data) {    $output .= '<div class="'. $id .' clear-block">';    $output .= $data;    $output .= '</div>';  }  $output .= '</div>';  return $output;}/** * Theme output of the dashboard page. * * @param $menu_items *   An array of modules to be displayed. * @ingroup themeable */function theme_system_admin_by_module($menu_items) {  $stripe = 0;  $output = '';  $container = array('left' => '', 'right' => '');  $flip = array('left' => 'right', 'right' => 'left');  $position = 'left';  // Iterate over all modules  foreach ($menu_items as $module => $block) {    list($description, $items) = $block;    // Output links    if (count($items)) {      $block = array();      $block['title'] = $module;      $block['content'] = theme('item_list', $items);      $block['description'] = t($description);      if ($block_output = theme('admin_block', $block)) {        if (!isset($block['position'])) {          // Perform automatic striping.          $block['position'] = $position;          $position = $flip[$position];        }        $container[$block['position']] .= $block_output;      }    }  }  $output = '<div class="admin clear-block">';  foreach ($container as $id => $data) {    $output .= '<div class="'. $id .' clear-block">';    $output .= $data;    $output .= '</div>';  }  $output .= '</div>';  return $output;}/** * Theme requirements status report. * * @param $requirements *   An array of requirements. * @ingroup themeable */function theme_status_report($requirements) {  $i = 0;  $output = '<table class="system-status-report">';  foreach ($requirements as $requirement) {    if (empty($requirement['#type'])) {      $class = ++$i % 2 == 0 ? 'even' : 'odd';      $classes = array(        REQUIREMENT_INFO => 'info',        REQUIREMENT_OK => 'ok',        REQUIREMENT_WARNING => 'warning',        REQUIREMENT_ERROR => 'error',      );      $class = $classes[isset($requirement['severity']) ? (int)$requirement['severity'] : 0] .' '. $class;      // Output table row(s)      if (!empty($requirement['description'])) {        $output .= '<tr class="'. $class .' merge-down"><th>'. $requirement['title'] .'</th><td>'. $requirement['value'] .'</td></tr>';        $output .= '<tr class="'. $class .' merge-up"><td colspan="2">'. $requirement['description'] .'</td></tr>';      }      else {        $output .= '<tr class="'. $class .'"><th>'. $requirement['title'] .'</th><td>'. $requirement['value'] .'</td></tr>';      }    }  }  $output .= '</table>';  return $output;}/** * Theme callback for the modules form. * * @param $form *   An associative array containing the structure of the form. * @ingroup themeable */function theme_system_modules($form) {  if (isset($form['confirm'])) {    return drupal_render($form);  }  // Individual table headers.  $header = array();  $header[] = array('data' => t('Enabled'), 'class' => 'checkbox');  if (module_exists('throttle')) {    $header[] = array('data' => t('Throttle'), 'class' => 'checkbox');  }  $header[] = t('Name');  $header[] = t('Version');  $header[] = t('Description');  // Pull package information from module list and start grouping modules.  $modules = $form['validation_modules']['#value'];  foreach ($modules as $module) {    if (!isset($module->info['package']) || !$module->info['package']) {      $module->info['package'] = t('Other');    }    $packages[$module->info['package']][$module->name] = $module->info;  }  ksort($packages);  // Display packages.  $output = '';  foreach ($packages as $package => $modules) {    $rows = array();    foreach ($modules as $key => $module) {      $row = array();      $description = drupal_render($form['description'][$key]);      if (isset($form['status']['#incompatible_modules_core'][$key])) {        unset($form['status'][$key]);        $status = theme('image', 'misc/watchdog-error.png', t('incompatible'), t('Incompatible with this version of Drupal core'));        $description .= '<div class="incompatible">'. t('This version is incompatible with the !core_version version of Drupal core.', array('!core_version' => VERSION)) .'</div>';      }      elseif (isset($form['status']['#incompatible_modules_php'][$key])) {        unset($form['status'][$key]);        $status = theme('image', 'misc/watchdog-error.png', t('incompatible'), t('Incompatible with this version of PHP'));        $php_required = $form['status']['#incompatible_modules_php'][$key];        if (substr_count($php_required, '.') < 2) {          $php_required .= '.*';        }        $description .= '<div class="incompatible">'. t('This module requires PHP version @php_required and is incompatible with PHP version !php_version.', array('@php_required' => $php_required, '!php_version' => phpversion())) .'</div>';      }      else {        $status = drupal_render($form['status'][$key]);      }      $row[] = array('data' => $status, 'class' => 'checkbox');      if (module_exists('throttle')) {        $row[] = array('data' => drupal_render($form['throttle'][$key]), 'class' => 'checkbox');      }      // Add labels only when there is also a checkbox.      if (isset($form['status'][$key])) {        $row[] = '<strong><label for="'. $form['status'][$key]['#id'] .'">'. drupal_render($form['name'][$key]) .'</label></strong>';      }      else {        $row[] = '<strong>'. drupal_render($form['name'][$key]) .'</strong>';      }      $row[] = array('data' => drupal_render($form['version'][$key]), 'class' => 'version');      $row[] = array('data' => $description, 'class' => 'description');      $rows[] = $row;    }    $fieldset = array(      '#title' => t($package),      '#collapsible' => TRUE,      '#collapsed' => ($package == 'Core - required'),      '#value' => theme('table', $header, $rows, array('class' => 'package')),    );    $output .= theme('fieldset', $fieldset);  }  $output .= drupal_render($form);  return $output;}/** * Themes a table of currently disabled modules. * * @ingroup themeable * @param $form *   The form array representing the currently disabled modules. * @return *   An HTML string representing the table. */function theme_system_modules_uninstall($form) {  // No theming for the confirm form.  if (isset($form['confirm'])) {    return drupal_render($form);  }  // Table headers.  $header = array(t('Uninstall'),    t('Name'),    t('Description'),  );  // Display table.  $rows = array();  foreach (element_children($form['modules']) as $module) {    $rows[] = array(      array('data' => drupal_render($form['uninstall'][$module]), 'align' => 'center'),      '<strong>'. drupal_render($form['modules'][$module]['name']) .'</strong>',      array('data' => drupal_render($form['modules'][$module]['description']), 'class' => 'description'),    );  }  // Only display table if there are modules that can be uninstalled.  if (empty($rows)) {    $rows[] = array(array('data' => t('No modules are available to uninstall.'), 'colspan' => '3', 'align' => 'center', 'class' => 'message'));  }  $output  = theme('table', $header, $rows);  $output .= drupal_render($form);  return $output;}/** * Theme the theme select form. * @param $form *   An associative array containing the structure of the form. * @ingroup themeable */function theme_system_theme_select_form($form) {  foreach (element_children($form) as $key) {    $row = array();    if (isset($form[$key]['description']) && is_array($form[$key]['description'])) {      $row[] = drupal_render($form[$key]['screenshot']);      $row[] = drupal_render($form[$key]['description']);      $row[] = drupal_render($form['theme'][$key]);    }    $rows[] = $row;  }  $header = array(t('Screenshot'), t('Name'), t('Selected'));  $output = theme('table', $header, $rows);  return $output;}/** * Theme function for the system themes form. * * @param $form *   An associative array containing the structure of the form. * @ingroup themeable */function theme_system_themes_form($form) {  foreach (element_children($form) as $key) {    // Only look for themes    if (!isset($form[$key]['info'])) {      continue;    }    // Fetch info    $info = $form[$key]['info']['#value'];    // Localize theme description.    $description = t($info['description']);    // Make sure it is compatible and render the checkbox if so.    if (isset($form['status']['#incompatible_themes_core'][$key])) {      unset($form['status'][$key]);      $status = theme('image', 'misc/watchdog-error.png', t('incompatible'), t('Incompatible with this version of Drupal core'));      $description .= '<div class="incompatible">'. t('This version is incompatible with the !core_version version of Drupal core.', array('!core_version' => VERSION)) .'</div>';    }    elseif (isset($form['status']['#incompatible_themes_php'][$key])) {      unset($form['status'][$key]);      $status = theme('image', 'misc/watchdog-error.png', t('incompatible'), t('Incompatible with this version of PHP'));      $php_required = $form['status']['#incompatible_themes_php'][$key];      if (substr_count($php_required, '.') < 2) {        $php_required .= '.*';      }      $description .= '<div class="incompatible">'. t('This theme requires PHP version @php_required and is incompatible with PHP version !php_version.', array('@php_required' => $php_required, '!php_version' => phpversion())) .'</div>';    }    else {      $status = drupal_render($form['status'][$key]);    }    // Style theme info    $theme = '<div class="theme-info"><h2>'. $info['name'] .'</h2><div class="description">'. $description .'</div></div>';    // Build rows    $row = array();    $row[] = drupal_render($form[$key]['screenshot']);    $row[] = $theme;    $row[] = isset($info['version']) ? $info['version'] : '';    $row[] = array('data' => $status, 'align' => 'center');    if ($form['theme_default']) {      $row[] = array('data' => drupal_render($form['theme_default'][$key]), 'align' => 'center');      $row[] = array('data' => drupal_render($form[$key]['operations']), 'align' => 'center');    }    $rows[] = $row;  }  $header = array(t('Screenshot'), t('Name'), t('Version'), t('Enabled'), t('Default'), t('Operations'));  $output = theme('table', $header, $rows);  $output .= drupal_render($form);  return $output;}
<?php// $Id$/** * Implementation of hook_install(). */function menu_install() {  // Create tables.  drupal_install_schema('menu');    $t = get_t();  db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", 'navigation', $t('Navigation'), $t('The navigation menu is provided by Drupal and is the main interactive menu for any site. It is usually the only menu that contains personalized links for authenticated users, and is often not even visible to anonymous users.'));  db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", 'primary-links', $t('Primary links'), $t('Primary links are often used at the theme layer to show the major sections of a site. A typical representation for primary links would be tabs along the top.'));  db_query("INSERT INTO {menu_custom} (menu_name, title, description) VALUES ('%s', '%s', '%s')", 'secondary-links', $t('Secondary links'), $t('Secondary links are often used for pages like legal notices, contact details, and other secondary navigation items that play a lesser role than primary links'));}/** * Implementation of hook_uninstall(). */function menu_uninstall() {  // Remove tables.  drupal_uninstall_schema('menu');  menu_rebuild();}/** * Implementation of hook_schema(). */function menu_schema() {  $schema['menu_custom'] = array(    'description' => 'Holds definitions for top-level custom menus (for example, Primary Links).',    'fields' => array(      'menu_name' => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '',        'description' => 'Primary Key: Unique key for menu. This is used as a block delta so length is 32.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Menu title; displayed at top of block.',      ),      'description' => array(        'type' => 'text',        'not null' => FALSE,        'description' => 'Menu description.',      ),    ),    'primary key' => array('menu_name'),  );  return $schema;}
<?php// $Id$/** * @file * Theming for maintenance pages. *//** * Sets up the theming system for site installs, updates and when the site is * in off-line mode. It also applies when the database is unavailable. * * Minnelli is always used for the initial install and update operations. In * other cases, "settings.php" must have a "maintenance_theme" key set for the * $conf variable in order to change the maintenance theme. */function _drupal_maintenance_theme() {  global $theme, $theme_key;  // If $theme is already set, assume the others are set too, and do nothing.  if (isset($theme)) {    return;  }  require_once './includes/path.inc';  require_once './includes/theme.inc';  require_once './includes/common.inc';  require_once './includes/unicode.inc';  require_once './includes/file.inc';  require_once './includes/module.inc';  require_once './includes/database.inc';  unicode_check();  // Install and update pages are treated differently to prevent theming overrides.  if (defined('MAINTENANCE_MODE') && (MAINTENANCE_MODE == 'install' || MAINTENANCE_MODE == 'update')) {    $theme = 'minnelli';  }  else {    if (!db_is_active()) {      // Because we are operating in a crippled environment, we need to      // bootstrap just enough to allow hook invocations to work.      $module_list['system']['filename'] = 'modules/system/system.module';      $module_list['filter']['filename'] = 'modules/filter/filter.module';      module_list(TRUE, FALSE, FALSE, $module_list);      drupal_load('module', 'system');      drupal_load('module', 'filter');    }    $theme = variable_get('maintenance_theme', 'minnelli');  }  $themes = list_themes();  // Store the identifier for retrieving theme settings with.  $theme_key = $theme;  // Find all our ancestor themes and put them in an array.  $base_theme = array();  $ancestor = $theme;  while ($ancestor && isset($themes[$ancestor]->base_theme)) {    $base_theme[] = $new_base_theme = $themes[$themes[$ancestor]->base_theme];    $ancestor = $themes[$ancestor]->base_theme;  }  _init_theme($themes[$theme], array_reverse($base_theme), '_theme_load_offline_registry');  // These are usually added from system_init() -except maintenance.css.  // When the database is inactive it's not called so we add it here.  drupal_add_css(drupal_get_path('module', 'system') .'/defaults.css', 'module');  drupal_add_css(drupal_get_path('module', 'system') .'/system.css', 'module');  drupal_add_css(drupal_get_path('module', 'system') .'/system-menus.css', 'module');  drupal_add_css(drupal_get_path('module', 'system') .'/maintenance.css', 'module');}/** * This builds the registry when the site needs to bypass any database calls. */function _theme_load_offline_registry($theme, $base_theme = NULL, $theme_engine = NULL) {  $registry = _theme_build_registry($theme, $base_theme, $theme_engine);  _theme_set_registry($registry);}/** * Return a themed list of maintenance tasks to perform. * * @ingroup themeable */function theme_task_list($items, $active = NULL) {  $done = isset($items[$active]) || $active == NULL;  $output = '<ol class="task-list">';  foreach ($items as $k => $item) {    if ($active == $k) {      $class = 'active';      $done = false;    }    else {      $class = $done ? 'done' : '';    }    $output .= '<li class="'. $class .'">'. $item .'</li>';  }  $output .= '</ol>';  return $output;}/** * Generate a themed installation page. * * Note: this function is not themeable. * * @param $content *   The page content to show. */function theme_install_page($content) {  drupal_set_header('Content-Type: text/html; charset=utf-8');  // Assign content.  $variables['content'] = $content;  // Delay setting the message variable so it can be processed below.  $variables['show_messages'] = FALSE;  // The maintenance preprocess function is recycled here.  template_preprocess_maintenance_page($variables);  // Special handling of error messages  $messages = drupal_set_message();  if (isset($messages['error'])) {    $title = count($messages['error']) > 1 ? st('The following errors must be resolved before you can continue the installation process') : st('The following error must be resolved before you can continue the installation process');    $variables['messages'] .= '<h3>'. $title .':</h3>';    $variables['messages'] .= theme('status_messages', 'error');    $variables['content'] .= '<p>'. st('Please check the error messages and <a href="!url">try again</a>.', array('!url' => check_url(request_uri()))) .'</p>';  }  // Special handling of warning messages  if (isset($messages['warning'])) {    $title = count($messages['warning']) > 1 ? st('The following installation warnings should be carefully reviewed') : st('The following installation warning should be carefully reviewed');    $variables['messages'] .= '<h4>'. $title .':</h4>';    $variables['messages'] .= theme('status_messages', 'warning');  }  // Special handling of status messages  if (isset($messages['status'])) {    $title = count($messages['status']) > 1 ? st('The following installation warnings should be carefully reviewed, but in most cases may be safely ignored') : st('The following installation warning should be carefully reviewed, but in most cases may be safely ignored');    $variables['messages'] .= '<h4>'. $title .':</h4>';    $variables['messages'] .= theme('status_messages', 'status');  }  // This was called as a theme hook (not template), so we need to  // fix path_to_theme() for the template, to point at the actual  // theme rather than system module as owner of the hook.  global $theme_path;  $theme_path = 'themes/garland';  return theme_render_template('themes/garland/maintenance-page.tpl.php', $variables);}/** * Generate a themed update page. * * Note: this function is not themeable. * * @param $content *   The page content to show. * @param $show_messages *   Whether to output status and error messages. *   FALSE can be useful to postpone the messages to a subsequent page. */function theme_update_page($content, $show_messages = TRUE) {  // Set required headers.  drupal_set_header('Content-Type: text/html; charset=utf-8');  // Assign content and show message flag.  $variables['content'] = $content;  $variables['show_messages'] = $show_messages;  // The maintenance preprocess function is recycled here.  template_preprocess_maintenance_page($variables);  // Special handling of warning messages.  $messages = drupal_set_message();  if (isset($messages['warning'])) {    $title = count($messages['warning']) > 1 ? 'The following update warnings should be carefully reviewed before continuing' : 'The following update warning should be carefully reviewed before continuing';    $variables['messages'] .= '<h4>'. $title .':</h4>';    $variables['messages'] .= theme('status_messages', 'warning');  }  // This was called as a theme hook (not template), so we need to  // fix path_to_theme() for the template, to point at the actual  // theme rather than system module as owner of the hook.  global $theme_path;  $theme_path = 'themes/garland';  return theme_render_template('themes/garland/maintenance-page.tpl.php', $variables);}/** * The variables generated here is a mirror of template_preprocess_page(). * This preprocessor will run it's course when theme_maintenance_page() is * invoked. It is also used in theme_install_page() and theme_update_page() to * keep all the variables consistent. * * An alternate template file of "maintenance-page-offline.tpl.php" can be * used when the database is offline to hide errors and completely replace the * content. * * The $variables array contains the following arguments: * - $content * - $show_blocks * * @see maintenance-page.tpl.php */function template_preprocess_maintenance_page(&$variables) {  // Add favicon  if (theme_get_setting('toggle_favicon')) {    drupal_set_html_head('<link rel="shortcut icon" href="'. check_url(theme_get_setting('favicon')) .'" type="image/x-icon" />');  }  global $theme;  // Retrieve the theme data to list all available regions.  $theme_data = _system_theme_data();  $regions = $theme_data[$theme]->info['regions'];  // Get all region content set with drupal_set_content().  foreach (array_keys($regions) as $region) {    // Assign region to a region variable.    $region_content = drupal_get_content($region);    isset($variables[$region]) ? $variables[$region] .= $region_content : $variables[$region] = $region_content;  }  // Setup layout variable.  $variables['layout'] = 'none';  if (!empty($variables['left'])) {    $variables['layout'] = 'left';  }  if (!empty($variables['right'])) {    $variables['layout'] = ($variables['layout'] == 'left') ? 'both' : 'right';  }  // Construct page title  if (drupal_get_title()) {    $head_title = array(strip_tags(drupal_get_title()), variable_get('site_name', 'Drupal'));  }  else {    $head_title = array(variable_get('site_name', 'Drupal'));    if (variable_get('site_slogan', '')) {      $head_title[] = variable_get('site_slogan', '');    }  }  $variables['head_title']        = implode(' | ', $head_title);  $variables['base_path']         = base_path();  $variables['breadcrumb']        = '';  $variables['feed_icons']        = '';  $variables['footer_message']    = filter_xss_admin(variable_get('site_footer', FALSE));  $variables['head']              = drupal_get_html_head();  $variables['help']              = '';  $variables['language']          = $GLOBALS['language'];  $variables['language']->dir     = $GLOBALS['language']->direction ? 'rtl' : 'ltr';  $variables['logo']              = theme_get_setting('logo');  $variables['messages']          = $variables['show_messages'] ? theme('status_messages') : '';  $variables['mission']           = '';  $variables['primary_links']     = array();  $variables['secondary_links']   = array();  $variables['search_box']        = '';  $variables['site_name']         = (theme_get_setting('toggle_name') ? variable_get('site_name', 'Drupal') : '');  $variables['site_slogan']       = (theme_get_setting('toggle_slogan') ? variable_get('site_slogan', '') : '');  $variables['css']               = drupal_add_css();  $variables['styles']            = drupal_get_css();  $variables['scripts']           = drupal_get_js();  $variables['tabs']              = '';  $variables['title']             = drupal_get_title();  $variables['closure']           = '';  // Compile a list of classes that are going to be applied to the body element.  $body_classes = array();  $body_classes[] = 'in-maintenance';  if (isset($variables['db_is_active']) && !$variables['db_is_active']) {    $body_classes[] = 'db-offline';  }  if ($variables['layout'] == 'both') {    $body_classes[] = 'two-sidebars';  }  elseif ($variables['layout'] == 'none') {    $body_classes[] = 'no-sidebars';  }  else {    $body_classes[] = 'one-sidebar sidebar-'. $variables['layout'];  }  $variables['body_classes'] = implode(' ', $body_classes);  // Dead databases will show error messages so supplying this template will  // allow themers to override the page and the content completely.  if (isset($variables['db_is_active']) && !$variables['db_is_active']) {    $variables['template_file'] = 'maintenance-page-offline';  }}
<?php// $Id$/** * @file * System monitoring and logging for administrators. * * The dblog module monitors your site and keeps a list of * recorded events containing usage and performance data, errors, * warnings, and similar operational information. * * @see watchdog() *//** * Implementation of hook_help(). */function dblog_help($path, $arg) {  switch ($path) {    case 'admin/help#dblog':      $output = '<p>'. t('The dblog module monitors your system, capturing system events in a log to be reviewed by an authorized individual at a later time. This is useful for site administrators who want a quick overview of activities on their site. The logs also record the sequence of events, so it can be useful for debugging site errors.') .'</p>';      $output .= '<p>'. t('The dblog log is simply a list of recorded events containing usage data, performance data, errors, warnings and operational information. Administrators should check the dblog report on a regular basis to ensure their site is working properly.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@dblog">Dblog module</a>.', array('@dblog' => 'http://drupal.org/handbook/modules/dblog/')) .'</p>';      return $output;    case 'admin/reports/dblog':      return '<p>'. t('The dblog module monitors your website, capturing system events in a log to be reviewed by an authorized individual at a later time. The dblog log is simply a list of recorded events containing usage data, performance data, errors, warnings and operational information. It is vital to check the dblog report on a regular basis as it is often the only way to tell what is going on.') .'</p>';  }}/** * Implementation of hook_theme() */function dblog_theme() {  return array(    'dblog_filters' => array(      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_menu(). */function dblog_menu() {  $items['admin/settings/logging/dblog'] = array(    'title' => 'Database logging',    'description' => 'Settings for logging to the Drupal database logs. This is the most common method for small to medium sites on shared hosting. The logs are viewable from the admin pages.',    'page callback' => 'drupal_get_form',    'page arguments' => array('dblog_admin_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'dblog.admin.inc',  );  $items['admin/reports/dblog'] = array(    'title' => 'Recent log entries',    'description' => 'View events that have recently been logged.',    'page callback' => 'dblog_overview',    'access arguments' => array('access site reports'),    'weight' => -1,    'file' => 'dblog.admin.inc',  );  $items['admin/reports/page-not-found'] = array(    'title' => "Top 'page not found' errors",    'description' => "View 'page not found' errors (404s).",    'page callback' => 'dblog_top',    'page arguments' => array('page not found'),    'access arguments' => array('access site reports'),    'file' => 'dblog.admin.inc',  );  $items['admin/reports/access-denied'] = array(    'title' => "Top 'access denied' errors",    'description' => "View 'access denied' errors (403s).",    'page callback' => 'dblog_top',    'page arguments' => array('access denied'),    'access arguments' => array('access site reports'),    'file' => 'dblog.admin.inc',  );  $items['admin/reports/event/%'] = array(    'title' => 'Details',    'page callback' => 'dblog_event',    'page arguments' => array(3),    'access arguments' => array('access site reports'),    'type' => MENU_CALLBACK,    'file' => 'dblog.admin.inc',  );  return $items;}function dblog_init() {  if (arg(0) == 'admin' && arg(1) == 'reports') {    // Add the CSS for this module    drupal_add_css(drupal_get_path('module', 'dblog') .'/dblog.css', 'module', 'all', FALSE);  }}/** * Implementation of hook_cron(). * * Remove expired log messages and flood control events. */function dblog_cron() {  // Cleanup the watchdog table  $max = db_result(db_query('SELECT MAX(wid) FROM {watchdog}'));  db_query('DELETE FROM {watchdog} WHERE wid <= %d', $max - variable_get('dblog_row_limit', 1000));}/** * Implementation of hook_user(). */function dblog_user($op, &$edit, &$user) {  if ($op == 'delete') {    db_query('UPDATE {watchdog} SET uid = 0 WHERE uid = %d', $user->uid);  }}function _dblog_get_message_types() {  $types = array();  $result = db_query('SELECT DISTINCT(type) FROM {watchdog} ORDER BY type');  while ($object = db_fetch_object($result)) {    $types[] = $object->type;  }  return $types;}/** * Implementation of hook_watchdog(). */function dblog_watchdog($log = array()) {  $current_db = db_set_active();  db_query("INSERT INTO {watchdog}    (uid, type, message, variables, severity, link, location, referer, hostname, timestamp)    VALUES    (%d, '%s', '%s', '%s', %d, '%s', '%s', '%s', '%s', %d)",    $log['user']->uid,    $log['type'],    $log['message'],    serialize($log['variables']),    $log['severity'],    $log['link'],    $log['request_uri'],    $log['referer'],    $log['ip'],    $log['timestamp']);  if ($current_db) {    db_set_active($current_db);  }}/** * Theme dblog administration filter selector. * * @ingroup themeable */function theme_dblog_filters($form) {  $output = '';  foreach (element_children($form['status']) as $key) {    $output .= drupal_render($form['status'][$key]);  }  $output .= '<div id="dblog-admin-buttons">'. drupal_render($form['buttons']) .'</div>';  return $output;}
<?php// $Id$/** * @file * File-handling and attaching files to nodes. * *//** * Implementation of hook_help(). */function upload_help($path, $arg) {  switch ($path) {    case 'admin/help#upload':      $output = '<p>'. t('The upload module allows users to upload files to the site. The ability to upload files is important for members of a community who want to share work. It is also useful to administrators who want to keep uploaded files connected to posts.') .'</p>';      $output .= '<p>'. t('Users with the upload files permission can upload attachments to posts. Uploads may be enabled for specific content types on the content types settings page. Each user role can be customized to limit or control the file size of uploads, or the maximum dimension of image files.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@upload">Upload module</a>.', array('@upload' => 'http://drupal.org/handbook/modules/upload/')) .'</p>';      return $output;    case 'admin/settings/upload':      return '<p>'. t('Users with the <a href="@permissions">upload files permission</a> can upload attachments. Users with the <a href="@permissions">view uploaded files permission</a> can view uploaded attachments. You can choose which post types can take attachments on the <a href="@types">content types settings</a> page.', array('@permissions' => url('admin/user/permissions'), '@types' => url('admin/settings/types'))) .'</p>';  }}/** * Implementation of hook_theme() */function upload_theme() {  return array(    'upload_attachments' => array(      'arguments' => array('files' => NULL),    ),    'upload_form_current' => array(      'arguments' => array('form' => NULL),    ),    'upload_form_new' => array(      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_perm(). */function upload_perm() {  return array('upload files', 'view uploaded files');}/** * Implementation of hook_link(). */function upload_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  // Display a link with the number of attachments  if ($teaser && $type == 'node' && isset($node->files) && user_access('view uploaded files')) {    $num_files = 0;    foreach ($node->files as $file) {      if ($file->list) {        $num_files++;      }    }    if ($num_files) {      $links['upload_attachments'] = array(        'title' => format_plural($num_files, '1 attachment', '@count attachments'),        'href' => "node/$node->nid",        'attributes' => array('title' => t('Read full article to view attachments.')),        'fragment' => 'attachments'      );    }  }  return $links;}/** * Implementation of hook_menu(). */function upload_menu() {  $items['upload/js'] = array(    'page callback' => 'upload_js',    'access arguments' => array('upload files'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/uploads'] = array(    'title' => 'File uploads',    'description' => 'Control how files may be attached to content.',    'page callback' => 'drupal_get_form',    'page arguments' => array('upload_admin_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_NORMAL_ITEM,    'file' => 'upload.admin.inc',  );  return $items;}function upload_menu_alter(&$items) {  $items['system/files']['access arguments'] = array('view uploaded files');}/** * Determine the limitations on files that a given user may upload. The user * may be in multiple roles so we select the most permissive limitations from * all of their roles. * * @param $user *   A Drupal user object. * @return *   An associative array with the following keys: *     'extensions' *       A white space separated string containing all the file extensions this *       user may upload. *     'file_size' *       The maximum size of a file upload in bytes. *     'user_size' *       The total number of bytes for all for a user's files. *     'resolution' *       A string specifying the maximum resolution of images. */function _upload_file_limits($user) {  $file_limit = variable_get('upload_uploadsize_default', 1);  $user_limit = variable_get('upload_usersize_default', 1);  $all_extensions = explode(' ', variable_get('upload_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp'));  foreach ($user->roles as $rid => $name) {    $extensions = variable_get("upload_extensions_$rid", variable_get('upload_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp'));    $all_extensions = array_merge($all_extensions, explode(' ', $extensions));    // A zero value indicates no limit, take the least restrictive limit.    $file_size = variable_get("upload_uploadsize_$rid", variable_get('upload_uploadsize_default', 1)) * 1024 * 1024;    $file_limit = ($file_limit && $file_size) ? max($file_limit, $file_size) : 0;    $user_size = variable_get("upload_usersize_$rid", variable_get('upload_usersize_default', 1)) * 1024 * 1024;    $user_limit = ($user_limit && $user_size) ? max($user_limit, $user_size) : 0;  }  $all_extensions = implode(' ', array_unique($all_extensions));  return array(    'extensions' => $all_extensions,    'file_size' => $file_limit,    'user_size' => $user_limit,    'resolution' => variable_get('upload_max_resolution', 0),  );}/** * Implementation of hook_file_download(). */function upload_file_download($filepath) {  $filepath = file_create_path($filepath);  $result = db_query("SELECT f.*, u.nid FROM {files} f INNER JOIN {upload} u ON f.fid = u.fid WHERE filepath = '%s'", $filepath);  if ($file = db_fetch_object($result)) {    if (user_access('view uploaded files') && ($node = node_load($file->nid)) && node_access('view', $node)) {      return array(        'Content-Type: ' . $file->filemime,        'Content-Length: ' . $file->filesize,      );    }    else {      return -1;    }  }}/** * Save new uploads and store them in the session to be associated to the node * on upload_save. * * @param $node *   A node object to associate with uploaded files. */function upload_node_form_submit(&$form, &$form_state) {  global $user;  $limits = _upload_file_limits($user);  $validators = array(    'file_validate_extensions' => array($limits['extensions']),    'file_validate_image_resolution' => array($limits['resolution']),    'file_validate_size' => array($limits['file_size'], $limits['user_size']),  );  // Save new file uploads.  if (user_access('upload files') && ($file = file_save_upload('upload', $validators, file_directory_path()))) {    $file->list = variable_get('upload_list_default', 1);    $file->description = $file->filename;    $file->weight = 0;    $file->new = TRUE;    $form['#node']->files[$file->fid] = $file;    $form_state['values']['files'][$file->fid] = (array)$file;  }  if (isset($form_state['values']['files'])) {    foreach ($form_state['values']['files'] as $fid => $file) {      $form_state['values']['files'][$fid]['new'] = !empty($form['#node']->files[$fid]->new);    }  }  // Order the form according to the set file weight values.  if (!empty($form_state['values']['files'])) {    $microweight = 0.001;    foreach ($form_state['values']['files'] as $fid => $file) {      if (is_numeric($fid)) {        $form_state['values']['files'][$fid]['#weight'] = $file['weight'] + $microweight;        $microweight += 0.001;      }    }    uasort($form_state['values']['files'], 'element_sort');  }}function upload_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {    $form['workflow']['upload'] = array(      '#type' => 'radios',      '#title' => t('Attachments'),      '#default_value' => variable_get('upload_'. $form['#node_type']->type, 1),      '#options' => array(t('Disabled'), t('Enabled')),    );  }  if (isset($form['type']) && isset($form['#node'])) {    $node = $form['#node'];    if ($form['type']['#value'] .'_node_form' == $form_id && variable_get("upload_$node->type", TRUE)) {      // Attachments fieldset      $form['attachments'] = array(        '#type' => 'fieldset',        '#access' => user_access('upload files'),        '#title' => t('File attachments'),        '#collapsible' => TRUE,        '#collapsed' => empty($node->files),        '#description' => t('Changes made to the attachments are not permanent until you save this post. The first "listed" file will be included in RSS feeds.'),        '#prefix' => '<div class="attachments">',        '#suffix' => '</div>',        '#weight' => 30,      );      // Wrapper for fieldset contents (used by ahah.js).      $form['attachments']['wrapper'] = array(        '#prefix' => '<div id="attach-wrapper">',        '#suffix' => '</div>',      );      // Make sure necessary directories for upload.module exist and are      // writable before displaying the attachment form.      $path = file_directory_path();      $temp = file_directory_temp();      // Note: pass by reference      if (!file_check_directory($path, FILE_CREATE_DIRECTORY) || !file_check_directory($temp, FILE_CREATE_DIRECTORY)) {        $form['attachments']['#description'] =  t('File attachments are disabled. The file directories have not been properly configured.');        if (user_access('administer site configuration')) {          $form['attachments']['#description'] .= ' '. t('Please visit the <a href="@admin-file-system">file system configuration page</a>.', array('@admin-file-system' => url('admin/settings/file-system')));        }        else {          $form['attachments']['#description'] .= ' '. t('Please contact the site administrator.');        }      }      else {        $form['attachments']['wrapper'] += _upload_form($node);        $form['#attributes']['enctype'] = 'multipart/form-data';      }      $form['#submit'][] = 'upload_node_form_submit';    }  }}/** * Implementation of hook_nodeapi(). */function upload_nodeapi(&$node, $op, $teaser) {  switch ($op) {    case 'load':      $output = '';      if (variable_get("upload_$node->type", 1) == 1) {        $output['files'] = upload_load($node);        return $output;      }      break;    case 'view':      if (isset($node->files) && user_access('view uploaded files')) {        // Add the attachments list to node body with a heavy        // weight to ensure they're below other elements        if (count($node->files)) {          if (!$teaser && user_access('view uploaded files')) {            $node->content['files'] = array(              '#value' => theme('upload_attachments', $node->files),              '#weight' => 50,            );          }        }      }      break;    case 'insert':    case 'update':      if (user_access('upload files')) {        upload_save($node);      }      break;    case 'delete':      upload_delete($node);      break;    case 'delete revision':      upload_delete_revision($node);      break;    case 'search result':      return isset($node->files) && is_array($node->files) ? format_plural(count($node->files), '1 attachment', '@count attachments') : NULL;    case 'rss item':      if (is_array($node->files)) {        $files = array();        foreach ($node->files as $file) {          if ($file->list) {            $files[] = $file;          }        }        if (count($files) > 0) {          // RSS only allows one enclosure per item          $file = array_shift($files);          return array(            array(              'key' => 'enclosure',              'attributes' => array(                'url' => file_create_url($file->filepath),                'length' => $file->filesize,                'type' => $file->filemime              )            )          );        }      }      return array();  }}/** * Displays file attachments in table * * @ingroup themeable */function theme_upload_attachments($files) {  $header = array(t('Attachment'), t('Size'));  $rows = array();  foreach ($files as $file) {    $file = (object)$file;    if ($file->list && empty($file->remove)) {      $href = file_create_url($file->filepath);      $text = $file->description ? $file->description : $file->filename;      $rows[] = array(l($text, $href), format_size($file->filesize));    }  }  if (count($rows)) {    return theme('table', $header, $rows, array('id' => 'attachments'));  }}/** * Determine how much disk space is occupied by a user's uploaded files. * * @param $uid *   The integer user id of a user. * @return *   The amount of disk space used by the user in bytes. */function upload_space_used($uid) {  return file_space_used($uid);}/** * Determine how much disk space is occupied by uploaded files. * * @return *   The amount of disk space used by uploaded files in bytes. */function upload_total_space_used() {  return db_result(db_query('SELECT SUM(f.filesize) FROM {files} f INNER JOIN {upload} u ON f.fid = u.fid'));}function upload_save(&$node) {  if (empty($node->files) || !is_array($node->files)) {    return;  }  foreach ($node->files as $fid => $file) {    // Convert file to object for compatibility    $file = (object)$file;    // Remove file. Process removals first since no further processing    // will be required.    if (!empty($file->remove)) {      db_query('DELETE FROM {upload} WHERE fid = %d AND vid = %d', $fid, $node->vid);      // If the file isn't used by any other revisions delete it.      $count = db_result(db_query('SELECT COUNT(fid) FROM {upload} WHERE fid = %d', $fid));      if ($count < 1) {        file_delete($file->filepath);        db_query('DELETE FROM {files} WHERE fid = %d', $fid);      }      // Remove it from the session in the case of new uploads,      // that you want to disassociate before node submission.      unset($node->files[$fid]);      // Move on, so the removed file won't be added to new revisions.      continue;    }    // Create a new revision, or associate a new file needed.    if (!empty($node->old_vid) || $file->new) {      db_query("INSERT INTO {upload} (fid, nid, vid, list, description, weight) VALUES (%d, %d, %d, %d, '%s', %d)", $file->fid, $node->nid, $node->vid, $file->list, $file->description, $file->weight);      file_set_status($file, FILE_STATUS_PERMANENT);    }    // Update existing revision.    else {      db_query("UPDATE {upload} SET list = %d, description = '%s', weight = %d WHERE fid = %d AND vid = %d", $file->list, $file->description, $file->weight, $file->fid, $node->vid);      file_set_status($file, FILE_STATUS_PERMANENT);    }  }}function upload_delete($node) {  $files = array();  $result = db_query('SELECT DISTINCT f.* FROM {upload} u INNER JOIN {files} f ON u.fid = f.fid WHERE u.nid = %d', $node->nid);  while ($file = db_fetch_object($result)) {    $files[$file->fid] = $file;  }  foreach ($files as $fid => $file) {    // Delete all files associated with the node    db_query('DELETE FROM {files} WHERE fid = %d', $fid);    file_delete($file->filepath);  }  // Delete all file revision information associated with the node  db_query('DELETE FROM {upload} WHERE nid = %d', $node->nid);}function upload_delete_revision($node) {  if (is_array($node->files)) {    foreach ($node->files as $file) {      // Check if the file will be used after this revision is deleted      $count = db_result(db_query('SELECT COUNT(fid) FROM {upload} WHERE fid = %d', $file->fid));      // if the file won't be used, delete it      if ($count < 2) {        db_query('DELETE FROM {files} WHERE fid = %d', $file->fid);        file_delete($file->filepath);      }    }  }  // delete the revision  db_query('DELETE FROM {upload} WHERE vid = %d', $node->vid);}function _upload_form($node) {  global $user;  $form = array(    '#theme' => 'upload_form_new',    '#cache' => TRUE,  );  if (!empty($node->files) && is_array($node->files)) {    $form['files']['#theme'] = 'upload_form_current';    $form['files']['#tree'] = TRUE;    foreach ($node->files as $key => $file) {      $file = (object)$file;      $description = file_create_url($file->filepath);      $description = "<small>". check_plain($description) ."</small>";      $form['files'][$key]['description'] = array('#type' => 'textfield', '#default_value' => !empty($file->description) ? $file->description : $file->filename, '#maxlength' => 256, '#description' => $description );      $form['files'][$key]['size'] = array('#value' => format_size($file->filesize));      $form['files'][$key]['remove'] = array('#type' => 'checkbox', '#default_value' => !empty($file->remove));      $form['files'][$key]['list'] = array('#type' => 'checkbox',  '#default_value' => $file->list);      $form['files'][$key]['weight'] = array('#type' => 'weight', '#delta' => count($node->files), '#default_value' => $file->weight);      $form['files'][$key]['filename'] = array('#type' => 'value',  '#value' => $file->filename);      $form['files'][$key]['filepath'] = array('#type' => 'value',  '#value' => $file->filepath);      $form['files'][$key]['filemime'] = array('#type' => 'value',  '#value' => $file->filemime);      $form['files'][$key]['filesize'] = array('#type' => 'value',  '#value' => $file->filesize);      $form['files'][$key]['fid'] = array('#type' => 'value',  '#value' => $file->fid);      $form['files'][$key]['new'] = array('#type' => 'value', '#value' => FALSE);    }  }  if (user_access('upload files')) {    $limits = _upload_file_limits($user);    $form['new']['#weight'] = 10;    $form['new']['upload'] = array(      '#type' => 'file',      '#title' => t('Attach new file'),      '#size' => 40,      '#description' => ($limits['resolution'] ? t('Images are larger than %resolution will be resized. ', array('%resolution' => $limits['resolution'])) : '') . t('The maximum upload size is %filesize. Only files with the following extensions may be uploaded: %extensions. ', array('%extensions' => $limits['extensions'], '%filesize' => format_size($limits['file_size']))),    );    $form['new']['attach'] = array(      '#type' => 'submit',      '#value' => t('Attach'),      '#name' => 'attach',      '#ahah' => array(        'path' => 'upload/js',        'wrapper' => 'attach-wrapper',        'progress' => array('type' => 'bar', 'message' => t('Please wait...')),      ),      '#submit' => array('node_form_submit_build_node'),    );  }  return $form;}/** * Theme the attachments list. * * @ingroup themeable */function theme_upload_form_current($form) {  $header = array('', t('Delete'), t('List'), t('Description'), t('Weight'), t('Size'));  drupal_add_tabledrag('upload-attachments', 'order', 'sibling', 'upload-weight');  foreach (element_children($form) as $key) {    // Add class to group weight fields for drag and drop.    $form[$key]['weight']['#attributes']['class'] = 'upload-weight';    $row = array('');    $row[] = drupal_render($form[$key]['remove']);    $row[] = drupal_render($form[$key]['list']);    $row[] = drupal_render($form[$key]['description']);    $row[] = drupal_render($form[$key]['weight']);    $row[] = drupal_render($form[$key]['size']);    $rows[] = array('data' => $row, 'class' => 'draggable');  }  $output = theme('table', $header, $rows, array('id' => 'upload-attachments'));  $output .= drupal_render($form);  return $output;}/** * Theme the attachment form. * Note: required to output prefix/suffix. * * @ingroup themeable */function theme_upload_form_new($form) {  drupal_add_tabledrag('upload-attachments', 'order', 'sibling', 'upload-weight');  $output = drupal_render($form);  return $output;}function upload_load($node) {  $files = array();  if ($node->vid) {    $result = db_query('SELECT * FROM {files} f INNER JOIN {upload} r ON f.fid = r.fid WHERE r.vid = %d ORDER BY r.weight, f.fid', $node->vid);    while ($file = db_fetch_object($result)) {      $files[$file->fid] = $file;    }  }  return $files;}/** * Menu-callback for JavaScript-based uploads. */function upload_js() {  $cached_form_state = array();  $files = array();  // Load the form from the Form API cache.  if (!($cached_form = form_get_cache($_POST['form_build_id'], $cached_form_state)) || !isset($cached_form['#node']) || !isset($cached_form['attachments'])) {    form_set_error('form_token', t('Validation error, please try again. If this error persists, please contact the site administrator.'));    $output = theme('status_messages');    print drupal_to_js(array('status' => TRUE, 'data' => $output));    exit();  }  $form_state = array('values' => $_POST);  // Handle new uploads, and merge tmp files into node-files.  upload_node_form_submit($cached_form, $form_state);  if(!empty($form_state['values']['files'])) {    foreach ($form_state['values']['files'] as $fid => $file) {      if (isset($cached_form['#node']->files[$fid])) {        $files[$fid] = $cached_form['#node']->files[$fid];      }    }  }  $node = $cached_form['#node'];  $node->files = $files;  $form = _upload_form($node);  unset($cached_form['attachments']['wrapper']['new']);  $cached_form['attachments']['wrapper'] = array_merge($cached_form['attachments']['wrapper'], $form);  $cached_form['attachments']['#collapsed'] = FALSE;  form_set_cache($_POST['form_build_id'], $cached_form, $cached_form_state);  foreach ($files as $fid => $file) {    if (is_numeric($fid)) {      $form['files'][$fid]['description']['#default_value'] = $form_state['values']['files'][$fid]['description'];      $form['files'][$fid]['list']['#default_value'] = !empty($form_state['values']['files'][$fid]['list']);      $form['files'][$fid]['remove']['#default_value'] = !empty($form_state['values']['files'][$fid]['remove']);      $form['files'][$fid]['weight']['#default_value'] = $form_state['values']['files'][$fid]['weight'];    }  }  // Render the form for output.  $form += array(    '#post' => $_POST,    '#programmed' => FALSE,    '#tree' => FALSE,    '#parents' => array(),  );  drupal_alter('form', $form, array(), 'upload_js');  $form_state = array('submitted' => FALSE);  $form = form_builder('upload_js', $form, $form_state);  $output = theme('status_messages') . drupal_render($form);  // We send the updated file attachments form.  // Don't call drupal_json(). ahah.js uses an iframe and  // the header output by drupal_json() causes problems in some browsers.  print drupal_to_js(array('status' => TRUE, 'data' => $output));  exit;}
<?php// $Id$/** * @file * Content administration and module settings UI. *//** * Menu callback; presents general node configuration options. */function node_configure() {  $status = '<p>'. t('If the site is experiencing problems with permissions to content, you may have to rebuild the permissions cache. Possible causes for permission problems are disabling modules or configuration changes to permissions. Rebuilding will remove all privileges to posts, and replace them with permissions based on the current modules and settings.') .'</p>';  $status .= '<p>'. t('Rebuilding may take some time if there is a lot of content or complex permission settings. After rebuilding has completed posts will automatically use the new permissions.') .'</p>';  $form['access'] = array(    '#type' => 'fieldset',    '#title' => t('Node access status'),  );  $form['access']['status'] = array('#value' => $status);  $form['access']['rebuild'] = array(    '#type' => 'submit',    '#value' => t('Rebuild permissions'),    '#submit' => array('node_configure_access_submit'),  );  $form['default_nodes_main'] = array(    '#type' => 'select', '#title' => t('Number of posts on main page'), '#default_value' => variable_get('default_nodes_main', 10),    '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30)),    '#description' => t('The default maximum number of posts to display per page on overview pages such as the main page.')  );  $form['teaser_length'] = array(    '#type' => 'select', '#title' => t('Length of trimmed posts'), '#default_value' => variable_get('teaser_length', 600),    '#options' => array(      0 => t('Unlimited'),      200 => t('200 characters'),      400 => t('400 characters'),      600 => t('600 characters'),      800 => t('800 characters'),      1000 => t('1000 characters'),      1200 => t('1200 characters'),      1400 => t('1400 characters'),      1600 => t('1600 characters'),      1800 => t('1800 characters'),      2000 => t('2000 characters'),    ),    '#description' => t("The maximum number of characters used in the trimmed version of a post. Drupal will use this setting to determine at which offset long posts should be trimmed. The trimmed version of a post is typically used as a teaser when displaying the post on the main page, in XML feeds, etc. To disable teasers, set to 'Unlimited'. Note that this setting will only affect new or updated content and will not affect existing teasers.")  );  $form['node_preview'] = array(    '#type' => 'radios',    '#title' => t('Preview post'),    '#default_value' => variable_get('node_preview', 0),    '#options' => array(t('Optional'), t('Required')),    '#description' => t('Must users preview posts before submitting?'),  );  return system_settings_form($form);}/** * Form button submit callback. */function node_configure_access_submit($form, &$form_state) {  $form_state['redirect'] = 'admin/content/node-settings/rebuild';}/** * Menu callback: confirm rebuilding of permissions. */function node_configure_rebuild_confirm() {  return confirm_form(array(), t('Are you sure you want to rebuild the permissions on site content?'),                  'admin/content/node-settings', t('This action rebuilds all permissions on site content, and may be a lengthy process. This action cannot be undone.'), t('Rebuild permissions'), t('Cancel'));}/** * Handler for wipe confirmation */function node_configure_rebuild_confirm_submit($form, &$form_state) {  node_access_rebuild(TRUE);  $form_state['redirect'] = 'admin/content/node-settings';}/** * Implementation of hook_node_operations(). */function node_node_operations() {  $operations = array(    'publish' => array(      'label' => t('Publish'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('status' => 1)),    ),    'unpublish' => array(      'label' => t('Unpublish'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('status' => 0)),    ),    'promote' => array(      'label' => t('Promote to front page'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('status' => 1, 'promote' => 1)),    ),    'demote' => array(      'label' => t('Demote from front page'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('promote' => 0)),    ),    'sticky' => array(      'label' => t('Make sticky'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('status' => 1, 'sticky' => 1)),    ),    'unsticky' => array(      'label' => t('Remove stickiness'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('sticky' => 0)),    ),    'delete' => array(      'label' => t('Delete'),      'callback' => NULL,    ),  );  return $operations;}/** * List node administration filters that can be applied. */function node_filters() {  // Regular filters  $filters['status'] = array(    'title' => t('status'),    'options' => array(      'status-1' => t('published'),      'status-0' => t('not published'),      'promote-1' => t('promoted'),      'promote-0' => t('not promoted'),      'sticky-1' => t('sticky'),      'sticky-0' => t('not sticky'),    ),  );  // Include translation states if we have this module enabled  if (module_exists('translation')) {    $filters['status']['options'] += array(      'translate-0' => t('Up to date translation'),      'translate-1' => t('Outdated translation'),    );  }  $filters['type'] = array('title' => t('type'), 'options' => node_get_types('names'));  // The taxonomy filter  if ($taxonomy = module_invoke('taxonomy', 'form_all', 1)) {    $filters['category'] = array('title' => t('category'), 'options' => $taxonomy);  }  // Language filter if there is a list of languages  if ($languages = module_invoke('locale', 'language_list')) {    $languages = array('' => t('Language neutral')) + $languages;    $filters['language'] = array('title' => t('language'), 'options' => $languages);  }  return $filters;}/** * Build query for node administration filters based on session. */function node_build_filter_query() {  $filters = node_filters();  // Build query  $where = $args = array();  $join = '';  foreach ($_SESSION['node_overview_filter'] as $index => $filter) {    list($key, $value) = $filter;    switch ($key) {      case 'status':        // Note: no exploitable hole as $key/$value have already been checked when submitted        list($key, $value) = explode('-', $value, 2);        $where[] = 'n.'. $key .' = %d';        break;      case 'category':        $table = "tn$index";        $where[] = "$table.tid = %d";        $join .= "INNER JOIN {term_node} $table ON n.nid = $table.nid ";        break;      case 'type':        $where[] = "n.type = '%s'";        break;      case 'language':        $where[] = "n.language = '%s'";        break;    }    $args[] = $value;  }  $where = count($where) ? 'WHERE '. implode(' AND ', $where) : '';  return array('where' => $where, 'join' => $join, 'args' => $args);}/** * Return form for node administration filters. */function node_filter_form() {  $session = &$_SESSION['node_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = node_filters();  $i = 0;  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Show only items where'),    '#theme' => 'node_filters',  );  $form['#submit'][] = 'node_filter_form_submit';  foreach ($session as $filter) {    list($type, $value) = $filter;    if ($type == 'category') {      // Load term name from DB rather than search and parse options array.      $value = module_invoke('taxonomy', 'get_term', $value);      $value = $value->name;    }    else if ($type == 'language') {      $value = empty($value) ? t('Language neutral') : module_invoke('locale', 'language_name', $value);    }    else {      $value = $filters[$type]['options'][$value];    }    if ($i++) {      $form['filters']['current'][] = array('#value' => t('<em>and</em> where <strong>%a</strong> is <strong>%b</strong>', array('%a' => $filters[$type]['title'], '%b' => $value)));    }    else {      $form['filters']['current'][] = array('#value' => t('<strong>%a</strong> is <strong>%b</strong>', array('%a' => $filters[$type]['title'], '%b' => $value)));    }    if (in_array($type, array('type', 'language'))) {      // Remove the option if it is already being filtered on.      unset($filters[$type]);    }  }  foreach ($filters as $key => $filter) {    $names[$key] = $filter['title'];    $form['filters']['status'][$key] = array('#type' => 'select', '#options' => $filter['options']);  }  $form['filters']['filter'] = array('#type' => 'radios', '#options' => $names, '#default_value' => 'status');  $form['filters']['buttons']['submit'] = array('#type' => 'submit', '#value' => (count($session) ? t('Refine') : t('Filter')));  if (count($session)) {    $form['filters']['buttons']['undo'] = array('#type' => 'submit', '#value' => t('Undo'));    $form['filters']['buttons']['reset'] = array('#type' => 'submit', '#value' => t('Reset'));  }  drupal_add_js('misc/form.js', 'core');  return $form;}/** * Theme node administration filter form. * * @ingroup themeable */function theme_node_filter_form($form) {  $output = '';  $output .= '<div id="node-admin-filter">';  $output .= drupal_render($form['filters']);  $output .= '</div>';  $output .= drupal_render($form);  return $output;}/** * Theme node administration filter selector. * * @ingroup themeable */function theme_node_filters($form) {  $output = '';  $output .= '<ul class="clear-block">';  if (!empty($form['current'])) {    foreach (element_children($form['current']) as $key) {      $output .= '<li>'. drupal_render($form['current'][$key]) .'</li>';    }  }  $output .= '<li><dl class="multiselect">'. (!empty($form['current']) ? '<dt><em>'. t('and') .'</em> '. t('where') .'</dt>' : '') .'<dd class="a">';  foreach (element_children($form['filter']) as $key) {    $output .= drupal_render($form['filter'][$key]);  }  $output .= '</dd>';  $output .= '<dt>'. t('is') .'</dt><dd class="b">';  foreach (element_children($form['status']) as $key) {    $output .= drupal_render($form['status'][$key]);  }  $output .= '</dd>';  $output .= '</dl>';  $output .= '<div class="container-inline" id="node-admin-buttons">'. drupal_render($form['buttons']) .'</div>';  $output .= '</li></ul>';  return $output;}/** * Process result from node administration filter form. */function node_filter_form_submit($form, &$form_state) {  $filters = node_filters();  switch ($form_state['values']['op']) {    case t('Filter'):    case t('Refine'):      if (isset($form_state['values']['filter'])) {        $filter = $form_state['values']['filter'];        // Flatten the options array to accommodate hierarchical/nested options.        $flat_options = form_options_flatten($filters[$filter]['options']);        if (isset($flat_options[$form_state['values'][$filter]])) {          $_SESSION['node_overview_filter'][] = array($filter, $form_state['values'][$filter]);        }      }      break;    case t('Undo'):      array_pop($_SESSION['node_overview_filter']);      break;    case t('Reset'):      $_SESSION['node_overview_filter'] = array();      break;  }}/** * Make mass update of nodes, changing all nodes in the $nodes array * to update them with the field values in $updates. * * IMPORTANT NOTE: This function is intended to work when called * from a form submit handler. Calling it outside of the form submission * process may not work correctly. * * @param array $nodes *   Array of node nids to update. * @param array $updates *   Array of key/value pairs with node field names and the *   value to update that field to. */function node_mass_update($nodes, $updates) {  // We use batch processing to prevent timeout when updating a large number  // of nodes.  if (count($nodes) > 10) {    $batch = array(      'operations' => array(        array('_node_mass_update_batch_process', array($nodes, $updates))      ),      'finished' => '_node_mass_update_batch_finished',      'title' => t('Processing'),      // We use a single multi-pass operation, so the default      // 'Remaining x of y operations' message will be confusing here.      'progress_message' => '',      'error_message' => t('The update has encountered an error.'),      // The operations do not live in the .module file, so we need to      // tell the batch engine which file to load before calling them.      'file' => drupal_get_path('module', 'node') .'/node.admin.inc',    );    batch_set($batch);  }  else {    foreach ($nodes as $nid) {      _node_mass_update_helper($nid, $updates);    }    drupal_set_message(t('The update has been performed.'));  }}/** * Node Mass Update - helper function. */function _node_mass_update_helper($nid, $updates) {  $node = node_load($nid, NULL, TRUE);  foreach ($updates as $name => $value) {    $node->$name = $value;  }  node_save($node);  return $node;}/** * Node Mass Update Batch operation */function _node_mass_update_batch_process($nodes, $updates, &$context) {  if (!isset($context['sandbox']['progress'])) {    $context['sandbox']['progress'] = 0;    $context['sandbox']['max'] = count($nodes);    $context['sandbox']['nodes'] = $nodes;  }  // Process nodes by groups of 5.  $count = min(5, count($context['sandbox']['nodes']));  for ($i = 1; $i <= $count; $i++) {    // For each nid, load the node, reset the values, and save it.    $nid = array_shift($context['sandbox']['nodes']);    $node = _node_mass_update_helper($nid, $updates);    // Store result for post-processing in the finished callback.    $context['results'][] = l($node->title, 'node/'. $node->nid);    // Update our progress information.    $context['sandbox']['progress']++;  }  // Inform the batch engine that we are not finished,  // and provide an estimation of the completion level we reached.  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];  }}/** * Node Mass Update Batch 'finished' callback. */function _node_mass_update_batch_finished($success, $results, $operations) {  if ($success) {    drupal_set_message(t('The update has been performed.'));  }  else {    drupal_set_message(t('An error occurred and processing did not complete.'), 'error');    $message = format_plural(count($results), '1 item successfully processed:', '@count items successfully processed:');    $message .= theme('item_list', $results);    drupal_set_message($message);  }}/** * Menu callback: content administration. */function node_admin_content($form_state) {  if (isset($form_state['values']['operation']) && $form_state['values']['operation'] == 'delete') {    return node_multiple_delete_confirm($form_state, array_filter($form_state['values']['nodes']));  }  $form = node_filter_form();  $form['#theme'] = 'node_filter_form';  $form['admin']  = node_admin_nodes();  return $form;}/** * Form builder: Builds the node administration overview. */function node_admin_nodes() {  $filter = node_build_filter_query();  $result = pager_query(db_rewrite_sql('SELECT n.*, u.name FROM {node} n '. $filter['join'] .' INNER JOIN {users} u ON n.uid = u.uid '. $filter['where'] .' ORDER BY n.changed DESC'), 50, 0, NULL, $filter['args']);  // Enable language column if locale is enabled or if we have any node with language  $count = db_result(db_query("SELECT COUNT(*) FROM {node} n WHERE language != ''"));  $multilanguage = (module_exists('locale') || $count);  $form['options'] = array(    '#type' => 'fieldset',    '#title' => t('Update options'),    '#prefix' => '<div class="container-inline">',    '#suffix' => '</div>',  );  $options = array();  foreach (module_invoke_all('node_operations') as $operation => $array) {    $options[$operation] = $array['label'];  }  $form['options']['operation'] = array(    '#type' => 'select',    '#options' => $options,    '#default_value' => 'approve',  );  $form['options']['submit'] = array(    '#type' => 'submit',    '#value' => t('Update'),    '#submit' => array('node_admin_nodes_submit'),  );  $languages = language_list();  $destination = drupal_get_destination();  $nodes = array();  while ($node = db_fetch_object($result)) {    $nodes[$node->nid] = '';    $options = empty($node->language) ? array() : array('language' => $languages[$node->language]);    $form['title'][$node->nid] = array('#value' => l($node->title, 'node/'. $node->nid, $options) .' '. theme('mark', node_mark($node->nid, $node->changed)));    $form['name'][$node->nid] =  array('#value' => check_plain(node_get_types('name', $node)));    $form['username'][$node->nid] = array('#value' => theme('username', $node));    $form['status'][$node->nid] =  array('#value' => ($node->status ? t('published') : t('not published')));    if ($multilanguage) {      $form['language'][$node->nid] = array('#value' => empty($node->language) ? t('Language neutral') : t($languages[$node->language]->name));    }    $form['operations'][$node->nid] = array('#value' => l(t('edit'), 'node/'. $node->nid .'/edit', array('query' => $destination)));  }  $form['nodes'] = array('#type' => 'checkboxes', '#options' => $nodes);  $form['pager'] = array('#value' => theme('pager', NULL, 50, 0));  $form['#theme'] = 'node_admin_nodes';  return $form;}/** * Validate node_admin_nodes form submissions. *  * Check if any nodes have been selected to perform the chosen * 'Update option' on. */function node_admin_nodes_validate($form, &$form_state) {  $nodes = array_filter($form_state['values']['nodes']);  if (count($nodes) == 0) {    form_set_error('', t('No items selected.'));  }}/** * Process node_admin_nodes form submissions. *  * Execute the chosen 'Update option' on the selected nodes. */function node_admin_nodes_submit($form, &$form_state) {  $operations = module_invoke_all('node_operations');  $operation = $operations[$form_state['values']['operation']];  // Filter out unchecked nodes  $nodes = array_filter($form_state['values']['nodes']);  if ($function = $operation['callback']) {    // Add in callback arguments if present.    if (isset($operation['callback arguments'])) {      $args = array_merge(array($nodes), $operation['callback arguments']);    }    else {      $args = array($nodes);    }    call_user_func_array($function, $args);    cache_clear_all();  }  else {    // We need to rebuild the form to go to a second step.  For example, to    // show the confirmation form for the deletion of nodes.    $form_state['rebuild'] = TRUE;  }}/** * Theme node administration overview. * * @ingroup themeable */function theme_node_admin_nodes($form) {  // If there are rows in this form, then $form['title'] contains a list of  // the title form elements.  $has_posts = isset($form['title']) && is_array($form['title']);  $select_header = $has_posts ? theme('table_select_header_cell') : '';  $header = array($select_header, t('Title'), t('Type'), t('Author'), t('Status'));  if (isset($form['language'])) {    $header[] = t('Language');  }  $header[] = t('Operations');  $output = '';  $output .= drupal_render($form['options']);  if ($has_posts) {    foreach (element_children($form['title']) as $key) {      $row = array();      $row[] = drupal_render($form['nodes'][$key]);      $row[] = drupal_render($form['title'][$key]);      $row[] = drupal_render($form['name'][$key]);      $row[] = drupal_render($form['username'][$key]);      $row[] = drupal_render($form['status'][$key]);      if (isset($form['language'])) {        $row[] = drupal_render($form['language'][$key]);      }      $row[] = drupal_render($form['operations'][$key]);      $rows[] = $row;    }  }  else {    $rows[] = array(array('data' => t('No posts available.'), 'colspan' => '6'));  }  $output .= theme('table', $header, $rows);  if ($form['pager']['#value']) {    $output .= drupal_render($form['pager']);  }  $output .= drupal_render($form);  return $output;}function node_multiple_delete_confirm(&$form_state, $nodes) {  $form['nodes'] = array('#prefix' => '<ul>', '#suffix' => '</ul>', '#tree' => TRUE);  // array_filter returns only elements with TRUE values  foreach ($nodes as $nid => $value) {    $title = db_result(db_query('SELECT title FROM {node} WHERE nid = %d', $nid));    $form['nodes'][$nid] = array(      '#type' => 'hidden',      '#value' => $nid,      '#prefix' => '<li>',      '#suffix' => check_plain($title) ."</li>\n",    );  }  $form['operation'] = array('#type' => 'hidden', '#value' => 'delete');  $form['#submit'][] = 'node_multiple_delete_confirm_submit';  return confirm_form($form,                      t('Are you sure you want to delete these items?'),                      'admin/content/node', t('This action cannot be undone.'),                      t('Delete all'), t('Cancel'));}function node_multiple_delete_confirm_submit($form, &$form_state) {  if ($form_state['values']['confirm']) {    foreach ($form_state['values']['nodes'] as $nid => $value) {      node_delete($nid);    }    drupal_set_message(t('The items have been deleted.'));  }  $form_state['redirect'] = 'admin/content/node';  return;}
<?php// $Id$?>  <div class="comment<?php print ' '. $status; ?>">    <?php if ($picture) {    print $picture;  } ?><h3 class="title"><?php print $title; ?></h3><?php if ($new != '') { ?><span class="new"><?php print $new; ?></span><?php } ?>    <div class="submitted"><?php print $submitted; ?></div>    <div class="content">     <?php print $content; ?>     <?php if ($signature): ?>      <div class="clear-block">       <div></div>       <?php print $signature ?>      </div>     <?php endif; ?>    </div>    <div class="links">&raquo; <?php print $links; ?></div>  </div>
<?php// $Id$/** * @file * The core that allows content to be submitted to the site. Modules and scripts may * programmatically submit nodes using the usual form API pattern. *//** * Nodes changed before this time are always marked as read. * * Nodes changed after this time may be marked new, updated, or read, depending * on their state for the current user. Defaults to 30 days ago. */define('NODE_NEW_LIMIT', time() - 30 * 24 * 60 * 60);define('NODE_BUILD_NORMAL', 0);define('NODE_BUILD_PREVIEW', 1);define('NODE_BUILD_SEARCH_INDEX', 2);define('NODE_BUILD_SEARCH_RESULT', 3);define('NODE_BUILD_RSS', 4);define('NODE_BUILD_PRINT', 5);/** * Implementation of hook_help(). */function node_help($path, $arg) {  // Remind site administrators about the {node_access} table being flagged  // for rebuild. We don't need to issue the message on the confirm form, or  // while the rebuild is being processed.  if ($path != 'admin/content/node-settings/rebuild' && $path != 'batch' && strpos($path, '#') === FALSE      && user_access('access administration pages') && node_access_needs_rebuild()) {    if ($path == 'admin/content/node-settings') {      $message = t('The content access permissions need to be rebuilt.');    }    else {      $message = t('The content access permissions need to be rebuilt. Please visit <a href="@node_access_rebuild">this page</a>.', array('@node_access_rebuild' => url('admin/content/node-settings/rebuild')));    }    drupal_set_message($message, 'error');  }  switch ($path) {    case 'admin/help#node':      $output = '<p>'. t('The node module manages content on your site, and stores all posts (regardless of type) as a "node". In addition to basic publishing settings, including whether the post has been published, promoted to the site front page, or should remain present (or sticky) at the top of lists, the node module also records basic information about the author of a post. Optional revision control over edits is available. For additional functionality, the node module is often extended by other modules.') .'</p>';      $output .= '<p>'. t('Though each post on your site is a node, each post is also of a particular <a href="@content-type">content type</a>. <a href="@content-type">Content types</a> are used to define the characteristics of a post, including the title and description of the fields displayed on its add and edit pages. Each content type may have different default settings for <em>Publishing options</em> and other workflow controls. By default, the two content types in a standard Drupal installation are <em>Page</em> and <em>Story</em>. Use the <a href="@content-type">content types page</a> to add new or edit existing content types. Additional content types also become available as you enable additional core, contributed and custom modules.', array('@content-type' => url('admin/content/types'))) .'</p>';      $output .= '<p>'. t('The administrative <a href="@content">content page</a> allows you to review and manage your site content. The <a href="@post-settings">post settings page</a> sets certain options for the display of posts. The node module makes a number of permissions available for each content type, which may be set by role on the <a href="@permissions">permissions page</a>.', array('@content' => url('admin/content/node'), '@post-settings' => url('admin/content/node-settings'), '@permissions' => url('admin/user/permissions'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@node">Node module</a>.', array('@node' => 'http://drupal.org/handbook/modules/node/')) .'</p>';      return $output;    case 'admin/content/node':      return ' '; // Return a non-null value so that the 'more help' link is shown.    case 'admin/content/types':      return '<p>'. t('Below is a list of all the content types on your site. All posts that exist on your site are instances of one of these content types.') .'</p>';    case 'admin/content/types/add':      return '<p>'. t('To create a new content type, enter the human-readable name, the machine-readable name, and all other relevant fields that are on this page. Once created, users of your site will be able to create posts that are instances of this content type.') .'</p>';    case 'node/%/revisions':      return '<p>'. t('The revisions let you track differences between multiple versions of a post.') .'</p>';    case 'node/%/edit':      $node = node_load($arg[1]);      $type = node_get_types('type', $node->type);      return (!empty($type->help) ? '<p>'. filter_xss_admin($type->help) .'</p>' : '');  }  if ($arg[0] == 'node' && $arg[1] == 'add' && $arg[2]) {    $type = node_get_types('type', str_replace('-', '_', $arg[2]));    return (!empty($type->help) ? '<p>'. filter_xss_admin($type->help) .'</p>' : '');  }}/** * Implementation of hook_theme() */function node_theme() {  return array(    'node' => array(      'arguments' => array('node' => NULL, 'teaser' => FALSE, 'page' => FALSE),      'template' => 'node',    ),    'node_list' => array(      'arguments' => array('items' => NULL, 'title' => NULL),    ),    'node_search_admin' => array(      'arguments' => array('form' => NULL),    ),    'node_filter_form' => array(      'arguments' => array('form' => NULL),      'file' => 'node.admin.inc',    ),    'node_filters' => array(      'arguments' => array('form' => NULL),      'file' => 'node.admin.inc',    ),    'node_admin_nodes' => array(      'arguments' => array('form' => NULL),      'file' => 'node.admin.inc',    ),    'node_add_list' => array(      'arguments' => array('content' => NULL),      'file' => 'node.pages.inc',    ),    'node_form' => array(      'arguments' => array('form' => NULL),      'file' => 'node.pages.inc',    ),    'node_preview' => array(      'arguments' => array('node' => NULL),      'file' => 'node.pages.inc',    ),    'node_log_message' => array(      'arguments' => array('log' => NULL),    ),    'node_submitted' => array(      'arguments' => array('node' => NULL),    ),  );}/** * Implementation of hook_cron(). */function node_cron() {  db_query('DELETE FROM {history} WHERE timestamp < %d', NODE_NEW_LIMIT);}/** * Gather a listing of links to nodes. * * @param $result *   A DB result object from a query to fetch node objects. If your query *   joins the <code>node_comment_statistics</code> table so that the *   <code>comment_count</code> field is available, a title attribute will *   be added to show the number of comments. * @param $title *   A heading for the resulting list. * * @return *   An HTML list suitable as content for a block, or FALSE if no result can *   fetch from DB result object. */function node_title_list($result, $title = NULL) {  $items = array();  $num_rows = FALSE;  while ($node = db_fetch_object($result)) {    $items[] = l($node->title, 'node/'. $node->nid, !empty($node->comment_count) ? array('attributes' => array('title' => format_plural($node->comment_count, '1 comment', '@count comments'))) : array());    $num_rows = TRUE;  }  return $num_rows ? theme('node_list', $items, $title) : FALSE;}/** * Format a listing of links to nodes. * * @ingroup themeable */function theme_node_list($items, $title = NULL) {  return theme('item_list', $items, $title);}/** * Update the 'last viewed' timestamp of the specified node for current user. */function node_tag_new($nid) {  global $user;  if ($user->uid) {    if (node_last_viewed($nid)) {      db_query('UPDATE {history} SET timestamp = %d WHERE uid = %d AND nid = %d', time(), $user->uid, $nid);    }    else {      @db_query('INSERT INTO {history} (uid, nid, timestamp) VALUES (%d, %d, %d)', $user->uid, $nid, time());    }  }}/** * Retrieves the timestamp at which the current user last viewed the * specified node. */function node_last_viewed($nid) {  global $user;  static $history;  if (!isset($history[$nid])) {    $history[$nid] = db_fetch_object(db_query("SELECT timestamp FROM {history} WHERE uid = %d AND nid = %d", $user->uid, $nid));  }  return (isset($history[$nid]->timestamp) ? $history[$nid]->timestamp : 0);}/** * Decide on the type of marker to be displayed for a given node. * * @param $nid *   Node ID whose history supplies the "last viewed" timestamp. * @param $timestamp *   Time which is compared against node's "last viewed" timestamp. * @return *   One of the MARK constants. */function node_mark($nid, $timestamp) {  global $user;  static $cache;  if (!$user->uid) {    return MARK_READ;  }  if (!isset($cache[$nid])) {    $cache[$nid] = node_last_viewed($nid);  }  if ($cache[$nid] == 0 && $timestamp > NODE_NEW_LIMIT) {    return MARK_NEW;  }  elseif ($timestamp > $cache[$nid] && $timestamp > NODE_NEW_LIMIT) {    return MARK_UPDATED;  }  return MARK_READ;}/** * See if the user used JS to submit a teaser. */function node_teaser_js(&$form, &$form_state) {  if (isset($form['#post']['teaser_js'])) {    // Glue the teaser to the body.    if (trim($form_state['values']['teaser_js'])) {      // Space the teaser from the body      $body = trim($form_state['values']['teaser_js']) ."\r\n<!--break-->\r\n". trim($form_state['values']['body']);    }    else {      // Empty teaser, no spaces.      $body = '<!--break-->'. $form_state['values']['body'];    }    // Pass updated body value on to preview/submit form processing.    form_set_value($form['body'], $body, $form_state);    // Pass updated body value back onto form for those cases    // in which the form is redisplayed.    $form['body']['#value'] = $body;  }  return $form;}/** * Ensure value of "teaser_include" checkbox is consistent with other form data. * * This handles two situations in which an unchecked checkbox is rejected: * *   1. The user defines a teaser (summary) but it is empty; *   2. The user does not define a teaser (summary) (in this case an *      unchecked checkbox would cause the body to be empty, or missing *      the auto-generated teaser). * * If JavaScript is active then it is used to force the checkbox to be * checked when hidden, and so the second case will not arise. * * In either case a warning message is output. */function node_teaser_include_verify(&$form, &$form_state) {  $message = '';  // $form['#post'] is set only when the form is built for preview/submit.  if (isset($form['#post']['body']) && isset($form_state['values']['teaser_include']) && !$form_state['values']['teaser_include']) {    // "teaser_include" checkbox is present and unchecked.    if (strpos($form_state['values']['body'], '<!--break-->') === 0) {      // Teaser is empty string.      $message = t('You specified that the summary should not be shown when this post is displayed in full view. This setting is ignored when the summary is empty.');    }    elseif (strpos($form_state['values']['body'], '<!--break-->') === FALSE) {      // Teaser delimiter is not present in the body.      $message = t('You specified that the summary should not be shown when this post is displayed in full view. This setting has been ignored since you have not defined a summary for the post. (To define a summary, insert the delimiter "&lt;!--break--&gt;" (without the quotes) in the Body of the post to indicate the end of the summary and the start of the main content.)');    }    if (!empty($message)) {      drupal_set_message($message, 'warning');      // Pass new checkbox value on to preview/submit form processing.      form_set_value($form['teaser_include'], 1, $form_state);      // Pass new checkbox value back onto form for those cases      // in which form is redisplayed.      $form['teaser_include']['#value'] = 1;    }  }  return $form;}/** * Generate a teaser for a node body. * * If the end of the teaser is not indicated using the <!--break--> delimiter * then we generate the teaser automatically, trying to end it at a sensible * place such as the end of a paragraph, a line break, or the end of a * sentence (in that order of preference). * * @param $body *   The content for which a teaser will be generated. * @param $format *   The format of the content. If the content contains PHP code, we do not *   split it up to prevent parse errors. If the line break filter is present *   then we treat newlines embedded in $body as line breaks. * @param $size *   The desired character length of the teaser. If omitted, the default *   value will be used. Ignored if the special delimiter is present *   in $body. * @return *   The generated teaser. */function node_teaser($body, $format = NULL, $size = NULL) {  if (!isset($size)) {    $size = variable_get('teaser_length', 600);  }  // Find where the delimiter is in the body  $delimiter = strpos($body, '<!--break-->');  // If the size is zero, and there is no delimiter, the entire body is the teaser.  if ($size == 0 && $delimiter === FALSE) {    return $body;  }  // If a valid delimiter has been specified, use it to chop off the teaser.  if ($delimiter !== FALSE) {    return substr($body, 0, $delimiter);  }  // We check for the presence of the PHP evaluator filter in the current  // format. If the body contains PHP code, we do not split it up to prevent  // parse errors.  if (isset($format)) {    $filters = filter_list_format($format);    if (isset($filters['php/0']) && strpos($body, '<?') !== FALSE) {      return $body;    }  }  // If we have a short body, the entire body is the teaser.  if (drupal_strlen($body) <= $size) {    return $body;  }  // If the delimiter has not been specified, try to split at paragraph or  // sentence boundaries.  // The teaser may not be longer than maximum length specified. Initial slice.  $teaser = truncate_utf8($body, $size);  // Store the actual length of the UTF8 string -- which might not be the same  // as $size.  $max_rpos = strlen($teaser);  // How much to cut off the end of the teaser so that it doesn't end in the  // middle of a paragraph, sentence, or word.  // Initialize it to maximum in order to find the minimum.  $min_rpos = $max_rpos;  // Store the reverse of the teaser.  We use strpos on the reversed needle and  // haystack for speed and convenience.  $reversed = strrev($teaser);  // Build an array of arrays of break points grouped by preference.  $break_points = array();  // A paragraph near the end of sliced teaser is most preferable.  $break_points[] = array('</p>' => 0);  // If no complete paragraph then treat line breaks as paragraphs.  $line_breaks = array('<br />' => 6, '<br>' => 4);  // Newline only indicates a line break if line break converter  // filter is present.  if (isset($filters['filter/1'])) {    $line_breaks["\n"] = 1;  }  $break_points[] = $line_breaks;  // If the first paragraph is too long, split at the end of a sentence.  $break_points[] = array('. ' => 1, '! ' => 1, '? ' => 1, '' => 0, ' ' => 1);  // Iterate over the groups of break points until a break point is found.  foreach ($break_points as $points) {    // Look for each break point, starting at the end of the teaser.    foreach ($points as $point => $offset) {      // The teaser is already reversed, but the break point isn't.      $rpos = strpos($reversed, strrev($point));      if ($rpos !== FALSE) {        $min_rpos = min($rpos + $offset, $min_rpos);      }    }    // If a break point was found in this group, slice and return the teaser.    if ($min_rpos !== $max_rpos) {      // Don't slice with length 0.  Length must be <0 to slice from RHS.      return ($min_rpos === 0) ? $teaser : substr($teaser, 0, 0 - $min_rpos);    }  }  // If a break point was not found, still return a teaser.  return $teaser;}/** * Builds a list of available node types, and returns all of part of this list * in the specified format. * * @param $op *   The format in which to return the list. When this is set to 'type', *   'module', or 'name', only the specified node type is returned. When set to *   'types' or 'names', all node types are returned. * @param $node *   A node object, array, or string that indicates the node type to return. *   Leave at default value (NULL) to return a list of all node types. * @param $reset *   Whether or not to reset this function's internal cache (defaults to *   FALSE). * * @return *   Either an array of all available node types, or a single node type, in a *   variable format. Returns FALSE if the node type is not found. */function node_get_types($op = 'types', $node = NULL, $reset = FALSE) {  static $_node_types, $_node_names;  if ($reset || !isset($_node_types)) {    list($_node_types, $_node_names) = _node_types_build();  }  if ($node) {    if (is_array($node)) {      $type = $node['type'];    }    elseif (is_object($node)) {      $type = $node->type;    }    elseif (is_string($node)) {      $type = $node;    }    if (!isset($_node_types[$type])) {      return FALSE;    }  }  switch ($op) {    case 'types':      return $_node_types;    case 'type':      return isset($_node_types[$type]) ? $_node_types[$type] : FALSE;    case 'module':      return isset($_node_types[$type]->module) ? $_node_types[$type]->module : FALSE;    case 'names':      return $_node_names;    case 'name':      return isset($_node_names[$type]) ? $_node_names[$type] : FALSE;  }}/** * Resets the database cache of node types, and saves all new or non-modified * module-defined node types to the database. */function node_types_rebuild() {  _node_types_build();  $node_types = node_get_types('types', NULL, TRUE);  foreach ($node_types as $type => $info) {    if (!empty($info->is_new)) {      node_type_save($info);    }    if (!empty($info->disabled)) {      node_type_delete($info->type);    }  }  _node_types_build();}/** * Saves a node type to the database. * * @param $info *   The node type to save, as an object. * * @return *   Status flag indicating outcome of the operation. */function node_type_save($info) {  $is_existing = FALSE;  $existing_type = !empty($info->old_type) ? $info->old_type : $info->type;  $is_existing = db_result(db_query("SELECT COUNT(*) FROM {node_type} WHERE type = '%s'", $existing_type));  if (!isset($info->help)) {    $info->help = '';  }  if (!isset($info->min_word_count)) {    $info->min_word_count = 0;  }  if (!isset($info->body_label)) {    $info->body_label = '';  }  if ($is_existing) {    db_query("UPDATE {node_type} SET type = '%s', name = '%s', module = '%s', has_title = %d, title_label = '%s', has_body = %d, body_label = '%s', description = '%s', help = '%s', min_word_count = %d, custom = %d, modified = %d, locked = %d WHERE type = '%s'", $info->type, $info->name, $info->module, $info->has_title, $info->title_label, $info->has_body, $info->body_label, $info->description, $info->help, $info->min_word_count, $info->custom, $info->modified, $info->locked, $existing_type);    module_invoke_all('node_type', 'update', $info);    return SAVED_UPDATED;  }  else {    db_query("INSERT INTO {node_type} (type, name, module, has_title, title_label, has_body, body_label, description, help, min_word_count, custom, modified, locked, orig_type) VALUES ('%s', '%s', '%s', %d, '%s', %d, '%s', '%s', '%s', %d, %d, %d, %d, '%s')", $info->type, $info->name, $info->module, $info->has_title, $info->title_label, $info->has_body, $info->body_label, $info->description, $info->help, $info->min_word_count, $info->custom, $info->modified, $info->locked, $info->orig_type);    module_invoke_all('node_type', 'insert', $info);    return SAVED_NEW;  }}/** * Deletes a node type from the database. * * @param $type *   The machine-readable name of the node type to be deleted. */function node_type_delete($type) {  $info = node_get_types('type', $type);  db_query("DELETE FROM {node_type} WHERE type = '%s'", $type);  module_invoke_all('node_type', 'delete', $info);}/** * Updates all nodes of one type to be of another type. * * @param $old_type *   The current node type of the nodes. * @param $type *   The new node type of the nodes. * * @return *   The number of nodes whose node type field was modified. */function node_type_update_nodes($old_type, $type) {  db_query("UPDATE {node} SET type = '%s' WHERE type = '%s'", $type, $old_type);  return db_affected_rows();}/** * Builds and returns the list of available node types. * * The list of types is built by querying hook_node_info() in all modules, and * by comparing this information with the node types in the {node_type} table. * */function _node_types_build() {  $_node_types = array();  $_node_names = array();  $info_array = module_invoke_all('node_info');  foreach ($info_array as $type => $info) {    $info['type'] = $type;    $_node_types[$type] = (object) _node_type_set_defaults($info);    $_node_names[$type] = $info['name'];  }  $type_result = db_query(db_rewrite_sql('SELECT nt.type, nt.* FROM {node_type} nt ORDER BY nt.type ASC', 'nt', 'type'));  while ($type_object = db_fetch_object($type_result)) {    // Check for node types from disabled modules and mark their types for removal.    // Types defined by the node module in the database (rather than by a separate    // module using hook_node_info) have a module value of 'node'.    if ($type_object->module != 'node' && empty($info_array[$type_object->type])) {      $type_object->disabled = TRUE;    }    if (!isset($_node_types[$type_object->type]) || $type_object->modified) {      $_node_types[$type_object->type] = $type_object;      $_node_names[$type_object->type] = $type_object->name;      if ($type_object->type != $type_object->orig_type) {        unset($_node_types[$type_object->orig_type]);        unset($_node_names[$type_object->orig_type]);      }    }  }  asort($_node_names);  return array($_node_types, $_node_names);}/** * Set default values for a node type defined through hook_node_info(). */function _node_type_set_defaults($info) {  if (!isset($info['has_title'])) {    $info['has_title'] = TRUE;  }  if ($info['has_title'] && !isset($info['title_label'])) {    $info['title_label'] = t('Title');  }  if (!isset($info['has_body'])) {    $info['has_body'] = TRUE;  }  if ($info['has_body'] && !isset($info['body_label'])) {    $info['body_label'] = t('Body');  }  if (!isset($info['help'])) {    $info['help'] = '';  }  if (!isset($info['min_word_count'])) {    $info['min_word_count'] = 0;  }  if (!isset($info['custom'])) {    $info['custom'] = FALSE;  }  if (!isset($info['modified'])) {    $info['modified'] = FALSE;  }  if (!isset($info['locked'])) {    $info['locked'] = TRUE;  }  $info['orig_type'] = $info['type'];  $info['is_new'] = TRUE;  return $info;}/** * Determine whether a node hook exists. * * @param &$node *   Either a node object, node array, or a string containing the node type. * @param $hook *   A string containing the name of the hook. * @return *   TRUE iff the $hook exists in the node type of $node. */function node_hook(&$node, $hook) {  $module = node_get_types('module', $node);  if ($module == 'node') {    $module = 'node_content'; // Avoid function name collisions.  }  return module_hook($module, $hook);}/** * Invoke a node hook. * * @param &$node *   Either a node object, node array, or a string containing the node type. * @param $hook *   A string containing the name of the hook. * @param $a2, $a3, $a4 *   Arguments to pass on to the hook, after the $node argument. * @return *   The returned value of the invoked hook. */function node_invoke(&$node, $hook, $a2 = NULL, $a3 = NULL, $a4 = NULL) {  if (node_hook($node, $hook)) {    $module = node_get_types('module', $node);    if ($module == 'node') {      $module = 'node_content'; // Avoid function name collisions.    }    $function = $module .'_'. $hook;    return ($function($node, $a2, $a3, $a4));  }}/** * Invoke a hook_nodeapi() operation in all modules. * * @param &$node *   A node object. * @param $op *   A string containing the name of the nodeapi operation. * @param $a3, $a4 *   Arguments to pass on to the hook, after the $node and $op arguments. * @return *   The returned value of the invoked hooks. */function node_invoke_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {  $return = array();  foreach (module_implements('nodeapi') as $name) {    $function = $name .'_nodeapi';    $result = $function($node, $op, $a3, $a4);    if (isset($result) && is_array($result)) {      $return = array_merge($return, $result);    }    else if (isset($result)) {      $return[] = $result;    }  }  return $return;}/** * Load a node object from the database. * * @param $param *   Either the nid of the node or an array of conditions to match against in the database query * @param $revision *   Which numbered revision to load. Defaults to the current version. * @param $reset *   Whether to reset the internal node_load cache. * * @return *   A fully-populated node object. */function node_load($param = array(), $revision = NULL, $reset = NULL) {  static $nodes = array();  if ($reset) {    $nodes = array();  }  $cachable = ($revision == NULL);  $arguments = array();  if (is_numeric($param)) {    if ($cachable) {      // Is the node statically cached?      if (isset($nodes[$param])) {        return is_object($nodes[$param]) ? drupal_clone($nodes[$param]) : $nodes[$param];      }    }    $cond = 'n.nid = %d';    $arguments[] = $param;  }  elseif (is_array($param)) {    // Turn the conditions into a query.    foreach ($param as $key => $value) {      $cond[] = 'n.'. db_escape_table($key) ." = '%s'";      $arguments[] = $value;    }    $cond = implode(' AND ', $cond);  }  else {    return FALSE;  }  // Retrieve a field list based on the site's schema.  $fields = drupal_schema_fields_sql('node', 'n');  $fields = array_merge($fields, drupal_schema_fields_sql('node_revisions', 'r'));  $fields = array_merge($fields, array('u.name', 'u.picture', 'u.data'));  // Remove fields not needed in the query: n.vid and r.nid are redundant,  // n.title is unnecessary because the node title comes from the  // node_revisions table.  We'll keep r.vid, r.title, and n.nid.  $fields = array_diff($fields, array('n.vid', 'n.title', 'r.nid'));  $fields = implode(', ', $fields);  // Rename timestamp field for clarity.  $fields = str_replace('r.timestamp', 'r.timestamp AS revision_timestamp', $fields);  // Change name of revision uid so it doesn't conflict with n.uid.  $fields = str_replace('r.uid', 'r.uid AS revision_uid', $fields);  // Retrieve the node.  // No db_rewrite_sql is applied so as to get complete indexing for search.  if ($revision) {    array_unshift($arguments, $revision);    $node = db_fetch_object(db_query('SELECT '. $fields .' FROM {node} n INNER JOIN {users} u ON u.uid = n.uid INNER JOIN {node_revisions} r ON r.nid = n.nid AND r.vid = %d WHERE '. $cond, $arguments));  }  else {    $node = db_fetch_object(db_query('SELECT '. $fields .' FROM {node} n INNER JOIN {users} u ON u.uid = n.uid INNER JOIN {node_revisions} r ON r.vid = n.vid WHERE '. $cond, $arguments));  }  if ($node && $node->nid) {    // Call the node specific callback (if any) and piggy-back the    // results to the node or overwrite some values.    if ($extra = node_invoke($node, 'load')) {      foreach ($extra as $key => $value) {        $node->$key = $value;      }    }    if ($extra = node_invoke_nodeapi($node, 'load')) {      foreach ($extra as $key => $value) {        $node->$key = $value;      }    }    if ($cachable) {      $nodes[$node->nid] = is_object($node) ? drupal_clone($node) : $node;    }  }  return $node;}/** * Perform validation checks on the given node. */function node_validate($node, $form = array()) {  // Convert the node to an object, if necessary.  $node = (object)$node;  $type = node_get_types('type', $node);  // Make sure the body has the minimum number of words.  // TODO : use a better word counting algorithm that will work in other languages  if (!empty($type->min_word_count) && isset($node->body) && count(explode(' ', $node->body)) < $type->min_word_count) {    form_set_error('body', t('The body of your @type is too short. You need at least %words words.', array('%words' => $type->min_word_count, '@type' => $type->name)));  }  if (isset($node->nid) && (node_last_changed($node->nid) > $node->changed)) {    form_set_error('changed', t('This content has been modified by another user, changes cannot be saved.'));  }  if (user_access('administer nodes')) {    // Validate the "authored by" field.    if (!empty($node->name) && !($account = user_load(array('name' => $node->name)))) {      // The use of empty() is mandatory in the context of usernames      // as the empty string denotes the anonymous user. In case we      // are dealing with an anonymous user we set the user ID to 0.      form_set_error('name', t('The username %name does not exist.', array('%name' => $node->name)));    }    // Validate the "authored on" field. As of PHP 5.1.0, strtotime returns FALSE instead of -1 upon failure.    if (!empty($node->date) && strtotime($node->date) <= 0) {      form_set_error('date', t('You have to specify a valid date.'));    }  }  // Do node-type-specific validation checks.  node_invoke($node, 'validate', $form);  node_invoke_nodeapi($node, 'validate', $form);}/** * Prepare node for save and allow modules to make changes. */function node_submit($node) {  global $user;  // Convert the node to an object, if necessary.  $node = (object)$node;  // Generate the teaser, but only if it hasn't been set (e.g. by a  // module-provided 'teaser' form item).  if (!isset($node->teaser)) {    if (isset($node->body)) {      $node->teaser = node_teaser($node->body, isset($node->format) ? $node->format : NULL);      // Chop off the teaser from the body if needed. The teaser_include      // property might not be set (eg. in Blog API postings), so only act on      // it, if it was set with a given value.      if (isset($node->teaser_include) && !$node->teaser_include && $node->teaser == substr($node->body, 0, strlen($node->teaser))) {        $node->body = substr($node->body, strlen($node->teaser));      }    }    else {      $node->teaser = '';      $node->format = 0;    }  }  if (user_access('administer nodes')) {    // Populate the "authored by" field.    if ($account = user_load(array('name' => $node->name))) {      $node->uid = $account->uid;    }    else {      $node->uid = 0;    }  }  $node->created = !empty($node->date) ? strtotime($node->date) : time();  $node->validated = TRUE;  return $node;}/** * Save a node object into the database. */function node_save(&$node) {  // Let modules modify the node before it is saved to the database.  node_invoke_nodeapi($node, 'presave');  global $user;  // Insert a new node.  $node->is_new = empty($node->nid);  if ($node->is_new || !empty($node->revision)) {    // When inserting a node, $node->log must be set because    // {node_revisions}.log does not (and cannot) have a default    // value.  If the user does not have permission to create    // revisions, however, the form will not contain an element for    // log so $node->log will be unset at this point.    if (!isset($node->log)) {      $node->log = '';    }  }  elseif (empty($node->log)) {    // When updating a node, however, avoid clobbering an existing    // log entry with an empty one.    unset($node->log);  }  // For the same reasons, make sure we have $node->teaser and  // $node->body set.  if (!isset($node->teaser)) {    $node->teaser = '';  }  if (!isset($node->body)) {    $node->body = '';  }  // Save the old revision if needed.  if (!$node->is_new && !empty($node->revision) && $node->vid) {    $node->old_vid = $node->vid;  }  $time = time();  if (empty($node->created)) {    $node->created = $time;  }  // The changed timestamp is always updated for bookkeeping purposes (revisions, searching, ...)  $node->changed = $time;  $node->timestamp = $time;  $node->format = isset($node->format) ? $node->format : FILTER_FORMAT_DEFAULT;  // Generate the node table query and the node_revisions table query.  if ($node->is_new) {    _node_save_revision($node, $user->uid);    drupal_write_record('node', $node);    db_query('UPDATE {node_revisions} SET nid = %d WHERE vid = %d', $node->nid, $node->vid);    $op = 'insert';  }  else {    drupal_write_record('node', $node, 'nid');    if (!empty($node->revision)) {      _node_save_revision($node, $user->uid);      db_query('UPDATE {node} SET vid = %d WHERE nid = %d', $node->vid, $node->nid);    }    else {      _node_save_revision($node, $user->uid, 'vid');    }    $op = 'update';  }  // Call the node specific callback (if any).  node_invoke($node, $op);  node_invoke_nodeapi($node, $op);  // Update the node access table for this node.  node_access_acquire_grants($node);  // Clear the page and block caches.  cache_clear_all();}/** * Helper function to save a revision with the uid of the current user. * * Node is taken by reference, becuse drupal_write_record() updates the * $node with the revision id, and we need to pass that back to the caller. */function _node_save_revision(&$node, $uid, $update = NULL) {  $temp_uid = $node->uid;  $node->uid = $uid;  if (isset($update)) {    drupal_write_record('node_revisions', $node, $update);  }  else {    drupal_write_record('node_revisions', $node);  }  $node->uid = $temp_uid;}/** * Delete a node. */function node_delete($nid) {  // Clear the cache before the load, so if multiple nodes are deleted, the  // memory will not fill up with nodes (possibly) already removed.  $node = node_load($nid, NULL, TRUE);  if (node_access('delete', $node)) {    db_query('DELETE FROM {node} WHERE nid = %d', $node->nid);    db_query('DELETE FROM {node_revisions} WHERE nid = %d', $node->nid);    // Call the node-specific callback (if any):    node_invoke($node, 'delete');    node_invoke_nodeapi($node, 'delete');    // Clear the page and block caches.    cache_clear_all();    // Remove this node from the search index if needed.    if (function_exists('search_wipe')) {      search_wipe($node->nid, 'node');    }    watchdog('content', '@type: deleted %title.', array('@type' => $node->type, '%title' => $node->title));    drupal_set_message(t('@type %title has been deleted.', array('@type' => node_get_types('name', $node), '%title' => $node->title)));  }}/** * Generate a display of the given node. * * @param $node *   A node array or node object. * @param $teaser *   Whether to display the teaser only or the full form. * @param $page *   Whether the node is being displayed by itself as a page. * @param $links *   Whether or not to display node links. Links are omitted for node previews. * * @return *   An HTML representation of the themed node. */function node_view($node, $teaser = FALSE, $page = FALSE, $links = TRUE) {  $node = (object)$node;  $node = node_build_content($node, $teaser, $page);  if ($links) {    $node->links = module_invoke_all('link', 'node', $node, $teaser);    drupal_alter('link', $node->links, $node);  }  // Set the proper node part, then unset unused $node part so that a bad  // theme can not open a security hole.  $content = drupal_render($node->content);  if ($teaser) {    $node->teaser = $content;    unset($node->body);  }  else {    $node->body = $content;    unset($node->teaser);  }  // Allow modules to modify the fully-built node.  node_invoke_nodeapi($node, 'alter', $teaser, $page);  return theme('node', $node, $teaser, $page);}/** * Apply filters and build the node's standard elements. */function node_prepare($node, $teaser = FALSE) {  // First we'll overwrite the existing node teaser and body with  // the filtered copies! Then, we'll stick those into the content  // array and set the read more flag if appropriate.  $node->readmore = $node->teaser != $node->body;  if ($teaser == FALSE) {    $node->body = check_markup($node->body, $node->format, FALSE);  }  else {    $node->teaser = check_markup($node->teaser, $node->format, FALSE);  }  $node->content['body'] = array(    '#value' => $teaser ? $node->teaser : $node->body,    '#weight' => 0,  );  return $node;}/** * Builds a structured array representing the node's content. * * @param $node *   A node object. * @param $teaser *   Whether to display the teaser only, as on the main page. * @param $page *   Whether the node is being displayed by itself as a page. * * @return *   An structured array containing the individual elements *   of the node's body. */function node_build_content($node, $teaser = FALSE, $page = FALSE) {  // The build mode identifies the target for which the node is built.  if (!isset($node->build_mode)) {    $node->build_mode = NODE_BUILD_NORMAL;  }  // Remove the delimiter (if any) that separates the teaser from the body.  $node->body = isset($node->body) ? str_replace('<!--break-->', '', $node->body) : '';  // The 'view' hook can be implemented to overwrite the default function  // to display nodes.  if (node_hook($node, 'view')) {    $node = node_invoke($node, 'view', $teaser, $page);  }  else {    $node = node_prepare($node, $teaser);  }  // Allow modules to make their own additions to the node.  node_invoke_nodeapi($node, 'view', $teaser, $page);  return $node;}/** * Generate a page displaying a single node, along with its comments. */function node_show($node, $cid, $message = FALSE) {  if ($message) {    drupal_set_title(t('Revision of %title from %date', array('%title' => $node->title, '%date' => format_date($node->revision_timestamp))));  }  $output = node_view($node, FALSE, TRUE);  if (function_exists('comment_render') && $node->comment) {    $output .= comment_render($node, $cid);  }  // Update the history table, stating that this user viewed this node.  node_tag_new($node->nid);  return $output;}/** * Theme a log message. * * @ingroup themeable */function theme_node_log_message($log) {  return '<div class="log"><div class="title">'. t('Log') .':</div>'. $log .'</div>';}/** * Implementation of hook_perm(). */function node_perm() {  $perms = array('administer content types', 'administer nodes', 'access content', 'view revisions', 'revert revisions', 'delete revisions');  foreach (node_get_types() as $type) {    if ($type->module == 'node') {      $name = check_plain($type->type);      $perms[] = 'create '. $name .' content';      $perms[] = 'delete own '. $name .' content';      $perms[] = 'delete any '. $name .' content';      $perms[] = 'edit own '. $name .' content';      $perms[] = 'edit any '. $name .' content';    }  }  return $perms;}/** * Implementation of hook_search(). */function node_search($op = 'search', $keys = NULL) {  switch ($op) {    case 'name':      return t('Content');    case 'reset':      db_query("UPDATE {search_dataset} SET reindex = %d WHERE type = 'node'", time());      return;    case 'status':      $total = db_result(db_query('SELECT COUNT(*) FROM {node} WHERE status = 1'));      $remaining = db_result(db_query("SELECT COUNT(*) FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE n.status = 1 AND (d.sid IS NULL OR d.reindex <> 0)"));      return array('remaining' => $remaining, 'total' => $total);    case 'admin':      $form = array();      // Output form for defining rank factor weights.      $form['content_ranking'] = array(        '#type' => 'fieldset',        '#title' => t('Content ranking'),      );      $form['content_ranking']['#theme'] = 'node_search_admin';      $form['content_ranking']['info'] = array(        '#value' => '<em>'. t('The following numbers control which properties the content search should favor when ordering the results. Higher numbers mean more influence, zero means the property is ignored. Changing these numbers does not require the search index to be rebuilt. Changes take effect immediately.') .'</em>'      );      $ranking = array('node_rank_relevance' => t('Keyword relevance'),                       'node_rank_recent' => t('Recently posted'));      if (module_exists('comment')) {        $ranking['node_rank_comments'] = t('Number of comments');      }      if (module_exists('statistics') && variable_get('statistics_count_content_views', 0)) {        $ranking['node_rank_views'] = t('Number of views');      }      // Note: reversed to reflect that higher number = higher ranking.      $options = drupal_map_assoc(range(0, 10));      foreach ($ranking as $var => $title) {        $form['content_ranking']['factors'][$var] = array(          '#title' => $title,          '#type' => 'select',          '#options' => $options,          '#default_value' => variable_get($var, 5),        );      }      return $form;    case 'search':      // Build matching conditions      list($join1, $where1) = _db_rewrite_sql();      $arguments1 = array();      $conditions1 = 'n.status = 1';      if ($type = search_query_extract($keys, 'type')) {        $types = array();        foreach (explode(',', $type) as $t) {          $types[] = "n.type = '%s'";          $arguments1[] = $t;        }        $conditions1 .= ' AND ('. implode(' OR ', $types) .')';        $keys = search_query_insert($keys, 'type');      }      if ($category = search_query_extract($keys, 'category')) {        $categories = array();        foreach (explode(',', $category) as $c) {          $categories[] = "tn.tid = %d";          $arguments1[] = $c;        }        $conditions1 .= ' AND ('. implode(' OR ', $categories) .')';        $join1 .= ' INNER JOIN {term_node} tn ON n.vid = tn.vid';        $keys = search_query_insert($keys, 'category');      }      // Build ranking expression (we try to map each parameter to a      // uniform distribution in the range 0..1).      $ranking = array();      $arguments2 = array();      $join2 = '';      // Used to avoid joining on node_comment_statistics twice      $stats_join = FALSE;      $total = 0;      if ($weight = (int)variable_get('node_rank_relevance', 5)) {        // Average relevance values hover around 0.15        $ranking[] = '%d * i.relevance';        $arguments2[] = $weight;        $total += $weight;      }      if ($weight = (int)variable_get('node_rank_recent', 5)) {        // Exponential decay with half-life of 6 months, starting at last indexed node        $ranking[] = '%d * POW(2, (GREATEST(MAX(n.created), MAX(n.changed), MAX(c.last_comment_timestamp)) - %d) * 6.43e-8)';        $arguments2[] = $weight;        $arguments2[] = (int)variable_get('node_cron_last', 0);        $join2 .= ' LEFT JOIN {node_comment_statistics} c ON c.nid = i.sid';        $stats_join = TRUE;        $total += $weight;      }      if (module_exists('comment') && $weight = (int)variable_get('node_rank_comments', 5)) {        // Inverse law that maps the highest reply count on the site to 1 and 0 to 0.        $scale = variable_get('node_cron_comments_scale', 0.0);        $ranking[] = '%d * (2.0 - 2.0 / (1.0 + MAX(c.comment_count) * %f))';        $arguments2[] = $weight;        $arguments2[] = $scale;        if (!$stats_join) {          $join2 .= ' LEFT JOIN {node_comment_statistics} c ON c.nid = i.sid';        }        $total += $weight;      }      if (module_exists('statistics') && variable_get('statistics_count_content_views', 0) &&          $weight = (int)variable_get('node_rank_views', 5)) {        // Inverse law that maps the highest view count on the site to 1 and 0 to 0.        $scale = variable_get('node_cron_views_scale', 0.0);        $ranking[] = '%d * (2.0 - 2.0 / (1.0 + MAX(nc.totalcount) * %f))';        $arguments2[] = $weight;        $arguments2[] = $scale;        $join2 .= ' LEFT JOIN {node_counter} nc ON nc.nid = i.sid';        $total += $weight;      }            // When all search factors are disabled (ie they have a weight of zero),       // the default score is based only on keyword relevance and there is no need to       // adjust the score of each item.       if ($total == 0) {        $select2 = 'i.relevance AS score';        $total = 1;      }      else {        $select2 = implode(' + ', $ranking) . ' AS score';      }            // Do search.      $find = do_search($keys, 'node', 'INNER JOIN {node} n ON n.nid = i.sid '. $join1, $conditions1 . (empty($where1) ? '' : ' AND '. $where1), $arguments1, $select2, $join2, $arguments2);      // Load results.      $results = array();      foreach ($find as $item) {        // Build the node body.        $node = node_load($item->sid);        $node->build_mode = NODE_BUILD_SEARCH_RESULT;        $node = node_build_content($node, FALSE, FALSE);        $node->body = drupal_render($node->content);        // Fetch comments for snippet.        $node->body .= module_invoke('comment', 'nodeapi', $node, 'update index');        // Fetch terms for snippet.        $node->body .= module_invoke('taxonomy', 'nodeapi', $node, 'update index');        $extra = node_invoke_nodeapi($node, 'search result');        $results[] = array(          'link' => url('node/'. $item->sid, array('absolute' => TRUE)),          'type' => check_plain(node_get_types('name', $node)),          'title' => $node->title,          'user' => theme('username', $node),          'date' => $node->changed,          'node' => $node,          'extra' => $extra,          'score' => $item->score / $total,          'snippet' => search_excerpt($keys, $node->body),        );      }      return $results;  }}/** * Implementation of hook_user(). */function node_user($op, &$edit, &$user) {  if ($op == 'delete') {    db_query('UPDATE {node} SET uid = 0 WHERE uid = %d', $user->uid);    db_query('UPDATE {node_revisions} SET uid = 0 WHERE uid = %d', $user->uid);  }}/** * Theme the content ranking part of the search settings admin page. * * @ingroup themeable */function theme_node_search_admin($form) {  $output = drupal_render($form['info']);  $header = array(t('Factor'), t('Weight'));  foreach (element_children($form['factors']) as $key) {    $row = array();    $row[] = $form['factors'][$key]['#title'];    unset($form['factors'][$key]['#title']);    $row[] = drupal_render($form['factors'][$key]);    $rows[] = $row;  }  $output .= theme('table', $header, $rows);  $output .= drupal_render($form);  return $output;}/** * Retrieve the comment mode for the given node ID (none, read, or read/write). */function node_comment_mode($nid) {  static $comment_mode;  if (!isset($comment_mode[$nid])) {    $comment_mode[$nid] = db_result(db_query('SELECT comment FROM {node} WHERE nid = %d', $nid));  }  return $comment_mode[$nid];}/** * Implementation of hook_link(). */function node_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node') {    if ($teaser == 1 && $node->teaser && !empty($node->readmore)) {      $links['node_read_more'] = array(        'title' => t('Read more'),        'href' => "node/$node->nid",        // The title attribute gets escaped when the links are processed, so        // there is no need to escape here.        'attributes' => array('title' => t('Read the rest of !title.', array('!title' => $node->title)))      );    }  }  return $links;}function _node_revision_access($node, $op = 'view') {  static $access = array();  if (!isset($access[$node->vid])) {    $node_current_revision = node_load($node->nid);    $is_current_revision = $node_current_revision->vid == $node->vid;    // There should be at least two revisions. If the vid of the given node    // and the vid of the current revision differs, then we already have two    // different revisions so there is no need for a separate database check.    // Also, if you try to revert to or delete the current revision, that's    // not good.    if ($is_current_revision && (db_result(db_query('SELECT COUNT(vid) FROM {node_revisions} WHERE nid = %d', $node->nid)) == 1 || $op == 'update' || $op == 'delete')) {      $access[$node->vid] = FALSE;    }    elseif (user_access('administer nodes')) {      $access[$node->vid] = TRUE;    }    else {      $map = array('view' => 'view revisions', 'update' => 'revert revisions', 'delete' => 'delete revisions');      // First check the user permission, second check the access to the      // current revision and finally, if the node passed in is not the current      // revision then access to that, too.      $access[$node->vid] = isset($map[$op]) && user_access($map[$op]) && node_access($op, $node_current_revision) && ($is_current_revision || node_access($op, $node));    }  }  return $access[$node->vid];}function _node_add_access() {  $types = node_get_types();  foreach ($types as $type) {    if (node_hook($type->type, 'form') && node_access('create', $type->type)) {      return TRUE;    }  }  return FALSE;}/** * Implementation of hook_menu(). */function node_menu() {  $items['admin/content/node'] = array(    'title' => 'Content',    'description' => "View, edit, and delete your site's content.",    'page callback' => 'drupal_get_form',    'page arguments' => array('node_admin_content'),    'access arguments' => array('administer nodes'),    'file' => 'node.admin.inc',  );  $items['admin/content/node/overview'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/node-settings'] = array(    'title' => 'Post settings',    'description' => 'Control posting behavior, such as teaser length, requiring previews before posting, and the number of posts on the front page.',    'page callback' => 'drupal_get_form',    'page arguments' => array('node_configure'),    'access arguments' => array('administer nodes'),    'file' => 'node.admin.inc',  );  $items['admin/content/node-settings/rebuild'] = array(    'title' => 'Rebuild permissions',    'page arguments' => array('node_configure_rebuild_confirm'),    'file' => 'node.admin.inc',    // Any user than can potentially trigger a node_acess_needs_rebuild(TRUE)    // has to be allowed access to the 'node access rebuild' confirm form.    'access arguments' => array('access administration pages'),    'type' => MENU_CALLBACK,  );  $items['admin/content/types'] = array(    'title' => 'Content types',    'description' => 'Manage posts by content type, including default status, front page promotion, etc.',    'page callback' => 'node_overview_types',    'access arguments' => array('administer content types'),    'file' => 'content_types.inc',  );  $items['admin/content/types/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/types/add'] = array(    'title' => 'Add content type',    'page callback' => 'drupal_get_form',    'page arguments' => array('node_type_form'),    'access arguments' => array('administer content types'),    'file' => 'content_types.inc',    'type' => MENU_LOCAL_TASK,  );  $items['node'] = array(    'title' => 'Content',    'page callback' => 'node_page_default',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,  );  $items['node/add'] = array(    'title' => 'Create content',    'page callback' => 'node_add_page',    'access callback' => '_node_add_access',    'weight' => 1,    'file' => 'node.pages.inc',  );  $items['rss.xml'] = array(    'title' => 'RSS feed',    'page callback' => 'node_feed',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,  );  foreach (node_get_types('types', NULL, TRUE) as $type) {    $type_url_str = str_replace('_', '-', $type->type);    $items['node/add/'. $type_url_str] = array(      'title' => drupal_ucfirst($type->name),      'title callback' => 'check_plain',      'page callback' => 'node_add',      'page arguments' => array(2),      'access callback' => 'node_access',      'access arguments' => array('create', $type->type),      'description' => $type->description,      'file' => 'node.pages.inc',    );    $items['admin/content/node-type/'. $type_url_str] = array(      'title' => $type->name,      'page callback' => 'drupal_get_form',      'page arguments' => array('node_type_form', $type),      'access arguments' => array('administer content types'),      'file' => 'content_types.inc',      'type' => MENU_CALLBACK,    );    $items['admin/content/node-type/'. $type_url_str .'/edit'] = array(      'title' => 'Edit',      'type' => MENU_DEFAULT_LOCAL_TASK,    );    $items['admin/content/node-type/'. $type_url_str .'/delete'] = array(      'title' => 'Delete',      'page arguments' => array('node_type_delete_confirm', $type),      'access arguments' => array('administer content types'),      'file' => 'content_types.inc',      'type' => MENU_CALLBACK,    );  }  $items['node/%node'] = array(    'title callback' => 'node_page_title',    'title arguments' => array(1),    'page callback' => 'node_page_view',    'page arguments' => array(1),    'access callback' => 'node_access',    'access arguments' => array('view', 1),    'type' => MENU_CALLBACK);  $items['node/%node/view'] = array(    'title' => 'View',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10);  $items['node/%node/edit'] = array(    'title' => 'Edit',    'page callback' => 'node_page_edit',    'page arguments' => array(1),    'access callback' => 'node_access',    'access arguments' => array('update', 1),    'weight' => 1,    'file' => 'node.pages.inc',    'type' => MENU_LOCAL_TASK,  );  $items['node/%node/delete'] = array(    'title' => 'Delete',    'page callback' => 'drupal_get_form',    'page arguments' => array('node_delete_confirm', 1),    'access callback' => 'node_access',    'access arguments' => array('delete', 1),    'file' => 'node.pages.inc',    'weight' => 1,    'type' => MENU_CALLBACK);  $items['node/%node/revisions'] = array(    'title' => 'Revisions',    'page callback' => 'node_revision_overview',    'page arguments' => array(1),    'access callback' => '_node_revision_access',    'access arguments' => array(1),    'weight' => 2,    'file' => 'node.pages.inc',    'type' => MENU_LOCAL_TASK,  );  $items['node/%node/revisions/%/view'] = array(    'title' => 'Revisions',    'load arguments' => array(3),    'page callback' => 'node_show',    'page arguments' => array(1, NULL, TRUE),    'access callback' => '_node_revision_access',    'access arguments' => array(1),    'type' => MENU_CALLBACK,  );  $items['node/%node/revisions/%/revert'] = array(    'title' => 'Revert to earlier revision',    'load arguments' => array(3),    'page callback' => 'drupal_get_form',    'page arguments' => array('node_revision_revert_confirm', 1),    'access callback' => '_node_revision_access',    'access arguments' => array(1, 'update'),    'file' => 'node.pages.inc',    'type' => MENU_CALLBACK,  );  $items['node/%node/revisions/%/delete'] = array(    'title' => 'Delete earlier revision',    'load arguments' => array(3),    'page callback' => 'drupal_get_form',    'page arguments' => array('node_revision_delete_confirm', 1),    'access callback' => '_node_revision_access',    'access arguments' => array(1, 'delete'),    'file' => 'node.pages.inc',    'type' => MENU_CALLBACK,  );  return $items;}/** * Title callback. */function node_page_title($node) {  return $node->title;}/** * Implementation of hook_init(). */function node_init() {  drupal_add_css(drupal_get_path('module', 'node') .'/node.css');}function node_last_changed($nid) {  $node = db_fetch_object(db_query('SELECT changed FROM {node} WHERE nid = %d', $nid));  return ($node->changed);}/** * Return a list of all the existing revision numbers. */function node_revision_list($node) {  $revisions = array();  $result = db_query('SELECT r.vid, r.title, r.log, r.uid, n.vid AS current_vid, r.timestamp, u.name FROM {node_revisions} r LEFT JOIN {node} n ON n.vid = r.vid INNER JOIN {users} u ON u.uid = r.uid WHERE r.nid = %d ORDER BY r.timestamp DESC', $node->nid);  while ($revision = db_fetch_object($result)) {    $revisions[$revision->vid] = $revision;  }  return $revisions;}/** * Implementation of hook_block(). */function node_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Syndicate');    // Not worth caching.    $blocks[0]['cache'] = BLOCK_NO_CACHE;    return $blocks;  }  else if ($op == 'view') {    $block['subject'] = t('Syndicate');    $block['content'] = theme('feed_icon', url('rss.xml'), t('Syndicate'));    return $block;  }}/** * A generic function for generating RSS feeds from a set of nodes. * * @param $nids *   An array of node IDs (nid). Defaults to FALSE so empty feeds can be *   generated with passing an empty array, if no items are to be added *   to the feed. * @param $channel *   An associative array containing title, link, description and other keys. *   The link should be an absolute URL. */function node_feed($nids = FALSE, $channel = array()) {  global $base_url, $language;  if ($nids === FALSE) {    $nids = array();    $result = db_query_range(db_rewrite_sql('SELECT n.nid, n.created FROM {node} n WHERE n.promote = 1 AND n.status = 1 ORDER BY n.created DESC'), 0, variable_get('feed_default_items', 10));    while ($row = db_fetch_object($result)) {      $nids[] = $row->nid;    }  }  $item_length = variable_get('feed_item_length', 'teaser');  $namespaces = array('xmlns:dc' => 'http://purl.org/dc/elements/1.1/');  $items = '';  foreach ($nids as $nid) {    // Load the specified node:    $item = node_load($nid);    $item->build_mode = NODE_BUILD_RSS;    $item->link = url("node/$nid", array('absolute' => TRUE));    if ($item_length != 'title') {      $teaser = ($item_length == 'teaser') ? TRUE : FALSE;      // Filter and prepare node teaser      if (node_hook($item, 'view')) {        $item = node_invoke($item, 'view', $teaser, FALSE);      }      else {        $item = node_prepare($item, $teaser);      }      // Allow modules to change $node->content before the node is rendered.      node_invoke_nodeapi($item, 'view', $teaser, FALSE);      // Set the proper node property, then unset unused $node property so that a      // bad theme can not open a security hole.      $content = drupal_render($item->content);      if ($teaser) {        $item->teaser = $content;        unset($item->body);      }      else {        $item->body = $content;        unset($item->teaser);      }          // Allow modules to modify the fully-built node.      node_invoke_nodeapi($item, 'alter', $teaser, FALSE);    }    // Allow modules to add additional item fields and/or modify $item    $extra = node_invoke_nodeapi($item, 'rss item');    $extra = array_merge($extra, array(array('key' => 'pubDate', 'value' => gmdate('r', $item->created)), array('key' => 'dc:creator', 'value' => $item->name), array('key' => 'guid', 'value' => $item->nid .' at '. $base_url, 'attributes' => array('isPermaLink' => 'false'))));    foreach ($extra as $element) {      if (isset($element['namespace'])) {        $namespaces = array_merge($namespaces, $element['namespace']);      }    }    // Prepare the item description    switch ($item_length) {      case 'fulltext':        $item_text = $item->body;        break;      case 'teaser':        $item_text = $item->teaser;        if (!empty($item->readmore)) {          $item_text .= '<p>'. l(t('read more'), 'node/'. $item->nid, array('absolute' => TRUE, 'attributes' => array('target' => '_blank'))) .'</p>';        }        break;      case 'title':        $item_text = '';        break;    }    $items .= format_rss_item($item->title, $item->link, $item_text, $extra);  }  $channel_defaults = array(    'version'     => '2.0',    'title'       => variable_get('site_name', 'Drupal'),    'link'        => $base_url,    'description' => variable_get('site_mission', ''),    'language'    => $language->language  );  $channel = array_merge($channel_defaults, $channel);  $output = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";  $output .= "<rss version=\"". $channel["version"] ."\" xml:base=\"". $base_url ."\" ". drupal_attributes($namespaces) .">\n";  $output .= format_rss_channel($channel['title'], $channel['link'], $channel['description'], $items, $channel['language']);  $output .= "</rss>\n";  drupal_set_header('Content-Type: application/rss+xml; charset=utf-8');  print $output;}/** * Menu callback; Generate a listing of promoted nodes. */function node_page_default() {  $result = pager_query(db_rewrite_sql('SELECT n.nid, n.sticky, n.created FROM {node} n WHERE n.promote = 1 AND n.status = 1 ORDER BY n.sticky DESC, n.created DESC'), variable_get('default_nodes_main', 10));  $output = '';  $num_rows = FALSE;  while ($node = db_fetch_object($result)) {    $output .= node_view(node_load($node->nid), 1);    $num_rows = TRUE;  }  if ($num_rows) {    $feed_url = url('rss.xml', array('absolute' => TRUE));    drupal_add_feed($feed_url, variable_get('site_name', 'Drupal') .' '. t('RSS'));    $output .= theme('pager', NULL, variable_get('default_nodes_main', 10));  }  else {    $default_message = t('<h1 class="title">Welcome to your new Drupal website!</h1><p>Please follow these steps to set up and start using your website:</p>');    $default_message .= '<ol>';    $default_message .= '<li>'. t('<strong>Configure your website</strong> Once logged in, visit the <a href="@admin">administration section</a>, where you can <a href="@config">customize and configure</a> all aspects of your website.', array('@admin' => url('admin'), '@config' => url('admin/settings'))) .'</li>';    $default_message .= '<li>'. t('<strong>Enable additional functionality</strong> Next, visit the <a href="@modules">module list</a> and enable features which suit your specific needs. You can find additional modules in the <a href="@download_modules">Drupal modules download section</a>.', array('@modules' => url('admin/build/modules'), '@download_modules' => 'http://drupal.org/project/modules')) .'</li>';    $default_message .= '<li>'. t('<strong>Customize your website design</strong> To change the "look and feel" of your website, visit the <a href="@themes">themes section</a>. You may choose from one of the included themes or download additional themes from the <a href="@download_themes">Drupal themes download section</a>.', array('@themes' => url('admin/build/themes'), '@download_themes' => 'http://drupal.org/project/themes')) .'</li>';    $default_message .= '<li>'. t('<strong>Start posting content</strong> Finally, you can <a href="@content">create content</a> for your website. This message will disappear once you have promoted a post to the front page.', array('@content' => url('node/add'))) .'</li>';    $default_message .= '</ol>';    $default_message .= '<p>'. t('For more information, please refer to the <a href="@help">help section</a>, or the <a href="@handbook">online Drupal handbooks</a>. You may also post at the <a href="@forum">Drupal forum</a>, or view the wide range of <a href="@support">other support options</a> available.', array('@help' => url('admin/help'), '@handbook' => 'http://drupal.org/handbooks', '@forum' => 'http://drupal.org/forum', '@support' => 'http://drupal.org/support')) .'</p>';    $output = '<div id="first-time">'. $default_message .'</div>';  }  drupal_set_title('');  return $output;}/** * Menu callback; view a single node. */function node_page_view($node, $cid = NULL) {  drupal_set_title(check_plain($node->title));  return node_show($node, $cid);}/** * Implementation of hook_update_index(). */function node_update_index() {  $limit = (int)variable_get('search_cron_limit', 100);  // Store the maximum possible comments per thread (used for ranking by reply count)  variable_set('node_cron_comments_scale', 1.0 / max(1, db_result(db_query('SELECT MAX(comment_count) FROM {node_comment_statistics}'))));  variable_set('node_cron_views_scale', 1.0 / max(1, db_result(db_query('SELECT MAX(totalcount) FROM {node_counter}'))));  $result = db_query_range("SELECT n.nid FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE d.sid IS NULL OR d.reindex <> 0 ORDER BY d.reindex ASC, n.nid ASC", 0, $limit);  while ($node = db_fetch_object($result)) {    _node_index_node($node);  }}/** * Index a single node. * * @param $node *   The node to index. */function _node_index_node($node) {  $node = node_load($node->nid);  // save the changed time of the most recent indexed node, for the search results half-life calculation  variable_set('node_cron_last', $node->changed);  // Build the node body.  $node->build_mode = NODE_BUILD_SEARCH_INDEX;  $node = node_build_content($node, FALSE, FALSE);  $node->body = drupal_render($node->content);  $text = '<h1>'. check_plain($node->title) .'</h1>'. $node->body;  // Fetch extra data normally not visible  $extra = node_invoke_nodeapi($node, 'update index');  foreach ($extra as $t) {    $text .= $t;  }  // Update index  search_index($node->nid, 'node', $text);}/** * Implementation of hook_form_alter(). */function node_form_alter(&$form, $form_state, $form_id) {  // Advanced node search form  if ($form_id == 'search_form' && $form['module']['#value'] == 'node' && user_access('use advanced search')) {    // Keyword boxes:    $form['advanced'] = array(      '#type' => 'fieldset',      '#title' => t('Advanced search'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#attributes' => array('class' => 'search-advanced'),    );    $form['advanced']['keywords'] = array(      '#prefix' => '<div class="criterion">',      '#suffix' => '</div>',    );    $form['advanced']['keywords']['or'] = array(      '#type' => 'textfield',      '#title' => t('Containing any of the words'),      '#size' => 30,      '#maxlength' => 255,    );    $form['advanced']['keywords']['phrase'] = array(      '#type' => 'textfield',      '#title' => t('Containing the phrase'),      '#size' => 30,      '#maxlength' => 255,    );    $form['advanced']['keywords']['negative'] = array(      '#type' => 'textfield',      '#title' => t('Containing none of the words'),      '#size' => 30,      '#maxlength' => 255,    );    // Taxonomy box:    if ($taxonomy = module_invoke('taxonomy', 'form_all', 1)) {      $form['advanced']['category'] = array(        '#type' => 'select',        '#title' => t('Only in the category(s)'),        '#prefix' => '<div class="criterion">',        '#size' => 10,        '#suffix' => '</div>',        '#options' => $taxonomy,        '#multiple' => TRUE,      );    }    // Node types:    $types = array_map('check_plain', node_get_types('names'));    $form['advanced']['type'] = array(      '#type' => 'checkboxes',      '#title' => t('Only of the type(s)'),      '#prefix' => '<div class="criterion">',      '#suffix' => '</div>',      '#options' => $types,    );    $form['advanced']['submit'] = array(      '#type' => 'submit',      '#value' => t('Advanced search'),      '#prefix' => '<div class="action">',      '#suffix' => '</div>',    );    $form['#validate'][] = 'node_search_validate';  }}/** * Form API callback for the search form. Registered in node_form_alter(). */function node_search_validate($form, &$form_state) {  // Initialise using any existing basic search keywords.  $keys = $form_state['values']['processed_keys'];  // Insert extra restrictions into the search keywords string.  if (isset($form_state['values']['type']) && is_array($form_state['values']['type'])) {    // Retrieve selected types - Forms API sets the value of unselected checkboxes to 0.    $form_state['values']['type'] = array_filter($form_state['values']['type']);    if (count($form_state['values']['type'])) {      $keys = search_query_insert($keys, 'type', implode(',', array_keys($form_state['values']['type'])));    }  }  if (isset($form_state['values']['category']) && is_array($form_state['values']['category'])) {    $keys = search_query_insert($keys, 'category', implode(',', $form_state['values']['category']));  }  if ($form_state['values']['or'] != '') {    if (preg_match_all('/ ("[^"]+"|[^" ]+)/i', ' '. $form_state['values']['or'], $matches)) {      $keys .= ' '. implode(' OR ', $matches[1]);    }  }  if ($form_state['values']['negative'] != '') {    if (preg_match_all('/ ("[^"]+"|[^" ]+)/i', ' '. $form_state['values']['negative'], $matches)) {      $keys .= ' -'. implode(' -', $matches[1]);    }  }  if ($form_state['values']['phrase'] != '') {    $keys .= ' "'. str_replace('"', ' ', $form_state['values']['phrase']) .'"';  }  if (!empty($keys)) {    form_set_value($form['basic']['inline']['processed_keys'], trim($keys), $form_state);  }}/** * @defgroup node_access Node access rights * @{ * The node access system determines who can do what to which nodes. * * In determining access rights for a node, node_access() first checks * whether the user has the "administer nodes" permission. Such users have * unrestricted access to all nodes. Then the node module's hook_access() * is called, and a TRUE or FALSE return value will grant or deny access. * This allows, for example, the blog module to always grant access to the * blog author, and for the book module to always deny editing access to * PHP pages. * * If node module does not intervene (returns NULL), then the * node_access table is used to determine access. All node access * modules are queried using hook_node_grants() to assemble a list of * "grant IDs" for the user. This list is compared against the table. * If any row contains the node ID in question (or 0, which stands for "all * nodes"), one of the grant IDs returned, and a value of TRUE for the * operation in question, then access is granted. Note that this table is a * list of grants; any matching row is sufficient to grant access to the * node. * * In node listings, the process above is followed except that * hook_access() is not called on each node for performance reasons and for * proper functioning of the pager system. When adding a node listing to your * module, be sure to use db_rewrite_sql() to add * the appropriate clauses to your query for access checks. * * To see how to write a node access module of your own, see * node_access_example.module. *//** * Determine whether the current user may perform the given operation on the * specified node. * * @param $op *   The operation to be performed on the node. Possible values are: *   - "view" *   - "update" *   - "delete" *   - "create" * @param $node *   The node object (or node array) on which the operation is to be performed, *   or node type (e.g. 'forum') for "create" operation. * @param $account *   Optional, a user object representing the user for whom the operation is to *   be performed. Determines access for a user other than the current user. * @return *   TRUE if the operation may be performed, or FALSE otherwise. */function node_access($op, $node, $account = NULL) {  global $user;  if (!$node || !in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {    // If there was no node to check against, or the $op was not one of the    // supported ones, we return access denied.    return FALSE;  }  // Convert the node to an object if necessary:  if ($op != 'create') {    $node = (object)$node;  }  // If no user object is supplied, the access check is for the current user.  if (empty($account)) {    $account = $user;  }  // If the node is in a restricted format, disallow editing.  if ($op == 'update' && !filter_access($node->format)) {    return FALSE;  }  if (user_access('administer nodes', $account)) {    return TRUE;  }  if (!user_access('access content', $account)) {    return FALSE;  }  // Can't use node_invoke(), because the access hook takes the $op parameter  // before the $node parameter.  $module = node_get_types('module', $node);  if ($module == 'node') {    $module = 'node_content'; // Avoid function name collisions.  }  $access = module_invoke($module, 'access', $op, $node, $account);  if (!is_null($access)) {    return $access;  }  // If the module did not override the access rights, use those set in the  // node_access table.  if ($op != 'create' && $node->nid && $node->status) {    $grants = array();    foreach (node_access_grants($op, $account) as $realm => $gids) {      foreach ($gids as $gid) {        $grants[] = "(gid = $gid AND realm = '$realm')";      }    }    $grants_sql = '';    if (count($grants)) {      $grants_sql = 'AND ('. implode(' OR ', $grants) .')';    }    $sql = "SELECT 1 FROM {node_access} WHERE (nid = 0 OR nid = %d) $grants_sql AND grant_$op >= 1";    $result = db_query_range($sql, $node->nid, 0, 1);    return (bool) db_result($result);  }  // Let authors view their own nodes.  if ($op == 'view' && $account->uid == $node->uid && $account->uid != 0) {    return TRUE;  }  return FALSE;}/** * Generate an SQL join clause for use in fetching a node listing. * * @param $node_alias *   If the node table has been given an SQL alias other than the default *   "n", that must be passed here. * @param $node_access_alias *   If the node_access table has been given an SQL alias other than the default *   "na", that must be passed here. * @return *   An SQL join clause. */function _node_access_join_sql($node_alias = 'n', $node_access_alias = 'na') {  if (user_access('administer nodes')) {    return '';  }  return 'INNER JOIN {node_access} '. $node_access_alias .' ON '. $node_access_alias .'.nid = '. $node_alias .'.nid';}/** * Generate an SQL where clause for use in fetching a node listing. * * @param $op *   The operation that must be allowed to return a node. * @param $node_access_alias *   If the node_access table has been given an SQL alias other than the default *   "na", that must be passed here. * @param $account *   The user object for the user performing the operation. If omitted, the *   current user is used. * @return *   An SQL where clause. */function _node_access_where_sql($op = 'view', $node_access_alias = 'na', $account = NULL) {  if (user_access('administer nodes')) {    return;  }  $grants = array();  foreach (node_access_grants($op, $account) as $realm => $gids) {    foreach ($gids as $gid) {      $grants[] = "($node_access_alias.gid = $gid AND $node_access_alias.realm = '$realm')";    }  }  $grants_sql = '';  if (count($grants)) {    $grants_sql = 'AND ('. implode(' OR ', $grants) .')';  }  $sql = "$node_access_alias.grant_$op >= 1 $grants_sql";  return $sql;}/** * Fetch an array of permission IDs granted to the given user ID. * * The implementation here provides only the universal "all" grant. A node * access module should implement hook_node_grants() to provide a grant * list for the user. * * @param $op *   The operation that the user is trying to perform. * @param $account *   The user object for the user performing the operation. If omitted, the *   current user is used. * @return *   An associative array in which the keys are realms, and the values are *   arrays of grants for those realms. */function node_access_grants($op, $account = NULL) {  if (!isset($account)) {    $account = $GLOBALS['user'];  }  return array_merge(array('all' => array(0)), module_invoke_all('node_grants', $account, $op));}/** * Determine whether the user has a global viewing grant for all nodes. */function node_access_view_all_nodes() {  static $access;  if (!isset($access)) {    $grants = array();    foreach (node_access_grants('view') as $realm => $gids) {      foreach ($gids as $gid) {        $grants[] = "(gid = $gid AND realm = '$realm')";      }    }    $grants_sql = '';    if (count($grants)) {      $grants_sql = 'AND ('. implode(' OR ', $grants) .')';    }    $sql = "SELECT COUNT(*) FROM {node_access} WHERE nid = 0 $grants_sql AND grant_view >= 1";    $result = db_query($sql);    $access = db_result($result);  }  return $access;}/** * Implementation of hook_db_rewrite_sql */function node_db_rewrite_sql($query, $primary_table, $primary_field) {  if ($primary_field == 'nid' && !node_access_view_all_nodes()) {    $return['join'] = _node_access_join_sql($primary_table);    $return['where'] = _node_access_where_sql();    $return['distinct'] = 1;    return $return;  }}/** * This function will call module invoke to get a list of grants and then * write them to the database. It is called at node save, and should be * called by modules whenever something other than a node_save causes * the permissions on a node to change. * * This function is the only function that should write to the node_access * table. * * @param $node *   The $node to acquire grants for. */function node_access_acquire_grants($node) {  $grants = module_invoke_all('node_access_records', $node);  if (empty($grants)) {    $grants[] = array('realm' => 'all', 'gid' => 0, 'grant_view' => 1, 'grant_update' => 0, 'grant_delete' => 0);  }  else {    // retain grants by highest priority    $grant_by_priority = array();    foreach ($grants as $g) {      $grant_by_priority[intval($g['priority'])][] = $g;    }    krsort($grant_by_priority);    $grants = array_shift($grant_by_priority);  }  node_access_write_grants($node, $grants);}/** * This function will write a list of grants to the database, deleting * any pre-existing grants. If a realm is provided, it will only * delete grants from that realm, but it will always delete a grant * from the 'all' realm. Modules which utilize node_access can * use this function when doing mass updates due to widespread permission * changes. * * @param $node *   The $node being written to. All that is necessary is that it contain a nid. * @param $grants *   A list of grants to write. Each grant is an array that must contain the *   following keys: realm, gid, grant_view, grant_update, grant_delete. *   The realm is specified by a particular module; the gid is as well, and *   is a module-defined id to define grant privileges. each grant_* field *   is a boolean value. * @param $realm *   If provided, only read/write grants for that realm. * @param $delete *   If false, do not delete records. This is only for optimization purposes, *   and assumes the caller has already performed a mass delete of some form. */function node_access_write_grants($node, $grants, $realm = NULL, $delete = TRUE) {  if ($delete) {    $query = 'DELETE FROM {node_access} WHERE nid = %d';    if ($realm) {      $query .= " AND realm in ('%s', 'all')";    }    db_query($query, $node->nid, $realm);  }  // Only perform work when node_access modules are active.  if (count(module_implements('node_grants'))) {    foreach ($grants as $grant) {      if ($realm && $realm != $grant['realm']) {        continue;      }      // Only write grants; denies are implicit.      if ($grant['grant_view'] || $grant['grant_update'] || $grant['grant_delete']) {        db_query("INSERT INTO {node_access} (nid, realm, gid, grant_view, grant_update, grant_delete) VALUES (%d, '%s', %d, %d, %d, %d)", $node->nid, $grant['realm'], $grant['gid'], $grant['grant_view'], $grant['grant_update'], $grant['grant_delete']);      }    }  }}/** * Flag / unflag the node access grants for rebuilding, or read the current * value of the flag. * * When the flag is set, a message is displayed to users with 'access * administration pages' permission, pointing to the 'rebuild' confirm form. * This can be used as an alternative to direct node_access_rebuild calls, * allowing administrators to decide when they want to perform the actual * (possibly time consuming) rebuild. * When unsure the current user is an adminisrator, node_access_rebuild * should be used instead. * * @param $rebuild *   (Optional) The boolean value to be written.  * @return *   (If no value was provided for $rebuild) The current value of the flag. */function node_access_needs_rebuild($rebuild = NULL) {  if (!isset($rebuild)) {    return variable_get('node_access_needs_rebuild', FALSE);  }  elseif ($rebuild) {    variable_set('node_access_needs_rebuild', TRUE);  }  else {    variable_del('node_access_needs_rebuild');  }}/** * Rebuild the node access database. This is occasionally needed by modules * that make system-wide changes to access levels. * * When the rebuild is required by an admin-triggered action (e.g module * settings form), calling node_access_needs_rebuild(TRUE) instead of * node_access_rebuild() lets the user perform his changes and actually * rebuild only once he is done. * * Note : As of Drupal 6, node access modules are not required to (and actually * should not) call node_access_rebuild() in hook_enable/disable anymore. * * @see node_access_needs_rebuild() * * @param $batch_mode *   Set to TRUE to process in 'batch' mode, spawning processing over several *   HTTP requests (thus avoiding the risk of PHP timeout if the site has a *   large number of nodes). *   hook_update_N and any form submit handler are safe contexts to use the *   'batch mode'. Less decidable cases (such as calls from hook_user, *   hook_taxonomy, hook_node_type...) might consider using the non-batch mode. */function node_access_rebuild($batch_mode = FALSE) {  db_query("DELETE FROM {node_access}");  // Only recalculate if the site is using a node_access module.  if (count(module_implements('node_grants'))) {    if ($batch_mode) {      $batch = array(        'title' => t('Rebuilding content access permissions'),        'operations' => array(          array('_node_access_rebuild_batch_operation', array()),        ),        'finished' => '_node_access_rebuild_batch_finished'      );      batch_set($batch);    }    else {      // Try to allocate enough time to rebuild node grants      if (function_exists('set_time_limit')) {        @set_time_limit(240);      }      $result = db_query("SELECT nid FROM {node}");      while ($node = db_fetch_object($result)) {        $loaded_node = node_load($node->nid, NULL, TRUE);        // To preserve database integrity, only aquire grants if the node        // loads successfully.        if (!empty($loaded_node)) {          node_access_acquire_grants($loaded_node);        }      }    }  }  else {    // Not using any node_access modules. Add the default grant.    db_query("INSERT INTO {node_access} VALUES (0, 0, 'all', 1, 0, 0)");  }  if (!isset($batch)) {    drupal_set_message(t('Content permissions have been rebuilt.'));    node_access_needs_rebuild(FALSE);    cache_clear_all();  }}/** * Batch operation for node_access_rebuild_batch. * * This is a mutlistep operation : we go through all nodes by packs of 20. * The batch processing engine interrupts processing and sends progress * feedback after 1 second execution time. */function _node_access_rebuild_batch_operation(&$context) {  if (empty($context['sandbox'])) {    // Initiate multistep processing.    $context['sandbox']['progress'] = 0;    $context['sandbox']['current_node'] = 0;    $context['sandbox']['max'] = db_result(db_query('SELECT COUNT(DISTINCT nid) FROM {node}'));  }  // Process the next 20 nodes.  $limit = 20;  $result = db_query_range("SELECT nid FROM {node} WHERE nid > %d ORDER BY nid ASC", $context['sandbox']['current_node'], 0, $limit);  while ($row = db_fetch_array($result)) {    $loaded_node = node_load($row['nid'], NULL, TRUE);    // To preserve database integrity, only aquire grants if the node    // loads successfully.    if (!empty($loaded_node)) {      node_access_acquire_grants($loaded_node);    }    $context['sandbox']['progress']++;    $context['sandbox']['current_node'] = $loaded_node->nid;  }  // Multistep processing : report progress.  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];  }}/** * Post-processing for node_access_rebuild_batch. */function _node_access_rebuild_batch_finished($success, $results, $operations) {  if ($success) {    drupal_set_message(t('The content access permissions have been rebuilt.'));    node_access_needs_rebuild(FALSE);  }  else {    drupal_set_message(t('The content access permissions have not been properly rebuilt.'), 'error');  }  cache_clear_all();}/** * @} End of "defgroup node_access". *//** * @defgroup node_content Hook implementations for user-created content types. * @{ *//** * Implementation of hook_access(). * * Named so as not to conflict with node_access() */function node_content_access($op, $node, $account) {  $type = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);  if ($op == 'create') {    return user_access('create '. $type .' content', $account);  }  if ($op == 'update') {    if (user_access('edit any '. $type .' content', $account) || (user_access('edit own '. $type .' content', $account) && ($account->uid == $node->uid))) {      return TRUE;    }  }  if ($op == 'delete') {    if (user_access('delete any '. $type .' content', $account) || (user_access('delete own '. $type .' content', $account) && ($account->uid == $node->uid))) {      return TRUE;    }  }}/** * Implementation of hook_form(). */function node_content_form($node, $form_state) {  $type = node_get_types('type', $node);  $form = array();  if ($type->has_title) {    $form['title'] = array(      '#type' => 'textfield',      '#title' => check_plain($type->title_label),      '#required' => TRUE,      '#default_value' => $node->title,      '#maxlength' => 255,      '#weight' => -5,    );  }  if ($type->has_body) {    $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);  }  return $form;}/** * @} End of "defgroup node_content". *//** * Implementation of hook_forms(). All node forms share the same form handler */function node_forms() {  $forms = array();  if ($types = node_get_types()) {    foreach (array_keys($types) as $type) {      $forms[$type .'_node_form']['callback'] = 'node_form';    }  }  return $forms;}/** * Format the "Submitted by username on date/time" for each node * * @ingroup themeable */function theme_node_submitted($node) {  return t('Submitted by !username on @datetime',    array(      '!username' => theme('username', $node),      '@datetime' => format_date($node->created),    ));}/** * Implementation of hook_hook_info(). */function node_hook_info() {  return array(    'node' => array(      'nodeapi' => array(        'presave' => array(          'runs when' => t('When either saving a new post or updating an existing post'),        ),        'insert' => array(          'runs when' => t('After saving a new post'),        ),        'update' => array(          'runs when' => t('After saving an updated post'),        ),        'delete' => array(          'runs when' => t('After deleting a post')        ),        'view' => array(          'runs when' => t('When content is viewed by an authenticated user')        ),      ),    ),  );}/** * Implementation of hook_action_info(). */function node_action_info() {  return array(    'node_publish_action' => array(      'type' => 'node',      'description' => t('Publish post'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('insert', 'update'),      ),    ),    'node_unpublish_action' => array(      'type' => 'node',      'description' => t('Unpublish post'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('delete', 'insert', 'update'),      ),    ),    'node_make_sticky_action' => array(      'type' => 'node',      'description' => t('Make post sticky'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('insert', 'update'),      ),    ),    'node_make_unsticky_action' => array(      'type' => 'node',      'description' => t('Make post unsticky'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('delete', 'insert', 'update'),      ),    ),    'node_promote_action' => array(      'type' => 'node',      'description' => t('Promote post to front page'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('insert', 'update'),      ),    ),    'node_unpromote_action' => array(      'type' => 'node',      'description' => t('Remove post from front page'),      'configurable' => FALSE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'nodeapi' => array('presave'),        'comment' => array('delete', 'insert', 'update'),      ),    ),    'node_assign_owner_action' => array(      'type' => 'node',      'description' => t('Change the author of a post'),      'configurable' => TRUE,      'behavior' => array('changes_node_property'),      'hooks' => array(        'any' => TRUE,        'nodeapi' => array('presave'),        'comment' => array('delete', 'insert', 'update'),      ),    ),    'node_save_action' => array(      'type' => 'node',      'description' => t('Save post'),      'configurable' => FALSE,      'hooks' => array(        'comment' => array('delete', 'insert', 'update'),      ),    ),    'node_unpublish_by_keyword_action' => array(      'type' => 'node',      'description' => t('Unpublish post containing keyword(s)'),      'configurable' => TRUE,      'hooks' => array(        'nodeapi' => array('presave', 'insert', 'update'),      ),    ),  );}/** * Implementation of a Drupal action. * Sets the status of a node to 1, meaning published. */function node_publish_action(&$node, $context = array()) {  $node->status = 1;  watchdog('action', 'Set @type %title to published.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Sets the status of a node to 0, meaning unpublished. */function node_unpublish_action(&$node, $context = array()) {  $node->status = 0;  watchdog('action', 'Set @type %title to unpublished.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Sets the sticky-at-top-of-list property of a node to 1. */function node_make_sticky_action(&$node, $context = array()) {  $node->sticky = 1;  watchdog('action', 'Set @type %title to sticky.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Sets the sticky-at-top-of-list property of a node to 0. */function node_make_unsticky_action(&$node, $context = array()) {  $node->sticky = 0;  watchdog('action', 'Set @type %title to unsticky.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Sets the promote property of a node to 1. */function node_promote_action(&$node, $context = array()) {  $node->promote = 1;  watchdog('action', 'Promoted @type %title to front page.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Sets the promote property of a node to 0. */function node_unpromote_action(&$node, $context = array()) {  $node->promote = 0;  watchdog('action', 'Removed @type %title from front page.', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a Drupal action. * Saves a node. */function node_save_action($node) {  node_save($node);  watchdog('action', 'Saved @type %title', array('@type' => node_get_types('name', $node), '%title' => $node->title));}/** * Implementation of a configurable Drupal action. * Assigns ownership of a node to a user. */function node_assign_owner_action(&$node, $context) {  $node->uid = $context['owner_uid'];  $owner_name = db_result(db_query("SELECT name FROM {users} WHERE uid = %d", $context['owner_uid']));  watchdog('action', 'Changed owner of @type %title to uid %name.', array('@type' => node_get_types('type', $node), '%title' => $node->title, '%name' => $owner_name));}function node_assign_owner_action_form($context) {  $description = t('The username of the user to which you would like to assign ownership.');  $count = db_result(db_query("SELECT COUNT(*) FROM {users}"));  $owner_name = '';  if (isset($context['owner_uid'])) {    $owner_name = db_result(db_query("SELECT name FROM {users} WHERE uid = %d", $context['owner_uid']));  }  // Use dropdown for fewer than 200 users; textbox for more than that.  if (intval($count) < 200) {    $options = array();    $result = db_query("SELECT uid, name FROM {users} WHERE uid > 0 ORDER BY name");    while ($data = db_fetch_object($result)) {      $options[$data->name] = $data->name;    }    $form['owner_name'] = array(      '#type' => 'select',      '#title' => t('Username'),      '#default_value' => $owner_name,      '#options' => $options,      '#description' => $description,    );  }  else {    $form['owner_name'] = array(      '#type' => 'textfield',      '#title' => t('Username'),      '#default_value' => $owner_name,      '#autocomplete_path' => 'user/autocomplete',      '#size' => '6',      '#maxlength' => '60',      '#description' => $description,    );  }  return $form;}function node_assign_owner_action_validate($form, $form_state) {  $count = db_result(db_query("SELECT COUNT(*) FROM {users} WHERE name = '%s'", $form_state['values']['owner_name']));  if (intval($count) != 1) {    form_set_error('owner_name', t('Please enter a valid username.'));  }}function node_assign_owner_action_submit($form, $form_state) {  // Username can change, so we need to store the ID, not the username.  $uid = db_result(db_query("SELECT uid from {users} WHERE name = '%s'", $form_state['values']['owner_name']));  return array('owner_uid' => $uid);}function node_unpublish_by_keyword_action_form($context) {  $form['keywords'] = array(    '#title' => t('Keywords'),    '#type' => 'textarea',    '#description' => t('The post will be unpublished if it contains any of the character sequences above. Use a comma-separated list of character sequences. Example: funny, bungee jumping, "Company, Inc.". Character sequences are case-sensitive.'),    '#default_value' => isset($context['keywords']) ? drupal_implode_tags($context['keywords']) : '',  );  return $form;}function node_unpublish_by_keyword_action_submit($form, $form_state) {  return array('keywords' => drupal_explode_tags($form_state['values']['keywords']));}/** * Implementation of a configurable Drupal action. * Unpublish a node if it contains a certain string. * * @param $context *   An array providing more information about the context of the call to this action. * @param $comment *   A node object. */function node_unpublish_by_keyword_action($node, $context) {  foreach ($context['keywords'] as $keyword) {    if (strstr(node_view(drupal_clone($node)), $keyword) || strstr($node->title, $keyword)) {      $node->status = 0;      watchdog('action', 'Set @type %title to unpublished.', array('@type' => node_get_types('name', $node), '%title' => $node->title));      break;    }  }}
<?php// $Id$define('SCHEMA_UNINSTALLED', -1);define('SCHEMA_INSTALLED', 0);define('REQUIREMENT_INFO', -1);define('REQUIREMENT_OK', 0);define('REQUIREMENT_WARNING', 1);define('REQUIREMENT_ERROR', 2);define('FILE_EXIST',          1);define('FILE_READABLE',       2);define('FILE_WRITABLE',       4);define('FILE_EXECUTABLE',     8);define('FILE_NOT_EXIST',      16);define('FILE_NOT_READABLE',   32);define('FILE_NOT_WRITABLE',   64);define('FILE_NOT_EXECUTABLE', 128);/** * Initialize the update system by loading all installed module's .install files. */function drupal_load_updates() {  foreach (drupal_get_installed_schema_version(NULL, FALSE, TRUE) as $module => $schema_version) {    if ($schema_version > -1) {      module_load_install($module);    }  }}/** * Returns an array of available schema versions for a module. * * @param $module *   A module name. * @return *   If the module has updates, an array of available updates sorted by version.  *   Otherwise, FALSE. */function drupal_get_schema_versions($module) {  $updates = array();  $functions = get_defined_functions();  foreach ($functions['user'] as $function) {    if (strpos($function, $module .'_update_') === 0) {      $version = substr($function, strlen($module .'_update_'));      if (is_numeric($version)) {        $updates[] = $version;      }    }  }  if (count($updates) == 0) {    return FALSE;  }  sort($updates, SORT_NUMERIC);  return $updates;}/** * Returns the currently installed schema version for a module. * * @param $module *   A module name. * @param $reset *   Set to TRUE after modifying the system table. * @param $array *   Set to TRUE if you want to get information about all modules in the *   system. * @return *   The currently installed schema version. */function drupal_get_installed_schema_version($module, $reset = FALSE, $array = FALSE) {  static $versions = array();  if ($reset) {    $versions = array();  }  if (!$versions) {    $versions = array();    $result = db_query("SELECT name, schema_version FROM {system} WHERE type = '%s'", 'module');    while ($row = db_fetch_object($result)) {      $versions[$row->name] = $row->schema_version;    }  }  return $array ? $versions : $versions[$module];}/** * Update the installed version information for a module. * * @param $module *   A module name. * @param $version *   The new schema version. */function drupal_set_installed_schema_version($module, $version) {  db_query("UPDATE {system} SET schema_version = %d WHERE name = '%s'", $version, $module);}/** * Loads the profile definition, extracting the profile's defined name. * * @return *   The name defined in the profile's _profile_details() hook. */function drupal_install_profile_name() {  global $profile;  static $name = NULL;  if (!isset($name)) {    // Load profile details.    $function = $profile .'_profile_details';    if (function_exists($function)) {      $details = $function();    }    $name = isset($details['name']) ? $details['name'] : 'Drupal';  }  return $name;}/** * Auto detect the base_url with PHP predefined variables. * * @param $file *   The name of the file calling this function so we can strip it out of *   the URI when generating the base_url. * * @return *   The auto-detected $base_url that should be configured in settings.php */function drupal_detect_baseurl($file = 'install.php') {  global $profile;  $proto = $_SERVER['HTTPS'] ? 'https://' : 'http://';  $host = $_SERVER['SERVER_NAME'];  $port = ($_SERVER['SERVER_PORT'] == 80 ? '' : ':'. $_SERVER['SERVER_PORT']);  $uri = preg_replace("/\?.*/", '', $_SERVER['REQUEST_URI']);  $dir = str_replace("/$file", '', $uri);  return "$proto$host$port$dir";}/** * Detect all databases supported by Drupal that are compiled into the current * PHP installation. * * @return *  An array of database types compiled into PHP. */function drupal_detect_database_types() {  $databases = array();  foreach (array('mysql', 'mysqli', 'pgsql') as $type) {    if (file_exists('./includes/install.'. $type .'.inc')) {      include_once './includes/install.'. $type .'.inc';      $function = $type .'_is_available';      if ($function()) {        $databases[$type] = $type;      }    }  }  return $databases;}/** * Read settings.php into a buffer line by line, changing values specified in * $settings array, then over-writing the old settings.php file. * * @param $settings *   An array of settings that need to be updated. */function drupal_rewrite_settings($settings = array(), $prefix = '') {  $default_settings = './sites/default/default.settings.php';  $settings_file = './'. conf_path(FALSE, TRUE) .'/'. $prefix .'settings.php';  // Build list of setting names and insert the values into the global namespace.  $keys = array();  foreach ($settings as $setting => $data) {    $GLOBALS[$setting] = $data['value'];    $keys[] = $setting;  }  $buffer = NULL;  $first = TRUE;  if ($fp = fopen($default_settings, 'r')) {    // Step line by line through settings.php.    while (!feof($fp)) {      $line = fgets($fp);      if ($first && substr($line, 0, 5) != '<?php') {        $buffer = "<?php\n\n";      }      $first = FALSE;      // Check for constants.      if (substr($line, 0, 7) == 'define(') {        preg_match('/define\(\s*[\'"]([A-Z_-]+)[\'"]\s*,(.*?)\);/', $line, $variable);        if (in_array($variable[1], $keys)) {          $setting = $settings[$variable[1]];          $buffer .= str_replace($variable[2], " '". $setting['value'] ."'", $line);          unset($settings[$variable[1]]);          unset($settings[$variable[2]]);        }        else {          $buffer .= $line;        }      }      // Check for variables.      elseif (substr($line, 0, 1) == '$') {        preg_match('/\$([^ ]*) /', $line, $variable);        if (in_array($variable[1], $keys)) {          // Write new value to settings.php in the following format:          //    $'setting' = 'value'; // 'comment'          $setting = $settings[$variable[1]];          $buffer .= '$'. $variable[1] ." = '". $setting['value'] ."';". (!empty($setting['comment']) ? ' // '. $setting['comment'] ."\n" : "\n");          unset($settings[$variable[1]]);        }        else {          $buffer .= $line;        }      }      else {        $buffer .= $line;      }    }    fclose($fp);    // Add required settings that were missing from settings.php.    foreach ($settings as $setting => $data) {      if ($data['required']) {        $buffer .= "\$$setting = '". $data['value'] ."';\n";      }    }    $fp = fopen($settings_file, 'w');    if ($fp && fwrite($fp, $buffer) === FALSE) {      drupal_set_message(st('Failed to modify %settings, please verify the file permissions.', array('%settings' => $settings_file)), 'error');    }  }  else {    drupal_set_message(st('Failed to open %settings, please verify the file permissions.', array('%settings' => $default_settings)), 'error');  }}/** * Get list of all .install files. * * @param $module_list *   An array of modules to search for their .install files. */function drupal_get_install_files($module_list = array()) {  $installs = array();  foreach ($module_list as $module) {    $installs = array_merge($installs, drupal_system_listing($module .'.install$', 'modules'));  }  return $installs;}/** * Verify a profile for installation. * * @param profile *   Name of profile to verify. * @param locale *   Name of locale used (if any). * @return *   The list of modules to install. */function drupal_verify_profile($profile, $locale) {  include_once './includes/file.inc';  include_once './includes/common.inc';  $profile_file = "./profiles/$profile/$profile.profile";  if (!isset($profile) || !file_exists($profile_file)) {    install_no_profile_error();  }  require_once($profile_file);  // Get a list of modules required by this profile.  $function = $profile .'_profile_modules';  $module_list = array_merge(drupal_required_modules(), $function(), ($locale != 'en' && !empty($locale) ? array('locale') : array()));  // Get a list of modules that exist in Drupal's assorted subdirectories.  $present_modules = array();  foreach (drupal_system_listing('\.module$', 'modules', 'name', 0) as $present_module) {    $present_modules[] = $present_module->name;  }  // Verify that all of the profile's required modules are present.  $missing_modules = array_diff($module_list, $present_modules);  if (count($missing_modules)) {    foreach ($missing_modules as $module) {      drupal_set_message(st('The %module module is required but was not found. Please move it into the <em>modules</em> subdirectory.', array('%module' => $module)), 'error');    }  }  else {    return $module_list;  }}/** * Calls the install function and updates the system table for a given list of * modules. * * @param module_list *   The modules to install. */function drupal_install_modules($module_list = array()) {  $files = module_rebuild_cache();  $module_list = array_flip(array_values($module_list));  do {    $moved = FALSE;    foreach ($module_list as $module => $weight) {      $file = $files[$module];      if (isset($file->info['dependencies']) && is_array($file->info['dependencies'])) {        foreach ($file->info['dependencies'] as $dependency) {          if (isset($module_list[$dependency]) && $module_list[$module] < $module_list[$dependency] +1) {            $module_list[$module] = $module_list[$dependency] +1;            $moved = TRUE;          }        }      }    }  } while ($moved);  asort($module_list);  $module_list = array_keys($module_list);  array_filter($module_list, '_drupal_install_module');  module_enable($module_list);}/** * Callback to install an individual profile module. * * Used during installation to install modules one at a time and then * enable them, or to install a number of modules at one time * from admin/build/modules. */function _drupal_install_module($module) {  if (drupal_get_installed_schema_version($module, TRUE) == SCHEMA_UNINSTALLED) {    module_load_install($module);    module_invoke($module, 'install');    $versions = drupal_get_schema_versions($module);    drupal_set_installed_schema_version($module, $versions ? max($versions) : SCHEMA_INSTALLED);    return TRUE;  }}/** * Callback to install the system module. * * Separated from the installation of other modules so core system * functions can be made available while other modules are installed. */function drupal_install_system() {  $system_path = dirname(drupal_get_filename('module', 'system', NULL));  require_once './'. $system_path .'/system.install';  module_invoke('system', 'install');  $system_versions = drupal_get_schema_versions('system');  $system_version = $system_versions ? max($system_versions) : SCHEMA_INSTALLED;  db_query("INSERT INTO {system} (filename, name, type, owner, status, throttle, bootstrap, schema_version) VALUES('%s', '%s', '%s', '%s', %d, %d, %d, %d)", $system_path .'/system.module', 'system', 'module', '', 1, 0, 0, $system_version);  // Now that we've installed things properly, bootstrap the full Drupal environment  drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);  module_rebuild_cache();}/** * Calls the uninstall function and updates the system table for a given module. * * @param $module *   The module to uninstall. */function drupal_uninstall_module($module) {  // First, retrieve all the module's menu paths from db.  drupal_load('module', $module);  $paths = module_invoke($module, 'menu');  // Uninstall the module(s).  module_load_install($module);  module_invoke($module, 'uninstall');  // Now remove the menu links for all paths declared by this module.  if (!empty($paths)) {    $paths = array_keys($paths);    // Clean out the names of load functions.    foreach ($paths as $index => $path) {      $parts = explode('/', $path, MENU_MAX_PARTS);      foreach ($parts as $k => $part) {        if (preg_match('/^%[a-z_]*$/', $part)) {          $parts[$k] = '%';        }      }      $paths[$index] = implode('/', $parts);    }    $placeholders = implode(', ', array_fill(0, count($paths), "'%s'"));    $result = db_query('SELECT * FROM {menu_links} WHERE router_path IN ('. $placeholders .') AND external = 0 ORDER BY depth DESC', $paths);    // Remove all such items. Starting from those with the greatest depth will    // minimize the amount of re-parenting done by menu_link_delete().    while ($item = db_fetch_array($result)) {      _menu_delete_item($item, TRUE);    }  }  drupal_set_installed_schema_version($module, SCHEMA_UNINSTALLED);}/** * Verify the state of the specified file. * * @param $file *   The file to check for. * @param $mask *   An optional bitmask created from various FILE_* constants. * @param $type *   The type of file. Can be file (default), dir, or link. * @return *   TRUE on success or FALSE on failure. A message is set for the latter. */function drupal_verify_install_file($file, $mask = NULL, $type = 'file') {  $return = TRUE;  // Check for files that shouldn't be there.  if (isset($mask) && ($mask & FILE_NOT_EXIST) && file_exists($file)) {    return FALSE;  }  // Verify that the file is the type of file it is supposed to be.  if (isset($type) && file_exists($file)) {    $check = 'is_'. $type;    if (!function_exists($check) || !$check($file)) {      $return = FALSE;    }  }  // Verify file permissions.  if (isset($mask)) {    $masks = array(FILE_EXIST, FILE_READABLE, FILE_WRITABLE, FILE_EXECUTABLE, FILE_NOT_READABLE, FILE_NOT_WRITABLE, FILE_NOT_EXECUTABLE);    foreach ($masks as $current_mask) {      if ($mask & $current_mask) {        switch ($current_mask) {          case FILE_EXIST:            if (!file_exists($file)) {              if ($type == 'dir') {                drupal_install_mkdir($file, $mask);              }              if (!file_exists($file)) {                $return = FALSE;              }            }            break;          case FILE_READABLE:            if (!is_readable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;          case FILE_WRITABLE:            if (!is_writable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;          case FILE_EXECUTABLE:            if (!is_executable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;          case FILE_NOT_READABLE:            if (is_readable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;          case FILE_NOT_WRITABLE:            if (is_writable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;          case FILE_NOT_EXECUTABLE:            if (is_executable($file) && !drupal_install_fix_file($file, $mask)) {              $return = FALSE;            }            break;        }      }    }  }  return $return;}/** * Create a directory with specified permissions. * * @param file *  The name of the directory to create; * @param mask *  The permissions of the directory to create. * @param $message *  (optional) Whether to output messages. Defaults to TRUE. * * @return *  TRUE/FALSE whether or not the directory was successfully created. */function drupal_install_mkdir($file, $mask, $message = TRUE) {  $mod = 0;  $masks = array(FILE_READABLE, FILE_WRITABLE, FILE_EXECUTABLE, FILE_NOT_READABLE, FILE_NOT_WRITABLE, FILE_NOT_EXECUTABLE);  foreach ($masks as $m) {    if ($mask & $m) {      switch ($m) {        case FILE_READABLE:          $mod += 444;          break;        case FILE_WRITABLE:          $mod += 222;          break;        case FILE_EXECUTABLE:          $mod += 111;          break;      }    }  }  if (@mkdir($file, intval("0$mod", 8))) {    return TRUE;  }  else {    return FALSE;  }}/** * Attempt to fix file permissions. * * The general approach here is that, because we do not know the security * setup of the webserver, we apply our permission changes to all three * digits of the file permission (i.e. user, group and all). * * To ensure that the values behave as expected (and numbers don't carry * from one digit to the next) we do the calculation on the octal value * using bitwise operations. This lets us remove, for example, 0222 from * 0700 and get the correct value of 0500. * * @param $file *  The name of the file with permissions to fix. * @param $mask *  The desired permissions for the file. * @param $message *  (optional) Whether to output messages. Defaults to TRUE. * * @return *  TRUE/FALSE whether or not we were able to fix the file's permissions. */function drupal_install_fix_file($file, $mask, $message = TRUE) {  $mod = fileperms($file) & 0777;  $masks = array(FILE_READABLE, FILE_WRITABLE, FILE_EXECUTABLE, FILE_NOT_READABLE, FILE_NOT_WRITABLE, FILE_NOT_EXECUTABLE);  // FILE_READABLE, FILE_WRITABLE, and FILE_EXECUTABLE permission strings  // can theoretically be 0400, 0200, and 0100 respectively, but to be safe  // we set all three access types in case the administrator intends to  // change the owner of settings.php after installation.  foreach ($masks as $m) {    if ($mask & $m) {      switch ($m) {        case FILE_READABLE:          if (!is_readable($file)) {            $mod |= 0444;          }          break;        case FILE_WRITABLE:          if (!is_writable($file)) {            $mod |= 0222;          }          break;        case FILE_EXECUTABLE:          if (!is_executable($file)) {            $mod |= 0111;          }          break;        case FILE_NOT_READABLE:          if (is_readable($file)) {            $mod &= ~0444;          }          break;        case FILE_NOT_WRITABLE:          if (is_writable($file)) {            $mod &= ~0222;          }          break;        case FILE_NOT_EXECUTABLE:          if (is_executable($file)) {            $mod &= ~0111;          }          break;      }    }  }  // chmod() will work if the web server is running as owner of the file.  // If PHP safe_mode is enabled the currently executing script must also  // have the same owner.  if (@chmod($file, $mod)) {    return TRUE;  }  else {    return FALSE;  }}/** * Send the user to a different installer page. This issues an on-site HTTP * redirect. Messages (and errors) are erased. * * @param $path *   An installer path. */function install_goto($path) {  global $base_url;  header('Location: '. $base_url .'/'. $path);  header('Cache-Control: no-cache'); // Not a permanent redirect.  exit();}/** * Hardcoded function for doing the equivalent of t() during * the install process, when database, theme, and localization * system is possibly not yet available. */function st($string, $args = array()) {  static $locale_strings = NULL;  global $profile, $install_locale;  if (!isset($locale_strings)) {    $locale_strings = array();    $filename = './profiles/'. $profile .'/translations/'. $install_locale .'.po';    if (file_exists($filename)) {      require_once './includes/locale.inc';      $file = (object) array('filepath' => $filename);      _locale_import_read_po('mem-store', $file);      $locale_strings = _locale_import_one_string('mem-report');    }  }  require_once './includes/theme.inc';  // Transform arguments before inserting them  foreach ($args as $key => $value) {    switch ($key[0]) {      // Escaped only      case '@':        $args[$key] = check_plain($value);        break;      // Escaped and placeholder      case '%':      default:        $args[$key] = '<em>'. check_plain($value) .'</em>';        break;      // Pass-through      case '!':    }  }  return strtr((!empty($locale_strings[$string]) ? $locale_strings[$string] : $string), $args);}/** * Check a profile's requirements. * * @param profile *   Name of profile to check. */function drupal_check_profile($profile) {  include_once './includes/file.inc';  $profile_file = "./profiles/$profile/$profile.profile";  if (!isset($profile) || !file_exists($profile_file)) {    install_no_profile_error();  }  require_once($profile_file);  // Get a list of modules required by this profile.  $function = $profile .'_profile_modules';  $module_list = array_unique(array_merge(drupal_required_modules(), $function()));  // Get a list of all .install files.  $installs = drupal_get_install_files($module_list);  // Collect requirement testing results  $requirements = array();  foreach ($installs as $install) {    require_once $install->filename;    if (module_hook($install->name, 'requirements')) {      $requirements = array_merge($requirements, module_invoke($install->name, 'requirements', 'install'));    }  }  return $requirements;}/** * Extract highest severity from requirements array. */function drupal_requirements_severity(&$requirements) {  $severity = REQUIREMENT_OK;  foreach ($requirements as $requirement) {    if (isset($requirement['severity'])) {      $severity = max($severity, $requirement['severity']);    }  }  return $severity;}/** * Check a module's requirements. */function drupal_check_module($module) {  // Include install file  $install = drupal_get_install_files(array($module));  if (isset($install[$module])) {    require_once $install[$module]->filename;    // Check requirements    $requirements = module_invoke($module, 'requirements', 'install');    if (is_array($requirements) && drupal_requirements_severity($requirements) == REQUIREMENT_ERROR) {      // Print any error messages      foreach ($requirements as $requirement) {        if (isset($requirement['severity']) && $requirement['severity'] == REQUIREMENT_ERROR) {          $message = $requirement['description'];          if (isset($requirement['value']) && $requirement['value']) {            $message .= ' ('. t('Currently using !item !version', array('!item' => $requirement['title'], '!version' => $requirement['value'])) .')';          }          drupal_set_message($message, 'error');        }      }      return FALSE;    }  }  return TRUE;}
<?php// $Id$/** * @file * Configuration system that lets administrators modify the workings of the site. *//** * The current system version. */define('VERSION', '6.16');/** * Core API compatibility. */define('DRUPAL_CORE_COMPATIBILITY', '6.x');/** * Minimum supported version of PHP. */define('DRUPAL_MINIMUM_PHP',    '4.3.5');/** * Minimum recommended value of PHP memory_limit. */define('DRUPAL_MINIMUM_PHP_MEMORY_LIMIT',    '16M');/** * Minimum supported version of MySQL, if it is used. */define('DRUPAL_MINIMUM_MYSQL',  '4.1.1');/** * Minimum supported version of PostgreSQL, if it is used. */define('DRUPAL_MINIMUM_PGSQL',  '7.4');/** * Maximum age of temporary files in seconds. */define('DRUPAL_MAXIMUM_TEMP_FILE_AGE', 21600);/** * Implementation of hook_help(). */function system_help($path, $arg) {  global $base_url;  switch ($path) {    case 'admin/help#system':      $output = '<p>'. t('The system module is at the foundation of your Drupal website, and provides basic but extensible functionality for use by other modules and themes. Some integral elements of Drupal are contained in and managed by the system module, including caching, enabling or disabling of modules and themes, preparing and displaying the administrative page, and configuring fundamental site settings. A number of key system maintenance operations are also part of the system module.') .'</p>';      $output .= '<p>'. t('The system module provides:') .'</p>';      $output .= '<ul><li>'. t('support for enabling and disabling <a href="@modules">modules</a>. Drupal comes packaged with a number of core modules; each module provides a discrete set of features and may be enabled depending on the needs of your site. A wide array of additional modules contributed by members of the Drupal community are available for download at the <a href="@drupal-modules">Drupal.org module page</a>.', array('@modules' => url('admin/build/modules'), '@drupal-modules' => 'http://drupal.org/project/modules')) .'</li>';      $output .= '<li>'. t('support for enabling and disabling <a href="@themes">themes</a>, which determine the design and presentation of your site. Drupal comes packaged with several core themes and additional contributed themes are available at the <a href="@drupal-themes">Drupal.org theme page</a>.', array('@themes' => url('admin/build/themes'), '@drupal-themes' => 'http://drupal.org/project/themes')) .'</li>';      $output .= '<li>'. t('a robust <a href="@cache-settings">caching system</a> that allows the efficient re-use of previously-constructed web pages and web page components. Drupal stores the pages requested by anonymous users in a compressed format; depending on your site configuration and the amount of your web traffic tied to anonymous visitors, Drupal\'s caching system may significantly increase the speed of your site.', array('@cache-settings' => url('admin/settings/performance'))) .'</li>';      $output .= '<li>'. t('a set of routine administrative operations that rely on a correctly-configured <a href="@cron">cron maintenance task</a> to run automatically. A number of other modules, including the feed aggregator, ping module and search also rely on <a href="@cron">cron maintenance tasks</a>. For more information, see the online handbook entry for <a href="@handbook">configuring cron jobs</a>.', array('@cron' => url('admin/reports/status'), '@handbook' => 'http://drupal.org/cron')) .'</li>';      $output .= '<li>'. t('basic configuration options for your site, including <a href="@date-settings">date and time settings</a>, <a href="@file-system">file system settings</a>, <a href="@clean-url">clean URL support</a>, <a href="@site-info">site name and other information</a>, and a <a href="@site-maintenance">site maintenance</a> function for taking your site temporarily off-line.', array('@date-settings' => url('admin/settings/date-time'), '@file-system' => url('admin/settings/file-system'), '@clean-url' => url('admin/settings/clean-urls'), '@site-info' => url('admin/settings/site-information'), '@site-maintenance' => url('admin/settings/site-maintenance'))) .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@system">System module</a>.', array('@system' => 'http://drupal.org/handbook/modules/system/')) .'</p>';      return $output;    case 'admin':      return '<p>'. t('Welcome to the administration section. Here you may control how your site functions.') .'</p>';    case 'admin/by-module':      return '<p>'. t('This page shows you all available administration tasks for each module.') .'</p>';    case 'admin/build/themes':      $output = '<p>'. t('Select which themes are available to your users and specify the default theme. To configure site-wide display settings, click the "configure" task above. Alternatively, to override these settings in a specific theme, click the "configure" link for that theme. Note that different themes may have different regions available for displaying content; for consistency in presentation, you may wish to enable only one theme.') .'</p>';      $output .= '<p>'. t('To change the appearance of your site, a number of <a href="@themes">contributed themes</a> are available.', array('@themes' => 'http://drupal.org/project/themes')) .'</p>';      return $output;    case 'admin/build/themes/settings/'. $arg[4]:      $reference = explode('.', $arg[4], 2);      $theme = array_pop($reference);      return '<p>'. t('These options control the display settings for the <code>%template</code> theme. When your site is displayed using this theme, these settings will be used. By clicking "Reset to defaults," you can choose to use the <a href="@global">global settings</a> for this theme.', array('%template' => $theme, '@global' => url('admin/build/themes/settings'))) .'</p>';    case 'admin/build/themes/settings':      return '<p>'. t('These options control the default display settings for your entire site, across all themes. Unless they have been overridden by a specific theme, these settings will be used.') .'</p>';    case 'admin/build/modules':      $output = '<p>'. t('Modules are plugins that extend Drupal\'s core functionality. Enable modules by selecting the <em>Enabled</em> checkboxes below and clicking the <em>Save configuration</em> button. Once a module is enabled, new <a href="@permissions">permissions</a> may be available. To reduce server load, modules with their <em>Throttle</em> checkbox selected are temporarily disabled when your site becomes extremely busy. (Note that the <em>Throttle</em> checkbox is only available if the Throttle module is enabled.)', array('@permissions' => url('admin/user/permissions')));      if (module_exists('throttle')) {        $output .= ' '. t('The auto-throttle functionality must be enabled on the <a href="@throttle">throttle configuration page</a> after having enabled the throttle module.', array('@throttle' => url('admin/settings/throttle')));      }      $output .= '</p>';      $output .= '<p>'. t('It is important that <a href="@update-php">update.php</a> is run every time a module is updated to a newer version.', array('@update-php' => $base_url .'/update.php')) .'</p>';      $output .= '<p>'. t('You can find all administration tasks belonging to a particular module on the <a href="@by-module">administration by module page</a>.', array('@by-module' => url('admin/by-module'))) .'</p>';      $output .= '<p>'. t('To extend the functionality of your site, a number of <a href="@modules">contributed modules</a> are available.', array('@modules' => 'http://drupal.org/project/modules')) .'</p>';      $output .= '<p>'. t('To clear all caches, click the button on the <a href="@performance">Performance page</a>.', array('@performance' => url('admin/settings/performance', array('fragment' => 'edit-clear')))) .'</p>';      return $output;    case 'admin/build/modules/uninstall':      return '<p>'. t('The uninstall process removes all data related to a module. To uninstall a module, you must first disable it. Not all modules support this feature.') .'</p>';    case 'admin/build/block/configure':      if ($arg[4] == 'system' && $arg[5] == 0) {        return '<p>'. t('The <em>Powered by Drupal</em> block is an optional link to the home page of the Drupal project. While there is absolutely no requirement that sites feature this link, it may be used to show support for Drupal.') .'</p>';      }      break;    case 'admin/settings/actions':    case 'admin/settings/actions/manage':      $output = '<p>'. t('Actions are individual tasks that the system can do, such as unpublishing a piece of content or banning a user. Modules, such as the trigger module, can fire these actions when certain system events happen; for example, when a new post is added or when a user logs in. Modules may also provide additional actions.') .'</p>';      $output .= '<p>'. t('There are two types of actions: simple and advanced. Simple actions do not require any additional configuration, and are listed here automatically. Advanced actions can do more than simple actions; for example, send an e-mail to a specified address, or check for certain words within a piece of content. These actions need to be created and configured first before they may be used. To create an advanced action, select the action from the drop-down below and click the <em>Create</em> button.') .'</p>';      if (module_exists('trigger')) {        $output .= '<p>'. t('You may proceed to the <a href="@url">Triggers</a> page to assign these actions to system events.', array('@url' => url('admin/build/trigger'))) .'</p>';      }      return $output;    case 'admin/settings/actions/configure':      return t('An advanced action offers additional configuration options which may be filled out below. Changing the <em>Description</em> field is recommended, in order to better identify the precise action taking place. This description will be displayed in modules such as the trigger module when assigning actions to system events, so it is best if it is as descriptive as possible (for example, "Send e-mail to Moderation Team" rather than simply "Send e-mail").');    case 'admin/reports/status':      return '<p>'. t("Here you can find a short overview of your site's parameters as well as any problems detected with your installation. It may be useful to copy and paste this information into support requests filed on drupal.org's support forums and project issue queues.") .'</p>';  }}/** * Implementation of hook_theme(). */function system_theme() {  return array_merge(drupal_common_theme(), array(    'system_theme_select_form' => array(      'arguments' => array('form' => NULL),      'file' => 'system.admin.inc',    ),    'system_themes_form' => array(      'arguments' => array('form' => NULL),      'file' => 'system.admin.inc',    ),    'system_modules' => array(      'arguments' => array('form' => NULL),      'file' => 'system.admin.inc',    ),    'system_modules_uninstall' => array(      'arguments' => array('form' => NULL),      'file' => 'system.admin.inc',    ),    'status_report' => array(      'arguments' => array('requirements' => NULL),      'file' => 'system.admin.inc',    ),    'admin_page' => array(      'arguments' => array('blocks' => NULL),      'file' => 'system.admin.inc',    ),    'admin_block' => array(      'arguments' => array('block' => NULL),      'file' => 'system.admin.inc',    ),    'admin_block_content' => array(      'arguments' => array('content' => NULL),      'file' => 'system.admin.inc',    ),    'system_admin_by_module' => array(      'arguments' => array('menu_items' => NULL),      'file' => 'system.admin.inc',    ),    'system_powered_by' => array(      'arguments' => array('image_path' => NULL),    ),  ));}/** * Implementation of hook_perm(). */function system_perm() {  return array('administer site configuration', 'access administration pages', 'administer actions', 'access site reports', 'select different theme', 'administer files');}/** * Implementation of hook_elements(). */function system_elements() {  // Top level form  $type['form'] = array('#method' => 'post', '#action' => request_uri());  // Inputs  $type['submit'] = array('#input' => TRUE, '#name' => 'op', '#button_type' => 'submit', '#executes_submit_callback' => TRUE, '#process' => array('form_expand_ahah'));  $type['button'] = array('#input' => TRUE, '#name' => 'op', '#button_type' => 'submit', '#executes_submit_callback' => FALSE, '#process' => array('form_expand_ahah'));  $type['image_button'] = array('#input' => TRUE, '#button_type' => 'submit', '#executes_submit_callback' => TRUE, '#process' => array('form_expand_ahah'), '#return_value' => TRUE, '#has_garbage_value' => TRUE, '#src' => NULL);  $type['textfield'] = array('#input' => TRUE, '#size' => 60, '#maxlength' => 128, '#autocomplete_path' => FALSE, '#process' => array('form_expand_ahah'));  $type['password'] = array('#input' => TRUE, '#size' => 60, '#maxlength' => 128, '#process' => array('form_expand_ahah'));  $type['password_confirm'] = array('#input' => TRUE, '#process' => array('expand_password_confirm'));  $type['textarea'] = array('#input' => TRUE, '#cols' => 60, '#rows' => 5, '#resizable' => TRUE, '#process' => array('form_expand_ahah'));  $type['radios'] = array('#input' => TRUE, '#process' => array('expand_radios'));  $type['radio'] = array('#input' => TRUE, '#default_value' => NULL, '#process' => array('form_expand_ahah'));  $type['checkboxes'] = array('#input' => TRUE, '#process' => array('expand_checkboxes'), '#tree' => TRUE);  $type['checkbox'] = array('#input' => TRUE, '#return_value' => 1, '#process' => array('form_expand_ahah'));  $type['select'] = array('#input' => TRUE, '#size' => 0, '#multiple' => FALSE, '#process' => array('form_expand_ahah'));  $type['weight'] = array('#input' => TRUE, '#delta' => 10, '#default_value' => 0, '#process' => array('process_weight', 'form_expand_ahah'));  $type['date'] = array('#input' => TRUE, '#process' => array('expand_date'), '#element_validate' => array('date_validate'));  $type['file'] = array('#input' => TRUE, '#size' => 60);  // Form structure  $type['item'] = array('#value' => '');  $type['hidden'] = array('#input' => TRUE, '#process' => array('form_expand_ahah'));  $type['value'] = array('#input' => TRUE);  $type['markup'] = array('#prefix' => '', '#suffix' => '');  $type['fieldset'] = array('#collapsible' => FALSE, '#collapsed' => FALSE, '#value' => NULL, '#process' => array('form_expand_ahah'));  $type['token'] = array('#input' => TRUE);  return $type;}/** * Implementation of hook_menu(). */function system_menu() {  $items['system/files'] = array(    'title' => 'File download',    'page callback' => 'file_download',    'access callback' => TRUE,    'type' => MENU_CALLBACK,  );  $items['admin'] = array(    'title' => 'Administer',    'access arguments' => array('access administration pages'),    'page callback' => 'system_main_admin_page',    'weight' => 9,    'file' => 'system.admin.inc',  );  $items['admin/compact'] = array(    'title' => 'Compact mode',    'page callback' => 'system_admin_compact_page',    'access arguments' => array('access administration pages'),    'type' => MENU_CALLBACK,    'file' => 'system.admin.inc',  );  $items['admin/by-task'] = array(    'title' => 'By task',    'page callback' => 'system_main_admin_page',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/by-module'] = array(    'title' => 'By module',    'page callback' => 'system_admin_by_module',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',    'type' => MENU_LOCAL_TASK,    'weight' => 2,  );  $items['admin/content'] = array(    'title' => 'Content management',    'description' => "Manage your site's content.",    'position' => 'left',    'weight' => -10,    'page callback' => 'system_admin_menu_block_page',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',  );  // menu items that are basically just menu blocks  $items['admin/settings'] = array(    'title' => 'Site configuration',    'description' => 'Adjust basic site configuration options.',    'position' => 'right',    'weight' => -5,    'page callback' => 'system_settings_overview',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',  );  $items['admin/build'] = array(    'title' => 'Site building',    'description' => 'Control how your site looks and feels.',    'position' => 'right',    'weight' => -10,    'page callback' => 'system_admin_menu_block_page',    'access arguments' => array('access administration pages'),    'file' => 'system.admin.inc',  );  $items['admin/settings/admin'] = array(    'title' => 'Administration theme',    'description' => 'Settings for how your administrative pages should look.',    'position' => 'left',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_admin_theme_settings'),    'access arguments' => array('administer site configuration'),    'block callback' => 'system_admin_theme_settings',    'file' => 'system.admin.inc',  );  // Themes:  $items['admin/build/themes'] = array(    'title' => 'Themes',    'description' => 'Change which theme your site uses or allows users to set.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_themes_form', NULL),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/build/themes/select'] = array(    'title' => 'List',    'description' => 'Select the default theme.',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -1,  );  $items['admin/build/themes/settings'] = array(    'title' => 'Configure',    'page arguments' => array('system_theme_settings'),    'access arguments' => array('administer site configuration'),    'type' => MENU_LOCAL_TASK,  );  // Theme configuration subtabs  $items['admin/build/themes/settings/global'] = array(    'title' => 'Global settings',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -1,  );  foreach (list_themes() as $theme) {    $items['admin/build/themes/settings/'. $theme->name] = array(      'title' => $theme->info['name'],      'page arguments' => array('system_theme_settings', $theme->name),      'type' => MENU_LOCAL_TASK,      'access callback' => '_system_themes_access',      'access arguments' => array($theme),    );  }  // Modules:  $items['admin/build/modules'] = array(    'title' => 'Modules',    'description' => 'Enable or disable add-on modules for your site.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_modules'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/build/modules/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/build/modules/list/confirm'] = array(    'title' => 'List',    'access arguments' => array('administer site configuration'),    'type' => MENU_CALLBACK,  );  $items['admin/build/modules/uninstall'] = array(    'title' => 'Uninstall',    'page arguments' => array('system_modules_uninstall'),    'access arguments' => array('administer site configuration'),    'type' => MENU_LOCAL_TASK,  );  $items['admin/build/modules/uninstall/confirm'] = array(    'title' => 'Uninstall',    'access arguments' => array('administer site configuration'),    'type' => MENU_CALLBACK,  );  // Actions:  $items['admin/settings/actions'] = array(    'title' => 'Actions',    'description' => 'Manage the actions defined for your site.',    'access arguments' => array('administer actions'),    'page callback' => 'system_actions_manage'  );  $items['admin/settings/actions/manage'] = array(    'title' => 'Manage actions',    'description' => 'Manage the actions defined for your site.',    'page callback' => 'system_actions_manage',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -2,  );  $items['admin/settings/actions/configure'] = array(    'title' => 'Configure an advanced action',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_actions_configure'),    'access arguments' => array('administer actions'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/actions/delete/%actions'] = array(    'title' => 'Delete action',    'description' => 'Delete an action.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_actions_delete_form', 4),    'access arguments' => array('administer actions'),    'type' => MENU_CALLBACK,  );  $items['admin/settings/actions/orphan'] = array(    'title' => 'Remove orphans',    'page callback' => 'system_actions_remove_orphans',    'access arguments' => array('administer actions'),    'type' => MENU_CALLBACK,  );  // Settings:  $items['admin/settings/site-information'] = array(    'title' => 'Site information',    'description' => 'Change basic site information, such as the site name, slogan, e-mail address, mission, front page and more.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_site_information_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/error-reporting'] = array(    'title' => 'Error reporting',    'description' => 'Control how Drupal deals with errors including 403/404 errors as well as PHP error reporting.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_error_reporting_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/logging'] = array(    'title' => 'Logging and alerts',    'description' => "Settings for logging and alerts modules. Various modules can route Drupal's system events to different destination, such as syslog, database, email, ...etc.",    'page callback' => 'system_logging_overview',    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/performance'] = array(    'title' => 'Performance',    'description' => 'Enable or disable page caching for anonymous users and set CSS and JS bandwidth optimization options.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_performance_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/file-system'] = array(    'title' => 'File system',    'description' => 'Tell Drupal where to store uploaded files and how they are accessed.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_file_system_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/image-toolkit'] = array(    'title' => 'Image toolkit',    'description' => 'Choose which image toolkit to use if you have installed optional toolkits.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_image_toolkit_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/content/rss-publishing'] = array(    'title' => 'RSS publishing',    'description' => 'Configure the number of items per feed and whether feeds should be titles/teasers/full-text.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_rss_feeds_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/date-time'] = array(    'title' => 'Date and time',    'description' => "Settings for how Drupal displays date and time, as well as the system's default timezone.",    'page callback' => 'drupal_get_form',    'page arguments' => array('system_date_time_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/date-time/lookup'] = array(    'title' => 'Date and time lookup',    'type' => MENU_CALLBACK,    'page callback' => 'system_date_time_lookup',    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/site-maintenance'] = array(    'title' => 'Site maintenance',    'description' => 'Take the site off-line for maintenance or bring it back online.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_site_maintenance_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/clean-urls'] = array(    'title' => 'Clean URLs',    'description' => 'Enable or disable clean URLs for your site.',    'page callback' => 'drupal_get_form',    'page arguments' => array('system_clean_url_settings'),    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/settings/clean-urls/check'] = array(    'title' => 'Clean URL check',    'page callback' => 'drupal_json',    'page arguments' => array(array('status' => TRUE)),    'access callback' => TRUE,    'type' => MENU_CALLBACK,  );  // Reports:  $items['admin/reports'] = array(    'title' => 'Reports',    'description' => 'View reports from system logs and other status information.',    'page callback' => 'system_admin_menu_block_page',    'access arguments' => array('access site reports'),    'weight' => 5,    'position' => 'left',    'file' => 'system.admin.inc',  );  $items['admin/reports/status'] = array(    'title' => 'Status report',    'description' => "Get a status report about your site's operation and any detected problems.",    'page callback' => 'system_status',    'weight' => 10,    'access arguments' => array('administer site configuration'),    'file' => 'system.admin.inc',  );  $items['admin/reports/status/run-cron'] = array(    'title' => 'Run cron',    'page callback' => 'system_run_cron',    'access arguments' => array('administer site configuration'),    'type' => MENU_CALLBACK,    'file' => 'system.admin.inc',  );  $items['admin/reports/status/php'] = array(    'title' => 'PHP',    'page callback' => 'system_php',    'access arguments' => array('administer site configuration'),    'type' => MENU_CALLBACK,    'file' => 'system.admin.inc',  );  $items['admin/reports/status/sql'] = array(    'title' => 'SQL',    'page callback' => 'system_sql',    'access arguments' => array('administer site configuration'),    'type' => MENU_CALLBACK,    'file' => 'system.admin.inc',  );  // Default page for batch operations  $items['batch'] = array(    'page callback' => 'system_batch_page',    'access callback' => TRUE,    'type' => MENU_CALLBACK,    'file' => 'system.admin.inc',  );  return $items;}/** * Menu item access callback - only admin or enabled themes can be accessed. */function _system_themes_access($theme) {  return user_access('administer site configuration') && ($theme->status || $theme->name == variable_get('admin_theme', '0'));}/** * Implementation of hook_init(). */function system_init() {  // Use the administrative theme if the user is looking at a page in the admin/* path.  if (arg(0) == 'admin' || (variable_get('node_admin_theme', '0') && arg(0) == 'node' && (arg(1) == 'add' || arg(2) == 'edit'))) {    global $custom_theme;    $custom_theme = variable_get('admin_theme', '0');    drupal_add_css(drupal_get_path('module', 'system') .'/admin.css', 'module');  }  // Add the CSS for this module.  drupal_add_css(drupal_get_path('module', 'system') .'/defaults.css', 'module');  drupal_add_css(drupal_get_path('module', 'system') .'/system.css', 'module');  drupal_add_css(drupal_get_path('module', 'system') .'/system-menus.css', 'module');}/** * Implementation of hook_user(). * * Allows users to individually set their theme and time zone. */function system_user($type, $edit, &$user, $category = NULL) {  if ($type == 'form' && $category == 'account') {    $form['theme_select'] = system_theme_select_form(t('Selecting a different theme will change the look and feel of the site.'), isset($edit['theme']) ? $edit['theme'] : NULL, 2);    if (variable_get('configurable_timezones', 1)) {      $zones = _system_zonelist();      $form['timezone'] = array(        '#type' => 'fieldset',        '#title' => t('Locale settings'),        '#weight' => 6,        '#collapsible' => TRUE,      );      $form['timezone']['timezone'] = array(        '#type' => 'select',        '#title' => t('Time zone'),        '#default_value' => strlen($edit['timezone']) ? $edit['timezone'] : variable_get('date_default_timezone', 0),        '#options' => $zones,        '#description' => t('Select your current local time. Dates and times throughout this site will be displayed using this time zone.'),      );    }    return $form;  }}/** * Implementation of hook_block(). * * Generate a block with a promotional link to Drupal.org. */function system_block($op = 'list', $delta = 0, $edit = NULL) {  switch ($op) {    case 'list':      $blocks[0] = array(        'info' => t('Powered by Drupal'),        'weight' => '10',         // Not worth caching.        'cache' => BLOCK_NO_CACHE,      );      return $blocks;    case 'configure':      // Compile a list of fields to show      $form['wrapper']['color'] = array(        '#type' => 'select',        '#title' => t('Badge color'),        '#default_value' => variable_get('drupal_badge_color', 'powered-blue'),        '#options' => array('powered-black' => t('Black'), 'powered-blue' => t('Blue'), 'powered-gray' => t('Gray')),      );      $form['wrapper']['size'] = array(        '#type' => 'select',        '#title' => t('Badge size'),        '#default_value' => variable_get('drupal_badge_size', '80x15'),        '#options' => array('80x15' => t('Small'), '88x31' => t('Medium'), '135x42' => t('Large')),      );      return $form;    case 'save':      variable_set('drupal_badge_color', $edit['color']);      variable_set('drupal_badge_size', $edit['size']);      break;    case 'view':      $image_path = 'misc/'. variable_get('drupal_badge_color', 'powered-blue') .'-'. variable_get('drupal_badge_size', '80x15') .'.png';      $block['subject'] = NULL; // Don't display a title      $block['content'] = theme('system_powered_by', $image_path);      return $block;  }}/** * Provide a single block on the administration overview page. * * @param $item *   The menu item to be displayed. */function system_admin_menu_block($item) {  $content = array();  if (!isset($item['mlid'])) {    $item += db_fetch_array(db_query("SELECT mlid, menu_name FROM {menu_links} ml WHERE ml.router_path = '%s' AND module = 'system'", $item['path']));  }  $result = db_query("    SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, m.description, ml.*    FROM {menu_links} ml    LEFT JOIN {menu_router} m ON ml.router_path = m.path    WHERE ml.plid = %d AND ml.menu_name = '%s' AND hidden = 0", $item['mlid'], $item['menu_name']);  while ($item = db_fetch_array($result)) {    _menu_link_translate($item);    if (!$item['access']) {      continue;    }    // The link 'description' either derived from the hook_menu 'description' or    // entered by the user via menu module is saved as the title attribute.    if (!empty($item['localized_options']['attributes']['title'])) {      $item['description'] = $item['localized_options']['attributes']['title'];    }    // Prepare for sorting as in function _menu_tree_check_access().    // The weight is offset so it is always positive, with a uniform 5-digits.    $content[(50000 + $item['weight']) .' '. drupal_strtolower($item['title']) .' '. $item['mlid']] = $item;  }  ksort($content);  return $content;}/** * Process admin theme form submissions. */function system_admin_theme_submit($form, &$form_state) {  // If we're changing themes, make sure the theme has its blocks initialized.  if ($form_state['values']['admin_theme'] && $form_state['values']['admin_theme'] != variable_get('admin_theme', '0')) {    $result = db_result(db_query("SELECT COUNT(*) FROM {blocks} WHERE theme = '%s'", $form_state['values']['admin_theme']));    if (!$result) {      system_initialize_theme_blocks($form_state['values']['admin_theme']);    }  }}/** * Returns a fieldset containing the theme select form. * * @param $description *    description of the fieldset * @param $default_value *    default value of theme radios * @param $weight *    weight of the fieldset * @return *    a form array */function system_theme_select_form($description = '', $default_value = '', $weight = 0) {  if (user_access('select different theme')) {    $enabled = array();    $themes = list_themes();    foreach ($themes as $theme) {      if ($theme->status) {        $enabled[] = $theme;      }    }    if (count($enabled) > 1) {      ksort($enabled);      $form['themes'] = array(        '#type' => 'fieldset',        '#title' => t('Theme configuration'),        '#description' => $description,        '#collapsible' => TRUE,        '#theme' => 'system_theme_select_form'      );      foreach ($enabled as $info) {        // For the default theme, revert to an empty string so the user's theme updates when the site theme is changed.        $info->key = $info->name == variable_get('theme_default', 'garland') ? '' : $info->name;        $screenshot = NULL;        $theme_key = $info->name;        while ($theme_key) {          if (file_exists($themes[$theme_key]->info['screenshot'])) {            $screenshot = $themes[$theme_key]->info['screenshot'];            break;          }          $theme_key = isset($themes[$theme_key]->info['base theme']) ? $themes[$theme_key]->info['base theme'] : NULL;        }        $screenshot = $screenshot ? theme('image', $screenshot, t('Screenshot for %theme theme', array('%theme' => $info->name)), '', array('class' => 'screenshot'), FALSE) : t('no screenshot');        $form['themes'][$info->key]['screenshot'] = array('#value' => $screenshot);        $form['themes'][$info->key]['description'] = array('#type' => 'item', '#title' => $info->name, '#value' => dirname($info->filename) . ($info->name == variable_get('theme_default', 'garland') ? '<br /> <em>'. t('(site default theme)') .'</em>' : ''));        $options[$info->key] = '';      }      $form['themes']['theme'] = array('#type' => 'radios', '#options' => $options, '#default_value' => $default_value ? $default_value : '');      $form['#weight'] = $weight;      return $form;    }  }}/** * Checks the existence of the directory specified in $form_element. This * function is called from the system_settings form to check both the * file_directory_path and file_directory_temp directories. If validation * fails, the form element is flagged with an error from within the * file_check_directory function. * * @param $form_element *   The form element containing the name of the directory to check. */function system_check_directory($form_element) {  file_check_directory($form_element['#value'], FILE_CREATE_DIRECTORY, $form_element['#parents'][0]);  return $form_element;}/** * Retrieves the current status of an array of files in the system table. * * @param $files *   An array of files to check. * @param $type *   The type of the files. */function system_get_files_database(&$files, $type) {  // Extract current files from database.  $result = db_query("SELECT filename, name, type, status, throttle, schema_version FROM {system} WHERE type = '%s'", $type);  while ($file = db_fetch_object($result)) {    if (isset($files[$file->name]) && is_object($files[$file->name])) {      $file->old_filename = $file->filename;      foreach ($file as $key => $value) {        if (!isset($files[$file->name]) || !isset($files[$file->name]->$key)) {          $files[$file->name]->$key = $value;        }      }    }  }}/** * Prepare defaults for themes. * * @return *   An array of default themes settings. */function system_theme_default() {  return array(    'regions' => array(      'left' => 'Left sidebar',      'right' => 'Right sidebar',      'content' => 'Content',      'header' => 'Header',      'footer' => 'Footer',    ),    'description' => '',    'features' => array(      'comment_user_picture',      'favicon',      'mission',      'logo',      'name',      'node_user_picture',      'search',      'slogan',      'primary_links',      'secondary_links',    ),    'stylesheets' => array(      'all' => array('style.css')    ),    'scripts' => array('script.js'),    'screenshot' => 'screenshot.png',    'php' => DRUPAL_MINIMUM_PHP,  );}/** * Collect data about all currently available themes. * * @return *   Array of all available themes and their data. */function system_theme_data() {  // Scan the installation theme .info files and their engines.  $themes = _system_theme_data();  // Extract current files from database.  system_get_files_database($themes, 'theme');  db_query("DELETE FROM {system} WHERE type = 'theme'");  foreach ($themes as $theme) {    if (!isset($theme->owner)) {      $theme->owner = '';    }    db_query("INSERT INTO {system} (name, owner, info, type, filename, status, throttle, bootstrap) VALUES ('%s', '%s', '%s', '%s', '%s', %d, %d, %d)", $theme->name, $theme->owner, serialize($theme->info), 'theme', $theme->filename, isset($theme->status) ? $theme->status : 0, 0, 0);  }  return $themes;}/** * Helper function to scan and collect theme .info data and their engines. * * @return *   An associative array of themes information. */function _system_theme_data() {  static $themes_info = array();  if (empty($themes_info)) {    // Find themes    $themes = drupal_system_listing('\.info$', 'themes');    // Find theme engines    $engines = drupal_system_listing('\.engine$', 'themes/engines');    $defaults = system_theme_default();    $sub_themes = array();    // Read info files for each theme    foreach ($themes as $key => $theme) {      $themes[$key]->info = drupal_parse_info_file($theme->filename) + $defaults;      // Invoke hook_system_info_alter() to give installed modules a chance to      // modify the data in the .info files if necessary.      drupal_alter('system_info', $themes[$key]->info, $themes[$key]);      if (!empty($themes[$key]->info['base theme'])) {        $sub_themes[] = $key;      }      if (empty($themes[$key]->info['engine'])) {        $filename = dirname($themes[$key]->filename) .'/'. $themes[$key]->name .'.theme';        if (file_exists($filename)) {          $themes[$key]->owner = $filename;          $themes[$key]->prefix = $key;        }      }      else {        $engine = $themes[$key]->info['engine'];        if (isset($engines[$engine])) {          $themes[$key]->owner = $engines[$engine]->filename;          $themes[$key]->prefix = $engines[$engine]->name;          $themes[$key]->template = TRUE;        }      }      // Give the stylesheets proper path information.      $pathed_stylesheets = array();      foreach ($themes[$key]->info['stylesheets'] as $media => $stylesheets) {        foreach ($stylesheets as $stylesheet) {          $pathed_stylesheets[$media][$stylesheet] = dirname($themes[$key]->filename) .'/'. $stylesheet;        }      }      $themes[$key]->info['stylesheets'] = $pathed_stylesheets;      // Give the scripts proper path information.      $scripts = array();      foreach ($themes[$key]->info['scripts'] as $script) {        $scripts[$script] = dirname($themes[$key]->filename) .'/'. $script;      }      $themes[$key]->info['scripts'] = $scripts;      // Give the screenshot proper path information.      if (!empty($themes[$key]->info['screenshot'])) {        $themes[$key]->info['screenshot'] = dirname($themes[$key]->filename) .'/'. $themes[$key]->info['screenshot'];      }    }    // Now that we've established all our master themes, go back and fill in    // data for subthemes.    foreach ($sub_themes as $key) {      $themes[$key]->base_themes = system_find_base_themes($themes, $key);      // Don't proceed if there was a problem with the root base theme.      if (!current($themes[$key]->base_themes)) {        continue;      }      $base_key = key($themes[$key]->base_themes);      foreach (array_keys($themes[$key]->base_themes) as $base_theme) {        $themes[$base_theme]->sub_themes[$key] = $themes[$key]->info['name'];      }      // Copy the 'owner' and 'engine' over if the top level theme uses a      // theme engine.      if (isset($themes[$base_key]->owner)) {        if (isset($themes[$base_key]->info['engine'])) {          $themes[$key]->info['engine'] = $themes[$base_key]->info['engine'];          $themes[$key]->owner = $themes[$base_key]->owner;          $themes[$key]->prefix = $themes[$base_key]->prefix;        }        else {          $themes[$key]->prefix = $key;        }      }    }    $themes_info = $themes;  }  return $themes_info;}/** * Find all the base themes for the specified theme. * * Themes can inherit templates and function implementations from earlier themes. * * @param $themes *   An array of available themes. * @param $key *   The name of the theme whose base we are looking for. * @param $used_keys *   A recursion parameter preventing endless loops. * @return *   Returns an array of all of the theme's ancestors; the first element's value *   will be NULL if an error occurred. */function system_find_base_themes($themes, $key, $used_keys = array()) {  $base_key = $themes[$key]->info['base theme'];  // Does the base theme exist?  if (!isset($themes[$base_key])) {    return array($base_key => NULL);  }  $current_base_theme = array($base_key => $themes[$base_key]->info['name']);  // Is the base theme itself a child of another theme?  if (isset($themes[$base_key]->info['base theme'])) {    // Do we already know the base themes of this theme?    if (isset($themes[$base_key]->base_themes)) {      return $themes[$base_key]->base_themes + $current_base_theme;    }    // Prevent loops.    if (!empty($used_keys[$base_key])) {      return array($base_key => NULL);    }    $used_keys[$base_key] = TRUE;    return system_find_base_themes($themes, $base_key, $used_keys) + $current_base_theme;  }  // If we get here, then this is our parent theme.  return $current_base_theme;}/** * This function has been deprecated in favor of system_find_base_themes(). * * Recursive function to find the top level base theme. Themes can inherit * templates and function implementations from earlier themes. * * @param $themes *   An array of available themes. * @param $key *   The name of the theme whose base we are looking for. * @param $used_keys *   A recursion parameter preventing endless loops. * @return *   Returns the top level parent that has no ancestor or returns NULL if there isn't a valid parent. */function system_find_base_theme($themes, $key, $used_keys = array()) {  $base_key = $themes[$key]->info['base theme'];  // Does the base theme exist?  if (!isset($themes[$base_key])) {    return NULL;  }  // Is the base theme itself a child of another theme?  if (isset($themes[$base_key]->info['base theme'])) {    // Prevent loops.    if (!empty($used_keys[$base_key])) {      return NULL;    }    $used_keys[$base_key] = TRUE;    return system_find_base_theme($themes, $base_key, $used_keys);  }  // If we get here, then this is our parent theme.  return $base_key;}/** * Get a list of available regions from a specified theme. * * @param $theme_key *   The name of a theme. * @return *   An array of regions in the form $region['name'] = 'description'. */function system_region_list($theme_key) {  static $list = array();  if (!array_key_exists($theme_key, $list)) {    $info = unserialize(db_result(db_query("SELECT info FROM {system} WHERE type = 'theme' AND name = '%s'", $theme_key)));    $list[$theme_key] = array_map('t', $info['regions']);  }  return $list[$theme_key];}/** * Get the name of the default region for a given theme. * * @param $theme *   The name of a theme. * @return *   A string that is the region name. */function system_default_region($theme) {  $regions = array_keys(system_region_list($theme));  return isset($regions[0]) ? $regions[0] : '';}/** * Assign an initial, default set of blocks for a theme. * * This function is called the first time a new theme is enabled. The new theme * gets a copy of the default theme's blocks, with the difference that if a * particular region isn't available in the new theme, the block is assigned * to the new theme's default region. * * @param $theme *   The name of a theme. */function system_initialize_theme_blocks($theme) {  // Initialize theme's blocks if none already registered.  if (!(db_result(db_query("SELECT COUNT(*) FROM {blocks} WHERE theme = '%s'", $theme)))) {    $default_theme = variable_get('theme_default', 'garland');    $regions = system_region_list($theme);    $result = db_query("SELECT * FROM {blocks} WHERE theme = '%s'", $default_theme);    while ($block = db_fetch_array($result)) {      // If the region isn't supported by the theme, assign the block to the theme's default region.      if (!array_key_exists($block['region'], $regions)) {        $block['region'] = system_default_region($theme);      }      db_query("INSERT INTO {blocks} (module, delta, theme, status, weight, region, visibility, pages, custom, throttle, cache) VALUES ('%s', '%s', '%s', %d, %d, '%s', %d, '%s', %d, %d, %d)",          $block['module'], $block['delta'], $theme, $block['status'], $block['weight'], $block['region'], $block['visibility'], $block['pages'], $block['custom'], $block['throttle'], $block['cache']);    }  }}/** * Add default buttons to a form and set its prefix. * * @ingroup forms * @see system_settings_form_submit() * @param $form *   An associative array containing the structure of the form. * @return *   The form structure. */function system_settings_form($form) {  $form['buttons']['submit'] = array('#type' => 'submit', '#value' => t('Save configuration') );  $form['buttons']['reset'] = array('#type' => 'submit', '#value' => t('Reset to defaults') );  if (!empty($_POST) && form_get_errors()) {    drupal_set_message(t('The settings have not been saved because of the errors.'), 'error');  }  $form['#submit'][] = 'system_settings_form_submit';  $form['#theme'] = 'system_settings_form';  return $form;}/** * Execute the system_settings_form. * * If you want node type configure style handling of your checkboxes, * add an array_filter value to your form. */function system_settings_form_submit($form, &$form_state) {  $op = isset($form_state['values']['op']) ? $form_state['values']['op'] : '';  // Exclude unnecessary elements.  unset($form_state['values']['submit'], $form_state['values']['reset'], $form_state['values']['form_id'], $form_state['values']['op'], $form_state['values']['form_token'], $form_state['values']['form_build_id']);  foreach ($form_state['values'] as $key => $value) {    if ($op == t('Reset to defaults')) {      variable_del($key);    }    else {      if (is_array($value) && isset($form_state['values']['array_filter'])) {        $value = array_keys(array_filter($value));      }      variable_set($key, $value);    }  }  if ($op == t('Reset to defaults')) {    drupal_set_message(t('The configuration options have been reset to their default values.'));  }  else {    drupal_set_message(t('The configuration options have been saved.'));  }  cache_clear_all();  drupal_rebuild_theme_registry();}/** * Helper function to sort requirements. */function _system_sort_requirements($a, $b) {  if (!isset($a['weight'])) {    if (!isset($b['weight'])) {      return strcmp($a['title'], $b['title']);    }    return -$b['weight'];  }  return isset($b['weight']) ? $a['weight'] - $b['weight'] : $a['weight'];}/** * Implementation of hook_node_type(). * * Updates theme settings after a node type change. */function system_node_type($op, $info) {  if ($op == 'update' && !empty($info->old_type) && $info->type != $info->old_type) {    $old = 'toggle_node_info_'. $info->old_type;    $new = 'toggle_node_info_'. $info->type;    $theme_settings = variable_get('theme_settings', array());    if (isset($theme_settings[$old])) {      $theme_settings[$new] = $theme_settings[$old];      unset($theme_settings[$old]);      variable_set('theme_settings', $theme_settings);    }  }}/** * Output a confirmation form * * This function returns a complete form for confirming an action. A link is * offered to go back to the item that is being changed in case the user changes * his/her mind. * * If the submit handler for this form is invoked, the user successfully * confirmed the action. You should never directly inspect $_POST to see if an * action was confirmed. * * @ingroup forms * @param $form *   Additional elements to inject into the form, for example hidden elements. * @param $question *   The question to ask the user (e.g. "Are you sure you want to delete the *   block <em>foo</em>?"). * @param $path *   The page to go to if the user denies the action. *   Can be either a drupal path, or an array with the keys 'path', 'query', 'fragment'. * @param $description *   Additional text to display (defaults to "This action cannot be undone."). * @param $yes *   A caption for the button which confirms the action (e.g. "Delete", *   "Replace", ...). * @param $no *   A caption for the link which denies the action (e.g. "Cancel"). * @param $name *   The internal name used to refer to the confirmation item. * @return *   The form. */function confirm_form($form, $question, $path, $description = NULL, $yes = NULL, $no = NULL, $name = 'confirm') {  $description = isset($description) ? $description : t('This action cannot be undone.');  // Prepare cancel link  $query = $fragment = NULL;  if (is_array($path)) {    $query = isset($path['query']) ? $path['query'] : NULL;    $fragment = isset($path['fragment']) ? $path['fragment'] : NULL;    $path = isset($path['path']) ? $path['path'] : NULL;  }  $cancel = l($no ? $no : t('Cancel'), $path, array('query' => $query, 'fragment' => $fragment));  drupal_set_title($question);  // Confirm form fails duplication check, as the form values rarely change -- so skip it.  $form['#skip_duplicate_check'] = TRUE;  $form['#attributes'] = array('class' => 'confirmation');  $form['description'] = array('#value' => $description);  $form[$name] = array('#type' => 'hidden', '#value' => 1);  $form['actions'] = array('#prefix' => '<div class="container-inline">', '#suffix' => '</div>');  $form['actions']['submit'] = array('#type' => 'submit', '#value' => $yes ? $yes : t('Confirm'));  $form['actions']['cancel'] = array('#value' => $cancel);  $form['#theme'] = 'confirm_form';  return $form;}/** * Determine if a user is in compact mode. */function system_admin_compact_mode() {  global $user;  return (isset($user->admin_compact_mode)) ? $user->admin_compact_mode : variable_get('admin_compact_mode', FALSE);}/** * Generate a list of tasks offered by a specified module. * * @param $module *   Module name. * @return *   An array of task links. */function system_get_module_admin_tasks($module) {  static $items;  $admin_access = user_access('administer permissions');  $admin_tasks = array();  if (!isset($items)) {    $result = db_query("       SELECT m.load_functions, m.to_arg_functions, m.access_callback, m.access_arguments, m.page_callback, m.page_arguments, m.title, m.title_callback, m.title_arguments, m.type, ml.*       FROM {menu_links} ml INNER JOIN {menu_router} m ON ml.router_path = m.path WHERE ml.link_path LIKE 'admin/%' AND hidden >= 0 AND module = 'system' AND m.number_parts > 2");    $items = array();    while ($item = db_fetch_array($result)) {      _menu_link_translate($item);      if ($item['access']) {        $items[$item['router_path']] = $item;      }    }  }  $admin_tasks = array();  $admin_task_count = 0;  // Check for permissions.  if (module_hook($module, 'perm') && $admin_access) {    $admin_tasks[-1] = l(t('Configure permissions'), 'admin/user/permissions', array('fragment' => 'module-'. $module));  }  // Check for menu items that are admin links.  if ($menu = module_invoke($module, 'menu')) {    foreach (array_keys($menu) as $path) {      if (isset($items[$path])) {        $admin_tasks[$items[$path]['title'] . $admin_task_count ++] = l($items[$path]['title'], $path);      }    }  }  return $admin_tasks;}/** * Implementation of hook_cron(). * * Remove older rows from flood and batch table. Remove old temporary files. */function system_cron() {  // Cleanup the flood.  db_query('DELETE FROM {flood} WHERE timestamp < %d', time() - 3600);  // Cleanup the batch table.  db_query('DELETE FROM {batch} WHERE timestamp < %d', time() - 864000);  // Remove temporary files that are older than DRUPAL_MAXIMUM_TEMP_FILE_AGE.  $result = db_query('SELECT * FROM {files} WHERE status = %d and timestamp < %d', FILE_STATUS_TEMPORARY, time() - DRUPAL_MAXIMUM_TEMP_FILE_AGE);  while ($file = db_fetch_object($result)) {    if (file_exists($file->filepath)) {      // If files that exist cannot be deleted, continue so the database remains      // consistent.      if (!file_delete($file->filepath)) {        watchdog('file system', 'Could not delete temporary file "%path" during garbage collection', array('%path' => $file->filepath), 'error');        continue;      }    }    db_query('DELETE FROM {files} WHERE fid = %d', $file->fid);  }  $core = array('cache', 'cache_block', 'cache_filter', 'cache_page', 'cache_form', 'cache_menu');  $cache_tables = array_merge(module_invoke_all('flush_caches'), $core);  foreach ($cache_tables as $table) {    cache_clear_all(NULL, $table);  }}/** * Implementation of hook_hook_info(). */function system_hook_info() {  return array(    'system' => array(      'cron' => array(        'run' => array(          'runs when' => t('When cron runs'),        ),      ),    ),  );}/** * Implementation of hook_action_info(). */function system_action_info() {  return array(    'system_message_action' => array(      'type' => 'system',      'description' => t('Display a message to the user'),      'configurable' => TRUE,      'hooks' => array(        'nodeapi' => array('view', 'insert', 'update', 'delete'),        'comment' => array('view', 'insert', 'update', 'delete'),        'user' => array('view', 'insert', 'update', 'delete', 'login'),        'taxonomy' => array('insert', 'update', 'delete'),      ),    ),    'system_send_email_action' => array(      'description' => t('Send e-mail'),      'type' => 'system',      'configurable' => TRUE,      'hooks' => array(        'nodeapi' => array('view', 'insert', 'update', 'delete'),        'comment' => array('view', 'insert', 'update', 'delete'),        'user' => array('view', 'insert', 'update', 'delete', 'login'),        'taxonomy' => array('insert', 'update', 'delete'),      )    ),    'system_goto_action' => array(      'description' => t('Redirect to URL'),      'type' => 'system',      'configurable' => TRUE,      'hooks' => array(        'nodeapi' => array('view', 'insert', 'update', 'delete'),        'comment' => array('view', 'insert', 'update', 'delete'),        'user' => array('view', 'insert', 'update', 'delete', 'login'),      )    )  );}/** * Menu callback. Display an overview of available and configured actions. */function system_actions_manage() {  $output = '';  $actions = actions_list();  actions_synchronize($actions);  $actions_map = actions_actions_map($actions);  $options = array(t('Choose an advanced action'));  $unconfigurable = array();  foreach ($actions_map as $key => $array) {    if ($array['configurable']) {      $options[$key] = $array['description'] .'...';    }    else {      $unconfigurable[] = $array;    }  }  $row = array();  $instances_present = db_fetch_object(db_query("SELECT aid FROM {actions} WHERE parameters <> ''"));  $header = array(    array('data' => t('Action type'), 'field' => 'type'),    array('data' => t('Description'), 'field' => 'description'),    array('data' => $instances_present ? t('Operations') : '', 'colspan' => '2')  );  $sql = 'SELECT * FROM {actions}';  $result = pager_query($sql . tablesort_sql($header), 50);  while ($action = db_fetch_object($result)) {    $row[] = array(      array('data' => $action->type),      array('data' => $action->description),      array('data' => $action->parameters ? l(t('configure'), "admin/settings/actions/configure/$action->aid") : ''),      array('data' => $action->parameters ? l(t('delete'), "admin/settings/actions/delete/$action->aid") : '')    );  }  if ($row) {    $pager = theme('pager', NULL, 50, 0);    if (!empty($pager)) {      $row[] = array(array('data' => $pager, 'colspan' => '3'));    }    $output .= '<h3>'. t('Actions available to Drupal:') .'</h3>';    $output .= theme('table', $header, $row);  }  if ($actions_map) {    $output .= drupal_get_form('system_actions_manage_form', $options);  }  return $output;}/** * Define the form for the actions overview page. * * @see system_actions_manage_form_submit() * @ingroup forms * @param $form_state *   An associative array containing the current state of the form; not used. * @param $options *   An array of configurable actions. * @return *   Form definition. */function system_actions_manage_form($form_state, $options = array()) {  $form['parent'] = array(    '#type' => 'fieldset',    '#title' => t('Make a new advanced action available'),    '#prefix' => '<div class="container-inline">',    '#suffix' => '</div>',  );  $form['parent']['action'] = array(    '#type' => 'select',    '#default_value' => '',    '#options' => $options,    '#description' => '',  );  $form['parent']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Create'),  );  return $form;}/** * Process system_actions_manage form submissions. */function system_actions_manage_form_submit($form, &$form_state) {  if ($form_state['values']['action']) {    $form_state['redirect'] = 'admin/settings/actions/configure/'. $form_state['values']['action'];  }}/** * Menu callback. Create the form for configuration of a single action. * * We provide the "Description" field. The rest of the form * is provided by the action. We then provide the Save button. * Because we are combining unknown form elements with the action * configuration form, we use actions_ prefix on our elements. * * @see system_actions_configure_validate() * @see system_actions_configure_submit() * @param $action *   md5 hash of action ID or an integer. If it's an md5 hash, we *   are creating a new instance. If it's an integer, we're editing *   an existing instance. * @return *   Form definition. */function system_actions_configure($form_state, $action = NULL) {  if ($action === NULL) {    drupal_goto('admin/settings/actions');  }  $actions_map = actions_actions_map(actions_list());  $edit = array();  // Numeric action denotes saved instance of a configurable action;  // else we are creating a new action instance.  if (is_numeric($action)) {    $aid = $action;    // Load stored parameter values from database.    $data = db_fetch_object(db_query("SELECT * FROM {actions} WHERE aid = '%s'", $aid));    $edit['actions_description'] = $data->description;    $edit['actions_type'] = $data->type;    $function = $data->callback;    $action = md5($data->callback);    $params = unserialize($data->parameters);    if ($params) {      foreach ($params as $name => $val) {        $edit[$name] = $val;      }    }  }  else {    $function = $actions_map[$action]['callback'];    $edit['actions_description'] = $actions_map[$action]['description'];    $edit['actions_type'] = $actions_map[$action]['type'];  }  $form['actions_description'] = array(    '#type' => 'textfield',    '#title' => t('Description'),    '#default_value' => $edit['actions_description'],    '#maxlength' => '255',    '#description' => t('A unique description for this advanced action. This description will be displayed in the interface of modules that integrate with actions, such as Trigger module.'),    '#weight' => -10  );  $action_form = $function .'_form';  $form = array_merge($form, $action_form($edit));  $form['actions_type'] = array(    '#type' => 'value',    '#value' => $edit['actions_type'],  );  $form['actions_action'] = array(    '#type' => 'hidden',    '#value' => $action,  );  // $aid is set when configuring an existing action instance.  if (isset($aid)) {    $form['actions_aid'] = array(      '#type' => 'hidden',      '#value' => $aid,    );  }  $form['actions_configured'] = array(    '#type' => 'hidden',    '#value' => '1',  );  $form['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => t('Save'),    '#weight' => 13  );  return $form;}/** * Validate system_actions_configure form submissions. */function system_actions_configure_validate($form, $form_state) {  $function = actions_function_lookup($form_state['values']['actions_action']) .'_validate';  // Hand off validation to the action.  if (function_exists($function)) {    $function($form, $form_state);  }}/** * Process system_actions_configure form submissions. */function system_actions_configure_submit($form, &$form_state) {  $function = actions_function_lookup($form_state['values']['actions_action']);  $submit_function = $function .'_submit';  // Action will return keyed array of values to store.  $params = $submit_function($form, $form_state);  $aid = isset($form_state['values']['actions_aid']) ? $form_state['values']['actions_aid'] : NULL;  actions_save($function, $form_state['values']['actions_type'], $params, $form_state['values']['actions_description'], $aid);  drupal_set_message(t('The action has been successfully saved.'));  $form_state['redirect'] = 'admin/settings/actions/manage';}/** * Create the form for confirmation of deleting an action. * * @ingroup forms * @see system_actions_delete_form_submit() */function system_actions_delete_form($form_state, $action) {  $form['aid'] = array(    '#type' => 'hidden',    '#value' => $action->aid,  );  return confirm_form($form,    t('Are you sure you want to delete the action %action?', array('%action' => $action->description)),    'admin/settings/actions/manage',    t('This cannot be undone.'),    t('Delete'), t('Cancel')  );}/** * Process system_actions_delete form submissions. * * Post-deletion operations for action deletion. */function system_actions_delete_form_submit($form, &$form_state) {  $aid = $form_state['values']['aid'];  $action = actions_load($aid);  actions_delete($aid);  $description = check_plain($action->description);  watchdog('user', 'Deleted action %aid (%action)', array('%aid' => $aid, '%action' => $description));  drupal_set_message(t('Action %action was deleted', array('%action' => $description)));  $form_state['redirect'] = 'admin/settings/actions/manage';}/** * Post-deletion operations for deleting action orphans. * * @param $orphaned *   An array of orphaned actions. */function system_action_delete_orphans_post($orphaned) {  foreach ($orphaned as $callback) {    drupal_set_message(t("Deleted orphaned action (%action).", array('%action' => $callback)));  }}/** * Remove actions that are in the database but not supported by any enabled module. */function system_actions_remove_orphans() {  actions_synchronize(actions_list(), TRUE);  drupal_goto('admin/settings/actions/manage');}/** * Return a form definition so the Send email action can be configured. * * @see system_send_email_action_validate() * @see system_send_email_action_submit() * @param $context *   Default values (if we are editing an existing action instance). * @return *   Form definition. */function system_send_email_action_form($context) {  // Set default values for form.  if (!isset($context['recipient'])) {    $context['recipient'] = '';  }  if (!isset($context['subject'])) {    $context['subject'] = '';  }  if (!isset($context['message'])) {    $context['message'] = '';  }  $form['recipient'] = array(    '#type' => 'textfield',    '#title' => t('Recipient'),    '#default_value' => $context['recipient'],    '#maxlength' => '254',    '#description' => t('The email address to which the message should be sent OR enter %author if you would like to send an e-mail to the author of the original post.', array('%author' => '%author')),  );  $form['subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => $context['subject'],    '#maxlength' => '254',    '#description' => t('The subject of the message.'),  );  $form['message'] = array(    '#type' => 'textarea',    '#title' => t('Message'),    '#default_value' => $context['message'],    '#cols' => '80',    '#rows' => '20',    '#description' => t('The message that should be sent. You may include the following variables: %site_name, %username, %node_url, %node_type, %title, %teaser, %body. Not all variables will be available in all contexts.'),  );  return $form;}/** * Validate system_send_email_action form submissions. */function system_send_email_action_validate($form, $form_state) {  $form_values = $form_state['values'];  // Validate the configuration form.  if (!valid_email_address($form_values['recipient']) && $form_values['recipient'] != '%author') {    // We want the literal %author placeholder to be emphasized in the error message.    form_set_error('recipient', t('Please enter a valid email address or %author.', array('%author' => '%author')));  }}/** * Process system_send_email_action form submissions. */function system_send_email_action_submit($form, $form_state) {  $form_values = $form_state['values'];  // Process the HTML form to store configuration. The keyed array that  // we return will be serialized to the database.  $params = array(    'recipient' => $form_values['recipient'],    'subject'   => $form_values['subject'],    'message'   => $form_values['message'],  );  return $params;}/** * Implementation of a configurable Drupal action. Sends an email. */function system_send_email_action($object, $context) {  global $user;  switch ($context['hook']) {    case 'nodeapi':      // Because this is not an action of type 'node' the node      // will not be passed as $object, but it will still be available      // in $context.      $node = $context['node'];      break;    // The comment hook provides nid, in $context.    case 'comment':      $comment = $context['comment'];      $node = node_load($comment->nid);      break;    case 'user':      // Because this is not an action of type 'user' the user      // object is not passed as $object, but it will still be available      // in $context.      $account = $context['account'];      if (isset($context['node'])) {        $node = $context['node'];      }      elseif ($context['recipient'] == '%author') {        // If we don't have a node, we don't have a node author.        watchdog('error', 'Cannot use %author token in this context.');        return;      }      break;    default:      // We are being called directly.      $node = $object;  }  $recipient = $context['recipient'];  if (isset($node)) {    if (!isset($account)) {      $account = user_load(array('uid' => $node->uid));    }    if ($recipient == '%author') {      $recipient = $account->mail;    }  }  if (!isset($account)) {    $account = $user;  }  $language = user_preferred_language($account);  $params = array('account' => $account, 'object' => $object, 'context' => $context);  if (isset($node)) {    $params['node'] = $node;  }  if (drupal_mail('system', 'action_send_email', $recipient, $language, $params)) {    watchdog('action', 'Sent email to %recipient', array('%recipient' => $recipient));  }  else {    watchdog('error', 'Unable to send email to %recipient', array('%recipient' => $recipient));  }}/** * Implementation of hook_mail(). */function system_mail($key, &$message, $params) {  $account = $params['account'];  $context = $params['context'];  $variables = array(    '%site_name' => variable_get('site_name', 'Drupal'),    '%username' => $account->name,  );  if ($context['hook'] == 'taxonomy') {    $object = $params['object'];    $vocabulary = taxonomy_vocabulary_load($object->vid);    $variables += array(      '%term_name' => $object->name,      '%term_description' => $object->description,      '%term_id' => $object->tid,      '%vocabulary_name' => $vocabulary->name,      '%vocabulary_description' => $vocabulary->description,      '%vocabulary_id' => $vocabulary->vid,    );  }  // Node-based variable translation is only available if we have a node.  if (isset($params['node'])) {    $node = $params['node'];    $variables += array(      '%uid' => $node->uid,      '%node_url' => url('node/'. $node->nid, array('absolute' => TRUE)),      '%node_type' => node_get_types('name', $node),      '%title' => $node->title,      '%teaser' => $node->teaser,      '%body' => $node->body,    );  }  $subject = strtr($context['subject'], $variables);  $body = strtr($context['message'], $variables);  $message['subject'] .= str_replace(array("\r", "\n"), '', $subject);  $message['body'][] = drupal_html_to_text($body);}function system_message_action_form($context) {  $form['message'] = array(    '#type' => 'textarea',    '#title' => t('Message'),    '#default_value' => isset($context['message']) ? $context['message'] : '',    '#required' => TRUE,    '#rows' => '8',    '#description' => t('The message to be displayed to the current user. You may include the following variables: %site_name, %username, %node_url, %node_type, %title, %teaser, %body. Not all variables will be available in all contexts.'),  );  return $form;}function system_message_action_submit($form, $form_state) {  return array('message' => $form_state['values']['message']);}/** * A configurable Drupal action. Sends a message to the current user's screen. */function system_message_action(&$object, $context = array()) {  global $user;  $variables = array(    '%site_name' => variable_get('site_name', 'Drupal'),    '%username' => $user->name ? $user->name : variable_get('anonymous', t('Anonymous')),  );  // This action can be called in any context, but if placeholders  // are used a node object must be present to be the source  // of substituted text.  switch ($context['hook']) {    case 'nodeapi':      // Because this is not an action of type 'node' the node      // will not be passed as $object, but it will still be available      // in $context.      $node = $context['node'];      break;    // The comment hook also provides the node, in context.    case 'comment':      $comment = $context['comment'];      $node = node_load($comment->nid);      break;    case 'taxonomy':      $vocabulary = taxonomy_vocabulary_load($object->vid);      $variables = array_merge($variables, array(        '%term_name' => $object->name,        '%term_description' => $object->description,        '%term_id' => $object->tid,        '%vocabulary_name' => $vocabulary->name,        '%vocabulary_description' => $vocabulary->description,        '%vocabulary_id' => $vocabulary->vid,        )      );      break;    default:      // We are being called directly.      $node = $object;  }  if (isset($node) && is_object($node)) {    $variables = array_merge($variables, array(      '%uid' => $node->uid,      '%node_url' => url('node/'. $node->nid, array('absolute' => TRUE)),      '%node_type' => check_plain(node_get_types('name', $node)),      '%title' => filter_xss($node->title),      '%teaser' => filter_xss($node->teaser),      '%body' => filter_xss($node->body),      )    );  }  $context['message'] = strtr($context['message'], $variables);  drupal_set_message($context['message']);}/** * Implementation of a configurable Drupal action. Redirect user to a URL. */function system_goto_action_form($context) {  $form['url'] = array(    '#type' => 'textfield',    '#title' => t('URL'),    '#description' => t('The URL to which the user should be redirected. This can be an internal URL like node/1234 or an external URL like http://drupal.org.'),    '#default_value' => isset($context['url']) ? $context['url'] : '',    '#required' => TRUE,  );  return $form;}function system_goto_action_submit($form, $form_state) {  return array(    'url' => $form_state['values']['url']  );}function system_goto_action($object, $context) {  drupal_goto($context['url']);}/** * Generate an array of time zones and their local time&date. */function _system_zonelist() {  $timestamp = time();  $zonelist = array(-11, -10, -9.5, -9, -8, -7, -6, -5, -4.5, -4, -3.5, -3, -2.5, -2, -1, 0, 1, 2, 3, 3.5, 4, 5, 5.5, 5.75, 6, 6.5, 7, 8, 9, 9.5, 10, 10.5, 11, 11.5, 12, 12.75, 13, 14);  $zones = array();  foreach ($zonelist as $offset) {    $zone = $offset * 3600;    $zones[$zone] = format_date($timestamp, 'custom', variable_get('date_format_long', 'l, F j, Y - H:i') .' O', $zone);  }  return $zones;}/** * Checks whether the server is capable of issuing HTTP requests. * * The function sets the drupal_http_request_fail system variable to TRUE if * drupal_http_request() does not work and then the system status report page * will contain an error. * * @return *  TRUE if this installation can issue HTTP requests. */function system_check_http_request() {  // Try to get the content of the front page via drupal_http_request().  $result = drupal_http_request(url('', array('absolute' => TRUE)));  // We only care that we get a http response - this means that Drupal  // can make a http request.  $works = isset($result->code) && ($result->code >= 100) && ($result->code < 600);  variable_set('drupal_http_request_fails', !$works);  return $works;}/** * Format the Powered by Drupal text. * * @ingroup themeable */function theme_system_powered_by($image_path) {  $image = theme('image', $image_path, t('Powered by Drupal, an open source content management system'), t('Powered by Drupal, an open source content management system'));  return l($image, 'http://drupal.org', array('html' => TRUE, 'absolute' => TRUE, 'external' => TRUE));}
<?php// $Id$/** * Implementation of hook_install(). */function upload_install() {  // Create table. The upload table might have been created in the Drupal 5  // to Drupal 6 upgrade, and was migrated from the file_revisions table. So  // in this case, there is no need to create the table, it is already there.  if (!db_table_exists('upload')) {    drupal_install_schema('upload');  }}/** * Implementation of hook_uninstall(). */function upload_uninstall() {  // Remove tables.  drupal_uninstall_schema('upload');}/** * Implementation of hook_schema(). */function upload_schema() {  $schema['upload'] = array(    'description' => 'Stores uploaded file information and table associations.',    'fields' => array(      'fid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {files}.fid.',      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid associated with the uploaded file.',      ),      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {node}.vid associated with the uploaded file.',      ),      'description' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Description of the uploaded file.',      ),      'list' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether the file should be visibly listed on the node: yes(1) or no(0).',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Weight of this upload in relation to other uploads in this node.',      ),    ),    'primary key' => array('vid', 'fid'),    'indexes' => array(      'fid' => array('fid'),      'nid' => array('nid'),    ),  );  return $schema;}
<?php// $Id$/** * @file * Enable threaded discussions about general topics. *//** * Implementation of hook_help(). */function forum_help($path, $arg) {  switch ($path) {    case 'admin/help#forum':      $output = '<p>'. t('The forum module lets you create threaded discussion forums with functionality similar to other message board systems. Forums are useful because they allow community members to discuss topics with one another while ensuring those conversations are archived for later reference. The <a href="@create-topic">forum topic</a> menu item (under <em>Create content</em> on the Navigation menu) creates the initial post of a new threaded discussion, or thread.', array('@create-topic' => url('node/add/forum'))) .'</p>';      $output .= '<p>'. t('A threaded discussion occurs as people leave comments on a forum topic (or on other comments within that topic). A forum topic is contained within a forum, which may hold many similar or related forum topics. Forums are (optionally) nested within a container, which may hold many similar or related forums. Both containers and forums may be nested within other containers and forums, and provide structure for your message board. By carefully planning this structure, you make it easier for users to find and comment on a specific forum topic.') .'</p>';      $output .= '<p>'. t('When administering a forum, note that:') .'</p>';      $output .= '<ul><li>'. t('a forum topic (and all of its comments) may be moved between forums by selecting a different forum while editing a forum topic.') .'</li>';      $output .= '<li>'. t('when moving a forum topic between forums, the <em>Leave shadow copy</em> option creates a link in the original forum pointing to the new location.') .'</li>';      $output .= '<li>'. t('selecting <em>Read only</em> under <em>Comment settings</em> while editing a forum topic will lock (prevent new comments) on the thread.') .'</li>';      $output .= '<li>'. t('selecting <em>Disabled</em> under <em>Comment settings</em> while editing a forum topic will hide all existing comments on the thread, and prevent new ones.') .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@forum">Forum module</a>.', array('@forum' => 'http://drupal.org/handbook/modules/forum/')) .'</p>';      return $output;    case 'admin/content/forum':      return '<p>'. t('This page displays a list of existing forums and containers. Containers (optionally) hold forums, and forums hold forum topics (a forum topic is the initial post to a threaded discussion). To provide structure, both containers and forums may be placed inside other containers and forums. To rearrange forums and containers, grab a drag-and-drop handle under the <em>Name</em> column and drag the forum or container to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save</em> button at the bottom of the page.') .'</p>';    case 'admin/content/forum/add/container':      return '<p>'. t('By grouping related or similar forums, containers help organize forums. For example, a container named "Food" may hold two forums named "Fruit" and "Vegetables", respectively.') .'</p>';    case 'admin/content/forum/add/forum':      return '<p>'. t('A forum holds related or similar forum topics (a forum topic is the initial post to a threaded discussion). For example, a forum named "Fruit" may contain forum topics titled "Apples" and "Bananas", respectively.') .'</p>';    case 'admin/content/forum/settings':      return '<p>'. t('These settings allow you to adjust the display of your forum topics. The content types available for use within a forum may be selected by editing the <em>Content types</em> on the <a href="@forum-vocabulary">forum vocabulary page</a>.', array('@forum-vocabulary' => url('admin/content/taxonomy/edit/vocabulary/'. variable_get('forum_nav_vocabulary', '')))) .'</p>';  }}/** * Implementation of hook_theme() */function forum_theme() {  return array(    'forums' => array(      'template' => 'forums',      'arguments' => array('forums' => NULL, 'topics' => NULL, 'parents' => NULL, 'tid' => NULL, 'sortby' => NULL, 'forum_per_page' => NULL),    ),    'forum_list' => array(      'template' => 'forum-list',      'arguments' => array('forums' => NULL, 'parents' => NULL, 'tid' => NULL),    ),    'forum_topic_list' => array(      'template' => 'forum-topic-list',      'arguments' => array('tid' => NULL, 'topics' => NULL, 'sortby' => NULL, 'forum_per_page' => NULL),    ),    'forum_icon' => array(      'template' => 'forum-icon',      'arguments' => array('new_posts' => NULL, 'num_posts' => 0, 'comment_mode' => 0, 'sticky' => 0),    ),    'forum_topic_navigation' => array(      'template' => 'forum-topic-navigation',      'arguments' => array('node' => NULL),    ),    'forum_submitted' => array(      'template' => 'forum-submitted',      'arguments' => array('topic' => NULL),    ),  );}/** * Fetch a forum term. * * @param $tid *   The ID of the term which should be loaded. * * @return *   An associative array containing the term data or FALSE if the term cannot be loaded, or is not part of the forum vocabulary. */function forum_term_load($tid) {  $result = db_query(db_rewrite_sql('SELECT t.tid, t.vid, t.name, t.description, t.weight FROM {term_data} t WHERE t.tid = %d AND t.vid = %d', 't', 'tid'), $tid, variable_get('forum_nav_vocabulary', ''));  return db_fetch_array($result);}/** * Implementation of hook_menu(). */function forum_menu() {  $items['forum'] = array(    'title' => 'Forums',    'page callback' => 'forum_page',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'forum.pages.inc',  );  $items['admin/content/forum'] = array(    'title' => 'Forums',    'description' => 'Control forums and their hierarchy and change forum settings.',    'page callback' => 'drupal_get_form',    'page arguments' => array('forum_overview'),    'access arguments' => array('administer forums'),    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/forum/add/container'] = array(    'title' => 'Add container',    'page callback' => 'forum_form_main',    'page arguments' => array('container'),    'access arguments' => array('administer forums'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/add/forum'] = array(    'title' => 'Add forum',    'page callback' => 'forum_form_main',    'page arguments' => array('forum'),    'access arguments' => array('administer forums'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('forum_admin_settings'),    'access arguments' => array('administer forums'),    'weight' => 5,    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/%forum_term'] = array(    'page callback' => 'forum_form_main',    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/container/%forum_term'] = array(    'title' => 'Edit container',    'page callback' => 'forum_form_main',    'page arguments' => array('container', 5),    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/forum/%forum_term'] = array(    'title' => 'Edit forum',    'page callback' => 'forum_form_main',    'page arguments' => array('forum', 5),    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  return $items;}/** * Implementation of hook_init(). */function forum_init() {  drupal_add_css(drupal_get_path('module', 'forum') .'/forum.css');}/** * Implementation of hook_nodeapi(). */function forum_nodeapi(&$node, $op, $teaser, $page) {  // We are going to return if $node->type is not one of the node  // types assigned to the forum vocabulary.  If forum_nav_vocabulary  // is undefined or the vocabulary does not exist, it clearly cannot  // be assigned to $node->type, so return to avoid E_ALL warnings.  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  if (empty($vocabulary)) {    return;  }  // Operate only on node types assigned for the forum vocabulary.  if (!in_array($node->type, $vocabulary->nodes)) {    return;  }  switch ($op) {    case 'view':      if ($page && taxonomy_node_get_terms_by_vocabulary($node, $vid) && $tree = taxonomy_get_tree($vid)) {        // Get the forum terms from the (cached) tree        foreach ($tree as $term) {          $forum_terms[] = $term->tid;        }        foreach ($node->taxonomy as $term_id => $term) {          if (in_array($term_id, $forum_terms)) {            $node->tid = $term_id;          }        }        // Breadcrumb navigation        $breadcrumb[] = l(t('Home'), NULL);        $breadcrumb[] = l($vocabulary->name, 'forum');        if ($parents = taxonomy_get_parents_all($node->tid)) {          $parents = array_reverse($parents);          foreach ($parents as $p) {            $breadcrumb[] = l($p->name, 'forum/'. $p->tid);          }        }        drupal_set_breadcrumb($breadcrumb);        if (!$teaser) {          $node->content['forum_navigation'] = array(            '#value' => theme('forum_topic_navigation', $node),            '#weight' => 100,          );        }      }      break;    case 'prepare':      if (empty($node->nid)) {        // New topic        $node->taxonomy[arg(3)]->vid = $vid;        $node->taxonomy[arg(3)]->tid = arg(3);      }      break;    // Check in particular that only a "leaf" term in the associated taxonomy    // vocabulary is selected, not a "container" term.    case 'validate':      if ($node->taxonomy) {        // Extract the node's proper topic ID.        $vocabulary = $vid;        $containers = variable_get('forum_containers', array());        foreach ($node->taxonomy as $term) {          if (db_result(db_query('SELECT COUNT(*) FROM {term_data} WHERE tid = %d AND vid = %d', $term, $vocabulary))) {            if (in_array($term, $containers)) {              $term = taxonomy_get_term($term);              form_set_error('taxonomy', t('The item %forum is only a container for forums. Please select one of the forums below it.', array('%forum' => $term->name)));            }          }        }      }      break;    // Assign forum taxonomy when adding a topic from within a forum.    case 'presave':      // Make sure all fields are set properly:      $node->icon = !empty($node->icon) ? $node->icon : '';      if ($node->taxonomy && $tree = taxonomy_get_tree($vid)) {        // Get the forum terms from the (cached) tree if we have a taxonomy.        foreach ($tree as $term) {          $forum_terms[] = $term->tid;        }        foreach ($node->taxonomy as $term_id) {          if (in_array($term_id, $forum_terms)) {            $node->tid = $term_id;          }        }        $old_tid = db_result(db_query_range("SELECT t.tid FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.nid = %d ORDER BY t.vid DESC", $node->nid, 0, 1));        if ($old_tid && isset($node->tid) && ($node->tid != $old_tid) && !empty($node->shadow)) {          // A shadow copy needs to be created. Retain new term and add old term.          $node->taxonomy[] = $old_tid;        }      }      break;    case 'update':      if (empty($node->revision) && db_result(db_query('SELECT tid FROM {forum} WHERE nid=%d', $node->nid))) {        if (!empty($node->tid)) {          db_query('UPDATE {forum} SET tid = %d WHERE vid = %d', $node->tid, $node->vid);        }        // The node is removed from the forum.        else {          db_query('DELETE FROM {forum} WHERE nid = %d', $node->nid);        }        break;      }      // Deliberate no break -- for new revisions and for previously unassigned terms we need an insert.    case 'insert':      if (!empty($node->tid)) {        db_query('INSERT INTO {forum} (tid, vid, nid) VALUES (%d, %d, %d)', $node->tid, $node->vid, $node->nid);      }      break;    case 'delete':      db_query('DELETE FROM {forum} WHERE nid = %d', $node->nid);      break;    case 'load':      return db_fetch_array(db_query('SELECT tid AS forum_tid FROM {forum} WHERE vid = %d', $node->vid));  }  return;}/** * Implementation of hook_node_info(). */function forum_node_info() {  return array(    'forum' => array(      'name' => t('Forum topic'),      'module' => 'forum',      'description' => t('A <em>forum topic</em> is the initial post to a new discussion thread within a forum.'),      'title_label' => t('Subject'),    )  );}/** * Implementation of hook_access(). */function forum_access($op, $node, $account) {  switch ($op) {    case 'create':      return user_access('create forum topics', $account) ? TRUE : NULL;    case 'update':      return user_access('edit any forum topic', $account) || (user_access('edit own forum topics', $account) && ($account->uid == $node->uid)) ? TRUE : NULL;    case 'delete':      return user_access('delete any forum topic', $account) || (user_access('delete own forum topics', $account) && ($account->uid == $node->uid)) ? TRUE : NULL;  }}/** * Implementation of hook_perm(). */function forum_perm() {  return array('create forum topics', 'delete own forum topics', 'delete any forum topic', 'edit own forum topics', 'edit any forum topic', 'administer forums');}/** * Implementation of hook_taxonomy(). */function forum_taxonomy($op, $type, $term = NULL) {  if ($op == 'delete' && $term['vid'] == variable_get('forum_nav_vocabulary', '')) {    switch ($type) {      case 'term':        $results = db_query('SELECT tn.nid FROM {term_node} tn WHERE tn.tid = %d', $term['tid']);        while ($node = db_fetch_object($results)) {          // node_delete will also remove any association with non-forum vocabularies.          node_delete($node->nid);        }        // For containers, remove the tid from the forum_containers variable.        $containers = variable_get('forum_containers', array());        $key = array_search($term['tid'], $containers);        if ($key !== FALSE) {          unset($containers[$key]);        }        variable_set('forum_containers', $containers);        break;      case 'vocabulary':        variable_del('forum_nav_vocabulary');    }  }}/** * Implementation of hook_form_alter(). */function forum_form_alter(&$form, $form_state, $form_id) {  $vid = variable_get('forum_nav_vocabulary', '');  if (isset($form['vid']) && $form['vid']['#value'] == $vid) {    // Hide critical options from forum vocabulary.    if ($form_id == 'taxonomy_form_vocabulary') {      $form['help_forum_vocab'] = array(        '#value' => t('This is the designated forum vocabulary. Some of the normal vocabulary options have been removed.'),        '#weight' => -1,      );      $form['content_types']['nodes']['#required'] = TRUE;      $form['hierarchy'] = array('#type' => 'value', '#value' => 1);      $form['settings']['required'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['relations'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['tags'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['multiple'] = array('#type' => 'value', '#value' => FALSE);      unset($form['delete']);    }    // Hide multiple parents select from forum terms.    elseif ($form_id == 'taxonomy_form_term') {      $form['advanced']['parent']['#access'] = FALSE;    }  }  if ($form_id == 'forum_node_form') {    // Make the vocabulary required for 'real' forum-nodes.    $vid = variable_get('forum_nav_vocabulary', '');    $form['taxonomy'][$vid]['#required'] = TRUE;    $form['taxonomy'][$vid]['#options'][''] = t('- Please choose -');  }}/** * Implementation of hook_load(). */function forum_load($node) {  $forum = db_fetch_object(db_query('SELECT * FROM {forum} WHERE vid = %d', $node->vid));  return $forum;}/** * Implementation of hook_block(). * * Generates a block containing the currently active forum topics and the * most recently added forum topics. */function forum_block($op = 'list', $delta = 0, $edit = array()) {  switch ($op) {    case 'list':      $blocks[0]['info'] = t('Active forum topics');      $blocks[1]['info'] = t('New forum topics');      return $blocks;    case 'configure':      $form['forum_block_num_'. $delta] = array('#type' => 'select', '#title' => t('Number of topics'), '#default_value' => variable_get('forum_block_num_'. $delta, '5'), '#options' => drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)));      return $form;    case 'save':      variable_set('forum_block_num_'. $delta, $edit['forum_block_num_'. $delta]);      break;    case 'view':      if (user_access('access content')) {        switch ($delta) {          case 0:            $title = t('Active forum topics');            $sql = db_rewrite_sql("SELECT n.nid, n.title, l.comment_count, l.last_comment_timestamp FROM {node} n INNER JOIN {term_node} tn ON tn.vid = n.vid INNER JOIN {term_data} td ON td.tid = tn.tid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 AND td.vid = %d ORDER BY l.last_comment_timestamp DESC");            $result = db_query_range($sql, variable_get('forum_nav_vocabulary', ''), 0, variable_get('forum_block_num_0', '5'));            $content = node_title_list($result);            break;          case 1:            $title = t('New forum topics');            $sql = db_rewrite_sql("SELECT n.nid, n.title, l.comment_count FROM {node} n INNER JOIN {term_node} tn ON tn.vid = n.vid INNER JOIN {term_data} td ON td.tid = tn.tid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 AND td.vid = %d ORDER BY n.nid DESC");            $result = db_query_range($sql, variable_get('forum_nav_vocabulary', ''), 0, variable_get('forum_block_num_1', '5'));            $content = node_title_list($result);            break;        }        if (!empty($content)) {          $block['subject'] = $title;          $block['content'] = $content . theme('more_link', url('forum'), t('Read the latest forum topics.'));          return $block;        }      }  }}/** * Implementation of hook_form(). */function forum_form(&$node, $form_state) {  $type = node_get_types('type', $node);  $form['title'] = array('#type' => 'textfield', '#title' => check_plain($type->title_label), '#default_value' => !empty($node->title) ? $node->title : '', '#required' => TRUE, '#weight' => -5);  if (!empty($node->nid)) {    $vid = variable_get('forum_nav_vocabulary', '');    $forum_terms = taxonomy_node_get_terms_by_vocabulary($node, $vid);    // if editing, give option to leave shadows    $shadow = (count($forum_terms) > 1);    $form['shadow'] = array('#type' => 'checkbox', '#title' => t('Leave shadow copy'), '#default_value' => $shadow, '#description' => t('If you move this topic, you can leave a link in the old forum to the new forum.'));  }  $form['body_field'] = node_body_field($node, $type->body_label, 1);  $form['#submit'][] = 'forum_submit';  // Assign the forum topic submit handler.  return $form;}/** * Implementation of hook_term_path(). */function forum_term_path($term) {  return 'forum/'. $term->tid;}/** * Returns a list of all forums for a given taxonomy id * * Forum objects contain the following fields * -num_topics Number of topics in the forum * -num_posts Total number of posts in all topics * -last_post Most recent post for the forum * * @param $tid *   Taxonomy ID of the vocabulary that holds the forum list. * @return *   Array of object containing the forum information. */function forum_get_forums($tid = 0) {  $forums = array();  $vid = variable_get('forum_nav_vocabulary', '');  $_forums = taxonomy_get_tree($vid, $tid);  if (count($_forums)) {    $counts = array();    $sql = "SELECT r.tid, COUNT(n.nid) AS topic_count, SUM(l.comment_count) AS comment_count FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {term_node} r ON n.vid = r.vid WHERE n.status = 1 GROUP BY r.tid";    $sql = db_rewrite_sql($sql);    $_counts = db_query($sql);    while ($count = db_fetch_object($_counts)) {      $counts[$count->tid] = $count;    }  }  foreach ($_forums as $forum) {    if (in_array($forum->tid, variable_get('forum_containers', array()))) {      $forum->container = 1;    }    if (!empty($counts[$forum->tid])) {      $forum->num_topics = $counts[$forum->tid]->topic_count;      $forum->num_posts = $counts[$forum->tid]->topic_count + $counts[$forum->tid]->comment_count;    }    else {      $forum->num_topics = 0;      $forum->num_posts = 0;    }    // This query does not use full ANSI syntax since MySQL 3.x does not support    // table1 INNER JOIN table2 INNER JOIN table3 ON table2_criteria ON table3_criteria    // used to join node_comment_statistics to users.    $sql = "SELECT ncs.last_comment_timestamp, IF (ncs.last_comment_uid != 0, u2.name, ncs.last_comment_name) AS last_comment_name, ncs.last_comment_uid FROM {node} n INNER JOIN {users} u1 ON n.uid = u1.uid INNER JOIN {term_node} tn ON n.vid = tn.vid INNER JOIN {node_comment_statistics} ncs ON n.nid = ncs.nid INNER JOIN {users} u2 ON ncs.last_comment_uid=u2.uid WHERE n.status = 1 AND tn.tid = %d ORDER BY ncs.last_comment_timestamp DESC";    $sql = db_rewrite_sql($sql);    $topic = db_fetch_object(db_query_range($sql, $forum->tid, 0, 1));    $last_post = new stdClass();    if (!empty($topic->last_comment_timestamp)) {      $last_post->timestamp = $topic->last_comment_timestamp;      $last_post->name = $topic->last_comment_name;      $last_post->uid = $topic->last_comment_uid;    }    $forum->last_post = $last_post;    $forums[$forum->tid] = $forum;  }  return $forums;}/** * Calculate the number of nodes the user has not yet read and are newer * than NODE_NEW_LIMIT. */function _forum_topics_unread($term, $uid) {  $sql = "SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid AND tn.tid = %d LEFT JOIN {history} h ON n.nid = h.nid AND h.uid = %d WHERE n.status = 1 AND n.created > %d AND h.nid IS NULL";  $sql = db_rewrite_sql($sql);  return db_result(db_query($sql, $term, $uid, NODE_NEW_LIMIT));}function forum_get_topics($tid, $sortby, $forum_per_page) {  global $user, $forum_topic_list_header;  $forum_topic_list_header = array(    NULL,    array('data' => t('Topic'), 'field' => 'n.title'),    array('data' => t('Replies'), 'field' => 'l.comment_count'),    array('data' => t('Created'), 'field' => 'n.created'),    array('data' => t('Last reply'), 'field' => 'l.last_comment_timestamp'),  );  $order = _forum_get_topic_order($sortby);  for ($i = 0; $i < count($forum_topic_list_header); $i++) {    if ($forum_topic_list_header[$i]['field'] == $order['field']) {      $forum_topic_list_header[$i]['sort'] = $order['sort'];    }  }  $term = taxonomy_get_term($tid);  $sql = db_rewrite_sql("SELECT n.nid, r.tid, n.title, n.type, n.sticky, u.name, u.uid, n.created AS timestamp, n.comment AS comment_mode, l.last_comment_timestamp, IF(l.last_comment_uid != 0, cu.name, l.last_comment_name) AS last_comment_name, l.last_comment_uid, l.comment_count AS num_comments, f.tid AS forum_tid FROM {node_comment_statistics} l INNER JOIN {node} n ON n.nid = l.nid INNER JOIN {users} cu ON l.last_comment_uid = cu.uid INNER JOIN {term_node} r ON n.vid = r.vid INNER JOIN {users} u ON n.uid = u.uid INNER JOIN {forum} f ON n.vid = f.vid WHERE n.status = 1 AND r.tid = %d");  $sql .= tablesort_sql($forum_topic_list_header, 'n.sticky DESC,');  $sql .= ', n.created DESC';  // Always add a secondary sort order so that the news forum topics are on top.  $sql_count = db_rewrite_sql("SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} r ON n.vid = r.vid AND r.tid = %d WHERE n.status = 1");  $result = pager_query($sql, $forum_per_page, 0, $sql_count, $tid);  $topics = array();  while ($topic = db_fetch_object($result)) {    if ($user->uid) {      // folder is new if topic is new or there are new comments since last visit      if ($topic->tid != $tid) {        $topic->new = 0;      }      else {        $history = _forum_user_last_visit($topic->nid);        $topic->new_replies = comment_num_new($topic->nid, $history);        $topic->new = $topic->new_replies || ($topic->timestamp > $history);      }    }    else {      // Do not track "new replies" status for topics if the user is anonymous.      $topic->new_replies = 0;      $topic->new = 0;    }    if ($topic->num_comments > 0) {      $last_reply = new stdClass();      $last_reply->timestamp = $topic->last_comment_timestamp;      $last_reply->name = $topic->last_comment_name;      $last_reply->uid = $topic->last_comment_uid;      $topic->last_reply = $last_reply;    }    $topics[] = $topic;  }  return $topics;}/** * Finds the first unread node for a given forum. */function _forum_new($tid) {  global $user;  $sql = "SELECT n.nid FROM {node} n LEFT JOIN {history} h ON n.nid = h.nid AND h.uid = %d INNER JOIN {term_node} r ON n.nid = r.nid AND r.tid = %d WHERE n.status = 1 AND h.nid IS NULL AND n.created > %d ORDER BY created";  $sql = db_rewrite_sql($sql);  $nid = db_result(db_query_range($sql, $user->uid, $tid, NODE_NEW_LIMIT, 0, 1));  return $nid ? $nid : 0;}/** * Process variables for forums.tpl.php * * The $variables array contains the following arguments: * - $forums * - $topics * - $parents * - $tid * - $sortby * - $forum_per_page * * @see forums.tpl.php */function template_preprocess_forums(&$variables) {  global $user;  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  $title = !empty($vocabulary->name) ? $vocabulary->name : '';  // Breadcrumb navigation:  $breadcrumb[] = l(t('Home'), NULL);  if ($variables['tid']) {    $breadcrumb[] = l($vocabulary->name, 'forum');  }  if ($variables['parents']) {    $variables['parents'] = array_reverse($variables['parents']);    foreach ($variables['parents'] as $p) {      if ($p->tid == $variables['tid']) {        $title = $p->name;      }      else {        $breadcrumb[] = l($p->name, 'forum/'. $p->tid);      }    }  }  drupal_set_breadcrumb($breadcrumb);  drupal_set_title(check_plain($title));  if ($variables['forums_defined'] = count($variables['forums']) || count($variables['parents'])) {    // Format the "post new content" links listing.    $forum_types = array();    // Loop through all node types for forum vocabulary.    foreach ($vocabulary->nodes as $type) {      // Check if the current user has the 'create' permission for this node type.      if (node_access('create', $type)) {        // Fetch the "General" name of the content type;        // Push the link with title and url to the array.        $forum_types[$type] = array('title' => t('Post new @node_type', array('@node_type' => node_get_types('name', $type))), 'href' => 'node/add/'. str_replace('_', '-', $type) .'/'. $variables['tid']);      }    }    if (empty($forum_types)) {      // The user is logged-in; but denied access to create any new forum content type.      if ($user->uid) {        $forum_types['disallowed'] = array('title' => t('You are not allowed to post new content in the forum.'));      }      // The user is not logged-in; and denied access to create any new forum content type.      else {        $forum_types['login'] = array('title' => t('<a href="@login">Login</a> to post new content in the forum.', array('@login' => url('user/login', array('query' => drupal_get_destination())))), 'html' => TRUE);      }    }    $variables['links'] = $forum_types;    if (!empty($variables['forums'])) {      $variables['forums'] = theme('forum_list', $variables['forums'], $variables['parents'], $variables['tid']);    }    else {      $variables['forums'] = '';    }    if ($variables['tid'] && !in_array($variables['tid'], variable_get('forum_containers', array()))) {      $variables['topics'] = theme('forum_topic_list', $variables['tid'], $variables['topics'], $variables['sortby'], $variables['forum_per_page']);      drupal_add_feed(url('taxonomy/term/'. $variables['tid'] .'/0/feed'), 'RSS - '. $title);    }    else {      $variables['topics'] = '';    }    // Provide separate template suggestions based on what's being output. Topic id is also accounted for.    // Check both variables to be safe then the inverse. Forums with topic ID's take precedence.    if ($variables['forums'] && !$variables['topics']) {      $variables['template_files'][] = 'forums-containers';      $variables['template_files'][] = 'forums-'. $variables['tid'];      $variables['template_files'][] = 'forums-containers-'. $variables['tid'];    }    elseif (!$variables['forums'] && $variables['topics']) {      $variables['template_files'][] = 'forums-topics';      $variables['template_files'][] = 'forums-'. $variables['tid'];      $variables['template_files'][] = 'forums-topics-'. $variables['tid'];    }    else {      $variables['template_files'][] = 'forums-'. $variables['tid'];    }  }  else {    drupal_set_title(t('No forums defined'));    $variables['links'] = array();    $variables['forums'] = '';    $variables['topics'] = '';  }}/** * Process variables to format a forum listing. * * $variables contains the following information: * - $forums * - $parents * - $tid * * @see forum-list.tpl.php * @see theme_forum_list() */function template_preprocess_forum_list(&$variables) {  global $user;  $row = 0;  // Sanitize each forum so that the template can safely print the data.  foreach ($variables['forums'] as $id => $forum) {    $variables['forums'][$id]->description = !empty($forum->description) ? filter_xss_admin($forum->description) : '';    $variables['forums'][$id]->link = url("forum/$forum->tid");    $variables['forums'][$id]->name = check_plain($forum->name);    $variables['forums'][$id]->is_container = !empty($forum->container);    $variables['forums'][$id]->zebra = $row % 2 == 0 ? 'odd' : 'even';    $row++;    $variables['forums'][$id]->new_text = '';    $variables['forums'][$id]->new_url = '';    $variables['forums'][$id]->new_topics = 0;    $variables['forums'][$id]->old_topics = $forum->num_topics;    if ($user->uid) {      $variables['forums'][$id]->new_topics = _forum_topics_unread($forum->tid, $user->uid);      if ($variables['forums'][$id]->new_topics) {        $variables['forums'][$id]->new_text = format_plural($variables['forums'][$id]->new_topics, '1 new', '@count new');        $variables['forums'][$id]->new_url = url("forum/$forum->tid", array('fragment' => 'new'));      }      $variables['forums'][$id]->old_topics = $forum->num_topics - $variables['forums'][$id]->new_topics;    }    $variables['forums'][$id]->last_reply = theme('forum_submitted', $forum->last_post);  }  // Give meaning to $tid for themers. $tid actually stands for term id.  $variables['forum_id'] = $variables['tid'];  unset($variables['tid']);}/** * Preprocess variables to format the topic listing. * * $variables contains the following data: * - $tid * - $topics * - $sortby * - $forum_per_page * * @see forum-topic-list.tpl.php * @see theme_forum_topic_list() */function template_preprocess_forum_topic_list(&$variables) {  global $forum_topic_list_header;  // Create the tablesorting header.  $ts = tablesort_init($forum_topic_list_header);  $header = '';  foreach ($forum_topic_list_header as $cell) {    $cell = tablesort_header($cell, $forum_topic_list_header, $ts);    $header .= _theme_table_cell($cell, TRUE);  }  $variables['header'] = $header;  if (!empty($variables['topics'])) {    $row = 0;    foreach ($variables['topics'] as $id => $topic) {      $variables['topics'][$id]->icon = theme('forum_icon', $topic->new, $topic->num_comments, $topic->comment_mode, $topic->sticky);      $variables['topics'][$id]->zebra = $row % 2 == 0 ? 'odd' : 'even';      $row++;      // We keep the actual tid in forum table, if it's different from the      // current tid then it means the topic appears in two forums, one of      // them is a shadow copy.      if ($topic->forum_tid != $variables['tid']) {        $variables['topics'][$id]->moved = TRUE;        $variables['topics'][$id]->title = check_plain($topic->title);        $variables['topics'][$id]->message = l(t('This topic has been moved'), "forum/$topic->forum_tid");      }      else {        $variables['topics'][$id]->moved = FALSE;        $variables['topics'][$id]->title = l($topic->title, "node/$topic->nid");        $variables['topics'][$id]->message = '';      }      $variables['topics'][$id]->created = theme('forum_submitted', $topic);      $variables['topics'][$id]->last_reply = theme('forum_submitted', isset($topic->last_reply) ? $topic->last_reply : NULL);      $variables['topics'][$id]->new_text = '';      $variables['topics'][$id]->new_url = '';      if ($topic->new_replies) {        $variables['topics'][$id]->new_text = format_plural($topic->new_replies, '1 new', '@count new');        $variables['topics'][$id]->new_url = url("node/$topic->nid", array('query' => comment_new_page_count($topic->num_comments, $topic->new_replies, $topic), 'fragment' => 'new'));      }    }  }  else {    // Make this safe for the template    $variables['topics'] = array();  }  // Give meaning to $tid for themers. $tid actually stands for term id.  $variables['topic_id'] = $variables['tid'];  unset($variables['tid']);  $variables['pager'] = theme('pager', NULL, $variables['forum_per_page'], 0);}/** * Process variables to format the icon for each individual topic. * * $variables contains the following data: * - $new_posts * - $num_posts = 0 * - $comment_mode = 0 * - $sticky = 0 * * @see forum-icon.tpl.php * @see theme_forum_icon() */function template_preprocess_forum_icon(&$variables) {  $variables['hot_threshold'] = variable_get('forum_hot_topic', 15);  if ($variables['num_posts'] > $variables['hot_threshold']) {    $variables['icon'] = $variables['new_posts'] ? 'hot-new' : 'hot';  }  else {    $variables['icon'] = $variables['new_posts'] ? 'new' : 'default';  }  if ($variables['comment_mode'] == COMMENT_NODE_READ_ONLY || $variables['comment_mode'] == COMMENT_NODE_DISABLED) {    $variables['icon'] = 'closed';  }  if ($variables['sticky'] == 1) {    $variables['icon'] = 'sticky';  }}/** * Preprocess variables to format the next/previous forum topic navigation links. * * $variables contains $node. * * @see forum-topic-navigation.tpl.php * @see theme_forum_topic_navigation() */function template_preprocess_forum_topic_navigation(&$variables) {  $output = '';  // get previous and next topic  $sql = "SELECT n.nid, n.title, n.sticky, l.comment_count, l.last_comment_timestamp FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {term_node} r ON n.nid = r.nid AND r.tid = %d WHERE n.status = 1 ORDER BY n.sticky DESC, ". _forum_get_topic_order_sql(variable_get('forum_order', 1));  $result = db_query(db_rewrite_sql($sql), isset($variables['node']->tid) ? $variables['node']->tid : 0);  $stop = $variables['prev'] = $variables['next'] = 0;  while ($topic = db_fetch_object($result)) {    if ($stop == 1) {      $variables['next'] = $topic->nid;      $variables['next_title'] = check_plain($topic->title);      $variables['next_url'] = url("node/$topic->nid");      break;    }    if ($topic->nid == $variables['node']->nid) {      $stop = 1;    }    else {      $variables['prev'] = $topic->nid;      $variables['prev_title'] = check_plain($topic->title);      $variables['prev_url'] = url("node/$topic->nid");    }  }}/** * Process variables to format submission info for display in the forum list and topic list. * * $variables will contain: $topic * * @see forum-submitted.tpl.php * @see theme_forum_submitted() */function template_preprocess_forum_submitted(&$variables) {  $variables['author'] = isset($variables['topic']->uid) ? theme('username', $variables['topic']) : '';  $variables['time'] = isset($variables['topic']->timestamp) ? format_interval(time() - $variables['topic']->timestamp) : '';}function _forum_user_last_visit($nid) {  global $user;  static $history = array();  if (empty($history)) {    $result = db_query('SELECT nid, timestamp FROM {history} WHERE uid = %d', $user->uid);    while ($t = db_fetch_object($result)) {      $history[$t->nid] = $t->timestamp > NODE_NEW_LIMIT ? $t->timestamp : NODE_NEW_LIMIT;    }  }  return isset($history[$nid]) ? $history[$nid] : NODE_NEW_LIMIT;}function _forum_get_topic_order($sortby) {  switch ($sortby) {    case 1:      return array('field' => 'l.last_comment_timestamp', 'sort' => 'desc');      break;    case 2:      return array('field' => 'l.last_comment_timestamp', 'sort' => 'asc');      break;    case 3:      return array('field' => 'l.comment_count', 'sort' => 'desc');      break;    case 4:      return array('field' => 'l.comment_count', 'sort' => 'asc');      break;  }}function _forum_get_topic_order_sql($sortby) {  $order = _forum_get_topic_order($sortby);  return $order['field'] .' '. strtoupper($order['sort']);}
<?php// $Id$/** * @file * Functions to aid in presenting database results as a set of pages. *//** * Perform a paged database query. * * Use this function when doing select queries you wish to be able to page. The * pager uses LIMIT-based queries to fetch only the records required to render a * certain page. However, it has to learn the total number of records returned * by the query to compute the number of pages (the number of records / records * per page). This is done by inserting "COUNT(*)" in the original query. For * example, the query "SELECT nid, type FROM node WHERE status = '1' ORDER BY * sticky DESC, created DESC" would be rewritten to read "SELECT COUNT(*) FROM * node WHERE status = '1' ORDER BY sticky DESC, created DESC". Rewriting the * query is accomplished using a regular expression. * * Unfortunately, the rewrite rule does not always work as intended for queries * that already have a "COUNT(*)" or a "GROUP BY" clause, and possibly for * other complex queries. In those cases, you can optionally pass a query that * will be used to count the records. * * For example, if you want to page the query "SELECT COUNT(*), TYPE FROM node * GROUP BY TYPE", pager_query() would invoke the incorrect query "SELECT * COUNT(*) FROM node GROUP BY TYPE". So instead, you should pass "SELECT * COUNT(DISTINCT(TYPE)) FROM node" as the optional $count_query parameter. * * @param $query *   The SQL query that needs paging. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $count_query *   An SQL query used to count matching records. * @param ... *   A variable number of arguments which are substituted into the query (and *   the count query) using printf() syntax. Instead of a variable number of *   query arguments, you may also pass a single array containing the query *   arguments. * @return *   A database query result resource, or FALSE if the query was not executed *   correctly. * * @ingroup database */function pager_query($query, $limit = 10, $element = 0, $count_query = NULL) {  global $pager_page_array, $pager_total, $pager_total_items;  $page = isset($_GET['page']) ? $_GET['page'] : '';  // Substitute in query arguments.  $args = func_get_args();  $args = array_slice($args, 4);  // Alternative syntax for '...'  if (isset($args[0]) && is_array($args[0])) {    $args = $args[0];  }  // Construct a count query if none was given.  if (!isset($count_query)) {    $count_query = preg_replace(array('/SELECT.*?FROM /As', '/ORDER BY .*/'), array('SELECT COUNT(*) FROM ', ''), $query);  }  // Convert comma-separated $page to an array, used by other functions.  $pager_page_array = explode(',', $page);  // We calculate the total of pages as ceil(items / limit).  $pager_total_items[$element] = db_result(db_query($count_query, $args));  $pager_total[$element] = ceil($pager_total_items[$element] / $limit);  $pager_page_array[$element] = max(0, min((int)$pager_page_array[$element], ((int)$pager_total[$element]) - 1));  return db_query_range($query, $args, $pager_page_array[$element] * $limit, $limit);}/** * Compose a query string to append to pager requests. * * @return *   A query string that consists of all components of the current page request *   except for those pertaining to paging. */function pager_get_querystring() {  static $string = NULL;  if (!isset($string)) {    $string = drupal_query_string_encode($_REQUEST, array_merge(array('q', 'page', 'pass'), array_keys($_COOKIE)));  }  return $string;}/** * Format a query pager. * * Menu callbacks that display paged query results should call theme('pager') to * retrieve a pager control so that users can view other results. * Format a list of nearby pages with additional query results. * * @param $tags *   An array of labels for the controls in the pager. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @param $quantity *   The number of pages in the list. * @return *   An HTML string that generates the query pager. * * @ingroup themeable */function theme_pager($tags = array(), $limit = 10, $element = 0, $parameters = array(), $quantity = 9) {  global $pager_page_array, $pager_total;  // Calculate various markers within this pager piece:  // Middle is used to "center" pages around the current page.  $pager_middle = ceil($quantity / 2);  // current is the page we are currently paged to  $pager_current = $pager_page_array[$element] + 1;  // first is the first page listed by this pager piece (re quantity)  $pager_first = $pager_current - $pager_middle + 1;  // last is the last page listed by this pager piece (re quantity)  $pager_last = $pager_current + $quantity - $pager_middle;  // max is the maximum page number  $pager_max = $pager_total[$element];  // End of marker calculations.  // Prepare for generation loop.  $i = $pager_first;  if ($pager_last > $pager_max) {    // Adjust "center" if at end of query.    $i = $i + ($pager_max - $pager_last);    $pager_last = $pager_max;  }  if ($i <= 0) {    // Adjust "center" if at start of query.    $pager_last = $pager_last + (1 - $i);    $i = 1;  }  // End of generation loop preparation.  $li_first = theme('pager_first', (isset($tags[0]) ? $tags[0] : t(' first')), $limit, $element, $parameters);  $li_previous = theme('pager_previous', (isset($tags[1]) ? $tags[1] : t(' previous')), $limit, $element, 1, $parameters);  $li_next = theme('pager_next', (isset($tags[3]) ? $tags[3] : t('next ')), $limit, $element, 1, $parameters);  $li_last = theme('pager_last', (isset($tags[4]) ? $tags[4] : t('last ')), $limit, $element, $parameters);  if ($pager_total[$element] > 1) {    if ($li_first) {      $items[] = array(        'class' => 'pager-first',        'data' => $li_first,      );    }    if ($li_previous) {      $items[] = array(        'class' => 'pager-previous',        'data' => $li_previous,      );    }    // When there is more than one page, create the pager list.    if ($i != $pager_max) {      if ($i > 1) {        $items[] = array(          'class' => 'pager-ellipsis',          'data' => '',        );      }      // Now generate the actual pager piece.      for (; $i <= $pager_last && $i <= $pager_max; $i++) {        if ($i < $pager_current) {          $items[] = array(            'class' => 'pager-item',            'data' => theme('pager_previous', $i, $limit, $element, ($pager_current - $i), $parameters),          );        }        if ($i == $pager_current) {          $items[] = array(            'class' => 'pager-current',            'data' => $i,          );        }        if ($i > $pager_current) {          $items[] = array(            'class' => 'pager-item',            'data' => theme('pager_next', $i, $limit, $element, ($i - $pager_current), $parameters),          );        }      }      if ($i < $pager_max) {        $items[] = array(          'class' => 'pager-ellipsis',          'data' => '',        );      }    }    // End generation.    if ($li_next) {      $items[] = array(        'class' => 'pager-next',        'data' => $li_next,      );    }    if ($li_last) {      $items[] = array(        'class' => 'pager-last',        'data' => $li_last,      );    }    return theme('item_list', $items, NULL, 'ul', array('class' => 'pager'));  }}/** * @name Pager pieces * @{ * Use these pieces to construct your own custom pagers in your theme. Note that * you should NOT modify this file to customize your pager. *//** * Format a "first page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_first($text, $limit, $element = 0, $parameters = array()) {  global $pager_page_array;  $output = '';  // If we are anywhere but the first page  if ($pager_page_array[$element] > 0) {    $output = theme('pager_link', $text, pager_load_array(0, $element, $pager_page_array), $element, $parameters);  }  return $output;}/** * Format a "previous page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $interval *   The number of pages to move backward when the link is clicked. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_previous($text, $limit, $element = 0, $interval = 1, $parameters = array()) {  global $pager_page_array;  $output = '';  // If we are anywhere but the first page  if ($pager_page_array[$element] > 0) {    $page_new = pager_load_array($pager_page_array[$element] - $interval, $element, $pager_page_array);    // If the previous page is the first page, mark the link as such.    if ($page_new[$element] == 0) {      $output = theme('pager_first', $text, $limit, $element, $parameters);    }    // The previous page is not the first page.    else {      $output = theme('pager_link', $text, $page_new, $element, $parameters);    }  }  return $output;}/** * Format a "next page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $interval *   The number of pages to move forward when the link is clicked. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_next($text, $limit, $element = 0, $interval = 1, $parameters = array()) {  global $pager_page_array, $pager_total;  $output = '';  // If we are anywhere but the last page  if ($pager_page_array[$element] < ($pager_total[$element] - 1)) {    $page_new = pager_load_array($pager_page_array[$element] + $interval, $element, $pager_page_array);    // If the next page is the last page, mark the link as such.    if ($page_new[$element] == ($pager_total[$element] - 1)) {      $output = theme('pager_last', $text, $limit, $element, $parameters);    }    // The next page is not the last page.    else {      $output = theme('pager_link', $text, $page_new, $element, $parameters);    }  }  return $output;}/** * Format a "last page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_last($text, $limit, $element = 0, $parameters = array()) {  global $pager_page_array, $pager_total;  $output = '';  // If we are anywhere but the last page  if ($pager_page_array[$element] < ($pager_total[$element] - 1)) {    $output = theme('pager_link', $text, pager_load_array($pager_total[$element] - 1, $element, $pager_page_array), $element, $parameters);  }  return $output;}/** * Format a link to a specific query result page. * * @param $page_new *   The first result to display on the linked page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager link. * @param $attributes *   An associative array of HTML attributes to apply to a pager anchor tag. * @return *   An HTML string that generates the link. * * @ingroup themeable */function theme_pager_link($text, $page_new, $element, $parameters = array(), $attributes = array()) {  $page = isset($_GET['page']) ? $_GET['page'] : '';  if ($new_page = implode(',', pager_load_array($page_new[$element], $element, explode(',', $page)))) {    $parameters['page'] = $new_page;  }  $query = array();  if (count($parameters)) {    $query[] = drupal_query_string_encode($parameters, array());  }  $querystring = pager_get_querystring();  if ($querystring != '') {    $query[] = $querystring;  }  // Set each pager link title  if (!isset($attributes['title'])) {    static $titles = NULL;    if (!isset($titles)) {      $titles = array(        t(' first') => t('Go to first page'),        t(' previous') => t('Go to previous page'),        t('next ') => t('Go to next page'),        t('last ') => t('Go to last page'),      );    }    if (isset($titles[$text])) {      $attributes['title'] = $titles[$text];    }    else if (is_numeric($text)) {      $attributes['title'] = t('Go to page @number', array('@number' => $text));    }  }  return l($text, $_GET['q'], array('attributes' => $attributes, 'query' => count($query) ? implode('&', $query) : NULL));}/** * @} End of "Pager pieces". *//** * Helper function * * Copies $old_array to $new_array and sets $new_array[$element] = $value * Fills in $new_array[0 .. $element - 1] = 0 */function pager_load_array($value, $element, $old_array) {  $new_array = $old_array;  // Look for empty elements.  for ($i = 0; $i < $element; $i++) {    if (!$new_array[$i]) {      // Load found empty element with 0.      $new_array[$i] = 0;    }  }  // Update the changed element.  $new_array[$element] = (int)$value;  return $new_array;}
<?php// $Id$/** * Implementation of hook_install(). */function aggregator_install() {  // Create tables.  drupal_install_schema('aggregator');}/** * Implementation of hook_uninstall(). */function aggregator_uninstall() {  // Remove tables.  drupal_uninstall_schema('aggregator');  variable_del('aggregator_allowed_html_tags');  variable_del('aggregator_summary_items');  variable_del('aggregator_clear');  variable_del('aggregator_category_selector');}/** * Implementation of hook_schema(). */function aggregator_schema() {  $schema['aggregator_category'] = array(    'description' => 'Stores categories for aggregator feeds and feed items.',    'fields' => array(      'cid'  => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique aggregator category ID.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Title of the category.',      ),      'description' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Description of the category',      ),      'block' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'The number of recent items to show within the category block.',      )    ),    'primary key' => array('cid'),    'unique keys' => array('title' => array('title')),  );  $schema['aggregator_category_feed'] = array(    'description' => 'Bridge table; maps feeds to categories.',    'fields' => array(      'fid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => "The feed's {aggregator_feed}.fid.",      ),      'cid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {aggregator_category}.cid to which the feed is being assigned.',      )    ),    'primary key' => array('cid', 'fid'),    'indexes' => array('fid' => array('fid')),  );  $schema['aggregator_category_item'] = array(    'description' => 'Bridge table; maps feed items to categories.',    'fields' => array(      'iid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => "The feed item's {aggregator_item}.iid.",      ),      'cid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {aggregator_category}.cid to which the feed item is being assigned.',      )    ),    'primary key' => array('cid', 'iid'),    'indexes' => array('iid' => array('iid')),  );  $schema['aggregator_feed'] = array(    'description' => 'Stores feeds to be parsed by the aggregator.',    'fields' => array(      'fid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique feed ID.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Title of the feed.',      ),      'url' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'URL to the feed.',      ),      'refresh' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'How often to check for new feed items, in seconds.',      ),      'checked' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Last time feed was checked for new items, as Unix timestamp.',      ),      'link' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'The parent website of the feed; comes from the &lt;link&gt; element in the feed.',      ),      'description' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => "The parent website's description; comes from the &lt;description&gt; element in the feed.",      ),      'image' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'An image representing the feed.',      ),      'etag' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Entity tag HTTP response header, used for validating cache.',      ),      'modified' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'When the feed was last modified, as a Unix timestamp.',      ),      'block' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => "Number of items to display in the feed's block.",      )    ),    'primary key' => array('fid'),    'unique keys' => array(      'url'  => array('url'),      'title' => array('title'),    ),  );  $schema['aggregator_item'] = array(    'description' => 'Stores the individual items imported from feeds.',    'fields' => array(      'iid'  => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Primary Key: Unique ID for feed item.',      ),      'fid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The {aggregator_feed}.fid to which this item belongs.',      ),      'title' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Title of the feed item.',      ),      'link' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Link to the feed item.',      ),      'author' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Author of the feed item.',      ),      'description' => array(        'type' => 'text',        'not null' => TRUE,        'size' => 'big',        'description' => 'Body of the feed item.',      ),      'timestamp' => array(        'type' => 'int',        'not null' => FALSE,        'description' => 'Post date of feed item, as a Unix timestamp.',      ),      'guid' => array(        'type' => 'varchar',        'length' => 255,        'not null' => FALSE,        'description' => 'Unique identifier for the feed item.',      )    ),    'primary key' => array('iid'),    'indexes' => array('fid' => array('fid')),  );  return $schema;}
