<?php// $Id$/** * @file page.tpl.php * * Theme implementation to display a single Drupal page. * * Available variables: * * General utility variables: * - $base_path: The base URL path of the Drupal installation. At the very *   least, this will always default to /. * - $css: An array of CSS files for the current page. * - $directory: The directory the theme is located in, e.g. themes/garland or *   themes/garland/minelli. * - $is_front: TRUE if the current page is the front page. Used to toggle the mission statement. * - $logged_in: TRUE if the user is registered and signed in. * - $is_admin: TRUE if the user has permission to access administration pages. * * Page metadata: * - $language: (object) The language the site is being displayed in. *   $language->language contains its textual representation. *   $language->dir contains the language direction. It will either be 'ltr' or 'rtl'. * - $head_title: A modified version of the page title, for use in the TITLE tag. * - $head: Markup for the HEAD section (including meta tags, keyword tags, and *   so on). * - $styles: Style tags necessary to import all CSS files for the page. * - $scripts: Script tags necessary to load the JavaScript files and settings *   for the page. * - $body_classes: A set of CSS classes for the BODY tag. This contains flags *   indicating the current layout (multiple columns, single column), the current *   path, whether the user is logged in, and so on. * * Site identity: * - $front_page: The URL of the front page. Use this instead of $base_path, *   when linking to the front page. This includes the language domain or prefix. * - $logo: The path to the logo image, as defined in theme configuration. * - $site_name: The name of the site, empty when display has been disabled *   in theme settings. * - $site_slogan: The slogan of the site, empty when display has been disabled *   in theme settings. * - $mission: The text of the site mission, empty when display has been disabled *   in theme settings. * * Navigation: * - $search_box: HTML to display the search box, empty if search has been disabled. * - $primary_links (array): An array containing primary navigation links for the *   site, if they have been configured. * - $secondary_links (array): An array containing secondary navigation links for *   the site, if they have been configured. * * Page content (in order of occurrance in the default page.tpl.php): * - $left: The HTML for the left sidebar. * * - $breadcrumb: The breadcrumb trail for the current page. * - $title: The page title, for use in the actual HTML content. * - $help: Dynamic help text, mostly for admin pages. * - $messages: HTML for status and error messages. Should be displayed prominently. * - $tabs: Tabs linking to any sub-pages beneath the current page (e.g., the view *   and edit tabs when displaying a node). * * - $content: The main content of the current Drupal page. * * - $right: The HTML for the right sidebar. * * Footer/closing data: * - $feed_icons: A string of all feed icons for the current page. * - $footer_message: The footer message as defined in the admin settings. * - $footer : The footer region. * - $closure: Final closing markup from any modules that have altered the page. *   This variable should always be output last, after all other dynamic content. * * @see template_preprocess() * @see template_preprocess_page() */?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>"><head>  <?php print $head; ?>  <title><?php print $head_title; ?></title>  <?php print $styles; ?>  <?php print $scripts; ?>  <script type="text/javascript"><?php /* Needed to avoid Flash of Unstyled Content in IE */ ?> </script></head><body class="<?php print $body_classes; ?>">  <div id="page">    <div id="header">      <div id="logo-title">        <?php if (!empty($logo)): ?>          <a href="<?php print $front_page; ?>" title="<?php print t('Home'); ?>" rel="home" id="logo">            <img src="<?php print $logo; ?>" alt="<?php print t('Home'); ?>" />          </a>        <?php endif; ?>        <div id="name-and-slogan">          <?php if (!empty($site_name)): ?>            <h1 id="site-name">              <a href="<?php print $front_page ?>" title="<?php print t('Home'); ?>" rel="home"><span><?php print $site_name; ?></span></a>            </h1>          <?php endif; ?>          <?php if (!empty($site_slogan)): ?>            <div id="site-slogan"><?php print $site_slogan; ?></div>          <?php endif; ?>        </div> <!-- /name-and-slogan -->      </div> <!-- /logo-title -->      <?php if (!empty($search_box)): ?>        <div id="search-box"><?php print $search_box; ?></div>      <?php endif; ?>      <?php if (!empty($header)): ?>        <div id="header-region">          <?php print $header; ?>        </div>      <?php endif; ?>    </div> <!-- /header -->    <div id="container" class="clear-block">      <div id="navigation" class="menu <?php if (!empty($primary_links)) { print "withprimary"; } if (!empty($secondary_links)) { print " withsecondary"; } ?> ">        <?php if (!empty($primary_links)): ?>          <div id="primary" class="clear-block">            <?php print theme('links', $primary_links, array('class' => 'links primary-links')); ?>          </div>        <?php endif; ?>        <?php if (!empty($secondary_links)): ?>          <div id="secondary" class="clear-block">            <?php print theme('links', $secondary_links, array('class' => 'links secondary-links')); ?>          </div>        <?php endif; ?>      </div> <!-- /navigation -->      <?php if (!empty($left)): ?>        <div id="sidebar-left" class="column sidebar">          <?php print $left; ?>        </div> <!-- /sidebar-left -->      <?php endif; ?>      <div id="main" class="column"><div id="main-squeeze">        <?php if (!empty($breadcrumb)): ?><div id="breadcrumb"><?php print $breadcrumb; ?></div><?php endif; ?>        <?php if (!empty($mission)): ?><div id="mission"><?php print $mission; ?></div><?php endif; ?>        <div id="content">          <?php if (!empty($title)): ?><h1 class="title" id="page-title"><?php print $title; ?></h1><?php endif; ?>          <?php if (!empty($tabs)): ?><div class="tabs"><?php print $tabs; ?></div><?php endif; ?>          <?php if (!empty($messages)): print $messages; endif; ?>          <?php if (!empty($help)): print $help; endif; ?>          <div id="content-content" class="clear-block">            <?php print $content; ?>          </div> <!-- /content-content -->          <?php print $feed_icons; ?>        </div> <!-- /content -->      </div></div> <!-- /main-squeeze /main -->      <?php if (!empty($right)): ?>        <div id="sidebar-right" class="column sidebar">          <?php print $right; ?>        </div> <!-- /sidebar-right -->      <?php endif; ?>    </div> <!-- /container -->    <div id="footer-wrapper">      <div id="footer">        <?php print $footer_message; ?>        <?php if (!empty($footer)): print $footer; endif; ?>      </div> <!-- /footer -->    </div> <!-- /footer-wrapper -->    <?php print $closure; ?>  </div> <!-- /page --></body></html>
<?php// $Id$/** * Implementation of hook_install(). */function locale_install() {  // locales_source.source and locales_target.target are not used as binary  // fields; non-MySQL database servers need to ensure the field type is text  // and that LIKE produces a case-sensitive comparison.  // Create tables.  drupal_install_schema('locale');  db_query("INSERT INTO {languages} (language, name, native, direction, enabled, weight, javascript) VALUES ('en', 'English', 'English', '0', '1', '0', '')");}/** * @defgroup updates-5.x-to-6.x Locale updates from 5.x to 6.x * @{ *//** * {locales_meta} table became {languages}. */function locale_update_6000() {  $ret = array();  $schema['languages'] = array(    'fields' => array(      'language' => array(        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => '',      ),      'name' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',      ),      'native' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',      ),      'direction' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,      ),      'enabled' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,      ),      'plurals' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,      ),      'formula' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',      ),      'domain' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',      ),      'prefix' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,      ),      'javascript' => array( //Adds a column to store the filename of the JavaScript translation file.        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '',      ),    ),    'primary key' => array('language'),    'indexes' => array(      'list' => array('weight', 'name'),    ),  );  db_create_table($ret, 'languages', $schema['languages']);  // Save the languages  $ret[] = update_sql("INSERT INTO {languages} (language, name, native, direction, enabled, plurals, formula, domain, prefix, weight) SELECT locale, name, name, 0, enabled, plurals, formula, '', locale, 0 FROM {locales_meta}");  // Save the language count in the variable table  $count = db_result(db_query('SELECT COUNT(*) FROM {languages} WHERE enabled = 1'));  variable_set('language_count', $count);  // Save the default language in the variable table  $default = db_fetch_object(db_query('SELECT * FROM {locales_meta} WHERE isdefault = 1'));  variable_set('language_default', (object) array('language' => $default->locale, 'name' => $default->name, 'native' => '', 'direction' => 0, 'enabled' => 1, 'plurals' => $default->plurals, 'formula' => $default->formula, 'domain' => '', 'prefix' => $default->locale, 'weight' => 0));  $ret[] = update_sql("DROP TABLE {locales_meta}");  return $ret;}/** * Change locale column to language. The language column is added by * update_fix_d6_requirements() in update.php to avoid a large number * of error messages from update.php.  All we need to do here is copy * locale to language and then drop locale. */function locale_update_6001() {  $ret = array();  $ret[] = update_sql('UPDATE {locales_target} SET language = locale');  db_drop_field($ret, 'locales_target', 'locale');  return $ret;}/** * Remove empty translations, we don't need these anymore. */function locale_update_6002() {  $ret = array();  $ret[] = update_sql("DELETE FROM {locales_target} WHERE translation = ''");  return $ret;}/** * Prune strings with no translations (will be automatically re-registered if still in use) */function locale_update_6003() {  $ret = array();  $ret[] = update_sql("DELETE FROM {locales_source} WHERE lid NOT IN (SELECT lid FROM {locales_target})");  return $ret;}/** * Fix remaining inconsistent indexes. */function locale_update_6004() {  $ret = array();  db_add_index($ret, 'locales_target', 'language', array('language'));  switch ($GLOBALS['db_type']) {    case 'pgsql':      db_drop_index($ret, 'locales_source', 'source');      db_add_index($ret, 'locales_source', 'source', array(array('source', 30)));      break;  }  return $ret;}/** * Change language setting variable of content types. * * Use language_content_type_<content_type> instead of language_<content_type> * so content types such as 'default', 'count' or 'negotiation' will not * interfere with language variables. */function locale_update_6005() {  foreach (node_get_types() as $type => $content_type) {    // Default to NULL, so we can skip dealing with non-existent settings.    $setting = variable_get('language_'. $type, NULL);    if ($type == 'default' && is_numeric($setting)) {      // language_default was overwritten with the content type setting,      // so reset the default language and save the content type setting.      variable_set('language_content_type_default', $setting);      variable_del('language_default');      drupal_set_message('The default language setting has been reset to its default value. Check the '. l('language configuration page', 'admin/settings/language') .' to configure it correctly.');    }    elseif ($type == 'negotiation') {      // language_content_type_negotiation is an integer either if it is      // the negotiation setting or the content type setting.      // The language_negotiation setting is not reset, but      // the user is alerted that this setting possibly was overwritten      variable_set('language_content_type_negotiation', $setting);      drupal_set_message('The language negotiation setting was possibly overwritten by a content type of the same name. Check the '. l('language configuration page', 'admin/settings/language/configure') .' and the '. l('<em>'. $content_type->name ."</em> content type's multilingual support settings", 'admin/content/types/negotiation', array('html' => TRUE)) .' to configure them correctly.');    }    elseif (!is_null($setting)) {      // Change the language setting variable for any other content type.      // Do not worry about language_count, it will be updated below.      variable_set('language_content_type_'. $type, $setting);      variable_del('language_'. $type);    }  }  // Update language count variable that might be overwritten.  $count = db_result(db_query('SELECT COUNT(*) FROM {languages} WHERE enabled = 1'));  variable_set('language_count', $count);  return array();}/** * Neutralize unsafe language names in the database. */function locale_update_6006() {  $ret = array();  $matches = db_result(db_query("SELECT 1 FROM {languages} WHERE native LIKE '%<%' OR native LIKE '%>%' OR name LIKE '%<%' OR name LIKE '%>%'"));  if ($matches) {    $ret[] = update_sql("UPDATE {languages} SET name = REPLACE(name, '<', ''), native = REPLACE(native, '<', '')");    $ret[] = update_sql("UPDATE {languages} SET name = REPLACE(name, '>', ''), native = REPLACE(native, '>', '')");    drupal_set_message('The language name in English and the native language name values of all the existing custom languages of your site have been sanitized for security purposes. Visit the <a href="'. url('admin/settings/language') .'">Languages</a> page to check these and fix them if necessary.', 'warning');  }  // Check if some langcode values contain potentially dangerous characters and  // warn the user if so. These are not fixed since they are referenced in other  // tables (e.g. {node}).  if (db_result(db_query("SELECT 1 FROM {languages} WHERE language LIKE '%<%' OR language LIKE '%>%' OR language LIKE '%\"%' OR language LIKE '%\\\\\%'"))) {    drupal_set_message('Some of your custom language code values contain invalid characters. You should examine the <a href="'. url('admin/settings/language') .'">Languages</a> page. These must be fixed manually.', 'error');  }  return $ret;}/** * @} End of "defgroup updates-5.x-to-6.x" *//** * Implementation of hook_uninstall(). */function locale_uninstall() {  // Delete all JavaScript translation files  $files = db_query('SELECT javascript FROM {languages}');  while ($file = db_fetch_object($files)) {    if (!empty($file)) {      file_delete(file_create_path($file->javascript));    }  }  // Clear variables.  variable_del('language_default');  variable_del('language_count');  variable_del('language_content_type_default');  variable_del('language_content_type_negotiation');  variable_del('locale_cache_strings');  variable_del('locale_js_directory');  variable_del('javascript_parsed');  variable_del('language_negotiation');  foreach (node_get_types() as $type => $content_type) {    variable_del("language_content_type_$type");  }  // Switch back to English: with a $language->language value different from  // 'en' successive calls of t() might result in calling locale(), which in  // turn might try to query the unexisting {locales_source} and  // {locales_target} tables.  drupal_init_language();  // Remove tables.  drupal_uninstall_schema('locale');}/** * Implementation of hook_schema(). */function locale_schema() {  $schema['languages'] = array(    'description' => 'List of all available languages in the system.',    'fields' => array(      'language' => array(        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => '',        'description' => "Language code, e.g. 'de' or 'en-US'.",      ),      'name' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Language name in English.',      ),      'native' => array(        'type' => 'varchar',        'length' => 64,        'not null' => TRUE,        'default' => '',        'description' => 'Native language name.',      ),      'direction' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Direction of language (Left-to-Right = 0, Right-to-Left = 1).',      ),      'enabled' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Enabled flag (1 = Enabled, 0 = Disabled).',      ),      'plurals' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Number of plural indexes in this language.',      ),      'formula' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Plural formula in PHP code to evaluate to get plural indexes.',      ),      'domain' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Domain to use for this language.',      ),      'prefix' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'Path prefix to use for this language.',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Weight, used in lists of languages.',      ),      'javascript' => array(        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => '',        'description' => 'Location of JavaScript translation file.',      ),    ),    'primary key' => array('language'),    'indexes' => array(      'list' => array('weight', 'name'),    ),  );  $schema['locales_source'] = array(    'description' => 'List of English source strings.',    'fields' => array(      'lid' => array(        'type' => 'serial',        'not null' => TRUE,        'description' => 'Unique identifier of this string.',      ),      'location' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Drupal path in case of online discovered translations or file path in case of imported strings.',      ),      'textgroup' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => 'default',        'description' => 'A module defined group of translations, see hook_locale().',      ),      'source' => array(        'type' => 'text',        'mysql_type' => 'blob',        'not null' => TRUE,        'description' => 'The original string in English.',      ),      'version' => array(        'type' => 'varchar',        'length' => 20,        'not null' => TRUE,        'default' => 'none',        'description' => 'Version of Drupal, where the string was last used (for locales optimization).',      ),    ),    'primary key' => array('lid'),    'indexes' => array(      'source' => array(array('source', 30)),    ),  );  $schema['locales_target'] = array(    'description' => 'Stores translated versions of strings.',    'fields' => array(      'lid' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Source string ID. References {locales_source}.lid.',      ),      'translation' => array(        'type' => 'text',        'mysql_type' => 'blob',        'not null' => TRUE,        'description' => 'Translation string value in this language.',      ),      'language' => array(        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => '',        'description' => 'Language code. References {languages}.language.',      ),      'plid' => array(        'type' => 'int',        'not null' => TRUE, // This should be NULL for no referenced string, not zero.        'default' => 0,        'description' => 'Parent lid (lid of the previous string in the plural chain) in case of plural strings. References {locales_source}.lid.',      ),      'plural' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'Plural index number in case of plural strings.',      ),    ),    'primary key' => array('language', 'lid', 'plural'),    'indexes' => array(      'lid'      => array('lid'),      'plid'     => array('plid'),      'plural'   => array('plural'),    ),  );  return $schema;}
<?php// $Id$/** * @file * Enables users to comment on published content. * * When enabled, the Drupal comment module creates a discussion * board for each Drupal node. Users can post comments to discuss * a forum topic, weblog post, story, collaborative book page, etc. *//** * Comment is published. */define('COMMENT_PUBLISHED', 0);/** * Comment is awaiting approval. */define('COMMENT_NOT_PUBLISHED', 1);/** * Comments are displayed in a flat list - collapsed. */define('COMMENT_MODE_FLAT_COLLAPSED', 1);/** * Comments are displayed in a flat list - expanded. */define('COMMENT_MODE_FLAT_EXPANDED', 2);/** * Comments are displayed as a threaded list - collapsed. */define('COMMENT_MODE_THREADED_COLLAPSED', 3);/** * Comments are displayed as a threaded list - expanded. */define('COMMENT_MODE_THREADED_EXPANDED', 4);/** * Comments are ordered by date - newest first. */define('COMMENT_ORDER_NEWEST_FIRST', 1);/** * Comments are ordered by date - oldest first. */define('COMMENT_ORDER_OLDEST_FIRST', 2);/** * Comment controls should be shown above the comment list. */define('COMMENT_CONTROLS_ABOVE', 0);/** * Comment controls should be shown below the comment list. */define('COMMENT_CONTROLS_BELOW', 1);/** * Comment controls should be shown both above and below the comment list. */define('COMMENT_CONTROLS_ABOVE_BELOW', 2);/** * Comment controls are hidden. */define('COMMENT_CONTROLS_HIDDEN', 3);/** * Anonymous posters may not enter their contact information. */define('COMMENT_ANONYMOUS_MAYNOT_CONTACT', 0);/** * Anonymous posters may leave their contact information. */define('COMMENT_ANONYMOUS_MAY_CONTACT', 1);/** * Anonymous posters must leave their contact information. */define('COMMENT_ANONYMOUS_MUST_CONTACT', 2);/** * Comment form should be displayed on a separate page. */define('COMMENT_FORM_SEPARATE_PAGE', 0);/** * Comment form should be shown below post or list of comments. */define('COMMENT_FORM_BELOW', 1);/** * Comments for this node are disabled. */define('COMMENT_NODE_DISABLED', 0);/** * Comments for this node are locked. */define('COMMENT_NODE_READ_ONLY', 1);/** * Comments are enabled on this node. */define('COMMENT_NODE_READ_WRITE', 2);/** * Comment preview is optional. */define('COMMENT_PREVIEW_OPTIONAL', 0);/** * Comment preview is required. */define('COMMENT_PREVIEW_REQUIRED', 1);/** * Implementation of hook_help(). */function comment_help($path, $arg) {  switch ($path) {    case 'admin/help#comment':      $output = '<p>'. t('The comment module allows visitors to comment on your posts, creating ad hoc discussion boards. Any <a href="@content-type">content type</a> may have its <em>Default comment setting</em> set to <em>Read/Write</em> to allow comments, or <em>Disabled</em>, to prevent comments. Comment display settings and other controls may also be customized for each content type (some display settings are customizable by individual users).', array('@content-type' => url('admin/content/types'))) .'</p>';      $output .= '<p>'. t('Comment permissions are assigned to user roles, and are used to determine whether anonymous users (or other roles) are allowed to comment on posts. If anonymous users are allowed to comment, their individual contact information may be retained in cookies stored on their local computer for use in later comment submissions. When a comment has no replies, it may be (optionally) edited by its author. The comment module uses the same input formats and HTML tags available when creating other forms of content.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@comment">Comment module</a>.', array('@comment' => 'http://drupal.org/handbook/modules/comment/')) .'</p>';      return $output;    case 'admin/content/comment':      return '<p>'. t("Below is a list of the latest comments posted to your site. Click on a subject to see the comment, the author's name to edit the author's user information, 'edit' to modify the text, and 'delete' to remove their submission.") .'</p>';    case 'admin/content/comment/approval':      return '<p>'. t("Below is a list of the comments posted to your site that need approval. To approve a comment, click on 'edit' and then change its 'moderation status' to Approved. Click on a subject to see the comment, the author's name to edit the author's user information, 'edit' to modify the text, and 'delete' to remove their submission.") .'</p>';  }}/** * Implementation of hook_theme(). */function comment_theme() {  return array(    'comment_block' => array(      'arguments' => array(),    ),    'comment_admin_overview' => array(      'arguments' => array('form' => NULL),    ),    'comment_preview' => array(      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array(), 'visible' => 1),    ),    'comment_view' => array(      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array(), 'visible' => 1),    ),    'comment_controls' => array(      'arguments' => array('form' => NULL),    ),    'comment' => array(      'template' => 'comment',      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array()),    ),    'comment_folded' => array(      'template' => 'comment-folded',      'arguments' => array('comment' => NULL),    ),    'comment_flat_collapsed' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_flat_expanded' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_thread_collapsed' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_thread_expanded' => array(      'arguments' => array('comment' => NULL, 'node' => NULL),    ),    'comment_post_forbidden' => array(      'arguments' => array('nid' => NULL),    ),    'comment_wrapper' => array(      'template' => 'comment-wrapper',      'arguments' => array('content' => NULL, 'node' => NULL),    ),    'comment_submitted' => array(      'arguments' => array('comment' => NULL),    ),  );}/** * Implementation of hook_menu(). */function comment_menu() {  $items['admin/content/comment'] = array(    'title' => 'Comments',    'description' => 'List and edit site comments and the comment moderation queue.',    'page callback' => 'comment_admin',    'access arguments' => array('administer comments'),    'file' => 'comment.admin.inc',  );  // Tabs:  $items['admin/content/comment/new'] = array(    'title' => 'Published comments',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/comment/approval'] = array(    'title' => 'Approval queue',    'page arguments' => array('approval'),    'access arguments' => array('administer comments'),    'type' => MENU_LOCAL_TASK,    'file' => 'comment.admin.inc',  );  $items['comment/delete'] = array(    'title' => 'Delete comment',    'page callback' => 'comment_delete',    'access arguments' => array('administer comments'),    'type' => MENU_CALLBACK,    'file' => 'comment.admin.inc',  );  $items['comment/edit'] = array(    'title' => 'Edit comment',    'page callback' => 'comment_edit',    'access arguments' => array('post comments'),    'type' => MENU_CALLBACK,    'file' => 'comment.pages.inc',  );  $items['comment/reply/%node'] = array(    'title' => 'Reply to comment',    'page callback' => 'comment_reply',    'page arguments' => array(2),    'access callback' => 'node_access',    'access arguments' => array('view', 2),    'type' => MENU_CALLBACK,    'file' => 'comment.pages.inc',  );  return $items;}/** * Implementation of hook_node_type(). */function comment_node_type($op, $info) {  $settings = array(    'comment',    'comment_default_mode',    'comment_default_order',    'comment_default_per_page',    'comment_controls',    'comment_anonymous',    'comment_subject_field',    'comment_preview',    'comment_form_location',  );  switch ($op) {    case 'delete':      foreach ($settings as $setting) {        variable_del($setting .'_'. $info->type);      }      break;  }}/** * Implementation of hook_perm(). */function comment_perm() {  return array('access comments', 'post comments', 'administer comments', 'post comments without approval');}/** * Implementation of hook_block(). * * Generates a block with the most recent comments. */function comment_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Recent comments');    return $blocks;  }  else if ($op == 'view' && user_access('access comments')) {    $block['subject'] = t('Recent comments');    $block['content'] = theme('comment_block');    return $block;  }}/** * Find a number of recent comments. This is done in two steps. *   1. Find the n (specified by $number) nodes that have the most recent *      comments.  This is done by querying node_comment_statistics which has *      an index on last_comment_timestamp, and is thus a fast query. *   2. Loading the information from the comments table based on the nids found *      in step 1. * * @param $number *   (optional) The maximum number of comments to find. * @return *   An array of comment objects each containing a nid, *   subject, cid, and timestamp, or an empty array if there are no recent *   comments visible to the current user. */function comment_get_recent($number = 10) {  // Select the $number nodes (visible to the current user) with the most  // recent comments. This is efficient due to the index on  // last_comment_timestamp.  $result = db_query_range(db_rewrite_sql("SELECT nc.nid FROM {node_comment_statistics} nc WHERE nc.comment_count > 0 ORDER BY nc.last_comment_timestamp DESC", 'nc'), 0, $number);  $nids = array();  while ($row = db_fetch_object($result)) {    $nids[] = $row->nid;  }  $comments = array();  if (!empty($nids)) {    // From among the comments on the nodes selected in the first query,    // find the $number most recent comments.    $result = db_query_range('SELECT c.nid, c.subject, c.cid, c.timestamp FROM {comments} c INNER JOIN {node} n ON n.nid = c.nid WHERE c.nid IN ('. implode(',', $nids) .') AND n.status = 1 AND c.status = %d ORDER BY c.cid DESC', COMMENT_PUBLISHED, 0, $number);    while ($comment = db_fetch_object($result)) {      $comments[] = $comment;    }  }  return $comments;}/** * Calculate page number for first new comment. * * @param $num_comments *   Number of comments. * @param $new_replies *   Number of new replies. * @param $node *   The first new comment node. * @return *   "page=X" if the page number is greater than zero; empty string otherwise. */function comment_new_page_count($num_comments, $new_replies, $node) {  $comments_per_page = _comment_get_display_setting('comments_per_page', $node);  $mode = _comment_get_display_setting('mode', $node);  $order = _comment_get_display_setting('sort', $node);  $pagenum = NULL;  $flat = in_array($mode, array(COMMENT_MODE_FLAT_COLLAPSED, COMMENT_MODE_FLAT_EXPANDED));  if ($num_comments <= $comments_per_page || ($flat && $order == COMMENT_ORDER_NEWEST_FIRST)) {    // Only one page of comments or flat forum and newest first.    // First new comment will always be on first page.    $pageno = 0;  }  else {    if ($flat) {      // Flat comments and oldest first.      $count = $num_comments - $new_replies;    }    else {      // Threaded comments. See the documentation for comment_render().      if ($order == COMMENT_ORDER_NEWEST_FIRST) {        // Newest first: find the last thread with new comment        $result = db_query('SELECT thread FROM (SELECT thread FROM {comments} WHERE nid = %d AND status = 0 ORDER BY timestamp DESC LIMIT %d) AS thread ORDER BY thread DESC LIMIT 1', $node->nid, $new_replies);        $thread = db_result($result);        $result_count = db_query("SELECT COUNT(*) FROM {comments} WHERE nid = %d AND status = 0 AND thread > '". $thread ."'", $node->nid);      }      else {        // Oldest first: find the first thread with new comment        $result = db_query('SELECT thread FROM (SELECT thread FROM {comments} WHERE nid = %d AND status = 0 ORDER BY timestamp DESC LIMIT %d) AS thread ORDER BY SUBSTRING(thread, 1, (LENGTH(thread) - 1)) LIMIT 1', $node->nid, $new_replies);        $thread = substr(db_result($result), 0, -1);        $result_count = db_query("SELECT COUNT(*) FROM {comments} WHERE nid = %d AND status = 0 AND SUBSTRING(thread, 1, (LENGTH(thread) - 1)) < '". $thread ."'", $node->nid);      }      $count = db_result($result_count);    }    $pageno =  $count / $comments_per_page;  }  if ($pageno >= 1) {    $pagenum = "page=". intval($pageno);  }  return $pagenum;}/** * Returns a formatted list of recent comments to be displayed in the comment block. * * @return *   The comment list HTML. * @ingroup themeable */function theme_comment_block() {  $items = array();  foreach (comment_get_recent() as $comment) {    $items[] = l($comment->subject, 'node/'. $comment->nid, array('fragment' => 'comment-'. $comment->cid)) .'<br />'. t('@time ago', array('@time' => format_interval(time() - $comment->timestamp)));  }  if ($items) {    return theme('item_list', $items);  }}/** * Implementation of hook_link(). */function comment_link($type, $node = NULL, $teaser = FALSE) {  $links = array();  if ($type == 'node' && $node->comment) {    if ($teaser) {      // Main page: display the number of comments that have been posted.      if (user_access('access comments')) {        $all = comment_num_all($node->nid);        if ($all) {          $links['comment_comments'] = array(            'title' => format_plural($all, '1 comment', '@count comments'),            'href' => "node/$node->nid",            'attributes' => array('title' => t('Jump to the first comment of this posting.')),            'fragment' => 'comments'          );          $new = comment_num_new($node->nid);          if ($new) {            $links['comment_new_comments'] = array(              'title' => format_plural($new, '1 new comment', '@count new comments'),              'href' => "node/$node->nid",              'query' => comment_new_page_count($all, $new, $node),              'attributes' => array('title' => t('Jump to the first new comment of this posting.')),              'fragment' => 'new'            );          }        }        else {          if ($node->comment == COMMENT_NODE_READ_WRITE) {            if (user_access('post comments')) {              $links['comment_add'] = array(                'title' => t('Add new comment'),                'href' => "comment/reply/$node->nid",                'attributes' => array('title' => t('Add a new comment to this page.')),                'fragment' => 'comment-form'              );            }            else {              $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);            }          }        }      }    }    else {      // Node page: add a "post comment" link if the user is allowed to      // post comments, if this node is not read-only, and if the comment form isn't already shown      if ($node->comment == COMMENT_NODE_READ_WRITE) {        if (user_access('post comments')) {          if (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_SEPARATE_PAGE) {            $links['comment_add'] = array(              'title' => t('Add new comment'),              'href' => "comment/reply/$node->nid",              'attributes' => array('title' => t('Share your thoughts and opinions related to this posting.')),              'fragment' => 'comment-form'            );          }        }        else {          $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);        }      }    }  }  if ($type == 'comment') {    $links = comment_links($node, $teaser);  }  if (isset($links['comment_forbidden'])) {    $links['comment_forbidden']['html'] = TRUE;  }  return $links;}/** * Implementation of hook_form_alter(). */function comment_form_alter(&$form, $form_state, $form_id) {  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {    $form['comment'] = array(      '#type' => 'fieldset',      '#title' => t('Comment settings'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,    );    $form['comment']['comment'] = array(      '#type' => 'radios',      '#title' => t('Default comment setting'),      '#default_value' => variable_get('comment_'. $form['#node_type']->type, COMMENT_NODE_READ_WRITE),      '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),      '#description' => t('Users with the <em>administer comments</em> permission will be able to override this setting.'),    );    $form['comment']['comment_default_mode'] = array(      '#type' => 'radios',      '#title' => t('Default display mode'),      '#default_value' => variable_get('comment_default_mode_'. $form['#node_type']->type, COMMENT_MODE_THREADED_EXPANDED),      '#options' => _comment_get_modes(),      '#description' => t('The default view for comments. Expanded views display the body of the comment. Threaded views keep replies together.'),    );    $form['comment']['comment_default_order'] = array(      '#type' => 'radios',      '#title' => t('Default display order'),      '#default_value' => variable_get('comment_default_order_'. $form['#node_type']->type, COMMENT_ORDER_NEWEST_FIRST),      '#options' => _comment_get_orders(),      '#description' => t('The default sorting for new users and anonymous users while viewing comments. These users may change their view using the comment control panel. For registered users, this change is remembered as a persistent user preference.'),    );    $form['comment']['comment_default_per_page'] = array(      '#type' => 'select',      '#title' => t('Default comments per page'),      '#default_value' => variable_get('comment_default_per_page_'. $form['#node_type']->type, 50),      '#options' => _comment_per_page(),      '#description' => t('Default number of comments for each page: more comments are distributed in several pages.'),    );    $form['comment']['comment_controls'] = array(      '#type' => 'radios',      '#title' => t('Comment controls'),      '#default_value' => variable_get('comment_controls_'. $form['#node_type']->type, COMMENT_CONTROLS_HIDDEN),      '#options' => array(        t('Display above the comments'),        t('Display below the comments'),        t('Display above and below the comments'),        t('Do not display')),      '#description' => t('Position of the comment controls box. The comment controls let the user change the default display mode and display order of comments.'),    );    $form['comment']['comment_anonymous'] = array(      '#type' => 'radios',      '#title' => t('Anonymous commenting'),      '#default_value' => variable_get('comment_anonymous_'. $form['#node_type']->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT),      '#options' => array(        COMMENT_ANONYMOUS_MAYNOT_CONTACT => t('Anonymous posters may not enter their contact information'),        COMMENT_ANONYMOUS_MAY_CONTACT => t('Anonymous posters may leave their contact information'),        COMMENT_ANONYMOUS_MUST_CONTACT => t('Anonymous posters must leave their contact information')),      '#description' => t('This option is enabled when anonymous users have permission to post comments on the <a href="@url">permissions page</a>.', array('@url' => url('admin/user/permissions', array('fragment' => 'module-comment')))),    );    if (!user_access('post comments', drupal_anonymous_user())) {      $form['comment']['comment_anonymous']['#disabled'] = TRUE;    }    $form['comment']['comment_subject_field'] = array(      '#type' => 'radios',      '#title' => t('Comment subject field'),      '#default_value' => variable_get('comment_subject_field_'. $form['#node_type']->type, 1),      '#options' => array(t('Disabled'), t('Enabled')),      '#description' => t('Can users provide a unique subject for their comments?'),    );    $form['comment']['comment_preview'] = array(      '#type' => 'radios',      '#title' => t('Preview comment'),      '#default_value' => variable_get('comment_preview_'. $form['#node_type']->type, COMMENT_PREVIEW_REQUIRED),      '#options' => array(t('Optional'), t('Required')),      '#description' => t("Forces a user to look at their comment by clicking on a 'Preview' button before they can actually add the comment"),    );    $form['comment']['comment_form_location'] = array(      '#type' => 'radios',      '#title' => t('Location of comment submission form'),      '#default_value' => variable_get('comment_form_location_'. $form['#node_type']->type, COMMENT_FORM_SEPARATE_PAGE),      '#options' => array(t('Display on separate page'), t('Display below post or comments')),    );  }  elseif (isset($form['type']) && isset($form['#node'])) {    if ($form['type']['#value'] .'_node_form' == $form_id) {      $node = $form['#node'];      $form['comment_settings'] = array(        '#type' => 'fieldset',        '#access' => user_access('administer comments'),        '#title' => t('Comment settings'),        '#collapsible' => TRUE,        '#collapsed' => TRUE,        '#weight' => 30,      );      $form['comment_settings']['comment'] = array(        '#type' => 'radios',        '#parents' => array('comment'),        '#default_value' => $node->comment,        '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),      );    }  }}/** * Implementation of hook_nodeapi(). */function comment_nodeapi(&$node, $op, $arg = 0) {  switch ($op) {    case 'load':      return db_fetch_array(db_query("SELECT last_comment_timestamp, last_comment_name, comment_count FROM {node_comment_statistics} WHERE nid = %d", $node->nid));      break;    case 'prepare':      if (!isset($node->comment)) {        $node->comment = variable_get("comment_$node->type", COMMENT_NODE_READ_WRITE);      }      break;    case 'insert':      db_query('INSERT INTO {node_comment_statistics} (nid, last_comment_timestamp, last_comment_name, last_comment_uid, comment_count) VALUES (%d, %d, NULL, %d, 0)', $node->nid, $node->changed, $node->uid);      break;    case 'delete':      db_query('DELETE FROM {comments} WHERE nid = %d', $node->nid);      db_query('DELETE FROM {node_comment_statistics} WHERE nid = %d', $node->nid);      break;    case 'update index':      $text = '';      $comments = db_query('SELECT subject, comment, format FROM {comments} WHERE nid = %d AND status = %d', $node->nid, COMMENT_PUBLISHED);      while ($comment = db_fetch_object($comments)) {        $text .= '<h2>'. check_plain($comment->subject) .'</h2>'. check_markup($comment->comment, $comment->format, FALSE);      }      return $text;    case 'search result':      $comments = db_result(db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = %d', $node->nid));      return format_plural($comments, '1 comment', '@count comments');    case 'rss item':      if ($node->comment != COMMENT_NODE_DISABLED) {        return array(array('key' => 'comments', 'value' => url('node/'. $node->nid, array('fragment' => 'comments', 'absolute' => TRUE))));      }      else {        return array();      }  }}/** * Implementation of hook_user(). */function comment_user($type, $edit, &$user, $category = NULL) {  if ($type == 'delete') {    db_query('UPDATE {comments} SET uid = 0 WHERE uid = %d', $user->uid);    db_query('UPDATE {node_comment_statistics} SET last_comment_uid = 0 WHERE last_comment_uid = %d', $user->uid);  }}/** * This is *not* a hook_access() implementation. This function is called * to determine whether the current user has access to a particular comment. * * Authenticated users can edit their comments as long they have not been * replied to. This prevents people from changing or revising their * statements based on the replies to their posts. * * @param $op *   The operation that is to be performed on the comment. Only 'edit' is recognized now. * @param $comment *   The comment object. * @return *   TRUE if the current user has acces to the comment, FALSE otherwise. */function comment_access($op, $comment) {  global $user;  if ($op == 'edit') {    return ($user->uid && $user->uid == $comment->uid && comment_num_replies($comment->cid) == 0) || user_access('administer comments');  }}/** * A simple helper function. * * @return *   The 0th and the 1st path components joined by a slash. */function comment_node_url() {  return arg(0) .'/'. arg(1);}/** * Accepts a submission of new or changed comment content. * * @param $edit *   A comment array. * * @return *   If the comment is successfully saved the comment ID is returned. If the comment *   is not saved, FALSE is returned. */function comment_save($edit) {  global $user;  if (user_access('post comments') && (user_access('administer comments') || node_comment_mode($edit['nid']) == COMMENT_NODE_READ_WRITE)) {    if (!form_get_errors()) {      $edit += array(        'mail' => '',        'homepage' => '',        'name' => '',        'status' => user_access('post comments without approval') ? COMMENT_PUBLISHED : COMMENT_NOT_PUBLISHED,      );      if ($edit['cid']) {        // Update the comment in the database.        db_query("UPDATE {comments} SET status = %d, timestamp = %d, subject = '%s', comment = '%s', format = %d, uid = %d, name = '%s', mail = '%s', homepage = '%s' WHERE cid = %d", $edit['status'], $edit['timestamp'], $edit['subject'], $edit['comment'], $edit['format'], $edit['uid'], $edit['name'], $edit['mail'], $edit['homepage'], $edit['cid']);        // Allow modules to respond to the updating of a comment.        comment_invoke_comment($edit, 'update');        // Add an entry to the watchdog log.        watchdog('content', 'Comment: updated %subject.', array('%subject' => $edit['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $edit['nid'], array('fragment' => 'comment-'. $edit['cid'])));      }      else {        // Add the comment to database.        // Here we are building the thread field. See the documentation for        // comment_render().        if ($edit['pid'] == 0) {          // This is a comment with no parent comment (depth 0): we start          // by retrieving the maximum thread level.          $max = db_result(db_query('SELECT MAX(thread) FROM {comments} WHERE nid = %d', $edit['nid']));          // Strip the "/" from the end of the thread.          $max = rtrim($max, '/');          // Finally, build the thread field for this new comment.          $thread = int2vancode(vancode2int($max) + 1) .'/';        }        else {          // This is comment with a parent comment: we increase          // the part of the thread value at the proper depth.          // Get the parent comment:          $parent = _comment_load($edit['pid']);          // Strip the "/" from the end of the parent thread.          $parent->thread = (string) rtrim((string) $parent->thread, '/');          // Get the max value in _this_ thread.          $max = db_result(db_query("SELECT MAX(thread) FROM {comments} WHERE thread LIKE '%s.%%' AND nid = %d", $parent->thread, $edit['nid']));          if ($max == '') {            // First child of this parent.            $thread = $parent->thread .'.'. int2vancode(0) .'/';          }          else {            // Strip the "/" at the end of the thread.            $max = rtrim($max, '/');            // We need to get the value at the correct depth.            $parts = explode('.', $max);            $parent_depth = count(explode('.', $parent->thread));            $last = $parts[$parent_depth];            // Finally, build the thread field for this new comment.            $thread = $parent->thread .'.'. int2vancode(vancode2int($last) + 1) .'/';          }        }        if (empty($edit['timestamp'])) {          $edit['timestamp'] = time();        }        if ($edit['uid'] === $user->uid && isset($user->name)) { // '===' Need to modify anonymous users as well.          $edit['name'] = $user->name;        }        db_query("INSERT INTO {comments} (nid, pid, uid, subject, comment, format, hostname, timestamp, status, thread, name, mail, homepage) VALUES (%d, %d, %d, '%s', '%s', %d, '%s', %d, %d, '%s', '%s', '%s', '%s')", $edit['nid'], $edit['pid'], $edit['uid'], $edit['subject'], $edit['comment'], $edit['format'], ip_address(), $edit['timestamp'], $edit['status'], $thread, $edit['name'], $edit['mail'], $edit['homepage']);        $edit['cid'] = db_last_insert_id('comments', 'cid');        // Tell the other modules a new comment has been submitted.        comment_invoke_comment($edit, 'insert');        // Add an entry to the watchdog log.        watchdog('content', 'Comment: added %subject.', array('%subject' => $edit['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $edit['nid'], array('fragment' => 'comment-'. $edit['cid'])));      }      _comment_update_node_statistics($edit['nid']);      // Clear the cache so an anonymous user can see his comment being added.      cache_clear_all();      // Explain the approval queue if necessary, and then      // redirect the user to the node he's commenting on.      if ($edit['status'] == COMMENT_NOT_PUBLISHED) {        drupal_set_message(t('Your comment has been queued for moderation by site administrators and will be published after approval.'));      }      else {        comment_invoke_comment($edit, 'publish');      }      return $edit['cid'];    }    else {      return FALSE;    }  }  else {    watchdog('content', 'Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $edit['subject']), WATCHDOG_WARNING);    drupal_set_message(t('Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $edit['subject'])), 'error');    return FALSE;  }}/** * Build command links for a comment (e.g.\ edit, reply, delete) with respect to the current user's access permissions. * * @param $comment *   The comment to which the links will be related. * @param $return *   Not used. * @return *   An associative array containing the links. */function comment_links($comment, $return = 1) {  global $user;  $links = array();  // If we are viewing just this comment, we link back to the node.  if ($return) {    $links['comment_parent'] = array(      'title' => t('parent'),      'href' => comment_node_url(),      'fragment' => "comment-$comment->cid"    );  }  if (node_comment_mode($comment->nid) == COMMENT_NODE_READ_WRITE) {    if (user_access('administer comments') && user_access('post comments')) {      $links['comment_delete'] = array(        'title' => t('delete'),        'href' => "comment/delete/$comment->cid"      );      $links['comment_edit'] = array(        'title' => t('edit'),        'href' => "comment/edit/$comment->cid"      );      $links['comment_reply'] = array(        'title' => t('reply'),        'href' => "comment/reply/$comment->nid/$comment->cid"      );    }    else if (user_access('post comments')) {      if (comment_access('edit', $comment)) {        $links['comment_edit'] = array(          'title' => t('edit'),          'href' => "comment/edit/$comment->cid"        );      }      $links['comment_reply'] = array(        'title' => t('reply'),        'href' => "comment/reply/$comment->nid/$comment->cid"      );    }    else {      $node = node_load($comment->nid);      $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);    }  }  return $links;}/** * Renders comment(s). * * @param $node *   The node which comment(s) needs rendering. * @param $cid *   Optional, if given, only one comment is rendered. * * To display threaded comments in the correct order we keep a 'thread' field * and order by that value. This field keeps this data in * a way which is easy to update and convenient to use. * * A "thread" value starts at "1". If we add a child (A) to this comment, * we assign it a "thread" = "1.1". A child of (A) will have "1.1.1". Next * brother of (A) will get "1.2". Next brother of the parent of (A) will get * "2" and so on. * * First of all note that the thread field stores the depth of the comment: * depth 0 will be "X", depth 1 "X.X", depth 2 "X.X.X", etc. * * Now to get the ordering right, consider this example: * * 1 * 1.1 * 1.1.1 * 1.2 * 2 * * If we "ORDER BY thread ASC" we get the above result, and this is the * natural order sorted by time. However, if we "ORDER BY thread DESC" * we get: * * 2 * 1.2 * 1.1.1 * 1.1 * 1 * * Clearly, this is not a natural way to see a thread, and users will get * confused. The natural order to show a thread by time desc would be: * * 2 * 1 * 1.2 * 1.1 * 1.1.1 * * which is what we already did before the standard pager patch. To achieve * this we simply add a "/" at the end of each "thread" value. This way out * thread fields will look like depicted below: * * 1/ * 1.1/ * 1.1.1/ * 1.2/ * 2/ * * we add "/" since this char is, in ASCII, higher than every number, so if * now we "ORDER BY thread DESC" we get the correct order. However this would * spoil the reverse ordering, "ORDER BY thread ASC" -- here, we do not need * to consider the trailing "/" so we use a substring only. */function comment_render($node, $cid = 0) {  global $user;  $output = '';  if (user_access('access comments')) {    // Pre-process variables.    $nid = $node->nid;    if (empty($nid)) {      $nid = 0;    }    $mode = _comment_get_display_setting('mode', $node);    $order = _comment_get_display_setting('sort', $node);    $comments_per_page = _comment_get_display_setting('comments_per_page', $node);    if ($cid && is_numeric($cid)) {      // Single comment view.      $query = 'SELECT c.cid, c.pid, c.nid, c.subject, c.comment, c.format, c.timestamp, c.name, c.mail, c.homepage, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data, c.status FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d';      $query_args = array($cid);      if (!user_access('administer comments')) {        $query .= ' AND c.status = %d';        $query_args[] = COMMENT_PUBLISHED;      }      $query = db_rewrite_sql($query, 'c', 'cid');      $result = db_query($query, $query_args);      if ($comment = db_fetch_object($result)) {        $comment->name = $comment->uid ? $comment->registered_name : $comment->name;        $links = module_invoke_all('link', 'comment', $comment, 1);        drupal_alter('link', $links, $node);        $output .= theme('comment_view', $comment, $node, $links);      }    }    else {      // Multiple comment view      $query_count = 'SELECT COUNT(*) FROM {comments} c WHERE c.nid = %d';      $query = 'SELECT c.cid as cid, c.pid, c.nid, c.subject, c.comment, c.format, c.timestamp, c.name, c.mail, c.homepage, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data, c.thread, c.status FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.nid = %d';      $query_args = array($nid);      if (!user_access('administer comments')) {        $query .= ' AND c.status = %d';        $query_count .= ' AND c.status = %d';        $query_args[] = COMMENT_PUBLISHED;      }      if ($order == COMMENT_ORDER_NEWEST_FIRST) {        if ($mode == COMMENT_MODE_FLAT_COLLAPSED || $mode == COMMENT_MODE_FLAT_EXPANDED) {          $query .= ' ORDER BY c.cid DESC';        }        else {          $query .= ' ORDER BY c.thread DESC';        }      }      else if ($order == COMMENT_ORDER_OLDEST_FIRST) {        if ($mode == COMMENT_MODE_FLAT_COLLAPSED || $mode == COMMENT_MODE_FLAT_EXPANDED) {          $query .= ' ORDER BY c.cid';        }        else {          // See comment above. Analysis reveals that this doesn't cost too          // much. It scales much much better than having the whole comment          // structure.          $query .= ' ORDER BY SUBSTRING(c.thread, 1, (LENGTH(c.thread) - 1))';        }      }      $query = db_rewrite_sql($query, 'c', 'cid');      $query_count = db_rewrite_sql($query_count, 'c', 'cid');      // Start a form, for use with comment control.      $result = pager_query($query, $comments_per_page, 0, $query_count, $query_args);      $divs = 0;      $num_rows = FALSE;      $comments = '';      drupal_add_css(drupal_get_path('module', 'comment') .'/comment.css');      while ($comment = db_fetch_object($result)) {        $comment = drupal_unpack($comment);        $comment->name = $comment->uid ? $comment->registered_name : $comment->name;        $comment->depth = count(explode('.', $comment->thread)) - 1;        if ($mode == COMMENT_MODE_THREADED_COLLAPSED || $mode == COMMENT_MODE_THREADED_EXPANDED) {          if ($comment->depth > $divs) {            $divs++;            $comments .= '<div class="indented">';          }          else {            while ($comment->depth < $divs) {              $divs--;              $comments .= '</div>';            }          }        }        if ($mode == COMMENT_MODE_FLAT_COLLAPSED) {          $comments .= theme('comment_flat_collapsed', $comment, $node);        }        else if ($mode == COMMENT_MODE_FLAT_EXPANDED) {          $comments .= theme('comment_flat_expanded', $comment, $node);        }        else if ($mode == COMMENT_MODE_THREADED_COLLAPSED) {          $comments .= theme('comment_thread_collapsed', $comment, $node);        }        else if ($mode == COMMENT_MODE_THREADED_EXPANDED) {          $comments .= theme('comment_thread_expanded', $comment, $node);        }        $num_rows = TRUE;      }      while ($divs-- > 0) {        $comments .= '</div>';      }      $comment_controls = variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN);      if ($num_rows && ($comment_controls == COMMENT_CONTROLS_ABOVE || $comment_controls == COMMENT_CONTROLS_ABOVE_BELOW)) {        $output .= drupal_get_form('comment_controls', $mode, $order, $comments_per_page);      }      $output .= $comments;      $output .= theme('pager', NULL, $comments_per_page, 0);      if ($num_rows && ($comment_controls == COMMENT_CONTROLS_BELOW || $comment_controls == COMMENT_CONTROLS_ABOVE_BELOW)) {        $output .= drupal_get_form('comment_controls', $mode, $order, $comments_per_page);      }    }    // If enabled, show new comment form if it's not already being displayed.    $reply = arg(0) == 'comment' && arg(1) == 'reply';    if (user_access('post comments') && node_comment_mode($nid) == COMMENT_NODE_READ_WRITE && (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_BELOW) && !$reply) {      $output .= comment_form_box(array('nid' => $nid), t('Post new comment'));    }    if ($output) {      $output = theme('comment_wrapper', $output, $node);    }  }  return $output;}/** * Comment operations. We offer different update operations depending on * which comment administration page we're on. * * @param $action *   The comment administration page. * @return *   An associative array containing the offered operations. */function comment_operations($action = NULL) {  if ($action == 'publish') {    $operations = array(      'publish' => array(t('Publish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  else if ($action == 'unpublish') {    $operations = array(      'unpublish' => array(t('Unpublish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  else {    $operations = array(      'publish' => array(t('Publish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d'),      'unpublish' => array(t('Unpublish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED .' WHERE cid = %d'),      'delete' => array(t('Delete the selected comments'), ''),    );  }  return $operations;}/** * Misc functions: helpers, privates, history *//** * Load the entire comment by cid. * * @param $cid *   The identifying comment id. * @return *   The comment object. */function _comment_load($cid) {  return db_fetch_object(db_query('SELECT * FROM {comments} WHERE cid = %d', $cid));}/** * Get comment count for a node. * * @param $nid *   The node id. * @return *   The comment count. */function comment_num_all($nid) {  static $cache;  if (!isset($cache[$nid])) {    $cache[$nid] = db_result(db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = %d', $nid));  }  return $cache[$nid];}/** * Get replies count for a comment. * * @param $pid *   The comment id. * @return *   The replies count. */function comment_num_replies($pid) {  static $cache;  if (!isset($cache[$pid])) {    $cache[$pid] = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE pid = %d AND status = %d', $pid, COMMENT_PUBLISHED));  }  return $cache[$pid];}/** * Get number of new comments for current user and specified node. * * @param $nid *   node-id to count comments for * @param $timestamp *   time to count from (defaults to time of last user access *   to node) */function comment_num_new($nid, $timestamp = 0) {  global $user;  if ($user->uid) {    // Retrieve the timestamp at which the current user last viewed the    // specified node.    if (!$timestamp) {      $timestamp = node_last_viewed($nid);    }    $timestamp = ($timestamp > NODE_NEW_LIMIT ? $timestamp : NODE_NEW_LIMIT);    // Use the timestamp to retrieve the number of new comments.    $result = db_result(db_query('SELECT COUNT(c.cid) FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid WHERE n.nid = %d AND timestamp > %d AND c.status = %d', $nid, $timestamp, COMMENT_PUBLISHED));    return $result;  }  else {    return 0;  }}/** * Validate comment data. * * @param $edit *   An associative array containig the comment data. * @return *   The original $edit. */function comment_validate($edit) {  global $user;  // Invoke other validation handlers  comment_invoke_comment($edit, 'validate');  if (isset($edit['date'])) {    // As of PHP 5.1.0, strtotime returns FALSE upon failure instead of -1.    if (strtotime($edit['date']) <= 0) {      form_set_error('date', t('You have to specify a valid date.'));    }  }  if (isset($edit['author']) && !$account = user_load(array('name' => $edit['author']))) {    form_set_error('author', t('You have to specify a valid author.'));  }  // Check validity of name, mail and homepage (if given)  if (!$user->uid || isset($edit['is_anonymous'])) {    $node = node_load($edit['nid']);    if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) > COMMENT_ANONYMOUS_MAYNOT_CONTACT) {      if ($edit['name']) {        $taken = db_result(db_query("SELECT COUNT(uid) FROM {users} WHERE LOWER(name) = '%s'", $edit['name']));        if ($taken != 0) {          form_set_error('name', t('The name you used belongs to a registered user.'));        }      }      else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {        form_set_error('name', t('You have to leave your name.'));      }      if ($edit['mail']) {        if (!valid_email_address($edit['mail'])) {          form_set_error('mail', t('The e-mail address you specified is not valid.'));        }      }      else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {        form_set_error('mail', t('You have to leave an e-mail address.'));      }      if ($edit['homepage']) {        if (!valid_url($edit['homepage'], TRUE)) {          form_set_error('homepage', t('The URL of your homepage is not valid. Remember that it must be fully qualified, i.e. of the form <code>http://example.com/directory</code>.'));        }      }    }  }  return $edit;}/** * Generate the basic commenting form, for appending to a node or display on a separate page. * * @param $title *   Not used. * @ingroup forms * @see comment_form_validate() * @see comment_form_submit() */function comment_form(&$form_state, $edit, $title = NULL) {  global $user;  $op = isset($_POST['op']) ? $_POST['op'] : '';  $node = node_load($edit['nid']);  if (!$user->uid && variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) != COMMENT_ANONYMOUS_MAYNOT_CONTACT) {    drupal_add_js(drupal_get_path('module', 'comment') .'/comment.js');  }  $edit += array('name' => '', 'mail' => '', 'homepage' => '');  if ($user->uid) {    if (!empty($edit['cid']) && user_access('administer comments')) {      if (!empty($edit['author'])) {        $author = $edit['author'];      }      elseif (!empty($edit['name'])) {        $author = $edit['name'];      }      else {        $author = $edit['registered_name'];      }      if (!empty($edit['status'])) {        $status = $edit['status'];      }      else {        $status = 0;      }      if (!empty($edit['date'])) {        $date = $edit['date'];      }      else {        $date = format_date($edit['timestamp'], 'custom', 'Y-m-d H:i O');      }      $form['admin'] = array(        '#type' => 'fieldset',        '#title' => t('Administration'),        '#collapsible' => TRUE,        '#collapsed' => TRUE,        '#weight' => -2,      );      if ($edit['registered_name'] != '') {        // The comment is by a registered user        $form['admin']['author'] = array(          '#type' => 'textfield',          '#title' => t('Authored by'),          '#size' => 30,          '#maxlength' => 60,          '#autocomplete_path' => 'user/autocomplete',          '#default_value' => $author,          '#weight' => -1,        );      }      else {        // The comment is by an anonymous user        $form['is_anonymous'] = array(          '#type' => 'value',          '#value' => TRUE,        );        $form['admin']['name'] = array(          '#type' => 'textfield',          '#title' => t('Authored by'),          '#size' => 30,          '#maxlength' => 60,          '#default_value' => $author,          '#weight' => -1,        );        $form['admin']['mail'] = array(          '#type' => 'textfield',          '#title' => t('E-mail'),          '#maxlength' => 64,          '#size' => 30,          '#default_value' => $edit['mail'],          '#description' => t('The content of this field is kept private and will not be shown publicly.'),        );        $form['admin']['homepage'] = array(          '#type' => 'textfield',          '#title' => t('Homepage'),          '#maxlength' => 255,          '#size' => 30,          '#default_value' => $edit['homepage'],        );      }      $form['admin']['date'] = array('#type' => 'textfield', '#parents' => array('date'), '#title' => t('Authored on'), '#size' => 20, '#maxlength' => 25, '#default_value' => $date, '#weight' => -1);      $form['admin']['status'] = array('#type' => 'radios', '#parents' => array('status'), '#title' => t('Status'), '#default_value' =>  $status, '#options' => array(t('Published'), t('Not published')), '#weight' => -1);    }    else {      $form['_author'] = array('#type' => 'item', '#title' => t('Your name'), '#value' => theme('username', $user)      );      $form['author'] = array('#type' => 'value', '#value' => $user->name);    }  }  else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MAY_CONTACT) {    $form['name'] = array('#type' => 'textfield', '#title' => t('Your name'), '#maxlength' => 60, '#size' => 30, '#default_value' => $edit['name'] ? $edit['name'] : variable_get('anonymous', t('Anonymous'))    );    $form['mail'] = array('#type' => 'textfield', '#title' => t('E-mail'), '#maxlength' => 64, '#size' => 30, '#default_value' => $edit['mail'], '#description' => t('The content of this field is kept private and will not be shown publicly.')    );    $form['homepage'] = array('#type' => 'textfield', '#title' => t('Homepage'), '#maxlength' => 255, '#size' => 30, '#default_value' => $edit['homepage']);  }  else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {    $form['name'] = array('#type' => 'textfield', '#title' => t('Your name'), '#maxlength' => 60, '#size' => 30, '#default_value' => $edit['name'] ? $edit['name'] : variable_get('anonymous', t('Anonymous')), '#required' => TRUE);    $form['mail'] = array('#type' => 'textfield', '#title' => t('E-mail'), '#maxlength' => 64, '#size' => 30, '#default_value' => $edit['mail'], '#description' => t('The content of this field is kept private and will not be shown publicly.'), '#required' => TRUE);    $form['homepage'] = array('#type' => 'textfield', '#title' => t('Homepage'), '#maxlength' => 255, '#size' => 30, '#default_value' => $edit['homepage']);  }  if (variable_get('comment_subject_field_'. $node->type, 1) == 1) {    $form['subject'] = array('#type' => 'textfield', '#title' => t('Subject'), '#maxlength' => 64, '#default_value' => !empty($edit['subject']) ? $edit['subject'] : '');  }  if (!empty($edit['comment'])) {    $default = $edit['comment'];  }  else {    $default = '';  }  $form['comment_filter']['comment'] = array(    '#type' => 'textarea',    '#title' => t('Comment'),    '#rows' => 15,    '#default_value' => $default,    '#required' => TRUE,  );  if (!isset($edit['format'])) {    $edit['format'] = FILTER_FORMAT_DEFAULT;  }  $form['comment_filter']['format'] = filter_form($edit['format']);  $form['cid'] = array('#type' => 'value', '#value' => !empty($edit['cid']) ? $edit['cid'] : NULL);  $form['pid'] = array('#type' => 'value', '#value' => !empty($edit['pid']) ? $edit['pid'] : NULL);  $form['nid'] = array('#type' => 'value', '#value' => $edit['nid']);  $form['uid'] = array('#type' => 'value', '#value' => !empty($edit['uid']) ? $edit['uid'] : 0);  // Only show save button if preview is optional or if we are in preview mode.  // We show the save button in preview mode even if there are form errors so that  // optional form elements (e.g., captcha) can be updated in preview mode.  if (!form_get_errors() && ((variable_get('comment_preview_'. $node->type, COMMENT_PREVIEW_REQUIRED) == COMMENT_PREVIEW_OPTIONAL) || ($op == t('Preview')) || ($op == t('Save')))) {    $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 19);  }  $form['preview'] = array('#type' => 'button', '#value' => t('Preview'), '#weight' => 20);  $form['#token'] = 'comment'. $edit['nid'] . (isset($edit['pid']) ? $edit['pid'] : '');  if ($op == t('Preview')) {    $form['#after_build'] = array('comment_form_add_preview');  }  if (empty($edit['cid']) && empty($edit['pid'])) {    $form['#action'] = url('comment/reply/'. $edit['nid']);  }  return $form;}/** * Theme the comment form box. * * @param $edit *   The form structure. * @param $title *   The form title. */function comment_form_box($edit, $title = NULL) {  return theme('box', $title, drupal_get_form('comment_form', $edit, $title));}/** * Form builder; Generate and validate a comment preview form. * * @ingroup forms */function comment_form_add_preview($form, &$form_state) {  global $user;  $edit = $form_state['values'];  drupal_set_title(t('Preview comment'));  $output = '';  $node = node_load($edit['nid']);  // Invoke full validation for the form, to protect against cross site  // request forgeries (CSRF) and setting arbitrary values for fields such as  // the input format. Preview the comment only when form validation does not  // set any errors.  drupal_validate_form($form['form_id']['#value'], $form, $form_state);  if (!form_get_errors()) {    _comment_form_submit($edit);    $comment = (object)$edit;    // Attach the user and time information.    if (!empty($edit['author'])) {      $account = user_load(array('name' => $edit['author']));    }    elseif ($user->uid && !isset($edit['is_anonymous'])) {      $account = $user;    }    if (!empty($account)) {      $comment->uid = $account->uid;      $comment->name = check_plain($account->name);    }    elseif (empty($comment->name)) {      $comment->name = variable_get('anonymous', t('Anonymous'));    }    $comment->timestamp = !empty($edit['timestamp']) ? $edit['timestamp'] : time();    $output .= theme('comment_view', $comment, $node);  }  $form['comment_preview'] = array(    '#value' => $output,    '#weight' => -100,    '#prefix' => '<div class="preview">',    '#suffix' => '</div>',  );  $output = '';  if ($edit['pid']) {    $comment = db_fetch_object(db_query('SELECT c.*, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status = %d', $edit['pid'], COMMENT_PUBLISHED));    $comment = drupal_unpack($comment);    $comment->name = $comment->uid ? $comment->registered_name : $comment->name;    $output .= theme('comment_view', $comment, $node);  }  else {    $suffix = empty($form['#suffix']) ? '' : $form['#suffix'];    $form['#suffix'] = $suffix . node_view($node);    $edit['pid'] = 0;  }  $form['comment_preview_below'] = array('#value' => $output, '#weight' => 100);  return $form;}/** * Validate comment form submissions. */function comment_form_validate($form, &$form_state) {  global $user;  if ($user->uid === 0) {    foreach (array('name', 'homepage', 'mail') as $field) {      // Set cookie for 365 days.      if (isset($form_state['values'][$field])) {        setcookie('comment_info_'. $field, $form_state['values'][$field], time() + 31536000, '/');      }    }  }  comment_validate($form_state['values']);}/** * Prepare a comment for submission. * * @param $comment_values *   An associative array containing the comment data. */function _comment_form_submit(&$comment_values) {  $comment_values += array('subject' => '');  if (!isset($comment_values['date'])) {    $comment_values['date'] = 'now';  }  $comment_values['timestamp'] = strtotime($comment_values['date']);  if (isset($comment_values['author'])) {    $account = user_load(array('name' => $comment_values['author']));    $comment_values['uid'] = $account->uid;    $comment_values['name'] = $comment_values['author'];  }  // Validate the comment's subject. If not specified, extract  // one from the comment's body.  if (trim($comment_values['subject']) == '') {    // The body may be in any format, so we:    // 1) Filter it into HTML    // 2) Strip out all HTML tags    // 3) Convert entities back to plain-text.    // Note: format is checked by check_markup().    $comment_values['subject'] = truncate_utf8(trim(decode_entities(strip_tags(check_markup($comment_values['comment'], $comment_values['format'])))), 29, TRUE);    // Edge cases where the comment body is populated only by HTML tags will    // require a default subject.    if ($comment_values['subject'] == '') {      $comment_values['subject'] = t('(No subject)');    }  }}/** * Process comment form submissions; prepare the comment, store it, and set a redirection target. */function comment_form_submit($form, &$form_state) {  _comment_form_submit($form_state['values']);  if ($cid = comment_save($form_state['values'])) {    $node = node_load($form_state['values']['nid']);    // Add 1 to existing $node->comment count to include new comment being added.    $comment_count = $node->comment_count + 1;    $page = comment_new_page_count($comment_count, 1, $node);    $form_state['redirect'] = array('node/'. $node->nid, $page, "comment-$cid");    return;  }}/** * Themes a single comment and related items. * * @param $comment *   The comment object. * @param $node *   The comment node. * @param $links *   An associative array containing control links suitable for passing into *   theme_links(). These are generated by modules implementing hook_link() with *   $type='comment'. Typical examples are links for editing and deleting *   comments. * @param $visible *   Switches between folded/unfolded view. If TRUE the comments are visible, if *   FALSE the comments are folded. * @ingroup themeable */function theme_comment_view($comment, $node, $links = array(), $visible = TRUE) {  static $first_new = TRUE;  $output = '';  $comment->new = node_mark($comment->nid, $comment->timestamp);  if ($first_new && $comment->new != MARK_READ) {    // Assign the anchor only for the first new comment. This avoids duplicate    // id attributes on a page.    $first_new = FALSE;    $output .= "<a id=\"new\"></a>\n";  }  $output .= "<a id=\"comment-$comment->cid\"></a>\n";  // Switch to folded/unfolded view of the comment  if ($visible) {    $comment->comment = check_markup($comment->comment, $comment->format, FALSE);    // Comment API hook    comment_invoke_comment($comment, 'view');    $output .= theme('comment', $comment, $node, $links);  }  else {    $output .= theme('comment_folded', $comment);  }  return $output;}/** * Build a comment control form. * * @param $mode *   Comment display mode. * @param $order *   Comment order mode. * @param $comments_per_page *   Comments per page. * @ingroup forms */function comment_controls(&$form_state, $mode = COMMENT_MODE_THREADED_EXPANDED, $order = COMMENT_ORDER_NEWEST_FIRST, $comments_per_page = 50) {  $form['mode'] = array('#type' => 'select',    '#default_value' => $mode,    '#options' => _comment_get_modes(),    '#weight' => 1,  );  $form['order'] = array(    '#type' => 'select',    '#default_value' => $order,    '#options' => _comment_get_orders(),    '#weight' => 2,  );  foreach (_comment_per_page() as $i) {    $options[$i] = t('!a comments per page', array('!a' => $i));  }  $form['comments_per_page'] = array('#type' => 'select',    '#default_value' => $comments_per_page,    '#options' => $options,    '#weight' => 3,  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Save settings'),    '#weight' => 20,  );  return $form;}/** * Theme comment controls box where the user can change the default display mode and display order of comments. * * @param $form *   The form structure. * @ingroup themeable */function theme_comment_controls($form) {  $output = '<div class="container-inline">';  $output .=  drupal_render($form);  $output .= '</div>';  $output .= '<div class="description">'. t('Select your preferred way to display the comments and click "Save settings" to activate your changes.') .'</div>';  return theme('box', t('Comment viewing options'), $output);}/** * Process comment_controls form submissions. */function comment_controls_submit($form, &$form_state) {  global $user;  $mode = $form_state['values']['mode'];  $order = $form_state['values']['order'];  $comments_per_page = $form_state['values']['comments_per_page'];  if ($user->uid) {    $account = user_save($user, array('mode' => $mode, 'sort' => $order, 'comments_per_page' => $comments_per_page));    // Terminate if an error occured during user_save().    if (!$account) {      drupal_set_message(t("Error saving user account."), 'error');      return;    }    $user = $account;  }  else {    $_SESSION['comment_mode'] = $mode;    $_SESSION['comment_sort'] = $order;    $_SESSION['comment_comments_per_page'] = $comments_per_page;  }}/** * Process variables for comment.tpl.php. * * @see comment.tpl.php * @see theme_comment() */function template_preprocess_comment(&$variables) {  $comment = $variables['comment'];  $node = $variables['node'];  $variables['author']    = theme('username', $comment);  $variables['content']   = $comment->comment;  $variables['date']      = format_date($comment->timestamp);  $variables['links']     = isset($variables['links']) ? theme('links', $variables['links']) : '';  $variables['new']       = $comment->new ? t('new') : '';  $variables['picture']   = theme_get_setting('toggle_comment_user_picture') ? theme('user_picture', $comment) : '';  $variables['signature'] = $comment->signature;  $variables['submitted'] = theme('comment_submitted', $comment);  $variables['title']     = l($comment->subject, $_GET['q'], array('fragment' => "comment-$comment->cid"));  $variables['template_files'][] = 'comment-'. $node->type;  // set status to a string representation of comment->status.  if (isset($comment->preview)) {    $variables['status']  = 'comment-preview';  }  else {    $variables['status']  = ($comment->status == COMMENT_NOT_PUBLISHED) ? 'comment-unpublished' : 'comment-published';  }}/** * Process variables for comment-folded.tpl.php. * * @see comment-folded.tpl.php * @see theme_comment_folded() */function template_preprocess_comment_folded(&$variables) {  $comment = $variables['comment'];  $variables['author'] = theme('username', $comment);  $variables['date']   = format_date($comment->timestamp);  $variables['new']    = $comment->new ? t('new') : '';  $variables['title']  = l($comment->subject, comment_node_url() .'/'. $comment->cid, array('fragment' => "comment-$comment->cid"));}/** * Theme comment flat collapsed view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_flat_collapsed($comment, $node) {  return theme('comment_view', $comment, $node, '', 0);}/** * Theme comment flat expanded view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_flat_expanded($comment, $node) {  $links = module_invoke_all('link', 'comment', $comment, 0);  drupal_alter('link', $links, $node);  return theme('comment_view', $comment, $node, $links);}/** * Theme comment thread collapsed view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_thread_collapsed($comment, $node) {  return theme('comment_view', $comment, $node, '', 0);}/** * Theme comment thread expanded view. * * @param $comment *   The comment to be themed. * @param $node *   The comment node. * @ingroup themeable */function theme_comment_thread_expanded($comment, $node) {  $links = module_invoke_all('link', 'comment', $comment, 0);  drupal_alter('link', $links, $node);  return theme('comment_view', $comment, $node, $links);}/** * Theme a "you can't post comments" notice. * * @param $node *   The comment node. * @ingroup themeable */function theme_comment_post_forbidden($node) {  global $user;  static $authenticated_post_comments;  if (!$user->uid) {    if (!isset($authenticated_post_comments)) {      // We only output any link if we are certain, that users get permission      // to post comments by logging in. We also locally cache this information.      $authenticated_post_comments = array_key_exists(DRUPAL_AUTHENTICATED_RID, user_roles(TRUE, 'post comments') + user_roles(TRUE, 'post comments without approval'));    }    if ($authenticated_post_comments) {      // We cannot use drupal_get_destination() because these links      // sometimes appear on /node and taxonomy listing pages.      if (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_SEPARATE_PAGE) {        $destination = 'destination='. rawurlencode("comment/reply/$node->nid#comment-form");      }      else {        $destination = 'destination='. rawurlencode("node/$node->nid#comment-form");      }      if (variable_get('user_register', 1)) {        // Users can register themselves.        return t('<a href="@login">Login</a> or <a href="@register">register</a> to post comments', array('@login' => url('user/login', array('query' => $destination)), '@register' => url('user/register', array('query' => $destination))));      }      else {        // Only admins can add new users, no public registration.        return t('<a href="@login">Login</a> to post comments', array('@login' => url('user/login', array('query' => $destination))));      }    }  }}/** * Process variables for comment-wrapper.tpl.php. * * @see comment-wrapper.tpl.php * @see theme_comment_wrapper() */function template_preprocess_comment_wrapper(&$variables) {  // Provide contextual information.  $variables['display_mode']  = _comment_get_display_setting('mode', $variables['node']);  $variables['display_order'] = _comment_get_display_setting('sort', $variables['node']);  $variables['comment_controls_state'] = variable_get('comment_controls_'. $variables['node']->type, COMMENT_CONTROLS_HIDDEN);  $variables['template_files'][] = 'comment-wrapper-'. $variables['node']->type;}/** * Theme a "Submitted by ..." notice. * * @param $comment *   The comment. * @ingroup themeable */function theme_comment_submitted($comment) {  return t('Submitted by !username on @datetime.',    array(      '!username' => theme('username', $comment),      '@datetime' => format_date($comment->timestamp)    ));}/** * Return an array of viewing modes for comment listings. * * We can't use a global variable array because the locale system * is not initialized yet when the comment module is loaded. */function _comment_get_modes() {  return array(    COMMENT_MODE_FLAT_COLLAPSED => t('Flat list - collapsed'),    COMMENT_MODE_FLAT_EXPANDED => t('Flat list - expanded'),    COMMENT_MODE_THREADED_COLLAPSED => t('Threaded list - collapsed'),    COMMENT_MODE_THREADED_EXPANDED => t('Threaded list - expanded')  );}/** * Return an array of viewing orders for comment listings. * * We can't use a global variable array because the locale system * is not initialized yet when the comment module is loaded. */function _comment_get_orders() {  return array(    COMMENT_ORDER_NEWEST_FIRST => t('Date - newest first'),    COMMENT_ORDER_OLDEST_FIRST => t('Date - oldest first')  );}/** * Return an array of "comments per page" settings from which the user * can choose. */function _comment_per_page() {  return drupal_map_assoc(array(10, 30, 50, 70, 90, 150, 200, 250, 300));}/** * Return a current comment display setting * * @param $setting *   can be one of these: 'mode', 'sort', 'comments_per_page' * @param $node *   The comment node in question. */function _comment_get_display_setting($setting, $node) {  global $user;  if (isset($_GET[$setting])) {    $value = $_GET[$setting];  }  else {    // get the setting's site default    switch ($setting) {      case 'mode':        $default = variable_get('comment_default_mode_'. $node->type, COMMENT_MODE_THREADED_EXPANDED);        break;      case 'sort':        $default = variable_get('comment_default_order_'. $node->type, COMMENT_ORDER_NEWEST_FIRST);        break;      case 'comments_per_page':        $default = variable_get('comment_default_per_page_'. $node->type, 50);    }    if (variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN) == COMMENT_CONTROLS_HIDDEN) {      // if comment controls are disabled use site default      $value = $default;    }    else {      // otherwise use the user's setting if set      if (isset($user->$setting) && $user->$setting) {        $value = $user->$setting;      }      else if (isset($_SESSION['comment_'. $setting]) && $_SESSION['comment_'. $setting]) {        $value = $_SESSION['comment_'. $setting];      }      else {        $value = $default;      }    }  }  return $value;}/** * Updates the comment statistics for a given node. This should be called any * time a comment is added, deleted, or updated. * * The following fields are contained in the node_comment_statistics table. * - last_comment_timestamp: the timestamp of the last comment for this node or the node create stamp if no comments exist for the node. * - last_comment_name: the name of the anonymous poster for the last comment * - last_comment_uid: the uid of the poster for the last comment for this node or the node authors uid if no comments exists for the node. * - comment_count: the total number of approved/published comments on this node. */function _comment_update_node_statistics($nid) {  $count = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE nid = %d AND status = %d', $nid, COMMENT_PUBLISHED));  // comments exist  if ($count > 0) {    $last_reply = db_fetch_object(db_query_range('SELECT cid, name, timestamp, uid FROM {comments} WHERE nid = %d AND status = %d ORDER BY cid DESC', $nid, COMMENT_PUBLISHED, 0, 1));    db_query("UPDATE {node_comment_statistics} SET comment_count = %d, last_comment_timestamp = %d, last_comment_name = '%s', last_comment_uid = %d WHERE nid = %d", $count, $last_reply->timestamp, $last_reply->uid ? '' : $last_reply->name, $last_reply->uid, $nid);  }  // no comments  else {    $node = db_fetch_object(db_query("SELECT uid, created FROM {node} WHERE nid = %d", $nid));    db_query("UPDATE {node_comment_statistics} SET comment_count = 0, last_comment_timestamp = %d, last_comment_name = '', last_comment_uid = %d WHERE nid = %d", $node->created, $node->uid, $nid);  }}/** * Invoke a hook_comment() operation in all modules. * * @param &$comment *   A comment object. * @param $op *   A string containing the name of the comment operation. * @return *   The returned value of the invoked hooks. */function comment_invoke_comment(&$comment, $op) {  $return = array();  foreach (module_implements('comment') as $name) {    $function = $name .'_comment';    $result = $function($comment, $op);    if (isset($result) && is_array($result)) {      $return = array_merge($return, $result);    }    else if (isset($result)) {      $return[] = $result;    }  }  return $return;}/** * Generate vancode. * * Consists of a leading character indicating length, followed by N digits * with a numerical value in base 36. Vancodes can be sorted as strings * without messing up numerical order. * * It goes: * 00, 01, 02, ..., 0y, 0z, * 110, 111, ... , 1zy, 1zz, * 2100, 2101, ..., 2zzy, 2zzz, * 31000, 31001, ... */function int2vancode($i = 0) {  $num = base_convert((int)$i, 10, 36);  $length = strlen($num);  return chr($length + ord('0') - 1) . $num;}/** * Decode vancode back to an integer. */function vancode2int($c = '00') {  return base_convert(substr($c, 1), 36, 10);}/** * Implementation of hook_hook_info(). */function comment_hook_info() {  return array(    'comment' => array(      'comment' => array(        'insert' => array(          'runs when' => t('After saving a new comment'),        ),        'update' => array(          'runs when' => t('After saving an updated comment'),        ),        'delete' => array(          'runs when' => t('After deleting a comment')        ),        'view' => array(          'runs when' => t('When a comment is being viewed by an authenticated user')        ),      ),    ),  );}/** * Implementation of hook_action_info(). */function comment_action_info() {  return array(    'comment_unpublish_action' => array(      'description' => t('Unpublish comment'),      'type' => 'comment',      'configurable' => FALSE,      'hooks' => array(        'comment' => array('insert', 'update'),      )    ),    'comment_unpublish_by_keyword_action' => array(      'description' => t('Unpublish comment containing keyword(s)'),      'type' => 'comment',      'configurable' => TRUE,      'hooks' => array(        'comment' => array('insert', 'update'),      )    )  );}/** * Drupal action to unpublish a comment. * * @param $context *   Keyed array. Must contain the id of the comment if $comment is not passed. * @param $comment *   An optional comment object. */function comment_unpublish_action($comment, $context = array()) {  if (isset($comment->cid)) {    $cid = $comment->cid;    $subject = $comment->subject;  }  else {    $cid = $context['cid'];    $subject = db_result(db_query("SELECT subject FROM {comments} WHERE cid = %d", $cid));  }  db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_NOT_PUBLISHED, $cid);  watchdog('action', 'Unpublished comment %subject.', array('%subject' => $subject));}/** * Form builder; Prepare a form for blacklisted keywords. * * @ingroup forms */function comment_unpublish_by_keyword_action_form($context) {  $form['keywords'] = array(    '#title' => t('Keywords'),    '#type' => 'textarea',    '#description' => t('The comment will be unpublished if it contains any of the character sequences above. Use a comma-separated list of character sequences. Example: funny, bungee jumping, "Company, Inc.". Character sequences are case-sensitive.'),    '#default_value' => isset($context['keywords']) ? drupal_implode_tags($context['keywords']) : '',  );  return $form;}/** * Process comment_unpublish_by_keyword_action_form form submissions. */function comment_unpublish_by_keyword_action_submit($form, $form_state) {  return array('keywords' => drupal_explode_tags($form_state['values']['keywords']));}/** * Implementation of a configurable Drupal action. * Unpublish a comment if it contains a certain string. * * @param $context *   An array providing more information about the context of the call to this action. *   Unused here since this action currently only supports the insert and update ops of *   the comment hook, both of which provide a complete $comment object. * @param $comment *   A comment object. */function comment_unpublish_by_keyword_action($comment, $context) {  foreach ($context['keywords'] as $keyword) {    if (strstr($comment->comment, $keyword) || strstr($comment->subject, $keyword)) {      db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_NOT_PUBLISHED, $comment->cid);      watchdog('action', 'Unpublished comment %subject.', array('%subject' => $comment->subject));      break;    }  }}
<?php// $Id$/** * Implementation of hook_help(). */function color_help($path, $arg) {  switch ($path) {    case 'admin/help#color':      $output = '<p>'. t('The color module allows a site administrator to quickly and easily change the color scheme of certain themes. Although not all themes support color module, both Garland (the default theme) and Minnelli were designed to take advantage of its features. By using color module with a compatible theme, you can easily change the color of links, backgrounds, text, and other theme elements. Color module requires that your <a href="@url">file download method</a> be set to public.', array('@url' => url('admin/settings/file-system'))) .'</p>';      $output .= '<p>'. t("It is important to remember that color module saves a modified copy of the theme's specified stylesheets in the files directory. This means that if you make any manual changes to your theme's stylesheet, you must save your color settings again, even if they haven't changed. This causes the color module generated version of the stylesheets in the files directory to be recreated using the new version of the original file.") .'</p>';      $output .= '<p>'. t('To change the color settings for a compatible theme, select the "configure" link for the theme on the <a href="@themes">themes administration page</a>.', array('@themes' => url('admin/build/themes'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@color">Color module</a>.', array('@color' => 'http://drupal.org/handbook/modules/color/')) .'</p>';      return $output;  }}/** * Implementation of hook_theme(). */function color_theme() {  return array(    'color_scheme_form' => array(      'arguments' => array('form' => NULL),    ),  );}/** * Implementation of hook_form_alter(). */function color_form_alter(&$form, $form_state, $form_id) {  // Insert the color changer into the theme settings page.  if ($form_id == 'system_theme_settings' && color_get_info(arg(4)) && function_exists('gd_info')) {    if (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) != FILE_DOWNLOADS_PUBLIC) {      // Disables the color changer when the private download method is used.      // TODO: This should be solved in a different way. See issue #181003.      drupal_set_message(t('The color picker only works if the <a href="@url">download method</a> is set to public.', array('@url' => url('admin/settings/file-system'))), 'warning');    }    else {      $form['color'] = array(        '#type' => 'fieldset',        '#title' => t('Color scheme'),        '#weight' => -1,        '#attributes' => array('id' => 'color_scheme_form'),        '#theme' => 'color_scheme_form',      );      $form['color'] += color_scheme_form($form_state, arg(4));      $form['#submit'][] = 'color_scheme_form_submit';    }  }  // Use the generated screenshot in the theme list.  if ($form_id == 'system_theme_select_form' || $form_id == 'system_themes') {    $themes = list_themes();    foreach (element_children($form) as $theme) {      if ($screenshot = variable_get('color_'. $theme .'_screenshot', NULL)) {        if (isset($form[$theme]['screenshot'])) {          $form[$theme]['screenshot']['#value'] = theme('image', $screenshot, '', '', array('class' => 'screenshot'), FALSE);        }      }    }  }}/** * Callback for the theme to alter the resources used. */function _color_page_alter(&$vars) {  global $language, $theme_key;  // Override stylesheets.  $color_paths = variable_get('color_'. $theme_key .'_stylesheets', array());  if (!empty($color_paths)) {    // Loop over theme CSS files and try to rebuild CSS array with rewritten    // stylesheets. Keep the orginal order intact for CSS cascading.    $new_theme_css = array();    foreach ($vars['css']['all']['theme'] as $old_path => $old_preprocess) {      // Add the non-colored stylesheet first as we might not find a      // re-colored stylesheet for replacement later.      $new_theme_css[$old_path] = $old_preprocess;      // Loop over the path array with recolored CSS files to find matching      // paths which could replace the non-recolored paths.      foreach ($color_paths as $color_path) {        // Color module currently requires unique file names to be used,        // which allows us to compare different file paths.        if (basename($old_path) == basename($color_path)) {          // Pull out the non-colored and add rewritten stylesheet.          unset($new_theme_css[$old_path]);          $new_theme_css[$color_path] = $old_preprocess;          // If the current language is RTL and the CSS file had an RTL variant,          // pull out the non-colored and add rewritten RTL stylesheet.          if ($language->direction == LANGUAGE_RTL) {            $rtl_old_path = str_replace('.css', '-rtl.css', $old_path);            $rtl_color_path = str_replace('.css', '-rtl.css', $color_path);            if (file_exists($rtl_color_path)) {              unset($new_theme_css[$rtl_old_path]);              $new_theme_css[$rtl_color_path] = $old_preprocess;            }          }          break;        }      }    }    $vars['css']['all']['theme'] = $new_theme_css;    $vars['styles'] = drupal_get_css($vars['css']);  }  // Override logo.  $logo = variable_get('color_'. $theme_key .'_logo', NULL);  if ($logo && $vars['logo'] && preg_match('!'. $theme_key .'/logo.png$!', $vars['logo'])) {    $vars['logo'] = base_path() . $logo;  }}/** * Retrieve the color.module info for a particular theme. */function color_get_info($theme) {  $path = drupal_get_path('theme', $theme);  $file = $path .'/color/color.inc';  if ($path && file_exists($file)) {    include $file;    return $info;  }}/** * Helper function to retrieve the color palette for a particular theme. */function color_get_palette($theme, $default = false) {  // Fetch and expand default palette  $fields = array('base', 'link', 'top', 'bottom', 'text');  $info = color_get_info($theme);  $keys = array_keys($info['schemes']);  foreach (explode(',', array_shift($keys)) as $k => $scheme) {    $palette[$fields[$k]] = $scheme;  }  // Load variable  return $default ? $palette : variable_get('color_'. $theme .'_palette', $palette);}/** * Form callback. Returns the configuration form. */function color_scheme_form(&$form_state, $theme) {  $base = drupal_get_path('module', 'color');  $info = color_get_info($theme);  // Add Farbtastic color picker  drupal_add_css('misc/farbtastic/farbtastic.css', 'module', 'all', FALSE);  drupal_add_js('misc/farbtastic/farbtastic.js');  // Add custom CSS/JS  drupal_add_css($base .'/color.css', 'module', 'all', FALSE);  drupal_add_js($base .'/color.js');  drupal_add_js(array('color' => array(    'reference' => color_get_palette($theme, true)  )), 'setting');  // See if we're using a predefined scheme  $current = implode(',', variable_get('color_'. $theme .'_palette', array()));  // Note: we use the original theme when the default scheme is chosen.  $current = isset($info['schemes'][$current]) ? $current : ($current == '' ? reset($info['schemes']) : '');  // Add scheme selector  $info['schemes'][''] = t('Custom');  $form['scheme'] = array(    '#type' => 'select',    '#title' => t('Color set'),    '#options' => $info['schemes'],    '#default_value' => $current,  );  // Add palette fields  $palette = color_get_palette($theme);  $names = array(    'base' => t('Base color'),    'link' => t('Link color'),    'top' => t('Header top'),    'bottom' => t('Header bottom'),    'text' => t('Text color')  );  $form['palette']['#tree'] = true;  foreach ($palette as $name => $value) {    $form['palette'][$name] = array(      '#type' => 'textfield',      '#title' => $names[$name],      '#default_value' => $value,      '#size' => 8,    );  }  $form['theme'] = array('#type' => 'value', '#value' => arg(4));  $form['info'] = array('#type' => 'value', '#value' => $info);  return $form;}/** * Theme color form. * * @ingroup themeable */function theme_color_scheme_form($form) {  // Include stylesheet  $theme = $form['theme']['#value'];  $info = $form['info']['#value'];  $path = drupal_get_path('theme', $theme) .'/';  drupal_add_css($path . $info['preview_css']);  $output = '';  // Wrapper  $output .= '<div class="color-form clear-block">';  // Color schemes  $output .= drupal_render($form['scheme']);  // Palette  $output .= '<div id="palette" class="clear-block">';  foreach (element_children($form['palette']) as $name) {    $output .= drupal_render($form['palette'][$name]);  }  $output .= '</div>';  // Preview  $output .= drupal_render($form);  $output .= '<h2>'. t('Preview') .'</h2>';  $output .= '<div id="preview"><div id="text"><h2>Lorem ipsum dolor</h2><p>Sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud <a href="#">exercitation ullamco</a> laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p></div><div id="img" style="background-image: url('. base_path() . $path . $info['preview_image'] .')"></div></div>';  // Close wrapper  $output .= '</div>';  return $output;}/** * Submit handler for color change form. */function color_scheme_form_submit($form, &$form_state) {  // Get theme coloring info  if (!isset($form_state['values']['info'])) {    return;  }  $theme = $form_state['values']['theme'];  $info = $form_state['values']['info'];  // Resolve palette  $palette = $form_state['values']['palette'];  if ($form_state['values']['scheme'] != '') {    $scheme = explode(',', $form_state['values']['scheme']);    foreach ($palette as $k => $color) {      $palette[$k] = array_shift($scheme);    }  }  // Make sure enough memory is available, if PHP's memory limit is compiled in.  if (function_exists('memory_get_usage')) {    // Fetch source image dimensions.    $source = drupal_get_path('theme', $theme) .'/'. $info['base_image'];    list($width, $height) = getimagesize($source);    // We need at least a copy of the source and a target buffer of the same    // size (both at 32bpp).    $required = $width * $height * 8;    $usage = memory_get_usage();    $limit = parse_size(ini_get('memory_limit'));    if ($usage + $required > $limit) {      drupal_set_message(t('There is not enough memory available to PHP to change this theme\'s color scheme. You need at least %size more. Check the <a href="@url">PHP documentation</a> for more information.', array('%size' => format_size($usage + $required - $limit), '@url' => 'http://www.php.net/manual/en/ini.core.php#ini.sect.resource-limits')), 'error');      return;    }  }  // Delete old files  foreach (variable_get('color_'. $theme .'_files', array()) as $file) {    @unlink($file);  }  if (isset($file) && $file = dirname($file)) {    @rmdir($file);  }  // Don't render the default colorscheme, use the standard theme instead.  if (implode(',', color_get_palette($theme, true)) == implode(',', $palette)    || $form_state['values']['op'] == t('Reset to defaults')) {    variable_del('color_'. $theme .'_palette');    variable_del('color_'. $theme .'_stylesheets');    variable_del('color_'. $theme .'_logo');    variable_del('color_'. $theme .'_files');    variable_del('color_'. $theme .'_screenshot');    return;  }  // Prepare target locations for generated files.  $id = $theme .'-'. substr(md5(serialize($palette) . microtime()), 0, 8);  $paths['color'] = file_directory_path() .'/color';  $paths['target'] = $paths['color'] .'/'. $id;  foreach ($paths as $path) {    file_check_directory($path, FILE_CREATE_DIRECTORY);  }  $paths['target'] = $paths['target'] .'/';  $paths['id'] = $id;  $paths['source'] = drupal_get_path('theme', $theme) .'/';  $paths['files'] = $paths['map'] = array();  // Save palette and logo location.  variable_set('color_'. $theme .'_palette', $palette);  variable_set('color_'. $theme .'_logo', $paths['target'] .'logo.png');  // Copy over neutral images.  foreach ($info['copy'] as $file) {    $base = basename($file);    $source = $paths['source'] . $file;    file_copy($source, $paths['target'] . $base);    $paths['map'][$file] = $base;    $paths['files'][] = $paths['target'] . $base;  }  // Render new images, if image provided.  if ($info['base_image']) {    _color_render_images($theme, $info, $paths, $palette);  }  // Rewrite theme stylesheets.  $css = array();  foreach ($info['css'] as $stylesheet) {    // Build a temporary array with LTR and RTL files.    $files = array();    if (file_exists($paths['source'] . $stylesheet)) {      $files[] = $stylesheet;      $rtl_file = str_replace('.css', '-rtl.css', $stylesheet);      if (file_exists($paths['source'] . $rtl_file)) {        $files[] = $rtl_file;      }    }    foreach ($files as $file) {      // Aggregate @imports recursively for each configured top level CSS file      // without optimization. Aggregation and optimization will be      // handled by drupal_build_css_cache() only.      $style = drupal_load_stylesheet($paths['source'] . $file, FALSE);      // Return the path to where this CSS file originated from, stripping      // off the name of the file at the end of the path.      $base = base_path() . dirname($paths['source'] . $file) .'/';      _drupal_build_css_path(NULL, $base);      // Prefix all paths within this CSS file, ignoring absolute paths.      $style = preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $style);      // Rewrite stylesheet with new colors.      $style = _color_rewrite_stylesheet($theme, $info, $paths, $palette, $style);      $base_file = basename($file);      $css[] = $paths['target'] . $base_file;      _color_save_stylesheet($paths['target'] . $base_file, $style, $paths);    }  }  // Maintain list of files.  variable_set('color_'. $theme .'_stylesheets', $css);  variable_set('color_'. $theme .'_files', $paths['files']);}/** * Rewrite the stylesheet to match the colors in the palette. */function _color_rewrite_stylesheet($theme, &$info, &$paths, $palette, $style) {  $themes = list_themes();  // Prepare color conversion table  $conversion = $palette;  unset($conversion['base']);  foreach ($conversion as $k => $v) {    $conversion[$k] = drupal_strtolower($v);  }  $default = color_get_palette($theme, true);  // Split off the "Don't touch" section of the stylesheet.  $split = "Color Module: Don't touch";  if (strpos($style, $split) !== FALSE) {    list($style, $fixed) = explode($split, $style);  }  // Find all colors in the stylesheet and the chunks in between.  $style = preg_split('/(#[0-9a-f]{6}|#[0-9a-f]{3})/i', $style, -1, PREG_SPLIT_DELIM_CAPTURE);  $is_color = false;  $output = '';  $base = 'base';  // Iterate over all parts.  foreach ($style as $chunk) {    if ($is_color) {      $chunk = drupal_strtolower($chunk);      // Check if this is one of the colors in the default palette.      if ($key = array_search($chunk, $default)) {        $chunk = $conversion[$key];      }      // Not a pre-set color. Extrapolate from the base.      else {        $chunk = _color_shift($palette[$base], $default[$base], $chunk, $info['blend_target']);      }    }    else {      // Determine the most suitable base color for the next color.      // 'a' declarations. Use link.      if (preg_match('@[^a-z0-9_-](a)[^a-z0-9_-][^/{]*{[^{]+$@i', $chunk)) {        $base = 'link';      }      // 'color:' styles. Use text.      else if (preg_match('/(?<!-)color[^{:]*:[^{#]*$/i', $chunk)) {        $base = 'text';      }      // Reset back to base.      else {        $base = 'base';      }    }    $output .= $chunk;    $is_color = !$is_color;  }  // Append fixed colors segment.  if (isset($fixed)) {    $output .= $fixed;  }  // Replace paths to images.  foreach ($paths['map'] as $before => $after) {    $before = base_path() . $paths['source'] . $before;    $before = preg_replace('`(^|/)(?!../)([^/]+)/../`', '$1', $before);    $output = str_replace($before, $after, $output);  }  return $output;}/** * Save the rewritten stylesheet to disk. */function _color_save_stylesheet($file, $style, &$paths) {  // Write new stylesheet.  file_save_data($style, $file, FILE_EXISTS_REPLACE);  $paths['files'][] = $file;  // Set standard file permissions for webserver-generated files.  @chmod($file, 0664);}/** * Render images that match a given palette. */function _color_render_images($theme, &$info, &$paths, $palette) {  // Prepare template image.  $source = $paths['source'] .'/'. $info['base_image'];  $source = imagecreatefrompng($source);  $width = imagesx($source);  $height = imagesy($source);  // Prepare target buffer.  $target = imagecreatetruecolor($width, $height);  imagealphablending($target, true);  // Fill regions of solid color.  foreach ($info['fill'] as $color => $fill) {    imagefilledrectangle($target, $fill[0], $fill[1], $fill[0] + $fill[2], $fill[1] + $fill[3], _color_gd($target, $palette[$color]));  }  // Render gradient.  for ($y = 0; $y < $info['gradient'][3]; ++$y) {    $color = _color_blend($target, $palette['top'], $palette['bottom'], $y / ($info['gradient'][3] - 1));    imagefilledrectangle($target, $info['gradient'][0], $info['gradient'][1] + $y, $info['gradient'][0] + $info['gradient'][2], $info['gradient'][1] + $y + 1, $color);  }  // Blend over template.  imagecopy($target, $source, 0, 0, 0, 0, $width, $height);  // Clean up template image.  imagedestroy($source);  // Cut out slices.  foreach ($info['slices'] as $file => $coord) {    list($x, $y, $width, $height) = $coord;    $base = basename($file);    $image = $paths['target'] . $base;    // Cut out slice.    if ($file == 'screenshot.png') {      $slice = imagecreatetruecolor(150, 90);      imagecopyresampled($slice, $target, 0, 0, $x, $y, 150, 90, $width, $height);      variable_set('color_'. $theme .'_screenshot', $image);    }    else {      $slice = imagecreatetruecolor($width, $height);      imagecopy($slice, $target, 0, 0, $x, $y, $width, $height);    }    // Save image.    imagepng($slice, $image);    imagedestroy($slice);    $paths['files'][] = $image;    // Set standard file permissions for webserver-generated files    @chmod(realpath($image), 0664);    // Build before/after map of image paths.    $paths['map'][$file] = $base;  }  // Clean up target buffer.  imagedestroy($target);}/** * Shift a given color, using a reference pair and a target blend color. * * Note: this function is significantly different from the JS version, as it * is written to match the blended images perfectly. * * Constraint: if (ref2 == target + (ref1 - target) * delta) for some fraction delta *              then (return == target + (given - target) * delta) * * Loose constraint: Preserve relative positions in saturation and luminance *                   space. */function _color_shift($given, $ref1, $ref2, $target) {  // We assume that ref2 is a blend of ref1 and target and find  // delta based on the length of the difference vectors:  // delta = 1 - |ref2 - ref1| / |white - ref1|  $target = _color_unpack($target, true);  $ref1 = _color_unpack($ref1, true);  $ref2 = _color_unpack($ref2, true);  $numerator = 0;  $denominator = 0;  for ($i = 0; $i < 3; ++$i) {    $numerator += ($ref2[$i] - $ref1[$i]) * ($ref2[$i] - $ref1[$i]);    $denominator += ($target[$i] - $ref1[$i]) * ($target[$i] - $ref1[$i]);  }  $delta = ($denominator > 0) ? (1 - sqrt($numerator / $denominator)) : 0;  // Calculate the color that ref2 would be if the assumption was true.  for ($i = 0; $i < 3; ++$i) {    $ref3[$i] = $target[$i] + ($ref1[$i] - $target[$i]) * $delta;  }  // If the assumption is not true, there is a difference between ref2 and ref3.  // We measure this in HSL space. Notation: x' = hsl(x).  $ref2 = _color_rgb2hsl($ref2);  $ref3 = _color_rgb2hsl($ref3);  for ($i = 0; $i < 3; ++$i) {    $shift[$i] = $ref2[$i] - $ref3[$i];  }  // Take the given color, and blend it towards the target.  $given = _color_unpack($given, true);  for ($i = 0; $i < 3; ++$i) {    $result[$i] = $target[$i] + ($given[$i] - $target[$i]) * $delta;  }  // Finally, we apply the extra shift in HSL space.  // Note: if ref2 is a pure blend of ref1 and target, then |shift| = 0.  $result = _color_rgb2hsl($result);  for ($i = 0; $i < 3; ++$i) {    $result[$i] = min(1, max(0, $result[$i] + $shift[$i]));  }  $result = _color_hsl2rgb($result);  // Return hex color.  return _color_pack($result, true);}/** * Convert a hex triplet into a GD color. */function _color_gd($img, $hex) {  $c = array_merge(array($img), _color_unpack($hex));  return call_user_func_array('imagecolorallocate', $c);}/** * Blend two hex colors and return the GD color. */function _color_blend($img, $hex1, $hex2, $alpha) {  $in1 = _color_unpack($hex1);  $in2 = _color_unpack($hex2);  $out = array($img);  for ($i = 0; $i < 3; ++$i) {    $out[] = $in1[$i] + ($in2[$i] - $in1[$i]) * $alpha;  }  return call_user_func_array('imagecolorallocate', $out);}/** * Convert a hex color into an RGB triplet. */function _color_unpack($hex, $normalize = false) {  if (strlen($hex) == 4) {    $hex = $hex[1] . $hex[1] . $hex[2] . $hex[2] . $hex[3] . $hex[3];  }  $c = hexdec($hex);  for ($i = 16; $i >= 0; $i -= 8) {    $out[] = (($c >> $i) & 0xFF) / ($normalize ? 255 : 1);  }  return $out;}/** * Convert an RGB triplet to a hex color. */function _color_pack($rgb, $normalize = false) {  $out = 0;  foreach ($rgb as $k => $v) {    $out |= (($v * ($normalize ? 255 : 1)) << (16 - $k * 8));  }  return '#'. str_pad(dechex($out), 6, 0, STR_PAD_LEFT);}/** * Convert a HSL triplet into RGB */function _color_hsl2rgb($hsl) {  $h = $hsl[0];  $s = $hsl[1];  $l = $hsl[2];  $m2 = ($l <= 0.5) ? $l * ($s + 1) : $l + $s - $l*$s;  $m1 = $l * 2 - $m2;  return array(    _color_hue2rgb($m1, $m2, $h + 0.33333),    _color_hue2rgb($m1, $m2, $h),    _color_hue2rgb($m1, $m2, $h - 0.33333),  );}/** * Helper function for _color_hsl2rgb(). */function _color_hue2rgb($m1, $m2, $h) {  $h = ($h < 0) ? $h + 1 : (($h > 1) ? $h - 1 : $h);  if ($h * 6 < 1) return $m1 + ($m2 - $m1) * $h * 6;  if ($h * 2 < 1) return $m2;  if ($h * 3 < 2) return $m1 + ($m2 - $m1) * (0.66666 - $h) * 6;  return $m1;}/** * Convert an RGB triplet to HSL. */function _color_rgb2hsl($rgb) {  $r = $rgb[0];  $g = $rgb[1];  $b = $rgb[2];  $min = min($r, min($g, $b));  $max = max($r, max($g, $b));  $delta = $max - $min;  $l = ($min + $max) / 2;  $s = 0;  if ($l > 0 && $l < 1) {    $s = $delta / ($l < 0.5 ? (2 * $l) : (2 - 2 * $l));  }  $h = 0;  if ($delta > 0) {    if ($max == $r && $max != $g) $h += ($g - $b) / $delta;    if ($max == $g && $max != $b) $h += (2 + ($b - $r) / $delta);    if ($max == $b && $max != $r) $h += (4 + ($r - $g) / $delta);    $h /= 6;  }  return array($h, $s, $l);}
<?php// $Id$/** * @file * Enables site-wide keyword searching. *//** * Matches Unicode character classes to exclude from the search index. * * See: http://www.unicode.org/Public/UNIDATA/UCD.html#General_Category_Values * * The index only contains the following character classes: * Lu     Letter, Uppercase * Ll     Letter, Lowercase * Lt     Letter, Titlecase * Lo     Letter, Other * Nd     Number, Decimal Digit * No     Number, Other */define('PREG_CLASS_SEARCH_EXCLUDE','\x{0}-\x{2f}\x{3a}-\x{40}\x{5b}-\x{60}\x{7b}-\x{bf}\x{d7}\x{f7}\x{2b0}-'.'\x{385}\x{387}\x{3f6}\x{482}-\x{489}\x{559}-\x{55f}\x{589}-\x{5c7}\x{5f3}-'.'\x{61f}\x{640}\x{64b}-\x{65e}\x{66a}-\x{66d}\x{670}\x{6d4}\x{6d6}-\x{6ed}'.'\x{6fd}\x{6fe}\x{700}-\x{70f}\x{711}\x{730}-\x{74a}\x{7a6}-\x{7b0}\x{901}-'.'\x{903}\x{93c}\x{93e}-\x{94d}\x{951}-\x{954}\x{962}-\x{965}\x{970}\x{981}-'.'\x{983}\x{9bc}\x{9be}-\x{9cd}\x{9d7}\x{9e2}\x{9e3}\x{9f2}-\x{a03}\x{a3c}-'.'\x{a4d}\x{a70}\x{a71}\x{a81}-\x{a83}\x{abc}\x{abe}-\x{acd}\x{ae2}\x{ae3}'.'\x{af1}-\x{b03}\x{b3c}\x{b3e}-\x{b57}\x{b70}\x{b82}\x{bbe}-\x{bd7}\x{bf0}-'.'\x{c03}\x{c3e}-\x{c56}\x{c82}\x{c83}\x{cbc}\x{cbe}-\x{cd6}\x{d02}\x{d03}'.'\x{d3e}-\x{d57}\x{d82}\x{d83}\x{dca}-\x{df4}\x{e31}\x{e34}-\x{e3f}\x{e46}-'.'\x{e4f}\x{e5a}\x{e5b}\x{eb1}\x{eb4}-\x{ebc}\x{ec6}-\x{ecd}\x{f01}-\x{f1f}'.'\x{f2a}-\x{f3f}\x{f71}-\x{f87}\x{f90}-\x{fd1}\x{102c}-\x{1039}\x{104a}-'.'\x{104f}\x{1056}-\x{1059}\x{10fb}\x{10fc}\x{135f}-\x{137c}\x{1390}-\x{1399}'.'\x{166d}\x{166e}\x{1680}\x{169b}\x{169c}\x{16eb}-\x{16f0}\x{1712}-\x{1714}'.'\x{1732}-\x{1736}\x{1752}\x{1753}\x{1772}\x{1773}\x{17b4}-\x{17db}\x{17dd}'.'\x{17f0}-\x{180e}\x{1843}\x{18a9}\x{1920}-\x{1945}\x{19b0}-\x{19c0}\x{19c8}'.'\x{19c9}\x{19de}-\x{19ff}\x{1a17}-\x{1a1f}\x{1d2c}-\x{1d61}\x{1d78}\x{1d9b}-'.'\x{1dc3}\x{1fbd}\x{1fbf}-\x{1fc1}\x{1fcd}-\x{1fcf}\x{1fdd}-\x{1fdf}\x{1fed}-'.'\x{1fef}\x{1ffd}-\x{2070}\x{2074}-\x{207e}\x{2080}-\x{2101}\x{2103}-\x{2106}'.'\x{2108}\x{2109}\x{2114}\x{2116}-\x{2118}\x{211e}-\x{2123}\x{2125}\x{2127}'.'\x{2129}\x{212e}\x{2132}\x{213a}\x{213b}\x{2140}-\x{2144}\x{214a}-\x{2b13}'.'\x{2ce5}-\x{2cff}\x{2d6f}\x{2e00}-\x{3005}\x{3007}-\x{303b}\x{303d}-\x{303f}'.'\x{3099}-\x{309e}\x{30a0}\x{30fb}-\x{30fe}\x{3190}-\x{319f}\x{31c0}-\x{31cf}'.'\x{3200}-\x{33ff}\x{4dc0}-\x{4dff}\x{a015}\x{a490}-\x{a716}\x{a802}\x{a806}'.'\x{a80b}\x{a823}-\x{a82b}\x{d800}-\x{f8ff}\x{fb1e}\x{fb29}\x{fd3e}\x{fd3f}'.'\x{fdfc}-\x{fe6b}\x{feff}-\x{ff0f}\x{ff1a}-\x{ff20}\x{ff3b}-\x{ff40}\x{ff5b}-'.'\x{ff65}\x{ff70}\x{ff9e}\x{ff9f}\x{ffe0}-\x{fffd}');/** * Matches all 'N' Unicode character classes (numbers) */define('PREG_CLASS_NUMBERS','\x{30}-\x{39}\x{b2}\x{b3}\x{b9}\x{bc}-\x{be}\x{660}-\x{669}\x{6f0}-\x{6f9}'.'\x{966}-\x{96f}\x{9e6}-\x{9ef}\x{9f4}-\x{9f9}\x{a66}-\x{a6f}\x{ae6}-\x{aef}'.'\x{b66}-\x{b6f}\x{be7}-\x{bf2}\x{c66}-\x{c6f}\x{ce6}-\x{cef}\x{d66}-\x{d6f}'.'\x{e50}-\x{e59}\x{ed0}-\x{ed9}\x{f20}-\x{f33}\x{1040}-\x{1049}\x{1369}-'.'\x{137c}\x{16ee}-\x{16f0}\x{17e0}-\x{17e9}\x{17f0}-\x{17f9}\x{1810}-\x{1819}'.'\x{1946}-\x{194f}\x{2070}\x{2074}-\x{2079}\x{2080}-\x{2089}\x{2153}-\x{2183}'.'\x{2460}-\x{249b}\x{24ea}-\x{24ff}\x{2776}-\x{2793}\x{3007}\x{3021}-\x{3029}'.'\x{3038}-\x{303a}\x{3192}-\x{3195}\x{3220}-\x{3229}\x{3251}-\x{325f}\x{3280}-'.'\x{3289}\x{32b1}-\x{32bf}\x{ff10}-\x{ff19}');/** * Matches all 'P' Unicode character classes (punctuation) */define('PREG_CLASS_PUNCTUATION','\x{21}-\x{23}\x{25}-\x{2a}\x{2c}-\x{2f}\x{3a}\x{3b}\x{3f}\x{40}\x{5b}-\x{5d}'.'\x{5f}\x{7b}\x{7d}\x{a1}\x{ab}\x{b7}\x{bb}\x{bf}\x{37e}\x{387}\x{55a}-\x{55f}'.'\x{589}\x{58a}\x{5be}\x{5c0}\x{5c3}\x{5f3}\x{5f4}\x{60c}\x{60d}\x{61b}\x{61f}'.'\x{66a}-\x{66d}\x{6d4}\x{700}-\x{70d}\x{964}\x{965}\x{970}\x{df4}\x{e4f}'.'\x{e5a}\x{e5b}\x{f04}-\x{f12}\x{f3a}-\x{f3d}\x{f85}\x{104a}-\x{104f}\x{10fb}'.'\x{1361}-\x{1368}\x{166d}\x{166e}\x{169b}\x{169c}\x{16eb}-\x{16ed}\x{1735}'.'\x{1736}\x{17d4}-\x{17d6}\x{17d8}-\x{17da}\x{1800}-\x{180a}\x{1944}\x{1945}'.'\x{2010}-\x{2027}\x{2030}-\x{2043}\x{2045}-\x{2051}\x{2053}\x{2054}\x{2057}'.'\x{207d}\x{207e}\x{208d}\x{208e}\x{2329}\x{232a}\x{23b4}-\x{23b6}\x{2768}-'.'\x{2775}\x{27e6}-\x{27eb}\x{2983}-\x{2998}\x{29d8}-\x{29db}\x{29fc}\x{29fd}'.'\x{3001}-\x{3003}\x{3008}-\x{3011}\x{3014}-\x{301f}\x{3030}\x{303d}\x{30a0}'.'\x{30fb}\x{fd3e}\x{fd3f}\x{fe30}-\x{fe52}\x{fe54}-\x{fe61}\x{fe63}\x{fe68}'.'\x{fe6a}\x{fe6b}\x{ff01}-\x{ff03}\x{ff05}-\x{ff0a}\x{ff0c}-\x{ff0f}\x{ff1a}'.'\x{ff1b}\x{ff1f}\x{ff20}\x{ff3b}-\x{ff3d}\x{ff3f}\x{ff5b}\x{ff5d}\x{ff5f}-'.'\x{ff65}');/** * Matches all CJK characters that are candidates for auto-splitting * (Chinese, Japanese, Korean). * Contains kana and BMP ideographs. */define('PREG_CLASS_CJK', '\x{3041}-\x{30ff}\x{31f0}-\x{31ff}\x{3400}-\x{4db5}'.'\x{4e00}-\x{9fbb}\x{f900}-\x{fad9}');/** * Implementation of hook_help(). */function search_help($path, $arg) {  switch ($path) {    case 'admin/help#search':      $output = '<p>'. t('The search module adds the ability to search for content by keywords. Search is often the only practical way to find content on a large site, and is useful for finding both users and posts.') .'</p>';      $output .= '<p>'. t('To provide keyword searching, the search engine maintains an index of words found in your site\'s content. To build and maintain this index, a correctly configured <a href="@cron">cron maintenance task</a> is required. Indexing behavior can be adjusted using the <a href="@searchsettings">search settings page</a>; for example, the <em>Number of items to index per cron run</em> sets the maximum number of items indexed in each pass of a <a href="@cron">cron maintenance task</a>. If necessary, reduce this number to prevent timeouts and memory errors when indexing.', array('@cron' => url('admin/reports/status'), '@searchsettings' => url('admin/settings/search'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@search">Search module</a>.', array('@search' => 'http://drupal.org/handbook/modules/search/')) .'</p>';      return $output;    case 'admin/settings/search':      return '<p>'. t('The search engine maintains an index of words found in your site\'s content. To build and maintain this index, a correctly configured <a href="@cron">cron maintenance task</a> is required. Indexing behavior can be adjusted using the settings below.', array('@cron' => url('admin/reports/status'))) .'</p>';    case 'search#noresults':      return t('<ul><li>Check if your spelling is correct.</li><li>Remove quotes around phrases to match each word individually: <em>"blue smurf"</em> will match less than <em>blue smurf</em>.</li><li>Consider loosening your query with <em>OR</em>: <em>blue smurf</em> will match less than <em>blue OR smurf</em>.</li></ul>');  }}/** * Implementation of hook_theme() */function search_theme() {  return array(    'search_theme_form' => array(      'arguments' => array('form' => NULL),      'template' => 'search-theme-form',    ),    'search_block_form' => array(      'arguments' => array('form' => NULL),      'template' => 'search-block-form',    ),    'search_result' => array(      'arguments' => array('result' => NULL, 'type' => NULL),      'file' => 'search.pages.inc',      'template' => 'search-result',    ),    'search_results' => array(      'arguments' => array('results' => NULL, 'type' => NULL),      'file' => 'search.pages.inc',      'template' => 'search-results',    ),  );}/** * Implementation of hook_perm(). */function search_perm() {  return array('search content', 'use advanced search', 'administer search');}/** * Implementation of hook_block(). */function search_block($op = 'list', $delta = 0) {  if ($op == 'list') {    $blocks[0]['info'] = t('Search form');    // Not worth caching.    $blocks[0]['cache'] = BLOCK_NO_CACHE;    return $blocks;  }  else if ($op == 'view' && user_access('search content')) {    $block['content'] = drupal_get_form('search_block_form');    $block['subject'] = t('Search');    return $block;  }}/** * Implementation of hook_menu(). */function search_menu() {  $items['search'] = array(    'title' => 'Search',    'page callback' => 'search_view',    'access arguments' => array('search content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'search.pages.inc',  );  $items['admin/settings/search'] = array(    'title' => 'Search settings',    'description' => 'Configure relevance settings for search and other indexing options',    'page callback' => 'drupal_get_form',    'page arguments' => array('search_admin_settings'),    'access arguments' => array('administer search'),    'type' => MENU_NORMAL_ITEM,    'file' => 'search.admin.inc',  );  $items['admin/settings/search/wipe'] = array(    'title' => 'Clear index',    'page callback' => 'drupal_get_form',    'page arguments' => array('search_wipe_confirm'),    'access arguments' => array('administer search'),    'type' => MENU_CALLBACK,    'file' => 'search.admin.inc',  );  $items['admin/reports/search'] = array(    'title' => 'Top search phrases',    'description' => 'View most popular search phrases.',    'page callback' => 'dblog_top',    'page arguments' => array('search'),    'access arguments' => array('access site reports'),    'file' => 'dblog.admin.inc',    'file path' => drupal_get_path('module', 'dblog'),  );  foreach (module_implements('search') as $name) {    $items['search/'. $name .'/%menu_tail'] = array(      'title callback' => 'module_invoke',      'title arguments' => array($name, 'search', 'name', TRUE),      'page callback' => 'search_view',      'page arguments' => array($name),      'access callback' => '_search_menu',      'access arguments' => array($name),      'type' => MENU_LOCAL_TASK,      'parent' => 'search',      'file' => 'search.pages.inc',    );  }  return $items;}function _search_menu($name) {  return user_access('search content') && module_invoke($name, 'search', 'name');}/** * Wipes a part of or the entire search index. * * @param $sid *  (optional) The SID of the item to wipe. If specified, $type must be passed *  too. * @param $type *  (optional) The type of item to wipe. */function search_wipe($sid = NULL, $type = NULL, $reindex = FALSE) {  if ($type == NULL && $sid == NULL) {    module_invoke_all('search', 'reset');  }  else {    db_query("DELETE FROM {search_dataset} WHERE sid = %d AND type = '%s'", $sid, $type);    db_query("DELETE FROM {search_index} WHERE sid = %d AND type = '%s'", $sid, $type);    // Don't remove links if re-indexing.    if (!$reindex) {      db_query("DELETE FROM {search_node_links} WHERE sid = %d AND type = '%s'", $sid, $type);    }  }}/** * Marks a word as dirty (or retrieves the list of dirty words). This is used * during indexing (cron). Words which are dirty have outdated total counts in * the search_total table, and need to be recounted. */function search_dirty($word = NULL) {  static $dirty = array();  if ($word !== NULL) {    $dirty[$word] = TRUE;  }  else {    return $dirty;  }}/** * Implementation of hook_cron(). * * Fires hook_update_index() in all modules and cleans up dirty words (see * search_dirty). */function search_cron() {  // We register a shutdown function to ensure that search_total is always up  // to date.  register_shutdown_function('search_update_totals');  // Update word index  foreach (module_list() as $module) {    module_invoke($module, 'update_index');  }}/** * This function is called on shutdown to ensure that search_total is always * up to date (even if cron times out or otherwise fails). */function search_update_totals() {  // Update word IDF (Inverse Document Frequency) counts for new/changed words  foreach (search_dirty() as $word => $dummy) {    // Get total count    $total = db_result(db_query("SELECT SUM(score) FROM {search_index} WHERE word = '%s'", $word));    // Apply Zipf's law to equalize the probability distribution    $total = log10(1 + 1/(max(1, $total)));    db_query("UPDATE {search_total} SET count = %f WHERE word = '%s'", $total, $word);    if (!db_affected_rows()) {      db_query("INSERT INTO {search_total} (word, count) VALUES ('%s', %f)", $word, $total);    }  }  // Find words that were deleted from search_index, but are still in  // search_total. We use a LEFT JOIN between the two tables and keep only the  // rows which fail to join.  $result = db_query("SELECT t.word AS realword, i.word FROM {search_total} t LEFT JOIN {search_index} i ON t.word = i.word WHERE i.word IS NULL");  while ($word = db_fetch_object($result)) {    db_query("DELETE FROM {search_total} WHERE word = '%s'", $word->realword);  }}/** * Simplifies a string according to indexing rules. */function search_simplify($text) {  // Decode entities to UTF-8  $text = decode_entities($text);  // Lowercase  $text = drupal_strtolower($text);  // Call an external processor for word handling.  search_invoke_preprocess($text);  // Simple CJK handling  if (variable_get('overlap_cjk', TRUE)) {    $text = preg_replace_callback('/['. PREG_CLASS_CJK .']+/u', 'search_expand_cjk', $text);  }  // To improve searching for numerical data such as dates, IP addresses  // or version numbers, we consider a group of numerical characters  // separated only by punctuation characters to be one piece.  // This also means that searching for e.g. '20/03/1984' also returns  // results with '20-03-1984' in them.  // Readable regexp: ([number]+)[punctuation]+(?=[number])  $text = preg_replace('/(['. PREG_CLASS_NUMBERS .']+)['. PREG_CLASS_PUNCTUATION .']+(?=['. PREG_CLASS_NUMBERS .'])/u', '\1', $text);  // The dot, underscore and dash are simply removed. This allows meaningful  // search behavior with acronyms and URLs.  $text = preg_replace('/[._-]+/', '', $text);  // With the exception of the rules above, we consider all punctuation,  // marks, spacers, etc, to be a word boundary.  $text = preg_replace('/['. PREG_CLASS_SEARCH_EXCLUDE .']+/u', ' ', $text);  return $text;}/** * Basic CJK tokenizer. Simply splits a string into consecutive, overlapping * sequences of characters ('minimum_word_size' long). */function search_expand_cjk($matches) {  $min = variable_get('minimum_word_size', 3);  $str = $matches[0];  $l = drupal_strlen($str);  // Passthrough short words  if ($l <= $min) {    return ' '. $str .' ';  }  $tokens = ' ';  // FIFO queue of characters  $chars = array();  // Begin loop  for ($i = 0; $i < $l; ++$i) {    // Grab next character    $current = drupal_substr($str, 0, 1);    $str = substr($str, strlen($current));    $chars[] = $current;    if ($i >= $min - 1) {      $tokens .= implode('', $chars) .' ';      array_shift($chars);    }  }  return $tokens;}/** * Splits a string into tokens for indexing. */function search_index_split($text) {  static $last = NULL;  static $lastsplit = NULL;  if ($last == $text) {    return $lastsplit;  }  // Process words  $text = search_simplify($text);  $words = explode(' ', $text);  array_walk($words, '_search_index_truncate');  // Save last keyword result  $last = $text;  $lastsplit = $words;  return $words;}/** * Helper function for array_walk in search_index_split. */function _search_index_truncate(&$text) {  $text = truncate_utf8($text, 50);}/** * Invokes hook_search_preprocess() in modules. */function search_invoke_preprocess(&$text) {  foreach (module_implements('search_preprocess') as $module) {    $text = module_invoke($module, 'search_preprocess', $text);  }}/** * Update the full-text search index for a particular item. * * @param $sid *   A number identifying this particular item (e.g. node id). * * @param $type *   A string defining this type of item (e.g. 'node') * * @param $text *   The content of this item. Must be a piece of HTML text. * * @ingroup search */function search_index($sid, $type, $text) {  $minimum_word_size = variable_get('minimum_word_size', 3);  // Link matching  global $base_url;  $node_regexp = '@href=[\'"]?(?:'. preg_quote($base_url, '@') .'/|'. preg_quote(base_path(), '@') .')(?:\?q=)?/?((?![a-z]+:)[^\'">]+)[\'">]@i';  // Multipliers for scores of words inside certain HTML tags.  // Note: 'a' must be included for link ranking to work.  $tags = array('h1' => 25,                'h2' => 18,                'h3' => 15,                'h4' => 12,                'h5' => 9,                'h6' => 6,                'u' => 3,                'b' => 3,                'i' => 3,                'strong' => 3,                'em' => 3,                'a' => 10);  // Strip off all ignored tags to speed up processing, but insert space before/after  // them to keep word boundaries.  $text = str_replace(array('<', '>'), array(' <', '> '), $text);  $text = strip_tags($text, '<'. implode('><', array_keys($tags)) .'>');  // Split HTML tags from plain text.  $split = preg_split('/\s*<([^>]+?)>\s*/', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting $null as required).  $tag = FALSE; // Odd/even counter. Tag or no tag.  $link = FALSE; // State variable for link analyser  $score = 1; // Starting score per word  $accum = ' '; // Accumulator for cleaned up data  $tagstack = array(); // Stack with open tags  $tagwords = 0; // Counter for consecutive words  $focus = 1; // Focus state  $results = array(0 => array()); // Accumulator for words for index  foreach ($split as $value) {    if ($tag) {      // Increase or decrease score per word based on tag      list($tagname) = explode(' ', $value, 2);      $tagname = drupal_strtolower($tagname);      // Closing or opening tag?      if ($tagname[0] == '/') {        $tagname = substr($tagname, 1);        // If we encounter unexpected tags, reset score to avoid incorrect boosting.        if (!count($tagstack) || $tagstack[0] != $tagname) {          $tagstack = array();          $score = 1;        }        else {          // Remove from tag stack and decrement score          $score = max(1, $score - $tags[array_shift($tagstack)]);        }        if ($tagname == 'a') {          $link = FALSE;        }      }      else {        if (isset($tagstack[0]) && $tagstack[0] == $tagname) {          // None of the tags we look for make sense when nested identically.          // If they are, it's probably broken HTML.          $tagstack = array();          $score = 1;        }        else {          // Add to open tag stack and increment score          array_unshift($tagstack, $tagname);          $score += $tags[$tagname];        }        if ($tagname == 'a') {          // Check if link points to a node on this site          if (preg_match($node_regexp, $value, $match)) {            $path = drupal_get_normal_path($match[1]);            if (preg_match('!(?:node|book)/(?:view/)?([0-9]+)!i', $path, $match)) {              $linknid = $match[1];              if ($linknid > 0) {                // Note: ignore links to uncachable nodes to avoid redirect bugs.                $node = db_fetch_object(db_query('SELECT n.title, n.nid, n.vid, r.format FROM {node} n INNER JOIN {node_revisions} r ON n.vid = r.vid WHERE n.nid = %d', $linknid));                if (filter_format_allowcache($node->format)) {                  $link = TRUE;                  $linktitle = $node->title;                }              }            }          }        }      }      // A tag change occurred, reset counter.      $tagwords = 0;    }    else {      // Note: use of PREG_SPLIT_DELIM_CAPTURE above will introduce empty values      if ($value != '') {        if ($link) {          // Check to see if the node link text is its URL. If so, we use the target node title instead.          if (preg_match('!^https?://!i', $value)) {            $value = $linktitle;          }        }        $words = search_index_split($value);        foreach ($words as $word) {          // Add word to accumulator          $accum .= $word .' ';          $num = is_numeric($word);          // Check wordlength          if ($num || drupal_strlen($word) >= $minimum_word_size) {            // Normalize numbers            if ($num) {              $word = (int)ltrim($word, '-0');            }            // Links score mainly for the target.            if ($link) {              if (!isset($results[$linknid])) {                $results[$linknid] = array();              }              $results[$linknid][] = $word;              // Reduce score of the link caption in the source.              $focus *= 0.2;            }            // Fall-through            if (!isset($results[0][$word])) {              $results[0][$word] = 0;            }            $results[0][$word] += $score * $focus;            // Focus is a decaying value in terms of the amount of unique words up to this point.            // From 100 words and more, it decays, to e.g. 0.5 at 500 words and 0.3 at 1000 words.            $focus = min(1, .01 + 3.5 / (2 + count($results[0]) * .015));          }          $tagwords++;          // Too many words inside a single tag probably mean a tag was accidentally left open.          if (count($tagstack) && $tagwords >= 15) {            $tagstack = array();            $score = 1;          }        }      }    }    $tag = !$tag;  }  search_wipe($sid, $type, TRUE);  // Insert cleaned up data into dataset  db_query("INSERT INTO {search_dataset} (sid, type, data, reindex) VALUES (%d, '%s', '%s', %d)", $sid, $type, $accum, 0);  // Insert results into search index  foreach ($results[0] as $word => $score) {    // Try inserting first because this will succeed most times, but because    // the database collates similar words (accented and non-accented), the    // insert can fail, in which case we need to add the word scores together.    @db_query("INSERT INTO {search_index} (word, sid, type, score) VALUES ('%s', %d, '%s', %f)", $word, $sid, $type, $score);    if (!db_affected_rows()) {      db_query("UPDATE {search_index} SET score = score + %f WHERE word = '%s' AND sid = %d AND type = '%s'", $score, $word, $sid, $type);    }    search_dirty($word);  }  unset($results[0]);  // Get all previous links from this item.  $result = db_query("SELECT nid, caption FROM {search_node_links} WHERE sid = %d AND type = '%s'", $sid, $type);  $links = array();  while ($link = db_fetch_object($result)) {    $links[$link->nid] = $link->caption;  }  // Now store links to nodes.  foreach ($results as $nid => $words) {    $caption = implode(' ', $words);    if (isset($links[$nid])) {      if ($links[$nid] != $caption) {        // Update the existing link and mark the node for reindexing.        db_query("UPDATE {search_node_links} SET caption = '%s' WHERE sid = %d AND type = '%s' AND nid = %d", $caption, $sid, $type, $nid);        search_touch_node($nid);      }      // Unset the link to mark it as processed.      unset($links[$nid]);    }    else {      // Insert the existing link and mark the node for reindexing.      db_query("INSERT INTO {search_node_links} (caption, sid, type, nid) VALUES ('%s', %d, '%s', %d)", $caption, $sid, $type, $nid);      search_touch_node($nid);    }  }  // Any left-over links in $links no longer exist. Delete them and mark the nodes for reindexing.  foreach ($links as $nid => $caption) {    db_query("DELETE FROM {search_node_links} WHERE sid = %d AND type = '%s' AND nid = %d", $sid, $type, $nid);    search_touch_node($nid);  }}/** * Change a node's changed timestamp to 'now' to force reindexing. * * @param $nid *   The nid of the node that needs reindexing. */function search_touch_node($nid) {  db_query("UPDATE {search_dataset} SET reindex = %d WHERE sid = %d AND type = 'node'", time(), $nid);}/** * Implementation of hook_nodeapi(). */function search_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {  switch ($op) {    // Transplant links to a node into the target node.    case 'update index':      $result = db_query("SELECT caption FROM {search_node_links} WHERE nid = %d", $node->nid);      $output = array();      while ($link = db_fetch_object($result)) {        $output[] = $link->caption;      }      if (count($output)) {        return '<a>('. implode(', ', $output) .')</a>';      }      break;    // Reindex the node when it is updated.  The node is automatically indexed    // when it is added, simply by being added to the node table.    case 'update':      search_touch_node($node->nid);      break;  }}/** * Implementation of hook_comment(). */function search_comment($a1, $op) {  switch ($op) {    // Reindex the node when comments are added or changed    case 'insert':    case 'update':    case 'delete':    case 'publish':    case 'unpublish':      search_touch_node(is_array($a1) ? $a1['nid'] : $a1->nid);      break;  }}/** * Extract a module-specific search option from a search query. e.g. 'type:book' */function search_query_extract($keys, $option) {  if (preg_match('/(^| )'. $option .':([^ ]*)( |$)/i', $keys, $matches)) {    return $matches[2];  }}/** * Return a query with the given module-specific search option inserted in. * e.g. 'type:book'. */function search_query_insert($keys, $option, $value = '') {  if (search_query_extract($keys, $option)) {    $keys = trim(preg_replace('/(^| )'. $option .':[^ ]*/i', '', $keys));  }  if ($value != '') {    $keys .= ' '. $option .':'. $value;  }  return $keys;}/** * Parse a search query into SQL conditions. * * We build two queries that matches the dataset bodies. @See do_search for * more about these. * * @param $text *   The search keys. * @return *   A list of six elements. *    * A series of statements AND'd together which will be used to provide all *      possible matches. *    * Arguments for this query part. *    * A series of exact word matches OR'd together. *    * Arguments for this query part. *    * A bool indicating whether this is a simple query or not. Negative *      terms, presence of both AND / OR make this FALSE. *    * A bool indicating the presence of a lowercase or. Maybe the user *      wanted to use OR. */function search_parse_query($text) {  $keys = array('positive' => array(), 'negative' => array());  // Tokenize query string  preg_match_all('/ (-?)("[^"]+"|[^" ]+)/i', ' '. $text, $matches, PREG_SET_ORDER);  if (count($matches) < 1) {    return NULL;  }  // Classify tokens  $or = FALSE;  $warning = '';  $simple = TRUE;  foreach ($matches as $match) {    $phrase = FALSE;    // Strip off phrase quotes    if ($match[2]{0} == '"') {      $match[2] = substr($match[2], 1, -1);      $phrase = TRUE;      $simple = FALSE;    }    // Simplify keyword according to indexing rules and external preprocessors    $words = search_simplify($match[2]);    // Re-explode in case simplification added more words, except when matching a phrase    $words = $phrase ? array($words) : preg_split('/ /', $words, -1, PREG_SPLIT_NO_EMPTY);    // Negative matches    if ($match[1] == '-') {      $keys['negative'] = array_merge($keys['negative'], $words);    }    // OR operator: instead of a single keyword, we store an array of all    // OR'd keywords.    elseif ($match[2] == 'OR' && count($keys['positive'])) {      $last = array_pop($keys['positive']);      // Starting a new OR?      if (!is_array($last)) {        $last = array($last);      }      $keys['positive'][] = $last;      $or = TRUE;      continue;    }    // AND operator: implied, so just ignore it    elseif ($match[2] == 'AND' || $match[2] == 'and') {      $warning = $match[2];      continue;    }    // Plain keyword    else {      if ($match[2] == 'or') {        $warning = $match[2];      }      if ($or) {        // Add to last element (which is an array)        $keys['positive'][count($keys['positive']) - 1] = array_merge($keys['positive'][count($keys['positive']) - 1], $words);      }      else {        $keys['positive'] = array_merge($keys['positive'], $words);      }    }    $or = FALSE;  }  // Convert keywords into SQL statements.  $query = array();  $query2 = array();  $arguments = array();  $arguments2 = array();  $matches = 0;  $simple_and = FALSE;  $simple_or = FALSE;  // Positive matches  foreach ($keys['positive'] as $key) {    // Group of ORed terms    if (is_array($key) && count($key)) {      $simple_or = TRUE;      $queryor = array();      $any = FALSE;      foreach ($key as $or) {        list($q, $num_new_scores) = _search_parse_query($or, $arguments2);        $any |= $num_new_scores;        if ($q) {          $queryor[] = $q;          $arguments[] = $or;        }      }      if (count($queryor)) {        $query[] = '('. implode(' OR ', $queryor) .')';        // A group of OR keywords only needs to match once        $matches += ($any > 0);      }    }    // Single ANDed term    else {      $simple_and = TRUE;      list($q, $num_new_scores, $num_valid_words) = _search_parse_query($key, $arguments2);      if ($q) {        $query[] = $q;        $arguments[] = $key;        if (!$num_valid_words) {          $simple = FALSE;        }        // Each AND keyword needs to match at least once        $matches += $num_new_scores;      }    }  }  if ($simple_and && $simple_or) {    $simple = FALSE;  }  // Negative matches  foreach ($keys['negative'] as $key) {    list($q) = _search_parse_query($key, $arguments2, TRUE);    if ($q) {      $query[] = $q;      $arguments[] = $key;      $simple = FALSE;    }  }  $query = implode(' AND ', $query);  // Build word-index conditions for the first pass  $query2 = substr(str_repeat("i.word = '%s' OR ", count($arguments2)), 0, -4);  return array($query, $arguments, $query2, $arguments2, $matches, $simple, $warning);}/** * Helper function for search_parse_query(); */function _search_parse_query(&$word, &$scores, $not = FALSE) {  $num_new_scores = 0;  $num_valid_words = 0;  // Determine the scorewords of this word/phrase  if (!$not) {    $split = explode(' ', $word);    foreach ($split as $s) {      $num = is_numeric($s);      if ($num || drupal_strlen($s) >= variable_get('minimum_word_size', 3)) {        $s = $num ? ((int)ltrim($s, '-0')) : $s;        if (!isset($scores[$s])) {          $scores[$s] = $s;          $num_new_scores++;        }        $num_valid_words++;      }    }  }  // Return matching snippet and number of added words  return array("d.data ". ($not ? 'NOT ' : '') ."LIKE '%% %s %%'", $num_new_scores, $num_valid_words);}/** * Do a query on the full-text search index for a word or words. * * This function is normally only called by each module that support the * indexed search (and thus, implements hook_update_index()). * * Results are retrieved in two logical passes. However, the two passes are * joined together into a single query.  And in the case of most simple * queries the second pass is not even used. * * The first pass selects a set of all possible matches, which has the benefit * of also providing the exact result set for simple "AND" or "OR" searches. * * The second portion of the query further refines this set by verifying * advanced text conditions (such negative or phrase matches) * * @param $keywords *   A search string as entered by the user. * * @param $type *   A string identifying the calling module. * * @param $join1 *   (optional) Inserted into the JOIN part of the first SQL query. *   For example "INNER JOIN {node} n ON n.nid = i.sid". * * @param $where1 *   (optional) Inserted into the WHERE part of the first SQL query. *   For example "(n.status > %d)". * * @param $arguments1 *   (optional) Extra SQL arguments belonging to the first query. * * @param $columns2 *   (optional) Inserted into the SELECT pat of the second query. Must contain *   a column selected as 'score'. *   defaults to 'i.relevance AS score' * * @param $join2 *   (optional) Inserted into the JOIN par of the second SQL query. *   For example "INNER JOIN {node_comment_statistics} n ON n.nid = i.sid" * * @param $arguments2 *   (optional) Extra SQL arguments belonging to the second query parameter. * * @param $sort_parameters *   (optional) SQL arguments for sorting the final results. *              Default: 'ORDER BY score DESC' * * @return *   An array of SIDs for the search results. * * @ingroup search */function do_search($keywords, $type, $join1 = '', $where1 = '1 = 1', $arguments1 = array(), $columns2 = 'i.relevance AS score', $join2 = '', $arguments2 = array(), $sort_parameters = 'ORDER BY score DESC') {  $query = search_parse_query($keywords);  if ($query[2] == '') {    form_set_error('keys', t('You must include at least one positive keyword with @count characters or more.', array('@count' => variable_get('minimum_word_size', 3))));  }  if ($query[6]) {    if ($query[6] == 'or') {      drupal_set_message(t('Search for either of the two terms with uppercase <strong>OR</strong>. For example, <strong>cats OR dogs</strong>.'));    }  }  if ($query === NULL || $query[0] == '' || $query[2] == '') {    return array();  }  // Build query for keyword normalization.  $conditions = "$where1 AND ($query[2]) AND i.type = '%s'";  $arguments1 = array_merge($arguments1, $query[3], array($type));  $join = "INNER JOIN {search_total} t ON i.word = t.word $join1";  if (!$query[5]) {    $conditions .= " AND ($query[0])";    $arguments1 = array_merge($arguments1, $query[1]);    $join .= " INNER JOIN {search_dataset} d ON i.sid = d.sid AND i.type = d.type";  }  // Calculate maximum keyword relevance, to normalize it.  $select = "SELECT SUM(i.score * t.count) AS score FROM {search_index} i $join WHERE $conditions GROUP BY i.type, i.sid HAVING COUNT(*) >= %d ORDER BY score DESC";  $arguments = array_merge($arguments1, array($query[4]));  $normalize = db_result(db_query_range($select, $arguments, 0, 1));  if (!$normalize) {    return array();  }  $columns2 = str_replace('i.relevance', '('. (1.0 / $normalize) .' * SUM(i.score * t.count))', $columns2);  // Build query to retrieve results.  $select = "SELECT i.type, i.sid, $columns2 FROM {search_index} i $join $join2 WHERE $conditions GROUP BY i.type, i.sid HAVING COUNT(*) >= %d";  $count_select =  "SELECT COUNT(*) FROM ($select) n1";  $arguments = array_merge($arguments2, $arguments1, array($query[4]));  // Do actual search query  $result = pager_query("$select $sort_parameters", 10, 0, $count_select, $arguments);  $results = array();  while ($item = db_fetch_object($result)) {    $results[] = $item;  }  return $results;}/** * Helper function for grabbing search keys. */function search_get_keys() {  static $return;  if (!isset($return)) {    // Extract keys as remainder of path    // Note: support old GET format of searches for existing links.    $path = explode('/', $_GET['q'], 3);    $keys = empty($_REQUEST['keys']) ? '' : $_REQUEST['keys'];    $return = count($path) == 3 ? $path[2] : $keys;  }  return $return;}/** * @defgroup search Search interface * @{ * The Drupal search interface manages a global search mechanism. * * Modules may plug into this system to provide searches of different types of * data. Most of the system is handled by search.module, so this must be enabled * for all of the search features to work. * * There are three ways to interact with the search system: * - Specifically for searching nodes, you can implement nodeapi('update index') *   and nodeapi('search result'). However, note that the search system already *   indexes all visible output of a node, i.e. everything displayed normally *   by hook_view() and hook_nodeapi('view'). This is usually sufficient. *   You should only use this mechanism if you want additional, non-visible data *   to be indexed. * - Implement hook_search(). This will create a search tab for your module on *   the /search page with a simple keyword search form. You may optionally *   implement hook_search_item() to customize the display of your results. * - Implement hook_update_index(). This allows your module to use Drupal's *   HTML indexing mechanism for searching full text efficiently. * * If your module needs to provide a more complicated search form, then you need * to implement it yourself without hook_search(). In that case, you should * define it as a local task (tab) under the /search page (e.g. /search/mymodule) * so that users can easily find it. *//** * Render a search form. * * @param $action *   Form action. Defaults to "search". * @param $keys *   The search string entered by the user, containing keywords for the search. * @param $type *   The type of search to render the node for. Must be the name of module *   which implements hook_search(). Defaults to 'node'. * @param $prompt *   A piece of text to put before the form (e.g. "Enter your keywords") * @return *   An HTML string containing the search form. */function search_form(&$form_state, $action = '', $keys = '', $type = NULL, $prompt = NULL) {  // Add CSS  drupal_add_css(drupal_get_path('module', 'search') .'/search.css', 'module', 'all', FALSE);  if (!$action) {    $action = url('search/'. $type);  }  if (is_null($prompt)) {    $prompt = t('Enter your keywords');  }  $form = array(    '#action' => $action,    '#attributes' => array('class' => 'search-form'),  );  $form['module'] = array('#type' => 'value', '#value' => $type);  $form['basic'] = array('#type' => 'item', '#title' => $prompt);  $form['basic']['inline'] = array('#prefix' => '<div class="container-inline">', '#suffix' => '</div>');  $form['basic']['inline']['keys'] = array(    '#type' => 'textfield',    '#title' => '',    '#default_value' => $keys,    '#size' => $prompt ? 40 : 20,    '#maxlength' => 255,  );  // processed_keys is used to coordinate keyword passing between other forms  // that hook into the basic search form.  $form['basic']['inline']['processed_keys'] = array('#type' => 'value', '#value' => array());  $form['basic']['inline']['submit'] = array('#type' => 'submit', '#value' => t('Search'));  return $form;}/** * Form builder; Output a search form for the search block and the theme's search box. * * @ingroup forms * @see search_box_form_submit() * @see theme_search_box_form() */function search_box(&$form_state, $form_id) {  $form[$form_id] = array(    '#title' => t('Search this site'),    '#type' => 'textfield',    '#size' => 15,    '#default_value' => '',    '#attributes' => array('title' => t('Enter the terms you wish to search for.')),  );  $form['submit'] = array('#type' => 'submit', '#value' => t('Search'));  $form['#submit'][] = 'search_box_form_submit';  return $form;}/** * Process a block search form submission. */function search_box_form_submit($form, &$form_state) {  // The search form relies on control of the redirect destination for its  // functionality, so we override any static destination set in the request,  // for example by drupal_access_denied() or drupal_not_found()  // (see http://drupal.org/node/292565).  if (isset($_REQUEST['destination'])) {    unset($_REQUEST['destination']);  }  if (isset($_REQUEST['edit']['destination'])) {    unset($_REQUEST['edit']['destination']);  }  $form_id = $form['form_id']['#value'];  $form_state['redirect'] = 'search/node/'. trim($form_state['values'][$form_id]);}/** * Process variables for search-theme-form.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see search-theme-form.tpl.php */function template_preprocess_search_theme_form(&$variables) {  $variables['search'] = array();  $hidden = array();  // Provide variables named after form keys so themers can print each element independently.  foreach (element_children($variables['form']) as $key) {    $type = $variables['form'][$key]['#type'];    if ($type == 'hidden' || $type == 'token') {      $hidden[] = drupal_render($variables['form'][$key]);    }    else {      $variables['search'][$key] = drupal_render($variables['form'][$key]);    }  }  // Hidden form elements have no value to themers. No need for separation.  $variables['search']['hidden'] = implode($hidden);  // Collect all form elements to make it easier to print the whole form.  $variables['search_form'] = implode($variables['search']);}/** * Process variables for search-block-form.tpl.php. * * The $variables array contains the following arguments: * - $form * * @see search-block-form.tpl.php */function template_preprocess_search_block_form(&$variables) {  $variables['search'] = array();  $hidden = array();  // Provide variables named after form keys so themers can print each element independently.  foreach (element_children($variables['form']) as $key) {    $type = $variables['form'][$key]['#type'];    if ($type == 'hidden' || $type == 'token') {      $hidden[] = drupal_render($variables['form'][$key]);    }    else {      $variables['search'][$key] = drupal_render($variables['form'][$key]);    }  }  // Hidden form elements have no value to themers. No need for separation.  $variables['search']['hidden'] = implode($hidden);  // Collect all form elements to make it easier to print the whole form.  $variables['search_form'] = implode($variables['search']);}/** * Perform a standard search on the given keys, and return the formatted results. */function search_data($keys = NULL, $type = 'node') {  if (isset($keys)) {    if (module_hook($type, 'search')) {      $results = module_invoke($type, 'search', 'search', $keys);      if (isset($results) && is_array($results) && count($results)) {        if (module_hook($type, 'search_page')) {          return module_invoke($type, 'search_page', $results);        }        else {          return theme('search_results', $results, $type);        }      }    }  }}/** * Returns snippets from a piece of text, with certain keywords highlighted. * Used for formatting search results. * * @param $keys *   A string containing a search query. * * @param $text *   The text to extract fragments from. * * @return *   A string containing HTML for the excerpt. */function search_excerpt($keys, $text) {  // We highlight around non-indexable or CJK characters.  $boundary = '(?:(?<=['. PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK .'])|(?=['. PREG_CLASS_SEARCH_EXCLUDE . PREG_CLASS_CJK .']))';  // Extract positive keywords and phrases  preg_match_all('/ ("([^"]+)"|(?!OR)([^" ]+))/', ' '. $keys, $matches);  $keys = array_merge($matches[2], $matches[3]);  // Prepare text  $text = ' '. strip_tags(str_replace(array('<', '>'), array(' <', '> '), $text)) .' ';  array_walk($keys, '_search_excerpt_replace');  $workkeys = $keys;  // Extract a fragment per keyword for at most 4 keywords.  // First we collect ranges of text around each keyword, starting/ending  // at spaces.  // If the sum of all fragments is too short, we look for second occurrences.  $ranges = array();  $included = array();  $length = 0;  while ($length < 256 && count($workkeys)) {    foreach ($workkeys as $k => $key) {      if (strlen($key) == 0) {        unset($workkeys[$k]);        unset($keys[$k]);        continue;      }      if ($length >= 256) {        break;      }      // Remember occurrence of key so we can skip over it if more occurrences      // are desired.      if (!isset($included[$key])) {        $included[$key] = 0;      }      // Locate a keyword (position $p), then locate a space in front (position      // $q) and behind it (position $s)      if (preg_match('/'. $boundary . $key . $boundary .'/iu', $text, $match, PREG_OFFSET_CAPTURE, $included[$key])) {        $p = $match[0][1];        if (($q = strpos($text, ' ', max(0, $p - 60))) !== FALSE) {          $end = substr($text, $p, 80);          if (($s = strrpos($end, ' ')) !== FALSE) {            $ranges[$q] = $p + $s;            $length += $p + $s - $q;            $included[$key] = $p + 1;          }          else {            unset($workkeys[$k]);          }        }        else {          unset($workkeys[$k]);        }      }      else {        unset($workkeys[$k]);      }    }  }  // If we didn't find anything, return the beginning.  if (count($ranges) == 0) {    return truncate_utf8($text, 256) .' ...';  }  // Sort the text ranges by starting position.  ksort($ranges);  // Now we collapse overlapping text ranges into one. The sorting makes it O(n).  $newranges = array();  foreach ($ranges as $from2 => $to2) {    if (!isset($from1)) {      $from1 = $from2;      $to1 = $to2;      continue;    }    if ($from2 <= $to1) {      $to1 = max($to1, $to2);    }    else {      $newranges[$from1] = $to1;      $from1 = $from2;      $to1 = $to2;    }  }  $newranges[$from1] = $to1;  // Fetch text  $out = array();  foreach ($newranges as $from => $to) {    $out[] = substr($text, $from, $to - $from);  }  $text = (isset($newranges[0]) ? '' : '... ') . implode(' ... ', $out) .' ...';  // Highlight keywords. Must be done at once to prevent conflicts ('strong' and '<strong>').  $text = preg_replace('/'. $boundary .'('. implode('|', $keys) .')'. $boundary .'/iu', '<strong>\0</strong>', $text);  return $text;}/** * @} End of "defgroup search". *//** * Helper function for array_walk in search_except. */function _search_excerpt_replace(&$text) {  $text = preg_quote($text, '/');}function search_forms() {  $forms['search_theme_form']= array(    'callback' => 'search_box',    'callback arguments' => array('search_theme_form'),  );  $forms['search_block_form']= array(    'callback' => 'search_box',    'callback arguments' => array('search_block_form'),  );  return $forms;}
<?php// $Id$/** * @file * Enables your site to capture votes on different topics in the form of multiple * choice questions. *//** * Implementation of hook_help(). */function poll_help($path, $arg) {  switch ($path) {    case 'admin/help#poll':      $output = '<p>'. t('The poll module can be used to create simple polls for site users. A poll is a simple, multiple choice questionnaire which displays the cumulative results of the answers to the poll. Having polls on the site is a good way to receive feedback from community members.') .'</p>';      $output .= '<p>'. t('When creating a poll, enter the question being posed, as well as the potential choices (and beginning vote counts for each choice). The status and duration (length of time the poll remains active for new votes) can also be specified. Use the <a href="@poll">poll</a> menu item to view all current polls. To vote in or view the results of a specific poll, click on the poll itself.', array('@poll' => url('poll'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@poll">Poll module</a>.', array('@poll' => 'http://drupal.org/handbook/modules/poll/')) .'</p>';      return $output;  }}/** * Implementation of hook_init(). */function poll_init() {  drupal_add_css(drupal_get_path('module', 'poll') .'/poll.css');}/** * Implementation of hook_theme() */function poll_theme() {  return array(    'poll_vote' => array(      'template' => 'poll-vote',      'arguments' => array('form' => NULL),    ),    'poll_choices' => array(      'arguments' => array('form' => NULL),    ),    'poll_results' => array(      'template' => 'poll-results',      'arguments' => array('raw_title' => NULL, 'results' => NULL, 'votes' => NULL, 'raw_links' => NULL, 'block' => NULL, 'nid' => NULL, 'vote' => NULL),    ),    'poll_bar' => array(      'template' => 'poll-bar',      'arguments' => array('title' => NULL, 'votes' => NULL, 'total_votes' => NULL, 'vote' => NULL, 'block' => NULL),    ),  );}/** * Implementation of hook_perm(). */function poll_perm() {  return array('create poll content', 'delete own poll content', 'delete any poll content', 'edit any poll content', 'edit own poll content', 'vote on polls', 'cancel own vote', 'inspect all votes');}/** * Implementation of hook_access(). */function poll_access($op, $node, $account) {  switch ($op) {    case 'create':      return user_access('create poll content', $account) ? TRUE : NULL;    case 'update':      return user_access('edit any poll content', $account) || (user_access('edit own poll content', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;    case 'delete':      return user_access('delete any poll content', $account) || (user_access('delete own poll content', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;  }}/** * Implementation of hook_menu(). */function poll_menu() {  $items['poll'] = array(    'title' => 'Polls',    'page callback' => 'poll_page',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'poll.pages.inc',  );  $items['node/%node/votes'] = array(    'title' => 'Votes',    'page callback' => 'poll_votes',    'page arguments' => array(1),    'access callback' => '_poll_menu_access',    'access arguments' => array(1, 'inspect all votes', FALSE),    'weight' => 3,    'type' => MENU_LOCAL_TASK,    'file' => 'poll.pages.inc',  );  $items['node/%node/results'] = array(    'title' => 'Results',    'page callback' => 'poll_results',    'page arguments' => array(1),    'access callback' => '_poll_menu_access',    'access arguments' => array(1, 'access content', TRUE),    'weight' => 3,    'type' => MENU_LOCAL_TASK,    'file' => 'poll.pages.inc',  );  $items['poll/js'] = array(    'title' => 'Javascript Choice Form',    'page callback' => 'poll_choice_js',    'access arguments' => array('access content'),    'type' => MENU_CALLBACK,  );  return $items;}/** * Callback function to see if a node is acceptable for poll menu items. */function _poll_menu_access($node, $perm, $inspect_allowvotes) {  return user_access($perm) && ($node->type == 'poll') && ($node->allowvotes || !$inspect_allowvotes);}/** * Implementation of hook_block(). * * Generates a block containing the latest poll. */function poll_block($op = 'list', $delta = 0) {  if (user_access('access content')) {    if ($op == 'list') {      $blocks[0]['info'] = t('Most recent poll');      return $blocks;    }    else if ($op == 'view') {      // Retrieve the latest poll.      $sql = db_rewrite_sql("SELECT MAX(n.created) FROM {node} n INNER JOIN {poll} p ON p.nid = n.nid WHERE n.status = 1 AND p.active = 1");      $timestamp = db_result(db_query($sql));      if ($timestamp) {        $poll = node_load(array('type' => 'poll', 'created' => $timestamp, 'status' => 1));        if ($poll->nid) {          $poll = poll_view($poll, TRUE, FALSE, TRUE);        }      }      $block['subject'] = t('Poll');      $block['content'] = drupal_render($poll->content);      return $block;    }  }}/** * Implementation of hook_cron(). * * Closes polls that have exceeded their allowed runtime. */function poll_cron() {  $result = db_query('SELECT p.nid FROM {poll} p INNER JOIN {node} n ON p.nid = n.nid WHERE (n.created + p.runtime) < '. time() .' AND p.active = 1 AND p.runtime != 0');  while ($poll = db_fetch_object($result)) {    db_query("UPDATE {poll} SET active = 0 WHERE nid = %d", $poll->nid);  }}/** * Implementation of hook_node_info(). */function poll_node_info() {  return array(    'poll' => array(      'name' => t('Poll'),      'module' => 'poll',      'description' => t('A <em>poll</em> is a question with a set of possible responses. A <em>poll</em>, once created, automatically provides a simple running count of the number of votes received for each response.'),      'title_label' => t('Question'),      'has_body' => FALSE,    )  );}/** * Implementation of hook_form(). */function poll_form(&$node, $form_state) {  global $user;  $admin = user_access('administer nodes') || user_access('edit any poll content') || (user_access('edit own poll content') && $user->uid == $node->uid);  $type = node_get_types('type', $node);  $form = array(    '#cache' => TRUE,  );  $form['title'] = array(    '#type' => 'textfield',    '#title' => check_plain($type->title_label),    '#required' => TRUE,    '#default_value' => $node->title,    '#weight' => -5,  );  if (isset($form_state['choice_count'])) {    $choice_count = $form_state['choice_count'];  }  else {    $choice_count = max(2, empty($node->choice) ? 2 : count($node->choice));  }  // Add a wrapper for the choices and more button.  $form['choice_wrapper'] = array(    '#tree' => FALSE,    '#weight' => -4,    '#prefix' => '<div class="clear-block" id="poll-choice-wrapper">',    '#suffix' => '</div>',  );  // Container for just the poll choices.  $form['choice_wrapper']['choice'] = array(    '#prefix' => '<div id="poll-choices">',    '#suffix' => '</div>',    '#theme' => 'poll_choices',  );  // Add the current choices to the form.  for ($delta = 0; $delta < $choice_count; $delta++) {    $text = isset($node->choice[$delta]['chtext']) ? $node->choice[$delta]['chtext'] : '';    $votes = isset($node->choice[$delta]['chvotes']) ? $node->choice[$delta]['chvotes'] : 0;    $form['choice_wrapper']['choice'][$delta] = _poll_choice_form($delta, $text, $votes);  }  // We name our button 'poll_more' to avoid conflicts with other modules using  // AHAH-enabled buttons with the id 'more'.  $form['choice_wrapper']['poll_more'] = array(    '#type' => 'submit',    '#value' => t('More choices'),    '#description' => t("If the amount of boxes above isn't enough, click here to add more choices."),    '#weight' => 1,    '#submit' => array('poll_more_choices_submit'), // If no javascript action.    '#ahah' => array(      'path' => 'poll/js',      'wrapper' => 'poll-choices',      'method' => 'replace',      'effect' => 'fade',    ),  );  // Poll attributes  $_duration = array(0 => t('Unlimited')) + drupal_map_assoc(array(86400, 172800, 345600, 604800, 1209600, 2419200, 4838400, 9676800, 31536000), "format_interval");  $_active = array(0 => t('Closed'), 1 => t('Active'));  if ($admin) {    $form['settings'] = array(      '#type' => 'fieldset',      '#collapsible' => TRUE,      '#title' => t('Poll settings'),      '#weight' => -3,    );    $form['settings']['active'] = array(      '#type' => 'radios',      '#title' => t('Poll status'),      '#default_value' => isset($node->active) ? $node->active : 1,      '#options' => $_active,      '#description' => t('When a poll is closed, visitors can no longer vote for it.')    );  }  $form['settings']['runtime'] = array(    '#type' => 'select',    '#title' => t('Poll duration'),    '#default_value' => isset($node->runtime) ? $node->runtime : 0,    '#options' => $_duration,    '#description' => t('After this period, the poll will be closed automatically.'),  );  return $form;}/** * Submit handler to add more choices to a poll form. This handler is used when * javascript is not available. It makes changes to the form state and the * entire form is rebuilt during the page reload. */function poll_more_choices_submit($form, &$form_state) {  // Set the form to rebuild and run submit handlers.  node_form_submit_build_node($form, $form_state);  // Make the changes we want to the form state.  if ($form_state['values']['poll_more']) {    $n = $_GET['q'] == 'poll/js' ? 1 : 5;    $form_state['choice_count'] = count($form_state['values']['choice']) + $n;  }}function _poll_choice_form($delta, $value = '', $votes = 0) {  $admin = user_access('administer nodes');  $form = array(    '#tree' => TRUE,  );  // We'll manually set the #parents property of these fields so that  // their values appear in the $form_state['values']['choice'] array.  $form['chtext'] = array(    '#type' => 'textfield',    '#title' => t('Choice @n', array('@n' => ($delta + 1))),    '#default_value' => $value,    '#parents' => array('choice', $delta, 'chtext'),  );  if ($admin) {    $form['chvotes'] = array(      '#type' => 'textfield',      '#title' => t('Votes for choice @n', array('@n' => ($delta + 1))),      '#default_value' => $votes,      '#size' => 5,      '#maxlength' => 7,      '#parents' => array('choice', $delta, 'chvotes'),    );  }  return $form;}/** * Menu callback for AHAH additions. */function poll_choice_js() {  include_once 'modules/node/node.pages.inc';  $form_state = array('storage' => NULL, 'submitted' => FALSE);  $form_build_id = $_POST['form_build_id'];  // Get the form from the cache.  $form = form_get_cache($form_build_id, $form_state);  $args = $form['#parameters'];  $form_id = array_shift($args);  // We will run some of the submit handlers so we need to disable redirecting.  $form['#redirect'] = FALSE;  // We need to process the form, prepare for that by setting a few internals  // variables.  $form['#post'] = $_POST;  $form['#programmed'] = FALSE;  $form_state['post'] = $_POST;  // Build, validate and if possible, submit the form.  drupal_process_form($form_id, $form, $form_state);  // This call recreates the form relying solely on the form_state that the  // drupal_process_form set up.  $form = drupal_rebuild_form($form_id, $form_state, $args, $form_build_id);  // Render the new output.  $choice_form = $form['choice_wrapper']['choice'];  unset($choice_form['#prefix'], $choice_form['#suffix']); // Prevent duplicate wrappers.  $output = theme('status_messages') . drupal_render($choice_form);  drupal_json(array('status' => TRUE, 'data' => $output));}/** * Renumbers fields and creates a teaser when a poll node is submitted. */function poll_node_form_submit(&$form, &$form_state) {  // Renumber fields  $form_state['values']['choice'] = array_values($form_state['values']['choice']);  $form_state['values']['teaser'] = poll_teaser((object)$form_state['values']);}/** * Implementation of hook_validate(). */function poll_validate($node) {  if (isset($node->title)) {    // Check for at least two options and validate amount of votes:    $realchoices = 0;    // Renumber fields    $node->choice = array_values($node->choice);    foreach ($node->choice as $i => $choice) {      if ($choice['chtext'] != '') {        $realchoices++;      }      if (isset($choice['chvotes']) && $choice['chvotes'] < 0) {        form_set_error("choice][$i][chvotes", t('Negative values are not allowed.'));      }    }    if ($realchoices < 2) {      form_set_error("choice][$realchoices][chtext", t('You must fill in at least two choices.'));    }  }}/** * Implementation of hook_load(). */function poll_load($node) {  global $user;  $poll = db_fetch_object(db_query("SELECT runtime, active FROM {poll} WHERE nid = %d", $node->nid));  // Load the appropriate choices into the $poll object.  $result = db_query("SELECT chtext, chvotes, chorder FROM {poll_choices} WHERE nid = %d ORDER BY chorder", $node->nid);  while ($choice = db_fetch_array($result)) {    $poll->choice[$choice['chorder']] = $choice;  }  // Determine whether or not this user is allowed to vote.  $poll->allowvotes = FALSE;  if (user_access('vote on polls') && $poll->active) {    if ($user->uid) {      $result = db_fetch_object(db_query('SELECT chorder FROM {poll_votes} WHERE nid = %d AND uid = %d', $node->nid, $user->uid));    }    else {      $result = db_fetch_object(db_query("SELECT chorder FROM {poll_votes} WHERE nid = %d AND hostname = '%s'", $node->nid, ip_address()));    }    if (isset($result->chorder)) {      $poll->vote = $result->chorder;    }    else {      $poll->vote = -1;      $poll->allowvotes = TRUE;    }  }  return $poll;}/** * Implementation of hook_insert(). */function poll_insert($node) {  if (!user_access('administer nodes')) {    // Make sure all votes are 0 initially    foreach ($node->choice as $i => $choice) {      $node->choice[$i]['chvotes'] = 0;    }    $node->active = 1;  }  db_query("INSERT INTO {poll} (nid, runtime, active) VALUES (%d, %d, %d)", $node->nid, $node->runtime, $node->active);  $i = 0;  foreach ($node->choice as $choice) {    if ($choice['chtext'] != '') {      db_query("INSERT INTO {poll_choices} (nid, chtext, chvotes, chorder) VALUES (%d, '%s', %d, %d)", $node->nid, $choice['chtext'], $choice['chvotes'], $i++);    }  }}/** * Implementation of hook_update(). */function poll_update($node) {  // Update poll settings.  db_query('UPDATE {poll} SET runtime = %d, active = %d WHERE nid = %d', $node->runtime, $node->active, $node->nid);  // Clean poll choices.  db_query('DELETE FROM {poll_choices} WHERE nid = %d', $node->nid);  // Poll choices come in the same order with the same numbers as they are in  // the database, but some might have an empty title, which signifies that  // they should be removed. We remove all votes to the removed options, so  // people who voted on them can vote again.  $new_chorder = 0;  foreach ($node->choice as $old_chorder => $choice) {    $chvotes = isset($choice['chvotes']) ? (int)$choice['chvotes'] : 0;    $chtext = $choice['chtext'];    if (!empty($chtext)) {      db_query("INSERT INTO {poll_choices} (nid, chtext, chvotes, chorder) VALUES (%d, '%s', %d, %d)", $node->nid, $chtext, $chvotes, $new_chorder);      if ($new_chorder != $old_chorder) {        // We can only remove items in the middle, not add, so        // new_chorder is always <= old_chorder, making this safe.        db_query("UPDATE {poll_votes} SET chorder = %d WHERE nid = %d AND chorder = %d", $new_chorder, $node->nid, $old_chorder);      }      $new_chorder++;    }    else {      db_query("DELETE FROM {poll_votes} WHERE nid = %d AND chorder = %d", $node->nid, $old_chorder);    }  }}/** * Implementation of hook_delete(). */function poll_delete($node) {  db_query("DELETE FROM {poll} WHERE nid = %d", $node->nid);  db_query("DELETE FROM {poll_choices} WHERE nid = %d", $node->nid);  db_query("DELETE FROM {poll_votes} WHERE nid = %d", $node->nid);}/** * Implementation of hook_view(). * * @param $block *   An extra parameter that adapts the hook to display a block-ready *   rendering of the poll. */function poll_view($node, $teaser = FALSE, $page = FALSE, $block = FALSE) {  global $user;  $output = '';  // Special display for side-block  if ($block) {    // No 'read more' link    $node->readmore = FALSE;    $links = module_invoke_all('link', 'node', $node, 1);    $links[] = array('title' => t('Older polls'), 'href' => 'poll', 'attributes' => array('title' => t('View the list of polls on this site.')));    if ($node->allowvotes && $block) {      $links[] = array('title' => t('Results'), 'href' => 'node/'. $node->nid .'/results', 'attributes' => array('title' => t('View the current poll results.')));    }    $node->links = $links;  }  if (!empty($node->allowvotes) && ($block || empty($node->show_results))) {    $node->content['body'] = array(      '#value' => drupal_get_form('poll_view_voting', $node, $block),    );  }  else {    $node->content['body'] = array(      '#value' => poll_view_results($node, $teaser, $page, $block),    );  }  return $node;}/** * Creates a simple teaser that lists all the choices. * * This is primarily used for RSS. */function poll_teaser($node) {  $teaser = NULL;  if (is_array($node->choice)) {    foreach ($node->choice as $k => $choice) {      if ($choice['chtext'] != '') {        $teaser .= '* '. check_plain($choice['chtext']) ."\n";      }    }  }  return $teaser;}/** * Generates the voting form for a poll. * * @ingroup forms * @see poll_vote() * @see phptemplate_preprocess_poll_vote() */function poll_view_voting(&$form_state, $node, $block) {  if ($node->choice) {    $list = array();    foreach ($node->choice as $i => $choice) {      $list[$i] = check_plain($choice['chtext']);    }    $form['choice'] = array(      '#type' => 'radios',      '#default_value' => -1,      '#options' => $list,    );  }  $form['vote'] = array(    '#type' => 'submit',    '#value' => t('Vote'),    '#submit' => array('poll_vote'),  );  // Store the node so we can get to it in submit functions.  $form['#node'] = $node;  $form['#block'] = $block;  // Set form caching because we could have multiple of these forms on  // the same page, and we want to ensure the right one gets picked.  $form['#cache'] = TRUE;  // Provide a more cleanly named voting form theme.  $form['#theme'] = 'poll_vote';  return $form;}/** * Validation function for processing votes */function poll_view_voting_validate($form, &$form_state) {  if ($form_state['values']['choice'] == -1) {    form_set_error( 'choice', t('Your vote could not be recorded because you did not select any of the choices.'));  }}/** * Submit handler for processing a vote */function poll_vote($form, &$form_state) {  $node = $form['#node'];  $choice = $form_state['values']['choice'];  global $user;  if ($user->uid) {    db_query('INSERT INTO {poll_votes} (nid, chorder, uid) VALUES (%d, %d, %d)', $node->nid, $choice, $user->uid);  }  else {    db_query("INSERT INTO {poll_votes} (nid, chorder, hostname) VALUES (%d, %d, '%s')", $node->nid, $choice, ip_address());  }  // Add one to the votes.  db_query("UPDATE {poll_choices} SET chvotes = chvotes + 1 WHERE nid = %d AND chorder = %d", $node->nid, $choice);  cache_clear_all();  drupal_set_message(t('Your vote was recorded.'));  // Return the user to whatever page they voted from.}/** * Themes the voting form for a poll. * * Inputs: $form */function template_preprocess_poll_vote(&$variables) {  $form = $variables['form'];  $variables['choice'] = drupal_render($form['choice']);  $variables['title'] = check_plain($form['#node']->title);  $variables['vote'] = drupal_render($form['vote']);  $variables['rest'] = drupal_render($form);  $variables['block'] = $form['#block'];  // If this is a block, allow a different tpl.php to be used.  if ($variables['block']) {    $variables['template_files'][] = 'poll-vote-block';  }}/** * Generates a graphical representation of the results of a poll. */function poll_view_results(&$node, $teaser, $page, $block) {  // Count the votes and find the maximum  $total_votes = 0;  $max_votes = 0;  foreach ($node->choice as $choice) {    if (isset($choice['chvotes'])) {      $total_votes += $choice['chvotes'];      $max_votes = max($max_votes, $choice['chvotes']);    }  }  $poll_results = '';  foreach ($node->choice as $i => $choice) {    if (!empty($choice['chtext'])) {      $chvotes = isset($choice['chvotes']) ? $choice['chvotes'] : NULL;      $poll_results .= theme('poll_bar', $choice['chtext'], $chvotes, $total_votes, isset($node->vote) && $node->vote == $i, $block);    }  }  return theme('poll_results', $node->title, $poll_results, $total_votes, isset($node->links) ? $node->links : array(), $block, $node->nid, isset($node->vote) ? $node->vote : NULL);}/** * Theme the admin poll form for choices. * * @ingroup themeable */function theme_poll_choices($form) {  // Change the button title to reflect the behavior when using JavaScript.  drupal_add_js('if (Drupal.jsEnabled) { $(document).ready(function() { $("#edit-poll-more").val("'. t('Add another choice') .'"); }); }', 'inline');  $rows = array();  $headers = array(    t('Choice'),    t('Vote count'),  );  foreach (element_children($form) as $key) {    // No need to print the field title every time.    unset($form[$key]['chtext']['#title'], $form[$key]['chvotes']['#title']);    // Build the table row.    $row = array(      'data' => array(        array('data' => drupal_render($form[$key]['chtext']), 'class' => 'poll-chtext'),        array('data' => drupal_render($form[$key]['chvotes']), 'class' => 'poll-chvotes'),      ),    );    // Add additional attributes to the row, such as a class for this row.    if (isset($form[$key]['#attributes'])) {      $row = array_merge($row, $form[$key]['#attributes']);    }    $rows[] = $row;  }  $output = theme('table', $headers, $rows);  $output .= drupal_render($form);  return $output;}/** * Preprocess the poll_results theme hook. * * Inputs: $raw_title, $results, $votes, $raw_links, $block, $nid, $vote. The * $raw_* inputs to this are naturally unsafe; often safe versions are * made to simply overwrite the raw version, but in this case it seems likely * that the title and the links may be overridden by the theme layer, so they * are left in with a different name for that purpose. * * @see poll-results.tpl.php * @see poll-results-block.tpl.php * @see theme_poll_results() */function template_preprocess_poll_results(&$variables) {  $variables['links'] = theme('links', $variables['raw_links']);  if (isset($variables['vote']) && $variables['vote'] > -1 && user_access('cancel own vote')) {    $variables['cancel_form'] = drupal_get_form('poll_cancel_form', $variables['nid']);  }  $variables['title'] = check_plain($variables['raw_title']);  // If this is a block, allow a different tpl.php to be used.  if ($variables['block']) {    $variables['template_files'][] = 'poll-results-block';  }}/** * Preprocess the poll_bar theme hook. * * Inputs: $title, $votes, $total_votes, $voted, $block * * @see poll-bar.tpl.php * @see poll-bar-block.tpl.php * @see theme_poll_bar() */function template_preprocess_poll_bar(&$variables) {  if ($variables['block']) {    $variables['template_files'][] = 'poll-bar-block';  }  $variables['title'] = check_plain($variables['title']);  $variables['percentage'] = round($variables['votes'] * 100 / max($variables['total_votes'], 1));}/** * Builds the cancel form for a poll. * * @ingroup forms * @see poll_cancel() */function poll_cancel_form(&$form_state, $nid) {  // Store the nid so we can get to it in submit functions.  $form['#nid'] = $nid;  $form['submit'] = array(    '#type' => 'submit',    '#value' => t('Cancel your vote'),    '#submit' => array('poll_cancel')  );  $form['#cache'] = TRUE;  return $form;}/** * Submit callback for poll_cancel_form */function poll_cancel($form, &$form_state) {  $node = node_load($form['#nid']);  global $user;  if ($user->uid) {    db_query('DELETE FROM {poll_votes} WHERE nid = %d and uid = %d', $node->nid, $user->uid);  }  else {    db_query("DELETE FROM {poll_votes} WHERE nid = %d and hostname = '%s'", $node->nid, ip_address());  }  // Subtract from the votes.  db_query("UPDATE {poll_choices} SET chvotes = chvotes - 1 WHERE nid = %d AND chorder = %d", $node->nid, $node->vote);}/** * Implementation of hook_user(). */function poll_user($op, &$edit, &$user) {  if ($op == 'delete') {    db_query('UPDATE {poll_votes} SET uid = 0 WHERE uid = %d', $user->uid);  }}
<?php// $Id$/** * @file * User page callbacks for the book module. *//** * Menu callback; prints a listing of all books. */function book_render() {  $book_list = array();  foreach (book_get_books() as $book) {    $book_list[] = l($book['title'], $book['href'], $book['options']);  }  return theme('item_list', $book_list);}/** * Menu callback; Generates various representation of a book page and its children. * * The function delegates the generation of output to helper functions. * The function name is derived by prepending 'book_export_' to the * given output type. So, e.g., a type of 'html' results in a call to * the function book_export_html(). * * @param $type *   A string encoding the type of output requested. The following *   types are currently supported in book module: * *   - html: HTML (printer friendly output) * *   Other types may be supported in contributed modules. * @param $nid *   An integer representing the node id (nid) of the node to export * @return *   A string representing the node and its children in the book hierarchy *   in a format determined by the $type parameter. */function book_export($type, $nid) {  $type = drupal_strtolower($type);  $export_function = 'book_export_'. $type;  if (function_exists($export_function)) {    print call_user_func($export_function, $nid);  }  else {    drupal_set_message(t('Unknown export format.'));    drupal_not_found();  }}/** * This function is called by book_export() to generate HTML for export. * * The given node is /embedded to its absolute depth in a top level * section/. For example, a child node with depth 2 in the hierarchy * is contained in (otherwise empty) &lt;div&gt; elements * corresponding to depth 0 and depth 1. This is intended to support * WYSIWYG output - e.g., level 3 sections always look like level 3 * sections, no matter their depth relative to the node selected to be * exported as printer-friendly HTML. * * @param $nid *   An integer representing the node id (nid) of the node to export. * @return *   A string containing HTML representing the node and its children in *   the book hierarchy. */function book_export_html($nid) {  if (user_access('access printer-friendly version')) {    $export_data = array();    $node = node_load($nid);    if (isset($node->book)) {      $tree = book_menu_subtree_data($node->book);      $contents = book_export_traverse($tree, 'book_node_export');    }    return theme('book_export_html', $node->title, $contents, $node->book['depth']);  }  else {    drupal_access_denied();  }}/** * Menu callback; show the outline form for a single node. */function book_outline($node) {  drupal_set_title(check_plain($node->title));  return drupal_get_form('book_outline_form', $node);}/** * Build the form to handle all book outline operations via the outline tab. * * @see book_outline_form_submit() * @see book_remove_button_submit() * * @ingroup forms */function book_outline_form(&$form_state, $node) {  if (!isset($node->book)) {    // The node is not part of any book yet - set default options.    $node->book = _book_link_defaults($node->nid);  }  else {    $node->book['original_bid'] = $node->book['bid'];  }  // Find the depth limit for the parent select.  if (!isset($node->book['parent_depth_limit'])) {    $node->book['parent_depth_limit'] = _book_parent_depth_limit($node->book);  }  $form['#node'] = $node;  $form['#id'] = 'book-outline';  _book_add_form_elements($form, $node);  $form['book']['#collapsible'] = FALSE;  $form['update'] = array(    '#type' => 'submit',    '#value' => $node->book['original_bid'] ? t('Update book outline') : t('Add to book outline'),    '#weight' => 15,  );  $form['remove'] = array(    '#type' => 'submit',    '#value' => t('Remove from book outline'),    '#access' => $node->nid != $node->book['bid'] && $node->book['bid'],    '#weight' => 20,    '#submit' => array('book_remove_button_submit'),  );  return $form;}/** * Button submit function to redirect to removal confirm form. * * @see book_outline_form() */function book_remove_button_submit($form, &$form_state) {  $form_state['redirect'] = 'node/'. $form['#node']->nid .'/outline/remove';}/** * Handles book outline form submissions from the outline tab. * * @see book_outline_form() */function book_outline_form_submit($form, &$form_state) {  $node = $form['#node'];  $form_state['redirect'] = "node/". $node->nid;  $book_link = $form_state['values']['book'];  if (!$book_link['bid']) {    drupal_set_message(t('No changes were made'));    return;  }  $book_link['menu_name'] = book_menu_name($book_link['bid']);  $node->book = $book_link;  if (_book_update_outline($node)) {    if ($node->book['parent_mismatch']) {      // This will usually only happen when JS is disabled.      drupal_set_message(t('The post has been added to the selected book. You may now position it relative to other pages.'));      $form_state['redirect'] = "node/". $node->nid ."/outline";    }    else {      drupal_set_message(t('The book outline has been updated.'));    }  }  else {    drupal_set_message(t('There was an error adding the post to the book.'), 'error');  }}/** * Menu callback; builds a form to confirm removal of a node from the book. * * @see book_remove_form_submit() * * @ingroup forms */function book_remove_form(&$form_state, $node) {  $form['#node'] = $node;  $title = array('%title' => $node->title);  if ($node->book['has_children']) {    $description = t('%title has associated child pages, which will be relocated automatically to maintain their connection to the book. To recreate the hierarchy (as it was before removing this page), %title may be added again using the Outline tab, and each of its former child pages will need to be relocated manually.', $title);  }  else {    $description = t('%title may be added to hierarchy again using the Outline tab.', $title);  }  return confirm_form($form, t('Are you sure you want to remove %title from the book hierarchy?', $title), 'node/'. $node->nid, $description, t('Remove'));}/** * Confirm form submit function to remove a node from the book. * * @see book_remove_form() */function book_remove_form_submit($form, &$form_state) {  $node = $form['#node'];  if ($node->nid != $node->book['bid']) {    // Only allowed when this is not a book (top-level page).    menu_link_delete($node->book['mlid']);    db_query('DELETE FROM {book} WHERE nid = %d', $node->nid);    drupal_set_message(t('The post has been removed from the book.'));  }  $form_state['redirect'] = 'node/'. $node->nid;}/** * AJAX callback to replace the book parent select options. * * This function is called when the selected book is changed.  It updates the * cached form (either the node form or the book outline form) and returns * rendered output to be used to replace the select containing the possible * parent pages in the newly selected book. * * @param $build_id *   The form's build_id. * @param $bid *   A bid from from among those in the form's book select. * @return *   Prints the replacement HTML in JSON format. */function book_form_update() {  $bid = $_POST['book']['bid'];  if ($form = form_get_cache($_POST['form_build_id'], $form_state)) {    // Validate the bid.    if (isset($form['book']['bid']['#options'][$bid])) {      $book_link = $form['#node']->book;      $book_link['bid'] = $bid;      // Get the new options and update the cache.      $form['book']['plid'] = _book_parent_select($book_link);      form_set_cache($_POST['form_build_id'], $form, $form_state);      // Build and render the new select element, then return it in JSON format.      $form_state = array();      $form['#post'] = array();      $form = form_builder($form['form_id']['#value'] , $form, $form_state);      $output = drupal_render($form['book']['plid']);      drupal_json(array('status' => TRUE, 'data' => $output));    }    else {      drupal_json(array('status' => FALSE, 'data' => ''));    }  }  else {    drupal_json(array('status' => FALSE, 'data' => ''));  }  exit();}
<?php// $Id$/** * @file * Functions to aid in presenting database results as a set of pages. *//** * Perform a paged database query. * * Use this function when doing select queries you wish to be able to page. The * pager uses LIMIT-based queries to fetch only the records required to render a * certain page. However, it has to learn the total number of records returned * by the query to compute the number of pages (the number of records / records * per page). This is done by inserting "COUNT(*)" in the original query. For * example, the query "SELECT nid, type FROM node WHERE status = '1' ORDER BY * sticky DESC, created DESC" would be rewritten to read "SELECT COUNT(*) FROM * node WHERE status = '1' ORDER BY sticky DESC, created DESC". Rewriting the * query is accomplished using a regular expression. * * Unfortunately, the rewrite rule does not always work as intended for queries * that already have a "COUNT(*)" or a "GROUP BY" clause, and possibly for * other complex queries. In those cases, you can optionally pass a query that * will be used to count the records. * * For example, if you want to page the query "SELECT COUNT(*), TYPE FROM node * GROUP BY TYPE", pager_query() would invoke the incorrect query "SELECT * COUNT(*) FROM node GROUP BY TYPE". So instead, you should pass "SELECT * COUNT(DISTINCT(TYPE)) FROM node" as the optional $count_query parameter. * * @param $query *   The SQL query that needs paging. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $count_query *   An SQL query used to count matching records. * @param ... *   A variable number of arguments which are substituted into the query (and *   the count query) using printf() syntax. Instead of a variable number of *   query arguments, you may also pass a single array containing the query *   arguments. * @return *   A database query result resource, or FALSE if the query was not executed *   correctly. * * @ingroup database */function pager_query($query, $limit = 10, $element = 0, $count_query = NULL) {  global $pager_page_array, $pager_total, $pager_total_items;  $page = isset($_GET['page']) ? $_GET['page'] : '';  // Substitute in query arguments.  $args = func_get_args();  $args = array_slice($args, 4);  // Alternative syntax for '...'  if (isset($args[0]) && is_array($args[0])) {    $args = $args[0];  }  // Construct a count query if none was given.  if (!isset($count_query)) {    $count_query = preg_replace(array('/SELECT.*?FROM /As', '/ORDER BY .*/'), array('SELECT COUNT(*) FROM ', ''), $query);  }  // Convert comma-separated $page to an array, used by other functions.  $pager_page_array = explode(',', $page);  // We calculate the total of pages as ceil(items / limit).  $pager_total_items[$element] = db_result(db_query($count_query, $args));  $pager_total[$element] = ceil($pager_total_items[$element] / $limit);  $pager_page_array[$element] = max(0, min((int)$pager_page_array[$element], ((int)$pager_total[$element]) - 1));  return db_query_range($query, $args, $pager_page_array[$element] * $limit, $limit);}/** * Compose a query string to append to pager requests. * * @return *   A query string that consists of all components of the current page request *   except for those pertaining to paging. */function pager_get_querystring() {  static $string = NULL;  if (!isset($string)) {    $string = drupal_query_string_encode($_REQUEST, array_merge(array('q', 'page', 'pass'), array_keys($_COOKIE)));  }  return $string;}/** * Format a query pager. * * Menu callbacks that display paged query results should call theme('pager') to * retrieve a pager control so that users can view other results. * Format a list of nearby pages with additional query results. * * @param $tags *   An array of labels for the controls in the pager. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @param $quantity *   The number of pages in the list. * @return *   An HTML string that generates the query pager. * * @ingroup themeable */function theme_pager($tags = array(), $limit = 10, $element = 0, $parameters = array(), $quantity = 9) {  global $pager_page_array, $pager_total;  // Calculate various markers within this pager piece:  // Middle is used to "center" pages around the current page.  $pager_middle = ceil($quantity / 2);  // current is the page we are currently paged to  $pager_current = $pager_page_array[$element] + 1;  // first is the first page listed by this pager piece (re quantity)  $pager_first = $pager_current - $pager_middle + 1;  // last is the last page listed by this pager piece (re quantity)  $pager_last = $pager_current + $quantity - $pager_middle;  // max is the maximum page number  $pager_max = $pager_total[$element];  // End of marker calculations.  // Prepare for generation loop.  $i = $pager_first;  if ($pager_last > $pager_max) {    // Adjust "center" if at end of query.    $i = $i + ($pager_max - $pager_last);    $pager_last = $pager_max;  }  if ($i <= 0) {    // Adjust "center" if at start of query.    $pager_last = $pager_last + (1 - $i);    $i = 1;  }  // End of generation loop preparation.  $li_first = theme('pager_first', (isset($tags[0]) ? $tags[0] : t(' first')), $limit, $element, $parameters);  $li_previous = theme('pager_previous', (isset($tags[1]) ? $tags[1] : t(' previous')), $limit, $element, 1, $parameters);  $li_next = theme('pager_next', (isset($tags[3]) ? $tags[3] : t('next ')), $limit, $element, 1, $parameters);  $li_last = theme('pager_last', (isset($tags[4]) ? $tags[4] : t('last ')), $limit, $element, $parameters);  if ($pager_total[$element] > 1) {    if ($li_first) {      $items[] = array(        'class' => 'pager-first',        'data' => $li_first,      );    }    if ($li_previous) {      $items[] = array(        'class' => 'pager-previous',        'data' => $li_previous,      );    }    // When there is more than one page, create the pager list.    if ($i != $pager_max) {      if ($i > 1) {        $items[] = array(          'class' => 'pager-ellipsis',          'data' => '',        );      }      // Now generate the actual pager piece.      for (; $i <= $pager_last && $i <= $pager_max; $i++) {        if ($i < $pager_current) {          $items[] = array(            'class' => 'pager-item',            'data' => theme('pager_previous', $i, $limit, $element, ($pager_current - $i), $parameters),          );        }        if ($i == $pager_current) {          $items[] = array(            'class' => 'pager-current',            'data' => $i,          );        }        if ($i > $pager_current) {          $items[] = array(            'class' => 'pager-item',            'data' => theme('pager_next', $i, $limit, $element, ($i - $pager_current), $parameters),          );        }      }      if ($i < $pager_max) {        $items[] = array(          'class' => 'pager-ellipsis',          'data' => '',        );      }    }    // End generation.    if ($li_next) {      $items[] = array(        'class' => 'pager-next',        'data' => $li_next,      );    }    if ($li_last) {      $items[] = array(        'class' => 'pager-last',        'data' => $li_last,      );    }    return theme('item_list', $items, NULL, 'ul', array('class' => 'pager'));  }}/** * @name Pager pieces * @{ * Use these pieces to construct your own custom pagers in your theme. Note that * you should NOT modify this file to customize your pager. *//** * Format a "first page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_first($text, $limit, $element = 0, $parameters = array()) {  global $pager_page_array;  $output = '';  // If we are anywhere but the first page  if ($pager_page_array[$element] > 0) {    $output = theme('pager_link', $text, pager_load_array(0, $element, $pager_page_array), $element, $parameters);  }  return $output;}/** * Format a "previous page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $interval *   The number of pages to move backward when the link is clicked. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_previous($text, $limit, $element = 0, $interval = 1, $parameters = array()) {  global $pager_page_array;  $output = '';  // If we are anywhere but the first page  if ($pager_page_array[$element] > 0) {    $page_new = pager_load_array($pager_page_array[$element] - $interval, $element, $pager_page_array);    // If the previous page is the first page, mark the link as such.    if ($page_new[$element] == 0) {      $output = theme('pager_first', $text, $limit, $element, $parameters);    }    // The previous page is not the first page.    else {      $output = theme('pager_link', $text, $page_new, $element, $parameters);    }  }  return $output;}/** * Format a "next page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $interval *   The number of pages to move forward when the link is clicked. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_next($text, $limit, $element = 0, $interval = 1, $parameters = array()) {  global $pager_page_array, $pager_total;  $output = '';  // If we are anywhere but the last page  if ($pager_page_array[$element] < ($pager_total[$element] - 1)) {    $page_new = pager_load_array($pager_page_array[$element] + $interval, $element, $pager_page_array);    // If the next page is the last page, mark the link as such.    if ($page_new[$element] == ($pager_total[$element] - 1)) {      $output = theme('pager_last', $text, $limit, $element, $parameters);    }    // The next page is not the last page.    else {      $output = theme('pager_link', $text, $page_new, $element, $parameters);    }  }  return $output;}/** * Format a "last page" link. * * @param $text *   The name (or image) of the link. * @param $limit *   The number of query results to display per page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager links. * @return *   An HTML string that generates this piece of the query pager. * * @ingroup themeable */function theme_pager_last($text, $limit, $element = 0, $parameters = array()) {  global $pager_page_array, $pager_total;  $output = '';  // If we are anywhere but the last page  if ($pager_page_array[$element] < ($pager_total[$element] - 1)) {    $output = theme('pager_link', $text, pager_load_array($pager_total[$element] - 1, $element, $pager_page_array), $element, $parameters);  }  return $output;}/** * Format a link to a specific query result page. * * @param $page_new *   The first result to display on the linked page. * @param $element *   An optional integer to distinguish between multiple pagers on one page. * @param $parameters *   An associative array of query string parameters to append to the pager link. * @param $attributes *   An associative array of HTML attributes to apply to a pager anchor tag. * @return *   An HTML string that generates the link. * * @ingroup themeable */function theme_pager_link($text, $page_new, $element, $parameters = array(), $attributes = array()) {  $page = isset($_GET['page']) ? $_GET['page'] : '';  if ($new_page = implode(',', pager_load_array($page_new[$element], $element, explode(',', $page)))) {    $parameters['page'] = $new_page;  }  $query = array();  if (count($parameters)) {    $query[] = drupal_query_string_encode($parameters, array());  }  $querystring = pager_get_querystring();  if ($querystring != '') {    $query[] = $querystring;  }  // Set each pager link title  if (!isset($attributes['title'])) {    static $titles = NULL;    if (!isset($titles)) {      $titles = array(        t(' first') => t('Go to first page'),        t(' previous') => t('Go to previous page'),        t('next ') => t('Go to next page'),        t('last ') => t('Go to last page'),      );    }    if (isset($titles[$text])) {      $attributes['title'] = $titles[$text];    }    else if (is_numeric($text)) {      $attributes['title'] = t('Go to page @number', array('@number' => $text));    }  }  return l($text, $_GET['q'], array('attributes' => $attributes, 'query' => count($query) ? implode('&', $query) : NULL));}/** * @} End of "Pager pieces". *//** * Helper function * * Copies $old_array to $new_array and sets $new_array[$element] = $value * Fills in $new_array[0 .. $element - 1] = 0 */function pager_load_array($value, $element, $old_array) {  $new_array = $old_array;  // Look for empty elements.  for ($i = 0; $i < $element; $i++) {    if (!$new_array[$i]) {      // Load found empty element with 0.      $new_array[$i] = 0;    }  }  // Update the changed element.  $new_array[$element] = (int)$value;  return $new_array;}
<?php// $Id$/** * @file node.tpl.php * * Theme implementation to display a node. * * Available variables: * - $title: the (sanitized) title of the node. * - $content: Node body or teaser depending on $teaser flag. * - $picture: The authors picture of the node output from *   theme_user_picture(). * - $date: Formatted creation date (use $created to reformat with *   format_date()). * - $links: Themed links like "Read more", "Add new comment", etc. output *   from theme_links(). * - $name: Themed username of node author output from theme_username(). * - $node_url: Direct url of the current node. * - $terms: the themed list of taxonomy term links output from theme_links(). * - $submitted: themed submission information output from *   theme_node_submitted(). * * Other variables: * - $node: Full node object. Contains data that may not be safe. * - $type: Node type, i.e. story, page, blog, etc. * - $comment_count: Number of comments attached to the node. * - $uid: User ID of the node author. * - $created: Time the node was published formatted in Unix timestamp. * - $zebra: Outputs either "even" or "odd". Useful for zebra striping in *   teaser listings. * - $id: Position of the node. Increments each time it's output. * * Node status variables: * - $teaser: Flag for the teaser state. * - $page: Flag for the full page state. * - $promote: Flag for front page promotion state. * - $sticky: Flags for sticky post setting. * - $status: Flag for published status. * - $comment: State of comment settings for the node. * - $readmore: Flags true if the teaser content of the node cannot hold the *   main body content. * - $is_front: Flags true when presented in the front page. * - $logged_in: Flags true when the current user is a logged-in member. * - $is_admin: Flags true when the current user is an administrator. * * @see template_preprocess() * @see template_preprocess_node() */?><div id="node-<?php print $node->nid; ?>" class="node<?php if ($sticky) { print ' sticky'; } ?><?php if (!$status) { print ' node-unpublished'; } ?> clear-block"><?php print $picture ?><?php if (!$page): ?>  <h2><a href="<?php print $node_url ?>" title="<?php print $title ?>"><?php print $title ?></a></h2><?php endif; ?>  <div class="meta">  <?php if ($submitted): ?>    <span class="submitted"><?php print $submitted ?></span>  <?php endif; ?>  <?php if ($terms): ?>    <div class="terms terms-inline"><?php print $terms ?></div>  <?php endif;?>  </div>  <div class="content">    <?php print $content ?>  </div>  <?php print $links; ?></div>
<?php// $Id$/** * @file forum-icon.tpl.php * Display an appropriate icon for a forum post. * * Available variables: * - $new_posts: Indicates whether or not the topic contains new posts. * - $icon: The icon to display. May be one of 'hot', 'hot-new', 'new', *   'default', 'closed', or 'sticky'. * * @see template_preprocess_forum_icon() * @see theme_forum_icon() */?><?php if ($new_posts): ?>  <a name="new"><?php endif; ?><?php print theme('image', "misc/forum-$icon.png") ?><?php if ($new_posts): ?>  </a><?php endif; ?>
<?php// $Id$/** * @file * Enable threaded discussions about general topics. *//** * Implementation of hook_help(). */function forum_help($path, $arg) {  switch ($path) {    case 'admin/help#forum':      $output = '<p>'. t('The forum module lets you create threaded discussion forums with functionality similar to other message board systems. Forums are useful because they allow community members to discuss topics with one another while ensuring those conversations are archived for later reference. The <a href="@create-topic">forum topic</a> menu item (under <em>Create content</em> on the Navigation menu) creates the initial post of a new threaded discussion, or thread.', array('@create-topic' => url('node/add/forum'))) .'</p>';      $output .= '<p>'. t('A threaded discussion occurs as people leave comments on a forum topic (or on other comments within that topic). A forum topic is contained within a forum, which may hold many similar or related forum topics. Forums are (optionally) nested within a container, which may hold many similar or related forums. Both containers and forums may be nested within other containers and forums, and provide structure for your message board. By carefully planning this structure, you make it easier for users to find and comment on a specific forum topic.') .'</p>';      $output .= '<p>'. t('When administering a forum, note that:') .'</p>';      $output .= '<ul><li>'. t('a forum topic (and all of its comments) may be moved between forums by selecting a different forum while editing a forum topic.') .'</li>';      $output .= '<li>'. t('when moving a forum topic between forums, the <em>Leave shadow copy</em> option creates a link in the original forum pointing to the new location.') .'</li>';      $output .= '<li>'. t('selecting <em>Read only</em> under <em>Comment settings</em> while editing a forum topic will lock (prevent new comments) on the thread.') .'</li>';      $output .= '<li>'. t('selecting <em>Disabled</em> under <em>Comment settings</em> while editing a forum topic will hide all existing comments on the thread, and prevent new ones.') .'</li></ul>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@forum">Forum module</a>.', array('@forum' => 'http://drupal.org/handbook/modules/forum/')) .'</p>';      return $output;    case 'admin/content/forum':      return '<p>'. t('This page displays a list of existing forums and containers. Containers (optionally) hold forums, and forums hold forum topics (a forum topic is the initial post to a threaded discussion). To provide structure, both containers and forums may be placed inside other containers and forums. To rearrange forums and containers, grab a drag-and-drop handle under the <em>Name</em> column and drag the forum or container to a new location in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save</em> button at the bottom of the page.') .'</p>';    case 'admin/content/forum/add/container':      return '<p>'. t('By grouping related or similar forums, containers help organize forums. For example, a container named "Food" may hold two forums named "Fruit" and "Vegetables", respectively.') .'</p>';    case 'admin/content/forum/add/forum':      return '<p>'. t('A forum holds related or similar forum topics (a forum topic is the initial post to a threaded discussion). For example, a forum named "Fruit" may contain forum topics titled "Apples" and "Bananas", respectively.') .'</p>';    case 'admin/content/forum/settings':      return '<p>'. t('These settings allow you to adjust the display of your forum topics. The content types available for use within a forum may be selected by editing the <em>Content types</em> on the <a href="@forum-vocabulary">forum vocabulary page</a>.', array('@forum-vocabulary' => url('admin/content/taxonomy/edit/vocabulary/'. variable_get('forum_nav_vocabulary', '')))) .'</p>';  }}/** * Implementation of hook_theme() */function forum_theme() {  return array(    'forums' => array(      'template' => 'forums',      'arguments' => array('forums' => NULL, 'topics' => NULL, 'parents' => NULL, 'tid' => NULL, 'sortby' => NULL, 'forum_per_page' => NULL),    ),    'forum_list' => array(      'template' => 'forum-list',      'arguments' => array('forums' => NULL, 'parents' => NULL, 'tid' => NULL),    ),    'forum_topic_list' => array(      'template' => 'forum-topic-list',      'arguments' => array('tid' => NULL, 'topics' => NULL, 'sortby' => NULL, 'forum_per_page' => NULL),    ),    'forum_icon' => array(      'template' => 'forum-icon',      'arguments' => array('new_posts' => NULL, 'num_posts' => 0, 'comment_mode' => 0, 'sticky' => 0),    ),    'forum_topic_navigation' => array(      'template' => 'forum-topic-navigation',      'arguments' => array('node' => NULL),    ),    'forum_submitted' => array(      'template' => 'forum-submitted',      'arguments' => array('topic' => NULL),    ),  );}/** * Fetch a forum term. * * @param $tid *   The ID of the term which should be loaded. * * @return *   An associative array containing the term data or FALSE if the term cannot be loaded, or is not part of the forum vocabulary. */function forum_term_load($tid) {  $result = db_query(db_rewrite_sql('SELECT t.tid, t.vid, t.name, t.description, t.weight FROM {term_data} t WHERE t.tid = %d AND t.vid = %d', 't', 'tid'), $tid, variable_get('forum_nav_vocabulary', ''));  return db_fetch_array($result);}/** * Implementation of hook_menu(). */function forum_menu() {  $items['forum'] = array(    'title' => 'Forums',    'page callback' => 'forum_page',    'access arguments' => array('access content'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'forum.pages.inc',  );  $items['admin/content/forum'] = array(    'title' => 'Forums',    'description' => 'Control forums and their hierarchy and change forum settings.',    'page callback' => 'drupal_get_form',    'page arguments' => array('forum_overview'),    'access arguments' => array('administer forums'),    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => -10,  );  $items['admin/content/forum/add/container'] = array(    'title' => 'Add container',    'page callback' => 'forum_form_main',    'page arguments' => array('container'),    'access arguments' => array('administer forums'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/add/forum'] = array(    'title' => 'Add forum',    'page callback' => 'forum_form_main',    'page arguments' => array('forum'),    'access arguments' => array('administer forums'),    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('forum_admin_settings'),    'access arguments' => array('administer forums'),    'weight' => 5,    'type' => MENU_LOCAL_TASK,    'parent' => 'admin/content/forum',    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/%forum_term'] = array(    'page callback' => 'forum_form_main',    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/container/%forum_term'] = array(    'title' => 'Edit container',    'page callback' => 'forum_form_main',    'page arguments' => array('container', 5),    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  $items['admin/content/forum/edit/forum/%forum_term'] = array(    'title' => 'Edit forum',    'page callback' => 'forum_form_main',    'page arguments' => array('forum', 5),    'access arguments' => array('administer forums'),    'type' => MENU_CALLBACK,    'file' => 'forum.admin.inc',  );  return $items;}/** * Implementation of hook_init(). */function forum_init() {  drupal_add_css(drupal_get_path('module', 'forum') .'/forum.css');}/** * Implementation of hook_nodeapi(). */function forum_nodeapi(&$node, $op, $teaser, $page) {  // We are going to return if $node->type is not one of the node  // types assigned to the forum vocabulary.  If forum_nav_vocabulary  // is undefined or the vocabulary does not exist, it clearly cannot  // be assigned to $node->type, so return to avoid E_ALL warnings.  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  if (empty($vocabulary)) {    return;  }  // Operate only on node types assigned for the forum vocabulary.  if (!in_array($node->type, $vocabulary->nodes)) {    return;  }  switch ($op) {    case 'view':      if ($page && taxonomy_node_get_terms_by_vocabulary($node, $vid) && $tree = taxonomy_get_tree($vid)) {        // Get the forum terms from the (cached) tree        foreach ($tree as $term) {          $forum_terms[] = $term->tid;        }        foreach ($node->taxonomy as $term_id => $term) {          if (in_array($term_id, $forum_terms)) {            $node->tid = $term_id;          }        }        // Breadcrumb navigation        $breadcrumb[] = l(t('Home'), NULL);        $breadcrumb[] = l($vocabulary->name, 'forum');        if ($parents = taxonomy_get_parents_all($node->tid)) {          $parents = array_reverse($parents);          foreach ($parents as $p) {            $breadcrumb[] = l($p->name, 'forum/'. $p->tid);          }        }        drupal_set_breadcrumb($breadcrumb);        if (!$teaser) {          $node->content['forum_navigation'] = array(            '#value' => theme('forum_topic_navigation', $node),            '#weight' => 100,          );        }      }      break;    case 'prepare':      if (empty($node->nid)) {        // New topic        $node->taxonomy[arg(3)]->vid = $vid;        $node->taxonomy[arg(3)]->tid = arg(3);      }      break;    // Check in particular that only a "leaf" term in the associated taxonomy    // vocabulary is selected, not a "container" term.    case 'validate':      if ($node->taxonomy) {        // Extract the node's proper topic ID.        $vocabulary = $vid;        $containers = variable_get('forum_containers', array());        foreach ($node->taxonomy as $term) {          if (db_result(db_query('SELECT COUNT(*) FROM {term_data} WHERE tid = %d AND vid = %d', $term, $vocabulary))) {            if (in_array($term, $containers)) {              $term = taxonomy_get_term($term);              form_set_error('taxonomy', t('The item %forum is only a container for forums. Please select one of the forums below it.', array('%forum' => $term->name)));            }          }        }      }      break;    // Assign forum taxonomy when adding a topic from within a forum.    case 'presave':      // Make sure all fields are set properly:      $node->icon = !empty($node->icon) ? $node->icon : '';      if ($node->taxonomy && $tree = taxonomy_get_tree($vid)) {        // Get the forum terms from the (cached) tree if we have a taxonomy.        foreach ($tree as $term) {          $forum_terms[] = $term->tid;        }        foreach ($node->taxonomy as $term_id) {          if (in_array($term_id, $forum_terms)) {            $node->tid = $term_id;          }        }        $old_tid = db_result(db_query_range("SELECT t.tid FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid WHERE n.nid = %d ORDER BY t.vid DESC", $node->nid, 0, 1));        if ($old_tid && isset($node->tid) && ($node->tid != $old_tid) && !empty($node->shadow)) {          // A shadow copy needs to be created. Retain new term and add old term.          $node->taxonomy[] = $old_tid;        }      }      break;    case 'update':      if (empty($node->revision) && db_result(db_query('SELECT tid FROM {forum} WHERE nid=%d', $node->nid))) {        if (!empty($node->tid)) {          db_query('UPDATE {forum} SET tid = %d WHERE vid = %d', $node->tid, $node->vid);        }        // The node is removed from the forum.        else {          db_query('DELETE FROM {forum} WHERE nid = %d', $node->nid);        }        break;      }      // Deliberate no break -- for new revisions and for previously unassigned terms we need an insert.    case 'insert':      if (!empty($node->tid)) {        db_query('INSERT INTO {forum} (tid, vid, nid) VALUES (%d, %d, %d)', $node->tid, $node->vid, $node->nid);      }      break;    case 'delete':      db_query('DELETE FROM {forum} WHERE nid = %d', $node->nid);      break;    case 'load':      return db_fetch_array(db_query('SELECT tid AS forum_tid FROM {forum} WHERE vid = %d', $node->vid));  }  return;}/** * Implementation of hook_node_info(). */function forum_node_info() {  return array(    'forum' => array(      'name' => t('Forum topic'),      'module' => 'forum',      'description' => t('A <em>forum topic</em> is the initial post to a new discussion thread within a forum.'),      'title_label' => t('Subject'),    )  );}/** * Implementation of hook_access(). */function forum_access($op, $node, $account) {  switch ($op) {    case 'create':      return user_access('create forum topics', $account) ? TRUE : NULL;    case 'update':      return user_access('edit any forum topic', $account) || (user_access('edit own forum topics', $account) && ($account->uid == $node->uid)) ? TRUE : NULL;    case 'delete':      return user_access('delete any forum topic', $account) || (user_access('delete own forum topics', $account) && ($account->uid == $node->uid)) ? TRUE : NULL;  }}/** * Implementation of hook_perm(). */function forum_perm() {  return array('create forum topics', 'delete own forum topics', 'delete any forum topic', 'edit own forum topics', 'edit any forum topic', 'administer forums');}/** * Implementation of hook_taxonomy(). */function forum_taxonomy($op, $type, $term = NULL) {  if ($op == 'delete' && $term['vid'] == variable_get('forum_nav_vocabulary', '')) {    switch ($type) {      case 'term':        $results = db_query('SELECT tn.nid FROM {term_node} tn WHERE tn.tid = %d', $term['tid']);        while ($node = db_fetch_object($results)) {          // node_delete will also remove any association with non-forum vocabularies.          node_delete($node->nid);        }        // For containers, remove the tid from the forum_containers variable.        $containers = variable_get('forum_containers', array());        $key = array_search($term['tid'], $containers);        if ($key !== FALSE) {          unset($containers[$key]);        }        variable_set('forum_containers', $containers);        break;      case 'vocabulary':        variable_del('forum_nav_vocabulary');    }  }}/** * Implementation of hook_form_alter(). */function forum_form_alter(&$form, $form_state, $form_id) {  $vid = variable_get('forum_nav_vocabulary', '');  if (isset($form['vid']) && $form['vid']['#value'] == $vid) {    // Hide critical options from forum vocabulary.    if ($form_id == 'taxonomy_form_vocabulary') {      $form['help_forum_vocab'] = array(        '#value' => t('This is the designated forum vocabulary. Some of the normal vocabulary options have been removed.'),        '#weight' => -1,      );      $form['content_types']['nodes']['#required'] = TRUE;      $form['hierarchy'] = array('#type' => 'value', '#value' => 1);      $form['settings']['required'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['relations'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['tags'] = array('#type' => 'value', '#value' => FALSE);      $form['settings']['multiple'] = array('#type' => 'value', '#value' => FALSE);      unset($form['delete']);    }    // Hide multiple parents select from forum terms.    elseif ($form_id == 'taxonomy_form_term') {      $form['advanced']['parent']['#access'] = FALSE;    }  }  if ($form_id == 'forum_node_form') {    // Make the vocabulary required for 'real' forum-nodes.    $vid = variable_get('forum_nav_vocabulary', '');    $form['taxonomy'][$vid]['#required'] = TRUE;    $form['taxonomy'][$vid]['#options'][''] = t('- Please choose -');  }}/** * Implementation of hook_load(). */function forum_load($node) {  $forum = db_fetch_object(db_query('SELECT * FROM {forum} WHERE vid = %d', $node->vid));  return $forum;}/** * Implementation of hook_block(). * * Generates a block containing the currently active forum topics and the * most recently added forum topics. */function forum_block($op = 'list', $delta = 0, $edit = array()) {  switch ($op) {    case 'list':      $blocks[0]['info'] = t('Active forum topics');      $blocks[1]['info'] = t('New forum topics');      return $blocks;    case 'configure':      $form['forum_block_num_'. $delta] = array('#type' => 'select', '#title' => t('Number of topics'), '#default_value' => variable_get('forum_block_num_'. $delta, '5'), '#options' => drupal_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)));      return $form;    case 'save':      variable_set('forum_block_num_'. $delta, $edit['forum_block_num_'. $delta]);      break;    case 'view':      if (user_access('access content')) {        switch ($delta) {          case 0:            $title = t('Active forum topics');            $sql = db_rewrite_sql("SELECT n.nid, n.title, l.comment_count, l.last_comment_timestamp FROM {node} n INNER JOIN {term_node} tn ON tn.vid = n.vid INNER JOIN {term_data} td ON td.tid = tn.tid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 AND td.vid = %d ORDER BY l.last_comment_timestamp DESC");            $result = db_query_range($sql, variable_get('forum_nav_vocabulary', ''), 0, variable_get('forum_block_num_0', '5'));            $content = node_title_list($result);            break;          case 1:            $title = t('New forum topics');            $sql = db_rewrite_sql("SELECT n.nid, n.title, l.comment_count FROM {node} n INNER JOIN {term_node} tn ON tn.vid = n.vid INNER JOIN {term_data} td ON td.tid = tn.tid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 AND td.vid = %d ORDER BY n.nid DESC");            $result = db_query_range($sql, variable_get('forum_nav_vocabulary', ''), 0, variable_get('forum_block_num_1', '5'));            $content = node_title_list($result);            break;        }        if (!empty($content)) {          $block['subject'] = $title;          $block['content'] = $content . theme('more_link', url('forum'), t('Read the latest forum topics.'));          return $block;        }      }  }}/** * Implementation of hook_form(). */function forum_form(&$node, $form_state) {  $type = node_get_types('type', $node);  $form['title'] = array('#type' => 'textfield', '#title' => check_plain($type->title_label), '#default_value' => !empty($node->title) ? $node->title : '', '#required' => TRUE, '#weight' => -5);  if (!empty($node->nid)) {    $vid = variable_get('forum_nav_vocabulary', '');    $forum_terms = taxonomy_node_get_terms_by_vocabulary($node, $vid);    // if editing, give option to leave shadows    $shadow = (count($forum_terms) > 1);    $form['shadow'] = array('#type' => 'checkbox', '#title' => t('Leave shadow copy'), '#default_value' => $shadow, '#description' => t('If you move this topic, you can leave a link in the old forum to the new forum.'));  }  $form['body_field'] = node_body_field($node, $type->body_label, 1);  $form['#submit'][] = 'forum_submit';  // Assign the forum topic submit handler.  return $form;}/** * Implementation of hook_term_path(). */function forum_term_path($term) {  return 'forum/'. $term->tid;}/** * Returns a list of all forums for a given taxonomy id * * Forum objects contain the following fields * -num_topics Number of topics in the forum * -num_posts Total number of posts in all topics * -last_post Most recent post for the forum * * @param $tid *   Taxonomy ID of the vocabulary that holds the forum list. * @return *   Array of object containing the forum information. */function forum_get_forums($tid = 0) {  $forums = array();  $vid = variable_get('forum_nav_vocabulary', '');  $_forums = taxonomy_get_tree($vid, $tid);  if (count($_forums)) {    $counts = array();    $sql = "SELECT r.tid, COUNT(n.nid) AS topic_count, SUM(l.comment_count) AS comment_count FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {term_node} r ON n.vid = r.vid WHERE n.status = 1 GROUP BY r.tid";    $sql = db_rewrite_sql($sql);    $_counts = db_query($sql);    while ($count = db_fetch_object($_counts)) {      $counts[$count->tid] = $count;    }  }  foreach ($_forums as $forum) {    if (in_array($forum->tid, variable_get('forum_containers', array()))) {      $forum->container = 1;    }    if (!empty($counts[$forum->tid])) {      $forum->num_topics = $counts[$forum->tid]->topic_count;      $forum->num_posts = $counts[$forum->tid]->topic_count + $counts[$forum->tid]->comment_count;    }    else {      $forum->num_topics = 0;      $forum->num_posts = 0;    }    // This query does not use full ANSI syntax since MySQL 3.x does not support    // table1 INNER JOIN table2 INNER JOIN table3 ON table2_criteria ON table3_criteria    // used to join node_comment_statistics to users.    $sql = "SELECT ncs.last_comment_timestamp, IF (ncs.last_comment_uid != 0, u2.name, ncs.last_comment_name) AS last_comment_name, ncs.last_comment_uid FROM {node} n INNER JOIN {users} u1 ON n.uid = u1.uid INNER JOIN {term_node} tn ON n.vid = tn.vid INNER JOIN {node_comment_statistics} ncs ON n.nid = ncs.nid INNER JOIN {users} u2 ON ncs.last_comment_uid=u2.uid WHERE n.status = 1 AND tn.tid = %d ORDER BY ncs.last_comment_timestamp DESC";    $sql = db_rewrite_sql($sql);    $topic = db_fetch_object(db_query_range($sql, $forum->tid, 0, 1));    $last_post = new stdClass();    if (!empty($topic->last_comment_timestamp)) {      $last_post->timestamp = $topic->last_comment_timestamp;      $last_post->name = $topic->last_comment_name;      $last_post->uid = $topic->last_comment_uid;    }    $forum->last_post = $last_post;    $forums[$forum->tid] = $forum;  }  return $forums;}/** * Calculate the number of nodes the user has not yet read and are newer * than NODE_NEW_LIMIT. */function _forum_topics_unread($term, $uid) {  $sql = "SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} tn ON n.vid = tn.vid AND tn.tid = %d LEFT JOIN {history} h ON n.nid = h.nid AND h.uid = %d WHERE n.status = 1 AND n.created > %d AND h.nid IS NULL";  $sql = db_rewrite_sql($sql);  return db_result(db_query($sql, $term, $uid, NODE_NEW_LIMIT));}function forum_get_topics($tid, $sortby, $forum_per_page) {  global $user, $forum_topic_list_header;  $forum_topic_list_header = array(    NULL,    array('data' => t('Topic'), 'field' => 'n.title'),    array('data' => t('Replies'), 'field' => 'l.comment_count'),    array('data' => t('Created'), 'field' => 'n.created'),    array('data' => t('Last reply'), 'field' => 'l.last_comment_timestamp'),  );  $order = _forum_get_topic_order($sortby);  for ($i = 0; $i < count($forum_topic_list_header); $i++) {    if ($forum_topic_list_header[$i]['field'] == $order['field']) {      $forum_topic_list_header[$i]['sort'] = $order['sort'];    }  }  $term = taxonomy_get_term($tid);  $sql = db_rewrite_sql("SELECT n.nid, r.tid, n.title, n.type, n.sticky, u.name, u.uid, n.created AS timestamp, n.comment AS comment_mode, l.last_comment_timestamp, IF(l.last_comment_uid != 0, cu.name, l.last_comment_name) AS last_comment_name, l.last_comment_uid, l.comment_count AS num_comments, f.tid AS forum_tid FROM {node_comment_statistics} l INNER JOIN {node} n ON n.nid = l.nid INNER JOIN {users} cu ON l.last_comment_uid = cu.uid INNER JOIN {term_node} r ON n.vid = r.vid INNER JOIN {users} u ON n.uid = u.uid INNER JOIN {forum} f ON n.vid = f.vid WHERE n.status = 1 AND r.tid = %d");  $sql .= tablesort_sql($forum_topic_list_header, 'n.sticky DESC,');  $sql .= ', n.created DESC';  // Always add a secondary sort order so that the news forum topics are on top.  $sql_count = db_rewrite_sql("SELECT COUNT(n.nid) FROM {node} n INNER JOIN {term_node} r ON n.vid = r.vid AND r.tid = %d WHERE n.status = 1");  $result = pager_query($sql, $forum_per_page, 0, $sql_count, $tid);  $topics = array();  while ($topic = db_fetch_object($result)) {    if ($user->uid) {      // folder is new if topic is new or there are new comments since last visit      if ($topic->tid != $tid) {        $topic->new = 0;      }      else {        $history = _forum_user_last_visit($topic->nid);        $topic->new_replies = comment_num_new($topic->nid, $history);        $topic->new = $topic->new_replies || ($topic->timestamp > $history);      }    }    else {      // Do not track "new replies" status for topics if the user is anonymous.      $topic->new_replies = 0;      $topic->new = 0;    }    if ($topic->num_comments > 0) {      $last_reply = new stdClass();      $last_reply->timestamp = $topic->last_comment_timestamp;      $last_reply->name = $topic->last_comment_name;      $last_reply->uid = $topic->last_comment_uid;      $topic->last_reply = $last_reply;    }    $topics[] = $topic;  }  return $topics;}/** * Finds the first unread node for a given forum. */function _forum_new($tid) {  global $user;  $sql = "SELECT n.nid FROM {node} n LEFT JOIN {history} h ON n.nid = h.nid AND h.uid = %d INNER JOIN {term_node} r ON n.nid = r.nid AND r.tid = %d WHERE n.status = 1 AND h.nid IS NULL AND n.created > %d ORDER BY created";  $sql = db_rewrite_sql($sql);  $nid = db_result(db_query_range($sql, $user->uid, $tid, NODE_NEW_LIMIT, 0, 1));  return $nid ? $nid : 0;}/** * Process variables for forums.tpl.php * * The $variables array contains the following arguments: * - $forums * - $topics * - $parents * - $tid * - $sortby * - $forum_per_page * * @see forums.tpl.php */function template_preprocess_forums(&$variables) {  global $user;  $vid = variable_get('forum_nav_vocabulary', '');  $vocabulary = taxonomy_vocabulary_load($vid);  $title = !empty($vocabulary->name) ? $vocabulary->name : '';  // Breadcrumb navigation:  $breadcrumb[] = l(t('Home'), NULL);  if ($variables['tid']) {    $breadcrumb[] = l($vocabulary->name, 'forum');  }  if ($variables['parents']) {    $variables['parents'] = array_reverse($variables['parents']);    foreach ($variables['parents'] as $p) {      if ($p->tid == $variables['tid']) {        $title = $p->name;      }      else {        $breadcrumb[] = l($p->name, 'forum/'. $p->tid);      }    }  }  drupal_set_breadcrumb($breadcrumb);  drupal_set_title(check_plain($title));  if ($variables['forums_defined'] = count($variables['forums']) || count($variables['parents'])) {    // Format the "post new content" links listing.    $forum_types = array();    // Loop through all node types for forum vocabulary.    foreach ($vocabulary->nodes as $type) {      // Check if the current user has the 'create' permission for this node type.      if (node_access('create', $type)) {        // Fetch the "General" name of the content type;        // Push the link with title and url to the array.        $forum_types[$type] = array('title' => t('Post new @node_type', array('@node_type' => node_get_types('name', $type))), 'href' => 'node/add/'. str_replace('_', '-', $type) .'/'. $variables['tid']);      }    }    if (empty($forum_types)) {      // The user is logged-in; but denied access to create any new forum content type.      if ($user->uid) {        $forum_types['disallowed'] = array('title' => t('You are not allowed to post new content in the forum.'));      }      // The user is not logged-in; and denied access to create any new forum content type.      else {        $forum_types['login'] = array('title' => t('<a href="@login">Login</a> to post new content in the forum.', array('@login' => url('user/login', array('query' => drupal_get_destination())))), 'html' => TRUE);      }    }    $variables['links'] = $forum_types;    if (!empty($variables['forums'])) {      $variables['forums'] = theme('forum_list', $variables['forums'], $variables['parents'], $variables['tid']);    }    else {      $variables['forums'] = '';    }    if ($variables['tid'] && !in_array($variables['tid'], variable_get('forum_containers', array()))) {      $variables['topics'] = theme('forum_topic_list', $variables['tid'], $variables['topics'], $variables['sortby'], $variables['forum_per_page']);      drupal_add_feed(url('taxonomy/term/'. $variables['tid'] .'/0/feed'), 'RSS - '. $title);    }    else {      $variables['topics'] = '';    }    // Provide separate template suggestions based on what's being output. Topic id is also accounted for.    // Check both variables to be safe then the inverse. Forums with topic ID's take precedence.    if ($variables['forums'] && !$variables['topics']) {      $variables['template_files'][] = 'forums-containers';      $variables['template_files'][] = 'forums-'. $variables['tid'];      $variables['template_files'][] = 'forums-containers-'. $variables['tid'];    }    elseif (!$variables['forums'] && $variables['topics']) {      $variables['template_files'][] = 'forums-topics';      $variables['template_files'][] = 'forums-'. $variables['tid'];      $variables['template_files'][] = 'forums-topics-'. $variables['tid'];    }    else {      $variables['template_files'][] = 'forums-'. $variables['tid'];    }  }  else {    drupal_set_title(t('No forums defined'));    $variables['links'] = array();    $variables['forums'] = '';    $variables['topics'] = '';  }}/** * Process variables to format a forum listing. * * $variables contains the following information: * - $forums * - $parents * - $tid * * @see forum-list.tpl.php * @see theme_forum_list() */function template_preprocess_forum_list(&$variables) {  global $user;  $row = 0;  // Sanitize each forum so that the template can safely print the data.  foreach ($variables['forums'] as $id => $forum) {    $variables['forums'][$id]->description = !empty($forum->description) ? filter_xss_admin($forum->description) : '';    $variables['forums'][$id]->link = url("forum/$forum->tid");    $variables['forums'][$id]->name = check_plain($forum->name);    $variables['forums'][$id]->is_container = !empty($forum->container);    $variables['forums'][$id]->zebra = $row % 2 == 0 ? 'odd' : 'even';    $row++;    $variables['forums'][$id]->new_text = '';    $variables['forums'][$id]->new_url = '';    $variables['forums'][$id]->new_topics = 0;    $variables['forums'][$id]->old_topics = $forum->num_topics;    if ($user->uid) {      $variables['forums'][$id]->new_topics = _forum_topics_unread($forum->tid, $user->uid);      if ($variables['forums'][$id]->new_topics) {        $variables['forums'][$id]->new_text = format_plural($variables['forums'][$id]->new_topics, '1 new', '@count new');        $variables['forums'][$id]->new_url = url("forum/$forum->tid", array('fragment' => 'new'));      }      $variables['forums'][$id]->old_topics = $forum->num_topics - $variables['forums'][$id]->new_topics;    }    $variables['forums'][$id]->last_reply = theme('forum_submitted', $forum->last_post);  }  // Give meaning to $tid for themers. $tid actually stands for term id.  $variables['forum_id'] = $variables['tid'];  unset($variables['tid']);}/** * Preprocess variables to format the topic listing. * * $variables contains the following data: * - $tid * - $topics * - $sortby * - $forum_per_page * * @see forum-topic-list.tpl.php * @see theme_forum_topic_list() */function template_preprocess_forum_topic_list(&$variables) {  global $forum_topic_list_header;  // Create the tablesorting header.  $ts = tablesort_init($forum_topic_list_header);  $header = '';  foreach ($forum_topic_list_header as $cell) {    $cell = tablesort_header($cell, $forum_topic_list_header, $ts);    $header .= _theme_table_cell($cell, TRUE);  }  $variables['header'] = $header;  if (!empty($variables['topics'])) {    $row = 0;    foreach ($variables['topics'] as $id => $topic) {      $variables['topics'][$id]->icon = theme('forum_icon', $topic->new, $topic->num_comments, $topic->comment_mode, $topic->sticky);      $variables['topics'][$id]->zebra = $row % 2 == 0 ? 'odd' : 'even';      $row++;      // We keep the actual tid in forum table, if it's different from the      // current tid then it means the topic appears in two forums, one of      // them is a shadow copy.      if ($topic->forum_tid != $variables['tid']) {        $variables['topics'][$id]->moved = TRUE;        $variables['topics'][$id]->title = check_plain($topic->title);        $variables['topics'][$id]->message = l(t('This topic has been moved'), "forum/$topic->forum_tid");      }      else {        $variables['topics'][$id]->moved = FALSE;        $variables['topics'][$id]->title = l($topic->title, "node/$topic->nid");        $variables['topics'][$id]->message = '';      }      $variables['topics'][$id]->created = theme('forum_submitted', $topic);      $variables['topics'][$id]->last_reply = theme('forum_submitted', isset($topic->last_reply) ? $topic->last_reply : NULL);      $variables['topics'][$id]->new_text = '';      $variables['topics'][$id]->new_url = '';      if ($topic->new_replies) {        $variables['topics'][$id]->new_text = format_plural($topic->new_replies, '1 new', '@count new');        $variables['topics'][$id]->new_url = url("node/$topic->nid", array('query' => comment_new_page_count($topic->num_comments, $topic->new_replies, $topic), 'fragment' => 'new'));      }    }  }  else {    // Make this safe for the template    $variables['topics'] = array();  }  // Give meaning to $tid for themers. $tid actually stands for term id.  $variables['topic_id'] = $variables['tid'];  unset($variables['tid']);  $variables['pager'] = theme('pager', NULL, $variables['forum_per_page'], 0);}/** * Process variables to format the icon for each individual topic. * * $variables contains the following data: * - $new_posts * - $num_posts = 0 * - $comment_mode = 0 * - $sticky = 0 * * @see forum-icon.tpl.php * @see theme_forum_icon() */function template_preprocess_forum_icon(&$variables) {  $variables['hot_threshold'] = variable_get('forum_hot_topic', 15);  if ($variables['num_posts'] > $variables['hot_threshold']) {    $variables['icon'] = $variables['new_posts'] ? 'hot-new' : 'hot';  }  else {    $variables['icon'] = $variables['new_posts'] ? 'new' : 'default';  }  if ($variables['comment_mode'] == COMMENT_NODE_READ_ONLY || $variables['comment_mode'] == COMMENT_NODE_DISABLED) {    $variables['icon'] = 'closed';  }  if ($variables['sticky'] == 1) {    $variables['icon'] = 'sticky';  }}/** * Preprocess variables to format the next/previous forum topic navigation links. * * $variables contains $node. * * @see forum-topic-navigation.tpl.php * @see theme_forum_topic_navigation() */function template_preprocess_forum_topic_navigation(&$variables) {  $output = '';  // get previous and next topic  $sql = "SELECT n.nid, n.title, n.sticky, l.comment_count, l.last_comment_timestamp FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {term_node} r ON n.nid = r.nid AND r.tid = %d WHERE n.status = 1 ORDER BY n.sticky DESC, ". _forum_get_topic_order_sql(variable_get('forum_order', 1));  $result = db_query(db_rewrite_sql($sql), isset($variables['node']->tid) ? $variables['node']->tid : 0);  $stop = $variables['prev'] = $variables['next'] = 0;  while ($topic = db_fetch_object($result)) {    if ($stop == 1) {      $variables['next'] = $topic->nid;      $variables['next_title'] = check_plain($topic->title);      $variables['next_url'] = url("node/$topic->nid");      break;    }    if ($topic->nid == $variables['node']->nid) {      $stop = 1;    }    else {      $variables['prev'] = $topic->nid;      $variables['prev_title'] = check_plain($topic->title);      $variables['prev_url'] = url("node/$topic->nid");    }  }}/** * Process variables to format submission info for display in the forum list and topic list. * * $variables will contain: $topic * * @see forum-submitted.tpl.php * @see theme_forum_submitted() */function template_preprocess_forum_submitted(&$variables) {  $variables['author'] = isset($variables['topic']->uid) ? theme('username', $variables['topic']) : '';  $variables['time'] = isset($variables['topic']->timestamp) ? format_interval(time() - $variables['topic']->timestamp) : '';}function _forum_user_last_visit($nid) {  global $user;  static $history = array();  if (empty($history)) {    $result = db_query('SELECT nid, timestamp FROM {history} WHERE uid = %d', $user->uid);    while ($t = db_fetch_object($result)) {      $history[$t->nid] = $t->timestamp > NODE_NEW_LIMIT ? $t->timestamp : NODE_NEW_LIMIT;    }  }  return isset($history[$nid]) ? $history[$nid] : NODE_NEW_LIMIT;}function _forum_get_topic_order($sortby) {  switch ($sortby) {    case 1:      return array('field' => 'l.last_comment_timestamp', 'sort' => 'desc');      break;    case 2:      return array('field' => 'l.last_comment_timestamp', 'sort' => 'asc');      break;    case 3:      return array('field' => 'l.comment_count', 'sort' => 'desc');      break;    case 4:      return array('field' => 'l.comment_count', 'sort' => 'asc');      break;  }}function _forum_get_topic_order_sql($sortby) {  $order = _forum_get_topic_order($sortby);  return $order['field'] .' '. strtoupper($order['sort']);}
<?php// $Id$/** * @defgroup forms Form builder functions * @{ * Functions that build an abstract representation of a HTML form. * * All modules should declare their form builder functions to be in this * group and each builder function should reference its validate and submit * functions using \@see. Conversely, validate and submit functions should * reference the form builder function using \@see. For examples, of this see * system_modules_uninstall() or user_pass(), the latter of which has the * following in its doxygen documentation: * * \@ingroup forms * \@see user_pass_validate(). * \@see user_pass_submit(). * * @} End of "defgroup forms". *//** * @defgroup form_api Form generation * @{ * Functions to enable the processing and display of HTML forms. * * Drupal uses these functions to achieve consistency in its form processing and * presentation, while simplifying code and reducing the amount of HTML that * must be explicitly generated by modules. * * The drupal_get_form() function handles retrieving, processing, and * displaying a rendered HTML form for modules automatically. For example: * * @code * // Display the user registration form. * $output = drupal_get_form('user_register'); * @endcode * * Forms can also be built and submitted programmatically without any user input * using the drupal_execute() function. * * For information on the format of the structured arrays used to define forms, * and more detailed explanations of the Form API workflow, see the * @link http://api.drupal.org/api/file/developer/topics/forms_api_reference.html reference @endlink * and the @link http://api.drupal.org/api/file/developer/topics/forms_api.html quickstart guide. @endlink *//** * Retrieves a form from a constructor function, or from the cache if * the form was built in a previous page-load. The form is then passed * on for processing, after and rendered for display if necessary. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param ... *   Any additional arguments are passed on to the functions called by *   drupal_get_form(), including the unique form constructor function. *   For example, the node_edit form requires that a node object be passed *   in here when it is called. * @return *   The rendered form. */function drupal_get_form($form_id) {  $form_state = array('storage' => NULL, 'submitted' => FALSE);  $args = func_get_args();  $cacheable = FALSE;  if (isset($_SESSION['batch_form_state'])) {    // We've been redirected here after a batch processing : the form has    // already been processed, so we grab the post-process $form_state value    // and move on to form display. See _batch_finished() function.    $form_state = $_SESSION['batch_form_state'];    unset($_SESSION['batch_form_state']);  }  else {    // If the incoming $_POST contains a form_build_id, we'll check the    // cache for a copy of the form in question. If it's there, we don't    // have to rebuild the form to proceed. In addition, if there is stored    // form_state data from a previous step, we'll retrieve it so it can    // be passed on to the form processing code.    if (isset($_POST['form_id']) && $_POST['form_id'] == $form_id && !empty($_POST['form_build_id'])) {      $form = form_get_cache($_POST['form_build_id'], $form_state);    }    // If the previous bit of code didn't result in a populated $form    // object, we're hitting the form for the first time and we need    // to build it from scratch.    if (!isset($form)) {      $form_state['post'] = $_POST;      // Use a copy of the function's arguments for manipulation      $args_temp = $args;      $args_temp[0] = &$form_state;      array_unshift($args_temp, $form_id);      $form = call_user_func_array('drupal_retrieve_form', $args_temp);      $form_build_id = 'form-'. md5(uniqid(mt_rand(), true));      $form['#build_id'] = $form_build_id;      drupal_prepare_form($form_id, $form, $form_state);      // Store a copy of the unprocessed form for caching and indicate that it      // is cacheable if #cache will be set.      $original_form = $form;      $cacheable = TRUE;      unset($form_state['post']);    }    $form['#post'] = $_POST;    // Now that we know we have a form, we'll process it (validating,    // submitting, and handling the results returned by its submission    // handlers. Submit handlers accumulate data in the form_state by    // altering the $form_state variable, which is passed into them by    // reference.    drupal_process_form($form_id, $form, $form_state);    if ($cacheable && !empty($form['#cache'])) {      // Caching is done past drupal_process_form so #process callbacks can      // set #cache.      form_set_cache($form_build_id, $original_form, $form_state);    }  }  // Most simple, single-step forms will be finished by this point --  // drupal_process_form() usually redirects to another page (or to  // a 'fresh' copy of the form) once processing is complete. If one  // of the form's handlers has set $form_state['redirect'] to FALSE,  // the form will simply be re-rendered with the values still in its  // fields.  //  // If $form_state['storage'] or $form_state['rebuild'] has been set  // and input has been processed, we know that we're in a complex  // multi-part process of some sort and the form's workflow is NOT  // complete. We need to construct a fresh copy of the form, passing  // in the latest $form_state in addition to any other variables passed  // into drupal_get_form().  if ((!empty($form_state['storage']) || !empty($form_state['rebuild'])) && !empty($form_state['process_input']) && !form_get_errors()) {    $form = drupal_rebuild_form($form_id, $form_state, $args);  }  // If we haven't redirected to a new location by now, we want to  // render whatever form array is currently in hand.  return drupal_render_form($form_id, $form);}/** * Retrieves a form, caches it and processes it with an empty $_POST. * * This function clears $_POST and passes the empty $_POST to the form_builder. * To preserve some parts from $_POST, pass them in $form_state. * * If your AHAH callback simulates the pressing of a button, then your AHAH * callback will need to do the same as what drupal_get_form would do when the * button is pressed: get the form from the cache, run drupal_process_form over * it and then if it needs rebuild, run drupal_rebuild_form over it. Then send * back a part of the returned form. * $form_state['clicked_button']['#array_parents'] will help you to find which * part. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param $form_state *   A keyed array containing the current state of the form. Most *   important is the $form_state['storage'] collection. * @param $args *   Any additional arguments are passed on to the functions called by *   drupal_get_form(), plus the original form_state in the beginning. If you *   are getting a form from the cache, use $form['#parameters'] to shift off *   the $form_id from its beginning then the resulting array can be used as *   $arg here. * @param $form_build_id *   If the AHAH callback calling this function only alters part of the form, *   then pass in the existing form_build_id so we can re-cache with the same *   csid. * @return *   The newly built form. */function drupal_rebuild_form($form_id, &$form_state, $args, $form_build_id = NULL) {  // Remove the first argument. This is $form_id.when called from  // drupal_get_form and the original $form_state when called from some AHAH  // callback. Neither is needed. After that, put in the current state.  $args[0] = &$form_state;  // And the form_id.  array_unshift($args, $form_id);  $form = call_user_func_array('drupal_retrieve_form', $args);  if (!isset($form_build_id)) {    // We need a new build_id for the new version of the form.    $form_build_id = 'form-'. md5(mt_rand());  }  $form['#build_id'] = $form_build_id;  drupal_prepare_form($form_id, $form, $form_state);  // Now, we cache the form structure so it can be retrieved later for  // validation. If $form_state['storage'] is populated, we'll also cache  // it so that it can be used to resume complex multi-step processes.  form_set_cache($form_build_id, $form, $form_state);  // Clear out all post data, as we don't want the previous step's  // data to pollute this one and trigger validate/submit handling,  // then process the form for rendering.  $_POST = array();  $form['#post'] = array();  drupal_process_form($form_id, $form, $form_state);  return $form;}/** * Store a form in the cache. */function form_set_cache($form_build_id, $form, $form_state) {  global $user;  // 6 hours cache life time for forms should be plenty.  $expire = 21600;  if ($user->uid) {    $form['#cache_token'] = drupal_get_token();  }  cache_set('form_'. $form_build_id, $form, 'cache_form', time() + $expire);  if (!empty($form_state['storage'])) {    cache_set('storage_'. $form_build_id, $form_state['storage'], 'cache_form', time() + $expire);  }}/** * Fetch a form from cache. */function form_get_cache($form_build_id, &$form_state) {  global $user;  if ($cached = cache_get('form_'. $form_build_id, 'cache_form')) {    $form = $cached->data;    if ((isset($form['#cache_token']) && drupal_valid_token($form['#cache_token'])) || (!isset($form['#cache_token']) && !$user->uid)) {      if ($cached = cache_get('storage_'. $form_build_id, 'cache_form')) {        $form_state['storage'] = $cached->data;      }      return $form;    }  }}/** * Retrieves a form using a form_id, populates it with $form_state['values'], * processes it, and returns any validation errors encountered. This * function is the programmatic counterpart to drupal_get_form(). * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. Examples *   may be found in node_forms(), search_forms(), and user_forms(). * @param $form_state *   A keyed array containing the current state of the form. Most *   important is the $form_state['values'] collection, a tree of data *   used to simulate the incoming $_POST information from a user's *   form submission. * @param ... *   Any additional arguments are passed on to the functions called by *   drupal_execute(), including the unique form constructor function. *   For example, the node_edit form requires that a node object be passed *   in here when it is called. * For example: * * @code * // register a new user * $form_state = array(); * $form_state['values']['name'] = 'robo-user'; * $form_state['values']['mail'] = 'robouser@example.com'; * $form_state['values']['pass']['pass1'] = 'password'; * $form_state['values']['pass']['pass2'] = 'password'; * $form_state['values']['op'] = t('Create new account'); * drupal_execute('user_register', $form_state); * * // Create a new node * $form_state = array(); * module_load_include('inc', 'node', 'node.pages'); * $node = array('type' => 'story'); * $form_state['values']['title'] = 'My node'; * $form_state['values']['body'] = 'This is the body text!'; * $form_state['values']['name'] = 'robo-user'; * $form_state['values']['op'] = t('Save'); * drupal_execute('story_node_form', $form_state, (object)$node); * @endcode */function drupal_execute($form_id, &$form_state) {  $args = func_get_args();  // Make sure $form_state is passed around by reference.  $args[1] = &$form_state;    $form = call_user_func_array('drupal_retrieve_form', $args);  $form['#post'] = $form_state['values'];  drupal_prepare_form($form_id, $form, $form_state);  drupal_process_form($form_id, $form, $form_state);}/** * Retrieves the structured array that defines a given form. * * @param $form_id *   The unique string identifying the desired form. If a function *   with that name exists, it is called to build the form array. *   Modules that need to generate the same form (or very similar forms) *   using different $form_ids can implement hook_forms(), which maps *   different $form_id values to the proper form constructor function. * @param $form_state *   A keyed array containing the current state of the form. * @param ... *   Any additional arguments needed by the unique form constructor *   function. Generally, these are any arguments passed into the *   drupal_get_form() or drupal_execute() functions after the first *   argument. If a module implements hook_forms(), it can examine *   these additional arguments and conditionally return different *   builder functions as well. */function drupal_retrieve_form($form_id, &$form_state) {  static $forms;  // We save two copies of the incoming arguments: one for modules to use  // when mapping form ids to constructor functions, and another to pass to  // the constructor function itself. We shift out the first argument -- the  // $form_id itself -- from the list to pass into the constructor function,  // since it's already known.  $args = func_get_args();  $saved_args = $args;  array_shift($args);  if (isset($form_state)) {    array_shift($args);  }  // We first check to see if there's a function named after the $form_id.  // If there is, we simply pass the arguments on to it to get the form.  if (!function_exists($form_id)) {    // In cases where many form_ids need to share a central constructor function,    // such as the node editing form, modules can implement hook_forms(). It    // maps one or more form_ids to the correct constructor functions.    //    // We cache the results of that hook to save time, but that only works    // for modules that know all their form_ids in advance. (A module that    // adds a small 'rate this comment' form to each comment in a list    // would need a unique form_id for each one, for example.)    //    // So, we call the hook if $forms isn't yet populated, OR if it doesn't    // yet have an entry for the requested form_id.    if (!isset($forms) || !isset($forms[$form_id])) {      $forms = module_invoke_all('forms', $form_id, $args);    }    $form_definition = $forms[$form_id];    if (isset($form_definition['callback arguments'])) {      $args = array_merge($form_definition['callback arguments'], $args);    }    if (isset($form_definition['callback'])) {      $callback = $form_definition['callback'];    }  }  array_unshift($args, NULL);  $args[0] = &$form_state;  // If $callback was returned by a hook_forms() implementation, call it.  // Otherwise, call the function named after the form id.  $form = call_user_func_array(isset($callback) ? $callback : $form_id, $args);  // We store the original function arguments, rather than the final $arg  // value, so that form_alter functions can see what was originally  // passed to drupal_retrieve_form(). This allows the contents of #parameters  // to be saved and passed in at a later date to recreate the form.  $form['#parameters'] = $saved_args;  return $form;}/** * This function is the heart of form API. The form gets built, validated and in * appropriate cases, submitted. * * @param $form_id *   The unique string identifying the current form. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. This *   includes the current persistent storage data for the form, and *   any data passed along by earlier steps when displaying a *   multi-step form. Additional information, like the sanitized $_POST *   data, is also accumulated here. */function drupal_process_form($form_id, &$form, &$form_state) {  $form_state['values'] = array();  $form = form_builder($form_id, $form, $form_state);  // Only process the form if it is programmed or the form_id coming  // from the POST data is set and matches the current form_id.  if ((!empty($form['#programmed'])) || (!empty($form['#post']) && (isset($form['#post']['form_id']) && ($form['#post']['form_id'] == $form_id)))) {    $form_state['process_input'] = TRUE;    drupal_validate_form($form_id, $form, $form_state);    // form_clean_id() maintains a cache of element IDs it has seen,    // so it can prevent duplicates. We want to be sure we reset that    // cache when a form is processed, so scenerios that result in    // the form being built behind the scenes and again for the    // browser don't increment all the element IDs needlessly.    form_clean_id(NULL, TRUE);    if ((!empty($form_state['submitted'])) && !form_get_errors() && empty($form_state['rebuild'])) {      $form_state['redirect'] = NULL;      form_execute_handlers('submit', $form, $form_state);      // We'll clear out the cached copies of the form and its stored data      // here, as we've finished with them. The in-memory copies are still      // here, though.      if (variable_get('cache', CACHE_DISABLED) == CACHE_DISABLED && !empty($form_state['values']['form_build_id'])) {        cache_clear_all('form_'. $form_state['values']['form_build_id'], 'cache_form');        cache_clear_all('storage_'. $form_state['values']['form_build_id'], 'cache_form');      }      // If batches were set in the submit handlers, we process them now,      // possibly ending execution. We make sure we do not react to the batch      // that is already being processed (if a batch operation performs a      // drupal_execute).      if ($batch =& batch_get() && !isset($batch['current_set'])) {        // The batch uses its own copies of $form and $form_state for        // late execution of submit handers and post-batch redirection.        $batch['form'] = $form;        $batch['form_state'] = $form_state;        $batch['progressive'] = !$form['#programmed'];        batch_process();        // Execution continues only for programmatic forms.        // For 'regular' forms, we get redirected to the batch processing        // page. Form redirection will be handled in _batch_finished(),        // after the batch is processed.      }      // If no submit handlers have populated the $form_state['storage']      // bundle, and the $form_state['rebuild'] flag has not been set,      // we're finished and should redirect to a new destination page      // if one has been set (and a fresh, unpopulated copy of the form      // if one hasn't). If the form was called by drupal_execute(),      // however, we'll skip this and let the calling function examine      // the resulting $form_state bundle itself.      if (!$form['#programmed'] && empty($form_state['rebuild']) && empty($form_state['storage'])) {        drupal_redirect_form($form, $form_state['redirect']);      }    }  }}/** * Prepares a structured form array by adding required elements, * executing any hook_form_alter functions, and optionally inserting * a validation token to prevent tampering. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. Passed *   in here so that hook_form_alter() calls can use it, as well. */function drupal_prepare_form($form_id, &$form, &$form_state) {  global $user;  $form['#type'] = 'form';  $form['#programmed'] = isset($form['#post']);  if (isset($form['#build_id'])) {    $form['form_build_id'] = array(      '#type' => 'hidden',      '#value' => $form['#build_id'],      '#id' => $form['#build_id'],      '#name' => 'form_build_id',    );  }  // Add a token, based on either #token or form_id, to any form displayed to  // authenticated users. This ensures that any submitted form was actually  // requested previously by the user and protects against cross site request  // forgeries.  if (isset($form['#token'])) {    if ($form['#token'] === FALSE || $user->uid == 0 || $form['#programmed']) {      unset($form['#token']);    }    else {      $form['form_token'] = array('#type' => 'token', '#default_value' => drupal_get_token($form['#token']));    }  }  else if (isset($user->uid) && $user->uid && !$form['#programmed']) {    $form['#token'] = $form_id;    $form['form_token'] = array(      '#id' => form_clean_id('edit-'. $form_id .'-form-token'),      '#type' => 'token',      '#default_value' => drupal_get_token($form['#token']),    );  }  if (isset($form_id)) {    $form['form_id'] = array(      '#type' => 'hidden',      '#value' => $form_id,      '#id' => form_clean_id("edit-$form_id"),    );  }  if (!isset($form['#id'])) {    $form['#id'] = form_clean_id($form_id);  }  $form += _element_info('form');  if (!isset($form['#validate'])) {    if (function_exists($form_id .'_validate')) {      $form['#validate'] = array($form_id .'_validate');    }  }  if (!isset($form['#submit'])) {    if (function_exists($form_id .'_submit')) {      // We set submit here so that it can be altered.      $form['#submit'] = array($form_id .'_submit');    }  }  // Normally, we would call drupal_alter($form_id, $form, $form_state).  // However, drupal_alter() normally supports just one byref parameter. Using  // the __drupal_alter_by_ref key, we can store any additional parameters  // that need to be altered, and they'll be split out into additional params  // for the hook_form_alter() implementations.  // @todo: Remove this in Drupal 7.  $data = &$form;  $data['__drupal_alter_by_ref'] = array(&$form_state);  drupal_alter('form_'. $form_id, $data);  // __drupal_alter_by_ref is unset in the drupal_alter() function, we need  // to repopulate it to ensure both calls get the data.  $data['__drupal_alter_by_ref'] = array(&$form_state);  drupal_alter('form', $data, $form_id);}/** * Validates user-submitted form data from the $form_state using * the validate functions defined in a structured form array. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. The current *   user-submitted data is stored in $form_state['values'], though *   form validation functions are passed an explicit copy of the *   values for the sake of simplicity. Validation handlers can also *   $form_state to pass information on to submit handlers. For example: *     $form_state['data_for_submision'] = $data; *   This technique is useful when validation requires file parsing, *   web service requests, or other expensive requests that should *   not be repeated in the submission step. */function drupal_validate_form($form_id, $form, &$form_state) {  static $validated_forms = array();  if (isset($validated_forms[$form_id])) {    return;  }  // If the session token was set by drupal_prepare_form(), ensure that it  // matches the current user's session.  if (isset($form['#token'])) {    if (!drupal_valid_token($form_state['values']['form_token'], $form['#token'])) {      // Setting this error will cause the form to fail validation.      form_set_error('form_token', t('Validation error, please try again. If this error persists, please contact the site administrator.'));    }  }  _form_validate($form, $form_state, $form_id);  $validated_forms[$form_id] = TRUE;}/** * Renders a structured form array into themed HTML. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @return *   A string containing the themed HTML. */function drupal_render_form($form_id, &$form) {  // Don't override #theme if someone already set it.  if (!isset($form['#theme'])) {    init_theme();    $registry = theme_get_registry();    if (isset($registry[$form_id])) {      $form['#theme'] = $form_id;    }  }  $output = drupal_render($form);  return $output;}/** * Redirect the user to a URL after a form has been processed. * * @param $form *   An associative array containing the structure of the form. * @param $redirect *   An optional value containing the destination path to redirect *   to if none is specified by the form. */function drupal_redirect_form($form, $redirect = NULL) {  $goto = NULL;  if (isset($redirect)) {    $goto = $redirect;  }  if ($goto !== FALSE && isset($form['#redirect'])) {    $goto = $form['#redirect'];  }  if (!isset($goto) || ($goto !== FALSE)) {    if (isset($goto)) {      if (is_array($goto)) {        call_user_func_array('drupal_goto', $goto);      }      else {        drupal_goto($goto);      }    }    drupal_goto($_GET['q']);  }}/** * Performs validation on form elements. First ensures required fields are * completed, #maxlength is not exceeded, and selected options were in the * list of options given to the user. Then calls user-defined validators. * * @param $elements *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. The current *   user-submitted data is stored in $form_state['values'], though *   form validation functions are passed an explicit copy of the *   values for the sake of simplicity. Validation handlers can also *   $form_state to pass information on to submit handlers. For example: *     $form_state['data_for_submision'] = $data; *   This technique is useful when validation requires file parsing, *   web service requests, or other expensive requests that should *   not be repeated in the submission step. * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. */function _form_validate($elements, &$form_state, $form_id = NULL) {  static $complete_form;  // Also used in the installer, pre-database setup.  $t = get_t();  // Recurse through all children.  foreach (element_children($elements) as $key) {    if (isset($elements[$key]) && $elements[$key]) {      _form_validate($elements[$key], $form_state);    }  }  // Validate the current input.  if (!isset($elements['#validated']) || !$elements['#validated']) {    if (isset($elements['#needs_validation'])) {      // Make sure a value is passed when the field is required.      // A simple call to empty() will not cut it here as some fields, like      // checkboxes, can return a valid value of '0'. Instead, check the      // length if it's a string, and the item count if it's an array.      if ($elements['#required'] && (!count($elements['#value']) || (is_string($elements['#value']) && strlen(trim($elements['#value'])) == 0))) {        form_error($elements, $t('!name field is required.', array('!name' => $elements['#title'])));      }      // Verify that the value is not longer than #maxlength.      if (isset($elements['#maxlength']) && drupal_strlen($elements['#value']) > $elements['#maxlength']) {        form_error($elements, $t('!name cannot be longer than %max characters but is currently %length characters long.', array('!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title'], '%max' => $elements['#maxlength'], '%length' => drupal_strlen($elements['#value']))));      }      if (isset($elements['#options']) && isset($elements['#value'])) {        if ($elements['#type'] == 'select') {          $options = form_options_flatten($elements['#options']);        }        else {          $options = $elements['#options'];        }        if (is_array($elements['#value'])) {          $value = $elements['#type'] == 'checkboxes' ? array_keys(array_filter($elements['#value'])) : $elements['#value'];          foreach ($value as $v) {            if (!isset($options[$v])) {              form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));              watchdog('form', 'Illegal choice %choice in !name element.', array('%choice' => $v, '!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);            }          }        }        elseif (!isset($options[$elements['#value']])) {          form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));          watchdog('form', 'Illegal choice %choice in %name element.', array('%choice' => $elements['#value'], '%name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);        }      }    }    // Call user-defined form level validators and store a copy of the full    // form so that element-specific validators can examine the entire structure    // if necessary.    if (isset($form_id)) {      form_execute_handlers('validate', $elements, $form_state);      $complete_form = $elements;    }    // Call any element-specific validators. These must act on the element    // #value data.    elseif (isset($elements['#element_validate'])) {      foreach ($elements['#element_validate'] as $function) {        if (function_exists($function))  {          $function($elements, $form_state, $complete_form);        }      }    }    $elements['#validated'] = TRUE;  }}/** * A helper function used to execute custom validation and submission * handlers for a given form. Button-specific handlers are checked * first. If none exist, the function falls back to form-level handlers. * * @param $type *   The type of handler to execute. 'validate' or 'submit' are the *   defaults used by Form API. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. If the user *   submitted the form by clicking a button with custom handler functions *   defined, those handlers will be stored here. */function form_execute_handlers($type, &$form, &$form_state) {  $return = FALSE;  if (isset($form_state[$type .'_handlers'])) {    $handlers = $form_state[$type .'_handlers'];  }  elseif (isset($form['#'. $type])) {    $handlers = $form['#'. $type];  }  else {    $handlers = array();  }  foreach ($handlers as $function) {    if (function_exists($function))  {      // Check to see if a previous _submit handler has set a batch, but       // make sure we do not react to a batch that is already being processed       // (for instance if a batch operation performs a drupal_execute()).      if ($type == 'submit' && ($batch =& batch_get()) && !isset($batch['current_set'])) {        // Some previous _submit handler has set a batch. We store the call        // in a special 'control' batch set, for execution at the correct        // time during the batch processing workflow.        $batch['sets'][] = array('form_submit' => $function);      }      else {        $function($form, $form_state);      }      $return = TRUE;    }  }  return $return;}/** * File an error against a form element. * * @param $name *   The name of the form element. If the #parents property of your form *   element is array('foo', 'bar', 'baz') then you may set an error on 'foo' *   or 'foo][bar][baz'. Setting an error on 'foo' sets an error for every *   element where the #parents array starts with 'foo'. * @param $message *   The error message to present to the user. * @param $reset *   Reset the form errors static cache. * @return *   Never use the return value of this function, use form_get_errors and *   form_get_error instead. */function form_set_error($name = NULL, $message = '', $reset = FALSE) {  static $form = array();  if ($reset) {    $form = array();  }  if (isset($name) && !isset($form[$name])) {    $form[$name] = $message;    if ($message) {      drupal_set_message($message, 'error');    }  }  return $form;}/** * Return an associative array of all errors. */function form_get_errors() {  $form = form_set_error();  if (!empty($form)) {    return $form;  }}/** * Return the error message filed against the form with the specified name. */function form_get_error($element) {  $form = form_set_error();  $key = $element['#parents'][0];  if (isset($form[$key])) {    return $form[$key];  }  $key = implode('][', $element['#parents']);  if (isset($form[$key])) {    return $form[$key];  }}/** * Flag an element as having an error. */function form_error(&$element, $message = '') {  form_set_error(implode('][', $element['#parents']), $message);}/** * Walk through the structured form array, adding any required * properties to each element and mapping the incoming $_POST * data to the proper elements. * * @param $form_id *   A unique string identifying the form for validation, submission, *   theming, and hook_form_alter functions. * @param $form *   An associative array containing the structure of the form. * @param $form_state *   A keyed array containing the current state of the form. In this *   context, it is used to accumulate information about which button *   was clicked when the form was submitted, as well as the sanitized *   $_POST data. */function form_builder($form_id, $form, &$form_state) {  static $complete_form, $cache;  // Initialize as unprocessed.  $form['#processed'] = FALSE;  // Use element defaults.  if ((!empty($form['#type'])) && ($info = _element_info($form['#type']))) {    // Overlay $info onto $form, retaining preexisting keys in $form.    $form += $info;  }  if (isset($form['#type']) && $form['#type'] == 'form') {    $cache = NULL;    $complete_form = $form;    if (!empty($form['#programmed'])) {      $form_state['submitted'] = TRUE;    }  }  if (isset($form['#input']) && $form['#input']) {    _form_builder_handle_input_element($form_id, $form, $form_state, $complete_form);  }  $form['#defaults_loaded'] = TRUE;  // We start off assuming all form elements are in the correct order.  $form['#sorted'] = TRUE;  // Recurse through all child elements.  $count = 0;  foreach (element_children($form) as $key) {    $form[$key]['#post'] = $form['#post'];    $form[$key]['#programmed'] = $form['#programmed'];    // Don't squash an existing tree value.    if (!isset($form[$key]['#tree'])) {      $form[$key]['#tree'] = $form['#tree'];    }    // Deny access to child elements if parent is denied.    if (isset($form['#access']) && !$form['#access']) {      $form[$key]['#access'] = FALSE;    }    // Don't squash existing parents value.    if (!isset($form[$key]['#parents'])) {      // Check to see if a tree of child elements is present. If so,      // continue down the tree if required.      $form[$key]['#parents'] = $form[$key]['#tree'] && $form['#tree'] ? array_merge($form['#parents'], array($key)) : array($key);      $array_parents = isset($form['#array_parents']) ? $form['#array_parents'] : array();      $array_parents[] = $key;      $form[$key]['#array_parents'] = $array_parents;    }    // Assign a decimal placeholder weight to preserve original array order.    if (!isset($form[$key]['#weight'])) {      $form[$key]['#weight'] = $count/1000;    }    else {      // If one of the child elements has a weight then we will need to sort      // later.      unset($form['#sorted']);    }    $form[$key] = form_builder($form_id, $form[$key], $form_state);    $count++;  }  // The #after_build flag allows any piece of a form to be altered  // after normal input parsing has been completed.  if (isset($form['#after_build']) && !isset($form['#after_build_done'])) {    foreach ($form['#after_build'] as $function) {      $form = $function($form, $form_state);      $form['#after_build_done'] = TRUE;    }  }  // Now that we've processed everything, we can go back to handle the funky  // Internet Explorer button-click scenario.  _form_builder_ie_cleanup($form, $form_state);  // We shoud keep the buttons array until the IE clean up function  // has recognized the submit button so the form has been marked  // as submitted. If we already know which button was submitted,  // we don't need the array.  if (!empty($form_state['submitted'])) {    unset($form_state['buttons']);  }  // If some callback set #cache, we need to flip a static flag so later it  // can be found.  if (!empty($form['#cache'])) {    $cache = $form['#cache'];  }  // We are on the top form, we can copy back #cache if it's set.  if (isset($form['#type']) && $form['#type'] == 'form' && isset($cache)) {    $form['#cache'] = TRUE;  }  return $form;}/** * Populate the #value and #name properties of input elements so they * can be processed and rendered. Also, execute any #process handlers * attached to a specific element. */function _form_builder_handle_input_element($form_id, &$form, &$form_state, $complete_form) {  if (!isset($form['#name'])) {    $name = array_shift($form['#parents']);    $form['#name'] = $name;    if ($form['#type'] == 'file') {      // To make it easier to handle $_FILES in file.inc, we place all      // file fields in the 'files' array. Also, we do not support      // nested file names.      $form['#name'] = 'files['. $form['#name'] .']';    }    elseif (count($form['#parents'])) {      $form['#name'] .= '['. implode('][', $form['#parents']) .']';    }    array_unshift($form['#parents'], $name);  }  if (!isset($form['#id'])) {    $form['#id'] = form_clean_id('edit-'. implode('-', $form['#parents']));  }  if (!empty($form['#disabled'])) {    $form['#attributes']['disabled'] = 'disabled';  }  if (!isset($form['#value']) && !array_key_exists('#value', $form)) {    $function = !empty($form['#value_callback']) ? $form['#value_callback'] : 'form_type_'. $form['#type'] .'_value';    if (($form['#programmed']) || ((!isset($form['#access']) || $form['#access']) && isset($form['#post']) && (isset($form['#post']['form_id']) && $form['#post']['form_id'] == $form_id))) {      $edit = $form['#post'];      foreach ($form['#parents'] as $parent) {        $edit = isset($edit[$parent]) ? $edit[$parent] : NULL;      }      if (!$form['#programmed'] || isset($edit)) {        // Call #type_value to set the form value;        if (function_exists($function)) {          $form['#value'] = $function($form, $edit);        }        if (!isset($form['#value']) && isset($edit)) {          $form['#value'] = $edit;        }      }      // Mark all posted values for validation.      if (isset($form['#value']) || (isset($form['#required']) && $form['#required'])) {        $form['#needs_validation'] = TRUE;      }    }    // Load defaults.    if (!isset($form['#value'])) {      // Call #type_value without a second argument to request default_value handling.      if (function_exists($function)) {        $form['#value'] = $function($form);      }      // Final catch. If we haven't set a value yet, use the explicit default value.      // Avoid image buttons (which come with garbage value), so we only get value      // for the button actually clicked.      if (!isset($form['#value']) && empty($form['#has_garbage_value'])) {        $form['#value'] = isset($form['#default_value']) ? $form['#default_value'] : '';      }    }  }  // Determine which button (if any) was clicked to submit the form.  // We compare the incoming values with the buttons defined in the form,  // and flag the one that matches. We have to do some funky tricks to  // deal with Internet Explorer's handling of single-button forms, though.  if (!empty($form['#post']) && isset($form['#executes_submit_callback'])) {    // First, accumulate a collection of buttons, divided into two bins:    // those that execute full submit callbacks and those that only validate.    $button_type = $form['#executes_submit_callback'] ? 'submit' : 'button';    $form_state['buttons'][$button_type][] = $form;    if (_form_button_was_clicked($form)) {      $form_state['submitted'] = $form_state['submitted'] || $form['#executes_submit_callback'];      // In most cases, we want to use form_set_value() to manipulate      // the global variables. In this special case, we want to make sure that      // the value of this element is listed in $form_variables under 'op'.      $form_state['values'][$form['#name']] = $form['#value'];      $form_state['clicked_button'] = $form;      if (isset($form['#validate'])) {        $form_state['validate_handlers'] = $form['#validate'];      }      if (isset($form['#submit'])) {        $form_state['submit_handlers'] = $form['#submit'];      }    }  }  // Allow for elements to expand to multiple elements, e.g., radios,  // checkboxes and files.  if (isset($form['#process']) && !$form['#processed']) {    foreach ($form['#process'] as $process) {      if (function_exists($process)) {        $form = $process($form, isset($edit) ? $edit : NULL, $form_state, $complete_form);      }    }    $form['#processed'] = TRUE;  }  form_set_value($form, $form['#value'], $form_state);}/** * Helper function to handle the sometimes-convoluted logic of button * click detection. * * In Internet Explorer, if ONLY one submit button is present, AND the * enter key is used to submit the form, no form value is sent for it * and we'll never detect a match. That special case is handled by * _form_builder_ie_cleanup(). */function _form_button_was_clicked($form) {  // First detect normal 'vanilla' button clicks. Traditionally, all  // standard buttons on a form share the same name (usually 'op'),  // and the specific return value is used to determine which was  // clicked. This ONLY works as long as $form['#name'] puts the  // value at the top level of the tree of $_POST data.  if (isset($form['#post'][$form['#name']]) && $form['#post'][$form['#name']] == $form['#value']) {    return TRUE;  }  // When image buttons are clicked, browsers do NOT pass the form element  // value in $_POST. Instead they pass an integer representing the  // coordinates of the click on the button image. This means that image  // buttons MUST have unique $form['#name'] values, but the details of  // their $_POST data should be ignored.  elseif (!empty($form['#has_garbage_value']) && isset($form['#value']) && $form['#value'] !== '') {    return TRUE;  }  return FALSE;}/** * In IE, if only one submit button is present, AND the enter key is * used to submit the form, no form value is sent for it and our normal * button detection code will never detect a match. We call this * function after all other button-detection is complete to check * for the proper conditions, and treat the single button on the form * as 'clicked' if they are met. */function _form_builder_ie_cleanup($form, &$form_state) {  // Quick check to make sure we're always looking at the full form  // and not a sub-element.  if (!empty($form['#type']) && $form['#type'] == 'form') {    // If we haven't recognized a submission yet, and there's a single    // submit button, we know that we've hit the right conditions. Grab    // the first one and treat it as the clicked button.    if (empty($form_state['submitted']) && !empty($form_state['buttons']['submit']) && empty($form_state['buttons']['button'])) {      $button = $form_state['buttons']['submit'][0];      // Set up all the $form_state information that would have been      // populated had the button been recognized earlier.      $form_state['submitted'] = TRUE;      $form_state['submit_handlers'] = empty($button['#submit']) ? NULL : $button['#submit'];      $form_state['validate_handlers'] = empty($button['#validate']) ? NULL : $button['#validate'];      $form_state['values'][$button['#name']] = $button['#value'];      $form_state['clicked_button'] = $button;    }  }}/** * Helper function to determine the value for an image button form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_image_button_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (!empty($edit)) {      // If we're dealing with Mozilla or Opera, we're lucky. It will      // return a proper value, and we can get on with things.      return $form['#return_value'];    }    else {      // Unfortunately, in IE we never get back a proper value for THIS      // form element. Instead, we get back two split values: one for the      // X and one for the Y coordinates on which the user clicked the      // button. We'll find this element in the #post data, and search      // in the same spot for its name, with '_x'.      $post = $form['#post'];      foreach (split('\[', $form['#name']) as $element_name) {        // chop off the ] that may exist.        if (substr($element_name, -1) == ']') {          $element_name = substr($element_name, 0, -1);        }        if (!isset($post[$element_name])) {          if (isset($post[$element_name .'_x'])) {            return $form['#return_value'];          }          return NULL;        }        $post = $post[$element_name];      }      return $form['#return_value'];    }  }}/** * Helper function to determine the value for a checkbox form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_checkbox_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (empty($form['#disabled'])) {      return !empty($edit) ? $form['#return_value'] : 0;    }    else {      return $form['#default_value'];    }  }}/** * Helper function to determine the value for a checkboxes form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_checkboxes_value($form, $edit = FALSE) {  if ($edit === FALSE) {    $value = array();    $form += array('#default_value' => array());    foreach ($form['#default_value'] as $key) {      $value[$key] = 1;    }    return $value;  }  elseif (!isset($edit)) {    return array();  }}/** * Helper function to determine the value for a password_confirm form * element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_password_confirm_value($form, $edit = FALSE) {  if ($edit === FALSE) {    $form += array('#default_value' => array());    return $form['#default_value'] + array('pass1' => '', 'pass2' => '');  }}/** * Helper function to determine the value for a select form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_select_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    if (isset($form['#multiple']) && $form['#multiple']) {      return (is_array($edit)) ? drupal_map_assoc($edit) : array();    }    else {      return $edit;    }  }}/** * Helper function to determine the value for a textfield form element. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_textfield_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    // Equate $edit to the form value to ensure it's marked for    // validation.    return str_replace(array("\r", "\n"), '', $edit);  }}/** * Helper function to determine the value for form's token value. * * @param $form *   The form element whose value is being populated. * @param $edit *   The incoming POST data to populate the form element. If this is FALSE, *   the element's default value should be returned. * @return *   The data that will appear in the $form_state['values'] collection *   for this element. Return nothing to use the default. */function form_type_token_value($form, $edit = FALSE) {  if ($edit !== FALSE) {    return (string)$edit;  }}/** * Change submitted form values during the form processing cycle. * * Use this function to change the submitted value of a form item in the * validation phase so that it persists in $form_state through to the * submission handlers in the submission phase. * * Since $form_state['values'] can either be a flat array of values, or a tree * of nested values, some care must be taken when using this function. * Specifically, $form_item['#parents'] is an array that describes the branch of * the tree whose value should be updated. For example, if we wanted to update * $form_state['values']['one']['two'] to 'new value', we'd pass in * $form_item['#parents'] = array('one', 'two') and $value = 'new value'. * * @param $form_item *   The form item that should have its value updated. Keys used: #parents, *   #value. In most cases you can just pass in the right element from the $form *   array. * @param $value *   The new value for the form item. * @param $form_state *   The array where the value change should be recorded. */function form_set_value($form_item, $value, &$form_state) {  _form_set_value($form_state['values'], $form_item, $form_item['#parents'], $value);}/** * Helper function for form_set_value(). * * We iterate over $parents and create nested arrays for them * in $form_state['values'] if needed. Then we insert the value into * the right array. */function _form_set_value(&$form_values, $form_item, $parents, $value) {  $parent = array_shift($parents);  if (empty($parents)) {    $form_values[$parent] = $value;  }  else {    if (!isset($form_values[$parent])) {      $form_values[$parent] = array();    }    _form_set_value($form_values[$parent], $form_item, $parents, $value);  }}/** * Retrieve the default properties for the defined element type. */function _element_info($type, $refresh = NULL) {  static $cache;  $basic_defaults = array(    '#description' => NULL,    '#attributes' => array(),    '#required' => FALSE,    '#tree' => FALSE,    '#parents' => array()  );  if (!isset($cache) || $refresh) {    $cache = array();    foreach (module_implements('elements') as $module) {      $elements = module_invoke($module, 'elements');      if (isset($elements) && is_array($elements)) {        $cache = array_merge_recursive($cache, $elements);      }    }    if (sizeof($cache)) {      foreach ($cache as $element_type => $info) {        $cache[$element_type] = array_merge_recursive($basic_defaults, $info);      }    }  }  return $cache[$type];}function form_options_flatten($array, $reset = TRUE) {  static $return;  if ($reset) {    $return = array();  }  foreach ($array as $key => $value) {    if (is_object($value)) {      form_options_flatten($value->option, FALSE);    }    else if (is_array($value)) {      form_options_flatten($value, FALSE);    }    else {      $return[$key] = 1;    }  }  return $return;}/** * Format a dropdown menu or scrolling selection box. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, extra, multiple, required * @return *   A themed HTML string representing the form element. * * @ingroup themeable * * It is possible to group options together; to do this, change the format of * $options to an associative array in which the keys are group labels, and the * values are associative arrays in the normal $options format. */function theme_select($element) {  $select = '';  $size = $element['#size'] ? ' size="'. $element['#size'] .'"' : '';  _form_set_class($element, array('form-select'));  $multiple = $element['#multiple'];  return theme('form_element', $element, '<select name="'. $element['#name'] .''. ($multiple ? '[]' : '') .'"'. ($multiple ? ' multiple="multiple" ' : '') . drupal_attributes($element['#attributes']) .' id="'. $element['#id'] .'" '. $size .'>'. form_select_options($element) .'</select>');}function form_select_options($element, $choices = NULL) {  if (!isset($choices)) {    $choices = $element['#options'];  }  // array_key_exists() accommodates the rare event where $element['#value'] is NULL.  // isset() fails in this situation.  $value_valid = isset($element['#value']) || array_key_exists('#value', $element);  $value_is_array = is_array($element['#value']);  $options = '';  foreach ($choices as $key => $choice) {    if (is_array($choice)) {      $options .= '<optgroup label="'. $key .'">';      $options .= form_select_options($element, $choice);      $options .= '</optgroup>';    }    elseif (is_object($choice)) {      $options .= form_select_options($element, $choice->option);    }    else {      $key = (string)$key;      if ($value_valid && (!$value_is_array && (string)$element['#value'] === $key || ($value_is_array && in_array($key, $element['#value'])))) {        $selected = ' selected="selected"';      }      else {        $selected = '';      }      $options .= '<option value="'. check_plain($key) .'"'. $selected .'>'. check_plain($choice) .'</option>';    }  }  return $options;}/** * Traverses a select element's #option array looking for any values * that hold the given key. Returns an array of indexes that match. * * This function is useful if you need to modify the options that are * already in a form element; for example, to remove choices which are * not valid because of additional filters imposed by another module. * One example might be altering the choices in a taxonomy selector. * To correctly handle the case of a multiple hierarchy taxonomy, * #options arrays can now hold an array of objects, instead of a * direct mapping of keys to labels, so that multiple choices in the * selector can have the same key (and label). This makes it difficult * to manipulate directly, which is why this helper function exists. * * This function does not support optgroups (when the elements of the * #options array are themselves arrays), and will return FALSE if * arrays are found. The caller must either flatten/restore or * manually do their manipulations in this case, since returning the * index is not sufficient, and supporting this would make the * "helper" too complicated and cumbersome to be of any help. * * As usual with functions that can return array() or FALSE, do not * forget to use === and !== if needed. * * @param $element *   The select element to search. * @param $key *   The key to look for. * @return *   An array of indexes that match the given $key. Array will be *   empty if no elements were found. FALSE if optgroups were found. */function form_get_options($element, $key) {  $keys = array();  foreach ($element['#options'] as $index => $choice) {    if (is_array($choice)) {      return FALSE;    }    else if (is_object($choice)) {      if (isset($choice->option[$key])) {        $keys[] = $index;      }    }    else if ($index == $key) {      $keys[] = $index;    }  }  return $keys;}/** * Format a group of form items. * * @param $element *   An associative array containing the properties of the element. *   Properties used: attributes, title, value, description, children, collapsible, collapsed * @return *   A themed HTML string representing the form item group. * * @ingroup themeable */function theme_fieldset($element) {  if (!empty($element['#collapsible'])) {    drupal_add_js('misc/collapse.js');    if (!isset($element['#attributes']['class'])) {      $element['#attributes']['class'] = '';    }    $element['#attributes']['class'] .= ' collapsible';    if (!empty($element['#collapsed'])) {      $element['#attributes']['class'] .= ' collapsed';    }  }  return '<fieldset'. drupal_attributes($element['#attributes']) .'>'. ($element['#title'] ? '<legend>'. $element['#title'] .'</legend>' : '') . (isset($element['#description']) && $element['#description'] ? '<div class="description">'. $element['#description'] .'</div>' : '') . (!empty($element['#children']) ? $element['#children'] : '') . (isset($element['#value']) ? $element['#value'] : '') ."</fieldset>\n";}/** * Format a radio button. * * @param $element *   An associative array containing the properties of the element. *   Properties used: required, return_value, value, attributes, title, description * @return *   A themed HTML string representing the form item group. * * @ingroup themeable */function theme_radio($element) {  _form_set_class($element, array('form-radio'));  $output = '<input type="radio" ';  $output .= 'id="'. $element['#id'] .'" ';  $output .= 'name="'. $element['#name'] .'" ';  $output .= 'value="'. $element['#return_value'] .'" ';  $output .= (check_plain($element['#value']) == $element['#return_value']) ? ' checked="checked" ' : ' ';  $output .= drupal_attributes($element['#attributes']) .' />';  if (!is_null($element['#title'])) {    $output = '<label class="option" for="'. $element['#id'] .'">'. $output .' '. $element['#title'] .'</label>';  }  unset($element['#title']);  return theme('form_element', $element, $output);}/** * Format a set of radio buttons. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, required and attributes. * @return *   A themed HTML string representing the radio button set. * * @ingroup themeable */function theme_radios($element) {  $class = 'form-radios';  if (isset($element['#attributes']['class'])) {    $class .= ' '. $element['#attributes']['class'];  }  $element['#children'] = '<div class="'. $class .'">'. (!empty($element['#children']) ? $element['#children'] : '') .'</div>';  if ($element['#title'] || $element['#description']) {    unset($element['#id']);    return theme('form_element', $element, $element['#children']);  }  else {    return $element['#children'];  }}/** * Format a password_confirm item. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, id, required, error. * @return *   A themed HTML string representing the form item. * * @ingroup themeable */function theme_password_confirm($element) {  return theme('form_element', $element, $element['#children']);}/** * Expand a password_confirm field into two text boxes. */function expand_password_confirm($element) {  $element['pass1'] =  array(    '#type' => 'password',    '#title' => t('Password'),    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass1'],    '#required' => $element['#required'],    '#attributes' => array('class' => 'password-field'),  );  $element['pass2'] =  array(    '#type' => 'password',    '#title' => t('Confirm password'),    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass2'],    '#required' => $element['#required'],    '#attributes' => array('class' => 'password-confirm'),  );  $element['#element_validate'] = array('password_confirm_validate');  $element['#tree'] = TRUE;  if (isset($element['#size'])) {    $element['pass1']['#size'] = $element['pass2']['#size'] = $element['#size'];  }  return $element;}/** * Validate password_confirm element. */function password_confirm_validate($form, &$form_state) {  $pass1 = trim($form['pass1']['#value']);  if (!empty($pass1)) {    $pass2 = trim($form['pass2']['#value']);    if (strcmp($pass1, $pass2)) {      form_error($form, t('The specified passwords do not match.'));    }  }  elseif ($form['#required'] && !empty($form['#post'])) {    form_error($form, t('Password field is required.'));  }  // Password field must be converted from a two-element array into a single  // string regardless of validation results.  form_set_value($form['pass1'], NULL, $form_state);  form_set_value($form['pass2'], NULL, $form_state);  form_set_value($form, $pass1, $form_state);  return $form;}/** * Format a date selection element. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, options, description, required and attributes. * @return *   A themed HTML string representing the date selection boxes. * * @ingroup themeable */function theme_date($element) {  return theme('form_element', $element, '<div class="container-inline">'. $element['#children'] .'</div>');}/** * Roll out a single date element. */function expand_date($element) {  // Default to current date  if (empty($element['#value'])) {    $element['#value'] = array('day' => format_date(time(), 'custom', 'j'),                            'month' => format_date(time(), 'custom', 'n'),                            'year' => format_date(time(), 'custom', 'Y'));  }  $element['#tree'] = TRUE;  // Determine the order of day, month, year in the site's chosen date format.  $format = variable_get('date_format_short', 'm/d/Y - H:i');  $sort = array();  $sort['day'] = max(strpos($format, 'd'), strpos($format, 'j'));  $sort['month'] = max(strpos($format, 'm'), strpos($format, 'M'));  $sort['year'] = strpos($format, 'Y');  asort($sort);  $order = array_keys($sort);  // Output multi-selector for date.  foreach ($order as $type) {    switch ($type) {      case 'day':        $options = drupal_map_assoc(range(1, 31));        break;      case 'month':        $options = drupal_map_assoc(range(1, 12), 'map_month');        break;      case 'year':        $options = drupal_map_assoc(range(1900, 2050));        break;    }    $parents = $element['#parents'];    $parents[] = $type;    $element[$type] = array(      '#type' => 'select',      '#value' => $element['#value'][$type],      '#attributes' => $element['#attributes'],      '#options' => $options,    );  }  return $element;}/** * Validates the date type to stop dates like February 30, 2006. */function date_validate($form) {  if (!checkdate($form['#value']['month'], $form['#value']['day'], $form['#value']['year'])) {    form_error($form, t('The specified date is invalid.'));  }}/** * Helper function for usage with drupal_map_assoc to display month names. */function map_month($month) {  return format_date(gmmktime(0, 0, 0, $month, 2, 1970), 'custom', 'M', 0);}/** * If no default value is set for weight select boxes, use 0. */function weight_value(&$form) {  if (isset($form['#default_value'])) {    $form['#value'] = $form['#default_value'];  }  else {    $form['#value'] = 0;  }}/** * Roll out a single radios element to a list of radios, * using the options array as index. */function expand_radios($element) {  if (count($element['#options']) > 0) {    foreach ($element['#options'] as $key => $choice) {      if (!isset($element[$key])) {        // Generate the parents as the autogenerator does, so we will have a        // unique id for each radio button.        $parents_for_id = array_merge($element['#parents'], array($key));        $element[$key] = array(          '#type' => 'radio',          '#title' => $choice,          '#return_value' => check_plain($key),          '#default_value' => isset($element['#default_value']) ? $element['#default_value'] : NULL,          '#attributes' => $element['#attributes'],          '#parents' => $element['#parents'],          '#id' => form_clean_id('edit-'. implode('-', $parents_for_id)),          '#ahah' => isset($element['#ahah']) ? $element['#ahah'] : NULL,        );      }    }  }  return $element;}/** * Add AHAH information about a form element to the page to communicate with * javascript. If #ahah[path] is set on an element, this additional javascript is * added to the page header to attach the AHAH behaviors. See ahah.js for more * information. * * @param $element *   An associative array containing the properties of the element. *   Properties used: ahah_event, ahah_path, ahah_wrapper, ahah_parameters, *   ahah_effect. * @return *   None. Additional code is added to the header of the page using *   drupal_add_js. */function form_expand_ahah($element) {  static $js_added = array();  // Add a reasonable default event handler if none specified.  if (isset($element['#ahah']['path']) && !isset($element['#ahah']['event'])) {    switch ($element['#type']) {      case 'submit':      case 'button':      case 'image_button':        // Use the mousedown instead of the click event because form        // submission via pressing the enter key triggers a click event on        // submit inputs, inappropriately triggering AHAH behaviors.        $element['#ahah']['event'] = 'mousedown';        // Attach an additional event handler so that AHAH behaviours        // can be triggered still via keyboard input.        $element['#ahah']['keypress'] = TRUE;        break;      case 'password':      case 'textfield':      case 'textarea':        $element['#ahah']['event'] = 'blur';        break;      case 'radio':      case 'checkbox':      case 'select':        $element['#ahah']['event'] = 'change';        break;    }  }  // Adding the same javascript settings twice will cause a recursion error,  // we avoid the problem by checking if the javascript has already been added.  if (isset($element['#ahah']['path']) && isset($element['#ahah']['event']) && !isset($js_added[$element['#id']])) {    drupal_add_js('misc/jquery.form.js');    drupal_add_js('misc/ahah.js');    $ahah_binding = array(      'url'      => url($element['#ahah']['path']),      'event'    => $element['#ahah']['event'],      'keypress' => empty($element['#ahah']['keypress']) ? NULL : $element['#ahah']['keypress'],      'wrapper'  => empty($element['#ahah']['wrapper']) ? NULL : $element['#ahah']['wrapper'],      'selector' => empty($element['#ahah']['selector']) ? '#'. $element['#id'] : $element['#ahah']['selector'],      'effect'   => empty($element['#ahah']['effect']) ? 'none' : $element['#ahah']['effect'],      'method'   => empty($element['#ahah']['method']) ? 'replace' : $element['#ahah']['method'],      'progress' => empty($element['#ahah']['progress']) ? array('type' => 'throbber') : $element['#ahah']['progress'],      'button'   => isset($element['#executes_submit_callback']) ? array($element['#name'] => $element['#value']) : FALSE,    );    // Convert a simple #ahah[progress] type string into an array.    if (is_string($ahah_binding['progress'])) {      $ahah_binding['progress'] = array('type' => $ahah_binding['progress']);    }    // Change progress path to a full url.    if (isset($ahah_binding['progress']['path'])) {      $ahah_binding['progress']['url'] = url($ahah_binding['progress']['path']);    }    // Add progress.js if we're doing a bar display.    if ($ahah_binding['progress']['type'] == 'bar') {      drupal_add_js('misc/progress.js');    }    drupal_add_js(array('ahah' => array($element['#id'] => $ahah_binding)), 'setting');    $js_added[$element['#id']] = TRUE;    $element['#cache'] = TRUE;  }  return $element;}/** * Format a form item. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, required, error * @return *   A themed HTML string representing the form item. * * @ingroup themeable */function theme_item($element) {  return theme('form_element', $element, $element['#value'] . (!empty($element['#children']) ? $element['#children'] : ''));}/** * Format a checkbox. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, return_value, description, required * @return *   A themed HTML string representing the checkbox. * * @ingroup themeable */function theme_checkbox($element) {  _form_set_class($element, array('form-checkbox'));  $checkbox = '<input ';  $checkbox .= 'type="checkbox" ';  $checkbox .= 'name="'. $element['#name'] .'" ';  $checkbox .= 'id="'. $element['#id'] .'" ' ;  $checkbox .= 'value="'. $element['#return_value'] .'" ';  $checkbox .= $element['#value'] ? ' checked="checked" ' : ' ';  $checkbox .= drupal_attributes($element['#attributes']) .' />';  if (!is_null($element['#title'])) {    $checkbox = '<label class="option" for="'. $element['#id'] .'">'. $checkbox .' '. $element['#title'] .'</label>';  }  unset($element['#title']);  return theme('form_element', $element, $checkbox);}/** * Format a set of checkboxes. * * @param $element *   An associative array containing the properties of the element. * @return *   A themed HTML string representing the checkbox set. * * @ingroup themeable */function theme_checkboxes($element) {  $class = 'form-checkboxes';  if (isset($element['#attributes']['class'])) {    $class .= ' '. $element['#attributes']['class'];  }  $element['#children'] = '<div class="'. $class .'">'. (!empty($element['#children']) ? $element['#children'] : '') .'</div>';  if ($element['#title'] || $element['#description']) {    unset($element['#id']);    return theme('form_element', $element, $element['#children']);  }  else {    return $element['#children'];  }}function expand_checkboxes($element) {  $value = is_array($element['#value']) ? $element['#value'] : array();  $element['#tree'] = TRUE;  if (count($element['#options']) > 0) {    if (!isset($element['#default_value']) || $element['#default_value'] == 0) {      $element['#default_value'] = array();    }    foreach ($element['#options'] as $key => $choice) {      if (!isset($element[$key])) {        $element[$key] = array(          '#type' => 'checkbox',          '#processed' => TRUE,          '#title' => $choice,          '#return_value' => $key,          '#default_value' => isset($value[$key]),          '#attributes' => $element['#attributes'],          '#ahah' => isset($element['#ahah']) ? $element['#ahah'] : NULL,        );      }    }  }  return $element;}/** * Theme a form submit button. * * @ingroup themeable */function theme_submit($element) {  return theme('button', $element);}/** * Theme a form button. * * @ingroup themeable */function theme_button($element) {  // Make sure not to overwrite classes.  if (isset($element['#attributes']['class'])) {    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];  }  else {    $element['#attributes']['class'] = 'form-'. $element['#button_type'];  }  return '<input type="submit" '. (empty($element['#name']) ? '' : 'name="'. $element['#name'] .'" ') .'id="'. $element['#id'] .'" value="'. check_plain($element['#value']) .'" '. drupal_attributes($element['#attributes']) ." />\n";}/** * Theme a form image button. * * @ingroup themeable */function theme_image_button($element) {  // Make sure not to overwrite classes.  if (isset($element['#attributes']['class'])) {    $element['#attributes']['class'] = 'form-'. $element['#button_type'] .' '. $element['#attributes']['class'];  }  else {    $element['#attributes']['class'] = 'form-'. $element['#button_type'];  }  return '<input type="image" name="'. $element['#name'] .'" '.    (!empty($element['#value']) ? ('value="'. check_plain($element['#value']) .'" ') : '') .    'id="'. $element['#id'] .'" '.    drupal_attributes($element['#attributes']) .    ' src="'. base_path() . $element['#src'] .'" '.    (!empty($element['#title']) ? 'alt="'. check_plain($element['#title']) .'" title="'. check_plain($element['#title']) .'" ' : '' ) .    "/>\n";}/** * Format a hidden form field. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  value, edit * @return *   A themed HTML string representing the hidden form field. * * @ingroup themeable */function theme_hidden($element) {  return '<input type="hidden" name="'. $element['#name'] .'" id="'. $element['#id'] .'" value="'. check_plain($element['#value']) ."\" ". drupal_attributes($element['#attributes']) ." />\n";}/** * Format a form token. * * @ingroup themeable */function theme_token($element) {  return theme('hidden', $element);}/** * Format a textfield. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, size, maxlength, required, attributes autocomplete_path * @return *   A themed HTML string representing the textfield. * * @ingroup themeable */function theme_textfield($element) {  $size = empty($element['#size']) ? '' : ' size="'. $element['#size'] .'"';  $maxlength = empty($element['#maxlength']) ? '' : ' maxlength="'. $element['#maxlength'] .'"';  $class = array('form-text');  $extra = '';  $output = '';  if ($element['#autocomplete_path'] && menu_valid_path(array('link_path' => $element['#autocomplete_path']))) {    drupal_add_js('misc/autocomplete.js');    $class[] = 'form-autocomplete';    $extra =  '<input class="autocomplete" type="hidden" id="'. $element['#id'] .'-autocomplete" value="'. check_url(url($element['#autocomplete_path'], array('absolute' => TRUE))) .'" disabled="disabled" />';  }  _form_set_class($element, $class);  if (isset($element['#field_prefix'])) {    $output .= '<span class="field-prefix">'. $element['#field_prefix'] .'</span> ';  }  $output .= '<input type="text"'. $maxlength .' name="'. $element['#name'] .'" id="'. $element['#id'] .'"'. $size .' value="'. check_plain($element['#value']) .'"'. drupal_attributes($element['#attributes']) .' />';  if (isset($element['#field_suffix'])) {    $output .= ' <span class="field-suffix">'. $element['#field_suffix'] .'</span>';  }  return theme('form_element', $element, $output) . $extra;}/** * Format a form. * * @param $element *   An associative array containing the properties of the element. *   Properties used: action, method, attributes, children * @return *   A themed HTML string representing the form. * * @ingroup themeable */function theme_form($element) {  // Anonymous div to satisfy XHTML compliance.  $action = $element['#action'] ? 'action="'. check_url($element['#action']) .'" ' : '';  return '<form '. $action .' accept-charset="UTF-8" method="'. $element['#method'] .'" id="'. $element['#id'] .'"'. drupal_attributes($element['#attributes']) .">\n<div>". $element['#children'] ."\n</div></form>\n";}/** * Format a textarea. * * @param $element *   An associative array containing the properties of the element. *   Properties used: title, value, description, rows, cols, required, attributes * @return *   A themed HTML string representing the textarea. * * @ingroup themeable */function theme_textarea($element) {  $class = array('form-textarea');  // Add teaser behavior (must come before resizable)  if (!empty($element['#teaser'])) {    drupal_add_js('misc/teaser.js');    // Note: arrays are merged in drupal_get_js().    drupal_add_js(array('teaserCheckbox' => array($element['#id'] => $element['#teaser_checkbox'])), 'setting');    drupal_add_js(array('teaser' => array($element['#id'] => $element['#teaser'])), 'setting');    $class[] = 'teaser';  }  // Add resizable behavior  if ($element['#resizable'] !== FALSE) {    drupal_add_js('misc/textarea.js');    $class[] = 'resizable';  }  _form_set_class($element, $class);  return theme('form_element', $element, '<textarea cols="'. $element['#cols'] .'" rows="'. $element['#rows'] .'" name="'. $element['#name'] .'" id="'. $element['#id'] .'" '. drupal_attributes($element['#attributes']) .'>'. check_plain($element['#value']) .'</textarea>');}/** * Format HTML markup for use in forms. * * This is used in more advanced forms, such as theme selection and filter format. * * @param $element *   An associative array containing the properties of the element. *   Properties used: value, children. * @return *   A themed HTML string representing the HTML markup. * * @ingroup themeable */function theme_markup($element) {  return (isset($element['#value']) ? $element['#value'] : '') . (isset($element['#children']) ? $element['#children'] : '');}/** * Format a password field. * * @param $element *   An associative array containing the properties of the element. *   Properties used:  title, value, description, size, maxlength, required, attributes * @return *   A themed HTML string representing the form. * * @ingroup themeable */function theme_password($element) {  $size = $element['#size'] ? ' size="'. $element['#size'] .'" ' : '';  $maxlength = $element['#maxlength'] ? ' maxlength="'. $element['#maxlength'] .'" ' : '';  _form_set_class($element, array('form-text'));  $output = '<input type="password" name="'. $element['#name'] .'" id="'. $element['#id'] .'" '. $maxlength . $size . drupal_attributes($element['#attributes']) .' />';  return theme('form_element', $element, $output);}/** * Expand weight elements into selects. */function process_weight($element) {  for ($n = (-1 * $element['#delta']); $n <= $element['#delta']; $n++) {    $weights[$n] = $n;  }  $element['#options'] = $weights;  $element['#type'] = 'select';  $element['#is_weight'] = TRUE;  $element += _element_info('select');  return $element;}/** * Format a file upload field. * * @param $title *   The label for the file upload field. * @param $name *   The internal name used to refer to the field. * @param $size *   A measure of the visible size of the field (passed directly to HTML). * @param $description *   Explanatory text to display after the form item. * @param $required *   Whether the user must upload a file to the field. * @return *   A themed HTML string representing the field. * * @ingroup themeable * * For assistance with handling the uploaded file correctly, see the API * provided by file.inc. */function theme_file($element) {  _form_set_class($element, array('form-file'));  return theme('form_element', $element, '<input type="file" name="'. $element['#name'] .'"'. ($element['#attributes'] ? ' '. drupal_attributes($element['#attributes']) : '') .' id="'. $element['#id'] .'" size="'. $element['#size'] ."\" />\n");}/** * Return a themed form element. * * @param element *   An associative array containing the properties of the element. *   Properties used: title, description, id, required * @param $value *   The form element's data. * @return *   A string representing the form element. * * @ingroup themeable */function theme_form_element($element, $value) {  // This is also used in the installer, pre-database setup.  $t = get_t();  $output = '<div class="form-item"';  if (!empty($element['#id'])) {    $output .= ' id="'. $element['#id'] .'-wrapper"';  }  $output .= ">\n";  $required = !empty($element['#required']) ? '<span class="form-required" title="'. $t('This field is required.') .'">*</span>' : '';  if (!empty($element['#title'])) {    $title = $element['#title'];    if (!empty($element['#id'])) {      $output .= ' <label for="'. $element['#id'] .'">'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";    }    else {      $output .= ' <label>'. $t('!title: !required', array('!title' => filter_xss_admin($title), '!required' => $required)) ."</label>\n";    }  }  $output .= " $value\n";  if (!empty($element['#description'])) {    $output .= ' <div class="description">'. $element['#description'] ."</div>\n";  }  $output .= "</div>\n";  return $output;}/** * Sets a form element's class attribute. * * Adds 'required' and 'error' classes as needed. * * @param &$element *   The form element. * @param $name *   Array of new class names to be added. */function _form_set_class(&$element, $class = array()) {  if ($element['#required']) {    $class[] = 'required';  }  if (form_get_error($element)) {    $class[] = 'error';  }  if (isset($element['#attributes']['class'])) {    $class[] = $element['#attributes']['class'];  }  $element['#attributes']['class'] = implode(' ', $class);}/** * Prepare an HTML ID attribute string for a form item. * * Remove invalid characters and guarantee uniqueness. * * @param $id *   The ID to clean. * @param $flush *   If set to TRUE, the function will flush and reset the static array *   which is built to test the uniqueness of element IDs. This is only *   used if a form has completed the validation process. This parameter *   should never be set to TRUE if this function is being called to *   assign an ID to the #ID element. * @return *   The cleaned ID. */function form_clean_id($id = NULL, $flush = FALSE) {  static $seen_ids = array();  if ($flush) {    $seen_ids = array();    return;  }  $id = str_replace(array('][', '_', ' '), '-', $id);  // Ensure IDs are unique. The first occurrence is held but left alone.  // Subsequent occurrences get a number appended to them. This incrementing  // will almost certainly break code that relies on explicit HTML IDs in  // forms that appear more than once on the page, but the alternative is  // outputting duplicate IDs, which would break JS code and XHTML  // validity anyways. For now, it's an acceptable stopgap solution.  if (isset($seen_ids[$id])) {    $id = $id .'-'. $seen_ids[$id]++;  }  else {    $seen_ids[$id] = 1;  }  return $id;}/** * @} End of "defgroup form_api". *//** * @defgroup batch Batch operations * @{ * Functions allowing forms processing to be spread out over several page * requests, thus ensuring that the processing does not get interrupted * because of a PHP timeout, while allowing the user to receive feedback * on the progress of the ongoing operations. * * The API is primarily designed to integrate nicely with the Form API * workflow, but can also be used by non-FAPI scripts (like update.php) * or even simple page callbacks (which should probably be used sparingly). * * Example: * @code * $batch = array( *   'title' => t('Exporting'), *   'operations' => array( *     array('my_function_1', array($account->uid, 'story')), *     array('my_function_2', array()), *   ), *   'finished' => 'my_finished_callback', *   'file' => 'path_to_file_containing_myfunctions', * ); * batch_set($batch); * // only needed if not inside a form _submit handler : * batch_process(); * @endcode * * Note: if the batch 'title', 'init_message', 'progress_message', or * 'error_message' could contain any user input, it is the responsibility of * the code calling batch_set() to sanitize them first with a function like * check_plain() or filter_xss(). * * Sample batch operations: * @code * // Simple and artificial: load a node of a given type for a given user * function my_function_1($uid, $type, &$context) { *   // The $context array gathers batch context information about the execution (read), *   // as well as 'return values' for the current operation (write) *   // The following keys are provided : *   // 'results' (read / write): The array of results gathered so far by *   //   the batch processing, for the current operation to append its own. *   // 'message' (write): A text message displayed in the progress page. *   // The following keys allow for multi-step operations : *   // 'sandbox' (read / write): An array that can be freely used to *   //   store persistent data between iterations. It is recommended to *   //   use this instead of $_SESSION, which is unsafe if the user *   //   continues browsing in a separate window while the batch is processing. *   // 'finished' (write): A float number between 0 and 1 informing *   //   the processing engine of the completion level for the operation. *   //   1 (or no value explicitly set) means the operation is finished *   //   and the batch processing can continue to the next operation. * *   $node = node_load(array('uid' => $uid, 'type' => $type)); *   $context['results'][] = $node->nid .' : '. $node->title; *   $context['message'] = $node->title; * } * * // More advanced example: multi-step operation - load all nodes, five by five * function my_function_2(&$context) { *   if (empty($context['sandbox'])) { *     $context['sandbox']['progress'] = 0; *     $context['sandbox']['current_node'] = 0; *     $context['sandbox']['max'] = db_result(db_query('SELECT COUNT(DISTINCT nid) FROM {node}')); *   } *   $limit = 5; *   $result = db_query_range("SELECT nid FROM {node} WHERE nid > %d ORDER BY nid ASC", $context['sandbox']['current_node'], 0, $limit); *   while ($row = db_fetch_array($result)) { *     $node = node_load($row['nid'], NULL, TRUE); *     $context['results'][] = $node->nid .' : '. $node->title; *     $context['sandbox']['progress']++; *     $context['sandbox']['current_node'] = $node->nid; *     $context['message'] = $node->title; *   } *   if ($context['sandbox']['progress'] != $context['sandbox']['max']) { *     $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max']; *   } * } * @endcode * * Sample 'finished' callback: * @code * function batch_test_finished($success, $results, $operations) { *   if ($success) { *     $message = format_plural(count($results), 'One post processed.', '@count posts processed.'); *   } *   else { *     $message = t('Finished with an error.'); *   } *   drupal_set_message($message); *   // Providing data for the redirected page is done through $_SESSION. *   foreach ($results as $result) { *     $items[] = t('Loaded node %title.', array('%title' => $result)); *   } *   $_SESSION['my_batch_results'] = $items; * } * @endcode *//** * Opens a new batch. * * @param $batch *   An array defining the batch. The following keys can be used -- only *   'operations' is required, and batch_init() provides default values for *   the messages. *   - 'operations': Array of function calls to be performed. *     Example: *     @code *     array( *       array('my_function_1', array($arg1)), *       array('my_function_2', array($arg2_1, $arg2_2)), *     ) *     @endcode *   - 'title': Title for the progress page. Only safe strings should be passed. *     Defaults to t('Processing'). *   - 'init_message': Message displayed while the processing is initialized. *     Defaults to t('Initializing.'). *   - 'progress_message': Message displayed while processing the batch. *     Available placeholders are @current, @remaining, @total, @percentage, *     @estimate and @elapsed. Defaults to t('Completed @current of @total.'). *   - 'error_message': Message displayed if an error occurred while processing *     the batch. Defaults to t('An error has occurred.'). *   - 'finished': Name of a function to be executed after the batch has *     completed. This should be used to perform any result massaging that *     may be needed, and possibly save data in $_SESSION for display after *     final page redirection. *   - 'file': Path to the file containing the definitions of the *     'operations' and 'finished' functions, for instance if they don't *     reside in the main .module file. The path should be relative to *     base_path(), and thus should be built using drupal_get_path(). * * Operations are added as new batch sets. Batch sets are used to ensure * clean code independence, ensuring that several batches submitted by * different parts of the code (core / contrib modules) can be processed * correctly while not interfering or having to cope with each other. Each * batch set gets to specify his own UI messages, operates on its own set * of operations and results, and triggers its own 'finished' callback. * Batch sets are processed sequentially, with the progress bar starting * fresh for every new set. */function batch_set($batch_definition) {  if ($batch_definition) {    $batch =& batch_get();    // Initialize the batch    if (empty($batch)) {      $batch = array(        'sets' => array(),      );    }    $init = array(      'sandbox' => array(),      'results' => array(),      'success' => FALSE,    );    // Use get_t() to allow batches at install time.    $t = get_t();    $defaults = array(      'title' => $t('Processing'),      'init_message' => $t('Initializing.'),      'progress_message' => $t('Remaining @remaining of @total.'),      'error_message' => $t('An error has occurred.'),    );    $batch_set = $init + $batch_definition + $defaults;    // Tweak init_message to avoid the bottom of the page flickering down after init phase.    $batch_set['init_message'] .= '<br/>&nbsp;';    $batch_set['total'] = count($batch_set['operations']);    // If the batch is being processed (meaning we are executing a stored submit handler),    // insert the new set after the current one.    if (isset($batch['current_set'])) {      // array_insert does not exist...      $slice1 = array_slice($batch['sets'], 0, $batch['current_set'] + 1);      $slice2 = array_slice($batch['sets'], $batch['current_set'] + 1);      $batch['sets'] = array_merge($slice1, array($batch_set), $slice2);    }    else {      $batch['sets'][] = $batch_set;    }  }}/** * Processes the batch. * * Unless the batch has been marked with 'progressive' = FALSE, the function * issues a drupal_goto and thus ends page execution. * * This function is not needed in form submit handlers; Form API takes care * of batches that were set during form submission. * * @param $redirect *   (optional) Path to redirect to when the batch has finished processing. * @param $url *   (optional - should only be used for separate scripts like update.php) *   URL of the batch processing page. */function batch_process($redirect = NULL, $url = NULL) {  $batch =& batch_get();  if (isset($batch)) {    // Add process information    $url = isset($url) ? $url : 'batch';    $process_info = array(      'current_set' => 0,      'progressive' => TRUE,      'url' => isset($url) ? $url : 'batch',      'source_page' => $_GET['q'],      'redirect' => $redirect,    );    $batch += $process_info;    if ($batch['progressive']) {      // Clear the way for the drupal_goto redirection to the batch processing      // page, by saving and unsetting the 'destination' if any, on both places      // drupal_goto looks for it.      if (isset($_REQUEST['destination'])) {        $batch['destination'] = $_REQUEST['destination'];        unset($_REQUEST['destination']);      }      elseif (isset($_REQUEST['edit']['destination'])) {        $batch['destination'] = $_REQUEST['edit']['destination'];        unset($_REQUEST['edit']['destination']);      }      // Initiate db storage in order to get a batch id. We have to provide      // at least an empty string for the (not null) 'token' column.      db_query("INSERT INTO {batch} (token, timestamp) VALUES ('', %d)", time());      $batch['id'] = db_last_insert_id('batch', 'bid');      // Now that we have a batch id, we can generate the redirection link in      // the generic error message.      $t = get_t();      $batch['error_message'] = $t('Please continue to <a href="@error_url">the error page</a>', array('@error_url' => url($url, array('query' => array('id' => $batch['id'], 'op' => 'finished')))));      // Actually store the batch data and the token generated form the batch id.      db_query("UPDATE {batch} SET token = '%s', batch = '%s' WHERE bid = %d", drupal_get_token($batch['id']), serialize($batch), $batch['id']);      drupal_goto($batch['url'], 'op=start&id='. $batch['id']);    }    else {      // Non-progressive execution: bypass the whole progressbar workflow      // and execute the batch in one pass.      require_once './includes/batch.inc';      _batch_process();    }  }}/** * Retrieves the current batch. */function &batch_get() {  static $batch = array();  return $batch;}/** * @} End of "defgroup batch". */
<?php// $Id$/** * @file * Wrapper for database interface code. *//** * A hash value to check when outputting database errors, md5('DB_ERROR'). * * @see drupal_error_handler() */define('DB_ERROR', 'a515ac9c2796ca0e23adbe92c68fc9fc');/** * @defgroup database Database abstraction layer * @{ * Allow the use of different database servers using the same code base. * * Drupal provides a slim database abstraction layer to provide developers with * the ability to support multiple database servers easily. The intent of this * layer is to preserve the syntax and power of SQL as much as possible, while * letting Drupal control the pieces of queries that need to be written * differently for different servers and provide basic security checks. * * Most Drupal database queries are performed by a call to db_query() or * db_query_range(). Module authors should also consider using pager_query() for * queries that return results that need to be presented on multiple pages, and * tablesort_sql() for generating appropriate queries for sortable tables. * * For example, one might wish to return a list of the most recent 10 nodes * authored by a given user. Instead of directly issuing the SQL query * @code *   SELECT n.nid, n.title, n.created FROM node n WHERE n.uid = $uid LIMIT 0, 10; * @endcode * one would instead call the Drupal functions: * @code *   $result = db_query_range('SELECT n.nid, n.title, n.created *     FROM {node} n WHERE n.uid = %d', $uid, 0, 10); *   while ($node = db_fetch_object($result)) { *     // Perform operations on $node->body, etc. here. *   } * @endcode * Curly braces are used around "node" to provide table prefixing via * db_prefix_tables(). The explicit use of a user ID is pulled out into an * argument passed to db_query() so that SQL injection attacks from user input * can be caught and nullified. The LIMIT syntax varies between database servers, * so that is abstracted into db_query_range() arguments. Finally, note the * common pattern of iterating over the result set using db_fetch_object(). *//** * Perform an SQL query and return success or failure. * * @param $sql *   A string containing a complete SQL query.  %-substitution *   parameters are not supported. * @return *   An array containing the keys: *      success: a boolean indicating whether the query succeeded *      query: the SQL query executed, passed through check_plain() */function update_sql($sql) {  $result = db_query($sql, true);  return array('success' => $result !== FALSE, 'query' => check_plain($sql));}/** * Append a database prefix to all tables in a query. * * Queries sent to Drupal should wrap all table names in curly brackets. This * function searches for this syntax and adds Drupal's table prefix to all * tables, allowing Drupal to coexist with other systems in the same database if * necessary. * * @param $sql *   A string containing a partial or entire SQL query. * @return *   The properly-prefixed string. */function db_prefix_tables($sql) {  global $db_prefix;  if (is_array($db_prefix)) {    if (array_key_exists('default', $db_prefix)) {      $tmp = $db_prefix;      unset($tmp['default']);      foreach ($tmp as $key => $val) {        $sql = strtr($sql, array('{'. $key .'}' => $val . $key));      }      return strtr($sql, array('{' => $db_prefix['default'], '}' => ''));    }    else {      foreach ($db_prefix as $key => $val) {        $sql = strtr($sql, array('{'. $key .'}' => $val . $key));      }      return strtr($sql, array('{' => '', '}' => ''));    }  }  else {    return strtr($sql, array('{' => $db_prefix, '}' => ''));  }}/** * Activate a database for future queries. * * If it is necessary to use external databases in a project, this function can * be used to change where database queries are sent. If the database has not * yet been used, it is initialized using the URL specified for that name in * Drupal's configuration file. If this name is not defined, a duplicate of the * default connection is made instead. * * Be sure to change the connection back to the default when done with custom * code. * * @param $name *   The name assigned to the newly active database connection. If omitted, the *   default connection will be made active. * * @return the name of the previously active database or FALSE if non was found. */function db_set_active($name = 'default') {  global $db_url, $db_type, $active_db;  static $db_conns, $active_name = FALSE;  if (empty($db_url)) {    include_once 'includes/install.inc';    install_goto('install.php');  }  if (!isset($db_conns[$name])) {    // Initiate a new connection, using the named DB URL specified.    if (is_array($db_url)) {      $connect_url = array_key_exists($name, $db_url) ? $db_url[$name] : $db_url['default'];    }    else {      $connect_url = $db_url;    }    $db_type = substr($connect_url, 0, strpos($connect_url, '://'));    $handler = "./includes/database.$db_type.inc";    if (is_file($handler)) {      include_once $handler;    }    else {      _db_error_page("The database type '". $db_type ."' is unsupported. Please use either 'mysql' or 'mysqli' for MySQL, or 'pgsql' for PostgreSQL databases.");    }    $db_conns[$name] = db_connect($connect_url);  }  $previous_name = $active_name;  // Set the active connection.  $active_name = $name;  $active_db = $db_conns[$name];  return $previous_name;}/** * Helper function to show fatal database errors. * * Prints a themed maintenance page with the 'Site off-line' text, * adding the provided error message in the case of 'display_errors' * set to on. Ends the page request; no return. * * @param $error *   The error message to be appended if 'display_errors' is on. */function _db_error_page($error = '') {  global $db_type;  drupal_init_language();  drupal_maintenance_theme();  drupal_set_header('HTTP/1.1 503 Service Unavailable');  drupal_set_title('Site off-line');  $message = '<p>The site is currently not available due to technical problems. Please try again later. Thank you for your understanding.</p>';  $message .= '<hr /><p><small>If you are the maintainer of this site, please check your database settings in the <code>settings.php</code> file and ensure that your hosting provider\'s database server is running. For more help, see the <a href="http://drupal.org/node/258">handbook</a>, or contact your hosting provider.</small></p>';  if ($error && ini_get('display_errors')) {    $message .= '<p><small>The '. theme('placeholder', $db_type) .' error was: '. theme('placeholder', $error) .'.</small></p>';  }  print theme('maintenance_page', $message);  exit;}/** * Returns a boolean depending on the availability of the database. */function db_is_active() {  global $active_db;  return !empty($active_db);}/** * Helper function for db_query(). */function _db_query_callback($match, $init = FALSE) {  static $args = NULL;  if ($init) {    $args = $match;    return;  }  switch ($match[1]) {    case '%d': // We must use type casting to int to convert FALSE/NULL/(TRUE?)      $value = array_shift($args);      // Do we need special bigint handling?      if ($value > PHP_INT_MAX) {        $precision = ini_get('precision');        @ini_set('precision', 16);        $value = sprintf('%.0f', $value);        @ini_set('precision', $precision);      }      else {        $value = (int) $value;      }      // We don't need db_escape_string as numbers are db-safe.      return $value;    case '%s':      return db_escape_string(array_shift($args));    case '%n':      // Numeric values have arbitrary precision, so can't be treated as float.      // is_numeric() allows hex values (0xFF), but they are not valid.      $value = trim(array_shift($args));      return is_numeric($value) && !preg_match('/x/i', $value) ? $value : '0';    case '%%':      return '%';    case '%f':      return (float) array_shift($args);    case '%b': // binary data      return db_encode_blob(array_shift($args));  }}/** * Generate placeholders for an array of query arguments of a single type. * * Given a Schema API field type, return correct %-placeholders to * embed in a query * * @param $arguments *  An array with at least one element. * @param $type *   The Schema API type of a field (e.g. 'int', 'text', or 'varchar'). */function db_placeholders($arguments, $type = 'int') {  $placeholder = db_type_placeholder($type);  return implode(',', array_fill(0, count($arguments), $placeholder));}/** * Indicates the place holders that should be replaced in _db_query_callback(). */define('DB_QUERY_REGEXP', '/(%d|%s|%%|%f|%b|%n)/');/** * Helper function for db_rewrite_sql. * * Collects JOIN and WHERE statements via hook_db_rewrite_sql() * Decides whether to select primary_key or DISTINCT(primary_key) * * @param $query *   Query to be rewritten. * @param $primary_table *   Name or alias of the table which has the primary key field for this query. *   Typical table names would be: {blocks}, {comments}, {forum}, {node}, *   {menu}, {term_data} or {vocabulary}. However, in most cases the usual *   table alias (b, c, f, n, m, t or v) is used instead of the table name. * @param $primary_field *   Name of the primary field. * @param $args *   Array of additional arguments. * @return *   An array: join statements, where statements, field or DISTINCT(field). */function _db_rewrite_sql($query = '', $primary_table = 'n', $primary_field = 'nid', $args = array()) {  $where = array();  $join = array();  $distinct = FALSE;  foreach (module_implements('db_rewrite_sql') as $module) {    $result = module_invoke($module, 'db_rewrite_sql', $query, $primary_table, $primary_field, $args);    if (isset($result) && is_array($result)) {      if (isset($result['where'])) {        $where[] = $result['where'];      }      if (isset($result['join'])) {        $join[] = $result['join'];      }      if (isset($result['distinct']) && $result['distinct']) {        $distinct = TRUE;      }    }    elseif (isset($result)) {      $where[] = $result;    }  }  $where = empty($where) ? '' : '('. implode(') AND (', $where) .')';  $join = empty($join) ? '' : implode(' ', $join);  return array($join, $where, $distinct);}/** * Rewrites node, taxonomy and comment queries. Use it for listing queries. Do not * use FROM table1, table2 syntax, use JOIN instead. * * @param $query *   Query to be rewritten. * @param $primary_table *   Name or alias of the table which has the primary key field for this query. *   Typical table names would be: {blocks}, {comments}, {forum}, {node}, *   {menu}, {term_data} or {vocabulary}. However, it is more common to use the *   the usual table aliases: b, c, f, n, m, t or v. * @param $primary_field *   Name of the primary field. * @param $args *   An array of arguments, passed to the implementations of hook_db_rewrite_sql. * @return *   The original query with JOIN and WHERE statements inserted from *   hook_db_rewrite_sql implementations. nid is rewritten if needed. */function db_rewrite_sql($query, $primary_table = 'n', $primary_field = 'nid',  $args = array()) {  list($join, $where, $distinct) = _db_rewrite_sql($query, $primary_table, $primary_field, $args);  if ($distinct) {    $query = db_distinct_field($primary_table, $primary_field, $query);  }  if (!empty($where) || !empty($join)) {    $pattern = '{      # Beginning of the string      ^      ((?P<anonymous_view>        # Everything within this set of parentheses is named "anonymous view"        (?:          [^()]++                   # anything not parentheses        |          \( (?P>anonymous_view) \)          # an open parenthesis, more "anonymous view" and finally a close parenthesis.        )*      )[^()]+WHERE)    }x';    preg_match($pattern, $query, $matches);    if (!$where) {      $where = '1 = 1';    }    if ($matches) {      $n = strlen($matches[1]);      $second_part = substr($query, $n);      $first_part = substr($matches[1], 0, $n - 5) ." $join WHERE $where AND ( ";      // PHP 4 does not support strrpos for strings. We emulate it.      $haystack_reverse = strrev($second_part);    }    else {      $haystack_reverse = strrev($query);    }    // No need to use strrev on the needle, we supply GROUP, ORDER, LIMIT    // reversed.    foreach (array('PUORG', 'REDRO', 'TIMIL') as $needle_reverse) {      $pos = strpos($haystack_reverse, $needle_reverse);      if ($pos !== FALSE) {        // All needles are five characters long.        $pos += 5;        break;      }    }    if ($matches) {      if ($pos === FALSE) {        $query = $first_part . $second_part .')';      }      else {        $query = $first_part . substr($second_part, 0, -$pos) .')'. substr($second_part, -$pos);      }    }    elseif ($pos === FALSE) {      $query .= " $join WHERE $where";    }    else {      $query = substr($query, 0, -$pos) . " $join WHERE $where " . substr($query, -$pos);    }  }  return $query;}/** * Adds the DISTINCT flag to the supplied query if a DISTINCT doesn't already * exist in the query. Returns the altered query. * * This will not, and never did guarantee that you will obtain distinct  * values of $table.$field. * * @param $table Unused. Kept to remain API compatibility. * @param $field Unused. Kept to remain API compatibility. * @param $query Query to which the DISTINCT flag should be applied. * @return SQL query with the DISTINCT flag set. */function db_distinct_field($table, $field, $query) {  $matches = array();  if (!preg_match('/^SELECT\s*DISTINCT/i', $query, $matches)) {    // Only add distinct to the outer SELECT to avoid messing up subqueries.    $query = preg_replace('/^SELECT/i', 'SELECT DISTINCT', $query);  }  return $query;}/** * Restrict a dynamic table, column or constraint name to safe characters. * * Only keeps alphanumeric and underscores. */function db_escape_table($string) {  return preg_replace('/[^A-Za-z0-9_]+/', '', $string);}/** * @} End of "defgroup database". *//** * @defgroup schemaapi Schema API * @{ * * A Drupal schema definition is an array structure representing one or * more tables and their related keys and indexes. A schema is defined by * hook_schema(), which usually lives in a modulename.install file. * * By implementing hook_schema() and specifying the tables your module * declares, you can easily create and drop these tables on all * supported database engines. You don't have to deal with the * different SQL dialects for table creation and alteration of the * supported database engines. * * hook_schema() should return an array with a key for each table that * the module defines. * * The following keys are defined: * *   - 'description': A string describing this table and its purpose. *     References to other tables should be enclosed in *     curly-brackets.  For example, the node_revisions table *     description field might contain "Stores per-revision title and *     body data for each {node}." *   - 'fields': An associative array ('fieldname' => specification) *     that describes the table's database columns.  The specification *     is also an array.  The following specification parameters are defined: * *     - 'description': A string describing this field and its purpose. *       References to other tables should be enclosed in *       curly-brackets.  For example, the node table vid field *       description might contain "Always holds the largest (most *       recent) {node_revisions}.vid value for this nid." *     - 'type': The generic datatype: 'varchar', 'int', 'serial' *       'float', 'numeric', 'text', 'blob' or 'datetime'.  Most types *       just map to the according database engine specific *       datatypes.  Use 'serial' for auto incrementing fields. This *       will expand to 'int auto_increment' on mysql. *     - 'serialize': A boolean indicating whether the field will be stored         as a serialized string. *     - 'size': The data size: 'tiny', 'small', 'medium', 'normal', *       'big'.  This is a hint about the largest value the field will *       store and determines which of the database engine specific *       datatypes will be used (e.g. on MySQL, TINYINT vs. INT vs. BIGINT). *       'normal', the default, selects the base type (e.g. on MySQL, *       INT, VARCHAR, BLOB, etc.). * *       Not all sizes are available for all data types. See *       db_type_map() for possible combinations. *     - 'not null': If true, no NULL values will be allowed in this *       database column.  Defaults to false. *     - 'default': The field's default value.  The PHP type of the *       value matters: '', '0', and 0 are all different.  If you *       specify '0' as the default value for a type 'int' field it *       will not work because '0' is a string containing the *       character "zero", not an integer. *     - 'length': The maximal length of a type 'char', 'varchar' or 'text' *       field.  Ignored for other field types. *     - 'unsigned': A boolean indicating whether a type 'int', 'float' *       and 'numeric' only is signed or unsigned.  Defaults to *       FALSE.  Ignored for other field types. *     - 'precision', 'scale': For type 'numeric' fields, indicates *       the precision (total number of significant digits) and scale *       (decimal digits right of the decimal point).  Both values are *       mandatory.  Ignored for other field types. * *     All parameters apart from 'type' are optional except that type *     'numeric' columns must specify 'precision' and 'scale'. * *  - 'primary key': An array of one or more key column specifiers (see below) *    that form the primary key. *  - 'unique keys': An associative array of unique keys ('keyname' => *    specification).  Each specification is an array of one or more *    key column specifiers (see below) that form a unique key on the table. *  - 'indexes':  An associative array of indexes ('indexame' => *    specification).  Each specification is an array of one or more *    key column specifiers (see below) that form an index on the *    table. * * A key column specifier is either a string naming a column or an * array of two elements, column name and length, specifying a prefix * of the named column. * * As an example, here is a SUBSET of the schema definition for * Drupal's 'node' table.  It show four fields (nid, vid, type, and * title), the primary key on field 'nid', a unique key named 'vid' on * field 'vid', and two indexes, one named 'nid' on field 'nid' and * one named 'node_title_type' on the field 'title' and the first four * bytes of the field 'type': * * @code * $schema['node'] = array( *   'fields' => array( *     'nid'      => array('type' => 'serial', 'unsigned' => TRUE, 'not null' => TRUE), *     'vid'      => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0), *     'type'     => array('type' => 'varchar', 'length' => 32, 'not null' => TRUE, 'default' => ''), *     'title'    => array('type' => 'varchar', 'length' => 128, 'not null' => TRUE, 'default' => ''), *   ), *   'primary key' => array('nid'), *   'unique keys' => array( *     'vid'     => array('vid') *   ), *   'indexes' => array( *     'nid'                 => array('nid'), *     'node_title_type'     => array('title', array('type', 4)), *   ), * ); * @endcode * * @see drupal_install_schema() */ /** * Create a new table from a Drupal table definition. * * @param $ret *   Array to which query results will be added. * @param $name *   The name of the table to create. * @param $table *   A Schema API table definition array. */function db_create_table(&$ret, $name, $table) {  $statements = db_create_table_sql($name, $table);  foreach ($statements as $statement) {    $ret[] = update_sql($statement);  }}/** * Return an array of field names from an array of key/index column specifiers. * * This is usually an identity function but if a key/index uses a column prefix * specification, this function extracts just the name. * * @param $fields *   An array of key/index column specifiers. * @return *   An array of field names. */function db_field_names($fields) {  $ret = array();  foreach ($fields as $field) {    if (is_array($field)) {      $ret[] = $field[0];    }    else {      $ret[] = $field;    }  }  return $ret;}/** * Given a Schema API field type, return the correct %-placeholder. * * Embed the placeholder in a query to be passed to db_query and and pass as an * argument to db_query a value of the specified type. * * @param $type *   The Schema API type of a field. * @return *   The placeholder string to embed in a query for that type. */function db_type_placeholder($type) {  switch ($type) {    case 'varchar':    case 'char':    case 'text':    case 'datetime':      return "'%s'";    case 'numeric':      // Numeric values are arbitrary precision numbers.  Syntacically, numerics      // should be specified directly in SQL. However, without single quotes      // the %s placeholder does not protect against non-numeric characters such      // as spaces which would expose us to SQL injection.      return '%n';    case 'serial':    case 'int':      return '%d';    case 'float':      return '%f';    case 'blob':      return '%b';  }  // There is no safe value to return here, so return something that  // will cause the query to fail.  return 'unsupported type '. $type .'for db_type_placeholder';}/** * @} End of "defgroup schemaapi". */
<?php// $Id$/** * @file * Functions to aid in the creation of sortable tables. * * All tables created with a call to theme('table') have the option of having * column headers that the user can click on to sort the table by that column. *//** * Initialize the table sort context. */function tablesort_init($header) {  $ts = tablesort_get_order($header);  $ts['sort'] = tablesort_get_sort($header);  $ts['query_string'] = tablesort_get_querystring();  return $ts;}/** * Create an SQL sort clause. * * This function produces the ORDER BY clause to insert in your SQL queries, * assuring that the returned database table rows match the sort order chosen * by the user. * * @param $header *   An array of column headers in the format described in theme_table(). * @param $before *   An SQL string to insert after ORDER BY and before the table sorting code. *   Useful for sorting by important attributes like "sticky" first. * @return *   An SQL string to append to the end of a query. * * @ingroup database */function tablesort_sql($header, $before = '') {  $ts = tablesort_init($header);  if ($ts['sql']) {    // Based on code from db_escape_table(), but this can also contain a dot.    $field = preg_replace('/[^A-Za-z0-9_.]+/', '', $ts['sql']);    // Sort order can only be ASC or DESC.    $sort = drupal_strtoupper($ts['sort']);    $sort = in_array($sort, array('ASC', 'DESC')) ? $sort : '';    return " ORDER BY $before $field $sort";  }}/** * Format a column header. * * If the cell in question is the column header for the current sort criterion, * it gets special formatting. All possible sort criteria become links. * * @param $cell *   The cell to format. * @param $header *   An array of column headers in the format described in theme_table(). * @param $ts *   The current table sort context as returned from tablesort_init(). * @return *   A properly formatted cell, ready for _theme_table_cell(). */function tablesort_header($cell, $header, $ts) {  // Special formatting for the currently sorted column header.  if (is_array($cell) && isset($cell['field'])) {    $title = t('sort by @s', array('@s' => $cell['data']));    if ($cell['data'] == $ts['name']) {      $ts['sort'] = (($ts['sort'] == 'asc') ? 'desc' : 'asc');      if (isset($cell['class'])) {        $cell['class'] .= ' active';      }      else {        $cell['class'] = 'active';      }      $image = theme('tablesort_indicator', $ts['sort']);    }    else {      // If the user clicks a different header, we want to sort ascending initially.      $ts['sort'] = 'asc';      $image = '';    }    if (!empty($ts['query_string'])) {      $ts['query_string'] = '&'. $ts['query_string'];    }    $cell['data'] = l($cell['data'] . $image, $_GET['q'], array('attributes' => array('title' => $title), 'query' => 'sort='. $ts['sort'] .'&order='. urlencode($cell['data']) . $ts['query_string'], 'html' => TRUE));    unset($cell['field'], $cell['sort']);  }  return $cell;}/** * Format a table cell. * * Adds a class attribute to all cells in the currently active column. * * @param $cell *   The cell to format. * @param $header *   An array of column headers in the format described in theme_table(). * @param $ts *   The current table sort context as returned from tablesort_init(). * @param $i *   The index of the cell's table column. * @return *   A properly formatted cell, ready for _theme_table_cell(). */function tablesort_cell($cell, $header, $ts, $i) {  if (isset($header[$i]['data']) && $header[$i]['data'] == $ts['name'] && !empty($header[$i]['field'])) {    if (is_array($cell)) {      if (isset($cell['class'])) {        $cell['class'] .= ' active';      }      else {        $cell['class'] = 'active';      }    }    else {      $cell = array('data' => $cell, 'class' => 'active');    }  }  return $cell;}/** * Compose a query string to append to table sorting requests. * * @return *   A query string that consists of all components of the current page request *   except for those pertaining to table sorting. */function tablesort_get_querystring() {  return drupal_query_string_encode($_REQUEST, array_merge(array('q', 'sort', 'order', 'pass'), array_keys($_COOKIE)));}/** * Determine the current sort criterion. * * @param $headers *   An array of column headers in the format described in theme_table(). * @return *   An associative array describing the criterion, containing the keys: *   - "name": The localized title of the table column. *   - "sql": The name of the database field to sort on. */function tablesort_get_order($headers) {  $order = isset($_GET['order']) ? $_GET['order'] : '';  foreach ($headers as $header) {    if (isset($header['data']) && $order == $header['data']) {      return array('name' => $header['data'], 'sql' => isset($header['field']) ? $header['field'] : '');    }    if (isset($header['sort']) && ($header['sort'] == 'asc' || $header['sort'] == 'desc')) {      $default = array('name' => $header['data'], 'sql' => isset($header['field']) ? $header['field'] : '');    }  }  if (isset($default)) {    return $default;  }  else {    // The first column specified is initial 'order by' field unless otherwise specified    if (is_array($headers[0])) {      $headers[0] += array('data' => NULL, 'field' => NULL);      return array('name' => $headers[0]['data'], 'sql' => $headers[0]['field']);    }    else {      return array('name' => $headers[0]);    }  }}/** * Determine the current sort direction. * * @param $headers *   An array of column headers in the format described in theme_table(). * @return *   The current sort direction ("asc" or "desc"). */function tablesort_get_sort($headers) {  if (isset($_GET['sort'])) {    return ($_GET['sort'] == 'desc') ? 'desc' : 'asc';  }  // User has not specified a sort. Use default if specified; otherwise use "asc".  else {    foreach ($headers as $header) {      if (is_array($header) && array_key_exists('sort', $header)) {        return $header['sort'];      }    }  }  return 'asc';}
<?php// $Id$/** * @file * Content administration and module settings UI. *//** * Menu callback; presents general node configuration options. */function node_configure() {  $status = '<p>'. t('If the site is experiencing problems with permissions to content, you may have to rebuild the permissions cache. Possible causes for permission problems are disabling modules or configuration changes to permissions. Rebuilding will remove all privileges to posts, and replace them with permissions based on the current modules and settings.') .'</p>';  $status .= '<p>'. t('Rebuilding may take some time if there is a lot of content or complex permission settings. After rebuilding has completed posts will automatically use the new permissions.') .'</p>';  $form['access'] = array(    '#type' => 'fieldset',    '#title' => t('Node access status'),  );  $form['access']['status'] = array('#value' => $status);  $form['access']['rebuild'] = array(    '#type' => 'submit',    '#value' => t('Rebuild permissions'),    '#submit' => array('node_configure_access_submit'),  );  $form['default_nodes_main'] = array(    '#type' => 'select', '#title' => t('Number of posts on main page'), '#default_value' => variable_get('default_nodes_main', 10),    '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30)),    '#description' => t('The default maximum number of posts to display per page on overview pages such as the main page.')  );  $form['teaser_length'] = array(    '#type' => 'select', '#title' => t('Length of trimmed posts'), '#default_value' => variable_get('teaser_length', 600),    '#options' => array(      0 => t('Unlimited'),      200 => t('200 characters'),      400 => t('400 characters'),      600 => t('600 characters'),      800 => t('800 characters'),      1000 => t('1000 characters'),      1200 => t('1200 characters'),      1400 => t('1400 characters'),      1600 => t('1600 characters'),      1800 => t('1800 characters'),      2000 => t('2000 characters'),    ),    '#description' => t("The maximum number of characters used in the trimmed version of a post. Drupal will use this setting to determine at which offset long posts should be trimmed. The trimmed version of a post is typically used as a teaser when displaying the post on the main page, in XML feeds, etc. To disable teasers, set to 'Unlimited'. Note that this setting will only affect new or updated content and will not affect existing teasers.")  );  $form['node_preview'] = array(    '#type' => 'radios',    '#title' => t('Preview post'),    '#default_value' => variable_get('node_preview', 0),    '#options' => array(t('Optional'), t('Required')),    '#description' => t('Must users preview posts before submitting?'),  );  return system_settings_form($form);}/** * Form button submit callback. */function node_configure_access_submit($form, &$form_state) {  $form_state['redirect'] = 'admin/content/node-settings/rebuild';}/** * Menu callback: confirm rebuilding of permissions. */function node_configure_rebuild_confirm() {  return confirm_form(array(), t('Are you sure you want to rebuild the permissions on site content?'),                  'admin/content/node-settings', t('This action rebuilds all permissions on site content, and may be a lengthy process. This action cannot be undone.'), t('Rebuild permissions'), t('Cancel'));}/** * Handler for wipe confirmation */function node_configure_rebuild_confirm_submit($form, &$form_state) {  node_access_rebuild(TRUE);  $form_state['redirect'] = 'admin/content/node-settings';}/** * Implementation of hook_node_operations(). */function node_node_operations() {  $operations = array(    'publish' => array(      'label' => t('Publish'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('status' => 1)),    ),    'unpublish' => array(      'label' => t('Unpublish'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('status' => 0)),    ),    'promote' => array(      'label' => t('Promote to front page'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('status' => 1, 'promote' => 1)),    ),    'demote' => array(      'label' => t('Demote from front page'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('promote' => 0)),    ),    'sticky' => array(      'label' => t('Make sticky'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('status' => 1, 'sticky' => 1)),    ),    'unsticky' => array(      'label' => t('Remove stickiness'),      'callback' => 'node_mass_update',      'callback arguments' => array('updates' => array('sticky' => 0)),    ),    'delete' => array(      'label' => t('Delete'),      'callback' => NULL,    ),  );  return $operations;}/** * List node administration filters that can be applied. */function node_filters() {  // Regular filters  $filters['status'] = array(    'title' => t('status'),    'options' => array(      'status-1' => t('published'),      'status-0' => t('not published'),      'promote-1' => t('promoted'),      'promote-0' => t('not promoted'),      'sticky-1' => t('sticky'),      'sticky-0' => t('not sticky'),    ),  );  // Include translation states if we have this module enabled  if (module_exists('translation')) {    $filters['status']['options'] += array(      'translate-0' => t('Up to date translation'),      'translate-1' => t('Outdated translation'),    );  }  $filters['type'] = array('title' => t('type'), 'options' => node_get_types('names'));  // The taxonomy filter  if ($taxonomy = module_invoke('taxonomy', 'form_all', 1)) {    $filters['category'] = array('title' => t('category'), 'options' => $taxonomy);  }  // Language filter if there is a list of languages  if ($languages = module_invoke('locale', 'language_list')) {    $languages = array('' => t('Language neutral')) + $languages;    $filters['language'] = array('title' => t('language'), 'options' => $languages);  }  return $filters;}/** * Build query for node administration filters based on session. */function node_build_filter_query() {  $filters = node_filters();  // Build query  $where = $args = array();  $join = '';  foreach ($_SESSION['node_overview_filter'] as $index => $filter) {    list($key, $value) = $filter;    switch ($key) {      case 'status':        // Note: no exploitable hole as $key/$value have already been checked when submitted        list($key, $value) = explode('-', $value, 2);        $where[] = 'n.'. $key .' = %d';        break;      case 'category':        $table = "tn$index";        $where[] = "$table.tid = %d";        $join .= "INNER JOIN {term_node} $table ON n.nid = $table.nid ";        break;      case 'type':        $where[] = "n.type = '%s'";        break;      case 'language':        $where[] = "n.language = '%s'";        break;    }    $args[] = $value;  }  $where = count($where) ? 'WHERE '. implode(' AND ', $where) : '';  return array('where' => $where, 'join' => $join, 'args' => $args);}/** * Return form for node administration filters. */function node_filter_form() {  $session = &$_SESSION['node_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = node_filters();  $i = 0;  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Show only items where'),    '#theme' => 'node_filters',  );  $form['#submit'][] = 'node_filter_form_submit';  foreach ($session as $filter) {    list($type, $value) = $filter;    if ($type == 'category') {      // Load term name from DB rather than search and parse options array.      $value = module_invoke('taxonomy', 'get_term', $value);      $value = $value->name;    }    else if ($type == 'language') {      $value = empty($value) ? t('Language neutral') : module_invoke('locale', 'language_name', $value);    }    else {      $value = $filters[$type]['options'][$value];    }    if ($i++) {      $form['filters']['current'][] = array('#value' => t('<em>and</em> where <strong>%a</strong> is <strong>%b</strong>', array('%a' => $filters[$type]['title'], '%b' => $value)));    }    else {      $form['filters']['current'][] = array('#value' => t('<strong>%a</strong> is <strong>%b</strong>', array('%a' => $filters[$type]['title'], '%b' => $value)));    }    if (in_array($type, array('type', 'language'))) {      // Remove the option if it is already being filtered on.      unset($filters[$type]);    }  }  foreach ($filters as $key => $filter) {    $names[$key] = $filter['title'];    $form['filters']['status'][$key] = array('#type' => 'select', '#options' => $filter['options']);  }  $form['filters']['filter'] = array('#type' => 'radios', '#options' => $names, '#default_value' => 'status');  $form['filters']['buttons']['submit'] = array('#type' => 'submit', '#value' => (count($session) ? t('Refine') : t('Filter')));  if (count($session)) {    $form['filters']['buttons']['undo'] = array('#type' => 'submit', '#value' => t('Undo'));    $form['filters']['buttons']['reset'] = array('#type' => 'submit', '#value' => t('Reset'));  }  drupal_add_js('misc/form.js', 'core');  return $form;}/** * Theme node administration filter form. * * @ingroup themeable */function theme_node_filter_form($form) {  $output = '';  $output .= '<div id="node-admin-filter">';  $output .= drupal_render($form['filters']);  $output .= '</div>';  $output .= drupal_render($form);  return $output;}/** * Theme node administration filter selector. * * @ingroup themeable */function theme_node_filters($form) {  $output = '';  $output .= '<ul class="clear-block">';  if (!empty($form['current'])) {    foreach (element_children($form['current']) as $key) {      $output .= '<li>'. drupal_render($form['current'][$key]) .'</li>';    }  }  $output .= '<li><dl class="multiselect">'. (!empty($form['current']) ? '<dt><em>'. t('and') .'</em> '. t('where') .'</dt>' : '') .'<dd class="a">';  foreach (element_children($form['filter']) as $key) {    $output .= drupal_render($form['filter'][$key]);  }  $output .= '</dd>';  $output .= '<dt>'. t('is') .'</dt><dd class="b">';  foreach (element_children($form['status']) as $key) {    $output .= drupal_render($form['status'][$key]);  }  $output .= '</dd>';  $output .= '</dl>';  $output .= '<div class="container-inline" id="node-admin-buttons">'. drupal_render($form['buttons']) .'</div>';  $output .= '</li></ul>';  return $output;}/** * Process result from node administration filter form. */function node_filter_form_submit($form, &$form_state) {  $filters = node_filters();  switch ($form_state['values']['op']) {    case t('Filter'):    case t('Refine'):      if (isset($form_state['values']['filter'])) {        $filter = $form_state['values']['filter'];        // Flatten the options array to accommodate hierarchical/nested options.        $flat_options = form_options_flatten($filters[$filter]['options']);        if (isset($flat_options[$form_state['values'][$filter]])) {          $_SESSION['node_overview_filter'][] = array($filter, $form_state['values'][$filter]);        }      }      break;    case t('Undo'):      array_pop($_SESSION['node_overview_filter']);      break;    case t('Reset'):      $_SESSION['node_overview_filter'] = array();      break;  }}/** * Make mass update of nodes, changing all nodes in the $nodes array * to update them with the field values in $updates. * * IMPORTANT NOTE: This function is intended to work when called * from a form submit handler. Calling it outside of the form submission * process may not work correctly. * * @param array $nodes *   Array of node nids to update. * @param array $updates *   Array of key/value pairs with node field names and the *   value to update that field to. */function node_mass_update($nodes, $updates) {  // We use batch processing to prevent timeout when updating a large number  // of nodes.  if (count($nodes) > 10) {    $batch = array(      'operations' => array(        array('_node_mass_update_batch_process', array($nodes, $updates))      ),      'finished' => '_node_mass_update_batch_finished',      'title' => t('Processing'),      // We use a single multi-pass operation, so the default      // 'Remaining x of y operations' message will be confusing here.      'progress_message' => '',      'error_message' => t('The update has encountered an error.'),      // The operations do not live in the .module file, so we need to      // tell the batch engine which file to load before calling them.      'file' => drupal_get_path('module', 'node') .'/node.admin.inc',    );    batch_set($batch);  }  else {    foreach ($nodes as $nid) {      _node_mass_update_helper($nid, $updates);    }    drupal_set_message(t('The update has been performed.'));  }}/** * Node Mass Update - helper function. */function _node_mass_update_helper($nid, $updates) {  $node = node_load($nid, NULL, TRUE);  foreach ($updates as $name => $value) {    $node->$name = $value;  }  node_save($node);  return $node;}/** * Node Mass Update Batch operation */function _node_mass_update_batch_process($nodes, $updates, &$context) {  if (!isset($context['sandbox']['progress'])) {    $context['sandbox']['progress'] = 0;    $context['sandbox']['max'] = count($nodes);    $context['sandbox']['nodes'] = $nodes;  }  // Process nodes by groups of 5.  $count = min(5, count($context['sandbox']['nodes']));  for ($i = 1; $i <= $count; $i++) {    // For each nid, load the node, reset the values, and save it.    $nid = array_shift($context['sandbox']['nodes']);    $node = _node_mass_update_helper($nid, $updates);    // Store result for post-processing in the finished callback.    $context['results'][] = l($node->title, 'node/'. $node->nid);    // Update our progress information.    $context['sandbox']['progress']++;  }  // Inform the batch engine that we are not finished,  // and provide an estimation of the completion level we reached.  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];  }}/** * Node Mass Update Batch 'finished' callback. */function _node_mass_update_batch_finished($success, $results, $operations) {  if ($success) {    drupal_set_message(t('The update has been performed.'));  }  else {    drupal_set_message(t('An error occurred and processing did not complete.'), 'error');    $message = format_plural(count($results), '1 item successfully processed:', '@count items successfully processed:');    $message .= theme('item_list', $results);    drupal_set_message($message);  }}/** * Menu callback: content administration. */function node_admin_content($form_state) {  if (isset($form_state['values']['operation']) && $form_state['values']['operation'] == 'delete') {    return node_multiple_delete_confirm($form_state, array_filter($form_state['values']['nodes']));  }  $form = node_filter_form();  $form['#theme'] = 'node_filter_form';  $form['admin']  = node_admin_nodes();  return $form;}/** * Form builder: Builds the node administration overview. */function node_admin_nodes() {  $filter = node_build_filter_query();  $result = pager_query(db_rewrite_sql('SELECT n.*, u.name FROM {node} n '. $filter['join'] .' INNER JOIN {users} u ON n.uid = u.uid '. $filter['where'] .' ORDER BY n.changed DESC'), 50, 0, NULL, $filter['args']);  // Enable language column if locale is enabled or if we have any node with language  $count = db_result(db_query("SELECT COUNT(*) FROM {node} n WHERE language != ''"));  $multilanguage = (module_exists('locale') || $count);  $form['options'] = array(    '#type' => 'fieldset',    '#title' => t('Update options'),    '#prefix' => '<div class="container-inline">',    '#suffix' => '</div>',  );  $options = array();  foreach (module_invoke_all('node_operations') as $operation => $array) {    $options[$operation] = $array['label'];  }  $form['options']['operation'] = array(    '#type' => 'select',    '#options' => $options,    '#default_value' => 'approve',  );  $form['options']['submit'] = array(    '#type' => 'submit',    '#value' => t('Update'),    '#submit' => array('node_admin_nodes_submit'),  );  $languages = language_list();  $destination = drupal_get_destination();  $nodes = array();  while ($node = db_fetch_object($result)) {    $nodes[$node->nid] = '';    $options = empty($node->language) ? array() : array('language' => $languages[$node->language]);    $form['title'][$node->nid] = array('#value' => l($node->title, 'node/'. $node->nid, $options) .' '. theme('mark', node_mark($node->nid, $node->changed)));    $form['name'][$node->nid] =  array('#value' => check_plain(node_get_types('name', $node)));    $form['username'][$node->nid] = array('#value' => theme('username', $node));    $form['status'][$node->nid] =  array('#value' => ($node->status ? t('published') : t('not published')));    if ($multilanguage) {      $form['language'][$node->nid] = array('#value' => empty($node->language) ? t('Language neutral') : t($languages[$node->language]->name));    }    $form['operations'][$node->nid] = array('#value' => l(t('edit'), 'node/'. $node->nid .'/edit', array('query' => $destination)));  }  $form['nodes'] = array('#type' => 'checkboxes', '#options' => $nodes);  $form['pager'] = array('#value' => theme('pager', NULL, 50, 0));  $form['#theme'] = 'node_admin_nodes';  return $form;}/** * Validate node_admin_nodes form submissions. *  * Check if any nodes have been selected to perform the chosen * 'Update option' on. */function node_admin_nodes_validate($form, &$form_state) {  $nodes = array_filter($form_state['values']['nodes']);  if (count($nodes) == 0) {    form_set_error('', t('No items selected.'));  }}/** * Process node_admin_nodes form submissions. *  * Execute the chosen 'Update option' on the selected nodes. */function node_admin_nodes_submit($form, &$form_state) {  $operations = module_invoke_all('node_operations');  $operation = $operations[$form_state['values']['operation']];  // Filter out unchecked nodes  $nodes = array_filter($form_state['values']['nodes']);  if ($function = $operation['callback']) {    // Add in callback arguments if present.    if (isset($operation['callback arguments'])) {      $args = array_merge(array($nodes), $operation['callback arguments']);    }    else {      $args = array($nodes);    }    call_user_func_array($function, $args);    cache_clear_all();  }  else {    // We need to rebuild the form to go to a second step.  For example, to    // show the confirmation form for the deletion of nodes.    $form_state['rebuild'] = TRUE;  }}/** * Theme node administration overview. * * @ingroup themeable */function theme_node_admin_nodes($form) {  // If there are rows in this form, then $form['title'] contains a list of  // the title form elements.  $has_posts = isset($form['title']) && is_array($form['title']);  $select_header = $has_posts ? theme('table_select_header_cell') : '';  $header = array($select_header, t('Title'), t('Type'), t('Author'), t('Status'));  if (isset($form['language'])) {    $header[] = t('Language');  }  $header[] = t('Operations');  $output = '';  $output .= drupal_render($form['options']);  if ($has_posts) {    foreach (element_children($form['title']) as $key) {      $row = array();      $row[] = drupal_render($form['nodes'][$key]);      $row[] = drupal_render($form['title'][$key]);      $row[] = drupal_render($form['name'][$key]);      $row[] = drupal_render($form['username'][$key]);      $row[] = drupal_render($form['status'][$key]);      if (isset($form['language'])) {        $row[] = drupal_render($form['language'][$key]);      }      $row[] = drupal_render($form['operations'][$key]);      $rows[] = $row;    }  }  else {    $rows[] = array(array('data' => t('No posts available.'), 'colspan' => '6'));  }  $output .= theme('table', $header, $rows);  if ($form['pager']['#value']) {    $output .= drupal_render($form['pager']);  }  $output .= drupal_render($form);  return $output;}function node_multiple_delete_confirm(&$form_state, $nodes) {  $form['nodes'] = array('#prefix' => '<ul>', '#suffix' => '</ul>', '#tree' => TRUE);  // array_filter returns only elements with TRUE values  foreach ($nodes as $nid => $value) {    $title = db_result(db_query('SELECT title FROM {node} WHERE nid = %d', $nid));    $form['nodes'][$nid] = array(      '#type' => 'hidden',      '#value' => $nid,      '#prefix' => '<li>',      '#suffix' => check_plain($title) ."</li>\n",    );  }  $form['operation'] = array('#type' => 'hidden', '#value' => 'delete');  $form['#submit'][] = 'node_multiple_delete_confirm_submit';  return confirm_form($form,                      t('Are you sure you want to delete these items?'),                      'admin/content/node', t('This action cannot be undone.'),                      t('Delete all'), t('Cancel'));}function node_multiple_delete_confirm_submit($form, &$form_state) {  if ($form_state['values']['confirm']) {    foreach ($form_state['values']['nodes'] as $nid => $value) {      node_delete($nid);    }    drupal_set_message(t('The items have been deleted.'));  }  $form_state['redirect'] = 'admin/content/node';  return;}
<?php// $Id$/** * @file * Admin page callbacks for the statistics module. *//** * Menu callback; presents the "recent hits" page. */function statistics_recent_hits() {  $header = array(    array('data' => t('Timestamp'), 'field' => 'a.timestamp', 'sort' => 'desc'),    array('data' => t('Page'), 'field' => 'a.path'),    array('data' => t('User'), 'field' => 'u.name'),    array('data' => t('Operations'))  );  $sql = 'SELECT a.aid, a.path, a.title, a.uid, u.name, a.timestamp FROM {accesslog} a LEFT JOIN {users} u ON u.uid = a.uid'. tablesort_sql($header);  $result = pager_query($sql, 30);  $rows = array();  while ($log = db_fetch_object($result)) {    $rows[] = array(      array('data' => format_date($log->timestamp, 'small'), 'class' => 'nowrap'),      _statistics_format_item($log->title, $log->path),      theme('username', $log),      l(t('details'), "admin/reports/access/$log->aid"));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "top pages" page. */function statistics_top_pages() {  // MAX(title) avoids having empty node titles which otherwise causes duplicates in the top pages list  $sql = "SELECT COUNT(path) AS hits, path, MAX(title) AS title, AVG(timer) AS average_time, SUM(timer) AS total_time FROM {accesslog} GROUP BY path";  $sql_cnt = "SELECT COUNT(DISTINCT(path)) FROM {accesslog}";  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Page'), 'field' => 'path'),    array('data' => t('Average page generation time'), 'field' => 'average_time'),    array('data' => t('Total page generation time'), 'field' => 'total_time')  );  $sql .= tablesort_sql($header);  $result = pager_query($sql, 30, 0, $sql_cnt);  $rows = array();  while ($page = db_fetch_object($result)) {    $rows[] = array($page->hits, _statistics_format_item($page->title, $page->path), t('%time ms', array('%time' => round($page->average_time))), format_interval(round($page->total_time / 1000)));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  drupal_set_title(t('Top pages in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "top visitors" page. */function statistics_top_visitors() {  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Visitor'), 'field' => 'u.name'),    array('data' => t('Total page generation time'), 'field' => 'total'),    array('data' => t('Operations'))  );  $sql = "SELECT COUNT(a.uid) AS hits, a.uid, u.name, a.hostname, SUM(a.timer) AS total, ac.aid FROM {accesslog} a LEFT JOIN {access} ac ON ac.type = 'host' AND LOWER(a.hostname) LIKE (ac.mask) LEFT JOIN {users} u ON a.uid = u.uid GROUP BY a.hostname, a.uid, u.name, ac.aid". tablesort_sql($header);  $sql_cnt = "SELECT COUNT(DISTINCT(CONCAT(uid, hostname))) FROM {accesslog}";  $result = pager_query($sql, 30, 0, $sql_cnt);  $rows = array();  while ($account = db_fetch_object($result)) {    $qs = drupal_get_destination();    $ban_link = $account->aid ? l(t('unban'), "admin/user/rules/delete/$account->aid", array('query' => $qs)) : l(t('ban'), "admin/user/rules/add/$account->hostname/host", array('query' => $qs));    $rows[] = array($account->hits, ($account->uid ? theme('username', $account) : $account->hostname), format_interval(round($account->total / 1000)), $ban_link);  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 4));  }  drupal_set_title(t('Top visitors in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; presents the "referrer" page. */function statistics_top_referrers() {  $query = "SELECT url, COUNT(url) AS hits, MAX(timestamp) AS last FROM {accesslog} WHERE url NOT LIKE '%%%s%%' AND url <> '' GROUP BY url";  $query_cnt = "SELECT COUNT(DISTINCT(url)) FROM {accesslog} WHERE url <> '' AND url NOT LIKE '%%%s%%'";  drupal_set_title(t('Top referrers in the past %interval', array('%interval' => format_interval(variable_get('statistics_flush_accesslog_timer', 259200)))));  $header = array(    array('data' => t('Hits'), 'field' => 'hits', 'sort' => 'desc'),    array('data' => t('Url'), 'field' => 'url'),    array('data' => t('Last visit'), 'field' => 'last'),  );  $query .= tablesort_sql($header);  $result = pager_query($query, 30, 0, $query_cnt, $_SERVER['HTTP_HOST']);  $rows = array();  while ($referrer = db_fetch_object($result)) {    $rows[] = array($referrer->hits, _statistics_link($referrer->url), t('@time ago', array('@time' => format_interval(time() - $referrer->last))));  }  if (empty($rows)) {    $rows[] = array(array('data' => t('No statistics available.'), 'colspan' => 3));  }  $output = theme('table', $header, $rows);  $output .= theme('pager', NULL, 30, 0);  return $output;}/** * Menu callback; Displays recent page accesses. */function statistics_access_log($aid) {  $result = db_query('SELECT a.*, u.name FROM {accesslog} a LEFT JOIN {users} u ON a.uid = u.uid WHERE aid = %d', $aid);  if ($access = db_fetch_object($result)) {    $rows[] = array(      array('data' => t('URL'), 'header' => TRUE),      l(url($access->path, array('absolute' => TRUE)), $access->path)    );    // It is safe to avoid filtering $access->title through check_plain because    // it comes from drupal_get_title().    $rows[] = array(      array('data' => t('Title'), 'header' => TRUE),      $access->title    );    $rows[] = array(      array('data' => t('Referrer'), 'header' => TRUE),      ($access->url ? l($access->url, $access->url) : '')    );    $rows[] = array(      array('data' => t('Date'), 'header' => TRUE),      format_date($access->timestamp, 'large')    );    $rows[] = array(      array('data' => t('User'), 'header' => TRUE),      theme('username', $access)    );    $rows[] = array(      array('data' => t('Hostname'), 'header' => TRUE),      check_plain($access->hostname)    );    return theme('table', array(), $rows);  }  else {    drupal_not_found();  }}/** * Form builder; Configure access logging. * * @ingroup forms * @see system_settings_form() */function statistics_access_logging_settings() {  // Access log settings:  $options = array('1' => t('Enabled'), '0' => t('Disabled'));  $form['access'] = array(    '#type' => 'fieldset',    '#title' => t('Access log settings'));  $form['access']['statistics_enable_access_log'] = array(    '#type' => 'radios',    '#title' => t('Enable access log'),    '#default_value' => variable_get('statistics_enable_access_log', 0),    '#options' => $options,    '#description' => t('Log each page access. Required for referrer statistics.'));  $period = drupal_map_assoc(array(3600, 10800, 21600, 32400, 43200, 86400, 172800, 259200, 604800, 1209600, 2419200, 4838400, 9676800), 'format_interval');  $form['access']['statistics_flush_accesslog_timer'] = array(    '#type' => 'select',    '#title' => t('Discard access logs older than'),    '#default_value'   => variable_get('statistics_flush_accesslog_timer', 259200),    '#options' => $period,    '#description' => t('Older access log entries (including referrer statistics) will be automatically discarded. (Requires a correctly configured <a href="@cron">cron maintenance task</a>.)', array('@cron' => url('admin/reports/status'))));  // count content views settings  $form['content'] = array(    '#type' => 'fieldset',    '#title' => t('Content viewing counter settings'));  $form['content']['statistics_count_content_views'] = array(    '#type' => 'radios',    '#title' => t('Count content views'),    '#default_value' => variable_get('statistics_count_content_views', 0),    '#options' => $options,    '#description' => t('Increment a counter each time content is viewed.'));  return system_settings_form($form);}
<?php// $Id$/** * @file * Common functions that many Drupal modules will need to reference. * * The functions that are critical and need to be available even when serving * a cached page are instead located in bootstrap.inc. *//** * Return status for saving which involved creating a new item. */define('SAVED_NEW', 1);/** * Return status for saving which involved an update to an existing item. */define('SAVED_UPDATED', 2);/** * Return status for saving which deleted an existing item. */define('SAVED_DELETED', 3);/** * Create E_DEPRECATED constant for older PHP versions (<5.3). */if (!defined('E_DEPRECATED')) {  define('E_DEPRECATED', 8192);}/** * Set content for a specified region. * * @param $region *   Page region the content is assigned to. * @param $data *   Content to be set. */function drupal_set_content($region = NULL, $data = NULL) {  static $content = array();  if (!is_null($region) && !is_null($data)) {    $content[$region][] = $data;  }  return $content;}/** * Get assigned content. * * @param $region *   A specified region to fetch content for. If NULL, all regions will be *   returned. * @param $delimiter *   Content to be inserted between imploded array elements. */function drupal_get_content($region = NULL, $delimiter = ' ') {  $content = drupal_set_content();  if (isset($region)) {    if (isset($content[$region]) && is_array($content[$region])) {      return implode($delimiter, $content[$region]);    }  }  else {    foreach (array_keys($content) as $region) {      if (is_array($content[$region])) {        $content[$region] = implode($delimiter, $content[$region]);      }    }    return $content;  }}/** * Set the breadcrumb trail for the current page. * * @param $breadcrumb *   Array of links, starting with "home" and proceeding up to but not including *   the current page. */function drupal_set_breadcrumb($breadcrumb = NULL) {  static $stored_breadcrumb;  if (!is_null($breadcrumb)) {    $stored_breadcrumb = $breadcrumb;  }  return $stored_breadcrumb;}/** * Get the breadcrumb trail for the current page. */function drupal_get_breadcrumb() {  $breadcrumb = drupal_set_breadcrumb();  if (is_null($breadcrumb)) {    $breadcrumb = menu_get_active_breadcrumb();  }  return $breadcrumb;}/** * Add output to the head tag of the HTML page. * * This function can be called as long the headers aren't sent. */function drupal_set_html_head($data = NULL) {  static $stored_head = '';  if (!is_null($data)) {    $stored_head .= $data ."\n";  }  return $stored_head;}/** * Retrieve output to be displayed in the head tag of the HTML page. */function drupal_get_html_head() {  $output = "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n";  return $output . drupal_set_html_head();}/** * Reset the static variable which holds the aliases mapped for this request. */function drupal_clear_path_cache() {  drupal_lookup_path('wipe');}/** * Set an HTTP response header for the current page. * * Note: When sending a Content-Type header, always include a 'charset' type, * too. This is necessary to avoid security bugs (e.g. UTF-7 XSS). */function drupal_set_header($header = NULL) {  // We use an array to guarantee there are no leading or trailing delimiters.  // Otherwise, header('') could get called when serving the page later, which  // ends HTTP headers prematurely on some PHP versions.  static $stored_headers = array();  if (strlen($header)) {    header($header);    $stored_headers[] = $header;  }  return implode("\n", $stored_headers);}/** * Get the HTTP response headers for the current page. */function drupal_get_headers() {  return drupal_set_header();}/** * Make any final alterations to the rendered xhtml. */function drupal_final_markup($content) {  // Make sure that the charset is always specified as the first element of the  // head region to prevent encoding-based attacks.  return preg_replace('/<head[^>]*>/i', "\$0\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />", $content, 1);}/** * Add a feed URL for the current page. * * @param $url *   A url for the feed. * @param $title *   The title of the feed. */function drupal_add_feed($url = NULL, $title = '') {  static $stored_feed_links = array();  if (!is_null($url) && !isset($stored_feed_links[$url])) {    $stored_feed_links[$url] = theme('feed_icon', $url, $title);    drupal_add_link(array('rel' => 'alternate',                          'type' => 'application/rss+xml',                          'title' => $title,                          'href' => $url));  }  return $stored_feed_links;}/** * Get the feed URLs for the current page. * * @param $delimiter *   A delimiter to split feeds by. */function drupal_get_feeds($delimiter = "\n") {  $feeds = drupal_add_feed();  return implode($feeds, $delimiter);}/** * @name HTTP handling * @{ * Functions to properly handle HTTP responses. *//** * Parse an array into a valid urlencoded query string. * * @param $query *   The array to be processed e.g. $_GET. * @param $exclude *   The array filled with keys to be excluded. Use parent[child] to exclude *   nested items. * @param $parent *   Should not be passed, only used in recursive calls. * @return *   An urlencoded string which can be appended to/as the URL query string. */function drupal_query_string_encode($query, $exclude = array(), $parent = '') {  $params = array();  foreach ($query as $key => $value) {    $key = rawurlencode($key);    if ($parent) {      $key = $parent .'['. $key .']';    }    if (in_array($key, $exclude)) {      continue;    }    if (is_array($value)) {      $params[] = drupal_query_string_encode($value, $exclude, $key);    }    else {      $params[] = $key .'='. rawurlencode($value);    }  }  return implode('&', $params);}/** * Prepare a destination query string for use in combination with drupal_goto(). * * Used to direct the user back to the referring page after completing a form. * By default the current URL is returned. If a destination exists in the * previous request, that destination is returned. As such, a destination can * persist across multiple pages. * * @see drupal_goto() */function drupal_get_destination() {  if (isset($_REQUEST['destination'])) {    return 'destination='. urlencode($_REQUEST['destination']);  }  else {    // Use $_GET here to retrieve the original path in source form.    $path = isset($_GET['q']) ? $_GET['q'] : '';    $query = drupal_query_string_encode($_GET, array('q'));    if ($query != '') {      $path .= '?'. $query;    }    return 'destination='. urlencode($path);  }}/** * Send the user to a different Drupal page. * * This issues an on-site HTTP redirect. The function makes sure the redirected * URL is formatted correctly. * * Usually the redirected URL is constructed from this function's input * parameters. However you may override that behavior by setting a * destination in either the $_REQUEST-array (i.e. by using * the query string of an URI) or the $_REQUEST['edit']-array (i.e. by * using a hidden form field). This is used to direct the user back to * the proper page after completing a form. For example, after editing * a post on the 'admin/content/node'-page or after having logged on using the * 'user login'-block in a sidebar. The function drupal_get_destination() * can be used to help set the destination URL. * * Drupal will ensure that messages set by drupal_set_message() and other * session data are written to the database before the user is redirected. * * This function ends the request; use it rather than a print theme('page') * statement in your menu callback. * * @param $path *   A Drupal path or a full URL. * @param $query *   A query string component, if any. * @param $fragment *   A destination fragment identifier (named anchor). * @param $http_response_code *   Valid values for an actual "goto" as per RFC 2616 section 10.3 are: *   - 301 Moved Permanently (the recommended value for most redirects) *   - 302 Found (default in Drupal and PHP, sometimes used for spamming search *         engines) *   - 303 See Other *   - 304 Not Modified *   - 305 Use Proxy *   - 307 Temporary Redirect (alternative to "503 Site Down for Maintenance") *   Note: Other values are defined by RFC 2616, but are rarely used and poorly *   supported. * @see drupal_get_destination() */function drupal_goto($path = '', $query = NULL, $fragment = NULL, $http_response_code = 302) {  $destination = FALSE;  if (isset($_REQUEST['destination'])) {    $destination = $_REQUEST['destination'];  }  else if (isset($_REQUEST['edit']['destination'])) {    $destination = $_REQUEST['edit']['destination'];  }  if ($destination) {    // Do not redirect to an absolute URL originating from user input.    $colonpos = strpos($destination, ':');    $absolute = ($colonpos !== FALSE && !preg_match('![/?#]!', substr($destination, 0, $colonpos)));    if (!$absolute) {      extract(parse_url(urldecode($destination)));    }  }  $url = url($path, array('query' => $query, 'fragment' => $fragment, 'absolute' => TRUE));  // Remove newlines from the URL to avoid header injection attacks.  $url = str_replace(array("\n", "\r"), '', $url);  // Allow modules to react to the end of the page request before redirecting.  // We do not want this while running update.php.  if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {    module_invoke_all('exit', $url);  }  // Even though session_write_close() is registered as a shutdown function, we  // need all session data written to the database before redirecting.  session_write_close();  header('Location: '. $url, TRUE, $http_response_code);  // The "Location" header sends a redirect status code to the HTTP daemon. In  // some cases this can be wrong, so we make sure none of the code below the  // drupal_goto() call gets executed upon redirection.  exit();}/** * Generates a site off-line message. */function drupal_site_offline() {  drupal_maintenance_theme();  drupal_set_header('HTTP/1.1 503 Service unavailable');  drupal_set_title(t('Site off-line'));  print theme('maintenance_page', filter_xss_admin(variable_get('site_offline_message',    t('@site is currently under maintenance. We should be back shortly. Thank you for your patience.', array('@site' => variable_get('site_name', 'Drupal'))))));}/** * Generates a 404 error if the request can not be handled. */function drupal_not_found() {  drupal_set_header('HTTP/1.1 404 Not Found');  watchdog('page not found', check_plain($_GET['q']), NULL, WATCHDOG_WARNING);  // Keep old path for reference, and to allow forms to redirect to it.  if (!isset($_REQUEST['destination'])) {    $_REQUEST['destination'] = $_GET['q'];  }  $path = drupal_get_normal_path(variable_get('site_404', ''));  if ($path && $path != $_GET['q']) {    // Set the active item in case there are tabs to display, or other    // dependencies on the path.    menu_set_active_item($path);    $return = menu_execute_active_handler($path);  }  if (empty($return) || $return == MENU_NOT_FOUND || $return == MENU_ACCESS_DENIED) {    drupal_set_title(t('Page not found'));    $return = t('The requested page could not be found.');  }  // To conserve CPU and bandwidth, omit the blocks.  print theme('page', $return, FALSE);}/** * Generates a 403 error if the request is not allowed. */function drupal_access_denied() {  drupal_set_header('HTTP/1.1 403 Forbidden');  watchdog('access denied', check_plain($_GET['q']), NULL, WATCHDOG_WARNING);  // Keep old path for reference, and to allow forms to redirect to it.  if (!isset($_REQUEST['destination'])) {    $_REQUEST['destination'] = $_GET['q'];  }  $path = drupal_get_normal_path(variable_get('site_403', ''));  if ($path && $path != $_GET['q']) {    // Set the active item in case there are tabs to display or other    // dependencies on the path.    menu_set_active_item($path);    $return = menu_execute_active_handler($path);  }  if (empty($return) || $return == MENU_NOT_FOUND || $return == MENU_ACCESS_DENIED) {    drupal_set_title(t('Access denied'));    $return = t('You are not authorized to access this page.');  }  print theme('page', $return);}/** * Perform an HTTP request. * * This is a flexible and powerful HTTP client implementation. Correctly handles * GET, POST, PUT or any other HTTP requests. Handles redirects. * * @param $url *   A string containing a fully qualified URI. * @param $headers *   An array containing an HTTP header => value pair. * @param $method *   A string defining the HTTP request to use. * @param $data *   A string containing data to include in the request. * @param $retry *   An integer representing how many times to retry the request in case of a *   redirect. * @return *   An object containing the HTTP request headers, response code, headers, *   data and redirect status. */function drupal_http_request($url, $headers = array(), $method = 'GET', $data = NULL, $retry = 3) {  global $db_prefix;  $result = new stdClass();  // Parse the URL and make sure we can handle the schema.  $uri = parse_url($url);  if ($uri == FALSE) {    $result->error = 'unable to parse URL';    $result->code = -1001;    return $result;  }  if (!isset($uri['scheme'])) {    $result->error = 'missing schema';    $result->code = -1002;    return $result;  }  switch ($uri['scheme']) {    case 'http':      $port = isset($uri['port']) ? $uri['port'] : 80;      $host = $uri['host'] . ($port != 80 ? ':'. $port : '');      $fp = @fsockopen($uri['host'], $port, $errno, $errstr, 15);      break;    case 'https':      // Note: Only works for PHP 4.3 compiled with OpenSSL.      $port = isset($uri['port']) ? $uri['port'] : 443;      $host = $uri['host'] . ($port != 443 ? ':'. $port : '');      $fp = @fsockopen('ssl://'. $uri['host'], $port, $errno, $errstr, 20);      break;    default:      $result->error = 'invalid schema '. $uri['scheme'];      $result->code = -1003;      return $result;  }  // Make sure the socket opened properly.  if (!$fp) {    // When a network error occurs, we use a negative number so it does not    // clash with the HTTP status codes.    $result->code = -$errno;    $result->error = trim($errstr);    // Mark that this request failed. This will trigger a check of the web    // server's ability to make outgoing HTTP requests the next time that    // requirements checking is performed.    // @see system_requirements()    variable_set('drupal_http_request_fails', TRUE);    return $result;  }  // Construct the path to act on.  $path = isset($uri['path']) ? $uri['path'] : '/';  if (isset($uri['query'])) {    $path .= '?'. $uri['query'];  }  // Create HTTP request.  $defaults = array(    // RFC 2616: "non-standard ports MUST, default ports MAY be included".    // We don't add the port to prevent from breaking rewrite rules checking the    // host that do not take into account the port number.    'Host' => "Host: $host",    'User-Agent' => 'User-Agent: Drupal (+http://drupal.org/)',  );  // Only add Content-Length if we actually have any content or if it is a POST  // or PUT request. Some non-standard servers get confused by Content-Length in  // at least HEAD/GET requests, and Squid always requires Content-Length in  // POST/PUT requests.  $content_length = strlen($data);  if ($content_length > 0 || $method == 'POST' || $method == 'PUT') {    $defaults['Content-Length'] = 'Content-Length: '. $content_length;  }  // If the server url has a user then attempt to use basic authentication  if (isset($uri['user'])) {    $defaults['Authorization'] = 'Authorization: Basic '. base64_encode($uri['user'] . (!empty($uri['pass']) ? ":". $uri['pass'] : ''));  }  // If the database prefix is being used by SimpleTest to run the tests in a copied  // database then set the user-agent header to the database prefix so that any  // calls to other Drupal pages will run the SimpleTest prefixed database. The  // user-agent is used to ensure that multiple testing sessions running at the  // same time won't interfere with each other as they would if the database  // prefix were stored statically in a file or database variable.  if (is_string($db_prefix) && preg_match("/^simpletest\d+$/", $db_prefix, $matches)) {    $defaults['User-Agent'] = 'User-Agent: ' . $matches[0];  }  foreach ($headers as $header => $value) {    $defaults[$header] = $header .': '. $value;  }  $request = $method .' '. $path ." HTTP/1.0\r\n";  $request .= implode("\r\n", $defaults);  $request .= "\r\n\r\n";  $request .= $data;  $result->request = $request;  fwrite($fp, $request);  // Fetch response.  $response = '';  while (!feof($fp) && $chunk = fread($fp, 1024)) {    $response .= $chunk;  }  fclose($fp);  // Parse response.  list($split, $result->data) = explode("\r\n\r\n", $response, 2);  $split = preg_split("/\r\n|\n|\r/", $split);  list($protocol, $code, $text) = explode(' ', trim(array_shift($split)), 3);  $result->headers = array();  // Parse headers.  while ($line = trim(array_shift($split))) {    list($header, $value) = explode(':', $line, 2);    if (isset($result->headers[$header]) && $header == 'Set-Cookie') {      // RFC 2109: the Set-Cookie response header comprises the token Set-      // Cookie:, followed by a comma-separated list of one or more cookies.      $result->headers[$header] .= ','. trim($value);    }    else {      $result->headers[$header] = trim($value);    }  }  $responses = array(    100 => 'Continue', 101 => 'Switching Protocols',    200 => 'OK', 201 => 'Created', 202 => 'Accepted', 203 => 'Non-Authoritative Information', 204 => 'No Content', 205 => 'Reset Content', 206 => 'Partial Content',    300 => 'Multiple Choices', 301 => 'Moved Permanently', 302 => 'Found', 303 => 'See Other', 304 => 'Not Modified', 305 => 'Use Proxy', 307 => 'Temporary Redirect',    400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Time-out', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 413 => 'Request Entity Too Large', 414 => 'Request-URI Too Large', 415 => 'Unsupported Media Type', 416 => 'Requested range not satisfiable', 417 => 'Expectation Failed',    500 => 'Internal Server Error', 501 => 'Not Implemented', 502 => 'Bad Gateway', 503 => 'Service Unavailable', 504 => 'Gateway Time-out', 505 => 'HTTP Version not supported'  );  // RFC 2616 states that all unknown HTTP codes must be treated the same as the  // base code in their class.  if (!isset($responses[$code])) {    $code = floor($code / 100) * 100;  }  switch ($code) {    case 200: // OK    case 304: // Not modified      break;    case 301: // Moved permanently    case 302: // Moved temporarily    case 307: // Moved temporarily      $location = $result->headers['Location'];      if ($retry) {        $result = drupal_http_request($result->headers['Location'], $headers, $method, $data, --$retry);        $result->redirect_code = $result->code;      }      $result->redirect_url = $location;      break;    default:      $result->error = $text;  }  $result->code = $code;  return $result;}/** * @} End of "HTTP handling". *//** * Log errors as defined by administrator. * * Error levels: * - 0 = Log errors to database. * - 1 = Log errors to database and to screen. */function drupal_error_handler($errno, $message, $filename, $line, $context) {  // If the @ error suppression operator was used, error_reporting will have  // been temporarily set to 0.  if (error_reporting() == 0) {    return;  }  if ($errno & (E_ALL ^ E_DEPRECATED ^ E_NOTICE)) {    $types = array(1 => 'error', 2 => 'warning', 4 => 'parse error', 8 => 'notice', 16 => 'core error', 32 => 'core warning', 64 => 'compile error', 128 => 'compile warning', 256 => 'user error', 512 => 'user warning', 1024 => 'user notice', 2048 => 'strict warning', 4096 => 'recoverable fatal error');    // For database errors, we want the line number/file name of the place that    // the query was originally called, not _db_query().    if (isset($context[DB_ERROR])) {      $backtrace = array_reverse(debug_backtrace());      // List of functions where SQL queries can originate.      $query_functions = array('db_query', 'pager_query', 'db_query_range', 'db_query_temporary', 'update_sql');      // Determine where query function was called, and adjust line/file      // accordingly.      foreach ($backtrace as $index => $function) {        if (in_array($function['function'], $query_functions)) {          $line = $backtrace[$index]['line'];          $filename = $backtrace[$index]['file'];          break;        }      }    }    $entry = $types[$errno] .': '. $message .' in '. $filename .' on line '. $line .'.';    // Force display of error messages in update.php.    if (variable_get('error_level', 1) == 1 || strstr($_SERVER['SCRIPT_NAME'], 'update.php')) {      drupal_set_message($entry, 'error');    }    watchdog('php', '%message in %file on line %line.', array('%error' => $types[$errno], '%message' => $message, '%file' => $filename, '%line' => $line), WATCHDOG_ERROR);  }}function _fix_gpc_magic(&$item) {  if (is_array($item)) {    array_walk($item, '_fix_gpc_magic');  }  else {    $item = stripslashes($item);  }}/** * Helper function to strip slashes from $_FILES skipping over the tmp_name keys * since PHP generates single backslashes for file paths on Windows systems. * * tmp_name does not have backslashes added see * http://php.net/manual/en/features.file-upload.php#42280 */function _fix_gpc_magic_files(&$item, $key) {  if ($key != 'tmp_name') {    if (is_array($item)) {      array_walk($item, '_fix_gpc_magic_files');    }    else {      $item = stripslashes($item);    }  }}/** * Fix double-escaping problems caused by "magic quotes" in some PHP installations. */function fix_gpc_magic() {  static $fixed = FALSE;  if (!$fixed && ini_get('magic_quotes_gpc')) {    array_walk($_GET, '_fix_gpc_magic');    array_walk($_POST, '_fix_gpc_magic');    array_walk($_COOKIE, '_fix_gpc_magic');    array_walk($_REQUEST, '_fix_gpc_magic');    array_walk($_FILES, '_fix_gpc_magic_files');    $fixed = TRUE;  }}/** * Translate strings to the page language or a given language. * * Human-readable text that will be displayed somewhere within a page should * be run through the t() function. * * Examples: * @code *   if (!$info || !$info['extension']) { *     form_set_error('picture_upload', t('The uploaded file was not an image.')); *   } * *   $form['submit'] = array( *     '#type' => 'submit', *     '#value' => t('Log in'), *   ); * @endcode * * Any text within t() can be extracted by translators and changed into * the equivalent text in their native language. * * Special variables called "placeholders" are used to signal dynamic * information in a string which should not be translated. Placeholders * can also be used for text that may change from time to time (such as * link paths) to be changed without requiring updates to translations. * * For example: * @code *   $output = t('There are currently %members and %visitors online.', array( *     '%members' => format_plural($total_users, '1 user', '@count users'), *     '%visitors' => format_plural($guests->count, '1 guest', '@count guests'))); * @endcode * * There are three styles of placeholders: * - !variable, which indicates that the text should be inserted as-is. This is *   useful for inserting variables into things like e-mail. *   @code *     $message[] = t("If you don't want to receive such e-mails, you can change your settings at !url.", array('!url' => url("user/$account->uid", array('absolute' => TRUE)))); *   @endcode * * - @variable, which indicates that the text should be run through *   check_plain, to escape HTML characters. Use this for any output that's *   displayed within a Drupal page. *   @code *     drupal_set_title($title = t("@name's blog", array('@name' => $account->name))); *   @endcode * * - %variable, which indicates that the string should be HTML escaped and *   highlighted with theme_placeholder() which shows up by default as *   <em>emphasized</em>. *   @code *     $message = t('%name-from sent %name-to an e-mail.', array('%name-from' => $user->name, '%name-to' => $account->name)); *   @endcode * * When using t(), try to put entire sentences and strings in one t() call. * This makes it easier for translators, as it provides context as to what * each word refers to. HTML markup within translation strings is allowed, but * should be avoided if possible. The exception are embedded links; link * titles add a context for translators, so should be kept in the main string. * * Here is an example of incorrect usage of t(): * @code *   $output .= t('<p>Go to the @contact-page.</p>', array('@contact-page' => l(t('contact page'), 'contact'))); * @endcode * * Here is an example of t() used correctly: * @code *   $output .= '<p>'. t('Go to the <a href="@contact-page">contact page</a>.', array('@contact-page' => url('contact'))) .'</p>'; * @endcode * * Avoid escaping quotation marks wherever possible. * * Incorrect: * @code *   $output .= t('Don\'t click me.'); * @endcode * * Correct: * @code *   $output .= t("Don't click me."); * @endcode * * Because t() is designed for handling code-based strings, in almost all * cases, the actual string and not a variable must be passed through t(). * * Extraction of translations is done based on the strings contained in t() * calls. If a variable is passed through t(), the content of the variable * cannot be extracted from the file for translation. * * Incorrect: * @code *   $message = 'An error occurred.'; *   drupal_set_message(t($message), 'error'); *   $output .= t($message); * @endcode * * Correct: * @code *   $message = t('An error occurred.'); *   drupal_set_message($message, 'error'); *   $output .= $message; * @endcode * * The only case in which variables can be passed safely through t() is when * code-based versions of the same strings will be passed through t() (or * otherwise extracted) elsewhere. * * In some cases, modules may include strings in code that can't use t() * calls. For example, a module may use an external PHP application that * produces strings that are loaded into variables in Drupal for output. * In these cases, module authors may include a dummy file that passes the * relevant strings through t(). This approach will allow the strings to be * extracted. * * Sample external (non-Drupal) code: * @code *   class Time { *     public $yesterday = 'Yesterday'; *     public $today = 'Today'; *     public $tomorrow = 'Tomorrow'; *   } * @endcode * * Sample dummy file. * @code *   // Dummy function included in example.potx.inc. *   function example_potx() { *     $strings = array( *       t('Yesterday'), *       t('Today'), *       t('Tomorrow'), *     ); *     // No return value needed, since this is a dummy function. *   } * @endcode * * Having passed strings through t() in a dummy function, it is then * okay to pass variables through t(). * * Correct (if a dummy file was used): * @code *   $time = new Time(); *   $output .= t($time->today); * @endcode * * However tempting it is, custom data from user input or other non-code * sources should not be passed through t(). Doing so leads to the following * problems and errors: *  - The t() system doesn't support updates to existing strings. When user *    data is updated, the next time it's passed through t() a new record is *    created instead of an update. The database bloats over time and any *    existing translations are orphaned with each update. *  - The t() system assumes any data it receives is in English. User data may *    be in another language, producing translation errors. *  - The "Built-in interface" text group in the locale system is used to *    produce translations for storage in .po files. When non-code strings are *    passed through t(), they are added to this text group, which is rendered *    inaccurate since it is a mix of actual interface strings and various user *    input strings of uncertain origin. * * Incorrect: * @code *   $item = item_load(); *   $output .= check_plain(t($item['title'])); * @endcode * * Instead, translation of these data can be done through the locale system, * either directly or through helper functions provided by contributed * modules. * @see hook_locale() * * During installation, st() is used in place of t(). Code that may be called * during installation or during normal operation should use the get_t() * helper function. * @see st() * @see get_t() * * @param $string *   A string containing the English string to translate. * @param $args *   An associative array of replacements to make after translation. Incidences *   of any key in this array are replaced with the corresponding value. Based *   on the first character of the key, the value is escaped and/or themed: *    - !variable: inserted as is *    - @variable: escape plain text to HTML (check_plain) *    - %variable: escape text and theme as a placeholder for user-submitted *      content (check_plain + theme_placeholder) * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   The translated string. */function t($string, $args = array(), $langcode = NULL) {  global $language;  static $custom_strings;  $langcode = isset($langcode) ? $langcode : $language->language;  // First, check for an array of customized strings. If present, use the array  // *instead of* database lookups. This is a high performance way to provide a  // handful of string replacements. See settings.php for examples.  // Cache the $custom_strings variable to improve performance.  if (!isset($custom_strings[$langcode])) {    $custom_strings[$langcode] = variable_get('locale_custom_strings_'. $langcode, array());  }  // Custom strings work for English too, even if locale module is disabled.  if (isset($custom_strings[$langcode][$string])) {    $string = $custom_strings[$langcode][$string];  }  // Translate with locale module if enabled.  elseif (function_exists('locale') && $langcode != 'en') {    $string = locale($string, $langcode);  }  if (empty($args)) {    return $string;  }  else {    // Transform arguments before inserting them.    foreach ($args as $key => $value) {      switch ($key[0]) {        case '@':          // Escaped only.          $args[$key] = check_plain($value);          break;        case '%':        default:          // Escaped and placeholder.          $args[$key] = theme('placeholder', $value);          break;        case '!':          // Pass-through.      }    }    return strtr($string, $args);  }}/** * @defgroup validation Input validation * @{ * Functions to validate user input. *//** * Verify the syntax of the given e-mail address. * * Empty e-mail addresses are allowed. See RFC 2822 for details. * * @param $mail *   A string containing an e-mail address. * @return *   TRUE if the address is in a valid format. */function valid_email_address($mail) {  $user = '[a-zA-Z0-9_\-\.\+\^!#\$%&*+\/\=\?\`\|\{\}~\']+';  $domain = '(?:(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.?)+';  $ipv4 = '[0-9]{1,3}(\.[0-9]{1,3}){3}';  $ipv6 = '[0-9a-fA-F]{1,4}(\:[0-9a-fA-F]{1,4}){7}';  return preg_match("/^$user@($domain|(\[($ipv4|$ipv6)\]))$/", $mail);}/** * Verify the syntax of the given URL. * * This function should only be used on actual URLs. It should not be used for * Drupal menu paths, which can contain arbitrary characters. * Valid values per RFC 3986. * * @param $url *   The URL to verify. * @param $absolute *   Whether the URL is absolute (beginning with a scheme such as "http:"). * @return *   TRUE if the URL is in a valid format. */function valid_url($url, $absolute = FALSE) {  if ($absolute) {    return (bool)preg_match("      /^                                                      # Start at the beginning of the text      (?:ftp|https?):\/\/                                     # Look for ftp, http, or https schemes      (?:                                                     # Userinfo (optional) which is typically        (?:(?:[\w\.\-\+!$&'\(\)*\+,;=]|%[0-9a-f]{2})+:)*      # a username or a username and password        (?:[\w\.\-\+%!$&'\(\)*\+,;=]|%[0-9a-f]{2})+@          # combination      )?      (?:        (?:[a-z0-9\-\.]|%[0-9a-f]{2})+                        # A domain name or a IPv4 address        |(?:\[(?:[0-9a-f]{0,4}:)*(?:[0-9a-f]{0,4})\])         # or a well formed IPv6 address      )      (?::[0-9]+)?                                            # Server port number (optional)      (?:[\/|\?]        (?:[\w#!:\.\?\+=&@$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})   # The path and query (optional)      *)?    $/xi", $url);  }  else {    return (bool)preg_match("/^(?:[\w#!:\.\?\+=&@$'~*,;\/\(\)\[\]\-]|%[0-9a-f]{2})+$/i", $url);  }}/** * @} End of "defgroup validation". *//** * Register an event for the current visitor (hostname/IP) to the flood control mechanism. * * @param $name *   The name of an event. */function flood_register_event($name) {  db_query("INSERT INTO {flood} (event, hostname, timestamp) VALUES ('%s', '%s', %d)", $name, ip_address(), time());}/** * Check if the current visitor (hostname/IP) is allowed to proceed with the specified event. * * The user is allowed to proceed if he did not trigger the specified event more * than $threshold times per hour. * * @param $name *   The name of the event. * @param $threshold *   The maximum number of the specified event per hour (per visitor). * @return *   True if the user did not exceed the hourly threshold. False otherwise. */function flood_is_allowed($name, $threshold) {  $number = db_result(db_query("SELECT COUNT(*) FROM {flood} WHERE event = '%s' AND hostname = '%s' AND timestamp > %d", $name, ip_address(), time() - 3600));  return ($number < $threshold ? TRUE : FALSE);}function check_file($filename) {  return is_uploaded_file($filename);}/** * Prepare a URL for use in an HTML attribute. Strips harmful protocols. */function check_url($uri) {  return filter_xss_bad_protocol($uri, FALSE);}/** * @defgroup format Formatting * @{ * Functions to format numbers, strings, dates, etc. *//** * Formats an RSS channel. * * Arbitrary elements may be added using the $args associative array. */function format_rss_channel($title, $link, $description, $items, $langcode = NULL, $args = array()) {  global $language;  $langcode = $langcode ? $langcode : $language->language;  $output = "<channel>\n";  $output .= ' <title>'. check_plain($title) ."</title>\n";  $output .= ' <link>'. check_url($link) ."</link>\n";  // The RSS 2.0 "spec" doesn't indicate HTML can be used in the description.  // We strip all HTML tags, but need to prevent double encoding from properly  // escaped source data (such as &amp becoming &amp;amp;).  $output .= ' <description>'. check_plain(decode_entities(strip_tags($description))) ."</description>\n";  $output .= ' <language>'. check_plain($langcode) ."</language>\n";  $output .= format_xml_elements($args);  $output .= $items;  $output .= "</channel>\n";  return $output;}/** * Format a single RSS item. * * Arbitrary elements may be added using the $args associative array. */function format_rss_item($title, $link, $description, $args = array()) {  $output = "<item>\n";  $output .= ' <title>'. check_plain($title) ."</title>\n";  $output .= ' <link>'. check_url($link) ."</link>\n";  $output .= ' <description>'. check_plain($description) ."</description>\n";  $output .= format_xml_elements($args);  $output .= "</item>\n";  return $output;}/** * Format XML elements. * * @param $array *   An array where each item represent an element and is either a: *   - (key => value) pair (<key>value</key>) *   - Associative array with fields: *     - 'key': element name *     - 'value': element contents *     - 'attributes': associative array of element attributes * * In both cases, 'value' can be a simple string, or it can be another array * with the same format as $array itself for nesting. */function format_xml_elements($array) {  $output = '';  foreach ($array as $key => $value) {    if (is_numeric($key)) {      if ($value['key']) {        $output .= ' <'. $value['key'];        if (isset($value['attributes']) && is_array($value['attributes'])) {          $output .= drupal_attributes($value['attributes']);        }        if (isset($value['value']) && $value['value'] != '') {          $output .= '>'. (is_array($value['value']) ? format_xml_elements($value['value']) : check_plain($value['value'])) .'</'. $value['key'] .">\n";        }        else {          $output .= " />\n";        }      }    }    else {      $output .= ' <'. $key .'>'. (is_array($value) ? format_xml_elements($value) : check_plain($value)) ."</$key>\n";    }  }  return $output;}/** * Format a string containing a count of items. * * This function ensures that the string is pluralized correctly. Since t() is * called by this function, make sure not to pass already-localized strings to * it. * * For example: * @code *   $output = format_plural($node->comment_count, '1 comment', '@count comments'); * @endcode * * Example with additional replacements: * @code *   $output = format_plural($update_count, *     'Changed the content type of 1 post from %old-type to %new-type.', *     'Changed the content type of @count posts from %old-type to %new-type.', *     array('%old-type' => $info->old_type, '%new-type' => $info->new_type))); * @endcode * * @param $count *   The item count to display. * @param $singular *   The string for the singular case. Please make sure it is clear this is *   singular, to ease translation (e.g. use "1 new comment" instead of "1 new"). *   Do not use @count in the singular string. * @param $plural *   The string for the plural case. Please make sure it is clear this is plural, *   to ease translation. Use @count in place of the item count, as in "@count *   new comments". * @param $args *   An associative array of replacements to make after translation. Incidences *   of any key in this array are replaced with the corresponding value. *   Based on the first character of the key, the value is escaped and/or themed: *    - !variable: inserted as is *    - @variable: escape plain text to HTML (check_plain) *    - %variable: escape text and theme as a placeholder for user-submitted *      content (check_plain + theme_placeholder) *   Note that you do not need to include @count in this array. *   This replacement is done automatically for the plural case. * @param $langcode *   Optional language code to translate to a language other than *   what is used to display the page. * @return *   A translated string. */function format_plural($count, $singular, $plural, $args = array(), $langcode = NULL) {  $args['@count'] = $count;  if ($count == 1) {    return t($singular, $args, $langcode);  }  // Get the plural index through the gettext formula.  $index = (function_exists('locale_get_plural')) ? locale_get_plural($count, $langcode) : -1;  // Backwards compatibility.  if ($index < 0) {    return t($plural, $args, $langcode);  }  else {    switch ($index) {      case "0":        return t($singular, $args, $langcode);      case "1":        return t($plural, $args, $langcode);      default:        unset($args['@count']);        $args['@count['. $index .']'] = $count;        return t(strtr($plural, array('@count' => '@count['. $index .']')), $args, $langcode);    }  }}/** * Parse a given byte count. * * @param $size *   A size expressed as a number of bytes with optional SI size and unit *   suffix (e.g. 2, 3K, 5MB, 10G). * @return *   An integer representation of the size. */function parse_size($size) {  $suffixes = array(    '' => 1,    'k' => 1024,    'm' => 1048576, // 1024 * 1024    'g' => 1073741824, // 1024 * 1024 * 1024  );  if (preg_match('/([0-9]+)\s*(k|m|g)?(b?(ytes?)?)/i', $size, $match)) {    return $match[1] * $suffixes[drupal_strtolower($match[2])];  }}/** * Generate a string representation for the given byte count. * * @param $size *   A size in bytes. * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   A translated string representation of the size. */function format_size($size, $langcode = NULL) {  if ($size < 1024) {    return format_plural($size, '1 byte', '@count bytes', array(), $langcode);  }  else {    $size = round($size / 1024, 2);    $suffix = t('KB', array(), $langcode);    if ($size >= 1024) {      $size = round($size / 1024, 2);      $suffix = t('MB', array(), $langcode);    }    return t('@size @suffix', array('@size' => $size, '@suffix' => $suffix), $langcode);  }}/** * Format a time interval with the requested granularity. * * @param $timestamp *   The length of the interval in seconds. * @param $granularity *   How many different units to display in the string. * @param $langcode *   Optional language code to translate to a language other than *   what is used to display the page. * @return *   A translated string representation of the interval. */function format_interval($timestamp, $granularity = 2, $langcode = NULL) {  $units = array('1 year|@count years' => 31536000, '1 week|@count weeks' => 604800, '1 day|@count days' => 86400, '1 hour|@count hours' => 3600, '1 min|@count min' => 60, '1 sec|@count sec' => 1);  $output = '';  foreach ($units as $key => $value) {    $key = explode('|', $key);    if ($timestamp >= $value) {      $output .= ($output ? ' ' : '') . format_plural(floor($timestamp / $value), $key[0], $key[1], array(), $langcode);      $timestamp %= $value;      $granularity--;    }    if ($granularity == 0) {      break;    }  }  return $output ? $output : t('0 sec', array(), $langcode);}/** * Format a date with the given configured format or a custom format string. * * Drupal allows administrators to select formatting strings for 'small', * 'medium' and 'large' date formats. This function can handle these formats, * as well as any custom format. * * @param $timestamp *   The exact date to format, as a UNIX timestamp. * @param $type *   The format to use. Can be "small", "medium" or "large" for the preconfigured *   date formats. If "custom" is specified, then $format is required as well. * @param $format *   A PHP date format string as required by date(). A backslash should be used *   before a character to avoid interpreting the character as part of a date *   format. * @param $timezone *   Time zone offset in seconds; if omitted, the user's time zone is used. * @param $langcode *   Optional language code to translate to a language other than what is used *   to display the page. * @return *   A translated date string in the requested format. */function format_date($timestamp, $type = 'medium', $format = '', $timezone = NULL, $langcode = NULL) {  if (!isset($timezone)) {    global $user;    if (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone)) {      $timezone = $user->timezone;    }    else {      $timezone = variable_get('date_default_timezone', 0);    }  }  $timestamp += $timezone;  switch ($type) {    case 'small':      $format = variable_get('date_format_short', 'm/d/Y - H:i');      break;    case 'large':      $format = variable_get('date_format_long', 'l, F j, Y - H:i');      break;    case 'custom':      // No change to format.      break;    case 'medium':    default:      $format = variable_get('date_format_medium', 'D, m/d/Y - H:i');  }  $max = strlen($format);  $date = '';  for ($i = 0; $i < $max; $i++) {    $c = $format[$i];    if (strpos('AaDlM', $c) !== FALSE) {      $date .= t(gmdate($c, $timestamp), array(), $langcode);    }    else if ($c == 'F') {      // Special treatment for long month names: May is both an abbreviation      // and a full month name in English, but other languages have      // different abbreviations.      $date .= trim(t('!long-month-name '. gmdate($c, $timestamp), array('!long-month-name' => ''), $langcode));    }    else if (strpos('BdgGhHiIjLmnsStTUwWYyz', $c) !== FALSE) {      $date .= gmdate($c, $timestamp);    }    else if ($c == 'r') {      $date .= format_date($timestamp - $timezone, 'custom', 'D, d M Y H:i:s O', $timezone, $langcode);    }    else if ($c == 'O') {      $date .= sprintf('%s%02d%02d', ($timezone < 0 ? '-' : '+'), abs($timezone / 3600), abs($timezone % 3600) / 60);    }    else if ($c == 'Z') {      $date .= $timezone;    }    else if ($c == '\\') {      $date .= $format[++$i];    }    else {      $date .= $c;    }  }  return $date;}/** * @} End of "defgroup format". *//** * Generate a URL from a Drupal menu path. Will also pass-through existing URLs. * * @param $path *   The Drupal path being linked to, such as "admin/content/node", or an *   existing URL like "http://drupal.org/".  The special path *   '<front>' may also be given and will generate the site's base URL. * @param $options *   An associative array of additional options, with the following keys: *   - 'query' *       A URL-encoded query string to append to the link, or an array of query *       key/value-pairs without any URL-encoding. *   - 'fragment' *       A fragment identifier (or named anchor) to append to the link. *       Do not include the '#' character. *   - 'absolute' (default FALSE) *       Whether to force the output to be an absolute link (beginning with *       http:). Useful for links that will be displayed outside the site, such *       as in an RSS feed. *   - 'alias' (default FALSE) *       Whether the given path is an alias already. *   - 'external' *       Whether the given path is an external URL. *   - 'language' *       An optional language object. Used to build the URL to link to and *       look up the proper alias for the link. *   - 'base_url' *       Only used internally, to modify the base URL when a language dependent *       URL requires so. *   - 'prefix' *       Only used internally, to modify the path when a language dependent URL *       requires so. * @return *   A string containing a URL to the given path. * * When creating links in modules, consider whether l() could be a better * alternative than url(). */function url($path = NULL, $options = array()) {  // Merge in defaults.  $options += array(    'fragment' => '',    'query' => '',    'absolute' => FALSE,    'alias' => FALSE,    'prefix' => ''  );  if (!isset($options['external'])) {    // Return an external link if $path contains an allowed absolute URL.    // Only call the slow filter_xss_bad_protocol if $path contains a ':' before    // any / ? or #.    $colonpos = strpos($path, ':');    $options['external'] = ($colonpos !== FALSE && !preg_match('![/?#]!', substr($path, 0, $colonpos)) && filter_xss_bad_protocol($path, FALSE) == check_plain($path));  }  // May need language dependent rewriting if language.inc is present.  if (function_exists('language_url_rewrite')) {    language_url_rewrite($path, $options);  }  if ($options['fragment']) {    $options['fragment'] = '#'. $options['fragment'];  }  if (is_array($options['query'])) {    $options['query'] = drupal_query_string_encode($options['query']);  }  if ($options['external']) {    // Split off the fragment.    if (strpos($path, '#') !== FALSE) {      list($path, $old_fragment) = explode('#', $path, 2);      if (isset($old_fragment) && !$options['fragment']) {        $options['fragment'] = '#'. $old_fragment;      }    }    // Append the query.    if ($options['query']) {      $path .= (strpos($path, '?') !== FALSE ? '&' : '?') . $options['query'];    }    // Reassemble.    return $path . $options['fragment'];  }  global $base_url;  static $script;  if (!isset($script)) {    // On some web servers, such as IIS, we can't omit "index.php". So, we    // generate "index.php?q=foo" instead of "?q=foo" on anything that is not    // Apache.    $script = (strpos($_SERVER['SERVER_SOFTWARE'], 'Apache') === FALSE) ? 'index.php' : '';  }  if (!isset($options['base_url'])) {    // The base_url might be rewritten from the language rewrite in domain mode.    $options['base_url'] = $base_url;  }  // Preserve the original path before aliasing.  $original_path = $path;  // The special path '<front>' links to the default front page.  if ($path == '<front>') {    $path = '';  }  elseif (!empty($path) && !$options['alias']) {    $path = drupal_get_path_alias($path, isset($options['language']) ? $options['language']->language : '');  }  if (function_exists('custom_url_rewrite_outbound')) {    // Modules may alter outbound links by reference.    custom_url_rewrite_outbound($path, $options, $original_path);  }  $base = $options['absolute'] ? $options['base_url'] .'/' : base_path();  $prefix = empty($path) ? rtrim($options['prefix'], '/') : $options['prefix'];  $path = drupal_urlencode($prefix . $path);  if (variable_get('clean_url', '0')) {    // With Clean URLs.    if ($options['query']) {      return $base . $path .'?'. $options['query'] . $options['fragment'];    }    else {      return $base . $path . $options['fragment'];    }  }  else {    // Without Clean URLs.    $variables = array();    if (!empty($path)) {      $variables[] = 'q='. $path;    }    if (!empty($options['query'])) {      $variables[] = $options['query'];    }    if ($query = join('&', $variables)) {      return $base . $script .'?'. $query . $options['fragment'];    }    else {      return $base . $options['fragment'];    }  }}/** * Format an attribute string to insert in a tag. * * @param $attributes *   An associative array of HTML attributes. * @return *   An HTML string ready for insertion in a tag. */function drupal_attributes($attributes = array()) {  if (is_array($attributes)) {    $t = '';    foreach ($attributes as $key => $value) {      $t .= " $key=".'"'. check_plain($value) .'"';    }    return $t;  }}/** * Format an internal Drupal link. * * This function correctly handles aliased paths, and allows themes to highlight * links to the current page correctly, so all internal links output by modules * should be generated by this function if possible. * * @param $text *   The text to be enclosed with the anchor tag. * @param $path *   The Drupal path being linked to, such as "admin/content/node". Can be an *   external or internal URL. *     - If you provide the full URL, it will be considered an external URL. *     - If you provide only the path (e.g. "admin/content/node"), it is *       considered an internal link. In this case, it must be a system URL *       as the url() function will generate the alias. *     - If you provide '<front>', it generates a link to the site's *       base URL (again via the url() function). *     - If you provide a path, and 'alias' is set to TRUE (see below), it is *       used as is. * @param $options *   An associative array of additional options, with the following keys: *     - 'attributes' *       An associative array of HTML attributes to apply to the anchor tag. *     - 'query' *       A query string to append to the link, or an array of query key/value *       properties. *     - 'fragment' *       A fragment identifier (named anchor) to append to the link. *       Do not include the '#' character. *     - 'absolute' (default FALSE) *       Whether to force the output to be an absolute link (beginning with *       http:). Useful for links that will be displayed outside the site, such *       as in an RSS feed. *     - 'html' (default FALSE) *       Whether the title is HTML, or just plain-text. For example for making *       an image a link, this must be set to TRUE, or else you will see the *       escaped HTML. *     - 'alias' (default FALSE) *       Whether the given path is an alias already. * @return *   an HTML string containing a link to the given path. */function l($text, $path, $options = array()) {  global $language;  // Merge in defaults.  $options += array(      'attributes' => array(),      'html' => FALSE,    );  // Append active class.  if (($path == $_GET['q'] || ($path == '<front>' && drupal_is_front_page())) &&      (empty($options['language']) || $options['language']->language == $language->language)) {    if (isset($options['attributes']['class'])) {      $options['attributes']['class'] .= ' active';    }    else {      $options['attributes']['class'] = 'active';    }  }  // Remove all HTML and PHP tags from a tooltip. For best performance, we act only  // if a quick strpos() pre-check gave a suspicion (because strip_tags() is expensive).  if (isset($options['attributes']['title']) && strpos($options['attributes']['title'], '<') !== FALSE) {    $options['attributes']['title'] = strip_tags($options['attributes']['title']);  }  return '<a href="'. check_url(url($path, $options)) .'"'. drupal_attributes($options['attributes']) .'>'. ($options['html'] ? $text : check_plain($text)) .'</a>';}/** * Perform end-of-request tasks. * * This function sets the page cache if appropriate, and allows modules to * react to the closing of the page by calling hook_exit(). */function drupal_page_footer() {  if (variable_get('cache', CACHE_DISABLED) != CACHE_DISABLED) {    page_set_cache();  }  module_invoke_all('exit');}/** * Form an associative array from a linear array. * * This function walks through the provided array and constructs an associative * array out of it. The keys of the resulting array will be the values of the * input array. The values will be the same as the keys unless a function is * specified, in which case the output of the function is used for the values * instead. * * @param $array *   A linear array. * @param $function *   A name of a function to apply to all values before output. * @result *   An associative array. */function drupal_map_assoc($array, $function = NULL) {  if (!isset($function)) {    $result = array();    foreach ($array as $value) {      $result[$value] = $value;    }    return $result;  }  elseif (function_exists($function)) {    $result = array();    foreach ($array as $value) {      $result[$value] = $function($value);    }    return $result;  }}/** * Evaluate a string of PHP code. * * This is a wrapper around PHP's eval(). It uses output buffering to capture both * returned and printed text. Unlike eval(), we require code to be surrounded by * <?php ?> tags; in other words, we evaluate the code as if it were a stand-alone * PHP file. * * Using this wrapper also ensures that the PHP code which is evaluated can not * overwrite any variables in the calling code, unlike a regular eval() call. * * @param $code *   The code to evaluate. * @return *   A string containing the printed output of the code, followed by the returned *   output of the code. */function drupal_eval($code) {  global $theme_path, $theme_info, $conf;  // Store current theme path.  $old_theme_path = $theme_path;  // Restore theme_path to the theme, as long as drupal_eval() executes,  // so code evaluted will not see the caller module as the current theme.  // If theme info is not initialized get the path from theme_default.  if (!isset($theme_info)) {    $theme_path = drupal_get_path('theme', $conf['theme_default']);  }  else {    $theme_path = dirname($theme_info->filename);  }  ob_start();  print eval('?>'. $code);  $output = ob_get_contents();  ob_end_clean();  // Recover original theme path.  $theme_path = $old_theme_path;  return $output;}/** * Returns the path to a system item (module, theme, etc.). * * @param $type *   The type of the item (i.e. theme, theme_engine, module). * @param $name *   The name of the item for which the path is requested. * * @return *   The path to the requested item. */function drupal_get_path($type, $name) {  return dirname(drupal_get_filename($type, $name));}/** * Returns the base URL path of the Drupal installation. * At the very least, this will always default to /. */function base_path() {  return $GLOBALS['base_path'];}/** * Provide a substitute clone() function for PHP4. */function drupal_clone($object) {  return version_compare(phpversion(), '5.0') < 0 ? $object : clone($object);}/** * Add a <link> tag to the page's HEAD. */function drupal_add_link($attributes) {  drupal_set_html_head('<link'. drupal_attributes($attributes) .' />');}/** * Adds a CSS file to the stylesheet queue. * * @param $path *   (optional) The path to the CSS file relative to the base_path(), e.g., *   /modules/devel/devel.css. * *   Modules should always prefix the names of their CSS files with the module *   name, for example: system-menus.css rather than simply menus.css. Themes *   can override module-supplied CSS files based on their filenames, and this *   prefixing helps prevent confusing name collisions for theme developers. *   See drupal_get_css where the overrides are performed. * *   If the direction of the current language is right-to-left (Hebrew, *   Arabic, etc.), the function will also look for an RTL CSS file and append *   it to the list. The name of this file should have an '-rtl.css' suffix. *   For example a CSS file called 'name.css' will have a 'name-rtl.css' *   file added to the list, if exists in the same directory. This CSS file *   should contain overrides for properties which should be reversed or *   otherwise different in a right-to-left display. * @param $type *   (optional) The type of stylesheet that is being added. Types are: module *   or theme. * @param $media *   (optional) The media type for the stylesheet, e.g., all, print, screen. * @param $preprocess *   (optional) Should this CSS file be aggregated and compressed if this *   feature has been turned on under the performance section? * *   What does this actually mean? *   CSS preprocessing is the process of aggregating a bunch of separate CSS *   files into one file that is then compressed by removing all extraneous *   white space. * *   The reason for merging the CSS files is outlined quite thoroughly here: *   http://www.die.net/musings/page_load_time/ *   "Load fewer external objects. Due to request overhead, one bigger file *   just loads faster than two smaller ones half its size." * *   However, you should *not* preprocess every file as this can lead to *   redundant caches. You should set $preprocess = FALSE when: * *     - Your styles are only used rarely on the site. This could be a special *       admin page, the homepage, or a handful of pages that does not represent *       the majority of the pages on your site. * *   Typical candidates for caching are for example styles for nodes across *   the site, or used in the theme. * @return *   An array of CSS files. */function drupal_add_css($path = NULL, $type = 'module', $media = 'all', $preprocess = TRUE) {  static $css = array();  global $language;  // Create an array of CSS files for each media type first, since each type needs to be served  // to the browser differently.  if (isset($path)) {    // This check is necessary to ensure proper cascading of styles and is faster than an asort().    if (!isset($css[$media])) {      $css[$media] = array('module' => array(), 'theme' => array());    }    $css[$media][$type][$path] = $preprocess;    // If the current language is RTL, add the CSS file with RTL overrides.    if ($language->direction == LANGUAGE_RTL) {      $rtl_path = str_replace('.css', '-rtl.css', $path);      if (file_exists($rtl_path)) {        $css[$media][$type][$rtl_path] = $preprocess;      }    }  }  return $css;}/** * Returns a themed representation of all stylesheets that should be attached to the page. * * It loads the CSS in order, with 'module' first, then 'theme' afterwards. * This ensures proper cascading of styles so themes can easily override * module styles through CSS selectors. * * Themes may replace module-defined CSS files by adding a stylesheet with the * same filename. For example, themes/garland/system-menus.css would replace * modules/system/system-menus.css. This allows themes to override complete * CSS files, rather than specific selectors, when necessary. * * If the original CSS file is being overridden by a theme, the theme is * responsible for supplying an accompanying RTL CSS file to replace the * module's. * * @param $css *   (optional) An array of CSS files. If no array is provided, the default *   stylesheets array is used instead. * @return *   A string of XHTML CSS tags. */function drupal_get_css($css = NULL) {  $output = '';  if (!isset($css)) {    $css = drupal_add_css();  }  $no_module_preprocess = '';  $no_theme_preprocess = '';  $preprocess_css = (variable_get('preprocess_css', FALSE) && (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update'));  $directory = file_directory_path();  $is_writable = is_dir($directory) && is_writable($directory) && (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC);  // A dummy query-string is added to filenames, to gain control over  // browser-caching. The string changes on every update or full cache  // flush, forcing browsers to load a new copy of the files, as the  // URL changed.  $query_string = '?'. substr(variable_get('css_js_query_string', '0'), 0, 1);  foreach ($css as $media => $types) {    // If CSS preprocessing is off, we still need to output the styles.    // Additionally, go through any remaining styles if CSS preprocessing is on and output the non-cached ones.    foreach ($types as $type => $files) {      if ($type == 'module') {        // Setup theme overrides for module styles.        $theme_styles = array();        foreach (array_keys($css[$media]['theme']) as $theme_style) {          $theme_styles[] = basename($theme_style);        }      }      foreach ($types[$type] as $file => $preprocess) {        // If the theme supplies its own style using the name of the module style, skip its inclusion.        // This includes any RTL styles associated with its main LTR counterpart.        if ($type == 'module' && in_array(str_replace('-rtl.css', '.css', basename($file)), $theme_styles)) {          // Unset the file to prevent its inclusion when CSS aggregation is enabled.          unset($types[$type][$file]);          continue;        }        // Only include the stylesheet if it exists.        if (file_exists($file)) {          if (!$preprocess || !($is_writable && $preprocess_css)) {            // If a CSS file is not to be preprocessed and it's a module CSS file, it needs to *always* appear at the *top*,            // regardless of whether preprocessing is on or off.            if (!$preprocess && $type == 'module') {              $no_module_preprocess .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }            // If a CSS file is not to be preprocessed and it's a theme CSS file, it needs to *always* appear at the *bottom*,            // regardless of whether preprocessing is on or off.            else if (!$preprocess && $type == 'theme') {              $no_theme_preprocess .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }            else {              $output .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $file . $query_string .'" />'."\n";            }          }        }      }    }    if ($is_writable && $preprocess_css) {      // Prefix filename to prevent blocking by firewalls which reject files      // starting with "ad*".      $filename = 'css_'. md5(serialize($types) . $query_string) .'.css';      $preprocess_file = drupal_build_css_cache($types, $filename);      $output .= '<link type="text/css" rel="stylesheet" media="'. $media .'" href="'. base_path() . $preprocess_file .'" />'."\n";    }  }  return $no_module_preprocess . $output . $no_theme_preprocess;}/** * Aggregate and optimize CSS files, putting them in the files directory. * * @param $types *   An array of types of CSS files (e.g., screen, print) to aggregate and *   compress into one file. * @param $filename *   The name of the aggregate CSS file. * @return *   The name of the CSS file. */function drupal_build_css_cache($types, $filename) {  $data = '';  // Create the css/ within the files folder.  $csspath = file_create_path('css');  file_check_directory($csspath, FILE_CREATE_DIRECTORY);  if (!file_exists($csspath .'/'. $filename)) {    // Build aggregate CSS file.    foreach ($types as $type) {      foreach ($type as $file => $cache) {        if ($cache) {          $contents = drupal_load_stylesheet($file, TRUE);          // Return the path to where this CSS file originated from.          $base = base_path() . dirname($file) .'/';          _drupal_build_css_path(NULL, $base);          // Prefix all paths within this CSS file, ignoring external and absolute paths.          $data .= preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $contents);        }      }    }    // Per the W3C specification at http://www.w3.org/TR/REC-CSS2/cascade.html#at-import,    // @import rules must proceed any other style, so we move those to the top.    $regexp = '/@import[^;]+;/i';    preg_match_all($regexp, $data, $matches);    $data = preg_replace($regexp, '', $data);    $data = implode('', $matches[0]) . $data;    // Create the CSS file.    file_save_data($data, $csspath .'/'. $filename, FILE_EXISTS_REPLACE);  }  return $csspath .'/'. $filename;}/** * Helper function for drupal_build_css_cache(). * * This function will prefix all paths within a CSS file. */function _drupal_build_css_path($matches, $base = NULL) {  static $_base;  // Store base path for preg_replace_callback.  if (isset($base)) {    $_base = $base;  }  // Prefix with base and remove '../' segments where possible.  $path = $_base . $matches[1];  $last = '';  while ($path != $last) {    $last = $path;    $path = preg_replace('`(^|/)(?!\.\./)([^/]+)/\.\./`', '$1', $path);  }  return 'url('. $path .')';}/** * Loads the stylesheet and resolves all @import commands. * * Loads a stylesheet and replaces @import commands with the contents of the * imported file. Use this instead of file_get_contents when processing * stylesheets. * * The returned contents are compressed removing white space and comments only * when CSS aggregation is enabled. This optimization will not apply for * color.module enabled themes with CSS aggregation turned off. * * @param $file *   Name of the stylesheet to be processed. * @param $optimize *   Defines if CSS contents should be compressed or not. * @return *   Contents of the stylesheet including the imported stylesheets. */function drupal_load_stylesheet($file, $optimize = NULL) {  static $_optimize;  // Store optimization parameter for preg_replace_callback with nested @import loops.  if (isset($optimize)) {    $_optimize = $optimize;  }  $contents = '';  if (file_exists($file)) {    // Load the local CSS stylesheet.    $contents = file_get_contents($file);    // Change to the current stylesheet's directory.    $cwd = getcwd();    chdir(dirname($file));    // Replaces @import commands with the actual stylesheet content.    // This happens recursively but omits external files.    $contents = preg_replace_callback('/@import\s*(?:url\()?[\'"]?(?![a-z]+:)([^\'"\()]+)[\'"]?\)?;/', '_drupal_load_stylesheet', $contents);    // Remove multiple charset declarations for standards compliance (and fixing Safari problems).    $contents = preg_replace('/^@charset\s+[\'"](\S*)\b[\'"];/i', '', $contents);    if ($_optimize) {      // Perform some safe CSS optimizations.      $contents = preg_replace('<        \s*([@{}:;,]|\)\s|\s\()\s* |  # Remove whitespace around separators, but keep space around parentheses.        /\*([^*\\\\]|\*(?!/))+\*/     # Remove comments that are not CSS hacks.        >x', '\1', $contents);    }    // Change back directory.    chdir($cwd);  }  return $contents;}/** * Loads stylesheets recursively and returns contents with corrected paths. * * This function is used for recursive loading of stylesheets and * returns the stylesheet content with all url() paths corrected. */function _drupal_load_stylesheet($matches) {  $filename = $matches[1];  // Load the imported stylesheet and replace @import commands in there as well.  $file = drupal_load_stylesheet($filename);  // Alter all url() paths, but not external.  return preg_replace('/url\(([\'"]?)(?![a-z]+:)([^\'")]+)[\'"]?\)?;/i', 'url(\1'. dirname($filename) .'/', $file);}/** * Delete all cached CSS files. */function drupal_clear_css_cache() {  file_scan_directory(file_create_path('css'), '.*', array('.', '..', 'CVS'), 'file_delete', TRUE);}/** * Add a JavaScript file, setting or inline code to the page. * * The behavior of this function depends on the parameters it is called with. * Generally, it handles the addition of JavaScript to the page, either as * reference to an existing file or as inline code. The following actions can be * performed using this function: * * - Add a file ('core', 'module' and 'theme'): *   Adds a reference to a JavaScript file to the page. JavaScript files *   are placed in a certain order, from 'core' first, to 'module' and finally *   'theme' so that files, that are added later, can override previously added *   files with ease. * * - Add inline JavaScript code ('inline'): *   Executes a piece of JavaScript code on the current page by placing the code *   directly in the page. This can, for example, be useful to tell the user that *   a new message arrived, by opening a pop up, alert box etc. * * - Add settings ('setting'): *   Adds a setting to Drupal's global storage of JavaScript settings. Per-page *   settings are required by some modules to function properly. The settings *   will be accessible at Drupal.settings. * * @param $data *   (optional) If given, the value depends on the $type parameter: *   - 'core', 'module' or 'theme': Path to the file relative to base_path(). *   - 'inline': The JavaScript code that should be placed in the given scope. *   - 'setting': An array with configuration options as associative array. The *       array is directly placed in Drupal.settings. You might want to wrap your *       actual configuration settings in another variable to prevent the pollution *       of the Drupal.settings namespace. * @param $type *   (optional) The type of JavaScript that should be added to the page. Allowed *   values are 'core', 'module', 'theme', 'inline' and 'setting'. You *   can, however, specify any value. It is treated as a reference to a JavaScript *   file. Defaults to 'module'. * @param $scope *   (optional) The location in which you want to place the script. Possible *   values are 'header' and 'footer' by default. If your theme implements *   different locations, however, you can also use these. * @param $defer *   (optional) If set to TRUE, the defer attribute is set on the <script> tag. *   Defaults to FALSE. This parameter is not used with $type == 'setting'. * @param $cache *   (optional) If set to FALSE, the JavaScript file is loaded anew on every page *   call, that means, it is not cached. Defaults to TRUE. Used only when $type *   references a JavaScript file. * @param $preprocess *   (optional) Should this JS file be aggregated if this *   feature has been turned on under the performance section? * @return *   If the first parameter is NULL, the JavaScript array that has been built so *   far for $scope is returned. If the first three parameters are NULL, *   an array with all scopes is returned. */function drupal_add_js($data = NULL, $type = 'module', $scope = 'header', $defer = FALSE, $cache = TRUE, $preprocess = TRUE) {  static $javascript = array();  if (isset($data)) {    // Add jquery.js and drupal.js, as well as the basePath setting, the    // first time a Javascript file is added.    if (empty($javascript)) {      $javascript['header'] = array(        'core' => array(          'misc/jquery.js' => array('cache' => TRUE, 'defer' => FALSE, 'preprocess' => TRUE),          'misc/drupal.js' => array('cache' => TRUE, 'defer' => FALSE, 'preprocess' => TRUE),        ),        'module' => array(),        'theme' => array(),        'setting' => array(          array('basePath' => base_path()),        ),        'inline' => array(),      );    }    if (isset($scope) && !isset($javascript[$scope])) {      $javascript[$scope] = array('core' => array(), 'module' => array(), 'theme' => array(), 'setting' => array(), 'inline' => array());    }    if (isset($type) && isset($scope) && !isset($javascript[$scope][$type])) {      $javascript[$scope][$type] = array();    }    switch ($type) {      case 'setting':        $javascript[$scope][$type][] = $data;        break;      case 'inline':        $javascript[$scope][$type][] = array('code' => $data, 'defer' => $defer);        break;      default:        // If cache is FALSE, don't preprocess the JS file.        $javascript[$scope][$type][$data] = array('cache' => $cache, 'defer' => $defer, 'preprocess' => (!$cache ? FALSE : $preprocess));    }  }  if (isset($scope)) {    if (isset($javascript[$scope])) {      return $javascript[$scope];    }    else {      return array();    }  }  else {    return $javascript;  }}/** * Returns a themed presentation of all JavaScript code for the current page. * * References to JavaScript files are placed in a certain order: first, all * 'core' files, then all 'module' and finally all 'theme' JavaScript files * are added to the page. Then, all settings are output, followed by 'inline' * JavaScript code. If running update.php, all preprocessing is disabled. * * @param $scope *   (optional) The scope for which the JavaScript rules should be returned. *   Defaults to 'header'. * @param $javascript *   (optional) An array with all JavaScript code. Defaults to the default *   JavaScript array for the given scope. * @return *   All JavaScript code segments and includes for the scope as HTML tags. */function drupal_get_js($scope = 'header', $javascript = NULL) {  if ((!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') && function_exists('locale_update_js_files')) {    locale_update_js_files();  }  if (!isset($javascript)) {    $javascript = drupal_add_js(NULL, NULL, $scope);  }  if (empty($javascript)) {    return '';  }  $output = '';  $preprocessed = '';  $no_preprocess = array('core' => '', 'module' => '', 'theme' => '');  $files = array();  $preprocess_js = (variable_get('preprocess_js', FALSE) && (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update'));  $directory = file_directory_path();  $is_writable = is_dir($directory) && is_writable($directory) && (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC) == FILE_DOWNLOADS_PUBLIC);  // A dummy query-string is added to filenames, to gain control over  // browser-caching. The string changes on every update or full cache  // flush, forcing browsers to load a new copy of the files, as the  // URL changed. Files that should not be cached (see drupal_add_js())  // get time() as query-string instead, to enforce reload on every  // page request.  $query_string = '?'. substr(variable_get('css_js_query_string', '0'), 0, 1);  // For inline Javascript to validate as XHTML, all Javascript containing  // XHTML needs to be wrapped in CDATA. To make that backwards compatible  // with HTML 4, we need to comment out the CDATA-tag.  $embed_prefix = "\n<!--//--><![CDATA[//><!--\n";  $embed_suffix = "\n//--><!]]>\n";  foreach ($javascript as $type => $data) {    if (!$data) continue;    switch ($type) {      case 'setting':        $output .= '<script type="text/javascript">' . $embed_prefix . 'jQuery.extend(Drupal.settings, ' . drupal_to_js(call_user_func_array('array_merge_recursive', $data)) . ");" . $embed_suffix . "</script>\n";        break;      case 'inline':        foreach ($data as $info) {          $output .= '<script type="text/javascript"' . ($info['defer'] ? ' defer="defer"' : '') . '>' . $embed_prefix . $info['code'] . $embed_suffix . "</script>\n";        }        break;      default:        // If JS preprocessing is off, we still need to output the scripts.        // Additionally, go through any remaining scripts if JS preprocessing is on and output the non-cached ones.        foreach ($data as $path => $info) {          if (!$info['preprocess'] || !$is_writable || !$preprocess_js) {            $no_preprocess[$type] .= '<script type="text/javascript"'. ($info['defer'] ? ' defer="defer"' : '') .' src="'. base_path() . $path . ($info['cache'] ? $query_string : '?'. time()) ."\"></script>\n";          }          else {            $files[$path] = $info;          }        }    }  }  // Aggregate any remaining JS files that haven't already been output.  if ($is_writable && $preprocess_js && count($files) > 0) {    // Prefix filename to prevent blocking by firewalls which reject files    // starting with "ad*".    $filename = 'js_'. md5(serialize($files) . $query_string) .'.js';    $preprocess_file = drupal_build_js_cache($files, $filename);    $preprocessed .= '<script type="text/javascript" src="'. base_path() . $preprocess_file .'"></script>'."\n";  }  // Keep the order of JS files consistent as some are preprocessed and others are not.  // Make sure any inline or JS setting variables appear last after libraries have loaded.  $output = $preprocessed . implode('', $no_preprocess) . $output;  return $output;}/** * Assist in adding the tableDrag JavaScript behavior to a themed table. * * Draggable tables should be used wherever an outline or list of sortable items * needs to be arranged by an end-user. Draggable tables are very flexible and * can manipulate the value of form elements placed within individual columns. * * To set up a table to use drag and drop in place of weight select-lists or * in place of a form that contains parent relationships, the form must be * themed into a table. The table must have an id attribute set. If using * theme_table(), the id may be set as such: * @code * $output = theme('table', $header, $rows, array('id' => 'my-module-table')); * return $output; * @endcode * * In the theme function for the form, a special class must be added to each * form element within the same column, "grouping" them together. * * In a situation where a single weight column is being sorted in the table, the * classes could be added like this (in the theme function): * @code * $form['my_elements'][$delta]['weight']['#attributes']['class'] = "my-elements-weight"; * @endcode * * Each row of the table must also have a class of "draggable" in order to enable the * drag handles: * @code * $row = array(...); * $rows[] = array( *   'data' => $row, *   'class' => 'draggable', * ); * @endcode * * When tree relationships are present, the two additional classes * 'tabledrag-leaf' and 'tabledrag-root' can be used to refine the behavior: * - Rows with the 'tabledrag-leaf' class cannot have child rows. * - Rows with the 'tabledrag-root' class cannot be nested under a parent row. * * Calling drupal_add_tabledrag() would then be written as such: * @code * drupal_add_tabledrag('my-module-table', 'order', 'sibling', 'my-elements-weight'); * @endcode * * In a more complex case where there are several groups in one column (such as * the block regions on the admin/build/block page), a separate subgroup class * must also be added to differentiate the groups. * @code * $form['my_elements'][$region][$delta]['weight']['#attributes']['class'] = "my-elements-weight my-elements-weight-". $region; * @endcode * * $group is still 'my-element-weight', and the additional $subgroup variable * will be passed in as 'my-elements-weight-'. $region. This also means that * you'll need to call drupal_add_tabledrag() once for every region added. * * @code * foreach ($regions as $region) { *   drupal_add_tabledrag('my-module-table', 'order', 'sibling', 'my-elements-weight', 'my-elements-weight-'. $region); * } * @endcode * * In a situation where tree relationships are present, adding multiple * subgroups is not necessary, because the table will contain indentations that * provide enough information about the sibling and parent relationships. * See theme_menu_overview_form() for an example creating a table containing * parent relationships. * * Please note that this function should be called from the theme layer, such as * in a .tpl.php file, theme_ function, or in a template_preprocess function, * not in a form declartion. Though the same JavaScript could be added to the * page using drupal_add_js() directly, this function helps keep template files * clean and readable. It also prevents tabledrag.js from being added twice * accidentally. * * @param $table_id *   String containing the target table's id attribute. If the table does not *   have an id, one will need to be set, such as <table id="my-module-table">. * @param $action *   String describing the action to be done on the form item. Either 'match' *   'depth', or 'order'. Match is typically used for parent relationships. *   Order is typically used to set weights on other form elements with the same *   group. Depth updates the target element with the current indentation. * @param $relationship *   String describing where the $action variable should be performed. Either *   'parent', 'sibling', 'group', or 'self'. Parent will only look for fields *   up the tree. Sibling will look for fields in the same group in rows above *   and below it. Self affects the dragged row itself. Group affects the *   dragged row, plus any children below it (the entire dragged group). * @param $group *   A class name applied on all related form elements for this action. * @param $subgroup *   (optional) If the group has several subgroups within it, this string should *   contain the class name identifying fields in the same subgroup. * @param $source *   (optional) If the $action is 'match', this string should contain the class *   name identifying what field will be used as the source value when matching *   the value in $subgroup. * @param $hidden *   (optional) The column containing the field elements may be entirely hidden *   from view dynamically when the JavaScript is loaded. Set to FALSE if the *   column should not be hidden. * @param $limit *   (optional) Limit the maximum amount of parenting in this table. * @see block-admin-display-form.tpl.php * @see theme_menu_overview_form() */function drupal_add_tabledrag($table_id, $action, $relationship, $group, $subgroup = NULL, $source = NULL, $hidden = TRUE, $limit = 0) {  static $js_added = FALSE;  if (!$js_added) {    drupal_add_js('misc/tabledrag.js', 'core');    $js_added = TRUE;  }  // If a subgroup or source isn't set, assume it is the same as the group.  $target = isset($subgroup) ? $subgroup : $group;  $source = isset($source) ? $source : $target;  $settings['tableDrag'][$table_id][$group][] = array(    'target' => $target,    'source' => $source,    'relationship' => $relationship,    'action' => $action,    'hidden' => $hidden,    'limit' => $limit,  );  drupal_add_js($settings, 'setting');}/** * Aggregate JS files, putting them in the files directory. * * @param $files *   An array of JS files to aggregate and compress into one file. * @param $filename *   The name of the aggregate JS file. * @return *   The name of the JS file. */function drupal_build_js_cache($files, $filename) {  $contents = '';  // Create the js/ within the files folder.  $jspath = file_create_path('js');  file_check_directory($jspath, FILE_CREATE_DIRECTORY);  if (!file_exists($jspath .'/'. $filename)) {    // Build aggregate JS file.    foreach ($files as $path => $info) {      if ($info['preprocess']) {        // Append a ';' after each JS file to prevent them from running together.        $contents .= file_get_contents($path) .';';      }    }    // Create the JS file.    file_save_data($contents, $jspath .'/'. $filename, FILE_EXISTS_REPLACE);  }  return $jspath .'/'. $filename;}/** * Delete all cached JS files. */function drupal_clear_js_cache() {  file_scan_directory(file_create_path('js'), '.*', array('.', '..', 'CVS'), 'file_delete', TRUE);  variable_set('javascript_parsed', array());}/** * Converts a PHP variable into its Javascript equivalent. * * We use HTML-safe strings, i.e. with <, > and & escaped. */function drupal_to_js($var) {  switch (gettype($var)) {    case 'boolean':      return $var ? 'true' : 'false'; // Lowercase necessary!    case 'integer':    case 'double':      return $var;    case 'resource':    case 'string':      return '"'. str_replace(array("\r", "\n", "<", ">", "&"),                              array('\r', '\n', '\x3c', '\x3e', '\x26'),                              addslashes($var)) .'"';    case 'array':      // Arrays in JSON can't be associative. If the array is empty or if it      // has sequential whole number keys starting with 0, it's not associative      // so we can go ahead and convert it as an array.      if (empty ($var) || array_keys($var) === range(0, sizeof($var) - 1)) {        $output = array();        foreach ($var as $v) {          $output[] = drupal_to_js($v);        }        return '[ '. implode(', ', $output) .' ]';      }      // Otherwise, fall through to convert the array as an object.    case 'object':      $output = array();      foreach ($var as $k => $v) {        $output[] = drupal_to_js(strval($k)) .': '. drupal_to_js($v);      }      return '{ '. implode(', ', $output) .' }';    default:      return 'null';  }}/** * Return data in JSON format. * * This function should be used for JavaScript callback functions returning * data in JSON format. It sets the header for JavaScript output. * * @param $var *   (optional) If set, the variable will be converted to JSON and output. */function drupal_json($var = NULL) {  // We are returning JavaScript, so tell the browser.  drupal_set_header('Content-Type: text/javascript; charset=utf-8');  if (isset($var)) {    echo drupal_to_js($var);  }}/** * Wrapper around urlencode() which avoids Apache quirks. * * Should be used when placing arbitrary data in an URL. Note that Drupal paths * are urlencoded() when passed through url() and do not require urlencoding() * of individual components. * * Notes: * - For esthetic reasons, we do not escape slashes. This also avoids a 'feature' *   in Apache where it 404s on any path containing '%2F'. * - mod_rewrite unescapes %-encoded ampersands, hashes, and slashes when clean *   URLs are used, which are interpreted as delimiters by PHP. These *   characters are double escaped so PHP will still see the encoded version. * - With clean URLs, Apache changes '//' to '/', so every second slash is *   double escaped. * - This function should only be used on paths, not on query string arguments, *   otherwise unwanted double encoding will occur. * * @param $text *   String to encode */function drupal_urlencode($text) {  if (variable_get('clean_url', '0')) {    return str_replace(array('%2F', '%26', '%23', '//'),                       array('/', '%2526', '%2523', '/%252F'),                       rawurlencode($text));  }  else {    return str_replace('%2F', '/', rawurlencode($text));  }}/** * Ensure the private key variable used to generate tokens is set. * * @return *   The private key. */function drupal_get_private_key() {  if (!($key = variable_get('drupal_private_key', 0))) {    $key = md5(uniqid(mt_rand(), true)) . md5(uniqid(mt_rand(), true));    variable_set('drupal_private_key', $key);  }  return $key;}/** * Generate a token based on $value, the current user session and private key. * * @param $value *   An additional value to base the token on. */function drupal_get_token($value = '') {  $private_key = drupal_get_private_key();  return md5(session_id() . $value . $private_key);}/** * Validate a token based on $value, the current user session and private key. * * @param $token *   The token to be validated. * @param $value *   An additional value to base the token on. * @param $skip_anonymous *   Set to true to skip token validation for anonymous users. * @return *   True for a valid token, false for an invalid token. When $skip_anonymous *   is true, the return value will always be true for anonymous users. */function drupal_valid_token($token, $value = '', $skip_anonymous = FALSE) {  global $user;  return (($skip_anonymous && $user->uid == 0) || ($token == md5(session_id() . $value . variable_get('drupal_private_key', ''))));}/** * Performs one or more XML-RPC request(s). * * @param $url *   An absolute URL of the XML-RPC endpoint. *     Example: *     http://www.example.com/xmlrpc.php * @param ... *   For one request: *     The method name followed by a variable number of arguments to the method. *   For multiple requests (system.multicall): *     An array of call arrays. Each call array follows the pattern of the single *     request: method name followed by the arguments to the method. * @return *   For one request: *     Either the return value of the method on success, or FALSE. *     If FALSE is returned, see xmlrpc_errno() and xmlrpc_error_msg(). *   For multiple requests: *     An array of results. Each result will either be the result *     returned by the method called, or an xmlrpc_error object if the call *     failed. See xmlrpc_error(). */function xmlrpc($url) {  require_once './includes/xmlrpc.inc';  $args = func_get_args();  return call_user_func_array('_xmlrpc', $args);}function _drupal_bootstrap_full() {  static $called;  if ($called) {    return;  }  $called = 1;  require_once './includes/theme.inc';  require_once './includes/pager.inc';  require_once './includes/menu.inc';  require_once './includes/tablesort.inc';  require_once './includes/file.inc';  require_once './includes/unicode.inc';  require_once './includes/image.inc';  require_once './includes/form.inc';  require_once './includes/mail.inc';  require_once './includes/actions.inc';  // Set the Drupal custom error handler.  set_error_handler('drupal_error_handler');  // Emit the correct charset HTTP header.  drupal_set_header('Content-Type: text/html; charset=utf-8');  // Detect string handling method  unicode_check();  // Undo magic quotes  fix_gpc_magic();  // Load all enabled modules  module_load_all();  // Let all modules take action before menu system handles the request  // We do not want this while running update.php.  if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {    module_invoke_all('init');  }}/** * Store the current page in the cache. * * We try to store a gzipped version of the cache. This requires the * PHP zlib extension (http://php.net/manual/en/ref.zlib.php). * Presence of the extension is checked by testing for the function * gzencode. There are two compression algorithms: gzip and deflate. * The majority of all modern browsers support gzip or both of them. * We thus only deal with the gzip variant and unzip the cache in case * the browser does not accept gzip encoding. * * @see drupal_page_header */function page_set_cache() {  global $user, $base_root;  if (!$user->uid && $_SERVER['REQUEST_METHOD'] == 'GET' && page_get_cache(TRUE)) {    // This will fail in some cases, see page_get_cache() for the explanation.    if ($data = ob_get_contents()) {      $cache = TRUE;      if (variable_get('page_compression', TRUE) && function_exists('gzencode')) {        // We do not store the data in case the zlib mode is deflate.        // This should be rarely happening.        if (zlib_get_coding_type() == 'deflate') {          $cache = FALSE;        }        else if (zlib_get_coding_type() == FALSE) {          $data = gzencode($data, 9, FORCE_GZIP);        }        // The remaining case is 'gzip' which means the data is        // already compressed and nothing left to do but to store it.      }      ob_end_flush();      if ($cache && $data) {        cache_set($base_root . request_uri(), $data, 'cache_page', CACHE_TEMPORARY, drupal_get_headers());      }    }  }}/** * Executes a cron run when called * @return * Returns TRUE if ran successfully */function drupal_cron_run() {  // Try to allocate enough time to run all the hook_cron implementations.  if (function_exists('set_time_limit')) {    @set_time_limit(240);  }  // Fetch the cron semaphore  $semaphore = variable_get('cron_semaphore', FALSE);  if ($semaphore) {    if (time() - $semaphore > 3600) {      // Either cron has been running for more than an hour or the semaphore      // was not reset due to a database error.      watchdog('cron', 'Cron has been running for more than an hour and is most likely stuck.', array(), WATCHDOG_ERROR);      // Release cron semaphore      variable_del('cron_semaphore');    }    else {      // Cron is still running normally.      watchdog('cron', 'Attempting to re-run cron while it is already running.', array(), WATCHDOG_WARNING);    }  }  else {    // Register shutdown callback    register_shutdown_function('drupal_cron_cleanup');    // Lock cron semaphore    variable_set('cron_semaphore', time());    // Iterate through the modules calling their cron handlers (if any):    module_invoke_all('cron');    // Record cron time    variable_set('cron_last', time());    watchdog('cron', 'Cron run completed.', array(), WATCHDOG_NOTICE);    // Release cron semaphore    variable_del('cron_semaphore');    // Return TRUE so other functions can check if it did run successfully    return TRUE;  }}/** * Shutdown function for cron cleanup. */function drupal_cron_cleanup() {  // See if the semaphore is still locked.  if (variable_get('cron_semaphore', FALSE)) {    watchdog('cron', 'Cron run exceeded the time limit and was aborted.', array(), WATCHDOG_WARNING);    // Release cron semaphore    variable_del('cron_semaphore');  }}/** * Return an array of system file objects. * * Returns an array of file objects of the given type from the site-wide * directory (i.e. modules/), the all-sites directory (i.e. * sites/all/modules/), the profiles directory, and site-specific directory * (i.e. sites/somesite/modules/). The returned array will be keyed using the * key specified (name, basename, filename). Using name or basename will cause * site-specific files to be prioritized over similar files in the default * directories. That is, if a file with the same name appears in both the * site-wide directory and site-specific directory, only the site-specific * version will be included. * * @param $mask *   The regular expression of the files to find. * @param $directory *   The subdirectory name in which the files are found. For example, *   'modules' will search in both modules/ and *   sites/somesite/modules/. * @param $key *   The key to be passed to file_scan_directory(). * @param $min_depth *   Minimum depth of directories to return files from. * * @return *   An array of file objects of the specified type. */function drupal_system_listing($mask, $directory, $key = 'name', $min_depth = 1) {  global $profile;  $config = conf_path();  // When this function is called during Drupal's initial installation process,  // the name of the profile that's about to be installed is stored in the global  // $profile variable. At all other times, the standard Drupal systems variable  // table contains the name of the current profile, and we can call variable_get()  // to determine what one is active.  if (!isset($profile)) {    $profile = variable_get('install_profile', 'default');  }  $searchdir = array($directory);  $files = array();  // The 'profiles' directory contains pristine collections of modules and  // themes as organized by a distribution.  It is pristine in the same way  // that /modules is pristine for core; users should avoid changing anything  // there in favor of sites/all or sites/<domain> directories.  if (file_exists("profiles/$profile/$directory")) {    $searchdir[] = "profiles/$profile/$directory";  }  // Always search sites/all/* as well as the global directories  $searchdir[] = 'sites/all/'. $directory;  if (file_exists("$config/$directory")) {    $searchdir[] = "$config/$directory";  }  // Get current list of items  foreach ($searchdir as $dir) {    $files = array_merge($files, file_scan_directory($dir, $mask, array('.', '..', 'CVS'), 0, TRUE, $key, $min_depth));  }  return $files;}/** * This dispatch function hands off structured Drupal arrays to type-specific * *_alter implementations. It ensures a consistent interface for all altering * operations. * * @param $type *   The data type of the structured array. 'form', 'links', *   'node_content', and so on are several examples. * @param $data *   The structured array to be altered. * @param ... *   Any additional params will be passed on to the called *   hook_$type_alter functions. */function drupal_alter($type, &$data) {  // PHP's func_get_args() always returns copies of params, not references, so  // drupal_alter() can only manipulate data that comes in via the required first  // param. For the edge case functions that must pass in an arbitrary number of  // alterable parameters (hook_form_alter() being the best example), an array of  // those params can be placed in the __drupal_alter_by_ref key of the $data  // array. This is somewhat ugly, but is an unavoidable consequence of a flexible  // drupal_alter() function, and the limitations of func_get_args().  // @todo: Remove this in Drupal 7.  if (is_array($data) && isset($data['__drupal_alter_by_ref'])) {    $by_ref_parameters = $data['__drupal_alter_by_ref'];    unset($data['__drupal_alter_by_ref']);  }  // Hang onto a reference to the data array so that it isn't blown away later.  // Also, merge in any parameters that need to be passed by reference.  $args = array(&$data);  if (isset($by_ref_parameters)) {    $args = array_merge($args, $by_ref_parameters);  }  // Now, use func_get_args() to pull in any additional parameters passed into  // the drupal_alter() call.  $additional_args = func_get_args();  array_shift($additional_args);  array_shift($additional_args);  $args = array_merge($args, $additional_args);  foreach (module_implements($type .'_alter') as $module) {    $function = $module .'_'. $type .'_alter';    call_user_func_array($function, $args);  }}/** * Renders HTML given a structured array tree. * * Recursively iterates over each of the array elements, generating HTML code. * This function is usually called from within a another function, like * drupal_get_form() or node_view(). * * @param $elements *   The structured array describing the data to be rendered. * @return *   The rendered HTML. */function drupal_render(&$elements) {  if (!isset($elements) || (isset($elements['#access']) && !$elements['#access'])) {    return NULL;  }  // If the default values for this element haven't been loaded yet, populate  // them.  if (!isset($elements['#defaults_loaded']) || !$elements['#defaults_loaded']) {    if ((!empty($elements['#type'])) && ($info = _element_info($elements['#type']))) {      $elements += $info;    }  }  // Make any final changes to the element before it is rendered. This means  // that the $element or the children can be altered or corrected before the  // element is rendered into the final text.  if (isset($elements['#pre_render'])) {    foreach ($elements['#pre_render'] as $function) {      if (function_exists($function)) {        $elements = $function($elements);      }    }  }  $content = '';  // Either the elements did not go through form_builder or one of the children  // has a #weight.  if (!isset($elements['#sorted'])) {    uasort($elements, "element_sort");  }  $elements += array('#title' => NULL, '#description' => NULL);  if (!isset($elements['#children'])) {    $children = element_children($elements);    // Render all the children that use a theme function.    if (isset($elements['#theme']) && empty($elements['#theme_used'])) {      $elements['#theme_used'] = TRUE;      $previous = array();      foreach (array('#value', '#type', '#prefix', '#suffix') as $key) {        $previous[$key] = isset($elements[$key]) ? $elements[$key] : NULL;      }      // If we rendered a single element, then we will skip the renderer.      if (empty($children)) {        $elements['#printed'] = TRUE;      }      else {        $elements['#value'] = '';      }      $elements['#type'] = 'markup';      unset($elements['#prefix'], $elements['#suffix']);      $content = theme($elements['#theme'], $elements);      foreach (array('#value', '#type', '#prefix', '#suffix') as $key) {        $elements[$key] = isset($previous[$key]) ? $previous[$key] : NULL;      }    }    // Render each of the children using drupal_render and concatenate them.    if (!isset($content) || $content === '') {      foreach ($children as $key) {        $content .= drupal_render($elements[$key]);      }    }  }  if (isset($content) && $content !== '') {    $elements['#children'] = $content;  }  // Until now, we rendered the children, here we render the element itself  if (!isset($elements['#printed'])) {    $content = theme(!empty($elements['#type']) ? $elements['#type'] : 'markup', $elements);    $elements['#printed'] = TRUE;  }  if (isset($content) && $content !== '') {    // Filter the outputted content and make any last changes before the    // content is sent to the browser. The changes are made on $content    // which allows the output'ed text to be filtered.    if (isset($elements['#post_render'])) {      foreach ($elements['#post_render'] as $function) {        if (function_exists($function)) {          $content = $function($content, $elements);        }      }    }    $prefix = isset($elements['#prefix']) ? $elements['#prefix'] : '';    $suffix = isset($elements['#suffix']) ? $elements['#suffix'] : '';    return $prefix . $content . $suffix;  }}/** * Function used by uasort to sort structured arrays by weight. */function element_sort($a, $b) {  $a_weight = (is_array($a) && isset($a['#weight'])) ? $a['#weight'] : 0;  $b_weight = (is_array($b) && isset($b['#weight'])) ? $b['#weight'] : 0;  if ($a_weight == $b_weight) {    return 0;  }  return ($a_weight < $b_weight) ? -1 : 1;}/** * Check if the key is a property. */function element_property($key) {  return $key[0] == '#';}/** * Get properties of a structured array element. Properties begin with '#'. */function element_properties($element) {  return array_filter(array_keys((array) $element), 'element_property');}/** * Check if the key is a child. */function element_child($key) {  return !isset($key[0]) || $key[0] != '#';}/** * Get keys of a structured array tree element that are not properties (i.e., do not begin with '#'). */function element_children($element) {  return array_filter(array_keys((array) $element), 'element_child');}/** * Provide theme registration for themes across .inc files. */function drupal_common_theme() {  return array(    // theme.inc    'placeholder' => array(      'arguments' => array('text' => NULL)    ),    'page' => array(      'arguments' => array('content' => NULL, 'show_blocks' => TRUE, 'show_messages' => TRUE),      'template' => 'page',    ),    'maintenance_page' => array(      'arguments' => array('content' => NULL, 'show_blocks' => TRUE, 'show_messages' => TRUE),      'template' => 'maintenance-page',    ),    'update_page' => array(      'arguments' => array('content' => NULL, 'show_messages' => TRUE),    ),    'install_page' => array(      'arguments' => array('content' => NULL),    ),    'task_list' => array(      'arguments' => array('items' => NULL, 'active' => NULL),    ),    'status_messages' => array(      'arguments' => array('display' => NULL),    ),    'links' => array(      'arguments' => array('links' => NULL, 'attributes' => array('class' => 'links')),    ),    'image' => array(      'arguments' => array('path' => NULL, 'alt' => '', 'title' => '', 'attributes' => NULL, 'getsize' => TRUE),    ),    'breadcrumb' => array(      'arguments' => array('breadcrumb' => NULL),    ),    'help' => array(      'arguments' => array(),    ),    'submenu' => array(      'arguments' => array('links' => NULL),    ),    'table' => array(      'arguments' => array('header' => NULL, 'rows' => NULL, 'attributes' => array(), 'caption' => NULL),    ),    'table_select_header_cell' => array(      'arguments' => array(),    ),    'tablesort_indicator' => array(      'arguments' => array('style' => NULL),    ),    'box' => array(      'arguments' => array('title' => NULL, 'content' => NULL, 'region' => 'main'),      'template' => 'box',    ),    'block' => array(      'arguments' => array('block' => NULL),      'template' => 'block',    ),    'mark' => array(      'arguments' => array('type' => MARK_NEW),    ),    'item_list' => array(      'arguments' => array('items' => array(), 'title' => NULL, 'type' => 'ul', 'attributes' => NULL),    ),    'more_help_link' => array(      'arguments' => array('url' => NULL),    ),    'xml_icon' => array(      'arguments' => array('url' => NULL),    ),    'feed_icon' => array(      'arguments' => array('url' => NULL, 'title' => NULL),    ),    'more_link' => array(      'arguments' => array('url' => NULL, 'title' => NULL)    ),    'closure' => array(      'arguments' => array('main' => 0),    ),    'blocks' => array(      'arguments' => array('region' => NULL),    ),    'username' => array(      'arguments' => array('object' => NULL),    ),    'progress_bar' => array(      'arguments' => array('percent' => NULL, 'message' => NULL),    ),    'indentation' => array(      'arguments' => array('size' => 1),    ),    // from pager.inc    'pager' => array(      'arguments' => array('tags' => array(), 'limit' => 10, 'element' => 0, 'parameters' => array()),    ),    'pager_first' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'parameters' => array()),    ),    'pager_previous' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'interval' => 1, 'parameters' => array()),    ),    'pager_next' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'interval' => 1, 'parameters' => array()),    ),    'pager_last' => array(      'arguments' => array('text' => NULL, 'limit' => NULL, 'element' => 0, 'parameters' => array()),    ),    'pager_link' => array(      'arguments' => array('text' => NULL, 'page_new' => NULL, 'element' => NULL, 'parameters' => array(), 'attributes' => array()),    ),    // from locale.inc    'locale_admin_manage_screen' => array(      'arguments' => array('form' => NULL),    ),    // from menu.inc    'menu_item_link' => array(      'arguments' => array('item' => NULL),    ),    'menu_tree' => array(      'arguments' => array('tree' => NULL),    ),    'menu_item' => array(      'arguments' => array('link' => NULL, 'has_children' => NULL, 'menu' => ''),    ),    'menu_local_task' => array(      'arguments' => array('link' => NULL, 'active' => FALSE),    ),    'menu_local_tasks' => array(      'arguments' => array(),    ),    // from form.inc    'select' => array(      'arguments' => array('element' => NULL),    ),    'fieldset' => array(      'arguments' => array('element' => NULL),    ),    'radio' => array(      'arguments' => array('element' => NULL),    ),    'radios' => array(      'arguments' => array('element' => NULL),    ),    'password_confirm' => array(      'arguments' => array('element' => NULL),    ),    'date' => array(      'arguments' => array('element' => NULL),    ),    'item' => array(      'arguments' => array('element' => NULL),    ),    'checkbox' => array(      'arguments' => array('element' => NULL),    ),    'checkboxes' => array(      'arguments' => array('element' => NULL),    ),    'submit' => array(      'arguments' => array('element' => NULL),    ),    'button' => array(      'arguments' => array('element' => NULL),    ),    'image_button' => array(      'arguments' => array('element' => NULL),    ),    'hidden' => array(      'arguments' => array('element' => NULL),    ),    'token' => array(      'arguments' => array('element' => NULL),    ),    'textfield' => array(      'arguments' => array('element' => NULL),    ),    'form' => array(      'arguments' => array('element' => NULL),    ),    'textarea' => array(      'arguments' => array('element' => NULL),    ),    'markup' => array(      'arguments' => array('element' => NULL),    ),    'password' => array(      'arguments' => array('element' => NULL),    ),    'file' => array(      'arguments' => array('element' => NULL),    ),    'form_element' => array(      'arguments' => array('element' => NULL, 'value' => NULL),    ),  );}/** * @ingroup schemaapi * @{ *//** * Get the schema definition of a table, or the whole database schema. * * The returned schema will include any modifications made by any * module that implements hook_schema_alter(). * * @param $table *   The name of the table. If not given, the schema of all tables is returned. * @param $rebuild *   If true, the schema will be rebuilt instead of retrieved from the cache. */function drupal_get_schema($table = NULL, $rebuild = FALSE) {  static $schema = array();  if (empty($schema) || $rebuild) {    // Try to load the schema from cache.    if (!$rebuild && $cached = cache_get('schema')) {      $schema = $cached->data;    }    // Otherwise, rebuild the schema cache.    else {      $schema = array();      // Load the .install files to get hook_schema.      module_load_all_includes('install');      // Invoke hook_schema for all modules.      foreach (module_implements('schema') as $module) {        $current = module_invoke($module, 'schema');        _drupal_initialize_schema($module, $current);        $schema = array_merge($schema, $current);      }      drupal_alter('schema', $schema);      cache_set('schema', $schema);    }  }  if (!isset($table)) {    return $schema;  }  elseif (isset($schema[$table])) {    return $schema[$table];  }  else {    return FALSE;  }}/** * Create all tables that a module defines in its hook_schema(). * * Note: This function does not pass the module's schema through * hook_schema_alter(). The module's tables will be created exactly as the * module defines them. * * @param $module *   The module for which the tables will be created. * @return *   An array of arrays with the following key/value pairs: *    - success: a boolean indicating whether the query succeeded. *    - query: the SQL query(s) executed, passed through check_plain(). */function drupal_install_schema($module) {  $schema = drupal_get_schema_unprocessed($module);  _drupal_initialize_schema($module, $schema);  $ret = array();  foreach ($schema as $name => $table) {    db_create_table($ret, $name, $table);  }  return $ret;}/** * Remove all tables that a module defines in its hook_schema(). * * Note: This function does not pass the module's schema through * hook_schema_alter(). The module's tables will be created exactly as the * module defines them. * * @param $module *   The module for which the tables will be removed. * @return *   An array of arrays with the following key/value pairs: *    - success: a boolean indicating whether the query succeeded. *    - query: the SQL query(s) executed, passed through check_plain(). */function drupal_uninstall_schema($module) {  $schema = drupal_get_schema_unprocessed($module);  _drupal_initialize_schema($module, $schema);  $ret = array();  foreach ($schema as $table) {    db_drop_table($ret, $table['name']);  }  return $ret;}/** * Returns the unprocessed and unaltered version of a module's schema. * * Use this function only if you explicitly need the original * specification of a schema, as it was defined in a module's * hook_schema(). No additional default values will be set, * hook_schema_alter() is not invoked and these unprocessed * definitions won't be cached. * * This function can be used to retrieve a schema specification in * hook_schema(), so it allows you to derive your tables from existing * specifications. * * It is also used by drupal_install_schema() and * drupal_uninstall_schema() to ensure that a module's tables are * created exactly as specified without any changes introduced by a * module that implements hook_schema_alter(). * * @param $module *   The module to which the table belongs. * @param $table *   The name of the table. If not given, the module's complete schema *   is returned. */function drupal_get_schema_unprocessed($module, $table = NULL) {  // Load the .install file to get hook_schema.  module_load_include('install', $module);  $schema = module_invoke($module, 'schema');  if (!is_null($table) && isset($schema[$table])) {    return $schema[$table];  }  else {    return $schema;  }}/** * Fill in required default values for table definitions returned by hook_schema(). * * @param $module *   The module for which hook_schema() was invoked. * @param $schema *   The schema definition array as it was returned by the module's *   hook_schema(). */function _drupal_initialize_schema($module, &$schema) {  // Set the name and module key for all tables.  foreach ($schema as $name => $table) {    if (empty($table['module'])) {      $schema[$name]['module'] = $module;    }    if (!isset($table['name'])) {      $schema[$name]['name'] = $name;    }  }}/** * Retrieve a list of fields from a table schema. The list is suitable for use in a SQL query. * * @param $table *   The name of the table from which to retrieve fields. * @param *   An optional prefix to to all fields. * * @return An array of fields. **/function drupal_schema_fields_sql($table, $prefix = NULL) {  $schema = drupal_get_schema($table);  $fields = array_keys($schema['fields']);  if ($prefix) {    $columns = array();    foreach ($fields as $field) {      $columns[] = "$prefix.$field";    }    return $columns;  }  else {    return $fields;  }}/** * Save a record to the database based upon the schema. * * Default values are filled in for missing items, and 'serial' (auto increment) * types are filled in with IDs. * * @param $table *   The name of the table; this must exist in schema API. * @param $object *   The object to write. This is a reference, as defaults according to *   the schema may be filled in on the object, as well as ID on the serial *   type(s). Both array an object types may be passed. * @param $update *   If this is an update, specify the primary keys' field names. It is the *   caller's responsibility to know if a record for this object already *   exists in the database. If there is only 1 key, you may pass a simple string. * @return *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or *   SAVED_UPDATED is returned depending on the operation performed. The *   $object parameter contains values for any serial fields defined by *   the $table. For example, $object->nid will be populated after inserting *   a new node. */function drupal_write_record($table, &$object, $update = array()) {  // Standardize $update to an array.  if (is_string($update)) {    $update = array($update);  }  $schema = drupal_get_schema($table);  if (empty($schema)) {    return FALSE;  }  // Convert to an object if needed.  if (is_array($object)) {    $object = (object) $object;    $array = TRUE;  }  else {    $array = FALSE;  }  $fields = $defs = $values = $serials = $placeholders = array();  // Go through our schema, build SQL, and when inserting, fill in defaults for  // fields that are not set.  foreach ($schema['fields'] as $field => $info) {    // Special case -- skip serial types if we are updating.    if ($info['type'] == 'serial' && count($update)) {      continue;    }    // For inserts, populate defaults from Schema if not already provided    if (!isset($object->$field) && !count($update) && isset($info['default'])) {      $object->$field = $info['default'];    }    // Track serial fields so we can helpfully populate them after the query.    if ($info['type'] == 'serial') {      $serials[] = $field;      // Ignore values for serials when inserting data. Unsupported.      unset($object->$field);    }    // Build arrays for the fields, placeholders, and values in our query.    if (isset($object->$field)) {      $fields[] = $field;      $placeholders[] = db_type_placeholder($info['type']);      if (empty($info['serialize'])) {        $values[] = $object->$field;      }      else {        $values[] = serialize($object->$field);      }    }  }  // Build the SQL.  $query = '';  if (!count($update)) {    $query = "INSERT INTO {". $table ."} (". implode(', ', $fields) .') VALUES ('. implode(', ', $placeholders) .')';    $return = SAVED_NEW;  }  else {    $query = '';    foreach ($fields as $id => $field) {      if ($query) {        $query .= ', ';      }      $query .= $field .' = '. $placeholders[$id];    }    foreach ($update as $key){      $conditions[] = "$key = ". db_type_placeholder($schema['fields'][$key]['type']);      $values[] = $object->$key;    }    $query = "UPDATE {". $table ."} SET $query WHERE ". implode(' AND ', $conditions);    $return = SAVED_UPDATED;  }  // Execute the SQL.  if (db_query($query, $values)) {    if ($serials) {      // Get last insert ids and fill them in.      foreach ($serials as $field) {        $object->$field = db_last_insert_id($table, $field);      }    }  }  else {    $return = FALSE;  }  // If we began with an array, convert back so we don't surprise the caller.  if ($array) {    $object = (array) $object;  }  return $return;}/** * @} End of "ingroup schemaapi". *//** * Parse Drupal info file format. * * Files should use an ini-like format to specify values. * White-space generally doesn't matter, except inside values. * e.g. * * @code *   key = value *   key = "value" *   key = 'value' *   key = "multi-line * *   value" *   key = 'multi-line * *   value' *   key *   = *   'value' * @endcode * * Arrays are created using a GET-like syntax: * * @code *   key[] = "numeric array" *   key[index] = "associative array" *   key[index][] = "nested numeric array" *   key[index][index] = "nested associative array" * @endcode * * PHP constants are substituted in, but only when used as the entire value: * * Comments should start with a semi-colon at the beginning of a line. * * This function is NOT for placing arbitrary module-specific settings. Use * variable_get() and variable_set() for that. * * Information stored in the module.info file: * - name: The real name of the module for display purposes. * - description: A brief description of the module. * - dependencies: An array of shortnames of other modules this module depends on. * - package: The name of the package of modules this module belongs to. * * Example of .info file: * @code *   name = Forum *   description = Enables threaded discussions about general topics. *   dependencies[] = taxonomy *   dependencies[] = comment *   package = Core - optional *   version = VERSION * @endcode * * @param $filename *   The file we are parsing. Accepts file with relative or absolute path. * @return *   The info array. */function drupal_parse_info_file($filename) {  $info = array();  $constants = get_defined_constants();  if (!file_exists($filename)) {    return $info;  }  $data = file_get_contents($filename);  if (preg_match_all('    @^\s*                           # Start at the beginning of a line, ignoring leading whitespace    ((?:      [^=;\[\]]|                    # Key names cannot contain equal signs, semi-colons or square brackets,      \[[^\[\]]*\]                  # unless they are balanced and not nested    )+?)    \s*=\s*                         # Key/value pairs are separated by equal signs (ignoring white-space)    (?:      ("(?:[^"]|(?<=\\\\)")*")|     # Double-quoted string, which may contain slash-escaped quotes/slashes      (\'(?:[^\']|(?<=\\\\)\')*\')| # Single-quoted string, which may contain slash-escaped quotes/slashes      ([^\r\n]*?)                   # Non-quoted string    )\s*$                           # Stop at the next end of a line, ignoring trailing whitespace    @msx', $data, $matches, PREG_SET_ORDER)) {    foreach ($matches as $match) {      // Fetch the key and value string      $i = 0;      foreach (array('key', 'value1', 'value2', 'value3') as $var) {        $$var = isset($match[++$i]) ? $match[$i] : '';      }      $value = stripslashes(substr($value1, 1, -1)) . stripslashes(substr($value2, 1, -1)) . $value3;      // Parse array syntax      $keys = preg_split('/\]?\[/', rtrim($key, ']'));      $last = array_pop($keys);      $parent = &$info;      // Create nested arrays      foreach ($keys as $key) {        if ($key == '') {          $key = count($parent);        }        if (!isset($parent[$key]) || !is_array($parent[$key])) {          $parent[$key] = array();        }        $parent = &$parent[$key];      }      // Handle PHP constants.      if (isset($constants[$value])) {        $value = $constants[$value];      }      // Insert actual value      if ($last == '') {        $last = count($parent);      }      $parent[$last] = $value;    }  }  return $info;}/** * @return *   Array of the possible severity levels for log messages. * * @see watchdog */function watchdog_severity_levels() {  return array(    WATCHDOG_EMERG    => t('emergency'),    WATCHDOG_ALERT    => t('alert'),    WATCHDOG_CRITICAL => t('critical'),    WATCHDOG_ERROR    => t('error'),    WATCHDOG_WARNING  => t('warning'),    WATCHDOG_NOTICE   => t('notice'),    WATCHDOG_INFO     => t('info'),    WATCHDOG_DEBUG    => t('debug'),  );}/** * Explode a string of given tags into an array. */function drupal_explode_tags($tags) {  // This regexp allows the following types of user input:  // this, "somecompany, llc", "and ""this"" w,o.rks", foo bar  $regexp = '%(?:^|,\ *)("(?>[^"]*)(?>""[^"]* )*"|(?: [^",]*))%x';  preg_match_all($regexp, $tags, $matches);  $typed_tags = array_unique($matches[1]);  $tags = array();  foreach ($typed_tags as $tag) {    // If a user has escaped a term (to demonstrate that it is a group,    // or includes a comma or quote character), we remove the escape    // formatting so to save the term into the database as the user intends.    $tag = trim(str_replace('""', '"', preg_replace('/^"(.*)"$/', '\1', $tag)));    if ($tag != "") {      $tags[] = $tag;    }  }  return $tags;}/** * Implode an array of tags into a string. */function drupal_implode_tags($tags) {  $encoded_tags = array();  foreach ($tags as $tag) {    // Commas and quotes in tag names are special cases, so encode them.    if (strpos($tag, ',') !== FALSE || strpos($tag, '"') !== FALSE) {      $tag = '"'. str_replace('"', '""', $tag) .'"';    }    $encoded_tags[] = $tag;  }  return implode(', ', $encoded_tags);}/** * Flush all cached data on the site. * * Empties cache tables, rebuilds the menu cache and theme registries, and * invokes a hook so that other modules' cache data can be cleared as well. */function drupal_flush_all_caches() {  // Change query-strings on css/js files to enforce reload for all users.  _drupal_flush_css_js();  drupal_clear_css_cache();  drupal_clear_js_cache();  // If invoked from update.php, we must not update the theme information in the  // database, or this will result in all themes being disabled.  if (defined('MAINTENANCE_MODE') && MAINTENANCE_MODE == 'update') {    _system_theme_data();  }  else {    system_theme_data();  }  drupal_rebuild_theme_registry();  menu_rebuild();  node_types_rebuild();  // Don't clear cache_form - in-progress form submissions may break.  // Ordered so clearing the page cache will always be the last action.  $core = array('cache', 'cache_block', 'cache_filter', 'cache_page');  $cache_tables = array_merge(module_invoke_all('flush_caches'), $core);  foreach ($cache_tables as $table) {    cache_clear_all('*', $table, TRUE);  }}/** * Helper function to change query-strings on css/js files. * * Changes the character added to all css/js files as dummy query-string, * so that all browsers are forced to reload fresh files. We keep * 20 characters history (FIFO) to avoid repeats, but only the first * (newest) character is actually used on urls, to keep them short. * This is also called from update.php. */function _drupal_flush_css_js() {  $string_history = variable_get('css_js_query_string', '00000000000000000000');  $new_character = $string_history[0];  // Not including 'q' to allow certain JavaScripts to re-use query string.  $characters = 'abcdefghijklmnoprstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';  while (strpos($string_history, $new_character) !== FALSE) {    $new_character = $characters[mt_rand(0, strlen($characters) - 1)];  }  variable_set('css_js_query_string', $new_character . substr($string_history, 0, 19));}
<?php// $Id$/** * @file * User page callbacks for the forum module. *//** * Menu callback; prints a forum listing. */function forum_page($tid = 0) {  if (!is_numeric($tid)) {    return MENU_NOT_FOUND;  }  $tid = (int)$tid;  $topics = '';  $forum_per_page = variable_get('forum_per_page', 25);  $sortby = variable_get('forum_order', 1);  $forums = forum_get_forums($tid);  $parents = taxonomy_get_parents_all($tid);  if ($tid && !in_array($tid, variable_get('forum_containers', array()))) {    $topics = forum_get_topics($tid, $sortby, $forum_per_page);  }  return theme('forums', $forums, $topics, $parents, $tid, $sortby, $forum_per_page);}
<?php// $Id$/** * Implementation of hook_install(). */function poll_install() {  // Create tables.  drupal_install_schema('poll');}/** * Implementation of hook_uninstall(). */function poll_uninstall() {  // Remove tables.  drupal_uninstall_schema('poll');}/** * Implementation of hook_schema(). */function poll_schema() {  $schema['poll'] = array(    'description' => 'Stores poll-specific information for poll nodes.',    'fields' => array(      'nid'     => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The poll's {node}.nid."        ),      'runtime' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The number of seconds past {node}.created during which the poll is open.'        ),      'active'  => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Boolean indicating whether or not the poll is open.',        ),      ),    'primary key' => array('nid'),    );  $schema['poll_choices'] = array(    'description' => 'Stores information about all choices for all {poll}s.',    'fields' => array(      'chid'    => array(        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'Unique identifier for a poll choice.',        ),      'nid'     => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid this choice belongs to.',        ),      'chtext'  => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'The text for this choice.',        ),      'chvotes' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The total number of votes this choice has received by all users.',        ),      'chorder' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'description' => 'The sort order of this choice among all choices for the same node.',        )      ),    'indexes' => array(      'nid' => array('nid')      ),    'primary key' => array('chid'),    );  $schema['poll_votes'] = array(    'description' => 'Stores per-{users} votes for each {poll}.',    'fields' => array(      'nid'      => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'description' => 'The {poll} node this vote is for.',        ),      'uid'      => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {users}.uid this vote is from unless the voter was anonymous.',        ),      'chorder'  => array(        'type' => 'int',        'not null' => TRUE,        'default' => -1,        'description' => "The {users}'s vote for this poll.",        ),      'hostname' => array(        'type' => 'varchar',        'length' => 128,        'not null' => TRUE,        'default' => '',        'description' => 'The IP address this vote is from unless the voter was logged in.',        ),      ),    'primary key' => array('nid', 'uid', 'hostname'),    'indexes' => array(      'hostname' => array('hostname'),      'uid'      => array('uid'),      ),    );  return $schema;}
<?php// $Id$/** * @file * User page callbacks for the contact module. *//** * Site-wide contact page. */function contact_site_page() {  global $user;  if (!flood_is_allowed('contact', variable_get('contact_hourly_threshold', 3))) {    $output = t("You cannot send more than %number messages per hour. Please try again later.", array('%number' => variable_get('contact_hourly_threshold', 3)));  }  else {    $output = drupal_get_form('contact_mail_page');  }  return $output;}function contact_mail_page() {  global $user;  $form = $categories = array();  $result = db_query('SELECT cid, category, selected FROM {contact} ORDER BY weight, category');  while ($category = db_fetch_object($result)) {    $categories[$category->cid] = $category->category;    if ($category->selected) {      $default_category = $category->cid;    }  }  if (count($categories) > 0) {    $form['#token'] = $user->uid ? $user->name . $user->mail : '';    $form['contact_information'] = array('#value' => filter_xss_admin(variable_get('contact_form_information', t('You can leave a message using the contact form below.'))));    $form['name'] = array('#type' => 'textfield',      '#title' => t('Your name'),      '#maxlength' => 255,      '#default_value' => $user->uid ? $user->name : '',      '#required' => TRUE,    );    $form['mail'] = array('#type' => 'textfield',      '#title' => t('Your e-mail address'),      '#maxlength' => 255,      '#default_value' => $user->uid ? $user->mail : '',      '#required' => TRUE,    );    $form['subject'] = array('#type' => 'textfield',      '#title' => t('Subject'),      '#maxlength' => 255,      '#required' => TRUE,    );    if (count($categories) > 1) {      // If there is more than one category available and no default category has been selected,      // prepend a default placeholder value.      if (!isset($default_category)) {        $default_category = t('- Please choose -');        $categories = array($default_category) + $categories;      }      $form['cid'] = array('#type' => 'select',        '#title' => t('Category'),        '#default_value' => $default_category,        '#options' => $categories,        '#required' => TRUE,      );    }    else {      // If there is only one category, store its cid.      $category_keys = array_keys($categories);      $form['cid'] = array('#type' => 'value',        '#value' => array_shift($category_keys),      );    }    $form['message'] = array('#type' => 'textarea',      '#title' => t('Message'),      '#required' => TRUE,    );    // We do not allow anonymous users to send themselves a copy    // because it can be abused to spam people.    if ($user->uid) {      $form['copy'] = array('#type' => 'checkbox',        '#title' => t('Send yourself a copy.'),      );    }    else {      $form['copy'] = array('#type' => 'value', '#value' => FALSE);    }    $form['submit'] = array('#type' => 'submit',      '#value' => t('Send e-mail'),    );  }  else {    drupal_set_message(t('The contact form has not been configured. <a href="@add">Add one or more categories</a> to the form.', array('@add' => url('admin/build/contact/add'))), 'error');  }  return $form;}/** * Validate the site-wide contact page form submission. */function contact_mail_page_validate($form, &$form_state) {  if (!$form_state['values']['cid']) {    form_set_error('cid', t('You must select a valid category.'));  }  if (!valid_email_address($form_state['values']['mail'])) {    form_set_error('mail', t('You must enter a valid e-mail address.'));  }}/** * Process the site-wide contact page form submission. */function contact_mail_page_submit($form, &$form_state) {  global $language;  $values = $form_state['values'];  // E-mail address of the sender: as the form field is a text field,  // all instances of \r and \n have been automatically stripped from it.  $from = $values['mail'];  // Load category properties and save form values for email composition.  $contact = contact_load($values['cid']);  $values['contact'] = $contact;  // Send the e-mail to the recipients using the site default language.  drupal_mail('contact', 'page_mail', $contact['recipients'], language_default(), $values, $from);  // If the user requests it, send a copy using the current language.  if ($values['copy']) {    drupal_mail('contact', 'page_copy', $from, $language, $values, $from);  }  // Send an auto-reply if necessary using the current language.  if ($contact['reply']) {    drupal_mail('contact', 'page_autoreply', $from, $language, $values, $contact['recipients']);  }  flood_register_event('contact');  watchdog('mail', '%name-from sent an e-mail regarding %category.', array('%name-from' => $values['name'] ." [$from]", '%category' => $contact['category']));  drupal_set_message(t('Your message has been sent.'));  // Jump to home page rather than back to contact page to avoid  // contradictory messages if flood control has been activated.  $form_state['redirect'] = '';}/** * Personal contact page. */function contact_user_page($account) {  global $user;  if (!valid_email_address($user->mail)) {    $output = t('You need to provide a valid e-mail address to contact other users. Please update your <a href="@url">user information</a> and try again.', array('@url' => url("user/$user->uid/edit")));  }  else if (!flood_is_allowed('contact', variable_get('contact_hourly_threshold', 3))) {    $output = t('You cannot contact more than %number users per hour. Please try again later.', array('%number' => variable_get('contact_hourly_threshold', 3)));  }  else {    drupal_set_title(check_plain($account->name));    $output = drupal_get_form('contact_mail_user', $account);  }  return $output;}function contact_mail_user(&$form_state, $recipient) {  global $user;  $form['#token'] = $user->name . $user->mail;  $form['recipient'] = array('#type' => 'value', '#value' => $recipient);  $form['from'] = array('#type' => 'item',    '#title' => t('From'),    '#value' => theme('username', $user) .' &lt;'. check_plain($user->mail) .'&gt;',  );  $form['to'] = array('#type' => 'item',    '#title' => t('To'),    '#value' => theme('username', $recipient),  );  $form['subject'] = array('#type' => 'textfield',    '#title' => t('Subject'),    '#maxlength' => 50,    '#required' => TRUE,  );  $form['message'] = array('#type' => 'textarea',    '#title' => t('Message'),    '#rows' => 15,    '#required' => TRUE,  );  $form['copy'] = array('#type' => 'checkbox',    '#title' => t('Send yourself a copy.'),  );  $form['submit'] = array('#type' => 'submit',    '#value' => t('Send e-mail'),  );  return $form;}/** * Process the personal contact page form submission. */function contact_mail_user_submit($form, &$form_state) {  global $user, $language;  $account = $form_state['values']['recipient'];  // Send from the current user to the requested user.  $to = $account->mail;  $from = $user->mail;  // Save both users and all form values for email composition.  $values = $form_state['values'];  $values['account'] = $account;  $values['user'] = $user;  // Send the e-mail in the requested user language.  drupal_mail('contact', 'user_mail', $to, user_preferred_language($account), $values, $from);  // Send a copy if requested, using current page language.  if ($form_state['values']['copy']) {    drupal_mail('contact', 'user_copy', $from, $language, $values, $from);  }  flood_register_event('contact');  watchdog('mail', '%name-from sent %name-to an e-mail.', array('%name-from' => $user->name, '%name-to' => $account->name));  drupal_set_message(t('The message has been sent.'));  // Back to the requested users profile page.  $form_state['redirect'] = "user/$account->uid";}
<?php// $Id$/** * @file * Admin page callback file for the user module. */function user_admin($callback_arg = '') {  $op = isset($_POST['op']) ? $_POST['op'] : $callback_arg;  switch ($op) {    case t('Create new account'):    case 'create':      $output = drupal_get_form('user_register');      break;    default:      if (!empty($_POST['accounts']) && isset($_POST['operation']) && ($_POST['operation'] == 'delete')) {        $output = drupal_get_form('user_multiple_delete_confirm');      }      else {        $output = drupal_get_form('user_filter_form');        $output .= drupal_get_form('user_admin_account');      }  }  return $output;}/** * Form builder; Return form for user administration filters. * * @ingroup forms * @see user_filter_form_submit() */function user_filter_form() {  $session = &$_SESSION['user_overview_filter'];  $session = is_array($session) ? $session : array();  $filters = user_filters();  $i = 0;  $form['filters'] = array(    '#type' => 'fieldset',    '#title' => t('Show only users where'),    '#theme' => 'user_filters',  );  foreach ($session as $filter) {    list($type, $value) = $filter;    // Merge an array of arrays into one if necessary.    $options = $type == 'permission' ? call_user_func_array('array_merge', $filters[$type]['options']) : $filters[$type]['options'];    $params = array('%property' => $filters[$type]['title'] , '%value' => $options[$value]);    if ($i++ > 0) {      $form['filters']['current'][] = array('#value' => t('<em>and</em> where <strong>%property</strong> is <strong>%value</strong>', $params));    }    else {      $form['filters']['current'][] = array('#value' => t('<strong>%property</strong> is <strong>%value</strong>', $params));    }  }  foreach ($filters as $key => $filter) {    $names[$key] = $filter['title'];    $form['filters']['status'][$key] = array(      '#type' => 'select',      '#options' => $filter['options'],    );  }  $form['filters']['filter'] = array(    '#type' => 'radios',    '#options' => $names,  );  $form['filters']['buttons']['submit'] = array(    '#type' => 'submit',    '#value' => (count($session) ? t('Refine') : t('Filter')),  );  if (count($session)) {    $form['filters']['buttons']['undo'] = array(      '#type' => 'submit',      '#value' => t('Undo'),    );    $form['filters']['buttons']['reset'] = array(      '#type' => 'submit',      '#value' => t('Reset'),    );  }  drupal_add_js('misc/form.js', 'core');  return $form;}/** * Process result from user administration filter form. */function user_filter_form_submit($form, &$form_state) {  $op = $form_state['values']['op'];  $filters = user_filters();  switch ($op) {    case t('Filter'): case t('Refine'):      if (isset($form_state['values']['filter'])) {        $filter = $form_state['values']['filter'];        // Merge an array of arrays into one if necessary.        $options = $filter == 'permission' ? call_user_func_array('array_merge', $filters[$filter]['options']) : $filters[$filter]['options'];        if (isset($options[$form_state['values'][$filter]])) {          $_SESSION['user_overview_filter'][] = array($filter, $form_state['values'][$filter]);        }      }      break;    case t('Undo'):      array_pop($_SESSION['user_overview_filter']);      break;    case t('Reset'):      $_SESSION['user_overview_filter'] = array();      break;    case t('Update'):      return;  }  $form_state['redirect'] = 'admin/user/user';  return;}/** * Form builder; User administration page. * * @ingroup forms * @see user_admin_account_validate() * @see user_admin_account_submit() */function user_admin_account() {  $filter = user_build_filter_query();  $header = array(    array(),    array('data' => t('Username'), 'field' => 'u.name'),    array('data' => t('Status'), 'field' => 'u.status'),    t('Roles'),    array('data' => t('Member for'), 'field' => 'u.created', 'sort' => 'desc'),    array('data' => t('Last access'), 'field' => 'u.access'),    t('Operations')  );  if ($filter['join'] != "") {    $sql = 'SELECT DISTINCT u.uid, u.name, u.status, u.created, u.access FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid '. $filter['join'] .' WHERE u.uid != 0 '. $filter['where'];    $query_count = 'SELECT COUNT(DISTINCT u.uid) FROM {users} u LEFT JOIN {users_roles} ur ON u.uid = ur.uid '. $filter['join'] .' WHERE u.uid != 0 '. $filter['where'];  }  else {    $sql = 'SELECT u.uid, u.name, u.status, u.created, u.access FROM {users} u WHERE u.uid != 0 '. $filter['where'];    $query_count = 'SELECT COUNT(u.uid) FROM {users} u WHERE u.uid != 0 '. $filter['where'];  }    $sql .= tablesort_sql($header);  $result = pager_query($sql, 50, 0, $query_count, $filter['args']);  $form['options'] = array(    '#type' => 'fieldset',    '#title' => t('Update options'),    '#prefix' => '<div class="container-inline">',    '#suffix' => '</div>',  );  $options = array();  foreach (module_invoke_all('user_operations') as $operation => $array) {    $options[$operation] = $array['label'];  }  $form['options']['operation'] = array(    '#type' => 'select',    '#options' => $options,    '#default_value' => 'unblock',  );  $form['options']['submit'] = array(    '#type' => 'submit',    '#value' => t('Update'),  );  $destination = drupal_get_destination();  $status = array(t('blocked'), t('active'));  $roles = user_roles(TRUE);  $accounts = array();  while ($account = db_fetch_object($result)) {    $accounts[$account->uid] = '';    $form['name'][$account->uid] = array('#value' => theme('username', $account));    $form['status'][$account->uid] =  array('#value' => $status[$account->status]);    $users_roles = array();    $roles_result = db_query('SELECT rid FROM {users_roles} WHERE uid = %d', $account->uid);    while ($user_role = db_fetch_object($roles_result)) {      $users_roles[] = $roles[$user_role->rid];    }    asort($users_roles);    $form['roles'][$account->uid][0] = array('#value' => theme('item_list', $users_roles));    $form['member_for'][$account->uid] = array('#value' => format_interval(time() - $account->created));    $form['last_access'][$account->uid] =  array('#value' => $account->access ? t('@time ago', array('@time' => format_interval(time() - $account->access))) : t('never'));    $form['operations'][$account->uid] = array('#value' => l(t('edit'), "user/$account->uid/edit", array('query' => $destination)));  }  $form['accounts'] = array(    '#type' => 'checkboxes',    '#options' => $accounts  );  $form['pager'] = array('#value' => theme('pager', NULL, 50, 0));  return $form;}/** * Submit the user administration update form. */function user_admin_account_submit($form, &$form_state) {  $operations = module_invoke_all('user_operations', $form_state);  $operation = $operations[$form_state['values']['operation']];  // Filter out unchecked accounts.  $accounts = array_filter($form_state['values']['accounts']);  if ($function = $operation['callback']) {    // Add in callback arguments if present.    if (isset($operation['callback arguments'])) {      $args = array_merge(array($accounts), $operation['callback arguments']);    }    else {      $args = array($accounts);    }    call_user_func_array($function, $args);    drupal_set_message(t('The update has been performed.'));  }}function user_admin_account_validate($form, &$form_state) {  $form_state['values']['accounts'] = array_filter($form_state['values']['accounts']);  if (count($form_state['values']['accounts']) == 0) {    form_set_error('', t('No users selected.'));  }}/** * Form builder; Configure user settings for this site. * * @ingroup forms * @see system_settings_form() */function user_admin_settings() {  // User registration settings.  $form['registration'] = array('#type' => 'fieldset', '#title' => t('User registration settings'));  $form['registration']['user_register'] = array('#type' => 'radios', '#title' => t('Public registrations'), '#default_value' => variable_get('user_register', 1), '#options' => array(t('Only site administrators can create new user accounts.'), t('Visitors can create accounts and no administrator approval is required.'), t('Visitors can create accounts but administrator approval is required.')));  $form['registration']['user_email_verification'] = array('#type' => 'checkbox', '#title' => t('Require e-mail verification when a visitor creates an account'), '#default_value' => variable_get('user_email_verification', TRUE), '#description' => t('If this box is checked, new users will be required to validate their e-mail address prior to logging into the site, and will be assigned a system-generated password. With it unchecked, users will be logged in immediately upon registering, and may select their own passwords during registration.'));  $form['registration']['user_registration_help'] = array('#type' => 'textarea', '#title' => t('User registration guidelines'), '#default_value' => variable_get('user_registration_help', ''), '#description' => t('This text is displayed at the top of the user registration form and is useful for helping or instructing your users.'));  // User e-mail settings.  $form['email'] = array(    '#type' => 'fieldset',    '#title' => t('User e-mail settings'),    '#description' => t('Drupal sends emails whenever new users register on your site, and optionally, may also notify users after other account actions. Using a simple set of content templates, notification e-mails can be customized to fit the specific needs of your site.'),  );  // These email tokens are shared for all settings, so just define  // the list once to help ensure they stay in sync.  $email_token_help = t('Available variables are:') .' !username, !site, !password, !uri, !uri_brief, !mailto, !date, !login_uri, !edit_uri, !login_url.';  $form['email']['admin_created'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, new user created by administrator'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 0),    '#description' => t('Customize welcome e-mail messages sent to new member accounts created by an administrator.') .' '. $email_token_help,  );  $form['email']['admin_created']['user_mail_register_admin_created_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_admin_created_subject'),    '#maxlength' => 180,  );  $form['email']['admin_created']['user_mail_register_admin_created_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_admin_created_body'),    '#rows' => 15,  );  $form['email']['no_approval_required'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, no approval required'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 1),    '#description' => t('Customize welcome e-mail messages sent to new members upon registering, when no administrator approval is required.') .' '. $email_token_help  );  $form['email']['no_approval_required']['user_mail_register_no_approval_required_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_no_approval_required_subject'),    '#maxlength' => 180,  );  $form['email']['no_approval_required']['user_mail_register_no_approval_required_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_no_approval_required_body'),    '#rows' => 15,  );  $form['email']['pending_approval'] = array(    '#type' => 'fieldset',    '#title' => t('Welcome, awaiting administrator approval'),    '#collapsible' => TRUE,    '#collapsed' => (variable_get('user_register', 1) != 2),    '#description' => t('Customize welcome e-mail messages sent to new members upon registering, when administrative approval is required.') .' '. $email_token_help,  );  $form['email']['pending_approval']['user_mail_register_pending_approval_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('register_pending_approval_subject'),    '#maxlength' => 180,  );  $form['email']['pending_approval']['user_mail_register_pending_approval_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('register_pending_approval_body'),    '#rows' => 8,  );  $form['email']['password_reset'] = array(    '#type' => 'fieldset',    '#title' => t('Password recovery email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Customize e-mail messages sent to users who request a new password.') .' '. $email_token_help,  );  $form['email']['password_reset']['user_mail_password_reset_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('password_reset_subject'),    '#maxlength' => 180,  );  $form['email']['password_reset']['user_mail_password_reset_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('password_reset_body'),    '#rows' => 12,  );  $form['email']['activated'] = array(    '#type' => 'fieldset',    '#title' => t('Account activation email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users upon account activation (when an administrator activates an account of a user who has already registered, on a site where administrative approval is required).') .' '. $email_token_help,  );  $form['email']['activated']['user_mail_status_activated_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is activated.'),    '#default_value' => variable_get('user_mail_status_activated_notify', TRUE),  );  $form['email']['activated']['user_mail_status_activated_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_activated_subject'),    '#maxlength' => 180,  );  $form['email']['activated']['user_mail_status_activated_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_activated_body'),    '#rows' => 15,  );  $form['email']['blocked'] = array(    '#type' => 'fieldset',    '#title' => t('Account blocked email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users when their accounts are blocked.') .' '. $email_token_help,  );  $form['email']['blocked']['user_mail_status_blocked_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is blocked.'),    '#default_value' => variable_get('user_mail_status_blocked_notify', FALSE),  );  $form['email']['blocked']['user_mail_status_blocked_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_blocked_subject'),    '#maxlength' => 180,  );  $form['email']['blocked']['user_mail_status_blocked_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_blocked_body'),    '#rows' => 3,  );  $form['email']['deleted'] = array(    '#type' => 'fieldset',    '#title' => t('Account deleted email'),    '#collapsible' => TRUE,    '#collapsed' => TRUE,    '#description' => t('Enable and customize e-mail messages sent to users when their accounts are deleted.') .' '. $email_token_help,  );  $form['email']['deleted']['user_mail_status_deleted_notify'] = array(    '#type' => 'checkbox',    '#title' => t('Notify user when account is deleted.'),    '#default_value' => variable_get('user_mail_status_deleted_notify', FALSE),  );  $form['email']['deleted']['user_mail_status_deleted_subject'] = array(    '#type' => 'textfield',    '#title' => t('Subject'),    '#default_value' => _user_mail_text('status_deleted_subject'),    '#maxlength' => 180,  );  $form['email']['deleted']['user_mail_status_deleted_body'] = array(    '#type' => 'textarea',    '#title' => t('Body'),    '#default_value' => _user_mail_text('status_deleted_body'),    '#rows' => 3,  );  // User signatures.  $form['signatures'] = array(    '#type' => 'fieldset',    '#title' => t('Signatures'),  );  $form['signatures']['user_signatures'] = array(    '#type' => 'radios',    '#title' => t('Signature support'),    '#default_value' => variable_get('user_signatures', 0),    '#options' => array(t('Disabled'), t('Enabled')),  );  // If picture support is enabled, check whether the picture directory exists:  if (variable_get('user_pictures', 0)) {    $picture_path = file_create_path(variable_get('user_picture_path', 'pictures'));    file_check_directory($picture_path, 1, 'user_picture_path');  }  $form['pictures'] = array(    '#type' => 'fieldset',    '#title' => t('Pictures'),  );  $picture_support = variable_get('user_pictures', 0);  $form['pictures']['user_pictures'] = array(    '#type' => 'radios',    '#title' => t('Picture support'),    '#default_value' => $picture_support,    '#options' => array(t('Disabled'), t('Enabled')),    '#prefix' => '<div class="user-admin-picture-radios">',    '#suffix' => '</div>',  );  drupal_add_js(drupal_get_path('module', 'user') .'/user.js');  // If JS is enabled, and the radio is defaulting to off, hide all  // the settings on page load via .css using the js-hide class so  // that there's no flicker.  $css_class = 'user-admin-picture-settings';  if (!$picture_support) {    $css_class .= ' js-hide';  }  $form['pictures']['settings'] = array(    '#prefix' => '<div class="'. $css_class .'">',    '#suffix' => '</div>',  );  $form['pictures']['settings']['user_picture_path'] = array(    '#type' => 'textfield',    '#title' => t('Picture image path'),    '#default_value' => variable_get('user_picture_path', 'pictures'),    '#size' => 30,    '#maxlength' => 255,    '#description' => t('Subdirectory in the directory %dir where pictures will be stored.', array('%dir' => file_directory_path() .'/')),  );  $form['pictures']['settings']['user_picture_default'] = array(    '#type' => 'textfield',    '#title' => t('Default picture'),    '#default_value' => variable_get('user_picture_default', ''),    '#size' => 30,    '#maxlength' => 255,    '#description' => t('URL of picture to display for users with no custom picture selected. Leave blank for none.'),  );  $form['pictures']['settings']['user_picture_dimensions'] = array(    '#type' => 'textfield',    '#title' => t('Picture maximum dimensions'),    '#default_value' => variable_get('user_picture_dimensions', '85x85'),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('Maximum dimensions for pictures, in pixels.'),  );  $form['pictures']['settings']['user_picture_file_size'] = array(    '#type' => 'textfield',    '#title' => t('Picture maximum file size'),    '#default_value' => variable_get('user_picture_file_size', '30'),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('Maximum file size for pictures, in kB.'),  );  $form['pictures']['settings']['user_picture_guidelines'] = array(    '#type' => 'textarea',    '#title' => t('Picture guidelines'),    '#default_value' => variable_get('user_picture_guidelines', ''),    '#description' => t("This text is displayed at the picture upload form in addition to the default guidelines. It's useful for helping or instructing your users."),  );  return system_settings_form($form);}/** * Menu callback: administer permissions. * * @ingroup forms * @see user_admin_perm_submit() * @see theme_user_admin_perm() */function user_admin_perm($form_state, $rid = NULL) {  if (is_numeric($rid)) {    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid WHERE r.rid = %d', $rid);  }  else {    $result = db_query('SELECT r.rid, p.perm FROM {role} r LEFT JOIN {permission} p ON r.rid = p.rid ORDER BY name');  }  // Compile role array:  // Add a comma at the end so when searching for a permission, we can  // always search for "$perm," to make sure we do not confuse  // permissions that are substrings of each other.  while ($role = db_fetch_object($result)) {    $role_permissions[$role->rid] = $role->perm .',';  }  // Retrieve role names for columns.  $role_names = user_roles();  if (is_numeric($rid)) {    $role_names = array($rid => $role_names[$rid]);  }  // Render role/permission overview:  $options = array();  foreach (module_list(FALSE, FALSE, TRUE) as $module) {    if ($permissions = module_invoke($module, 'perm')) {      $form['permission'][] = array(        '#value' => $module,      );      asort($permissions);      foreach ($permissions as $perm) {        $options[$perm] = '';        $form['permission'][$perm] = array('#value' => t($perm));        foreach ($role_names as $rid => $name) {          // Builds arrays for checked boxes for each role          if (strpos($role_permissions[$rid], $perm .',') !== FALSE) {            $status[$rid][] = $perm;          }        }      }    }  }  // Have to build checkboxes here after checkbox arrays are built  foreach ($role_names as $rid => $name) {    $form['checkboxes'][$rid] = array('#type' => 'checkboxes', '#options' => $options, '#default_value' => isset($status[$rid]) ? $status[$rid] : array());    $form['role_names'][$rid] = array('#value' => $name, '#tree' => TRUE);  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save permissions'));  return $form;}function user_admin_perm_submit($form, &$form_state) {  // Save permissions:  $result = db_query('SELECT * FROM {role}');  while ($role = db_fetch_object($result)) {    if (isset($form_state['values'][$role->rid])) {      // Delete, so if we clear every checkbox we reset that role;      // otherwise permissions are active and denied everywhere.      db_query('DELETE FROM {permission} WHERE rid = %d', $role->rid);      $form_state['values'][$role->rid] = array_filter($form_state['values'][$role->rid]);      if (count($form_state['values'][$role->rid])) {        db_query("INSERT INTO {permission} (rid, perm) VALUES (%d, '%s')", $role->rid, implode(', ', array_keys($form_state['values'][$role->rid])));      }    }  }  drupal_set_message(t('The changes have been saved.'));  // Clear the cached pages  cache_clear_all();}/** * Theme the administer permissions page. * * @ingroup themeable */function theme_user_admin_perm($form) {  $roles = user_roles();  foreach (element_children($form['permission']) as $key) {    // Don't take form control structures    if (is_array($form['permission'][$key])) {      $row = array();      // Module name      if (is_numeric($key)) {        $row[] = array('data' => t('@module module', array('@module' => drupal_render($form['permission'][$key]))), 'class' => 'module', 'id' => 'module-'. $form['permission'][$key]['#value'], 'colspan' => count($form['role_names']) + 1);      }      else {        $row[] = array('data' => drupal_render($form['permission'][$key]), 'class' => 'permission');        foreach (element_children($form['checkboxes']) as $rid) {          if (is_array($form['checkboxes'][$rid])) {            $row[] = array('data' => drupal_render($form['checkboxes'][$rid][$key]), 'class' => 'checkbox', 'title' => $roles[$rid] .' : '. t($key));          }        }      }      $rows[] = $row;    }  }  $header[] = (t('Permission'));  foreach (element_children($form['role_names']) as $rid) {    if (is_array($form['role_names'][$rid])) {      $header[] = array('data' => drupal_render($form['role_names'][$rid]), 'class' => 'checkbox');    }  }  $output = theme('table', $header, $rows, array('id' => 'permissions'));  $output .= drupal_render($form);  return $output;}/** * Menu callback: administer roles. * * @ingroup forms * @see user_admin_role_validate() * @see user_admin_role_submit() * @see theme_user_admin_new_role() */function user_admin_role() {  $rid = arg(4);  if ($rid) {    if ($rid == DRUPAL_ANONYMOUS_RID || $rid == DRUPAL_AUTHENTICATED_RID) {      drupal_goto('admin/user/roles');    }    // Display the edit role form.    $role = db_fetch_object(db_query('SELECT * FROM {role} WHERE rid = %d', $rid));    $form['name'] = array(      '#type' => 'textfield',      '#title' => t('Role name'),      '#default_value' => $role->name,      '#size' => 30,      '#required' => TRUE,      '#maxlength' => 64,      '#description' => t('The name for this role. Example: "moderator", "editorial board", "site architect".'),    );    $form['rid'] = array(      '#type' => 'value',      '#value' => $rid,    );    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Save role'),    );    $form['delete'] = array(      '#type' => 'submit',      '#value' => t('Delete role'),    );  }  else {    $form['name'] = array(      '#type' => 'textfield',      '#size' => 32,      '#maxlength' => 64,    );    $form['submit'] = array(      '#type' => 'submit',      '#value' => t('Add role'),    );    $form['#submit'][] = 'user_admin_role_submit';    $form['#validate'][] = 'user_admin_role_validate';  }  return $form;}function user_admin_role_validate($form, &$form_state) {  if ($form_state['values']['name']) {    if ($form_state['values']['op'] == t('Save role')) {      if (db_result(db_query("SELECT COUNT(*) FROM {role} WHERE name = '%s' AND rid != %d", $form_state['values']['name'], $form_state['values']['rid']))) {        form_set_error('name', t('The role name %name already exists. Please choose another role name.', array('%name' => $form_state['values']['name'])));      }    }    else if ($form_state['values']['op'] == t('Add role')) {      if (db_result(db_query("SELECT COUNT(*) FROM {role} WHERE name = '%s'", $form_state['values']['name']))) {        form_set_error('name', t('The role name %name already exists. Please choose another role name.', array('%name' => $form_state['values']['name'])));      }    }  }  else {    form_set_error('name', t('You must specify a valid role name.'));  }}function user_admin_role_submit($form, &$form_state) {  if ($form_state['values']['op'] == t('Save role')) {    db_query("UPDATE {role} SET name = '%s' WHERE rid = %d", $form_state['values']['name'], $form_state['values']['rid']);    drupal_set_message(t('The role has been renamed.'));  }  else if ($form_state['values']['op'] == t('Delete role')) {    db_query('DELETE FROM {role} WHERE rid = %d', $form_state['values']['rid']);    db_query('DELETE FROM {permission} WHERE rid = %d', $form_state['values']['rid']);    // Update the users who have this role set:    db_query('DELETE FROM {users_roles} WHERE rid = %d', $form_state['values']['rid']);    drupal_set_message(t('The role has been deleted.'));  }  else if ($form_state['values']['op'] == t('Add role')) {    db_query("INSERT INTO {role} (name) VALUES ('%s')", $form_state['values']['name']);    drupal_set_message(t('The role has been added.'));  }  $form_state['redirect'] = 'admin/user/roles';  return;}/** * Menu callback: list all access rules */function user_admin_access_check() {  $output = drupal_get_form('user_admin_check_user');  $output .= drupal_get_form('user_admin_check_mail');  $output .= drupal_get_form('user_admin_check_host');  return $output;}/** * Menu callback: add an access rule. */function user_admin_access_add($mask = NULL, $type = NULL) {  $edit = array();  $edit['aid'] = 0;  $edit['mask'] = $mask;  $edit['type'] = $type;  return drupal_get_form('user_admin_access_add_form', $edit, t('Add rule'));}/** * Menu callback: edit an access rule. */function user_admin_access_edit($aid = 0) {  $edit = db_fetch_array(db_query('SELECT aid, type, status, mask FROM {access} WHERE aid = %d', $aid));  return drupal_get_form('user_admin_access_edit_form', $edit, t('Save rule'));}/** * Form builder; Configure access rules. * * @ingroup forms */function user_admin_access_form(&$form_state, $edit, $submit) {  $form = array();  $form['aid'] = array(    '#type' => 'value',    '#value' => $edit['aid'],  );  $form['status'] = array(    '#type' => 'radios',    '#title' => t('Access type'),    '#default_value' => isset($edit['status']) ? $edit['status'] : 0,    '#options' => array('1' => t('Allow'), '0' => t('Deny')),  );  $type_options = array('user' => t('Username'), 'mail' => t('E-mail'), 'host' => t('Host'));  $form['type'] = array(    '#type' => 'radios',    '#title' => t('Rule type'),    '#default_value' => (isset($type_options[$edit['type']]) ? $edit['type'] : 'user'),    '#options' => $type_options,  );  $form['mask'] = array(    '#type' => 'textfield',    '#title' => t('Mask'),    '#size' => 30,    '#maxlength' => 64,    '#default_value' => $edit['mask'],    '#description' => '%: '. t('Matches any number of characters, even zero characters') .'.<br />_: '. t('Matches exactly one character.'),    '#required' => TRUE,  );  $form['submit'] = array('#type' => 'submit', '#value' => $submit);  $form['#submit'] = array('user_admin_access_form_submit');  return $form;}/** * Submit callback for user_admin_access_form(). */function user_admin_access_form_submit($form, &$form_state) {  $edit = $form_state['values'];  if ($edit['aid']) {    db_query("UPDATE {access} SET mask = '%s', type = '%s', status = '%s' WHERE aid = %d", $edit['mask'], $edit['type'], $edit['status'], $edit['aid']);    drupal_set_message(t('The access rule has been saved.'));  }  else {    db_query("INSERT INTO {access} (mask, type, status) VALUES ('%s', '%s', %d)", $edit['mask'], $edit['type'], $edit['status']);    drupal_set_message(t('The access rule has been added.'));  }  $form_state['redirect'] = 'admin/user/rules';}function user_admin_access_check_validate($form, &$form_state) {  if (empty($form_state['values']['test'])) {    form_set_error($form_state['values']['type'], t('No value entered. Please enter a test string and try again.'));  }}function user_admin_check_user() {  $form['user'] = array('#type' => 'fieldset', '#title' => t('Username'));  $form['user']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter a username to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => USERNAME_MAX_LENGTH);  $form['user']['type'] = array('#type' => 'hidden', '#value' => 'user');  $form['user']['submit'] = array('#type' => 'submit', '#value' => t('Check username'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_check_mail() {  $form['mail'] = array('#type' => 'fieldset', '#title' => t('E-mail'));  $form['mail']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter an e-mail address to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => EMAIL_MAX_LENGTH);  $form['mail']['type'] = array('#type' => 'hidden', '#value' => 'mail');  $form['mail']['submit'] = array('#type' => 'submit', '#value' => t('Check e-mail'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_check_host() {  $form['host'] = array('#type' => 'fieldset', '#title' => t('Hostname'));  $form['host']['test'] = array('#type' => 'textfield', '#title' => '', '#description' => t('Enter a hostname or IP address to check if it will be denied or allowed.'), '#size' => 30, '#maxlength' => 64);  $form['host']['type'] = array('#type' => 'hidden', '#value' => 'host');  $form['host']['submit'] = array('#type' => 'submit', '#value' => t('Check hostname'));  $form['#submit'][] = 'user_admin_access_check_submit';  $form['#validate'][] = 'user_admin_access_check_validate';  $form['#theme'] = 'user_admin_access_check';  return $form;}function user_admin_access_check_submit($form, &$form_state) {  switch ($form_state['values']['type']) {    case 'user':      if (drupal_is_denied('user', $form_state['values']['test'])) {        drupal_set_message(t('The username %name is not allowed.', array('%name' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The username %name is allowed.', array('%name' => $form_state['values']['test'])));      }      break;    case 'mail':      if (drupal_is_denied('mail', $form_state['values']['test'])) {        drupal_set_message(t('The e-mail address %mail is not allowed.', array('%mail' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The e-mail address %mail is allowed.', array('%mail' => $form_state['values']['test'])));      }      break;    case 'host':      if (drupal_is_denied('host', $form_state['values']['test'])) {        drupal_set_message(t('The hostname %host is not allowed.', array('%host' => $form_state['values']['test'])));      }      else {        drupal_set_message(t('The hostname %host is allowed.', array('%host' => $form_state['values']['test'])));      }      break;    default:      break;  }}/** * Menu callback: delete an access rule * * @ingroup forms * @see user_admin_access_delete_confirm_submit() */function user_admin_access_delete_confirm($form_state, $aid = 0) {  $access_types = array('user' => t('username'), 'mail' => t('e-mail'), 'host' => t('host'));  $edit = db_fetch_object(db_query('SELECT aid, type, status, mask FROM {access} WHERE aid = %d', $aid));  $form = array();  $form['aid'] = array('#type' => 'hidden', '#value' => $aid);  $output = confirm_form($form,                  t('Are you sure you want to delete the @type rule for %rule?', array('@type' => $access_types[$edit->type], '%rule' => $edit->mask)),                  'admin/user/rules',                  t('This action cannot be undone.'),                  t('Delete'),                  t('Cancel'));  return $output;}function user_admin_access_delete_confirm_submit($form, &$form_state) {  db_query('DELETE FROM {access} WHERE aid = %d', $form_state['values']['aid']);  drupal_set_message(t('The access rule has been deleted.'));  $form_state['redirect'] = 'admin/user/rules';  return;}/** * Menu callback: list all access rules */function user_admin_access() {  $header = array(array('data' => t('Access type'), 'field' => 'status'), array('data' => t('Rule type'), 'field' => 'type'), array('data' => t('Mask'), 'field' => 'mask'), array('data' => t('Operations'), 'colspan' => 2));  $result = db_query("SELECT aid, type, status, mask FROM {access}". tablesort_sql($header));  $access_types = array('user' => t('username'), 'mail' => t('e-mail'), 'host' => t('host'));  $rows = array();  while ($rule = db_fetch_object($result)) {    $rows[] = array($rule->status ? t('allow') : t('deny'), $access_types[$rule->type], $rule->mask, l(t('edit'), 'admin/user/rules/edit/'. $rule->aid), l(t('delete'), 'admin/user/rules/delete/'. $rule->aid));  }  if (empty($rows)) {    $rows[] = array(array('data' => '<em>'. t('There are currently no access rules.') .'</em>', 'colspan' => 5));  }  return theme('table', $header, $rows);}/** * Theme user administration overview. * * @ingroup themeable */function theme_user_admin_account($form) {  // Overview table:  $header = array(    theme('table_select_header_cell'),    array('data' => t('Username'), 'field' => 'u.name'),    array('data' => t('Status'), 'field' => 'u.status'),    t('Roles'),    array('data' => t('Member for'), 'field' => 'u.created', 'sort' => 'desc'),    array('data' => t('Last access'), 'field' => 'u.access'),    t('Operations')  );  $output = drupal_render($form['options']);  if (isset($form['name']) && is_array($form['name'])) {    foreach (element_children($form['name']) as $key) {      $rows[] = array(        drupal_render($form['accounts'][$key]),        drupal_render($form['name'][$key]),        drupal_render($form['status'][$key]),        drupal_render($form['roles'][$key]),        drupal_render($form['member_for'][$key]),        drupal_render($form['last_access'][$key]),        drupal_render($form['operations'][$key]),      );    }  }  else {    $rows[] = array(array('data' => t('No users available.'), 'colspan' => '7'));  }  $output .= theme('table', $header, $rows);  if ($form['pager']['#value']) {    $output .= drupal_render($form['pager']);  }  $output .= drupal_render($form);  return $output;}/** * Theme the new-role form. * * @ingroup themeable */function theme_user_admin_new_role($form) {  $header = array(t('Name'), array('data' => t('Operations'), 'colspan' => 2));  foreach (user_roles() as $rid => $name) {    $edit_permissions = l(t('edit permissions'), 'admin/user/permissions/'. $rid);    if (!in_array($rid, array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID))) {      $rows[] = array($name, l(t('edit role'), 'admin/user/roles/edit/'. $rid), $edit_permissions);    }    else {      $rows[] = array($name, t('locked'), $edit_permissions);    }  }  $rows[] = array(drupal_render($form['name']), array('data' => drupal_render($form['submit']), 'colspan' => 2));  $output = drupal_render($form);  $output .= theme('table', $header, $rows);  return $output;}/** * Theme user administration filter form. * * @ingroup themeable */function theme_user_filter_form($form) {  $output = '<div id="user-admin-filter">';  $output .= drupal_render($form['filters']);  $output .= '</div>';  $output .= drupal_render($form);  return $output;}/** * Theme user administration filter selector. * * @ingroup themeable */function theme_user_filters($form) {  $output = '<ul class="clear-block">';  if (!empty($form['current'])) {    foreach (element_children($form['current']) as $key) {      $output .= '<li>'. drupal_render($form['current'][$key]) .'</li>';    }  }  $output .= '<li><dl class="multiselect">'. (!empty($form['current']) ? '<dt><em>'. t('and') .'</em> '. t('where') .'</dt>' : '') .'<dd class="a">';  foreach (element_children($form['filter']) as $key) {    $output .= drupal_render($form['filter'][$key]);  }  $output .= '</dd>';  $output .= '<dt>'. t('is') .'</dt><dd class="b">';  foreach (element_children($form['status']) as $key) {    $output .= drupal_render($form['status'][$key]);  }  $output .= '</dd>';  $output .= '</dl>';  $output .= '<div class="container-inline" id="user-admin-buttons">'. drupal_render($form['buttons']) .'</div>';  $output .= '</li></ul>';  return $output;}
<?php// $Id$?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="<?php print $language->language ?>" lang="<?php print $language->language ?>" dir="<?php print $language->dir ?>">  <head>    <?php print $head ?>    <title><?php print $head_title ?></title>    <?php print $styles ?>    <?php print $scripts ?>    <!--[if lt IE 7]>      <?php print phptemplate_get_ie_styles(); ?>    <![endif]-->  </head>  <body<?php print phptemplate_body_class($left, $right); ?>><!-- Layout -->  <div id="header-region" class="clear-block"><?php print $header; ?></div>    <div id="wrapper">    <div id="container" class="clear-block">      <div id="header">        <div id="logo-floater">        <?php          // Prepare header          $site_fields = array();          if ($site_name) {            $site_fields[] = check_plain($site_name);          }          if ($site_slogan) {            $site_fields[] = check_plain($site_slogan);          }          $site_title = implode(' ', $site_fields);          if ($site_fields) {            $site_fields[0] = '<span>'. $site_fields[0] .'</span>';          }          $site_html = implode(' ', $site_fields);          if ($logo || $site_title) {            print '<h1><a href="'. check_url($front_page) .'" title="'. $site_title .'">';            if ($logo) {              print '<img src="'. check_url($logo) .'" alt="'. $site_title .'" id="logo" />';            }            print $site_html .'</a></h1>';          }        ?>        </div>        <?php if (isset($primary_links)) : ?>          <?php print theme('links', $primary_links, array('class' => 'links primary-links')) ?>        <?php endif; ?>        <?php if (isset($secondary_links)) : ?>          <?php print theme('links', $secondary_links, array('class' => 'links secondary-links')) ?>        <?php endif; ?>      </div> <!-- /header -->      <?php if ($left): ?>        <div id="sidebar-left" class="sidebar">          <?php if ($search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $left ?>        </div>      <?php endif; ?>      <div id="center"><div id="squeeze"><div class="right-corner"><div class="left-corner">          <?php print $breadcrumb; ?>          <?php if ($mission): print '<div id="mission">'. $mission .'</div>'; endif; ?>          <?php if ($tabs): print '<div id="tabs-wrapper" class="clear-block">'; endif; ?>          <?php if ($title): print '<h2'. ($tabs ? ' class="with-tabs"' : '') .'>'. $title .'</h2>'; endif; ?>          <?php if ($tabs): print '<ul class="tabs primary">'. $tabs .'</ul></div>'; endif; ?>          <?php if ($tabs2): print '<ul class="tabs secondary">'. $tabs2 .'</ul>'; endif; ?>          <?php if ($show_messages && $messages): print $messages; endif; ?>          <?php print $help; ?>          <div class="clear-block">            <?php print $content ?>          </div>          <?php print $feed_icons ?>          <div id="footer"><?php print $footer_message . $footer ?></div>      </div></div></div></div> <!-- /.left-corner, /.right-corner, /#squeeze, /#center -->      <?php if ($right): ?>        <div id="sidebar-right" class="sidebar">          <?php if (!$left && $search_box): ?><div class="block block-theme"><?php print $search_box ?></div><?php endif; ?>          <?php print $right ?>        </div>      <?php endif; ?>    </div> <!-- /container -->  </div><!-- /layout -->  <?php print $closure ?>  </body></html>
<?php// $Id$/** * @file * User page callbacks for the profile module. *//** * Menu callback; display a list of user information. */function profile_browse() {  // Ensure that the path is converted to 3 levels always.  list(, $name, $value) = array_pad(explode('/', $_GET['q'], 3), 3, '');  $field = db_fetch_object(db_query("SELECT DISTINCT(fid), type, title, page, visibility FROM {profile_fields} WHERE name = '%s'", $name));  if ($name && $field->fid) {    // Only allow browsing of fields that have a page title set.    if (empty($field->page)) {      drupal_not_found();      return;    }    // Do not allow browsing of private and hidden fields by non-admins.    if (!user_access('administer users') && ($field->visibility == PROFILE_PRIVATE || $field->visibility == PROFILE_HIDDEN)) {      drupal_access_denied();      return;    }    // Compile a list of fields to show.    $fields = array();    $result = db_query('SELECT name, title, type, weight, page FROM {profile_fields} WHERE fid != %d AND visibility = %d ORDER BY weight', $field->fid, PROFILE_PUBLIC_LISTINGS);    while ($record = db_fetch_object($result)) {      $fields[] = $record;    }    // Determine what query to use:    $arguments = array($field->fid);    switch ($field->type) {      case 'checkbox':        $query = 'v.value = 1';        break;      case 'textfield':      case 'selection':        $query = "v.value = '%s'";        $arguments[] = $value;        break;      case 'list':        $query = "v.value LIKE '%%%s%%'";        $arguments[] = $value;        break;      default:        drupal_not_found();        return;    }    // Extract the affected users:    $result = pager_query("SELECT u.uid, u.access FROM {users} u INNER JOIN {profile_values} v ON u.uid = v.uid WHERE v.fid = %d AND $query AND u.access != 0 AND u.status != 0 ORDER BY u.access DESC", 20, 0, NULL, $arguments);    $content = '';    while ($account = db_fetch_object($result)) {      $account = user_load(array('uid' => $account->uid));      $profile = _profile_update_user_fields($fields, $account);      $content .= theme('profile_listing', $account, $profile);    }    $output = theme('profile_wrapper', $content);    $output .= theme('pager', NULL, 20);    if ($field->type == 'selection' || $field->type == 'list' || $field->type == 'textfield') {      $title = strtr(check_plain($field->page), array('%value' => theme('placeholder', $value)));    }    else {      $title = check_plain($field->page);    }    drupal_set_title($title);    return $output;  }  else if ($name && !$field->fid) {    drupal_not_found();  }  else {    // Compile a list of fields to show.    $fields = array();    $result = db_query('SELECT name, title, type, weight, page FROM {profile_fields} WHERE visibility = %d ORDER BY category, weight', PROFILE_PUBLIC_LISTINGS);    while ($record = db_fetch_object($result)) {      $fields[] = $record;    }    // Extract the affected users:    $result = pager_query('SELECT uid, access FROM {users} WHERE uid > 0 AND status != 0 AND access != 0 ORDER BY access DESC', 20, 0, NULL);    $content = '';    while ($account = db_fetch_object($result)) {      $account = user_load(array('uid' => $account->uid));      $profile = _profile_update_user_fields($fields, $account);      $content .= theme('profile_listing', $account, $profile);    }    $output = theme('profile_wrapper', $content);    $output .= theme('pager', NULL, 20);    drupal_set_title(t('User list'));    return $output;  }}/** * Callback to allow autocomplete of profile text fields. */function profile_autocomplete($field, $string) {  $matches = array();  if (db_result(db_query("SELECT COUNT(*) FROM {profile_fields} WHERE fid = %d AND autocomplete = 1", $field))) {    $result = db_query_range("SELECT value FROM {profile_values} WHERE fid = %d AND LOWER(value) LIKE LOWER('%s%%') GROUP BY value ORDER BY value ASC", $field, $string, 0, 10);    while ($data = db_fetch_object($result)) {      $matches[$data->value] = check_plain($data->value);    }  }  drupal_json($matches);}
<?php// $Id$/** * Implementation of hook_install(). */function upload_install() {  // Create table. The upload table might have been created in the Drupal 5  // to Drupal 6 upgrade, and was migrated from the file_revisions table. So  // in this case, there is no need to create the table, it is already there.  if (!db_table_exists('upload')) {    drupal_install_schema('upload');  }}/** * Implementation of hook_uninstall(). */function upload_uninstall() {  // Remove tables.  drupal_uninstall_schema('upload');}/** * Implementation of hook_schema(). */function upload_schema() {  $schema['upload'] = array(    'description' => 'Stores uploaded file information and table associations.',    'fields' => array(      'fid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {files}.fid.',      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'The {node}.nid associated with the uploaded file.',      ),      'vid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => 'Primary Key: The {node}.vid associated with the uploaded file.',      ),      'description' => array(        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '',        'description' => 'Description of the uploaded file.',      ),      'list' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Whether the file should be visibly listed on the node: yes(1) or no(0).',      ),      'weight' => array(        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny',        'description' => 'Weight of this upload in relation to other uploads in this node.',      ),    ),    'primary key' => array('vid', 'fid'),    'indexes' => array(      'fid' => array('fid'),      'nid' => array('nid'),    ),  );  return $schema;}
<?php// $Id$/** * @file * Functions to handle paths in Drupal, including path aliasing. * * These functions are not loaded for cached pages, but modules that need * to use them in hook_init() or hook exit() can make them available, by * executing "drupal_bootstrap(DRUPAL_BOOTSTRAP_PATH);". *//** * Initialize the $_GET['q'] variable to the proper normal path. */function drupal_init_path() {  if (!empty($_GET['q'])) {    $_GET['q'] = drupal_get_normal_path(trim($_GET['q'], '/'));  }  else {    $_GET['q'] = drupal_get_normal_path(variable_get('site_frontpage', 'node'));  }}/** * Given an alias, return its Drupal system URL if one exists. Given a Drupal * system URL return one of its aliases if such a one exists. Otherwise, * return FALSE. * * @param $action *   One of the following values: *   - wipe: delete the alias cache. *   - alias: return an alias for a given Drupal system path (if one exists). *   - source: return the Drupal system URL for a path alias (if one exists). * @param $path *   The path to investigate for corresponding aliases or system URLs. * @param $path_language *   Optional language code to search the path with. Defaults to the page language. *   If there's no path defined for that language it will search paths without *   language. * * @return *   Either a Drupal system path, an aliased path, or FALSE if no path was *   found. */function drupal_lookup_path($action, $path = '', $path_language = '') {  global $language;  // $map is an array with language keys, holding arrays of Drupal paths to alias relations  static $map = array(), $no_src = array(), $count;  $path_language = $path_language ? $path_language : $language->language;  // Use $count to avoid looking up paths in subsequent calls if there simply are no aliases  if (!isset($count)) {    $count = db_result(db_query('SELECT COUNT(pid) FROM {url_alias}'));  }  if ($action == 'wipe') {    $map = array();    $no_src = array();    $count = NULL;  }  elseif ($count > 0 && $path != '') {    if ($action == 'alias') {      if (isset($map[$path_language][$path])) {        return $map[$path_language][$path];      }      // Get the most fitting result falling back with alias without language      $alias = db_result(db_query("SELECT dst FROM {url_alias} WHERE src = '%s' AND language IN('%s', '') ORDER BY language DESC, pid DESC", $path, $path_language));      $map[$path_language][$path] = $alias;      return $alias;    }    // Check $no_src for this $path in case we've already determined that there    // isn't a path that has this alias    elseif ($action == 'source' && !isset($no_src[$path_language][$path])) {      // Look for the value $path within the cached $map      $src = '';      if (!isset($map[$path_language]) || !($src = array_search($path, $map[$path_language]))) {        // Get the most fitting result falling back with alias without language        if ($src = db_result(db_query("SELECT src FROM {url_alias} WHERE dst = '%s' AND language IN('%s', '') ORDER BY language DESC, pid DESC", $path, $path_language))) {          $map[$path_language][$src] = $path;        }        else {          // We can't record anything into $map because we do not have a valid          // index and there is no need because we have not learned anything          // about any Drupal path. Thus cache to $no_src.          $no_src[$path_language][$path] = TRUE;        }      }      return $src;    }  }  return FALSE;}/** * Given an internal Drupal path, return the alias set by the administrator. * * @param $path *   An internal Drupal path. * @param $path_language *   An optional language code to look up the path in. * * @return *   An aliased path if one was found, or the original path if no alias was *   found. */function drupal_get_path_alias($path, $path_language = '') {  $result = $path;  if ($alias = drupal_lookup_path('alias', $path, $path_language)) {    $result = $alias;  }  return $result;}/** * Given a path alias, return the internal path it represents. * * @param $path *   A Drupal path alias. * @param $path_language *   An optional language code to look up the path in. * * @return *   The internal path represented by the alias, or the original alias if no *   internal path was found. */function drupal_get_normal_path($path, $path_language = '') {  $result = $path;  if ($src = drupal_lookup_path('source', $path, $path_language)) {    $result = $src;  }  if (function_exists('custom_url_rewrite_inbound')) {    // Modules may alter the inbound request path by reference.    custom_url_rewrite_inbound($result, $path, $path_language);  }  return $result;}/** * Return a component of the current Drupal path. * * When viewing a page at the path "admin/content/types", for example, arg(0) * would return "admin", arg(1) would return "content", and arg(2) would return * "types". * * Avoid use of this function where possible, as resulting code is hard to read. * Instead, attempt to use named arguments in menu callback functions. See the * explanation in menu.inc for how to construct callbacks that take arguments. * * @param $index *   The index of the component, where each component is separated by a '/' *   (forward-slash), and where the first component has an index of 0 (zero). * * @return *   The component specified by $index, or NULL if the specified component was *   not found. */function arg($index = NULL, $path = NULL) {  static $arguments;  if (!isset($path)) {    $path = $_GET['q'];  }  if (!isset($arguments[$path])) {    $arguments[$path] = explode('/', $path);  }  if (!isset($index)) {    return $arguments[$path];  }  if (isset($arguments[$path][$index])) {    return $arguments[$path][$index];  }}/** * Get the title of the current page, for display on the page and in the title bar. * * @return *   The current page's title. */function drupal_get_title() {  $title = drupal_set_title();  // during a bootstrap, menu.inc is not included and thus we cannot provide a title  if (!isset($title) && function_exists('menu_get_active_title')) {    $title = check_plain(menu_get_active_title());  }  return $title;}/** * Set the title of the current page, for display on the page and in the title bar. * * @param $title *   Optional string value to assign to the page title; or if set to NULL *   (default), leaves the current title unchanged. * * @return *   The updated title of the current page. */function drupal_set_title($title = NULL) {  static $stored_title;  if (isset($title)) {    $stored_title = $title;  }  return $stored_title;}/** * Check if the current page is the front page. * * @return *   Boolean value: TRUE if the current page is the front page; FALSE if otherwise. */function drupal_is_front_page() {  // As drupal_init_path updates $_GET['q'] with the 'site_frontpage' path,  // we can check it against the 'site_frontpage' variable.  return $_GET['q'] == drupal_get_normal_path(variable_get('site_frontpage', 'node'));}/** * Check if a path matches any pattern in a set of patterns. * * @param $path *   The path to match. * @param $patterns *   String containing a set of patterns separated by \n, \r or \r\n. * * @return *   1 if there is a match, 0 if there is not a match. */function drupal_match_path($path, $patterns) {  static $regexps;  if (!isset($regexps[$patterns])) {    $regexps[$patterns] = '/^('. preg_replace(array('/(\r\n?|\n)/', '/\\\\\*/', '/(^|\|)\\\\<front\\\\>($|\|)/'), array('|', '.*', '\1'. preg_quote(variable_get('site_frontpage', 'node'), '/') .'\2'), preg_quote($patterns, '/')) .')$/';  }  return preg_match($regexps[$patterns], $path);}
<?php// $Id$/** * @file * Enables the use of personal and site-wide contact forms. *//** * Implementation of hook_help(). */function contact_help($path, $arg) {  switch ($path) {    case 'admin/help#contact':      $output = '<p>'. t('The contact module facilitates communication via e-mail, by allowing your site\'s visitors to contact one another (personal contact forms), and by providing a simple way to direct messages to a set of administrator-defined recipients (the <a href="@contact">contact page</a>). With either form, users specify a subject, write their message, and (optionally) have a copy of their message sent to their own e-mail address.', array('@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t("Personal contact forms allow users to be contacted via e-mail, while keeping recipient e-mail addresses private. Users may enable or disable their personal contact forms by editing their <em>My account</em> page. If enabled, a <em>Contact</em> tab leading to their personal contact form is available on their user profile. Site administrators have access to all personal contact forms (even if they have been disabled). The <em>Contact</em> tab is only visible when viewing another user's profile (users do not see their own <em>Contact</em> tab).") .'</p>';      $output .= '<p>'. t('The <a href="@contact">contact page</a> provides a simple form for visitors to leave comments, feedback, or other requests. Messages are routed by selecting a category from a list of administrator-defined options; each category has its own set of e-mail recipients. Common categories for a business site include, for example, "Website feedback" (messages are forwarded to web site administrators) and "Product information" (messages are forwarded to members of the sales department). The actual e-mail addresses defined within a category are not displayed. Only users in roles with the <em>access site-wide contact form</em> permission may access the <a href="@contact">contact page</a>.', array('@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t('A link to your site\'s <a href="@contact">contact page</a> from the main <em>Navigation</em> menu is created, but is disabled by default. Create a similar link on another menu by adding a menu item pointing to the path "contact"', array('@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t('Customize the <a href="@contact">contact page</a> with additional information (like physical location, mailing address, and telephone number) using the <a href="@contact-settings">contact form settings page</a>. The <a href="@contact-settings">settings page</a> also provides configuration options for the maximum number of contact form submissions a user may perform per hour, and the default status of users\' personal contact forms.', array('@contact-settings' => url('admin/build/contact/settings'), '@contact' => url('contact'))) .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@contact">Contact module</a>.', array('@contact' => url('http://drupal.org/handbook/modules/contact/', array('absolute' => TRUE)))) .'</p>';      return $output;    case 'admin/build/contact':      $output = '<p>'. t('This page lets you set up <a href="@form">your site-wide contact form</a>. To do so, add one or more categories. You can associate different recipients with each category to route e-mails to different people. For example, you can route website feedback to the webmaster and direct product information requests to the sales department. On the <a href="@settings">settings page</a>, you can customize the information shown above the contact form. This can be useful to provide additional contact information such as your postal address and telephone number.', array('@settings' => url('admin/build/contact/settings'), '@form' => url('contact'))) .'</p>';      if (!module_exists('menu')) {        $menu_note = t('The menu item can be customized and configured only once the menu module has been <a href="@modules-page">enabled</a>.', array('@modules-page' => url('admin/settings/modules')));      }      else {        $menu_note = '';      }      $output .= '<p>'. t('The contact module also adds a <a href="@menu-settings">menu item</a> (disabled by default) to the navigation block.', array('@menu-settings' => url('admin/build/menu'))) .' '. $menu_note .'</p>';      return $output;  }}/** * Implementation of hook_perm */function contact_perm() {  return array('access site-wide contact form', 'administer site-wide contact form');}/** * Implementation of hook_menu(). */function contact_menu() {  $items['admin/build/contact'] = array(    'title' => 'Contact form',    'description' => 'Create a system contact form and set up categories for the form to use.',    'page callback' => 'contact_admin_categories',    'access arguments' => array('administer site-wide contact form'),    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/list'] = array(    'title' => 'List',    'page callback' => 'contact_admin_categories',    'type' => MENU_DEFAULT_LOCAL_TASK,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/add'] = array(    'title' => 'Add category',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_edit', 3),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/edit/%contact'] = array(    'title' => 'Edit contact category',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_edit', 3, 4),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_CALLBACK,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/delete/%contact'] = array(    'title' => 'Delete contact',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_delete', 4),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_CALLBACK,    'file' => 'contact.admin.inc',  );  $items['admin/build/contact/settings'] = array(    'title' => 'Settings',    'page callback' => 'drupal_get_form',    'page arguments' => array('contact_admin_settings'),    'access arguments' => array('administer site-wide contact form'),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'contact.admin.inc',  );  $items['contact'] = array(    'title' => 'Contact',    'page callback' => 'contact_site_page',    'access arguments' => array('access site-wide contact form'),    'type' => MENU_SUGGESTED_ITEM,    'file' => 'contact.pages.inc',  );  $items['user/%user/contact'] = array(    'title' => 'Contact',    'page callback' => 'contact_user_page',    'page arguments' => array(1),    'type' => MENU_LOCAL_TASK,    'access callback' => '_contact_user_tab_access',    'access arguments' => array(1),    'weight' => 2,    'file' => 'contact.pages.inc',  );  return $items;}/** * Menu access callback for a user's personal contact form. * * @param $account *   A user account object. * @return *   TRUE if the current user has access to the requested user's contact form, *   or FALSE otherwise. */function _contact_user_tab_access($account) {  global $user;  // Anonymous users cannot use or have contact forms.  if (!$user->uid || !$account->uid) {    return FALSE;  }  // User administrators should always have access to personal contact forms.  if (user_access('administer users')) {    return TRUE;  }  // Users may not contact themselves.  if ($user->uid == $account->uid) {    return FALSE;  }  // If the requested user has disabled their contact form, or this preference  // has not yet been saved, do not allow users to contact them.  if (empty($account->contact)) {    return FALSE;  }  return TRUE;}/** * Load the data for a single contact category. */function contact_load($cid) {  $contact = db_fetch_array(db_query("SELECT * FROM {contact} WHERE cid = %d", $cid));  return empty($contact) ? FALSE : $contact;}/** * Implementation of hook_user(). * * Allows the user the option of enabling/disabling his personal contact form. */function contact_user($type, &$edit, &$user, $category = NULL) {  if ($type == 'form' && $category == 'account') {    $form['contact'] = array('#type' => 'fieldset',      '#title' => t('Contact settings'),      '#weight' => 5,      '#collapsible' => TRUE,    );    $form['contact']['contact'] = array('#type' => 'checkbox',      '#title' => t('Personal contact form'),      '#default_value' => !empty($edit['contact']) ? $edit['contact'] : FALSE,      '#description' => t('Allow other users to contact you by e-mail via <a href="@url">your personal contact form</a>. Note that while your e-mail address is not made public to other members of the community, privileged users such as site administrators are able to contact you even if you choose not to enable this feature.', array('@url' => url("user/$user->uid/contact"))),    );    return $form;  }  elseif ($type == 'validate') {    return array('contact' => isset($edit['contact']) ? $edit['contact'] : FALSE);  }  elseif ($type == 'insert') {    $edit['contact'] = variable_get('contact_default_status', 1);  }}/** * Implementation of hook_mail(). */function contact_mail($key, &$message, $params) {  $language = $message['language'];  switch ($key) {    case 'page_mail':    case 'page_copy':      $contact = $params['contact'];      $message['subject'] .= t('[!category] !subject', array('!category' => $contact['category'], '!subject' => $params['subject']), $language->language);      $message['body'][] = t("!name sent a message using the contact form at !form.", array('!name' => $params['name'], '!form' => url($_GET['q'], array('absolute' => TRUE, 'language' => $language))), $language->language);      $message['body'][] = $params['message'];      break;    case 'page_autoreply':      $contact = $params['contact'];      $message['subject'] .= t('[!category] !subject', array('!category' => $contact['category'], '!subject' => $params['subject']), $language->language);      $message['body'][] = $contact['reply'];      break;    case 'user_mail':    case 'user_copy':      $user = $params['user'];      $account = $params['account'];      $message['subject'] .= '['. variable_get('site_name', 'Drupal') .'] '. $params['subject'];      $message['body'][] = "$account->name,";      $message['body'][] = t("!name (!name-url) has sent you a message via your contact form (!form-url) at !site.", array('!name' => $user->name, '!name-url' => url("user/$user->uid", array('absolute' => TRUE, 'language' => $language)), '!form-url' => url($_GET['q'], array('absolute' => TRUE, 'language' => $language)), '!site' => variable_get('site_name', 'Drupal')), $language->language);      $message['body'][] = t("If you don't want to receive such e-mails, you can change your settings at !url.", array('!url' => url("user/$account->uid", array('absolute' => TRUE, 'language' => $language))), $language->language);      $message['body'][] = t('Message:', NULL, $language->language);      $message['body'][] = $params['message'];      break;  }}
<?php// $Id$/** * @file * Admin page callbacks for the trigger module. *//** * Build the form that allows users to assign actions to hooks. * * @param $type *   Name of hook. * @return *   HTML form. */function trigger_assign($type = NULL) {  // If no type is specified we default to node actions, since they  // are the most common.  if (!isset($type)) {    drupal_goto('admin/build/trigger/node');  }  if ($type == 'node') {    $type = 'nodeapi';  }  $output = '';  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $hook) {    if (isset($hook[$type])) {      foreach ($hook[$type] as $op => $description) {        $form_id = 'trigger_'. $type .'_'. $op .'_assign_form';        $output .= drupal_get_form($form_id, $type, $op, $description['runs when']);      }    }  }  return $output;}/** * Confirm removal of an assigned action. * * @param $hook * @param $op * @param $aid *   The action ID. * @ingroup forms * @see trigger_unassign_submit() */function trigger_unassign($form_state, $hook = NULL, $op = NULL, $aid = NULL) {  if (!($hook && $op && $aid)) {    drupal_goto('admin/build/trigger/assign');  }  $form['hook'] = array(    '#type' => 'value',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'value',    '#value' => $op,  );  $form['aid'] = array(    '#type' => 'value',    '#value' => $aid,  );  $action = actions_function_lookup($aid);  $actions = actions_get_all_actions();  $destination = 'admin/build/trigger/'. ($hook == 'nodeapi' ? 'node' : $hook);  return confirm_form($form,    t('Are you sure you want to unassign the action %title?', array('%title' => $actions[$action]['description'])),    $destination,    t('You can assign it again later if you wish.'),    t('Unassign'), t('Cancel')  );}function trigger_unassign_submit($form, &$form_state) {  $form_values = $form_state['values'];  if ($form_values['confirm'] == 1) {    $aid = actions_function_lookup($form_values['aid']);    db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid);    $actions = actions_get_all_actions();    watchdog('actions', 'Action %action has been unassigned.',  array('%action' => check_plain($actions[$aid]['description'])));    drupal_set_message(t('Action %action has been unassigned.', array('%action' => $actions[$aid]['description'])));    $hook = $form_values['hook'] == 'nodeapi' ? 'node' : $form_values['hook'];    $form_state['redirect'] = 'admin/build/trigger/'. $hook;  }  else {    drupal_goto('admin/build/trigger');  }}/** * Create the form definition for assigning an action to a hook-op combination. * * @param $form_state *   Information about the current form. * @param $hook *   The name of the hook, e.g., 'nodeapi'. * @param $op *   The name of the hook operation, e.g., 'insert'. * @param $description *   A plain English description of what this hook operation does. * @return * * @ingoup forms * @see trigger_assign_form_validate() * @see trigger_assign_form_submit() */function trigger_assign_form($form_state, $hook, $op, $description) {  $form['hook'] = array(    '#type' => 'hidden',    '#value' => $hook,  );  $form['operation'] = array(    '#type' => 'hidden',    '#value' => $op,  );  // All of these forms use the same validate and submit functions.  $form['#validate'][] = 'trigger_assign_form_validate';  $form['#submit'][] = 'trigger_assign_form_submit';  $options = array();  $functions = array();  // Restrict the options list to actions that declare support for this hook-op  // combination.  foreach (actions_list() as $func => $metadata) {    if (isset($metadata['hooks']['any']) || (isset($metadata['hooks'][$hook]) && is_array($metadata['hooks'][$hook]) && (in_array($op, $metadata['hooks'][$hook])))) {      $functions[] = $func;    }  }  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {    if (in_array($action['callback'], $functions)) {      $options[$action['type']][$aid] = $action['description'];    }  }  $form[$op] = array(    '#type' => 'fieldset',    '#title' => t('Trigger: ') . $description,    '#theme' => 'trigger_display'    );  // Retrieve actions that are already assigned to this hook-op combination.  $actions = _trigger_get_hook_actions($hook, $op);  $form[$op]['assigned']['#type'] = 'value';  $form[$op]['assigned']['#value'] = array();  foreach ($actions as $aid => $description) {    $form[$op]['assigned']['#value'][$aid] = array(      'description' => $description,      'link' => l(t('unassign'), "admin/build/trigger/unassign/$hook/$op/". md5($aid))    );  }  $form[$op]['parent'] = array(    '#prefix' => "<div class='container-inline'>",    '#suffix' => '</div>',  );  // List possible actions that may be assigned.  if (count($options) != 0) {    array_unshift($options, t('Choose an action'));    $form[$op]['parent']['aid'] = array(      '#type' => 'select',      '#options' => $options,    );    $form[$op]['parent']['submit'] = array(      '#type' => 'submit',      '#value' => t('Assign')    );  }  else {    $form[$op]['none'] = array(      '#value' => t('No available actions for this trigger.')    );  }  return $form;}/** * Validation function for trigger_assign_form(). * * Makes sure that the user is not re-assigning an action to an event. */function trigger_assign_form_validate($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    if (db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = '%s'", $form_values['hook'], $form_values['operation'], $aid))) {      form_set_error($form_values['operation'], t('The action you chose is already assigned to that trigger.'));    }  }}/** * Submit function for trigger_assign_form(). */function trigger_assign_form_submit($form, $form_state) {  $form_values = $form_state['values'];  if (!empty($form_values['aid'])) {    $aid = actions_function_lookup($form_values['aid']);    $weight = db_result(db_query("SELECT MAX(weight) FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s'", $form_values['hook'], $form_values['operation']));    db_query("INSERT INTO {trigger_assignments} values ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], $aid, $weight + 1);    // If this action changes a node property, we need to save the node    // so the change will persist.    $actions = actions_list();    if (isset($actions[$aid]['behavior']) && in_array('changes_node_property', $actions[$aid]['behavior']) && ($form_values['operation'] != 'presave')) {      // Delete previous node_save_action if it exists, and re-add a new one at a higher weight.      $save_post_action_assigned = db_result(db_query("SELECT aid FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']));      if ($save_post_action_assigned) {        db_query("DELETE FROM {trigger_assignments} WHERE hook = '%s' AND op = '%s' AND aid = 'node_save_action'", $form_values['hook'], $form_values['operation']);      }      db_query("INSERT INTO {trigger_assignments} VALUES ('%s', '%s', '%s', %d)", $form_values['hook'], $form_values['operation'], 'node_save_action', $weight + 2);      if (!$save_post_action_assigned) {        drupal_set_message(t('You have added an action that changes a the property of a post. A Save post action has been added so that the property change will be saved.'));      }    }  }}/** * Display actions assigned to this hook-op combination in a table. * * @param array $element *   The fieldset including all assigned actions. * @return *   The rendered form with the table prepended. * * @ingroup themeable */function theme_trigger_display($element) {  $header = array();  $rows = array();  if (count($element['assigned']['#value'])) {    $header = array(array('data' => t('Name')), array('data' => t('Operation')));    $rows = array();    foreach ($element['assigned']['#value'] as $aid => $info) {      $rows[] = array(        $info['description'],        $info['link']      );    }  }  if (count($rows)) {    $output = theme('table', $header, $rows) . drupal_render($element);  }  else {    $output = drupal_render($element);  }  return $output;}/** * Get the actions that have already been defined for this * type-hook-op combination. * * @param $type *   One of 'node', 'user', 'comment'. * @param $hook *   The name of the hook for which actions have been assigned, *   e.g. 'nodeapi'. * @param $op *   The hook operation for which the actions have been assigned, *   e.g., 'view'. * @return *   An array of action descriptions keyed by action IDs. */function _trigger_get_hook_actions($hook, $op, $type = NULL) {  $actions = array();  if ($type) {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE a.type = '%s' AND h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $type, $hook, $op);  }  else {    $result = db_query("SELECT h.aid, a.description FROM {trigger_assignments} h LEFT JOIN {actions} a on a.aid = h.aid WHERE h.hook = '%s' AND h.op = '%s' ORDER BY h.weight", $hook, $op);  }  while ($action = db_fetch_object($result)) {    $actions[$action->aid] = $action->description;  }  return $actions;}
<?php// $Id$/** * Implementation of hook_schema(). */function node_schema() {  $schema['node'] = array(    'description' => 'The base table for nodes.',    'fields' => array(      'nid' => array(        'description' => 'The primary identifier for a node.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'vid' => array(        'description' => 'The current {node_revisions}.vid version identifier.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'type' => array(        'description' => 'The {node_type}.type of this node.',        'type' => 'varchar',        'length' => 32,        'not null' => TRUE,        'default' => ''),      'language' => array(        'description' => 'The {languages}.language of this node.',        'type' => 'varchar',        'length' => 12,        'not null' => TRUE,        'default' => ''),      'title' => array(        'description' => 'The title of this node, always treated as non-markup plain text.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'uid' => array(        'description' => 'The {users}.uid that owns this node; initially, this is the user that created it.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'status' => array(        'description' => 'Boolean indicating whether the node is published (visible to non-administrators).',        'type' => 'int',        'not null' => TRUE,        'default' => 1),      'created' => array(        'description' => 'The Unix timestamp when the node was created.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'changed' => array(        'description' => 'The Unix timestamp when the node was most recently saved.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'comment' => array(        'description' => 'Whether comments are allowed on this node: 0 = no, 1 = read only, 2 = read/write.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'promote' => array(        'description' => 'Boolean indicating whether the node should be displayed on the front page.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'moderate' => array(        'description' => 'Previously, a boolean indicating whether the node was "in moderation"; mostly no longer used.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'sticky' => array(        'description' => 'Boolean indicating whether the node should be displayed at the top of lists in which it appears.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'tnid' => array(        'description' => 'The translation set id for this node, which equals the node id of the source post in each set.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'translate' => array(        'description' => 'A boolean indicating whether this translation page needs to be updated.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      ),    'indexes' => array(      'node_changed'        => array('changed'),      'node_created'        => array('created'),      'node_moderate'       => array('moderate'),      'node_promote_status' => array('promote', 'status'),      'node_status_type'    => array('status', 'type', 'nid'),      'node_title_type'     => array('title', array('type', 4)),      'node_type'           => array(array('type', 4)),      'uid'                 => array('uid'),      'tnid'                => array('tnid'),      'translate'           => array('translate'),      ),    'unique keys' => array(      'vid'     => array('vid')      ),    'primary key' => array('nid'),    );  $schema['node_access'] = array(    'description' => 'Identifies which realm/grant pairs a user must possess in order to view, update, or delete specific nodes.',    'fields' => array(      'nid' => array(        'description' => 'The {node}.nid this record affects.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'gid' => array(        'description' => "The grant ID a user must possess in the specified realm to gain this row's privileges on the node.",        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'realm' => array(        'description' => 'The realm in which the user must possess the grant ID. Each node access node can define one or more realms.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'grant_view' => array(        'description' => 'Boolean indicating whether a user with the realm/grant pair can view this node.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'grant_update' => array(        'description' => 'Boolean indicating whether a user with the realm/grant pair can edit this node.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'grant_delete' => array(        'description' => 'Boolean indicating whether a user with the realm/grant pair can delete this node.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'tiny')      ),    'primary key' => array('nid', 'gid', 'realm'),    );  $schema['node_counter'] = array(    'description' => 'Access statistics for {node}s.',    'fields' => array(      'nid' => array(        'description' => 'The {node}.nid for these statistics.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'totalcount' => array(        'description' => 'The total number of times the {node} has been viewed.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'big'),      'daycount' => array(        'description' => 'The total number of times the {node} has been viewed today.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'size' => 'medium'),      'timestamp' => array(        'description' => 'The most recent time the {node} has been viewed.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0)      ),    'primary key' => array('nid'),    );  $schema['node_revisions'] = array(    'description' => 'Stores information about each saved version of a {node}.',    'fields' => array(      'nid' => array(        'description' => 'The {node} this version belongs to.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0),      'vid' => array(        'description' => 'The primary identifier for this version.',        'type' => 'serial',        'unsigned' => TRUE,        'not null' => TRUE),      'uid' => array(        'description' => 'The {users}.uid that created this version.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'title' => array(        'description' => 'The title of this version.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'body' => array(        'description' => 'The body of this version.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'teaser' => array(        'description' => 'The teaser of this version.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'log' => array(        'description' => 'The log entry explaining the changes in this version.',        'type' => 'text',        'not null' => TRUE,        'size' => 'big'),      'timestamp' => array(        'description' => 'A Unix timestamp indicating when this version was created.',        'type' => 'int',        'not null' => TRUE,        'default' => 0),      'format' => array(        'description' => "The input format used by this version's body.",        'type' => 'int',        'not null' => TRUE,        'default' => 0)      ),    'indexes' => array(      'nid' => array('nid'),      'uid' => array('uid')      ),    'primary key' => array('vid'),    );  $schema['node_type'] = array(    'description' => 'Stores information about all defined {node} types.',    'fields' => array(      'type' => array(        'description' => 'The machine-readable name of this type.',        'type' => 'varchar',        'length' => 32,        'not null' => TRUE),      'name' => array(        'description' => 'The human-readable name of this type.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'module' => array(        'description' => 'The base string used to construct callbacks corresponding to this node type.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE),      'description'    => array(        'description' => 'A brief description of this type.',        'type' => 'text',        'not null' => TRUE,        'size' => 'medium'),      'help' => array(        'description' => 'Help information shown to the user when creating a {node} of this type.',        'type' => 'text',        'not null' => TRUE,        'size' => 'medium'),      'has_title' => array(        'description' => 'Boolean indicating whether this type uses the {node}.title field.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'size' => 'tiny'),      'title_label' => array(        'description' => 'The label displayed for the title field on the edit form.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'has_body' => array(        'description' => 'Boolean indicating whether this type uses the {node_revisions}.body field.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'size' => 'tiny'),      'body_label' => array(        'description' => 'The label displayed for the body field on the edit form.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => ''),      'min_word_count' => array(        'description' => 'The minimum number of words the body must contain.',        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'size' => 'small'),      'custom' => array(        'description' => 'A boolean indicating whether this type is defined by a module (FALSE) or by a user via a module like the Content Construction Kit (TRUE).',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'modified' => array(        'description' => 'A boolean indicating whether this type has been modified by an administrator; currently not used in any way.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'locked' => array(        'description' => 'A boolean indicating whether the administrator can change the machine name of this type.',        'type' => 'int',        'not null' => TRUE,        'default' => 0,        'size' => 'tiny'),      'orig_type' => array(        'description' => 'The original machine-readable name of this node type. This may be different from the current type name if the locked field is 0.',        'type' => 'varchar',        'length' => 255,        'not null' => TRUE,        'default' => '')      ),    'primary key' => array('type'),    );  return $schema;}
<?php// $Id$/** * @file * User page callbacks for the tracker module. *//** * Menu callback. Prints a listing of active nodes on the site. */function tracker_page($account = NULL, $set_title = FALSE) {  // Add CSS  drupal_add_css(drupal_get_path('module', 'tracker') .'/tracker.css', 'module', 'all', FALSE);  if ($account) {    if ($set_title) {      // When viewed from user/%user/track, display the name of the user      // as page title -- the tab title remains Track so this needs to be done      // here and not in the menu definiton.      drupal_set_title(check_plain($account->name));    }  // TODO: These queries are very expensive, see http://drupal.org/node/105639    $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.changed, n.uid, u.name, GREATEST(n.changed, l.last_comment_timestamp) AS last_updated, l.comment_count FROM {node} n INNER JOIN {node_comment_statistics} l ON n.nid = l.nid INNER JOIN {users} u ON n.uid = u.uid LEFT JOIN {comments} c ON n.nid = c.nid AND (c.status = %d OR c.status IS NULL) WHERE n.status = 1 AND (n.uid = %d OR c.uid = %d) ORDER BY last_updated DESC';    $sql = db_rewrite_sql($sql);    $sql_count = 'SELECT COUNT(DISTINCT(n.nid)) FROM {node} n LEFT JOIN {comments} c ON n.nid = c.nid AND (c.status = %d OR c.status IS NULL) WHERE n.status = 1 AND (n.uid = %d OR c.uid = %d)';    $sql_count = db_rewrite_sql($sql_count);    $result = pager_query($sql, 25, 0, $sql_count, COMMENT_PUBLISHED, $account->uid, $account->uid);  }  else {    $sql = 'SELECT DISTINCT(n.nid), n.title, n.type, n.changed, n.uid, u.name, GREATEST(n.changed, l.last_comment_timestamp) AS last_updated, l.comment_count FROM {node} n INNER JOIN {users} u ON n.uid = u.uid INNER JOIN {node_comment_statistics} l ON n.nid = l.nid WHERE n.status = 1 ORDER BY last_updated DESC';    $sql = db_rewrite_sql($sql);    $sql_count = 'SELECT COUNT(n.nid) FROM {node} n WHERE n.status = 1';    $sql_count = db_rewrite_sql($sql_count);    $result = pager_query($sql, 25, 0, $sql_count);  }  $rows = array();  while ($node = db_fetch_object($result)) {    // Determine the number of comments:    $comments = 0;    if ($node->comment_count) {      $comments = $node->comment_count;      if ($new = comment_num_new($node->nid)) {        $comments .= '<br />';        $comments .= l(format_plural($new, '1 new', '@count new'), "node/$node->nid", array('query' => comment_new_page_count($node->comment_count, $new, $node), 'fragment' => 'new'));      }    }    $rows[] = array(      check_plain(node_get_types('name', $node->type)),      l($node->title, "node/$node->nid") .' '. theme('mark', node_mark($node->nid, $node->changed)),      theme('username', $node),      array('class' => 'replies', 'data' => $comments),      t('!time ago', array('!time' => format_interval(time() - $node->last_updated)))    );  }  if (!$rows) {    $rows[] = array(array('data' => t('No posts available.'), 'colspan' => '5'));  }  $header = array(t('Type'), t('Post'), t('Author'), t('Replies'), t('Last updated'));  $output = '<div id="tracker">';  $output .= theme('table', $header, $rows);  $output .= theme('pager', NULL, 25, 0);  $output .= '</div>';  return $output;}
<?php// $Id$?>  <div class="comment<?php print ' '. $status; ?>">    <?php if ($picture) {    print $picture;  } ?><h3 class="title"><?php print $title; ?></h3><?php if ($new != '') { ?><span class="new"><?php print $new; ?></span><?php } ?>    <div class="submitted"><?php print $submitted; ?></div>    <div class="content">     <?php print $content; ?>     <?php if ($signature): ?>      <div class="clear-block">       <div></div>       <?php print $signature ?>      </div>     <?php endif; ?>    </div>    <div class="links">&raquo; <?php print $links; ?></div>  </div>
<?php// $Id$/** * Implementation of hook_install(). */function book_install() {  // Create tables.  drupal_install_schema('book');  // Add the node type.  _book_install_type_create();}/** * Implementation of hook_uninstall(). */function book_uninstall() {  // Delete menu links.  db_query("DELETE FROM {menu_links} WHERE module = 'book'");  menu_cache_clear_all();  // Remove tables.  drupal_uninstall_schema('book');}function _book_install_type_create() {  // Create an additional node type  $book_node_type = array(    'type' => 'book',    'name' => t('Book page'),    'module' => 'node',    'description' => t('A <em>book page</em> is a page of content, organized into a collection of related entries collectively known as a <em>book</em>. A <em>book page</em> automatically displays links to adjacent pages, providing a simple navigation system for organizing and reviewing structured content.'),    'custom' => TRUE,    'modified' => TRUE,    'locked' => FALSE,  );  $book_node_type = (object)_node_type_set_defaults($book_node_type);  node_type_save($book_node_type);  // Default to not promoted.  variable_set('node_options_book', array('status'));  // Use this default type for adding content to books.  variable_set('book_allowed_types', array('book'));  variable_set('book_child_type', 'book');}/** * Drupal 5.x to 6.x update. * * This function moves any existing book hierarchy into the new structure used * in the 6.x module.  Rather than storing the hierarchy in the {book} table, * the menu API is used to store the hierarchy in the {menu_links} table and the * {book} table serves to uniquely connect a node to a menu link. * * In order to accomplish this, the current hierarchy is processed using a stack. * The stack insures that each parent is processed before any of its children * in the book hierarchy, and is compatible with batched update processing. * */function book_update_6000() {  $ret = array();  // Set up for a multi-part update.  if (!isset($_SESSION['book_update_6000'])) {    $schema['book'] = array(      'fields' => array(        'mlid'    => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'nid'     => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),        'bid' => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),      ),      'primary key' => array('mlid'),      'unique keys' => array(        'nid' => array('nid'),      ),      'indexes' => array(        'bid' => array('bid'),      ),    );    // Add the node type.    _book_install_type_create();    // Fix role permissions to account for the changed names    // Setup the array holding strings to match and the corresponding    // strings to replace them with.    $replace = array(      'outline posts in books' => 'administer book outlines',      'create book pages' => 'create book content',      'edit book pages' => 'edit any book content',      'edit own book pages' => 'edit own book content',      'see printer-friendly version' => 'access printer-friendly version',    );    // Loop over all the roles, and do the necessary transformations.    $query = db_query("SELECT rid, perm FROM {permission} ORDER BY rid");    while ($role = db_fetch_object($query)) {      // Replace all the old permissions with the corresponding new permissions.      $fixed_perm = strtr($role->perm, $replace);      // If the user could previously create book pages, they should get the new      // 'add content to books' permission.      if (strpos($role->perm, 'create book pages') !== FALSE) {        $fixed_perm .= ', add content to books';      }      // Only save if the permissions have changed.      if ($fixed_perm != $role->perm) {        $ret[] = update_sql("UPDATE {permission} SET perm = '$fixed_perm' WHERE rid = $role->rid");      }    }    // Determine whether there are any existing nodes in the book hierarchy.    if (db_result(db_query("SELECT COUNT(*) FROM {book}"))) {      // Temporary table for the old book hierarchy; we'll discard revision info.      $schema['book_temp'] = array(        'fields' => array(          'nid'    => array('type' => 'int', 'unsigned' => TRUE, 'not null' => TRUE, 'default' => 0),          'parent' => array('type' => 'int', 'not null' => TRUE, 'default' => 0),          'weight' => array('type' => 'int', 'not null' => TRUE, 'default' => 0, 'size' => 'tiny')        ),        'indexes' => array(          'parent' => array('parent')        ),        'primary key' => array('nid'),      );      db_create_table($ret, 'book_temp', $schema['book_temp']);      // Insert each node in the old table into the temporary table.      $ret[] = update_sql("INSERT INTO {book_temp} (nid, parent, weight) SELECT b.nid, b.parent, b.weight FROM {book} b INNER JOIN {node} n on b.vid = n.vid");      $ret[] = update_sql("DROP TABLE {book}");      db_create_table($ret, 'book', $schema['book']);      $_SESSION['book_update_6000_orphans']['from'] = 0;      $_SESSION['book_update_6000'] = array();      $result = db_query("SELECT * from {book_temp} WHERE parent = 0");      // Collect all books - top-level nodes.      while ($a = db_fetch_array($result)) {        $_SESSION['book_update_6000'][] = $a;      }      $ret['#finished'] = FALSE;      return $ret;    }    else {      // No exising nodes in the hierarchy, so drop the table and re-create it.      $ret[] = update_sql("DROP TABLE {book}");      db_create_table($ret, 'book', $schema['book']);      return $ret;    }  }  elseif ($_SESSION['book_update_6000_orphans']) {    // Do the first batched part of the update - collect orphans.    $update_count = 400; // Update this many at a time    $result = db_query_range("SELECT * FROM {book_temp}", $_SESSION['book_update_6000_orphans']['from'], $update_count);    $has_rows = FALSE;    // Go through the next $update_count book pages and locate the orphans.    while ($book = db_fetch_array($result)) {      $has_rows = TRUE;      // Orphans are defined as nodes whose parent does not exist in the table.      if ($book['parent'] && !db_result(db_query("SELECT COUNT(*) FROM {book_temp} WHERE nid = %d", $book['parent']))) {        if (empty($_SESSION['book_update_6000_orphans']['book'])) {          // The first orphan becomes the parent for all other orphans.          $book['parent'] = 0;          $_SESSION['book_update_6000_orphans']['book'] = $book;          $ret[] = array('success' => TRUE, 'query' => 'Relocated orphan book pages.');        }        else {          // Re-assign the parent value of the book, and add it to the stack.          $book['parent'] = $_SESSION['book_update_6000_orphans']['book']['nid'];          $_SESSION['book_update_6000'][] = $book;        }      }    }    if ($has_rows) {      $_SESSION['book_update_6000_orphans']['from'] += $update_count;    }    else {      // Done with this part      if (!empty($_SESSION['book_update_6000_orphans']['book'])) {        // The orphans' parent is added last, so it will be processed first.        $_SESSION['book_update_6000'][] = $_SESSION['book_update_6000_orphans']['book'];      }      $_SESSION['book_update_6000_orphans'] = FALSE;    }    $ret['#finished'] = FALSE;    return $ret;  }  else {    // Do the next batched part of the update    $update_count = 100; // Update this many at a time    while ($update_count && $_SESSION['book_update_6000']) {      // Get the last node off the stack.      $book = array_pop($_SESSION['book_update_6000']);      // Add all of this node's children to the stack      $result = db_query("SELECT * FROM {book_temp} WHERE parent = %d", $book['nid']);      while ($a = db_fetch_array($result)) {        $_SESSION['book_update_6000'][] = $a;      }      if ($book['parent']) {        // If its not a top level page, get its parent's mlid.        $parent = db_fetch_array(db_query("SELECT b.mlid AS plid, b.bid FROM {book} b WHERE b.nid = %d", $book['parent']));        $book = array_merge($book, $parent);      }      else {        // There is not a parent - this is a new book.        $book['plid'] = 0;        $book['bid'] = $book['nid'];      }      $book += array(        'module' => 'book',        'link_path' => 'node/'. $book['nid'],        'router_path' => 'node/%',        'menu_name' => 'book-toc-'. $book['bid'],      );      $book = array_merge($book, db_fetch_array(db_query("SELECT title AS link_title FROM {node} WHERE nid = %d", $book['nid'])));      // Items with depth > MENU_MAX_DEPTH cannot be saved.      if (menu_link_save($book)) {        db_query("INSERT INTO {book} (mlid, nid, bid) VALUES (%d, %d, %d)", $book['mlid'], $book['nid'], $book['bid']);      }      else {        // The depth was greater then MENU_MAX_DEPTH, so attach it to the        // closest valid parent.        $book['plid'] = db_result(db_query("SELECT plid FROM {menu_links} WHERE mlid = %d", $book['plid']));        if (menu_link_save($book)) {          db_query("INSERT INTO {book} (mlid, nid, bid) VALUES (%d, %d, %d)", $book['mlid'], $book['nid'], $book['bid']);        }      }      $update_count--;    }    $ret['#finished'] = FALSE;  }  if (empty($_SESSION['book_update_6000'])) {    $ret['#finished'] = TRUE;    $ret[] = array('success' => TRUE, 'query' => 'Relocated existing book pages.');    $ret[] = update_sql("DROP TABLE {book_temp}");    unset($_SESSION['book_update_6000']);    unset($_SESSION['book_update_6000_orphans']);  }  return $ret;}/** * Implementation of hook_schema(). */function book_schema() {  $schema['book'] = array(  'description' => 'Stores book outline information. Uniquely connects each node in the outline to a link in {menu_links}',    'fields' => array(      'mlid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book page's {menu_links}.mlid.",      ),      'nid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book page's {node}.nid.",      ),      'bid' => array(        'type' => 'int',        'unsigned' => TRUE,        'not null' => TRUE,        'default' => 0,        'description' => "The book ID is the {book}.nid of the top-level page.",      ),    ),    'primary key' => array('mlid'),    'unique keys' => array(      'nid' => array('nid'),    ),    'indexes' => array(      'bid' => array('bid'),    ),  );  return $schema;}
<?php// $Id$/** * @file * Framework for handling filtering of content. */// This is a special format ID which means "use the default format". This value// can be passed to the filter APIs as a format ID: this is equivalent to not// passing an explicit format at all.define('FILTER_FORMAT_DEFAULT', 0);define('FILTER_HTML_STRIP', 1);define('FILTER_HTML_ESCAPE', 2);/** * Implementation of hook_help(). */function filter_help($path, $arg) {  switch ($path) {    case 'admin/help#filter':      $output = '<p>'. t("The filter module allows administrators to configure text input formats for use on your site. An input format defines the HTML tags, codes, and other input allowed in both content and comments, and is a key feature in guarding against potentially damaging input from malicious users. Two input formats included by default are <em>Filtered HTML</em> (which allows only an administrator-approved subset of HTML tags) and <em>Full HTML</em> (which allows the full set of HTML tags). Additional input formats may be created by an administrator.") .'</p>';      $output .= '<p>'. t('Each input format uses filters to manipulate text, and most input formats apply several different filters to text in a specific order. Each filter is designed for a specific purpose, and generally either adds, removes or transforms elements within user-entered text before it is displayed. A filter does not change the actual content of a post, but instead, modifies it temporarily before it is displayed. A filter may remove unapproved HTML tags, for instance, while another automatically adds HTML to make links referenced in text clickable.') .'</p>';      $output .= '<p>'. t('Users can choose between the available input formats when creating or editing content. Administrators can configure which input formats are available to which user roles, as well as choose a default input format.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@filter">Filter module</a>.', array('@filter' => 'http://drupal.org/handbook/modules/filter/')) .'</p>';      return $output;    case 'admin/settings/filters':      $output = '<p>'. t('<em>Input formats</em> define a way of processing user-supplied text in Drupal. Each input format uses filters to manipulate text, and most input formats apply several different filters to text, in a specific order. Each filter is designed to accomplish a specific purpose, and generally either removes elements from or adds elements to text before it is displayed. Users can choose between the available input formats when submitting content.') .'</p>';      $output .= '<p>'. t('Use the list below to configure which input formats are available to which roles, as well as choose a default input format (used for imported content, for example). The default format is always available to users. All input formats are available to users in a role with the "administer filters" permission.') .'</p>';      return $output;    case 'admin/settings/filters/%':      return '<p>'. t('Every <em>filter</em> performs one particular change on the user input, for example stripping out malicious HTML or making URLs clickable. Choose which filters you want to apply to text in this input format. If you notice some filters are causing conflicts in the output, you can <a href="@rearrange">rearrange them</a>.', array('@rearrange' => url('admin/settings/filters/'. $arg[3] .'/order'))) .'</p>';    case 'admin/settings/filters/%/configure':      return '<p>'. t('If you cannot find the settings for a certain filter, make sure you have enabled it on the <a href="@url">view tab</a> first.', array('@url' => url('admin/settings/filters/'. $arg[3]))) .'</p>';    case 'admin/settings/filters/%/order':      $output = '<p>'. t('Because of the flexible filtering system, you might encounter a situation where one filter prevents another from doing its job. For example: a word in an URL gets converted into a glossary term, before the URL can be converted to a clickable link. When this happens, rearrange the order of the filters.') .'</p>';      $output .= '<p>'. t("Filters are executed from top-to-bottom. To change the order of the filters, modify the values in the <em>Weight</em> column or grab a drag-and-drop handle under the <em>Name</em> column and drag filters to new locations in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save configuration</em> button at the bottom of the page.") .'</p>';      return $output;  }}/** * Implementation of hook_theme() */function filter_theme() {  return array(    'filter_admin_overview' => array(      'arguments' => array('form' => NULL),      'file' => 'filter.admin.inc',    ),    'filter_admin_order' => array(      'arguments' => array('form' => NULL),      'file' => 'filter.admin.inc',    ),    'filter_tips' => array(      'arguments' => array('tips' => NULL, 'long' => FALSE, 'extra' => ''),      'file' => 'filter.pages.inc',    ),    'filter_tips_more_info' => array(      'arguments' => array(),    ),  );}/** * Implementation of hook_menu(). */function filter_menu() {  $items['admin/settings/filters'] = array(    'title' => 'Input formats',    'description' => 'Configure how content input by users is filtered, including allowed HTML tags. Also allows enabling of module-provided filters.',    'page callback' => 'drupal_get_form',    'page arguments' => array('filter_admin_overview'),    'access arguments' => array('administer filters'),    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/list'] = array(    'title' => 'List',    'type' => MENU_DEFAULT_LOCAL_TASK,  );  $items['admin/settings/filters/add'] = array(    'title' => 'Add input format',    'page callback' => 'filter_admin_format_page',    'access arguments' => array('administer filters'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/delete'] = array(    'title' => 'Delete input format',    'page callback' => 'drupal_get_form',    'page arguments' => array('filter_admin_delete'),    'access arguments' => array('administer filters'),    'type' => MENU_CALLBACK,    'file' => 'filter.admin.inc',  );  $items['filter/tips'] = array(    'title' => 'Compose tips',    'page callback' => 'filter_tips_long',    'access callback' => TRUE,    'type' => MENU_SUGGESTED_ITEM,    'file' => 'filter.pages.inc',  );  $items['admin/settings/filters/%filter_format'] = array(    'type' => MENU_CALLBACK,    'title callback' => 'filter_admin_format_title',    'title arguments' => array(3),    'page callback' => 'filter_admin_format_page',    'page arguments' => array(3),    'access arguments' => array('administer filters'),    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/%filter_format/edit'] = array(    'title' => 'Edit',    'type' => MENU_DEFAULT_LOCAL_TASK,    'weight' => 0,    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/%filter_format/configure'] = array(    'title' => 'Configure',    'page callback' => 'filter_admin_configure_page',    'page arguments' => array(3),    'access arguments' => array('administer filters'),    'type' => MENU_LOCAL_TASK,    'weight' => 1,    'file' => 'filter.admin.inc',  );  $items['admin/settings/filters/%filter_format/order'] = array(    'title' => 'Rearrange',    'page callback' => 'filter_admin_order_page',    'page arguments' => array(3),    'access arguments' => array('administer filters'),    'type' => MENU_LOCAL_TASK,    'weight' => 2,    'file' => 'filter.admin.inc',  );  return $items;}function filter_format_load($arg) {  return filter_formats($arg);}/** * Display a filter format form title. */function filter_admin_format_title($format) {  return $format->name;}/** * Implementation of hook_perm(). */function filter_perm() {  return array('administer filters');}/** * Implementation of hook_cron(). * * Expire outdated filter cache entries */function filter_cron() {  cache_clear_all(NULL, 'cache_filter');}/** * Implementation of hook_filter_tips(). */function filter_filter_tips($delta, $format, $long = FALSE) {  global $base_url;  switch ($delta) {    case 0:      if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_STRIP) {        if ($allowed_html = variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>')) {          switch ($long) {            case 0:              return t('Allowed HTML tags: @tags', array('@tags' => $allowed_html));            case 1:              $output = '<p>'. t('Allowed HTML tags: @tags', array('@tags' => $allowed_html)) .'</p>';              if (!variable_get("filter_html_help_$format", 1)) {                return $output;              }              $output .= t('<p>This site allows HTML content. While learning all of HTML may feel intimidating, learning how to use a very small number of the most basic HTML "tags" is very easy. This table provides examples for each tag that is enabled on this site.</p><p>For more information see W3C\'s <a href="http://www.w3.org/TR/html/">HTML Specifications</a> or use your favorite search engine to find other sites that explain HTML.</p>');              $tips = array(                'a' => array( t('Anchors are used to make links to other pages.'), '<a href="'. $base_url .'">'. variable_get('site_name', 'Drupal') .'</a>'),                'br' => array( t('By default line break tags are automatically added, so use this tag to add additional ones. Use of this tag is different because it is not used with an open/close pair like all the others. Use the extra " /" inside the tag to maintain XHTML 1.0 compatibility'), t('Text with <br />line break')),                'p' => array( t('By default paragraph tags are automatically added, so use this tag to add additional ones.'), '<p>'. t('Paragraph one.') .'</p> <p>'. t('Paragraph two.') .'</p>'),                'strong' => array( t('Strong'), '<strong>'. t('Strong') .'</strong>'),                'em' => array( t('Emphasized'), '<em>'. t('Emphasized') .'</em>'),                'cite' => array( t('Cited'), '<cite>'. t('Cited') .'</cite>'),                'code' => array( t('Coded text used to show programming source code'), '<code>'. t('Coded') .'</code>'),                'b' => array( t('Bolded'), '<b>'. t('Bolded') .'</b>'),                'u' => array( t('Underlined'), '<u>'. t('Underlined') .'</u>'),                'i' => array( t('Italicized'), '<i>'. t('Italicized') .'</i>'),                'sup' => array( t('Superscripted'), t('<sup>Super</sup>scripted')),                'sub' => array( t('Subscripted'), t('<sub>Sub</sub>scripted')),                'pre' => array( t('Preformatted'), '<pre>'. t('Preformatted') .'</pre>'),                'abbr' => array( t('Abbreviation'), t('<abbr title="Abbreviation">Abbrev.</abbr>')),                'acronym' => array( t('Acronym'), t('<acronym title="Three-Letter Acronym">TLA</acronym>')),                'blockquote' => array( t('Block quoted'), '<blockquote>'. t('Block quoted') .'</blockquote>'),                'q' => array( t('Quoted inline'), '<q>'. t('Quoted inline') .'</q>'),                // Assumes and describes tr, td, th.                'table' => array( t('Table'), '<table> <tr><th>'. t('Table header') .'</th></tr> <tr><td>'. t('Table cell') .'</td></tr> </table>'),                'tr' => NULL, 'td' => NULL, 'th' => NULL,                'del' => array( t('Deleted'), '<del>'. t('Deleted') .'</del>'),                'ins' => array( t('Inserted'), '<ins>'. t('Inserted') .'</ins>'),                 // Assumes and describes li.                'ol' => array( t('Ordered list - use the &lt;li&gt; to begin each list item'), '<ol> <li>'. t('First item') .'</li> <li>'. t('Second item') .'</li> </ol>'),                'ul' => array( t('Unordered list - use the &lt;li&gt; to begin each list item'), '<ul> <li>'. t('First item') .'</li> <li>'. t('Second item') .'</li> </ul>'),                'li' => NULL,                // Assumes and describes dt and dd.                'dl' => array( t('Definition lists are similar to other HTML lists. &lt;dl&gt; begins the definition list, &lt;dt&gt; begins the definition term and &lt;dd&gt; begins the definition description.'), '<dl> <dt>'. t('First term') .'</dt> <dd>'. t('First definition') .'</dd> <dt>'. t('Second term') .'</dt> <dd>'. t('Second definition') .'</dd> </dl>'),                'dt' => NULL, 'dd' => NULL,                'h1' => array( t('Header'), '<h1>'. t('Title') .'</h1>'),                'h2' => array( t('Header'), '<h2>'. t('Subtitle') .'</h2>'),                'h3' => array( t('Header'), '<h3>'. t('Subtitle three') .'</h3>'),                'h4' => array( t('Header'), '<h4>'. t('Subtitle four') .'</h4>'),                'h5' => array( t('Header'), '<h5>'. t('Subtitle five') .'</h5>'),                'h6' => array( t('Header'), '<h6>'. t('Subtitle six') .'</h6>')              );              $header = array(t('Tag Description'), t('You Type'), t('You Get'));              preg_match_all('/<([a-z0-9]+)[^a-z0-9]/i', $allowed_html, $out);              foreach ($out[1] as $tag) {                if (array_key_exists($tag, $tips)) {                  if ($tips[$tag]) {                    $rows[] = array(                      array('data' => $tips[$tag][0], 'class' => 'description'),                      array('data' => '<code>'. check_plain($tips[$tag][1]) .'</code>', 'class' => 'type'),                      array('data' => $tips[$tag][1], 'class' => 'get')                    );                  }                }                else {                  $rows[] = array(                    array('data' => t('No help provided for tag %tag.', array('%tag' => $tag)), 'class' => 'description', 'colspan' => 3),                  );                }              }              $output .= theme('table', $header, $rows);              $output .= t('<p>Most unusual characters can be directly entered without any problems.</p><p>If you do encounter problems, try using HTML character entities. A common example looks like &amp;amp; for an ampersand &amp; character. For a full list of entities see HTML\'s <a href="http://www.w3.org/TR/html4/sgml/entities.html">entities</a> page. Some of the available characters include:</p>');              $entities = array(                array( t('Ampersand'), '&amp;'),                array( t('Greater than'), '&gt;'),                array( t('Less than'), '&lt;'),                array( t('Quotation mark'), '&quot;'),              );              $header = array(t('Character Description'), t('You Type'), t('You Get'));              unset($rows);              foreach ($entities as $entity) {                $rows[] = array(                  array('data' => $entity[0], 'class' => 'description'),                  array('data' => '<code>'. check_plain($entity[1]) .'</code>', 'class' => 'type'),                  array('data' => $entity[1], 'class' => 'get')                );              }              $output .= theme('table', $header, $rows);              return $output;          }        }        else {          return t('No HTML tags allowed');        }      }      break;    case 1:      switch ($long) {        case 0:          return t('Lines and paragraphs break automatically.');        case 1:          return t('Lines and paragraphs are automatically recognized. The &lt;br /&gt; line break, &lt;p&gt; paragraph and &lt;/p&gt; close paragraph tags are inserted automatically. If paragraphs are not recognized simply add a couple blank lines.');      }      break;    case 2:      return t('Web page addresses and e-mail addresses turn into links automatically.');  }}/** * Retrieve a list of input formats. */function filter_formats($index = NULL) {  global $user;  static $formats;  // Administrators can always use all input formats.  $all = user_access('administer filters');  if (!isset($formats)) {    $formats = array();    $query = 'SELECT * FROM {filter_formats}';    // Build query for selecting the format(s) based on the user's roles.    $args = array();    if (!$all) {      $where = array();      foreach ($user->roles as $rid => $role) {        $where[] = "roles LIKE '%%,%d,%%'";        $args[] = $rid;      }      $query .= ' WHERE '. implode(' OR ', $where) .' OR format = %d';      $args[] = variable_get('filter_default_format', 1);    }    $result = db_query($query, $args);    while ($format = db_fetch_object($result)) {      $formats[$format->format] = $format;    }  }  if (isset($index)) {    return isset($formats[$index]) ? $formats[$index] : FALSE;  }  return $formats;}/** * Build a list of all filters. */function filter_list_all() {  $filters = array();  foreach (module_list() as $module) {    $list = module_invoke($module, 'filter', 'list');    if (isset($list) && is_array($list)) {      foreach ($list as $delta => $name) {        $filters[$module .'/'. $delta] = (object)array('module' => $module, 'delta' => $delta, 'name' => $name);      }    }  }  uasort($filters, '_filter_list_cmp');  return $filters;}/** * Helper function for sorting the filter list by filter name. */function _filter_list_cmp($a, $b) {  return strcmp($a->name, $b->name);}/** * Resolve a format id, including the default format. */function filter_resolve_format($format) {  return $format == FILTER_FORMAT_DEFAULT ? variable_get('filter_default_format', 1) : $format;}/** * Check if text in a certain input format is allowed to be cached. */function filter_format_allowcache($format) {  static $cache = array();  $format = filter_resolve_format($format);  if (!isset($cache[$format])) {    $cache[$format] = db_result(db_query('SELECT cache FROM {filter_formats} WHERE format = %d', $format));  }  return $cache[$format];}/** * Retrieve a list of filters for a certain format. */function filter_list_format($format) {  static $filters = array();  if (!isset($filters[$format])) {    $result = db_query("SELECT * FROM {filters} WHERE format = %d ORDER BY weight, module, delta", $format);    if (db_affected_rows($result) == 0 && !db_result(db_query("SELECT 1 FROM {filter_formats} WHERE format = %d", $format))) {      // The format has no filters and does not exist, use the default input      // format.      $filters[$format] = filter_list_format(variable_get('filter_default_format', 1));    }    else {      $filters[$format] = array();      while ($filter = db_fetch_object($result)) {        $list = module_invoke($filter->module, 'filter', 'list');        if (isset($list) && is_array($list) && isset($list[$filter->delta])) {          $filter->name = $list[$filter->delta];          $filters[$format][$filter->module .'/'. $filter->delta] = $filter;        }      }    }  }  return $filters[$format];}/** * @name Filtering functions * @{ * Modules which need to have content filtered can use these functions to * interact with the filter system. * * For more info, see the hook_filter() documentation. * * Note: because filters can inject JavaScript or execute PHP code, security is * vital here. When a user supplies a $format, you should validate it with * filter_access($format) before accepting/using it. This is normally done in * the validation stage of the node system. You should for example never make a * preview of content in a disallowed format. *//** * Run all the enabled filters on a piece of text. * * @param $text *    The text to be filtered. * @param $format *    The format of the text to be filtered. Specify FILTER_FORMAT_DEFAULT for *    the default format. * @param $check *    Whether to check the $format with filter_access() first. Defaults to TRUE. *    Note that this will check the permissions of the current user, so you *    should specify $check = FALSE when viewing other people's content. When *    showing content that is not (yet) stored in the database (eg. upon preview), *    set to TRUE so the user's permissions are checked. */function check_markup($text, $format = FILTER_FORMAT_DEFAULT, $check = TRUE) {  // When $check = TRUE, do an access check on $format.  if (isset($text) && (!$check || filter_access($format))) {    $format = filter_resolve_format($format);    // Check for a cached version of this piece of text.    $cache_id = $format .':'. md5($text);    if ($cached = cache_get($cache_id, 'cache_filter')) {      return $cached->data;    }    // See if caching is allowed for this format.    $cache = filter_format_allowcache($format);    // Convert all Windows and Mac newlines to a single newline,    // so filters only need to deal with one possibility.    $text = str_replace(array("\r\n", "\r"), "\n", $text);    // Get a complete list of filters, ordered properly.    $filters = filter_list_format($format);    // Give filters the chance to escape HTML-like data such as code or formulas.    foreach ($filters as $filter) {      $text = module_invoke($filter->module, 'filter', 'prepare', $filter->delta, $format, $text, $cache_id);    }    // Perform filtering.    foreach ($filters as $filter) {      $text = module_invoke($filter->module, 'filter', 'process', $filter->delta, $format, $text, $cache_id);    }    // Store in cache with a minimum expiration time of 1 day.    if ($cache) {      cache_set($cache_id, $text, 'cache_filter', time() + (60 * 60 * 24));    }  }  else {    $text = t('n/a');  }  return $text;}/** * Generate a selector for choosing a format in a form. * * @ingroup forms * @see filter_form_validate() * @param $value *   The ID of the format that is currently selected. * @param $weight *   The weight of the input format. * @param $parents *   Required when defining multiple input formats on a single node or having a different parent than 'format'. * @return *   HTML for the form element. */function filter_form($value = FILTER_FORMAT_DEFAULT, $weight = NULL, $parents = array('format')) {  $value = filter_resolve_format($value);  $formats = filter_formats();  $extra = theme('filter_tips_more_info');  if (count($formats) > 1) {    $form = array(      '#type' => 'fieldset',      '#title' => t('Input format'),      '#collapsible' => TRUE,      '#collapsed' => TRUE,      '#weight' => $weight,      '#element_validate' => array('filter_form_validate'),    );    // Multiple formats available: display radio buttons with tips.    foreach ($formats as $format) {      // Generate the parents as the autogenerator does, so we will have a      // unique id for each radio button.      $parents_for_id = array_merge($parents, array($format->format));      $form[$format->format] = array(        '#type' => 'radio',        '#title' => $format->name,        '#default_value' => $value,        '#return_value' => $format->format,        '#parents' => $parents,        '#description' => theme('filter_tips', _filter_tips($format->format, FALSE)),        '#id' => form_clean_id('edit-'. implode('-', $parents_for_id)),      );    }  }  else {    // Only one format available: use a hidden form item and only show tips.    $format = array_shift($formats);    $form[$format->format] = array('#type' => 'value', '#value' => $format->format, '#parents' => $parents);    $tips = _filter_tips(variable_get('filter_default_format', 1), FALSE);    $form['format']['guidelines'] = array(      '#title' => t('Formatting guidelines'),      '#value' => theme('filter_tips', $tips, FALSE, $extra),    );  }  $form[] = array('#value' => $extra);  return $form;}function filter_form_validate($form) {  foreach (element_children($form) as $key) {    if ($form[$key]['#value'] == $form[$key]['#return_value']) {      return;    }  }  form_error($form, t('An illegal choice has been detected. Please contact the site administrator.'));  watchdog('form', 'Illegal choice %choice in %name element.', array('%choice' => $form[$key]['#value'], '%name' => empty($form['#title']) ? $form['#parents'][0] : $form['#title']), WATCHDOG_ERROR);}/** * Returns TRUE if the user is allowed to access this format. */function filter_access($format) {  $format = filter_resolve_format($format);  if (user_access('administer filters') || ($format == variable_get('filter_default_format', 1))) {    return TRUE;  }  else {    $formats = filter_formats();    return isset($formats[$format]);  }}/** * @} End of "Filtering functions". *//** * Helper function for fetching filter tips. */function _filter_tips($format, $long = FALSE) {  if ($format == -1) {    $formats = filter_formats();  }  else {    $formats = array(db_fetch_object(db_query("SELECT * FROM {filter_formats} WHERE format = %d", $format)));  }  $tips = array();  foreach ($formats as $format) {    $filters = filter_list_format($format->format);    $tips[$format->name] = array();    foreach ($filters as $id => $filter) {      if ($tip = module_invoke($filter->module, 'filter_tips', $filter->delta, $format->format, $long)) {        $tips[$format->name][] = array('tip' => $tip, 'id' => $id);      }    }  }  return $tips;}/** * Format a link to the more extensive filter tips. * * @ingroup themeable */function theme_filter_tips_more_info() {  return '<p>'. l(t('More information about formatting options'), 'filter/tips') .'</p>';}/** * @name Standard filters * @{ * Filters implemented by the filter.module. *//** * Implementation of hook_filter(). Contains a basic set of essential filters. * - HTML filter: *     Validates user-supplied HTML, transforming it as necessary. * - Line break converter: *     Converts newlines into paragraph and break tags. * - URL and e-mail address filter: *     Converts newlines into paragraph and break tags. */function filter_filter($op, $delta = 0, $format = -1, $text = '') {  switch ($op) {    case 'list':      return array(0 => t('HTML filter'), 1 => t('Line break converter'), 2 => t('URL filter'), 3 => t('HTML corrector'));    case 'description':      switch ($delta) {        case 0:          return t('Allows you to restrict whether users can post HTML and which tags to filter out. It will also remove harmful content such as JavaScript events, JavaScript URLs and CSS styles from those tags that are not removed.');        case 1:          return t('Converts line breaks into HTML (i.e. &lt;br&gt; and &lt;p&gt; tags).');        case 2:          return t('Turns web and e-mail addresses into clickable links.');        case 3:          return t('Corrects faulty and chopped off HTML in postings.');        default:          return;      }    case 'process':      switch ($delta) {        case 0:          return _filter_html($text, $format);        case 1:          return _filter_autop($text);        case 2:          return _filter_url($text, $format);        case 3:          return _filter_htmlcorrector($text);        default:          return $text;      }    case 'settings':      switch ($delta) {        case 0:          return _filter_html_settings($format);        case 2:          return _filter_url_settings($format);        default:          return;      }    default:      return $text;  }}/** * Settings for the HTML filter. */function _filter_html_settings($format) {  $form['filter_html'] = array(    '#type' => 'fieldset',    '#title' => t('HTML filter'),    '#collapsible' => TRUE,  );  $form['filter_html']["filter_html_$format"] = array(    '#type' => 'radios',    '#title' => t('Filter HTML tags'),    '#default_value' => variable_get("filter_html_$format", FILTER_HTML_STRIP),    '#options' => array(FILTER_HTML_STRIP => t('Strip disallowed tags'), FILTER_HTML_ESCAPE => t('Escape all tags')),    '#description' => t('How to deal with HTML tags in user-contributed content. If set to "Strip disallowed tags", dangerous tags are removed (see below). If set to "Escape tags", all HTML is escaped and presented as it was typed.'),  );  $form['filter_html']["allowed_html_$format"] = array(    '#type' => 'textfield',    '#title' => t('Allowed HTML tags'),    '#default_value' => variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>'),    '#size' => 64,    '#maxlength' => 1024,    '#description' => t('If "Strip disallowed tags" is selected, optionally specify tags which should not be stripped. JavaScript event attributes are always stripped.'),  );  $form['filter_html']["filter_html_help_$format"] = array(    '#type' => 'checkbox',    '#title' => t('Display HTML help'),    '#default_value' => variable_get("filter_html_help_$format", 1),    '#description' => t('If enabled, Drupal will display some basic HTML help in the long filter tips.'),  );  $form['filter_html']["filter_html_nofollow_$format"] = array(    '#type' => 'checkbox',    '#title' => t('Spam link deterrent'),    '#default_value' => variable_get("filter_html_nofollow_$format", FALSE),    '#description' => t('If enabled, Drupal will add rel="nofollow" to all links, as a measure to reduce the effectiveness of spam links. Note: this will also prevent valid links from being followed by search engines, therefore it is likely most effective when enabled for anonymous users.'),  );  return $form;}/** * HTML filter. Provides filtering of input into accepted HTML. */function _filter_html($text, $format) {  if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_STRIP) {    $allowed_tags = preg_split('/\s+|<|>/', variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>'), -1, PREG_SPLIT_NO_EMPTY);    $text = filter_xss($text, $allowed_tags);  }  if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_ESCAPE) {    // Escape HTML    $text = check_plain($text);  }  if (variable_get("filter_html_nofollow_$format", FALSE)) {    $text = preg_replace('/<a([^>]+)>/i', '<a\\1 rel="nofollow">', $text);  }  return trim($text);}/** * Settings for URL filter. */function _filter_url_settings($format) {  $form['filter_urlfilter'] = array(    '#type' => 'fieldset',    '#title' => t('URL filter'),    '#collapsible' => TRUE,  );  $form['filter_urlfilter']['filter_url_length_'. $format] = array(    '#type' => 'textfield',    '#title' => t('Maximum link text length'),    '#default_value' => variable_get('filter_url_length_'. $format, 72),    '#maxlength' => 4,    '#description' => t('URLs longer than this number of characters will be truncated to prevent long strings that break formatting. The link itself will be retained; just the text portion of the link will be truncated.'),  );  return $form;}/** * URL filter. Automatically converts text web addresses (URLs, e-mail addresses, * ftp links, etc.) into hyperlinks. */function _filter_url($text, $format) {  // Pass length to regexp callback  _filter_url_trim(NULL, variable_get('filter_url_length_'. $format, 72));  $text = ' '. $text .' ';  // Match absolute URLs.  $text = preg_replace_callback("`(<p>|<li>|<br\s*/?>|[ \n\r\t\(])((http://|https://|ftp://|mailto:|smb://|afp://|file://|gopher://|news://|ssl://|sslv2://|sslv3://|tls://|tcp://|udp://)([a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+*~#&=/;-]))([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '_filter_url_parse_full_links', $text);  // Match e-mail addresses.  $text = preg_replace("`(<p>|<li>|<br\s*/?>|[ \n\r\t\(])([A-Za-z0-9._-]+@[A-Za-z0-9._+-]+\.[A-Za-z]{2,4})([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '\1<a href="mailto:\2">\2</a>\3', $text);  // Match www domains/addresses.  $text = preg_replace_callback("`(<p>|<li>|[ \n\r\t\(])(www\.[a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+~#\&=/;-])([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '_filter_url_parse_partial_links', $text);  $text = substr($text, 1, -1);  return $text;}/** * Scan input and make sure that all HTML tags are properly closed and nested. */function _filter_htmlcorrector($text) {  // Prepare tag lists.  static $no_nesting, $single_use;  if (!isset($no_nesting)) {    // Tags which cannot be nested but are typically left unclosed.    $no_nesting = drupal_map_assoc(array('li', 'p'));    // Single use tags in HTML4    $single_use = drupal_map_assoc(array('base', 'meta', 'link', 'hr', 'br', 'param', 'img', 'area', 'input', 'col', 'frame'));  }  // Properly entify angles.  $text = preg_replace('!<([^a-zA-Z/])!', '&lt;\1', $text);  // Split tags from text.  $split = preg_split('/<([^>]+?)>/', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting $null as required).  $tag = false; // Odd/even counter. Tag or no tag.  $stack = array();  $output = '';  foreach ($split as $value) {    // Process HTML tags.    if ($tag) {      list($tagname) = explode(' ', strtolower($value), 2);      // Closing tag      if ($tagname{0} == '/') {        $tagname = substr($tagname, 1);        // Discard XHTML closing tags for single use tags.        if (!isset($single_use[$tagname])) {          // See if we possibly have a matching opening tag on the stack.          if (in_array($tagname, $stack)) {            // Close other tags lingering first.            do {              $output .= '</'. $stack[0] .'>';            } while (array_shift($stack) != $tagname);          }          // Otherwise, discard it.        }      }      // Opening tag      else {        // See if we have an identical 'no nesting' tag already open and close it if found.        if (count($stack) && ($stack[0] == $tagname) && isset($no_nesting[$stack[0]])) {          $output .= '</'. array_shift($stack) .'>';        }        // Push non-single-use tags onto the stack        if (!isset($single_use[$tagname])) {          array_unshift($stack, $tagname);        }        // Add trailing slash to single-use tags as per X(HT)ML.        else {          $value = rtrim($value, ' /') .' /';        }        $output .= '<'. $value .'>';      }    }    else {      // Passthrough all text.      $output .= $value;    }    $tag = !$tag;  }  // Close remaining tags.  while (count($stack) > 0) {    $output .= '</'. array_shift($stack) .'>';  }  return $output;}/** * Make links out of absolute URLs. */function _filter_url_parse_full_links($match) {  $match[2] = decode_entities($match[2]);  $caption = check_plain(_filter_url_trim($match[2]));  $match[2] = check_url($match[2]);  return $match[1] .'<a href="'. $match[2] .'" title="'. $match[2] .'">'. $caption .'</a>'. $match[5];}/** * Make links out of domain names starting with "www." */function _filter_url_parse_partial_links($match) {  $match[2] = decode_entities($match[2]);  $caption = check_plain(_filter_url_trim($match[2]));  $match[2] = check_plain($match[2]);  return $match[1] .'<a href="http://'. $match[2] .'" title="'. $match[2] .'">'. $caption .'</a>'. $match[3];}/** * Shortens long URLs to http://www.example.com/long/url... */function _filter_url_trim($text, $length = NULL) {  static $_length;  if ($length !== NULL) {    $_length = $length;  }  // Use +3 for '...' string length.  if (strlen($text) > $_length + 3) {    $text = substr($text, 0, $_length) .'...';  }  return $text;}/** * Convert line breaks into <p> and <br> in an intelligent fashion. * Based on: http://photomatt.net/scripts/autop */function _filter_autop($text) {  // All block level tags  $block = '(?:table|thead|tfoot|caption|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|select|form|blockquote|address|p|h[1-6]|hr)';  // Split at <pre>, <script>, <style> and </pre>, </script>, </style> tags.  // We don't apply any processing to the contents of these tags to avoid messing  // up code. We look for matched pairs and allow basic nesting. For example:  // "processed <pre> ignored <script> ignored </script> ignored </pre> processed"  $chunks = preg_split('@(</?(?:pre|script|style|object)[^>]*>)@i', $text, -1, PREG_SPLIT_DELIM_CAPTURE);  // Note: PHP ensures the array consists of alternating delimiters and literals  // and begins and ends with a literal (inserting NULL as required).  $ignore = FALSE;  $ignoretag = '';  $output = '';  foreach ($chunks as $i => $chunk) {    if ($i % 2) {      // Opening or closing tag?      $open = ($chunk[1] != '/');      list($tag) = split('[ >]', substr($chunk, 2 - $open), 2);      if (!$ignore) {        if ($open) {          $ignore = TRUE;          $ignoretag = $tag;        }      }      // Only allow a matching tag to close it.      else if (!$open && $ignoretag == $tag) {        $ignore = FALSE;        $ignoretag = '';      }    }    else if (!$ignore) {      $chunk = preg_replace('|\n*$|', '', $chunk) ."\n\n"; // just to make things a little easier, pad the end      $chunk = preg_replace('|<br />\s*<br />|', "\n\n", $chunk);      $chunk = preg_replace('!(<'. $block .'[^>]*>)!', "\n$1", $chunk); // Space things out a little      $chunk = preg_replace('!(</'. $block .'>)!', "$1\n\n", $chunk); // Space things out a little      $chunk = preg_replace("/\n\n+/", "\n\n", $chunk); // take care of duplicates      $chunk = preg_replace('/\n?(.+?)(?:\n\s*\n|\z)/s', "<p>$1</p>\n", $chunk); // make paragraphs, including one at the end      $chunk = preg_replace("|<p>(<li.+?)</p>|", "$1", $chunk); // problem with nested lists      $chunk = preg_replace('|<p><blockquote([^>]*)>|i', "<blockquote$1><p>", $chunk);      $chunk = str_replace('</blockquote></p>', '</p></blockquote>', $chunk);      $chunk = preg_replace('|<p>\s*</p>\n?|', '', $chunk); // under certain strange conditions it could create a P of entirely whitespace      $chunk = preg_replace('!<p>\s*(</?'. $block .'[^>]*>)!', "$1", $chunk);      $chunk = preg_replace('!(</?'. $block .'[^>]*>)\s*</p>!', "$1", $chunk);      $chunk = preg_replace('|(?<!<br />)\s*\n|', "<br />\n", $chunk); // make line breaks      $chunk = preg_replace('!(</?'. $block .'[^>]*>)\s*<br />!', "$1", $chunk);      $chunk = preg_replace('!<br />(\s*</?(?:p|li|div|th|pre|td|ul|ol)>)!', '$1', $chunk);      $chunk = preg_replace('/&([^#])(?![A-Za-z0-9]{1,8};)/', '&amp;$1', $chunk);    }    $output .= $chunk;  }  return $output;}/** * Very permissive XSS/HTML filter for admin-only use. * * Use only for fields where it is impractical to use the * whole filter system, but where some (mainly inline) mark-up * is desired (so check_plain() is not acceptable). * * Allows all tags that can be used inside an HTML body, save * for scripts and styles. */function filter_xss_admin($string) {  return filter_xss($string, array('a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big', 'blockquote', 'br', 'caption', 'cite', 'code', 'col', 'colgroup', 'dd', 'del', 'dfn', 'div', 'dl', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'ol', 'p', 'pre', 'q', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'ul', 'var'));}/** * Filters XSS. Based on kses by Ulf Harnhammar, see * http://sourceforge.net/projects/kses * * For examples of various XSS attacks, see: * http://ha.ckers.org/xss.html * * This code does four things: * - Removes characters and constructs that can trick browsers * - Makes sure all HTML entities are well-formed * - Makes sure all HTML tags and attributes are well-formed * - Makes sure no HTML tags contain URLs with a disallowed protocol (e.g. javascript:) * * @param $string *   The string with raw HTML in it. It will be stripped of everything that can cause *   an XSS attack. * @param $allowed_tags *   An array of allowed tags. */function filter_xss($string, $allowed_tags = array('a', 'em', 'strong', 'cite', 'code', 'ul', 'ol', 'li', 'dl', 'dt', 'dd')) {  // Only operate on valid UTF-8 strings. This is necessary to prevent cross  // site scripting issues on Internet Explorer 6.  if (!drupal_validate_utf8($string)) {    return '';  }  // Store the input format  _filter_xss_split($allowed_tags, TRUE);  // Remove NUL characters (ignored by some browsers)  $string = str_replace(chr(0), '', $string);  // Remove Netscape 4 JS entities  $string = preg_replace('%&\s*\{[^}]*(\}\s*;?|$)%', '', $string);  // Defuse all HTML entities  $string = str_replace('&', '&amp;', $string);  // Change back only well-formed entities in our whitelist  // Decimal numeric entities  $string = preg_replace('/&amp;#([0-9]+;)/', '&#\1', $string);  // Hexadecimal numeric entities  $string = preg_replace('/&amp;#[Xx]0*((?:[0-9A-Fa-f]{2})+;)/', '&#x\1', $string);  // Named entities  $string = preg_replace('/&amp;([A-Za-z][A-Za-z0-9]*;)/', '&\1', $string);  return preg_replace_callback('%    (    <(?=[^a-zA-Z!/])  # a lone <    |                 # or    <[^>]*(>|$)       # a string that starts with a <, up until the > or the end of the string    |                 # or    >                 # just a >    )%x', '_filter_xss_split', $string);}/** * Processes an HTML tag. * * @param @m *   An array with various meaning depending on the value of $store. *   If $store is TRUE then the array contains the allowed tags. *   If $store is FALSE then the array has one element, the HTML tag to process. * @param $store *   Whether to store $m. * @return *   If the element isn't allowed, an empty string. Otherwise, the cleaned up *   version of the HTML element. */function _filter_xss_split($m, $store = FALSE) {  static $allowed_html;  if ($store) {    $allowed_html = array_flip($m);    return;  }  $string = $m[1];  if (substr($string, 0, 1) != '<') {    // We matched a lone ">" character    return '&gt;';  }  else if (strlen($string) == 1) {    // We matched a lone "<" character    return '&lt;';  }  if (!preg_match('%^<\s*(/\s*)?([a-zA-Z0-9]+)([^>]*)>?$%', $string, $matches)) {    // Seriously malformed    return '';  }  $slash = trim($matches[1]);  $elem = &$matches[2];  $attrlist = &$matches[3];  if (!isset($allowed_html[strtolower($elem)])) {    // Disallowed HTML element    return '';  }  if ($slash != '') {    return "</$elem>";  }  // Is there a closing XHTML slash at the end of the attributes?  // In PHP 5.1.0+ we could count the changes, currently we need a separate match  $xhtml_slash = preg_match('%\s?/\s*$%', $attrlist) ? ' /' : '';  $attrlist = preg_replace('%(\s?)/\s*$%', '\1', $attrlist);  // Clean up attributes  $attr2 = implode(' ', _filter_xss_attributes($attrlist));  $attr2 = preg_replace('/[<>]/', '', $attr2);  $attr2 = strlen($attr2) ? ' '. $attr2 : '';  return "<$elem$attr2$xhtml_slash>";}/** * Processes a string of HTML attributes. * * @return *   Cleaned up version of the HTML attributes. */function _filter_xss_attributes($attr) {  $attrarr = array();  $mode = 0;  $attrname = '';  while (strlen($attr) != 0) {    // Was the last operation successful?    $working = 0;    switch ($mode) {      case 0:        // Attribute name, href for instance        if (preg_match('/^([-a-zA-Z]+)/', $attr, $match)) {          $attrname = strtolower($match[1]);          $skip = ($attrname == 'style' || substr($attrname, 0, 2) == 'on');          $working = $mode = 1;          $attr = preg_replace('/^[-a-zA-Z]+/', '', $attr);        }        break;      case 1:        // Equals sign or valueless ("selected")        if (preg_match('/^\s*=\s*/', $attr)) {          $working = 1; $mode = 2;          $attr = preg_replace('/^\s*=\s*/', '', $attr);          break;        }        if (preg_match('/^\s+/', $attr)) {          $working = 1; $mode = 0;          if (!$skip) {            $attrarr[] = $attrname;          }          $attr = preg_replace('/^\s+/', '', $attr);        }        break;      case 2:        // Attribute value, a URL after href= for instance        if (preg_match('/^"([^"]*)"(\s+|$)/', $attr, $match)) {          $thisval = filter_xss_bad_protocol($match[1]);          if (!$skip) {            $attrarr[] = "$attrname=\"$thisval\"";          }          $working = 1;          $mode = 0;          $attr = preg_replace('/^"[^"]*"(\s+|$)/', '', $attr);          break;        }        if (preg_match("/^'([^']*)'(\s+|$)/", $attr, $match)) {          $thisval = filter_xss_bad_protocol($match[1]);          if (!$skip) {            $attrarr[] = "$attrname='$thisval'";;          }          $working = 1; $mode = 0;          $attr = preg_replace("/^'[^']*'(\s+|$)/", '', $attr);          break;        }        if (preg_match("%^([^\s\"']+)(\s+|$)%", $attr, $match)) {          $thisval = filter_xss_bad_protocol($match[1]);          if (!$skip) {            $attrarr[] = "$attrname=\"$thisval\"";          }          $working = 1; $mode = 0;          $attr = preg_replace("%^[^\s\"']+(\s+|$)%", '', $attr);        }        break;    }    if ($working == 0) {      // not well formed, remove and try again      $attr = preg_replace('/        ^        (        "[^"]*("|$)     # - a string that starts with a double quote, up until the next double quote or the end of the string        |               # or        \'[^\']*(\'|$)| # - a string that starts with a quote, up until the next quote or the end of the string        |               # or        \S              # - a non-whitespace character        )*              # any number of the above three        \s*             # any number of whitespaces        /x', '', $attr);      $mode = 0;    }  }  // the attribute list ends with a valueless attribute like "selected"  if ($mode == 1) {    $attrarr[] = $attrname;  }  return $attrarr;}/** * Processes an HTML attribute value and ensures it does not contain an URL * with a disallowed protocol (e.g. javascript:) * * @param $string *   The string with the attribute value. * @param $decode *   Whether to decode entities in the $string. Set to FALSE if the $string *   is in plain text, TRUE otherwise. Defaults to TRUE. * @return *   Cleaned up and HTML-escaped version of $string. */function filter_xss_bad_protocol($string, $decode = TRUE) {  static $allowed_protocols;  if (!isset($allowed_protocols)) {    $allowed_protocols = array_flip(variable_get('filter_allowed_protocols', array('http', 'https', 'ftp', 'news', 'nntp', 'telnet', 'mailto', 'irc', 'ssh', 'sftp', 'webcal', 'rtsp')));  }  // Get the plain text representation of the attribute value (i.e. its meaning).  if ($decode) {    $string = decode_entities($string);  }  // Iteratively remove any invalid protocol found.  do {    $before = $string;    $colonpos = strpos($string, ':');    if ($colonpos > 0) {      // We found a colon, possibly a protocol. Verify.      $protocol = substr($string, 0, $colonpos);      // If a colon is preceded by a slash, question mark or hash, it cannot      // possibly be part of the URL scheme. This must be a relative URL,      // which inherits the (safe) protocol of the base document.      if (preg_match('![/?#]!', $protocol)) {        break;      }      // Per RFC2616, section 3.2.3 (URI Comparison) scheme comparison must be case-insensitive      // Check if this is a disallowed protocol.      if (!isset($allowed_protocols[strtolower($protocol)])) {        $string = substr($string, $colonpos + 1);      }    }  } while ($before != $string);  return check_plain($string);}/** * @} End of "Standard filters". */
<?php// $Id$/** * Indicates an error during check for PHP unicode support. */define('UNICODE_ERROR', -1);/** * Indicates that standard PHP (emulated) unicode support is being used. */define('UNICODE_SINGLEBYTE', 0);/** * Indicates that full unicode support with the PHP mbstring extension is being * used. */define('UNICODE_MULTIBYTE', 1);/** * Wrapper around _unicode_check(). */function unicode_check() {  list($GLOBALS['multibyte']) = _unicode_check();}/** * Perform checks about Unicode support in PHP, and set the right settings if * needed. * * Because Drupal needs to be able to handle text in various encodings, we do * not support mbstring function overloading. HTTP input/output conversion must * be disabled for similar reasons. * * @param $errors *   Whether to report any fatal errors with form_set_error(). */function _unicode_check() {  // Ensure translations don't break at install time  $t = get_t();  // Set the standard C locale to ensure consistent, ASCII-only string handling.  setlocale(LC_CTYPE, 'C');  // Check for outdated PCRE library  // Note: we check if U+E2 is in the range U+E0 - U+E1. This test returns TRUE on old PCRE versions.  if (preg_match('/[-]/u', '')) {    return array(UNICODE_ERROR, $t('The PCRE library in your PHP installation is outdated. This will cause problems when handling Unicode text. If you are running PHP 4.3.3 or higher, make sure you are using the PCRE library supplied by PHP. Please refer to the <a href="@url">PHP PCRE documentation</a> for more information.', array('@url' => 'http://www.php.net/pcre')));  }  // Check for mbstring extension  if (!function_exists('mb_strlen')) {    return array(UNICODE_SINGLEBYTE, $t('Operations on Unicode strings are emulated on a best-effort basis. Install the <a href="@url">PHP mbstring extension</a> for improved Unicode support.', array('@url' => 'http://www.php.net/mbstring')));  }  // Check mbstring configuration  if (ini_get('mbstring.func_overload') != 0) {    return array(UNICODE_ERROR, $t('Multibyte string function overloading in PHP is active and must be disabled. Check the php.ini <em>mbstring.func_overload</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.encoding_translation') != 0) {    return array(UNICODE_ERROR, $t('Multibyte string input conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.encoding_translation</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.http_input') != 'pass') {    return array(UNICODE_ERROR, $t('Multibyte string input conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.http_input</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  if (ini_get('mbstring.http_output') != 'pass') {    return array(UNICODE_ERROR, $t('Multibyte string output conversion in PHP is active and must be disabled. Check the php.ini <em>mbstring.http_output</em> setting. Please refer to the <a href="@url">PHP mbstring documentation</a> for more information.', array('@url' => 'http://www.php.net/mbstring')));  }  // Set appropriate configuration  mb_internal_encoding('utf-8');  mb_language('uni');  return array(UNICODE_MULTIBYTE, '');}/** * Return Unicode library status and errors. */function unicode_requirements() {  // Ensure translations don't break at install time  $t = get_t();  $libraries = array(    UNICODE_SINGLEBYTE => $t('Standard PHP'),    UNICODE_MULTIBYTE => $t('PHP Mbstring Extension'),    UNICODE_ERROR => $t('Error'),  );  $severities = array(    UNICODE_SINGLEBYTE => REQUIREMENT_WARNING,    UNICODE_MULTIBYTE => REQUIREMENT_OK,    UNICODE_ERROR => REQUIREMENT_ERROR,  );  list($library, $description) = _unicode_check();  $requirements['unicode'] = array(    'title' => $t('Unicode library'),    'value' => $libraries[$library],  );  if ($description) {    $requirements['unicode']['description'] = $description;  }  $requirements['unicode']['severity'] = $severities[$library];  return $requirements;}/** * Prepare a new XML parser. * * This is a wrapper around xml_parser_create() which extracts the encoding from * the XML data first and sets the output encoding to UTF-8. This function should * be used instead of xml_parser_create(), because PHP 4's XML parser doesn't * check the input encoding itself. "Starting from PHP 5, the input encoding is * automatically detected, so that the encoding parameter specifies only the * output encoding." * * This is also where unsupported encodings will be converted. Callers should * take this into account: $data might have been changed after the call. * * @param &$data *   The XML data which will be parsed later. * @return *   An XML parser object. */function drupal_xml_parser_create(&$data) {  // Default XML encoding is UTF-8  $encoding = 'utf-8';  $bom = FALSE;  // Check for UTF-8 byte order mark (PHP5's XML parser doesn't handle it).  if (!strncmp($data, "\xEF\xBB\xBF", 3)) {    $bom = TRUE;    $data = substr($data, 3);  }  // Check for an encoding declaration in the XML prolog if no BOM was found.  if (!$bom && ereg('^<\?xml[^>]+encoding="([^"]+)"', $data, $match)) {    $encoding = $match[1];  }  // Unsupported encodings are converted here into UTF-8.  $php_supported = array('utf-8', 'iso-8859-1', 'us-ascii');  if (!in_array(strtolower($encoding), $php_supported)) {    $out = drupal_convert_to_utf8($data, $encoding);    if ($out !== FALSE) {      $encoding = 'utf-8';      $data = ereg_replace('^(<\?xml[^>]+encoding)="([^"]+)"', '\\1="utf-8"', $out);    }    else {      watchdog('php', 'Could not convert XML encoding %s to UTF-8.', array('%s' => $encoding), WATCHDOG_WARNING);      return 0;    }  }  $xml_parser = xml_parser_create($encoding);  xml_parser_set_option($xml_parser, XML_OPTION_TARGET_ENCODING, 'utf-8');  return $xml_parser;}/** * Convert data to UTF-8 * * Requires the iconv, GNU recode or mbstring PHP extension. * * @param $data *   The data to be converted. * @param $encoding *   The encoding that the data is in * @return *   Converted data or FALSE. */function drupal_convert_to_utf8($data, $encoding) {  if (function_exists('iconv')) {    $out = @iconv($encoding, 'utf-8', $data);  }  else if (function_exists('mb_convert_encoding')) {    $out = @mb_convert_encoding($data, 'utf-8', $encoding);  }  else if (function_exists('recode_string')) {    $out = @recode_string($encoding .'..utf-8', $data);  }  else {    watchdog('php', 'Unsupported encoding %s. Please install iconv, GNU recode or mbstring for PHP.', array('%s' => $encoding), WATCHDOG_ERROR);    return FALSE;  }  return $out;}/** * Truncate a UTF-8-encoded string safely to a number of bytes. * * If the end position is in the middle of a UTF-8 sequence, it scans backwards * until the beginning of the byte sequence. * * Use this function whenever you want to chop off a string at an unsure * location. On the other hand, if you're sure that you're splitting on a * character boundary (e.g. after using strpos() or similar), you can safely use * substr() instead. * * @param $string *   The string to truncate. * @param $len *   An upper limit on the returned string length. * @return *   The truncated string. */function drupal_truncate_bytes($string, $len) {  if (strlen($string) <= $len) {    return $string;  }  if ((ord($string[$len]) < 0x80) || (ord($string[$len]) >= 0xC0)) {    return substr($string, 0, $len);  }  while (--$len >= 0 && ord($string[$len]) >= 0x80 && ord($string[$len]) < 0xC0) {};  return substr($string, 0, $len);}/** * Truncate a UTF-8-encoded string safely to a number of characters. * * @param $string *   The string to truncate. * @param $len *   An upper limit on the returned string length. * @param $wordsafe *   Flag to truncate at last space within the upper limit. Defaults to FALSE. * @param $dots *   Flag to add trailing dots. Defaults to FALSE. * @return *   The truncated string. */function truncate_utf8($string, $len, $wordsafe = FALSE, $dots = FALSE) {  if (drupal_strlen($string) <= $len) {    return $string;  }  if ($dots) {    $len -= 4;  }  if ($wordsafe) {    $string = drupal_substr($string, 0, $len + 1); // leave one more character    if ($last_space = strrpos($string, ' ')) { // space exists AND is not on position 0      $string = substr($string, 0, $last_space);    }    else {      $string = drupal_substr($string, 0, $len);    }  }  else {    $string = drupal_substr($string, 0, $len);  }  if ($dots) {    $string .= ' ...';  }  return $string;}/** * Encodes MIME/HTTP header values that contain non-ASCII, UTF-8 encoded * characters. * * For example, mime_header_encode('tst.txt') returns "=?UTF-8?B?dMOpc3QudHh0?=". * * See http://www.rfc-editor.org/rfc/rfc2047.txt for more information. * * Notes: * - Only encode strings that contain non-ASCII characters. * - We progressively cut-off a chunk with truncate_utf8(). This is to ensure *   each chunk starts and ends on a character boundary. * - Using \n as the chunk separator may cause problems on some systems and may *   have to be changed to \r\n or \r. */function mime_header_encode($string) {  if (preg_match('/[^\x20-\x7E]/', $string)) {    $chunk_size = 47; // floor((75 - strlen("=?UTF-8?B??=")) * 0.75);    $len = strlen($string);    $output = '';    while ($len > 0) {      $chunk = drupal_truncate_bytes($string, $chunk_size);      $output .= ' =?UTF-8?B?'. base64_encode($chunk) ."?=\n";      $c = strlen($chunk);      $string = substr($string, $c);      $len -= $c;    }    return trim($output);  }  return $string;}/** * Complement to mime_header_encode */function mime_header_decode($header) {  // First step: encoded chunks followed by other encoded chunks (need to collapse whitespace)  $header = preg_replace_callback('/=\?([^?]+)\?(Q|B)\?([^?]+|\?(?!=))\?=\s+(?==\?)/', '_mime_header_decode', $header);  // Second step: remaining chunks (do not collapse whitespace)  return preg_replace_callback('/=\?([^?]+)\?(Q|B)\?([^?]+|\?(?!=))\?=/', '_mime_header_decode', $header);}/** * Helper function to mime_header_decode */function _mime_header_decode($matches) {  // Regexp groups:  // 1: Character set name  // 2: Escaping method (Q or B)  // 3: Encoded data  $data = ($matches[2] == 'B') ? base64_decode($matches[3]) : str_replace('_', ' ', quoted_printable_decode($matches[3]));  if (strtolower($matches[1]) != 'utf-8') {    $data = drupal_convert_to_utf8($data, $matches[1]);  }  return $data;}/** * Decode all HTML entities (including numerical ones) to regular UTF-8 bytes. * Double-escaped entities will only be decoded once ("&amp;lt;" becomes "&lt;", not "<"). * * @param $text *   The text to decode entities in. * @param $exclude *   An array of characters which should not be decoded. For example, *   array('<', '&', '"'). This affects both named and numerical entities. */function decode_entities($text, $exclude = array()) {  static $table;  // We store named entities in a table for quick processing.  if (!isset($table)) {    // Get all named HTML entities.    $table = array_flip(get_html_translation_table(HTML_ENTITIES));    // PHP gives us ISO-8859-1 data, we need UTF-8.    $table = array_map('utf8_encode', $table);    // Add apostrophe (XML)    $table['&apos;'] = "'";  }  $newtable = array_diff($table, $exclude);  // Use a regexp to select all entities in one pass, to avoid decoding double-escaped entities twice.  return preg_replace('/&(#x?)?([A-Za-z0-9]+);/e', '_decode_entities("$1", "$2", "$0", $newtable, $exclude)', $text);}/** * Helper function for decode_entities */function _decode_entities($prefix, $codepoint, $original, &$table, &$exclude) {  // Named entity  if (!$prefix) {    if (isset($table[$original])) {      return $table[$original];    }    else {      return $original;    }  }  // Hexadecimal numerical entity  if ($prefix == '#x') {    $codepoint = base_convert($codepoint, 16, 10);  }  // Decimal numerical entity (strip leading zeros to avoid PHP octal notation)  else {    $codepoint = preg_replace('/^0+/', '', $codepoint);  }  // Encode codepoint as UTF-8 bytes  if ($codepoint < 0x80) {    $str = chr($codepoint);  }  else if ($codepoint < 0x800) {    $str = chr(0xC0 | ($codepoint >> 6))         . chr(0x80 | ($codepoint & 0x3F));  }  else if ($codepoint < 0x10000) {    $str = chr(0xE0 | ( $codepoint >> 12))         . chr(0x80 | (($codepoint >> 6) & 0x3F))         . chr(0x80 | ( $codepoint       & 0x3F));  }  else if ($codepoint < 0x200000) {    $str = chr(0xF0 | ( $codepoint >> 18))         . chr(0x80 | (($codepoint >> 12) & 0x3F))         . chr(0x80 | (($codepoint >> 6)  & 0x3F))         . chr(0x80 | ( $codepoint        & 0x3F));  }  // Check for excluded characters  if (in_array($str, $exclude)) {    return $original;  }  else {    return $str;  }}/** * Count the amount of characters in a UTF-8 string. This is less than or * equal to the byte count. */function drupal_strlen($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strlen($text);  }  else {    // Do not count UTF-8 continuation bytes.    return strlen(preg_replace("/[\x80-\xBF]/", '', $text));  }}/** * Uppercase a UTF-8 string. */function drupal_strtoupper($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strtoupper($text);  }  else {    // Use C-locale for ASCII-only uppercase    $text = strtoupper($text);    // Case flip Latin-1 accented letters    $text = preg_replace_callback('/\xC3[\xA0-\xB6\xB8-\xBE]/', '_unicode_caseflip', $text);    return $text;  }}/** * Lowercase a UTF-8 string. */function drupal_strtolower($text) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return mb_strtolower($text);  }  else {    // Use C-locale for ASCII-only lowercase    $text = strtolower($text);    // Case flip Latin-1 accented letters    $text = preg_replace_callback('/\xC3[\x80-\x96\x98-\x9E]/', '_unicode_caseflip', $text);    return $text;  }}/** * Helper function for case conversion of Latin-1. * Used for flipping U+C0-U+DE to U+E0-U+FD and back. */function _unicode_caseflip($matches) {  return $matches[0][0] . chr(ord($matches[0][1]) ^ 32);}/** * Capitalize the first letter of a UTF-8 string. */function drupal_ucfirst($text) {  // Note: no mbstring equivalent!  return drupal_strtoupper(drupal_substr($text, 0, 1)) . drupal_substr($text, 1);}/** * Cut off a piece of a string based on character indices and counts. Follows * the same behavior as PHP's own substr() function. * * Note that for cutting off a string at a known character/substring * location, the usage of PHP's normal strpos/substr is safe and * much faster. */function drupal_substr($text, $start, $length = NULL) {  global $multibyte;  if ($multibyte == UNICODE_MULTIBYTE) {    return $length === NULL ? mb_substr($text, $start) : mb_substr($text, $start, $length);  }  else {    $strlen = strlen($text);    // Find the starting byte offset    $bytes = 0;    if ($start > 0) {      // Count all the continuation bytes from the start until we have found      // $start characters      $bytes = -1; $chars = -1;      while ($bytes < $strlen && $chars < $start) {        $bytes++;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }    }    else if ($start < 0) {      // Count all the continuation bytes from the end until we have found      // abs($start) characters      $start = abs($start);      $bytes = $strlen; $chars = 0;      while ($bytes > 0 && $chars < $start) {        $bytes--;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }    }    $istart = $bytes;    // Find the ending byte offset    if ($length === NULL) {      $bytes = $strlen - 1;    }    else if ($length > 0) {      // Count all the continuation bytes from the starting index until we have      // found $length + 1 characters. Then backtrack one byte.      $bytes = $istart; $chars = 0;      while ($bytes < $strlen && $chars < $length) {        $bytes++;        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }      }      $bytes--;    }    else if ($length < 0) {      // Count all the continuation bytes from the end until we have found      // abs($length) characters      $length = abs($length);      $bytes = $strlen - 1; $chars = 0;      while ($bytes >= 0 && $chars < $length) {        $c = ord($text[$bytes]);        if ($c < 0x80 || $c >= 0xC0) {          $chars++;        }        $bytes--;      }    }    $iend = $bytes;    return substr($text, $istart, max(0, $iend - $istart + 1));  }}
<?php// $Id$/** * @file * Enables functions to be stored and executed at a later time when * triggered by other modules or by one of Drupal's core API hooks. *//** * Implementation of hook_help(). */function trigger_help($path, $arg) {  $explanation = '<p>'. t('Triggers are system events, such as when new content is added or when a user logs in. Trigger module combines these triggers with actions (functional tasks), such as unpublishing content or e-mailing an administrator. The <a href="@url">Actions settings page</a> contains a list of existing actions and provides the ability to create and configure additional actions.', array('@url' => url('admin/settings/actions'))) .'</p>';  switch ($path) {    case 'admin/build/trigger/comment':      return $explanation .'<p>'. t('Below you can assign actions to run when certain comment-related triggers happen. For example, you could promote a post to the front page when a comment is added.') .'</p>';    case 'admin/build/trigger/node':      return $explanation .'<p>'. t('Below you can assign actions to run when certain content-related triggers happen. For example, you could send an e-mail to an administrator when a post is created or updated.') .'</p>';    case 'admin/build/trigger/cron':      return $explanation .'<p>'. t('Below you can assign actions to run during each pass of a <a href="@cron">cron maintenance task</a>.', array('@cron' => url('admin/reports/status'))) .'</p>';    case 'admin/build/trigger/taxonomy':      return $explanation .'<p>'. t('Below you can assign actions to run when certain taxonomy-related triggers happen. For example, you could send an e-mail to an administrator when a term is deleted.') .'</p>';    case 'admin/build/trigger/user':      return $explanation .'<p>'. t("Below you can assign actions to run when certain user-related triggers happen. For example, you could send an e-mail to an administrator when a user account is deleted.") .'</p>';    case 'admin/help#trigger':      $output = '<p>'. t('The Trigger module provides the ability to trigger <a href="@actions">actions</a> upon system events, such as when new content is added or when a user logs in.', array('@actions' => url('admin/settings/actions'))) .'</p>';      $output .= '<p>'. t('The combination of actions and triggers can perform many useful tasks, such as e-mailing an administrator if a user account is deleted, or automatically unpublishing comments that contain certain words. By default, there are five "contexts" of events (Comments, Content, Cron, Taxonomy, and Users), but more may be added by additional modules.') .'</p>';      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@trigger">Trigger module</a>.', array('@trigger' => 'http://drupal.org/handbook/modules/trigger/')) .'</p>';      return $output;  }}/** * Implementation of hook_menu(). */function trigger_menu() {  $items['admin/build/trigger'] = array(    'title' => 'Triggers',    'description' => 'Tell Drupal when to execute actions.',    'page callback' => 'trigger_assign',    'access callback' => 'trigger_access_check',    'access arguments' => array('node'),    'file' => 'trigger.admin.inc',  );  // We don't use a menu wildcard here because these are tabs,  // not invisible items.  $items['admin/build/trigger/node'] = array(    'title' => 'Content',    'page callback' => 'trigger_assign',    'page arguments' => array('node'),    'access callback' => 'trigger_access_check',    'access arguments' => array('node'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/user'] = array(    'title' => 'Users',    'page callback' => 'trigger_assign',    'page arguments' => array('user'),    'access callback' => 'trigger_access_check',    'access arguments' => array('user'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/comment'] = array(    'title' => 'Comments',    'page callback' => 'trigger_assign',    'page arguments' => array('comment'),    'access callback' => 'trigger_access_check',    'access arguments' => array('comment'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/taxonomy'] = array(    'title' => 'Taxonomy',    'page callback' => 'trigger_assign',    'page arguments' => array('taxonomy'),    'access callback' => 'trigger_access_check',    'access arguments' => array('taxonomy'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  $items['admin/build/trigger/cron'] = array(    'title' => 'Cron',    'page callback' => 'trigger_assign',    'page arguments' => array('cron'),    'access arguments' => array('administer actions'),    'type' => MENU_LOCAL_TASK,    'file' => 'trigger.admin.inc',  );  // We want contributed modules to be able to describe  // their hooks and have actions assignable to them.  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $hook) {    // We've already done these.    if (in_array($module, array('node', 'comment', 'user', 'system', 'taxonomy'))) {      continue;    }    $info = db_result(db_query("SELECT info FROM {system} WHERE name = '%s'", $module));    $info = unserialize($info);    $nice_name = $info['name'];    $items["admin/build/trigger/$module"] = array(      'title' => $nice_name,      'page callback' => 'trigger_assign',      'page arguments' => array($module),      'access arguments' => array($module),      'type' => MENU_LOCAL_TASK,      'file' => 'trigger.admin.inc',    );  }  $items['admin/build/trigger/unassign'] = array(    'title' => 'Unassign',    'description' => 'Unassign an action from a trigger.',    'page callback' => 'drupal_get_form',    'page arguments' => array('trigger_unassign'),    'access arguments' => array('administer actions'),    'type' => MENU_CALLBACK,    'file' => 'trigger.admin.inc',  );  return $items;}/** * Access callback for menu system. */function trigger_access_check($module) {  return (module_exists($module) && user_access('administer actions'));}/** * Get the aids of actions to be executed for a hook-op combination. * * @param $hook *   The name of the hook being fired. * @param $op *   The name of the operation being executed. Defaults to an empty string *   because some hooks (e.g., hook_cron()) do not have operations. * @return *   An array of action IDs. */function _trigger_get_hook_aids($hook, $op = '') {  $aids = array();  $result = db_query("SELECT aa.aid, a.type FROM {trigger_assignments} aa LEFT JOIN {actions} a ON aa.aid = a.aid WHERE aa.hook = '%s' AND aa.op = '%s' ORDER BY weight", $hook, $op);  while ($action = db_fetch_object($result)) {    $aids[$action->aid]['type'] = $action->type;  }  return $aids;}/** * Implementation of hook_theme(). */function trigger_theme() {  return array(    'trigger_display' => array(      'arguments' => array('element'),      'file' => 'trigger.admin.inc',    ),  );}/** * Implementation of hook_forms(). We reuse code by using the * same assignment form definition for each node-op combination. */function trigger_forms() {  $hooks = module_invoke_all('hook_info');  foreach ($hooks as $module => $info) {    foreach ($hooks[$module] as $hook => $ops) {      foreach ($ops as $op => $description) {        $forms['trigger_'. $hook .'_'. $op .'_assign_form'] = array('callback' => 'trigger_assign_form');      }    }  }  return $forms;}/** * When an action is called in a context that does not match its type, * the object that the action expects must be retrieved. For example, when * an action that works on users is called during the node hook, the * user object is not available since the node hook doesn't pass it. * So here we load the object the action expects. * * @param $type *   The type of action that is about to be called. * @param $node *   The node that was passed via the nodeapi hook. * @return *   The object expected by the action that is about to be called. */function _trigger_normalize_node_context($type, $node) {  switch ($type) {    // If an action that works on comments is being called in a node context,    // the action is expecting a comment object. But we do not know which comment    // to give it. The first? The most recent? All of them? So comment actions    // in a node context are not supported.    // An action that works on users is being called in a node context.    // Load the user object of the node's author.    case 'user':      return user_load(array('uid' => $node->uid));  }}/** * Implementation of hook_nodeapi(). */function trigger_nodeapi(&$node, $op, $a3, $a4) {  // Keep objects for reuse so that changes actions make to objects can persist.  static $objects;  // Prevent recursion by tracking which operations have already been called.  static $recursion;  // Support a subset of operations.  if (!in_array($op, array('view', 'update', 'presave', 'insert', 'delete')) || isset($recursion[$op])) {    return;  }  $recursion[$op] = TRUE;  $aids = _trigger_get_hook_aids('nodeapi', $op);  if (!$aids) {    return;  }  $context = array(    'hook' => 'nodeapi',    'op' => $op,  );  // We need to get the expected object if the action's type is not 'node'.  // We keep the object in $objects so we can reuse it if we have multiple actions  // that make changes to an object.  foreach ($aids as $aid => $action_info) {    if ($action_info['type'] != 'node') {      if (!isset($objects[$action_info['type']])) {        $objects[$action_info['type']] = _trigger_normalize_node_context($action_info['type'], $node);      }      // Since we know about the node, we pass that info along to the action.      $context['node'] = $node;      $result = actions_do($aid, $objects[$action_info['type']], $context, $a3, $a4);    }    else {      actions_do($aid, $node, $context, $a3, $a4);    }  }}/** * When an action is called in a context that does not match its type, * the object that the action expects must be retrieved. For example, when * an action that works on nodes is called during the comment hook, the * node object is not available since the comment hook doesn't pass it. * So here we load the object the action expects. * * @param $type *   The type of action that is about to be called. * @param $comment *   The comment that was passed via the comment hook. * @return *   The object expected by the action that is about to be called. */function _trigger_normalize_comment_context($type, $comment) {  switch ($type) {    // An action that works with nodes is being called in a comment context.    case 'node':      return node_load(is_array($comment) ? $comment['nid'] : $comment->nid);    // An action that works on users is being called in a comment context.    case 'user':      return user_load(array('uid' => is_array($comment) ? $comment['uid'] : $comment->uid));  }}/** * Implementation of hook_comment(). */function trigger_comment($a1, $op) {  // Keep objects for reuse so that changes actions make to objects can persist.  static $objects;  // We support a subset of operations.  if (!in_array($op, array('insert', 'update', 'delete', 'view'))) {    return;  }  $aids = _trigger_get_hook_aids('comment', $op);  $context = array(    'hook' => 'comment',    'op' => $op,  );  // We need to get the expected object if the action's type is not 'comment'.  // We keep the object in $objects so we can reuse it if we have multiple actions  // that make changes to an object.  foreach ($aids as $aid => $action_info) {    if ($action_info['type'] != 'comment') {      if (!isset($objects[$action_info['type']])) {        $objects[$action_info['type']] = _trigger_normalize_comment_context($action_info['type'], $a1);      }      // Since we know about the comment, we pass it along to the action      // in case it wants to peek at it.      $context['comment'] = (object) $a1;      actions_do($aid, $objects[$action_info['type']], $context);    }    else {      $comment = (object) $a1;      actions_do($aid, $comment, $context);    }  }}/** * Implementation of hook_cron(). */function trigger_cron() {  $aids = _trigger_get_hook_aids('cron', 'run');  $context = array(    'hook' => 'cron',    'op' => 'run',  );  // Cron does not act on any specific object.  $object = NULL;  actions_do(array_keys($aids), $object, $context);}/** * When an action is called in a context that does not match its type, * the object that the action expects must be retrieved. For example, when * an action that works on nodes is called during the user hook, the * node object is not available since the user hook doesn't pass it. * So here we load the object the action expects. * * @param $type *   The type of action that is about to be called. * @param $account *   The account object that was passed via the user hook. * @return *   The object expected by the action that is about to be called. */function _trigger_normalize_user_context($type, $account) {  switch ($type) {    // If an action that works on comments is being called in a user context,    // the action is expecting a comment object. But we have no way of    // determining the appropriate comment object to pass. So comment    // actions in a user context are not supported.    // An action that works with nodes is being called in a user context.    // If a single node is being viewed, return the node.    case 'node':      // If we are viewing an individual node, return the node.      if ((arg(0) == 'node') && is_numeric(arg(1)) && (arg(2) == NULL)) {        return node_load(array('nid' => arg(1)));      }  }}/** * Implementation of hook_user(). */function trigger_user($op, &$edit, &$account, $category = NULL) {  // Keep objects for reuse so that changes actions make to objects can persist.  static $objects;  // We support a subset of operations.  if (!in_array($op, array('login', 'logout', 'insert', 'update', 'delete', 'view'))) {    return;  }  $aids = _trigger_get_hook_aids('user', $op);  $context = array(    'hook' => 'user',    'op' => $op,    'form_values' => &$edit,  );  foreach ($aids as $aid => $action_info) {    if ($action_info['type'] != 'user') {      if (!isset($objects[$action_info['type']])) {        $objects[$action_info['type']] = _trigger_normalize_user_context($action_info['type'], $account);      }      $context['account'] = $account;      actions_do($aid, $objects[$action_info['type']], $context);    }    else {      actions_do($aid, $account, $context, $category);    }  }}/** * Implementation of hook_taxonomy(). */function trigger_taxonomy($op, $type, $array) {  if ($type != 'term') {    return;  }  $aids = _trigger_get_hook_aids('taxonomy', $op);  $context = array(    'hook' => 'taxonomy',    'op' => $op  );  foreach ($aids as $aid => $action_info) {    $taxonomy_object = (object) $array;    actions_do($aid, $taxonomy_object, $context);  }}/** * Often we generate a select field of all actions. This function * generates the options for that select. * * @param $type *   One of 'node', 'user', 'comment'. * @return *   Array keyed by action ID. */function trigger_options($type = 'all') {  $options = array(t('Choose an action'));  foreach (actions_actions_map(actions_get_all_actions()) as $aid => $action) {    $options[$action['type']][$aid] = $action['description'];  }  if ($type == 'all') {    return $options;  }  else {    return $options[$type];  }}/** * Implementation of hook_actions_delete(). * * Remove all trigger entries for the given action, when deleted. */function trigger_actions_delete($aid) {  db_query("DELETE FROM {trigger_assignments} WHERE aid = '%s'", $aid);}
<?php// $Id$/** * Return data from the persistent cache. Data may be stored as either plain text or as serialized data. * cache_get will automatically return unserialized objects and arrays. * * @param $cid *   The cache ID of the data to retrieve. * @param $table *   The table $table to store the data in. Valid core values are 'cache_filter', *   'cache_menu', 'cache_page', or 'cache' for the default cache. */function cache_get($cid, $table = 'cache') {  global $user;  // Garbage collection necessary when enforcing a minimum cache lifetime  $cache_flush = variable_get('cache_flush_'. $table, 0);  if ($cache_flush && ($cache_flush + variable_get('cache_lifetime', 0) <= time())) {    // Reset the variable immediately to prevent a meltdown in heavy load situations.    variable_set('cache_flush_'. $table, 0);    // Time to flush old cache data    db_query("DELETE FROM {". $table ."} WHERE expire != %d AND expire <= %d", CACHE_PERMANENT, $cache_flush);  }  $cache = db_fetch_object(db_query("SELECT data, created, headers, expire, serialized FROM {". $table ."} WHERE cid = '%s'", $cid));  if (isset($cache->data)) {    // If the data is permanent or we're not enforcing a minimum cache lifetime    // always return the cached data.    if ($cache->expire == CACHE_PERMANENT || !variable_get('cache_lifetime', 0)) {      $cache->data = db_decode_blob($cache->data);      if ($cache->serialized) {        $cache->data = unserialize($cache->data);      }    }    // If enforcing a minimum cache lifetime, validate that the data is    // currently valid for this user before we return it by making sure the    // cache entry was created before the timestamp in the current session's    // cache timer. The cache variable is loaded into the $user object by    // sess_read() in session.inc.    else {      if ($user->cache > $cache->created) {        // This cache data is too old and thus not valid for us, ignore it.        return 0;      }      else {        $cache->data = db_decode_blob($cache->data);        if ($cache->serialized) {          $cache->data = unserialize($cache->data);        }      }    }    return $cache;  }  return 0;}/** * Store data in the persistent cache. * * The persistent cache is split up into four database * tables. Contributed modules can add additional tables. * * 'cache_page': This table stores generated pages for anonymous * users. This is the only table affected by the page cache setting on * the administrator panel. * * 'cache_menu': Stores the cachable part of the users' menus. * * 'cache_filter': Stores filtered pieces of content. This table is * periodically cleared of stale entries by cron. * * 'cache': Generic cache storage table. * * The reasons for having several tables are as follows: * * - smaller tables allow for faster selects and inserts * - we try to put fast changing cache items and rather static *   ones into different tables. The effect is that only the fast *   changing tables will need a lot of writes to disk. The more *   static tables will also be better cachable with MySQL's query cache * * @param $cid *   The cache ID of the data to store. * @param $data *   The data to store in the cache. Complex data types will be automatically serialized before insertion. *   Strings will be stored as plain text and not serialized. * @param $table *   The table $table to store the data in. Valid core values are 'cache_filter', *   'cache_menu', 'cache_page', or 'cache'. * @param $expire *   One of the following values: *   - CACHE_PERMANENT: Indicates that the item should never be removed unless *     explicitly told to using cache_clear_all() with a cache ID. *   - CACHE_TEMPORARY: Indicates that the item should be removed at the next *     general cache wipe. *   - A Unix timestamp: Indicates that the item should be kept at least until *     the given time, after which it behaves like CACHE_TEMPORARY. * @param $headers *   A string containing HTTP header information for cached pages. */function cache_set($cid, $data, $table = 'cache', $expire = CACHE_PERMANENT, $headers = NULL) {  $serialized = 0;  if (is_object($data) || is_array($data)) {    $data = serialize($data);    $serialized = 1;  }  $created = time();  db_query("UPDATE {". $table ."} SET data = %b, created = %d, expire = %d, headers = '%s', serialized = %d WHERE cid = '%s'", $data, $created, $expire, $headers, $serialized, $cid);  if (!db_affected_rows()) {    @db_query("INSERT INTO {". $table ."} (cid, data, created, expire, headers, serialized) VALUES ('%s', %b, %d, %d, '%s', %d)", $cid, $data, $created, $expire, $headers, $serialized);  }}/** * * Expire data from the cache. If called without arguments, expirable * entries will be cleared from the cache_page and cache_block tables. * * @param $cid *   If set, the cache ID to delete. Otherwise, all cache entries that can *   expire are deleted. * * @param $table *   If set, the table $table to delete from. Mandatory *   argument if $cid is set. * * @param $wildcard *   If $wildcard is TRUE, cache IDs starting with $cid are deleted in *   addition to the exact cache ID specified by $cid.  If $wildcard is *   TRUE and $cid is '*' then the entire table $table is emptied. */function cache_clear_all($cid = NULL, $table = NULL, $wildcard = FALSE) {  global $user;  if (!isset($cid) && !isset($table)) {    // Clear the block cache first, so stale data will    // not end up in the page cache.    cache_clear_all(NULL, 'cache_block');    cache_clear_all(NULL, 'cache_page');    return;  }  if (empty($cid)) {    if (variable_get('cache_lifetime', 0)) {      // We store the time in the current user's $user->cache variable which      // will be saved into the sessions table by sess_write(). We then      // simulate that the cache was flushed for this user by not returning      // cached data that was cached before the timestamp.      $user->cache = time();      $cache_flush = variable_get('cache_flush_'. $table, 0);      if ($cache_flush == 0) {        // This is the first request to clear the cache, start a timer.        variable_set('cache_flush_'. $table, time());      }      else if (time() > ($cache_flush + variable_get('cache_lifetime', 0))) {        // Clear the cache for everyone, cache_lifetime seconds have        // passed since the first request to clear the cache.        db_query("DELETE FROM {". $table ."} WHERE expire != %d AND expire < %d", CACHE_PERMANENT, time());        variable_set('cache_flush_'. $table, 0);      }    }    else {      // No minimum cache lifetime, flush all temporary cache entries now.      db_query("DELETE FROM {". $table ."} WHERE expire != %d AND expire < %d", CACHE_PERMANENT, time());    }  }  else {    if ($wildcard) {      if ($cid == '*') {        db_query("TRUNCATE TABLE {". $table ."}");      }      else {        db_query("DELETE FROM {". $table ."} WHERE cid LIKE '%s%%'", $cid);      }    }    else {      db_query("DELETE FROM {". $table ."} WHERE cid = '%s'", $cid);    }  }}
<?php// $Id$/** * @file * Admin page callbacks for the filter module. *//** * Menu callback; Displays a list of all input formats and which * one is the default. * * @ingroup forms * @see filter_admin_overview_submit() */function filter_admin_overview() {  // Overview of all formats.  $formats = filter_formats();  $error = FALSE;  foreach ($formats as $id => $format) {    $roles = array();    foreach (user_roles() as $rid => $name) {      // Prepare a roles array with roles that may access the filter.      if (strstr($format->roles, ",$rid,")) {        $roles[] = $name;      }    }    $default = ($id == variable_get('filter_default_format', 1));    $options[$id] = '';    $form[$format->name]['id'] = array('#value' => $id);    $form[$format->name]['roles'] = array('#value' => $default ? t('All roles may use default format') : ($roles ? implode(', ', $roles) : t('No roles may use this format')));    $form[$format->name]['configure'] = array('#value' => l(t('configure'), 'admin/settings/filters/'. $id));    $form[$format->name]['delete'] = array('#value' => $default ? '' : l(t('delete'), 'admin/settings/filters/delete/'. $id));  }  $form['default'] = array('#type' => 'radios', '#options' => $options, '#default_value' => variable_get('filter_default_format', 1));  $form['submit'] = array('#type' => 'submit', '#value' => t('Set default format'));  return $form;}function filter_admin_overview_submit($form, &$form_state) {  // Process form submission to set the default format.  if (is_numeric($form_state['values']['default'])) {    drupal_set_message(t('Default format updated.'));    variable_set('filter_default_format', $form_state['values']['default']);  }}/** * Theme the admin overview form. * * @ingroup themeable */function theme_filter_admin_overview($form) {  $rows = array();  foreach ($form as $name => $element) {    if (isset($element['roles']) && is_array($element['roles'])) {      $rows[] = array(        drupal_render($form['default'][$element['id']['#value']]),        check_plain($name),        drupal_render($element['roles']),        drupal_render($element['configure']),        drupal_render($element['delete'])      );      unset($form[$name]);    }  }  $header = array(t('Default'), t('Name'), t('Roles'), array('data' => t('Operations'), 'colspan' => 2));  $output = theme('table', $header, $rows);  $output .= drupal_render($form);  return $output;}/** * Menu callback; Display a filter format form. */function filter_admin_format_page($format = NULL) {  if (!isset($format->name)) {    drupal_set_title(t("Add input format"));    $format = (object)array('name' => '', 'roles' => '', 'format' => '');  }  return drupal_get_form('filter_admin_format_form', $format);}/** * Generate a filter format form. * * @ingroup forms * @see filter_admin_format_form_validate() * @see filter_admin_format_form_submit() */function filter_admin_format_form(&$form_state, $format) {  $default = ($format->format == variable_get('filter_default_format', 1));  if ($default) {    $help = t('All roles for the default format must be enabled and cannot be changed.');    $form['default_format'] = array('#type' => 'hidden', '#value' => 1);  }  $form['name'] = array('#type' => 'textfield',    '#title' => t('Name'),    '#default_value' => $format->name,    '#description' => t('Specify a unique name for this filter format.'),    '#required' => TRUE,  );  // Add a row of checkboxes for form group.  $form['roles'] = array('#type' => 'fieldset',    '#title' => t('Roles'),    '#description' => $default ? $help : t('Choose which roles may use this filter format. Note that roles with the "administer filters" permission can always use all the filter formats.'),    '#tree' => TRUE,  );  foreach (user_roles() as $rid => $name) {    $checked = strstr($format->roles, ",$rid,");    $form['roles'][$rid] = array('#type' => 'checkbox',      '#title' => $name,      '#default_value' => ($default || $checked),    );    if ($default) {      $form['roles'][$rid]['#disabled'] = TRUE;    }  }  // Table with filters  $all = filter_list_all();  $enabled = filter_list_format($format->format);  $form['filters'] = array('#type' => 'fieldset',    '#title' => t('Filters'),    '#description' => t('Choose the filters that will be used in this filter format.'),    '#tree' => TRUE,  );  foreach ($all as $id => $filter) {    $form['filters'][$id] = array('#type' => 'checkbox',      '#title' => $filter->name,      '#default_value' => isset($enabled[$id]),      '#description' => module_invoke($filter->module, 'filter', 'description', $filter->delta),    );  }  if (!empty($format->format)) {    $form['format'] = array('#type' => 'hidden', '#value' => $format->format);    // Composition tips (guidelines)    $tips = _filter_tips($format->format, FALSE);    $extra = '<p>'. l(t('More information about formatting options'), 'filter/tips') .'</p>';    $tiplist = theme('filter_tips', $tips, FALSE, $extra);    if (!$tiplist) {      $tiplist = '<p>'. t('No guidelines available.') .'</p>';    }    $group = '<p>'. t('These are the guidelines that users will see for posting in this input format. They are automatically generated from the filter settings.') .'</p>';    $group .= $tiplist;    $form['tips'] = array('#value' => '<h2>'. t('Formatting guidelines') .'</h2>'. $group);  }  $form['submit'] = array('#type' => 'submit', '#value' => t('Save configuration'));  return $form;}/** * Validate filter format form submissions. */function filter_admin_format_form_validate($form, &$form_state) {  if (!isset($form_state['values']['format'])) {    $name = trim($form_state['values']['name']);    $result = db_fetch_object(db_query("SELECT format FROM {filter_formats} WHERE name='%s'", $name));    if ($result) {      form_set_error('name', t('Filter format names need to be unique. A format named %name already exists.', array('%name' => $name)));    }  }}/** * Process filter format form submissions. */function filter_admin_format_form_submit($form, &$form_state) {  $format = isset($form_state['values']['format']) ? $form_state['values']['format'] : NULL;  $current = filter_list_format($format);  $name = trim($form_state['values']['name']);  $cache = TRUE;  // Add a new filter format.  if (!$format) {    $new = TRUE;    db_query("INSERT INTO {filter_formats} (name) VALUES ('%s')", $name);    $format = db_result(db_query("SELECT MAX(format) AS format FROM {filter_formats}"));    drupal_set_message(t('Added input format %format.', array('%format' => $name)));  }  else {    drupal_set_message(t('The input format settings have been updated.'));  }  db_query("DELETE FROM {filters} WHERE format = %d", $format);  foreach ($form_state['values']['filters'] as $id => $checked) {    if ($checked) {      list($module, $delta) = explode('/', $id);      // Add new filters to the bottom.      $weight = isset($current[$id]->weight) ? $current[$id]->weight : 10;      db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $format, $module, $delta, $weight);      // Check if there are any 'no cache' filters.      $cache &= !module_invoke($module, 'filter', 'no cache', $delta);    }  }  // We store the roles as a string for ease of use.  // We should always set all roles to TRUE when saving a default role.  // We use leading and trailing comma's to allow easy substring matching.  $roles = array();  if (isset($form_state['values']['roles'])) {    foreach ($form_state['values']['roles'] as $id => $checked) {      if ($checked) {        $roles[] = $id;      }    }  }  if (!empty($form_state['values']['default_format'])) {    $roles = ','. implode(',', array_keys(user_roles())) .',';  }  else {    $roles = ','. implode(',', $roles) .',';  }  db_query("UPDATE {filter_formats} SET cache = %d, name='%s', roles = '%s' WHERE format = %d", $cache, $name, $roles, $format);  cache_clear_all($format .':', 'cache_filter', TRUE);  // If a new filter was added, return to the main list of filters. Otherwise, stay on edit filter page to show new changes.  $return = 'admin/settings/filters';  if (!empty($new)) {    $return .= '/'. $format;  }  $form_state['redirect'] = $return;  return;}/** * Menu callback; confirm deletion of a format. * * @ingroup forms * @see filter_admin_delete_submit() */function filter_admin_delete() {  $format = arg(4);  $format = db_fetch_object(db_query('SELECT * FROM {filter_formats} WHERE format = %d', $format));  if ($format) {    if ($format->format != variable_get('filter_default_format', 1)) {      $form['format'] = array('#type' => 'hidden', '#value' => $format->format);      $form['name'] = array('#type' => 'hidden', '#value' => $format->name);      return confirm_form($form, t('Are you sure you want to delete the input format %format?', array('%format' => $format->name)), 'admin/settings/filters', t('If you have any content left in this input format, it will be switched to the default input format. This action cannot be undone.'), t('Delete'), t('Cancel'));    }    else {      drupal_set_message(t('The default format cannot be deleted.'));      drupal_goto('admin/settings/filters');    }  }  else {    drupal_not_found();  }}/** * Process filter delete form submission. */function filter_admin_delete_submit($form, &$form_state) {  db_query("DELETE FROM {filter_formats} WHERE format = %d", $form_state['values']['format']);  db_query("DELETE FROM {filters} WHERE format = %d", $form_state['values']['format']);  $default = variable_get('filter_default_format', 1);  // Replace existing instances of the deleted format with the default format.  db_query("UPDATE {node_revisions} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  db_query("UPDATE {comments} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  db_query("UPDATE {boxes} SET format = %d WHERE format = %d", $default, $form_state['values']['format']);  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);  drupal_set_message(t('Deleted input format %format.', array('%format' => $form_state['values']['name'])));  $form_state['redirect'] = 'admin/settings/filters';  return;}/** * Menu callback; display settings defined by a format's filters. */function filter_admin_configure_page($format) {  drupal_set_title(t("Configure %format", array('%format' => $format->name)));  return drupal_get_form('filter_admin_configure', $format);}/** * Build a form to change the settings for a format's filters. * * @ingroup forms */function filter_admin_configure(&$form_state, $format) {  $list = filter_list_format($format->format);  $form = array();  foreach ($list as $filter) {    $form_module = module_invoke($filter->module, 'filter', 'settings', $filter->delta, $format->format);    if (isset($form_module) && is_array($form_module)) {      $form = array_merge($form, $form_module);    }  }  if (!empty($form)) {    $form = system_settings_form($form);  }  else {    $form['error'] = array('#value' => t('No settings are available.'));  }  $form['format'] = array('#type' => 'hidden', '#value' => $format->format);  $form['#submit'][] = 'filter_admin_configure_submit';  return $form;}/** * Clear the filter's cache when configuration settings are saved. */function filter_admin_configure_submit($form, &$form_state) {  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);}/** * Menu callback; display form for ordering filters for a format. */function filter_admin_order_page($format) {  drupal_set_title(t("Rearrange %format", array('%format' => $format->name)));  return drupal_get_form('filter_admin_order', $format);}/** * Build the form for ordering filters for a format. * * @ingroup forms * @see theme_filter_admin_order() * @see filter_admin_order_submit() */function filter_admin_order(&$form_state, $format = NULL) {  // Get list (with forced refresh).  $filters = filter_list_format($format->format);  $form['weights'] = array('#tree' => TRUE);  foreach ($filters as $id => $filter) {    $form['names'][$id] = array('#value' => $filter->name);    $form['weights'][$id] = array('#type' => 'weight', '#default_value' => $filter->weight);  }  $form['format'] = array('#type' => 'hidden', '#value' => $format->format);  $form['submit'] = array('#type' => 'submit', '#value' => t('Save configuration'));  return $form;}/** * Theme filter order configuration form. * * @ingroup themeable */function theme_filter_admin_order($form) {  $header = array(t('Name'), t('Weight'));  $rows = array();  foreach (element_children($form['names']) as $id) {    // Don't take form control structures.    if (is_array($form['names'][$id])) {      $form['weights'][$id]['#attributes']['class'] = 'filter-order-weight';      $rows[] = array(        'data' => array(drupal_render($form['names'][$id]), drupal_render($form['weights'][$id])),        'class' => 'draggable',      );    }  }  $output = theme('table', $header, $rows, array('id' => 'filter-order'));  $output .= drupal_render($form);  drupal_add_tabledrag('filter-order', 'order', 'sibling', 'filter-order-weight', NULL, NULL, FALSE);  return $output;}/** * Process filter order configuration form submission. */function filter_admin_order_submit($form, &$form_state) {  foreach ($form_state['values']['weights'] as $id => $weight) {    list($module, $delta) = explode('/', $id);    db_query("UPDATE {filters} SET weight = %d WHERE format = %d AND module = '%s' AND delta = %d", $weight, $form_state['values']['format'], $module, $delta);  }  drupal_set_message(t('The filter ordering has been saved.'));  cache_clear_all($form_state['values']['format'] .':', 'cache_filter', TRUE);}
<?php// $Id$/** * @file comment.tpl.php * Default theme implementation for comments. * * Available variables: * - $author: Comment author. Can be link or plain text. * - $content: Body of the post. * - $date: Date and time of posting. * - $links: Various operational links. * - $new: New comment marker. * - $picture: Authors picture. * - $signature: Authors signature. * - $status: Comment status. Possible values are: *   comment-unpublished, comment-published or comment-preview. * - $submitted: By line with date and time. * - $title: Linked title. * * These two variables are provided for context. * - $comment: Full comment object. * - $node: Node object the comments are attached to. * * @see template_preprocess_comment() * @see theme_comment() */?><div class="comment<?php print ($comment->new) ? ' comment-new' : ''; print ' '. $status ?> clear-block">  <?php print $picture ?>  <?php if ($comment->new): ?>    <span class="new"><?php print $new ?></span>  <?php endif; ?>  <h3><?php print $title ?></h3>  <div class="submitted">    <?php print $submitted ?>  </div>  <div class="content">    <?php print $content ?>    <?php if ($signature): ?>    <div class="user-signature clear-block">      <?php print $signature ?>    </div>    <?php endif; ?>  </div>  <?php print $links ?></div>
<?php// $Id$/** * Form API callback to validate the upload settings form. */function upload_admin_settings_validate($form, &$form_state) {  if (($form_state['values']['upload_max_resolution'] != '0')) {    if (!preg_match('/^[0-9]+x[0-9]+$/', $form_state['values']['upload_max_resolution'])) {      form_set_error('upload_max_resolution', t('The maximum allowed image size expressed as WIDTHxHEIGHT (e.g. 640x480). Set to 0 for no restriction.'));    }  }  $default_uploadsize = $form_state['values']['upload_uploadsize_default'];  $default_usersize = $form_state['values']['upload_usersize_default'];  $exceed_max_msg = t('Your PHP settings limit the maximum file size per upload to %size.', array('%size' => format_size(file_upload_max_size()))) .'<br/>';  $more_info = t("Depending on your server environment, these settings may be changed in the system-wide php.ini file, a php.ini file in your Drupal root directory, in your Drupal site's settings.php file, or in the .htaccess file in your Drupal root directory.");  if (!is_numeric($default_uploadsize) || ($default_uploadsize <= 0)) {    form_set_error('upload_uploadsize_default', t('The %role file size limit must be a number and greater than zero.', array('%role' => t('default'))));  }  if (!is_numeric($default_usersize) || ($default_usersize <= 0)) {    form_set_error('upload_usersize_default', t('The %role file size limit must be a number and greater than zero.', array('%role' => t('default'))));  }  if ($default_uploadsize * 1024 * 1024 > file_upload_max_size()) {    form_set_error('upload_uploadsize_default', $exceed_max_msg . $more_info);    $more_info = '';  }  if ($default_uploadsize > $default_usersize) {    form_set_error('upload_uploadsize_default', t('The %role maximum file size per upload is greater than the total file size allowed per user', array('%role' => t('default'))));  }  foreach ($form_state['values']['roles'] as $rid => $role) {    $uploadsize = $form_state['values']['upload_uploadsize_'. $rid];    $usersize = $form_state['values']['upload_usersize_'. $rid];    if (!is_numeric($uploadsize) || ($uploadsize <= 0)) {      form_set_error('upload_uploadsize_'. $rid, t('The %role file size limit must be a number and greater than zero.', array('%role' => $role)));    }    if (!is_numeric($usersize) || ($usersize <= 0)) {      form_set_error('upload_usersize_'. $rid, t('The %role file size limit must be a number and greater than zero.', array('%role' => $role)));    }    if ($uploadsize * 1024 * 1024 > file_upload_max_size()) {      form_set_error('upload_uploadsize_'. $rid, $exceed_max_msg . $more_info);      $more_info = '';    }    if ($uploadsize > $usersize) {      form_set_error('upload_uploadsize_'. $rid, t('The %role maximum file size per upload is greater than the total file size allowed per user', array('%role' => $role)));    }  }}/** * Menu callback for the upload settings form. */function upload_admin_settings() {  $upload_extensions_default = variable_get('upload_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp');  $upload_uploadsize_default = variable_get('upload_uploadsize_default', 1);  $upload_usersize_default = variable_get('upload_usersize_default', 1);  $form['settings_general'] = array(    '#type' => 'fieldset',    '#title' => t('General settings'),    '#collapsible' => TRUE,  );  $form['settings_general']['upload_max_resolution'] = array(    '#type' => 'textfield',    '#title' => t('Maximum resolution for uploaded images'),    '#default_value' => variable_get('upload_max_resolution', 0),    '#size' => 15,    '#maxlength' => 10,    '#description' => t('The maximum allowed image size (e.g. 640x480). Set to 0 for no restriction. If an <a href="!image-toolkit-link">image toolkit</a> is installed, files exceeding this value will be scaled down to fit.', array('!image-toolkit-link' => url('admin/settings/image-toolkit'))),    '#field_suffix' => '<kbd>'. t('WIDTHxHEIGHT') .'</kbd>'  );  $form['settings_general']['upload_list_default'] = array(    '#type' => 'select',    '#title' => t('List files by default'),    '#default_value' => variable_get('upload_list_default', 1),    '#options' => array(0 => t('No'), 1 => t('Yes')),    '#description' => t('Display attached files when viewing a post.'),  );  $form['settings_general']['upload_extensions_default'] = array(    '#type' => 'textfield',    '#title' => t('Default permitted file extensions'),    '#default_value' => $upload_extensions_default,    '#maxlength' => 255,    '#description' => t('Default extensions that users can upload. Separate extensions with a space and do not include the leading dot.'),  );  $form['settings_general']['upload_uploadsize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default maximum file size per upload'),    '#default_value' => $upload_uploadsize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum file size a user can upload. If an image is uploaded and a maximum resolution is set, the size will be checked after the file has been resized.'),    '#field_suffix' => t('MB'),  );  $form['settings_general']['upload_usersize_default'] = array(    '#type' => 'textfield',    '#title' => t('Default total file size per user'),    '#default_value' => $upload_usersize_default,    '#size' => 5,    '#maxlength' => 5,    '#description' => t('The default maximum size of all files a user can have on the site.'),    '#field_suffix' => t('MB'),  );  $form['settings_general']['upload_max_size'] = array('#value' => '<p>'. t('Your PHP settings limit the maximum file size per upload to %size.', array('%size' => format_size(file_upload_max_size()))) .'</p>');  $roles = user_roles(FALSE, 'upload files');  $form['roles'] = array('#type' => 'value', '#value' => $roles);  foreach ($roles as $rid => $role) {    $form['settings_role_'. $rid] = array(      '#type' => 'fieldset',      '#title' => t('Settings for @role', array('@role' => $role)),      '#collapsible' => TRUE,      '#collapsed' => TRUE,    );    $form['settings_role_'. $rid]['upload_extensions_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Permitted file extensions'),      '#default_value' => variable_get('upload_extensions_'. $rid, $upload_extensions_default),      '#maxlength' => 255,      '#description' => t('Extensions that users in this role can upload. Separate extensions with a space and do not include the leading dot.'),    );    $form['settings_role_'. $rid]['upload_uploadsize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Maximum file size per upload'),      '#default_value' => variable_get('upload_uploadsize_'. $rid, $upload_uploadsize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of a file a user can upload. If an image is uploaded and a maximum resolution is set, the size will be checked after the file has been resized.'),      '#field_suffix' => t('MB'),    );    $form['settings_role_'. $rid]['upload_usersize_'. $rid] = array(      '#type' => 'textfield',      '#title' => t('Total file size per user'),      '#default_value' => variable_get('upload_usersize_'. $rid, $upload_usersize_default),      '#size' => 5,      '#maxlength' => 5,      '#description' => t('The maximum size of all files a user can have on the site.'),      '#field_suffix' => t('MB'),    );  }  $form['#validate'] = array('upload_admin_settings_validate');  return system_settings_form($form);}
<?php// $Id$/** * @file * API for handling file uploads and server file management. *//** * @defgroup file File interface * @{ * Common file handling functions. */define('FILE_DOWNLOADS_PUBLIC', 1);define('FILE_DOWNLOADS_PRIVATE', 2);define('FILE_CREATE_DIRECTORY', 1);define('FILE_MODIFY_PERMISSIONS', 2);define('FILE_EXISTS_RENAME', 0);define('FILE_EXISTS_REPLACE', 1);define('FILE_EXISTS_ERROR', 2);/** * A files status can be one of two values: temporary or permanent. The status * for each file Drupal manages is stored in the {files} tables. If the status * is temporary Drupal's file garbage collection will delete the file and * remove it from the files table after a set period of time. * * If you wish to add custom statuses for use by contrib modules please expand as * binary flags and consider the first 8 bits reserved. (0,1,2,4,8,16,32,64,128) */define('FILE_STATUS_TEMPORARY', 0);define('FILE_STATUS_PERMANENT', 1);/** * Create the download path to a file. * * @param $path A string containing the path of the file to generate URL for. * @return A string containing a URL that can be used to download the file. */function file_create_url($path) {  // Strip file_directory_path from $path. We only include relative paths in urls.  if (strpos($path, file_directory_path() .'/') === 0) {    $path = trim(substr($path, strlen(file_directory_path())), '\\/');  }  switch (variable_get('file_downloads', FILE_DOWNLOADS_PUBLIC)) {    case FILE_DOWNLOADS_PUBLIC:      return $GLOBALS['base_url'] .'/'. file_directory_path() .'/'. str_replace('\\', '/', $path);    case FILE_DOWNLOADS_PRIVATE:      return url('system/files/'. $path, array('absolute' => TRUE));  }}/** * Make sure the destination is a complete path and resides in the file system * directory, if it is not prepend the file system directory. * * @param $dest A string containing the path to verify. If this value is *   omitted, Drupal's 'files' directory will be used. * @return A string containing the path to file, with file system directory *   appended if necessary, or FALSE if the path is invalid (i.e. outside the *   configured 'files' or temp directories). */function file_create_path($dest = 0) {  $file_path = file_directory_path();  if (!$dest) {    return $file_path;  }  // file_check_location() checks whether the destination is inside the Drupal files directory.  if (file_check_location($dest, $file_path)) {    return $dest;  }  // check if the destination is instead inside the Drupal temporary files directory.  else if (file_check_location($dest, file_directory_temp())) {    return $dest;  }  // Not found, try again with prefixed directory path.  else if (file_check_location($file_path .'/'. $dest, $file_path)) {    return $file_path .'/'. $dest;  }  // File not found.  return FALSE;}/** * Check that the directory exists and is writable. Directories need to * have execute permissions to be considered a directory by FTP servers, etc. * * @param $directory A string containing the name of a directory path. * @param $mode A Boolean value to indicate if the directory should be created *   if it does not exist or made writable if it is read-only. * @param $form_item An optional string containing the name of a form item that *   any errors will be attached to. This is useful for settings forms that *   require the user to specify a writable directory. If it can't be made to *   work, a form error will be set preventing them from saving the settings. * @return FALSE when directory not found, or TRUE when directory exists. */function file_check_directory(&$directory, $mode = 0, $form_item = NULL) {  $directory = rtrim($directory, '/\\');  // Check if directory exists.  if (!is_dir($directory)) {    if (($mode & FILE_CREATE_DIRECTORY) && @mkdir($directory)) {      drupal_set_message(t('The directory %directory has been created.', array('%directory' => $directory)));      @chmod($directory, 0775); // Necessary for non-webserver users.    }    else {      if ($form_item) {        form_set_error($form_item, t('The directory %directory does not exist.', array('%directory' => $directory)));      }      return FALSE;    }  }  // Check to see if the directory is writable.  if (!is_writable($directory)) {    if (($mode & FILE_MODIFY_PERMISSIONS) && @chmod($directory, 0775)) {      drupal_set_message(t('The permissions of directory %directory have been changed to make it writable.', array('%directory' => $directory)));    }    else {      form_set_error($form_item, t('The directory %directory is not writable', array('%directory' => $directory)));      watchdog('file system', 'The directory %directory is not writable, because it does not have the correct permissions set.', array('%directory' => $directory), WATCHDOG_ERROR);      return FALSE;    }  }  if ((file_directory_path() == $directory || file_directory_temp() == $directory) && !is_file("$directory/.htaccess")) {    $htaccess_lines = "SetHandler Drupal_Security_Do_Not_Remove_See_SA_2006_006\nOptions None\nOptions +FollowSymLinks";    if (($fp = fopen("$directory/.htaccess", 'w')) && fputs($fp, $htaccess_lines)) {      fclose($fp);      chmod($directory .'/.htaccess', 0664);    }    else {      $variables = array('%directory' => $directory, '!htaccess' => '<br />'. nl2br(check_plain($htaccess_lines)));      form_set_error($form_item, t("Security warning: Couldn't write .htaccess file. Please create a .htaccess file in your %directory directory which contains the following lines: <code>!htaccess</code>", $variables));      watchdog('security', "Security warning: Couldn't write .htaccess file. Please create a .htaccess file in your %directory directory which contains the following lines: <code>!htaccess</code>", $variables, WATCHDOG_ERROR);    }  }  return TRUE;}/** * Checks path to see if it is a directory, or a dir/file. * * @param $path A string containing a file path. This will be set to the *   directory's path. * @return If the directory is not in a Drupal writable directory, FALSE is *   returned. Otherwise, the base name of the path is returned. */function file_check_path(&$path) {  // Check if path is a directory.  if (file_check_directory($path)) {    return '';  }  // Check if path is a possible dir/file.  $filename = basename($path);  $path = dirname($path);  if (file_check_directory($path)) {    return $filename;  }  return FALSE;}/** * Check if a file is really located inside $directory. Should be used to make * sure a file specified is really located within the directory to prevent * exploits. * * @code *   // Returns FALSE: *   file_check_location('/www/example.com/files/../../../etc/passwd', '/www/example.com/files'); * @endcode * * @param $source A string set to the file to check. * @param $directory A string where the file should be located. * @return 0 for invalid path or the real path of the source. */function file_check_location($source, $directory = '') {  $check = realpath($source);  if ($check) {    $source = $check;  }  else {    // This file does not yet exist    $source = realpath(dirname($source)) .'/'. basename($source);  }  $directory = realpath($directory);  if ($directory && strpos($source, $directory) !== 0) {    return 0;  }  return $source;}/** * Copies a file to a new location. This is a powerful function that in many ways * performs like an advanced version of copy(). * - Checks if $source and $dest are valid and readable/writable. * - Performs a file copy if $source is not equal to $dest. * - If file already exists in $dest either the call will error out, replace the *   file or rename the file based on the $replace parameter. * * @param $source A string specifying the file location of the original file. *   This parameter will contain the resulting destination filename in case of *   success. * @param $dest A string containing the directory $source should be copied to. *   If this value is omitted, Drupal's 'files' directory will be used. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return True for success, FALSE for failure. */function file_copy(&$source, $dest = 0, $replace = FILE_EXISTS_RENAME) {  $dest = file_create_path($dest);  $directory = $dest;  $basename = file_check_path($directory);  // Make sure we at least have a valid directory.  if ($basename === FALSE) {    $source = is_object($source) ? $source->filepath : $source;    drupal_set_message(t('The selected file %file could not be uploaded, because the destination %directory is not properly configured.', array('%file' => $source, '%directory' => $dest)), 'error');    watchdog('file system', 'The selected file %file could not be uploaded, because the destination %directory could not be found, or because its permissions do not allow the file to be written.', array('%file' => $source, '%directory' => $dest), WATCHDOG_ERROR);    return 0;  }  // Process a file upload object.  if (is_object($source)) {    $file = $source;    $source = $file->filepath;    if (!$basename) {      $basename = $file->filename;    }  }  $source = realpath($source);  if (!file_exists($source)) {    drupal_set_message(t('The selected file %file could not be copied, because no file by that name exists. Please check that you supplied the correct filename.', array('%file' => $source)), 'error');    return 0;  }  // If the destination file is not specified then use the filename of the source file.  $basename = $basename ? $basename : basename($source);  $dest = $directory .'/'. $basename;  // Make sure source and destination filenames are not the same, makes no sense  // to copy it if they are. In fact copying the file will most likely result in  // a 0 byte file. Which is bad. Real bad.  if ($source != realpath($dest)) {    if (!$dest = file_destination($dest, $replace)) {      drupal_set_message(t('The selected file %file could not be copied, because a file by that name already exists in the destination.', array('%file' => $source)), 'error');      return FALSE;    }    if (!@copy($source, $dest)) {      drupal_set_message(t('The selected file %file could not be copied.', array('%file' => $source)), 'error');      return 0;    }    // Give everyone read access so that FTP'd users or    // non-webserver users can see/read these files,    // and give group write permissions so group members    // can alter files uploaded by the webserver.    @chmod($dest, 0664);  }  if (isset($file) && is_object($file)) {    $file->filename = $basename;    $file->filepath = $dest;    $source = $file;  }  else {    $source = $dest;  }  return 1; // Everything went ok.}/** * Determines the destination path for a file depending on how replacement of * existing files should be handled. * * @param $destination A string specifying the desired path. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is *     unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return The destination file path or FALSE if the file already exists and *   FILE_EXISTS_ERROR was specified. */function file_destination($destination, $replace) {  if (file_exists($destination)) {    switch ($replace) {      case FILE_EXISTS_RENAME:        $basename = basename($destination);        $directory = dirname($destination);        $destination = file_create_filename($basename, $directory);        break;      case FILE_EXISTS_ERROR:        drupal_set_message(t('The selected file %file could not be copied, because a file by that name already exists in the destination.', array('%file' => $destination)), 'error');        return FALSE;    }  }  return $destination;}/** * Moves a file to a new location. * - Checks if $source and $dest are valid and readable/writable. * - Performs a file move if $source is not equal to $dest. * - If file already exists in $dest either the call will error out, replace the *   file or rename the file based on the $replace parameter. * * @param $source A string specifying the file location of the original file. *   This parameter will contain the resulting destination filename in case of *   success. * @param $dest A string containing the directory $source should be copied to. *   If this value is omitted, Drupal's 'files' directory will be used. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * @return True for success, FALSE for failure. */function file_move(&$source, $dest = 0, $replace = FILE_EXISTS_RENAME) {  $path_original = is_object($source) ? $source->filepath : $source;  if (file_copy($source, $dest, $replace)) {    $path_current = is_object($source) ? $source->filepath : $source;    if ($path_original == $path_current || file_delete($path_original)) {      return 1;    }    drupal_set_message(t('The removal of the original file %file has failed.', array('%file' => $path_original)), 'error');  }  return 0;}/** * Modify a filename as needed for security purposes. * * Dangerous file names will be altered; for instance, the file name * "exploit.php.pps" will become "exploit.php_.pps". All extensions that are * between 2 and 5 characters in length, internal to the file name, and not * included in $extensions will be altered by adding an underscore. If variable * 'allow_insecure_uploads' evaluates to TRUE, no alterations will be made. * * @param $filename *   File name to modify. * @param $extensions *   A space-separated list of extensions that should not be altered. * @param $alerts *   If TRUE, drupal_set_message() will be called to display a message if the *   file name was changed. * * @return *   The potentially modified $filename. */function file_munge_filename($filename, $extensions, $alerts = TRUE) {  $original = $filename;  // Allow potentially insecure uploads for very savvy users and admin  if (!variable_get('allow_insecure_uploads', 0)) {    $whitelist = array_unique(explode(' ', trim($extensions)));    // Split the filename up by periods. The first part becomes the basename    // the last part the final extension.    $filename_parts = explode('.', $filename);    $new_filename = array_shift($filename_parts); // Remove file basename.    $final_extension = array_pop($filename_parts); // Remove final extension.    // Loop through the middle parts of the name and add an underscore to the    // end of each section that could be a file extension but isn't in the list    // of allowed extensions.    foreach ($filename_parts as $filename_part) {      $new_filename .= '.'. $filename_part;      if (!in_array($filename_part, $whitelist) && preg_match("/^[a-zA-Z]{2,5}\d?$/", $filename_part)) {        $new_filename .= '_';      }    }    $filename = $new_filename .'.'. $final_extension;    if ($alerts && $original != $filename) {      drupal_set_message(t('For security reasons, your upload has been renamed to %filename.', array('%filename' => $filename)));    }  }  return $filename;}/** * Undo the effect of upload_munge_filename(). * * @param $filename string filename * @return string */function file_unmunge_filename($filename) {  return str_replace('_.', '.', $filename);}/** * Create a full file path from a directory and filename. If a file with the * specified name already exists, an alternative will be used. * * @param $basename string filename * @param $directory string directory * @return */function file_create_filename($basename, $directory) {  $dest = $directory .'/'. $basename;  if (file_exists($dest)) {    // Destination file already exists, generate an alternative.    if ($pos = strrpos($basename, '.')) {      $name = substr($basename, 0, $pos);      $ext = substr($basename, $pos);    }    else {      $name = $basename;    }    $counter = 0;    do {      $dest = $directory .'/'. $name .'_'. $counter++ . $ext;    } while (file_exists($dest));  }  return $dest;}/** * Delete a file. * * @param $path A string containing a file path. * @return TRUE for success, FALSE for failure. */function file_delete($path) {  if (is_file($path)) {    return unlink($path);  }}/** * Determine total disk space used by a single user or the whole filesystem. * * @param $uid *   An optional user id. A NULL value returns the total space used *   by all files. */function file_space_used($uid = NULL) {  if (isset($uid)) {    return (int) db_result(db_query('SELECT SUM(filesize) FROM {files} WHERE uid = %d', $uid));  }  return (int) db_result(db_query('SELECT SUM(filesize) FROM {files}'));}/** * Saves a file upload to a new location. The source file is validated as a * proper upload and handled as such. * * The file will be added to the files table as a temporary file. Temporary files * are periodically cleaned. To make the file permanent file call * file_set_status() to change its status. * * @param $source *   A string specifying the name of the upload field to save. * @param $validators *   An optional, associative array of callback functions used to validate the *   file. The keys are function names and the values arrays of callback *   parameters which will be passed in after the file object. The *   functions should return an array of error messages; an empty array *   indicates that the file passed validation. The functions will be called in *   the order specified. * @param $dest *   A string containing the directory $source should be copied to. If this is *   not provided or is not writable, the temporary directory will be used. * @param $replace *   A boolean indicating whether an existing file of the same name in the *   destination directory should overwritten. A false value will generate a *   new, unique filename in the destination directory. * @return *   An object containing the file information, or 0 in the event of an error. */function file_save_upload($source, $validators = array(), $dest = FALSE, $replace = FILE_EXISTS_RENAME) {  global $user;  static $upload_cache;  // Add in our check of the the file name length.  $validators['file_validate_name_length'] = array();  // Return cached objects without processing since the file will have  // already been processed and the paths in _FILES will be invalid.  if (isset($upload_cache[$source])) {    return $upload_cache[$source];  }  // If a file was uploaded, process it.  if (isset($_FILES['files']) && $_FILES['files']['name'][$source] && is_uploaded_file($_FILES['files']['tmp_name'][$source])) {    // Check for file upload errors and return FALSE if a    // lower level system error occurred.    switch ($_FILES['files']['error'][$source]) {      // @see http://php.net/manual/en/features.file-upload.errors.php      case UPLOAD_ERR_OK:        break;      case UPLOAD_ERR_INI_SIZE:      case UPLOAD_ERR_FORM_SIZE:        drupal_set_message(t('The file %file could not be saved, because it exceeds %maxsize, the maximum allowed size for uploads.', array('%file' => $source, '%maxsize' => format_size(file_upload_max_size()))), 'error');        return 0;      case UPLOAD_ERR_PARTIAL:      case UPLOAD_ERR_NO_FILE:        drupal_set_message(t('The file %file could not be saved, because the upload did not complete.', array('%file' => $source)), 'error');        return 0;        // Unknown error      default:        drupal_set_message(t('The file %file could not be saved. An unknown error has occurred.', array('%file' => $source)), 'error');        return 0;    }    // Build the list of non-munged extensions.    // @todo: this should not be here. we need to figure out the right place.    $extensions = '';    foreach ($user->roles as $rid => $name) {      $extensions .= ' '. variable_get("upload_extensions_$rid",      variable_get('upload_extensions_default', 'jpg jpeg gif png txt html doc xls pdf ppt pps odt ods odp'));    }    // Begin building file object.    $file = new stdClass();    $file->filename = file_munge_filename(trim(basename($_FILES['files']['name'][$source]), '.'), $extensions);    $file->filepath = $_FILES['files']['tmp_name'][$source];    $file->filemime = file_get_mimetype($file->filename);    // If the destination is not provided, or is not writable, then use the    // temporary directory.    if (empty($dest) || file_check_path($dest) === FALSE) {      $dest = file_directory_temp();    }    $file->source = $source;    $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), $replace);    $file->filesize = $_FILES['files']['size'][$source];    // Call the validation functions.    $errors = array();    foreach ($validators as $function => $args) {      array_unshift($args, $file);      // Make sure $file is passed around by reference.      $args[0] = &$file;      $errors = array_merge($errors, call_user_func_array($function, $args));    }    // Rename potentially executable files, to help prevent exploits.    if (preg_match('/\.(php|pl|py|cgi|asp|js)$/i', $file->filename) && (substr($file->filename, -4) != '.txt')) {            $file->filemime = 'text/plain';      $file->filepath .= '.txt';      $file->filename .= '.txt';      // As the file may be named example.php.txt, we need to munge again to      // convert to example.php_.txt, then create the correct destination.      $file->filename = file_munge_filename($file->filename, $extensions);      $file->destination = file_destination(file_create_path($dest .'/'. $file->filename), $replace);    }    // Check for validation errors.    if (!empty($errors)) {      $message = t('The selected file %name could not be uploaded.', array('%name' => $file->filename));      if (count($errors) > 1) {        $message .= '<ul><li>'. implode('</li><li>', $errors) .'</li></ul>';      }      else {        $message .= ' '. array_pop($errors);      }      form_set_error($source, $message);      return 0;    }    // Move uploaded files from PHP's upload_tmp_dir to Drupal's temporary directory.    // This overcomes open_basedir restrictions for future file operations.    $file->filepath = $file->destination;    if (!move_uploaded_file($_FILES['files']['tmp_name'][$source], $file->filepath)) {      form_set_error($source, t('File upload error. Could not move uploaded file.'));      watchdog('file', 'Upload error. Could not move uploaded file %file to destination %destination.', array('%file' => $file->filename, '%destination' => $file->filepath));      return 0;    }    // If we made it this far it's safe to record this file in the database.    $file->uid = $user->uid;    $file->status = FILE_STATUS_TEMPORARY;    $file->timestamp = time();    drupal_write_record('files', $file);    // Add file to the cache.    $upload_cache[$source] = $file;    return $file;  }  return 0;}/** * Check for files with names longer than we can store in the database. * * @param $file *   A Drupal file object. * @return *   An array. If the file name is too long, it will contain an error message. */function file_validate_name_length($file) {  $errors = array();  if (strlen($file->filename) > 255) {    $errors[] = t('Its name exceeds the 255 characters limit. Please rename the file and try again.');  }  return $errors;}/** * Check that the filename ends with an allowed extension. This check is not * enforced for the user #1. * * @param $file *   A Drupal file object. * @param $extensions *   A string with a space separated * @return *   An array. If the file extension is not allowed, it will contain an error message. */function file_validate_extensions($file, $extensions) {  global $user;  $errors = array();  // Bypass validation for uid  = 1.  if ($user->uid != 1) {    $regex = '/\.('. ereg_replace(' +', '|', preg_quote($extensions)) .')$/i';    if (!preg_match($regex, $file->filename)) {      $errors[] = t('Only files with the following extensions are allowed: %files-allowed.', array('%files-allowed' => $extensions));    }  }  return $errors;}/** * Check that the file's size is below certain limits. This check is not * enforced for the user #1. * * @param $file *   A Drupal file object. * @param $file_limit *   An integer specifying the maximum file size in bytes. Zero indicates that *   no limit should be enforced. * @param $user_limit *   An integer specifying the maximum number of bytes the user is allowed. Zero *   indicates that no limit should be enforced. * @return *   An array. If the file size exceeds limits, it will contain an error message. */function file_validate_size($file, $file_limit = 0, $user_limit = 0) {  global $user;  $errors = array();  // Bypass validation for uid  = 1.  if ($user->uid != 1) {    if ($file_limit && $file->filesize > $file_limit) {      $errors[] = t('The file is %filesize exceeding the maximum file size of %maxsize.', array('%filesize' => format_size($file->filesize), '%maxsize' => format_size($file_limit)));    }    // Save a query by only calling file_space_used() when a limit is provided.    if ($user_limit && (file_space_used($user->uid) + $file->filesize) > $user_limit) {      $errors[] = t('The file is %filesize which would exceed your disk quota of %quota.', array('%filesize' => format_size($file->filesize), '%quota' => format_size($user_limit)));    }  }  return $errors;}/** * Check that the file is recognized by image_get_info() as an image. * * @param $file *   A Drupal file object. * @return *   An array. If the file is not an image, it will contain an error message. */function file_validate_is_image(&$file) {  $errors = array();  $info = image_get_info($file->filepath);  if (!$info || empty($info['extension'])) {    $errors[] = t('Only JPEG, PNG and GIF images are allowed.');  }  return $errors;}/** * If the file is an image verify that its dimensions are within the specified * maximum and minimum dimensions. Non-image files will be ignored. * * @param $file *   A Drupal file object. This function may resize the file affecting its size. * @param $maximum_dimensions *   An optional string in the form WIDTHxHEIGHT e.g. '640x480' or '85x85'. If *   an image toolkit is installed the image will be resized down to these *   dimensions. A value of 0 indicates no restriction on size, so resizing *   will be attempted. * @param $minimum_dimensions *   An optional string in the form WIDTHxHEIGHT. This will check that the image *   meets a minimum size. A value of 0 indicates no restriction. * @return *   An array. If the file is an image and did not meet the requirements, it *   will contain an error message. */function file_validate_image_resolution(&$file, $maximum_dimensions = 0, $minimum_dimensions = 0) {  $errors = array();  // Check first that the file is an image.  if ($info = image_get_info($file->filepath)) {    if ($maximum_dimensions) {      // Check that it is smaller than the given dimensions.      list($width, $height) = explode('x', $maximum_dimensions);      if ($info['width'] > $width || $info['height'] > $height) {        // Try to resize the image to fit the dimensions.        if (image_get_toolkit() && image_scale($file->filepath, $file->filepath, $width, $height)) {          drupal_set_message(t('The image was resized to fit within the maximum allowed dimensions of %dimensions pixels.', array('%dimensions' => $maximum_dimensions)));          // Clear the cached filesize and refresh the image information.          clearstatcache();          $info = image_get_info($file->filepath);          $file->filesize = $info['file_size'];        }        else {          $errors[] = t('The image is too large; the maximum dimensions are %dimensions pixels.', array('%dimensions' => $maximum_dimensions));        }      }    }    if ($minimum_dimensions) {      // Check that it is larger than the given dimensions.      list($width, $height) = explode('x', $minimum_dimensions);      if ($info['width'] < $width || $info['height'] < $height) {        $errors[] = t('The image is too small; the minimum dimensions are %dimensions pixels.', array('%dimensions' => $minimum_dimensions));      }    }  }  return $errors;}/** * Save a string to the specified destination. * * @param $data A string containing the contents of the file. * @param $dest A string containing the destination location. * @param $replace Replace behavior when the destination file already exists. *   - FILE_EXISTS_REPLACE - Replace the existing file *   - FILE_EXISTS_RENAME - Append _{incrementing number} until the filename is unique *   - FILE_EXISTS_ERROR - Do nothing and return FALSE. * * @return A string containing the resulting filename or 0 on error */function file_save_data($data, $dest, $replace = FILE_EXISTS_RENAME) {  $temp = file_directory_temp();  // On Windows, tempnam() requires an absolute path, so we use realpath().  $file = tempnam(realpath($temp), 'file');  if (!$fp = fopen($file, 'wb')) {    drupal_set_message(t('The file could not be created.'), 'error');    return 0;  }  fwrite($fp, $data);  fclose($fp);  if (!file_move($file, $dest, $replace)) {    return 0;  }  return $file;}/** * Set the status of a file. * * @param file A Drupal file object * @param status A status value to set the file to. * @return FALSE on failure, TRUE on success and $file->status will contain the *     status. */function file_set_status(&$file, $status) {  if (db_query('UPDATE {files} SET status = %d WHERE fid = %d', $status, $file->fid)) {    $file->status = $status;    return TRUE;  }  return FALSE;}/** * Transfer file using http to client. Pipes a file through Drupal to the * client. * * @param $source File to transfer. * @param $headers An array of http headers to send along with file. */function file_transfer($source, $headers) {  if (ob_get_level()) {    ob_end_clean();  }  foreach ($headers as $header) {    // To prevent HTTP header injection, we delete new lines that are    // not followed by a space or a tab.    // See http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2    $header = preg_replace('/\r?\n(?!\t| )/', '', $header);    drupal_set_header($header);  }  $source = file_create_path($source);  // Transfer file in 1024 byte chunks to save memory usage.  if ($fd = fopen($source, 'rb')) {    while (!feof($fd)) {      print fread($fd, 1024);    }    fclose($fd);  }  else {    drupal_not_found();  }  exit();}/** * Call modules that implement hook_file_download() to find out if a file is * accessible and what headers it should be transferred with. If a module * returns -1 drupal_access_denied() will be returned. If one or more modules * returned headers the download will start with the returned headers. If no * modules respond drupal_not_found() will be returned. */function file_download() {  // Merge remainder of arguments from GET['q'], into relative file path.  $args = func_get_args();  $filepath = implode('/', $args);  // Maintain compatibility with old ?file=paths saved in node bodies.  if (isset($_GET['file'])) {    $filepath =  $_GET['file'];  }  if (file_exists(file_create_path($filepath))) {    $headers = module_invoke_all('file_download', $filepath);    if (in_array(-1, $headers)) {      return drupal_access_denied();    }    if (count($headers)) {      file_transfer($filepath, $headers);    }  }  return drupal_not_found();}/** * Finds all files that match a given mask in a given directory. * Directories and files beginning with a period are excluded; this * prevents hidden files and directories (such as SVN working directories) * from being scanned. * * @param $dir *   The base directory for the scan, without trailing slash. * @param $mask *   The regular expression of the files to find. * @param $nomask *   An array of files/directories to ignore. * @param $callback *   The callback function to call for each match. * @param $recurse *   When TRUE, the directory scan will recurse the entire tree *   starting at the provided directory. * @param $key *   The key to be used for the returned array of files. Possible *   values are "filename", for the path starting with $dir, *   "basename", for the basename of the file, and "name" for the name *   of the file without an extension. * @param $min_depth *   Minimum depth of directories to return files from. * @param $depth *   Current depth of recursion. This parameter is only used internally and should not be passed. * * @return *   An associative array (keyed on the provided key) of objects with *   "path", "basename", and "name" members corresponding to the *   matching files. */function file_scan_directory($dir, $mask, $nomask = array('.', '..', 'CVS'), $callback = 0, $recurse = TRUE, $key = 'filename', $min_depth = 0, $depth = 0) {  $key = (in_array($key, array('filename', 'basename', 'name')) ? $key : 'filename');  $files = array();  if (is_dir($dir) && $handle = opendir($dir)) {    while (FALSE !== ($file = readdir($handle))) {      if (!in_array($file, $nomask) && $file[0] != '.') {        if (is_dir("$dir/$file") && $recurse) {          // Give priority to files in this folder by merging them in after any subdirectory files.          $files = array_merge(file_scan_directory("$dir/$file", $mask, $nomask, $callback, $recurse, $key, $min_depth, $depth + 1), $files);        }        elseif ($depth >= $min_depth && ereg($mask, $file)) {          // Always use this match over anything already set in $files with the same $$key.          $filename = "$dir/$file";          $basename = basename($file);          $name = substr($basename, 0, strrpos($basename, '.'));          $files[$$key] = new stdClass();          $files[$$key]->filename = $filename;          $files[$$key]->basename = $basename;          $files[$$key]->name = $name;          if ($callback) {            $callback($filename);          }        }      }    }    closedir($handle);  }  return $files;}/** * Determine the default temporary directory. * * @return A string containing a temp directory. */function file_directory_temp() {  $temporary_directory = variable_get('file_directory_temp', NULL);  if (is_null($temporary_directory)) {    $directories = array();    // Has PHP been set with an upload_tmp_dir?    if (ini_get('upload_tmp_dir')) {      $directories[] = ini_get('upload_tmp_dir');    }    // Operating system specific dirs.    if (substr(PHP_OS, 0, 3) == 'WIN') {      $directories[] = 'c:\\windows\\temp';      $directories[] = 'c:\\winnt\\temp';      $path_delimiter = '\\';    }    else {      $directories[] = '/tmp';      $path_delimiter = '/';    }    foreach ($directories as $directory) {      if (!$temporary_directory && is_dir($directory)) {        $temporary_directory = $directory;      }    }    // if a directory has been found, use it, otherwise default to 'files/tmp' or 'files\\tmp';    $temporary_directory = $temporary_directory ? $temporary_directory : file_directory_path() . $path_delimiter .'tmp';    variable_set('file_directory_temp', $temporary_directory);  }  return $temporary_directory;}/** * Determine the default 'files' directory. * * @return A string containing the path to Drupal's 'files' directory. */function file_directory_path() {  return variable_get('file_directory_path', conf_path() .'/files');}/** * Determine the maximum file upload size by querying the PHP settings. * * @return *   A file size limit in bytes based on the PHP upload_max_filesize and post_max_size */function file_upload_max_size() {  static $max_size = -1;  if ($max_size < 0) {    $upload_max = parse_size(ini_get('upload_max_filesize'));    $post_max = parse_size(ini_get('post_max_size'));    $max_size = ($upload_max < $post_max) ? $upload_max : $post_max;  }  return $max_size;}/** * Determine an Internet Media Type, or MIME type from a filename. * * @param $filename *   Name of the file, including extension. * @param $mapping *   An optional array of extension to media type mappings in the form *   'extension1|extension2|...' => 'type'. * * @return *   The internet media type registered for the extension or application/octet-stream for unknown extensions. */function file_get_mimetype($filename, $mapping = NULL) {  if (!is_array($mapping)) {    $mapping = variable_get('mime_extension_mapping', array(      'ez' => 'application/andrew-inset',      'atom' => 'application/atom',      'atomcat' => 'application/atomcat+xml',      'atomsrv' => 'application/atomserv+xml',      'cap|pcap' => 'application/cap',      'cu' => 'application/cu-seeme',      'tsp' => 'application/dsptype',      'spl' => 'application/x-futuresplash',      'hta' => 'application/hta',      'jar' => 'application/java-archive',      'ser' => 'application/java-serialized-object',      'class' => 'application/java-vm',      'hqx' => 'application/mac-binhex40',      'cpt' => 'image/x-corelphotopaint',      'nb' => 'application/mathematica',      'mdb' => 'application/msaccess',      'doc|dot' => 'application/msword',      'bin' => 'application/octet-stream',      'oda' => 'application/oda',      'ogg|ogx' => 'application/ogg',      'pdf' => 'application/pdf',      'key' => 'application/pgp-keys',      'pgp' => 'application/pgp-signature',      'prf' => 'application/pics-rules',      'ps|ai|eps' => 'application/postscript',      'rar' => 'application/rar',      'rdf' => 'application/rdf+xml',      'rss' => 'application/rss+xml',      'rtf' => 'application/rtf',      'smi|smil' => 'application/smil',      'wpd' => 'application/wordperfect',      'wp5' => 'application/wordperfect5.1',      'xhtml|xht' => 'application/xhtml+xml',      'xml|xsl' => 'application/xml',      'zip' => 'application/zip',      'cdy' => 'application/vnd.cinderella',      'kml' => 'application/vnd.google-earth.kml+xml',      'kmz' => 'application/vnd.google-earth.kmz',      'xul' => 'application/vnd.mozilla.xul+xml',      'xls|xlb|xlt' => 'application/vnd.ms-excel',      'cat' => 'application/vnd.ms-pki.seccat',      'stl' => 'application/vnd.ms-pki.stl',      'ppt|pps' => 'application/vnd.ms-powerpoint',      'odc' => 'application/vnd.oasis.opendocument.chart',      'odb' => 'application/vnd.oasis.opendocument.database',      'odf' => 'application/vnd.oasis.opendocument.formula',      'odg' => 'application/vnd.oasis.opendocument.graphics',      'otg' => 'application/vnd.oasis.opendocument.graphics-template',      'odi' => 'application/vnd.oasis.opendocument.image',      'odp' => 'application/vnd.oasis.opendocument.presentation',      'otp' => 'application/vnd.oasis.opendocument.presentation-template',      'ods' => 'application/vnd.oasis.opendocument.spreadsheet',      'ots' => 'application/vnd.oasis.opendocument.spreadsheet-template',      'odt' => 'application/vnd.oasis.opendocument.text',      'odm' => 'application/vnd.oasis.opendocument.text-master',      'ott' => 'application/vnd.oasis.opendocument.text-template',      'oth' => 'application/vnd.oasis.opendocument.text-web',      'docm' => 'application/vnd.ms-word.document.macroEnabled.12',      'docx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',      'dotm' => 'application/vnd.ms-word.template.macroEnabled.12',      'dotx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',      'potm' => 'application/vnd.ms-powerpoint.template.macroEnabled.12',      'potx' => 'application/vnd.openxmlformats-officedocument.presentationml.template',      'ppam' => 'application/vnd.ms-powerpoint.addin.macroEnabled.12',      'ppsm' => 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',      'ppsx' => 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',      'pptm' => 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',      'pptx' => 'application/vnd.openxmlformats-officedocument.presentationml.presentation',      'xlam' => 'application/vnd.ms-excel.addin.macroEnabled.12',      'xlsb' => 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',      'xlsm' => 'application/vnd.ms-excel.sheet.macroEnabled.12',      'xlsx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',      'xltm' => 'application/vnd.ms-excel.template.macroEnabled.12',      'xltx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',      'cod' => 'application/vnd.rim.cod',      'mmf' => 'application/vnd.smaf',      'sdc' => 'application/vnd.stardivision.calc',      'sds' => 'application/vnd.stardivision.chart',      'sda' => 'application/vnd.stardivision.draw',      'sdd' => 'application/vnd.stardivision.impress',      'sdf' => 'application/vnd.stardivision.math',      'sdw' => 'application/vnd.stardivision.writer',      'sgl' => 'application/vnd.stardivision.writer-global',      'sxc' => 'application/vnd.sun.xml.calc',      'stc' => 'application/vnd.sun.xml.calc.template',      'sxd' => 'application/vnd.sun.xml.draw',      'std' => 'application/vnd.sun.xml.draw.template',      'sxi' => 'application/vnd.sun.xml.impress',      'sti' => 'application/vnd.sun.xml.impress.template',      'sxm' => 'application/vnd.sun.xml.math',      'sxw' => 'application/vnd.sun.xml.writer',      'sxg' => 'application/vnd.sun.xml.writer.global',      'stw' => 'application/vnd.sun.xml.writer.template',      'sis' => 'application/vnd.symbian.install',      'vsd' => 'application/vnd.visio',      'wbxml' => 'application/vnd.wap.wbxml',      'wmlc' => 'application/vnd.wap.wmlc',      'wmlsc' => 'application/vnd.wap.wmlscriptc',      'wk' => 'application/x-123',      '7z' => 'application/x-7z-compressed',      'abw' => 'application/x-abiword',      'dmg' => 'application/x-apple-diskimage',      'bcpio' => 'application/x-bcpio',      'torrent' => 'application/x-bittorrent',      'cab' => 'application/x-cab',      'cbr' => 'application/x-cbr',      'cbz' => 'application/x-cbz',      'cdf' => 'application/x-cdf',      'vcd' => 'application/x-cdlink',      'pgn' => 'application/x-chess-pgn',      'cpio' => 'application/x-cpio',      'csh' => 'text/x-csh',      'deb|udeb' => 'application/x-debian-package',      'dcr|dir|dxr' => 'application/x-director',      'dms' => 'application/x-dms',      'wad' => 'application/x-doom',      'dvi' => 'application/x-dvi',      'rhtml' => 'application/x-httpd-eruby',      'flac' => 'application/x-flac',      'pfa|pfb|gsf|pcf|pcf.Z' => 'application/x-font',      'mm' => 'application/x-freemind',      'gnumeric' => 'application/x-gnumeric',      'sgf' => 'application/x-go-sgf',      'gcf' => 'application/x-graphing-calculator',      'gtar|tgz|taz' => 'application/x-gtar',      'hdf' => 'application/x-hdf',      'phtml|pht|php' => 'application/x-httpd-php',      'phps' => 'application/x-httpd-php-source',      'php3' => 'application/x-httpd-php3',      'php3p' => 'application/x-httpd-php3-preprocessed',      'php4' => 'application/x-httpd-php4',      'ica' => 'application/x-ica',      'ins|isp' => 'application/x-internet-signup',      'iii' => 'application/x-iphone',      'iso' => 'application/x-iso9660-image',      'jnlp' => 'application/x-java-jnlp-file',      'js' => 'application/x-javascript',      'jmz' => 'application/x-jmol',      'chrt' => 'application/x-kchart',      'kil' => 'application/x-killustrator',      'skp|skd|skt|skm' => 'application/x-koan',      'kpr|kpt' => 'application/x-kpresenter',      'ksp' => 'application/x-kspread',      'kwd|kwt' => 'application/x-kword',      'latex' => 'application/x-latex',      'lha' => 'application/x-lha',      'lyx' => 'application/x-lyx',      'lzh' => 'application/x-lzh',      'lzx' => 'application/x-lzx',      'frm|maker|frame|fm|fb|book|fbdoc' => 'application/x-maker',      'mif' => 'application/x-mif',      'wmd' => 'application/x-ms-wmd',      'wmz' => 'application/x-ms-wmz',      'com|exe|bat|dll' => 'application/x-msdos-program',      'msi' => 'application/x-msi',      'nc' => 'application/x-netcdf',      'pac' => 'application/x-ns-proxy-autoconfig',      'nwc' => 'application/x-nwc',      'o' => 'application/x-object',      'oza' => 'application/x-oz-application',      'p7r' => 'application/x-pkcs7-certreqresp',      'crl' => 'application/x-pkcs7-crl',      'pyc|pyo' => 'application/x-python-code',      'qtl' => 'application/x-quicktimeplayer',      'rpm' => 'application/x-redhat-package-manager',      'sh' => 'text/x-sh',      'shar' => 'application/x-shar',      'swf|swfl' => 'application/x-shockwave-flash',      'sit|sitx' => 'application/x-stuffit',      'sv4cpio' => 'application/x-sv4cpio',      'sv4crc' => 'application/x-sv4crc',      'tar' => 'application/x-tar',      'tcl' => 'application/x-tcl',      'gf' => 'application/x-tex-gf',      'pk' => 'application/x-tex-pk',      'texinfo|texi' => 'application/x-texinfo',      '~|%|bak|old|sik' => 'application/x-trash',      't|tr|roff' => 'application/x-troff',      'man' => 'application/x-troff-man',      'me' => 'application/x-troff-me',      'ms' => 'application/x-troff-ms',      'ustar' => 'application/x-ustar',      'src' => 'application/x-wais-source',      'wz' => 'application/x-wingz',      'crt' => 'application/x-x509-ca-cert',      'xcf' => 'application/x-xcf',      'fig' => 'application/x-xfig',      'xpi' => 'application/x-xpinstall',      'au|snd' => 'audio/basic',      'mid|midi|kar' => 'audio/midi',      'mpga|mpega|mp2|mp3|m4a' => 'audio/mpeg',      'f4a|f4b' => 'audio/mp4',      'm3u' => 'audio/x-mpegurl',      'oga|spx' => 'audio/ogg',      'sid' => 'audio/prs.sid',      'aif|aiff|aifc' => 'audio/x-aiff',      'gsm' => 'audio/x-gsm',      'wma' => 'audio/x-ms-wma',      'wax' => 'audio/x-ms-wax',      'ra|rm|ram' => 'audio/x-pn-realaudio',      'ra' => 'audio/x-realaudio',      'pls' => 'audio/x-scpls',      'sd2' => 'audio/x-sd2',      'wav' => 'audio/x-wav',      'alc' => 'chemical/x-alchemy',      'cac|cache' => 'chemical/x-cache',      'csf' => 'chemical/x-cache-csf',      'cbin|cascii|ctab' => 'chemical/x-cactvs-binary',      'cdx' => 'chemical/x-cdx',      'cer' => 'chemical/x-cerius',      'c3d' => 'chemical/x-chem3d',      'chm' => 'chemical/x-chemdraw',      'cif' => 'chemical/x-cif',      'cmdf' => 'chemical/x-cmdf',      'cml' => 'chemical/x-cml',      'cpa' => 'chemical/x-compass',      'bsd' => 'chemical/x-crossfire',      'csml|csm' => 'chemical/x-csml',      'ctx' => 'chemical/x-ctx',      'cxf|cef' => 'chemical/x-cxf',      'emb|embl' => 'chemical/x-embl-dl-nucleotide',      'spc' => 'chemical/x-galactic-spc',      'inp|gam|gamin' => 'chemical/x-gamess-input',      'fch|fchk' => 'chemical/x-gaussian-checkpoint',      'cub' => 'chemical/x-gaussian-cube',      'gau|gjc|gjf' => 'chemical/x-gaussian-input',      'gal' => 'chemical/x-gaussian-log',      'gcg' => 'chemical/x-gcg8-sequence',      'gen' => 'chemical/x-genbank',      'hin' => 'chemical/x-hin',      'istr|ist' => 'chemical/x-isostar',      'jdx|dx' => 'chemical/x-jcamp-dx',      'kin' => 'chemical/x-kinemage',      'mcm' => 'chemical/x-macmolecule',      'mmd|mmod' => 'chemical/x-macromodel-input',      'mol' => 'chemical/x-mdl-molfile',      'rd' => 'chemical/x-mdl-rdfile',      'rxn' => 'chemical/x-mdl-rxnfile',      'sd|sdf' => 'chemical/x-mdl-sdfile',      'tgf' => 'chemical/x-mdl-tgf',      'mcif' => 'chemical/x-mmcif',      'mol2' => 'chemical/x-mol2',      'b' => 'chemical/x-molconn-Z',      'gpt' => 'chemical/x-mopac-graph',      'mop|mopcrt|mpc|dat|zmt' => 'chemical/x-mopac-input',      'moo' => 'chemical/x-mopac-out',      'mvb' => 'chemical/x-mopac-vib',      'asn' => 'chemical/x-ncbi-asn1-spec',      'prt|ent' => 'chemical/x-ncbi-asn1-ascii',      'val|aso' => 'chemical/x-ncbi-asn1-binary',      'pdb|ent' => 'chemical/x-pdb',      'ros' => 'chemical/x-rosdal',      'sw' => 'chemical/x-swissprot',      'vms' => 'chemical/x-vamas-iso14976',      'vmd' => 'chemical/x-vmd',      'xtel' => 'chemical/x-xtel',      'xyz' => 'chemical/x-xyz',      'gif' => 'image/gif',      'ief' => 'image/ief',      'jpeg|jpg|jpe' => 'image/jpeg',      'pcx' => 'image/pcx',      'png' => 'image/png',      'svg|svgz' => 'image/svg+xml',      'tiff|tif' => 'image/tiff',      'djvu|djv' => 'image/vnd.djvu',      'wbmp' => 'image/vnd.wap.wbmp',      'ras' => 'image/x-cmu-raster',      'cdr' => 'image/x-coreldraw',      'pat' => 'image/x-coreldrawpattern',      'cdt' => 'image/x-coreldrawtemplate',      'ico' => 'image/x-icon',      'art' => 'image/x-jg',      'jng' => 'image/x-jng',      'bmp' => 'image/x-ms-bmp',      'psd' => 'image/x-photoshop',      'pnm' => 'image/x-portable-anymap',      'pbm' => 'image/x-portable-bitmap',      'pgm' => 'image/x-portable-graymap',      'ppm' => 'image/x-portable-pixmap',      'rgb' => 'image/x-rgb',      'xbm' => 'image/x-xbitmap',      'xpm' => 'image/x-xpixmap',      'xwd' => 'image/x-xwindowdump',      'eml' => 'message/rfc822',      'igs|iges' => 'model/iges',      'msh|mesh|silo' => 'model/mesh',      'wrl|vrml' => 'model/vrml',      'ics|icz' => 'text/calendar',      'css' => 'text/css',      'csv' => 'text/csv',      '323' => 'text/h323',      'html|htm|shtml' => 'text/html',      'uls' => 'text/iuls',      'mml' => 'text/mathml',      'asc|txt|text|pot' => 'text/plain',      'rtx' => 'text/richtext',      'sct|wsc' => 'text/scriptlet',      'tm|ts' => 'text/texmacs',      'tsv' => 'text/tab-separated-values',      'jad' => 'text/vnd.sun.j2me.app-descriptor',      'wml' => 'text/vnd.wap.wml',      'wmls' => 'text/vnd.wap.wmlscript',      'bib' => 'text/x-bibtex',      'boo' => 'text/x-boo',      'h++|hpp|hxx|hh' => 'text/x-c++hdr',      'c++|cpp|cxx|cc' => 'text/x-c++src',      'h' => 'text/x-chdr',      'htc' => 'text/x-component',      'c' => 'text/x-csrc',      'd' => 'text/x-dsrc',      'diff|patch' => 'text/x-diff',      'hs' => 'text/x-haskell',      'java' => 'text/x-java',      'lhs' => 'text/x-literate-haskell',      'moc' => 'text/x-moc',      'p|pas' => 'text/x-pascal',      'gcd' => 'text/x-pcs-gcd',      'pl|pm' => 'text/x-perl',      'py' => 'text/x-python',      'etx' => 'text/x-setext',      'tcl|tk' => 'text/x-tcl',      'tex|ltx|sty|cls' => 'text/x-tex',      'vcs' => 'text/x-vcalendar',      'vcf' => 'text/x-vcard',      '3gp' => 'video/3gpp',      'dl' => 'video/dl',      'dif|dv' => 'video/dv',      'fli' => 'video/fli',      'gl' => 'video/gl',      'mpeg|mpg|mpe' => 'video/mpeg',      'mp4|f4v|f4p' => 'video/mp4',      'flv' => 'video/x-flv',      'ogv' => 'video/ogg',      'qt|mov' => 'video/quicktime',      'mxu' => 'video/vnd.mpegurl',      'lsf|lsx' => 'video/x-la-asf',      'mng' => 'video/x-mng',      'asf|asx' => 'video/x-ms-asf',      'wm' => 'video/x-ms-wm',      'wmv' => 'video/x-ms-wmv',      'wmx' => 'video/x-ms-wmx',      'wvx' => 'video/x-ms-wvx',      'avi' => 'video/x-msvideo',      'movie' => 'video/x-sgi-movie',      'ice' => 'x-conference/x-cooltalk',      'sisx' => 'x-epoc/x-sisx-app',      'vrm|vrml|wrl' => 'x-world/x-vrml',      'xps' => 'application/vnd.ms-xpsdocument',    ));  }  foreach ($mapping as $ext_preg => $mime_match) {    if (preg_match('!\.('. $ext_preg .')$!i', $filename)) {      return $mime_match;    }  }  return 'application/octet-stream';}/** * @} End of "defgroup file". */
<?php// $Id$/** * @file * Code required only when fetching information about available updates. *//** * Callback to manually check the update status without cron. */function update_manual_status() {  if (_update_refresh()) {    drupal_set_message(t('Attempted to fetch information about all available new releases and updates.'));  }  else {    drupal_set_message(t('Unable to fetch any information about available new releases and updates.'), 'error');  }  drupal_goto('admin/reports/updates');}/** * Fetch project info via XML from a central server. */function _update_refresh() {  static $fail = array();  global $base_url;  module_load_include('inc', 'update', 'update.compare');  // Since we're fetching new available update data, we want to clear  // our cache of both the projects we care about, and the current update  // status of the site. We do *not* want to clear the cache of available  // releases just yet, since that data (even if it's stale) can be useful  // during update_get_projects(); for example, to modules that implement  // hook_system_info_alter() such as cvs_deploy.  _update_cache_clear('update_project_projects');  _update_cache_clear('update_project_data');  $available = array();  $data = array();  $site_key = md5($base_url . drupal_get_private_key());  $projects = update_get_projects();  // Now that we have the list of projects, we should also clear our cache of  // available release data, since even if we fail to fetch new data, we need  // to clear out the stale data at this point.  _update_cache_clear('update_available_releases');  $max_fetch_attempts = variable_get('update_max_fetch_attempts', UPDATE_MAX_FETCH_ATTEMPTS);    foreach ($projects as $key => $project) {    $url = _update_build_fetch_url($project, $site_key);    $fetch_url_base = _update_get_fetch_url_base($project);    if (empty($fail[$fetch_url_base]) || count($fail[$fetch_url_base]) < $max_fetch_attempts) {      $xml = drupal_http_request($url);      if (isset($xml->data)) {        $data[] = $xml->data;      }      else {        // Connection likely broken; prepare to give up.        $fail[$fetch_url_base][$key] = 1;      }    }    else {      // Didn't bother trying to fetch.      $fail[$fetch_url_base][$key] = 1;    }  }  if ($data) {    $parser = new update_xml_parser;    $available = $parser->parse($data);  }  if (!empty($available) && is_array($available)) {    // Record the projects where we failed to fetch data.    foreach ($fail as $fetch_url_base => $failures) {      foreach ($failures as $key => $value) {        $available[$key]['project_status'] = 'not-fetched';      }    }    $frequency = variable_get('update_check_frequency', 1);    _update_cache_set('update_available_releases', $available, time() + (60 * 60 * 24 * $frequency));    watchdog('update', 'Attempted to fetch information about all available new releases and updates.', array(), WATCHDOG_NOTICE, l(t('view'), 'admin/reports/updates'));  }  else {    watchdog('update', 'Unable to fetch any information about available new releases and updates.', array(), WATCHDOG_ERROR, l(t('view'), 'admin/reports/updates'));  }  // Whether this worked or not, we did just (try to) check for updates.  variable_set('update_last_check', time());  return $available;}/** * Generates the URL to fetch information about project updates. * * This figures out the right URL to use, based on the project's .info file * and the global defaults. Appends optional query arguments when the site is * configured to report usage stats. * * @param $project *   The array of project information from update_get_projects(). * @param $site_key *   The anonymous site key hash (optional). * * @see update_refresh() * @see update_get_projects() */function _update_build_fetch_url($project, $site_key = '') {  $name = $project['name'];  $url = _update_get_fetch_url_base($project);  $url .= '/'. $name .'/'. DRUPAL_CORE_COMPATIBILITY;  // Only append a site_key and the version information if we have a site_key  // in the first place, and if this is not a disabled module or theme. We do  // not want to record usage statistics for disabled code.  if (!empty($site_key) && (strpos($project['project_type'], 'disabled') === FALSE)) {    $url .= (strpos($url, '?') === TRUE) ? '&' : '?';    $url .= 'site_key=';    $url .= rawurlencode($site_key);    if (!empty($project['info']['version'])) {      $url .= '&version=';      $url .= rawurlencode($project['info']['version']);    }  }  return $url;}/** * Return the base of the URL to fetch available update data for a project. * * @param $project *   The array of project information from update_get_projects(). * @return *   The base of the URL used for fetching available update data. This does *   not include the path elements to specify a particular project, version, *   site_key, etc. * * @see _update_build_fetch_url() */function _update_get_fetch_url_base($project) {  return isset($project['info']['project status url']) ? $project['info']['project status url'] : variable_get('update_fetch_url', UPDATE_DEFAULT_URL);}/** * Perform any notifications that should be done once cron fetches new data. * * This method checks the status of the site using the new data and depending * on the configuration of the site, notifies administrators via email if there * are new releases or missing security updates. * * @see update_requirements() */function _update_cron_notify() {  include_once './includes/install.inc';  $status = update_requirements('runtime');  $params = array();  $notify_all = (variable_get('update_notification_threshold', 'all') == 'all');  foreach (array('core', 'contrib') as $report_type) {    $type = 'update_'. $report_type;    if (isset($status[$type]['severity'])        && ($status[$type]['severity'] == REQUIREMENT_ERROR || ($notify_all && $status[$type]['reason'] == UPDATE_NOT_CURRENT))) {      $params[$report_type] = $status[$type]['reason'];    }  }  if (!empty($params)) {    $notify_list = variable_get('update_notify_emails', '');    if (!empty($notify_list)) {      $default_language = language_default();      foreach ($notify_list as $target) {        if ($target_user = user_load(array('mail' => $target))) {          $target_language = user_preferred_language($target_user);        }        else {          $target_language = $default_language;        }        drupal_mail('update', 'status_notify', $target, $target_language, $params);      }    }  }}/** * XML Parser object to read Drupal's release history info files. * This uses PHP4's lame XML parsing, but it works. */class update_xml_parser {  var $projects = array();  var $current_project;  var $current_release;  var $current_term;  var $current_tag;  var $current_object;  /**   * Parse an array of XML data files.   */  function parse($data) {    foreach ($data as $datum) {      $parser = xml_parser_create();      xml_set_object($parser, $this);      xml_set_element_handler($parser, 'start', 'end');      xml_set_character_data_handler($parser, "data");      xml_parse($parser, $datum);      xml_parser_free($parser);    }    return $this->projects;  }  function start($parser, $name, $attr) {    $this->current_tag = $name;    switch ($name) {      case 'PROJECT':        unset($this->current_object);        $this->current_project = array();        $this->current_object = &$this->current_project;        break;      case 'RELEASE':        unset($this->current_object);        $this->current_release = array();        $this->current_object = &$this->current_release;        break;      case 'TERM':        unset($this->current_object);        $this->current_term = array();        $this->current_object = &$this->current_term;        break;    }  }  function end($parser, $name) {    switch ($name) {      case 'PROJECT':        unset($this->current_object);        $this->projects[$this->current_project['short_name']] = $this->current_project;        $this->current_project = array();        break;      case 'RELEASE':        unset($this->current_object);        $this->current_project['releases'][$this->current_release['version']] = $this->current_release;        break;      case 'RELEASES':        $this->current_object = &$this->current_project;        break;      case 'TERM':        unset($this->current_object);        $term_name = $this->current_term['name'];        if (!isset($this->current_release['terms'])) {          $this->current_release['terms'] = array();        }        if (!isset($this->current_release['terms'][$term_name])) {          $this->current_release['terms'][$term_name] = array();        }        $this->current_release['terms'][$term_name][] = $this->current_term['value'];        break;      case 'TERMS':        $this->current_object = &$this->current_release;        break;      default:        $this->current_object[strtolower($this->current_tag)] = trim($this->current_object[strtolower($this->current_tag)]);        $this->current_tag = '';    }  }  function data($parser, $data) {    if ($this->current_tag && !in_array($this->current_tag, array('PROJECT', 'RELEASE', 'RELEASES', 'TERM', 'TERMS'))) {      $tag = strtolower($this->current_tag);      if (isset($this->current_object[$tag])) {        $this->current_object[$tag] .= $data;      }      else {        $this->current_object[$tag] = $data;      }    }  }}
