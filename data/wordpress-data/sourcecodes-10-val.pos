<?php/** * Redirects to the RSS feed * This file is deprecated and only exists for backwards compatibility * * @package WordPress */require( './wp-load.php' );wp_redirect( get_bloginfo( 'rss_url' ), 301 );?>
<?php/** * Parse OPML XML files and store in globals. * * @package WordPress * @subpackage Administration */if ( ! defined('ABSPATH') )	die();global $opml, $map;// columns we wish to find are:  link_url, link_name, link_target, link_description// we need to map XML attribute names to our columns$opml_map = array('URL'         => 'link_url',	'HTMLURL'     => 'link_url',	'TEXT'        => 'link_name',	'TITLE'       => 'link_name',	'TARGET'      => 'link_target',	'DESCRIPTION' => 'link_description',	'XMLURL'      => 'link_rss');$map = $opml_map;/** * XML callback function for the start of a new XML tag. * * @since unknown * @access private * * @uses $updated_timestamp Not used inside function. * @uses $all_links Not used inside function. * @uses $map Stores names of attributes to use. * @global array $names * @global array $urls * @global array $targets * @global array $descriptions * @global array $feeds * * @param mixed $parser XML Parser resource. * @param string $tagName XML element name. * @param array $attrs XML element attributes. */function startElement($parser, $tagName, $attrs) {	global $updated_timestamp, $all_links, $map;	global $names, $urls, $targets, $descriptions, $feeds;	if ($tagName == 'OUTLINE') {		foreach (array_keys($map) as $key) {			if (isset($attrs[$key])) {				$$map[$key] = $attrs[$key];			}		}		//echo("got data: link_url = [$link_url], link_name = [$link_name], link_target = [$link_target], link_description = [$link_description]<br />\n");		// save the data away.		$names[] = $link_name;		$urls[] = $link_url;		$targets[] = $link_target;		$feeds[] = $link_rss;		$descriptions[] = $link_description;	} // end if outline}/** * XML callback function that is called at the end of a XML tag. * * @since unknown * @access private * @package WordPress * @subpackage Dummy * * @param mixed $parser XML Parser resource. * @param string $tagName XML tag name. */function endElement($parser, $tagName) {	// nothing to do.}// Create an XML parser$xml_parser = xml_parser_create();// Set the functions to handle opening and closing tagsxml_set_element_handler($xml_parser, "startElement", "endElement");if (!xml_parse($xml_parser, $opml, true)) {	echo(sprintf(__('XML error: %1$s at line %2$s'),	xml_error_string(xml_get_error_code($xml_parser)),	xml_get_current_line_number($xml_parser)));}// Free up memory used by the XML parserxml_parser_free($xml_parser);?>
<?php/** * Portable PHP password hashing framework. * @package phpass * @since 2.5 * @version 0.2 / genuine. * @link http://www.openwall.com/phpass/ */## Written by Solar Designer <solar at openwall.com> in 2004-2006 and placed in# the public domain.## There's absolutely no warranty.## Please be sure to update the Version line if you edit this file in any way.# It is suggested that you leave the main version number intact, but indicate# your project name (after the slash) and add your own revision information.## Please do not change the "private" password hashing method implemented in# here, thereby making your hashes incompatible.  However, if you must, please# change the hash type identifier (the "$P$") to something different.## Obviously, since this code is in the public domain, the above are not# requirements (there can be none), but merely suggestions.#/** * Portable PHP password hashing framework. * * @package phpass * @version 0.2 / genuine. * @link http://www.openwall.com/phpass/ * @since 2.5 */class PasswordHash {	var $itoa64;	var $iteration_count_log2;	var $portable_hashes;	var $random_state;	function PasswordHash($iteration_count_log2, $portable_hashes)	{		$this->itoa64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';		if ($iteration_count_log2 < 4 || $iteration_count_log2 > 31)			$iteration_count_log2 = 8;		$this->iteration_count_log2 = $iteration_count_log2;		$this->portable_hashes = $portable_hashes;		$this->random_state = microtime() . uniqid(rand(), TRUE); // removed getmypid() for compability reasons	}	function get_random_bytes($count)	{		$output = '';		if ( @is_readable('/dev/urandom') &&		    ($fh = @fopen('/dev/urandom', 'rb'))) {			$output = fread($fh, $count);			fclose($fh);		}		if (strlen($output) < $count) {			$output = '';			for ($i = 0; $i < $count; $i += 16) {				$this->random_state =				    md5(microtime() . $this->random_state);				$output .=				    pack('H*', md5($this->random_state));			}			$output = substr($output, 0, $count);		}		return $output;	}	function encode64($input, $count)	{		$output = '';		$i = 0;		do {			$value = ord($input[$i++]);			$output .= $this->itoa64[$value & 0x3f];			if ($i < $count)				$value |= ord($input[$i]) << 8;			$output .= $this->itoa64[($value >> 6) & 0x3f];			if ($i++ >= $count)				break;			if ($i < $count)				$value |= ord($input[$i]) << 16;			$output .= $this->itoa64[($value >> 12) & 0x3f];			if ($i++ >= $count)				break;			$output .= $this->itoa64[($value >> 18) & 0x3f];		} while ($i < $count);		return $output;	}	function gensalt_private($input)	{		$output = '$P$';		$output .= $this->itoa64[min($this->iteration_count_log2 +			((PHP_VERSION >= '5') ? 5 : 3), 30)];		$output .= $this->encode64($input, 6);		return $output;	}	function crypt_private($password, $setting)	{		$output = '*0';		if (substr($setting, 0, 2) == $output)			$output = '*1';		if (substr($setting, 0, 3) != '$P$')			return $output;		$count_log2 = strpos($this->itoa64, $setting[3]);		if ($count_log2 < 7 || $count_log2 > 30)			return $output;		$count = 1 << $count_log2;		$salt = substr($setting, 4, 8);		if (strlen($salt) != 8)			return $output;		# We're kind of forced to use MD5 here since it's the only		# cryptographic primitive available in all versions of PHP		# currently in use.  To implement our own low-level crypto		# in PHP would result in much worse performance and		# consequently in lower iteration counts and hashes that are		# quicker to crack (by non-PHP code).		if (PHP_VERSION >= '5') {			$hash = md5($salt . $password, TRUE);			do {				$hash = md5($hash . $password, TRUE);			} while (--$count);		} else {			$hash = pack('H*', md5($salt . $password));			do {				$hash = pack('H*', md5($hash . $password));			} while (--$count);		}		$output = substr($setting, 0, 12);		$output .= $this->encode64($hash, 16);		return $output;	}	function gensalt_extended($input)	{		$count_log2 = min($this->iteration_count_log2 + 8, 24);		# This should be odd to not reveal weak DES keys, and the		# maximum valid value is (2**24 - 1) which is odd anyway.		$count = (1 << $count_log2) - 1;		$output = '_';		$output .= $this->itoa64[$count & 0x3f];		$output .= $this->itoa64[($count >> 6) & 0x3f];		$output .= $this->itoa64[($count >> 12) & 0x3f];		$output .= $this->itoa64[($count >> 18) & 0x3f];		$output .= $this->encode64($input, 3);		return $output;	}	function gensalt_blowfish($input)	{		# This one needs to use a different order of characters and a		# different encoding scheme from the one in encode64() above.		# We care because the last character in our encoded string will		# only represent 2 bits.  While two known implementations of		# bcrypt will happily accept and correct a salt string which		# has the 4 unused bits set to non-zero, we do not want to take		# chances and we also do not want to waste an additional byte		# of entropy.		$itoa64 = './ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';		$output = '$2a$';		$output .= chr(ord('0') + $this->iteration_count_log2 / 10);		$output .= chr(ord('0') + $this->iteration_count_log2 % 10);		$output .= '$';		$i = 0;		do {			$c1 = ord($input[$i++]);			$output .= $itoa64[$c1 >> 2];			$c1 = ($c1 & 0x03) << 4;			if ($i >= 16) {				$output .= $itoa64[$c1];				break;			}			$c2 = ord($input[$i++]);			$c1 |= $c2 >> 4;			$output .= $itoa64[$c1];			$c1 = ($c2 & 0x0f) << 2;			$c2 = ord($input[$i++]);			$c1 |= $c2 >> 6;			$output .= $itoa64[$c1];			$output .= $itoa64[$c2 & 0x3f];		} while (1);		return $output;	}	function HashPassword($password)	{		$random = '';		if (CRYPT_BLOWFISH == 1 && !$this->portable_hashes) {			$random = $this->get_random_bytes(16);			$hash =			    crypt($password, $this->gensalt_blowfish($random));			if (strlen($hash) == 60)				return $hash;		}		if (CRYPT_EXT_DES == 1 && !$this->portable_hashes) {			if (strlen($random) < 3)				$random = $this->get_random_bytes(3);			$hash =			    crypt($password, $this->gensalt_extended($random));			if (strlen($hash) == 20)				return $hash;		}		if (strlen($random) < 6)			$random = $this->get_random_bytes(6);		$hash =		    $this->crypt_private($password,		    $this->gensalt_private($random));		if (strlen($hash) == 34)			return $hash;		# Returning '*' on error is safe here, but would _not_ be safe		# in a crypt(3)-like function used _both_ for generating new		# hashes and for validating passwords against existing hashes.		return '*';	}	function CheckPassword($password, $stored_hash)	{		$hash = $this->crypt_private($password, $stored_hash);		if ($hash[0] == '*')			$hash = crypt($password, $stored_hash);		return $hash == $stored_hash;	}}?>
<?php/** * WordPress Upgrade Functions. Old file, must not be used. Include * wp-admin/includes/upgrade.php instead. * * @deprecated 2.5 * @package WordPress * @subpackage Administration */_deprecated_file( basename(__FILE__), '2.5', 'wp-admin/includes/upgrade.php' );require_once(ABSPATH . 'wp-admin/includes/upgrade.php');?>
<?php/** * General API for generating and formatting diffs - the differences between * two sequences of strings. * * The original PHP version of this code was written by Geoffrey T. Dairiki * <dairiki@dairiki.org>, and is used/adapted with his permission. * * Copyright 2004 Geoffrey T. Dairiki <dairiki@dairiki.org> * Copyright 2004-2010 The Horde Project (http://www.horde.org/) * * See the enclosed file COPYING for license information (LGPL). If you did * not receive this file, see http://opensource.org/licenses/lgpl-license.php. * * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> */class Text_Diff {    /**     * Array of changes.     *     * @var array     */    var $_edits;    /**     * Computes diffs between sequences of strings.     *     * @param string $engine     Name of the diffing engine to use.  'auto'     *                           will automatically select the best.     * @param array $params      Parameters to pass to the diffing engine.     *                           Normally an array of two arrays, each     *                           containing the lines from a file.     */    function Text_Diff($engine, $params)    {        // Backward compatibility workaround.        if (!is_string($engine)) {            $params = array($engine, $params);            $engine = 'auto';        }        if ($engine == 'auto') {            $engine = extension_loaded('xdiff') ? 'xdiff' : 'native';        } else {            $engine = basename($engine);        }        // WP #7391        require_once dirname(__FILE__).'/Diff/Engine/' . $engine . '.php';        $class = 'Text_Diff_Engine_' . $engine;        $diff_engine = new $class();        $this->_edits = call_user_func_array(array($diff_engine, 'diff'), $params);    }    /**     * Returns the array of differences.     */    function getDiff()    {        return $this->_edits;    }    /**     * returns the number of new (added) lines in a given diff.     *     * @since Text_Diff 1.1.0     *     * @return integer The number of new lines     */    function countAddedLines()    {        $count = 0;        foreach ($this->_edits as $edit) {            if (is_a($edit, 'Text_Diff_Op_add') ||                is_a($edit, 'Text_Diff_Op_change')) {                $count += $edit->nfinal();            }        }        return $count;    }    /**     * Returns the number of deleted (removed) lines in a given diff.     *     * @since Text_Diff 1.1.0     *     * @return integer The number of deleted lines     */    function countDeletedLines()    {        $count = 0;        foreach ($this->_edits as $edit) {            if (is_a($edit, 'Text_Diff_Op_delete') ||                is_a($edit, 'Text_Diff_Op_change')) {                $count += $edit->norig();            }        }        return $count;    }    /**     * Computes a reversed diff.     *     * Example:     * <code>     * $diff = new Text_Diff($lines1, $lines2);     * $rev = $diff->reverse();     * </code>     *     * @return Text_Diff  A Diff object representing the inverse of the     *                    original diff.  Note that we purposely don't return a     *                    reference here, since this essentially is a clone()     *                    method.     */    function reverse()    {        if (version_compare(zend_version(), '2', '>')) {            $rev = clone($this);        } else {            $rev = $this;        }        $rev->_edits = array();        foreach ($this->_edits as $edit) {            $rev->_edits[] = $edit->reverse();        }        return $rev;    }    /**     * Checks for an empty diff.     *     * @return boolean  True if two sequences were identical.     */    function isEmpty()    {        foreach ($this->_edits as $edit) {            if (!is_a($edit, 'Text_Diff_Op_copy')) {                return false;            }        }        return true;    }    /**     * Computes the length of the Longest Common Subsequence (LCS).     *     * This is mostly for diagnostic purposes.     *     * @return integer  The length of the LCS.     */    function lcs()    {        $lcs = 0;        foreach ($this->_edits as $edit) {            if (is_a($edit, 'Text_Diff_Op_copy')) {                $lcs += count($edit->orig);            }        }        return $lcs;    }    /**     * Gets the original set of lines.     *     * This reconstructs the $from_lines parameter passed to the constructor.     *     * @return array  The original sequence of strings.     */    function getOriginal()    {        $lines = array();        foreach ($this->_edits as $edit) {            if ($edit->orig) {                array_splice($lines, count($lines), 0, $edit->orig);            }        }        return $lines;    }    /**     * Gets the final set of lines.     *     * This reconstructs the $to_lines parameter passed to the constructor.     *     * @return array  The sequence of strings.     */    function getFinal()    {        $lines = array();        foreach ($this->_edits as $edit) {            if ($edit->final) {                array_splice($lines, count($lines), 0, $edit->final);            }        }        return $lines;    }    /**     * Removes trailing newlines from a line of text. This is meant to be used     * with array_walk().     *     * @param string $line  The line to trim.     * @param integer $key  The index of the line in the array. Not used.     */    function trimNewlines(&$line, $key)    {        $line = str_replace(array("\n", "\r"), '', $line);    }    /**     * Determines the location of the system temporary directory.     *     * @static     *     * @access protected     *     * @return string  A directory name which can be used for temp files.     *                 Returns false if one could not be found.     */    function _getTempDir()    {        $tmp_locations = array('/tmp', '/var/tmp', 'c:\WUTemp', 'c:\temp',                               'c:\windows\temp', 'c:\winnt\temp');        /* Try PHP's upload_tmp_dir directive. */        $tmp = ini_get('upload_tmp_dir');        /* Otherwise, try to determine the TMPDIR environment variable. */        if (!strlen($tmp)) {            $tmp = getenv('TMPDIR');        }        /* If we still cannot determine a value, then cycle through a list of         * preset possibilities. */        while (!strlen($tmp) && count($tmp_locations)) {            $tmp_check = array_shift($tmp_locations);            if (@is_dir($tmp_check)) {                $tmp = $tmp_check;            }        }        /* If it is still empty, we have failed, so return false; otherwise         * return the directory determined. */        return strlen($tmp) ? $tmp : false;    }    /**     * Checks a diff for validity.     *     * This is here only for debugging purposes.     */    function _check($from_lines, $to_lines)    {        if (serialize($from_lines) != serialize($this->getOriginal())) {            trigger_error("Reconstructed original doesn't match", E_USER_ERROR);        }        if (serialize($to_lines) != serialize($this->getFinal())) {            trigger_error("Reconstructed final doesn't match", E_USER_ERROR);        }        $rev = $this->reverse();        if (serialize($to_lines) != serialize($rev->getOriginal())) {            trigger_error("Reversed original doesn't match", E_USER_ERROR);        }        if (serialize($from_lines) != serialize($rev->getFinal())) {            trigger_error("Reversed final doesn't match", E_USER_ERROR);        }        $prevtype = null;        foreach ($this->_edits as $edit) {            if ($prevtype == get_class($edit)) {                trigger_error("Edit sequence is non-optimal", E_USER_ERROR);            }            $prevtype = get_class($edit);        }        return true;    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> */class Text_MappedDiff extends Text_Diff {    /**     * Computes a diff between sequences of strings.     *     * This can be used to compute things like case-insensitve diffs, or diffs     * which ignore changes in white-space.     *     * @param array $from_lines         An array of strings.     * @param array $to_lines           An array of strings.     * @param array $mapped_from_lines  This array should have the same size     *                                  number of elements as $from_lines.  The     *                                  elements in $mapped_from_lines and     *                                  $mapped_to_lines are what is actually     *                                  compared when computing the diff.     * @param array $mapped_to_lines    This array should have the same number     *                                  of elements as $to_lines.     */    function Text_MappedDiff($from_lines, $to_lines,                             $mapped_from_lines, $mapped_to_lines)    {        assert(count($from_lines) == count($mapped_from_lines));        assert(count($to_lines) == count($mapped_to_lines));        parent::Text_Diff($mapped_from_lines, $mapped_to_lines);        $xi = $yi = 0;        for ($i = 0; $i < count($this->_edits); $i++) {            $orig = &$this->_edits[$i]->orig;            if (is_array($orig)) {                $orig = array_slice($from_lines, $xi, count($orig));                $xi += count($orig);            }            $final = &$this->_edits[$i]->final;            if (is_array($final)) {                $final = array_slice($to_lines, $yi, count($final));                $yi += count($final);            }        }    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * * @access private */class Text_Diff_Op {    var $orig;    var $final;    function &reverse()    {        trigger_error('Abstract method', E_USER_ERROR);    }    function norig()    {        return $this->orig ? count($this->orig) : 0;    }    function nfinal()    {        return $this->final ? count($this->final) : 0;    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * * @access private */class Text_Diff_Op_copy extends Text_Diff_Op {    function Text_Diff_Op_copy($orig, $final = false)    {        if (!is_array($final)) {            $final = $orig;        }        $this->orig = $orig;        $this->final = $final;    }    function &reverse()    {        $reverse = &new Text_Diff_Op_copy($this->final, $this->orig);        return $reverse;    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * * @access private */class Text_Diff_Op_delete extends Text_Diff_Op {    function Text_Diff_Op_delete($lines)    {        $this->orig = $lines;        $this->final = false;    }    function &reverse()    {        $reverse = &new Text_Diff_Op_add($this->orig);        return $reverse;    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * * @access private */class Text_Diff_Op_add extends Text_Diff_Op {    function Text_Diff_Op_add($lines)    {        $this->final = $lines;        $this->orig = false;    }    function &reverse()    {        $reverse = &new Text_Diff_Op_delete($this->final);        return $reverse;    }}/** * @package Text_Diff * @author  Geoffrey T. Dairiki <dairiki@dairiki.org> * * @access private */class Text_Diff_Op_change extends Text_Diff_Op {    function Text_Diff_Op_change($orig, $final)    {        $this->orig = $orig;        $this->final = $final;    }    function &reverse()    {        $reverse = &new Text_Diff_Op_change($this->final, $this->orig);        return $reverse;    }}
<?php/** * Site/blog functions that work with the blogs table and related data. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */// @todo use update_blog_detailsfunction wpmu_update_blogs_date() {	global $wpdb;	$wpdb->update( $wpdb->blogs, array('last_updated' => current_time('mysql', true)), array('blog_id' => $wpdb->blogid) );	refresh_blog_details( $wpdb->blogid );	do_action( 'wpmu_blog_updated', $wpdb->blogid );}function get_blogaddress_by_id( $blog_id ) {	$bloginfo = get_blog_details( (int) $blog_id, false ); // only get bare details!	return esc_url( 'http://' . $bloginfo->domain . $bloginfo->path );}function get_blogaddress_by_name( $blogname ) {	global $current_site;	if ( is_subdomain_install() ) {		if ( $blogname == 'main' )			$blogname = 'www';		$url = rtrim( network_home_url(), '/' );		if ( !empty( $blogname ) )			$url = preg_replace( '|^([^\.]+://)|', '$1' . $blogname . '.', $url );	} else {		$url = network_home_url( $blogname );	}	return esc_url( $url . '/' );}function get_blogaddress_by_domain( $domain, $path ){	if ( is_subdomain_install() ) {		$url = "http://".$domain.$path;	} else {		if ( $domain != $_SERVER['HTTP_HOST'] ) {			$blogname = substr( $domain, 0, strpos( $domain, '.' ) );			$url = 'http://' . substr( $domain, strpos( $domain, '.' ) + 1 ) . $path;			// we're not installing the main blog			if ( $blogname != 'www.' )				$url .= $blogname . '/';		} else { // main blog			$url = 'http://' . $domain . $path;		}	}	return esc_url( $url );}function get_id_from_blogname( $name ) {	global $wpdb, $current_site;	$blog_id = wp_cache_get( "get_id_from_blogname_" . $name, 'blog-details' );	if ( $blog_id )		return $blog_id;	if ( is_subdomain_install() ) {		$domain = $name . '.' . $current_site->domain;		$path = $current_site->path;	} else {		$domain = $current_site->domain;		$path = $current_site->path . $name . '/';	}	$blog_id = $wpdb->get_var( $wpdb->prepare("SELECT blog_id FROM {$wpdb->blogs} WHERE domain = %s AND path = %s", $domain, $path) );	wp_cache_set( 'get_id_from_blogname_' . $name, $blog_id, 'blog-details' );	return $blog_id;}/** * Retrieve the details for a blog from the blogs table and blog options. * * @since 3.0.0 * @param int|string|array $fields A blog ID, a blog name, or an array of fields to query against. * @param bool $get_all Whether to retrieve all details or only the details in the blogs table. Default is true. * @return object Blog details. */function get_blog_details( $fields, $get_all = true ) {	global $wpdb;	if ( is_array($fields ) ) {		if ( isset($fields['blog_id']) ) {			$blog_id = $fields['blog_id'];		} elseif ( isset($fields['domain']) && isset($fields['path']) ) {			$key = md5( $fields['domain'] . $fields['path'] );			$blog = wp_cache_get($key, 'blog-lookup');			if ( false !== $blog )				return $blog;			if ( substr( $fields['domain'], 0, 4 ) == 'www.' ) {				$nowww = substr( $fields['domain'], 4 );				$blog = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->blogs WHERE domain IN (%s,%s) AND path = %s ORDER BY CHAR_LENGTH(domain) DESC", $nowww, $fields['domain'], $fields['path'] ) );			} else {				$blog = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->blogs WHERE domain = %s AND path = %s", $fields['domain'], $fields['path'] ) );			}			if ( $blog ) {				wp_cache_set($blog->blog_id . 'short', $blog, 'blog-details');				$blog_id = $blog->blog_id;			} else {				return false;			}		} elseif ( isset($fields['domain']) && is_subdomain_install() ) {			$key = md5( $fields['domain'] );			$blog = wp_cache_get($key, 'blog-lookup');			if ( false !== $blog )				return $blog;			if ( substr( $fields['domain'], 0, 4 ) == 'www.' ) {				$nowww = substr( $fields['domain'], 4 );				$blog = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->blogs WHERE domain IN (%s,%s) ORDER BY CHAR_LENGTH(domain) DESC", $nowww, $fields['domain'] ) );			} else {				$blog = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->blogs WHERE domain = %s", $fields['domain'] ) );			}			if ( $blog ) {				wp_cache_set($blog->blog_id . 'short', $blog, 'blog-details');				$blog_id = $blog->blog_id;			} else {				return false;			}		} else {			return false;		}	} else {		if ( !is_numeric( $fields ) )			$blog_id = get_id_from_blogname( $fields );		else			$blog_id = $fields;	}	$blog_id = (int) $blog_id;	$all = $get_all == true ? '' : 'short';	$details = wp_cache_get( $blog_id . $all, 'blog-details' );	if ( $details ) {		if ( ! is_object( $details ) ) {			if ( $details == -1 ) {				return false;			} else {				// Clear old pre-serialized objects. Cache clients do better with that.				wp_cache_delete( $blog_id . $all, 'blog-details' );				unset($details);			}		} else {			return $details;		}	}	// Try the other cache.	if ( $get_all ) {		$details = wp_cache_get( $blog_id . 'short', 'blog-details' );	} else {		$details = wp_cache_get( $blog_id, 'blog-details' );		// If short was requested and full cache is set, we can return.		if ( $details ) {			if ( ! is_object( $details ) ) {				if ( $details == -1 ) {					return false;				} else {					// Clear old pre-serialized objects. Cache clients do better with that.					wp_cache_delete( $blog_id, 'blog-details' );					unset($details);				}			} else {				return $details;			}		}	}	if ( empty($details) ) {		$details = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->blogs WHERE blog_id = %d /* get_blog_details */", $blog_id ) );		if ( ! $details ) {			// Set the full cache.			wp_cache_set( $blog_id, -1, 'blog-details' );			return false;		}	}	if ( ! $get_all ) {		wp_cache_set( $blog_id . $all, $details, 'blog-details' );		return $details;	}	$details->blogname		= get_blog_option( $blog_id, 'blogname' );	$details->siteurl		= get_blog_option( $blog_id, 'siteurl' );	$details->post_count	= get_blog_option( $blog_id, 'post_count' );	$details = apply_filters( 'blog_details', $details );	wp_cache_set( $blog_id . $all, $details, 'blog-details' );	$key = md5( $details->domain . $details->path );	wp_cache_set( $key, $details, 'blog-lookup' );	return $details;}/** * Clear the blog details cache. * * @since 3.0.0 * * @param int $blog_id Blog ID */function refresh_blog_details( $blog_id ) {	$blog_id = (int) $blog_id;	$details = get_blog_details( $blog_id, false );	wp_cache_delete( $blog_id , 'blog-details' );	wp_cache_delete( $blog_id . 'short' , 'blog-details' );	wp_cache_delete( md5( $details->domain . $details->path )  , 'blog-lookup' );	wp_cache_delete( 'current_blog_' . $details->domain, 'site-options' );	wp_cache_delete( 'current_blog_' . $details->domain . $details->path, 'site-options' );}/** * Update the details for a blog. Updates the blogs table for a given blog id. * * @since 3.0.0 * * @param int $blog_id Blog ID * @param array $details Array of details keyed by blogs table field names. * @return bool True if update succeeds, false otherwise. */function update_blog_details( $blog_id, $details = array() ) {	global $wpdb;	if ( empty($details) )		return false;	if ( is_object($details) )		$details = get_object_vars($details);	$current_details = get_blog_details($blog_id, false);	if ( empty($current_details) )		return false;	$current_details = get_object_vars($current_details);	$details = array_merge($current_details, $details);	$details['last_updated'] = current_time('mysql', true);	$update_details = array();	$fields = array( 'site_id', 'domain', 'path', 'registered', 'last_updated', 'public', 'archived', 'mature', 'spam', 'deleted', 'lang_id');	foreach ( array_intersect( array_keys( $details ), $fields ) as $field )		$update_details[$field] = $details[$field];	$wpdb->update( $wpdb->blogs, $update_details, array('blog_id' => $blog_id) );	// If spam status changed, issue actions.	if ( $details[ 'spam' ] != $current_details[ 'spam' ] ) {		if ( $details[ 'spam' ] == 1 )			do_action( "make_spam_blog", $blog_id );		else			do_action( "make_ham_blog", $blog_id );	}	if ( isset($details[ 'public' ]) )		update_blog_option( $blog_id, 'blog_public', $details[ 'public' ], false );	refresh_blog_details($blog_id);	return true;}/** * Retrieve option value based on setting name and blog_id. * * If the option does not exist or does not have a value, then the return value * will be false. This is useful to check whether you need to install an option * and is commonly used during installation of plugin options and to test * whether upgrading is required. * * There is a filter called 'blog_option_$option' with the $option being * replaced with the option name. The filter takes two parameters. $value and * $blog_id. It returns $value. * The 'option_$option' filter in get_option() is not called. * * @since NA * @package WordPress MU * @subpackage Option * @uses apply_filters() Calls 'blog_option_$optionname' with the option name value. * * @param int $blog_id is the id of the blog. * @param string $setting Name of option to retrieve. Should already be SQL-escaped * @param string $default (optional) Default value returned if option not found. * @return mixed Value set for the option. */function get_blog_option( $blog_id, $setting, $default = false ) {	global $wpdb;	$key = $blog_id."-".$setting."-blog_option";	$value = wp_cache_get( $key, "site-options" );	if ( $value == null ) {		if ( $blog_id == $wpdb->blogid ) {			$value = get_option( $setting, $default );			$notoptions = wp_cache_get( 'notoptions', 'options' );			if ( isset( $notoptions[$setting] ) ) {				wp_cache_set( $key, 'noop', 'site-options' );				$value = $default;			} elseif ( $value == false ) {				wp_cache_set( $key, 'falsevalue', 'site-options' );			} else {				wp_cache_set( $key, $value, 'site-options' );			}			return apply_filters( 'blog_option_' . $setting, $value, $blog_id );		} else {			$blog_prefix = $wpdb->get_blog_prefix( $blog_id );			$row = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM {$blog_prefix}options WHERE option_name = %s", $setting ) );			if ( is_object( $row ) ) { // Has to be get_row instead of get_var because of funkiness with 0, false, null values				$value = $row->option_value;				if ( $value == false )					wp_cache_set( $key, 'falsevalue', 'site-options' );				else					wp_cache_set( $key, $value, 'site-options' );			} else { // option does not exist, so we must cache its non-existence				wp_cache_set( $key, 'noop', 'site-options' );				$value = $default;			}		}	} elseif ( $value == 'noop' ) {		$value = $default;	} elseif ( $value == 'falsevalue' ) {		$value = false;	}	// If home is not set use siteurl.	if ( 'home' == $setting && '' == $value )		return get_blog_option( $blog_id, 'siteurl' );	if ( 'siteurl' == $setting || 'home' == $setting || 'category_base' == $setting )		$value = untrailingslashit( $value );	if (! @unserialize( $value ) )		$value = stripslashes( $value );	return apply_filters( 'blog_option_' . $setting, maybe_unserialize( $value ), $blog_id );}function add_blog_option( $id, $key, $value ) {	$id = (int) $id;	switch_to_blog($id);	add_option( $key, $value );	restore_current_blog();	wp_cache_set( $id."-".$key."-blog_option", $value, 'site-options' );}function delete_blog_option( $id, $key ) {	$id = (int) $id;	switch_to_blog($id);	delete_option( $key );	restore_current_blog();	wp_cache_set( $id."-".$key."-blog_option", '', 'site-options' );}function update_blog_option( $id, $key, $value, $refresh = true ) {	$id = (int) $id;	switch_to_blog($id);	update_option( $key, $value );	restore_current_blog();	if ( $refresh == true )		refresh_blog_details( $id );	wp_cache_set( $id."-".$key."-blog_option", $value, 'site-options');}function switch_to_blog( $new_blog, $validate = false ) {	global $wpdb, $table_prefix, $blog_id, $switched, $switched_stack, $wp_roles, $current_user, $wp_object_cache;	if ( empty($new_blog) )		$new_blog = $blog_id;	if ( $validate && ! get_blog_details( $new_blog ) )		return false;	if ( empty($switched_stack) )		$switched_stack = array();	$switched_stack[] = $blog_id;	/* If we're switching to the same blog id that we're on,	* set the right vars, do the associated actions, but skip	* the extra unnecessary work */	if ( $blog_id == $new_blog ) {		do_action( 'switch_blog', $blog_id, $blog_id );		$switched = true;		return true;	}	$wpdb->set_blog_id($new_blog);	$table_prefix = $wpdb->prefix;	$prev_blog_id = $blog_id;	$blog_id = $new_blog;	if ( is_object( $wp_roles ) ) {		$wpdb->suppress_errors();		if ( method_exists( $wp_roles ,'_init' ) )			$wp_roles->_init();		elseif ( method_exists( $wp_roles, '__construct' ) )			$wp_roles->__construct();		$wpdb->suppress_errors( false );	}	if ( is_object( $current_user ) )		$current_user->for_blog( $blog_id );	if ( is_object( $wp_object_cache ) && isset( $wp_object_cache->global_groups ) )		$global_groups = $wp_object_cache->global_groups;	else		$global_groups = false;	wp_cache_init();	if ( function_exists('wp_cache_add_global_groups') ) {		if ( is_array( $global_groups ) )			wp_cache_add_global_groups( $global_groups );		else			wp_cache_add_global_groups( array( 'users', 'userlogins', 'usermeta', 'site-options', 'site-lookup', 'blog-lookup', 'blog-details', 'rss', 'site-transient', 'global-posts' ) );		wp_cache_add_non_persistent_groups(array( 'comment', 'counts', 'plugins' ));	}	do_action('switch_blog', $blog_id, $prev_blog_id);	$switched = true;	return true;}function restore_current_blog() {	global $table_prefix, $wpdb, $blog_id, $switched, $switched_stack, $wp_roles, $current_user, $wp_object_cache;	if ( !$switched )		return false;	if ( !is_array( $switched_stack ) )		return false;	$blog = array_pop( $switched_stack );	if ( $blog_id == $blog ) {		do_action( 'switch_blog', $blog, $blog );		/* If we still have items in the switched stack, consider ourselves still 'switched' */		$switched = ( is_array( $switched_stack ) && count( $switched_stack ) > 0 );		return true;	}	$wpdb->set_blog_id($blog);	$prev_blog_id = $blog_id;	$blog_id = $blog;	$table_prefix = $wpdb->prefix;	if ( is_object( $wp_roles ) ) {		$wpdb->suppress_errors();		if ( method_exists( $wp_roles ,'_init' ) )			$wp_roles->_init();		elseif ( method_exists( $wp_roles, '__construct' ) )			$wp_roles->__construct();		$wpdb->suppress_errors( false );	}	if ( is_object( $current_user ) )		$current_user->for_blog( $blog_id );	if ( is_object( $wp_object_cache ) && isset( $wp_object_cache->global_groups ) )		$global_groups = $wp_object_cache->global_groups;	else		$global_groups = false;	wp_cache_init();	if ( function_exists('wp_cache_add_global_groups') ) {		if ( is_array( $global_groups ) )			wp_cache_add_global_groups( $global_groups );		else			wp_cache_add_global_groups( array( 'users', 'userlogins', 'usermeta', 'site-options', 'site-lookup', 'blog-lookup', 'blog-details', 'rss', 'site-transient' ) );		wp_cache_add_non_persistent_groups(array( 'comment', 'counts', 'plugins' ));	}	do_action('switch_blog', $blog_id, $prev_blog_id);	/* If we still have items in the switched stack, consider ourselves still 'switched' */	$switched = ( is_array( $switched_stack ) && count( $switched_stack ) > 0 );	return true;}function is_archived( $id ) {	return get_blog_status($id, 'archived');}function update_archived( $id, $archived ) {	update_blog_status($id, 'archived', $archived);	return $archived;}/** * Update a blog details field. * * @since 3.0.0 * * @param int $blog_id BLog ID * @param string $pref A field name * @param string $value Value for $pref * @param bool $refresh Whether to refresh the blog details cache. Default is true. */function update_blog_status( $blog_id, $pref, $value, $refresh = true ) {	global $wpdb;	if ( !in_array( $pref, array( 'site_id', 'domain', 'path', 'registered', 'last_updated', 'public', 'archived', 'mature', 'spam', 'deleted', 'lang_id') ) )		return $value;	$wpdb->update( $wpdb->blogs, array($pref => $value, 'last_updated' => current_time('mysql', true)), array('blog_id' => $blog_id) );	if ( $refresh )		refresh_blog_details($blog_id);	if ( $pref == 'spam' ) {		if ( $value == 1 )			do_action( "make_spam_blog", $blog_id );		else			do_action( "make_ham_blog", $blog_id );	}	return $value;}function get_blog_status( $id, $pref ) {	global $wpdb;	$details = get_blog_details( $id, false );	if ( $details )		return $details->$pref;	return $wpdb->get_var( $wpdb->prepare("SELECT %s FROM {$wpdb->blogs} WHERE blog_id = %d", $pref, $id) );}function get_last_updated( $deprecated = '', $start = 0, $quantity = 40 ) {	global $wpdb;	return $wpdb->get_results( $wpdb->prepare("SELECT blog_id, domain, path FROM $wpdb->blogs WHERE site_id = %d AND public = '1' AND archived = '0' AND mature = '0' AND spam = '0' AND deleted = '0' AND last_updated != '0000-00-00 00:00:00' ORDER BY last_updated DESC limit %d, %d", $wpdb->siteid, $start, $quantity ) , ARRAY_A );}?>
<?php/** * Multisite administration panel. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */require_once( './admin.php' );if ( !is_multisite() )	wp_die( __( 'Multisite support is not enabled.' ) );if ( ! current_user_can( 'manage_network' ) )	wp_die( __( 'You do not have permission to access this page.' ) );$title = __( 'Network Admin' );$parent_file = 'ms-admin.php';add_contextual_help($current_screen,	'<p>' . __('Until WordPress 3.0, running multiple sites required using WordPress MU instead of regular WordPress. In version 3.0, these applications have merged. If you are a former MU user, you should be aware of the following changes:') . '</p>' .	'<ul><li>' . __('Site Admin is now Super Admin (we highly encourage you to get yourself a cape!).') . '</li>' .	'<li>' . __('Blogs are now called Sites; Site is now called Network.') . '</li></ul>' .	'<p>' . __('This screen provides the network administrator with links to the screens for Sites and Users to either create a new site or user, or to search existing users and sites. Those screens are also accessible through the left-hand navigation in the Super Admin section.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Super_Admin_Super_Admin_Menu" target="_blank">Documentation on Super Admin Menu</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once( './admin-header.php' );$c_users = get_user_count();$c_blogs = get_blog_count();$user_text = sprintf( _n( '%s user', '%s users', $c_users ), number_format_i18n( $c_users ) );$blog_text = sprintf( _n( '%s site', '%s sites', $c_blogs ), number_format_i18n( $c_blogs ) );$sentence = sprintf( __( 'You have %1$s and %2$s.' ), $blog_text, $user_text );?><div class="wrap">	<?php screen_icon(); ?>	<h2><?php echo esc_html( $title ); ?></h2>	<ul class="subsubsub">	<li><a href="ms-sites.php#form-add-site"><?php _e( 'Create a New Site' ); ?></a> |</li>	<li><a href="ms-users.php#form-add-user"><?php _e( 'Create a New User' ); ?></a></li>	</ul>	<br class="clear" />	<p class="youhave"><?php echo $sentence; ?></p>	<?php do_action( 'wpmuadminresult', '' ); ?>	<form name="searchform" action="ms-users.php" method="get">		<p>			<input type="hidden" name="action" value="users" />			<input type="text" name="s" value="" size="17" />			<input class="button" type="submit" name="submit" value="<?php esc_attr_e( 'Search Users' ); ?>" />		</p>	</form>	<form name="searchform" action="ms-sites.php" method="get">		<p>			<input type="hidden" name="action" value="blogs" />			<input type="hidden" name="searchaction" value="name" />			<input type="text" name="s" value="" size="17" />			<input class="button" type="submit" name="blog_name" value="<?php esc_attr_e( 'Search Sites' ); ?>" />		</p>	</form>	<?php do_action( 'mu_rightnow_end' ); ?>	<?php do_action( 'mu_activity_box_end' ); ?></div><?php include( './admin-footer.php' ); ?>
<?php/** * Multisite users administration panel. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */require_once( './admin.php' );if ( !is_multisite() )	wp_die( __( 'Multisite support is not enabled.' ) );if ( ! current_user_can( 'manage_network_users' ) )	wp_die( __( 'You do not have permission to access this page.' ) );$title = __( 'Users' );$parent_file = 'ms-admin.php';add_contextual_help($current_screen,	'<p>' . __('This table shows all users across the network and the sites to which they are assigned.') . '</p>' .	'<p>' . __('Hover over any user on the list to make the edit links appear. The Edit link on the left will take you to his or her Edit User profile page; the Edit link on the right by any site name goes to an Edit Site screen for that site.') . '</p>' .	'<p>' . __('You can also go to the user&#8217;s profile page by clicking on the individual username.') . '</p>' .	'<p>' . __('You can sort the table by clicking on any of the bold headings and switch between list and excerpt views by using the icons in the upper right.') . '</p>' .	'<p>' . __('The bulk action will permanently delete selected users, or mark/unmark those selected as spam. Spam users will have posts removed and will be unable to sign up again with the same email addresses.') . '</p>' .	'<p>' . __('Add User will add that person to this table and send them an email.') . '</p>' .	'<p>' . __('Users who are signed up to the network without a site are added as subscribers to the main or primary dashboard site, giving them profile pages to manage their accounts. These users will only see Dashboard and My Sites in the main navigation until a site is created for them.') . '</p>' .	'<p>' . __('You can make an existing user an additional super admin by going to the Edit User profile page and checking the box to grant that privilege.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Super_Admin_Users_SubPanel" target="_blank">Network Users Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');wp_enqueue_script( 'admin-forms' );require_once( './admin-header.php' );if ( isset( $_GET['updated'] ) && $_GET['updated'] == 'true' && ! empty( $_GET['action'] ) ) {	?>	<div id="message" class="updated"><p>		<?php		switch ( $_GET['action'] ) {			case 'delete':				_e( 'User deleted.' );			break;			case 'all_spam':				_e( 'Users marked as spam.' );			break;			case 'all_notspam':				_e( 'Users removed from spam.' );			break;			case 'all_delete':				_e( 'Users deleted.' );			break;			case 'add':				_e( 'User added.' );			break;		}		?>	</p></div>	<?php}	$pagenum = isset( $_GET['paged'] ) ? absint( $_GET['paged'] ) : 0;	if ( empty( $pagenum ) )		$pagenum = 1;	$per_page = (int) get_user_option( 'ms_users_per_page' );	if ( empty( $per_page ) || $per_page < 1 )		$per_page = 15;	$per_page = apply_filters( 'ms_users_per_page', $per_page );	$s = isset( $_GET['s'] ) ? stripslashes( trim( $_GET[ 's' ] ) ) : '';	$like_s = esc_sql( like_escape( $s ) );	$query = "SELECT * FROM {$wpdb->users}";	if ( !empty( $like_s ) ) {		$query .= " WHERE user_login LIKE '%$like_s%' OR user_email LIKE '%$like_s%'";	}	$order_by = isset( $_GET['sortby'] ) ? $_GET['sortby'] : 'id';	if ( $order_by == 'email' ) {		$query .= ' ORDER BY user_email ';	} elseif ( $order_by == 'login' ) {		$query .= ' ORDER BY user_login ';	} elseif ( $order_by == 'name' ) {		$query .= ' ORDER BY display_name ';	} elseif ( $order_by == 'registered' ) {		$query .= ' ORDER BY user_registered ';	} else {		$order_by = 'id';		$query .= ' ORDER BY ID ';	}	$order = ( isset( $_GET['order'] ) && 'DESC' == $_GET['order'] ) ? 'DESC' : 'ASC';	$query .= $order;	$total = $wpdb->get_var( str_replace( 'SELECT *', 'SELECT COUNT(ID)', $query ) );	$query .= " LIMIT " . intval( ( $pagenum - 1 ) * $per_page) . ", " . intval( $per_page );	$user_list = $wpdb->get_results( $query, ARRAY_A );	$num_pages = ceil( $total / $per_page );	$page_links = paginate_links( array(		'base' => add_query_arg( 'paged', '%#%' ),		'format' => '',		'prev_text' => __( '&laquo;' ),		'next_text' => __( '&raquo;' ),		'total' => $num_pages,		'current' => $pagenum	));	if ( empty( $_GET['mode'] ) )		$mode = 'list';	else		$mode = esc_attr( $_GET['mode'] );	?>	<div class="wrap">	<?php screen_icon(); ?>	<h2><?php esc_html_e( 'Users' ); ?>	<a href="#form-add-user" class="button add-new-h2"><?php echo esc_html_x( 'Add New' , 'users'); ?></a>	<?php	if ( isset( $_GET['s'] ) && $_GET['s'] )	printf( '<span class="subtitle">' . __( 'Search results for &#8220;%s&#8221;' ) . '</span>', esc_html( $s ) );	?>	</h2>	<form action="ms-users.php" method="get" class="search-form">		<p class="search-box">		<input type="text" name="s" value="<?php echo esc_attr( $s ); ?>" class="search-input" id="user-search-input" />		<input type="submit" id="post-query-submit" value="<?php esc_attr_e( 'Search Users' ) ?>" class="button" />		</p>	</form>	<form id="form-user-list" action='ms-edit.php?action=allusers' method='post'>		<input type="hidden" name="mode" value="<?php echo esc_attr( $mode ); ?>" />		<div class="tablenav">			<div class="alignleft actions">				<select name="action">					<option value="-1" selected="selected"><?php _e( 'Bulk Actions' ); ?></option>					<option value="delete"><?php _e( 'Delete' ); ?></option>					<option value="spam"><?php _ex( 'Mark as Spam', 'user' ); ?></option>					<option value="notspam"><?php _ex( 'Not Spam', 'user' ); ?></option>				</select>				<input type="submit" value="<?php esc_attr_e( 'Apply' ); ?>" name="doaction" id="doaction" class="button-secondary action" />				<?php wp_nonce_field( 'bulk-ms-users', '_wpnonce_bulk-ms-users' ); ?>			</div>			<?php if ( $page_links ) { ?>			<div class="tablenav-pages">			<?php $page_links_text = sprintf( '<span class="displaying-num">' . __( 'Displaying %s&#8211;%s of %s' ) . '</span>%s',			number_format_i18n( ( $pagenum - 1 ) * $per_page + 1 ),			number_format_i18n( min( $pagenum * $per_page, $total ) ),			number_format_i18n( $total ),			$page_links			); echo $page_links_text; ?>			</div>			<?php } ?>			<div class="view-switch">				<a href="<?php echo esc_url( add_query_arg( 'mode', 'list', $_SERVER['REQUEST_URI'] ) ) ?>"><img <?php if ( 'list' == $mode ) echo 'class="current"'; ?> id="view-switch-list" src="<?php echo esc_url( includes_url( 'images/blank.gif' ) ); ?>" width="20" height="20" title="<?php _e( 'List View' ) ?>" alt="<?php _e( 'List View' ) ?>" /></a>				<a href="<?php echo esc_url( add_query_arg( 'mode', 'excerpt', $_SERVER['REQUEST_URI'] ) ) ?>"><img <?php if ( 'excerpt' == $mode ) echo 'class="current"'; ?> id="view-switch-excerpt" src="<?php echo esc_url( includes_url( 'images/blank.gif' ) ); ?>" width="20" height="20" title="<?php _e( 'Excerpt View' ) ?>" alt="<?php _e( 'Excerpt View' ) ?>" /></a>			</div>		</div>		<div class="clear"></div>		<?php		// define the columns to display, the syntax is 'internal name' => 'display name'		$users_columns = array(			'id'           => __( 'ID' ),			'login'      => __( 'Username' ),			'name'       => __( 'Name' ),			'email'      => __( 'E-mail' ),			'registered' => _x( 'Registered', 'user' ),			'blogs'      => __( 'Sites' )		);		$users_columns = apply_filters( 'wpmu_users_columns', $users_columns );		?>		<table class="widefat">			<thead>			<tr>				<th class="manage-column column-cb check-column" scope="col">					<input type="checkbox" />				</th>				<?php				$col_url = '';				foreach($users_columns as $column_id => $column_display_name) {					$column_link = "<a href='";					$order2 = '';					if ( $order_by == $column_id )						$order2 = ( $order == 'DESC' ) ? 'ASC' : 'DESC';					$column_link .= esc_url( add_query_arg( array( 'order' => $order2, 'paged' => $pagenum, 'sortby' => $column_id ), remove_query_arg( array( 'action', 'updated' ), $_SERVER['REQUEST_URI'] ) ) );					$column_link .= "'>{$column_display_name}</a>";					$col_url .= '<th scope="col">' . ( $column_id == 'blogs' ? $column_display_name : $column_link ) . '</th>';				}				echo $col_url; ?>			</tr>			</thead>			<tfoot>			<tr>				<th class="manage-column column-cb check-column" scope="col">					<input type="checkbox" />				</th>				<?php echo $col_url; ?>			</tr>			</tfoot>			<tbody id="the-user-list" class="list:user">			<?php if ( $user_list ) {				$class = '';				$super_admins = get_super_admins();				foreach ( (array) $user_list as $user ) {					$class = ( 'alternate' == $class ) ? '' : 'alternate';					$status_list = array( 'spam' => 'site-spammed', 'deleted' => 'site-deleted' );					foreach ( $status_list as $status => $col ) {						if ( $user[$status] )							$class = $col;					}					?>					<tr class="<?php echo $class; ?>">					<?php					foreach( (array) $users_columns as $column_name=>$column_display_name ) :						switch( $column_name ) {							case 'id': ?>								<th scope="row" class="check-column">									<input type="checkbox" id="blog_<?php echo $user['ID'] ?>" name="allusers[]" value="<?php echo esc_attr( $user['ID'] ) ?>" />								</th>								<th valign="top" scope="row">									<?php echo $user['ID'] ?>								</th>							<?php							break;							case 'login':								$avatar	= get_avatar( $user['user_email'], 32 );								$edit_link = ( $current_user->ID == $user['ID'] ) ? 'profile.php' : 'user-edit.php?user_id=' . $user['ID'];								?>								<td class="username column-username">									<?php echo $avatar; ?><strong><a href="<?php echo esc_url( admin_url( $edit_link ) ); ?>" class="edit"><?php echo stripslashes( $user['user_login'] ); ?></a><?php									if ( in_array( $user['user_login'], $super_admins ) )										echo ' - ' . __( 'Super admin' );									?></strong>									<br/>									<div class="row-actions">										<span class="edit"><a href="<?php echo esc_url( admin_url( $edit_link ) ); ?>"><?php _e( 'Edit' ); ?></a></span>										<?php if ( ! in_array( $user['user_login'], $super_admins ) ) { ?>										| <span class="delete"><a href="<?php echo $delete	= esc_url( admin_url( add_query_arg( '_wp_http_referer', urlencode( stripslashes( $_SERVER['REQUEST_URI'] ) ), wp_nonce_url( 'ms-edit.php', 'deleteuser' ) . '&amp;action=deleteuser&amp;id=' . $user['ID'] ) ) ); ?>" class="delete"><?php _e( 'Delete' ); ?></a></span>										<?php } ?>									</div>								</td>							<?php							break;							case 'name': ?>								<td class="name column-name"><?php echo $user['display_name'] ?></td>							<?php							break;							case 'email': ?>								<td class="email column-email"><a href="mailto:<?php echo $user['user_email'] ?>"><?php echo $user['user_email'] ?></a></td>							<?php							break;							case 'registered':								if ( 'list' == $mode )									$date = 'Y/m/d';								else									$date = 'Y/m/d \<\b\r \/\> g:i:s a';							?>								<td><?php echo mysql2date( __( $date ), $user['user_registered'] ); ?></td>							<?php							break;							case 'blogs':								$blogs = get_blogs_of_user( $user['ID'], true );								?>								<td>									<?php									if ( is_array( $blogs ) ) {										foreach ( (array) $blogs as $key => $val ) {											$path	= ( $val->path == '/' ) ? '' : $val->path;											echo '<a href="'. esc_url( admin_url( 'ms-sites.php?action=editblog&amp;id=' . $val->userblog_id  ) ) .'">' . str_replace( '.' . $current_site->domain, '', $val->domain . $path ) . '</a>';											echo ' <small class="row-actions">';											// Edit											echo '<a href="'. esc_url( admin_url( 'ms-sites.php?action=editblog&amp;id=' . $val->userblog_id  ) ) .'">' . __( 'Edit' ) . '</a> | ';											// View											echo '<a ';											if ( get_blog_status( $val->userblog_id, 'spam' ) == 1 )												echo 'style="background-color: #faa" ';											echo 'href="' .  esc_url( get_home_url( $val->userblog_id ) )  . '">' . __( 'View' ) . '</a>';											echo '</small><br />';										}									}									?>								</td>							<?php							break;							default: ?>								<td><?php do_action( 'manage_users_custom_column', $column_name, $user['ID'] ); ?></td>							<?php							break;						}					endforeach					?>					</tr>					<?php				}			} else {			?>				<tr>					<td colspan="<?php echo (int) count($users_columns); ?>"><?php _e( 'No users found.' ) ?></td>				</tr>				<?php			} // end if ($users)			?>			</tbody>		</table>		<div class="tablenav">			<?php			if ( $page_links )				echo "<div class='tablenav-pages'>$page_links_text</div>";			?>			<div class="alignleft actions">				<select name="action2">					<option value="-1" selected="selected"><?php _e( 'Bulk Actions' ); ?></option>					<option value="delete"><?php _e( 'Delete' ); ?></option>					<option value="spam"><?php _ex( 'Mark as Spam', 'user' ); ?></option>					<option value="notspam"><?php _ex( 'Not Spam', 'user' ); ?></option>				</select>				<input type="submit" value="<?php esc_attr_e( 'Apply' ); ?>" name="doaction2" id="doaction2" class="button-secondary action" />			</div>			<br class="clear" />		</div>		</form>		</div><?phpif ( apply_filters( 'show_adduser_fields', true ) ) :?><div class="wrap" id="form-add-user">	<h3><?php _e( 'Add User' ) ?></h3>	<form action="ms-edit.php?action=adduser" method="post">	<table class="form-table">		<tr class="form-field form-required">			<th scope="row"><?php _e( 'Username' ) ?></th>			<td><input type="text" class="regular-text" name="user[username]" /></td>		</tr>		<tr class="form-field form-required">			<th scope="row"><?php _e( 'Email' ) ?></th>			<td><input type="text" class="regular-text" name="user[email]" /></td>		</tr>		<tr class="form-field">			<td colspan="2"><?php _e( 'Username and password will be mailed to the above email address.' ) ?></td>		</tr>	</table>	<p class="submit">		<?php wp_nonce_field( 'add-user', '_wpnonce_add-user' ) ?>		<input class="button" type="submit" value="<?php esc_attr_e( 'Add user' ) ?>" /></p>	</form></div><?php endif; ?><?php include( './admin-footer.php' ); ?>
<?php/** * Handle default dashboard widgets options AJAX. * * @package WordPress * @subpackage Administration *//** Load WordPress Bootstrap */require_once( './admin.php' );/** Load WordPress Administration Dashboard API */require( './includes/dashboard.php' );@header( 'Content-Type: ' . get_option( 'html_type' ) . '; charset=' . get_option( 'blog_charset' ) );send_nosniff_header();switch ( $_GET['jax'] ) {case 'dashboard_incoming_links' :	wp_dashboard_incoming_links_output();	break;case 'dashboard_primary' :	wp_dashboard_rss_output( 'dashboard_primary' );	break;case 'dashboard_secondary' :	wp_dashboard_secondary_output();	break;case 'dashboard_plugins' :	wp_dashboard_plugins_output();	break;case 'dashboard_quick_press' :	wp_dashboard_quick_press_output();	break;}?>
<?php/** * Class for a set of entries for translation and their associated headers * * @version $Id: translations.php 406 2010-02-07 11:10:24Z nbachiyski $ * @package pomo * @subpackage translations */require_once dirname(__FILE__) . '/entry.php';if ( !class_exists( 'Translations' ) ):class Translations {	var $entries = array();	var $headers = array();	/**	 * Add entry to the PO structure	 *	 * @param object &$entry	 * @return bool true on success, false if the entry doesn't have a key	 */	function add_entry($entry) {		if (is_array($entry)) {			$entry = new Translation_Entry($entry);		}		$key = $entry->key();		if (false === $key) return false;		$this->entries[$key] = &$entry;		return true;	}	/**	 * Sets $header PO header to $value	 *	 * If the header already exists, it will be overwritten	 *	 * TODO: this should be out of this class, it is gettext specific	 *	 * @param string $header header name, without trailing :	 * @param string $value header value, without trailing \n	 */	function set_header($header, $value) {		$this->headers[$header] = $value;	}	function set_headers(&$headers) {		foreach($headers as $header => $value) {			$this->set_header($header, $value);		}	}	function get_header($header) {		return isset($this->headers[$header])? $this->headers[$header] : false;	}	function translate_entry(&$entry) {		$key = $entry->key();		return isset($this->entries[$key])? $this->entries[$key] : false;	}	function translate($singular, $context=null) {		$entry = new Translation_Entry(array('singular' => $singular, 'context' => $context));		$translated = $this->translate_entry($entry);		return ($translated && !empty($translated->translations))? $translated->translations[0] : $singular;	}	/**	 * Given the number of items, returns the 0-based index of the plural form to use	 *	 * Here, in the base Translations class, the commong logic for English is implmented:	 * 	0 if there is one element, 1 otherwise	 *	 * This function should be overrided by the sub-classes. For example MO/PO can derive the logic	 * from their headers.	 *	 * @param integer $count number of items	 */	function select_plural_form($count) {		return 1 == $count? 0 : 1;	}	function get_plural_forms_count() {		return 2;	}	function translate_plural($singular, $plural, $count, $context = null) {		$entry = new Translation_Entry(array('singular' => $singular, 'plural' => $plural, 'context' => $context));		$translated = $this->translate_entry($entry);		$index = $this->select_plural_form($count);		$total_plural_forms = $this->get_plural_forms_count();		if ($translated && 0 <= $index && $index < $total_plural_forms &&				is_array($translated->translations) &&				isset($translated->translations[$index]))			return $translated->translations[$index];		else			return 1 == $count? $singular : $plural;	}	/**	 * Merge $other in the current object.	 *	 * @param Object &$other Another Translation object, whose translations will be merged in this one	 * @return void	 **/	function merge_with(&$other) {		foreach( $other->entries as $entry ) {			$this->entries[$entry->key()] = $entry;		}	}}class Gettext_Translations extends Translations {	/**	 * The gettext implmentation of select_plural_form.	 *	 * It lives in this class, because there are more than one descendand, which will use it and	 * they can't share it effectively.	 *	 */	function gettext_select_plural_form($count) {		if (!isset($this->_gettext_select_plural_form) || is_null($this->_gettext_select_plural_form)) {			list( $nplurals, $expression ) = $this->nplurals_and_expression_from_header($this->get_header('Plural-Forms'));			$this->_nplurals = $nplurals;			$this->_gettext_select_plural_form = $this->make_plural_form_function($nplurals, $expression);		}		return call_user_func($this->_gettext_select_plural_form, $count);	}	function nplurals_and_expression_from_header($header) {		if (preg_match('/^\s*nplurals\s*=\s*(\d+)\s*;\s+plural\s*=\s*(.+)$/', $header, $matches)) {			$nplurals = (int)$matches[1];			$expression = trim($this->parenthesize_plural_exression($matches[2]));			return array($nplurals, $expression);		} else {			return array(2, 'n != 1');		}	}	/**	 * Makes a function, which will return the right translation index, according to the	 * plural forms header	 */	function make_plural_form_function($nplurals, $expression) {		$expression = str_replace('n', '$n', $expression);		$func_body = "			\$index = (int)($expression);			return (\$index < $nplurals)? \$index : $nplurals - 1;";		return create_function('$n', $func_body);	}	/**	 * Adds parantheses to the inner parts of ternary operators in	 * plural expressions, because PHP evaluates ternary oerators from left to right	 *	 * @param string $expression the expression without parentheses	 * @return string the expression with parentheses added	 */	function parenthesize_plural_exression($expression) {		$expression .= ';';		$res = '';		$depth = 0;		for ($i = 0; $i < strlen($expression); ++$i) {			$char = $expression[$i];			switch ($char) {				case '?':					$res .= ' ? (';					$depth++;					break;				case ':':					$res .= ') : (';					break;				case ';':					$res .= str_repeat(')', $depth) . ';';					$depth= 0;					break;				default:					$res .= $char;			}		}		return rtrim($res, ';');	}	function make_headers($translation) {		$headers = array();		// sometimes \ns are used instead of real new lines		$translation = str_replace('\n', "\n", $translation);		$lines = explode("\n", $translation);		foreach($lines as $line) {			$parts = explode(':', $line, 2);			if (!isset($parts[1])) continue;			$headers[trim($parts[0])] = trim($parts[1]);		}		return $headers;	}	function set_header($header, $value) {		parent::set_header($header, $value);		if ('Plural-Forms' == $header) {			list( $nplurals, $expression ) = $this->nplurals_and_expression_from_header($this->get_header('Plural-Forms'));			$this->_nplurals = $nplurals;			$this->_gettext_select_plural_form = $this->make_plural_form_function($nplurals, $expression);		}	}}endif;if ( !class_exists( 'NOOP_Translations' ) ):/** * Provides the same interface as Translations, but doesn't do anything */class NOOP_Translations {	var $entries = array();	var $headers = array();	function add_entry($entry) {		return true;	}	function set_header($header, $value) {	}	function set_headers(&$headers) {	}	function get_header($header) {		return false;	}	function translate_entry(&$entry) {		return false;	}	function translate($singular, $context=null) {		return $singular;	}	function select_plural_form($count) {		return 1 == $count? 0 : 1;	}	function get_plural_forms_count() {		return 2;	}	function translate_plural($singular, $plural, $count, $context = null) {			return 1 == $count? $singular : $plural;	}	function merge_with(&$other) {	}}endif;
<?php/** Sets up the WordPress Environment. */require( dirname(__FILE__) . '/wp-load.php' );add_action( 'wp_head', 'signuppageheaders' ) ;require( './wp-blog-header.php' );require_once( ABSPATH . WPINC . '/registration.php' );if ( is_array( get_site_option( 'illegal_names' )) && isset( $_GET[ 'new' ] ) && in_array( $_GET[ 'new' ], get_site_option( 'illegal_names' ) ) == true ) {	wp_redirect( network_home_url() );	die();}function do_signup_header() {	do_action("signup_header");}add_action( 'wp_head', 'do_signup_header' );function signuppageheaders() {	echo "<meta name='robots' content='noindex,nofollow' />\n";}if ( !is_multisite() ) {	wp_redirect( get_option( 'siteurl' ) . "/wp-login.php?action=register" );	die();}if ( !is_main_site() ) {	wp_redirect( network_home_url( 'wp-signup.php' ) );	die();}// Fix for page title$wp_query->is_404 = false;function wpmu_signup_stylesheet() {	?>	<style type="text/css">		.mu_register { width: 90%; margin:0 auto; }		.mu_register form { margin-top: 2em; }		.mu_register .error { font-weight:700; padding:10px; color:#333333; background:#FFEBE8; border:1px solid #CC0000; }		.mu_register input[type="submit"],			.mu_register #blog_title,			.mu_register #user_email,			.mu_register #blogname,			.mu_register #user_name { width:100%; font-size: 24px; margin:5px 0; }		.mu_register .prefix_address,			.mu_register .suffix_address {font-size: 18px;display:inline; }		.mu_register label { font-weight:700; font-size:15px; display:block; margin:10px 0; }		.mu_register label.checkbox { display:inline; }		.mu_register .mu_alert { font-weight:700; padding:10px; color:#333333; background:#ffffe0; border:1px solid #e6db55; }	</style>	<?php}add_action( 'wp_head', 'wpmu_signup_stylesheet' );get_header();do_action( 'before_signup_form' );?><div id="content" class="widecolumn"><div class="mu_register"><?phpfunction show_blog_form($blogname = '', $blog_title = '', $errors = '') {	global $current_site;	// Blog name	if ( !is_subdomain_install() )		echo '<label for="blogname">' . __('Site Name:') . '</label>';	else		echo '<label for="blogname">' . __('Site Domain:') . '</label>';	if ( $errmsg = $errors->get_error_message('blogname') ) { ?>		<p class="error"><?php echo $errmsg ?></p>	<?php }	if ( !is_subdomain_install() )		echo '<span class="prefix_address">' . $current_site->domain . $current_site->path . '</span><input name="blogname" type="text" id="blogname" value="'. esc_attr($blogname) .'" maxlength="60" /><br />';	else		echo '<input name="blogname" type="text" id="blogname" value="'.esc_attr($blogname).'" maxlength="60" /><span class="suffix_address">.' . ( $site_domain = preg_replace( '|^www\.|', '', $current_site->domain ) ) . '</span><br />';	if ( !is_user_logged_in() ) {		print '(<strong>' . __( 'Your address will be ' );		if ( !is_subdomain_install() )			print $current_site->domain . $current_site->path . __( 'sitename' );		else			print __( 'domain.' ) . $site_domain . $current_site->path;		echo '.</strong>) ' . __( 'Must be at least 4 characters, letters and numbers only. It cannot be changed, so choose carefully!' ) . '</p>';	}	// Blog Title	?>	<label for="blog_title"><?php _e('Site Title:') ?></label>	<?php if ( $errmsg = $errors->get_error_message('blog_title') ) { ?>		<p class="error"><?php echo $errmsg ?></p>	<?php }	echo '<input name="blog_title" type="text" id="blog_title" value="'.esc_attr($blog_title).'" />';	?>	<div id="privacy">        <p class="privacy-intro">            <label for="blog_public_on"><?php _e('Privacy:') ?></label>            <?php _e('Allow my site to appear in search engines like Google, Technorati, and in public listings around this network.'); ?>            <br style="clear:both" />            <label class="checkbox" for="blog_public_on">                <input type="radio" id="blog_public_on" name="blog_public" value="1" <?php if ( !isset( $_POST['blog_public'] ) || $_POST['blog_public'] == '1' ) { ?>checked="checked"<?php } ?> />                <strong><?php _e( 'Yes' ); ?></strong>            </label>            <label class="checkbox" for="blog_public_off">                <input type="radio" id="blog_public_off" name="blog_public" value="0" <?php if ( isset( $_POST['blog_public'] ) && $_POST['blog_public'] == '0' ) { ?>checked="checked"<?php } ?> />                <strong><?php _e( 'No' ); ?></strong>            </label>        </p>	</div>	<?php	do_action('signup_blogform', $errors);}function validate_blog_form() {	$user = '';	if ( is_user_logged_in() )		$user = wp_get_current_user();	return wpmu_validate_blog_signup($_POST['blogname'], $_POST['blog_title'], $user);}function show_user_form($user_name = '', $user_email = '', $errors = '') {	// User name	echo '<label for="user_name">' . __('Username:') . '</label>';	if ( $errmsg = $errors->get_error_message('user_name') ) {		echo '<p class="error">'.$errmsg.'</p>';	}	echo '<input name="user_name" type="text" id="user_name" value="'. esc_attr($user_name) .'" maxlength="60" /><br />';	_e( '(Must be at least 4 characters, letters and numbers only.)' );	?>	<label for="user_email"><?php _e( 'Email&nbsp;Address:' ) ?></label>	<?php if ( $errmsg = $errors->get_error_message('user_email') ) { ?>		<p class="error"><?php echo $errmsg ?></p>	<?php } ?>	<input name="user_email" type="text" id="user_email" value="<?php  echo esc_attr($user_email) ?>" maxlength="200" /><br /><?php _e('We send your registration email to this address. (Double-check your email address before continuing.)') ?>	<?php	if ( $errmsg = $errors->get_error_message('generic') ) {		echo '<p class="error">' . $errmsg . '</p>';	}	do_action( 'signup_extra_fields', $errors );}function validate_user_form() {	return wpmu_validate_user_signup($_POST['user_name'], $_POST['user_email']);}function signup_another_blog($blogname = '', $blog_title = '', $errors = '') {	global $current_user, $current_site;	if ( ! is_wp_error($errors) ) {		$errors = new WP_Error();	}	// allow definition of default variables	$filtered_results = apply_filters('signup_another_blog_init', array('blogname' => $blogname, 'blog_title' => $blog_title, 'errors' => $errors ));	$blogname = $filtered_results['blogname'];	$blog_title = $filtered_results['blog_title'];	$errors = $filtered_results['errors'];	echo '<h2>' . sprintf( __( 'Get <em>another</em> %s site in seconds' ), $current_site->site_name ) . '</h2>';	if ( $errors->get_error_code() ) {		echo '<p>' . __( 'There was a problem, please correct the form below and try again.' ) . '</p>';	}	?>	<p><?php printf( __( 'Welcome back, %s. By filling out the form below, you can <strong>add another site to your account</strong>. There is no limit to the number of sites you can have, so create to your heart&#8217;s content, but write responsibly!' ), $current_user->display_name ) ?></p>	<?php	$blogs = get_blogs_of_user($current_user->ID);	if ( !empty($blogs) ) { ?>			<p><?php _e( 'Sites you are already a member of:' ) ?></p>			<ul>				<?php foreach ( $blogs as $blog ) {					$home_url = get_home_url( $blog->userblog_id );					echo '<li><a href="' . esc_url( $home_url ) . '">' . $home_url . '</a></li>';				} ?>			</ul>	<?php } ?>	<p><?php _e( 'If you&#8217;re not going to use a great site domain, leave it for a new user. Now have at it!' ) ?></p>	<form id="setupform" method="post" action="wp-signup.php">		<input type="hidden" name="stage" value="gimmeanotherblog" />		<?php do_action( "signup_hidden_fields" ); ?>		<?php show_blog_form($blogname, $blog_title, $errors); ?>		<p class="submit"><input type="submit" name="submit" class="submit" value="<?php esc_attr_e( 'Create Site' ) ?>" /></p>	</form>	<?php}function validate_another_blog_signup() {	global $wpdb, $current_user, $blogname, $blog_title, $errors, $domain, $path;	$current_user = wp_get_current_user();	if ( !is_user_logged_in() )		die();	$result = validate_blog_form();	extract($result);	if ( $errors->get_error_code() ) {		signup_another_blog($blogname, $blog_title, $errors);		return false;	}	$public = (int) $_POST['blog_public'];	$meta = apply_filters( 'signup_create_blog_meta', array( 'lang_id' => 1, 'public' => $public ) ); // deprecated	$meta = apply_filters( 'add_signup_meta', $meta );	wpmu_create_blog( $domain, $path, $blog_title, $current_user->id, $meta, $wpdb->siteid );	confirm_another_blog_signup($domain, $path, $blog_title, $current_user->user_login, $current_user->user_email, $meta);	return true;}function confirm_another_blog_signup($domain, $path, $blog_title, $user_name, $user_email = '', $meta = '') {	?>	<h2><?php printf( __( 'The site %s is yours.' ), "<a href='http://{$domain}{$path}'>{$blog_title}</a>" ) ?></h2>	<p>		<?php printf( __( '<a href="http://%1$s">http://%2$s</a> is your new site.  <a href="%3$s">Log in</a> as &#8220;%4$s&#8221; using your existing password.' ), $domain.$path, $domain.$path, "http://" . $domain.$path . "wp-login.php", $user_name ) ?>	</p>	<?php	do_action( 'signup_finished' );}function signup_user($user_name = '', $user_email = '', $errors = '') {	global $current_site, $active_signup;	if ( !is_wp_error($errors) )		$errors = new WP_Error();	if ( isset( $_POST[ 'signup_for' ] ) )		$signup[ esc_html( $_POST[ 'signup_for' ] ) ] = 'checked="checked"';	else		$signup[ 'blog' ] = 'checked="checked"';	//TODO - This doesn't seem to do anything do we really need it?	$signup['user'] = isset( $signup['user'] ) ? $signup['user'] : '';	// allow definition of default variables	$filtered_results = apply_filters('signup_user_init', array('user_name' => $user_name, 'user_email' => $user_email, 'errors' => $errors ));	$user_name = $filtered_results['user_name'];	$user_email = $filtered_results['user_email'];	$errors = $filtered_results['errors'];	?>	<h2><?php printf( __( 'Get your own %s account in seconds' ), $current_site->site_name ) ?></h2>	<form id="setupform" method="post" action="wp-signup.php">		<input type="hidden" name="stage" value="validate-user-signup" />		<?php do_action( "signup_hidden_fields" ); ?>		<?php show_user_form($user_name, $user_email, $errors); ?>		<p>		<?php if ( $active_signup == 'blog' ) { ?>			<input id="signupblog" type="hidden" name="signup_for" value="blog" />		<?php } elseif ( $active_signup == 'user' ) { ?>			<input id="signupblog" type="hidden" name="signup_for" value="user" />		<?php } else { ?>			<input id="signupblog" type="radio" name="signup_for" value="blog" <?php echo $signup['blog'] ?> />			<label class="checkbox" for="signupblog"><?php _e('Gimme a site!') ?></label>			<br />			<input id="signupuser" type="radio" name="signup_for" value="user" <?php echo $signup['user'] ?> />			<label class="checkbox" for="signupuser"><?php _e('Just a username, please.') ?></label>		<?php } ?>		</p>		<p class="submit"><input type="submit" name="submit" class="submit" value="<?php esc_attr_e('Next') ?>" /></p>	</form>	<?php}function validate_user_signup() {	$result = validate_user_form();	extract($result);	if ( $errors->get_error_code() ) {		signup_user($user_name, $user_email, $errors);		return false;	}	if ( 'blog' == $_POST['signup_for'] ) {		signup_blog($user_name, $user_email);		return false;	}	wpmu_signup_user($user_name, $user_email, apply_filters( "add_signup_meta", array() ) );	confirm_user_signup($user_name, $user_email);	return true;}function confirm_user_signup($user_name, $user_email) {	?>	<h2><?php printf( __( '%s is your new username' ), $user_name) ?></h2>	<p><?php _e( 'But, before you can start using your new username, <strong>you must activate it</strong>.' ) ?></p>	<p><?php printf(__( 'Check your inbox at <strong>%1$s</strong> and click the link given.' ),  $user_email) ?></p>	<p><?php _e( 'If you do not activate your username within two days, you will have to sign up again.' ); ?></p>	<?php	do_action( 'signup_finished' );}function signup_blog($user_name = '', $user_email = '', $blogname = '', $blog_title = '', $errors = '') {	if ( !is_wp_error($errors) )		$errors = new WP_Error();	// allow definition of default variables	$filtered_results = apply_filters('signup_blog_init', array('user_name' => $user_name, 'user_email' => $user_email, 'blogname' => $blogname, 'blog_title' => $blog_title, 'errors' => $errors ));	$user_name = $filtered_results['user_name'];	$user_email = $filtered_results['user_email'];	$blogname = $filtered_results['blogname'];	$blog_title = $filtered_results['blog_title'];	$errors = $filtered_results['errors'];	if ( empty($blogname) )		$blogname = $user_name;	?>	<form id="setupform" method="post" action="wp-signup.php">		<input type="hidden" name="stage" value="validate-blog-signup" />		<input type="hidden" name="user_name" value="<?php echo esc_attr($user_name) ?>" />		<input type="hidden" name="user_email" value="<?php echo esc_attr($user_email) ?>" />		<?php do_action( "signup_hidden_fields" ); ?>		<?php show_blog_form($blogname, $blog_title, $errors); ?>		<p class="submit"><input type="submit" name="submit" class="submit" value="<?php esc_attr_e('Signup') ?>" /></p>	</form>	<?php}function validate_blog_signup() {	// Re-validate user info.	$result = wpmu_validate_user_signup($_POST['user_name'], $_POST['user_email']);	extract($result);	if ( $errors->get_error_code() ) {		signup_user($user_name, $user_email, $errors);		return false;	}	$result = wpmu_validate_blog_signup($_POST['blogname'], $_POST['blog_title']);	extract($result);	if ( $errors->get_error_code() ) {		signup_blog($user_name, $user_email, $blogname, $blog_title, $errors);		return false;	}	$public = (int) $_POST['blog_public'];	$meta = array ('lang_id' => 1, 'public' => $public);	$meta = apply_filters( "add_signup_meta", $meta );	wpmu_signup_blog($domain, $path, $blog_title, $user_name, $user_email, $meta);	confirm_blog_signup($domain, $path, $blog_title, $user_name, $user_email, $meta);	return true;}function confirm_blog_signup($domain, $path, $blog_title, $user_name = '', $user_email = '', $meta) {	?>	<h2><?php printf( __( 'Congratulations! Your new site, %s, is almost ready.' ), "<a href='http://{$domain}{$path}'>{$blog_title}</a>" ) ?></h2>	<p><?php _e( 'But, before you can start using your site, <strong>you must activate it</strong>.' ) ?></p>	<p><?php printf( __( 'Check your inbox at <strong>%s</strong> and click the link given.' ),  $user_email) ?></p>	<p><?php _e( 'If you do not activate your site within two days, you will have to sign up again.' ); ?></p>	<h2><?php _e( 'Still waiting for your email?' ); ?></h2>	<p>		<?php _e( 'If you haven&#8217;t received your email yet, there are a number of things you can do:' ) ?>		<ul id="noemail-tips">			<li><p><strong><?php _e( 'Wait a little longer. Sometimes delivery of email can be delayed by processes outside of our control.' ) ?></strong></p></li>			<li><p><?php _e( 'Check the junk or spam folder of your email client. Sometime emails wind up there by mistake.' ) ?></p></li>			<li><?php printf( __( 'Have you entered your email correctly?  You have entered %s, if it&#8217;s incorrect, you will not receive your email.' ), $user_email ) ?></li>		</ul>	</p>	<?php	do_action( 'signup_finished' );}// Main$active_signup = get_site_option( 'registration' );if ( !$active_signup )	$active_signup = 'all';$active_signup = apply_filters( 'wpmu_active_signup', $active_signup ); // return "all", "none", "blog" or "user"// Make the signup type translatable.$i18n_signup['all'] = _x('all', 'Multisite active signup type');$i18n_signup['none'] = _x('none', 'Multisite active signup type');$i18n_signup['blog'] = _x('blog', 'Multisite active signup type');$i18n_signup['user'] = _x('user', 'Multisite active signup type');if ( is_super_admin() )	echo '<div class="mu_alert">' . sprintf( __( 'Greetings Site Administrator! You are currently allowing &#8220;%s&#8221; registrations. To change or disable registration go to your <a href="%s">Options page</a>.' ), $i18n_signup[$active_signup], esc_url( network_admin_url( 'ms-options.php' ) ) ) . '</div>';$newblogname = isset($_GET['new']) ? strtolower(preg_replace('/^-|-$|[^-a-zA-Z0-9]/', '', $_GET['new'])) : null;$current_user = wp_get_current_user();if ( $active_signup == "none" ) {	_e( 'Registration has been disabled.' );} elseif ( $active_signup == 'blog' && !is_user_logged_in() ) {	if ( is_ssl() )		$proto = 'https://';	else		$proto = 'http://';	$login_url = site_url( 'wp-login.php?redirect_to=' . urlencode($proto . $_SERVER['HTTP_HOST'] . '/wp-signup.php' ));	echo sprintf( __( 'You must first <a href="%s">log in</a>, and then you can create a new site.' ), $login_url );} else {	$stage = isset( $_POST['stage'] ) ?  $_POST['stage'] : 'default';	switch ( $stage ) {		case 'validate-user-signup' :			if ( $active_signup == 'all' || $_POST[ 'signup_for' ] == 'blog' && $active_signup == 'blog' || $_POST[ 'signup_for' ] == 'user' && $active_signup == 'user' )				validate_user_signup();			else				_e( 'User registration has been disabled.' );		break;		case 'validate-blog-signup':			if ( $active_signup == 'all' || $active_signup == 'blog' )				validate_blog_signup();			else				_e( 'Site registration has been disabled.' );			break;		case 'gimmeanotherblog':			validate_another_blog_signup();			break;		case 'default':		default :			$user_email = isset( $_POST[ 'user_email' ] ) ? $_POST[ 'user_email' ] : '';			do_action( "preprocess_signup_form" ); // populate the form from invites, elsewhere?			if ( is_user_logged_in() && ( $active_signup == 'all' || $active_signup == 'blog' ) )				signup_another_blog($newblogname);			elseif ( is_user_logged_in() == false && ( $active_signup == 'all' || $active_signup == 'user' ) )				signup_user( $newblogname, $user_email );			elseif ( is_user_logged_in() == false && ( $active_signup == 'blog' ) )				_e( 'Sorry, new registrations are not allowed at this time.' );			else				_e( 'You are logged in already. No need to register again!' );			if ( $newblogname ) {				$newblog = get_blogaddress_by_name( $newblogname );				if ( $active_signup == 'blog' || $active_signup == 'all' )					printf( __( '<p><em>The site you were looking for, <strong>%s</strong> does not exist, but you can create it now!</em></p>' ), $newblog );				else					printf( __( '<p><em>The site you were looking for, <strong>%s</strong>, does not exist.</em></p>' ), $newblog );			}			break;	}}?></div></div><?php do_action( 'after_signup_form' ); ?><?php get_footer(); ?>
<?php/** * RSS 1 RDF Feed Template for displaying RSS 1 Posts feed. * * @package WordPress */header('Content-Type: ' . feed_content_type('rdf') . '; charset=' . get_option('blog_charset'), true);$more = 1;echo '<?xml version="1.0" encoding="'.get_option('blog_charset').'"?'.'>'; ?><rdf:RDF	xmlns="http://purl.org/rss/1.0/"	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"	xmlns:dc="http://purl.org/dc/elements/1.1/"	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"	xmlns:admin="http://webns.net/mvcb/"	xmlns:content="http://purl.org/rss/1.0/modules/content/"	<?php do_action('rdf_ns'); ?>><channel rdf:about="<?php bloginfo_rss("url") ?>">	<title><?php bloginfo_rss('name'); wp_title_rss(); ?></title>	<link><?php bloginfo_rss('url') ?></link>	<description><?php bloginfo_rss('description') ?></description>	<dc:date><?php echo mysql2date('Y-m-d\TH:i:s\Z', get_lastpostmodified('GMT'), false); ?></dc:date>	<sy:updatePeriod><?php echo apply_filters( 'rss_update_period', 'hourly' ); ?></sy:updatePeriod>	<sy:updateFrequency><?php echo apply_filters( 'rss_update_frequency', '1' ); ?></sy:updateFrequency>	<sy:updateBase>2000-01-01T12:00+00:00</sy:updateBase>	<?php do_action('rdf_header'); ?>	<items>		<rdf:Seq>		<?php while (have_posts()): the_post(); ?>			<rdf:li rdf:resource="<?php the_permalink_rss() ?>"/>		<?php endwhile; ?>		</rdf:Seq>	</items></channel><?php rewind_posts(); while (have_posts()): the_post(); ?><item rdf:about="<?php the_permalink_rss() ?>">	<title><?php the_title_rss() ?></title>	<link><?php the_permalink_rss() ?></link>	 <dc:date><?php echo mysql2date('Y-m-d\TH:i:s\Z', $post->post_date_gmt, false); ?></dc:date>	<dc:creator><?php the_author() ?></dc:creator>	<?php the_category_rss('rdf') ?><?php if (get_option('rss_use_excerpt')) : ?>	<description><?php the_excerpt_rss() ?></description><?php else : ?>	<description><?php the_excerpt_rss() ?></description>	<content:encoded><![CDATA[<?php the_content_feed('rdf') ?>]]></content:encoded><?php endif; ?>	<?php do_action('rdf_item'); ?></item><?php endwhile;  ?></rdf:RDF>
<?php/** * Simple and uniform HTTP request API. * * Standardizes the HTTP requests for WordPress. Handles cookies, gzip encoding and decoding, chunk * decoding, if HTTP 1.1 and various other difficult HTTP protocol implementations. * * @link http://trac.wordpress.org/ticket/4779 HTTP API Proposal * * @package WordPress * @subpackage HTTP * @since 2.7.0 *//** * WordPress HTTP Class for managing HTTP Transports and making HTTP requests. * * This class is called for the functionality of making HTTP requests and replaces Snoopy * functionality. There is no available functionality to add HTTP transport implementations, since * most of the HTTP transports are added and available for use. * * There are no properties, because none are needed and for performance reasons. Some of the * functions are static and while they do have some overhead over functions in PHP4, the purpose is * maintainability. When PHP5 is finally the requirement, it will be easy to add the static keyword * to the code. It is not as easy to convert a function to a method after enough code uses the old * way. * * Debugging includes several actions, which pass different variables for debugging the HTTP API. * * <strong>http_transport_get_debug</strong> - gives working, nonblocking, and blocking transports. * * <strong>http_transport_post_debug</strong> - gives working, nonblocking, and blocking transports. * * @package WordPress * @subpackage HTTP * @since 2.7.0 */class WP_Http {	/**	 * PHP4 style Constructor - Calls PHP5 Style Constructor	 *	 * @since 2.7.0	 * @return WP_Http	 */	function WP_Http() {		$this->__construct();	}	/**	 * PHP5 style Constructor - Set up available transport if not available.	 *	 * PHP4 does not have the 'self' keyword and since WordPress supports PHP4, the class needs to	 * be used for the static call. The transport are set up to save time and will only be created	 * once. This class can be created many times without having to go through the step of finding	 * which transports are available.	 *	 * @since 2.7.0	 * @return WP_Http	 */	function __construct() {		WP_Http::_getTransport();		WP_Http::_postTransport();	}	/**	 * Tests the WordPress HTTP objects for an object to use and returns it.	 *	 * Tests all of the objects and returns the object that passes. Also caches that object to be	 * used later.	 *	 * The order for the GET/HEAD requests are HTTP Extension, cURL, Streams, Fopen, and finally	 * Fsockopen. fsockopen() is used last, because it has the most overhead in its implementation.	 * There isn't any real way around it, since redirects have to be supported, much the same way	 * the other transports also handle redirects.	 *	 * There are currently issues with "localhost" not resolving correctly with DNS. This may cause	 * an error "failed to open stream: A connection attempt failed because the connected party did	 * not properly respond after a period of time, or established connection failed because [the]	 * connected host has failed to respond."	 *	 * @since 2.7.0	 * @access private	 *	 * @param array $args Request args, default us an empty array	 * @return object|null Null if no transports are available, HTTP transport object.	 */	function &_getTransport( $args = array() ) {		static $working_transport, $blocking_transport, $nonblocking_transport;		if ( is_null($working_transport) ) {			if ( true === WP_Http_ExtHttp::test($args) ) {				$working_transport['exthttp'] = new WP_Http_ExtHttp();				$blocking_transport[] = &$working_transport['exthttp'];			} else if ( true === WP_Http_Curl::test($args) ) {				$working_transport['curl'] = new WP_Http_Curl();				$blocking_transport[] = &$working_transport['curl'];			} else if ( true === WP_Http_Streams::test($args) ) {				$working_transport['streams'] = new WP_Http_Streams();				$blocking_transport[] = &$working_transport['streams'];			} else if ( true === WP_Http_Fopen::test($args) ) {				$working_transport['fopen'] = new WP_Http_Fopen();				$blocking_transport[] = &$working_transport['fopen'];			} else if ( true === WP_Http_Fsockopen::test($args) ) {				$working_transport['fsockopen'] = new WP_Http_Fsockopen();				$blocking_transport[] = &$working_transport['fsockopen'];			}			foreach ( array('curl', 'streams', 'fopen', 'fsockopen', 'exthttp') as $transport ) {				if ( isset($working_transport[$transport]) )					$nonblocking_transport[] = &$working_transport[$transport];			}		}		do_action( 'http_transport_get_debug', $working_transport, $blocking_transport, $nonblocking_transport );		if ( isset($args['blocking']) && !$args['blocking'] )			return $nonblocking_transport;		else			return $blocking_transport;	}	/**	 * Tests the WordPress HTTP objects for an object to use and returns it.	 *	 * Tests all of the objects and returns the object that passes. Also caches	 * that object to be used later. This is for posting content to a URL and	 * is used when there is a body. The plain Fopen Transport can not be used	 * to send content, but the streams transport can. This is a limitation that	 * is addressed here, by just not including that transport.	 *	 * @since 2.7.0	 * @access private	 *	 * @param array $args Request args, default us an empty array	 * @return object|null Null if no transports are available, HTTP transport object.	 */	function &_postTransport( $args = array() ) {		static $working_transport, $blocking_transport, $nonblocking_transport;		if ( is_null($working_transport) ) {			if ( true === WP_Http_ExtHttp::test($args) ) {				$working_transport['exthttp'] = new WP_Http_ExtHttp();				$blocking_transport[] = &$working_transport['exthttp'];			} else if ( true === WP_Http_Curl::test($args) ) {				$working_transport['curl'] = new WP_Http_Curl();				$blocking_transport[] = &$working_transport['curl'];			} else if ( true === WP_Http_Streams::test($args) ) {				$working_transport['streams'] = new WP_Http_Streams();				$blocking_transport[] = &$working_transport['streams'];			} else if ( true === WP_Http_Fsockopen::test($args) ) {				$working_transport['fsockopen'] = new WP_Http_Fsockopen();				$blocking_transport[] = &$working_transport['fsockopen'];			}			foreach ( array('curl', 'streams', 'fsockopen', 'exthttp') as $transport ) {				if ( isset($working_transport[$transport]) )					$nonblocking_transport[] = &$working_transport[$transport];			}		}		do_action( 'http_transport_post_debug', $working_transport, $blocking_transport, $nonblocking_transport );		if ( isset($args['blocking']) && !$args['blocking'] )			return $nonblocking_transport;		else			return $blocking_transport;	}	/**	 * Send a HTTP request to a URI.	 *	 * The body and headers are part of the arguments. The 'body' argument is for the body and will	 * accept either a string or an array. The 'headers' argument should be an array, but a string	 * is acceptable. If the 'body' argument is an array, then it will automatically be escaped	 * using http_build_query().	 *	 * The only URI that are supported in the HTTP Transport implementation are the HTTP and HTTPS	 * protocols. HTTP and HTTPS are assumed so the server might not know how to handle the send	 * headers. Other protocols are unsupported and most likely will fail.	 *	 * The defaults are 'method', 'timeout', 'redirection', 'httpversion', 'blocking' and	 * 'user-agent'.	 *	 * Accepted 'method' values are 'GET', 'POST', and 'HEAD', some transports technically allow	 * others, but should not be assumed. The 'timeout' is used to sent how long the connection	 * should stay open before failing when no response. 'redirection' is used to track how many	 * redirects were taken and used to sent the amount for other transports, but not all transports	 * accept setting that value.	 *	 * The 'httpversion' option is used to sent the HTTP version and accepted values are '1.0', and	 * '1.1' and should be a string. Version 1.1 is not supported, because of chunk response. The	 * 'user-agent' option is the user-agent and is used to replace the default user-agent, which is	 * 'WordPress/WP_Version', where WP_Version is the value from $wp_version.	 *	 * 'blocking' is the default, which is used to tell the transport, whether it should halt PHP	 * while it performs the request or continue regardless. Actually, that isn't entirely correct.	 * Blocking mode really just means whether the fread should just pull what it can whenever it	 * gets bytes or if it should wait until it has enough in the buffer to read or finishes reading	 * the entire content. It doesn't actually always mean that PHP will continue going after making	 * the request.	 *	 * @access public	 * @since 2.7.0	 * @todo Refactor this code. The code in this method extends the scope of its original purpose	 *		and should be refactored to allow for cleaner abstraction and reduce duplication of the	 *		code. One suggestion is to create a class specifically for the arguments, however	 *		preliminary refactoring to this affect has affect more than just the scope of the	 *		arguments. Something to ponder at least.	 *	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return array containing 'headers', 'body', 'response', 'cookies'	 */	function request( $url, $args = array() ) {		global $wp_version;		$defaults = array(			'method' => 'GET',			'timeout' => apply_filters( 'http_request_timeout', 5),			'redirection' => apply_filters( 'http_request_redirection_count', 5),			'httpversion' => apply_filters( 'http_request_version', '1.0'),			'user-agent' => apply_filters( 'http_headers_useragent', 'WordPress/' . $wp_version . '; ' . get_bloginfo( 'url' )  ),			'blocking' => true,			'headers' => array(),			'cookies' => array(),			'body' => null,			'compress' => false,			'decompress' => true,			'sslverify' => true		);		$r = wp_parse_args( $args, $defaults );		$r = apply_filters( 'http_request_args', $r, $url );		// Allow plugins to short-circuit the request		$pre = apply_filters( 'pre_http_request', false, $r, $url );		if ( false !== $pre )			return $pre;		$arrURL = parse_url($url);		if ( empty( $url ) || empty($url['scheme'] ) )			return new WP_Error('http_request_failed', __('A valid URL was not provided.'));		if ( $this->block_request( $url ) )			return new WP_Error('http_request_failed', __('User has blocked requests through HTTP.'));		// Determine if this is a https call and pass that on to the transport functions		// so that we can blacklist the transports that do not support ssl verification		$r['ssl'] = $arrURL['scheme'] == 'https' || $arrURL['scheme'] == 'ssl';		// Determine if this request is to OUR install of WordPress		$homeURL = parse_url( get_bloginfo('url') );		$r['local'] = $homeURL['host'] == $arrURL['host'] || 'localhost' == $arrURL['host'];		unset($homeURL);		if ( is_null( $r['headers'] ) )			$r['headers'] = array();		if ( ! is_array($r['headers']) ) {			$processedHeaders = WP_Http::processHeaders($r['headers']);			$r['headers'] = $processedHeaders['headers'];		}		if ( isset($r['headers']['User-Agent']) ) {			$r['user-agent'] = $r['headers']['User-Agent'];			unset($r['headers']['User-Agent']);		}		if ( isset($r['headers']['user-agent']) ) {			$r['user-agent'] = $r['headers']['user-agent'];			unset($r['headers']['user-agent']);		}		// Construct Cookie: header if any cookies are set		WP_Http::buildCookieHeader( $r );		if ( WP_Http_Encoding::is_available() )			$r['headers']['Accept-Encoding'] = WP_Http_Encoding::accept_encoding();		if ( empty($r['body']) ) {			// Some servers fail when sending content without the content-length header being set.			// Also, to fix another bug, we only send when doing POST and PUT and the content-length			// header isn't already set.			if( ($r['method'] == 'POST' || $r['method'] == 'PUT') && ! isset($r['headers']['Content-Length']) )				$r['headers']['Content-Length'] = 0;			// The method is ambiguous, because we aren't talking about HTTP methods, the "get" in			// this case is simply that we aren't sending any bodies and to get the transports that			// don't support sending bodies along with those which do.			$transports = WP_Http::_getTransport($r);		} else {			if ( is_array( $r['body'] ) || is_object( $r['body'] ) ) {				if ( ! version_compare(phpversion(), '5.1.2', '>=') )					$r['body'] = _http_build_query($r['body'], null, '&');				else					$r['body'] = http_build_query($r['body'], null, '&');				$r['headers']['Content-Type'] = 'application/x-www-form-urlencoded; charset=' . get_option('blog_charset');				$r['headers']['Content-Length'] = strlen($r['body']);			}			if ( ! isset( $r['headers']['Content-Length'] ) && ! isset( $r['headers']['content-length'] ) )				$r['headers']['Content-Length'] = strlen($r['body']);			// The method is ambiguous, because we aren't talking about HTTP methods, the "post" in			// this case is simply that we are sending HTTP body and to get the transports that do			// support sending the body. Not all do, depending on the limitations of the PHP core			// limitations.			$transports = WP_Http::_postTransport($r);		}		do_action( 'http_api_debug', $transports, 'transports_list' );		$response = array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		foreach ( (array) $transports as $transport ) {			$response = $transport->request($url, $r);			do_action( 'http_api_debug', $response, 'response', get_class($transport) );			if ( ! is_wp_error($response) )				return apply_filters( 'http_response', $response, $r, $url );		}		return $response;	}	/**	 * Uses the POST HTTP method.	 *	 * Used for sending data that is expected to be in the body.	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return boolean	 */	function post($url, $args = array()) {		$defaults = array('method' => 'POST');		$r = wp_parse_args( $args, $defaults );		return $this->request($url, $r);	}	/**	 * Uses the GET HTTP method.	 *	 * Used for sending data that is expected to be in the body.	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return boolean	 */	function get($url, $args = array()) {		$defaults = array('method' => 'GET');		$r = wp_parse_args( $args, $defaults );		return $this->request($url, $r);	}	/**	 * Uses the HEAD HTTP method.	 *	 * Used for sending data that is expected to be in the body.	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return boolean	 */	function head($url, $args = array()) {		$defaults = array('method' => 'HEAD');		$r = wp_parse_args( $args, $defaults );		return $this->request($url, $r);	}	/**	 * Parses the responses and splits the parts into headers and body.	 *	 * @access public	 * @static	 * @since 2.7.0	 *	 * @param string $strResponse The full response string	 * @return array Array with 'headers' and 'body' keys.	 */	function processResponse($strResponse) {		$res = explode("\r\n\r\n", $strResponse, 2);		return array('headers' => isset($res[0]) ? $res[0] : array(), 'body' => isset($res[1]) ? $res[1] : '');	}	/**	 * Transform header string into an array.	 *	 * If an array is given then it is assumed to be raw header data with numeric keys with the	 * headers as the values. No headers must be passed that were already processed.	 *	 * @access public	 * @static	 * @since 2.7.0	 *	 * @param string|array $headers	 * @return array Processed string headers. If duplicate headers are encountered,	 * 					Then a numbered array is returned as the value of that header-key.	 */	function processHeaders($headers) {		// split headers, one per array element		if ( is_string($headers) ) {			// tolerate line terminator: CRLF = LF (RFC 2616 19.3)			$headers = str_replace("\r\n", "\n", $headers);			// unfold folded header fields. LWS = [CRLF] 1*( SP | HT ) <US-ASCII SP, space (32)>, <US-ASCII HT, horizontal-tab (9)> (RFC 2616 2.2)			$headers = preg_replace('/\n[ \t]/', ' ', $headers);			// create the headers array			$headers = explode("\n", $headers);		}		$response = array('code' => 0, 'message' => '');		// If a redirection has taken place, The headers for each page request may have been passed.		// In this case, determine the final HTTP header and parse from there.		for ( $i = count($headers)-1; $i >= 0; $i-- ) {			if ( !empty($headers[$i]) && false === strpos($headers[$i], ':') ) {				$headers = array_splice($headers, $i);				break;			}		}		$cookies = array();		$newheaders = array();		foreach ( $headers as $tempheader ) {			if ( empty($tempheader) )				continue;			if ( false === strpos($tempheader, ':') ) {				list( , $response['code'], $response['message']) = explode(' ', $tempheader, 3);				continue;			}			list($key, $value) = explode(':', $tempheader, 2);			if ( !empty( $value ) ) {				$key = strtolower( $key );				if ( isset( $newheaders[$key] ) ) {					if ( !is_array($newheaders[$key]) )						$newheaders[$key] = array($newheaders[$key]);					$newheaders[$key][] = trim( $value );				} else {					$newheaders[$key] = trim( $value );				}				if ( 'set-cookie' == strtolower( $key ) )					$cookies[] = new WP_Http_Cookie( $value );			}		}		return array('response' => $response, 'headers' => $newheaders, 'cookies' => $cookies);	}	/**	 * Takes the arguments for a ::request() and checks for the cookie array.	 *	 * If it's found, then it's assumed to contain WP_Http_Cookie objects, which are each parsed	 * into strings and added to the Cookie: header (within the arguments array). Edits the array by	 * reference.	 *	 * @access public	 * @version 2.8.0	 * @static	 *	 * @param array $r Full array of args passed into ::request()	 */	function buildCookieHeader( &$r ) {		if ( ! empty($r['cookies']) ) {			$cookies_header = '';			foreach ( (array) $r['cookies'] as $cookie ) {				$cookies_header .= $cookie->getHeaderValue() . '; ';			}			$cookies_header = substr( $cookies_header, 0, -2 );			$r['headers']['cookie'] = $cookies_header;		}	}	/**	 * Decodes chunk transfer-encoding, based off the HTTP 1.1 specification.	 *	 * Based off the HTTP http_encoding_dechunk function. Does not support UTF-8. Does not support	 * returning footer headers. Shouldn't be too difficult to support it though.	 *	 * @todo Add support for footer chunked headers.	 * @access public	 * @since 2.7.0	 * @static	 *	 * @param string $body Body content	 * @return string Chunked decoded body on success or raw body on failure.	 */	function chunkTransferDecode($body) {		$body = str_replace(array("\r\n", "\r"), "\n", $body);		// The body is not chunked encoding or is malformed.		if ( ! preg_match( '/^[0-9a-f]+(\s|\n)+/mi', trim($body) ) )			return $body;		$parsedBody = '';		//$parsedHeaders = array(); Unsupported		while ( true ) {			$hasChunk = (bool) preg_match( '/^([0-9a-f]+)(\s|\n)+/mi', $body, $match );			if ( $hasChunk ) {				if ( empty( $match[1] ) )					return $body;				$length = hexdec( $match[1] );				$chunkLength = strlen( $match[0] );				$strBody = substr($body, $chunkLength, $length);				$parsedBody .= $strBody;				$body = ltrim(str_replace(array($match[0], $strBody), '', $body), "\n");				if ( "0" == trim($body) )					return $parsedBody; // Ignore footer headers.			} else {				return $body;			}		}	}	/**	 * Block requests through the proxy.	 *	 * Those who are behind a proxy and want to prevent access to certain hosts may do so. This will	 * prevent plugins from working and core functionality, if you don't include api.wordpress.org.	 *	 * You block external URL requests by defining WP_HTTP_BLOCK_EXTERNAL as true in your wp-config.php	 * file and this will only allow localhost and your blog to make requests. The constant	 * WP_ACCESSIBLE_HOSTS will allow additional hosts to go through for requests. The format of the	 * WP_ACCESSIBLE_HOSTS constant is a comma separated list of hostnames to allow.	 *	 * @since 2.8.0	 * @link http://core.trac.wordpress.org/ticket/8927 Allow preventing external requests.	 *	 * @param string $uri URI of url.	 * @return bool True to block, false to allow.	 */	function block_request($uri) {		// We don't need to block requests, because nothing is blocked.		if ( ! defined( 'WP_HTTP_BLOCK_EXTERNAL' ) || ! WP_HTTP_BLOCK_EXTERNAL )			return false;		// parse_url() only handles http, https type URLs, and will emit E_WARNING on failure.		// This will be displayed on blogs, which is not reasonable.		$check = @parse_url($uri);		/* Malformed URL, can not process, but this could mean ssl, so let through anyway.		 *		 * This isn't very security sound. There are instances where a hacker might attempt		 * to bypass the proxy and this check. However, the reason for this behavior is that		 * WordPress does not do any checking currently for non-proxy requests, so it is keeps with		 * the default unsecure nature of the HTTP request.		 */		if ( $check === false )			return false;		$home = parse_url( get_option('siteurl') );		// Don't block requests back to ourselves by default		if ( $check['host'] == 'localhost' || $check['host'] == $home['host'] )			return apply_filters('block_local_requests', false);		if ( !defined('WP_ACCESSIBLE_HOSTS') )			return true;		static $accessible_hosts;		if ( null == $accessible_hosts )			$accessible_hosts = preg_split('|,\s*|', WP_ACCESSIBLE_HOSTS);		return !in_array( $check['host'], $accessible_hosts ); //Inverse logic, If its in the array, then we can't access it.	}}/** * HTTP request method uses fsockopen function to retrieve the url. * * This would be the preferred method, but the fsockopen implementation has the most overhead of all * the HTTP transport implementations. * * @package WordPress * @subpackage HTTP * @since 2.7.0 */class WP_Http_Fsockopen {	/**	 * Send a HTTP request to a URI using fsockopen().	 *	 * Does not support non-blocking mode.	 *	 * @see WP_Http::request For default options descriptions.	 *	 * @since 2.7	 * @access public	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return array 'headers', 'body', 'cookies' and 'response' keys.	 */	function request($url, $args = array()) {		$defaults = array(			'method' => 'GET', 'timeout' => 5,			'redirection' => 5, 'httpversion' => '1.0',			'blocking' => true,			'headers' => array(), 'body' => null, 'cookies' => array()		);		$r = wp_parse_args( $args, $defaults );		if ( isset($r['headers']['User-Agent']) ) {			$r['user-agent'] = $r['headers']['User-Agent'];			unset($r['headers']['User-Agent']);		} else if( isset($r['headers']['user-agent']) ) {			$r['user-agent'] = $r['headers']['user-agent'];			unset($r['headers']['user-agent']);		}		// Construct Cookie: header if any cookies are set		WP_Http::buildCookieHeader( $r );		$iError = null; // Store error number		$strError = null; // Store error string		$arrURL = parse_url($url);		$fsockopen_host = $arrURL['host'];		$secure_transport = false;		if ( ! isset( $arrURL['port'] ) ) {			if ( ( $arrURL['scheme'] == 'ssl' || $arrURL['scheme'] == 'https' ) && extension_loaded('openssl') ) {				$fsockopen_host = "ssl://$fsockopen_host";				$arrURL['port'] = 443;				$secure_transport = true;			} else {				$arrURL['port'] = 80;			}		}		//fsockopen has issues with 'localhost' with IPv6 with certain versions of PHP, It attempts to connect to ::1,		// which fails when the server is not set up for it. For compatibility, always connect to the IPv4 address.		if ( 'localhost' == strtolower($fsockopen_host) )			$fsockopen_host = '127.0.0.1';		// There are issues with the HTTPS and SSL protocols that cause errors that can be safely		// ignored and should be ignored.		if ( true === $secure_transport )			$error_reporting = error_reporting(0);		$startDelay = time();		$proxy = new WP_HTTP_Proxy();		if ( !WP_DEBUG ) {			if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) )				$handle = @fsockopen( $proxy->host(), $proxy->port(), $iError, $strError, $r['timeout'] );			else				$handle = @fsockopen( $fsockopen_host, $arrURL['port'], $iError, $strError, $r['timeout'] );		} else {			if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) )				$handle = fsockopen( $proxy->host(), $proxy->port(), $iError, $strError, $r['timeout'] );			else				$handle = fsockopen( $fsockopen_host, $arrURL['port'], $iError, $strError, $r['timeout'] );		}		$endDelay = time();		// If the delay is greater than the timeout then fsockopen should't be used, because it will		// cause a long delay.		$elapseDelay = ($endDelay-$startDelay) > $r['timeout'];		if ( true === $elapseDelay )			add_option( 'disable_fsockopen', $endDelay, null, true );		if ( false === $handle )			return new WP_Error('http_request_failed', $iError . ': ' . $strError);		$timeout = (int) floor( $r['timeout'] );		$utimeout = $timeout == $r['timeout'] ? 0 : 1000000 * $r['timeout'] % 1000000;		stream_set_timeout( $handle, $timeout, $utimeout );		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) //Some proxies require full URL in this field.			$requestPath = $url;		else			$requestPath = $arrURL['path'] . ( isset($arrURL['query']) ? '?' . $arrURL['query'] : '' );		if ( empty($requestPath) )			$requestPath .= '/';		$strHeaders = strtoupper($r['method']) . ' ' . $requestPath . ' HTTP/' . $r['httpversion'] . "\r\n";		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) )			$strHeaders .= 'Host: ' . $arrURL['host'] . ':' . $arrURL['port'] . "\r\n";		else			$strHeaders .= 'Host: ' . $arrURL['host'] . "\r\n";		if ( isset($r['user-agent']) )			$strHeaders .= 'User-agent: ' . $r['user-agent'] . "\r\n";		if ( is_array($r['headers']) ) {			foreach ( (array) $r['headers'] as $header => $headerValue )				$strHeaders .= $header . ': ' . $headerValue . "\r\n";		} else {			$strHeaders .= $r['headers'];		}		if ( $proxy->use_authentication() )			$strHeaders .= $proxy->authentication_header() . "\r\n";		$strHeaders .= "\r\n";		if ( ! is_null($r['body']) )			$strHeaders .= $r['body'];		fwrite($handle, $strHeaders);		if ( ! $r['blocking'] ) {			fclose($handle);			return array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		}		$strResponse = '';		while ( ! feof($handle) )			$strResponse .= fread($handle, 4096);		fclose($handle);		if ( true === $secure_transport )			error_reporting($error_reporting);		$process = WP_Http::processResponse($strResponse);		$arrHeaders = WP_Http::processHeaders($process['headers']);		// Is the response code within the 400 range?		if ( (int) $arrHeaders['response']['code'] >= 400 && (int) $arrHeaders['response']['code'] < 500 )			return new WP_Error('http_request_failed', $arrHeaders['response']['code'] . ': ' . $arrHeaders['response']['message']);		// If location is found, then assume redirect and redirect to location.		if ( 'HEAD' != $r['method'] && isset($arrHeaders['headers']['location']) ) {			if ( $r['redirection']-- > 0 ) {				return $this->request($arrHeaders['headers']['location'], $r);			} else {				return new WP_Error('http_request_failed', __('Too many redirects.'));			}		}		// If the body was chunk encoded, then decode it.		if ( ! empty( $process['body'] ) && isset( $arrHeaders['headers']['transfer-encoding'] ) && 'chunked' == $arrHeaders['headers']['transfer-encoding'] )			$process['body'] = WP_Http::chunkTransferDecode($process['body']);		if ( true === $r['decompress'] && true === WP_Http_Encoding::should_decode($arrHeaders['headers']) )			$process['body'] = WP_Http_Encoding::decompress( $process['body'] );		return array('headers' => $arrHeaders['headers'], 'body' => $process['body'], 'response' => $arrHeaders['response'], 'cookies' => $arrHeaders['cookies']);	}	/**	 * Whether this class can be used for retrieving an URL.	 *	 * @since 2.7.0	 * @static	 * @return boolean False means this class can not be used, true means it can.	 */	function test( $args = array() ) {		if ( false !== ($option = get_option( 'disable_fsockopen' )) && time()-$option < 43200 ) // 12 hours			return false;		$is_ssl = isset($args['ssl']) && $args['ssl'];		if ( ! $is_ssl && function_exists( 'fsockopen' ) )			$use = true;		elseif ( $is_ssl && extension_loaded('openssl') && function_exists( 'fsockopen' ) )			$use = true;		else			$use = false;		return apply_filters('use_fsockopen_transport', $use, $args);	}}/** * HTTP request method uses fopen function to retrieve the url. * * Requires PHP version greater than 4.3.0 for stream support. Does not allow for $context support, * but should still be okay, to write the headers, before getting the response. Also requires that * 'allow_url_fopen' to be enabled. * * @package WordPress * @subpackage HTTP * @since 2.7.0 */class WP_Http_Fopen {	/**	 * Send a HTTP request to a URI using fopen().	 *	 * This transport does not support sending of headers and body, therefore should not be used in	 * the instances, where there is a body and headers.	 *	 * Notes: Does not support non-blocking mode. Ignores 'redirection' option.	 *	 * @see WP_Http::retrieve For default options descriptions.	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url URI resource.	 * @param str|array $args Optional. Override the defaults.	 * @return array 'headers', 'body', 'cookies' and 'response' keys.	 */	function request($url, $args = array()) {		$defaults = array(			'method' => 'GET', 'timeout' => 5,			'redirection' => 5, 'httpversion' => '1.0',			'blocking' => true,			'headers' => array(), 'body' => null, 'cookies' => array()		);		$r = wp_parse_args( $args, $defaults );		$arrURL = parse_url($url);		if ( false === $arrURL )			return new WP_Error('http_request_failed', sprintf(__('Malformed URL: %s'), $url));		if ( 'http' != $arrURL['scheme'] && 'https' != $arrURL['scheme'] )			$url = str_replace($arrURL['scheme'], 'http', $url);		if ( is_null( $r['headers'] ) )			$r['headers'] = array();		if ( is_string($r['headers']) ) {			$processedHeaders = WP_Http::processHeaders($r['headers']);			$r['headers'] = $processedHeaders['headers'];		}		$initial_user_agent = ini_get('user_agent');		if ( !empty($r['headers']) && is_array($r['headers']) ) {			$user_agent_extra_headers = '';			foreach ( $r['headers'] as $header => $value )				$user_agent_extra_headers .= "\r\n$header: $value";			@ini_set('user_agent', $r['user-agent'] . $user_agent_extra_headers);		} else {			@ini_set('user_agent', $r['user-agent']);		}		if ( !WP_DEBUG )			$handle = @fopen($url, 'r');		else			$handle = fopen($url, 'r');		if (! $handle)			return new WP_Error('http_request_failed', sprintf(__('Could not open handle for fopen() to %s'), $url));		$timeout = (int) floor( $r['timeout'] );		$utimeout = $timeout == $r['timeout'] ? 0 : 1000000 * $r['timeout'] % 1000000;		stream_set_timeout( $handle, $timeout, $utimeout );		if ( ! $r['blocking'] ) {			fclose($handle);			@ini_set('user_agent', $initial_user_agent); //Clean up any extra headers added			return array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		}		$strResponse = '';		while ( ! feof($handle) )			$strResponse .= fread($handle, 4096);		if ( function_exists('stream_get_meta_data') ) {			$meta = stream_get_meta_data($handle);			$theHeaders = $meta['wrapper_data'];			if ( isset( $meta['wrapper_data']['headers'] ) )				$theHeaders = $meta['wrapper_data']['headers'];		} else {			//$http_response_header is a PHP reserved variable which is set in the current-scope when using the HTTP Wrapper			//see http://php.oregonstate.edu/manual/en/reserved.variables.httpresponseheader.php			$theHeaders = $http_response_header;		}		fclose($handle);		@ini_set('user_agent', $initial_user_agent); //Clean up any extra headers added		$processedHeaders = WP_Http::processHeaders($theHeaders);		if ( ! empty( $strResponse ) && isset( $processedHeaders['headers']['transfer-encoding'] ) && 'chunked' == $processedHeaders['headers']['transfer-encoding'] )			$strResponse = WP_Http::chunkTransferDecode($strResponse);		if ( true === $r['decompress'] && true === WP_Http_Encoding::should_decode($processedHeaders['headers']) )			$strResponse = WP_Http_Encoding::decompress( $strResponse );		return array('headers' => $processedHeaders['headers'], 'body' => $strResponse, 'response' => $processedHeaders['response'], 'cookies' => $processedHeaders['cookies']);	}	/**	 * Whether this class can be used for retrieving an URL.	 *	 * @since 2.7.0	 * @static	 * @return boolean False means this class can not be used, true means it can.	 */	function test($args = array()) {		if ( ! function_exists('fopen') || (function_exists('ini_get') && true != ini_get('allow_url_fopen')) )			return false;		if ( isset($args['method']) && 'HEAD' == $args['method'] ) //This transport cannot make a HEAD request			return false;		$use = true;		//PHP does not verify SSL certs, We can only make a request via this transports if SSL Verification is turned off.		$is_ssl = isset($args['ssl']) && $args['ssl'];		if ( $is_ssl ) {			$is_local = isset($args['local']) && $args['local'];			$ssl_verify = isset($args['sslverify']) && $args['sslverify'];			if ( $is_local && true != apply_filters('https_local_ssl_verify', true) )				$use = true;			elseif ( !$is_local && true != apply_filters('https_ssl_verify', true) )				$use = true;			elseif ( !$ssl_verify )				$use = true;			else				$use = false;		}		return apply_filters('use_fopen_transport', $use, $args);	}}/** * HTTP request method uses Streams to retrieve the url. * * Requires PHP 5.0+ and uses fopen with stream context. Requires that 'allow_url_fopen' PHP setting * to be enabled. * * Second preferred method for getting the URL, for PHP 5. * * @package WordPress * @subpackage HTTP * @since 2.7.0 */class WP_Http_Streams {	/**	 * Send a HTTP request to a URI using streams with fopen().	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url	 * @param str|array $args Optional. Override the defaults.	 * @return array 'headers', 'body', 'cookies' and 'response' keys.	 */	function request($url, $args = array()) {		$defaults = array(			'method' => 'GET', 'timeout' => 5,			'redirection' => 5, 'httpversion' => '1.0',			'blocking' => true,			'headers' => array(), 'body' => null, 'cookies' => array()		);		$r = wp_parse_args( $args, $defaults );		if ( isset($r['headers']['User-Agent']) ) {			$r['user-agent'] = $r['headers']['User-Agent'];			unset($r['headers']['User-Agent']);		} else if( isset($r['headers']['user-agent']) ) {			$r['user-agent'] = $r['headers']['user-agent'];			unset($r['headers']['user-agent']);		}		// Construct Cookie: header if any cookies are set		WP_Http::buildCookieHeader( $r );		$arrURL = parse_url($url);		if ( false === $arrURL )			return new WP_Error('http_request_failed', sprintf(__('Malformed URL: %s'), $url));		if ( 'http' != $arrURL['scheme'] && 'https' != $arrURL['scheme'] )			$url = preg_replace('|^' . preg_quote($arrURL['scheme'], '|') . '|', 'http', $url);		// Convert Header array to string.		$strHeaders = '';		if ( is_array( $r['headers'] ) )			foreach ( $r['headers'] as $name => $value )				$strHeaders .= "{$name}: $value\r\n";		else if ( is_string( $r['headers'] ) )			$strHeaders = $r['headers'];		$is_local = isset($args['local']) && $args['local'];		$ssl_verify = isset($args['sslverify']) && $args['sslverify'];		if ( $is_local )			$ssl_verify = apply_filters('https_local_ssl_verify', $ssl_verify);		elseif ( ! $is_local )			$ssl_verify = apply_filters('https_ssl_verify', $ssl_verify);		$arrContext = array('http' =>			array(				'method' => strtoupper($r['method']),				'user_agent' => $r['user-agent'],				'max_redirects' => $r['redirection'] + 1, // See #11557				'protocol_version' => (float) $r['httpversion'],				'header' => $strHeaders,				'ignore_errors' => true, // Return non-200 requests.				'timeout' => $r['timeout'],				'ssl' => array(						'verify_peer' => $ssl_verify,						'verify_host' => $ssl_verify				)			)		);		$proxy = new WP_HTTP_Proxy();		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) {			$arrContext['http']['proxy'] = 'tcp://' . $proxy->host() . ':' . $proxy->port();			$arrContext['http']['request_fulluri'] = true;			// We only support Basic authentication so this will only work if that is what your proxy supports.			if ( $proxy->use_authentication() )				$arrContext['http']['header'] .= $proxy->authentication_header() . "\r\n";		}		if ( 'HEAD' == $r['method'] ) // Disable redirects for HEAD requests			$arrContext['http']['max_redirects'] = 1;		if ( ! empty($r['body'] ) )			$arrContext['http']['content'] = $r['body'];		$context = stream_context_create($arrContext);		if ( !WP_DEBUG )			$handle = @fopen($url, 'r', false, $context);		else			$handle = fopen($url, 'r', false, $context);		if ( ! $handle )			return new WP_Error('http_request_failed', sprintf(__('Could not open handle for fopen() to %s'), $url));		$timeout = (int) floor( $r['timeout'] );		$utimeout = $timeout == $r['timeout'] ? 0 : 1000000 * $r['timeout'] % 1000000;		stream_set_timeout( $handle, $timeout, $utimeout );		if ( ! $r['blocking'] ) {			stream_set_blocking($handle, 0);			fclose($handle);			return array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		}		$strResponse = stream_get_contents($handle);		$meta = stream_get_meta_data($handle);		fclose($handle);		$processedHeaders = array();		if ( isset( $meta['wrapper_data']['headers'] ) )			$processedHeaders = WP_Http::processHeaders($meta['wrapper_data']['headers']);		else			$processedHeaders = WP_Http::processHeaders($meta['wrapper_data']);		if ( ! empty( $strResponse ) && isset( $processedHeaders['headers']['transfer-encoding'] ) && 'chunked' == $processedHeaders['headers']['transfer-encoding'] )			$strResponse = WP_Http::chunkTransferDecode($strResponse);		if ( true === $r['decompress'] && true === WP_Http_Encoding::should_decode($processedHeaders['headers']) )			$strResponse = WP_Http_Encoding::decompress( $strResponse );		return array('headers' => $processedHeaders['headers'], 'body' => $strResponse, 'response' => $processedHeaders['response'], 'cookies' => $processedHeaders['cookies']);	}	/**	 * Whether this class can be used for retrieving an URL.	 *	 * @static	 * @access public	 * @since 2.7.0	 *	 * @return boolean False means this class can not be used, true means it can.	 */	function test($args = array()) {		if ( ! function_exists('fopen') || (function_exists('ini_get') && true != ini_get('allow_url_fopen')) )			return false;		if ( version_compare(PHP_VERSION, '5.0', '<') )			return false;		//HTTPS via Proxy was added in 5.1.0		$is_ssl = isset($args['ssl']) && $args['ssl'];		if ( $is_ssl && version_compare(PHP_VERSION, '5.1.0', '<') ) {			$proxy = new WP_HTTP_Proxy();			/**			 * No URL check, as its not currently passed to the ::test() function			 * In the case where a Proxy is in use, Just bypass this transport for HTTPS.			 */			if ( $proxy->is_enabled() )				return false;		}		return apply_filters('use_streams_transport', true, $args);	}}/** * HTTP request method uses HTTP extension to retrieve the url. * * Requires the HTTP extension to be installed. This would be the preferred transport since it can * handle a lot of the problems that forces the others to use the HTTP version 1.0. Even if PHP 5.2+ * is being used, it doesn't mean that the HTTP extension will be enabled. * * @package WordPress * @subpackage HTTP * @since 2.7.0 */class WP_Http_ExtHTTP {	/**	 * Send a HTTP request to a URI using HTTP extension.	 *	 * Does not support non-blocking.	 *	 * @access public	 * @since 2.7	 *	 * @param string $url	 * @param str|array $args Optional. Override the defaults.	 * @return array 'headers', 'body', 'cookies' and 'response' keys.	 */	function request($url, $args = array()) {		$defaults = array(			'method' => 'GET', 'timeout' => 5,			'redirection' => 5, 'httpversion' => '1.0',			'blocking' => true,			'headers' => array(), 'body' => null, 'cookies' => array()		);		$r = wp_parse_args( $args, $defaults );		if ( isset($r['headers']['User-Agent']) ) {			$r['user-agent'] = $r['headers']['User-Agent'];			unset($r['headers']['User-Agent']);		} else if( isset($r['headers']['user-agent']) ) {			$r['user-agent'] = $r['headers']['user-agent'];			unset($r['headers']['user-agent']);		}		// Construct Cookie: header if any cookies are set		WP_Http::buildCookieHeader( $r );		switch ( $r['method'] ) {			case 'POST':				$r['method'] = HTTP_METH_POST;				break;			case 'HEAD':				$r['method'] = HTTP_METH_HEAD;				break;			case 'PUT':				$r['method'] =  HTTP_METH_PUT;				break;			case 'GET':			default:				$r['method'] = HTTP_METH_GET;		}		$arrURL = parse_url($url);		if ( 'http' != $arrURL['scheme'] && 'https' != $arrURL['scheme'] )			$url = preg_replace('|^' . preg_quote($arrURL['scheme'], '|') . '|', 'http', $url);		$is_local = isset($args['local']) && $args['local'];		$ssl_verify = isset($args['sslverify']) && $args['sslverify'];		if ( $is_local )			$ssl_verify = apply_filters('https_local_ssl_verify', $ssl_verify);		elseif ( ! $is_local )			$ssl_verify = apply_filters('https_ssl_verify', $ssl_verify);		$r['timeout'] = (int) ceil( $r['timeout'] );		$options = array(			'timeout' => $r['timeout'],			'connecttimeout' => $r['timeout'],			'redirect' => $r['redirection'],			'useragent' => $r['user-agent'],			'headers' => $r['headers'],			'ssl' => array(				'verifypeer' => $ssl_verify,				'verifyhost' => $ssl_verify			)		);		if ( HTTP_METH_HEAD == $r['method'] )			$options['redirect'] = 0; // Assumption: Docs seem to suggest that this means do not follow. Untested.		// The HTTP extensions offers really easy proxy support.		$proxy = new WP_HTTP_Proxy();		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) {			$options['proxyhost'] = $proxy->host();			$options['proxyport'] = $proxy->port();			$options['proxytype'] = HTTP_PROXY_HTTP;			if ( $proxy->use_authentication() ) {				$options['proxyauth'] = $proxy->authentication();				$options['proxyauthtype'] = HTTP_AUTH_ANY;			}		}		if ( !WP_DEBUG ) //Emits warning level notices for max redirects and timeouts			$strResponse = @http_request($r['method'], $url, $r['body'], $options, $info);		else			$strResponse = http_request($r['method'], $url, $r['body'], $options, $info); //Emits warning level notices for max redirects and timeouts		// Error may still be set, Response may return headers or partial document, and error		// contains a reason the request was aborted, eg, timeout expired or max-redirects reached.		if ( false === $strResponse || ! empty($info['error']) )			return new WP_Error('http_request_failed', $info['response_code'] . ': ' . $info['error']);		if ( ! $r['blocking'] )			return array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		$headers_body = WP_HTTP::processResponse($strResponse);		$theHeaders = $headers_body['headers'];		$theBody = $headers_body['body'];		unset($headers_body);		$theHeaders = WP_Http::processHeaders($theHeaders);		if ( ! empty( $theBody ) && isset( $theHeaders['headers']['transfer-encoding'] ) && 'chunked' == $theHeaders['headers']['transfer-encoding'] ) {			if ( !WP_DEBUG )				$theBody = @http_chunked_decode($theBody);			else				$theBody = http_chunked_decode($theBody);		}		if ( true === $r['decompress'] && true === WP_Http_Encoding::should_decode($theHeaders['headers']) )			$theBody = http_inflate( $theBody );		$theResponse = array();		$theResponse['code'] = $info['response_code'];		$theResponse['message'] = get_status_header_desc($info['response_code']);		return array('headers' => $theHeaders['headers'], 'body' => $theBody, 'response' => $theResponse, 'cookies' => $theHeaders['cookies']);	}	/**	 * Whether this class can be used for retrieving an URL.	 *	 * @static	 * @since 2.7.0	 *	 * @return boolean False means this class can not be used, true means it can.	 */	function test($args = array()) {		return apply_filters('use_http_extension_transport', function_exists('http_request'), $args );	}}/** * HTTP request method uses Curl extension to retrieve the url. * * Requires the Curl extension to be installed. * * @package WordPress * @subpackage HTTP * @since 2.7 */class WP_Http_Curl {	/**	 * Send a HTTP request to a URI using cURL extension.	 *	 * @access public	 * @since 2.7.0	 *	 * @param string $url	 * @param str|array $args Optional. Override the defaults.	 * @return array 'headers', 'body', 'cookies' and 'response' keys.	 */	function request($url, $args = array()) {		$defaults = array(			'method' => 'GET', 'timeout' => 5,			'redirection' => 5, 'httpversion' => '1.0',			'blocking' => true,			'headers' => array(), 'body' => null, 'cookies' => array()		);		$r = wp_parse_args( $args, $defaults );		if ( isset($r['headers']['User-Agent']) ) {			$r['user-agent'] = $r['headers']['User-Agent'];			unset($r['headers']['User-Agent']);		} else if( isset($r['headers']['user-agent']) ) {			$r['user-agent'] = $r['headers']['user-agent'];			unset($r['headers']['user-agent']);		}		// Construct Cookie: header if any cookies are set.		WP_Http::buildCookieHeader( $r );		$handle = curl_init();		// cURL offers really easy proxy support.		$proxy = new WP_HTTP_Proxy();		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) {			$isPHP5 = version_compare(PHP_VERSION, '5.0.0', '>=');			if ( $isPHP5 ) {				curl_setopt( $handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP );				curl_setopt( $handle, CURLOPT_PROXY, $proxy->host() );				curl_setopt( $handle, CURLOPT_PROXYPORT, $proxy->port() );			} else {				curl_setopt( $handle, CURLOPT_PROXY, $proxy->host() .':'. $proxy->port() );			}			if ( $proxy->use_authentication() ) {				if ( $isPHP5 )					curl_setopt( $handle, CURLOPT_PROXYAUTH, CURLAUTH_ANY );				curl_setopt( $handle, CURLOPT_PROXYUSERPWD, $proxy->authentication() );			}		}		$is_local = isset($args['local']) && $args['local'];		$ssl_verify = isset($args['sslverify']) && $args['sslverify'];		if ( $is_local )			$ssl_verify = apply_filters('https_local_ssl_verify', $ssl_verify);		elseif ( ! $is_local )			$ssl_verify = apply_filters('https_ssl_verify', $ssl_verify);		// CURLOPT_TIMEOUT and CURLOPT_CONNECTTIMEOUT expect integers.  Have to use ceil since		// a value of 0 will allow an ulimited timeout.		$timeout = (int) ceil( $r['timeout'] );		curl_setopt( $handle, CURLOPT_CONNECTTIMEOUT, $timeout );		curl_setopt( $handle, CURLOPT_TIMEOUT, $timeout );		curl_setopt( $handle, CURLOPT_URL, $url);		curl_setopt( $handle, CURLOPT_RETURNTRANSFER, true );		curl_setopt( $handle, CURLOPT_SSL_VERIFYHOST, $ssl_verify );		curl_setopt( $handle, CURLOPT_SSL_VERIFYPEER, $ssl_verify );		curl_setopt( $handle, CURLOPT_USERAGENT, $r['user-agent'] );		curl_setopt( $handle, CURLOPT_MAXREDIRS, $r['redirection'] );		switch ( $r['method'] ) {			case 'HEAD':				curl_setopt( $handle, CURLOPT_NOBODY, true );				break;			case 'POST':				curl_setopt( $handle, CURLOPT_POST, true );				curl_setopt( $handle, CURLOPT_POSTFIELDS, $r['body'] );				break;			case 'PUT':				curl_setopt( $handle, CURLOPT_CUSTOMREQUEST, 'PUT' );				curl_setopt( $handle, CURLOPT_POSTFIELDS, $r['body'] );				break;		}		if ( true === $r['blocking'] )			curl_setopt( $handle, CURLOPT_HEADER, true );		else			curl_setopt( $handle, CURLOPT_HEADER, false );		// The option doesn't work with safe mode or when open_basedir is set.		// Disable HEAD when making HEAD requests.		if ( !ini_get('safe_mode') && !ini_get('open_basedir') && 'HEAD' != $r['method'] )			curl_setopt( $handle, CURLOPT_FOLLOWLOCATION, true );		if ( !empty( $r['headers'] ) ) {			// cURL expects full header strings in each element			$headers = array();			foreach ( $r['headers'] as $name => $value ) {				$headers[] = "{$name}: $value";			}			curl_setopt( $handle, CURLOPT_HTTPHEADER, $headers );		}		if ( $r['httpversion'] == '1.0' )			curl_setopt( $handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0 );		else			curl_setopt( $handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1 );		// Cookies are not handled by the HTTP API currently. Allow for plugin authors to handle it		// themselves... Although, it is somewhat pointless without some reference.		do_action_ref_array( 'http_api_curl', array(&$handle) );		// We don't need to return the body, so don't. Just execute request and return.		if ( ! $r['blocking'] ) {			curl_exec( $handle );			curl_close( $handle );			return array( 'headers' => array(), 'body' => '', 'response' => array('code' => false, 'message' => false), 'cookies' => array() );		}		$theResponse = curl_exec( $handle );		if ( !empty($theResponse) ) {			$headerLength = curl_getinfo($handle, CURLINFO_HEADER_SIZE);			$theHeaders = trim( substr($theResponse, 0, $headerLength) );			if ( strlen($theResponse) > $headerLength )				$theBody = substr( $theResponse, $headerLength );			else				$theBody = '';			if ( false !== strrpos($theHeaders, "\r\n\r\n") ) {				$headerParts = explode("\r\n\r\n", $theHeaders);				$theHeaders = $headerParts[ count($headerParts) -1 ];			}			$theHeaders = WP_Http::processHeaders($theHeaders);		} else {			if ( $curl_error = curl_error($handle) )				return new WP_Error('http_request_failed', $curl_error);			if ( in_array( curl_getinfo( $handle, CURLINFO_HTTP_CODE ), array(301, 302) ) )				return new WP_Error('http_request_failed', __('Too many redirects.'));			$theHeaders = array( 'headers' => array(), 'cookies' => array() );			$theBody = '';		}		$response = array();		$response['code'] = curl_getinfo( $handle, CURLINFO_HTTP_CODE );		$response['message'] = get_status_header_desc($response['code']);		curl_close( $handle );		// See #11305 - When running under safe mode, redirection is disabled above. Handle it manually.		if ( !empty($theHeaders['headers']['location']) && (ini_get('safe_mode') || ini_get('open_basedir')) ) {			if ( $r['redirection']-- > 0 ) {				return $this->request($theHeaders['headers']['location'], $r);			} else {				return new WP_Error('http_request_failed', __('Too many redirects.'));			}		}		if ( true === $r['decompress'] && true === WP_Http_Encoding::should_decode($theHeaders['headers']) )			$theBody = WP_Http_Encoding::decompress( $theBody );		return array('headers' => $theHeaders['headers'], 'body' => $theBody, 'response' => $response, 'cookies' => $theHeaders['cookies']);	}	/**	 * Whether this class can be used for retrieving an URL.	 *	 * @static	 * @since 2.7.0	 *	 * @return boolean False means this class can not be used, true means it can.	 */	function test($args = array()) {		if ( function_exists('curl_init') && function_exists('curl_exec') )			return apply_filters('use_curl_transport', true, $args);		return false;	}}/** * Adds Proxy support to the WordPress HTTP API. * * There are caveats to proxy support. It requires that defines be made in the wp-config.php file to * enable proxy support. There are also a few filters that plugins can hook into for some of the * constants. * * Please note that only BASIC authentication is supported by most transports. * cURL and the PHP HTTP Extension MAY support more methods (such as NTLM authentication) depending on your environment. * * The constants are as follows: * <ol> * <li>WP_PROXY_HOST - Enable proxy support and host for connecting.</li> * <li>WP_PROXY_PORT - Proxy port for connection. No default, must be defined.</li> * <li>WP_PROXY_USERNAME - Proxy username, if it requires authentication.</li> * <li>WP_PROXY_PASSWORD - Proxy password, if it requires authentication.</li> * <li>WP_PROXY_BYPASS_HOSTS - Will prevent the hosts in this list from going through the proxy. * You do not need to have localhost and the blog host in this list, because they will not be passed * through the proxy. The list should be presented in a comma separated list</li> * </ol> * * An example can be as seen below. * <code> * define('WP_PROXY_HOST', '192.168.84.101'); * define('WP_PROXY_PORT', '8080'); * define('WP_PROXY_BYPASS_HOSTS', 'localhost, www.example.com'); * </code> * * @link http://core.trac.wordpress.org/ticket/4011 Proxy support ticket in WordPress. * @since 2.8 */class WP_HTTP_Proxy {	/**	 * Whether proxy connection should be used.	 *	 * @since 2.8	 * @use WP_PROXY_HOST	 * @use WP_PROXY_PORT	 *	 * @return bool	 */	function is_enabled() {		return defined('WP_PROXY_HOST') && defined('WP_PROXY_PORT');	}	/**	 * Whether authentication should be used.	 *	 * @since 2.8	 * @use WP_PROXY_USERNAME	 * @use WP_PROXY_PASSWORD	 *	 * @return bool	 */	function use_authentication() {		return defined('WP_PROXY_USERNAME') && defined('WP_PROXY_PASSWORD');	}	/**	 * Retrieve the host for the proxy server.	 *	 * @since 2.8	 *	 * @return string	 */	function host() {		if ( defined('WP_PROXY_HOST') )			return WP_PROXY_HOST;		return '';	}	/**	 * Retrieve the port for the proxy server.	 *	 * @since 2.8	 *	 * @return string	 */	function port() {		if ( defined('WP_PROXY_PORT') )			return WP_PROXY_PORT;		return '';	}	/**	 * Retrieve the username for proxy authentication.	 *	 * @since 2.8	 *	 * @return string	 */	function username() {		if ( defined('WP_PROXY_USERNAME') )			return WP_PROXY_USERNAME;		return '';	}	/**	 * Retrieve the password for proxy authentication.	 *	 * @since 2.8	 *	 * @return string	 */	function password() {		if ( defined('WP_PROXY_PASSWORD') )			return WP_PROXY_PASSWORD;		return '';	}	/**	 * Retrieve authentication string for proxy authentication.	 *	 * @since 2.8	 *	 * @return string	 */	function authentication() {		return $this->username() . ':' . $this->password();	}	/**	 * Retrieve header string for proxy authentication.	 *	 * @since 2.8	 *	 * @return string	 */	function authentication_header() {		return 'Proxy-Authorization: Basic ' . base64_encode( $this->authentication() );	}	/**	 * Whether URL should be sent through the proxy server.	 *	 * We want to keep localhost and the blog URL from being sent through the proxy server, because	 * some proxies can not handle this. We also have the constant available for defining other	 * hosts that won't be sent through the proxy.	 *	 * @uses WP_PROXY_BYPASS_HOSTS	 * @since unknown	 *	 * @param string $uri URI to check.	 * @return bool True, to send through the proxy and false if, the proxy should not be used.	 */	function send_through_proxy( $uri ) {		// parse_url() only handles http, https type URLs, and will emit E_WARNING on failure.		// This will be displayed on blogs, which is not reasonable.		$check = @parse_url($uri);		// Malformed URL, can not process, but this could mean ssl, so let through anyway.		if ( $check === false )			return true;		$home = parse_url( get_option('siteurl') );		if ( $check['host'] == 'localhost' || $check['host'] == $home['host'] )			return false;		if ( !defined('WP_PROXY_BYPASS_HOSTS') )			return true;		static $bypass_hosts;		if ( null == $bypass_hosts )			$bypass_hosts = preg_split('|,\s*|', WP_PROXY_BYPASS_HOSTS);		return !in_array( $check['host'], $bypass_hosts );	}}/** * Internal representation of a single cookie. * * Returned cookies are represented using this class, and when cookies are set, if they are not * already a WP_Http_Cookie() object, then they are turned into one. * * @todo The WordPress convention is to use underscores instead of camelCase for function and method * names. Need to switch to use underscores instead for the methods. * * @package WordPress * @subpackage HTTP * @since 2.8.0 */class WP_Http_Cookie {	/**	 * Cookie name.	 *	 * @since 2.8.0	 * @var string	 */	var $name;	/**	 * Cookie value.	 *	 * @since 2.8.0	 * @var string	 */	var $value;	/**	 * When the cookie expires.	 *	 * @since 2.8.0	 * @var string	 */	var $expires;	/**	 * Cookie URL path.	 *	 * @since 2.8.0	 * @var string	 */	var $path;	/**	 * Cookie Domain.	 *	 * @since 2.8.0	 * @var string	 */	var $domain;	/**	 * PHP4 style Constructor - Calls PHP5 Style Constructor.	 *	 * @access public	 * @since 2.8.0	 * @param string|array $data Raw cookie data.	 */	function WP_Http_Cookie( $data ) {		$this->__construct( $data );	}	/**	 * Sets up this cookie object.	 *	 * The parameter $data should be either an associative array containing the indices names below	 * or a header string detailing it.	 *	 * If it's an array, it should include the following elements:	 * <ol>	 * <li>Name</li>	 * <li>Value - should NOT be urlencoded already.</li>	 * <li>Expires - (optional) String or int (UNIX timestamp).</li>	 * <li>Path (optional)</li>	 * <li>Domain (optional)</li>	 * </ol>	 *	 * @access public	 * @since 2.8.0	 *	 * @param string|array $data Raw cookie data.	 */	function __construct( $data ) {		if ( is_string( $data ) ) {			// Assume it's a header string direct from a previous request			$pairs = explode( ';', $data );			// Special handling for first pair; name=value. Also be careful of "=" in value			$name  = trim( substr( $pairs[0], 0, strpos( $pairs[0], '=' ) ) );			$value = substr( $pairs[0], strpos( $pairs[0], '=' ) + 1 );			$this->name  = $name;			$this->value = urldecode( $value );			array_shift( $pairs ); //Removes name=value from items.			// Set everything else as a property			foreach ( $pairs as $pair ) {				$pair = rtrim($pair);				if ( empty($pair) ) //Handles the cookie ending in ; which results in a empty final pair					continue;				list( $key, $val ) = strpos( $pair, '=' ) ? explode( '=', $pair ) : array( $pair, '' );				$key = strtolower( trim( $key ) );				if ( 'expires' == $key )					$val = strtotime( $val );				$this->$key = $val;			}		} else {			if ( !isset( $data['name'] ) )				return false;			// Set properties based directly on parameters			$this->name   = $data['name'];			$this->value  = isset( $data['value'] ) ? $data['value'] : '';			$this->path   = isset( $data['path'] ) ? $data['path'] : '';			$this->domain = isset( $data['domain'] ) ? $data['domain'] : '';			if ( isset( $data['expires'] ) )				$this->expires = is_int( $data['expires'] ) ? $data['expires'] : strtotime( $data['expires'] );			else				$this->expires = null;		}	}	/**	 * Confirms that it's OK to send this cookie to the URL checked against.	 *	 * Decision is based on RFC 2109/2965, so look there for details on validity.	 *	 * @access public	 * @since 2.8.0	 *	 * @param string $url URL you intend to send this cookie to	 * @return boolean TRUE if allowed, FALSE otherwise.	 */	function test( $url ) {		// Expires - if expired then nothing else matters		if ( time() > $this->expires )			return false;		// Get details on the URL we're thinking about sending to		$url = parse_url( $url );		$url['port'] = isset( $url['port'] ) ? $url['port'] : 80;		$url['path'] = isset( $url['path'] ) ? $url['path'] : '/';		// Values to use for comparison against the URL		$path   = isset( $this->path )   ? $this->path   : '/';		$port   = isset( $this->port )   ? $this->port   : 80;		$domain = isset( $this->domain ) ? strtolower( $this->domain ) : strtolower( $url['host'] );		if ( false === stripos( $domain, '.' ) )			$domain .= '.local';		// Host - very basic check that the request URL ends with the domain restriction (minus leading dot)		$domain = substr( $domain, 0, 1 ) == '.' ? substr( $domain, 1 ) : $domain;		if ( substr( $url['host'], -strlen( $domain ) ) != $domain )			return false;		// Port - supports "port-lists" in the format: "80,8000,8080"		if ( !in_array( $url['port'], explode( ',', $port) ) )			return false;		// Path - request path must start with path restriction		if ( substr( $url['path'], 0, strlen( $path ) ) != $path )			return false;		return true;	}	/**	 * Convert cookie name and value back to header string.	 *	 * @access public	 * @since 2.8.0	 *	 * @return string Header encoded cookie name and value.	 */	function getHeaderValue() {		if ( empty( $this->name ) || empty( $this->value ) )			return '';		return $this->name . '=' . urlencode( $this->value );	}	/**	 * Retrieve cookie header for usage in the rest of the WordPress HTTP API.	 *	 * @access public	 * @since 2.8.0	 *	 * @return string	 */	function getFullHeader() {		return 'Cookie: ' . $this->getHeaderValue();	}}/** * Implementation for deflate and gzip transfer encodings. * * Includes RFC 1950, RFC 1951, and RFC 1952. * * @since 2.8 * @package WordPress * @subpackage HTTP */class WP_Http_Encoding {	/**	 * Compress raw string using the deflate format.	 *	 * Supports the RFC 1951 standard.	 *	 * @since 2.8	 *	 * @param string $raw String to compress.	 * @param int $level Optional, default is 9. Compression level, 9 is highest.	 * @param string $supports Optional, not used. When implemented it will choose the right compression based on what the server supports.	 * @return string|bool False on failure.	 */	function compress( $raw, $level = 9, $supports = null ) {		return gzdeflate( $raw, $level );	}	/**	 * Decompression of deflated string.	 *	 * Will attempt to decompress using the RFC 1950 standard, and if that fails	 * then the RFC 1951 standard deflate will be attempted. Finally, the RFC	 * 1952 standard gzip decode will be attempted. If all fail, then the	 * original compressed string will be returned.	 *	 * @since 2.8	 *	 * @param string $compressed String to decompress.	 * @param int $length The optional length of the compressed data.	 * @return string|bool False on failure.	 */	function decompress( $compressed, $length = null ) {		if ( empty($compressed) )			return $compressed;		if ( false !== ( $decompressed = @gzinflate( $compressed ) ) )			return $decompressed;		if ( false !== ( $decompressed = WP_Http_Encoding::compatible_gzinflate( $compressed ) ) )			return $decompressed;		if ( false !== ( $decompressed = @gzuncompress( $compressed ) ) )			return $decompressed;		if ( function_exists('gzdecode') ) {			$decompressed = @gzdecode( $compressed );			if ( false !== $decompressed )				return $decompressed;		}		return $compressed;	}	/**	 * Decompression of deflated string while staying compatible with the majority of servers.	 *	 * Certain Servers will return deflated data with headers which PHP's gziniflate()	 * function cannot handle out of the box. The following function lifted from	 * http://au2.php.net/manual/en/function.gzinflate.php#77336 will attempt to deflate	 * the various return forms used.	 *	 * @since 2.8.1	 * @link http://au2.php.net/manual/en/function.gzinflate.php#77336	 *	 * @param string $gzData String to decompress.	 * @return string|bool False on failure.	 */	function compatible_gzinflate($gzData) {		if ( substr($gzData, 0, 3) == "\x1f\x8b\x08" ) {			$i = 10;			$flg = ord( substr($gzData, 3, 1) );			if ( $flg > 0 ) {				if ( $flg & 4 ) {					list($xlen) = unpack('v', substr($gzData, $i, 2) );					$i = $i + 2 + $xlen;				}				if ( $flg & 8 )					$i = strpos($gzData, "\0", $i) + 1;				if ( $flg & 16 )					$i = strpos($gzData, "\0", $i) + 1;				if ( $flg & 2 )					$i = $i + 2;			}			return gzinflate( substr($gzData, $i, -8) );		} else {			return false;		}	}	/**	 * What encoding types to accept and their priority values.	 *	 * @since 2.8	 *	 * @return string Types of encoding to accept.	 */	function accept_encoding() {		$type = array();		if ( function_exists( 'gzinflate' ) )			$type[] = 'deflate;q=1.0';		if ( function_exists( 'gzuncompress' ) )			$type[] = 'compress;q=0.5';		if ( function_exists( 'gzdecode' ) )			$type[] = 'gzip;q=0.5';		return implode(', ', $type);	}	/**	 * What enconding the content used when it was compressed to send in the headers.	 *	 * @since 2.8	 *	 * @return string Content-Encoding string to send in the header.	 */	function content_encoding() {		return 'deflate';	}	/**	 * Whether the content be decoded based on the headers.	 *	 * @since 2.8	 *	 * @param array|string $headers All of the available headers.	 * @return bool	 */	function should_decode($headers) {		if ( is_array( $headers ) ) {			if ( array_key_exists('content-encoding', $headers) && ! empty( $headers['content-encoding'] ) )				return true;		} else if ( is_string( $headers ) ) {			return ( stripos($headers, 'content-encoding:') !== false );		}		return false;	}	/**	 * Whether decompression and compression are supported by the PHP version.	 *	 * Each function is tested instead of checking for the zlib extension, to	 * ensure that the functions all exist in the PHP version and aren't	 * disabled.	 *	 * @since 2.8	 *	 * @return bool	 */	function is_available() {		return ( function_exists('gzuncompress') || function_exists('gzdeflate') || function_exists('gzinflate') );	}}
<?php/** * WordPress Post Thumbnail Template Functions. * * Support for post thumbnails * Themes function.php must call add_theme_support( 'post-thumbnails' ) to use these. * * @package WordPress * @subpackage Template *//** * Check if post has an image attached. * * @since 2.9.0 * * @param int $post_id Optional. Post ID. * @return bool Whether post has an image attached. */function has_post_thumbnail( $post_id = NULL ) {	global $id;	$post_id = ( NULL === $post_id ) ? $id : $post_id;	return !! get_post_thumbnail_id( $post_id );}/** * Retrieve Post Thumbnail ID. * * @since 2.9.0 * * @param int $post_id Optional. Post ID. * @return int */function get_post_thumbnail_id( $post_id = NULL ) {	global $id;	$post_id = ( NULL === $post_id ) ? $id : $post_id;	return get_post_meta( $post_id, '_thumbnail_id', true );}/** * Display Post Thumbnail. * * @since 2.9.0 * * @param int $size Optional. Image size.  Defaults to 'post-thumbnail', which theme sets using set_post_thumbnail_size( $width, $height, $crop_flag );. * @param string|array $attr Optional. Query string or array of attributes. */function the_post_thumbnail( $size = 'post-thumbnail', $attr = '' ) {	echo get_the_post_thumbnail( NULL, $size, $attr );}/** * Retrieve Post Thumbnail. * * @since 2.9.0 * * @param int $post_id Optional. Post ID. * @param string $size Optional. Image size.  Defaults to 'thumbnail'. * @param string|array $attr Optional. Query string or array of attributes.  */function get_the_post_thumbnail( $post_id = NULL, $size = 'post-thumbnail', $attr = '' ) {	global $id;	$post_id = ( NULL === $post_id ) ? $id : $post_id;	$post_thumbnail_id = get_post_thumbnail_id( $post_id );	$size = apply_filters( 'post_thumbnail_size', $size );	if ( $post_thumbnail_id ) {		do_action( 'begin_fetch_post_thumbnail_html', $post_id, $post_thumbnail_id, $size ); // for "Just In Time" filtering of all of wp_get_attachment_image()'s filters		$html = wp_get_attachment_image( $post_thumbnail_id, $size, false, $attr );		do_action( 'end_fetch_post_thumbnail_html', $post_id, $post_thumbnail_id, $size );	} else {		$html = '';	}	return apply_filters( 'post_thumbnail_html', $html, $post_id, $post_thumbnail_id, $size, $attr );}?>
<?php/** * Dashboard Administration Panel * * @package WordPress * @subpackage Administration *//** Load WordPress Bootstrap */require_once('./admin.php');/** Load WordPress dashboard API */require_once(ABSPATH . 'wp-admin/includes/dashboard.php');wp_dashboard_setup();wp_enqueue_script( 'dashboard' );wp_enqueue_script( 'plugin-install' );wp_enqueue_script( 'media-upload' );wp_admin_css( 'dashboard' );wp_admin_css( 'plugin-install' );add_thickbox();$title = __('Dashboard');$parent_file = 'index.php';add_contextual_help($current_screen,	'<p>' . __('Welcome to your WordPress Dashboard! You will find helpful tips in the Help tab of each screen to assist you as you get to know the application.') . '</p>' .	'<p>' . __('The left-hand navigation menu provides links to the administration screens in your WordPress application. You can expand or collapse navigation sections by clicking on the arrow that appears on the right side of each navigation item when you hover over it. You can also minimize the navigation menu to a narrow icon strip by clicking on the separator lines between navigation sections that end in double arrowheads; when minimized, the submenu items will be displayed on hover.') . '</p>' .	'<p>' . __('You can configure your dashboard by choosing which modules to display, how many columns to display them in, and where each module should be placed. You can hide/show modules and select the number of columns in the Screen Options tab. To rearrange the modules, drag and drop by clicking on the title bar of the selected module and releasing when you see a gray dotted-line box appear in the location you want to place the module. You can also expand or collapse each module by clicking once on the the module&#8217;s title bar. In addition, some modules are configurable, and will show a &#8220;Configure&#8221; link in the title bar when you hover over it.') . '</p>' .	'<p>' . __('The modules on your Dashboard screen are:') . '</p>' .	'<p>' . __('<strong>Right Now</strong> - Displays a summary of the content on your site and identifies which theme and version of WordPress you are using.') . '</p>' .	'<p>' . __('<strong>Recent Comments</strong> - Shows the most recent comments on your posts (configurable, up to 30) and allows you to moderate them.') . '</p>' .	'<p>' . __('<strong>Incoming Links</strong> - Shows links to your site found by Google Blog Search.') . '</p>' .	'<p>' . __('<strong>QuickPress</strong> - Allows you to create a new post and either publish it or save it as a draft.') . '</p>' .	'<p>' . __('<strong>Recent Drafts</strong> - Displays links to the 5 most recent draft posts you&#8217;ve started.') . '</p>' .	'<p>' . __('<strong>Other WordPress News</strong> - Shows the feed from <a href="http://planet.wordpress.org" target="_blank">WordPress Planet</a>. You can configure it to show a different feed of your choosing.') . '</p>' .	'<p>' . __('<strong>Plugins</strong> - Features the most popular, newest, and recently updated plugins from the WordPress.org Plugin Directory.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Dashboard_SubPanel" target="_blank">Dashboard Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once('./admin-header.php');$today = current_time('mysql', 1);?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><div id="dashboard-widgets-wrap"><?php wp_dashboard(); ?><div class="clear"></div></div><!-- dashboard-widgets-wrap --></div><!-- wrap --><?php require(ABSPATH . 'wp-admin/admin-footer.php'); ?>
<?php/** * File contains all the administration image manipulation functions. * * @package WordPress * @subpackage Administration *//** * Create a thumbnail from an Image given a maximum side size. * * This function can handle most image file formats which PHP supports. If PHP * does not have the functionality to save in a file of the same format, the * thumbnail will be created as a jpeg. * * @since 1.2.0 * * @param mixed $file Filename of the original image, Or attachment id. * @param int $max_side Maximum length of a single side for the thumbnail. * @param mixed $deprecated Never used. * @return string Thumbnail path on success, Error string on failure. */function wp_create_thumbnail( $file, $max_side, $deprecated = '' ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '1.2' );	$thumbpath = image_resize( $file, $max_side, $max_side );	return apply_filters( 'wp_create_thumbnail', $thumbpath );}/** * Crop an Image to a given size. * * @since 2.1.0 * * @param string|int $src_file The source file or Attachment ID. * @param int $src_x The start x position to crop from. * @param int $src_y The start y position to crop from. * @param int $src_w The width to crop. * @param int $src_h The height to crop. * @param int $dst_w The destination width. * @param int $dst_h The destination height. * @param int $src_abs Optional. If the source crop points are absolute. * @param string $dst_file Optional. The destination file to write to. * @return string|WP_Error|false New filepath on success, WP_Error or false on failure. */function wp_crop_image( $src_file, $src_x, $src_y, $src_w, $src_h, $dst_w, $dst_h, $src_abs = false, $dst_file = false ) {	if ( is_numeric( $src_file ) ) // Handle int as attachment ID		$src_file = get_attached_file( $src_file );	$src = wp_load_image( $src_file );	if ( !is_resource( $src ) )		return new WP_Error( 'error_loading_image', $src, $src_file );	$dst = wp_imagecreatetruecolor( $dst_w, $dst_h );	if ( $src_abs ) {		$src_w -= $src_x;		$src_h -= $src_y;	}	if (function_exists('imageantialias'))		imageantialias( $dst, true );	imagecopyresampled( $dst, $src, 0, 0, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h );	imagedestroy( $src ); // Free up memory	if ( ! $dst_file )		$dst_file = str_replace( basename( $src_file ), 'cropped-' . basename( $src_file ), $src_file );	$dst_file = preg_replace( '/\\.[^\\.]+$/', '.jpg', $dst_file );	if ( imagejpeg( $dst, $dst_file, apply_filters( 'jpeg_quality', 90, 'wp_crop_image' ) ) )		return $dst_file;	else		return false;}/** * Generate post thumbnail attachment meta data. * * @since 2.1.0 * * @param int $attachment_id Attachment Id to process. * @param string $file Filepath of the Attached image. * @return mixed Metadata for attachment. */function wp_generate_attachment_metadata( $attachment_id, $file ) {	$attachment = get_post( $attachment_id );	$metadata = array();	if ( preg_match('!^image/!', get_post_mime_type( $attachment )) && file_is_displayable_image($file) ) {		$imagesize = getimagesize( $file );		$metadata['width'] = $imagesize[0];		$metadata['height'] = $imagesize[1];		list($uwidth, $uheight) = wp_constrain_dimensions($metadata['width'], $metadata['height'], 128, 96);		$metadata['hwstring_small'] = "height='$uheight' width='$uwidth'";		// Make the file path relative to the upload dir		$metadata['file'] = _wp_relative_upload_path($file);		// make thumbnails and other intermediate sizes		global $_wp_additional_image_sizes;		foreach ( get_intermediate_image_sizes() as $s ) {			$sizes[$s] = array( 'width' => '', 'height' => '', 'crop' => FALSE );			if ( isset( $_wp_additional_image_sizes[$s]['width'] ) )				$sizes[$s]['width'] = intval( $_wp_additional_image_sizes[$s]['width'] ); // For theme-added sizes			else				$sizes[$s]['width'] = get_option( "{$s}_size_w" ); // For default sizes set in options			if ( isset( $_wp_additional_image_sizes[$s]['height'] ) )				$sizes[$s]['height'] = intval( $_wp_additional_image_sizes[$s]['height'] ); // For theme-added sizes			else				$sizes[$s]['height'] = get_option( "{$s}_size_h" ); // For default sizes set in options			if ( isset( $_wp_additional_image_sizes[$s]['crop'] ) )				$sizes[$s]['crop'] = intval( $_wp_additional_image_sizes[$s]['crop'] ); // For theme-added sizes			else				$sizes[$s]['crop'] = get_option( "{$s}_crop" ); // For default sizes set in options		}		$sizes = apply_filters( 'intermediate_image_sizes_advanced', $sizes );		foreach ($sizes as $size => $size_data ) {			$resized = image_make_intermediate_size( $file, $size_data['width'], $size_data['height'], $size_data['crop'] );			if ( $resized )				$metadata['sizes'][$size] = $resized;		}		// fetch additional metadata from exif/iptc		$image_meta = wp_read_image_metadata( $file );		if ( $image_meta )			$metadata['image_meta'] = $image_meta;	}	return apply_filters( 'wp_generate_attachment_metadata', $metadata, $attachment_id );}/** * Calculated the new dimentions for a downsampled image. * * @since 2.0.0 * @see wp_constrain_dimensions() * * @param int $width Current width of the image * @param int $height Current height of the image * @return mixed Array(height,width) of shrunk dimensions. */function get_udims( $width, $height) {	return wp_constrain_dimensions( $width, $height, 128, 96 );}/** * Convert a fraction string to a decimal. * * @since 2.5.0 * * @param string $str * @return int|float */function wp_exif_frac2dec($str) {	@list( $n, $d ) = explode( '/', $str );	if ( !empty($d) )		return $n / $d;	return $str;}/** * Convert the exif date format to a unix timestamp. * * @since 2.5.0 * * @param string $str * @return int */function wp_exif_date2ts($str) {	@list( $date, $time ) = explode( ' ', trim($str) );	@list( $y, $m, $d ) = explode( ':', $date );	return strtotime( "{$y}-{$m}-{$d} {$time}" );}/** * Get extended image metadata, exif or iptc as available. * * Retrieves the EXIF metadata aperture, credit, camera, caption, copyright, iso * created_timestamp, focal_length, shutter_speed, and title. * * The IPTC metadata that is retrieved is APP13, credit, byline, created date * and time, caption, copyright, and title. Also includes FNumber, Model, * DateTimeDigitized, FocalLength, ISOSpeedRatings, and ExposureTime. * * @todo Try other exif libraries if available. * @since 2.5.0 * * @param string $file * @return bool|array False on failure. Image metadata array on success. */function wp_read_image_metadata( $file ) {	if ( ! file_exists( $file ) )		return false;	list( , , $sourceImageType ) = getimagesize( $file );	// exif contains a bunch of data we'll probably never need formatted in ways	// that are difficult to use. We'll normalize it and just extract the fields	// that are likely to be useful.  Fractions and numbers are converted to	// floats, dates to unix timestamps, and everything else to strings.	$meta = array(		'aperture' => 0,		'credit' => '',		'camera' => '',		'caption' => '',		'created_timestamp' => 0,		'copyright' => '',		'focal_length' => 0,		'iso' => 0,		'shutter_speed' => 0,		'title' => '',	);	// read iptc first, since it might contain data not available in exif such	// as caption, description etc	if ( is_callable( 'iptcparse' ) ) {		getimagesize( $file, $info );		if ( ! empty( $info['APP13'] ) ) {			$iptc = iptcparse( $info['APP13'] );			// headline, "A brief synopsis of the caption."			if ( ! empty( $iptc['2#105'][0] ) )				$meta['title'] = utf8_encode( trim( $iptc['2#105'][0] ) );			// title, "Many use the Title field to store the filename of the image, though the field may be used in many ways."			elseif ( ! empty( $iptc['2#005'][0] ) )				$meta['title'] = utf8_encode( trim( $iptc['2#005'][0] ) );			if ( ! empty( $iptc['2#120'][0] ) ) { // description / legacy caption				$caption = utf8_encode( trim( $iptc['2#120'][0] ) );				if ( empty( $meta['title'] ) ) {					// Assume the title is stored in 2:120 if it's short.					if ( strlen( $caption ) < 80 )						$meta['title'] = $caption;					else						$meta['caption'] = $caption;				} elseif ( $caption != $meta['title'] ) {					$meta['caption'] = $caption;				}			}			if ( ! empty( $iptc['2#110'][0] ) ) // credit				$meta['credit'] = utf8_encode(trim($iptc['2#110'][0]));			elseif ( ! empty( $iptc['2#080'][0] ) ) // creator / legacy byline				$meta['credit'] = utf8_encode(trim($iptc['2#080'][0]));			if ( ! empty( $iptc['2#055'][0] ) and ! empty( $iptc['2#060'][0] ) ) // created date and time				$meta['created_timestamp'] = strtotime( $iptc['2#055'][0] . ' ' . $iptc['2#060'][0] );			if ( ! empty( $iptc['2#116'][0] ) ) // copyright				$meta['copyright'] = utf8_encode( trim( $iptc['2#116'][0] ) );		 }	}	// fetch additional info from exif if available	if ( is_callable( 'exif_read_data' ) && in_array( $sourceImageType, apply_filters( 'wp_read_image_metadata_types', array( IMAGETYPE_JPEG, IMAGETYPE_TIFF_II, IMAGETYPE_TIFF_MM ) ) ) ) {		$exif = @exif_read_data( $file );		if ( !empty( $exif['Title'] ) )			$meta['title'] = utf8_encode( trim( $exif['Title'] ) );		if ( ! empty( $exif['ImageDescription'] ) ) {			if ( empty( $meta['title'] ) && strlen( $exif['ImageDescription'] ) < 80 ) {				// Assume the title is stored in ImageDescription				$meta['title'] = utf8_encode( trim( $exif['ImageDescription'] ) );				if ( ! empty( $exif['COMPUTED']['UserComment'] ) && trim( $exif['COMPUTED']['UserComment'] ) != $meta['title'] )					$meta['caption'] = utf8_encode( trim( $exif['COMPUTED']['UserComment'] ) );			} elseif ( trim( $exif['ImageDescription'] ) != $meta['title'] ) {				$meta['caption'] = utf8_encode( trim( $exif['ImageDescription'] ) );			}		} elseif ( ! empty( $exif['Comments'] ) && trim( $exif['Comments'] ) != $meta['title'] ) {			$meta['caption'] = utf8_encode( trim( $exif['Comments'] ) );		}		if ( ! empty( $exif['Artist'] ) )			$meta['credit'] = utf8_encode( trim( $exif['Artist'] ) );		elseif ( ! empty($exif['Author'] ) )			$meta['credit'] = utf8_encode( trim( $exif['Author'] ) );		if ( ! empty( $exif['Copyright'] ) )			$meta['copyright'] = utf8_encode( trim( $exif['Copyright'] ) );		if ( ! empty($exif['FNumber'] ) )			$meta['aperture'] = round( wp_exif_frac2dec( $exif['FNumber'] ), 2 );		if ( ! empty($exif['Model'] ) )			$meta['camera'] = utf8_encode( trim( $exif['Model'] ) );		if ( ! empty($exif['DateTimeDigitized'] ) )			$meta['created_timestamp'] = wp_exif_date2ts($exif['DateTimeDigitized'] );		if ( ! empty($exif['FocalLength'] ) )			$meta['focal_length'] = wp_exif_frac2dec( $exif['FocalLength'] );		if ( ! empty($exif['ISOSpeedRatings'] ) )			$meta['iso'] = utf8_encode( trim( $exif['ISOSpeedRatings'] ) );		if ( ! empty($exif['ExposureTime'] ) )			$meta['shutter_speed'] = wp_exif_frac2dec( $exif['ExposureTime'] );	}	return apply_filters( 'wp_read_image_metadata', $meta, $file, $sourceImageType );}/** * Validate that file is an image. * * @since 2.5.0 * * @param string $path File path to test if valid image. * @return bool True if valid image, false if not valid image. */function file_is_valid_image($path) {	$size = @getimagesize($path);	return !empty($size);}/** * Validate that file is suitable for displaying within a web page. * * @since 2.5.0 * @uses apply_filters() Calls 'file_is_displayable_image' on $result and $path. * * @param string $path File path to test. * @return bool True if suitable, false if not suitable. */function file_is_displayable_image($path) {	$info = @getimagesize($path);	if ( empty($info) )		$result = false;	elseif ( !in_array($info[2], array(IMAGETYPE_GIF, IMAGETYPE_JPEG, IMAGETYPE_PNG)) )	// only gif, jpeg and png images can reliably be displayed		$result = false;	else		$result = true;	return apply_filters('file_is_displayable_image', $result, $path);}
<?php/** * WordPress Administration Importer API. * * @package WordPress * @subpackage Administration *//** * Retrieve list of importers. * * @since 2.0.0 * * @return array */function get_importers() {	global $wp_importers;	if ( is_array($wp_importers) )		uasort($wp_importers, create_function('$a, $b', 'return strcmp($a[0], $b[0]);'));	return $wp_importers;}/** * Register importer for WordPress. * * @since 2.0.0 * * @param string $id Importer tag. Used to uniquely identify importer. * @param string $name Importer name and title. * @param string $description Importer description. * @param callback $callback Callback to run. * @return WP_Error Returns WP_Error when $callback is WP_Error. */function register_importer( $id, $name, $description, $callback ) {	global $wp_importers;	if ( is_wp_error( $callback ) )		return $callback;	$wp_importers[$id] = array ( $name, $description, $callback );}/** * Cleanup importer. * * Removes attachment based on ID. * * @since 2.0.0 * * @param string $id Importer ID. */function wp_import_cleanup( $id ) {	wp_delete_attachment( $id );}/** * Handle importer uploading and add attachment. * * @since 2.0.0 * * @return array */function wp_import_handle_upload() {	if ( !isset($_FILES['import']) ) {		$file['error'] = __( 'File is empty. Please upload something more substantial. This error could also be caused by uploads being disabled in your php.ini or by post_max_size being defined as smaller than upload_max_filesize in php.ini.' );		return $file;	}	$overrides = array( 'test_form' => false, 'test_type' => false );	$_FILES['import']['name'] .= '.txt';	$file = wp_handle_upload( $_FILES['import'], $overrides );	if ( isset( $file['error'] ) )		return $file;	$url = $file['url'];	$type = $file['type'];	$file = addslashes( $file['file'] );	$filename = basename( $file );	// Construct the object array	$object = array( 'post_title' => $filename,		'post_content' => $url,		'post_mime_type' => $type,		'guid' => $url	);	// Save the data	$id = wp_insert_attachment( $object, $file );	return array( 'file' => $file, 'id' => $id );}?>
<?php/** * The base configurations of the WordPress. * * This file has the following configurations: MySQL settings, Table Prefix, * Secret Keys, WordPress Language, and ABSPATH. You can find more information * by visiting {@link http://codex.wordpress.org/Editing_wp-config.php Editing * wp-config.php} Codex page. You can get the MySQL settings from your web host. * * This file is used by the wp-config.php creation script during the * installation. You don't have to use the web site, you can just copy this file * to "wp-config.php" and fill in the values. * * @package WordPress */// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define('DB_NAME', 'database_name_here');/** MySQL database username */define('DB_USER', 'username_here');/** MySQL database password */define('DB_PASSWORD', 'password_here');/** MySQL hostname */define('DB_HOST', 'localhost');/** Database Charset to use in creating database tables. */define('DB_CHARSET', 'utf8');/** The Database Collate type. Don't change this if in doubt. */define('DB_COLLATE', '');/**#@+ * Authentication Unique Keys and Salts. * * Change these to different unique phrases! * You can generate these using the {@link https://api.wordpress.org/secret-key/1.1/salt/ WordPress.org secret-key service} * You can change these at any point in time to invalidate all existing cookies. This will force all users to have to log in again. * * @since 2.6.0 */define('AUTH_KEY',         'put your unique phrase here');define('SECURE_AUTH_KEY',  'put your unique phrase here');define('LOGGED_IN_KEY',    'put your unique phrase here');define('NONCE_KEY',        'put your unique phrase here');define('AUTH_SALT',        'put your unique phrase here');define('SECURE_AUTH_SALT', 'put your unique phrase here');define('LOGGED_IN_SALT',   'put your unique phrase here');define('NONCE_SALT',       'put your unique phrase here');/**#@-*//** * WordPress Database Table prefix. * * You can have multiple installations in one database if you give each a unique * prefix. Only numbers, letters, and underscores please! */$table_prefix  = 'wp_';/** * WordPress Localized Language, defaults to English. * * Change this to localize WordPress.  A corresponding MO file for the chosen * language must be installed to wp-content/languages. For example, install * de.mo to wp-content/languages and set WPLANG to 'de' to enable German * language support. */define ('WPLANG', '');/** * For developers: WordPress debugging mode. * * Change this to true to enable the display of notices during development. * It is strongly recommended that plugin and theme developers use WP_DEBUG * in their development environments. */define('WP_DEBUG', false);/* That's all, stop editing! Happy blogging. *//** Absolute path to the WordPress directory. */if ( !defined('ABSPATH') )	define('ABSPATH', dirname(__FILE__) . '/');/** Sets up WordPress vars and included files. */require_once(ABSPATH . 'wp-settings.php');
<?php/** * RSS 0.92 Feed Template for displaying RSS 0.92 Posts feed. * * @package WordPress */header('Content-Type: ' . feed_content_type('rss-http') . '; charset=' . get_option('blog_charset'), true);$more = 1;echo '<?xml version="1.0" encoding="'.get_option('blog_charset').'"?'.'>'; ?><rss version="0.92"><channel>	<title><?php bloginfo_rss('name'); wp_title_rss(); ?></title>	<link><?php bloginfo_rss('url') ?></link>	<description><?php bloginfo_rss('description') ?></description>	<lastBuildDate><?php echo mysql2date('D, d M Y H:i:s +0000', get_lastpostmodified('GMT'), false); ?></lastBuildDate>	<docs>http://backend.userland.com/rss092</docs>	<language><?php echo get_option('rss_language'); ?></language>	<?php do_action('rss_head'); ?><?php while (have_posts()) : the_post(); ?>	<item>		<title><?php the_title_rss() ?></title>		<description><![CDATA[<?php the_excerpt_rss() ?>]]></description>		<link><?php the_permalink_rss() ?></link>		<?php do_action('rss_item'); ?>	</item><?php endwhile; ?></channel></rss>
<?php/** * Front to the WordPress application. This file doesn't do anything, but loads * wp-blog-header.php which does and tells WordPress to load the theme. * * @package WordPress *//** * Tells WordPress to load the WordPress theme and output it. * * @var bool */define('WP_USE_THEMES', true);/** Loads the WordPress Environment and Template */require('./wp-blog-header.php');?>
<?php/** * Navigation Menu functions * * @package WordPress * @subpackage Nav_Menus * @since 3.0.0 *//** * Returns a navigation menu object. * * @since 3.0.0 * * @uses get_term * @uses get_term_by * * @param string $menu Menu id, slug or name * @return mixed false if $menu param isn't supplied or term does not exist, menu object if successful. */function wp_get_nav_menu_object( $menu ) {	if ( ! $menu )		return false;	$menu_obj = get_term( $menu, 'nav_menu' );	if ( ! $menu_obj )		$menu_obj = get_term_by( 'slug', $menu, 'nav_menu' );	if ( ! $menu_obj )		$menu_obj = get_term_by( 'name', $menu, 'nav_menu' );	if ( ! $menu_obj )		$menu_obj = false;	return $menu_obj;}/** * Check if the given ID is a navigation menu. * * Returns true if it is; false otherwise. * * @since 3.0.0 * * @param int|string $menu The menu to check (id, slug, or name) * @return bool Whether the menu exists. */function is_nav_menu( $menu ) {	if ( ! $menu )		return false;	$menu_obj = wp_get_nav_menu_object( $menu );	if (		$menu_obj &&		! is_wp_error( $menu_obj ) &&		! empty( $menu_obj->taxonomy ) &&		'nav_menu' == $menu_obj->taxonomy	)		return true;	return false;}/** * Register navigation menus for a theme. * * @since 3.0.0 * * @param array $locations Associative array of menu location identifiers (like a slug) and descriptive text. */function register_nav_menus( $locations = array() ) {	global $_wp_registered_nav_menus;	add_theme_support( 'menus' );	$_wp_registered_nav_menus = array_merge( (array) $_wp_registered_nav_menus, $locations );}/** * Register a navigation menu for a theme. * * @since 3.0.0 * * @param string $location Menu location identifier, like a slug. * @param string $description Menu location descriptive text. */function register_nav_menu( $location, $description ) {	register_nav_menus( array( $location => $description ) );}/** * Returns an array of all registered navigation menus in a theme * * @since 3.0.0 * @return array */function get_registered_nav_menus() {	global $_wp_registered_nav_menus;	if ( isset( $_wp_registered_nav_menus ) )		return $_wp_registered_nav_menus;	return array();}/** * Returns an array with the registered navigation menu locations and the menu assigned to it * * @since 3.0.0 * @return array */function get_nav_menu_locations() {	return get_theme_mod( 'nav_menu_locations' );}/** * Whether a registered nav menu location has a menu assigned to it. * * @since 3.0.0 * @param string $location Menu location identifier. * @return bool Whether location has a menu. */function has_nav_menu( $location ) {	$locations = get_nav_menu_locations();	return ( ! empty( $locations[ $location ] ) );}/** * Determine whether the given ID is a nav menu item. * * @since 3.0.0 * * @param int $menu_item_id The ID of the potential nav menu item. * @return bool Whether the given ID is that of a nav menu item. */function is_nav_menu_item( $menu_item_id = 0 ) {	return ( ! is_wp_error( $menu_item_id ) && ( 'nav_menu_item' == get_post_type( $menu_item_id ) ) );}/** * Create a Navigation Menu. * * @since 3.0.0 * * @param string $menu_name Menu Name * @return mixed Menu object on success|WP_Error on failure */function wp_create_nav_menu( $menu_name ) {	return wp_update_nav_menu_object( 0, array( 'menu-name' => $menu_name ) );}/** * Delete a Navigation Menu. * * @since 3.0.0 * * @param string $menu name|id|slug * @return mixed Menu object on success|WP_Error on failure */function wp_delete_nav_menu( $menu ) {	$menu = wp_get_nav_menu_object( $menu );	if ( ! $menu )		return false;	$menu_objects = get_objects_in_term( $menu->term_id, 'nav_menu' );	if ( ! empty( $menu_objects ) ) {		foreach ( $menu_objects as $item ) {			wp_delete_post( $item );		}	}	$result = wp_delete_term( $menu->term_id, 'nav_menu' );	if ( $result && !is_wp_error($result) )		do_action( 'wp_delete_nav_menu', $menu->term_id );	return $result;}/** * Save the properties of a menu or create a new menu with those properties. * * @since 3.0.0 * * @param int $menu_id The ID of the menu or "0" to create a new menu. * @param array $menu_data The array of menu data. * @return int|error object The menu's ID or WP_Error object. */function wp_update_nav_menu_object( $menu_id = 0, $menu_data = array() ) {	$menu_id = (int) $menu_id;	$_menu = wp_get_nav_menu_object( $menu_id );	$args = array(		'description' => ( isset( $menu_data['description'] ) ? $menu_data['description']  : '' ),		'name'        => ( isset( $menu_data['menu-name']   ) ? $menu_data['menu-name']    : '' ),		'parent'      => ( isset( $menu_data['parent']      ) ? (int) $menu_data['parent'] : 0  ),		'slug'        => null,	);	// double-check that we're not going to have one menu take the name of another	$_possible_existing = get_term_by( 'name', $menu_data['menu-name'], 'nav_menu' );	if (		$_possible_existing &&		! is_wp_error( $_possible_existing ) &&		isset( $_possible_existing->term_id ) &&		$_possible_existing->term_id != $menu_id	)		return new WP_Error( 'menu_exists', sprintf( __('The menu name <strong>%s</strong> conflicts with another menu name. Please try another.'), esc_html( $menu_data['menu-name'] ) ) );	// menu doesn't already exist, so create a new menu	if ( ! $_menu || is_wp_error( $_menu ) ) {		$menu_exists = get_term_by( 'name', $menu_data['menu-name'], 'nav_menu' );		if ( $menu_exists )			return new WP_Error( 'menu_exists', sprintf( __('The menu name <strong>%s</strong> conflicts with another menu name. Please try another.'), esc_html( $menu_data['menu-name'] ) ) );		$_menu = wp_insert_term( $menu_data['menu-name'], 'nav_menu', $args );		if ( is_wp_error( $_menu ) )			return $_menu;		do_action( 'wp_create_nav_menu', $_menu['term_id'], $menu_data );		return (int) $_menu['term_id'];	}	if ( ! $_menu || ! isset( $_menu->term_id ) )		return 0;	$menu_id = (int) $_menu->term_id;	$update_response = wp_update_term( $menu_id, 'nav_menu', $args );	if ( is_wp_error( $update_response ) )		return $update_response;	do_action( 'wp_update_nav_menu', $menu_id, $menu_data );	return $menu_id;}/** * Save the properties of a menu item or create a new one. * * @since 3.0.0 * * @param int $menu_id The ID of the menu. Required. If "0", makes the menu item a draft orphan. * @param int $menu_item_db_id The ID of the menu item. If "0", creates a new menu item. * @param array $menu_item_data The menu item's data. * @return int The menu item's database ID or WP_Error object on failure. */function wp_update_nav_menu_item( $menu_id = 0, $menu_item_db_id = 0, $menu_item_data = array() ) {	$menu_id = (int) $menu_id;	$menu_item_db_id = (int) $menu_item_db_id;	// make sure that we don't convert non-nav_menu_item objects into nav_menu_item objects	if ( ! empty( $menu_item_db_id ) && ! is_nav_menu_item( $menu_item_db_id ) )		return new WP_Error('update_nav_menu_item_failed', __('The given object ID is not that of a menu item.'));	$menu = wp_get_nav_menu_object( $menu_id );	if ( ( ! $menu && 0 !== $menu_id ) || is_wp_error( $menu ) )		return $menu;	$menu_items = 0 == $menu_id ? array() : (array) wp_get_nav_menu_items( $menu_id, array( 'post_status' => 'publish,draft' ) );	$count = count( $menu_items );	$defaults = array(		'menu-item-db-id' => $menu_item_db_id,		'menu-item-object-id' => 0,		'menu-item-object' => '',		'menu-item-parent-id' => 0,		'menu-item-position' => 0,		'menu-item-type' => 'custom',		'menu-item-title' => '',		'menu-item-url' => '',		'menu-item-description' => '',		'menu-item-attr-title' => '',		'menu-item-target' => '',		'menu-item-classes' => '',		'menu-item-xfn' => '',		'menu-item-status' => '',	);	$args = wp_parse_args( $menu_item_data, $defaults );	if ( 0 == $menu_id ) {		$args['menu-item-position'] = 1;	} elseif ( 0 == (int) $args['menu-item-position'] ) {		$last_item = array_pop( $menu_items );		$args['menu-item-position'] = ( $last_item && isset( $last_item->menu_order ) ) ? 1 + $last_item->menu_order : $count;	}	$original_parent = 0 < $menu_item_db_id ? get_post_field( 'post_parent', $menu_item_db_id ) : 0;	if ( 'custom' != $args['menu-item-type'] ) {		/* if non-custom menu item, then:			* use original object's URL			* blank default title to sync with original object's		*/		$args['menu-item-url'] = '';		$original_title = '';		if ( 'taxonomy' == $args['menu-item-type'] ) {			$original_parent = get_term_field( 'parent', $args['menu-item-object-id'], $args['menu-item-object'], 'raw' );			$original_title = get_term_field( 'name', $args['menu-item-object-id'], $args['menu-item-object'], 'raw' );		} elseif ( 'post_type' == $args['menu-item-type'] ) {			$original_object = get_post( $args['menu-item-object-id'] );			$original_parent = (int) $original_object->post_parent;			$original_title = $original_object->post_title;		}		if ( empty( $args['menu-item-title'] ) || $args['menu-item-title'] == $original_title ) {			$args['menu-item-title'] = '';			// hack to get wp to create a post object when too many properties are empty			if ( empty( $args['menu-item-description'] ) )				$args['menu-item-description'] = ' ';		}	}	// Populate the menu item object	$post = array(		'menu_order' => $args['menu-item-position'],		'ping_status' => 0,		'post_content' => $args['menu-item-description'],		'post_excerpt' => $args['menu-item-attr-title'],		'post_parent' => $original_parent,		'post_title' => $args['menu-item-title'],		'post_type' => 'nav_menu_item',	);	if ( 0 != $menu_id )		$post['tax_input'] = array( 'nav_menu' => array( intval( $menu->term_id ) ) );	// New menu item. Default is draft status	if ( 0 == $menu_item_db_id ) {		$post['ID'] = 0;		$post['post_status'] = 'publish' == $args['menu-item-status'] ? 'publish' : 'draft';		$menu_item_db_id = wp_insert_post( $post );	// Update existing menu item. Default is publish status	} else {		$post['ID'] = $menu_item_db_id;		$post['post_status'] = 'draft' == $args['menu-item-status'] ? 'draft' : 'publish';		wp_update_post( $post );	}	if ( 'custom' == $args['menu-item-type'] ) {		$args['menu-item-object-id'] = $menu_item_db_id;		$args['menu-item-object'] = 'custom';	}	if ( ! $menu_item_db_id || is_wp_error( $menu_item_db_id ) )		return $menu_item_db_id;	$menu_item_db_id = (int) $menu_item_db_id;	update_post_meta( $menu_item_db_id, '_menu_item_type', sanitize_key($args['menu-item-type']) );	update_post_meta( $menu_item_db_id, '_menu_item_menu_item_parent', (int) $args['menu-item-parent-id'] );	update_post_meta( $menu_item_db_id, '_menu_item_object_id', (int) $args['menu-item-object-id'] );	update_post_meta( $menu_item_db_id, '_menu_item_object', sanitize_key($args['menu-item-object']) );	update_post_meta( $menu_item_db_id, '_menu_item_target', sanitize_key($args['menu-item-target']) );	$args['menu-item-classes'] = array_map( 'sanitize_html_class', explode( ' ', $args['menu-item-classes'] ) );	$args['menu-item-xfn'] = implode( ' ', array_map( 'sanitize_html_class', explode( ' ', $args['menu-item-xfn'] ) ) );	update_post_meta( $menu_item_db_id, '_menu_item_classes', $args['menu-item-classes'] );	update_post_meta( $menu_item_db_id, '_menu_item_xfn', $args['menu-item-xfn'] );	update_post_meta( $menu_item_db_id, '_menu_item_url', esc_url_raw($args['menu-item-url']) );	if ( 0 == $menu_id )		update_post_meta( $menu_item_db_id, '_menu_item_orphaned', time() );	else		delete_post_meta( $menu_item_db_id, '_menu_item_orphaned' );	do_action('wp_update_nav_menu_item', $menu_id, $menu_item_db_id, $args );	return $menu_item_db_id;}/** * Returns all navigation menu objects. * * @since 3.0.0 * * @param $args array Array of arguments passed on to get_terms(). * @return array menu objects */function wp_get_nav_menus( $args = array() ) {	$defaults = array( 'hide_empty' => false, 'orderby' => 'none' );	$args = wp_parse_args( $args, $defaults );	return apply_filters( 'wp_get_nav_menus', get_terms( 'nav_menu',  $args), $args );}/** * Sort menu items by the desired key. * * @since 3.0.0 * @access private * * @param object $a The first object to compare * @param object $b The second object to compare * @return int -1, 0, or 1 if $a is considered to be respectively less than, equal to, or greater than $b. */function _sort_nav_menu_items( $a, $b ) {	global $_menu_item_sort_prop;	if ( empty( $_menu_item_sort_prop ) )		return 0;	if ( ! isset( $a->$_menu_item_sort_prop ) || ! isset( $b->$_menu_item_sort_prop ) )		return 0;	$_a = (int) $a->$_menu_item_sort_prop;	$_b = (int) $b->$_menu_item_sort_prop;	if ( $a->$_menu_item_sort_prop == $b->$_menu_item_sort_prop )		return 0;	elseif ( $_a == $a->$_menu_item_sort_prop && $_b == $b->$_menu_item_sort_prop )		return $_a < $_b ? -1 : 1;	else		return strcmp( $a->$_menu_item_sort_prop, $b->$_menu_item_sort_prop );}/** * Returns all menu items of a navigation menu. * * @since 3.0.0 * * @param string $menu menu name, id, or slug * @param string $args * @return mixed $items array of menu items, else false. */function wp_get_nav_menu_items( $menu, $args = array() ) {	global $_wp_using_ext_object_cache;	$menu = wp_get_nav_menu_object( $menu );	if ( ! $menu )		return false;	static $fetched = array();	$items = get_objects_in_term( $menu->term_id, 'nav_menu' );	if ( empty( $items ) )		return $items;	$defaults = array( 'order' => 'ASC', 'orderby' => 'menu_order', 'post_type' => 'nav_menu_item',		'post_status' => 'publish', 'output' => ARRAY_A, 'output_key' => 'menu_order', 'nopaging' => true,		'update_post_term_cache' => false );	$args = wp_parse_args( $args, $defaults );	if ( count( $items ) > 1 )		$args['include'] = implode( ',', $items );	else		$args['include'] = $items[0];	$items = get_posts( $args );	if ( is_wp_error( $items ) || ! is_array( $items ) )		return false;	// Get all posts and terms at once to prime the caches	if ( empty( $fetched[$menu->term_id] ) || $_wp_using_ext_object_cache ) {		$fetched[$menu->term_id] = true;		$posts = array();		$terms = array();		foreach ( $items as $item ) {			$object_id = get_post_meta( $item->ID, '_menu_item_object_id', true );			$object    = get_post_meta( $item->ID, '_menu_item_object',    true );			$type      = get_post_meta( $item->ID, '_menu_item_type',      true );			if ( 'post_type' == $type )				$posts[$object][] = $object_id;			elseif ( 'taxonomy' == $type)				$terms[$object][] = $object_id;		}		if ( ! empty( $posts ) ) {			foreach ( array_keys($posts) as $post_type ) {				get_posts( array('post__in' => $posts[$post_type], 'post_type' => $post_type, 'nopaging' => true, 'update_post_term_cache' => false) );			}		}		unset($posts);		if ( ! empty( $terms ) ) {			foreach ( array_keys($terms) as $taxonomy ) {				get_terms($taxonomy, array('include' => $terms[$taxonomy]) );			}		}		unset($terms);	}	$items = array_map( 'wp_setup_nav_menu_item', $items );	if ( ARRAY_A == $args['output'] ) {		$GLOBALS['_menu_item_sort_prop'] = $args['output_key'];		usort($items, '_sort_nav_menu_items');		$i = 1;		foreach( $items as $k => $item ) {			$items[$k]->$args['output_key'] = $i++;		}	}	return apply_filters( 'wp_get_nav_menu_items',  $items, $menu, $args );}/** * Decorates a menu item object with the shared navigation menu item properties. * * Properties: * - db_id: 		The DB ID of this item as a nav_menu_item object, if it exists (0 if it doesn't exist). * - object_id:		The DB ID of the original object this menu item represents, e.g. ID for posts and term_id for categories. * - type:		The family of objects originally represented, such as "post_type" or "taxonomy." * - object:		The type of object originally represented, such as "category," "post", or "attachment." * - type_label:	The singular label used to describe this type of menu item. * - post_parent:	The DB ID of the original object's parent object, if any (0 otherwise). * - menu_item_parent: 	The DB ID of the nav_menu_item that is this item's menu parent, if any.  0 otherwise. * - url:		The URL to which this menu item points. * - title:		The title of this menu item. * - target: 		The target attribute of the link element for this menu item. * - attr_title:	The title attribute of the link element for this menu item. * - classes:		The array of class attribute values for the link element of this menu item. * - xfn:		The XFN relationship expressed in the link of this menu item. * - description:	The description of this menu item. * * @since 3.0.0 * * @param object $menu_item The menu item to modify. * @return object $menu_item The menu item with standard menu item properties. */function wp_setup_nav_menu_item( $menu_item ) {	if ( isset( $menu_item->post_type ) ) {		if ( 'nav_menu_item' == $menu_item->post_type ) {			$menu_item->db_id = (int) $menu_item->ID;			$menu_item->menu_item_parent = empty( $menu_item->menu_item_parent ) ? get_post_meta( $menu_item->ID, '_menu_item_menu_item_parent', true ) : $menu_item->menu_item_parent;			$menu_item->object_id = empty( $menu_item->object_id ) ? get_post_meta( $menu_item->ID, '_menu_item_object_id', true ) : $menu_item->object_id;			$menu_item->object = empty( $menu_item->object ) ? get_post_meta( $menu_item->ID, '_menu_item_object', true ) : $menu_item->object;			$menu_item->type = empty( $menu_item->type ) ? get_post_meta( $menu_item->ID, '_menu_item_type', true ) : $menu_item->type;			if ( 'post_type' == $menu_item->type ) {				$object = get_post_type_object( $menu_item->object );				$menu_item->type_label = $object->labels->singular_name;				$menu_item->url = get_permalink( $menu_item->object_id );				$original_object = get_post( $menu_item->object_id );				$original_title = $original_object->post_title;				$menu_item->title = '' == $menu_item->post_title ? $original_title : $menu_item->post_title;			} elseif ( 'taxonomy' == $menu_item->type ) {				$object = get_taxonomy( $menu_item->object );				$menu_item->type_label = $object->labels->singular_name;				$term_url = get_term_link( (int) $menu_item->object_id, $menu_item->object );				$menu_item->url = !is_wp_error( $term_url ) ? $term_url : '';				$original_title = get_term_field( 'name', $menu_item->object_id, $menu_item->object, 'raw' );				$menu_item->title = '' == $menu_item->post_title ? $original_title : $menu_item->post_title;			} else {				$menu_item->type_label = __('Custom');				$menu_item->title = $menu_item->post_title;				$menu_item->url = empty( $menu_item->url ) ? get_post_meta( $menu_item->ID, '_menu_item_url', true ) : $menu_item->url;			}			$menu_item->target = empty( $menu_item->target ) ? get_post_meta( $menu_item->ID, '_menu_item_target', true ) : $menu_item->target;			$menu_item->attr_title = empty( $menu_item->attr_title ) ? apply_filters( 'nav_menu_attr_title', $menu_item->post_excerpt ) : $menu_item->attr_title;			$menu_item->description = empty( $menu_item->description ) ? apply_filters( 'nav_menu_description', $menu_item->post_content ) : $menu_item->description;			$menu_item->classes = empty( $menu_item->classes ) ? (array) get_post_meta( $menu_item->ID, '_menu_item_classes', true ) : $menu_item->classes;			$menu_item->xfn = empty( $menu_item->xfn ) ? get_post_meta( $menu_item->ID, '_menu_item_xfn', true ) : $menu_item->xfn;		} else {			$menu_item->db_id = 0;			$menu_item->menu_item_parent = 0;			$menu_item->object_id = (int) $menu_item->ID;			$menu_item->type = 'post_type';			$object = get_post_type_object( $menu_item->post_type );			$menu_item->object = $object->name;			$menu_item->type_label = $object->labels->singular_name;			$menu_item->title = $menu_item->post_title;			$menu_item->url = get_permalink( $menu_item->ID );			$menu_item->target = '';			$menu_item->attr_title = apply_filters( 'nav_menu_attr_title', $menu_item->post_excerpt );			$menu_item->description = apply_filters( 'nav_menu_description', $menu_item->post_content );			$menu_item->classes = array();			$menu_item->xfn = '';		}	} elseif ( isset( $menu_item->taxonomy ) ) {		$menu_item->ID = $menu_item->term_id;		$menu_item->db_id = 0;		$menu_item->menu_item_parent = 0;		$menu_item->object_id = (int) $menu_item->term_id;		$menu_item->post_parent = (int) $menu_item->parent;		$menu_item->type = 'taxonomy';		$object = get_taxonomy( $menu_item->taxonomy );		$menu_item->object = $object->name;		$menu_item->type_label = $object->labels->singular_name;		$menu_item->title = $menu_item->name;		$menu_item->url = get_term_link( $menu_item, $menu_item->taxonomy );		$menu_item->target = '';		$menu_item->attr_title = '';		$menu_item->description = get_term_field( 'description', $menu_item->term_id, $menu_item->taxonomy );		$menu_item->classes = array();		$menu_item->xfn = '';	}	return apply_filters( 'wp_setup_nav_menu_item', $menu_item );}/** * Get the menu items associated with a particular object. * * @since 3.0.0 * * @param int $object_id The ID of the original object. * @param string $object_type The type of object, such as "taxonomy" or "post_type." * @return array The array of menu item IDs; empty array if none; */function wp_get_associated_nav_menu_items( $object_id = 0, $object_type = 'post_type' ) {	$object_id = (int) $object_id;	$menu_item_ids = array();	$query = new WP_Query;	$menu_items = $query->query(		array(			'meta_key' => '_menu_item_object_id',			'meta_value' => $object_id,			'post_status' => 'any',			'post_type' => 'nav_menu_item',			'showposts' => -1,		)	);	foreach( (array) $menu_items as $menu_item ) {		if ( isset( $menu_item->ID ) && is_nav_menu_item( $menu_item->ID ) ) {			if ( get_post_meta( $menu_item->ID, '_menu_item_type', true ) != $object_type )				continue;			$menu_item_ids[] = (int) $menu_item->ID;		}	}	return array_unique( $menu_item_ids );}/** * Callback for handling a menu item when its original object is deleted. * * @since 3.0.0 * @access private * * @param int $object_id The ID of the original object being trashed. * */function _wp_delete_post_menu_item( $object_id = 0 ) {	$object_id = (int) $object_id;	$menu_item_ids = wp_get_associated_nav_menu_items( $object_id, 'post_type' );	foreach( (array) $menu_item_ids as $menu_item_id ) {		wp_delete_post( $menu_item_id, true );	}}/** * Callback for handling a menu item when its original object is deleted. * * @since 3.0.0 * @access private * * @param int $object_id The ID of the original object being trashed. * */function _wp_delete_tax_menu_item( $object_id = 0 ) {	$object_id = (int) $object_id;	$menu_item_ids = wp_get_associated_nav_menu_items( $object_id, 'taxonomy' );	foreach( (array) $menu_item_ids as $menu_item_id ) {		wp_delete_post( $menu_item_id, true );	}}/** * Automatically add newly published page objects to menus with that as an option. * * @since 3.0.0 * @access private * * @param string $new_status The new status of the post object. * @param string $old_status The old status of the post object. * @param object $post The post object being transitioned from one status to another. * @return void */function _wp_auto_add_pages_to_menu( $new_status, $old_status, $post ) {	if ( 'publish' != $new_status || 'publish' == $old_status || 'page' != $post->post_type )		return;	if ( ! empty( $post->post_parent ) )		return;	$auto_add = get_option( 'nav_menu_options' );	if ( empty( $auto_add ) || ! is_array( $auto_add ) || ! isset( $auto_add['auto_add'] ) )		return;	$auto_add = $auto_add['auto_add'];	if ( empty( $auto_add ) || ! is_array( $auto_add ) )		return;	$args = array(		'menu-item-object-id' => $post->ID,		'menu-item-object' => $post->post_type,		'menu-item-type' => 'post_type',		'menu-item-status' => 'publish',	);	foreach ( $auto_add as $menu_id ) {		$items = wp_get_nav_menu_items( $menu_id, array( 'post_status' => 'publish,draft' ) );		if ( ! is_array( $items ) )			continue;		foreach ( $items as $item ) {			if ( $post->ID == $item->object_id )				continue 2;		}		wp_update_nav_menu_item( $menu_id, 0, $args );	}}?>
<?php/** * WordPress Category API * * @package WordPress *//** * Retrieves all category IDs. * * @since 2.0.0 * @link http://codex.wordpress.org/Function_Reference/get_all_category_ids * * @return object List of all of the category IDs. */function get_all_category_ids() {	if ( ! $cat_ids = wp_cache_get( 'all_category_ids', 'category' ) ) {		$cat_ids = get_terms( 'category', array('fields' => 'ids', 'get' => 'all') );		wp_cache_add( 'all_category_ids', $cat_ids, 'category' );	}	return $cat_ids;}/** * Retrieve list of category objects. * * If you change the type to 'link' in the arguments, then the link categories * will be returned instead. Also all categories will be updated to be backwards * compatible with pre-2.3 plugins and themes. * * @since 2.1.0 * @see get_terms() Type of arguments that can be changed. * @link http://codex.wordpress.org/Function_Reference/get_categories * * @param string|array $args Optional. Change the defaults retrieving categories. * @return array List of categories. */function &get_categories( $args = '' ) {	$defaults = array( 'taxonomy' => 'category' );	$args = wp_parse_args( $args, $defaults );	$taxonomy = apply_filters( 'get_categories_taxonomy', $args['taxonomy'], $args );	// Back compat	if ( isset($args['type']) && 'link' == $args['type'] ) {		_deprecated_argument( __FUNCTION__, '3.0', '' );		$taxonomy = $args['taxonomy'] = 'link_category';	}	$categories = (array) get_terms( $taxonomy, $args );	foreach ( array_keys( $categories ) as $k )		_make_cat_compat( $categories[$k] );	return $categories;}/** * Retrieves category data given a category ID or category object. * * If you pass the $category parameter an object, which is assumed to be the * category row object retrieved the database. It will cache the category data. * * If you pass $category an integer of the category ID, then that category will * be retrieved from the database, if it isn't already cached, and pass it back. * * If you look at get_term(), then both types will be passed through several * filters and finally sanitized based on the $filter parameter value. * * The category will converted to maintain backwards compatibility. * * @since 1.5.1 * @uses get_term() Used to get the category data from the taxonomy. * * @param int|object $category Category ID or Category row object * @param string $output Optional. Constant OBJECT, ARRAY_A, or ARRAY_N * @param string $filter Optional. Default is raw or no WordPress defined filter will applied. * @return mixed Category data in type defined by $output parameter. */function &get_category( $category, $output = OBJECT, $filter = 'raw' ) {	$category = get_term( $category, 'category', $output, $filter );	if ( is_wp_error( $category ) )		return $category;	_make_cat_compat( $category );	return $category;}/** * Retrieve category based on URL containing the category slug. * * Breaks the $category_path parameter up to get the category slug. * * Tries to find the child path and will return it. If it doesn't find a * match, then it will return the first category matching slug, if $full_match, * is set to false. If it does not, then it will return null. * * It is also possible that it will return a WP_Error object on failure. Check * for it when using this function. * * @since 2.1.0 * * @param string $category_path URL containing category slugs. * @param bool $full_match Optional. Whether full path should be matched. * @param string $output Optional. Constant OBJECT, ARRAY_A, or ARRAY_N * @return null|object|array Null on failure. Type is based on $output value. */function get_category_by_path( $category_path, $full_match = true, $output = OBJECT ) {	$category_path = rawurlencode( urldecode( $category_path ) );	$category_path = str_replace( '%2F', '/', $category_path );	$category_path = str_replace( '%20', ' ', $category_path );	$category_paths = '/' . trim( $category_path, '/' );	$leaf_path  = sanitize_title( basename( $category_paths ) );	$category_paths = explode( '/', $category_paths );	$full_path = '';	foreach ( (array) $category_paths as $pathdir )		$full_path .= ( $pathdir != '' ? '/' : '' ) . sanitize_title( $pathdir );	$categories = get_terms( 'category', array('get' => 'all', 'slug' => $leaf_path) );	if ( empty( $categories ) )		return null;	foreach ( $categories as $category ) {		$path = '/' . $leaf_path;		$curcategory = $category;		while ( ( $curcategory->parent != 0 ) && ( $curcategory->parent != $curcategory->term_id ) ) {			$curcategory = get_term( $curcategory->parent, 'category' );			if ( is_wp_error( $curcategory ) )				return $curcategory;			$path = '/' . $curcategory->slug . $path;		}		if ( $path == $full_path )			return get_category( $category->term_id, $output );	}	// If full matching is not required, return the first cat that matches the leaf.	if ( ! $full_match )		return get_category( $categories[0]->term_id, $output );	return null;}/** * Retrieve category object by category slug. * * @since 2.3.0 * * @param string $slug The category slug. * @return object Category data object */function get_category_by_slug( $slug  ) {	$category = get_term_by( 'slug', $slug, 'category' );	if ( $category )		_make_cat_compat( $category );	return $category;}/** * Retrieve the ID of a category from its name. * * @since 1.0.0 * * @param string $cat_name Optional. Default is 'General' and can be any category name. * @return int 0, if failure and ID of category on success. */function get_cat_ID( $cat_name='General' ) {	$cat = get_term_by( 'name', $cat_name, 'category' );	if ( $cat )		return $cat->term_id;	return 0;}/** * Retrieve the name of a category from its ID. * * @since 1.0.0 * * @param int $cat_id Category ID * @return string Category name, or an empty string if category doesn't exist. */function get_cat_name( $cat_id ) {	$cat_id = (int) $cat_id;	$category = &get_category( $cat_id );	if ( ! $category || is_wp_error( $category ) )		return '';	return $category->name;}/** * Check if a category is an ancestor of another category. * * You can use either an id or the category object for both parameters. If you * use an integer the category will be retrieved. * * @since 2.1.0 * * @param int|object $cat1 ID or object to check if this is the parent category. * @param int|object $cat2 The child category. * @return bool Whether $cat2 is child of $cat1 */function cat_is_ancestor_of( $cat1, $cat2 ) {	if ( ! isset($cat1->term_id) )		$cat1 = &get_category( $cat1 );	if ( ! isset($cat2->parent) )		$cat2 = &get_category( $cat2 );	if ( empty($cat1->term_id) || empty($cat2->parent) )		return false;	if ( $cat2->parent == $cat1->term_id )		return true;	return cat_is_ancestor_of( $cat1, get_category( $cat2->parent ) );}/** * Sanitizes category data based on context. * * @since 2.3.0 * @uses sanitize_term() See this function for what context are supported. * * @param object|array $category Category data * @param string $context Optional. Default is 'display'. * @return object|array Same type as $category with sanitized data for safe use. */function sanitize_category( $category, $context = 'display' ) {	return sanitize_term( $category, 'category', $context );}/** * Sanitizes data in single category key field. * * @since 2.3.0 * @uses sanitize_term_field() See function for more details. * * @param string $field Category key to sanitize * @param mixed $value Category value to sanitize * @param int $cat_id Category ID * @param string $context What filter to use, 'raw', 'display', etc. * @return mixed Same type as $value after $value has been sanitized. */function sanitize_category_field( $field, $value, $cat_id, $context ) {	return sanitize_term_field( $field, $value, $cat_id, 'category', $context );}/* Tags *//** * Retrieves all post tags. * * @since 2.3.0 * @see get_terms() For list of arguments to pass. * @uses apply_filters() Calls 'get_tags' hook on array of tags and with $args. * * @param string|array $args Tag arguments to use when retrieving tags. * @return array List of tags. */function &get_tags( $args = '' ) {	$tags = get_terms( 'post_tag', $args );	if ( empty( $tags ) ) {		$return = array();		return $return;	}	$tags = apply_filters( 'get_tags', $tags, $args );	return $tags;}/** * Retrieve post tag by tag ID or tag object. * * If you pass the $tag parameter an object, which is assumed to be the tag row * object retrieved the database. It will cache the tag data. * * If you pass $tag an integer of the tag ID, then that tag will * be retrieved from the database, if it isn't already cached, and pass it back. * * If you look at get_term(), then both types will be passed through several * filters and finally sanitized based on the $filter parameter value. * * @since 2.3.0 * * @param int|object $tag * @param string $output Optional. Constant OBJECT, ARRAY_A, or ARRAY_N * @param string $filter Optional. Default is raw or no WordPress defined filter will applied. * @return object|array Return type based on $output value. */function &get_tag( $tag, $output = OBJECT, $filter = 'raw' ) {	return get_term( $tag, 'post_tag', $output, $filter );}/* Cache *//** * Update the categories cache. * * This function does not appear to be used anymore or does not appear to be * needed. It might be a legacy function left over from when there was a need * for updating the category cache. * * @since 1.5.0 * * @return bool Always return True */function update_category_cache() {	return true;}/** * Remove the category cache data based on ID. * * @since 2.1.0 * @uses clean_term_cache() Clears the cache for the category based on ID * * @param int $id Category ID */function clean_category_cache( $id ) {	clean_term_cache( $id, 'category' );}/** * Update category structure to old pre 2.3 from new taxonomy structure. * * This function was added for the taxonomy support to update the new category * structure with the old category one. This will maintain compatibility with * plugins and themes which depend on the old key or property names. * * The parameter should only be passed a variable and not create the array or * object inline to the parameter. The reason for this is that parameter is * passed by reference and PHP will fail unless it has the variable. * * There is no return value, because everything is updated on the variable you * pass to it. This is one of the features with using pass by reference in PHP. * * @since 2.3.0 * @access private * * @param array|object $category Category Row object or array */function _make_cat_compat( &$category ) {	if ( is_object( $category ) ) {		$category->cat_ID = &$category->term_id;		$category->category_count = &$category->count;		$category->category_description = &$category->description;		$category->cat_name = &$category->name;		$category->category_nicename = &$category->slug;		$category->category_parent = &$category->parent;	} elseif ( is_array( $category ) && isset( $category['term_id'] ) ) {		$category['cat_ID'] = &$category['term_id'];		$category['category_count'] = &$category['count'];		$category['category_description'] = &$category['description'];		$category['cat_name'] = &$category['name'];		$category['category_nicename'] = &$category['slug'];		$category['category_parent'] = &$category['parent'];	}}?>
<?php/** * These functions are needed to load Multisite. * * @since 3.0.0 * * @package WordPress * @subpackage Multisite *//** * Whether a subdomain configuration is enabled. * * @since 3.0.0 * * @return bool True if subdomain configuration is enabled, false otherwise. */function is_subdomain_install() {	if ( defined('SUBDOMAIN_INSTALL') )		return SUBDOMAIN_INSTALL;	if ( defined('VHOST') && VHOST == 'yes' )		return true;	return false;}/** * Checks status of current blog. * * Checks if the blog is deleted, inactive, archived, or spammed. * * Dies with a default message if the blog does not pass the check. * * To change the default message when a blog does not pass the check, * use the wp-content/blog-deleted.php, blog-inactive.php and * blog-suspended.php drop-ins. * * @return bool|string Returns true on success, or drop-in file to include. */function ms_site_check() {	global $wpdb, $current_blog;	// Allow short-circuiting	$check = apply_filters('ms_site_check', null);	if ( null !== $check )		return true;	// Allow super admins to see blocked sites	if ( is_super_admin() )		return true;	if ( '1' == $current_blog->deleted ) {		if ( file_exists( WP_CONTENT_DIR . '/blog-deleted.php' ) ) {			return WP_CONTENT_DIR . '/blog-deleted.php';		} else {			header( 'HTTP/1.1 410 Gone' );			wp_die( /*WP_I18N_USER_DELETED_BLOG*/'This user has elected to delete their account and the content is no longer available.'/*/WP_I18N_USER_DELETED_BLOG*/ );		}	}	if ( '2' == $current_blog->deleted ) {		if ( file_exists( WP_CONTENT_DIR . '/blog-inactive.php' ) )			return WP_CONTENT_DIR . '/blog-inactive.php';		else			wp_die( sprintf( /*WP_I18N_BLOG_NOT_ACTIVATED*/'This site has not been activated yet. If you are having problems activating your site, please contact <a href="mailto:%1$s">%1$s</a>.'/*/WP_I18N_BLOG_NOT_ACTIVATED*/, str_replace( '@', ' AT ', get_site_option( 'admin_email', "support@{$current_site->domain}" ) ) ) );	}	if ( $current_blog->archived == '1' || $current_blog->spam == '1' ) {		if ( file_exists( WP_CONTENT_DIR . '/blog-suspended.php' ) ) {			return WP_CONTENT_DIR . '/blog-suspended.php';		} else {			header( 'HTTP/1.1 410 Gone' );			wp_die( /*WP_I18N_ARCHIVED*/'This site has been archived or suspended.'/*/WP_I18N_ARCHIVED*/ );		}	}	return true;}/** * Sets current site name. * * @access private * @since 3.0.0 * @return object $current_site object with site_name */function get_current_site_name( $current_site ) {	global $wpdb;	$current_site->site_name = wp_cache_get( $current_site->id . ':current_site_name', 'site-options' );	if ( ! $current_site->site_name ) {		$current_site->site_name = wp_cache_get( $current_site->id . ':site_name', 'site-options' );		if ( ! $current_site->site_name ) {			$current_site->site_name = $wpdb->get_var( $wpdb->prepare( "SELECT meta_value FROM $wpdb->sitemeta WHERE site_id = %d AND meta_key = 'site_name'", $current_site->id ) );			if ( ! $current_site->site_name )				$current_site->site_name = ucfirst( $current_site->domain );		}		wp_cache_set( $current_site->id . ':current_site_name', $current_site->site_name, 'site-options' );	}	return $current_site;}/** * Sets current_site object. * * @access private * @since 3.0.0 * @return object $current_site object */function wpmu_current_site() {	global $wpdb, $current_site, $domain, $path, $sites, $cookie_domain;	if ( defined( 'DOMAIN_CURRENT_SITE' ) && defined( 'PATH_CURRENT_SITE' ) ) {		$current_site->id = defined( 'SITE_ID_CURRENT_SITE' ) ? SITE_ID_CURRENT_SITE : 1;		$current_site->domain = DOMAIN_CURRENT_SITE;		$current_site->path   = $path = PATH_CURRENT_SITE;		if ( defined( 'BLOG_ID_CURRENT_SITE' ) )			$current_site->blog_id = BLOG_ID_CURRENT_SITE;		elseif ( defined( 'BLOGID_CURRENT_SITE' ) ) // deprecated.			$current_site->blog_id = BLOGID_CURRENT_SITE;		if ( DOMAIN_CURRENT_SITE == $domain )			$current_site->cookie_domain = $cookie_domain;		elseif ( substr( $current_site->domain, 0, 4 ) == 'www.' )			$current_site->cookie_domain = substr( $current_site->domain, 4 );		else			$current_site->cookie_domain = $current_site->domain;		wp_load_core_site_options( $current_site->id );		return $current_site;	}	$current_site = wp_cache_get( 'current_site', 'site-options' );	if ( $current_site )		return $current_site;	$sites = $wpdb->get_results( "SELECT * FROM $wpdb->site" ); // usually only one site	if ( 1 == count( $sites ) ) {		$current_site = $sites[0];		wp_load_core_site_options( $current_site->id );		$path = $current_site->path;		$current_site->blog_id = $wpdb->get_var( $wpdb->prepare( "SELECT blog_id FROM $wpdb->blogs WHERE domain = %s AND path = %s", $current_site->domain, $current_site->path ) );		$current_site = get_current_site_name( $current_site );		if ( substr( $current_site->domain, 0, 4 ) == 'www.' )			$current_site->cookie_domain = substr( $current_site->domain, 4 );		wp_cache_set( 'current_site', $current_site, 'site-options' );		return $current_site;	}	$path = substr( $_SERVER[ 'REQUEST_URI' ], 0, 1 + strpos( $_SERVER[ 'REQUEST_URI' ], '/', 1 ) );	if ( $domain == $cookie_domain )		$current_site = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->site WHERE domain = %s AND path = %s", $domain, $path ) );	else		$current_site = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->site WHERE domain IN ( %s, %s ) AND path = %s ORDER BY CHAR_LENGTH( domain ) DESC LIMIT 1", $domain, $cookie_domain, $path ) );	if ( ! $current_site ) {		if ( $domain == $cookie_domain )			$current_site = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->site WHERE domain = %s AND path='/'", $domain ) );		else			$current_site = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->site WHERE domain IN ( %s, %s ) AND path = '/' ORDER BY CHAR_LENGTH( domain ) DESC LIMIT 1", $domain, $cookie_domain, $path ) );	}	if ( $current_site ) {		$path = $current_site->path;		$current_site->cookie_domain = $cookie_domain;		return $current_site;	}	if ( is_subdomain_install() ) {		$sitedomain = substr( $domain, 1 + strpos( $domain, '.' ) );		$current_site = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->site WHERE domain = %s AND path = %s", $sitedomain, $path) );		if ( $current_site ) {			$current_site->cookie_domain = $current_site->domain;			return $current_site;		}		$current_site = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->site WHERE domain = %s AND path='/'", $sitedomain) );	}	if ( $current_site || defined( 'WP_INSTALLING' ) ) {		$path = '/';		return $current_site;	}	// Still no dice.	// @todo Update or remove WPMU codex link.	if ( 1 == count( $sites ) )		wp_die( sprintf( /*WP_I18N_BLOG_DOESNT_EXIST*/'That site does not exist. Please try <a href="%s">%s</a>.'/*/WP_I18N_BLOG_DOESNT_EXIST*/, $sites[0]->domain . $sites[0]->path ) );	else		wp_die( /*WP_I18N_NO_SITE_DEFINED*/'No site defined on this host. If you are the owner of this site, please check <a href="http://codex.wordpress.org/Debugging_WPMU">Debugging WPMU</a> for help.'/*/WP_I18N_NO_SITE_DEFINED*/ );}/** * Displays a failure message. * * Used when a blog's tables do not exist. Checks for a missing $wpdb->site table as well. * * @todo update Codex link for 3.0.0 * * @access private * @since 3.0.0 */function ms_not_installed() {	global $wpdb, $domain, $path;	$title = /*WP_I18N_FATAL_ERROR*/'Error establishing database connection'/*/WP_I18N_FATAL_ERROR*/;	$msg  = '<h1>' . $title . '</h1>';	if ( ! is_admin() )		die( $msg );	$msg .= '<p>' . /*WP_I18N_CONTACT_OWNER*/'If your site does not display, please contact the owner of this network.'/*/WP_I18N_CONTACT_OWNER*/ . '';	$msg .= ' ' . /*WP_I18N_CHECK_MYSQL*/'If you are the owner of this network please check that MySQL is running properly and all tables are error free.'/*/WP_I18N_CHECK_MYSQL*/ . '</p>';	if ( false && !$wpdb->get_var( "SHOW TABLES LIKE '$wpdb->site'" ) )		$msg .= '<p>' . sprintf( /*WP_I18N_TABLES_MISSING_LONG*/'<strong>Database tables are missing.</strong> This means that MySQL is not running, WordPress was not installed properly, or someone deleted <code>%s</code>. You really should look at your database now.'/*/WP_I18N_TABLES_MISSING_LONG*/, $wpdb->site ) . '</p>';	else		$msg .= '<p>' . sprintf( /*WP_I18N_NO_SITE_FOUND*/'<strong>Could not find site <code>%1$s</code>.</strong> Searched for table <code>%2$s</code> in database <code>%3$s</code>. Is that right?'/*/WP_I18N_NO_SITE_FOUND*/, rtrim( $domain . $path, '/' ), $wpdb->blogs, DB_NAME ) . '</p>';	$msg .= '<p><strong>' . /*WP_I18N_WHAT_DO_I_DO*/'What do I do now?'/*WP_I18N_WHAT_DO_I_DO*/ . '</strong> ';	$msg .= /*WP_I18N_RTFM*/'Read the <a target="_blank" href="http://codex.wordpress.org/Debugging_WPMU">bug report</a> page. Some of the guidelines there may help you figure out what went wrong.'/*/WP_I18N_RTFM*/;	$msg .= ' ' . /*WP_I18N_STUCK*/'If you&#8217;re still stuck with this message, then check that your database contains the following tables:'/*/WP_I18N_STUCK*/ . '</p><ul>';	foreach ( $wpdb->tables('global') as $t => $table ) {		if ( 'sitecategories' == $t )			continue;		$msg .= '<li>' . $table . '</li>';	}	$msg .= '</ul>';	wp_die( $msg, $title );}?>
<?php/** * The Header for our theme. * * Displays all of the <head> section and everything up till <div id="main"> * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */?><!DOCTYPE html><html <?php language_attributes(); ?>><head><meta charset="<?php bloginfo( 'charset' ); ?>" /><title><?php	/*	 * Print the <title> tag based on what is being viewed.	 * We filter the output of wp_title() a bit -- see	 * twentyten_filter_wp_title() in functions.php.	 */	wp_title( '|', true, 'right' );	?></title><link rel="profile" href="http://gmpg.org/xfn/11" /><link rel="stylesheet" type="text/css" media="all" href="<?php bloginfo( 'stylesheet_url' ); ?>" /><link rel="pingback" href="<?php bloginfo( 'pingback_url' ); ?>" /><?php	/* We add some JavaScript to pages with the comment form	 * to support sites with threaded comments (when in use).	 */	if ( is_singular() && get_option( 'thread_comments' ) )		wp_enqueue_script( 'comment-reply' );	/* Always have wp_head() just before the closing </head>	 * tag of your theme, or you will break many plugins, which	 * generally use this hook to add elements to <head> such	 * as styles, scripts, and meta tags.	 */	wp_head();?></head><body <?php body_class(); ?>><div id="wrapper" class="hfeed">	<div id="header">		<div id="masthead">			<div id="branding" role="banner">				<?php $heading_tag = ( is_home() || is_front_page() ) ? 'h1' : 'div'; ?>				<<?php echo $heading_tag; ?> id="site-title">					<span>						<a href="<?php echo home_url( '/' ); ?>" title="<?php echo esc_attr( get_bloginfo( 'name', 'display' ) ); ?>" rel="home"><?php bloginfo( 'name' ); ?></a>					</span>				</<?php echo $heading_tag; ?>>				<div id="site-description"><?php bloginfo( 'description' ); ?></div>				<?php					// Check if this is a post or page, if it has a thumbnail, and if it's a big one					if ( is_singular() &&							has_post_thumbnail( $post->ID ) &&							( /* $src, $width, $height */ $image = wp_get_attachment_image_src( get_post_thumbnail_id( $post->ID ), 'post-thumbnail' ) ) &&							$image[1] >= HEADER_IMAGE_WIDTH ) :						// Houston, we have a new header image!						echo get_the_post_thumbnail( $post->ID, 'post-thumbnail' );					else : ?>						<img src="<?php header_image(); ?>" width="<?php echo HEADER_IMAGE_WIDTH; ?>" height="<?php echo HEADER_IMAGE_HEIGHT; ?>" alt="" />					<?php endif; ?>			</div><!-- #branding -->			<div id="access" role="navigation">			  <?php /*  Allow screen readers / text browsers to skip the navigation menu and get right to the good stuff */ ?>				<div class="skip-link screen-reader-text"><a href="#content" title="<?php esc_attr_e( 'Skip to content', 'twentyten' ); ?>"><?php _e( 'Skip to content', 'twentyten' ); ?></a></div>				<?php /* Our navigation menu.  If one isn't filled out, wp_nav_menu falls back to wp_page_menu.  The menu assiged to the primary position is the one used.  If none is assigned, the menu with the lowest ID is used.  */ ?>				<?php wp_nav_menu( array( 'container_class' => 'menu-header', 'theme_location' => 'primary' ) ); ?>			</div><!-- #access -->		</div><!-- #masthead -->	</div><!-- #header -->	<div id="main">
<?php/** * The template for displaying 404 pages (Not Found). * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>	<div id="container">		<div id="content" role="main">			<div id="post-0" class="post error404 not-found">				<h1 class="entry-title"><?php _e( 'Not Found', 'twentyten' ); ?></h1>				<div class="entry-content">					<p><?php _e( 'Apologies, but the page you requested could not be found. Perhaps searching will help.', 'twentyten' ); ?></p>					<?php get_search_form(); ?>				</div><!-- .entry-content -->			</div><!-- #post-0 -->		</div><!-- #content -->	</div><!-- #container -->	<script type="text/javascript">		// focus on search field after it has loaded		document.getElementById('s') && document.getElementById('s').focus();	</script><?php get_footer(); ?>
<?php/** * @package WordPress * @subpackage Theme_Compat * @deprecated 3.0 *  * This file is here for Backwards compatibility with old themes and will be removed in a future version *  */_deprecated_file( sprintf( __( 'Theme without %1$s' ), basename(__FILE__) ), '3.0', null, sprintf( __('Please include a %1$s template in your theme.'), basename(__FILE__) ) );?><hr /><div id="footer" role="contentinfo"><!-- If you'd like to support WordPress, having the "powered by" link somewhere on your blog is the best way; it's our only promotion or advertising. -->	<p>		<?php printf(__('%1$s is proudly powered by %2$s'), get_bloginfo('name'),		'<a href="http://wordpress.org/">WordPress</a>'); ?>		<br /><?php printf(__('%1$s and %2$s.'), '<a href="' . get_bloginfo('rss2_url') . '">' . __('Entries (RSS)') . '</a>', '<a href="' . get_bloginfo('comments_rss2_url') . '">' . __('Comments (RSS)') . '</a>'); ?>		<!-- <?php printf(__('%d queries. %s seconds.'), get_num_queries(), timer_stop(0, 3)); ?> -->	</p></div></div><!-- Gorgeous design by Michael Heilemann - http://binarybonsai.com/kubrick/ --><?php /* "Just what do you think you're doing Dave?" */ ?>		<?php wp_footer(); ?></body></html>
<?php/** * New Post Administration Panel. * * @package WordPress * @subpackage Administration *//** Load WordPress Administration Bootstrap */require_once('./admin.php');if ( !isset($_GET['post_type']) )	$post_type = 'post';elseif ( in_array( $_GET['post_type'], get_post_types( array('show_ui' => true ) ) ) )	$post_type = $_GET['post_type'];else	wp_die( __('Invalid post type') );if ( 'post' != $post_type ) {	$parent_file = "edit.php?post_type=$post_type";	$submenu_file = "post-new.php?post_type=$post_type";} else {	$parent_file = 'edit.php';	$submenu_file = 'post-new.php';}$post_type_object = get_post_type_object($post_type);$title = $post_type_object->labels->add_new_item;$editing = true;if ( 'post' == $post_type && !current_user_can('edit_posts') ) {	include('./admin-header.php'); ?><div class="wrap"><p><?php printf(__('Since you&#8217;re a newcomer, you&#8217;ll have to wait for an admin to add the <code>edit_posts</code> capability to your user, in order to be authorized to post.<br />You can also <a href="mailto:%s?subject=Promotion?">e-mail the admin</a> to ask for a promotion.<br />When you&#8217;re promoted, just reload this page and you&#8217;ll be able to blog. :)'), get_option('admin_email')); ?></p></div><?php	include('./admin-footer.php');	exit();}wp_enqueue_script('autosave');// Show post form.if ( current_user_can($post_type_object->cap->edit_posts) ) {	$post = get_default_post_to_edit( $post_type, true );	$post_ID = $post->ID;	include('edit-form-advanced.php');}include('./admin-footer.php');?>
<?php/** * The template for displaying all pages. * * This is the template that displays all pages by default. * Please note that this is the wordpress construct of pages * and that other 'pages' on your wordpress site will use a * different template. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main"><?php if ( have_posts() ) while ( have_posts() ) : the_post(); ?>				<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>					<?php if ( is_front_page() ) { ?>						<h2 class="entry-title"><?php the_title(); ?></h2>					<?php } else { ?>							<h1 class="entry-title"><?php the_title(); ?></h1>					<?php } ?>									<div class="entry-content">						<?php the_content(); ?>						<?php wp_link_pages( array( 'before' => '<div class="page-link">' . __( 'Pages:', 'twentyten' ), 'after' => '</div>' ) ); ?>						<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="edit-link">', '</span>' ); ?>					</div><!-- .entry-content -->				</div><!-- #post-## -->				<?php comments_template( '', true ); ?><?php endwhile; ?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
<?php/* Continent and city translations for timezone selection. * This file is not included anywhere. It exists solely for use by xgettext. */__('Africa', 'continents-cities');__('Abidjan', 'continents-cities');__('Accra', 'continents-cities');__('Addis Ababa', 'continents-cities');__('Algiers', 'continents-cities');__('Asmara', 'continents-cities');__('Asmera', 'continents-cities');__('Bamako', 'continents-cities');__('Bangui', 'continents-cities');__('Banjul', 'continents-cities');__('Bissau', 'continents-cities');__('Blantyre', 'continents-cities');__('Brazzaville', 'continents-cities');__('Bujumbura', 'continents-cities');__('Cairo', 'continents-cities');__('Casablanca', 'continents-cities');__('Ceuta', 'continents-cities');__('Conakry', 'continents-cities');__('Dakar', 'continents-cities');__('Dar es Salaam', 'continents-cities');__('Djibouti', 'continents-cities');__('Douala', 'continents-cities');__('El Aaiun', 'continents-cities');__('Freetown', 'continents-cities');__('Gaborone', 'continents-cities');__('Harare', 'continents-cities');__('Johannesburg', 'continents-cities');__('Kampala', 'continents-cities');__('Khartoum', 'continents-cities');__('Kigali', 'continents-cities');__('Kinshasa', 'continents-cities');__('Lagos', 'continents-cities');__('Libreville', 'continents-cities');__('Lome', 'continents-cities');__('Luanda', 'continents-cities');__('Lubumbashi', 'continents-cities');__('Lusaka', 'continents-cities');__('Malabo', 'continents-cities');__('Maputo', 'continents-cities');__('Maseru', 'continents-cities');__('Mbabane', 'continents-cities');__('Mogadishu', 'continents-cities');__('Monrovia', 'continents-cities');__('Nairobi', 'continents-cities');__('Ndjamena', 'continents-cities');__('Niamey', 'continents-cities');__('Nouakchott', 'continents-cities');__('Ouagadougou', 'continents-cities');__('Porto-Novo', 'continents-cities');__('Sao Tome', 'continents-cities');__('Timbuktu', 'continents-cities');__('Tripoli', 'continents-cities');__('Tunis', 'continents-cities');__('Windhoek', 'continents-cities');__('America', 'continents-cities');__('Adak', 'continents-cities');__('Anchorage', 'continents-cities');__('Anguilla', 'continents-cities');__('Antigua', 'continents-cities');__('Araguaina', 'continents-cities');__('Argentina', 'continents-cities');__('Buenos Aires', 'continents-cities');__('Catamarca', 'continents-cities');__('ComodRivadavia', 'continents-cities');__('Cordoba', 'continents-cities');__('Jujuy', 'continents-cities');__('La Rioja', 'continents-cities');__('Mendoza', 'continents-cities');__('Rio Gallegos', 'continents-cities');__('San Juan', 'continents-cities');__('San Luis', 'continents-cities');__('Tucuman', 'continents-cities');__('Ushuaia', 'continents-cities');__('Aruba', 'continents-cities');__('Asuncion', 'continents-cities');__('Atikokan', 'continents-cities');__('Atka', 'continents-cities');__('Bahia', 'continents-cities');__('Barbados', 'continents-cities');__('Belem', 'continents-cities');__('Belize', 'continents-cities');__('Blanc-Sablon', 'continents-cities');__('Boa Vista', 'continents-cities');__('Bogota', 'continents-cities');__('Boise', 'continents-cities');__('Cambridge Bay', 'continents-cities');__('Campo Grande', 'continents-cities');__('Cancun', 'continents-cities');__('Caracas', 'continents-cities');__('Cayenne', 'continents-cities');__('Cayman', 'continents-cities');__('Chicago', 'continents-cities');__('Chihuahua', 'continents-cities');__('Coral Harbour', 'continents-cities');__('Costa Rica', 'continents-cities');__('Cuiaba', 'continents-cities');__('Curacao', 'continents-cities');__('Danmarkshavn', 'continents-cities');__('Dawson', 'continents-cities');__('Dawson Creek', 'continents-cities');__('Denver', 'continents-cities');__('Detroit', 'continents-cities');__('Dominica', 'continents-cities');__('Edmonton', 'continents-cities');__('Eirunepe', 'continents-cities');__('El Salvador', 'continents-cities');__('Ensenada', 'continents-cities');__('Fort Wayne', 'continents-cities');__('Fortaleza', 'continents-cities');__('Glace Bay', 'continents-cities');__('Godthab', 'continents-cities');__('Goose Bay', 'continents-cities');__('Grand Turk', 'continents-cities');__('Grenada', 'continents-cities');__('Guadeloupe', 'continents-cities');__('Guatemala', 'continents-cities');__('Guayaquil', 'continents-cities');__('Guyana', 'continents-cities');__('Halifax', 'continents-cities');__('Havana', 'continents-cities');__('Hermosillo', 'continents-cities');__('Indiana', 'continents-cities');__('Indianapolis', 'continents-cities');__('Knox', 'continents-cities');__('Marengo', 'continents-cities');__('Petersburg', 'continents-cities');__('Tell City', 'continents-cities');__('Vevay', 'continents-cities');__('Vincennes', 'continents-cities');__('Winamac', 'continents-cities');__('Inuvik', 'continents-cities');__('Iqaluit', 'continents-cities');__('Jamaica', 'continents-cities');__('Juneau', 'continents-cities');__('Kentucky', 'continents-cities');__('Louisville', 'continents-cities');__('Monticello', 'continents-cities');__('Knox IN', 'continents-cities');__('La Paz', 'continents-cities');__('Lima', 'continents-cities');__('Los Angeles', 'continents-cities');__('Maceio', 'continents-cities');__('Managua', 'continents-cities');__('Manaus', 'continents-cities');__('Marigot', 'continents-cities');__('Martinique', 'continents-cities');__('Mazatlan', 'continents-cities');__('Menominee', 'continents-cities');__('Merida', 'continents-cities');__('Mexico City', 'continents-cities');__('Miquelon', 'continents-cities');__('Moncton', 'continents-cities');__('Monterrey', 'continents-cities');__('Montevideo', 'continents-cities');__('Montreal', 'continents-cities');__('Montserrat', 'continents-cities');__('Nassau', 'continents-cities');__('New York', 'continents-cities');__('Nipigon', 'continents-cities');__('Nome', 'continents-cities');__('Noronha', 'continents-cities');__('North Dakota', 'continents-cities');__('Center', 'continents-cities');__('New Salem', 'continents-cities');__('Panama', 'continents-cities');__('Pangnirtung', 'continents-cities');__('Paramaribo', 'continents-cities');__('Phoenix', 'continents-cities');__('Port-au-Prince', 'continents-cities');__('Port of Spain', 'continents-cities');__('Porto Acre', 'continents-cities');__('Porto Velho', 'continents-cities');__('Puerto Rico', 'continents-cities');__('Rainy River', 'continents-cities');__('Rankin Inlet', 'continents-cities');__('Recife', 'continents-cities');__('Regina', 'continents-cities');__('Resolute', 'continents-cities');__('Rio Branco', 'continents-cities');__('Rosario', 'continents-cities');__('Santiago', 'continents-cities');__('Santo Domingo', 'continents-cities');__('Sao Paulo', 'continents-cities');__('Scoresbysund', 'continents-cities');__('Shiprock', 'continents-cities');__('St Barthelemy', 'continents-cities');__('St Johns', 'continents-cities');__('St Kitts', 'continents-cities');__('St Lucia', 'continents-cities');__('St Thomas', 'continents-cities');__('St Vincent', 'continents-cities');__('Swift Current', 'continents-cities');__('Tegucigalpa', 'continents-cities');__('Thule', 'continents-cities');__('Thunder Bay', 'continents-cities');__('Tijuana', 'continents-cities');__('Toronto', 'continents-cities');__('Tortola', 'continents-cities');__('Vancouver', 'continents-cities');__('Virgin', 'continents-cities');__('Whitehorse', 'continents-cities');__('Winnipeg', 'continents-cities');__('Yakutat', 'continents-cities');__('Yellowknife', 'continents-cities');__('Antarctica', 'continents-cities');__('Casey', 'continents-cities');__('Davis', 'continents-cities');__('DumontDUrville', 'continents-cities');__('Mawson', 'continents-cities');__('McMurdo', 'continents-cities');__('Palmer', 'continents-cities');__('Rothera', 'continents-cities');__('South Pole', 'continents-cities');__('Syowa', 'continents-cities');__('Vostok', 'continents-cities');__('Arctic', 'continents-cities');__('Longyearbyen', 'continents-cities');__('Asia', 'continents-cities');__('Aden', 'continents-cities');__('Almaty', 'continents-cities');__('Amman', 'continents-cities');__('Anadyr', 'continents-cities');__('Aqtau', 'continents-cities');__('Aqtobe', 'continents-cities');__('Ashgabat', 'continents-cities');__('Ashkhabad', 'continents-cities');__('Baghdad', 'continents-cities');__('Bahrain', 'continents-cities');__('Baku', 'continents-cities');__('Bangkok', 'continents-cities');__('Beirut', 'continents-cities');__('Bishkek', 'continents-cities');__('Brunei', 'continents-cities');__('Calcutta', 'continents-cities');__('Choibalsan', 'continents-cities');__('Chongqing', 'continents-cities');__('Chungking', 'continents-cities');__('Colombo', 'continents-cities');__('Dacca', 'continents-cities');__('Damascus', 'continents-cities');__('Dhaka', 'continents-cities');__('Dili', 'continents-cities');__('Dubai', 'continents-cities');__('Dushanbe', 'continents-cities');__('Gaza', 'continents-cities');__('Harbin', 'continents-cities');__('Ho Chi Minh', 'continents-cities');__('Hong Kong', 'continents-cities');__('Hovd', 'continents-cities');__('Irkutsk', 'continents-cities');__('Istanbul', 'continents-cities');__('Jakarta', 'continents-cities');__('Jayapura', 'continents-cities');__('Jerusalem', 'continents-cities');__('Kabul', 'continents-cities');__('Kamchatka', 'continents-cities');__('Karachi', 'continents-cities');__('Kashgar', 'continents-cities');__('Katmandu', 'continents-cities');__('Kolkata', 'continents-cities');__('Krasnoyarsk', 'continents-cities');__('Kuala Lumpur', 'continents-cities');__('Kuching', 'continents-cities');__('Kuwait', 'continents-cities');__('Macao', 'continents-cities');__('Macau', 'continents-cities');__('Magadan', 'continents-cities');__('Makassar', 'continents-cities');__('Manila', 'continents-cities');__('Muscat', 'continents-cities');__('Nicosia', 'continents-cities');__('Novosibirsk', 'continents-cities');__('Omsk', 'continents-cities');__('Oral', 'continents-cities');__('Phnom Penh', 'continents-cities');__('Pontianak', 'continents-cities');__('Pyongyang', 'continents-cities');__('Qatar', 'continents-cities');__('Qyzylorda', 'continents-cities');__('Rangoon', 'continents-cities');__('Riyadh', 'continents-cities');__('Saigon', 'continents-cities');__('Sakhalin', 'continents-cities');__('Samarkand', 'continents-cities');__('Seoul', 'continents-cities');__('Shanghai', 'continents-cities');__('Singapore', 'continents-cities');__('Taipei', 'continents-cities');__('Tashkent', 'continents-cities');__('Tbilisi', 'continents-cities');__('Tehran', 'continents-cities');__('Tel Aviv', 'continents-cities');__('Thimbu', 'continents-cities');__('Thimphu', 'continents-cities');__('Tokyo', 'continents-cities');__('Ujung Pandang', 'continents-cities');__('Ulaanbaatar', 'continents-cities');__('Ulan Bator', 'continents-cities');__('Urumqi', 'continents-cities');__('Vientiane', 'continents-cities');__('Vladivostok', 'continents-cities');__('Yakutsk', 'continents-cities');__('Yekaterinburg', 'continents-cities');__('Yerevan', 'continents-cities');__('Atlantic', 'continents-cities');__('Azores', 'continents-cities');__('Bermuda', 'continents-cities');__('Canary', 'continents-cities');__('Cape Verde', 'continents-cities');__('Faeroe', 'continents-cities');__('Faroe', 'continents-cities');__('Jan Mayen', 'continents-cities');__('Madeira', 'continents-cities');__('Reykjavik', 'continents-cities');__('South Georgia', 'continents-cities');__('St Helena', 'continents-cities');__('Stanley', 'continents-cities');__('Australia', 'continents-cities');__('ACT', 'continents-cities');__('Adelaide', 'continents-cities');__('Brisbane', 'continents-cities');__('Broken Hill', 'continents-cities');__('Canberra', 'continents-cities');__('Currie', 'continents-cities');__('Darwin', 'continents-cities');__('Eucla', 'continents-cities');__('Hobart', 'continents-cities');__('LHI', 'continents-cities');__('Lindeman', 'continents-cities');__('Lord Howe', 'continents-cities');__('Melbourne', 'continents-cities');__('North', 'continents-cities');__('NSW', 'continents-cities');__('Perth', 'continents-cities');__('Queensland', 'continents-cities');__('South', 'continents-cities');__('Sydney', 'continents-cities');__('Tasmania', 'continents-cities');__('Victoria', 'continents-cities');__('West', 'continents-cities');__('Yancowinna', 'continents-cities');__('Etc', 'continents-cities');__('GMT', 'continents-cities');__('GMT+0', 'continents-cities');__('GMT+1', 'continents-cities');__('GMT+10', 'continents-cities');__('GMT+11', 'continents-cities');__('GMT+12', 'continents-cities');__('GMT+2', 'continents-cities');__('GMT+3', 'continents-cities');__('GMT+4', 'continents-cities');__('GMT+5', 'continents-cities');__('GMT+6', 'continents-cities');__('GMT+7', 'continents-cities');__('GMT+8', 'continents-cities');__('GMT+9', 'continents-cities');__('GMT-0', 'continents-cities');__('GMT-1', 'continents-cities');__('GMT-10', 'continents-cities');__('GMT-11', 'continents-cities');__('GMT-12', 'continents-cities');__('GMT-13', 'continents-cities');__('GMT-14', 'continents-cities');__('GMT-2', 'continents-cities');__('GMT-3', 'continents-cities');__('GMT-4', 'continents-cities');__('GMT-5', 'continents-cities');__('GMT-6', 'continents-cities');__('GMT-7', 'continents-cities');__('GMT-8', 'continents-cities');__('GMT-9', 'continents-cities');__('GMT0', 'continents-cities');__('Greenwich', 'continents-cities');__('UCT', 'continents-cities');__('Universal', 'continents-cities');__('UTC', 'continents-cities');__('Zulu', 'continents-cities');__('Europe', 'continents-cities');__('Amsterdam', 'continents-cities');__('Andorra', 'continents-cities');__('Athens', 'continents-cities');__('Belfast', 'continents-cities');__('Belgrade', 'continents-cities');__('Berlin', 'continents-cities');__('Bratislava', 'continents-cities');__('Brussels', 'continents-cities');__('Bucharest', 'continents-cities');__('Budapest', 'continents-cities');__('Chisinau', 'continents-cities');__('Copenhagen', 'continents-cities');__('Dublin', 'continents-cities');__('Gibraltar', 'continents-cities');__('Guernsey', 'continents-cities');__('Helsinki', 'continents-cities');__('Isle of Man', 'continents-cities');__('Jersey', 'continents-cities');__('Kaliningrad', 'continents-cities');__('Kiev', 'continents-cities');__('Lisbon', 'continents-cities');__('Ljubljana', 'continents-cities');__('London', 'continents-cities');__('Luxembourg', 'continents-cities');__('Madrid', 'continents-cities');__('Malta', 'continents-cities');__('Mariehamn', 'continents-cities');__('Minsk', 'continents-cities');__('Monaco', 'continents-cities');__('Moscow', 'continents-cities');__('Oslo', 'continents-cities');__('Paris', 'continents-cities');__('Podgorica', 'continents-cities');__('Prague', 'continents-cities');__('Riga', 'continents-cities');__('Rome', 'continents-cities');__('Samara', 'continents-cities');__('San Marino', 'continents-cities');__('Sarajevo', 'continents-cities');__('Simferopol', 'continents-cities');__('Skopje', 'continents-cities');__('Sofia', 'continents-cities');__('Stockholm', 'continents-cities');__('Tallinn', 'continents-cities');__('Tirane', 'continents-cities');__('Tiraspol', 'continents-cities');__('Uzhgorod', 'continents-cities');__('Vaduz', 'continents-cities');__('Vatican', 'continents-cities');__('Vienna', 'continents-cities');__('Vilnius', 'continents-cities');__('Volgograd', 'continents-cities');__('Warsaw', 'continents-cities');__('Zagreb', 'continents-cities');__('Zaporozhye', 'continents-cities');__('Zurich', 'continents-cities');__('Indian', 'continents-cities');__('Antananarivo', 'continents-cities');__('Chagos', 'continents-cities');__('Christmas', 'continents-cities');__('Cocos', 'continents-cities');__('Comoro', 'continents-cities');__('Kerguelen', 'continents-cities');__('Mahe', 'continents-cities');__('Maldives', 'continents-cities');__('Mauritius', 'continents-cities');__('Mayotte', 'continents-cities');__('Reunion', 'continents-cities');__('Pacific', 'continents-cities');__('Apia', 'continents-cities');__('Auckland', 'continents-cities');__('Chatham', 'continents-cities');__('Easter', 'continents-cities');__('Efate', 'continents-cities');__('Enderbury', 'continents-cities');__('Fakaofo', 'continents-cities');__('Fiji', 'continents-cities');__('Funafuti', 'continents-cities');__('Galapagos', 'continents-cities');__('Gambier', 'continents-cities');__('Guadalcanal', 'continents-cities');__('Guam', 'continents-cities');__('Honolulu', 'continents-cities');__('Johnston', 'continents-cities');__('Kiritimati', 'continents-cities');__('Kosrae', 'continents-cities');__('Kwajalein', 'continents-cities');__('Majuro', 'continents-cities');__('Marquesas', 'continents-cities');__('Midway', 'continents-cities');__('Nauru', 'continents-cities');__('Niue', 'continents-cities');__('Norfolk', 'continents-cities');__('Noumea', 'continents-cities');__('Pago Pago', 'continents-cities');__('Palau', 'continents-cities');__('Pitcairn', 'continents-cities');__('Ponape', 'continents-cities');__('Port Moresby', 'continents-cities');__('Rarotonga', 'continents-cities');__('Saipan', 'continents-cities');__('Samoa', 'continents-cities');__('Tahiti', 'continents-cities');__('Tarawa', 'continents-cities');__('Tongatapu', 'continents-cities');__('Truk', 'continents-cities');__('Wake', 'continents-cities');__('Wallis', 'continents-cities');__('Yap', 'continents-cities');
