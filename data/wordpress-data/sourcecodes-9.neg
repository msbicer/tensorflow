<?php/** * Edit Comments Administration Panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( !current_user_can('edit_posts') )	wp_die(__('Cheatin&#8217; uh?'));wp_enqueue_script('admin-comments');enqueue_comment_hotkeys_js();$post_id = isset($_REQUEST['p']) ? (int) $_REQUEST['p'] : 0;if ( isset($_REQUEST['doaction']) ||  isset($_REQUEST['doaction2']) || isset($_REQUEST['delete_all']) || isset($_REQUEST['delete_all2']) ) {	check_admin_referer('bulk-comments');	if ( (isset($_REQUEST['delete_all']) || isset($_REQUEST['delete_all2'])) && !empty($_REQUEST['pagegen_timestamp']) ) {		$comment_status = $wpdb->escape($_REQUEST['comment_status']);		$delete_time = $wpdb->escape($_REQUEST['pagegen_timestamp']);		$comment_ids = $wpdb->get_col( "SELECT comment_ID FROM $wpdb->comments WHERE comment_approved = '$comment_status' AND '$delete_time' > comment_date_gmt" );		$doaction = 'delete';	} elseif ( ($_REQUEST['action'] != -1 || $_REQUEST['action2'] != -1) && isset($_REQUEST['delete_comments']) ) {		$comment_ids = $_REQUEST['delete_comments'];		$doaction = ($_REQUEST['action'] != -1) ? $_REQUEST['action'] : $_REQUEST['action2'];	} elseif ( $_REQUEST['doaction'] == 'undo' && isset($_REQUEST['ids']) ) {		$comment_ids = array_map( 'absint', explode(',', $_REQUEST['ids']) );		$doaction = $_REQUEST['action'];	} else {		wp_redirect( wp_get_referer() );	}	$approved = $unapproved = $spammed = $unspammed = $trashed = $untrashed = $deleted = 0;	$redirect_to = remove_query_arg( array('trashed', 'untrashed', 'deleted', 'spammed', 'unspammed', 'approved', 'unapproved', 'ids'), wp_get_referer() );	foreach ($comment_ids as $comment_id) { // Check the permissions on each		$_post_id = (int) $wpdb->get_var( $wpdb->prepare( "SELECT comment_post_ID FROM $wpdb->comments WHERE comment_ID = %d", $comment_id) );		if ( !current_user_can('edit_post', $_post_id) )			continue;		switch( $doaction ) {			case 'approve' :				wp_set_comment_status($comment_id, 'approve');				$approved++;				break;			case 'unapprove' :				wp_set_comment_status($comment_id, 'hold');				$unapproved++;				break;			case 'spam' :				wp_spam_comment($comment_id);				$spammed++;				break;			case 'unspam' :				wp_unspam_comment($comment_id);				$unspammed++;				break;			case 'trash' :				wp_trash_comment($comment_id);				$trashed++;				break;			case 'untrash' :				wp_untrash_comment($comment_id);				$untrashed++;				break;			case 'delete' :				wp_delete_comment($comment_id);				$deleted++;				break;		}	}	if ( $approved )		$redirect_to = add_query_arg( 'approved', $approved, $redirect_to );	if ( $unapproved )		$redirect_to = add_query_arg( 'unapproved', $unapproved, $redirect_to );	if ( $spammed )		$redirect_to = add_query_arg( 'spammed', $spammed, $redirect_to );	if ( $unspammed )		$redirect_to = add_query_arg( 'unspammed', $unspammed, $redirect_to );	if ( $trashed )		$redirect_to = add_query_arg( 'trashed', $trashed, $redirect_to );	if ( $untrashed )		$redirect_to = add_query_arg( 'untrashed', $untrashed, $redirect_to );	if ( $deleted )		$redirect_to = add_query_arg( 'deleted', $deleted, $redirect_to );	if ( $trashed || $spammed )		$redirect_to = add_query_arg( 'ids', join(',', $comment_ids), $redirect_to );	wp_redirect( $redirect_to );	exit;} elseif ( ! empty($_GET['_wp_http_referer']) ) {	 wp_redirect( remove_query_arg( array('_wp_http_referer', '_wpnonce'), stripslashes($_SERVER['REQUEST_URI']) ) );	 exit;}if ( $post_id )	$title = sprintf(__('Comments on &#8220;%s&#8221;'), wp_html_excerpt(_draft_or_post_title($post_id), 50));else	$title = __('Comments');add_contextual_help( $current_screen, '<p>' . __('You can manage comments made on your site similar to the way you manage Posts and other content. This screen is customizable in the same ways as other management screens, and you can act on comments using the on-hover action links or the Bulk Actions.') . '</p>' .	'<p>' . __('A yellow row means the comment is waiting for you to moderate it.') . '</p>' .	'<p>' . __('In the Author column, in addition to the author&#8217;s name, email address, and blog URL, the commenter&#8217;s IP address is shown. Clicking on this link will show you all the comments made from this IP address.') . '</p>' .	'<p>' . __('In the Comment column, above each comment it says &#8220;Submitted on,&#8221; followed by the date and time the comment was left on your site. Clicking on the date/time link will take you to that comment on your live site.') . '</p>' .	'<p>' . __('In the In Response To column, there are three elements. The text is the name of the post that inspired the comment, and links to the post editor for that entry. The &#8220;#&#8221; permalink symbol below leads to that post on your live site. The small bubble with the number in it shows how many comments that post has received. If the bubble is gray, you have moderated all comments for that post. If it is blue, there are pending comments. Clicking the bubble will filter the comments screen to show only comments on that post.') . '</p>' .	'<p>' . __('Many people take advantage of keyboard shortcuts to moderate their comments more quickly. Use the link below to learn more.') . '</p>' .	'<p><strong>' . __( 'For more information:' ) . '</strong></p>' .	'<p>' . __( '<a href="http://codex.wordpress.org/Administration_Panels#Comments" target="_blank">Comments Documentation</a>' ) . '</p>' .	'<p>' . __( '<a href="http://codex.wordpress.org/Comment_Spam" target="_blank">Comment Spam Documentation</a>') . '</p>' .	'<p>' . __( '<a href="http://codex.wordpress.org/Keyboard_Shortcuts" target="_blank">Keyboard Shortcuts Documentation</a>') . '</p>' .	'<p>' . __( '<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once('./admin-header.php');$mode = ( empty($_GET['mode']) ) ? 'detail' : esc_attr($_GET['mode']);$comment_status = isset($_REQUEST['comment_status']) ? $_REQUEST['comment_status'] : 'all';if ( !in_array($comment_status, array('all', 'moderated', 'approved', 'spam', 'trash')) )	$comment_status = 'all';$comment_type = !empty($_GET['comment_type']) ? esc_attr($_GET['comment_type']) : '';$search_dirty = ( isset($_GET['s']) ) ? $_GET['s'] : '';$search = esc_attr( $search_dirty ); ?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title );if ( isset($_GET['s']) && $_GET['s'] )	printf( '<span class="subtitle">' . sprintf( __( 'Search results for &#8220;%s&#8221;' ), wp_html_excerpt( esc_html( stripslashes( $_GET['s'] ) ), 50 ) ) . '</span>' ); ?></h2><?phpif ( isset( $_GET['error'] ) ) {	$error = (int) $_GET['error'];	$error_msg = '';	switch ( $error ) {		case 1 :			$error_msg = __( 'Oops, no comment with this ID.' );			break;		case 2 :			$error_msg = __( 'You are not allowed to edit comments on this post.' );			break;	}	if ( $error_msg )		echo '<div id="moderated" class="error"><p>' . $error_msg . '</p></div>';}if ( isset($_GET['approved']) || isset($_GET['deleted']) || isset($_GET['trashed']) || isset($_GET['untrashed']) || isset($_GET['spammed']) || isset($_GET['unspammed']) || isset($_GET['same']) ) {	$approved  = isset( $_GET['approved']  ) ? (int) $_GET['approved']  : 0;	$deleted   = isset( $_GET['deleted']   ) ? (int) $_GET['deleted']   : 0;	$trashed   = isset( $_GET['trashed']   ) ? (int) $_GET['trashed']   : 0;	$untrashed = isset( $_GET['untrashed'] ) ? (int) $_GET['untrashed'] : 0;	$spammed   = isset( $_GET['spammed']   ) ? (int) $_GET['spammed']   : 0;	$unspammed = isset( $_GET['unspammed'] ) ? (int) $_GET['unspammed'] : 0;	$same      = isset( $_GET['same'] )      ? (int) $_GET['same']      : 0;	if ( $approved > 0 || $deleted > 0 || $trashed > 0 || $untrashed > 0 || $spammed > 0 || $unspammed > 0 || $same > 0 ) {		if ( $approved > 0 )			$messages[] = sprintf( _n( '%s comment approved', '%s comments approved', $approved ), $approved );		if ( $spammed > 0 ) {			$ids = isset($_GET['ids']) ? $_GET['ids'] : 0;			$messages[] = sprintf( _n( '%s comment marked as spam.', '%s comments marked as spam.', $spammed ), $spammed ) . ' <a href="' . esc_url( wp_nonce_url( "edit-comments.php?doaction=undo&action=unspam&ids=$ids", "bulk-comments" ) ) . '">' . __('Undo') . '</a><br />';		}		if ( $unspammed > 0 )			$messages[] = sprintf( _n( '%s comment restored from the spam', '%s comments restored from the spam', $unspammed ), $unspammed );		if ( $trashed > 0 ) {			$ids = isset($_GET['ids']) ? $_GET['ids'] : 0;			$messages[] = sprintf( _n( '%s comment moved to the Trash.', '%s comments moved to the Trash.', $trashed ), $trashed ) . ' <a href="' . esc_url( wp_nonce_url( "edit-comments.php?doaction=undo&action=untrash&ids=$ids", "bulk-comments" ) ) . '">' . __('Undo') . '</a><br />';		}		if ( $untrashed > 0 )			$messages[] = sprintf( _n( '%s comment restored from the Trash', '%s comments restored from the Trash', $untrashed ), $untrashed );		if ( $deleted > 0 )			$messages[] = sprintf( _n( '%s comment permanently deleted', '%s comments permanently deleted', $deleted ), $deleted );		if ( $same > 0 && $comment = get_comment( $same ) ) {			switch ( $comment->comment_approved ) {				case '1' :					$messages[] = __('This comment is already approved.') . ' <a href="' . esc_url( admin_url( "comment.php?action=editcomment&c=$same" ) ) . '">' . __( 'Edit comment' ) . '</a>';					break;				case 'trash' :					$messages[] = __( 'This comment is already in the Trash.' ) . ' <a href="' . esc_url( admin_url( 'edit-comments.php?comment_status=trash' ) ) . '"> ' . __( 'View Trash' ) . '</a>';					break;				case 'spam' :					$messages[] = __( 'This comment is already marked as spam.' ) . ' <a href="' . esc_url( admin_url( "comment.php?action=editcomment&c=$same" ) ) . '">' . __( 'Edit comment' ) . '</a>';					break;			}		}		echo '<div id="moderated" class="updated"><p>' . implode( "<br/>\n", $messages ) . '</p></div>';	}}?><form id="comments-form" action="" method="get"><ul class="subsubsub"><?php$status_links = array();$num_comments = ( $post_id ) ? wp_count_comments( $post_id ) : wp_count_comments();//, number_format_i18n($num_comments->moderated) ), "<span class='comment-count'>" . number_format_i18n($num_comments->moderated) . "</span>"),//, number_format_i18n($num_comments->spam) ), "<span class='spam-comment-count'>" . number_format_i18n($num_comments->spam) . "</span>")$stati = array(		'all' => _nx_noop('All', 'All', 'comments'), // singular not used		'moderated' => _n_noop('Pending <span class="count">(<span class="pending-count">%s</span>)</span>', 'Pending <span class="count">(<span class="pending-count">%s</span>)</span>'),		'approved' => _n_noop('Approved', 'Approved'), // singular not used		'spam' => _n_noop('Spam <span class="count">(<span class="spam-count">%s</span>)</span>', 'Spam <span class="count">(<span class="spam-count">%s</span>)</span>'),		'trash' => _n_noop('Trash <span class="count">(<span class="trash-count">%s</span>)</span>', 'Trash <span class="count">(<span class="trash-count">%s</span>)</span>')	);if ( !EMPTY_TRASH_DAYS )	unset($stati['trash']);$link = 'edit-comments.php';if ( !empty($comment_type) && 'all' != $comment_type )	$link = add_query_arg( 'comment_type', $comment_type, $link );foreach ( $stati as $status => $label ) {	$class = ( $status == $comment_status ) ? ' class="current"' : '';	if ( !isset( $num_comments->$status ) )		$num_comments->$status = 10;	$link = add_query_arg( 'comment_status', $status, $link );	if ( $post_id )		$link = add_query_arg( 'p', absint( $post_id ), $link );	/*	// I toyed with this, but decided against it. Leaving it in here in case anyone thinks it is a good idea. ~ Mark	if ( !empty( $_GET['s'] ) )		$link = add_query_arg( 's', esc_attr( stripslashes( $_GET['s'] ) ), $link );	*/	$status_links[] = "<li class='$status'><a href='$link'$class>" . sprintf(		_n( $label[0], $label[1], $num_comments->$status ),		number_format_i18n( $num_comments->$status )	) . '</a>';}$status_links = apply_filters( 'comment_status_links', $status_links );echo implode( " |</li>\n", $status_links) . '</li>';unset($status_links);?></ul><p class="search-box">	<label class="screen-reader-text" for="comment-search-input"><?php _e( 'Search Comments' ); ?>:</label>	<input type="text" id="comment-search-input" name="s" value="<?php _admin_search_query(); ?>" />	<input type="submit" value="<?php esc_attr_e( 'Search Comments' ); ?>" class="button" /></p><?php$comments_per_page = (int) get_user_option( 'edit_comments_per_page' );if ( empty( $comments_per_page ) || $comments_per_page < 1 )	$comments_per_page = 20;$comments_per_page = apply_filters( 'comments_per_page', $comments_per_page, $comment_status );if ( isset( $_GET['apage'] ) )	$page = abs( (int) $_GET['apage'] );else	$page = 1;$start = $offset = ( $page - 1 ) * $comments_per_page;list($_comments, $total) = _wp_get_comment_list( $comment_status, $search_dirty, $start, $comments_per_page + 8, $post_id, $comment_type ); // Grab a few extra$_comment_post_ids = array();foreach ( $_comments as $_c ) {	$_comment_post_ids[] = $_c->comment_post_ID;}$_comment_pending_count = get_pending_comments_num($_comment_post_ids);$comments = array_slice($_comments, 0, $comments_per_page);$extra_comments = array_slice($_comments, $comments_per_page);$page_links = paginate_links( array(	'base' => add_query_arg( 'apage', '%#%' ),	'format' => '',	'prev_text' => __('&laquo;'),	'next_text' => __('&raquo;'),	'total' => ceil($total / $comments_per_page),	'current' => $page));?><input type="hidden" name="mode" value="<?php echo esc_attr($mode); ?>" /><?php if ( $post_id ) : ?><input type="hidden" name="p" value="<?php echo esc_attr( intval( $post_id ) ); ?>" /><?php endif; ?><input type="hidden" name="comment_status" value="<?php echo esc_attr($comment_status); ?>" /><input type="hidden" name="pagegen_timestamp" value="<?php echo esc_attr(current_time('mysql', 1)); ?>" /><div class="tablenav"><?php if ( $page_links ) : ?><div class="tablenav-pages"><?php $page_links_text = sprintf( '<span class="displaying-num">' . __( 'Displaying %s&#8211;%s of %s' ) . '</span>%s',	number_format_i18n( $start + 1 ),	number_format_i18n( min( $page * $comments_per_page, $total ) ),	'<span class="total-type-count">' . number_format_i18n( $total ) . '</span>',	$page_links); echo $page_links_text; ?></div><input type="hidden" name="_total" value="<?php echo esc_attr($total); ?>" /><input type="hidden" name="_per_page" value="<?php echo esc_attr($comments_per_page); ?>" /><input type="hidden" name="_page" value="<?php echo esc_attr($page); ?>" /><?php endif; ?><?php if ( $comments ) : ?><div class="alignleft actions"><select name="action"><option value="-1" selected="selected"><?php _e('Bulk Actions') ?></option><?php if ( 'all' == $comment_status || 'approved' == $comment_status ): ?><option value="unapprove"><?php _e('Unapprove'); ?></option><?php endif; ?><?php if ( 'all' == $comment_status || 'moderated' == $comment_status || 'spam' == $comment_status ): ?><option value="approve"><?php _e('Approve'); ?></option><?php endif; ?><?php if ( 'all' == $comment_status || 'approved' == $comment_status || 'moderated' == $comment_status ): ?><option value="spam"><?php _ex('Mark as Spam', 'comment'); ?></option><?php endif; ?><?php if ( 'trash' == $comment_status ): ?><option value="untrash"><?php _e('Restore'); ?></option><?php elseif ( 'spam' == $comment_status ): ?><option value="unspam"><?php _ex('Not Spam', 'comment'); ?></option><?php endif; ?><?php if ( 'trash' == $comment_status || 'spam' == $comment_status || !EMPTY_TRASH_DAYS ): ?><option value="delete"><?php _e('Delete Permanently'); ?></option><?php else: ?><option value="trash"><?php _e('Move to Trash'); ?></option><?php endif; ?></select><input type="submit" name="doaction" id="doaction" value="<?php esc_attr_e('Apply'); ?>" class="button-secondary apply" /><?php wp_nonce_field('bulk-comments'); ?><?php endif; ?><select name="comment_type">	<option value="all"><?php _e('Show all comment types'); ?></option><?php	$comment_types = apply_filters( 'admin_comment_types_dropdown', array(		'comment' => __('Comments'),		'pings' => __('Pings'),	) );	foreach ( $comment_types as $type => $label ) {		echo "	<option value='" . esc_attr($type) . "'";		selected( $comment_type, $type );		echo ">$label</option>\n";	}?></select><input type="submit" id="post-query-submit" value="<?php esc_attr_e('Filter'); ?>" class="button-secondary" /><?php if ( isset($_GET['apage']) ) { ?>	<input type="hidden" name="apage" value="<?php echo esc_attr( absint( $_GET['apage'] ) ); ?>" /><?php }if ( ( 'spam' == $comment_status || 'trash' == $comment_status) && current_user_can ('moderate_comments') ) {	wp_nonce_field('bulk-destroy', '_destroy_nonce');    if ( 'spam' == $comment_status && current_user_can('moderate_comments') ) { ?>		<input type="submit" name="delete_all" id="delete_all" value="<?php esc_attr_e('Empty Spam'); ?>" class="button-secondary apply" /><?php } elseif ( 'trash' == $comment_status && current_user_can('moderate_comments') ) { ?>		<input type="submit" name="delete_all" id="delete_all" value="<?php esc_attr_e('Empty Trash'); ?>" class="button-secondary apply" /><?php }} ?><?php do_action('manage_comments_nav', $comment_status); ?></div><br class="clear" /></div><div class="clear"></div><?php if ( $comments ) { ?><table class="widefat comments fixed" cellspacing="0"><thead>	<tr><?php print_column_headers('edit-comments'); ?>	</tr></thead><tfoot>	<tr><?php print_column_headers('edit-comments', false); ?>	</tr></tfoot><tbody id="the-comment-list" class="list:comment"><?php	foreach ($comments as $comment)		_wp_comment_row( $comment->comment_ID, $mode, $comment_status );?></tbody><tbody id="the-extra-comment-list" class="list:comment" style="display: none;"><?php	foreach ($extra_comments as $comment)		_wp_comment_row( $comment->comment_ID, $mode, $comment_status );?></tbody></table><div class="tablenav"><?phpif ( $page_links )	echo "<div class='tablenav-pages'>$page_links_text</div>";?><div class="alignleft actions"><select name="action2"><option value="-1" selected="selected"><?php _e('Bulk Actions') ?></option><?php if ( 'all' == $comment_status || 'approved' == $comment_status ): ?><option value="unapprove"><?php _e('Unapprove'); ?></option><?php endif; ?><?php if ( 'all' == $comment_status || 'moderated' == $comment_status || 'spam' == $comment_status ): ?><option value="approve"><?php _e('Approve'); ?></option><?php endif; ?><?php if ( 'all' == $comment_status || 'approved' == $comment_status || 'moderated' == $comment_status ): ?><option value="spam"><?php _ex('Mark as Spam', 'comment'); ?></option><?php endif; ?><?php if ( 'trash' == $comment_status ): ?><option value="untrash"><?php _e('Restore'); ?></option><?php endif; ?><?php if ( 'trash' == $comment_status || 'spam' == $comment_status || !EMPTY_TRASH_DAYS ): ?><option value="delete"><?php _e('Delete Permanently'); ?></option><?php elseif ( 'spam' == $comment_status ): ?><option value="unspam"><?php _ex('Not Spam', 'comment'); ?></option><?php else: ?><option value="trash"><?php _e('Move to Trash'); ?></option><?php endif; ?></select><input type="submit" name="doaction2" id="doaction2" value="<?php esc_attr_e('Apply'); ?>" class="button-secondary apply" /><?php if ( 'spam' == $comment_status && current_user_can('moderate_comments') ) { ?><input type="submit" name="delete_all2" id="delete_all2" value="<?php esc_attr_e('Empty Spam'); ?>" class="button-secondary apply" /><?php } elseif ( 'trash' == $comment_status && current_user_can('moderate_comments') ) { ?><input type="submit" name="delete_all2" id="delete_all2" value="<?php esc_attr_e('Empty Trash'); ?>" class="button-secondary apply" /><?php } ?><?php do_action('manage_comments_nav', $comment_status); ?></div><br class="clear" /></div></form><form id="get-extra-comments" method="post" action="" class="add:the-extra-comment-list:" style="display: none;">	<input type="hidden" name="s" value="<?php echo esc_attr($search); ?>" />	<input type="hidden" name="mode" value="<?php echo esc_attr($mode); ?>" />	<input type="hidden" name="comment_status" value="<?php echo esc_attr($comment_status); ?>" />	<input type="hidden" name="page" value="<?php echo esc_attr($page); ?>" />	<input type="hidden" name="per_page" value="<?php echo esc_attr($comments_per_page); ?>" />	<input type="hidden" name="p" value="<?php echo esc_attr( $post_id ); ?>" />	<input type="hidden" name="comment_type" value="<?php echo esc_attr( $comment_type ); ?>" />	<?php wp_nonce_field( 'add-comment', '_ajax_nonce', false ); ?></form><div id="ajax-response"></div><?php } elseif ( 'moderated' == $comment_status ) { ?><p><?php _e('No comments awaiting moderation&hellip; yet.') ?></p></div></form><?php } else { ?><p><?php _e('No comments found.') ?></p></div></form><?php } ?></div><?phpwp_comment_reply('-1', true, 'detail');wp_comment_trashnotice();include('./admin-footer.php'); ?>
<?php/** * Discussion settings administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can( 'manage_options' ) )	wp_die( __( 'You do not have sufficient permissions to manage options for this site.' ) );$title = __('Discussion Settings');$parent_file = 'options-general.php';add_contextual_help($current_screen,	'<p>' . __('This screen provides many options for controlling the management and display of comments and links to your posts/pages. So many, in fact, they won&#8217;t all fit here! :) Use the documentation link below to get information on what each discussion setting does.') . '</p>' .	'<p>' . __('You must click the Save Changes button at the bottom of the screen for new settings to take effect.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Settings_Discussion_SubPanel" target="_blank">Discussion Settings Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');include('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><form method="post" action="options.php"><?php settings_fields('discussion'); ?><table class="form-table"><tr valign="top"><th scope="row"><?php _e('Default article settings') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Default article settings') ?></span></legend><label for="default_pingback_flag"><input name="default_pingback_flag" type="checkbox" id="default_pingback_flag" value="1" <?php checked('1', get_option('default_pingback_flag')); ?> /><?php _e('Attempt to notify any blogs linked to from the article.') ?></label><br /><label for="default_ping_status"><input name="default_ping_status" type="checkbox" id="default_ping_status" value="open" <?php checked('open', get_option('default_ping_status')); ?> /><?php _e('Allow link notifications from other blogs (pingbacks and trackbacks.)') ?></label><br /><label for="default_comment_status"><input name="default_comment_status" type="checkbox" id="default_comment_status" value="open" <?php checked('open', get_option('default_comment_status')); ?> /><?php _e('Allow people to post comments on new articles') ?></label><br /><small><em><?php echo '(' . __('These settings may be overridden for individual articles.') . ')'; ?></em></small></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('Other comment settings') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Other comment settings') ?></span></legend><label for="require_name_email"><input type="checkbox" name="require_name_email" id="require_name_email" value="1" <?php checked('1', get_option('require_name_email')); ?> /> <?php _e('Comment author must fill out name and e-mail') ?></label><br /><label for="comment_registration"><input name="comment_registration" type="checkbox" id="comment_registration" value="1" <?php checked('1', get_option('comment_registration')); ?> /><?php _e('Users must be registered and logged in to comment') ?><?php if ( !get_option( 'users_can_register' ) && is_multisite() ) _e( ' (Signup has been disabled. Only members of this site can comment.)' ); ?></label><br /><label for="close_comments_for_old_posts"><input name="close_comments_for_old_posts" type="checkbox" id="close_comments_for_old_posts" value="1" <?php checked('1', get_option('close_comments_for_old_posts')); ?> /><?php printf( __('Automatically close comments on articles older than %s days'), '</label><input name="close_comments_days_old" type="text" id="close_comments_days_old" value="' . esc_attr(get_option('close_comments_days_old')) . '" class="small-text" />') ?><br /><label for="thread_comments"><input name="thread_comments" type="checkbox" id="thread_comments" value="1" <?php checked('1', get_option('thread_comments')); ?> /><?php$maxdeep = (int) apply_filters( 'thread_comments_depth_max', 10 );$thread_comments_depth = '</label><select name="thread_comments_depth" id="thread_comments_depth">';for ( $i = 2; $i <= $maxdeep; $i++ ) {	$thread_comments_depth .= "<option value='" . esc_attr($i) . "'";	if ( get_option('thread_comments_depth') == $i ) $thread_comments_depth .= " selected='selected'";	$thread_comments_depth .= ">$i</option>";}$thread_comments_depth .= '</select>';printf( __('Enable threaded (nested) comments %s levels deep'), $thread_comments_depth );?><br /><label for="page_comments"><input name="page_comments" type="checkbox" id="page_comments" value="1" <?php checked('1', get_option('page_comments')); ?> /><?php$default_comments_page = '</label><label for="default_comments_page"><select name="default_comments_page" id="default_comments_page"><option value="newest"';if ( 'newest' == get_option('default_comments_page') ) $default_comments_page .= ' selected="selected"';$default_comments_page .= '>' . __('last') . '</option><option value="oldest"';if ( 'oldest' == get_option('default_comments_page') ) $default_comments_page .= ' selected="selected"';$default_comments_page .= '>' . __('first') . '</option></select>';printf( __('Break comments into pages with %1$s top level comments per page and the %2$s page displayed by default'), '</label><label for="comments_per_page"><input name="comments_per_page" type="text" id="comments_per_page" value="' . esc_attr(get_option('comments_per_page')) . '" class="small-text" />', $default_comments_page );?></label><br /><label for="comment_order"><?php$comment_order = '<select name="comment_order" id="comment_order"><option value="asc"';if ( 'asc' == get_option('comment_order') ) $comment_order .= ' selected="selected"';$comment_order .= '>' . __('older') . '</option><option value="desc"';if ( 'desc' == get_option('comment_order') ) $comment_order .= ' selected="selected"';$comment_order .= '>' . __('newer') . '</option></select>';printf( __('Comments should be displayed with the %s comments at the top of each page'), $comment_order );?></label></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('E-mail me whenever') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('E-mail me whenever') ?></span></legend><label for="comments_notify"><input name="comments_notify" type="checkbox" id="comments_notify" value="1" <?php checked('1', get_option('comments_notify')); ?> /><?php _e('Anyone posts a comment') ?> </label><br /><label for="moderation_notify"><input name="moderation_notify" type="checkbox" id="moderation_notify" value="1" <?php checked('1', get_option('moderation_notify')); ?> /><?php _e('A comment is held for moderation') ?> </label></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('Before a comment appears') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Before a comment appears') ?></span></legend><label for="comment_moderation"><input name="comment_moderation" type="checkbox" id="comment_moderation" value="1" <?php checked('1', get_option('comment_moderation')); ?> /><?php _e('An administrator must always approve the comment') ?> </label><br /><label for="comment_whitelist"><input type="checkbox" name="comment_whitelist" id="comment_whitelist" value="1" <?php checked('1', get_option('comment_whitelist')); ?> /> <?php _e('Comment author must have a previously approved comment') ?></label></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('Comment Moderation') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Comment Moderation') ?></span></legend><p><label for="comment_max_links"><?php printf(__('Hold a comment in the queue if it contains %s or more links. (A common characteristic of comment spam is a large number of hyperlinks.)'), '<input name="comment_max_links" type="text" id="comment_max_links" value="' . esc_attr(get_option('comment_max_links')) . '" class="small-text" />' ) ?></label></p><p><label for="moderation_keys"><?php _e('When a comment contains any of these words in its content, name, URL, e-mail, or IP, it will be held in the <a href="edit-comments.php?comment_status=moderated">moderation queue</a>. One word or IP per line. It will match inside words, so &#8220;press&#8221; will match &#8220;WordPress&#8221;.') ?></label></p><p><textarea name="moderation_keys" rows="10" cols="50" id="moderation_keys" class="large-text code"><?php form_option('moderation_keys'); ?></textarea></p></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('Comment Blacklist') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Comment Blacklist') ?></span></legend><p><label for="blacklist_keys"><?php _e('When a comment contains any of these words in its content, name, URL, e-mail, or IP, it will be marked as spam. One word or IP per line. It will match inside words, so &#8220;press&#8221; will match &#8220;WordPress&#8221;.') ?></label></p><p><textarea name="blacklist_keys" rows="10" cols="50" id="blacklist_keys" class="large-text code"><?php form_option('blacklist_keys'); ?></textarea></p></fieldset></td></tr><?php do_settings_fields('discussion', 'default'); ?></table><h3><?php _e('Avatars') ?></h3><p><?php _e('An avatar is an image that follows you from weblog to weblog appearing beside your name when you comment on avatar enabled sites.  Here you can enable the display of avatars for people who comment on your site.'); ?></p><?php // the above would be a good place to link to codex documentation on the gravatar functions, for putting it in themes. anything like that? ?><table class="form-table"><tr valign="top"><th scope="row"><?php _e('Avatar Display') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Avatar Display') ?></span></legend><?php	$yesorno = array( 0 => __( 'Don&#8217;t show Avatars' ), 1 => __( 'Show Avatars' ) );	foreach ( $yesorno as $key => $value) {		$selected = (get_option('show_avatars') == $key) ? 'checked="checked"' : '';		echo "\n\t<label><input type='radio' name='show_avatars' value='" . esc_attr($key) . "' $selected/> $value</label><br />";	}?></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('Maximum Rating') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Maximum Rating') ?></span></legend><?php$ratings = array(	/* translators: Content suitability rating: http://bit.ly/89QxZA */	'G' => __('G &#8212; Suitable for all audiences'),	/* translators: Content suitability rating: http://bit.ly/89QxZA */	'PG' => __('PG &#8212; Possibly offensive, usually for audiences 13 and above'),	/* translators: Content suitability rating: http://bit.ly/89QxZA */	'R' => __('R &#8212; Intended for adult audiences above 17'),	/* translators: Content suitability rating: http://bit.ly/89QxZA */	'X' => __('X &#8212; Even more mature than above'));foreach ($ratings as $key => $rating) :	$selected = (get_option('avatar_rating') == $key) ? 'checked="checked"' : '';	echo "\n\t<label><input type='radio' name='avatar_rating' value='" . esc_attr($key) . "' $selected/> $rating</label><br />";endforeach;?></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('Default Avatar') ?></th><td class="defaultavatarpicker"><fieldset><legend class="screen-reader-text"><span><?php _e('Default Avatar') ?></span></legend><?php _e('For users without a custom avatar of their own, you can either display a generic logo or a generated one based on their e-mail address.'); ?><br /><?php$avatar_defaults = array(	'mystery' => __('Mystery Man'),	'blank' => __('Blank'),	'gravatar_default' => __('Gravatar Logo'),	'identicon' => __('Identicon (Generated)'),	'wavatar' => __('Wavatar (Generated)'),	'monsterid' => __('MonsterID (Generated)'));$avatar_defaults = apply_filters('avatar_defaults', $avatar_defaults);$default = get_option('avatar_default');if ( empty($default) )	$default = 'mystery';$size = 32;$avatar_list = '';foreach ( $avatar_defaults as $default_key => $default_name ) {	$selected = ($default == $default_key) ? 'checked="checked" ' : '';	$avatar_list .= "\n\t<label><input type='radio' name='avatar_default' id='avatar_{$default_key}' value='" . esc_attr($default_key)  . "' {$selected}/> ";	$avatar = get_avatar( $user_email, $size, $default_key );	$avatar_list .= preg_replace("/src='(.+?)'/", "src='\$1&amp;forcedefault=1'", $avatar);	$avatar_list .= ' ' . $default_name . '</label>';	$avatar_list .= '<br />';}echo apply_filters('default_avatar_select', $avatar_list);?></fieldset></td></tr><?php do_settings_fields('discussion', 'avatars'); ?></table><?php do_settings_sections('discussion'); ?><p class="submit"><input type="submit" name="Submit" class="button-primary" value="<?php esc_attr_e('Save Changes') ?>" /></p></form></div><?php include('./admin-footer.php'); ?>
<?php/** * Deprecated admin functions from past WordPress versions. You shouldn't use these * functions and look for the alternatives instead. The functions will be removed * in a later version. * * @package WordPress * @subpackage Deprecated *//* * Deprecated functions come here to die. *//** * @since 2.1 * @deprecated 2.1 * @deprecated Use wp_tiny_mce(). * @see wp_tiny_mce() */function tinymce_include() {	_deprecated_function( __FUNCTION__, '2.1', 'wp_tiny_mce()' );	wp_tiny_mce();}/** * Unused Admin function. * * @since 2.0 * @deprecated 2.5 * */function documentation_link() {	_deprecated_function( __FUNCTION__, '2.5', '' );	return;}/** * Calculates the new dimentions for a downsampled image. * * @since 2.0.0 * @deprecated 3.0.0 * @deprecated Use wp_constrain_dimensions() * * @param int $width Current width of the image * @param int $height Current height of the image * @param int $wmax Maximum wanted width * @param int $hmax Maximum wanted height * @return mixed Array(height,width) of shrunk dimensions. */function wp_shrink_dimensions( $width, $height, $wmax = 128, $hmax = 96 ) {	_deprecated_function( __FUNCTION__, '3.0', 'wp_constrain_dimensions()' );	return wp_constrain_dimensions( $width, $height, $wmax, $hmax );}/** * {@internal Missing Short Description}} * * @since unknown * @deprecated unknown * @deprecated Use wp_category_checklist() * @see wp_category_checklist() * * @param unknown_type $default * @param unknown_type $parent * @param unknown_type $popular_ids */function dropdown_categories( $default = 0, $parent = 0, $popular_ids = array() ) {	_deprecated_function( __FUNCTION__, '0.0', 'wp_category_checklist()' );	global $post_ID;	wp_category_checklist( $post_ID );}/** * {@internal Missing Short Description}} * * @since unknown * @deprecated unknown * @deprecated Use wp_link_category_checklist() * @see wp_link_category_checklist() * * @param unknown_type $default */function dropdown_link_categories( $default = 0 ) {	_deprecated_function( __FUNCTION__, '0.0', 'wp_link_category_checklist()' );	global $link_id;	wp_link_category_checklist( $link_id );}/** * {@internal Missing Short Description}} * * @since unknown * @deprecated 3.0.0 * @deprecated Use wp_dropdown_categories() * @see wp_dropdown_categories() * * @param unknown_type $currentcat * @param unknown_type $currentparent * @param unknown_type $parent * @param unknown_type $level * @param unknown_type $categories * @return unknown */function wp_dropdown_cats( $currentcat = 0, $currentparent = 0, $parent = 0, $level = 0, $categories = 0 ) {	_deprecated_function( __FUNCTION__, '3.0', 'wp_dropdown_categories()' );	if (!$categories )		$categories = get_categories( array('hide_empty' => 0) );	if ( $categories ) {		foreach ( $categories as $category ) {			if ( $currentcat != $category->term_id && $parent == $category->parent) {				$pad = str_repeat( '&#8211; ', $level );				$category->name = esc_html( $category->name );				echo "\n\t<option value='$category->term_id'";				if ( $currentparent == $category->term_id )					echo " selected='selected'";				echo ">$pad$category->name</option>";				wp_dropdown_cats( $currentcat, $currentparent, $category->term_id, $level +1, $categories );			}		}	} else {		return false;	}}/** * Register a setting and its sanitization callback * * @since 2.7.0 * @deprecated 3.0.0 * @deprecated Use register_setting() * @see register_setting() * * @param string $option_group A settings group name.  Should correspond to a whitelisted option key name. * 	Default whitelisted option key names include "general," "discussion," and "reading," among others. * @param string $option_name The name of an option to sanitize and save. * @param unknown_type $sanitize_callback A callback function that sanitizes the option's value. * @return unknown */function add_option_update_handler( $option_group, $option_name, $sanitize_callback = '' ) {	_deprecated_function( __FUNCTION__, '3.0', 'register_setting()' );	return register_setting( $option_group, $option_name, $sanitize_callback );}/** * Unregister a setting * * @since 2.7.0 * @deprecated 3.0.0 * @deprecated Use unregister_setting() * @see unregister_setting() * * @param unknown_type $option_group * @param unknown_type $option_name * @param unknown_type $sanitize_callback * @return unknown */function remove_option_update_handler( $option_group, $option_name, $sanitize_callback = '' ) {	_deprecated_function( __FUNCTION__, '3.0', 'unregister_setting()' );	return unregister_setting( $option_group, $option_name, $sanitize_callback );}/** * Determines the language to use for CodePress syntax highlighting. * * @since 2.8.0 * @deprecated 3.0.0 * * @param string $filename**/function codepress_get_lang( $filename ) {	_deprecated_function( __FUNCTION__, '3.0' );	return;}/** * Adds Javascript required to make CodePress work on the theme/plugin editors. * * @since 2.8.0 * @deprecated 3.0.0**/function codepress_footer_js() {	_deprecated_function( __FUNCTION__, '3.0' );	return;}/** * Determine whether to use CodePress. * * @since 2.8 * @deprecated 3.0.0**/function use_codepress() {	_deprecated_function( __FUNCTION__, '3.0' );	return;}?>
<?php/** * Category Template Tags and API. * * @package WordPress * @subpackage Template *//** * Retrieve category link URL. * * @since 1.0.0 * @uses apply_filters() Calls 'category_link' filter on category link and category ID. * * @param int $category_id Category ID. * @return string */function get_category_link( $category_id ) {	global $wp_rewrite;	$catlink = $wp_rewrite->get_category_permastruct();	if ( empty( $catlink ) ) {		$catlink = home_url('?cat=' . $category_id);	} else {		$category = &get_category( $category_id );		if ( is_wp_error( $category ) )			return $category;		$category_nicename = $category->slug;		if ( $category->parent == $category_id ) // recursive recursion			$category->parent = 0;		elseif ($category->parent != 0 )			$category_nicename = get_category_parents( $category->parent, false, '/', true ) . $category_nicename;		$catlink = str_replace( '%category%', $category_nicename, $catlink );		$catlink = home_url( user_trailingslashit( $catlink, 'category' ) );	}	return apply_filters( 'category_link', $catlink, $category_id );}/** * Retrieve category parents with separator. * * @since 1.2.0 * * @param int $id Category ID. * @param bool $link Optional, default is false. Whether to format with link. * @param string $separator Optional, default is '/'. How to separate categories. * @param bool $nicename Optional, default is false. Whether to use nice name for display. * @param array $visited Optional. Already linked to categories to prevent duplicates. * @return string */function get_category_parents( $id, $link = false, $separator = '/', $nicename = false, $visited = array() ) {	$chain = '';	$parent = &get_category( $id );	if ( is_wp_error( $parent ) )		return $parent;	if ( $nicename )		$name = $parent->slug;	else		$name = $parent->cat_name;	if ( $parent->parent && ( $parent->parent != $parent->term_id ) && !in_array( $parent->parent, $visited ) ) {		$visited[] = $parent->parent;		$chain .= get_category_parents( $parent->parent, $link, $separator, $nicename, $visited );	}	if ( $link )		$chain .= '<a href="' . get_category_link( $parent->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $parent->cat_name ) ) . '">'.$name.'</a>' . $separator;	else		$chain .= $name.$separator;	return $chain;}/** * Retrieve post categories. * * @since 0.71 * @uses $post * * @param int $id Optional, default to current post ID. The post ID. * @return array */function get_the_category( $id = false ) {	global $post;	$id = (int) $id;	if ( !$id )		$id = (int) $post->ID;	$categories = get_object_term_cache( $id, 'category' );	if ( false === $categories ) {		$categories = wp_get_object_terms( $id, 'category' );		wp_cache_add($id, $categories, 'category_relationships');	}	if ( !empty( $categories ) )		usort( $categories, '_usort_terms_by_name' );	else		$categories = array();	foreach ( (array) array_keys( $categories ) as $key ) {		_make_cat_compat( $categories[$key] );	}	return $categories;}/** * Sort categories by name. * * Used by usort() as a callback, should not be used directly. Can actually be * used to sort any term object. * * @since 2.3.0 * @access private * * @param object $a * @param object $b * @return int */function _usort_terms_by_name( $a, $b ) {	return strcmp( $a->name, $b->name );}/** * Sort categories by ID. * * Used by usort() as a callback, should not be used directly. Can actually be * used to sort any term object. * * @since 2.3.0 * @access private * * @param object $a * @param object $b * @return int */function _usort_terms_by_ID( $a, $b ) {	if ( $a->term_id > $b->term_id )		return 1;	elseif ( $a->term_id < $b->term_id )		return -1;	else		return 0;}/** * Retrieve category name based on category ID. * * @since 0.71 * * @param int $cat_ID Category ID. * @return string Category name. */function get_the_category_by_ID( $cat_ID ) {	$cat_ID = (int) $cat_ID;	$category = &get_category( $cat_ID );	if ( is_wp_error( $category ) )		return $category;	return $category->name;}/** * Retrieve category list in either HTML list or custom format. * * @since 1.5.1 * * @param string $separator Optional, default is empty string. Separator for between the categories. * @param string $parents Optional. How to display the parents. * @param int $post_id Optional. Post ID to retrieve categories. * @return string */function get_the_category_list( $separator = '', $parents='', $post_id = false ) {	global $wp_rewrite;	$categories = get_the_category( $post_id );	if ( !is_object_in_taxonomy( get_post_type( $post_id ), 'category' ) )		return apply_filters( 'the_category', '', $separator, $parents );	if ( empty( $categories ) )		return apply_filters( 'the_category', __( 'Uncategorized' ), $separator, $parents );	$rel = ( is_object( $wp_rewrite ) && $wp_rewrite->using_permalinks() ) ? 'rel="category tag"' : 'rel="category"';	$thelist = '';	if ( '' == $separator ) {		$thelist .= '<ul class="post-categories">';		foreach ( $categories as $category ) {			$thelist .= "\n\t<li>";			switch ( strtolower( $parents ) ) {				case 'multiple':					if ( $category->parent )						$thelist .= get_category_parents( $category->parent, true, $separator );					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>' . $category->name.'</a></li>';					break;				case 'single':					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>';					if ( $category->parent )						$thelist .= get_category_parents( $category->parent, false, $separator );					$thelist .= $category->name.'</a></li>';					break;				case '':				default:					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>' . $category->cat_name.'</a></li>';			}		}		$thelist .= '</ul>';	} else {		$i = 0;		foreach ( $categories as $category ) {			if ( 0 < $i )				$thelist .= $separator;			switch ( strtolower( $parents ) ) {				case 'multiple':					if ( $category->parent )						$thelist .= get_category_parents( $category->parent, true, $separator );					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>' . $category->cat_name.'</a>';					break;				case 'single':					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>';					if ( $category->parent )						$thelist .= get_category_parents( $category->parent, false, $separator );					$thelist .= "$category->cat_name</a>";					break;				case '':				default:					$thelist .= '<a href="' . get_category_link( $category->term_id ) . '" title="' . esc_attr( sprintf( __( "View all posts in %s" ), $category->name ) ) . '" ' . $rel . '>' . $category->name.'</a>';			}			++$i;		}	}	return apply_filters( 'the_category', $thelist, $separator, $parents );}/** * Check if the current post in within any of the given categories. * * The given categories are checked against the post's categories' term_ids, names and slugs. * Categories given as integers will only be checked against the post's categories' term_ids. * * Prior to v2.5 of WordPress, category names were not supported. * Prior to v2.7, category slugs were not supported. * Prior to v2.7, only one category could be compared: in_category( $single_category ). * Prior to v2.7, this function could only be used in the WordPress Loop. * As of 2.7, the function can be used anywhere if it is provided a post ID or post object. * * @since 1.2.0 * * @uses is_object_in_term() * * @param int|string|array $category. Category ID, name or slug, or array of said. * @param int|post object Optional.  Post to check instead of the current post. @since 2.7.0 * @return bool True if the current post is in any of the given categories. */function in_category( $category, $_post = null ) {	if ( empty( $category ) )		return false;	if ( $_post ) {		$_post = get_post( $_post );	} else {		$_post =& $GLOBALS['post'];	}	if ( !$_post )		return false;	$r = is_object_in_term( $_post->ID, 'category', $category );	if ( is_wp_error( $r ) )		return false;	return $r;}/** * Display the category list for the post. * * @since 0.71 * * @param string $separator Optional, default is empty string. Separator for between the categories. * @param string $parents Optional. How to display the parents. * @param int $post_id Optional. Post ID to retrieve categories. */function the_category( $separator = '', $parents='', $post_id = false ) {	echo get_the_category_list( $separator, $parents, $post_id );}/** * Retrieve category description. * * @since 1.0.0 * * @param int $category Optional. Category ID. Will use global category ID by default. * @return string Category description, available. */function category_description( $category = 0 ) {	return term_description( $category, 'category' );}/** * Display or retrieve the HTML dropdown list of categories. * * The list of arguments is below: *     'show_option_all' (string) - Text to display for showing all categories. *     'show_option_none' (string) - Text to display for showing no categories. *     'orderby' (string) default is 'ID' - What column to use for ordering the * categories. *     'order' (string) default is 'ASC' - What direction to order categories. *     'show_last_update' (bool|int) default is 0 - See {@link get_categories()} *     'show_count' (bool|int) default is 0 - Whether to show how many posts are * in the category. *     'hide_empty' (bool|int) default is 1 - Whether to hide categories that * don't have any posts attached to them. *     'child_of' (int) default is 0 - See {@link get_categories()}. *     'exclude' (string) - See {@link get_categories()}. *     'echo' (bool|int) default is 1 - Whether to display or retrieve content. *     'depth' (int) - The max depth. *     'tab_index' (int) - Tab index for select element. *     'name' (string) - The name attribute value for select element. *     'id' (string) - The ID attribute value for select element. Defaults to name if omitted. *     'class' (string) - The class attribute value for select element. *     'selected' (int) - Which category ID is selected. *     'taxonomy' (string) - The name of the taxonomy to retrieve. Defaults to category. * * The 'hierarchical' argument, which is disabled by default, will override the * depth argument, unless it is true. When the argument is false, it will * display all of the categories. When it is enabled it will use the value in * the 'depth' argument. * * @since 2.1.0 * * @param string|array $args Optional. Override default arguments. * @return string HTML content only if 'echo' argument is 0. */function wp_dropdown_categories( $args = '' ) {	$defaults = array(		'show_option_all' => '', 'show_option_none' => '',		'orderby' => 'id', 'order' => 'ASC',		'show_last_update' => 0, 'show_count' => 0,		'hide_empty' => 1, 'child_of' => 0,		'exclude' => '', 'echo' => 1,		'selected' => 0, 'hierarchical' => 0,		'name' => 'cat', 'id' => '',		'class' => 'postform', 'depth' => 0,		'tab_index' => 0, 'taxonomy' => 'category',		'hide_if_empty' => false	);	$defaults['selected'] = ( is_category() ) ? get_query_var( 'cat' ) : 0;	// Back compat.	if ( isset( $args['type'] ) && 'link' == $args['type'] ) {		_deprecated_argument( __FUNCTION__, '3.0', '' );		$args['taxonomy'] = 'link_category';	}	$r = wp_parse_args( $args, $defaults );	if ( !isset( $r['pad_counts'] ) && $r['show_count'] && $r['hierarchical'] ) {		$r['pad_counts'] = true;	}	$r['include_last_update_time'] = $r['show_last_update'];	extract( $r );	$tab_index_attribute = '';	if ( (int) $tab_index > 0 )		$tab_index_attribute = " tabindex=\"$tab_index\"";	$categories = get_terms( $taxonomy, $r );	$name = esc_attr( $name );	$class = esc_attr( $class );	$id = $id ? esc_attr( $id ) : $name;	if ( ! $r['hide_if_empty'] || ! empty($categories) )		$output = "<select name='$name' id='$id' class='$class' $tab_index_attribute>\n";	else		$output = '';	if ( empty($categories) && ! $r['hide_if_empty'] && !empty($show_option_none) ) {		$show_option_none = apply_filters( 'list_cats', $show_option_none );		$output .= "\t<option value='-1' selected='selected'>$show_option_none</option>\n";	}	if ( ! empty( $categories ) ) {		if ( $show_option_all ) {			$show_option_all = apply_filters( 'list_cats', $show_option_all );			$selected = ( '0' === strval($r['selected']) ) ? " selected='selected'" : '';			$output .= "\t<option value='0'$selected>$show_option_all</option>\n";		}		if ( $show_option_none ) {			$show_option_none = apply_filters( 'list_cats', $show_option_none );			$selected = ( '-1' === strval($r['selected']) ) ? " selected='selected'" : '';			$output .= "\t<option value='-1'$selected>$show_option_none</option>\n";		}		if ( $hierarchical )			$depth = $r['depth'];  // Walk the full depth.		else			$depth = -1; // Flat.		$output .= walk_category_dropdown_tree( $categories, $depth, $r );	}	if ( ! $r['hide_if_empty'] || ! empty($categories) )		$output .= "</select>\n";	$output = apply_filters( 'wp_dropdown_cats', $output );	if ( $echo )		echo $output;	return $output;}/** * Display or retrieve the HTML list of categories. * * The list of arguments is below: *     'show_option_all' (string) - Text to display for showing all categories. *     'orderby' (string) default is 'ID' - What column to use for ordering the * categories. *     'order' (string) default is 'ASC' - What direction to order categories. *     'show_last_update' (bool|int) default is 0 - See {@link * walk_category_dropdown_tree()} *     'show_count' (bool|int) default is 0 - Whether to show how many posts are * in the category. *     'hide_empty' (bool|int) default is 1 - Whether to hide categories that * don't have any posts attached to them. *     'use_desc_for_title' (bool|int) default is 1 - Whether to use the * description instead of the category title. *     'feed' - See {@link get_categories()}. *     'feed_type' - See {@link get_categories()}. *     'feed_image' - See {@link get_categories()}. *     'child_of' (int) default is 0 - See {@link get_categories()}. *     'exclude' (string) - See {@link get_categories()}. *     'exclude_tree' (string) - See {@link get_categories()}. *     'echo' (bool|int) default is 1 - Whether to display or retrieve content. *     'current_category' (int) - See {@link get_categories()}. *     'hierarchical' (bool) - See {@link get_categories()}. *     'title_li' (string) - See {@link get_categories()}. *     'depth' (int) - The max depth. * * @since 2.1.0 * * @param string|array $args Optional. Override default arguments. * @return string HTML content only if 'echo' argument is 0. */function wp_list_categories( $args = '' ) {	$defaults = array(		'show_option_all' => '', 'show_option_none' => __('No categories'),		'orderby' => 'name', 'order' => 'ASC',		'show_last_update' => 0, 'style' => 'list',		'show_count' => 0, 'hide_empty' => 1,		'use_desc_for_title' => 1, 'child_of' => 0,		'feed' => '', 'feed_type' => '',		'feed_image' => '', 'exclude' => '',		'exclude_tree' => '', 'current_category' => 0,		'hierarchical' => true, 'title_li' => __( 'Categories' ),		'echo' => 1, 'depth' => 0,		'taxonomy' => 'category'	);	$r = wp_parse_args( $args, $defaults );	if ( !isset( $r['pad_counts'] ) && $r['show_count'] && $r['hierarchical'] )		$r['pad_counts'] = true;	if ( isset( $r['show_date'] ) )		$r['include_last_update_time'] = $r['show_date'];	if ( true == $r['hierarchical'] ) {		$r['exclude_tree'] = $r['exclude'];		$r['exclude'] = '';	}	if ( !isset( $r['class'] ) )		$r['class'] = ( 'category' == $r['taxonomy'] ) ? 'categories' : $r['taxonomy'];	extract( $r );	if ( !taxonomy_exists($taxonomy) )		return false;	$categories = get_categories( $r );	$output = '';	if ( $title_li && 'list' == $style )			$output = '<li class="' . $class . '">' . $title_li . '<ul>';	if ( empty( $categories ) ) {		if ( ! empty( $show_option_none ) ) {			if ( 'list' == $style )				$output .= '<li>' . $show_option_none . '</li>';			else				$output .= $show_option_none;		}	} else {		global $wp_query;		if( !empty( $show_option_all ) )			if ( 'list' == $style )				$output .= '<li><a href="' .  get_bloginfo( 'url' )  . '">' . $show_option_all . '</a></li>';			else				$output .= '<a href="' .  get_bloginfo( 'url' )  . '">' . $show_option_all . '</a>';		if ( empty( $r['current_category'] ) && ( is_category() || is_tax() ) )			$r['current_category'] = $wp_query->get_queried_object_id();		if ( $hierarchical )			$depth = $r['depth'];		else			$depth = -1; // Flat.		$output .= walk_category_tree( $categories, $depth, $r );	}	if ( $title_li && 'list' == $style )		$output .= '</ul></li>';	$output = apply_filters( 'wp_list_categories', $output, $args );	if ( $echo )		echo $output;	else		return $output;}/** * Display tag cloud. * * The text size is set by the 'smallest' and 'largest' arguments, which will * use the 'unit' argument value for the CSS text size unit. The 'format' * argument can be 'flat' (default), 'list', or 'array'. The flat value for the * 'format' argument will separate tags with spaces. The list value for the * 'format' argument will format the tags in a UL HTML list. The array value for * the 'format' argument will return in PHP array type format. * * The 'orderby' argument will accept 'name' or 'count' and defaults to 'name'. * The 'order' is the direction to sort, defaults to 'ASC' and can be 'DESC'. * * The 'number' argument is how many tags to return. By default, the limit will * be to return the top 45 tags in the tag cloud list. * * The 'topic_count_text_callback' argument is a function, which, given the count * of the posts  with that tag, returns a text for the tooltip of the tag link. * * The 'exclude' and 'include' arguments are used for the {@link get_tags()} * function. Only one should be used, because only one will be used and the * other ignored, if they are both set. * * @since 2.3.0 * * @param array|string $args Optional. Override default arguments. * @return array Generated tag cloud, only if no failures and 'array' is set for the 'format' argument. */function wp_tag_cloud( $args = '' ) {	$defaults = array(		'smallest' => 8, 'largest' => 22, 'unit' => 'pt', 'number' => 45,		'format' => 'flat', 'separator' => "\n", 'orderby' => 'name', 'order' => 'ASC',		'exclude' => '', 'include' => '', 'link' => 'view', 'taxonomy' => 'post_tag', 'echo' => true	);	$args = wp_parse_args( $args, $defaults );	$tags = get_terms( $args['taxonomy'], array_merge( $args, array( 'orderby' => 'count', 'order' => 'DESC' ) ) ); // Always query top tags	if ( empty( $tags ) )		return;	foreach ( $tags as $key => $tag ) {		if ( 'edit' == $args['link'] )			$link = get_edit_tag_link( $tag->term_id, $args['taxonomy'] );		else			$link = get_term_link( intval($tag->term_id), $args['taxonomy'] );		if ( is_wp_error( $link ) )			return false;		$tags[ $key ]->link = $link;		$tags[ $key ]->id = $tag->term_id;	}	$return = wp_generate_tag_cloud( $tags, $args ); // Here's where those top tags get sorted according to $args	$return = apply_filters( 'wp_tag_cloud', $return, $args );	if ( 'array' == $args['format'] || empty($args['echo']) )		return $return;	echo $return;}/** * Default text for tooltip for tag links * * @param integer $count number of posts with that tag * @return string text for the tooltip of a tag link. */function default_topic_count_text( $count ) {	return sprintf( _n('%s topic', '%s topics', $count), number_format_i18n( $count ) );}/** * Default topic count scaling for tag links * * @param integer $count number of posts with that tag * @return integer scaled count */function default_topic_count_scale( $count ) {	return round(log10($count + 1) * 100);}/** * Generates a tag cloud (heatmap) from provided data. * * The text size is set by the 'smallest' and 'largest' arguments, which will * use the 'unit' argument value for the CSS text size unit. The 'format' * argument can be 'flat' (default), 'list', or 'array'. The flat value for the * 'format' argument will separate tags with spaces. The list value for the * 'format' argument will format the tags in a UL HTML list. The array value for * the 'format' argument will return in PHP array type format. * * The 'tag_cloud_sort' filter allows you to override the sorting. * Passed to the filter: $tags array and $args array, has to return the $tags array * after sorting it. * * The 'orderby' argument will accept 'name' or 'count' and defaults to 'name'. * The 'order' is the direction to sort, defaults to 'ASC' and can be 'DESC' or * 'RAND'. * * The 'number' argument is how many tags to return. By default, the limit will * be to return the entire tag cloud list. * * The 'topic_count_text_callback' argument is a function, which given the count * of the posts  with that tag returns a text for the tooltip of the tag link. * * @todo Complete functionality. * @since 2.3.0 * * @param array $tags List of tags. * @param string|array $args Optional, override default arguments. * @return string */function wp_generate_tag_cloud( $tags, $args = '' ) {	global $wp_rewrite;	$defaults = array(		'smallest' => 8, 'largest' => 22, 'unit' => 'pt', 'number' => 0,		'format' => 'flat', 'separator' => "\n", 'orderby' => 'name', 'order' => 'ASC',		'topic_count_text_callback' => 'default_topic_count_text',		'topic_count_scale_callback' => 'default_topic_count_scale', 'filter' => 1,	);	if ( !isset( $args['topic_count_text_callback'] ) && isset( $args['single_text'] ) && isset( $args['multiple_text'] ) ) {		$body = 'return sprintf (			_n(' . var_export($args['single_text'], true) . ', ' . var_export($args['multiple_text'], true) . ', $count),			number_format_i18n( $count ));';		$args['topic_count_text_callback'] = create_function('$count', $body);	}	$args = wp_parse_args( $args, $defaults );	extract( $args );	if ( empty( $tags ) )		return;	$tags_sorted = apply_filters( 'tag_cloud_sort', $tags, $args );	if ( $tags_sorted != $tags  ) { // the tags have been sorted by a plugin		$tags = $tags_sorted;		unset($tags_sorted);	} else {		if ( 'RAND' == $order ) {			shuffle($tags);		} else {			// SQL cannot save you; this is a second (potentially different) sort on a subset of data.			if ( 'name' == $orderby )				uasort( $tags, create_function('$a, $b', 'return strnatcasecmp($a->name, $b->name);') );			else				uasort( $tags, create_function('$a, $b', 'return ($a->count > $b->count);') );			if ( 'DESC' == $order )				$tags = array_reverse( $tags, true );		}	}	if ( $number > 0 )		$tags = array_slice($tags, 0, $number);	$counts = array();	$real_counts = array(); // For the alt tag	foreach ( (array) $tags as $key => $tag ) {		$real_counts[ $key ] = $tag->count;		$counts[ $key ] = $topic_count_scale_callback($tag->count);	}	$min_count = min( $counts );	$spread = max( $counts ) - $min_count;	if ( $spread <= 0 )		$spread = 1;	$font_spread = $largest - $smallest;	if ( $font_spread < 0 )		$font_spread = 1;	$font_step = $font_spread / $spread;	$a = array();	foreach ( $tags as $key => $tag ) {		$count = $counts[ $key ];		$real_count = $real_counts[ $key ];		$tag_link = '#' != $tag->link ? esc_url( $tag->link ) : '#';		$tag_id = isset($tags[ $key ]->id) ? $tags[ $key ]->id : $key;		$tag_name = $tags[ $key ]->name;		$a[] = "<a href='$tag_link' class='tag-link-$tag_id' title='" . esc_attr( $topic_count_text_callback( $real_count ) ) . "' style='font-size: " .			( $smallest + ( ( $count - $min_count ) * $font_step ) )			. "$unit;'>$tag_name</a>";	}	switch ( $format ) :	case 'array' :		$return =& $a;		break;	case 'list' :		$return = "<ul class='wp-tag-cloud'>\n\t<li>";		$return .= join( "</li>\n\t<li>", $a );		$return .= "</li>\n</ul>\n";		break;	default :		$return = join( $separator, $a );		break;	endswitch;    if ( $filter )		return apply_filters( 'wp_generate_tag_cloud', $return, $tags, $args );    else		return $return;}//// Helper functions///** * Retrieve HTML list content for category list. * * @uses Walker_Category to create HTML list content. * @since 2.1.0 * @see Walker_Category::walk() for parameters and return description. */function walk_category_tree() {	$args = func_get_args();	// the user's options are the third parameter	if ( empty($args[2]['walker']) || !is_a($args[2]['walker'], 'Walker') )		$walker = new Walker_Category;	else		$walker = $args[2]['walker'];	return call_user_func_array(array( &$walker, 'walk' ), $args );}/** * Retrieve HTML dropdown (select) content for category list. * * @uses Walker_CategoryDropdown to create HTML dropdown content. * @since 2.1.0 * @see Walker_CategoryDropdown::walk() for parameters and return description. */function walk_category_dropdown_tree() {	$args = func_get_args();	// the user's options are the third parameter	if ( empty($args[2]['walker']) || !is_a($args[2]['walker'], 'Walker') )		$walker = new Walker_CategoryDropdown;	else		$walker = $args[2]['walker'];	return call_user_func_array(array( &$walker, 'walk' ), $args );}//// Tags///** * Retrieve the link to the tag. * * @since 2.3.0 * @uses apply_filters() Calls 'tag_link' with tag link and tag ID as parameters. * * @param int $tag_id Tag (term) ID. * @return string */function get_tag_link( $tag_id ) {	global $wp_rewrite;	$taglink = $wp_rewrite->get_tag_permastruct();	$tag = &get_term( $tag_id, 'post_tag' );	if ( is_wp_error( $tag ) )		return $tag;	$slug = $tag->slug;	if ( empty( $taglink ) ) {		$file = get_option( 'home' ) . '/';		$taglink = $file . '?tag=' . $slug;	} else {		$taglink = str_replace( '%tag%', $slug, $taglink );		$taglink = get_option( 'home' ) . user_trailingslashit( $taglink, 'category' );	}	return apply_filters( 'tag_link', $taglink, $tag_id );}/** * Retrieve the tags for a post. * * @since 2.3.0 * @uses apply_filters() Calls 'get_the_tags' filter on the list of post tags. * * @param int $id Post ID. * @return array */function get_the_tags( $id = 0 ) {	return apply_filters( 'get_the_tags', get_the_terms( $id, 'post_tag' ) );}/** * Retrieve the tags for a post formatted as a string. * * @since 2.3.0 * @uses apply_filters() Calls 'the_tags' filter on string list of tags. * * @param string $before Optional. Before tags. * @param string $sep Optional. Between tags. * @param string $after Optional. After tags. * @return string */function get_the_tag_list( $before = '', $sep = '', $after = '' ) {	return apply_filters( 'the_tags', get_the_term_list( 0, 'post_tag', $before, $sep, $after ), $before, $sep, $after);}/** * Retrieve the tags for a post. * * @since 2.3.0 * * @param string $before Optional. Before list. * @param string $sep Optional. Separate items using this. * @param string $after Optional. After list. * @return string */function the_tags( $before = null, $sep = ', ', $after = '' ) {	if ( null === $before )		$before = __('Tags: ');	echo get_the_tag_list($before, $sep, $after);}/** * Retrieve tag description. * * @since 2.8 * * @param int $tag Optional. Tag ID. Will use global tag ID by default. * @return string Tag description, available. */function tag_description( $tag = 0 ) {	return term_description( $tag );}/** * Retrieve term description. * * @since 2.8 * * @param int $term Optional. Term ID. Will use global term ID by default. * @return string Term description, available. */function term_description( $term = 0, $taxonomy = 'post_tag' ) {	if ( !$term && ( is_tax() || is_tag() || is_category() ) ) {		global $wp_query;		$term = $wp_query->get_queried_object();		$taxonomy = $term->taxonomy;		$term = $term->term_id;	}	$description = get_term_field( 'description', $term, $taxonomy );	return is_wp_error( $description ) ? '' : $description;}/** * Retrieve the terms of the taxonomy that are attached to the post. * * This function can only be used within the loop. * * @since 2.5.0 * * @param int $id Post ID. Is not optional. * @param string $taxonomy Taxonomy name. * @return array|bool False on failure. Array of term objects on success. */function get_the_terms( $id = 0, $taxonomy ) {	global $post; 	$id = (int) $id;	if ( !$id ) {		if ( !$post->ID )			return false;		else			$id = (int) $post->ID;	}	$terms = get_object_term_cache( $id, $taxonomy );	if ( false === $terms )		$terms = wp_get_object_terms( $id, $taxonomy );	if ( empty( $terms ) )		return false;	return $terms;}/** * Retrieve a post's terms as a list with specified format. * * @since 2.5.0 * * @param int $id Post ID. * @param string $taxonomy Taxonomy name. * @param string $before Optional. Before list. * @param string $sep Optional. Separate items using this. * @param string $after Optional. After list. * @return string */function get_the_term_list( $id = 0, $taxonomy, $before = '', $sep = '', $after = '' ) {	$terms = get_the_terms( $id, $taxonomy );	if ( is_wp_error( $terms ) )		return $terms;	if ( empty( $terms ) )		return false;	foreach ( $terms as $term ) {		$link = get_term_link( $term, $taxonomy );		if ( is_wp_error( $link ) )			return $link;		$term_links[] = '<a href="' . $link . '" rel="tag">' . $term->name . '</a>';	}	$term_links = apply_filters( "term_links-$taxonomy", $term_links );	return $before . join( $sep, $term_links ) . $after;}/** * Display the terms in a list. * * @since 2.5.0 * * @param int $id Term ID. * @param string $taxonomy Taxonomy name. * @param string $before Optional. Before list. * @param string $sep Optional. Separate items using this. * @param string $after Optional. After list. * @return null|bool False on WordPress error. Returns null when displaying. */function the_terms( $id, $taxonomy, $before = '', $sep = ', ', $after = '' ) {	$term_list = get_the_term_list( $id, $taxonomy, $before, $sep, $after );	if ( is_wp_error( $term_list ) )		return false;	echo apply_filters('the_terms', $term_list, $taxonomy, $before, $sep, $after);}/** * Check if the current post has any of given tags. * * The given tags are checked against the post's tags' term_ids, names and slugs. * Tags given as integers will only be checked against the post's tags' term_ids. * If no tags are given, determines if post has any tags. * * Prior to v2.7 of WordPress, tags given as integers would also be checked against the post's tags' names and slugs (in addition to term_ids) * Prior to v2.7, this function could only be used in the WordPress Loop. * As of 2.7, the function can be used anywhere if it is provided a post ID or post object. * * @since 2.6.0 * * @uses is_object_in_term() * * @param string|int|array $tag Optional. The tag name/term_id/slug or array of them to check for. * @param int|post object Optional.  Post to check instead of the current post. @since 2.7.0 * @return bool True if the current post has any of the the given tags (or any tag, if no tag specified). */function has_tag( $tag = '', $_post = null ) {	if ( $_post ) {		$_post = get_post( $_post );	} else {		$_post =& $GLOBALS['post'];	}	if ( !$_post )		return false;	$r = is_object_in_term( $_post->ID, 'post_tag', $tag );	if ( is_wp_error( $r ) )		return false;	return $r;}?>
<?php/** * Edit Tags Administration Panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');wp_reset_vars( array('action', 'tag', 'taxonomy', 'post_type') );if ( empty($taxonomy) )	$taxonomy = 'post_tag';if ( !taxonomy_exists($taxonomy) )	wp_die(__('Invalid taxonomy'));$tax = get_taxonomy($taxonomy);$title = $tax->labels->name;if ( empty($post_type) || !in_array( $post_type, get_post_types( array('public' => true) ) ) )	$post_type = 'post';if ( 'post' != $post_type ) {	$parent_file = "edit.php?post_type=$post_type";	$submenu_file = "edit-tags.php?taxonomy=$taxonomy&amp;post_type=$post_type";} else {	$parent_file = 'edit.php';	$submenu_file = "edit-tags.php?taxonomy=$taxonomy";}if ( isset( $_GET['action'] ) && isset($_GET['delete_tags']) && ( 'delete' == $_GET['action'] || 'delete' == $_GET['action2'] ) )	$action = 'bulk-delete';switch($action) {case 'add-tag':	check_admin_referer('add-tag');	if ( !current_user_can($tax->cap->edit_terms) )		wp_die(__('Cheatin&#8217; uh?'));	$ret = wp_insert_term($_POST['tag-name'], $taxonomy, $_POST);	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_original_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	if ( $ret && !is_wp_error( $ret ) )		$location = add_query_arg('message', 1, $location);	else		$location = add_query_arg('message', 4, $location);	wp_redirect($location);	exit;break;case 'delete':	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	if ( !isset( $_GET['tag_ID'] ) ) {		wp_redirect($location);		exit;	}	$tag_ID = (int) $_GET['tag_ID'];	check_admin_referer('delete-tag_' .  $tag_ID);	if ( !current_user_can($tax->cap->delete_terms) )		wp_die(__('Cheatin&#8217; uh?'));	wp_delete_term( $tag_ID, $taxonomy);	$location = add_query_arg('message', 2, $location);	wp_redirect($location);	exit;break;case 'bulk-delete':	check_admin_referer('bulk-tags');	if ( !current_user_can($tax->cap->delete_terms) )		wp_die(__('Cheatin&#8217; uh?'));	$tags = (array) $_GET['delete_tags'];	foreach( $tags as $tag_ID ) {		wp_delete_term( $tag_ID, $taxonomy);	}	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	$location = add_query_arg('message', 6, $location);	wp_redirect($location);	exit;break;case 'edit':	$title = $tax->labels->edit_item;	require_once ('admin-header.php');	$tag_ID = (int) $_GET['tag_ID'];	$tag = get_term($tag_ID, $taxonomy, OBJECT, 'edit');	include('./edit-tag-form.php');break;case 'editedtag':	$tag_ID = (int) $_POST['tag_ID'];	check_admin_referer('update-tag_' . $tag_ID);	if ( !current_user_can($tax->cap->edit_terms) )		wp_die(__('Cheatin&#8217; uh?'));	$ret = wp_update_term($tag_ID, $taxonomy, $_POST);	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_original_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	if ( $ret && !is_wp_error( $ret ) )		$location = add_query_arg('message', 3, $location);	else		$location = add_query_arg('message', 5, $location);	wp_redirect($location);	exit;break;default:if ( ! empty($_GET['_wp_http_referer']) ) {	 wp_redirect( remove_query_arg( array('_wp_http_referer', '_wpnonce'), stripslashes($_SERVER['REQUEST_URI']) ) );	 exit;}wp_enqueue_script('admin-tags');if ( current_user_can($tax->cap->edit_terms) )	wp_enqueue_script('inline-edit-tax');if ( 'category' == $taxonomy || 'post_tag' == $taxonomy ) {	if ( 'category' == $taxonomy )		$help = '<p>' . sprintf(__('You can use categories to define sections of your site and group related posts. The default category is &#8220;Uncategorized&#8221; until you change it in your <a href="%s">writing settings</a>.'), 'options-writing.php') . '</p>';	else		$help = '<p>' . __('You can assign keywords to your posts using Post Tags. Unlike categories, tags have no hierarchy, meaning there&#8217;s no relationship from one tag to another.') . '</p>';	$help .='<p>' . __('What&#8217;s the difference between categories and tags? Normally, tags are ad-hoc keywords that identify important information in your post (names, subjects, etc) that may or may not recur in other posts, while categories are pre-determined sections. If you think of your site like a book, the categories are like the Table of Contents and the tags are like the terms in the index.') . '</p>';	if ( 'category' == $taxonomy )		$help .= '<p>' . __('When adding a new category on this screen, you&#8217;ll fill in the following fields:') . '</p>';	else		$help .= '<p>' . __('When adding a new tag on this screen, you&#8217;ll fill in the following fields:') . '</p>';	$help .= '<ul>' .		'<li>' . __('<strong>Name</strong> - The name is how it appears on your site.') . '</li>';	if ( ! global_terms_enabled() )		$help .= '<li>' . __('<strong>Slug</strong> - The &#8220;slug&#8221; is the URL-friendly version of the name. It is usually all lowercase and contains only letters, numbers, and hyphens.') . '</li>';	if ( 'category' == $taxonomy )		$help .= '<li>' . __('<strong>Parent</strong> - Categories, unlike tags, can have a hierarchy. You might have a Jazz category, and under that have children categories for Bebop and Big Band. Totally optional. To create a subcategory, just choose another category from the Parent dropdown.') . '</li>';	$help .= '<li>' . __('<strong>Description</strong> - The description is not prominent by default; however, some themes may display it.') . '</li>' .		'</ul>' .		'<p>' . __('You can change the display of this screen using the Screen Options tab to set how many items are displayed per screen and to display/hide columns in the table.') . '</p>' .		'<p><strong>' . __('For more information:') . '</strong></p>';	if ( 'category' == $taxonomy )		$help .= '<p>' . __('<a href="http://codex.wordpress.org/Manage_Categories_SubPanel" target="_blank">Categories Documentation</a>') . '</p>';	else		$help .= '<p>' . __('<a href="http://codex.wordpress.org/Post_Tags_SubPanel" target="_blank">Tags Documentation</a>') . '</p>';	$help .= '<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>';	add_contextual_help($current_screen, $help);	unset($help);}require_once ('admin-header.php');$messages[1] = __('Item added.');$messages[2] = __('Item deleted.');$messages[3] = __('Item updated.');$messages[4] = __('Item not added.');$messages[5] = __('Item not updated.');$messages[6] = __('Items deleted.');?><div class="wrap nosubsub"><?php screen_icon(); ?><h2><?php echo esc_html( $title );if ( !empty($_GET['s']) )	printf( '<span class="subtitle">' . __('Search results for &#8220;%s&#8221;') . '</span>', esc_html( stripslashes($_GET['s']) ) ); ?></h2><?php if ( isset($_GET['message']) && ( $msg = (int) $_GET['message'] ) ) : ?><div id="message" class="updated"><p><?php echo $messages[$msg]; ?></p></div><?php $_SERVER['REQUEST_URI'] = remove_query_arg(array('message'), $_SERVER['REQUEST_URI']);endif; ?><div id="ajax-response"></div><form class="search-form" action="" method="get"><input type="hidden" name="taxonomy" value="<?php echo esc_attr($taxonomy); ?>" /><input type="hidden" name="post_type" value="<?php echo esc_attr($post_type); ?>" /><p class="search-box">	<label class="screen-reader-text" for="tag-search-input"><?php echo $tax->labels->search_items; ?>:</label>	<input type="text" id="tag-search-input" name="s" value="<?php _admin_search_query(); ?>" />	<input type="submit" value="<?php echo esc_attr( $tax->labels->search_items );  ?>" class="button" /></p></form><br class="clear" /><div id="col-container"><div id="col-right"><div class="col-wrap"><form id="posts-filter" action="" method="get"><input type="hidden" name="taxonomy" value="<?php echo esc_attr($taxonomy); ?>" /><input type="hidden" name="post_type" value="<?php echo esc_attr($post_type); ?>" /><div class="tablenav"><?php$pagenum = isset( $_GET['pagenum'] ) ? absint( $_GET['pagenum'] ) : 0;if ( empty($pagenum) )	$pagenum = 1;$tags_per_page = (int) get_user_option( 'edit_' .  $taxonomy . '_per_page' );if ( empty($tags_per_page) || $tags_per_page < 1 )	$tags_per_page = 20;if ( 'post_tag' == $taxonomy ) {	$tags_per_page = apply_filters( 'edit_tags_per_page', $tags_per_page );	$tags_per_page = apply_filters( 'tagsperpage', $tags_per_page ); // Old filter} elseif ( 'category' == $taxonomy ) {	$tags_per_page = apply_filters( 'edit_categories_per_page', $tags_per_page ); // Old filter} else {	$tags_per_page = apply_filters( 'edit_' . $taxonomy . '_per_page', $tags_per_page );}$searchterms = !empty($_GET['s']) ? trim(stripslashes($_GET['s'])) : '';$page_links = paginate_links( array(	'base' => add_query_arg( 'pagenum', '%#%' ),	'format' => '',	'prev_text' => __('&laquo;'),	'next_text' => __('&raquo;'),	'total' => ceil(wp_count_terms($taxonomy, array('search' => $searchterms)) / $tags_per_page),	'current' => $pagenum));if ( $page_links )	echo "<div class='tablenav-pages'>$page_links</div>";?><div class="alignleft actions"><select name="action"><option value="" selected="selected"><?php _e('Bulk Actions'); ?></option><option value="delete"><?php _e('Delete'); ?></option></select><input type="submit" value="<?php esc_attr_e('Apply'); ?>" name="doaction" id="doaction" class="button-secondary action" /><?php wp_nonce_field('bulk-tags'); ?></div><br class="clear" /></div><div class="clear"></div><table class="widefat tag fixed" cellspacing="0">	<thead>	<tr><?php print_column_headers($current_screen); ?>	</tr>	</thead>	<tfoot>	<tr><?php print_column_headers($current_screen, false); ?>	</tr>	</tfoot>	<tbody id="the-list" class="list:tag"><?php tag_rows( $pagenum, $tags_per_page, $searchterms, $taxonomy ); ?>	</tbody></table><div class="tablenav"><?phpif ( $page_links )	echo "<div class='tablenav-pages'>$page_links</div>";?><div class="alignleft actions"><select name="action2"><option value="" selected="selected"><?php _e('Bulk Actions'); ?></option><option value="delete"><?php _e('Delete'); ?></option></select><input type="submit" value="<?php esc_attr_e('Apply'); ?>" name="doaction2" id="doaction2" class="button-secondary action" /></div><br class="clear" /></div><br class="clear" /></form><?php if ( 'category' == $taxonomy ) : ?><div class="form-wrap"><p><?php printf(__('<strong>Note:</strong><br />Deleting a category does not delete the posts in that category. Instead, posts that were only assigned to the deleted category are set to the category <strong>%s</strong>.'), apply_filters('the_category', get_cat_name(get_option('default_category')))) ?></p><?php if ( current_user_can( 'import' ) ) : ?><p><?php printf(__('Categories can be selectively converted to tags using the <a href="%s">category to tag converter</a>.'), 'import.php') ?></p><?php endif; ?></div><?php elseif ( 'post_tag' == $taxonomy && current_user_can( 'import' ) ) : ?><div class="form-wrap"><p><?php printf(__('Tags can be selectively converted to categories using the <a href="%s">tag to category converter</a>'), 'import.php') ;?>.</p></div><?php endif;do_action('after-' . $taxonomy . '-table', $taxonomy);?></div></div><!-- /col-right --><div id="col-left"><div class="col-wrap"><?phpif ( !is_taxonomy_hierarchical($taxonomy) ) {	if ( current_user_can( $tax->cap->edit_terms ) )		$tag_cloud = wp_tag_cloud( array( 'taxonomy' => $taxonomy, 'echo' => false, 'link' => 'edit' ) );	else		$tag_cloud = wp_tag_cloud( array( 'taxonomy' => $taxonomy, 'echo' => false ) );	if ( $tag_cloud ) :	?><div class="tagcloud"><h3><?php echo $tax->labels->popular_items; ?></h3><?php echo $tag_cloud; unset( $tag_cloud ); ?></div><?phpendif;}if ( current_user_can($tax->cap->edit_terms) ) {	if ( 'category' == $taxonomy )		do_action('add_category_form_pre', (object)array('parent' => 0) );  // Back compat hook. Deprecated in preference to $taxonomy_pre_add_form	else		do_action('add_tag_form_pre', $taxonomy); // Back compat hook. Applies to all Taxonomies -not- categories	do_action($taxonomy . '_pre_add_form', $taxonomy);?><div class="form-wrap"><h3><?php echo $tax->labels->add_new_item; ?></h3><form id="addtag" method="post" action="edit-tags.php" class="validate"><input type="hidden" name="action" value="add-tag" /><input type="hidden" name="screen" value="<?php echo esc_attr($current_screen->id); ?>" /><input type="hidden" name="taxonomy" value="<?php echo esc_attr($taxonomy); ?>" /><?php wp_nonce_field('add-tag'); ?><div class="form-field form-required">	<label for="tag-name"><?php _ex('Name', 'Taxonomy Name'); ?></label>	<input name="tag-name" id="tag-name" type="text" value="" size="40" aria-required="true" />	<p><?php _e('The name is how it appears on your site.'); ?></p></div><?php if ( ! global_terms_enabled() ) : ?><div class="form-field">	<label for="tag-slug"><?php _ex('Slug', 'Taxonomy Slug'); ?></label>	<input name="slug" id="tag-slug" type="text" value="" size="40" />	<p><?php _e('The &#8220;slug&#8221; is the URL-friendly version of the name. It is usually all lowercase and contains only letters, numbers, and hyphens.'); ?></p></div><?php endif; // is_multisite() ?><?php if ( is_taxonomy_hierarchical($taxonomy) ) : ?><div class="form-field">	<label for="parent"><?php _ex('Parent', 'Taxonomy Parent'); ?></label>	<?php wp_dropdown_categories(array('hide_empty' => 0, 'hide_if_empty' => false, 'taxonomy' => $taxonomy, 'name' => 'parent', 'orderby' => 'name', 'hierarchical' => true, 'show_option_none' => __('None'))); ?>	<?php if ( 'category' == $taxonomy ) : // @todo: Generic text for hierarchical taxonomies ?>		<p><?php _e('Categories, unlike tags, can have a hierarchy. You might have a Jazz category, and under that have children categories for Bebop and Big Band. Totally optional.'); ?></p>	<?php endif; ?></div><?php endif; // is_taxonomy_hierarchical() ?><div class="form-field">	<label for="tag-description"><?php _ex('Description', 'Taxonomy Description'); ?></label>	<textarea name="description" id="tag-description" rows="5" cols="40"></textarea>	<p><?php _e('The description is not prominent by default; however, some themes may show it.'); ?></p></div><?phpif ( ! is_taxonomy_hierarchical($taxonomy) )	do_action('add_tag_form_fields', $taxonomy);do_action($taxonomy . '_add_form_fields', $taxonomy);?><p class="submit"><input type="submit" class="button" name="submit" id="submit" value="<?php echo esc_attr( $tax->labels->add_new_item ); ?>" /></p><?phpif ( 'category' == $taxonomy )	do_action('edit_category_form',	(object)array('parent' => 0) );  // Back compat hook. Deprecated in preference to $taxonomy_add_formelse	do_action('add_tag_form', $taxonomy); // Back compat hook. Applies to all Taxonomies -not- categoriesdo_action($taxonomy . '_add_form', $taxonomy);?></form></div><?php } ?></div></div><!-- /col-left --></div><!-- /col-container --></div><!-- /wrap --><?php inline_edit_term_row('edit-tags', $taxonomy); ?><?phpbreak;}include('./admin-footer.php');?>
<?php/** * WordPress Taxonomy Administration API. * * @package WordPress * @subpackage Administration *///// Category///** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $cat_name * @return unknown */function category_exists($cat_name, $parent = 0) {	$id = term_exists($cat_name, 'category', $parent);	if ( is_array($id) )		$id = $id['term_id'];	return $id;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $id * @return unknown */function get_category_to_edit( $id ) {	$category = get_category( $id, OBJECT, 'edit' );	return $category;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $cat_name * @param unknown_type $parent * @return unknown */function wp_create_category( $cat_name, $parent = 0 ) {	if ( $id = category_exists($cat_name, $parent) )		return $id;	return wp_insert_category( array('cat_name' => $cat_name, 'category_parent' => $parent) );}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $categories * @param unknown_type $post_id * @return unknown */function wp_create_categories($categories, $post_id = '') {	$cat_ids = array ();	foreach ($categories as $category) {		if ($id = category_exists($category))			$cat_ids[] = $id;		else			if ($id = wp_create_category($category))				$cat_ids[] = $id;	}	if ( $post_id )		wp_set_post_categories($post_id, $cat_ids);	return $cat_ids;}/** * Deletes one existing category. * * @since 2.0.0 * * @param int $cat_ID * @return mixed Returns true if completes delete action; false if term doesnt exist; Zero on attempted deletion of default Category; WP_Error object is also a possibility. */function wp_delete_category($cat_ID) {	$cat_ID = (int) $cat_ID;	$default = get_option('default_category');	// Don't delete the default cat	if ( $cat_ID == $default )		return 0;	return wp_delete_term($cat_ID, 'category', array('default' => $default));}/** * Updates an existing Category or creates a new Category. * * @since 2.0.0 * * @param mixed $catarr See defaults below. Set 'cat_ID' to a non-zero value to update an existing category. The 'taxonomy' key was added in 3.0.0. * @param bool $wp_error Optional, since 2.5.0. Set this to true if the caller handles WP_Error return values. * @return int|object The ID number of the new or updated Category on success.  Zero or a WP_Error on failure, depending on param $wp_error. */function wp_insert_category($catarr, $wp_error = false) {	$cat_defaults = array('cat_ID' => 0, 'taxonomy' => 'category', 'cat_name' => '', 'category_description' => '', 'category_nicename' => '', 'category_parent' => '');	$catarr = wp_parse_args($catarr, $cat_defaults);	extract($catarr, EXTR_SKIP);	if ( trim( $cat_name ) == '' ) {		if ( ! $wp_error )			return 0;		else			return new WP_Error( 'cat_name', __('You did not enter a category name.') );	}	$cat_ID = (int) $cat_ID;	// Are we updating or creating?	if ( !empty ($cat_ID) )		$update = true;	else		$update = false;	$name = $cat_name;	$description = $category_description;	$slug = $category_nicename;	$parent = $category_parent;	$parent = (int) $parent;	if ( $parent < 0 )		$parent = 0;	if ( empty($parent) || !category_exists( $parent ) || ($cat_ID && cat_is_ancestor_of($cat_ID, $parent) ) )		$parent = 0;	$args = compact('name', 'slug', 'parent', 'description');	if ( $update )		$cat_ID = wp_update_term($cat_ID, $taxonomy, $args);	else		$cat_ID = wp_insert_term($cat_name, $taxonomy, $args);	if ( is_wp_error($cat_ID) ) {		if ( $wp_error )			return $cat_ID;		else			return 0;	}	return $cat_ID['term_id'];}/** * Aliases wp_insert_category() with minimal args. * * If you want to update only some fields of an existing category, call this * function with only the new values set inside $catarr. * * @since 2.0.0 * * @param array $catarr The 'cat_ID' value is required.  All other keys are optional. * @return int|bool The ID number of the new or updated Category on success. Zero or FALSE on failure. */function wp_update_category($catarr) {	$cat_ID = (int) $catarr['cat_ID'];	if ( isset($catarr['category_parent']) && ($cat_ID == $catarr['category_parent']) )		return false;	// First, get all of the original fields	$category = get_category($cat_ID, ARRAY_A);	// Escape data pulled from DB.	$category = add_magic_quotes($category);	// Merge old and new fields with new fields overwriting old ones.	$catarr = array_merge($category, $catarr);	return wp_insert_category($catarr);}//// Tags///** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $post_id * @return unknown */function get_tags_to_edit( $post_id, $taxonomy = 'post_tag' ) {	return get_terms_to_edit( $post_id, $taxonomy);}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $post_id * @return unknown */function get_terms_to_edit( $post_id, $taxonomy = 'post_tag' ) {	$post_id = (int) $post_id;	if ( !$post_id )		return false;	$tags = wp_get_post_terms($post_id, $taxonomy, array());	if ( !$tags )		return false;	if ( is_wp_error($tags) )		return $tags;	foreach ( $tags as $tag )		$tag_names[] = $tag->name;	$tags_to_edit = join( ',', $tag_names );	$tags_to_edit = esc_attr( $tags_to_edit );	$tags_to_edit = apply_filters( 'terms_to_edit', $tags_to_edit, $taxonomy );	return $tags_to_edit;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $tag_name * @return unknown */function tag_exists($tag_name) {	return term_exists($tag_name, 'post_tag');}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $tag_name * @return unknown */function wp_create_tag($tag_name) {	return wp_create_term( $tag_name, 'post_tag');}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $tag_name * @return unknown */function wp_create_term($tag_name, $taxonomy = 'post_tag') {	if ( $id = term_exists($tag_name, $taxonomy) )		return $id;	return wp_insert_term($tag_name, $taxonomy);}
<?php/** * WordPress Post Administration API. * * @package WordPress * @subpackage Administration *//** * Rename $_POST data from form names to DB post columns. * * Manipulates $_POST directly. * * @package WordPress * @since 2.6.0 * * @param bool $update Are we updating a pre-existing post? * @param post_data array Array of post data. Defaults to the contents of $_POST. * @return object|bool WP_Error on failure, true on success. */function _wp_translate_postdata( $update = false, $post_data = null ) {	if ( empty($post_data) )		$post_data = &$_POST;	if ( $update )		$post_data['ID'] = (int) $post_data['post_ID'];	$post_data['post_content'] = isset($post_data['content']) ? $post_data['content'] : '';	$post_data['post_excerpt'] = isset($post_data['excerpt']) ? $post_data['excerpt'] : '';	$post_data['post_parent'] = isset($post_data['parent_id'])? $post_data['parent_id'] : '';	if ( isset($post_data['trackback_url']) )		$post_data['to_ping'] = $post_data['trackback_url'];	if ( !isset($post_data['user_ID']) )		$post_data['user_ID'] = $GLOBALS['user_ID'];	if (!empty ( $post_data['post_author_override'] ) ) {		$post_data['post_author'] = (int) $post_data['post_author_override'];	} else {		if (!empty ( $post_data['post_author'] ) ) {			$post_data['post_author'] = (int) $post_data['post_author'];		} else {			$post_data['post_author'] = (int) $post_data['user_ID'];		}	}	$ptype = get_post_type_object( $post_data['post_type'] );	if ( isset($post_data['user_ID']) && ($post_data['post_author'] != $post_data['user_ID']) ) {		if ( !current_user_can( $ptype->cap->edit_others_posts ) ) {			if ( 'page' == $post_data['post_type'] ) {				return new WP_Error( 'edit_others_pages', $update ?					__( 'You are not allowed to edit pages as this user.' ) :					__( 'You are not allowed to create pages as this user.' )				);			} else {				return new WP_Error( 'edit_others_posts', $update ?					__( 'You are not allowed to edit posts as this user.' ) :					__( 'You are not allowed to post as this user.' )				);			}		}	}	// What to do based on which button they pressed	if ( isset($post_data['saveasdraft']) && '' != $post_data['saveasdraft'] )		$post_data['post_status'] = 'draft';	if ( isset($post_data['saveasprivate']) && '' != $post_data['saveasprivate'] )		$post_data['post_status'] = 'private';	if ( isset($post_data['publish']) && ( '' != $post_data['publish'] ) && ( !isset($post_data['post_status']) || $post_data['post_status'] != 'private' ) )		$post_data['post_status'] = 'publish';	if ( isset($post_data['advanced']) && '' != $post_data['advanced'] )		$post_data['post_status'] = 'draft';	if ( isset($post_data['pending']) && '' != $post_data['pending'] )		$post_data['post_status'] = 'pending';	if ( isset( $post_data['ID'] ) )		$post_id = $post_data['ID'];	else		$post_id = false;	$previous_status = $post_id ? get_post_field( 'post_status', $post_id ) : false;	// Posts 'submitted for approval' present are submitted to $_POST the same as if they were being published.	// Change status from 'publish' to 'pending' if user lacks permissions to publish or to resave published posts.	if ( isset($post_data['post_status']) && ('publish' == $post_data['post_status'] && !current_user_can( $ptype->cap->publish_posts )) )		if ( $previous_status != 'publish' || !current_user_can( 'edit_post', $post_id ) )			$post_data['post_status'] = 'pending';	if ( ! isset($post_data['post_status']) )		$post_data['post_status'] = $previous_status;	if (!isset( $post_data['comment_status'] ))		$post_data['comment_status'] = 'closed';	if (!isset( $post_data['ping_status'] ))		$post_data['ping_status'] = 'closed';	foreach ( array('aa', 'mm', 'jj', 'hh', 'mn') as $timeunit ) {		if ( !empty( $post_data['hidden_' . $timeunit] ) && $post_data['hidden_' . $timeunit] != $post_data[$timeunit] ) {			$post_data['edit_date'] = '1';			break;		}	}	if ( !empty( $post_data['edit_date'] ) ) {		$aa = $post_data['aa'];		$mm = $post_data['mm'];		$jj = $post_data['jj'];		$hh = $post_data['hh'];		$mn = $post_data['mn'];		$ss = $post_data['ss'];		$aa = ($aa <= 0 ) ? date('Y') : $aa;		$mm = ($mm <= 0 ) ? date('n') : $mm;		$jj = ($jj > 31 ) ? 31 : $jj;		$jj = ($jj <= 0 ) ? date('j') : $jj;		$hh = ($hh > 23 ) ? $hh -24 : $hh;		$mn = ($mn > 59 ) ? $mn -60 : $mn;		$ss = ($ss > 59 ) ? $ss -60 : $ss;		$post_data['post_date'] = sprintf( "%04d-%02d-%02d %02d:%02d:%02d", $aa, $mm, $jj, $hh, $mn, $ss );		$post_data['post_date_gmt'] = get_gmt_from_date( $post_data['post_date'] );	}	return $post_data;}/** * Update an existing post with values provided in $_POST. * * @since unknown * * @param array $post_data Optional. * @return int Post ID. */function edit_post( $post_data = null ) {	if ( empty($post_data) )		$post_data = &$_POST;	$post_ID = (int) $post_data['post_ID'];	$ptype = get_post_type_object($post_data['post_type']);	if ( !current_user_can( $ptype->cap->edit_post, $post_ID ) ) {		if ( 'page' == $post_data['post_type'] )			wp_die( __('You are not allowed to edit this page.' ));		else			wp_die( __('You are not allowed to edit this post.' ));	}	// Autosave shouldn't save too soon after a real save	if ( 'autosave' == $post_data['action'] ) {		$post =& get_post( $post_ID );		$now = time();		$then = strtotime($post->post_date_gmt . ' +0000');		$delta = AUTOSAVE_INTERVAL / 2;		if ( ($now - $then) < $delta )			return $post_ID;	}	$post_data = _wp_translate_postdata( true, $post_data );	if ( 'autosave' != $post_data['action']  && 'auto-draft' == $post_data['post_status'] )		$post_data['post_status'] = 'draft';	if ( is_wp_error($post_data) )		wp_die( $post_data->get_error_message() );	if ( isset($post_data['visibility']) ) {		switch ( $post_data['visibility'] ) {			case 'public' :				$post_data['post_password'] = '';				break;			case 'password' :				unset( $post_data['sticky'] );				break;			case 'private' :				$post_data['post_status'] = 'private';				$post_data['post_password'] = '';				unset( $post_data['sticky'] );				break;		}	}	// Meta Stuff	if ( isset($post_data['meta']) && $post_data['meta'] ) {		foreach ( $post_data['meta'] as $key => $value )			update_meta( $key, $value['key'], $value['value'] );	}	if ( isset($post_data['deletemeta']) && $post_data['deletemeta'] ) {		foreach ( $post_data['deletemeta'] as $key => $value )			delete_meta( $key );	}	add_meta( $post_ID );	update_post_meta( $post_ID, '_edit_last', $GLOBALS['current_user']->ID );	wp_update_post( $post_data );	// Reunite any orphaned attachments with their parent	if ( !$draft_ids = get_user_option( 'autosave_draft_ids' ) )		$draft_ids = array();	if ( $draft_temp_id = (int) array_search( $post_ID, $draft_ids ) )		_relocate_children( $draft_temp_id, $post_ID );	// Now that we have an ID we can fix any attachment anchor hrefs	_fix_attachment_links( $post_ID );	wp_set_post_lock( $post_ID, $GLOBALS['current_user']->ID );	if ( current_user_can( 'edit_others_posts' ) ) {		if ( !empty($post_data['sticky']) )			stick_post($post_ID);		else			unstick_post($post_ID);	}	return $post_ID;}/** * Process the post data for the bulk editing of posts. * * Updates all bulk edited posts/pages, adding (but not removing) tags and * categories. Skips pages when they would be their own parent or child. * * @since 2.7.0 * * @param array $post_data Optional, the array of post data to process if not provided will use $_POST superglobal. * @return array */function bulk_edit_posts( $post_data = null ) {	global $wpdb;	if ( empty($post_data) )		$post_data = &$_POST;	if ( isset($post_data['post_type']) )		$ptype = get_post_type_object($post_data['post_type']);	else		$ptype = get_post_type_object('post');	if ( !current_user_can( $ptype->cap->edit_posts ) ) {		if ( 'page' == $ptype->name )			wp_die( __('You are not allowed to edit pages.'));		else			wp_die( __('You are not allowed to edit posts.'));	}	if ( -1 == $post_data['_status'] ) {		$post_data['post_status'] = null;		unset($post_data['post_status']);	} else {		$post_data['post_status'] = $post_data['_status'];	}	unset($post_data['_status']);	$post_IDs = array_map( 'intval', (array) $post_data['post'] );	$reset = array( 'post_author', 'post_status', 'post_password', 'post_parent', 'page_template', 'comment_status', 'ping_status', 'keep_private', 'tax_input', 'post_category', 'sticky' );	foreach ( $reset as $field ) {		if ( isset($post_data[$field]) && ( '' == $post_data[$field] || -1 == $post_data[$field] ) )			unset($post_data[$field]);	}	if ( isset($post_data['post_category']) ) {		if ( is_array($post_data['post_category']) && ! empty($post_data['post_category']) )			$new_cats = array_map( 'absint', $post_data['post_category'] );		else			unset($post_data['post_category']);	}	$tax_input = array();	if ( isset($post_data['tax_input'])) {		foreach ( $post_data['tax_input'] as $tax_name => $terms ) {			if ( empty($terms) )				continue;			if ( is_taxonomy_hierarchical( $tax_name ) )				$tax_input[$tax_name] = array_map( 'absint', $terms );			else {				$tax_input[$tax_name] = preg_replace( '/\s*,\s*/', ',', rtrim( trim($terms), ' ,' ) );				$tax_input[$tax_name] = explode(',', $tax_input[$tax_name]);			}		}	}	if ( isset($post_data['post_parent']) && ($parent = (int) $post_data['post_parent']) ) {		$pages = $wpdb->get_results("SELECT ID, post_parent FROM $wpdb->posts WHERE post_type = 'page'");		$children = array();		for ( $i = 0; $i < 50 && $parent > 0; $i++ ) {			$children[] = $parent;			foreach ( $pages as $page ) {				if ( $page->ID == $parent ) {					$parent = $page->post_parent;					break;				}			}		}	}	$updated = $skipped = $locked = array();	foreach ( $post_IDs as $post_ID ) {		$post_type_object = get_post_type_object( get_post_type( $post_ID ) );		if ( !isset( $post_type_object ) || ( isset($children) && in_array($post_ID, $children) ) || !current_user_can( $post_type_object->cap->edit_post, $post_ID ) ) {			$skipped[] = $post_ID;			continue;		}		if ( wp_check_post_lock( $post_ID ) ) {			$locked[] = $post_ID;			continue;		}		$tax_names = get_object_taxonomies( get_post($post_ID) );		foreach ( $tax_names as $tax_name ) {			$taxonomy_obj = get_taxonomy($tax_name);			if (  isset( $tax_input[$tax_name]) && current_user_can( $taxonomy_obj->cap->assign_terms ) )				$new_terms = $tax_input[$tax_name];			else				$new_terms = array();			if ( $taxonomy_obj->hierarchical )				$current_terms = (array) wp_get_object_terms( $post_ID, $tax_name, array('fields' => 'ids') );			else				$current_terms = (array) wp_get_object_terms( $post_ID, $tax_name, array('fields' => 'names') );			$post_data['tax_input'][$tax_name] = array_merge( $current_terms, $new_terms );		}		if ( isset($new_cats) && in_array( 'category', $tax_names ) ) {			$cats = (array) wp_get_post_categories($post_ID);			$post_data['post_category'] = array_unique( array_merge($cats, $new_cats) );			unset( $post_data['tax_input']['category'] );		}		$post_data['ID'] = $post_ID;		$updated[] = wp_update_post( $post_data );		if ( isset( $post_data['sticky'] ) && current_user_can( 'edit_others_posts' ) ) {			if ( 'sticky' == $post_data['sticky'] )				stick_post( $post_ID );			else				unstick_post( $post_ID );		}	}	return array( 'updated' => $updated, 'skipped' => $skipped, 'locked' => $locked );}/** * Default post information to use when populating the "Write Post" form. * * @since unknown * *@param string A post type string, defaults to 'post'. * @return object stdClass object containing all the default post data as attributes */function get_default_post_to_edit( $post_type = 'post', $create_in_db = false ) {	global $wpdb;	$post_title = '';	if ( !empty( $_REQUEST['post_title'] ) )		$post_title = esc_html( stripslashes( $_REQUEST['post_title'] ));	$post_content = '';	if ( !empty( $_REQUEST['content'] ) )		$post_content = esc_html( stripslashes( $_REQUEST['content'] ));	$post_excerpt = '';	if ( !empty( $_REQUEST['excerpt'] ) )		$post_excerpt = esc_html( stripslashes( $_REQUEST['excerpt'] ));	if ( $create_in_db ) {		// Cleanup old auto-drafts more than 7 days old		$old_posts = $wpdb->get_col( "SELECT ID FROM $wpdb->posts WHERE post_status = 'auto-draft' AND DATE_SUB( NOW(), INTERVAL 7 DAY ) > post_date" );		foreach ( (array) $old_posts as $delete )			wp_delete_post( $delete, true ); // Force delete		$post = get_post( wp_insert_post( array( 'post_title' => __( 'Auto Draft' ), 'post_type' => $post_type, 'post_status' => 'auto-draft' ) ) );	} else {		$post->ID = 0;		$post->post_author = '';		$post->post_date = '';		$post->post_date_gmt = '';		$post->post_password = '';		$post->post_type = $post_type;		$post->post_status = 'draft';		$post->to_ping = '';		$post->pinged = '';		$post->comment_status = get_option( 'default_comment_status' );		$post->ping_status = get_option( 'default_ping_status' );		$post->post_pingback = get_option( 'default_pingback_flag' );		$post->post_category = get_option( 'default_category' );		$post->page_template = 'default';		$post->post_parent = 0;		$post->menu_order = 0;	}	$post->post_content = apply_filters( 'default_content', $post_content, $post );	$post->post_title   = apply_filters( 'default_title',   $post_title, $post   );	$post->post_excerpt = apply_filters( 'default_excerpt', $post_excerpt, $post );	$post->post_name = '';	return $post;}/** * Get the default page information to use. * * @since 2.5.0 * * @return object stdClass object containing all the default post data as attributes */function get_default_page_to_edit() {	$page = get_default_post_to_edit();	$page->post_type = 'page';	return $page;}/** * Get an existing post and format it for editing. * * @since unknown * * @param unknown_type $id * @return unknown */function get_post_to_edit( $id ) {	$post = get_post( $id, OBJECT, 'edit' );	if ( $post->post_type == 'page' )		$post->page_template = get_post_meta( $id, '_wp_page_template', true );	return $post;}/** * Determine if a post exists based on title, content, and date * * @since unknown * * @param string $title Post title * @param string $content Optional post content * @param string $date Optional post date * @return int Post ID if post exists, 0 otherwise. */function post_exists($title, $content = '', $date = '') {	global $wpdb;	$post_title = stripslashes( sanitize_post_field( 'post_title', $title, 0, 'db' ) );	$post_content = stripslashes( sanitize_post_field( 'post_content', $content, 0, 'db' ) );	$post_date = stripslashes( sanitize_post_field( 'post_date', $date, 0, 'db' ) );	$query = "SELECT ID FROM $wpdb->posts WHERE 1=1";	$args = array();	if ( !empty ( $date ) ) {		$query .= ' AND post_date = %s';		$args[] = $post_date;	}	if ( !empty ( $title ) ) {		$query .= ' AND post_title = %s';		$args[] = $post_title;	}	if ( !empty ( $content ) ) {		$query .= 'AND post_content = %s';		$args[] = $post_content;	}	if ( !empty ( $args ) )		return $wpdb->get_var( $wpdb->prepare($query, $args) );	return 0;}/** * Creates a new post from the "Write Post" form using $_POST information. * * @since unknown * * @return unknown */function wp_write_post() {	global $user_ID;	if ( isset($_POST['post_type']) )		$ptype = get_post_type_object($_POST['post_type']);	else		$ptype = get_post_type_object('post');	if ( !current_user_can( $ptype->cap->edit_posts ) ) {		if ( 'page' == $ptype->name )			return new WP_Error( 'edit_pages', __( 'You are not allowed to create pages on this site.' ) );		else			return new WP_Error( 'edit_posts', __( 'You are not allowed to create posts or drafts on this site.' ) );	}	// Check for autosave collisions	// Does this need to be updated? ~ Mark	$temp_id = false;	if ( isset($_POST['temp_ID']) ) {		$temp_id = (int) $_POST['temp_ID'];		if ( !$draft_ids = get_user_option( 'autosave_draft_ids' ) )			$draft_ids = array();		foreach ( $draft_ids as $temp => $real )			if ( time() + $temp > 86400 ) // 1 day: $temp is equal to -1 * time( then )				unset($draft_ids[$temp]);		if ( isset($draft_ids[$temp_id]) ) { // Edit, don't write			$_POST['post_ID'] = $draft_ids[$temp_id];			unset($_POST['temp_ID']);			update_user_option( $user_ID, 'autosave_draft_ids', $draft_ids );			return edit_post();		}	}	$translated = _wp_translate_postdata( false );	if ( is_wp_error($translated) )		return $translated;	if ( isset($_POST['visibility']) ) {		switch ( $_POST['visibility'] ) {			case 'public' :				$_POST['post_password'] = '';				break;			case 'password' :				unset( $_POST['sticky'] );				break;			case 'private' :				$_POST['post_status'] = 'private';				$_POST['post_password'] = '';				unset( $_POST['sticky'] );				break;		}	}	// Create the post.	$post_ID = wp_insert_post( $_POST );	if ( is_wp_error( $post_ID ) )		return $post_ID;	if ( empty($post_ID) )		return 0;	add_meta( $post_ID );	add_post_meta( $post_ID, '_edit_last', $GLOBALS['current_user']->ID );	// Reunite any orphaned attachments with their parent	// Does this need to be udpated? ~ Mark	if ( !$draft_ids = get_user_option( 'autosave_draft_ids' ) )		$draft_ids = array();	if ( $draft_temp_id = (int) array_search( $post_ID, $draft_ids ) )		_relocate_children( $draft_temp_id, $post_ID );	if ( $temp_id && $temp_id != $draft_temp_id )		_relocate_children( $temp_id, $post_ID );	// Update autosave collision detection	if ( $temp_id ) {		$draft_ids[$temp_id] = $post_ID;		update_user_option( $user_ID, 'autosave_draft_ids', $draft_ids );	}	// Now that we have an ID we can fix any attachment anchor hrefs	_fix_attachment_links( $post_ID );	wp_set_post_lock( $post_ID, $GLOBALS['current_user']->ID );	return $post_ID;}/** * Calls wp_write_post() and handles the errors. * * @since unknown * * @return unknown */function write_post() {	$result = wp_write_post();	if ( is_wp_error( $result ) )		wp_die( $result->get_error_message() );	else		return $result;}//// Post Meta///** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $post_ID * @return unknown */function add_meta( $post_ID ) {	global $wpdb;	$post_ID = (int) $post_ID;	$protected = array( '_wp_attached_file', '_wp_attachment_metadata', '_wp_old_slug', '_wp_page_template' );	$metakeyselect = isset($_POST['metakeyselect']) ? stripslashes( trim( $_POST['metakeyselect'] ) ) : '';	$metakeyinput = isset($_POST['metakeyinput']) ? stripslashes( trim( $_POST['metakeyinput'] ) ) : '';	$metavalue = isset($_POST['metavalue']) ? maybe_serialize( stripslashes_deep( $_POST['metavalue'] ) ) : '';	if ( is_string($metavalue) )		$metavalue = trim( $metavalue );	if ( ('0' === $metavalue || !empty ( $metavalue ) ) && ((('#NONE#' != $metakeyselect) && !empty ( $metakeyselect) ) || !empty ( $metakeyinput) ) ) {		// We have a key/value pair. If both the select and the		// input for the key have data, the input takes precedence: 		if ('#NONE#' != $metakeyselect)			$metakey = $metakeyselect;		if ( $metakeyinput)			$metakey = $metakeyinput; // default		if ( in_array($metakey, $protected) )			return false;		wp_cache_delete($post_ID, 'post_meta');		$wpdb->insert( $wpdb->postmeta, array( 'post_id' => $post_ID, 'meta_key' => $metakey, 'meta_value' => $metavalue ) );		do_action( 'added_postmeta', $wpdb->insert_id, $post_ID, $metakey, $metavalue );		return $wpdb->insert_id;	}	return false;} // add_meta/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $mid * @return unknown */function delete_meta( $mid ) {	global $wpdb;	$mid = (int) $mid;	$post_id = $wpdb->get_var( $wpdb->prepare("SELECT post_id FROM $wpdb->postmeta WHERE meta_id = %d", $mid) );	do_action( 'delete_postmeta', $mid );	wp_cache_delete($post_id, 'post_meta');	$rval = $wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->postmeta WHERE meta_id = %d", $mid) );	do_action( 'deleted_postmeta', $mid );	return $rval;}/** * Get a list of previously defined keys. * * @since unknown * * @return unknown */function get_meta_keys() {	global $wpdb;	$keys = $wpdb->get_col( "			SELECT meta_key			FROM $wpdb->postmeta			GROUP BY meta_key			ORDER BY meta_key" );	return $keys;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $mid * @return unknown */function get_post_meta_by_id( $mid ) {	global $wpdb;	$mid = (int) $mid;	$meta = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->postmeta WHERE meta_id = %d", $mid) );	if ( is_serialized_string( $meta->meta_value ) )		$meta->meta_value = maybe_unserialize( $meta->meta_value );	return $meta;}/** * {@internal Missing Short Description}} * * Some postmeta stuff. * * @since unknown * * @param unknown_type $postid * @return unknown */function has_meta( $postid ) {	global $wpdb;	return $wpdb->get_results( $wpdb->prepare("SELECT meta_key, meta_value, meta_id, post_id			FROM $wpdb->postmeta WHERE post_id = %d			ORDER BY meta_key,meta_id", $postid), ARRAY_A );}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $meta_id * @param unknown_type $meta_key Expect Slashed * @param unknown_type $meta_value Expect Slashed * @return unknown */function update_meta( $meta_id, $meta_key, $meta_value ) {	global $wpdb;	$protected = array( '_wp_attached_file', '_wp_attachment_metadata', '_wp_old_slug', '_wp_page_template' );	$meta_key = stripslashes($meta_key);	if ( in_array($meta_key, $protected) )		return false;	if ( '' === trim( $meta_value ) )		return false;	$post_id = $wpdb->get_var( $wpdb->prepare("SELECT post_id FROM $wpdb->postmeta WHERE meta_id = %d", $meta_id) );	$meta_value = maybe_serialize( stripslashes_deep( $meta_value ) );	$meta_id = (int) $meta_id;	$data  = compact( 'meta_key', 'meta_value' );	$where = compact( 'meta_id' );	do_action( 'update_postmeta', $meta_id, $post_id, $meta_key, $meta_value );	$rval = $wpdb->update( $wpdb->postmeta, $data, $where );	wp_cache_delete($post_id, 'post_meta');	do_action( 'updated_postmeta', $meta_id, $post_id, $meta_key, $meta_value );	return $rval;}//// Private///** * Replace hrefs of attachment anchors with up-to-date permalinks. * * @since unknown * @access private * * @param unknown_type $post_ID * @return unknown */function _fix_attachment_links( $post_ID ) {	global $_fix_attachment_link_id;	$post = & get_post( $post_ID, ARRAY_A );	$search = "#<a[^>]+rel=('|\")[^'\"]*attachment[^>]*>#ie";	// See if we have any rel="attachment" links	if ( 0 == preg_match_all( $search, $post['post_content'], $anchor_matches, PREG_PATTERN_ORDER ) )		return;	$i = 0;	$search = "#[\s]+rel=(\"|')(.*?)wp-att-(\d+)\\1#i";	foreach ( $anchor_matches[0] as $anchor ) {		if ( 0 == preg_match( $search, $anchor, $id_matches ) )			continue;		$id = (int) $id_matches[3];		// While we have the attachment ID, let's adopt any orphans.		$attachment = & get_post( $id, ARRAY_A );		if ( ! empty( $attachment) && ! is_object( get_post( $attachment['post_parent'] ) ) ) {			$attachment['post_parent'] = $post_ID;			// Escape data pulled from DB.			$attachment = add_magic_quotes( $attachment );			wp_update_post( $attachment );		}		$post_search[$i] = $anchor;		 $_fix_attachment_link_id = $id;		$post_replace[$i] = preg_replace_callback( "#href=(\"|')[^'\"]*\\1#", '_fix_attachment_links_replace_cb', $anchor );		++$i;	}	$post['post_content'] = str_replace( $post_search, $post_replace, $post['post_content'] );	// Escape data pulled from DB.	$post = add_magic_quotes( $post);	return wp_update_post( $post);}function _fix_attachment_links_replace_cb($match) {        global $_fix_attachment_link_id;        return stripslashes( 'href='.$match[1] ).get_attachment_link( $_fix_attachment_link_id ).stripslashes( $match[1] );}/** * Move child posts to a new parent. * * @since unknown * @access private * * @param unknown_type $old_ID * @param unknown_type $new_ID * @return unknown */function _relocate_children( $old_ID, $new_ID ) {	global $wpdb;	$old_ID = (int) $old_ID;	$new_ID = (int) $new_ID;	$children = $wpdb->get_col( $wpdb->prepare("		SELECT post_id		FROM $wpdb->postmeta		WHERE meta_key = '_wp_attachment_temp_parent'		AND meta_value = %d", $old_ID) );	foreach ( $children as $child_id ) {		$wpdb->update($wpdb->posts, array('post_parent' => $new_ID), array('ID' => $child_id) );		delete_post_meta($child_id, '_wp_attachment_temp_parent');	}}/** * Get all the possible statuses for a post_type * * @since 2.5.0 * * @param string $type The post_type you want the statuses for * @return array As array of all the statuses for the supplied post type */function get_available_post_statuses($type = 'post') {	$stati = wp_count_posts($type);	return array_keys(get_object_vars($stati));}/** * Run the wp query to fetch the posts for listing on the edit posts page * * @since 2.5.0 * * @param array|bool $q Array of query variables to use to build the query or false to use $_GET superglobal. * @return array */function wp_edit_posts_query( $q = false ) {	if ( false === $q )		$q = $_GET;	$q['m'] = isset($q['m']) ? (int) $q['m'] : 0;	$q['cat'] = isset($q['cat']) ? (int) $q['cat'] : 0;	$post_stati  = get_post_stati();	if ( isset($q['post_type']) && in_array( $q['post_type'], get_post_types() ) )		$post_type = $q['post_type'];	else		$post_type = 'post';	$avail_post_stati = get_available_post_statuses($post_type);	if ( isset($q['post_status']) && in_array( $q['post_status'], $post_stati ) ) {		$post_status = $q['post_status'];		$perm = 'readable';	}	if ( isset($q['post_status']) && 'pending' === $q['post_status'] ) {		$order = 'ASC';		$orderby = 'modified';	} elseif ( isset($q['post_status']) && 'draft' === $q['post_status'] ) {		$order = 'DESC';		$orderby = 'modified';	} else {		$order = 'DESC';		$orderby = 'date';	}	$per_page = 'edit_' . $post_type . '_per_page';	$posts_per_page = (int) get_user_option( $per_page );	if ( empty( $posts_per_page ) || $posts_per_page < 1 )		$posts_per_page = 15;	$posts_per_page = apply_filters( $per_page, $posts_per_page );	$query = compact('post_type', 'post_status', 'perm', 'order', 'orderby', 'posts_per_page');	// Hierarchical types require special args.	if ( is_post_type_hierarchical( $post_type ) ) {		$query['orderby'] = 'menu_order title';		$query['order'] = 'asc';		$query['posts_per_page'] = -1;		$query['posts_per_archive_page'] = -1;	}	wp( $query );	return $avail_post_stati;}/** * Get default post mime types * * @since 2.9.0 * * @return array */function get_post_mime_types() {	$post_mime_types = array(	//	array( adj, noun )		'image' => array(__('Images'), __('Manage Images'), _n_noop('Image <span class="count">(%s)</span>', 'Images <span class="count">(%s)</span>')),		'audio' => array(__('Audio'), __('Manage Audio'), _n_noop('Audio <span class="count">(%s)</span>', 'Audio <span class="count">(%s)</span>')),		'video' => array(__('Video'), __('Manage Video'), _n_noop('Video <span class="count">(%s)</span>', 'Video <span class="count">(%s)</span>')),	);	return apply_filters('post_mime_types', $post_mime_types);}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $type * @return unknown */function get_available_post_mime_types($type = 'attachment') {	global $wpdb;	$types = $wpdb->get_col($wpdb->prepare("SELECT DISTINCT post_mime_type FROM $wpdb->posts WHERE post_type = %s", $type));	return $types;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $q * @return unknown */function wp_edit_attachments_query( $q = false ) {	if ( false === $q )		$q = $_GET;	$q['m']   = isset( $q['m'] ) ? (int) $q['m'] : 0;	$q['cat'] = isset( $q['cat'] ) ? (int) $q['cat'] : 0;	$q['post_type'] = 'attachment';	$q['post_status'] = isset( $q['status'] ) && 'trash' == $q['status'] ? 'trash' : 'inherit';	$media_per_page = (int) get_user_option( 'upload_per_page' );	if ( empty( $media_per_page ) || $media_per_page < 1 )		$media_per_page = 20;	$q['posts_per_page'] = apply_filters( 'upload_per_page', $media_per_page );	$post_mime_types = get_post_mime_types();	$avail_post_mime_types = get_available_post_mime_types('attachment');	if ( isset($q['post_mime_type']) && !array_intersect( (array) $q['post_mime_type'], array_keys($post_mime_types) ) )		unset($q['post_mime_type']);	wp($q);	return array($post_mime_types, $avail_post_mime_types);}/** * {@internal Missing Short Description}} * * @uses get_user_option() * @since unknown * * @param unknown_type $id * @param unknown_type $page * @return unknown */function postbox_classes( $id, $page ) {	if ( isset( $_GET['edit'] ) && $_GET['edit'] == $id )		return '';	if ( $closed = get_user_option('closedpostboxes_'.$page ) ) {		if ( !is_array( $closed ) ) {			return '';		}		return in_array( $id, $closed )? 'closed' : '';	} else {		return '';	}}/** * {@internal Missing Short Description}} * * @since unknown * * @param int|object $id    Post ID or post object. * @param string $title (optional) Title * @param string $name (optional) Name * @return array With two entries of type string */function get_sample_permalink($id, $title = null, $name = null) {	$post = &get_post($id);	if ( !$post->ID )		return array('', '');	$ptype = get_post_type_object($post->post_type);	$original_status = $post->post_status;	$original_date = $post->post_date;	$original_name = $post->post_name;	// Hack: get_permalink would return ugly permalink for	// drafts, so we will fake, that our post is published	if ( in_array($post->post_status, array('draft', 'pending')) ) {		$post->post_status = 'publish';		$post->post_name = sanitize_title($post->post_name ? $post->post_name : $post->post_title, $post->ID);	}	// If the user wants to set a new name -- override the current one	// Note: if empty name is supplied -- use the title instead, see #6072	if ( !is_null($name) )		$post->post_name = sanitize_title($name ? $name : $title, $post->ID);	$post->post_name = wp_unique_post_slug($post->post_name, $post->ID, $post->post_status, $post->post_type, $post->post_parent);	$post->filter = 'sample';	$permalink = get_permalink($post, true);	// Replace custom post_type Token with generic pagename token for ease of use.	$permalink = str_replace("%$post->post_type%", '%pagename%', $permalink);	// Handle page hierarchy	if ( $ptype->hierarchical ) {		$uri = get_page_uri($post);		$uri = untrailingslashit($uri);		$uri = strrev( stristr( strrev( $uri ), '/' ) );		$uri = untrailingslashit($uri);		if ( !empty($uri) )			$uri .= '/';		$permalink = str_replace('%pagename%', "${uri}%pagename%", $permalink);	}	$permalink = array($permalink, apply_filters('editable_slug', $post->post_name));	$post->post_status = $original_status;	$post->post_date = $original_date;	$post->post_name = $original_name;	unset($post->filter);	return $permalink;}/** * sample permalink html * * intended to be used for the inplace editor of the permalink post slug on in the post (and page?) editor. * * @since unknown * * @param int|object $id Post ID or post object. * @param string $new_title (optional) New title * @param string $new_slug (optional) New slug * @return string intended to be used for the inplace editor of the permalink post slug on in the post (and page?) editor. */function get_sample_permalink_html( $id, $new_title = null, $new_slug = null ) {	global $wpdb;	$post = &get_post($id);	list($permalink, $post_name) = get_sample_permalink($post->ID, $new_title, $new_slug);	if ( 'publish' == $post->post_status ) {		$ptype = get_post_type_object($post->post_type);		$view_post = $ptype->labels->view_item;		$title = __('Click to edit this part of the permalink');	} else {		$title = __('Temporary permalink. Click to edit this part.');	}	if ( false === strpos($permalink, '%postname%') && false === strpos($permalink, '%pagename%') ) {		$return = '<strong>' . __('Permalink:') . "</strong>\n" . '<span id="sample-permalink">' . $permalink . "</span>\n";		if ( current_user_can( 'manage_options' ) && !( 'page' == get_option('show_on_front') && $id == get_option('page_on_front') ) )			$return .= '<span id="change-permalinks"><a href="options-permalink.php" class="button" target="_blank">' . __('Change Permalinks') . "</a></span>\n";		if ( isset($view_post) )			$return .= "<span id='view-post-btn'><a href='$permalink' class='button' target='_blank'>$view_post</a></span>\n";		$return = apply_filters('get_sample_permalink_html', $return, $id, $new_title, $new_slug);		return $return;	}	if ( function_exists('mb_strlen') ) {		if ( mb_strlen($post_name) > 30 ) {			$post_name_abridged = mb_substr($post_name, 0, 14). '&hellip;' . mb_substr($post_name, -14);		} else {			$post_name_abridged = $post_name;		}	} else {		if ( strlen($post_name) > 30 ) {			$post_name_abridged = substr($post_name, 0, 14). '&hellip;' . substr($post_name, -14);		} else {			$post_name_abridged = $post_name;		}	}	$post_name_html = '<span id="editable-post-name" title="' . $title . '">' . $post_name_abridged . '</span>';	$display_link = str_replace(array('%pagename%','%postname%'), $post_name_html, $permalink);	$view_link = str_replace(array('%pagename%','%postname%'), $post_name, $permalink);	$return =  '<strong>' . __('Permalink:') . "</strong>\n";	$return .= '<span id="sample-permalink">' . $display_link . "</span>\n";	$return .= '&lrm;'; // Fix bi-directional text display defect in RTL languages.	$return .= '<span id="edit-slug-buttons"><a href="#post_name" class="edit-slug button hide-if-no-js" onclick="editPermalink(' . $id . '); return false;">' . __('Edit') . "</a></span>\n";	$return .= '<span id="editable-post-name-full">' . $post_name . "</span>\n";	if ( isset($view_post) )		$return .= "<span id='view-post-btn'><a href='$view_link' class='button' target='_blank'>$view_post</a></span>\n";	$return = apply_filters('get_sample_permalink_html', $return, $id, $new_title, $new_slug);	return $return;}/** * Output HTML for the post thumbnail meta-box. * * @since 2.9.0 * * @param int $thumbnail_id ID of the attachment used for thumbnail * @return string html */function _wp_post_thumbnail_html( $thumbnail_id = NULL ) {	global $content_width, $_wp_additional_image_sizes, $post_ID;	$set_thumbnail_link = '<p class="hide-if-no-js"><a title="' . esc_attr__( 'Set featured image' ) . '" href="' . esc_url( get_upload_iframe_src('image') ) . '" id="set-post-thumbnail" class="thickbox">%s</a></p>';	$content = sprintf($set_thumbnail_link, esc_html__( 'Set featured image' ));	if ( $thumbnail_id && get_post( $thumbnail_id ) ) {		$old_content_width = $content_width;		$content_width = 266;		if ( !isset( $_wp_additional_image_sizes['post-thumbnail'] ) )			$thumbnail_html = wp_get_attachment_image( $thumbnail_id, array( $content_width, $content_width ) );		else			$thumbnail_html = wp_get_attachment_image( $thumbnail_id, 'post-thumbnail' );		if ( !empty( $thumbnail_html ) ) {			$ajax_nonce = wp_create_nonce( "set_post_thumbnail-$post_ID" );			$content = sprintf($set_thumbnail_link, $thumbnail_html);			$content .= '<p class="hide-if-no-js"><a href="#" id="remove-post-thumbnail" onclick="WPRemoveThumbnail(\'' . $ajax_nonce . '\');return false;">' . esc_html__( 'Remove featured image' ) . '</a></p>';		}		$content_width = $old_content_width;	}	return apply_filters( 'admin_post_thumbnail_html', $content );}/** * Check to see if the post is currently being edited by another user. * * @since 2.5.0 * * @param int $post_id ID of the post to check for editing * @return bool|int False: not locked or locked by current user. Int: user ID of user with lock. */function wp_check_post_lock( $post_id ) {	global $current_user;	if ( !$post = get_post( $post_id ) )		return false;	$lock = get_post_meta( $post->ID, '_edit_lock', true );	$last = get_post_meta( $post->ID, '_edit_last', true );	$time_window = apply_filters( 'wp_check_post_lock_window', AUTOSAVE_INTERVAL * 2 );	if ( $lock && $lock > time() - $time_window && $last != $current_user->ID )		return $last;	return false;}/** * Mark the post as currently being edited by the current user * * @since 2.5.0 * * @param int $post_id ID of the post to being edited * @return bool Returns false if the post doesn't exist of there is no current user */function wp_set_post_lock( $post_id ) {	global $current_user;	if ( !$post = get_post( $post_id ) )		return false;	if ( !$current_user || !$current_user->ID )		return false;	$now = time();	update_post_meta( $post->ID, '_edit_lock', $now );}/** * Outputs the notice message to say that someone else is editing this post at the moment. * * @since 2.8.5 * @return none */function _admin_notice_post_locked() {	global $post;	$last_user = get_userdata( get_post_meta( $post->ID, '_edit_last', true ) );	$last_user_name = $last_user ? $last_user->display_name : __('Somebody');	switch ($post->post_type) {		case 'post':			$message = __( 'Warning: %s is currently editing this post' );			break;		case 'page':			$message = __( 'Warning: %s is currently editing this page' );			break;		default:			$message = __( 'Warning: %s is currently editing this.' );	}	$message = sprintf( $message, esc_html( $last_user_name ) );	echo "<div class='error'><p>$message</p></div>";}/** * Creates autosave data for the specified post from $_POST data. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @uses _wp_translate_postdata() * @uses _wp_post_revision_fields() * * @return unknown */function wp_create_post_autosave( $post_id ) {	$translated = _wp_translate_postdata( true );	if ( is_wp_error( $translated ) )		return $translated;	// Only store one autosave.  If there is already an autosave, overwrite it.	if ( $old_autosave = wp_get_post_autosave( $post_id ) ) {		$new_autosave = _wp_post_revision_fields( $_POST, true );		$new_autosave['ID'] = $old_autosave->ID;		$current_user = wp_get_current_user();		$new_autosave['post_author'] = $current_user->ID;		return wp_update_post( $new_autosave );	}	// _wp_put_post_revision() expects unescaped.	$_POST = stripslashes_deep($_POST);	// Otherwise create the new autosave as a special post revision	return _wp_put_post_revision( $_POST, true );}/** * Save draft or manually autosave for showing preview. * * @package WordPress * @since 2.7.0 * * @uses wp_write_post() * @uses edit_post() * @uses get_post() * @uses current_user_can() * @uses wp_create_post_autosave() * * @return str URL to redirect to show the preview */function post_preview() {	$post_ID = (int) $_POST['post_ID'];	$status = get_post_status( $post_ID );	if ( 'auto-draft' == $status )		wp_die( __('Preview not available. Please save as a draft first.') );	if ( isset($_POST['catslist']) )		$_POST['post_category'] = explode(",", $_POST['catslist']);	if ( isset($_POST['tags_input']) )		$_POST['tags_input'] = explode(",", $_POST['tags_input']);	if ( $_POST['post_type'] == 'page' || empty($_POST['post_category']) )		unset($_POST['post_category']);	$_POST['ID'] = $post_ID;	$post = get_post($post_ID);	if ( 'page' == $post->post_type ) {		if ( !current_user_can('edit_page', $post_ID) )			wp_die(__('You are not allowed to edit this page.'));	} else {		if ( !current_user_can('edit_post', $post_ID) )			wp_die(__('You are not allowed to edit this post.'));	}	if ( 'draft' == $post->post_status ) {		$id = edit_post();	} else { // Non drafts are not overwritten.  The autosave is stored in a special post revision.		$id = wp_create_post_autosave( $post->ID );		if ( ! is_wp_error($id) )			$id = $post->ID;	}	if ( is_wp_error($id) )		wp_die( $id->get_error_message() );	if ( $_POST['post_status'] == 'draft'  ) {		$url = add_query_arg( 'preview', 'true', get_permalink($id) );	} else {		$nonce = wp_create_nonce('post_preview_' . $id);		$url = add_query_arg( array( 'preview' => 'true', 'preview_id' => $id, 'preview_nonce' => $nonce ), get_permalink($id) );	}	return $url;}/** * Adds the TinyMCE editor used on the Write and Edit screens. * * @package WordPress * @since 2.7.0 * * TinyMCE is loaded separately from other Javascript by using wp-tinymce.php. It outputs concatenated * and optionaly pre-compressed version of the core and all default plugins. Additional plugins are loaded * directly by TinyMCE using non-blocking method. Custom plugins can be refreshed by adding a query string * to the URL when queueing them with the mce_external_plugins filter. * * @param bool $teeny optional Output a trimmed down version used in Press This. * @param mixed $settings optional An array that can add to or overwrite the default TinyMCE settings. */function wp_tiny_mce( $teeny = false, $settings = false ) {	global $concatenate_scripts, $compress_scripts, $tinymce_version, $editor_styles;	if ( ! user_can_richedit() )		return;	$baseurl = includes_url('js/tinymce');	$mce_locale = ( '' == get_locale() ) ? 'en' : strtolower( substr(get_locale(), 0, 2) ); // only ISO 639-1	/*	The following filter allows localization scripts to change the languages displayed in the spellchecker's drop-down menu.	By default it uses Google's spellchecker API, but can be configured to use PSpell/ASpell if installed on the server.	The + sign marks the default language. More information:	http://wiki.moxiecode.com/index.php/TinyMCE:Plugins/spellchecker	*/	$mce_spellchecker_languages = apply_filters('mce_spellchecker_languages', '+English=en,Danish=da,Dutch=nl,Finnish=fi,French=fr,German=de,Italian=it,Polish=pl,Portuguese=pt,Spanish=es,Swedish=sv');	if ( $teeny ) {		$plugins = apply_filters( 'teeny_mce_plugins', array('safari', 'inlinepopups', 'media', 'fullscreen', 'wordpress') );		$ext_plugins = '';	} else {		$plugins = array( 'safari', 'inlinepopups', 'spellchecker', 'paste', 'wordpress', 'media', 'fullscreen', 'wpeditimage', 'wpgallery', 'tabfocus' );		/*		The following filter takes an associative array of external plugins for TinyMCE in the form 'plugin_name' => 'url'.		It adds the plugin's name to TinyMCE's plugins init and the call to PluginManager to load the plugin.		The url should be absolute and should include the js file name to be loaded. Example:		array( 'myplugin' => 'http://my-site.com/wp-content/plugins/myfolder/mce_plugin.js' )		If the plugin uses a button, it should be added with one of the "$mce_buttons" filters.		*/		$mce_external_plugins = apply_filters('mce_external_plugins', array());		$ext_plugins = '';		if ( ! empty($mce_external_plugins) ) {			/*			The following filter loads external language files for TinyMCE plugins.			It takes an associative array 'plugin_name' => 'path', where path is the			include path to the file. The language file should follow the same format as			/tinymce/langs/wp-langs.php and should define a variable $strings that			holds all translated strings.			When this filter is not used, the function will try to load {mce_locale}.js.			If that is not found, en.js will be tried next.			*/			$mce_external_languages = apply_filters('mce_external_languages', array());			$loaded_langs = array();			$strings = '';			if ( ! empty($mce_external_languages) ) {				foreach ( $mce_external_languages as $name => $path ) {					if ( @is_file($path) && @is_readable($path) ) {						include_once($path);						$ext_plugins .= $strings . "\n";						$loaded_langs[] = $name;					}				}			}			foreach ( $mce_external_plugins as $name => $url ) {				if ( is_ssl() ) $url = str_replace('http://', 'https://', $url);				$plugins[] = '-' . $name;				$plugurl = dirname($url);				$strings = $str1 = $str2 = '';				if ( ! in_array($name, $loaded_langs) ) {					$path = str_replace( WP_PLUGIN_URL, '', $plugurl );					$path = WP_PLUGIN_DIR . $path . '/langs/';					if ( function_exists('realpath') )						$path = trailingslashit( realpath($path) );					if ( @is_file($path . $mce_locale . '.js') )						$strings .= @file_get_contents($path . $mce_locale . '.js') . "\n";					if ( @is_file($path . $mce_locale . '_dlg.js') )						$strings .= @file_get_contents($path . $mce_locale . '_dlg.js') . "\n";					if ( 'en' != $mce_locale && empty($strings) ) {						if ( @is_file($path . 'en.js') ) {							$str1 = @file_get_contents($path . 'en.js');							$strings .= preg_replace( '/([\'"])en\./', '$1' . $mce_locale . '.', $str1, 1 ) . "\n";						}						if ( @is_file($path . 'en_dlg.js') ) {							$str2 = @file_get_contents($path . 'en_dlg.js');							$strings .= preg_replace( '/([\'"])en\./', '$1' . $mce_locale . '.', $str2, 1 ) . "\n";						}					}					if ( ! empty($strings) )						$ext_plugins .= "\n" . $strings . "\n";				}				$ext_plugins .= 'tinyMCEPreInit.load_ext("' . $plugurl . '", "' . $mce_locale . '");' . "\n";				$ext_plugins .= 'tinymce.PluginManager.load("' . $name . '", "' . $url . '");' . "\n";			}		}	}	$plugins = implode($plugins, ',');	if ( $teeny ) {		$mce_buttons = apply_filters( 'teeny_mce_buttons', array('bold, italic, underline, blockquote, separator, strikethrough, bullist, numlist,justifyleft, justifycenter, justifyright, undo, redo, link, unlink, fullscreen') );		$mce_buttons = implode($mce_buttons, ',');		$mce_buttons_2 = $mce_buttons_3 = $mce_buttons_4 = '';	} else {		$mce_buttons = apply_filters('mce_buttons', array('bold', 'italic', 'strikethrough', '|', 'bullist', 'numlist', 'blockquote', '|', 'justifyleft', 'justifycenter', 'justifyright', '|', 'link', 'unlink', 'wp_more', '|', 'spellchecker', 'fullscreen', 'wp_adv' ));		$mce_buttons = implode($mce_buttons, ',');		$mce_buttons_2 = array('formatselect', 'underline', 'justifyfull', 'forecolor', '|', 'pastetext', 'pasteword', 'removeformat', '|', 'media', 'charmap', '|', 'outdent', 'indent', '|', 'undo', 'redo', 'wp_help' );		if ( is_multisite() )			unset( $mce_buttons_2[ array_search( 'media', $mce_buttons_2 ) ] );		$mce_buttons_2 = apply_filters('mce_buttons_2', $mce_buttons_2);		$mce_buttons_2 = implode($mce_buttons_2, ',');		$mce_buttons_3 = apply_filters('mce_buttons_3', array());		$mce_buttons_3 = implode($mce_buttons_3, ',');		$mce_buttons_4 = apply_filters('mce_buttons_4', array());		$mce_buttons_4 = implode($mce_buttons_4, ',');	}	$no_captions = (bool) apply_filters( 'disable_captions', '' );	// TinyMCE init settings	$initArray = array (		'mode' => 'specific_textareas',		'editor_selector' => 'theEditor',		'width' => '100%',		'theme' => 'advanced',		'skin' => 'wp_theme',		'theme_advanced_buttons1' => $mce_buttons,		'theme_advanced_buttons2' => $mce_buttons_2,		'theme_advanced_buttons3' => $mce_buttons_3,		'theme_advanced_buttons4' => $mce_buttons_4,		'language' => $mce_locale,		'spellchecker_languages' => $mce_spellchecker_languages,		'theme_advanced_toolbar_location' => 'top',		'theme_advanced_toolbar_align' => 'left',		'theme_advanced_statusbar_location' => 'bottom',		'theme_advanced_resizing' => true,		'theme_advanced_resize_horizontal' => false,		'dialog_type' => 'modal',		'relative_urls' => false,		'remove_script_host' => false,		'convert_urls' => false,		'apply_source_formatting' => false,		'remove_linebreaks' => true,		'gecko_spellcheck' => true,		'entities' => '38,amp,60,lt,62,gt',		'accessibility_focus' => true,		'tabfocus_elements' => 'major-publishing-actions',		'media_strict' => false,		'paste_remove_styles' => true,		'paste_remove_spans' => true,		'paste_strip_class_attributes' => 'all',		'wpeditimage_disable_captions' => $no_captions,		'plugins' => $plugins	);	if ( ! empty( $editor_styles ) && is_array( $editor_styles ) ) {		$mce_css = array();		$style_uri = get_stylesheet_directory_uri();		if ( TEMPLATEPATH == STYLESHEETPATH ) {			foreach ( $editor_styles as $file )				$mce_css[] = "$style_uri/$file";		} else {			$style_dir    = get_stylesheet_directory();			$template_uri = get_template_directory_uri();			$template_dir = get_template_directory();			foreach ( $editor_styles as $file ) {				if ( file_exists( "$style_dir/$file" ) )					$mce_css[] = "$style_uri/$file";				if ( file_exists( "$template_dir/$file" ) )					$mce_css[] = "$template_uri/$file";			}		}		$mce_css = implode( ',', $mce_css );	} else {		$mce_css = '';	}	$mce_css = trim( apply_filters( 'mce_css', $mce_css ), ' ,' );	if ( ! empty($mce_css) )		$initArray['content_css'] = $mce_css;	if ( is_array($settings) )		$initArray = array_merge($initArray, $settings);	// For people who really REALLY know what they're doing with TinyMCE	// You can modify initArray to add, remove, change elements of the config before tinyMCE.init	// Setting "valid_elements", "invalid_elements" and "extended_valid_elements" can be done through "tiny_mce_before_init".	// Best is to use the default cleanup by not specifying valid_elements, as TinyMCE contains full set of XHTML 1.0.	if ( $teeny ) {		$initArray = apply_filters('teeny_mce_before_init', $initArray);	} else {		$initArray = apply_filters('tiny_mce_before_init', $initArray);	}	if ( empty($initArray['theme_advanced_buttons3']) && !empty($initArray['theme_advanced_buttons4']) ) {		$initArray['theme_advanced_buttons3'] = $initArray['theme_advanced_buttons4'];		$initArray['theme_advanced_buttons4'] = '';	}	if ( ! isset($concatenate_scripts) )		script_concat_settings();	$language = $initArray['language'];	$compressed = $compress_scripts && $concatenate_scripts && isset($_SERVER['HTTP_ACCEPT_ENCODING'])		&& false !== strpos( strtolower($_SERVER['HTTP_ACCEPT_ENCODING']), 'gzip');	/**	 * Deprecated	 *	 * The tiny_mce_version filter is not needed since external plugins are loaded directly by TinyMCE.	 * These plugins can be refreshed by appending query string to the URL passed to mce_external_plugins filter.	 * If the plugin has a popup dialog, a query string can be added to the button action that opens it (in the plugin's code).	 */	$version = apply_filters('tiny_mce_version', '');	$version = 'ver=' . $tinymce_version . $version;	if ( 'en' != $language )		include_once(ABSPATH . WPINC . '/js/tinymce/langs/wp-langs.php');	$mce_options = '';	foreach ( $initArray as $k => $v )	    $mce_options .= $k . ':"' . $v . '", ';	$mce_options = rtrim( trim($mce_options), '\n\r,' ); ?><script type="text/javascript">/* <![CDATA[ */tinyMCEPreInit = {	base : "<?php echo $baseurl; ?>",	suffix : "",	query : "<?php echo $version; ?>",	mceInit : {<?php echo $mce_options; ?>},	load_ext : function(url,lang){var sl=tinymce.ScriptLoader;sl.markDone(url+'/langs/'+lang+'.js');sl.markDone(url+'/langs/'+lang+'_dlg.js');}};/* ]]> */</script><?php	if ( $compressed )		echo "<script type='text/javascript' src='$baseurl/wp-tinymce.php?c=1&amp;$version'></script>\n";	else		echo "<script type='text/javascript' src='$baseurl/tiny_mce.js?$version'></script>\n";	if ( 'en' != $language && isset($lang) )		echo "<script type='text/javascript'>\n$lang\n</script>\n";	else		echo "<script type='text/javascript' src='$baseurl/langs/wp-langs-en.js?$version'></script>\n";?><script type="text/javascript">/* <![CDATA[ */<?php if ( $ext_plugins ) echo "$ext_plugins\n"; ?><?php if ( $compressed ) { ?>tinyMCEPreInit.go();<?php } else { ?>(function(){var t=tinyMCEPreInit,sl=tinymce.ScriptLoader,ln=t.mceInit.language,th=t.mceInit.theme,pl=t.mceInit.plugins;sl.markDone(t.base+'/langs/'+ln+'.js');sl.markDone(t.base+'/themes/'+th+'/langs/'+ln+'.js');sl.markDone(t.base+'/themes/'+th+'/langs/'+ln+'_dlg.js');tinymce.each(pl.split(','),function(n){if(n&&n.charAt(0)!='-'){sl.markDone(t.base+'/plugins/'+n+'/langs/'+ln+'.js');sl.markDone(t.base+'/plugins/'+n+'/langs/'+ln+'_dlg.js');}});})();<?php } ?>tinyMCE.init(tinyMCEPreInit.mceInit);/* ]]> */</script><?php}
<?php/** * BackPress Scripts enqueue. * * These classes were refactored from the WordPress WP_Scripts and WordPress * script enqueue API. * * @package BackPress * @since r16 *//** * BackPress Scripts enqueue class. * * @package BackPress * @uses WP_Dependencies * @since r16 */class WP_Scripts extends WP_Dependencies {	var $base_url; // Full URL with trailing slash	var $content_url;	var $default_version;	var $in_footer = array();	var $concat = '';	var $concat_version = '';	var $do_concat = false;	var $print_html = '';	var $print_code = '';	var $ext_handles = '';	var $ext_version = '';	var $default_dirs;	function __construct() {		do_action_ref_array( 'wp_default_scripts', array(&$this) );	}	/**	 * Prints scripts	 *	 * Prints the scripts passed to it or the print queue.  Also prints all necessary dependencies.	 *	 * @param mixed handles (optional) Scripts to be printed.  (void) prints queue, (string) prints that script, (array of strings) prints those scripts.	 * @param int group (optional) If scripts were queued in groups prints this group number.	 * @return array Scripts that have been printed	 */	function print_scripts( $handles = false, $group = false ) {		return $this->do_items( $handles, $group );	}	function print_scripts_l10n( $handle, $echo = true ) {		if ( empty($this->registered[$handle]->extra['l10n']) || empty($this->registered[$handle]->extra['l10n'][0]) || !is_array($this->registered[$handle]->extra['l10n'][1]) )			return false;		$object_name = $this->registered[$handle]->extra['l10n'][0];		$data = "var $object_name = {\n";		$eol = '';		foreach ( $this->registered[$handle]->extra['l10n'][1] as $var => $val ) {			if ( 'l10n_print_after' == $var ) {				$after = $val;				continue;			}			$data .= "$eol\t$var: \"" . esc_js( $val ) . '"';			$eol = ",\n";		}		$data .= "\n};\n";		$data .= isset($after) ? "$after\n" : '';		if ( $echo ) {			echo "<script type='text/javascript'>\n";			echo "/* <![CDATA[ */\n";			echo $data;			echo "/* ]]> */\n";			echo "</script>\n";			return true;		} else {			return $data;		}	}	function do_item( $handle, $group = false ) {		if ( !parent::do_item($handle) )			return false;		if ( 0 === $group && $this->groups[$handle] > 0 ) {			$this->in_footer[] = $handle;			return false;		}		if ( false === $group && in_array($handle, $this->in_footer, true) )			$this->in_footer = array_diff( $this->in_footer, (array) $handle );		if ( null === $this->registered[$handle]->ver )			$ver = '';		else			$ver = $this->registered[$handle]->ver ? $this->registered[$handle]->ver : $this->default_version;		if ( isset($this->args[$handle]) )			$ver = $ver ? $ver . '&amp;' . $this->args[$handle] : $this->args[$handle];		$src = $this->registered[$handle]->src;		if ( $this->do_concat ) {			$srce = apply_filters( 'script_loader_src', $src, $handle );			if ( $this->in_default_dir($srce) ) {				$this->print_code .= $this->print_scripts_l10n( $handle, false );				$this->concat .= "$handle,";				$this->concat_version .= "$handle$ver";				return true;			} else {				$this->ext_handles .= "$handle,";				$this->ext_version .= "$handle$ver";			}		}		$this->print_scripts_l10n( $handle );		if ( !preg_match('|^https?://|', $src) && ! ( $this->content_url && 0 === strpos($src, $this->content_url) ) ) {			$src = $this->base_url . $src;		}		if ( !empty($ver) )			$src = add_query_arg('ver', $ver, $src);		$src = esc_url(apply_filters( 'script_loader_src', $src, $handle ));		if ( $this->do_concat )			$this->print_html .= "<script type='text/javascript' src='$src'></script>\n";		else			echo "<script type='text/javascript' src='$src'></script>\n";		return true;	}	/**	 * Localizes a script	 *	 * Localizes only if script has already been added	 *	 * @param string handle Script name	 * @param string object_name Name of JS object to hold l10n info	 * @param array l10n Array of JS var name => localized string	 * @return bool Successful localization	 */	function localize( $handle, $object_name, $l10n ) {		if ( !$object_name || !$l10n )			return false;		return $this->add_data( $handle, 'l10n', array( $object_name, $l10n ) );	}	function set_group( $handle, $recursion, $group = false ) {		$grp = isset($this->registered[$handle]->extra['group']) ? (int) $this->registered[$handle]->extra['group'] : 0;		if ( false !== $group && $grp > $group )			$grp = $group;		return parent::set_group( $handle, $recursion, $grp );	}	function all_deps( $handles, $recursion = false, $group = false ) {		$r = parent::all_deps( $handles, $recursion );		if ( !$recursion )			$this->to_do = apply_filters( 'print_scripts_array', $this->to_do );		return $r;	}	function do_head_items() {		$this->do_items(false, 0);		return $this->done;	}	function do_footer_items() {		if ( !empty($this->in_footer) ) {			foreach( $this->in_footer as $key => $handle ) {				if ( !in_array($handle, $this->done, true) && isset($this->registered[$handle]) ) {					$this->do_item($handle);					$this->done[] = $handle;					unset( $this->in_footer[$key] );				}			}		}		return $this->done;	}	function in_default_dir($src) {		if ( ! $this->default_dirs )			return true;		foreach ( (array) $this->default_dirs as $test ) {			if ( 0 === strpos($src, $test) )				return true;		}		return false;	}	function reset() {		$this->do_concat = false;		$this->print_code = '';		$this->concat = '';		$this->concat_version = '';		$this->print_html = '';		$this->ext_version = '';		$this->ext_handles = '';	}}
<?php/** * WordPress Dashboard Widget Administration Panel API * * @package WordPress * @subpackage Administration *//** * Registers dashboard widgets. * * handles POST data, sets up filters. * * @since unknown */function wp_dashboard_setup() {	global $wp_registered_widgets, $wp_registered_widget_controls, $wp_dashboard_control_callbacks;	$wp_dashboard_control_callbacks = array();	$update = false;	$widget_options = get_option( 'dashboard_widget_options' );	if ( !$widget_options || !is_array($widget_options) )		$widget_options = array();	/* Register Widgets and Controls */	// Right Now	wp_add_dashboard_widget( 'dashboard_right_now', __( 'Right Now' ), 'wp_dashboard_right_now' );	// Recent Comments Widget	if ( !isset( $widget_options['dashboard_recent_comments'] ) || !isset( $widget_options['dashboard_recent_comments']['items'] ) ) {		$update = true;		$widget_options['dashboard_recent_comments'] = array(			'items' => 5,		);	}	$recent_comments_title = __( 'Recent Comments' );	wp_add_dashboard_widget( 'dashboard_recent_comments', $recent_comments_title, 'wp_dashboard_recent_comments', 'wp_dashboard_recent_comments_control' );	// Incoming Links Widget	if ( !isset( $widget_options['dashboard_incoming_links'] ) || !isset( $widget_options['dashboard_incoming_links']['home'] ) || $widget_options['dashboard_incoming_links']['home'] != get_option('home') ) {		$update = true;		$num_items = isset($widget_options['dashboard_incoming_links']['items']) ? $widget_options['dashboard_incoming_links']['items'] : 10;		$widget_options['dashboard_incoming_links'] = array(			'home' => get_option('home'),			'link' => apply_filters( 'dashboard_incoming_links_link', 'http://blogsearch.google.com/blogsearch?scoring=d&partner=wordpress&q=link:' . trailingslashit( get_option('home') ) ),			'url' => isset($widget_options['dashboard_incoming_links']['url']) ? apply_filters( 'dashboard_incoming_links_feed', $widget_options['dashboard_incoming_links']['url'] ) : apply_filters( 'dashboard_incoming_links_feed', 'http://blogsearch.google.com/blogsearch_feeds?scoring=d&ie=utf-8&num=' . $num_items . '&output=rss&partner=wordpress&q=link:' . trailingslashit( get_option('home') ) ),			'items' => $num_items,			'show_date' => isset($widget_options['dashboard_incoming_links']['show_date']) ? $widget_options['dashboard_incoming_links']['show_date'] : false		);	}	wp_add_dashboard_widget( 'dashboard_incoming_links', __( 'Incoming Links' ), 'wp_dashboard_incoming_links', 'wp_dashboard_incoming_links_control' );	// WP Plugins Widget	if ( current_user_can( 'install_plugins' ) )		wp_add_dashboard_widget( 'dashboard_plugins', __( 'Plugins' ), 'wp_dashboard_plugins' );	// QuickPress Widget	if ( current_user_can('edit_posts') )		wp_add_dashboard_widget( 'dashboard_quick_press', __( 'QuickPress' ), 'wp_dashboard_quick_press' );	// Recent Drafts	if ( current_user_can('edit_posts') )		wp_add_dashboard_widget( 'dashboard_recent_drafts', __('Recent Drafts'), 'wp_dashboard_recent_drafts' );	// Primary feed (Dev Blog) Widget	if ( !isset( $widget_options['dashboard_primary'] ) ) {		$update = true;		$widget_options['dashboard_primary'] = array(			'link' => apply_filters( 'dashboard_primary_link',  __( 'http://wordpress.org/development/' ) ),			'url' => apply_filters( 'dashboard_primary_feed',  __( 'http://wordpress.org/development/feed/' ) ),			'title' => apply_filters( 'dashboard_primary_title', __( 'WordPress Blog' ) ),			'items' => 2,			'show_summary' => 1,			'show_author' => 0,			'show_date' => 1,		);	}	wp_add_dashboard_widget( 'dashboard_primary', $widget_options['dashboard_primary']['title'], 'wp_dashboard_primary', 'wp_dashboard_primary_control' );	// Secondary Feed (Planet) Widget	if ( !isset( $widget_options['dashboard_secondary'] ) ) {		$update = true;		$widget_options['dashboard_secondary'] = array(			'link' => apply_filters( 'dashboard_secondary_link',  __( 'http://planet.wordpress.org/' ) ),			'url' => apply_filters( 'dashboard_secondary_feed',  __( 'http://planet.wordpress.org/feed/' ) ),			'title' => apply_filters( 'dashboard_secondary_title', __( 'Other WordPress News' ) ),			'items' => 5,			'show_summary' => 0,			'show_author' => 0,			'show_date' => 0,		);	}	wp_add_dashboard_widget( 'dashboard_secondary', $widget_options['dashboard_secondary']['title'], 'wp_dashboard_secondary', 'wp_dashboard_secondary_control' );	// Hook to register new widgets	do_action( 'wp_dashboard_setup' );	// Filter widget order	$dashboard_widgets = apply_filters( 'wp_dashboard_widgets', array() );	foreach ( $dashboard_widgets as $widget_id ) {		$name = empty( $wp_registered_widgets[$widget_id]['all_link'] ) ? $wp_registered_widgets[$widget_id]['name'] : $wp_registered_widgets[$widget_id]['name'] . " <a href='{$wp_registered_widgets[$widget_id]['all_link']}' class='edit-box open-box'>" . __('View all') . '</a>';		wp_add_dashboard_widget( $widget_id, $name, $wp_registered_widgets[$widget_id]['callback'], $wp_registered_widget_controls[$widget_id]['callback'] );	}	if ( 'POST' == $_SERVER['REQUEST_METHOD'] && isset($_POST['widget_id']) ) {		ob_start(); // hack - but the same hack wp-admin/widgets.php uses		wp_dashboard_trigger_widget_control( $_POST['widget_id'] );		ob_end_clean();		wp_redirect( remove_query_arg( 'edit' ) );		exit;	}	if ( $update )		update_option( 'dashboard_widget_options', $widget_options );	do_action('do_meta_boxes', 'dashboard', 'normal', '');	do_action('do_meta_boxes', 'dashboard', 'side', '');}function wp_add_dashboard_widget( $widget_id, $widget_name, $callback, $control_callback = null ) {	global $wp_dashboard_control_callbacks;	if ( $control_callback && current_user_can( 'edit_dashboard' ) && is_callable( $control_callback ) ) {		$wp_dashboard_control_callbacks[$widget_id] = $control_callback;		if ( isset( $_GET['edit'] ) && $widget_id == $_GET['edit'] ) {			list($url) = explode( '#', add_query_arg( 'edit', false ), 2 );			$widget_name .= ' <span class="postbox-title-action"><a href="' . esc_url( $url ) . '">' . __( 'Cancel' ) . '</a></span>';			add_meta_box( $widget_id, $widget_name, '_wp_dashboard_control_callback', 'dashboard', 'normal', 'core' );			return;		}		list($url) = explode( '#', add_query_arg( 'edit', $widget_id ), 2 );		$widget_name .= ' <span class="postbox-title-action"><a href="' . esc_url( "$url#$widget_id" ) . '" class="edit-box open-box">' . __( 'Configure' ) . '</a></span>';	}	$side_widgets = array('dashboard_quick_press', 'dashboard_recent_drafts', 'dashboard_primary', 'dashboard_secondary');	$location = 'normal';	if ( in_array($widget_id, $side_widgets) )		$location = 'side';	add_meta_box( $widget_id, $widget_name , $callback, 'dashboard', $location, 'core' );}function _wp_dashboard_control_callback( $dashboard, $meta_box ) {	echo '<form action="" method="post" class="dashboard-widget-control-form">';	wp_dashboard_trigger_widget_control( $meta_box['id'] );	echo '<p class="submit"><input type="hidden" name="widget_id" value="' . esc_attr($meta_box['id']) . '" /><input type="submit" value="' . esc_attr__( 'Submit' ) . '" /></p>';	echo '</form>';}/** * Displays the dashboard. * * @since unknown */function wp_dashboard() {	global $screen_layout_columns;	$hide2 = $hide3 = $hide4 = '';	switch ( $screen_layout_columns ) {		case 4:			$width = 'width:24.5%;';			break;		case 3:			$width = 'width:32.67%;';			$hide4 = 'display:none;';			break;		case 2:			$width = 'width:49%;';			$hide3 = $hide4 = 'display:none;';			break;		default:			$width = 'width:98%;';			$hide2 = $hide3 = $hide4 = 'display:none;';	}?><div id="dashboard-widgets" class="metabox-holder"><?php	echo "\t<div class='postbox-container' style='$width'>\n";	do_meta_boxes( 'dashboard', 'normal', '' );	echo "\t</div><div class='postbox-container' style='{$hide2}$width'>\n";	do_meta_boxes( 'dashboard', 'side', '' );	echo "\t</div><div class='postbox-container' style='{$hide3}$width'>\n";	do_meta_boxes( 'dashboard', 'column3', '' );	echo "\t</div><div class='postbox-container' style='{$hide4}$width'>\n";	do_meta_boxes( 'dashboard', 'column4', '' );?></div></div><form style="display:none" method="get" action="">	<p><?php	wp_nonce_field( 'closedpostboxes', 'closedpostboxesnonce', false );	wp_nonce_field( 'meta-box-order', 'meta-box-order-nonce', false );?>	</p></form><?php}/* Dashboard Widgets */function wp_dashboard_right_now() {	global $wp_registered_sidebars;	$num_posts = wp_count_posts( 'post' );	$num_pages = wp_count_posts( 'page' );	$num_cats  = wp_count_terms('category');	$num_tags = wp_count_terms('post_tag');	$num_comm = wp_count_comments( );	echo "\n\t".'<div class="table table_content">';	echo "\n\t".'<p class="sub">' . __('Content') . '</p>'."\n\t".'<table>';	echo "\n\t".'<tr class="first">';	// Posts	$num = number_format_i18n( $num_posts->publish );	$text = _n( 'Post', 'Posts', intval($num_posts->publish) );	if ( current_user_can( 'edit_posts' ) ) {		$num = "<a href='edit.php'>$num</a>";		$text = "<a href='edit.php'>$text</a>";	}	echo '<td class="first b b-posts">' . $num . '</td>';	echo '<td class="t posts">' . $text . '</td>';	echo '</tr><tr>';	/* TODO: Show status breakdown on hover	if ( $can_edit_pages && !empty($num_pages->publish) ) { // how many pages is not exposed in feeds.  Don't show if !current_user_can		$post_type_texts[] = '<a href="edit-pages.php">'.sprintf( _n( '%s page', '%s pages', $num_pages->publish ), number_format_i18n( $num_pages->publish ) ).'</a>';	}	if ( $can_edit_posts && !empty($num_posts->draft) ) {		$post_type_texts[] = '<a href="edit.php?post_status=draft">'.sprintf( _n( '%s draft', '%s drafts', $num_posts->draft ), number_format_i18n( $num_posts->draft ) ).'</a>';	}	if ( $can_edit_posts && !empty($num_posts->future) ) {		$post_type_texts[] = '<a href="edit.php?post_status=future">'.sprintf( _n( '%s scheduled post', '%s scheduled posts', $num_posts->future ), number_format_i18n( $num_posts->future ) ).'</a>';	}	if ( current_user_can('publish_posts') && !empty($num_posts->pending) ) {		$pending_text = sprintf( _n( 'There is <a href="%1$s">%2$s post</a> pending your review.', 'There are <a href="%1$s">%2$s posts</a> pending your review.', $num_posts->pending ), 'edit.php?post_status=pending', number_format_i18n( $num_posts->pending ) );	} else {		$pending_text = '';	}	*/	// Pages	$num = number_format_i18n( $num_pages->publish );	$text = _n( 'Page', 'Pages', $num_pages->publish );	if ( current_user_can( 'edit_pages' ) ) {		$num = "<a href='edit.php?post_type=page'>$num</a>";		$text = "<a href='edit.php?post_type=page'>$text</a>";	}	echo '<td class="first b b_pages">' . $num . '</td>';	echo '<td class="t pages">' . $text . '</td>';	echo '</tr><tr>';	// Categories	$num = number_format_i18n( $num_cats );	$text = _n( 'Category', 'Categories', $num_cats );	if ( current_user_can( 'manage_categories' ) ) {		$num = "<a href='edit-tags.php?taxonomy=category'>$num</a>";		$text = "<a href='edit-tags.php?taxonomy=category'>$text</a>";	}	echo '<td class="first b b-cats">' . $num . '</td>';	echo '<td class="t cats">' . $text . '</td>';	echo '</tr><tr>';	// Tags	$num = number_format_i18n( $num_tags );	$text = _n( 'Tag', 'Tags', $num_tags );	if ( current_user_can( 'manage_categories' ) ) {		$num = "<a href='edit-tags.php'>$num</a>";		$text = "<a href='edit-tags.php'>$text</a>";	}	echo '<td class="first b b-tags">' . $num . '</td>';	echo '<td class="t tags">' . $text . '</td>';	echo "</tr>";	do_action('right_now_content_table_end');	echo "\n\t</table>\n\t</div>";	echo "\n\t".'<div class="table table_discussion">';	echo "\n\t".'<p class="sub">' . __('Discussion') . '</p>'."\n\t".'<table>';	echo "\n\t".'<tr class="first">';	// Total Comments	$num = '<span class="total-count">' . number_format_i18n($num_comm->total_comments) . '</span>';	$text = _n( 'Comment', 'Comments', $num_comm->total_comments );	if ( current_user_can( 'moderate_comments' ) ) {		$num = '<a href="edit-comments.php">' . $num . '</a>';		$text = '<a href="edit-comments.php">' . $text . '</a>';	}	echo '<td class="b b-comments">' . $num . '</td>';	echo '<td class="last t comments">' . $text . '</td>';	echo '</tr><tr>';	// Approved Comments	$num = '<span class="approved-count">' . number_format_i18n($num_comm->approved) . '</span>';	$text = _nx( 'Approved', 'Approved', $num_comm->approved, 'Right Now' );	if ( current_user_can( 'moderate_comments' ) ) {		$num = "<a href='edit-comments.php?comment_status=approved'>$num</a>";		$text = "<a class='approved' href='edit-comments.php?comment_status=approved'>$text</a>";	}	echo '<td class="b b_approved">' . $num . '</td>';	echo '<td class="last t">' . $text . '</td>';	echo "</tr>\n\t<tr>";	// Pending Comments	$num = '<span class="pending-count">' . number_format_i18n($num_comm->moderated) . '</span>';	$text = _n( 'Pending', 'Pending', $num_comm->moderated );	if ( current_user_can( 'moderate_comments' ) ) {		$num = "<a href='edit-comments.php?comment_status=moderated'>$num</a>";		$text = "<a class='waiting' href='edit-comments.php?comment_status=moderated'>$text</a>";	}	echo '<td class="b b-waiting">' . $num . '</td>';	echo '<td class="last t">' . $text . '</td>';	echo "</tr>\n\t<tr>";	// Spam Comments	$num = number_format_i18n($num_comm->spam);	$text = _nx( 'Spam', 'Spam', $num_comm->spam, 'comment' );	if ( current_user_can( 'moderate_comments' ) ) {		$num = "<a href='edit-comments.php?comment_status=spam'><span class='spam-count'>$num</span></a>";		$text = "<a class='spam' href='edit-comments.php?comment_status=spam'>$text</a>";	}	echo '<td class="b b-spam">' . $num . '</td>';	echo '<td class="last t">' . $text . '</td>';	echo "</tr>";	do_action('right_now_table_end');	do_action('right_now_discussion_table_end');	echo "\n\t</table>\n\t</div>";	echo "\n\t".'<div class="versions">';	$ct = current_theme_info();	echo "\n\t<p>";	if ( !empty($wp_registered_sidebars) ) {		$sidebars_widgets = wp_get_sidebars_widgets();		$num_widgets = 0;		foreach ( (array) $sidebars_widgets as $k => $v ) {			if ( 'wp_inactive_widgets' == $k )				continue;			if ( is_array($v) )				$num_widgets = $num_widgets + count($v);		}		$num = number_format_i18n( $num_widgets );		$switch_themes = $ct->title;		if ( current_user_can( 'switch_themes') ) {			echo '<a href="themes.php" class="button rbutton">' . __('Change Theme') . '</a>';			$switch_themes = '<a href="themes.php">' . $switch_themes . '</a>';		}		if ( current_user_can( 'edit_theme_options' ) ) {			printf(_n('Theme <span class="b">%1$s</span> with <span class="b"><a href="widgets.php">%2$s Widget</a></span>', 'Theme <span class="b">%1$s</span> with <span class="b"><a href="widgets.php">%2$s Widgets</a></span>', $num_widgets), $switch_themes, $num);		} else {			printf(_n('Theme <span class="b">%1$s</span> with <span class="b">%2$s Widget</span>', 'Theme <span class="b">%1$s</span> with <span class="b">%2$s Widgets</span>', $num_widgets), $switch_themes, $num);		}	} else {		if ( current_user_can( 'switch_themes' ) ) {			echo '<a href="themes.php" class="button rbutton">' . __('Change Theme') . '</a>';			printf( __('Theme <span class="b"><a href="themes.php">%1$s</a></span>'), $ct->title );		} else {			printf( __('Theme <span class="b">%1$s</span>'), $ct->title );		}	}	echo '</p>';	update_right_now_message();	echo "\n\t".'<br class="clear" /></div>';	do_action( 'rightnow_end' );	do_action( 'activity_box_end' );}function wp_dashboard_quick_press_output() {	global $post_ID;	$drafts = false;	if ( 'post' === strtolower( $_SERVER['REQUEST_METHOD'] ) && isset( $_POST['action'] ) && 0 === strpos( $_POST['action'], 'post-quickpress' ) && (int) $_POST['post_ID'] ) {		$view = get_permalink( $_POST['post_ID'] );		$edit = esc_url( get_edit_post_link( $_POST['post_ID'] ) );		if ( 'post-quickpress-publish' == $_POST['action'] ) {			if ( current_user_can('publish_posts') )				printf( '<div class="updated"><p>' . __( 'Post published. <a href="%s">View post</a> | <a href="%s">Edit post</a>' ) . '</p></div>', esc_url( $view ), $edit );			else				printf( '<div class="updated"><p>' . __( 'Post submitted. <a href="%s">Preview post</a> | <a href="%s">Edit post</a>' ) . '</p></div>', esc_url( add_query_arg( 'preview', 1, $view ) ), $edit );		} else {			printf( '<div class="updated"><p>' . __( 'Draft saved. <a href="%s">Preview post</a> | <a href="%s">Edit post</a>' ) . '</p></div>', esc_url( add_query_arg( 'preview', 1, $view ) ), $edit );			$drafts_query = new WP_Query( array(				'post_type' => 'post',				'post_status' => 'draft',				'author' => $GLOBALS['current_user']->ID,				'posts_per_page' => 1,				'orderby' => 'modified',				'order' => 'DESC'			) );			if ( $drafts_query->posts )				$drafts =& $drafts_query->posts;		}		printf('<p class="textright">' . __('You can also try %s, easy blogging from anywhere on the Web.') . '</p>', '<a href="' . esc_url( admin_url( 'tools.php' ) ) . '">' . __('Press This') . '</a>' );		$_REQUEST = array(); // hack for get_default_post_to_edit()	}	/* Check if a new auto-draft (= no new post_ID) is needed or if the old can be used */	$last_post_id = (int) get_user_option( 'dashboard_quick_press_last_post_id' ); // Get the last post_ID	if ( $last_post_id ) {		$post = get_post( $last_post_id );		if ( empty( $post ) || $post->post_status != 'auto-draft' ) { // auto-draft doesn't exists anymore			$post = get_default_post_to_edit('post', true);			update_user_option( (int) $GLOBALS['current_user']->ID, 'dashboard_quick_press_last_post_id', (int) $post->ID ); // Save post_ID		} else {			$post->post_title = ''; // Remove the auto draft title		}	} else {		$post = get_default_post_to_edit('post', true);		update_user_option( (int) $GLOBALS['current_user']->ID, 'dashboard_quick_press_last_post_id', (int) $post->ID ); // Save post_ID	}	$post_ID = (int) $post->ID;?>	<form name="post" action="<?php echo esc_url( admin_url( 'post.php' ) ); ?>" method="post" id="quick-press">		<h4 id="quick-post-title"><label for="title"><?php _e('Title') ?></label></h4>		<div class="input-text-wrap">			<input type="text" name="post_title" id="title" tabindex="1" autocomplete="off" value="<?php echo esc_attr( $post->post_title ); ?>" />		</div>		<?php if ( current_user_can( 'upload_files' ) ) : ?>		<div id="media-buttons" class="hide-if-no-js">			<?php do_action( 'media_buttons' ); ?>		</div>		<?php endif; ?>		<h4 id="content-label"><label for="content"><?php _e('Content') ?></label></h4>		<div class="textarea-wrap">			<textarea name="content" id="content" class="mceEditor" rows="3" cols="15" tabindex="2"><?php echo $post->post_content; ?></textarea>		</div>		<script type="text/javascript">edCanvas = document.getElementById('content');edInsertContent = null;</script>		<h4><label for="tags-input"><?php _e('Tags') ?></label></h4>		<div class="input-text-wrap">			<input type="text" name="tags_input" id="tags-input" tabindex="3" value="<?php echo get_tags_to_edit( $post->ID ); ?>" />		</div>		<p class="submit">			<input type="hidden" name="action" id="quickpost-action" value="post-quickpress-save" />			<input type="hidden" name="quickpress_post_ID" value="<?php echo $post_ID; ?>" />			<input type="hidden" name="post_type" value="post" />			<?php wp_nonce_field('add-post'); ?>			<input type="submit" name="save" id="save-post" class="button" tabindex="4" value="<?php esc_attr_e('Save Draft'); ?>" />			<input type="reset" value="<?php esc_attr_e( 'Reset' ); ?>" class="button" />			<span id="publishing-action">				<input type="submit" name="publish" id="publish" accesskey="p" tabindex="5" class="button-primary" value="<?php current_user_can('publish_posts') ? esc_attr_e('Publish') : esc_attr_e('Submit for Review'); ?>" />				<img class="waiting" src="<?php echo esc_url( admin_url( 'images/wpspin_light.gif' ) ); ?>" />			</span>			<br class="clear" />		</p>	</form><?php	if ( $drafts )		wp_dashboard_recent_drafts( $drafts );}function wp_dashboard_quick_press() {	echo '<p class="widget-loading hide-if-no-js">' . __( 'Loading&#8230;' ) . '</p><p class="describe hide-if-js">' . __('This widget requires JavaScript.') . '</p>';}function wp_dashboard_recent_drafts( $drafts = false ) {	if ( !$drafts ) {		$drafts_query = new WP_Query( array(			'post_type' => 'post',			'post_status' => 'draft',			'author' => $GLOBALS['current_user']->ID,			'posts_per_page' => 5,			'orderby' => 'modified',			'order' => 'DESC'		) );		$drafts =& $drafts_query->posts;	}	if ( $drafts && is_array( $drafts ) ) {		$list = array();		foreach ( $drafts as $draft ) {			$url = get_edit_post_link( $draft->ID );			$title = _draft_or_post_title( $draft->ID );			$item = "<h4><a href='$url' title='" . sprintf( __( 'Edit &#8220;%s&#8221;' ), esc_attr( $title ) ) . "'>" . esc_html($title) . "</a> <abbr title='" . get_the_time(__('Y/m/d g:i:s A'), $draft) . "'>" . get_the_time( get_option( 'date_format' ), $draft ) . '</abbr></h4>';			if ( $the_content = preg_split( '#\s#', strip_tags( $draft->post_content ), 11, PREG_SPLIT_NO_EMPTY ) )				$item .= '<p>' . join( ' ', array_slice( $the_content, 0, 10 ) ) . ( 10 < count( $the_content ) ? '&hellip;' : '' ) . '</p>';			$list[] = $item;		}?>	<ul>		<li><?php echo join( "</li>\n<li>", $list ); ?></li>	</ul>	<p class="textright"><a href="edit.php?post_status=draft" class="button"><?php _e('View all'); ?></a></p><?php	} else {		_e('There are no drafts at the moment');	}}/** * Display recent comments dashboard widget content. * * @since unknown */function wp_dashboard_recent_comments() {	global $wpdb;	if ( current_user_can('edit_posts') )		$allowed_states = array('0', '1');	else		$allowed_states = array('1');	// Select all comment types and filter out spam later for better query performance.	$comments = array();	$start = 0;	$widgets = get_option( 'dashboard_widget_options' );	if ( isset( $widgets['dashboard_recent_comments'] ) && isset( $widgets['dashboard_recent_comments']['items'] ) )		$total_items = (int) $widgets['dashboard_recent_comments']['items'];	else		$total_items = 5;	while ( count( $comments ) < 5 && $possible = $wpdb->get_results( "SELECT * FROM $wpdb->comments c LEFT JOIN $wpdb->posts p ON c.comment_post_ID = p.ID WHERE p.post_status != 'trash' ORDER BY c.comment_date_gmt DESC LIMIT $start, 50" ) ) {		foreach ( $possible as $comment ) {			if ( count( $comments ) >= $total_items )				break;			if ( in_array( $comment->comment_approved, $allowed_states ) && current_user_can( 'read_post', $comment->comment_post_ID ) )				$comments[] = $comment;		}		$start = $start + 50;	}	if ( $comments ) :?>		<div id="the-comment-list" class="list:comment"><?php		foreach ( $comments as $comment )			_wp_dashboard_recent_comments_row( $comment );?>		</div><?php		if ( current_user_can('edit_posts') ) { ?>			<p class="textright"><a href="edit-comments.php" class="button"><?php _e('View all'); ?></a></p><?php	}		wp_comment_reply( -1, false, 'dashboard', false );		wp_comment_trashnotice();	else :?>	<p><?php _e( 'No comments yet.' ); ?></p><?php	endif; // $comments;}function _wp_dashboard_recent_comments_row( &$comment, $show_date = true ) {	$GLOBALS['comment'] =& $comment;	$comment_post_url = get_edit_post_link( $comment->comment_post_ID );	$comment_post_title = strip_tags(get_the_title( $comment->comment_post_ID ));	$comment_post_link = "<a href='$comment_post_url'>$comment_post_title</a>";	$comment_link = '<a class="comment-link" href="' . esc_url(get_comment_link()) . '">#</a>';	$actions_string = '';	if ( current_user_can('edit_post', $comment->comment_post_ID) ) {		// preorder it: Approve | Reply | Edit | Spam | Trash		$actions = array(			'approve' => '', 'unapprove' => '',			'reply' => '',			'edit' => '',			'spam' => '',			'trash' => '', 'delete' => ''		);		$del_nonce = esc_html( '_wpnonce=' . wp_create_nonce( "delete-comment_$comment->comment_ID" ) );		$approve_nonce = esc_html( '_wpnonce=' . wp_create_nonce( "approve-comment_$comment->comment_ID" ) );		$approve_url = esc_url( "comment.php?action=approvecomment&p=$comment->comment_post_ID&c=$comment->comment_ID&$approve_nonce" );		$unapprove_url = esc_url( "comment.php?action=unapprovecomment&p=$comment->comment_post_ID&c=$comment->comment_ID&$approve_nonce" );		$spam_url = esc_url( "comment.php?action=spamcomment&p=$comment->comment_post_ID&c=$comment->comment_ID&$del_nonce" );		$trash_url = esc_url( "comment.php?action=trashcomment&p=$comment->comment_post_ID&c=$comment->comment_ID&$del_nonce" );		$delete_url = esc_url( "comment.php?action=deletecomment&p=$comment->comment_post_ID&c=$comment->comment_ID&$del_nonce" );		$actions['approve'] = "<a href='$approve_url' class='dim:the-comment-list:comment-$comment->comment_ID:unapproved:e7e7d3:e7e7d3:new=approved vim-a' title='" . __( 'Approve this comment' ) . "'>" . __( 'Approve' ) . '</a>';		$actions['unapprove'] = "<a href='$unapprove_url' class='dim:the-comment-list:comment-$comment->comment_ID:unapproved:e7e7d3:e7e7d3:new=unapproved vim-u' title='" . __( 'Unapprove this comment' ) . "'>" . __( 'Unapprove' ) . '</a>';		$actions['edit'] = "<a href='comment.php?action=editcomment&amp;c={$comment->comment_ID}' title='" . __('Edit comment') . "'>". __('Edit') . '</a>';		$actions['reply'] = '<a onclick="commentReply.open(\''.$comment->comment_ID.'\',\''.$comment->comment_post_ID.'\');return false;" class="vim-r hide-if-no-js" title="'.__('Reply to this comment').'" href="#">' . __('Reply') . '</a>';		$actions['spam'] = "<a href='$spam_url' class='delete:the-comment-list:comment-$comment->comment_ID::spam=1 vim-s vim-destructive' title='" . __( 'Mark this comment as spam' ) . "'>" . /* translators: mark as spam link */  _x( 'Spam', 'verb' ) . '</a>';		if ( !EMPTY_TRASH_DAYS )			$actions['delete'] = "<a href='$delete_url' class='delete:the-comment-list:comment-$comment->comment_ID::trash=1 delete vim-d vim-destructive'>" . __('Delete Permanently') . '</a>';		else			$actions['trash'] = "<a href='$trash_url' class='delete:the-comment-list:comment-$comment->comment_ID::trash=1 delete vim-d vim-destructive' title='" . __( 'Move this comment to the trash' ) . "'>" . _x('Trash', 'verb') . '</a>';		$actions = apply_filters( 'comment_row_actions', array_filter($actions), $comment );		$i = 0;		foreach ( $actions as $action => $link ) {			++$i;			( ( ('approve' == $action || 'unapprove' == $action) && 2 === $i ) || 1 === $i ) ? $sep = '' : $sep = ' | ';			// Reply and quickedit need a hide-if-no-js span			if ( 'reply' == $action || 'quickedit' == $action )				$action .= ' hide-if-no-js';			$actions_string .= "<span class='$action'>$sep$link</span>";		}	}?>		<div id="comment-<?php echo $comment->comment_ID; ?>" <?php comment_class( array( 'comment-item', wp_get_comment_status($comment->comment_ID) ) ); ?>>			<?php if ( !$comment->comment_type || 'comment' == $comment->comment_type ) : ?>			<?php echo get_avatar( $comment, 50 ); ?>			<div class="dashboard-comment-wrap">			<h4 class="comment-meta">				<?php printf( /* translators: 1: comment author, 2: post link, 3: notification if the comment is pending */__( 'From %1$s on %2$s%3$s' ),					'<cite class="comment-author">' . get_comment_author_link() . '</cite>', $comment_post_link.' '.$comment_link, ' <span class="approve">' . __( '[Pending]' ) . '</span>' ); ?>			</h4>			<?php			else :				switch ( $comment->comment_type ) :				case 'pingback' :					$type = __( 'Pingback' );					break;				case 'trackback' :					$type = __( 'Trackback' );					break;				default :					$type = ucwords( $comment->comment_type );				endswitch;				$type = esc_html( $type );			?>			<div class="dashboard-comment-wrap">			<?php /* translators: %1$s is type of comment, %2$s is link to the post */ ?>			<h4 class="comment-meta"><?php printf( _x( '%1$s on %2$s', 'dashboard' ), "<strong>$type</strong>", $comment_post_link." ".$comment_link ); ?></h4>			<p class="comment-author"><?php comment_author_link(); ?></p>			<?php endif; // comment_type ?>			<blockquote><p><?php comment_excerpt(); ?></p></blockquote>			<p class="row-actions"><?php echo $actions_string; ?></p>			</div>		</div><?php}/** * The recent comments dashboard widget control. * * @since 3.0.0 */function wp_dashboard_recent_comments_control() {	if ( !$widget_options = get_option( 'dashboard_widget_options' ) )		$widget_options = array();	if ( !isset($widget_options['dashboard_recent_comments']) )		$widget_options['dashboard_recent_comments'] = array();	if ( 'POST' == $_SERVER['REQUEST_METHOD'] && isset($_POST['widget-recent-comments']) ) {		$number = (int) stripslashes($_POST['widget-recent-comments']['items']);		if ( $number < 1 || $number > 30 )			$number = 5;		$widget_options['dashboard_recent_comments']['items'] = $number;		update_option( 'dashboard_widget_options', $widget_options );	}	$number = isset( $widget_options['dashboard_recent_comments']['items'] ) ? (int) $widget_options['dashboard_recent_comments']['items'] : '';	echo '<p><label for="comments-number">' . __('Number of comments to show:') . '</label>';	echo '<input id="comments-number" name="widget-recent-comments[items]" type="text" value="' . $number . '" size="3" /> <small>' . __( '(at most 30)' ) . '</small></p>';}function wp_dashboard_incoming_links() {	echo '<p class="widget-loading hide-if-no-js">' . __( 'Loading&#8230;' ) . '</p><p class="describe hide-if-js">' . __('This widget requires JavaScript.') . '</p>';}/** * Display incoming links dashboard widget content. * * @since unknown */function wp_dashboard_incoming_links_output() {	$widgets = get_option( 'dashboard_widget_options' );	@extract( @$widgets['dashboard_incoming_links'], EXTR_SKIP );	$rss = fetch_feed( $url );	if ( is_wp_error($rss) ) {		if ( is_admin() || current_user_can('manage_options') ) {			echo '<p>';			printf(__('<strong>RSS Error</strong>: %s'), $rss->get_error_message());			echo '</p>';		}		return;	}	if ( !$rss->get_item_quantity() ) {		echo '<p>' . __('This dashboard widget queries <a href="http://blogsearch.google.com/">Google Blog Search</a> so that when another blog links to your site it will show up here. It has found no incoming links&hellip; yet. It&#8217;s okay &#8212; there is no rush.') . "</p>\n";		$rss->__destruct();		unset($rss);		return;	}	echo "<ul>\n";	if ( !isset($items) )		$items = 10;	foreach ( $rss->get_items(0, $items) as $item ) {		$publisher = '';		$site_link = '';		$link = '';		$content = '';		$date = '';		$link = esc_url( strip_tags( $item->get_link() ) );		$author = $item->get_author();		if ( $author ) {			$site_link = esc_url( strip_tags( $author->get_link() ) );			if ( !$publisher = esc_html( strip_tags( $author->get_name() ) ) )				$publisher = __( 'Somebody' );		} else {		  $publisher = __( 'Somebody' );		}		if ( $site_link )			$publisher = "<a href='$site_link'>$publisher</a>";		else			$publisher = "<strong>$publisher</strong>";		$content = $item->get_content();		$content = wp_html_excerpt($content, 50) . ' ...';		if ( $link )			/* translators: incoming links feed, %1$s is other person, %3$s is content */			$text = __( '%1$s linked here <a href="%2$s">saying</a>, "%3$s"' );		else			/* translators: incoming links feed, %1$s is other person, %3$s is content */			$text = __( '%1$s linked here saying, "%3$s"' );		if ( $show_date ) {			if ( $show_author || $show_summary )				/* translators: incoming links feed, %4$s is the date */				$text .= ' ' . __( 'on %4$s' );			$date = esc_html( strip_tags( $item->get_date() ) );			$date = strtotime( $date );			$date = gmdate( get_option( 'date_format' ), $date );		}		echo "\t<li>" . sprintf( $text, $publisher, $link, $content, $date ) . "</li>\n";	}	echo "</ul>\n";	$rss->__destruct();	unset($rss);}function wp_dashboard_incoming_links_control() {	wp_dashboard_rss_control( 'dashboard_incoming_links', array( 'title' => false, 'show_summary' => false, 'show_author' => false ) );}function wp_dashboard_primary() {	echo '<p class="widget-loading hide-if-no-js">' . __( 'Loading&#8230;' ) . '</p><p class="describe hide-if-js">' . __('This widget requires JavaScript.') . '</p>';}function wp_dashboard_primary_control() {	wp_dashboard_rss_control( 'dashboard_primary' );}/** * {@internal Missing Short Description}} * * @since unknown * * @param int $widget_id */function wp_dashboard_rss_output( $widget_id ) {	$widgets = get_option( 'dashboard_widget_options' );	echo '<div class="rss-widget">';	wp_widget_rss_output( $widgets[$widget_id] );	echo "</div>";}function wp_dashboard_secondary() {	echo '<p class="widget-loading hide-if-no-js">' . __( 'Loading&#8230;' ) . '</p><p class="describe hide-if-js">' . __('This widget requires JavaScript.') . '</p>';}function wp_dashboard_secondary_control() {	wp_dashboard_rss_control( 'dashboard_secondary' );}/** * Display secondary dashboard RSS widget feed. * * @since unknown * * @return unknown */function wp_dashboard_secondary_output() {	$widgets = get_option( 'dashboard_widget_options' );	@extract( @$widgets['dashboard_secondary'], EXTR_SKIP );	$rss = @fetch_feed( $url );	if ( is_wp_error($rss) ) {		if ( is_admin() || current_user_can('manage_options') ) {			echo '<div class="rss-widget"><p>';			printf(__('<strong>RSS Error</strong>: %s'), $rss->get_error_message());			echo '</p></div>';		}	} elseif ( !$rss->get_item_quantity() ) {		$rss->__destruct();		unset($rss);		return false;	} else {		echo '<div class="rss-widget">';		wp_widget_rss_output( $rss, $widgets['dashboard_secondary'] );		echo '</div>';		$rss->__destruct();		unset($rss);	}}function wp_dashboard_plugins() {	echo '<p class="widget-loading hide-if-no-js">' . __( 'Loading&#8230;' ) . '</p><p class="describe hide-if-js">' . __('This widget requires JavaScript.') . '</p>';}/** * Display plugins most popular, newest plugins, and recently updated widget text. * * @since unknown */function wp_dashboard_plugins_output() {	$popular = fetch_feed( 'http://wordpress.org/extend/plugins/rss/browse/popular/' );	$new     = fetch_feed( 'http://wordpress.org/extend/plugins/rss/browse/new/' );	$updated = fetch_feed( 'http://wordpress.org/extend/plugins/rss/browse/updated/' );	if ( false === $plugin_slugs = get_transient( 'plugin_slugs' ) ) {		$plugin_slugs = array_keys( get_plugins() );		set_transient( 'plugin_slugs', $plugin_slugs, 86400 );	}	foreach ( array( 'popular' => __('Most Popular'), 'new' => __('Newest Plugins'), 'updated' => __('Recently Updated') ) as $feed => $label ) {		if ( is_wp_error($$feed) || !$$feed->get_item_quantity() )			continue;		$items = $$feed->get_items(0, 5);		// Pick a random, non-installed plugin		while ( true ) {			// Abort this foreach loop iteration if there's no plugins left of this type			if ( 0 == count($items) )				continue 2;			$item_key = array_rand($items);			$item = $items[$item_key];			list($link, $frag) = explode( '#', $item->get_link() );			$link = esc_url($link);			if ( preg_match( '|/([^/]+?)/?$|', $link, $matches ) )				$slug = $matches[1];			else {				unset( $items[$item_key] );				continue;			}			// Is this random plugin's slug already installed? If so, try again.			reset( $plugin_slugs );			foreach ( $plugin_slugs as $plugin_slug ) {				if ( $slug == substr( $plugin_slug, 0, strlen( $slug ) ) ) {					unset( $items[$item_key] );					continue 2;				}			}			// If we get to this point, then the random plugin isn't installed and we can stop the while().			break;		}		// Eliminate some common badly formed plugin descriptions		while ( ( null !== $item_key = array_rand($items) ) && false !== strpos( $items[$item_key]->get_description(), 'Plugin Name:' ) )			unset($items[$item_key]);		if ( !isset($items[$item_key]) )			continue;		// current bbPress feed item titles are: user on "topic title"		if ( preg_match( '/&quot;(.*)&quot;/s', $item->get_title(), $matches ) )			$title = $matches[1];		else // but let's make it forward compatible if things change			$title = $item->get_title();		$title = esc_html( $title );		$description = esc_html( strip_tags(@html_entity_decode($item->get_description(), ENT_QUOTES, get_option('blog_charset'))) );		$ilink = wp_nonce_url('plugin-install.php?tab=plugin-information&plugin=' . $slug, 'install-plugin_' . $slug) .							'&amp;TB_iframe=true&amp;width=600&amp;height=800';		echo "<h4>$label</h4>\n";		echo "<h5><a href='$link'>$title</a></h5>&nbsp;<span>(<a href='$ilink' class='thickbox' title='$title'>" . __( 'Install' ) . "</a>)</span>\n";		echo "<p>$description</p>\n";		$$feed->__destruct();		unset($$feed);	}}/** * Checks to see if all of the feed url in $check_urls are cached. * * If $check_urls is empty, look for the rss feed url found in the dashboard * widget optios of $widget_id. If cached, call $callback, a function that * echoes out output for this widget. If not cache, echo a "Loading..." stub * which is later replaced by AJAX call (see top of /wp-admin/index.php) * * @since unknown * * @param int $widget_id * @param callback $callback * @param array $check_urls RSS feeds * @return bool False on failure. True on success. */function wp_dashboard_cached_rss_widget( $widget_id, $callback, $check_urls = array() ) {	$loading = '<p class="widget-loading">' . __( 'Loading&#8230;' ) . '</p>';	if ( empty($check_urls) ) {		$widgets = get_option( 'dashboard_widget_options' );		if ( empty($widgets[$widget_id]['url']) ) {			echo $loading;			return false;		}		$check_urls = array( $widgets[$widget_id]['url'] );	}	include_once ABSPATH . WPINC . '/class-feed.php';	foreach ( $check_urls as $check_url ) {		$cache = new WP_Feed_Cache_Transient('', md5($check_url), '');		if ( ! $cache->load() ) {			echo $loading;			return false;		}	}	if ( $callback && is_callable( $callback ) ) {		$args = array_slice( func_get_args(), 2 );		array_unshift( $args, $widget_id );		call_user_func_array( $callback, $args );	}	return true;}/* Dashboard Widgets Controls */// Calls widget_control callback/** * Calls widget control callback. * * @since unknown * * @param int $widget_control_id Registered Widget ID. */function wp_dashboard_trigger_widget_control( $widget_control_id = false ) {	global $wp_dashboard_control_callbacks;	if ( is_scalar($widget_control_id) && $widget_control_id && isset($wp_dashboard_control_callbacks[$widget_control_id]) && is_callable($wp_dashboard_control_callbacks[$widget_control_id]) ) {		call_user_func( $wp_dashboard_control_callbacks[$widget_control_id], '', array( 'id' => $widget_control_id, 'callback' => $wp_dashboard_control_callbacks[$widget_control_id] ) );	}}/** * The RSS dashboard widget control. * * Sets up $args to be used as input to wp_widget_rss_form(). Handles POST data * from RSS-type widgets. * * @since unknown * * @param string widget_id * @param array form_inputs */function wp_dashboard_rss_control( $widget_id, $form_inputs = array() ) {	if ( !$widget_options = get_option( 'dashboard_widget_options' ) )		$widget_options = array();	if ( !isset($widget_options[$widget_id]) )		$widget_options[$widget_id] = array();	$number = 1; // Hack to use wp_widget_rss_form()	$widget_options[$widget_id]['number'] = $number;	if ( 'POST' == $_SERVER['REQUEST_METHOD'] && isset($_POST['widget-rss'][$number]) ) {		$_POST['widget-rss'][$number] = stripslashes_deep( $_POST['widget-rss'][$number] );		$widget_options[$widget_id] = wp_widget_rss_process( $_POST['widget-rss'][$number] );		// title is optional.  If black, fill it if possible		if ( !$widget_options[$widget_id]['title'] && isset($_POST['widget-rss'][$number]['title']) ) {			$rss = fetch_feed($widget_options[$widget_id]['url']);			if ( is_wp_error($rss) ) {				$widget_options[$widget_id]['title'] = htmlentities(__('Unknown Feed'));			} else {				$widget_options[$widget_id]['title'] = htmlentities(strip_tags($rss->get_title()));				$rss->__destruct();				unset($rss);			}		}		update_option( 'dashboard_widget_options', $widget_options );	}	wp_widget_rss_form( $widget_options[$widget_id], $form_inputs );}/** * Empty function usable by plugins to output empty dashboard widget (to be populated later by JS). */function wp_dashboard_empty() {}?>
<?php/** * Plugins administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( is_multisite() ) {	$menu_perms = get_site_option( 'menu_items', array() );	if ( empty($menu_perms['plugins']) && ! is_super_admin() )		wp_die( __( 'Cheatin&#8217; uh?' ) );	else if ( $menu_perms['plugins'] != 1 && is_super_admin() )		add_action( 'admin_notices', '_admin_notice_multisite_activate_plugins_page' );}if ( ! current_user_can( 'activate_plugins' ) )	wp_die( __( 'You do not have sufficient permissions to manage plugins for this site.' ) );if ( isset($_POST['clear-recent-list']) )	$action = 'clear-recent-list';elseif ( !empty($_REQUEST['action']) )	$action = $_REQUEST['action'];elseif ( !empty($_REQUEST['action2']) )	$action = $_REQUEST['action2'];else	$action = false;$plugin = isset($_REQUEST['plugin']) ? $_REQUEST['plugin'] : '';$default_status = get_user_option('plugins_last_view');if ( empty($default_status) )	$default_status = 'all';$status = isset($_REQUEST['plugin_status']) ? $_REQUEST['plugin_status'] : $default_status;if ( !in_array($status, array('all', 'active', 'inactive', 'recent', 'upgrade', 'network', 'mustuse', 'dropins', 'search')) )	$status = 'all';if ( $status != $default_status && 'search' != $status )	update_user_meta($current_user->ID, 'plugins_last_view', $status);$page = isset($_REQUEST['paged']) ? $_REQUEST['paged'] : 1;//Clean up request URI from temporary args for screen options/paging uri's to work as expected.$_SERVER['REQUEST_URI'] = remove_query_arg(array('error', 'deleted', 'activate', 'activate-multi', 'deactivate', 'deactivate-multi', '_error_nonce'), $_SERVER['REQUEST_URI']);if ( !empty($action) ) {	$network_wide = false;	if ( ( isset( $_GET['networkwide'] ) || 'network-activate-selected' == $action ) && is_multisite() && current_user_can( 'manage_network_plugins' ) )		$network_wide = true;	switch ( $action ) {		case 'activate':			if ( ! current_user_can('activate_plugins') )				wp_die(__('You do not have sufficient permissions to activate plugins for this site.'));			check_admin_referer('activate-plugin_' . $plugin);			$result = activate_plugin($plugin, 'plugins.php?error=true&plugin=' . $plugin, $network_wide);			if ( is_wp_error( $result ) ) {				if ( 'unexpected_output' == $result->get_error_code() ) {					$redirect = 'plugins.php?error=true&charsout=' . strlen($result->get_error_data()) . '&plugin=' . $plugin;					wp_redirect(add_query_arg('_error_nonce', wp_create_nonce('plugin-activation-error_' . $plugin), $redirect));					exit;				} else {					wp_die($result);				}			}			$recent = (array)get_option('recently_activated');			if ( isset($recent[ $plugin ]) ) {				unset($recent[ $plugin ]);				update_option('recently_activated', $recent);			}			if ( isset($_GET['from']) && 'import' == $_GET['from'] ) {				wp_redirect("import.php?import=" . str_replace('-importer', '', dirname($plugin)) ); // overrides the ?error=true one above and redirects to the Imports page, striping the -importer suffix			} else {				wp_redirect("plugins.php?activate=true&plugin_status=$status&paged=$page"); // overrides the ?error=true one above			}			exit;			break;		case 'activate-selected':		case 'network-activate-selected':			if ( ! current_user_can('activate_plugins') )				wp_die(__('You do not have sufficient permissions to activate plugins for this site.'));			check_admin_referer('bulk-manage-plugins');			$plugins = isset( $_POST['checked'] ) ? (array) $_POST['checked'] : array();			$plugins = array_filter($plugins, create_function('$plugin', 'return !is_plugin_active($plugin);') ); // Only activate plugins which are not already active.			if ( empty($plugins) ) {				wp_redirect("plugins.php?plugin_status=$status&paged=$page");				exit;			}			activate_plugins($plugins, 'plugins.php?error=true', $network_wide);			$recent = (array)get_option('recently_activated');			foreach ( $plugins as $plugin => $time)				if ( isset($recent[ $plugin ]) )					unset($recent[ $plugin ]);			update_option('recently_activated', $recent);			wp_redirect("plugins.php?activate-multi=true&plugin_status=$status&paged=$page");			exit;			break;		case 'update-selected' :			check_admin_referer( 'bulk-manage-plugins' );			if ( isset( $_GET['plugins'] ) )				$plugins = explode( ',', $_GET['plugins'] );			elseif ( isset( $_POST['checked'] ) )				$plugins = (array) $_POST['checked'];			else				$plugins = array();			$title = __( 'Upgrade Plugins' );			$parent_file = 'plugins.php';			require_once( './admin-header.php' );			echo '<div class="wrap">';			screen_icon();			echo '<h2>' . esc_html( $title ) . '</h2>';			$url = 'update.php?action=update-selected&amp;plugins=' . urlencode( join(',', $plugins) );			$url = wp_nonce_url($url, 'bulk-update-plugins');			echo "<iframe src='$url' style='width: 100%; height:100%; min-height:850px;'></iframe>";			echo '</div>';			require_once( './admin-footer.php' );			exit;			break;		case 'error_scrape':			if ( ! current_user_can('activate_plugins') )				wp_die(__('You do not have sufficient permissions to activate plugins for this site.'));			check_admin_referer('plugin-activation-error_' . $plugin);			$valid = validate_plugin($plugin);			if ( is_wp_error($valid) )				wp_die($valid);			if ( ! WP_DEBUG ) {				if ( defined('E_RECOVERABLE_ERROR') )					error_reporting(E_CORE_ERROR | E_CORE_WARNING | E_COMPILE_ERROR | E_ERROR | E_WARNING | E_PARSE | E_USER_ERROR | E_USER_WARNING | E_RECOVERABLE_ERROR);				else					error_reporting(E_CORE_ERROR | E_CORE_WARNING | E_COMPILE_ERROR | E_ERROR | E_WARNING | E_PARSE | E_USER_ERROR | E_USER_WARNING);			}			@ini_set('display_errors', true); //Ensure that Fatal errors are displayed.			// Go back to "sandbox" scope so we get the same errors as before			function plugin_sandbox_scrape( $plugin ) {				include( WP_PLUGIN_DIR . '/' . $plugin );			}			plugin_sandbox_scrape( $plugin );			do_action('activate_' . $plugin);			exit;			break;		case 'deactivate':			if ( ! current_user_can('activate_plugins') )				wp_die(__('You do not have sufficient permissions to deactivate plugins for this site.'));			check_admin_referer('deactivate-plugin_' . $plugin);			deactivate_plugins($plugin);			update_option('recently_activated', array($plugin => time()) + (array)get_option('recently_activated'));			if (headers_sent())				echo "<meta http-equiv='refresh' content='" . esc_attr( "0;url=plugins.php?deactivate=true&plugin_status=$status&paged=$page" ) . "' />";			else				wp_redirect("plugins.php?deactivate=true&plugin_status=$status&paged=$page");			exit;			break;		case 'deactivate-selected':			if ( ! current_user_can('activate_plugins') )				wp_die(__('You do not have sufficient permissions to deactivate plugins for this site.'));			check_admin_referer('bulk-manage-plugins');			$plugins = isset( $_POST['checked'] ) ? (array) $_POST['checked'] : array();			$plugins = array_filter($plugins, 'is_plugin_active'); //Do not deactivate plugins which are already deactivated.			if ( empty($plugins) ) {				wp_redirect("plugins.php?plugin_status=$status&paged=$page");				exit;			}			deactivate_plugins($plugins);			$deactivated = array();			foreach ( $plugins as $plugin )				$deactivated[ $plugin ] = time();			update_option('recently_activated', $deactivated + (array)get_option('recently_activated'));			wp_redirect("plugins.php?deactivate-multi=true&plugin_status=$status&paged=$page");			exit;			break;		case 'delete-selected':			if ( ! current_user_can('delete_plugins') )				wp_die(__('You do not have sufficient permissions to delete plugins for this site.'));			check_admin_referer('bulk-manage-plugins');			//$_POST = from the plugin form; $_GET = from the FTP details screen.			$plugins = isset( $_REQUEST['checked'] ) ? (array) $_REQUEST['checked'] : array();			$plugins = array_filter($plugins, create_function('$plugin', 'return !is_plugin_active($plugin);') ); //Do not allow to delete Activated plugins.			if ( empty($plugins) ) {				wp_redirect("plugins.php?plugin_status=$status&paged=$page");				exit;			}			include(ABSPATH . 'wp-admin/update.php');			$parent_file = 'plugins.php';			if ( ! isset($_REQUEST['verify-delete']) ) {				wp_enqueue_script('jquery');				require_once('./admin-header.php');				?>			<div class="wrap">				<?php					$files_to_delete = $plugin_info = array();					foreach ( (array) $plugins as $plugin ) {						if ( '.' == dirname($plugin) ) {							$files_to_delete[] = WP_PLUGIN_DIR . '/' . $plugin;							if( $data = get_plugin_data(WP_PLUGIN_DIR . '/' . $plugin) ) {								$plugin_info[ $plugin ] = $data;								$plugin_info[ $plugin ]['is_uninstallable'] = is_uninstallable_plugin( $plugin );							}						} else {							// Locate all the files in that folder							$files = list_files( WP_PLUGIN_DIR . '/' . dirname($plugin) );							if ( $files ) {								$files_to_delete = array_merge($files_to_delete, $files);							}							// Get plugins list from that folder							if ( $folder_plugins = get_plugins( '/' . dirname($plugin)) ) {								foreach( $folder_plugins as $plugin_file => $data ) {									$plugin_info[ $plugin_file ] = $data;									$plugin_info[ $plugin_file ]['is_uninstallable'] = is_uninstallable_plugin( $plugin );								}							}						}					}					screen_icon();					$plugins_to_delete = count( $plugin_info );					echo '<h2>' . _n( 'Delete Plugin', 'Delete Plugins', $plugins_to_delete ) . '</h2>';				?>				<p><?php echo _n( 'You are about to remove the following plugin:', 'You are about to remove the following plugins:', $plugins_to_delete ); ?></p>					<ul class="ul-disc">						<?php						$data_to_delete = false;						foreach ( $plugin_info as $plugin ) {							if ( $plugin['is_uninstallable'] ) {								/* translators: 1: plugin name, 2: plugin author */								echo '<li>', sprintf( __( '<strong>%1$s</strong> by <em>%2$s</em> (will also <strong>delete its data</strong>)' ), $plugin['Name'], $plugin['Author'] ), '</li>';								$data_to_delete = true;							} else {								/* translators: 1: plugin name, 2: plugin author */								echo '<li>', sprintf( __('<strong>%1$s</strong> by <em>%2$s</em>' ), $plugin['Name'], $plugin['Author'] ), '</li>';							}						}						?>					</ul>				<p><?php				if ( $data_to_delete )					_e('Are you sure you wish to delete these files and data?');				else					_e('Are you sure you wish to delete these files?');				?></p>				<form method="post" action="<?php echo esc_url($_SERVER['REQUEST_URI']); ?>" style="display:inline;">					<input type="hidden" name="verify-delete" value="1" />					<input type="hidden" name="action" value="delete-selected" />					<?php						foreach ( (array)$plugins as $plugin )							echo '<input type="hidden" name="checked[]" value="' . esc_attr($plugin) . '" />';					?>					<?php wp_nonce_field('bulk-manage-plugins') ?>					<input type="submit" name="submit" value="<?php $data_to_delete ? esc_attr_e('Yes, Delete these files and data') : esc_attr_e('Yes, Delete these files') ?>" class="button" />				</form>				<form method="post" action="<?php echo esc_url(wp_get_referer()); ?>" style="display:inline;">					<input type="submit" name="submit" value="<?php esc_attr_e('No, Return me to the plugin list') ?>" class="button" />				</form>				<p><a href="#" onclick="jQuery('#files-list').toggle(); return false;"><?php _e('Click to view entire list of files which will be deleted'); ?></a></p>				<div id="files-list" style="display:none;">					<ul class="code">					<?php						foreach ( (array)$files_to_delete as $file )							echo '<li>' . str_replace(WP_PLUGIN_DIR, '', $file) . '</li>';					?>					</ul>				</div>			</div>				<?php				require_once('./admin-footer.php');				exit;			} //Endif verify-delete			$delete_result = delete_plugins($plugins);			set_transient('plugins_delete_result_'.$user_ID, $delete_result); //Store the result in a cache rather than a URL param due to object type & length			wp_redirect("plugins.php?deleted=true&plugin_status=$status&paged=$page");			exit;			break;		case 'clear-recent-list':			update_option('recently_activated', array());			break;	}}wp_enqueue_script('plugin-install');add_thickbox();add_contextual_help($current_screen,	'<p>' . __('Plugins extend and expand the functionality of WordPress. Once a plugin is installed, you may activate it or deactivate it here.') . '</p>' .	'<p>' . sprintf(__('You can find additional plugins for your site by using the <a href="%1$s">Plugin Browser/Installer</a> functionality or by browsing the <a href="%2$s" target="_blank">WordPress Plugin Directory</a> directly and installing new plugins manually. To manually install a plugin you generally just need to upload the plugin file into your <code>/wp-content/plugins</code> directory. Once a plugin has been installed, you can activate it here.'), 'plugin-install.php', 'http://wordpress.org/extend/plugins/') . '</p>' .	'<p>' . __('Most of the time, plugins play nicely with the core of WordPress and with other plugins. Sometimes, though, a plugin&#8217;s code will get in the way of another plugin, causing compatibility issues. If your site starts doing strange things, this may be the problem. Try deactivating all your plugins and re-activating them in various combinations until you isolate which one(s) caused the issue.') . '</p>' .	'<p>' . sprintf( __('If something goes wrong with a plugin and you can&#8217;t use WordPress, delete or rename that file in the <code>%s</code> directory and it will be automatically deactivated.'), WP_PLUGIN_DIR) . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Managing_Plugins#Plugin_Management" target="_blank">Documentation on Managing Plugins</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');$title = __('Plugins');require_once('./admin-header.php');$invalid = validate_active_plugins();if ( !empty($invalid) )	foreach ( $invalid as $plugin_file => $error )		echo '<div id="message" class="error"><p>' . sprintf(__('The plugin <code>%s</code> has been <strong>deactivated</strong> due to an error: %s'), esc_html($plugin_file), $error->get_error_message()) . '</p></div>';?><?php if ( isset($_GET['error']) ) :	if ( isset($_GET['charsout']) )		$errmsg = sprintf(__('The plugin generated %d characters of <strong>unexpected output</strong> during activation.  If you notice &#8220;headers already sent&#8221; messages, problems with syndication feeds or other issues, try deactivating or removing this plugin.'), $_GET['charsout']);	else		$errmsg = __('Plugin could not be activated because it triggered a <strong>fatal error</strong>.');	?>	<div id="message" class="updated"><p><?php echo $errmsg; ?></p>	<?php		if ( !isset($_GET['charsout']) && wp_verify_nonce($_GET['_error_nonce'], 'plugin-activation-error_' . $plugin) ) { ?>	<iframe style="border:0" width="100%" height="70px" src="<?php echo admin_url('plugins.php?action=error_scrape&amp;plugin=' . esc_attr($plugin) . '&amp;_wpnonce=' . esc_attr($_GET['_error_nonce'])); ?>"></iframe>	<?php		}	?>	</div><?php elseif ( isset($_GET['deleted']) ) :		$delete_result = get_transient('plugins_delete_result_'.$user_ID);		delete_transient('plugins_delete_result'); //Delete it once we're done.		if ( is_wp_error($delete_result) ) : ?>		<div id="message" class="updated"><p><?php printf( __('Plugin could not be deleted due to an error: %s'), $delete_result->get_error_message() ); ?></p></div>		<?php else : ?>		<div id="message" class="updated"><p><?php _e('The selected plugins have been <strong>deleted</strong>.'); ?></p></div>		<?php endif; ?><?php elseif ( isset($_GET['activate']) ) : ?>	<div id="message" class="updated"><p><?php _e('Plugin <strong>activated</strong>.') ?></p></div><?php elseif (isset($_GET['activate-multi'])) : ?>	<div id="message" class="updated"><p><?php _e('Selected plugins <strong>activated</strong>.'); ?></p></div><?php elseif ( isset($_GET['deactivate']) ) : ?>	<div id="message" class="updated"><p><?php _e('Plugin <strong>deactivated</strong>.') ?></p></div><?php elseif (isset($_GET['deactivate-multi'])) : ?>	<div id="message" class="updated"><p><?php _e('Selected plugins <strong>deactivated</strong>.'); ?></p></div><?php elseif ( 'update-selected' == $action ) : ?>	<div id="message" class="updated"><p><?php _e('No out of date plugins were selected.'); ?></p></div><?php endif; ?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); if ( current_user_can('install_plugins') ) { ?> <a href="plugin-install.php" class="button add-new-h2"><?php echo esc_html_x('Add New', 'plugin'); ?></a><?php } ?></h2><?php$all_plugins = apply_filters( 'all_plugins', get_plugins() );$search_plugins = array();$active_plugins = array();$inactive_plugins = array();$recent_plugins = array();$recently_activated = get_option('recently_activated', array());$upgrade_plugins = array();$network_plugins = array();$mustuse_plugins = $dropins_plugins = array();if ( ! is_multisite() || current_user_can('manage_network_plugins') ) {	if ( apply_filters( 'show_advanced_plugins', true, 'mustuse' ) )		$mustuse_plugins = get_mu_plugins();	if ( apply_filters( 'show_advanced_plugins', true, 'dropins' ) )		$dropins_plugins = get_dropins();}set_transient( 'plugin_slugs', array_keys($all_plugins), 86400 );// Clean out any plugins which were deactivated over a week ago.foreach ( $recently_activated as $key => $time )	if ( $time + (7*24*60*60) < time() ) //1 week		unset($recently_activated[ $key ]);if ( $recently_activated != get_option('recently_activated') ) //If array changed, update it.	update_option('recently_activated', $recently_activated);$current = get_site_transient( 'update_plugins' );foreach ( array( 'all_plugins', 'mustuse_plugins', 'dropins_plugins' ) as $plugin_array_name) {	foreach ( (array) $$plugin_array_name as $plugin_file => $plugin_data ) {		// Translate, Apply Markup, Sanitize HTML		$plugin_data = _get_plugin_data_markup_translate($plugin_file, $plugin_data, false, true);		${$plugin_array_name}[ $plugin_file ] = $plugin_data;	}}unset( $plugin_array_name );foreach ( (array) $all_plugins as $plugin_file => $plugin_data) {	// Filter into individual sections	if ( is_multisite() && is_network_only_plugin( $plugin_file ) && !current_user_can( 'manage_network_plugins' ) ) {		unset( $all_plugins[ $plugin_file ] );		continue;	} elseif ( is_plugin_active_for_network($plugin_file) ) {		$network_plugins[ $plugin_file ] = $plugin_data;	} elseif ( is_plugin_active($plugin_file) ) {		$active_plugins[ $plugin_file ] = $plugin_data;	} else {		if ( isset( $recently_activated[ $plugin_file ] ) ) // Was the plugin recently activated?			$recent_plugins[ $plugin_file ] = $plugin_data;		$inactive_plugins[ $plugin_file ] = $plugin_data;	}	if ( isset( $current->response[ $plugin_file ] ) )		$upgrade_plugins[ $plugin_file ] = $plugin_data;}if ( !current_user_can('update_plugins') )	$upgrade_plugins = array();$total_all_plugins = count($all_plugins);$total_inactive_plugins = count($inactive_plugins);$total_active_plugins = count($active_plugins);$total_recent_plugins = count($recent_plugins);$total_upgrade_plugins = count($upgrade_plugins);$total_network_plugins = count($network_plugins);$total_mustuse_plugins = count($mustuse_plugins);$total_dropins_plugins = count($dropins_plugins);// Searching.if ( !empty($_GET['s']) ) {	function _search_plugins_filter_callback($plugin) {		static $term;		if ( is_null($term) )			$term = stripslashes($_GET['s']);		if ( 	stripos($plugin['Name'], $term) !== false ||				stripos($plugin['Description'], $term) !== false ||				stripos($plugin['Author'], $term) !== false ||				stripos($plugin['PluginURI'], $term) !== false ||				stripos($plugin['AuthorURI'], $term) !== false ||				stripos($plugin['Version'], $term) !== false )			return true;		else			return false;	}	$status = 'search';	$search_plugins = array_filter($all_plugins, '_search_plugins_filter_callback');	$total_search_plugins = count($search_plugins);}$plugin_array_name = "${status}_plugins";if ( empty($$plugin_array_name) && !in_array($status, array('all', 'search')) ) {	$status = 'all';	$plugin_array_name = "${status}_plugins";}$plugins = &$$plugin_array_name;// Paging.$total_this_page = "total_{$status}_plugins";$total_this_page = $$total_this_page;$plugins_per_page = (int) get_user_option( 'plugins_per_page' );if ( empty( $plugins_per_page ) || $plugins_per_page < 1 )	$plugins_per_page = 999;$plugins_per_page = apply_filters( 'plugins_per_page', $plugins_per_page );$start = ($page - 1) * $plugins_per_page;$page_links = paginate_links( array(	'base' => add_query_arg( 'paged', '%#%' ),	'format' => '',	'prev_text' => __('&laquo;'),	'next_text' => __('&raquo;'),	'total' => ceil($total_this_page / $plugins_per_page),	'current' => $page));$page_links_text = sprintf( '<span class="displaying-num">' . __( 'Displaying %s&#8211;%s of %s' ) . '</span>%s',	number_format_i18n( $start + 1 ),	number_format_i18n( min( $page * $plugins_per_page, $total_this_page ) ),	'<span class="total-type-count">' . number_format_i18n( $total_this_page ) . '</span>',	$page_links);/** * @ignore * * @param array $plugins * @param string $context */function print_plugins_table($plugins, $context = '') {	global $page;	$checkbox = ! in_array( $context, array( 'mustuse', 'dropins' ) ) ? '<input type="checkbox" />' : '';?><table class="widefat" cellspacing="0" id="<?php echo $context ?>-plugins-table">	<thead>	<tr>		<th scope="col" class="manage-column check-column"><?php echo $checkbox; ?></th>		<th scope="col" class="manage-column"><?php _e('Plugin'); ?></th>		<th scope="col" class="manage-column"><?php _e('Description'); ?></th>	</tr>	</thead>	<tfoot>	<tr>		<th scope="col" class="manage-column check-column"><?php echo $checkbox; ?></th>		<th scope="col" class="manage-column"><?php _e('Plugin'); ?></th>		<th scope="col" class="manage-column"><?php _e('Description'); ?></th>	</tr>	</tfoot>	<tbody class="plugins"><?php	if ( empty($plugins) ) {		echo '<tr>			<td colspan="3">' . __('No plugins to show') . '</td>		</tr>';	}	foreach ( (array)$plugins as $plugin_file => $plugin_data) {		// preorder		$actions = array(			'network_deactivate' => '', 'deactivate' => '',			'network_only' => '', 'activate' => '',			'network_activate' => '',			'edit' => '',			'delete' => '',		);		if ( 'mustuse' == $context ) {			$is_active = true;		} elseif ( 'dropins' == $context ) {			$dropins = _get_dropins();			$plugin_name = $plugin_file;			if ( $plugin_file != $plugin_data['Name'] )				$plugin_name .= '<br/>' . $plugin_data['Name'];			if ( true === ( $dropins[ $plugin_file ][1] ) ) { // Doesn't require a constant				$is_active = true;				$description = '<p><strong>' . $dropins[ $plugin_file ][0] . '</strong></p>';			} elseif ( constant( $dropins[ $plugin_file ][1] ) ) { // Constant is true				$is_active = true;				$description = '<p><strong>' . $dropins[ $plugin_file ][0] . '</strong></p>';			} else {				$is_active = false;				$description = '<strong>' . $dropins[ $plugin_file ][0] . ' <span class="attention">' . __('Inactive:') . '</span></strong> ' . sprintf( __( 'Requires <code>%s</code> in <code>wp-config.php</code>.' ), "define('" . $dropins[ $plugin_file ][1] . "', true);" ) . '</p>';			}			$description .= '<p>' . $plugin_data['Description'] . '</p>';		} else {			$is_active_for_network = is_plugin_active_for_network($plugin_file);			$is_active = $is_active_for_network || is_plugin_active( $plugin_file );			if ( $is_active_for_network && !is_super_admin() )				continue;			if ( $is_active ) {				if ( $is_active_for_network ) {					if ( is_super_admin() )						$actions['network_deactivate'] = '<a href="' . wp_nonce_url('plugins.php?action=deactivate&amp;networkwide=1&amp;plugin=' . $plugin_file . '&amp;plugin_status=' . $context . '&amp;paged=' . $page, 'deactivate-plugin_' . $plugin_file) . '" title="' . __('Deactivate this plugin') . '">' . __('Network Deactivate') . '</a>';				} else {					$actions['deactivate'] = '<a href="' . wp_nonce_url('plugins.php?action=deactivate&amp;plugin=' . $plugin_file . '&amp;plugin_status=' . $context . '&amp;paged=' . $page, 'deactivate-plugin_' . $plugin_file) . '" title="' . __('Deactivate this plugin') . '">' . __('Deactivate') . '</a>';				}			} else {				if ( is_multisite() && is_network_only_plugin( $plugin_file ) )					$actions['network_only'] = '<span title="' . __('This plugin can only be activated for all sites in a network') . '">' . __('Network Only') . '</span>';				else					$actions['activate'] = '<a href="' . wp_nonce_url('plugins.php?action=activate&amp;plugin=' . $plugin_file . '&amp;plugin_status=' . $context . '&amp;paged=' . $page, 'activate-plugin_' . $plugin_file) . '" title="' . __('Activate this plugin') . '" class="edit">' . __('Activate') . '</a>';				if ( is_multisite() && current_user_can( 'manage_network_plugins' ) )					$actions['network_activate'] = '<a href="' . wp_nonce_url('plugins.php?action=activate&amp;networkwide=1&amp;plugin=' . $plugin_file . '&amp;plugin_status=' . $context . '&amp;paged=' . $page, 'activate-plugin_' . $plugin_file) . '" title="' . __('Activate this plugin for all sites in this network') . '" class="edit">' . __('Network Activate') . '</a>';				if ( current_user_can('delete_plugins') )					$actions['delete'] = '<a href="' . wp_nonce_url('plugins.php?action=delete-selected&amp;checked[]=' . $plugin_file . '&amp;plugin_status=' . $context . '&amp;paged=' . $page, 'bulk-manage-plugins') . '" title="' . __('Delete this plugin') . '" class="delete">' . __('Delete') . '</a>';			} // end if $is_active			if ( current_user_can('edit_plugins') && is_writable(WP_PLUGIN_DIR . '/' . $plugin_file) )				$actions['edit'] = '<a href="plugin-editor.php?file=' . $plugin_file . '" title="' . __('Open this file in the Plugin Editor') . '" class="edit">' . __('Edit') . '</a>';		} // end if $context		$actions = apply_filters( 'plugin_action_links', array_filter( $actions ), $plugin_file, $plugin_data, $context );		$actions = apply_filters( "plugin_action_links_$plugin_file", $actions, $plugin_file, $plugin_data, $context );		$class = $is_active ? 'active' : 'inactive';		$checkbox = in_array( $context, array( 'mustuse', 'dropins' ) ) ? '' : "<input type='checkbox' name='checked[]' value='" . esc_attr($plugin_file) . "' />";		if ( 'dropins' != $context ) {			$description = '<p>' . $plugin_data['Description'] . '</p>';			$plugin_name = $plugin_data['Name'];		}		echo "	<tr class='$class'>		<th scope='row' class='check-column'>$checkbox</th>		<td class='plugin-title'><strong>$plugin_name</strong></td>		<td class='desc'>$description</td>	</tr>	<tr class='$class second'>		<td></td>		<td class='plugin-title'>";		echo '<div class="row-actions-visible">';		foreach ( $actions as $action => $link ) {			$sep = end($actions) == $link ? '' : ' | ';			echo "<span class='$action'>$link$sep</span>";		}		echo "</div></td>		<td class='desc'>";		$plugin_meta = array();		if ( !empty($plugin_data['Version']) )			$plugin_meta[] = sprintf(__('Version %s'), $plugin_data['Version']);		if ( !empty($plugin_data['Author']) ) {			$author = $plugin_data['Author'];			if ( !empty($plugin_data['AuthorURI']) )				$author = '<a href="' . $plugin_data['AuthorURI'] . '" title="' . __( 'Visit author homepage' ) . '">' . $plugin_data['Author'] . '</a>';			$plugin_meta[] = sprintf( __('By %s'), $author );		}		if ( ! empty($plugin_data['PluginURI']) )			$plugin_meta[] = '<a href="' . $plugin_data['PluginURI'] . '" title="' . __( 'Visit plugin site' ) . '">' . __('Visit plugin site') . '</a>';		$plugin_meta = apply_filters('plugin_row_meta', $plugin_meta, $plugin_file, $plugin_data, $context);		echo implode(' | ', $plugin_meta);		echo "</td>	</tr>\n";		do_action( 'after_plugin_row', $plugin_file, $plugin_data, $context );		do_action( "after_plugin_row_$plugin_file", $plugin_file, $plugin_data, $context );	}?>	</tbody></table><?php} //End print_plugins_table()/** * @ignore * * @param string $context */function print_plugin_actions($context, $field_name = 'action' ) {	if ( in_array( $context, array( 'mustuse', 'dropins' ) ) )		return;?>	<div class="alignleft actions">		<select name="<?php echo $field_name; ?>">			<option value="" selected="selected"><?php _e('Bulk Actions'); ?></option>	<?php if ( 'active' != $context ) : ?>			<option value="activate-selected"><?php _e('Activate'); ?></option>	<?php endif; ?>	<?php if ( is_multisite() && 'network' != $context ) : ?>			<option value="network-activate-selected"><?php _e('Network Activate'); ?></option>	<?php endif; ?>	<?php if ( 'inactive' != $context && 'recent' != $context ) : ?>			<option value="deactivate-selected"><?php _e('Deactivate'); ?></option>	<?php endif; ?>	<?php if ( current_user_can( 'update_plugins' ) ) : ?>			<option value="update-selected"><?php _e( 'Upgrade' ); ?></option>	<?php endif; ?>	<?php if ( current_user_can('delete_plugins') && ( 'active' != $context ) ) : ?>			<option value="delete-selected"><?php _e('Delete'); ?></option>	<?php endif; ?>		</select>		<input type="submit" name="doaction_active" value="<?php esc_attr_e('Apply'); ?>" class="button-secondary action" />	<?php if ( 'recent' == $context ) : ?>		<input type="submit" name="clear-recent-list" value="<?php esc_attr_e('Clear List') ?>" class="button-secondary" />	<?php endif; ?>	</div><?php}?><form method="get" action=""><p class="search-box">	<label class="screen-reader-text" for="plugin-search-input"><?php _e( 'Search Plugins' ); ?>:</label>	<input type="text" id="plugin-search-input" name="s" value="<?php _admin_search_query(); ?>" />	<input type="submit" value="<?php esc_attr_e( 'Search Installed Plugins' ); ?>" class="button" /></p></form><?php do_action( 'pre_current_active_plugins', $all_plugins ) ?><form method="post" action="<?php echo admin_url('plugins.php') ?>"><?php wp_nonce_field('bulk-manage-plugins') ?><input type="hidden" name="plugin_status" value="<?php echo esc_attr($status) ?>" /><input type="hidden" name="paged" value="<?php echo esc_attr($page) ?>" /><ul class="subsubsub"><?php$status_links = array();$class = ( 'all' == $status ) ? ' class="current"' : '';$status_links[] = "<li><a href='plugins.php?plugin_status=all' $class>" . sprintf( _nx( 'All <span class="count">(%s)</span>', 'All <span class="count">(%s)</span>', $total_all_plugins, 'plugins' ), number_format_i18n( $total_all_plugins ) ) . '</a>';if ( ! empty($active_plugins) ) {	$class = ( 'active' == $status ) ? ' class="current"' : '';	$status_links[] = "<li><a href='plugins.php?plugin_status=active' $class>" . sprintf( _n( 'Active <span class="count">(%s)</span>', 'Active <span class="count">(%s)</span>', $total_active_plugins ), number_format_i18n( $total_active_plugins ) ) . '</a>';}if ( ! empty($recent_plugins) ) {	$class = ( 'recent' == $status ) ? ' class="current"' : '';	$status_links[] = "<li><a href='plugins.php?plugin_status=recent' $class>" . sprintf( _n( 'Recently Active <span class="count">(%s)</span>', 'Recently Active <span class="count">(%s)</span>', $total_recent_plugins ), number_format_i18n( $total_recent_plugins ) ) . '</a>';}if ( ! empty($inactive_plugins) ) {	$class = ( 'inactive' == $status ) ? ' class="current"' : '';	$status_links[] = "<li><a href='plugins.php?plugin_status=inactive' $class>" . sprintf( _n( 'Inactive <span class="count">(%s)</span>', 'Inactive <span class="count">(%s)</span>', $total_inactive_plugins ), number_format_i18n( $total_inactive_plugins ) ) . '</a>';}if ( ! empty($network_plugins) ) {	$class = ( 'network' == $status ) ? ' class="current"' : '';	$status_links[] = "<li><a href='plugins.php?plugin_status=network' $class>" . sprintf( _n( 'Network <span class="count">(%s)</span>', 'Network <span class="count">(%s)</span>', $total_network_plugins ), number_format_i18n( $total_network_plugins ) ) . '</a>';}if ( ! empty($mustuse_plugins) ) {	$class = ( 'mustuse' == $status ) ? ' class="current"' : '';	$status_links[] = "<li><a href='plugins.php?plugin_status=mustuse' $class>" . sprintf( _n( 'Must-Use <span class="count">(%s)</span>', 'Must-Use <span class="count">(%s)</span>', $total_mustuse_plugins ), number_format_i18n( $total_mustuse_plugins ) ) . '</a>';}if ( ! empty($dropins_plugins) ) {	$class = ( 'dropins' == $status ) ? ' class="current"' : '';	$status_links[] = "<li><a href='plugins.php?plugin_status=dropins' $class>" . sprintf( _n( 'Drop-ins <span class="count">(%s)</span>', 'Drop-ins <span class="count">(%s)</span>', $total_dropins_plugins ), number_format_i18n( $total_dropins_plugins ) ) . '</a>';}if ( ! empty($upgrade_plugins) ) {	$class = ( 'upgrade' == $status ) ? ' class="current"' : '';	$status_links[] = "<li><a href='plugins.php?plugin_status=upgrade' $class>" . sprintf( _n( 'Upgrade Available <span class="count">(%s)</span>', 'Upgrade Available <span class="count">(%s)</span>', $total_upgrade_plugins ), number_format_i18n( $total_upgrade_plugins ) ) . '</a>';}if ( ! empty($search_plugins) ) {	$class = ( 'search' == $status ) ? ' class="current"' : '';	$term = isset($_REQUEST['s']) ? urlencode(stripslashes($_REQUEST['s'])) : '';	$status_links[] = "<li><a href='plugins.php?s=$term' $class>" . sprintf( _n( 'Search Results <span class="count">(%s)</span>', 'Search Results <span class="count">(%s)</span>', $total_search_plugins ), number_format_i18n( $total_search_plugins ) ) . '</a>';}echo implode( " |</li>\n", $status_links ) . '</li>';unset( $status_links );?></ul><?phpif ( 'mustuse' == $status )	echo '<div class="clear"><p>' . __( 'Files in the <code>/wp-content/mu-plugins</code> directory are executed automatically.' ) . '</p>';elseif ( 'dropins' == $status )	echo '<div class="clear"><p>' . __( 'Drop-ins are advanced plugins in the <code>/wp-content</code> directory that replace WordPress functionality when present.' ) . '</p>';if ( !empty( $plugins ) && ( ! in_array( $status, array( 'mustuse', 'dropins' ) ) || $page_links ) ) :?><div class="tablenav"><?phpif ( $page_links )	echo '<div class="tablenav-pages">', $page_links_text, '</div>';print_plugin_actions($status);?></div><div class="clear"></div><?phpendif;if ( $total_this_page > $plugins_per_page )	$plugins = array_slice($plugins, $start, $plugins_per_page);print_plugins_table($plugins, $status);if ( !empty( $plugins ) && ! in_array( $status, array( 'mustuse', 'dropins' ) ) || $page_links ) {?><div class="tablenav"><?phpif ( $page_links )	echo "<div class='tablenav-pages'>$page_links_text</div>";print_plugin_actions($status, "action2");?></div><?php } elseif ( ! empty( $all_plugins ) ) { ?><p><?php __( 'No plugins found.' ); ?></p><?php } ?></form><?php if ( empty($all_plugins) ) : ?><br class="clear" /><p><?php _e('You do not appear to have any plugins available at this time.') ?></p><?php endif; ?></div><?phpinclude('./admin-footer.php');?>
<?php/** * WordPress Query API * * The query API attempts to get which part of WordPress to the user is on. It * also provides functionality to getting URL query information. * * @link http://codex.wordpress.org/The_Loop More information on The Loop. * * @package WordPress * @subpackage Query *//** * Retrieve variable in the WP_Query class. * * @see WP_Query::get() * @since 1.5.0 * @uses $wp_query * * @param string $var The variable key to retrieve. * @return mixed */function get_query_var($var) {	global $wp_query;	return $wp_query->get($var);}/** * Set query variable. * * @see WP_Query::set() * @since 2.2.0 * @uses $wp_query * * @param string $var Query variable key. * @param mixed $value * @return null */function set_query_var($var, $value) {	global $wp_query;	return $wp_query->set($var, $value);}/** * Set up The Loop with query parameters. * * This will override the current WordPress Loop and shouldn't be used more than * once. This must not be used within the WordPress Loop. * * @since 1.5.0 * @uses $wp_query * * @param string $query * @return array List of posts */function &query_posts($query) {	unset($GLOBALS['wp_query']);	$GLOBALS['wp_query'] =& new WP_Query();	return $GLOBALS['wp_query']->query($query);}/** * Destroy the previous query and set up a new query. * * This should be used after {@link query_posts()} and before another {@link * query_posts()}. This will remove obscure bugs that occur when the previous * wp_query object is not destroyed properly before another is set up. * * @since 2.3.0 * @uses $wp_query */function wp_reset_query() {	unset($GLOBALS['wp_query']);	$GLOBALS['wp_query'] =& $GLOBALS['wp_the_query'];	wp_reset_postdata();}/** * After looping through a separate query, this function restores * the $post global to the current post in the main query * * @since 3.0.0 * @uses $wp_query */function wp_reset_postdata() {	global $wp_query;	if ( !empty($wp_query->post) ) {		$GLOBALS['post'] = $wp_query->post;		setup_postdata($wp_query->post);	}}/* * Query type checks. *//** * Is query requesting an archive page. * * @since 1.5.0 * @uses $wp_query * * @return bool True if page is archive. */function is_archive() {	global $wp_query;	return $wp_query->is_archive;}/** * Is query requesting an attachment page. * * @since 2.0.0 * @uses $wp_query * * @return bool True if page is attachment. */function is_attachment() {	global $wp_query;	return $wp_query->is_attachment;}/** * Is query requesting an author page. * * If the $author parameter is specified then the check will be expanded to * include whether the queried author matches the one given in the parameter. * You can match against integers and against strings. * * If matching against an integer, the ID should be used of the author for the * test. If the $author is an ID and matches the author page user ID, then * 'true' will be returned. * * If matching against strings, then the test will be matched against both the * nickname and user nicename and will return true on success. * * @since 1.5.0 * @uses $wp_query * * @param string|int $author Optional. Is current page this author. * @return bool True if page is author or $author (if set). */function is_author($author = '') {	global $wp_query;	if ( !$wp_query->is_author )		return false;	if ( empty($author) )		return true;	$author_obj = $wp_query->get_queried_object();	$author = (array) $author;	if ( in_array( $author_obj->ID, $author ) )		return true;	elseif ( in_array( $author_obj->nickname, $author ) )		return true;	elseif ( in_array( $author_obj->user_nicename, $author ) )		return true;	return false;}/** * Whether current page query contains a category name or given category name. * * The category list can contain category IDs, names, or category slugs. If any * of them are part of the query, then it will return true. * * @since 1.5.0 * @uses $wp_query * * @param string|array $category Optional. * @return bool */function is_category($category = '') {	global $wp_query;	if ( !$wp_query->is_category )		return false;	if ( empty($category) )		return true;	$cat_obj = $wp_query->get_queried_object();	$category = (array) $category;	if ( in_array( $cat_obj->term_id, $category ) )		return true;	elseif ( in_array( $cat_obj->name, $category ) )		return true;	elseif ( in_array( $cat_obj->slug, $category ) )		return true;	return false;}/** * Whether the current page query has the given tag slug or contains tag. * * @since 2.3.0 * @uses $wp_query * * @param string|array $slug Optional. Single tag or list of tags to check for. * @return bool */function is_tag( $slug = '' ) {	global $wp_query;	if ( !$wp_query->is_tag )		return false;	if ( empty( $slug ) )		return true;	$tag_obj = $wp_query->get_queried_object();	$slug = (array) $slug;	if ( in_array( $tag_obj->slug, $slug ) )		return true;	return false;}/** * Whether the current query is for the given taxonomy and/or term. * * If no taxonomy argument is set, returns true if any taxonomy is queried. * If the taxonomy argument is passed but no term argument, returns true *    if the taxonomy or taxonomies in the argument are being queried. * If both taxonomy and term arguments are passed, returns true *    if the current query is for a term contained in the terms argument *    which has a taxonomy contained in the taxonomy argument. * * @since 2.5.0 * @uses $wp_query * * @param string|array $taxonomy Optional. Taxonomy slug or slugs to check in current query. * @param int|array|string $term. Optional. A single or array of, The term's ID, Name or Slug * @return bool */function is_tax( $taxonomy = '', $term = '' ) {	global $wp_query, $wp_taxonomies;	$queried_object = $wp_query->get_queried_object();	$tax_array = array_intersect(array_keys($wp_taxonomies), (array) $taxonomy);	$term_array = (array) $term;	if ( !$wp_query->is_tax )		return false;	if ( empty( $taxonomy ) )		return true;	if ( empty( $term ) ) // Only a Taxonomy provided		return isset($queried_object->taxonomy) && count( $tax_array ) && in_array($queried_object->taxonomy, $tax_array);	return isset($queried_object->term_id) &&			count(array_intersect(				array($queried_object->term_id, $queried_object->name, $queried_object->slug),				$term_array			));}/** * Whether the current URL is within the comments popup window. * * @since 1.5.0 * @uses $wp_query * * @return bool */function is_comments_popup() {	global $wp_query;	return $wp_query->is_comments_popup;}/** * Whether current URL is based on a date. * * @since 1.5.0 * @uses $wp_query * * @return bool */function is_date() {	global $wp_query;	return $wp_query->is_date;}/** * Whether current blog URL contains a day. * * @since 1.5.0 * @uses $wp_query * * @return bool */function is_day() {	global $wp_query;	return $wp_query->is_day;}/** * Whether current page query is feed URL. * * @since 1.5.0 * @uses $wp_query * * @return bool */function is_feed() {	global $wp_query;	return $wp_query->is_feed;}/** * Whether current page query is comment feed URL. * * @since 3.0.0 * @uses $wp_query * * @return bool */function is_comment_feed() {	global $wp_query;	return $wp_query->is_comment_feed;}/** * Whether current page query is the front of the site. * * @since 2.5.0 * @uses is_home() * @uses get_option() * * @return bool True, if front of site. */function is_front_page() {	// most likely case	if ( 'posts' == get_option('show_on_front') && is_home() )		return true;	elseif ( 'page' == get_option('show_on_front') && get_option('page_on_front') && is_page(get_option('page_on_front')) )		return true;	else		return false;}/** * Whether current page view is the blog homepage. * * This is the page which is showing the time based blog content of your site * so if you set a static page for the front page of your site then this will * only be true on the page which you set as the "Posts page" in Reading Settings. * * @since 1.5.0 * @uses $wp_query * * @return bool True if blog view homepage. */function is_home() {	global $wp_query;	return $wp_query->is_home;}/** * Whether current page query contains a month. * * @since 1.5.0 * @uses $wp_query * * @return bool */function is_month() {	global $wp_query;	return $wp_query->is_month;}/** * Whether query is page or contains given page(s). * * Calls the function without any parameters will only test whether the current * query is of the page type. Either a list or a single item can be tested * against for whether the query is a page and also is the value or one of the * values in the page parameter. * * The parameter can contain the page ID, page title, or page name. The * parameter can also be an array of those three values. * * @since 1.5.0 * @uses $wp_query * * @param mixed $page Either page or list of pages to test against. * @return bool */function is_page($page = '') {	global $wp_query;	if ( !$wp_query->is_page )		return false;	if ( empty($page) )		return true;	$page_obj = $wp_query->get_queried_object();	$page = (array) $page;	if ( in_array( $page_obj->ID, $page ) )		return true;	elseif ( in_array( $page_obj->post_title, $page ) )		return true;	else if ( in_array( $page_obj->post_name, $page ) )		return true;	return false;}/** * Whether query contains multiple pages for the results. * * @since 1.5.0 * @uses $wp_query * * @return bool */function is_paged() {	global $wp_query;	return $wp_query->is_paged;}/** * Whether the current page was created by a plugin. * * The plugin can set this by using the global $plugin_page and setting it to * true. * * @since 1.5.0 * @global bool $plugin_page Used by plugins to tell the query that current is a plugin page. * * @return bool */function is_plugin_page() {	global $plugin_page;	if ( isset($plugin_page) )		return true;	return false;}/** * Whether the current query is preview of post or page. * * @since 2.0.0 * @uses $wp_query * * @return bool */function is_preview() {	global $wp_query;	return $wp_query->is_preview;}/** * Whether the current query post is robots. * * @since 2.1.0 * @uses $wp_query * * @return bool */function is_robots() {	global $wp_query;	return $wp_query->is_robots;}/** * Whether current query is the result of a user search. * * @since 1.5.0 * @uses $wp_query * * @return bool */function is_search() {	global $wp_query;	return $wp_query->is_search;}/** * Whether the current page query is single page. * * The parameter can contain the post ID, post title, or post name. The * parameter can also be an array of those three values. * * This applies to other post types, attachments, pages, posts. Just means that * the current query has only a single object. * * @since 1.5.0 * @uses $wp_query * * @param mixed $post Either post or list of posts to test against. * @return bool */function is_single($post = '') {	global $wp_query;	if ( !$wp_query->is_single )		return false;	if ( empty($post) )		return true;	$post_obj = $wp_query->get_queried_object();	$post = (array) $post;	if ( in_array( $post_obj->ID, $post ) )		return true;	elseif ( in_array( $post_obj->post_title, $post ) )		return true;	elseif ( in_array( $post_obj->post_name, $post ) )		return true;	return false;}/** * Whether is single post, is a page, or is an attachment. * * @since 1.5.0 * @uses $wp_query * * @param string|array $post_types Optional. Post type or types to check in current query. * @return bool */function is_singular($post_types = '') {	global $wp_query;	if ( empty($post_types) || !$wp_query->is_singular )		return $wp_query->is_singular;	$post_obj = $wp_query->get_queried_object();	return in_array($post_obj->post_type, (array) $post_types);}/** * Whether the query contains a time. * * @since 1.5.0 * @uses $wp_query * * @return bool */function is_time() {	global $wp_query;	return $wp_query->is_time;}/** * Whether the query is a trackback. * * @since 1.5.0 * @uses $wp_query * * @return bool */function is_trackback() {	global $wp_query;	return $wp_query->is_trackback;}/** * Whether the query contains a year. * * @since 1.5.0 * @uses $wp_query * * @return bool */function is_year() {	global $wp_query;	return $wp_query->is_year;}/** * Whether current page query is a 404 and no results for WordPress query. * * @since 1.5.0 * @uses $wp_query * * @return bool True, if nothing is found matching WordPress Query. */function is_404() {	global $wp_query;	return $wp_query->is_404;}/* * The Loop.  Post loop control. *//** * Whether current WordPress query has results to loop over. * * @see WP_Query::have_posts() * @since 1.5.0 * @uses $wp_query * * @return bool */function have_posts() {	global $wp_query;	return $wp_query->have_posts();}/** * Whether the caller is in the Loop. * * @since 2.0.0 * @uses $wp_query * * @return bool True if caller is within loop, false if loop hasn't started or ended. */function in_the_loop() {	global $wp_query;	return $wp_query->in_the_loop;}/** * Rewind the loop posts. * * @see WP_Query::rewind_posts() * @since 1.5.0 * @uses $wp_query * * @return null */function rewind_posts() {	global $wp_query;	return $wp_query->rewind_posts();}/** * Iterate the post index in the loop. * * @see WP_Query::the_post() * @since 1.5.0 * @uses $wp_query */function the_post() {	global $wp_query;	$wp_query->the_post();}/* * Comments loop. *//** * Whether there are comments to loop over. * * @see WP_Query::have_comments() * @since 2.2.0 * @uses $wp_query * * @return bool */function have_comments() {	global $wp_query;	return $wp_query->have_comments();}/** * Iterate comment index in the comment loop. * * @see WP_Query::the_comment() * @since 2.2.0 * @uses $wp_query * * @return object */function the_comment() {	global $wp_query;	return $wp_query->the_comment();}/* * WP_Query *//** * The WordPress Query class. * * @link http://codex.wordpress.org/Function_Reference/WP_Query Codex page. * * @since 1.5.0 */class WP_Query {	/**	 * Query string	 *	 * @since 1.5.0	 * @access public	 * @var string	 */	var $query;	/**	 * Query search variables set by the user.	 *	 * @since 1.5.0	 * @access public	 * @var array	 */	var $query_vars = array();	/**	 * Holds the data for a single object that is queried.	 *	 * Holds the contents of a post, page, category, attachment.	 *	 * @since 1.5.0	 * @access public	 * @var object|array	 */	var $queried_object;	/**	 * The ID of the queried object.	 *	 * @since 1.5.0	 * @access public	 * @var int	 */	var $queried_object_id;	/**	 * Get post database query.	 *	 * @since 2.0.1	 * @access public	 * @var string	 */	var $request;	/**	 * List of posts.	 *	 * @since 1.5.0	 * @access public	 * @var array	 */	var $posts;	/**	 * The amount of posts for the current query.	 *	 * @since 1.5.0	 * @access public	 * @var int	 */	var $post_count = 0;	/**	 * Index of the current item in the loop.	 *	 * @since 1.5.0	 * @access public	 * @var int	 */	var $current_post = -1;	/**	 * Whether the loop has started and the caller is in the loop.	 *	 * @since 2.0.0	 * @access public	 * @var bool	 */	var $in_the_loop = false;	/**	 * The current post ID.	 *	 * @since 1.5.0	 * @access public	 * @var int	 */	var $post;	/**	 * The list of comments for current post.	 *	 * @since 2.2.0	 * @access public	 * @var array	 */	var $comments;	/**	 * The amount of comments for the posts.	 *	 * @since 2.2.0	 * @access public	 * @var int	 */	var $comment_count = 0;	/**	 * The index of the comment in the comment loop.	 *	 * @since 2.2.0	 * @access public	 * @var int	 */	var $current_comment = -1;	/**	 * Current comment ID.	 *	 * @since 2.2.0	 * @access public	 * @var int	 */	var $comment;	/**	 * Amount of posts if limit clause was not used.	 *	 * @since 2.1.0	 * @access public	 * @var int	 */	var $found_posts = 0;	/**	 * The amount of pages.	 *	 * @since 2.1.0	 * @access public	 * @var int	 */	var $max_num_pages = 0;	/**	 * The amount of comment pages.	 *	 * @since 2.7.0	 * @access public	 * @var int	 */	var $max_num_comment_pages = 0;	/**	 * Set if query is single post.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_single = false;	/**	 * Set if query is preview of blog.	 *	 * @since 2.0.0	 * @access public	 * @var bool	 */	var $is_preview = false;	/**	 * Set if query returns a page.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_page = false;	/**	 * Set if query is an archive list.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_archive = false;	/**	 * Set if query is part of a date.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_date = false;	/**	 * Set if query contains a year.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_year = false;	/**	 * Set if query contains a month.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_month = false;	/**	 * Set if query contains a day.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_day = false;	/**	 * Set if query contains time.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_time = false;	/**	 * Set if query contains an author.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_author = false;	/**	 * Set if query contains category.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_category = false;	/**	 * Set if query contains tag.	 *	 * @since 2.3.0	 * @access public	 * @var bool	 */	var $is_tag = false;	/**	 * Set if query contains taxonomy.	 *	 * @since 2.5.0	 * @access public	 * @var bool	 */	var $is_tax = false;	/**	 * Set if query was part of a search result.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_search = false;	/**	 * Set if query is feed display.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_feed = false;	/**	 * Set if query is comment feed display.	 *	 * @since 2.2.0	 * @access public	 * @var bool	 */	var $is_comment_feed = false;	/**	 * Set if query is trackback.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_trackback = false;	/**	 * Set if query is blog homepage.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_home = false;	/**	 * Set if query couldn't found anything.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_404 = false;	/**	 * Set if query is within comments popup window.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_comments_popup = false;	/**	 * Set if query is part of administration page.	 *	 * @since 1.5.0	 * @access public	 * @var bool	 */	var $is_admin = false;	/**	 * Set if query is an attachment.	 *	 * @since 2.0.0	 * @access public	 * @var bool	 */	var $is_attachment = false;	/**	 * Set if is single, is a page, or is an attachment.	 *	 * @since 2.1.0	 * @access public	 * @var bool	 */	var $is_singular = false;	/**	 * Set if query is for robots.	 *	 * @since 2.1.0	 * @access public	 * @var bool	 */	var $is_robots = false;	/**	 * Set if query contains posts.	 *	 * Basically, the homepage if the option isn't set for the static homepage.	 *	 * @since 2.1.0	 * @access public	 * @var bool	 */	var $is_posts_page = false;	/**	 * Resets query flags to false.	 *	 * The query flags are what page info WordPress was able to figure out.	 *	 * @since 2.0.0	 * @access private	 */	function init_query_flags() {		$this->is_single = false;		$this->is_page = false;		$this->is_archive = false;		$this->is_date = false;		$this->is_year = false;		$this->is_month = false;		$this->is_day = false;		$this->is_time = false;		$this->is_author = false;		$this->is_category = false;		$this->is_tag = false;		$this->is_tax = false;		$this->is_search = false;		$this->is_feed = false;		$this->is_comment_feed = false;		$this->is_trackback = false;		$this->is_home = false;		$this->is_404 = false;		$this->is_paged = false;		$this->is_admin = false;		$this->is_attachment = false;		$this->is_singular = false;		$this->is_robots = false;		$this->is_posts_page = false;	}	/**	 * Initiates object properties and sets default values.	 *	 * @since 1.5.0	 * @access public	 */	function init() {		unset($this->posts);		unset($this->query);		$this->query_vars = array();		unset($this->queried_object);		unset($this->queried_object_id);		$this->post_count = 0;		$this->current_post = -1;		$this->in_the_loop = false;		$this->init_query_flags();	}	/**	 * Reparse the query vars.	 *	 * @since 1.5.0	 * @access public	 */	function parse_query_vars() {		$this->parse_query('');	}	/**	 * Fills in the query variables, which do not exist within the parameter.	 *	 * @since 2.1.0	 * @access public	 *	 * @param array $array Defined query variables.	 * @return array Complete query variables with undefined ones filled in empty.	 */	function fill_query_vars($array) {		$keys = array(			'error'			, 'm'			, 'p'			, 'post_parent'			, 'subpost'			, 'subpost_id'			, 'attachment'			, 'attachment_id'			, 'name'			, 'static'			, 'pagename'			, 'page_id'			, 'second'			, 'minute'			, 'hour'			, 'day'			, 'monthnum'			, 'year'			, 'w'			, 'category_name'			, 'tag'			, 'cat'			, 'tag_id'			, 'author_name'			, 'feed'			, 'tb'			, 'paged'			, 'comments_popup'			, 'meta_key'			, 'meta_value'			, 'preview'			, 's'			, 'sentence'		);		foreach ( $keys as $key ) {			if ( !isset($array[$key]))				$array[$key] = '';		}		$array_keys = array('category__in', 'category__not_in', 'category__and', 'post__in', 'post__not_in',			'tag__in', 'tag__not_in', 'tag__and', 'tag_slug__in', 'tag_slug__and');		foreach ( $array_keys as $key ) {			if ( !isset($array[$key]))				$array[$key] = array();		}		return $array;	}	/**	 * Parse a query string and set query type booleans.	 *	 * @since 1.5.0	 * @access public	 *	 * @param string|array $query	 */	function parse_query($query) {		if ( !empty($query) || !isset($this->query) ) {			$this->init();			if ( is_array($query) )				$this->query_vars = $query;			else				parse_str($query, $this->query_vars);			$this->query = $query;		}		$this->query_vars = $this->fill_query_vars($this->query_vars);		$qv = &$this->query_vars;		if ( ! empty($qv['robots']) )			$this->is_robots = true;		$qv['p'] =  absint($qv['p']);		$qv['page_id'] =  absint($qv['page_id']);		$qv['year'] = absint($qv['year']);		$qv['monthnum'] = absint($qv['monthnum']);		$qv['day'] = absint($qv['day']);		$qv['w'] = absint($qv['w']);		$qv['m'] = absint($qv['m']);		$qv['paged'] = absint($qv['paged']);		$qv['cat'] = preg_replace( '|[^0-9,-]|', '', $qv['cat'] ); // comma separated list of positive or negative integers		$qv['pagename'] = trim( $qv['pagename'] );		$qv['name'] = trim( $qv['name'] );		if ( '' !== $qv['hour'] ) $qv['hour'] = absint($qv['hour']);		if ( '' !== $qv['minute'] ) $qv['minute'] = absint($qv['minute']);		if ( '' !== $qv['second'] ) $qv['second'] = absint($qv['second']);		// Compat.  Map subpost to attachment.		if ( '' != $qv['subpost'] )			$qv['attachment'] = $qv['subpost'];		if ( '' != $qv['subpost_id'] )			$qv['attachment_id'] = $qv['subpost_id'];		$qv['attachment_id'] = absint($qv['attachment_id']);		if ( ('' != $qv['attachment']) || !empty($qv['attachment_id']) ) {			$this->is_single = true;			$this->is_attachment = true;		} elseif ( '' != $qv['name'] ) {			$this->is_single = true;		} elseif ( $qv['p'] ) {			$this->is_single = true;		} elseif ( ('' !== $qv['hour']) && ('' !== $qv['minute']) &&('' !== $qv['second']) && ('' != $qv['year']) && ('' != $qv['monthnum']) && ('' != $qv['day']) ) {			// If year, month, day, hour, minute, and second are set, a single			// post is being queried.			$this->is_single = true;		} elseif ( '' != $qv['static'] || '' != $qv['pagename'] || !empty($qv['page_id']) ) {			$this->is_page = true;			$this->is_single = false;		} elseif ( !empty($qv['s']) ) {			$this->is_search = true;		} else {		// Look for archive queries.  Dates, categories, authors.			if ( '' !== $qv['second'] ) {				$this->is_time = true;				$this->is_date = true;			}			if ( '' !== $qv['minute'] ) {				$this->is_time = true;				$this->is_date = true;			}			if ( '' !== $qv['hour'] ) {				$this->is_time = true;				$this->is_date = true;			}			if ( $qv['day'] ) {				if ( ! $this->is_date ) {					$this->is_day = true;					$this->is_date = true;				}			}			if ( $qv['monthnum'] ) {				if ( ! $this->is_date ) {					$this->is_month = true;					$this->is_date = true;				}			}			if ( $qv['year'] ) {				if ( ! $this->is_date ) {					$this->is_year = true;					$this->is_date = true;				}			}			if ( $qv['m'] ) {				$this->is_date = true;				if ( strlen($qv['m']) > 9 ) {					$this->is_time = true;				} else if ( strlen($qv['m']) > 7 ) {					$this->is_day = true;				} else if ( strlen($qv['m']) > 5 ) {					$this->is_month = true;				} else {					$this->is_year = true;				}			}			if ( '' != $qv['w'] ) {				$this->is_date = true;			}			if ( empty($qv['cat']) || ($qv['cat'] == '0') ) {				$this->is_category = false;			} else {				if ( strpos($qv['cat'], '-') !== false ) {					$this->is_category = false;				} else {					$this->is_category = true;				}			}			if ( '' != $qv['category_name'] ) {				$this->is_category = true;			}			if ( !is_array($qv['category__in']) || empty($qv['category__in']) ) {				$qv['category__in'] = array();			} else {				$qv['category__in'] = array_map('absint', $qv['category__in']);				$this->is_category = true;			}			if ( !is_array($qv['category__not_in']) || empty($qv['category__not_in']) ) {				$qv['category__not_in'] = array();			} else {				$qv['category__not_in'] = array_map('absint', $qv['category__not_in']);			}			if ( !is_array($qv['category__and']) || empty($qv['category__and']) ) {				$qv['category__and'] = array();			} else {				$qv['category__and'] = array_map('absint', $qv['category__and']);				$this->is_category = true;			}			if (  '' != $qv['tag'] )				$this->is_tag = true;			$qv['tag_id'] = absint($qv['tag_id']);			if (  !empty($qv['tag_id']) )				$this->is_tag = true;			if ( !is_array($qv['tag__in']) || empty($qv['tag__in']) ) {				$qv['tag__in'] = array();			} else {				$qv['tag__in'] = array_map('absint', $qv['tag__in']);				$this->is_tag = true;			}			if ( !is_array($qv['tag__not_in']) || empty($qv['tag__not_in']) ) {				$qv['tag__not_in'] = array();			} else {				$qv['tag__not_in'] = array_map('absint', $qv['tag__not_in']);			}			if ( !is_array($qv['tag__and']) || empty($qv['tag__and']) ) {				$qv['tag__and'] = array();			} else {				$qv['tag__and'] = array_map('absint', $qv['tag__and']);				$this->is_category = true;			}			if ( !is_array($qv['tag_slug__in']) || empty($qv['tag_slug__in']) ) {				$qv['tag_slug__in'] = array();			} else {				$qv['tag_slug__in'] = array_map('sanitize_title', $qv['tag_slug__in']);				$this->is_tag = true;			}			if ( !is_array($qv['tag_slug__and']) || empty($qv['tag_slug__and']) ) {				$qv['tag_slug__and'] = array();			} else {				$qv['tag_slug__and'] = array_map('sanitize_title', $qv['tag_slug__and']);				$this->is_tag = true;			}			if ( empty($qv['taxonomy']) || empty($qv['term']) ) {				$this->is_tax = false;				foreach ( $GLOBALS['wp_taxonomies'] as $taxonomy => $t ) {					if ( $t->query_var && isset($qv[$t->query_var]) && '' != $qv[$t->query_var] ) {						$qv['taxonomy'] = $taxonomy;						$qv['term'] = $qv[$t->query_var];						$this->is_tax = true;						break;					}				}			} else {				$this->is_tax = true;			}			if ( empty($qv['author']) || ($qv['author'] == '0') ) {				$this->is_author = false;			} else {				$this->is_author = true;			}			if ( '' != $qv['author_name'] ) {				$this->is_author = true;			}			if ( ($this->is_date || $this->is_author || $this->is_category || $this->is_tag || $this->is_tax) )				$this->is_archive = true;		}		if ( '' != $qv['feed'] )			$this->is_feed = true;		if ( '' != $qv['tb'] )			$this->is_trackback = true;		if ( '' != $qv['paged'] && ( intval($qv['paged']) > 1 ) )			$this->is_paged = true;		if ( '' != $qv['comments_popup'] )			$this->is_comments_popup = true;		// if we're previewing inside the write screen		if ( '' != $qv['preview'] )			$this->is_preview = true;		if ( is_admin() )			$this->is_admin = true;		if ( false !== strpos($qv['feed'], 'comments-') ) {			$qv['feed'] = str_replace('comments-', '', $qv['feed']);			$qv['withcomments'] = 1;		}		$this->is_singular = $this->is_single || $this->is_page || $this->is_attachment;		if ( $this->is_feed && ( !empty($qv['withcomments']) || ( empty($qv['withoutcomments']) && $this->is_singular ) ) )			$this->is_comment_feed = true;		if ( !( $this->is_singular || $this->is_archive || $this->is_search || $this->is_feed || $this->is_trackback || $this->is_404 || $this->is_admin || $this->is_comments_popup || $this->is_robots ) )			$this->is_home = true;		// Correct is_* for page_on_front and page_for_posts		if ( $this->is_home && 'page' == get_option('show_on_front') && get_option('page_on_front') ) {			$_query = wp_parse_args($query);			if ( empty($_query) || !array_diff( array_keys($_query), array('preview', 'page', 'paged', 'cpage') ) ) {				$this->is_page = true;				$this->is_home = false;				$qv['page_id'] = get_option('page_on_front');				// Correct <!--nextpage--> for page_on_front				if ( !empty($qv['paged']) ) {					$qv['page'] = $qv['paged'];					unset($qv['paged']);				}			}		}		if ( '' != $qv['pagename'] ) {			$this->queried_object =& get_page_by_path($qv['pagename']);			if ( !empty($this->queried_object) )				$this->queried_object_id = (int) $this->queried_object->ID;			else				unset($this->queried_object);			if  ( 'page' == get_option('show_on_front') && isset($this->queried_object_id) && $this->queried_object_id == get_option('page_for_posts') ) {				$this->is_page = false;				$this->is_home = true;				$this->is_posts_page = true;			}		}		if ( $qv['page_id'] ) {			if  ( 'page' == get_option('show_on_front') && $qv['page_id'] == get_option('page_for_posts') ) {				$this->is_page = false;				$this->is_home = true;				$this->is_posts_page = true;			}		}		if ( !empty($qv['post_type']) ) {			if ( is_array($qv['post_type']) )				$qv['post_type'] = array_map('sanitize_user', $qv['post_type'], array(true));			else				$qv['post_type'] = sanitize_user($qv['post_type'], true);		}		if ( !empty($qv['post_status']) )			$qv['post_status'] = preg_replace('|[^a-z0-9_,-]|', '', $qv['post_status']);		if ( $this->is_posts_page && ( ! isset($qv['withcomments']) || ! $qv['withcomments'] ) )			$this->is_comment_feed = false;		$this->is_singular = $this->is_single || $this->is_page || $this->is_attachment;		// Done correcting is_* for page_on_front and page_for_posts		if ( '404' == $qv['error'] )			$this->set_404();		if ( !empty($query) )			do_action_ref_array('parse_query', array(&$this));	}	/**	 * Sets the 404 property and saves whether query is feed.	 *	 * @since 2.0.0	 * @access public	 */	function set_404() {		$is_feed = $this->is_feed;		$this->init_query_flags();		$this->is_404 = true;		$this->is_feed = $is_feed;	}	/**	 * Retrieve query variable.	 *	 * @since 1.5.0	 * @access public	 *	 * @param string $query_var Query variable key.	 * @return mixed	 */	function get($query_var) {		if ( isset($this->query_vars[$query_var]) )			return $this->query_vars[$query_var];		return '';	}	/**	 * Set query variable.	 *	 * @since 1.5.0	 * @access public	 *	 * @param string $query_var Query variable key.	 * @param mixed $value Query variable value.	 */	function set($query_var, $value) {		$this->query_vars[$query_var] = $value;	}	/**	 * Retrieve the posts based on query variables.	 *	 * There are a few filters and actions that can be used to modify the post	 * database query.	 *	 * @since 1.5.0	 * @access public	 * @uses do_action_ref_array() Calls 'pre_get_posts' hook before retrieving posts.	 *	 * @return array List of posts.	 */	function &get_posts() {		global $wpdb, $user_ID, $_wp_using_ext_object_cache;		do_action_ref_array('pre_get_posts', array(&$this));		// Shorthand.		$q = &$this->query_vars;		$q = $this->fill_query_vars($q);		// First let's clear some variables		$distinct = '';		$whichcat = '';		$whichauthor = '';		$whichmimetype = '';		$where = '';		$limits = '';		$join = '';		$search = '';		$groupby = '';		$fields = "$wpdb->posts.*";		$post_status_join = false;		$page = 1;		if ( !isset($q['caller_get_posts']) )			$q['caller_get_posts'] = false;		if ( !isset($q['suppress_filters']) )			$q['suppress_filters'] = false;		if ( !isset($q['cache_results']) ) {			if ( $_wp_using_ext_object_cache )				$q['cache_results'] = false;			else				$q['cache_results'] = true;		}		if ( !isset($q['update_post_term_cache']) )			$q['update_post_term_cache'] = true;		if ( !isset($q['update_post_meta_cache']) )			$q['update_post_meta_cache'] = true;		if ( !isset($q['post_type']) ) {			if ( $this->is_search )				$q['post_type'] = 'any';			else				$q['post_type'] = '';		}		$post_type = $q['post_type'];		if ( !isset($q['posts_per_page']) || $q['posts_per_page'] == 0 )			$q['posts_per_page'] = get_option('posts_per_page');		if ( isset($q['showposts']) && $q['showposts'] ) {			$q['showposts'] = (int) $q['showposts'];			$q['posts_per_page'] = $q['showposts'];		}		if ( (isset($q['posts_per_archive_page']) && $q['posts_per_archive_page'] != 0) && ($this->is_archive || $this->is_search) )			$q['posts_per_page'] = $q['posts_per_archive_page'];		if ( !isset($q['nopaging']) ) {			if ( $q['posts_per_page'] == -1 ) {				$q['nopaging'] = true;			} else {				$q['nopaging'] = false;			}		}		if ( $this->is_feed ) {			$q['posts_per_page'] = get_option('posts_per_rss');			$q['nopaging'] = false;		}		$q['posts_per_page'] = (int) $q['posts_per_page'];		if ( $q['posts_per_page'] < -1 )			$q['posts_per_page'] = abs($q['posts_per_page']);		else if ( $q['posts_per_page'] == 0 )			$q['posts_per_page'] = 1;		if ( !isset($q['comments_per_page']) || $q['comments_per_page'] == 0 )			$q['comments_per_page'] = get_option('comments_per_page');		if ( $this->is_home && (empty($this->query) || $q['preview'] == 'true') && ( 'page' == get_option('show_on_front') ) && get_option('page_on_front') ) {			$this->is_page = true;			$this->is_home = false;			$q['page_id'] = get_option('page_on_front');		}		if ( isset($q['page']) ) {			$q['page'] = trim($q['page'], '/');			$q['page'] = absint($q['page']);		}		// If true, forcibly turns off SQL_CALC_FOUND_ROWS even when limits are present.		if ( isset($q['no_found_rows']) )			$q['no_found_rows'] = (bool) $q['no_found_rows'];		else			$q['no_found_rows'] = false;		// If a month is specified in the querystring, load that month		if ( $q['m'] ) {			$q['m'] = '' . preg_replace('|[^0-9]|', '', $q['m']);			$where .= " AND YEAR($wpdb->posts.post_date)=" . substr($q['m'], 0, 4);			if ( strlen($q['m']) > 5 )				$where .= " AND MONTH($wpdb->posts.post_date)=" . substr($q['m'], 4, 2);			if ( strlen($q['m']) > 7 )				$where .= " AND DAYOFMONTH($wpdb->posts.post_date)=" . substr($q['m'], 6, 2);			if ( strlen($q['m']) > 9 )				$where .= " AND HOUR($wpdb->posts.post_date)=" . substr($q['m'], 8, 2);			if ( strlen($q['m']) > 11 )				$where .= " AND MINUTE($wpdb->posts.post_date)=" . substr($q['m'], 10, 2);			if ( strlen($q['m']) > 13 )				$where .= " AND SECOND($wpdb->posts.post_date)=" . substr($q['m'], 12, 2);		}		if ( '' !== $q['hour'] )			$where .= " AND HOUR($wpdb->posts.post_date)='" . $q['hour'] . "'";		if ( '' !== $q['minute'] )			$where .= " AND MINUTE($wpdb->posts.post_date)='" . $q['minute'] . "'";		if ( '' !== $q['second'] )			$where .= " AND SECOND($wpdb->posts.post_date)='" . $q['second'] . "'";		if ( $q['year'] )			$where .= " AND YEAR($wpdb->posts.post_date)='" . $q['year'] . "'";		if ( $q['monthnum'] )			$where .= " AND MONTH($wpdb->posts.post_date)='" . $q['monthnum'] . "'";		if ( $q['day'] )			$where .= " AND DAYOFMONTH($wpdb->posts.post_date)='" . $q['day'] . "'";		// If we've got a post_type AND its not "any" post_type.		if ( !empty($q['post_type']) && 'any' != $q['post_type'] ) {			foreach ( (array)$q['post_type'] as $_post_type ) {				$ptype_obj = get_post_type_object($_post_type);				if ( !$ptype_obj || !$ptype_obj->query_var || empty($q[ $ptype_obj->query_var ]) )					continue;				if ( ! $ptype_obj->hierarchical || strpos($q[ $ptype_obj->query_var ], '/') === false ) {					// Non-hierarchical post_types & parent-level-hierarchical post_types can directly use 'name'					$q['name'] = $q[ $ptype_obj->query_var ];				} else {					// Hierarchical post_types will operate through the					$q['pagename'] = $q[ $ptype_obj->query_var ];					$q['name'] = '';				}				// Only one request for a slug is possible, this is why name & pagename are overwritten above.				break;			} //end foreach			unset($ptype_obj);		}		if ( '' != $q['name'] ) {			$q['name'] = sanitize_title($q['name']);			$where .= " AND $wpdb->posts.post_name = '" . $q['name'] . "'";		} elseif ( '' != $q['pagename'] ) {			if ( isset($this->queried_object_id) ) {				$reqpage = $this->queried_object_id;			} else {				if ( 'page' != $q['post_type'] ) {					foreach ( (array)$q['post_type'] as $_post_type ) {						$ptype_obj = get_post_type_object($_post_type);						if ( !$ptype_obj || !$ptype_obj->hierarchical )							continue;						$reqpage = get_page_by_path($q['pagename'], OBJECT, $_post_type);						if ( $reqpage )							break;					}					unset($ptype_obj);				} else {					$reqpage = get_page_by_path($q['pagename']);				}				if ( !empty($reqpage) )					$reqpage = $reqpage->ID;				else					$reqpage = 0;			}			$page_for_posts = get_option('page_for_posts');			if  ( ('page' != get_option('show_on_front') ) || empty($page_for_posts) || ( $reqpage != $page_for_posts ) ) {				$q['pagename'] = str_replace('%2F', '/', urlencode(urldecode($q['pagename'])));				$page_paths = '/' . trim($q['pagename'], '/');				$q['pagename'] = sanitize_title(basename($page_paths));				$q['name'] = $q['pagename'];				$where .= " AND ($wpdb->posts.ID = '$reqpage')";				$reqpage_obj = get_page($reqpage);				if ( is_object($reqpage_obj) && 'attachment' == $reqpage_obj->post_type ) {					$this->is_attachment = true;					$post_type = $q['post_type'] = 'attachment';					$this->is_page = true;					$q['attachment_id'] = $reqpage;				}			}		} elseif ( '' != $q['attachment'] ) {			$q['attachment'] = str_replace('%2F', '/', urlencode(urldecode($q['attachment'])));			$attach_paths = '/' . trim($q['attachment'], '/');			$q['attachment'] = sanitize_title(basename($attach_paths));			$q['name'] = $q['attachment'];			$where .= " AND $wpdb->posts.post_name = '" . $q['attachment'] . "'";		}		if ( $q['w'] )			$where .= ' AND ' . _wp_mysql_week( "`$wpdb->posts`.`post_date`" ) . " = '" . $q['w'] . "'";		if ( intval($q['comments_popup']) )			$q['p'] = absint($q['comments_popup']);		// If an attachment is requested by number, let it supercede any post number.		if ( $q['attachment_id'] )			$q['p'] = absint($q['attachment_id']);		// If a post number is specified, load that post		if ( $q['p'] ) {			$where .= " AND {$wpdb->posts}.ID = " . $q['p'];		} elseif ( $q['post__in'] ) {			$post__in = implode(',', array_map( 'absint', $q['post__in'] ));			$where .= " AND {$wpdb->posts}.ID IN ($post__in)";		} elseif ( $q['post__not_in'] ) {			$post__not_in = implode(',',  array_map( 'absint', $q['post__not_in'] ));			$where .= " AND {$wpdb->posts}.ID NOT IN ($post__not_in)";		}		if ( is_numeric($q['post_parent']) )			$where .= $wpdb->prepare( " AND $wpdb->posts.post_parent = %d ", $q['post_parent'] );		if ( $q['page_id'] ) {			if  ( ('page' != get_option('show_on_front') ) || ( $q['page_id'] != get_option('page_for_posts') ) ) {				$q['p'] = $q['page_id'];				$where = " AND {$wpdb->posts}.ID = " . $q['page_id'];			}		}		// If a search pattern is specified, load the posts that match		if ( !empty($q['s']) ) {			// added slashes screw with quote grouping when done early, so done later			$q['s'] = stripslashes($q['s']);			if ( !empty($q['sentence']) ) {				$q['search_terms'] = array($q['s']);			} else {				preg_match_all('/".*?("|$)|((?<=[\\s",+])|^)[^\\s",+]+/', $q['s'], $matches);				$q['search_terms'] = array_map('_search_terms_tidy', $matches[0]);			}			$n = !empty($q['exact']) ? '' : '%';			$searchand = '';			foreach( (array) $q['search_terms'] as $term ) {				$term = addslashes_gpc($term);				$search .= "{$searchand}(($wpdb->posts.post_title LIKE '{$n}{$term}{$n}') OR ($wpdb->posts.post_content LIKE '{$n}{$term}{$n}'))";				$searchand = ' AND ';			}			$term = esc_sql($q['s']);			if ( empty($q['sentence']) && count($q['search_terms']) > 1 && $q['search_terms'][0] != $q['s'] )				$search .= " OR ($wpdb->posts.post_title LIKE '{$n}{$term}{$n}') OR ($wpdb->posts.post_content LIKE '{$n}{$term}{$n}')";			if ( !empty($search) ) {				$search = " AND ({$search}) ";				if ( !is_user_logged_in() )					$search .= " AND ($wpdb->posts.post_password = '') ";			}		}		// Allow plugins to contextually add/remove/modify the search section of the database query		$search = apply_filters_ref_array('posts_search', array( $search, &$this ) );		// Category stuff		if ( empty($q['cat']) || ($q['cat'] == '0') ||				// Bypass cat checks if fetching specific posts				$this->is_singular ) {			$whichcat = '';		} else {			$q['cat'] = ''.urldecode($q['cat']).'';			$q['cat'] = addslashes_gpc($q['cat']);			$cat_array = preg_split('/[,\s]+/', $q['cat']);			$q['cat'] = '';			$req_cats = array();			foreach ( (array) $cat_array as $cat ) {				$cat = intval($cat);				$req_cats[] = $cat;				$in = ($cat > 0);				$cat = abs($cat);				if ( $in ) {					$q['category__in'][] = $cat;					$q['category__in'] = array_merge($q['category__in'], get_term_children($cat, 'category'));				} else {					$q['category__not_in'][] = $cat;					$q['category__not_in'] = array_merge($q['category__not_in'], get_term_children($cat, 'category'));				}			}			$q['cat'] = implode(',', $req_cats);		}		if ( !empty($q['category__in']) ) {			$join = " INNER JOIN $wpdb->term_relationships ON ($wpdb->posts.ID = $wpdb->term_relationships.object_id) INNER JOIN $wpdb->term_taxonomy ON ($wpdb->term_relationships.term_taxonomy_id = $wpdb->term_taxonomy.term_taxonomy_id) ";			$whichcat .= " AND $wpdb->term_taxonomy.taxonomy = 'category' ";			$include_cats = "'" . implode("', '", $q['category__in']) . "'";			$whichcat .= " AND $wpdb->term_taxonomy.term_id IN ($include_cats) ";		}		if ( !empty($q['category__not_in']) ) {			$cat_string = "'" . implode("', '", $q['category__not_in']) . "'";			$whichcat .= " AND $wpdb->posts.ID NOT IN ( SELECT tr.object_id FROM $wpdb->term_relationships AS tr INNER JOIN $wpdb->term_taxonomy AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy = 'category' AND tt.term_id IN ($cat_string) )";		}		// Category stuff for nice URLs		if ( '' != $q['category_name'] && !$this->is_singular ) {			$q['category_name'] = implode('/', array_map('sanitize_title', explode('/', $q['category_name'])));			$reqcat = get_category_by_path($q['category_name']);			$q['category_name'] = str_replace('%2F', '/', urlencode(urldecode($q['category_name'])));			$cat_paths = '/' . trim($q['category_name'], '/');			$q['category_name'] = sanitize_title(basename($cat_paths));			$cat_paths = '/' . trim(urldecode($q['category_name']), '/');			$q['category_name'] = sanitize_title(basename($cat_paths));			$cat_paths = explode('/', $cat_paths);			$cat_path = '';			foreach ( (array) $cat_paths as $pathdir )				$cat_path .= ( $pathdir != '' ? '/' : '' ) . sanitize_title($pathdir);			//if we don't match the entire hierarchy fallback on just matching the nicename			if ( empty($reqcat) )				$reqcat = get_category_by_path($q['category_name'], false);			if ( !empty($reqcat) )				$reqcat = $reqcat->term_id;			else				$reqcat = 0;			$q['cat'] = $reqcat;			$join = " INNER JOIN $wpdb->term_relationships ON ($wpdb->posts.ID = $wpdb->term_relationships.object_id) INNER JOIN $wpdb->term_taxonomy ON ($wpdb->term_relationships.term_taxonomy_id = $wpdb->term_taxonomy.term_taxonomy_id) ";			$whichcat = " AND $wpdb->term_taxonomy.taxonomy = 'category' ";			$in_cats = array($q['cat']);			$in_cats = array_merge($in_cats, get_term_children($q['cat'], 'category'));			$in_cats = "'" . implode("', '", $in_cats) . "'";			$whichcat .= "AND $wpdb->term_taxonomy.term_id IN ($in_cats)";			$groupby = "{$wpdb->posts}.ID";		}		// Tags		if ( '' != $q['tag'] ) {			if ( strpos($q['tag'], ',') !== false ) {				$tags = preg_split('/[,\s]+/', $q['tag']);				foreach ( (array) $tags as $tag ) {					$tag = sanitize_term_field('slug', $tag, 0, 'post_tag', 'db');					$q['tag_slug__in'][] = $tag;				}			} else if ( preg_match('/[+\s]+/', $q['tag']) || !empty($q['cat']) ) {				$tags = preg_split('/[+\s]+/', $q['tag']);				foreach ( (array) $tags as $tag ) {					$tag = sanitize_term_field('slug', $tag, 0, 'post_tag', 'db');					$q['tag_slug__and'][] = $tag;				}			} else {				$q['tag'] = sanitize_term_field('slug', $q['tag'], 0, 'post_tag', 'db');				$q['tag_slug__in'][] = $q['tag'];			}		}		if ( !empty($q['category__in']) || !empty($q['meta_key']) || !empty($q['tag__in']) || !empty($q['tag_slug__in']) ) {			$groupby = "{$wpdb->posts}.ID";		}		if ( !empty($q['tag__in']) && empty($q['cat']) ) {			$join = " INNER JOIN $wpdb->term_relationships ON ($wpdb->posts.ID = $wpdb->term_relationships.object_id) INNER JOIN $wpdb->term_taxonomy ON ($wpdb->term_relationships.term_taxonomy_id = $wpdb->term_taxonomy.term_taxonomy_id) ";			$whichcat .= " AND $wpdb->term_taxonomy.taxonomy = 'post_tag' ";			$include_tags = "'" . implode("', '", $q['tag__in']) . "'";			$whichcat .= " AND $wpdb->term_taxonomy.term_id IN ($include_tags) ";			$reqtag = term_exists( $q['tag__in'][0], 'post_tag' );			if ( !empty($reqtag) )				$q['tag_id'] = $reqtag['term_id'];		}		if ( !empty($q['tag_slug__in']) && empty($q['cat']) ) {			$join = " INNER JOIN $wpdb->term_relationships ON ($wpdb->posts.ID = $wpdb->term_relationships.object_id) INNER JOIN $wpdb->term_taxonomy ON ($wpdb->term_relationships.term_taxonomy_id = $wpdb->term_taxonomy.term_taxonomy_id) INNER JOIN $wpdb->terms ON ($wpdb->term_taxonomy.term_id = $wpdb->terms.term_id) ";			$whichcat .= " AND $wpdb->term_taxonomy.taxonomy = 'post_tag' ";			$include_tags = "'" . implode("', '", $q['tag_slug__in']) . "'";			$whichcat .= " AND $wpdb->terms.slug IN ($include_tags) ";			$reqtag = get_term_by( 'slug', $q['tag_slug__in'][0], 'post_tag' );			if ( !empty($reqtag) )				$q['tag_id'] = $reqtag->term_id;		}		if ( !empty($q['tag__not_in']) ) {			$tag_string = "'" . implode("', '", $q['tag__not_in']) . "'";			$whichcat .= " AND $wpdb->posts.ID NOT IN ( SELECT tr.object_id FROM $wpdb->term_relationships AS tr INNER JOIN $wpdb->term_taxonomy AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy = 'post_tag' AND tt.term_id IN ($tag_string) )";		}		// Tag and slug intersections.		$intersections = array('category__and' => 'category', 'tag__and' => 'post_tag', 'tag_slug__and' => 'post_tag', 'tag__in' => 'post_tag', 'tag_slug__in' => 'post_tag');		$tagin = array('tag__in', 'tag_slug__in'); // These are used to make some exceptions below		foreach ( $intersections as $item => $taxonomy ) {			if ( empty($q[$item]) ) continue;			if ( in_array($item, $tagin) && empty($q['cat']) ) continue; // We should already have what we need if categories aren't being used			if ( $item != 'category__and' ) {				$reqtag = term_exists( $q[$item][0], 'post_tag' );				if ( !empty($reqtag) )					$q['tag_id'] = $reqtag['term_id'];			}			if ( in_array( $item, array('tag_slug__and', 'tag_slug__in' ) ) )				$taxonomy_field = 'slug';			else				$taxonomy_field = 'term_id';			$q[$item] = array_unique($q[$item]);			$tsql = "SELECT p.ID FROM $wpdb->posts p INNER JOIN $wpdb->term_relationships tr ON (p.ID = tr.object_id) INNER JOIN $wpdb->term_taxonomy tt ON (tr.term_taxonomy_id = tt.term_taxonomy_id) INNER JOIN $wpdb->terms t ON (tt.term_id = t.term_id)";			$tsql .= " WHERE tt.taxonomy = '$taxonomy' AND t.$taxonomy_field IN ('" . implode("', '", $q[$item]) . "')";			if ( !in_array($item, $tagin) ) { // This next line is only helpful if we are doing an and relationship				$tsql .= " GROUP BY p.ID HAVING count(p.ID) = " . count($q[$item]);			}			$post_ids = $wpdb->get_col($tsql);			if ( count($post_ids) )				$whichcat .= " AND $wpdb->posts.ID IN (" . implode(', ', $post_ids) . ") ";			else {				$whichcat = " AND 0 = 1";				break;			}		}		// Taxonomies		if ( $this->is_tax ) {			if ( '' != $q['taxonomy'] ) {				$taxonomy = $q['taxonomy'];				$tt[$taxonomy] = $q['term'];			} else {				foreach ( $GLOBALS['wp_taxonomies'] as $taxonomy => $t ) {					if ( $t->query_var && '' != $q[$t->query_var] ) {						$tt[$taxonomy] = $q[$t->query_var];						break;					}				}			}			$terms = get_terms($taxonomy, array('slug' => $tt[$taxonomy], 'hide_empty' => !is_taxonomy_hierarchical($taxonomy)));			if ( is_wp_error($terms) || empty($terms) ) {				$whichcat = " AND 0 ";			} else {				foreach ( $terms as $term ) {					$term_ids[] = $term->term_id;					if ( is_taxonomy_hierarchical($taxonomy) ) {						$children = get_term_children($term->term_id, $taxonomy);						$term_ids = array_merge($term_ids, $children);					}				}				$post_ids = get_objects_in_term($term_ids, $taxonomy);				if ( !is_wp_error($post_ids) && !empty($post_ids) ) {					$whichcat .= " AND $wpdb->posts.ID IN (" . implode(', ', $post_ids) . ") ";					if ( empty($post_type) ) {						$post_type = 'any';						$post_status_join = true;					} elseif ( in_array('attachment', (array)$post_type) ) {						$post_status_join = true;					}				} else {					$whichcat = " AND 0 ";				}			}		}		// Author/user stuff		if ( empty($q['author']) || ($q['author'] == '0') ) {			$whichauthor = '';		} else {			$q['author'] = (string)urldecode($q['author']);			$q['author'] = addslashes_gpc($q['author']);			if ( strpos($q['author'], '-') !== false ) {				$eq = '!=';				$andor = 'AND';				$q['author'] = explode('-', $q['author']);				$q['author'] = (string)absint($q['author'][1]);			} else {				$eq = '=';				$andor = 'OR';			}			$author_array = preg_split('/[,\s]+/', $q['author']);			$_author_array = array();			foreach ( $author_array as $key => $_author )				$_author_array[] = "$wpdb->posts.post_author " . $eq . ' ' . absint($_author);			$whichauthor .= ' AND (' . implode(" $andor ", $_author_array) . ')';			unset($author_array, $_author_array);		}		// Author stuff for nice URLs		if ( '' != $q['author_name'] ) {			if ( strpos($q['author_name'], '/') !== false ) {				$q['author_name'] = explode('/', $q['author_name']);				if ( $q['author_name'][ count($q['author_name'])-1 ] ) {					$q['author_name'] = $q['author_name'][count($q['author_name'])-1]; // no trailing slash				} else {					$q['author_name'] = $q['author_name'][count($q['author_name'])-2]; // there was a trailling slash				}			}			$q['author_name'] = sanitize_title($q['author_name']);			$q['author'] = get_user_by('slug', $q['author_name']);			if ( $q['author'] )				$q['author'] = $q['author']->ID;			$whichauthor .= " AND ($wpdb->posts.post_author = " . absint($q['author']) . ')';		}		// MIME-Type stuff for attachment browsing		if ( isset($q['post_mime_type']) && '' != $q['post_mime_type'] ) {			$table_alias = $post_status_join ? $wpdb->posts : '';			$whichmimetype = wp_post_mime_type_where($q['post_mime_type'], $table_alias);		}		$where .= $search . $whichcat . $whichauthor . $whichmimetype;		if ( empty($q['order']) || ((strtoupper($q['order']) != 'ASC') && (strtoupper($q['order']) != 'DESC')) )			$q['order'] = 'DESC';		// Order by		if ( empty($q['orderby']) ) {			$q['orderby'] = "$wpdb->posts.post_date " . $q['order'];		} elseif ( 'none' == $q['orderby'] ) {			$q['orderby'] = '';		} else {			// Used to filter values			$allowed_keys = array('author', 'date', 'title', 'modified', 'menu_order', 'parent', 'ID', 'rand', 'comment_count');			if ( !empty($q['meta_key']) ) {				$allowed_keys[] = $q['meta_key'];				$allowed_keys[] = 'meta_value';				$allowed_keys[] = 'meta_value_num';			}			$q['orderby'] = urldecode($q['orderby']);			$q['orderby'] = addslashes_gpc($q['orderby']);			$orderby_array = explode(' ', $q['orderby']);			$q['orderby'] = '';			foreach ( $orderby_array as $i => $orderby ) {				// Only allow certain values for safety				if ( ! in_array($orderby, $allowed_keys) )					continue;				switch ( $orderby ) {					case 'menu_order':						break;					case 'ID':						$orderby = "$wpdb->posts.ID";						break;					case 'rand':						$orderby = 'RAND()';						break;					case $q['meta_key']:					case 'meta_value':						$orderby = "$wpdb->postmeta.meta_value";						break;					case 'meta_value_num':						$orderby = "$wpdb->postmeta.meta_value+0";						break;					case 'comment_count':						$orderby = "$wpdb->posts.comment_count";						break;					default:						$orderby = "$wpdb->posts.post_" . $orderby;				}				$q['orderby'] .= (($i == 0) ? '' : ',') . $orderby;			}			// append ASC or DESC at the end			if ( !empty($q['orderby']))				$q['orderby'] .= " {$q['order']}";			if ( empty($q['orderby']) )				$q['orderby'] = "$wpdb->posts.post_date ".$q['order'];		}		if ( is_array($post_type) ) {			$post_type_cap = 'multiple_post_type';		} else {			$post_type_object = get_post_type_object ( $post_type );			if ( !empty($post_type_object) )				$post_type_cap = $post_type_object->capability_type;			else				$post_type_cap = $post_type;		}		$exclude_post_types = '';		$in_search_post_types = get_post_types( array('exclude_from_search' => false) );		if ( ! empty( $in_search_post_types ) )			$exclude_post_types .= $wpdb->prepare(" AND $wpdb->posts.post_type IN ('" . join("', '", $in_search_post_types ) . "')");		if ( 'any' == $post_type ) {			$where .= $exclude_post_types;		} elseif ( !empty( $post_type ) && is_array( $post_type ) ) {			$where .= " AND $wpdb->posts.post_type IN ('" . join("', '", $post_type) . "')";		} elseif ( ! empty( $post_type ) ) {			$where .= " AND $wpdb->posts.post_type = '$post_type'";			$post_type_object = get_post_type_object ( $post_type );		} elseif ( $this->is_attachment ) {			$where .= " AND $wpdb->posts.post_type = 'attachment'";			$post_type_object = get_post_type_object ( 'attachment' );		} elseif ( $this->is_page ) {			$where .= " AND $wpdb->posts.post_type = 'page'";			$post_type_object = get_post_type_object ( 'page' );		} else {			$where .= " AND $wpdb->posts.post_type = 'post'";			$post_type_object = get_post_type_object ( 'post' );		}		if ( !empty($post_type_object) ) {			$post_type_cap = $post_type_object->capability_type;			$edit_cap = $post_type_object->cap->edit_post;			$read_cap = $post_type_object->cap->read_post;			$edit_others_cap = $post_type_object->cap->edit_others_posts;			$read_private_cap = $post_type_object->cap->read_private_posts;		} else {			$edit_cap = 'edit_' . $post_type_cap;			$read_cap = 'read_' . $post_type_cap;			$edit_others_cap = 'edit_others_' . $post_type_cap . 's';			$read_private_cap = 'read_private_' . $post_type_cap . 's';		}		if ( isset($q['post_status']) && '' != $q['post_status'] ) {			$statuswheres = array();			$q_status = explode(',', $q['post_status']);			$r_status = array();			$p_status = array();			$e_status = array();			if ( $q['post_status'] == 'any' ) {				foreach ( get_post_stati( array('exclude_from_search' => true) ) as $status )					$e_status[] = "$wpdb->posts.post_status <> '$status'";			} else {				foreach ( get_post_stati() as $status ) {					if ( in_array( $status, $q_status ) ) {						if ( 'private' == $status )							$p_status[] = "$wpdb->posts.post_status = '$status'";						else							$r_status[] = "$wpdb->posts.post_status = '$status'";					}				}			}			if ( empty($q['perm'] ) || 'readable' != $q['perm'] ) {				$r_status = array_merge($r_status, $p_status);				unset($p_status);			}			if ( !empty($e_status) ) {				$statuswheres[] = "(" . join( ' AND ', $e_status ) . ")";			}			if ( !empty($r_status) ) {				if ( !empty($q['perm'] ) && 'editable' == $q['perm'] && !current_user_can($edit_others_cap) )					$statuswheres[] = "($wpdb->posts.post_author = $user_ID " .  "AND (" . join( ' OR ', $r_status ) . "))";				else					$statuswheres[] = "(" . join( ' OR ', $r_status ) . ")";			}			if ( !empty($p_status) ) {				if ( !empty($q['perm'] ) && 'readable' == $q['perm'] && !current_user_can($read_private_cap) )					$statuswheres[] = "($wpdb->posts.post_author = $user_ID " .  "AND (" . join( ' OR ', $p_status ) . "))";				else					$statuswheres[] = "(" . join( ' OR ', $p_status ) . ")";			}			if ( $post_status_join ) {				$join .= " LEFT JOIN $wpdb->posts AS p2 ON ($wpdb->posts.post_parent = p2.ID) ";				foreach ( $statuswheres as $index => $statuswhere )					$statuswheres[$index] = "($statuswhere OR ($wpdb->posts.post_status = 'inherit' AND " . str_replace($wpdb->posts, 'p2', $statuswhere) . "))";			}			foreach ( $statuswheres as $statuswhere )				$where .= " AND $statuswhere";		} elseif ( !$this->is_singular ) {			$where .= " AND ($wpdb->posts.post_status = 'publish'";			// Add public states.			$public_states = get_post_stati( array('public' => true) );			foreach ( (array) $public_states as $state ) {				if ( 'publish' == $state ) // Publish is hard-coded above.					continue;				$where .= " OR $wpdb->posts.post_status = '$state'";			}			if ( is_admin() ) {				// Add protected states that should show in the admin all list.				$admin_all_states = get_post_stati( array('protected' => true, 'show_in_admin_all_list' => true) );				foreach ( (array) $admin_all_states as $state )					$where .= " OR $wpdb->posts.post_status = '$state'";			}			if ( is_user_logged_in() ) {				// Add private states that are limited to viewing by the author of a post or someone who has caps to read private states.				$private_states = get_post_stati( array('private' => true) );				foreach ( (array) $private_states as $state )					$where .= current_user_can( $read_private_cap ) ? " OR $wpdb->posts.post_status = '$state'" : " OR $wpdb->posts.post_author = $user_ID AND $wpdb->posts.post_status = '$state'";			}			$where .= ')';		}		// postmeta queries		if ( ! empty($q['meta_key']) || ! empty($q['meta_value']) )			$join .= " JOIN $wpdb->postmeta ON ($wpdb->posts.ID = $wpdb->postmeta.post_id) ";		if ( ! empty($q['meta_key']) )			$where .= $wpdb->prepare(" AND $wpdb->postmeta.meta_key = %s ", $q['meta_key']);		if ( ! empty($q['meta_value']) ) {			if ( empty($q['meta_compare']) || ! in_array($q['meta_compare'], array('=', '!=', '>', '>=', '<', '<=')) )				$q['meta_compare'] = '=';			$where .= $wpdb->prepare("AND $wpdb->postmeta.meta_value {$q['meta_compare']} %s ", $q['meta_value']);		}		// Apply filters on where and join prior to paging so that any		// manipulations to them are reflected in the paging by day queries.		if ( !$q['suppress_filters'] ) {			$where = apply_filters_ref_array('posts_where', array( $where, &$this ) );			$join = apply_filters_ref_array('posts_join', array( $join, &$this ) );		}		// Paging		if ( empty($q['nopaging']) && !$this->is_singular ) {			$page = absint($q['paged']);			if ( empty($page) )				$page = 1;			if ( empty($q['offset']) ) {				$pgstrt = '';				$pgstrt = ($page - 1) * $q['posts_per_page'] . ', ';				$limits = 'LIMIT ' . $pgstrt . $q['posts_per_page'];			} else { // we're ignoring $page and using 'offset'				$q['offset'] = absint($q['offset']);				$pgstrt = $q['offset'] . ', ';				$limits = 'LIMIT ' . $pgstrt . $q['posts_per_page'];			}		}		// Comments feeds		if ( $this->is_comment_feed && ( $this->is_archive || $this->is_search || !$this->is_singular ) ) {			if ( $this->is_archive || $this->is_search ) {				$cjoin = "JOIN $wpdb->posts ON ($wpdb->comments.comment_post_ID = $wpdb->posts.ID) $join ";				$cwhere = "WHERE comment_approved = '1' $where";				$cgroupby = "$wpdb->comments.comment_id";			} else { // Other non singular e.g. front				$cjoin = "JOIN $wpdb->posts ON ( $wpdb->comments.comment_post_ID = $wpdb->posts.ID )";				$cwhere = "WHERE post_status = 'publish' AND comment_approved = '1'";				$cgroupby = '';			}			if ( !$q['suppress_filters'] ) {				$cjoin = apply_filters_ref_array('comment_feed_join', array( $cjoin, &$this ) );				$cwhere = apply_filters_ref_array('comment_feed_where', array( $cwhere, &$this ) );				$cgroupby = apply_filters_ref_array('comment_feed_groupby', array( $cgroupby, &$this ) );				$corderby = apply_filters_ref_array('comment_feed_orderby', array( 'comment_date_gmt DESC', &$this ) );				$climits = apply_filters_ref_array('comment_feed_limits', array( 'LIMIT ' . get_option('posts_per_rss'), &$this ) );			}			$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';			$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';			$this->comments = (array) $wpdb->get_results("SELECT $distinct $wpdb->comments.* FROM $wpdb->comments $cjoin $cwhere $cgroupby $corderby $climits");			$this->comment_count = count($this->comments);			$post_ids = array();			foreach ( $this->comments as $comment )				$post_ids[] = (int) $comment->comment_post_ID;			$post_ids = join(',', $post_ids);			$join = '';			if ( $post_ids )				$where = "AND $wpdb->posts.ID IN ($post_ids) ";			else				$where = "AND 0";		}		$orderby = $q['orderby'];		// Apply post-paging filters on where and join.  Only plugins that		// manipulate paging queries should use these hooks.		if ( !$q['suppress_filters'] ) {			$where		= apply_filters_ref_array( 'posts_where_paged',	array( $where, &$this ) );			$groupby	= apply_filters_ref_array( 'posts_groupby',		array( $groupby, &$this ) );			$join		= apply_filters_ref_array( 'posts_join_paged',	array( $join, &$this ) );			$orderby	= apply_filters_ref_array( 'posts_orderby',		array( $orderby, &$this ) );			$distinct	= apply_filters_ref_array( 'posts_distinct',	array( $distinct, &$this ) );			$limits		= apply_filters_ref_array( 'post_limits',		array( $limits, &$this ) );			$fields		= apply_filters_ref_array( 'posts_fields',		array( $fields, &$this ) );		}		// Announce current selection parameters.  For use by caching plugins.		do_action( 'posts_selection', $where . $groupby . $orderby . $limits . $join );		// Filter again for the benefit of caching plugins.  Regular plugins should use the hooks above.		if ( !$q['suppress_filters'] ) {			$where		= apply_filters_ref_array( 'posts_where_request',	array( $where, &$this ) );			$groupby	= apply_filters_ref_array( 'posts_groupby_request',		array( $groupby, &$this ) );			$join		= apply_filters_ref_array( 'posts_join_request',	array( $join, &$this ) );			$orderby	= apply_filters_ref_array( 'posts_orderby_request',		array( $orderby, &$this ) );			$distinct	= apply_filters_ref_array( 'posts_distinct_request',	array( $distinct, &$this ) );			$fields		= apply_filters_ref_array( 'posts_fields_request',		array( $fields, &$this ) );			$limits		= apply_filters_ref_array( 'post_limits_request',		array( $limits, &$this ) );		}		if ( ! empty($groupby) )			$groupby = 'GROUP BY ' . $groupby;		if ( !empty( $orderby ) )			$orderby = 'ORDER BY ' . $orderby;		$found_rows = '';		if ( !$q['no_found_rows'] && !empty($limits) )			$found_rows = 'SQL_CALC_FOUND_ROWS';		$this->request = " SELECT $found_rows $distinct $fields FROM $wpdb->posts $join WHERE 1=1 $where $groupby $orderby $limits";		if ( !$q['suppress_filters'] )			$this->request = apply_filters_ref_array('posts_request', array( $this->request, &$this ) );		$this->posts = $wpdb->get_results($this->request);		// Raw results filter.  Prior to status checks.		if ( !$q['suppress_filters'] )			$this->posts = apply_filters_ref_array('posts_results', array( $this->posts, &$this ) );		if ( !empty($this->posts) && $this->is_comment_feed && $this->is_singular ) {			$cjoin = apply_filters_ref_array('comment_feed_join', array( '', &$this ) );			$cwhere = apply_filters_ref_array('comment_feed_where', array( "WHERE comment_post_ID = '{$this->posts[0]->ID}' AND comment_approved = '1'", &$this ) );			$cgroupby = apply_filters_ref_array('comment_feed_groupby', array( '', &$this ) );			$cgroupby = ( ! empty( $cgroupby ) ) ? 'GROUP BY ' . $cgroupby : '';			$corderby = apply_filters_ref_array('comment_feed_orderby', array( 'comment_date_gmt DESC', &$this ) );			$corderby = ( ! empty( $corderby ) ) ? 'ORDER BY ' . $corderby : '';			$climits = apply_filters_ref_array('comment_feed_limits', array( 'LIMIT ' . get_option('posts_per_rss'), &$this ) );			$comments_request = "SELECT $wpdb->comments.* FROM $wpdb->comments $cjoin $cwhere $cgroupby $corderby $climits";			$this->comments = $wpdb->get_results($comments_request);			$this->comment_count = count($this->comments);		}		if ( !$q['no_found_rows'] && !empty($limits) ) {			$found_posts_query = apply_filters_ref_array( 'found_posts_query', array( 'SELECT FOUND_ROWS()', &$this ) );			$this->found_posts = $wpdb->get_var( $found_posts_query );			$this->found_posts = apply_filters_ref_array( 'found_posts', array( $this->found_posts, &$this ) );			$this->max_num_pages = ceil($this->found_posts / $q['posts_per_page']);		}		// Check post status to determine if post should be displayed.		if ( !empty($this->posts) && ($this->is_single || $this->is_page) ) {			$status = get_post_status($this->posts[0]);			$post_status_obj = get_post_status_object($status);			//$type = get_post_type($this->posts[0]);			if ( !$post_status_obj->public ) {				if ( ! is_user_logged_in() ) {					// User must be logged in to view unpublished posts.					$this->posts = array();				} else {					if  ( $post_status_obj->protected ) {						// User must have edit permissions on the draft to preview.						if ( ! current_user_can($edit_cap, $this->posts[0]->ID) ) {							$this->posts = array();						} else {							$this->is_preview = true;							if ( 'future' != $status )								$this->posts[0]->post_date = current_time('mysql');						}					} elseif ( $post_status_obj->private ) {						if ( ! current_user_can($read_cap, $this->posts[0]->ID) )							$this->posts = array();					} else {						$this->posts = array();					}				}			}			if ( $this->is_preview && current_user_can( $edit_cap, $this->posts[0]->ID ) )				$this->posts[0] = apply_filters_ref_array('the_preview', array( $this->posts[0], &$this ));		}		// Put sticky posts at the top of the posts array		$sticky_posts = get_option('sticky_posts');		if ( $this->is_home && $page <= 1 && is_array($sticky_posts) && !empty($sticky_posts) && !$q['caller_get_posts'] ) {			$num_posts = count($this->posts);			$sticky_offset = 0;			// Loop over posts and relocate stickies to the front.			for ( $i = 0; $i < $num_posts; $i++ ) {				if ( in_array($this->posts[$i]->ID, $sticky_posts) ) {					$sticky_post = $this->posts[$i];					// Remove sticky from current position					array_splice($this->posts, $i, 1);					// Move to front, after other stickies					array_splice($this->posts, $sticky_offset, 0, array($sticky_post));					// Increment the sticky offset.  The next sticky will be placed at this offset.					$sticky_offset++;					// Remove post from sticky posts array					$offset = array_search($sticky_post->ID, $sticky_posts);					unset( $sticky_posts[$offset] );				}			}			// If any posts have been excluded specifically, Ignore those that are sticky.			if ( !empty($sticky_posts) && !empty($q['post__not_in']) )				$sticky_posts = array_diff($sticky_posts, $q['post__not_in']);			// Fetch sticky posts that weren't in the query results			if ( !empty($sticky_posts) ) {				$stickies__in = implode(',', array_map( 'absint', $sticky_posts ));				// honor post type(s) if not set to any				$stickies_where = '';				if ( 'any' != $post_type && '' != $post_type ) {					if ( is_array( $post_type ) ) {						$post_types = join( "', '", $post_type );					} else {						$post_types = $post_type;					}					$stickies_where = "AND $wpdb->posts.post_type IN ('" . $post_types . "')";				}				$stickies = $wpdb->get_results( "SELECT * FROM $wpdb->posts WHERE $wpdb->posts.ID IN ($stickies__in) $stickies_where" );				foreach ( $stickies as $sticky_post ) {					// Ignore sticky posts the current user cannot read or are not published.					if ( 'publish' != $sticky_post->post_status )						continue;					array_splice($this->posts, $sticky_offset, 0, array($sticky_post));					$sticky_offset++;				}			}		}		if ( !$q['suppress_filters'] )			$this->posts = apply_filters_ref_array('the_posts', array( $this->posts, &$this ) );		$this->post_count = count($this->posts);		// Sanitize before caching so it'll only get done once		for ( $i = 0; $i < $this->post_count; $i++ ) {			$this->posts[$i] = sanitize_post($this->posts[$i], 'raw');		}		if ( $q['cache_results'] )			update_post_caches($this->posts, $post_type, $q['update_post_term_cache'], $q['update_post_meta_cache']);		if ( $this->post_count > 0 ) {			$this->post = $this->posts[0];		}		return $this->posts;	}	/**	 * Set up the next post and iterate current post index.	 *	 * @since 1.5.0	 * @access public	 *	 * @return object Next post.	 */	function next_post() {		$this->current_post++;		$this->post = $this->posts[$this->current_post];		return $this->post;	}	/**	 * Sets up the current post.	 *	 * Retrieves the next post, sets up the post, sets the 'in the loop'	 * property to true.	 *	 * @since 1.5.0	 * @access public	 * @uses $post	 * @uses do_action_ref_array() Calls 'loop_start' if loop has just started	 */	function the_post() {		global $post;		$this->in_the_loop = true;		if ( $this->current_post == -1 ) // loop has just started			do_action_ref_array('loop_start', array(&$this));		$post = $this->next_post();		setup_postdata($post);	}	/**	 * Whether there are more posts available in the loop.	 *	 * Calls action 'loop_end', when the loop is complete.	 *	 * @since 1.5.0	 * @access public	 * @uses do_action_ref_array() Calls 'loop_end' if loop is ended	 *	 * @return bool True if posts are available, false if end of loop.	 */	function have_posts() {		if ( $this->current_post + 1 < $this->post_count ) {			return true;		} elseif ( $this->current_post + 1 == $this->post_count && $this->post_count > 0 ) {			do_action_ref_array('loop_end', array(&$this));			// Do some cleaning up after the loop			$this->rewind_posts();		}		$this->in_the_loop = false;		return false;	}	/**	 * Rewind the posts and reset post index.	 *	 * @since 1.5.0	 * @access public	 */	function rewind_posts() {		$this->current_post = -1;		if ( $this->post_count > 0 ) {			$this->post = $this->posts[0];		}	}	/**	 * Iterate current comment index and return comment object.	 *	 * @since 2.2.0	 * @access public	 *	 * @return object Comment object.	 */	function next_comment() {		$this->current_comment++;		$this->comment = $this->comments[$this->current_comment];		return $this->comment;	}	/**	 * Sets up the current comment.	 *	 * @since 2.2.0	 * @access public	 * @global object $comment Current comment.	 * @uses do_action() Calls 'comment_loop_start' hook when first comment is processed.	 */	function the_comment() {		global $comment;		$comment = $this->next_comment();		if ( $this->current_comment == 0 ) {			do_action('comment_loop_start');		}	}	/**	 * Whether there are more comments available.	 *	 * Automatically rewinds comments when finished.	 *	 * @since 2.2.0	 * @access public	 *	 * @return bool True, if more comments. False, if no more posts.	 */	function have_comments() {		if ( $this->current_comment + 1 < $this->comment_count ) {			return true;		} elseif ( $this->current_comment + 1 == $this->comment_count ) {			$this->rewind_comments();		}		return false;	}	/**	 * Rewind the comments, resets the comment index and comment to first.	 *	 * @since 2.2.0	 * @access public	 */	function rewind_comments() {		$this->current_comment = -1;		if ( $this->comment_count > 0 ) {			$this->comment = $this->comments[0];		}	}	/**	 * Sets up the WordPress query by parsing query string.	 *	 * @since 1.5.0	 * @access public	 *	 * @param string $query URL query string.	 * @return array List of posts.	 */	function &query($query) {		$this->parse_query($query);		return $this->get_posts();	}	/**	 * Retrieve queried object.	 *	 * If queried object is not set, then the queried object will be set from	 * the category, tag, taxonomy, posts page, single post, page, or author	 * query variable. After it is set up, it will be returned.	 *	 * @since 1.5.0	 * @access public	 *	 * @return object	 */	function get_queried_object() {		if ( isset($this->queried_object) )			return $this->queried_object;		$this->queried_object = NULL;		$this->queried_object_id = 0;		if ( $this->is_category ) {			$cat = $this->get('cat');			$category = &get_category($cat);			if ( is_wp_error( $category ) )				return NULL;			$this->queried_object = &$category;			$this->queried_object_id = (int) $cat;		} elseif ( $this->is_tag ) {			$tag_id = $this->get('tag_id');			$tag = &get_term($tag_id, 'post_tag');			if ( is_wp_error( $tag ) )				return NULL;			$this->queried_object = &$tag;			$this->queried_object_id = (int) $tag_id;		} elseif ( $this->is_tax ) {			$tax = $this->get('taxonomy');			$slug = $this->get('term');			$term = &get_terms($tax, array( 'slug' => $slug, 'hide_empty' => false ) );			if ( is_wp_error($term) || empty($term) )				return NULL;			$term = $term[0];			$this->queried_object = $term;			$this->queried_object_id = $term->term_id;		} elseif ( $this->is_posts_page ) {			$this->queried_object = & get_page(get_option('page_for_posts'));			$this->queried_object_id = (int) $this->queried_object->ID;		} elseif ( $this->is_single && !is_null($this->post) ) {			$this->queried_object = $this->post;			$this->queried_object_id = (int) $this->post->ID;		} elseif ( $this->is_page && !is_null($this->post) ) {			$this->queried_object = $this->post;			$this->queried_object_id = (int) $this->post->ID;		} elseif ( $this->is_author ) {			$author_id = (int) $this->get('author');			$author = get_userdata($author_id);			$this->queried_object = $author;			$this->queried_object_id = $author_id;		}		return $this->queried_object;	}	/**	 * Retrieve ID of the current queried object.	 *	 * @since 1.5.0	 * @access public	 *	 * @return int	 */	function get_queried_object_id() {		$this->get_queried_object();		if ( isset($this->queried_object_id) ) {			return $this->queried_object_id;		}		return 0;	}	/**	 * PHP4 type constructor.	 *	 * Sets up the WordPress query, if parameter is not empty.	 *	 * @since 1.5.0	 * @access public	 *	 * @param string $query URL query string.	 * @return WP_Query	 */	function WP_Query($query = '') {		if ( ! empty($query) ) {			$this->query($query);		}	}}/** * Redirect old slugs to the correct permalink. * * Attempts to find the current slug from the past slugs. * * @since 2.1.0 * @uses $wp_query * @uses $wpdb * * @return null If no link is found, null is returned. */function wp_old_slug_redirect() {	global $wp_query;	if ( is_404() && '' != $wp_query->query_vars['name'] ) :		global $wpdb;		$query = "SELECT post_id FROM $wpdb->postmeta, $wpdb->posts WHERE ID = post_id AND meta_key = '_wp_old_slug' AND meta_value='" . $wp_query->query_vars['name'] . "'";		// if year, monthnum, or day have been specified, make our query more precise		// just in case there are multiple identical _wp_old_slug values		if ( '' != $wp_query->query_vars['year'] )			$query .= " AND YEAR(post_date) = '{$wp_query->query_vars['year']}'";		if ( '' != $wp_query->query_vars['monthnum'] )			$query .= " AND MONTH(post_date) = '{$wp_query->query_vars['monthnum']}'";		if ( '' != $wp_query->query_vars['day'] )			$query .= " AND DAYOFMONTH(post_date) = '{$wp_query->query_vars['day']}'";		$id = (int) $wpdb->get_var($query);		if ( !$id )			return;		$link = get_permalink($id);		if ( !$link )			return;		wp_redirect($link, '301'); // Permanent redirect		exit;	endif;}/** * Set up global post data. * * @since 1.5.0 * * @param object $post Post data. * @uses do_action_ref_array() Calls 'the_post' * @return bool True when finished. */function setup_postdata($post) {	global $id, $authordata, $day, $currentmonth, $page, $pages, $multipage, $more, $numpages;	$id = (int) $post->ID;	$authordata = get_userdata($post->post_author);	$day = mysql2date('d.m.y', $post->post_date, false);	$currentmonth = mysql2date('m', $post->post_date, false);	$numpages = 1;	$page = get_query_var('page');	if ( !$page )		$page = 1;	if ( is_single() || is_page() || is_feed() )		$more = 1;	$content = $post->post_content;	if ( strpos( $content, '<!--nextpage-->' ) ) {		if ( $page > 1 )			$more = 1;		$multipage = 1;		$content = str_replace("\n<!--nextpage-->\n", '<!--nextpage-->', $content);		$content = str_replace("\n<!--nextpage-->", '<!--nextpage-->', $content);		$content = str_replace("<!--nextpage-->\n", '<!--nextpage-->', $content);		$pages = explode('<!--nextpage-->', $content);		$numpages = count($pages);	} else {		$pages = array( $post->post_content );		$multipage = 0;	}	do_action_ref_array('the_post', array(&$post));	return true;}?>
<?php/** * Sets up the default filters and actions for most * of the WordPress hooks. * * If you need to remove a default hook, this file will * give you the priority for which to use to remove the * hook. * * Not all of the default hooks are found in default-filters.php * * @package WordPress */// Strip, trim, kses, special chars for string savesforeach ( array( 'pre_term_name', 'pre_comment_author_name', 'pre_link_name', 'pre_link_target', 'pre_link_rel', 'pre_user_display_name', 'pre_user_first_name', 'pre_user_last_name', 'pre_user_nickname' ) as $filter ) {	add_filter( $filter, 'sanitize_text_field'  );	add_filter( $filter, 'wp_filter_kses'       );	add_filter( $filter, '_wp_specialchars', 30 );}// Strip, kses, special chars for string displayforeach ( array( 'term_name', 'comment_author_name', 'link_name', 'link_target', 'link_rel', 'user_display_name', 'user_first_name', 'user_last_name', 'user_nickname' ) as $filter ) {	add_filter( $filter, 'sanitize_text_field'  );	add_filter( $filter, 'wp_kses_data'       );	add_filter( $filter, '_wp_specialchars', 30 );}// Kses only for textarea savesforeach ( array( 'pre_term_description', 'pre_link_description', 'pre_link_notes', 'pre_user_description' ) as $filter ) {	add_filter( $filter, 'wp_filter_kses' );}// Kses only for textarea saves displaysforeach ( array( 'term_description', 'link_description', 'link_notes', 'user_description' ) as $filter ) {	add_filter( $filter, 'wp_kses_data' );}// Email savesforeach ( array( 'pre_comment_author_email', 'pre_user_email' ) as $filter ) {	add_filter( $filter, 'trim'           );	add_filter( $filter, 'sanitize_email' );	add_filter( $filter, 'wp_filter_kses' );}// Email displayforeach ( array( 'comment_author_email', 'user_email' ) as $filter ) {	add_filter( $filter, 'sanitize_email' );	add_filter( $filter, 'wp_kses_data' );}// Save URLforeach ( array( 'pre_comment_author_url', 'pre_user_url', 'pre_link_url', 'pre_link_image',	'pre_link_rss' ) as $filter ) {	add_filter( $filter, 'wp_strip_all_tags' );	add_filter( $filter, 'esc_url_raw'       );	add_filter( $filter, 'wp_filter_kses'    );}// Display URLforeach ( array( 'user_url', 'link_url', 'link_image', 'link_rss', 'comment_url' ) as $filter ) {	add_filter( $filter, 'wp_strip_all_tags' );	add_filter( $filter, 'esc_url'           );	add_filter( $filter, 'wp_kses_data'    );}// Slugsforeach ( array( 'pre_term_slug' ) as $filter ) {	add_filter( $filter, 'sanitize_title' );}// Keysforeach ( array( 'pre_post_type' ) as $filter ) {	add_filter( $filter, 'sanitize_user' );}// Places to balance tags on inputforeach ( array( 'content_save_pre', 'excerpt_save_pre', 'comment_save_pre', 'pre_comment_content' ) as $filter ) {	add_filter( $filter, 'balanceTags', 50 );}// Format strings for display.foreach ( array( 'comment_author', 'term_name', 'link_name', 'link_description', 'link_notes', 'bloginfo', 'wp_title', 'widget_title' ) as $filter ) {	add_filter( $filter, 'wptexturize'   );	add_filter( $filter, 'convert_chars' );	add_filter( $filter, 'esc_html'      );}// Format WordPressforeach ( array( 'the_content', 'the_title', 'comment_text' ) as $filter )	add_filter( $filter, 'capital_P_dangit' );// Format titlesforeach ( array( 'single_post_title', 'single_cat_title', 'single_tag_title', 'single_month_title', 'nav_menu_attr_title', 'nav_menu_description' ) as $filter ) {	add_filter( $filter, 'wptexturize' );	add_filter( $filter, 'strip_tags'  );}// Format text area for display.foreach ( array( 'term_description' ) as $filter ) {	add_filter( $filter, 'wptexturize'      );	add_filter( $filter, 'convert_chars'    );	add_filter( $filter, 'wpautop'          );	add_filter( $filter, 'shortcode_unautop');}// Format for RSSforeach ( array( 'term_name_rss' ) as $filter ) {	add_filter( $filter, 'convert_chars' );}// Display filtersadd_filter( 'the_title', 'wptexturize'   );add_filter( 'the_title', 'convert_chars' );add_filter( 'the_title', 'trim'          );add_filter( 'the_content', 'wptexturize'        );add_filter( 'the_content', 'convert_smilies'    );add_filter( 'the_content', 'convert_chars'      );add_filter( 'the_content', 'wpautop'            );add_filter( 'the_content', 'shortcode_unautop'  );add_filter( 'the_content', 'prepend_attachment' );add_filter( 'the_excerpt',     'wptexturize'      );add_filter( 'the_excerpt',     'convert_smilies'  );add_filter( 'the_excerpt',     'convert_chars'    );add_filter( 'the_excerpt',     'wpautop'          );add_filter( 'the_excerpt',     'shortcode_unautop');add_filter( 'get_the_excerpt', 'wp_trim_excerpt'  );add_filter( 'comment_text', 'wptexturize'            );add_filter( 'comment_text', 'convert_chars'          );add_filter( 'comment_text', 'make_clickable',      9 );add_filter( 'comment_text', 'force_balance_tags', 25 );add_filter( 'comment_text', 'convert_smilies',    20 );add_filter( 'comment_text', 'wpautop',            30 );add_filter( 'comment_excerpt', 'convert_chars' );add_filter( 'list_cats',         'wptexturize' );add_filter( 'single_post_title', 'wptexturize' );add_filter( 'wp_sprintf', 'wp_sprintf_l', 10, 2 );// RSS filtersadd_filter( 'the_title_rss',      'strip_tags'      );add_filter( 'the_title_rss',      'ent2ncr',      8 );add_filter( 'the_title_rss',      'esc_html'        );add_filter( 'the_content_rss',    'ent2ncr',      8 );add_filter( 'the_excerpt_rss',    'convert_chars'   );add_filter( 'the_excerpt_rss',    'ent2ncr',      8 );add_filter( 'comment_author_rss', 'ent2ncr',      8 );add_filter( 'comment_text_rss',   'ent2ncr',      8 );add_filter( 'comment_text_rss',   'esc_html'        );add_filter( 'bloginfo_rss',       'ent2ncr',      8 );add_filter( 'the_author',         'ent2ncr',      8 );// Misc filtersadd_filter( 'option_ping_sites',    'privacy_ping_filter'                 );add_filter( 'option_blog_charset',  '_wp_specialchars'                    ); // IMPORTANT: This must not be wp_specialchars() or esc_html() or it'll cause an infinite loopadd_filter( 'option_home',          '_config_wp_home'                     );add_filter( 'option_siteurl',       '_config_wp_siteurl'                  );add_filter( 'tiny_mce_before_init', '_mce_set_direction'                  );add_filter( 'pre_kses',             'wp_pre_kses_less_than'               );add_filter( 'sanitize_title',       'sanitize_title_with_dashes'          );add_action( 'check_comment_flood',  'check_comment_flood_db',       10, 3 );add_filter( 'comment_flood_filter', 'wp_throttle_comment_flood',    10, 3 );add_filter( 'pre_comment_content',  'wp_rel_nofollow',              15    );add_filter( 'comment_email',        'antispambot'                         );add_filter( 'option_tag_base',      '_wp_filter_taxonomy_base'            );add_filter( 'option_category_base', '_wp_filter_taxonomy_base'            );add_filter( 'the_posts',            '_close_comments_for_old_posts'       );add_filter( 'comments_open',        '_close_comments_for_old_post', 10, 2 );add_filter( 'pings_open',           '_close_comments_for_old_post', 10, 2 );add_filter( 'editable_slug',        'urldecode'                           );add_filter( 'nav_menu_meta_box_object', '_wp_nav_menu_meta_box_object'    );// Atom SSL supportadd_filter( 'atom_service_url','atom_service_url_filter' );// Actionsadd_action( 'wp_head',             'wp_enqueue_scripts',            1     );add_action( 'wp_head',             'feed_links',                    2     );add_action( 'wp_head',             'feed_links_extra',              3     );add_action( 'wp_head',             'rsd_link'                             );add_action( 'wp_head',             'wlwmanifest_link'                     );add_action( 'wp_head',             'index_rel_link'                       );add_action( 'wp_head',             'parent_post_rel_link',          10, 0 );add_action( 'wp_head',             'start_post_rel_link',           10, 0 );add_action( 'wp_head',             'adjacent_posts_rel_link_wp_head', 10, 0 );add_action( 'wp_head',             'locale_stylesheet'                    );add_action( 'publish_future_post', 'check_and_publish_future_post', 10, 1 );add_action( 'wp_head',             'noindex',                       1     );add_action( 'wp_head',             'wp_print_styles',               8     );add_action( 'wp_head',             'wp_print_head_scripts',         9     );add_action( 'wp_head',             'wp_generator'                         );add_action( 'wp_head',             'rel_canonical'                        );add_action( 'wp_footer',           'wp_print_footer_scripts'              );add_action( 'wp_head',             'wp_shortlink_wp_head',          10, 0 );add_action( 'template_redirect',   'wp_shortlink_header',           11, 0 );// Feed Generator Tagsforeach ( array( 'rss2_head', 'commentsrss2_head', 'rss_head', 'rdf_header', 'atom_head', 'comments_atom_head', 'opml_head', 'app_head' ) as $action ) {	add_action( $action, 'the_generator' );}// WP Cronif ( !defined( 'DOING_CRON' ) )	add_action( 'sanitize_comment_cookies', 'wp_cron' );// 2 Actions 2 Furiousadd_action( 'do_feed_rdf',                'do_feed_rdf',             10, 1 );add_action( 'do_feed_rss',                'do_feed_rss',             10, 1 );add_action( 'do_feed_rss2',               'do_feed_rss2',            10, 1 );add_action( 'do_feed_atom',               'do_feed_atom',            10, 1 );add_action( 'do_pings',                   'do_all_pings',            10, 1 );add_action( 'do_robots',                  'do_robots'                      );add_action( 'sanitize_comment_cookies',   'sanitize_comment_cookies'       );add_action( 'admin_print_scripts',        'print_head_scripts',      20    );add_action( 'admin_print_footer_scripts', 'print_footer_scripts',    20    );add_action( 'admin_print_styles',         'print_admin_styles',      20    );add_action( 'init',                       'smilies_init',             5    );add_action( 'plugins_loaded',             'wp_maybe_load_widgets',    0    );add_action( 'plugins_loaded',             'wp_maybe_load_embeds',     0    );add_action( 'shutdown',                   'wp_ob_end_flush_all',      1    );add_action( 'pre_post_update',            'wp_save_post_revision'          );add_action( 'publish_post',               '_publish_post_hook',       5, 1 );add_action( 'save_post',                  '_save_post_hook',          5, 2 );add_action( 'transition_post_status',     '_transition_post_status',  5, 3 );add_action( 'comment_form', 'wp_comment_form_unfiltered_html_nonce'        );add_action( 'wp_scheduled_delete',        'wp_scheduled_delete'            );// Navigation menu actionsadd_action( 'delete_post',                '_wp_delete_post_menu_item'      );add_action( 'delete_term',                '_wp_delete_tax_menu_item'       );add_action( 'transition_post_status', '_wp_auto_add_pages_to_menu',  10, 3 );// Post Thumbnail CSS class filteringadd_action( 'begin_fetch_post_thumbnail_html', '_wp_post_thumbnail_class_filter_add'    );add_action( 'end_fetch_post_thumbnail_html',   '_wp_post_thumbnail_class_filter_remove' );// Redirect Old Slugsadd_action( 'template_redirect', 'wp_old_slug_redirect'              );add_action( 'post_updated',      'wp_check_for_changed_slugs', 12, 3 );// Nonce check for Post Previewsadd_action( 'init', '_show_post_preview' );// Timezoneadd_filter( 'pre_option_gmt_offset','wp_timezone_override_offset' );// Admin Color Schemesadd_action( 'admin_init', 'register_admin_color_schemes', 1);add_action( 'admin_color_scheme_picker', 'admin_color_scheme_picker' );?>
<?php/** * Metadata API * * Functions for retrieving and manipulating metadata of various WordPress object types.  Metadata * for an object is a represented by a simple key-value pair.  Objects may contain multiple * metadata entries that share the same key and differ only in their value. * * @package WordPress * @subpackage Meta * @since 2.9.0 *//** * Add metadata for the specified object. * * @since 2.9.0 * @uses $wpdb WordPress database object for queries. * @uses do_action() Calls 'added_{$meta_type}_meta' with meta_id of added metadata entry, * 		object ID, meta key, and meta value * * @param string $meta_type Type of object metadata is for (e.g., comment, post, or user) * @param int $object_id ID of the object metadata is for * @param string $meta_key Metadata key * @param string $meta_value Metadata value * @param bool $unique Optional, default is false.  Whether the specified metadata key should be * 		unique for the object.  If true, and the object already has a value for the specified * 		metadata key, no change will be made * @return bool True on successful update, false on failure. */function add_metadata($meta_type, $object_id, $meta_key, $meta_value, $unique = false) {	if ( !$meta_type || !$meta_key )		return false;	if ( !$object_id = absint($object_id) )		return false;	if ( ! $table = _get_meta_table($meta_type) )		return false;	global $wpdb;	$column = esc_sql($meta_type . '_id');	// expected_slashed ($meta_key)	$meta_key = stripslashes($meta_key);	if ( $unique && $wpdb->get_var( $wpdb->prepare(		"SELECT COUNT(*) FROM $table WHERE meta_key = %s AND $column = %d",		$meta_key, $object_id ) ) )		return false;	$_meta_value = $meta_value;	$meta_value = maybe_serialize( stripslashes_deep($meta_value) );	$wpdb->insert( $table, array(		$column => $object_id,		'meta_key' => $meta_key,		'meta_value' => $meta_value	) );	wp_cache_delete($object_id, $meta_type . '_meta');	// users cache stores usermeta that must be cleared.	if ( 'user' == $meta_type )		clean_user_cache($object_id);	do_action( "added_{$meta_type}_meta", $wpdb->insert_id, $object_id, $meta_key, $_meta_value );	return true;}/** * Update metadata for the specified object.  If no value already exists for the specified object * ID and metadata key, the metadata will be added. * * @since 2.9.0 * @uses $wpdb WordPress database object for queries. * @uses do_action() Calls 'update_{$meta_type}_meta' before updating metadata with meta_id of * 		metadata entry to update, object ID, meta key, and meta value * @uses do_action() Calls 'updated_{$meta_type}_meta' after updating metadata with meta_id of * 		updated metadata entry, object ID, meta key, and meta value * * @param string $meta_type Type of object metadata is for (e.g., comment, post, or user) * @param int $object_id ID of the object metadata is for * @param string $meta_key Metadata key * @param string $meta_value Metadata value * @param string $prev_value Optional.  If specified, only update existing metadata entries with * 		the specified value.  Otherwise, update all entries. * @return bool True on successful update, false on failure. */function update_metadata($meta_type, $object_id, $meta_key, $meta_value, $prev_value = '') {	if ( !$meta_type || !$meta_key )		return false;	if ( !$object_id = absint($object_id) )		return false;	if ( ! $table = _get_meta_table($meta_type) )		return false;	global $wpdb;	$column = esc_sql($meta_type . '_id');	$id_column = 'user' == $meta_type ? 'umeta_id' : 'meta_id';	// expected_slashed ($meta_key)	$meta_key = stripslashes($meta_key);	if ( ! $meta_id = $wpdb->get_var( $wpdb->prepare( "SELECT $id_column FROM $table WHERE meta_key = %s AND $column = %d", $meta_key, $object_id ) ) )		return add_metadata($meta_type, $object_id, $meta_key, $meta_value);	// Compare existing value to new value if no prev value given and the key exists only once.	if ( empty($prev_value) ) {		$old_value = get_metadata($meta_type, $object_id, $meta_key);		if ( count($old_value) == 1 ) {			if ( $old_value[0] == $meta_value )				return false;		}	}	$_meta_value = $meta_value;	$meta_value = maybe_serialize( stripslashes_deep($meta_value) );	$data  = compact( 'meta_value' );	$where = array( $column => $object_id, 'meta_key' => $meta_key );	if ( !empty( $prev_value ) ) {		$prev_value = maybe_serialize($prev_value);		$where['meta_value'] = $prev_value;	}	do_action( "update_{$meta_type}_meta", $meta_id, $object_id, $meta_key, $_meta_value );	$wpdb->update( $table, $data, $where );	wp_cache_delete($object_id, $meta_type . '_meta');	// users cache stores usermeta that must be cleared.	if ( 'user' == $meta_type )		clean_user_cache($object_id);	do_action( "updated_{$meta_type}_meta", $meta_id, $object_id, $meta_key, $_meta_value );	return true;}/** * Delete metadata for the specified object. * * @since 2.9.0 * @uses $wpdb WordPress database object for queries. * @uses do_action() Calls 'deleted_{$meta_type}_meta' after deleting with meta_id of * 		deleted metadata entries, object ID, meta key, and meta value * * @param string $meta_type Type of object metadata is for (e.g., comment, post, or user) * @param int $object_id ID of the object metadata is for * @param string $meta_key Metadata key * @param string $meta_value Optional. Metadata value.  If specified, only delete metadata entries * 		with this value.  Otherwise, delete all entries with the specified meta_key. * @param bool $delete_all Optional, default is false.  If true, delete matching metadata entries * 		for all objects, ignoring the specified object_id.  Otherwise, only delete matching * 		metadata entries for the specified object_id. * @return bool True on successful delete, false on failure. */function delete_metadata($meta_type, $object_id, $meta_key, $meta_value = '', $delete_all = false) {	if ( !$meta_type || !$meta_key )		return false;	if ( (!$object_id = absint($object_id)) && !$delete_all )		return false;	if ( ! $table = _get_meta_table($meta_type) )		return false;	global $wpdb;	$type_column = esc_sql($meta_type . '_id');	$id_column = 'user' == $meta_type ? 'umeta_id' : 'meta_id';	// expected_slashed ($meta_key)	$meta_key = stripslashes($meta_key);	$meta_value = maybe_serialize( stripslashes_deep($meta_value) );	$query = $wpdb->prepare( "SELECT $id_column FROM $table WHERE meta_key = %s", $meta_key );	if ( !$delete_all )		$query .= $wpdb->prepare(" AND $type_column = %d", $object_id );	if ( $meta_value )		$query .= $wpdb->prepare(" AND meta_value = %s", $meta_value );	$meta_ids = $wpdb->get_col( $query );	if ( !count( $meta_ids ) )		return false;	$query = "DELETE FROM $table WHERE $id_column IN( " . implode( ',', $meta_ids ) . " )";	$count = $wpdb->query($query);	if ( !$count )		return false;	wp_cache_delete($object_id, $meta_type . '_meta');	// users cache stores usermeta that must be cleared.	if ( 'user' == $meta_type )		clean_user_cache($object_id);	do_action( "deleted_{$meta_type}_meta", $meta_ids, $object_id, $meta_key, $meta_value );	return true;}/** * Retrieve metadata for the specified object. * * @since 2.9.0 * * @param string $meta_type Type of object metadata is for (e.g., comment, post, or user) * @param int $object_id ID of the object metadata is for * @param string $meta_key Optional.  Metadata key.  If not specified, retrieve all metadata for * 		the specified object. * @param bool $single Optional, default is false.  If true, return only the first value of the * 		specified meta_key.  This parameter has no effect if meta_key is not specified. * @return string|array Single metadata value, or array of values */function get_metadata($meta_type, $object_id, $meta_key = '', $single = false) {	if ( !$meta_type )		return false;	if ( !$object_id = absint($object_id) )		return false;	$meta_cache = wp_cache_get($object_id, $meta_type . '_meta');	if ( !$meta_cache ) {		update_meta_cache($meta_type, $object_id);		$meta_cache = wp_cache_get($object_id, $meta_type . '_meta');	}	if ( ! $meta_key )		return $meta_cache;	if ( isset($meta_cache[$meta_key]) ) {		if ( $single )			return maybe_unserialize( $meta_cache[$meta_key][0] );		else			return array_map('maybe_unserialize', $meta_cache[$meta_key]);	}	if ($single)		return '';	else		return array();}/** * Update the metadata cache for the specified objects. * * @since 2.9.0 * @uses $wpdb WordPress database object for queries. * * @param string $meta_type Type of object metadata is for (e.g., comment, post, or user) * @param int|array $object_ids array or comma delimited list of object IDs to update cache for * @return mixed Metadata cache for the specified objects, or false on failure. */function update_meta_cache($meta_type, $object_ids) {	if ( empty( $meta_type ) || empty( $object_ids ) )		return false;	if ( ! $table = _get_meta_table($meta_type) )		return false;	$column = esc_sql($meta_type . '_id');	global $wpdb;	if ( !is_array($object_ids) ) {		$object_ids = preg_replace('|[^0-9,]|', '', $object_ids);		$object_ids = explode(',', $object_ids);	}	$object_ids = array_map('intval', $object_ids);	$cache_key = $meta_type . '_meta';	$ids = array();	foreach ( $object_ids as $id ) {		if ( false === wp_cache_get($id, $cache_key) )			$ids[] = $id;	}	if ( empty( $ids ) )		return false;	// Get meta info	$id_list = join(',', $ids);	$cache = array();	$meta_list = $wpdb->get_results( $wpdb->prepare("SELECT $column, meta_key, meta_value FROM $table WHERE $column IN ($id_list)",		$meta_type), ARRAY_A );	if ( !empty($meta_list) ) {		foreach ( $meta_list as $metarow) {			$mpid = intval($metarow[$column]);			$mkey = $metarow['meta_key'];			$mval = $metarow['meta_value'];			// Force subkeys to be array type:			if ( !isset($cache[$mpid]) || !is_array($cache[$mpid]) )				$cache[$mpid] = array();			if ( !isset($cache[$mpid][$mkey]) || !is_array($cache[$mpid][$mkey]) )				$cache[$mpid][$mkey] = array();			// Add a value to the current pid/key:			$cache[$mpid][$mkey][] = $mval;		}	}	foreach ( $ids as $id ) {		if ( ! isset($cache[$id]) )			$cache[$id] = array();	}	foreach ( array_keys($cache) as $object)		wp_cache_set($object, $cache[$object], $cache_key);	return $cache;}/** * Retrieve the name of the metadata table for the specified object type. * * @since 2.9.0 * @uses $wpdb WordPress database object for queries. * * @param string $meta_type Type of object to get metadata table for (e.g., comment, post, or user) * @return mixed Metadata table name, or false if no metadata table exists */function _get_meta_table($type) {	global $wpdb;	$table_name = $type . 'meta';	if ( empty($wpdb->$table_name) )		return false;	return $wpdb->$table_name;}?>
<?php/** * Upgrade WordPress Page. * * @package WordPress * @subpackage Administration *//** * We are upgrading WordPress. * * @since unknown * @var bool */define( 'WP_INSTALLING', true );/** Load WordPress Bootstrap */require( '../wp-load.php' );timer_start();require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );delete_site_transient('update_core');if ( isset( $_GET['step'] ) )	$step = $_GET['step'];else	$step = 0;// Do it.  No output.if ( 'upgrade_db' === $step ) {	wp_upgrade();	die( '0' );}$step = (int) $step;$php_version    = phpversion();$mysql_version  = $wpdb->db_version();$php_compat     = version_compare( $php_version, $required_php_version, '>=' );$mysql_compat   = version_compare( $mysql_version, $required_mysql_version, '>=' ) || file_exists( WP_CONTENT_DIR . '/db.php' );@header( 'Content-Type: ' . get_option( 'html_type' ) . '; charset=' . get_option( 'blog_charset' ) );?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" <?php language_attributes(); ?>><head>	<meta http-equiv="Content-Type" content="<?php bloginfo( 'html_type' ); ?>; charset=<?php echo get_option( 'blog_charset' ); ?>" />	<title><?php _e( 'WordPress &rsaquo; Upgrade' ); ?></title>	<?php	wp_admin_css( 'install', true );	wp_admin_css( 'ie', true );	?></head><body><h1 id="logo"><img alt="WordPress" src="images/wordpress-logo.png" /></h1><?php if ( get_option( 'db_version' ) == $wp_db_version || !is_blog_installed() ) : ?><h2><?php _e( 'No Upgrade Required' ); ?></h2><p><?php _e( 'Your WordPress database is already up-to-date!' ); ?></p><p class="step"><a class="button" href="<?php echo get_option( 'home' ); ?>/"><?php _e( 'Continue' ); ?></a></p><?php elseif ( !$php_compat || !$mysql_compat ) :	if ( !$mysql_compat && !$php_compat )		printf( __('You cannot upgrade because <a href="http://codex.wordpress.org/Version_%1$s">WordPress %1$s</a> requires PHP version %2$s or higher and MySQL version %3$s or higher. You are running PHP version %4$s and MySQL version %5$s.'), $wp_version, $required_php_version, $required_mysql_version, $php_version, $mysql_version );	elseif ( !$php_compat )		printf( __('You cannot upgrade because <a href="http://codex.wordpress.org/Version_%1$s">WordPress %1$s</a> requires PHP version %2$s or higher. You are running version %3$s.'), $wp_version, $required_php_version, $php_version );	elseif ( !$mysql_compat )		printf( __('You cannot upgrade because <a href="http://codex.wordpress.org/Version_%1$s">WordPress %1$s</a> requires MySQL version %2$s or higher. You are running version %3$s.'), $wp_version, $required_mysql_version, $mysql_version );?><?php else :switch ( $step ) :	case 0:		$goback = stripslashes( wp_get_referer() );		$goback = esc_url_raw( $goback );		$goback = urlencode( $goback );?><h2><?php _e( 'Database Upgrade Required' ); ?></h2><p><?php _e( 'WordPress has been updated! Before we send you on your way, we have to upgrade your database to the newest version.' ); ?></p><p><?php _e( 'The upgrade process may take a little while, so please be patient.' ); ?></p><p class="step"><a class="button" href="upgrade.php?step=1&amp;backto=<?php echo $goback; ?>"><?php _e( 'Upgrade WordPress Database' ); ?></a></p><?php		break;	case 1:		wp_upgrade();			$backto = !empty($_GET['backto']) ? stripslashes( urldecode( $_GET['backto'] ) ) :  __get_option( 'home' ) . '/';			$backto = esc_url_raw( $backto );			$backto = wp_validate_redirect($backto, __get_option( 'home' ) . '/');?><h2><?php _e( 'Upgrade Complete' ); ?></h2>	<p><?php _e( 'Your WordPress database has been successfully upgraded!' ); ?></p>	<p class="step"><a class="button" href="<?php echo $backto; ?>"><?php _e( 'Continue' ); ?></a></p><!--<pre><?php printf( __( '%s queries' ), $wpdb->num_queries ); ?><?php printf( __( '%s seconds' ), timer_stop( 0 ) ); ?></pre>--><?php		break;endswitch;endif;?></body></html>
<?php/** * Manages WordPress comments * * @package WordPress * @subpackage Comment *//** * Checks whether a comment passes internal checks to be allowed to add. * * If comment moderation is set in the administration, then all comments, * regardless of their type and whitelist will be set to false. If the number of * links exceeds the amount in the administration, then the check fails. If any * of the parameter contents match the blacklist of words, then the check fails. * * If the number of links exceeds the amount in the administration, then the * check fails. If any of the parameter contents match the blacklist of words, * then the check fails. * * If the comment is a trackback and part of the blogroll, then the trackback is * automatically whitelisted. If the comment author was approved before, then * the comment is automatically whitelisted. * * If none of the checks fail, then the failback is to set the check to pass * (return true). * * @since 1.2.0 * @uses $wpdb * * @param string $author Comment Author's name * @param string $email Comment Author's email * @param string $url Comment Author's URL * @param string $comment Comment contents * @param string $user_ip Comment Author's IP address * @param string $user_agent Comment Author's User Agent * @param string $comment_type Comment type, either user submitted comment, *		trackback, or pingback * @return bool Whether the checks passed (true) and the comments should be *		displayed or set to moderated */function check_comment($author, $email, $url, $comment, $user_ip, $user_agent, $comment_type) {	global $wpdb;	if ( 1 == get_option('comment_moderation') )		return false; // If moderation is set to manual	// Check # of external links	if ( $max_links = get_option( 'comment_max_links' ) ) {		$num_links = preg_match_all( '/<a [^>]*href/i', apply_filters( 'comment_text', $comment ), $out );		$num_links = apply_filters( 'comment_max_links_url', $num_links, $url ); // provide for counting of $url as a link		if ( $num_links >= $max_links )			return false;	}	$mod_keys = trim(get_option('moderation_keys'));	if ( !empty($mod_keys) ) {		$words = explode("\n", $mod_keys );		foreach ( (array) $words as $word) {			$word = trim($word);			// Skip empty lines			if ( empty($word) )				continue;			// Do some escaping magic so that '#' chars in the			// spam words don't break things:			$word = preg_quote($word, '#');			$pattern = "#$word#i";			if ( preg_match($pattern, $author) ) return false;			if ( preg_match($pattern, $email) ) return false;			if ( preg_match($pattern, $url) ) return false;			if ( preg_match($pattern, $comment) ) return false;			if ( preg_match($pattern, $user_ip) ) return false;			if ( preg_match($pattern, $user_agent) ) return false;		}	}	// Comment whitelisting:	if ( 1 == get_option('comment_whitelist')) {		if ( 'trackback' == $comment_type || 'pingback' == $comment_type ) { // check if domain is in blogroll			$uri = parse_url($url);			$domain = $uri['host'];			$uri = parse_url( home_url() );			$home_domain = $uri['host'];			if ( $wpdb->get_var($wpdb->prepare("SELECT link_id FROM $wpdb->links WHERE link_url LIKE (%s) LIMIT 1", '%'.$domain.'%')) || $domain == $home_domain )				return true;			else				return false;		} elseif ( $author != '' && $email != '' ) {			// expected_slashed ($author, $email)			$ok_to_comment = $wpdb->get_var("SELECT comment_approved FROM $wpdb->comments WHERE comment_author = '$author' AND comment_author_email = '$email' and comment_approved = '1' LIMIT 1");			if ( ( 1 == $ok_to_comment ) &&				( empty($mod_keys) || false === strpos( $email, $mod_keys) ) )					return true;			else				return false;		} else {			return false;		}	}	return true;}/** * Retrieve the approved comments for post $post_id. * * @since 2.0.0 * @uses $wpdb * * @param int $post_id The ID of the post * @return array $comments The approved comments */function get_approved_comments($post_id) {	global $wpdb;	return $wpdb->get_results($wpdb->prepare("SELECT * FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved = '1' ORDER BY comment_date", $post_id));}/** * Retrieves comment data given a comment ID or comment object. * * If an object is passed then the comment data will be cached and then returned * after being passed through a filter. If the comment is empty, then the global * comment variable will be used, if it is set. * * If the comment is empty, then the global comment variable will be used, if it * is set. * * @since 2.0.0 * @uses $wpdb * * @param object|string|int $comment Comment to retrieve. * @param string $output Optional. OBJECT or ARRAY_A or ARRAY_N constants. * @return object|array|null Depends on $output value. */function &get_comment(&$comment, $output = OBJECT) {	global $wpdb;	$null = null;	if ( empty($comment) ) {		if ( isset($GLOBALS['comment']) )			$_comment = & $GLOBALS['comment'];		else			$_comment = null;	} elseif ( is_object($comment) ) {		wp_cache_add($comment->comment_ID, $comment, 'comment');		$_comment = $comment;	} else {		if ( isset($GLOBALS['comment']) && ($GLOBALS['comment']->comment_ID == $comment) ) {			$_comment = & $GLOBALS['comment'];		} elseif ( ! $_comment = wp_cache_get($comment, 'comment') ) {			$_comment = $wpdb->get_row($wpdb->prepare("SELECT * FROM $wpdb->comments WHERE comment_ID = %d LIMIT 1", $comment));			if ( ! $_comment )				return $null;			wp_cache_add($_comment->comment_ID, $_comment, 'comment');		}	}	$_comment = apply_filters('get_comment', $_comment);	if ( $output == OBJECT ) {		return $_comment;	} elseif ( $output == ARRAY_A ) {		$__comment = get_object_vars($_comment);		return $__comment;	} elseif ( $output == ARRAY_N ) {		$__comment = array_values(get_object_vars($_comment));		return $__comment;	} else {		return $_comment;	}}/** * Retrieve a list of comments. * * The comment list can be for the blog as a whole or for an individual post. * * The list of comment arguments are 'status', 'orderby', 'comment_date_gmt', * 'order', 'number', 'offset', and 'post_id'. * * @since 2.7.0 * @uses $wpdb * * @param mixed $args Optional. Array or string of options to override defaults. * @return array List of comments. */function get_comments( $args = '' ) {	global $wpdb;	$defaults = array(		'author_email' => '',		'ID' => '',		'karma' => '',		'number' => '',		'offset' => '',		'orderby' => '',		'order' => 'DESC',		'parent' => '',		'post_ID' => '',		'post_id' => 0,		'status' => '',		'type' => '',		'user_id' => '',	);	$args = wp_parse_args( $args, $defaults );	extract( $args, EXTR_SKIP );	// $args can be whatever, only use the args defined in defaults to compute the key	$key = md5( serialize( compact(array_keys($defaults)) )  );	$last_changed = wp_cache_get('last_changed', 'comment');	if ( !$last_changed ) {		$last_changed = time();		wp_cache_set('last_changed', $last_changed, 'comment');	}	$cache_key = "get_comments:$key:$last_changed";	if ( $cache = wp_cache_get( $cache_key, 'comment' ) ) {		return $cache;	}	$post_id = absint($post_id);	if ( 'hold' == $status )		$approved = "comment_approved = '0'";	elseif ( 'approve' == $status )		$approved = "comment_approved = '1'";	elseif ( 'spam' == $status )		$approved = "comment_approved = 'spam'";	elseif ( 'trash' == $status )		$approved = "comment_approved = 'trash'";	else		$approved = "( comment_approved = '0' OR comment_approved = '1' )";	$order = ( 'ASC' == $order ) ? 'ASC' : 'DESC';	if ( ! empty( $orderby ) ) {		$ordersby = is_array($orderby) ? $orderby : preg_split('/[,\s]/', $orderby);		$ordersby = array_intersect(			$ordersby,			array(				'comment_agent',				'comment_approved',				'comment_author',				'comment_author_email',				'comment_author_IP',				'comment_author_url',				'comment_content',				'comment_date',				'comment_date_gmt',				'comment_ID',				'comment_karma',				'comment_parent',				'comment_post_ID',				'comment_type',				'user_id',			)		);		$orderby = empty( $ordersby ) ? 'comment_date_gmt' : implode(', ', $ordersby);	} else {		$orderby = 'comment_date_gmt';	}	$number = absint($number);	$offset = absint($offset);	if ( !empty($number) ) {		if ( $offset )			$number = 'LIMIT ' . $offset . ',' . $number;		else			$number = 'LIMIT ' . $number;	} else {		$number = '';	}	$post_where = '';	if ( ! empty($post_id) )		$post_where .= $wpdb->prepare( 'comment_post_ID = %d AND ', $post_id );	if ( '' !== $author_email )		$post_where .= $wpdb->prepare( 'comment_author_email = %s AND ', $author_email );	if ( '' !== $karma )		$post_where .= $wpdb->prepare( 'comment_karma = %d AND ', $karma );	if ( 'comment' == $type )		$post_where .= "comment_type = '' AND ";	elseif ( ! empty( $type ) )		$post_where .= $wpdb->prepare( 'comment_type = %s AND ', $type );	if ( '' !== $parent )		$post_where .= $wpdb->prepare( 'comment_parent = %d AND ', $parent );	if ( '' !== $user_id )		$post_where .= $wpdb->prepare( 'user_id = %d AND ', $user_id );	$comments = $wpdb->get_results( "SELECT * FROM $wpdb->comments WHERE $post_where $approved ORDER BY $orderby $order $number" );	wp_cache_add( $cache_key, $comments, 'comment' );	return $comments;}/** * Retrieve all of the WordPress supported comment statuses. * * Comments have a limited set of valid status values, this provides the comment * status values and descriptions. * * @package WordPress * @subpackage Post * @since 2.7.0 * * @return array List of comment statuses. */function get_comment_statuses( ) {	$status = array(		'hold'		=> __('Unapproved'),		/* translators: comment status  */		'approve'	=> _x('Approved', 'adjective'),		/* translators: comment status */		'spam'		=> _x('Spam', 'adjective'),	);	return $status;}/** * The date the last comment was modified. * * @since 1.5.0 * @uses $wpdb * @global array $cache_lastcommentmodified * * @param string $timezone Which timezone to use in reference to 'gmt', 'blog', *		or 'server' locations. * @return string Last comment modified date. */function get_lastcommentmodified($timezone = 'server') {	global $cache_lastcommentmodified, $wpdb;	if ( isset($cache_lastcommentmodified[$timezone]) )		return $cache_lastcommentmodified[$timezone];	$add_seconds_server = date('Z');	switch ( strtolower($timezone)) {		case 'gmt':			$lastcommentmodified = $wpdb->get_var("SELECT comment_date_gmt FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1");			break;		case 'blog':			$lastcommentmodified = $wpdb->get_var("SELECT comment_date FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1");			break;		case 'server':			$lastcommentmodified = $wpdb->get_var($wpdb->prepare("SELECT DATE_ADD(comment_date_gmt, INTERVAL %s SECOND) FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1", $add_seconds_server));			break;	}	$cache_lastcommentmodified[$timezone] = $lastcommentmodified;	return $lastcommentmodified;}/** * The amount of comments in a post or total comments. * * A lot like {@link wp_count_comments()}, in that they both return comment * stats (albeit with different types). The {@link wp_count_comments()} actual * caches, but this function does not. * * @since 2.0.0 * @uses $wpdb * * @param int $post_id Optional. Comment amount in post if > 0, else total comments blog wide. * @return array The amount of spam, approved, awaiting moderation, and total comments. */function get_comment_count( $post_id = 0 ) {	global $wpdb;	$post_id = (int) $post_id;	$where = '';	if ( $post_id > 0 ) {		$where = $wpdb->prepare("WHERE comment_post_ID = %d", $post_id);	}	$totals = (array) $wpdb->get_results("		SELECT comment_approved, COUNT( * ) AS total		FROM {$wpdb->comments}		{$where}		GROUP BY comment_approved	", ARRAY_A);	$comment_count = array(		"approved"              => 0,		"awaiting_moderation"   => 0,		"spam"                  => 0,		"total_comments"        => 0	);	foreach ( $totals as $row ) {		switch ( $row['comment_approved'] ) {			case 'spam':				$comment_count['spam'] = $row['total'];				$comment_count["total_comments"] += $row['total'];				break;			case 1:				$comment_count['approved'] = $row['total'];				$comment_count['total_comments'] += $row['total'];				break;			case 0:				$comment_count['awaiting_moderation'] = $row['total'];				$comment_count['total_comments'] += $row['total'];				break;			default:				break;		}	}	return $comment_count;}//// Comment meta functions///** * Add meta data field to a comment. * * @since 2.9.0 * @uses add_metadata * @link http://codex.wordpress.org/Function_Reference/add_comment_meta * * @param int $comment_id Comment ID. * @param string $key Metadata name. * @param mixed $value Metadata value. * @param bool $unique Optional, default is false. Whether the same key should not be added. * @return bool False for failure. True for success. */function add_comment_meta($comment_id, $meta_key, $meta_value, $unique = false) {	return add_metadata('comment', $comment_id, $meta_key, $meta_value, $unique);}/** * Remove metadata matching criteria from a comment. * * You can match based on the key, or key and value. Removing based on key and * value, will keep from removing duplicate metadata with the same key. It also * allows removing all metadata matching key, if needed. * * @since 2.9.0 * @uses delete_metadata * @link http://codex.wordpress.org/Function_Reference/delete_comment_meta * * @param int $comment_id comment ID * @param string $meta_key Metadata name. * @param mixed $meta_value Optional. Metadata value. * @return bool False for failure. True for success. */function delete_comment_meta($comment_id, $meta_key, $meta_value = '') {	return delete_metadata('comment', $comment_id, $meta_key, $meta_value);}/** * Retrieve comment meta field for a comment. * * @since 2.9.0 * @uses get_metadata * @link http://codex.wordpress.org/Function_Reference/get_comment_meta * * @param int $comment_id Comment ID. * @param string $key The meta key to retrieve. * @param bool $single Whether to return a single value. * @return mixed Will be an array if $single is false. Will be value of meta data field if $single *  is true. */function get_comment_meta($comment_id, $key, $single = false) {	return get_metadata('comment', $comment_id, $key, $single);}/** * Update comment meta field based on comment ID. * * Use the $prev_value parameter to differentiate between meta fields with the * same key and comment ID. * * If the meta field for the comment does not exist, it will be added. * * @since 2.9.0 * @uses update_metadata * @link http://codex.wordpress.org/Function_Reference/update_comment_meta * * @param int $comment_id Comment ID. * @param string $key Metadata key. * @param mixed $value Metadata value. * @param mixed $prev_value Optional. Previous value to check before removing. * @return bool False on failure, true if success. */function update_comment_meta($comment_id, $meta_key, $meta_value, $prev_value = '') {	return update_metadata('comment', $comment_id, $meta_key, $meta_value, $prev_value);}/** * Sanitizes the cookies sent to the user already. * * Will only do anything if the cookies have already been created for the user. * Mostly used after cookies had been sent to use elsewhere. * * @since 2.0.4 */function sanitize_comment_cookies() {	if ( isset($_COOKIE['comment_author_'.COOKIEHASH]) ) {		$comment_author = apply_filters('pre_comment_author_name', $_COOKIE['comment_author_'.COOKIEHASH]);		$comment_author = stripslashes($comment_author);		$comment_author = esc_attr($comment_author);		$_COOKIE['comment_author_'.COOKIEHASH] = $comment_author;	}	if ( isset($_COOKIE['comment_author_email_'.COOKIEHASH]) ) {		$comment_author_email = apply_filters('pre_comment_author_email', $_COOKIE['comment_author_email_'.COOKIEHASH]);		$comment_author_email = stripslashes($comment_author_email);		$comment_author_email = esc_attr($comment_author_email);		$_COOKIE['comment_author_email_'.COOKIEHASH] = $comment_author_email;	}	if ( isset($_COOKIE['comment_author_url_'.COOKIEHASH]) ) {		$comment_author_url = apply_filters('pre_comment_author_url', $_COOKIE['comment_author_url_'.COOKIEHASH]);		$comment_author_url = stripslashes($comment_author_url);		$_COOKIE['comment_author_url_'.COOKIEHASH] = $comment_author_url;	}}/** * Validates whether this comment is allowed to be made. * * @since 2.0.0 * @uses $wpdb * @uses apply_filters() Calls 'pre_comment_approved' hook on the type of comment * @uses apply_filters() Calls 'comment_duplicate_trigger' hook on commentdata. * @uses do_action() Calls 'check_comment_flood' hook on $comment_author_IP, $comment_author_email, and $comment_date_gmt * * @param array $commentdata Contains information on the comment * @return mixed Signifies the approval status (0|1|'spam') */function wp_allow_comment($commentdata) {	global $wpdb;	extract($commentdata, EXTR_SKIP);	// Simple duplicate check	// expected_slashed ($comment_post_ID, $comment_author, $comment_author_email, $comment_content)	$dupe = "SELECT comment_ID FROM $wpdb->comments WHERE comment_post_ID = '$comment_post_ID' AND comment_approved != 'trash' AND ( comment_author = '$comment_author' ";	if ( $comment_author_email )		$dupe .= "OR comment_author_email = '$comment_author_email' ";	$dupe .= ") AND comment_content = '$comment_content' LIMIT 1";	if ( $wpdb->get_var($dupe) ) {		do_action( 'comment_duplicate_trigger', $commentdata );		if ( defined('DOING_AJAX') )			die( __('Duplicate comment detected; it looks as though you&#8217;ve already said that!') );		wp_die( __('Duplicate comment detected; it looks as though you&#8217;ve already said that!') );	}	do_action( 'check_comment_flood', $comment_author_IP, $comment_author_email, $comment_date_gmt );	if ( isset($user_id) && $user_id) {		$userdata = get_userdata($user_id);		$user = new WP_User($user_id);		$post_author = $wpdb->get_var($wpdb->prepare("SELECT post_author FROM $wpdb->posts WHERE ID = %d LIMIT 1", $comment_post_ID));	}	if ( isset($userdata) && ( $user_id == $post_author || $user->has_cap('moderate_comments') ) ) {		// The author and the admins get respect.		$approved = 1;	 } else {		// Everyone else's comments will be checked.		if ( check_comment($comment_author, $comment_author_email, $comment_author_url, $comment_content, $comment_author_IP, $comment_agent, $comment_type) )			$approved = 1;		else			$approved = 0;		if ( wp_blacklist_check($comment_author, $comment_author_email, $comment_author_url, $comment_content, $comment_author_IP, $comment_agent) )			$approved = 'spam';	}	$approved = apply_filters('pre_comment_approved', $approved);	return $approved;}/** * Check whether comment flooding is occurring. * * Won't run, if current user can manage options, so to not block * administrators. * * @since 2.3.0 * @uses $wpdb * @uses apply_filters() Calls 'comment_flood_filter' filter with first *		parameter false, last comment timestamp, new comment timestamp. * @uses do_action() Calls 'comment_flood_trigger' action with parameters with *		last comment timestamp and new comment timestamp. * * @param string $ip Comment IP. * @param string $email Comment author email address. * @param string $date MySQL time string. */function check_comment_flood_db( $ip, $email, $date ) {	global $wpdb;	if ( current_user_can( 'manage_options' ) )		return; // don't throttle admins	$hour_ago = gmdate( 'Y-m-d H:i:s', time() - 3600 );	if ( $lasttime = $wpdb->get_var( $wpdb->prepare( "SELECT `comment_date_gmt` FROM `$wpdb->comments` WHERE `comment_date_gmt` >= %s AND ( `comment_author_IP` = %s OR `comment_author_email` = %s ) ORDER BY `comment_date_gmt` DESC LIMIT 1", $hour_ago, $ip, $email ) ) ) {		$time_lastcomment = mysql2date('U', $lasttime, false);		$time_newcomment  = mysql2date('U', $date, false);		$flood_die = apply_filters('comment_flood_filter', false, $time_lastcomment, $time_newcomment);		if ( $flood_die ) {			do_action('comment_flood_trigger', $time_lastcomment, $time_newcomment);			if ( defined('DOING_AJAX') )				die( __('You are posting comments too quickly.  Slow down.') );			wp_die( __('You are posting comments too quickly.  Slow down.'), '', array('response' => 403) );		}	}}/** * Separates an array of comments into an array keyed by comment_type. * * @since 2.7.0 * * @param array $comments Array of comments * @return array Array of comments keyed by comment_type. */function &separate_comments(&$comments) {	$comments_by_type = array('comment' => array(), 'trackback' => array(), 'pingback' => array(), 'pings' => array());	$count = count($comments);	for ( $i = 0; $i < $count; $i++ ) {		$type = $comments[$i]->comment_type;		if ( empty($type) )			$type = 'comment';		$comments_by_type[$type][] = &$comments[$i];		if ( 'trackback' == $type || 'pingback' == $type )			$comments_by_type['pings'][] = &$comments[$i];	}	return $comments_by_type;}/** * Calculate the total number of comment pages. * * @since 2.7.0 * @uses get_query_var() Used to fill in the default for $per_page parameter. * @uses get_option() Used to fill in defaults for parameters. * @uses Walker_Comment * * @param array $comments Optional array of comment objects.  Defaults to $wp_query->comments * @param int $per_page Optional comments per page. * @param boolean $threaded Optional control over flat or threaded comments. * @return int Number of comment pages. */function get_comment_pages_count( $comments = null, $per_page = null, $threaded = null ) {	global $wp_query;	if ( null === $comments && null === $per_page && null === $threaded && !empty($wp_query->max_num_comment_pages) )		return $wp_query->max_num_comment_pages;	if ( !$comments || !is_array($comments) )		$comments = $wp_query->comments;	if ( empty($comments) )		return 0;	if ( !isset($per_page) )		$per_page = (int) get_query_var('comments_per_page');	if ( 0 === $per_page )		$per_page = (int) get_option('comments_per_page');	if ( 0 === $per_page )		return 1;	if ( !isset($threaded) )		$threaded = get_option('thread_comments');	if ( $threaded ) {		$walker = new Walker_Comment;		$count = ceil( $walker->get_number_of_root_elements( $comments ) / $per_page );	} else {		$count = ceil( count( $comments ) / $per_page );	}	return $count;}/** * Calculate what page number a comment will appear on for comment paging. * * @since 2.7.0 * @uses get_comment() Gets the full comment of the $comment_ID parameter. * @uses get_option() Get various settings to control function and defaults. * @uses get_page_of_comment() Used to loop up to top level comment. * * @param int $comment_ID Comment ID. * @param array $args Optional args. * @return int|null Comment page number or null on error. */function get_page_of_comment( $comment_ID, $args = array() ) {	global $wpdb;	if ( !$comment = get_comment( $comment_ID ) )		return;	$defaults = array( 'type' => 'all', 'page' => '', 'per_page' => '', 'max_depth' => '' );	$args = wp_parse_args( $args, $defaults );	if ( '' === $args['per_page'] && get_option('page_comments') )		$args['per_page'] = get_query_var('comments_per_page');	if ( empty($args['per_page']) ) {		$args['per_page'] = 0;		$args['page'] = 0;	}	if ( $args['per_page'] < 1 )		return 1;	if ( '' === $args['max_depth'] ) {		if ( get_option('thread_comments') )			$args['max_depth'] = get_option('thread_comments_depth');		else			$args['max_depth'] = -1;	}	// Find this comment's top level parent if threading is enabled	if ( $args['max_depth'] > 1 && 0 != $comment->comment_parent )		return get_page_of_comment( $comment->comment_parent, $args );	$allowedtypes = array(		'comment' => '',		'pingback' => 'pingback',		'trackback' => 'trackback',	);	$comtypewhere = ( 'all' != $args['type'] && isset($allowedtypes[$args['type']]) ) ? " AND comment_type = '" . $allowedtypes[$args['type']] . "'" : '';	// Count comments older than this one	$oldercoms = $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(comment_ID) FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_parent = 0 AND comment_approved = '1' AND comment_date_gmt < '%s'" . $comtypewhere, $comment->comment_post_ID, $comment->comment_date_gmt ) );	// No older comments? Then it's page #1.	if ( 0 == $oldercoms )		return 1;	// Divide comments older than this one by comments per page to get this comment's page number	return ceil( ( $oldercoms + 1 ) / $args['per_page'] );}/** * Does comment contain blacklisted characters or words. * * @since 1.5.0 * @uses do_action() Calls 'wp_blacklist_check' hook for all parameters. * * @param string $author The author of the comment * @param string $email The email of the comment * @param string $url The url used in the comment * @param string $comment The comment content * @param string $user_ip The comment author IP address * @param string $user_agent The author's browser user agent * @return bool True if comment contains blacklisted content, false if comment does not */function wp_blacklist_check($author, $email, $url, $comment, $user_ip, $user_agent) {	do_action('wp_blacklist_check', $author, $email, $url, $comment, $user_ip, $user_agent);	$mod_keys = trim( get_option('blacklist_keys') );	if ( '' == $mod_keys )		return false; // If moderation keys are empty	$words = explode("\n", $mod_keys );	foreach ( (array) $words as $word ) {		$word = trim($word);		// Skip empty lines		if ( empty($word) ) { continue; }		// Do some escaping magic so that '#' chars in the		// spam words don't break things:		$word = preg_quote($word, '#');		$pattern = "#$word#i";		if (			   preg_match($pattern, $author)			|| preg_match($pattern, $email)			|| preg_match($pattern, $url)			|| preg_match($pattern, $comment)			|| preg_match($pattern, $user_ip)			|| preg_match($pattern, $user_agent)		 )			return true;	}	return false;}/** * Retrieve total comments for blog or single post. * * The properties of the returned object contain the 'moderated', 'approved', * and spam comments for either the entire blog or single post. Those properties * contain the amount of comments that match the status. The 'total_comments' * property contains the integer of total comments. * * The comment stats are cached and then retrieved, if they already exist in the * cache. * * @since 2.5.0 * * @param int $post_id Optional. Post ID. * @return object Comment stats. */function wp_count_comments( $post_id = 0 ) {	global $wpdb;	$post_id = (int) $post_id;	$stats = apply_filters('wp_count_comments', array(), $post_id);	if ( !empty($stats) )		return $stats;	$count = wp_cache_get("comments-{$post_id}", 'counts');	if ( false !== $count )		return $count;	$where = '';	if ( $post_id > 0 )		$where = $wpdb->prepare( "WHERE comment_post_ID = %d", $post_id );	$count = $wpdb->get_results( "SELECT comment_approved, COUNT( * ) AS num_comments FROM {$wpdb->comments} {$where} GROUP BY comment_approved", ARRAY_A );	$total = 0;	$approved = array('0' => 'moderated', '1' => 'approved', 'spam' => 'spam', 'trash' => 'trash', 'post-trashed' => 'post-trashed');	$known_types = array_keys( $approved );	foreach ( (array) $count as $row ) {		// Don't count post-trashed toward totals		if ( 'post-trashed' != $row['comment_approved'] && 'trash' != $row['comment_approved'] )			$total += $row['num_comments'];		if ( in_array( $row['comment_approved'], $known_types ) )			$stats[$approved[$row['comment_approved']]] = $row['num_comments'];	}	$stats['total_comments'] = $total;	foreach ( $approved as $key ) {		if ( empty($stats[$key]) )			$stats[$key] = 0;	}	$stats = (object) $stats;	wp_cache_set("comments-{$post_id}", $stats, 'counts');	return $stats;}/** * Trashes or deletes a comment. * * The comment is moved to trash instead of permanently deleted unless trash is * disabled, item is already in the trash, or $force_delete is true. * * The post comment count will be updated if the comment was approved and has a * post ID available. * * @since 2.0.0 * @uses $wpdb * @uses do_action() Calls 'delete_comment' hook on comment ID * @uses do_action() Calls 'deleted_comment' hook on comment ID after deletion, on success * @uses do_action() Calls 'wp_set_comment_status' hook on comment ID with 'delete' set for the second parameter * @uses wp_transition_comment_status() Passes new and old comment status along with $comment object * * @param int $comment_id Comment ID * @param bool $force_delete Whether to bypass trash and force deletion. Default is false. * @return bool False if delete comment query failure, true on success. */function wp_delete_comment($comment_id, $force_delete = false) {	global $wpdb;	if (!$comment = get_comment($comment_id))		return false;	if ( !$force_delete && EMPTY_TRASH_DAYS && !in_array( wp_get_comment_status($comment_id), array( 'trash', 'spam' ) ) )		return wp_trash_comment($comment_id);	do_action('delete_comment', $comment_id);	// Move children up a level.	$children = $wpdb->get_col( $wpdb->prepare("SELECT comment_ID FROM $wpdb->comments WHERE comment_parent = %d", $comment_id) );	if ( !empty($children) ) {		$wpdb->update($wpdb->comments, array('comment_parent' => $comment->comment_parent), array('comment_parent' => $comment_id));		clean_comment_cache($children);	}	// Delete metadata	$meta_ids = $wpdb->get_col( $wpdb->prepare( "SELECT meta_id FROM $wpdb->commentmeta WHERE comment_id = %d ", $comment_id ) );	if ( !empty($meta_ids) ) {		do_action( 'delete_commentmeta', $meta_ids );		$in_meta_ids = "'" . implode("', '", $meta_ids) . "'";		$wpdb->query( "DELETE FROM $wpdb->commentmeta WHERE meta_id IN ($in_meta_ids)" );		do_action( 'deleted_commentmeta', $meta_ids );	}	if ( ! $wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->comments WHERE comment_ID = %d LIMIT 1", $comment_id) ) )		return false;	do_action('deleted_comment', $comment_id);	$post_id = $comment->comment_post_ID;	if ( $post_id && $comment->comment_approved == 1 )		wp_update_comment_count($post_id);	clean_comment_cache($comment_id);	do_action('wp_set_comment_status', $comment_id, 'delete');	wp_transition_comment_status('delete', $comment->comment_approved, $comment);	return true;}/** * Moves a comment to the Trash * * If trash is disabled, comment is permanently deleted. * * @since 2.9.0 * @uses do_action() on 'trash_comment' before trashing * @uses do_action() on 'trashed_comment' after trashing * @uses wp_delete_comment() if trash is disabled * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_trash_comment($comment_id) {	if ( !EMPTY_TRASH_DAYS )		return wp_delete_comment($comment_id, true);	if ( !$comment = get_comment($comment_id) )		return false;	do_action('trash_comment', $comment_id);	if ( wp_set_comment_status($comment_id, 'trash') ) {		add_comment_meta($comment_id, '_wp_trash_meta_status', $comment->comment_approved);		add_comment_meta($comment_id, '_wp_trash_meta_time', time() );		do_action('trashed_comment', $comment_id);		return true;	}	return false;}/** * Removes a comment from the Trash * * @since 2.9.0 * @uses do_action() on 'untrash_comment' before untrashing * @uses do_action() on 'untrashed_comment' after untrashing * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_untrash_comment($comment_id) {	if ( ! (int)$comment_id )		return false;	do_action('untrash_comment', $comment_id);	$status = (string) get_comment_meta($comment_id, '_wp_trash_meta_status', true);	if ( empty($status) )		$status = '0';	if ( wp_set_comment_status($comment_id, $status) ) {		delete_comment_meta($comment_id, '_wp_trash_meta_time');		delete_comment_meta($comment_id, '_wp_trash_meta_status');		do_action('untrashed_comment', $comment_id);		return true;	}	return false;}/** * Marks a comment as Spam * * @since 2.9.0 * @uses do_action() on 'spam_comment' before spamming * @uses do_action() on 'spammed_comment' after spamming * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_spam_comment($comment_id) {	if ( !$comment = get_comment($comment_id) )		return false;	do_action('spam_comment', $comment_id);	if ( wp_set_comment_status($comment_id, 'spam') ) {		add_comment_meta($comment_id, '_wp_trash_meta_status', $comment->comment_approved);		do_action('spammed_comment', $comment_id);		return true;	}	return false;}/** * Removes a comment from the Spam * * @since 2.9.0 * @uses do_action() on 'unspam_comment' before unspamming * @uses do_action() on 'unspammed_comment' after unspamming * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_unspam_comment($comment_id) {	if ( ! (int)$comment_id )		return false;	do_action('unspam_comment', $comment_id);	$status = (string) get_comment_meta($comment_id, '_wp_trash_meta_status', true);	if ( empty($status) )		$status = '0';	if ( wp_set_comment_status($comment_id, $status) ) {		delete_comment_meta($comment_id, '_wp_trash_meta_status');		do_action('unspammed_comment', $comment_id);		return true;	}	return false;}/** * The status of a comment by ID. * * @since 1.0.0 * * @param int $comment_id Comment ID * @return string|bool Status might be 'trash', 'approved', 'unapproved', 'spam'. False on failure. */function wp_get_comment_status($comment_id) {	$comment = get_comment($comment_id);	if ( !$comment )		return false;	$approved = $comment->comment_approved;	if ( $approved == NULL )		return false;	elseif ( $approved == '1' )		return 'approved';	elseif ( $approved == '0' )		return 'unapproved';	elseif ( $approved == 'spam' )		return 'spam';	elseif ( $approved == 'trash' )		return 'trash';	else		return false;}/** * Call hooks for when a comment status transition occurs. * * Calls hooks for comment status transitions. If the new comment status is not the same * as the previous comment status, then two hooks will be ran, the first is * 'transition_comment_status' with new status, old status, and comment data. The * next action called is 'comment_OLDSTATUS_to_NEWSTATUS' the NEWSTATUS is the * $new_status parameter and the OLDSTATUS is $old_status parameter; it has the * comment data. * * The final action will run whether or not the comment statuses are the same. The * action is named 'comment_NEWSTATUS_COMMENTTYPE', NEWSTATUS is from the $new_status * parameter and COMMENTTYPE is comment_type comment data. * * @since 2.7.0 * * @param string $new_status New comment status. * @param string $old_status Previous comment status. * @param object $comment Comment data. */function wp_transition_comment_status($new_status, $old_status, $comment) {	// Translate raw statuses to human readable formats for the hooks	// This is not a complete list of comment status, it's only the ones that need to be renamed	$comment_statuses = array(		0         => 'unapproved',		'hold'    => 'unapproved', // wp_set_comment_status() uses "hold"		1         => 'approved',		'approve' => 'approved', // wp_set_comment_status() uses "approve"	);	if ( isset($comment_statuses[$new_status]) ) $new_status = $comment_statuses[$new_status];	if ( isset($comment_statuses[$old_status]) ) $old_status = $comment_statuses[$old_status];	// Call the hooks	if ( $new_status != $old_status ) {		do_action('transition_comment_status', $new_status, $old_status, $comment);		do_action("comment_${old_status}_to_$new_status", $comment);	}	do_action("comment_${new_status}_$comment->comment_type", $comment->comment_ID, $comment);}/** * Get current commenter's name, email, and URL. * * Expects cookies content to already be sanitized. User of this function might * wish to recheck the returned array for validity. * * @see sanitize_comment_cookies() Use to sanitize cookies * * @since 2.0.4 * * @return array Comment author, email, url respectively. */function wp_get_current_commenter() {	// Cookies should already be sanitized.	$comment_author = '';	if ( isset($_COOKIE['comment_author_'.COOKIEHASH]) )		$comment_author = $_COOKIE['comment_author_'.COOKIEHASH];	$comment_author_email = '';	if ( isset($_COOKIE['comment_author_email_'.COOKIEHASH]) )		$comment_author_email = $_COOKIE['comment_author_email_'.COOKIEHASH];	$comment_author_url = '';	if ( isset($_COOKIE['comment_author_url_'.COOKIEHASH]) )		$comment_author_url = $_COOKIE['comment_author_url_'.COOKIEHASH];	return compact('comment_author', 'comment_author_email', 'comment_author_url');}/** * Inserts a comment to the database. * * The available comment data key names are 'comment_author_IP', 'comment_date', * 'comment_date_gmt', 'comment_parent', 'comment_approved', and 'user_id'. * * @since 2.0.0 * @uses $wpdb * * @param array $commentdata Contains information on the comment. * @return int The new comment's ID. */function wp_insert_comment($commentdata) {	global $wpdb;	extract(stripslashes_deep($commentdata), EXTR_SKIP);	if ( ! isset($comment_author_IP) )		$comment_author_IP = '';	if ( ! isset($comment_date) )		$comment_date = current_time('mysql');	if ( ! isset($comment_date_gmt) )		$comment_date_gmt = get_gmt_from_date($comment_date);	if ( ! isset($comment_parent) )		$comment_parent = 0;	if ( ! isset($comment_approved) )		$comment_approved = 1;	if ( ! isset($comment_karma) )		$comment_karma = 0;	if ( ! isset($user_id) )		$user_id = 0;	if ( ! isset($comment_type) )		$comment_type = '';	$data = compact('comment_post_ID', 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_author_IP', 'comment_date', 'comment_date_gmt', 'comment_content', 'comment_karma', 'comment_approved', 'comment_agent', 'comment_type', 'comment_parent', 'user_id');	$wpdb->insert($wpdb->comments, $data);	$id = (int) $wpdb->insert_id;	if ( $comment_approved == 1 )		wp_update_comment_count($comment_post_ID);	$comment = get_comment($id);	do_action('wp_insert_comment', $id, $comment);	return $id;}/** * Filters and sanitizes comment data. * * Sets the comment data 'filtered' field to true when finished. This can be * checked as to whether the comment should be filtered and to keep from * filtering the same comment more than once. * * @since 2.0.0 * @uses apply_filters() Calls 'pre_user_id' hook on comment author's user ID * @uses apply_filters() Calls 'pre_comment_user_agent' hook on comment author's user agent * @uses apply_filters() Calls 'pre_comment_author_name' hook on comment author's name * @uses apply_filters() Calls 'pre_comment_content' hook on the comment's content * @uses apply_filters() Calls 'pre_comment_user_ip' hook on comment author's IP * @uses apply_filters() Calls 'pre_comment_author_url' hook on comment author's URL * @uses apply_filters() Calls 'pre_comment_author_email' hook on comment author's email address * * @param array $commentdata Contains information on the comment. * @return array Parsed comment information. */function wp_filter_comment($commentdata) {	if ( isset($commentdata['user_ID']) )		$commentdata['user_id'] = apply_filters('pre_user_id', $commentdata['user_ID']);	elseif ( isset($commentdata['user_id']) )		$commentdata['user_id'] = apply_filters('pre_user_id', $commentdata['user_id']);	$commentdata['comment_agent']        = apply_filters('pre_comment_user_agent', ( isset( $commentdata['comment_agent'] ) ? $commentdata['comment_agent'] : '' ) );	$commentdata['comment_author']       = apply_filters('pre_comment_author_name', $commentdata['comment_author']);	$commentdata['comment_content']      = apply_filters('pre_comment_content', $commentdata['comment_content']);	$commentdata['comment_author_IP']    = apply_filters('pre_comment_user_ip', $commentdata['comment_author_IP']);	$commentdata['comment_author_url']   = apply_filters('pre_comment_author_url', $commentdata['comment_author_url']);	$commentdata['comment_author_email'] = apply_filters('pre_comment_author_email', $commentdata['comment_author_email']);	$commentdata['filtered'] = true;	return $commentdata;}/** * Whether comment should be blocked because of comment flood. * * @since 2.1.0 * * @param bool $block Whether plugin has already blocked comment. * @param int $time_lastcomment Timestamp for last comment. * @param int $time_newcomment Timestamp for new comment. * @return bool Whether comment should be blocked. */function wp_throttle_comment_flood($block, $time_lastcomment, $time_newcomment) {	if ( $block ) // a plugin has already blocked... we'll let that decision stand		return $block;	if ( ($time_newcomment - $time_lastcomment) < 15 )		return true;	return false;}/** * Adds a new comment to the database. * * Filters new comment to ensure that the fields are sanitized and valid before * inserting comment into database. Calls 'comment_post' action with comment ID * and whether comment is approved by WordPress. Also has 'preprocess_comment' * filter for processing the comment data before the function handles it. * * @since 1.5.0 * @uses apply_filters() Calls 'preprocess_comment' hook on $commentdata parameter array before processing * @uses do_action() Calls 'comment_post' hook on $comment_ID returned from adding the comment and if the comment was approved. * @uses wp_filter_comment() Used to filter comment before adding comment. * @uses wp_allow_comment() checks to see if comment is approved. * @uses wp_insert_comment() Does the actual comment insertion to the database. * * @param array $commentdata Contains information on the comment. * @return int The ID of the comment after adding. */function wp_new_comment( $commentdata ) {	$commentdata = apply_filters('preprocess_comment', $commentdata);	$commentdata['comment_post_ID'] = (int) $commentdata['comment_post_ID'];	if ( isset($commentdata['user_ID']) )		$commentdata['user_id'] = $commentdata['user_ID'] = (int) $commentdata['user_ID'];	elseif ( isset($commentdata['user_id']) )		$commentdata['user_id'] = (int) $commentdata['user_id'];	$commentdata['comment_parent'] = isset($commentdata['comment_parent']) ? absint($commentdata['comment_parent']) : 0;	$parent_status = ( 0 < $commentdata['comment_parent'] ) ? wp_get_comment_status($commentdata['comment_parent']) : '';	$commentdata['comment_parent'] = ( 'approved' == $parent_status || 'unapproved' == $parent_status ) ? $commentdata['comment_parent'] : 0;	$commentdata['comment_author_IP'] = preg_replace( '/[^0-9a-fA-F:., ]/', '',$_SERVER['REMOTE_ADDR'] );	$commentdata['comment_agent']     = substr($_SERVER['HTTP_USER_AGENT'], 0, 254);	$commentdata['comment_date']     = current_time('mysql');	$commentdata['comment_date_gmt'] = current_time('mysql', 1);	$commentdata = wp_filter_comment($commentdata);	$commentdata['comment_approved'] = wp_allow_comment($commentdata);	$comment_ID = wp_insert_comment($commentdata);	do_action('comment_post', $comment_ID, $commentdata['comment_approved']);	if ( 'spam' !== $commentdata['comment_approved'] ) { // If it's spam save it silently for later crunching		if ( '0' == $commentdata['comment_approved'] )			wp_notify_moderator($comment_ID);		$post = &get_post($commentdata['comment_post_ID']); // Don't notify if it's your own comment		if ( get_option('comments_notify') && $commentdata['comment_approved'] && ( ! isset( $commentdata['user_id'] ) || $post->post_author != $commentdata['user_id'] ) )			wp_notify_postauthor($comment_ID, empty( $commentdata['comment_type'] ) ? $commentdata['comment_type'] : '' );	}	return $comment_ID;}/** * Sets the status of a comment. * * The 'wp_set_comment_status' action is called after the comment is handled and * will only be called, if the comment status is either 'hold', 'approve', or * 'spam'. If the comment status is not in the list, then false is returned and * if the status is 'delete', then the comment is deleted without calling the * action. * * @since 1.0.0 * @uses wp_transition_comment_status() Passes new and old comment status along with $comment object * * @param int $comment_id Comment ID. * @param string $comment_status New comment status, either 'hold', 'approve', 'spam', or 'delete'. * @param bool $wp_error Whether to return a WP_Error object if there is a failure. Default is false. * @return bool False on failure or deletion and true on success. */function wp_set_comment_status($comment_id, $comment_status, $wp_error = false) {	global $wpdb;	$status = '0';	switch ( $comment_status ) {		case 'hold':		case '0':			$status = '0';			break;		case 'approve':		case '1':			$status = '1';			if ( get_option('comments_notify') ) {				$comment = get_comment($comment_id);				wp_notify_postauthor($comment_id, $comment->comment_type);			}			break;		case 'spam':			$status = 'spam';			break;		case 'trash':			$status = 'trash';			break;		default:			return false;	}	$comment_old = wp_clone(get_comment($comment_id));	if ( !$wpdb->update( $wpdb->comments, array('comment_approved' => $status), array('comment_ID' => $comment_id) ) ) {		if ( $wp_error )			return new WP_Error('db_update_error', __('Could not update comment status'), $wpdb->last_error);		else			return false;	}	clean_comment_cache($comment_id);	$comment = get_comment($comment_id);	do_action('wp_set_comment_status', $comment_id, $comment_status);	wp_transition_comment_status($comment_status, $comment_old->comment_approved, $comment);	wp_update_comment_count($comment->comment_post_ID);	return true;}/** * Updates an existing comment in the database. * * Filters the comment and makes sure certain fields are valid before updating. * * @since 2.0.0 * @uses $wpdb * @uses wp_transition_comment_status() Passes new and old comment status along with $comment object * * @param array $commentarr Contains information on the comment. * @return int Comment was updated if value is 1, or was not updated if value is 0. */function wp_update_comment($commentarr) {	global $wpdb;	// First, get all of the original fields	$comment = get_comment($commentarr['comment_ID'], ARRAY_A);	// Escape data pulled from DB.	$comment = esc_sql($comment);	$old_status = $comment['comment_approved'];	// Merge old and new fields with new fields overwriting old ones.	$commentarr = array_merge($comment, $commentarr);	$commentarr = wp_filter_comment( $commentarr );	// Now extract the merged array.	extract(stripslashes_deep($commentarr), EXTR_SKIP);	$comment_content = apply_filters('comment_save_pre', $comment_content);	$comment_date_gmt = get_gmt_from_date($comment_date);	if ( !isset($comment_approved) )		$comment_approved = 1;	else if ( 'hold' == $comment_approved )		$comment_approved = 0;	else if ( 'approve' == $comment_approved )		$comment_approved = 1;	$data = compact('comment_content', 'comment_author', 'comment_author_email', 'comment_approved', 'comment_karma', 'comment_author_url', 'comment_date', 'comment_date_gmt');	$rval = $wpdb->update( $wpdb->comments, $data, compact( 'comment_ID' ) );	clean_comment_cache($comment_ID);	wp_update_comment_count($comment_post_ID);	do_action('edit_comment', $comment_ID);	$comment = get_comment($comment_ID);	wp_transition_comment_status($comment->comment_approved, $old_status, $comment);	return $rval;}/** * Whether to defer comment counting. * * When setting $defer to true, all post comment counts will not be updated * until $defer is set to false. When $defer is set to false, then all * previously deferred updated post comment counts will then be automatically * updated without having to call wp_update_comment_count() after. * * @since 2.5.0 * @staticvar bool $_defer * * @param bool $defer * @return unknown */function wp_defer_comment_counting($defer=null) {	static $_defer = false;	if ( is_bool($defer) ) {		$_defer = $defer;		// flush any deferred counts		if ( !$defer )			wp_update_comment_count( null, true );	}	return $_defer;}/** * Updates the comment count for post(s). * * When $do_deferred is false (is by default) and the comments have been set to * be deferred, the post_id will be added to a queue, which will be updated at a * later date and only updated once per post ID. * * If the comments have not be set up to be deferred, then the post will be * updated. When $do_deferred is set to true, then all previous deferred post * IDs will be updated along with the current $post_id. * * @since 2.1.0 * @see wp_update_comment_count_now() For what could cause a false return value * * @param int $post_id Post ID * @param bool $do_deferred Whether to process previously deferred post comment counts * @return bool True on success, false on failure */function wp_update_comment_count($post_id, $do_deferred=false) {	static $_deferred = array();	if ( $do_deferred ) {		$_deferred = array_unique($_deferred);		foreach ( $_deferred as $i => $_post_id ) {			wp_update_comment_count_now($_post_id);			unset( $_deferred[$i] ); /** @todo Move this outside of the foreach and reset $_deferred to an array instead */		}	}	if ( wp_defer_comment_counting() ) {		$_deferred[] = $post_id;		return true;	}	elseif ( $post_id ) {		return wp_update_comment_count_now($post_id);	}}/** * Updates the comment count for the post. * * @since 2.5.0 * @uses $wpdb * @uses do_action() Calls 'wp_update_comment_count' hook on $post_id, $new, and $old * @uses do_action() Calls 'edit_posts' hook on $post_id and $post * * @param int $post_id Post ID * @return bool False on '0' $post_id or if post with ID does not exist. True on success. */function wp_update_comment_count_now($post_id) {	global $wpdb;	$post_id = (int) $post_id;	if ( !$post_id )		return false;	if ( !$post = get_post($post_id) )		return false;	$old = (int) $post->comment_count;	$new = (int) $wpdb->get_var( $wpdb->prepare("SELECT COUNT(*) FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved = '1'", $post_id) );	$wpdb->update( $wpdb->posts, array('comment_count' => $new), array('ID' => $post_id) );	if ( 'page' == $post->post_type )		clean_page_cache( $post_id );	else		clean_post_cache( $post_id );	do_action('wp_update_comment_count', $post_id, $new, $old);	do_action('edit_post', $post_id, $post);	return true;}//// Ping and trackback functions.///** * Finds a pingback server URI based on the given URL. * * Checks the HTML for the rel="pingback" link and x-pingback headers. It does * a check for the x-pingback headers first and returns that, if available. The * check for the rel="pingback" has more overhead than just the header. * * @since 1.5.0 * * @param string $url URL to ping. * @param int $deprecated Not Used. * @return bool|string False on failure, string containing URI on success. */function discover_pingback_server_uri( $url, $deprecated = '' ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.7' );	$pingback_str_dquote = 'rel="pingback"';	$pingback_str_squote = 'rel=\'pingback\'';	/** @todo Should use Filter Extension or custom preg_match instead. */	$parsed_url = parse_url($url);	if ( ! isset( $parsed_url['host'] ) ) // Not an URL. This should never happen.		return false;	//Do not search for a pingback server on our own uploads	$uploads_dir = wp_upload_dir();	if ( 0 === strpos($url, $uploads_dir['baseurl']) )		return false;	$response = wp_remote_head( $url, array( 'timeout' => 2, 'httpversion' => '1.0' ) );	if ( is_wp_error( $response ) )		return false;	if ( isset( $response['headers']['x-pingback'] ) )		return $response['headers']['x-pingback'];	// Not an (x)html, sgml, or xml page, no use going further.	if ( isset( $response['headers']['content-type'] ) && preg_match('#(image|audio|video|model)/#is', $response['headers']['content-type']) )		return false;	// Now do a GET since we're going to look in the html headers (and we're sure its not a binary file)	$response = wp_remote_get( $url, array( 'timeout' => 2, 'httpversion' => '1.0' ) );	if ( is_wp_error( $response ) )		return false;	$contents = $response['body'];	$pingback_link_offset_dquote = strpos($contents, $pingback_str_dquote);	$pingback_link_offset_squote = strpos($contents, $pingback_str_squote);	if ( $pingback_link_offset_dquote || $pingback_link_offset_squote ) {		$quote = ($pingback_link_offset_dquote) ? '"' : '\'';		$pingback_link_offset = ($quote=='"') ? $pingback_link_offset_dquote : $pingback_link_offset_squote;		$pingback_href_pos = @strpos($contents, 'href=', $pingback_link_offset);		$pingback_href_start = $pingback_href_pos+6;		$pingback_href_end = @strpos($contents, $quote, $pingback_href_start);		$pingback_server_url_len = $pingback_href_end - $pingback_href_start;		$pingback_server_url = substr($contents, $pingback_href_start, $pingback_server_url_len);		// We may find rel="pingback" but an incomplete pingback URL		if ( $pingback_server_url_len > 0 ) { // We got it!			return $pingback_server_url;		}	}	return false;}/** * Perform all pingbacks, enclosures, trackbacks, and send to pingback services. * * @since 2.1.0 * @uses $wpdb */function do_all_pings() {	global $wpdb;	// Do pingbacks	while ($ping = $wpdb->get_row("SELECT * FROM {$wpdb->posts}, {$wpdb->postmeta} WHERE {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id AND {$wpdb->postmeta}.meta_key = '_pingme' LIMIT 1")) {		$mid = $wpdb->get_var( "SELECT meta_id FROM {$wpdb->postmeta} WHERE post_id = {$ping->ID} AND meta_key = '_pingme' LIMIT 1");		do_action( 'delete_postmeta', $mid );		$wpdb->query( $wpdb->prepare( "DELETE FROM {$wpdb->postmeta} WHERE meta_id = %d", $mid ) );		do_action( 'deleted_postmeta', $mid );		pingback($ping->post_content, $ping->ID);	}	// Do Enclosures	while ($enclosure = $wpdb->get_row("SELECT * FROM {$wpdb->posts}, {$wpdb->postmeta} WHERE {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id AND {$wpdb->postmeta}.meta_key = '_encloseme' LIMIT 1")) {		$mid = $wpdb->get_var( $wpdb->prepare("SELECT meta_id FROM {$wpdb->postmeta} WHERE post_id = %d AND meta_key = '_encloseme'", $enclosure->ID) );		do_action( 'delete_postmeta', $mid );		$wpdb->query( $wpdb->prepare("DELETE FROM {$wpdb->postmeta} WHERE meta_id =  %d", $mid) );		do_action( 'deleted_postmeta', $mid );		do_enclose($enclosure->post_content, $enclosure->ID);	}	// Do Trackbacks	$trackbacks = $wpdb->get_col("SELECT ID FROM $wpdb->posts WHERE to_ping <> '' AND post_status = 'publish'");	if ( is_array($trackbacks) )		foreach ( $trackbacks as $trackback )			do_trackbacks($trackback);	//Do Update Services/Generic Pings	generic_ping();}/** * Perform trackbacks. * * @since 1.5.0 * @uses $wpdb * * @param int $post_id Post ID to do trackbacks on. */function do_trackbacks($post_id) {	global $wpdb;	$post = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->posts WHERE ID = %d", $post_id) );	$to_ping = get_to_ping($post_id);	$pinged  = get_pung($post_id);	if ( empty($to_ping) ) {		$wpdb->update($wpdb->posts, array('to_ping' => ''), array('ID' => $post_id) );		return;	}	if ( empty($post->post_excerpt) )		$excerpt = apply_filters('the_content', $post->post_content);	else		$excerpt = apply_filters('the_excerpt', $post->post_excerpt);	$excerpt = str_replace(']]>', ']]&gt;', $excerpt);	$excerpt = wp_html_excerpt($excerpt, 252) . '...';	$post_title = apply_filters('the_title', $post->post_title);	$post_title = strip_tags($post_title);	if ( $to_ping ) {		foreach ( (array) $to_ping as $tb_ping ) {			$tb_ping = trim($tb_ping);			if ( !in_array($tb_ping, $pinged) ) {				trackback($tb_ping, $post_title, $excerpt, $post_id);				$pinged[] = $tb_ping;			} else {				$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET to_ping = TRIM(REPLACE(to_ping, '$tb_ping', '')) WHERE ID = %d", $post_id) );			}		}	}}/** * Sends pings to all of the ping site services. * * @since 1.2.0 * * @param int $post_id Post ID. Not actually used. * @return int Same as Post ID from parameter */function generic_ping($post_id = 0) {	$services = get_option('ping_sites');	$services = explode("\n", $services);	foreach ( (array) $services as $service ) {		$service = trim($service);		if ( '' != $service )			weblog_ping($service);	}	return $post_id;}/** * Pings back the links found in a post. * * @since 0.71 * @uses $wp_version * @uses IXR_Client * * @param string $content Post content to check for links. * @param int $post_ID Post ID. */function pingback($content, $post_ID) {	global $wp_version;	include_once(ABSPATH . WPINC . '/class-IXR.php');	// original code by Mort (http://mort.mine.nu:8080)	$post_links = array();	$pung = get_pung($post_ID);	// Variables	$ltrs = '\w';	$gunk = '/#~:.?+=&%@!\-';	$punc = '.:?\-';	$any = $ltrs . $gunk . $punc;	// Step 1	// Parsing the post, external links (if any) are stored in the $post_links array	// This regexp comes straight from phpfreaks.com	// http://www.phpfreaks.com/quickcode/Extract_All_URLs_on_a_Page/15.php	preg_match_all("{\b http : [$any] +? (?= [$punc] * [^$any] | $)}x", $content, $post_links_temp);	// Step 2.	// Walking thru the links array	// first we get rid of links pointing to sites, not to specific files	// Example:	// http://dummy-weblog.org	// http://dummy-weblog.org/	// http://dummy-weblog.org/post.php	// We don't wanna ping first and second types, even if they have a valid <link/>	foreach ( (array) $post_links_temp[0] as $link_test ) :		if ( !in_array($link_test, $pung) && (url_to_postid($link_test) != $post_ID) // If we haven't pung it already and it isn't a link to itself				&& !is_local_attachment($link_test) ) : // Also, let's never ping local attachments.			if ( $test = @parse_url($link_test) ) {				if ( isset($test['query']) )					$post_links[] = $link_test;				elseif ( ($test['path'] != '/') && ($test['path'] != '') )					$post_links[] = $link_test;			}		endif;	endforeach;	do_action_ref_array('pre_ping', array(&$post_links, &$pung));	foreach ( (array) $post_links as $pagelinkedto ) {		$pingback_server_url = discover_pingback_server_uri($pagelinkedto, 2048);		if ( $pingback_server_url ) {			@ set_time_limit( 60 );			 // Now, the RPC call			$pagelinkedfrom = get_permalink($post_ID);			// using a timeout of 3 seconds should be enough to cover slow servers			$client = new IXR_Client($pingback_server_url);			$client->timeout = 3;			$client->useragent = apply_filters( 'pingback_useragent', $client->useragent . ' -- WordPress/' . $wp_version, $client->useragent, $pingback_server_url, $pagelinkedto, $pagelinkedfrom);			// when set to true, this outputs debug messages by itself			$client->debug = false;			if ( $client->query('pingback.ping', $pagelinkedfrom, $pagelinkedto) || ( isset($client->error->code) && 48 == $client->error->code ) ) // Already registered				add_ping( $post_ID, $pagelinkedto );		}	}}/** * Check whether blog is public before returning sites. * * @since 2.1.0 * * @param mixed $sites Will return if blog is public, will not return if not public. * @return mixed Empty string if blog is not public, returns $sites, if site is public. */function privacy_ping_filter($sites) {	if ( '0' != get_option('blog_public') )		return $sites;	else		return '';}/** * Send a Trackback. * * Updates database when sending trackback to prevent duplicates. * * @since 0.71 * @uses $wpdb * * @param string $trackback_url URL to send trackbacks. * @param string $title Title of post. * @param string $excerpt Excerpt of post. * @param int $ID Post ID. * @return mixed Database query from update. */function trackback($trackback_url, $title, $excerpt, $ID) {	global $wpdb;	if ( empty($trackback_url) )		return;	$options = array();	$options['timeout'] = 4;	$options['body'] = array(		'title' => $title,		'url' => get_permalink($ID),		'blog_name' => get_option('blogname'),		'excerpt' => $excerpt	);	$response = wp_remote_post($trackback_url, $options);	if ( is_wp_error( $response ) )		return;	$tb_url = addslashes( $trackback_url );	$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET pinged = CONCAT(pinged, '\n', '$tb_url') WHERE ID = %d", $ID) );	return $wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET to_ping = TRIM(REPLACE(to_ping, '$tb_url', '')) WHERE ID = %d", $ID) );}/** * Send a pingback. * * @since 1.2.0 * @uses $wp_version * @uses IXR_Client * * @param string $server Host of blog to connect to. * @param string $path Path to send the ping. */function weblog_ping($server = '', $path = '') {	global $wp_version;	include_once(ABSPATH . WPINC . '/class-IXR.php');	// using a timeout of 3 seconds should be enough to cover slow servers	$client = new IXR_Client($server, ((!strlen(trim($path)) || ('/' == $path)) ? false : $path));	$client->timeout = 3;	$client->useragent .= ' -- WordPress/'.$wp_version;	// when set to true, this outputs debug messages by itself	$client->debug = false;	$home = trailingslashit( home_url() );	if ( !$client->query('weblogUpdates.extendedPing', get_option('blogname'), $home, get_bloginfo('rss2_url') ) ) // then try a normal ping		$client->query('weblogUpdates.ping', get_option('blogname'), $home);}//// Cache///** * Removes comment ID from the comment cache. * * @since 2.3.0 * @package WordPress * @subpackage Cache * * @param int|array $id Comment ID or array of comment IDs to remove from cache */function clean_comment_cache($ids) {	foreach ( (array) $ids as $id )		wp_cache_delete($id, 'comment');}/** * Updates the comment cache of given comments. * * Will add the comments in $comments to the cache. If comment ID already exists * in the comment cache then it will not be updated. The comment is added to the * cache using the comment group with the key using the ID of the comments. * * @since 2.3.0 * @package WordPress * @subpackage Cache * * @param array $comments Array of comment row objects */function update_comment_cache($comments) {	foreach ( (array) $comments as $comment )		wp_cache_add($comment->comment_ID, $comment, 'comment');}//// Internal///** * Close comments on old posts on the fly, without any extra DB queries.  Hooked to the_posts. * * @access private * @since 2.7.0 * * @param object $posts Post data object. * @return object */function _close_comments_for_old_posts( $posts ) {	if ( empty($posts) || !is_singular() || !get_option('close_comments_for_old_posts') )		return $posts;	$days_old = (int) get_option('close_comments_days_old');	if ( !$days_old )		return $posts;	if ( time() - strtotime( $posts[0]->post_date_gmt ) > ( $days_old * 24 * 60 * 60 ) ) {		$posts[0]->comment_status = 'closed';		$posts[0]->ping_status = 'closed';	}	return $posts;}/** * Close comments on an old post.  Hooked to comments_open and pings_open. * * @access private * @since 2.7.0 * * @param bool $open Comments open or closed * @param int $post_id Post ID * @return bool $open */function _close_comments_for_old_post( $open, $post_id ) {	if ( ! $open )		return $open;	if ( !get_option('close_comments_for_old_posts') )		return $open;	$days_old = (int) get_option('close_comments_days_old');	if ( !$days_old )		return $open;	$post = get_post($post_id);	if ( time() - strtotime( $post->post_date_gmt ) > ( $days_old * 24 * 60 * 60 ) )		return false;	return $open;}?>
<?php/** * WordPress Export Administration Panel * * @package WordPress * @subpackage Administration *//** Load WordPress Bootstrap */require_once ('admin.php');if ( !current_user_can('export') )	wp_die(__('You do not have sufficient permissions to export the content of this site.'));/** Load WordPress export API */require_once('./includes/export.php');$title = __('Export');add_contextual_help($current_screen,	'<p>' . __('You can export a file of your site&#8217;s content in order to import it into another installation or platform. The export file will be an XML file format called WXR. Posts, pages, comments, custom fields, categories, and tags can be included. You can set filters to have the WXR file only include a certain date, author, category, tag, all posts or all pages, certain publishing statuses.') . '</p>' .	'<p>' . __('Once generated, your WXR file can be imported by another WordPress site or by another blogging platform able to access this format.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Tools_Export_SubPanel" target="_blank">Export Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');if ( isset( $_GET['download'] ) ) {		$author = isset($_GET['author']) ? $_GET['author'] : 'all';		$taxonomy = array();		foreach ( get_taxonomies( array( 'show_ui' => true ) ) as $tax )			$taxonomy[ $tax ] = ! empty( $_GET['taxonomy'][ $tax ] ) ? $_GET['taxonomy'][ $tax ] : 'all';		$post_type = isset($_GET['post_type']) ? stripslashes_deep($_GET['post_type']) : 'all';		$status = isset($_GET['status']) ? stripslashes_deep($_GET['status']) : 'all';		$mm_start = isset($_GET['mm_start']) ? $_GET['mm_start'] : 'all';		$mm_end = isset($_GET['mm_end']) ? $_GET['mm_end'] : 'all';		if( $mm_start != 'all' ) {			$start_date = sprintf( "%04d-%02d-%02d", substr( $mm_start, 0, 4 ), substr( $mm_start, 5, 2 ), 1 );		} else {			$start_date = 'all';		}		if( $mm_end != 'all' ) {			$end_date = sprintf( "%04d-%02d-%02d", substr( $mm_end, 0, 4 ), substr( $mm_end, 5, 2 ), 1 );		} else {			$end_date = 'all';		}	export_wp( array( 'author' => $author, 'taxonomy' => $taxonomy, 'post_type' => $post_type, 'post_status' => $status, 'start_date' => $start_date, 'end_date' => $end_date ) );	die();}require_once ('admin-header.php');$dateoptions = $edateoptions = '';$types = "'" . implode("', '", get_post_types( array( 'public' => true, 'can_export' => true ), 'names' )) . "'";$stati = "'" . implode("', '", get_post_stati( array( 'internal' => false ), 'names' )) . "'";if ( $monthyears = $wpdb->get_results("SELECT DISTINCT YEAR(post_date) AS `year`, MONTH(post_date) AS `month`, YEAR(DATE_ADD(post_date, INTERVAL 1 MONTH)) AS `eyear`, MONTH(DATE_ADD(post_date, INTERVAL 1 MONTH)) AS `emonth` FROM $wpdb->posts WHERE post_type IN ($types) AND post_status IN ($stati) ORDER BY post_date ASC ") ) {	foreach ( $monthyears as $k => $monthyear )		$monthyears[$k]->lmonth = $wp_locale->get_month( $monthyear->month, 2 );	for( $s = 0, $e = count( $monthyears ) - 1; $e >= 0; $s++, $e-- ) {		$dateoptions .= "\t<option value=\"" . $monthyears[$s]->year . '-' . zeroise( $monthyears[$s]->month, 2 ) . '">' . $monthyears[$s]->lmonth . ' ' . $monthyears[$s]->year . "</option>\n";		$edateoptions .= "\t<option value=\"" . $monthyears[$e]->eyear . '-' . zeroise( $monthyears[$e]->emonth, 2 ) . '">' . $monthyears[$e]->lmonth . ' ' . $monthyears[$e]->year . "</option>\n";	}}?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><p><?php _e('When you click the button below WordPress will create an XML file for you to save to your computer.'); ?></p><p><?php _e('This format, which we call WordPress eXtended RSS or WXR, will contain your posts, pages, comments, custom fields, categories, and tags.'); ?></p><p><?php _e('Once you&#8217;ve saved the download file, you can use the Import function on another WordPress site to import this site.'); ?></p><form action="" method="get"><h3><?php _e('Filters'); ?></h3><table class="form-table"><tr><th><label for="mm_start"><?php _e('Start Date'); ?></label></th><td><select name="mm_start" id="mm_start">	<option value="all" selected="selected"><?php _e('All Dates'); ?></option><?php echo $dateoptions; ?></select></td></tr><tr><th><label for="mm_end" id="mm_end"><?php _e('End Date'); ?></label></th><td><select name="mm_end" id="mm_end">	<option value="all" selected="selected"><?php _e('All Dates'); ?></option><?php echo $edateoptions; ?></select></td></tr><tr><th><label for="author"><?php _e('Authors'); ?></label></th><td><select name="author" id="author"><option value="all" selected="selected"><?php _e('All Authors'); ?></option><?php$authors = $wpdb->get_results( "SELECT DISTINCT u.id, u.display_name FROM $wpdb->users u INNER JOIN $wpdb->posts p WHERE u.id = p.post_author ORDER BY u.display_name" );foreach ( (array) $authors as $author ) {	echo "<option value='{$author->id}'>{$author->display_name}</option>\n";}?></select></td></tr><?php foreach ( get_taxonomies( array( 'show_ui' => true ), 'objects' ) as $tax_obj ) {	$term_dropdown = wp_dropdown_categories( array( 'taxonomy' => $tax_obj->name, 'hide_if_empty' => true, 'show_option_all' => __( 'All Terms' ), 'name' => 'taxonomy[' . $tax_obj->name . ']', 'id' => 'taxonomy-' . $tax_obj->name, 'class' => '', 'echo' => false ) );	if ( $term_dropdown )		echo '<tr><th><label for="taxonomy-' . $tax_obj->name . '">' . $tax_obj->labels->name . '</label></th><td>' . $term_dropdown . '</td></tr>';}?><tr><th><label for="post_type"><?php _e('Content Types'); ?></label></th><td><select name="post_type" id="post_type">	<option value="all" selected="selected"><?php _e('All Content'); ?></option>	<?php foreach ( get_post_types( array( 'public' => true, 'can_export' => true ), 'objects' ) as $post_type_obj ) { ?>		<option value="<?php echo $post_type_obj->name; ?>"><?php echo $post_type_obj->labels->name; ?></option>	<?php } ?></select></td></tr><tr><th><label for="status"><?php _e('Statuses'); ?></label></th><td><select name="status" id="status">	<option value="all" selected="selected"><?php _e('All Statuses'); ?></option><?php foreach ( get_post_stati( array( 'internal' => false ), 'objects' ) as $post_status_obj ) { ?>	<option value="<?php echo $post_status_obj->name; ?>"><?php echo $post_status_obj->label; ?></option><?php } ?></select></td></tr></table><p class="submit"><input type="submit" name="submit" class="button" value="<?php esc_attr_e('Download Export File'); ?>" /><input type="hidden" name="download" value="true" /></p></form></div><?phpinclude ('admin-footer.php');?>
<?php/** * TwentyTen functions and definitions * * Sets up the theme and provides some helper functions. Some helper functions * are used in the theme as custom template tags. Others are attached to action and * filter hooks in WordPress to change core functionality. * * The first function, twentyten_setup(), sets up the theme by registering support * for various features in WordPress, such as post thumbnails, navigation menus, and the like. * * When using a child theme (see http://codex.wordpress.org/Theme_Development and * http://codex.wordpress.org/Child_Themes), you can override certain functions * (those wrapped in a function_exists() call) by defining them first in your child theme's * functions.php file. The child theme's functions.php file is included before the parent * theme's file, so the child theme functions would be used. * * Functions that are not pluggable (not wrapped in function_exists()) are instead attached * to a filter or action hook. The hook can be removed by using remove_action() or * remove_filter() and you can attach your own function to the hook. * * We can remove the parent theme's hook only after it is attached, which means we need to * wait until setting up the child theme: * * <code> * add_action( 'after_setup_theme', 'my_child_theme_setup' ); * function my_child_theme_setup() { *     // We are providing our own filter for excerpt_length (or using the unfiltered value) *     remove_filter( 'excerpt_length', 'twentyten_excerpt_length' ); *     ... * } * </code> * * For more information on hooks, actions, and filters, see http://codex.wordpress.org/Plugin_API. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 *//** * Set the content width based on the theme's design and stylesheet. * * Used to set the width of images and content. Should be equal to the width the theme * is designed for, generally via the style.css stylesheet. */if ( ! isset( $content_width ) )	$content_width = 640;/** Tell WordPress to run twentyten_setup() when the 'after_setup_theme' hook is run. */add_action( 'after_setup_theme', 'twentyten_setup' );if ( ! function_exists( 'twentyten_setup' ) ):/** * Sets up theme defaults and registers support for various WordPress features. * * Note that this function is hooked into the after_setup_theme hook, which runs * before the init hook. The init hook is too late for some features, such as indicating * support post thumbnails. * * To override twentyten_setup() in a child theme, add your own twentyten_setup to your child theme's * functions.php file. * * @uses add_theme_support() To add support for post thumbnails and automatic feed links. * @uses register_nav_menus() To add support for navigation menus. * @uses add_custom_background() To add support for a custom background. * @uses add_editor_style() To style the visual editor. * @uses load_theme_textdomain() For translation/localization support. * @uses add_custom_image_header() To add support for a custom header. * @uses register_default_headers() To register the default custom header images provided with the theme. * @uses set_post_thumbnail_size() To set a custom post thumbnail size. * * @since Twenty Ten 1.0 */function twentyten_setup() {	// This theme styles the visual editor with editor-style.css to match the theme style.	add_editor_style();	// This theme uses post thumbnails	add_theme_support( 'post-thumbnails' );	// Add default posts and comments RSS feed links to head	add_theme_support( 'automatic-feed-links' );	// Make theme available for translation	// Translations can be filed in the /languages/ directory	load_theme_textdomain( 'twentyten', TEMPLATEPATH . '/languages' );	$locale = get_locale();	$locale_file = TEMPLATEPATH . "/languages/$locale.php";	if ( is_readable( $locale_file ) )		require_once( $locale_file );	// This theme uses wp_nav_menu() in one location.	register_nav_menus( array(		'primary' => __( 'Primary Navigation', 'twentyten' ),	) );	// This theme allows users to set a custom background	add_custom_background();	// Your changeable header business starts here	define( 'HEADER_TEXTCOLOR', '' );	// No CSS, just IMG call. The %s is a placeholder for the theme template directory URI.	define( 'HEADER_IMAGE', '%s/images/headers/path.jpg' );	// The height and width of your custom header. You can hook into the theme's own filters to change these values.	// Add a filter to twentyten_header_image_width and twentyten_header_image_height to change these values.	define( 'HEADER_IMAGE_WIDTH', apply_filters( 'twentyten_header_image_width', 940 ) );	define( 'HEADER_IMAGE_HEIGHT', apply_filters( 'twentyten_header_image_height', 198 ) );	// We'll be using post thumbnails for custom header images on posts and pages.	// We want them to be 940 pixels wide by 198 pixels tall.	// Larger images will be auto-cropped to fit, smaller ones will be ignored. See header.php.	set_post_thumbnail_size( HEADER_IMAGE_WIDTH, HEADER_IMAGE_HEIGHT, true );	// Don't support text inside the header image.	define( 'NO_HEADER_TEXT', true );	// Add a way for the custom header to be styled in the admin panel that controls	// custom headers. See twentyten_admin_header_style(), below.	add_custom_image_header( '', 'twentyten_admin_header_style' );	// ... and thus ends the changeable header business.	// Default custom headers packaged with the theme. %s is a placeholder for the theme template directory URI.	register_default_headers( array(		'berries' => array(			'url' => '%s/images/headers/berries.jpg',			'thumbnail_url' => '%s/images/headers/berries-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Berries', 'twentyten' )		),		'cherryblossom' => array(			'url' => '%s/images/headers/cherryblossoms.jpg',			'thumbnail_url' => '%s/images/headers/cherryblossoms-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Cherry Blossoms', 'twentyten' )		),		'concave' => array(			'url' => '%s/images/headers/concave.jpg',			'thumbnail_url' => '%s/images/headers/concave-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Concave', 'twentyten' )		),		'fern' => array(			'url' => '%s/images/headers/fern.jpg',			'thumbnail_url' => '%s/images/headers/fern-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Fern', 'twentyten' )		),		'forestfloor' => array(			'url' => '%s/images/headers/forestfloor.jpg',			'thumbnail_url' => '%s/images/headers/forestfloor-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Forest Floor', 'twentyten' )		),		'inkwell' => array(			'url' => '%s/images/headers/inkwell.jpg',			'thumbnail_url' => '%s/images/headers/inkwell-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Inkwell', 'twentyten' )		),		'path' => array(			'url' => '%s/images/headers/path.jpg',			'thumbnail_url' => '%s/images/headers/path-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Path', 'twentyten' )		),		'sunset' => array(			'url' => '%s/images/headers/sunset.jpg',			'thumbnail_url' => '%s/images/headers/sunset-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Sunset', 'twentyten' )		)	) );}endif;if ( ! function_exists( 'twentyten_admin_header_style' ) ) :/** * Styles the header image displayed on the Appearance > Header admin panel. * * Referenced via add_custom_image_header() in twentyten_setup(). * * @since Twenty Ten 1.0 */function twentyten_admin_header_style() {?><style type="text/css">/* Shows the same border as on front end */#headimg {	border-bottom: 1px solid #000;	border-top: 4px solid #000;}/* If NO_HEADER_TEXT is false, you would style the text with these selectors:	#headimg #name { }	#headimg #desc { }*/</style><?php}endif;/** * Makes some changes to the <title> tag, by filtering the output of wp_title(). * * If we have a site description and we're viewing the home page or a blog posts * page (when using a static front page), then we will add the site description. * * If we're viewing a search result, then we're going to recreate the title entirely. * We're going to add page numbers to all titles as well, to the middle of a search * result title and the end of all other titles. * * The site title also gets added to all titles. * * @since Twenty Ten 1.0 * * @param string $title Title generated by wp_title() * @param string $separator The separator passed to wp_title(). Twenty Ten uses a * 	vertical bar, "|", as a separator in header.php. * @return string The new title, ready for the <title> tag. */function twentyten_filter_wp_title( $title, $separator ) {	// Don't affect wp_title() calls in feeds.	if ( is_feed() )		return $title;	// The $paged global variable contains the page number of a listing of posts.	// The $page global variable contains the page number of a single post that is paged.	// We'll display whichever one applies, if we're not looking at the first page.	global $paged, $page;	if ( is_search() ) {		// If we're a search, let's start over:		$title = sprintf( __( 'Search results for %s', 'twentyten' ), '"' . get_search_query() . '"' );		// Add a page number if we're on page 2 or more:		if ( $paged >= 2 )			$title .= " $separator " . sprintf( __( 'Page %s', 'twentyten' ), $paged );		// Add the site name to the end:		$title .= " $separator " . get_bloginfo( 'name', 'display' );		// We're done. Let's send the new title back to wp_title():		return $title;	}	// Otherwise, let's start by adding the site name to the end:	$title .= get_bloginfo( 'name', 'display' );	// If we have a site description and we're on the home/front page, add the description:	$site_description = get_bloginfo( 'description', 'display' );	if ( $site_description && ( is_home() || is_front_page() ) )		$title .= " $separator " . $site_description;	// Add a page number if necessary:	if ( $paged >= 2 || $page >= 2 )		$title .= " $separator " . sprintf( __( 'Page %s', 'twentyten' ), max( $paged, $page ) );	// Return the new title to wp_title():	return $title;}add_filter( 'wp_title', 'twentyten_filter_wp_title', 10, 2 );/** * Get our wp_nav_menu() fallback, wp_page_menu(), to show a home link. * * To override this in a child theme, remove the filter and optionally add * your own function tied to the wp_page_menu_args filter hook. * * @since Twenty Ten 1.0 */function twentyten_page_menu_args( $args ) {	$args['show_home'] = true;	return $args;}add_filter( 'wp_page_menu_args', 'twentyten_page_menu_args' );/** * Sets the post excerpt length to 40 characters. * * To override this length in a child theme, remove the filter and add your own * function tied to the excerpt_length filter hook. * * @since Twenty Ten 1.0 * @return int */function twentyten_excerpt_length( $length ) {	return 40;}add_filter( 'excerpt_length', 'twentyten_excerpt_length' );/** * Returns a "Continue Reading" link for excerpts * * @since Twenty Ten 1.0 * @return string "Continue Reading" link */function twentyten_continue_reading_link() {	return ' <a href="'. get_permalink() . '">' . __( 'Continue reading <span class="meta-nav">&rarr;</span>', 'twentyten' ) . '</a>';}/** * Replaces "[...]" (appended to automatically generated excerpts) with an ellipsis and twentyten_continue_reading_link(). * * To override this in a child theme, remove the filter and add your own * function tied to the excerpt_more filter hook. * * @since Twenty Ten 1.0 * @return string An ellipsis */function twentyten_auto_excerpt_more( $more ) {	return ' &hellip;' . twentyten_continue_reading_link();}add_filter( 'excerpt_more', 'twentyten_auto_excerpt_more' );/** * Adds a pretty "Continue Reading" link to custom post excerpts. * * To override this link in a child theme, remove the filter and add your own * function tied to the get_the_excerpt filter hook. * * @since Twenty Ten 1.0 * @return string Excerpt with a pretty "Continue Reading" link */function twentyten_custom_excerpt_more( $output ) {	if ( has_excerpt() && ! is_attachment() ) {		$output .= twentyten_continue_reading_link();	}	return $output;}add_filter( 'get_the_excerpt', 'twentyten_custom_excerpt_more' );/** * Remove inline styles printed when the gallery shortcode is used. * * Galleries are styled by the theme in Twenty Ten's style.css. * * @since Twenty Ten 1.0 * @return string The gallery style filter, with the styles themselves removed. */function twentyten_remove_gallery_css( $css ) {	return preg_replace( "#<style type='text/css'>(.*?)</style>#s", '', $css );}add_filter( 'gallery_style', 'twentyten_remove_gallery_css' );if ( ! function_exists( 'twentyten_comment' ) ) :/** * Template for comments and pingbacks. * * To override this walker in a child theme without modifying the comments template * simply create your own twentyten_comment(), and that function will be used instead. * * Used as a callback by wp_list_comments() for displaying the comments. * * @since Twenty Ten 1.0 */function twentyten_comment( $comment, $args, $depth ) {	$GLOBALS['comment'] = $comment;	switch ( $comment->comment_type ) :		case '' :	?>	<li <?php comment_class(); ?> id="li-comment-<?php comment_ID(); ?>">		<div id="comment-<?php comment_ID(); ?>">		<div class="comment-author vcard">			<?php echo get_avatar( $comment, 40 ); ?>			<?php printf( __( '%s <span class="says">says:</span>', 'twentyten' ), sprintf( '<cite class="fn">%s</cite>', get_comment_author_link() ) ); ?>		</div><!-- .comment-author .vcard -->		<?php if ( $comment->comment_approved == '0' ) : ?>			<em><?php _e( 'Your comment is awaiting moderation.', 'twentyten' ); ?></em>			<br />		<?php endif; ?>		<div class="comment-meta commentmetadata"><a href="<?php echo esc_url( get_comment_link( $comment->comment_ID ) ); ?>">			<?php				/* translators: 1: date, 2: time */				printf( __( '%1$s at %2$s', 'twentyten' ), get_comment_date(),  get_comment_time() ); ?></a><?php edit_comment_link( __( '(Edit)', 'twentyten' ), ' ' );			?>		</div><!-- .comment-meta .commentmetadata -->		<div class="comment-body"><?php comment_text(); ?></div>		<div class="reply">			<?php comment_reply_link( array_merge( $args, array( 'depth' => $depth, 'max_depth' => $args['max_depth'] ) ) ); ?>		</div><!-- .reply -->	</div><!-- #comment-##  -->	<?php			break;		case 'pingback'  :		case 'trackback' :	?>	<li class="post pingback">		<p><?php _e( 'Pingback:', 'twentyten' ); ?> <?php comment_author_link(); ?><?php edit_comment_link( __('(Edit)', 'twentyten'), ' ' ); ?></p>	<?php			break;	endswitch;}endif;/** * Register widgetized areas, including two sidebars and four widget-ready columns in the footer. * * To override twentyten_widgets_init() in a child theme, remove the action hook and add your own * function tied to the init hook. * * @since Twenty Ten 1.0 * @uses register_sidebar */function twentyten_widgets_init() {	// Area 1, located at the top of the sidebar.	register_sidebar( array(		'name' => __( 'Primary Widget Area', 'twentyten' ),		'id' => 'primary-widget-area',		'description' => __( 'The primary widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );	// Area 2, located below the Primary Widget Area in the sidebar. Empty by default.	register_sidebar( array(		'name' => __( 'Secondary Widget Area', 'twentyten' ),		'id' => 'secondary-widget-area',		'description' => __( 'The secondary widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );	// Area 3, located in the footer. Empty by default.	register_sidebar( array(		'name' => __( 'First Footer Widget Area', 'twentyten' ),		'id' => 'first-footer-widget-area',		'description' => __( 'The first footer widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );	// Area 4, located in the footer. Empty by default.	register_sidebar( array(		'name' => __( 'Second Footer Widget Area', 'twentyten' ),		'id' => 'second-footer-widget-area',		'description' => __( 'The second footer widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );	// Area 5, located in the footer. Empty by default.	register_sidebar( array(		'name' => __( 'Third Footer Widget Area', 'twentyten' ),		'id' => 'third-footer-widget-area',		'description' => __( 'The third footer widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );	// Area 6, located in the footer. Empty by default.	register_sidebar( array(		'name' => __( 'Fourth Footer Widget Area', 'twentyten' ),		'id' => 'fourth-footer-widget-area',		'description' => __( 'The fourth footer widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );}/** Register sidebars by running twentyten_widgets_init() on the widgets_init hook. */add_action( 'widgets_init', 'twentyten_widgets_init' );/** * Removes the default styles that are packaged with the Recent Comments widget. * * To override this in a child theme, remove the filter and optionally add your own * function tied to the widgets_init action hook. * * @since Twenty Ten 1.0 */function twentyten_remove_recent_comments_style() {	global $wp_widget_factory;	remove_action( 'wp_head', array( $wp_widget_factory->widgets['WP_Widget_Recent_Comments'], 'recent_comments_style' ) );}add_action( 'widgets_init', 'twentyten_remove_recent_comments_style' );if ( ! function_exists( 'twentyten_posted_on' ) ) :/** * Prints HTML with meta information for the current postdate/time and author. * * @since Twenty Ten 1.0 */function twentyten_posted_on() {	printf( __( '<span class="%1$s">Posted on</span> %2$s <span class="meta-sep">by</span> %3$s', 'twentyten' ),		'meta-prep meta-prep-author',		sprintf( '<a href="%1$s" title="%2$s" rel="bookmark"><span class="entry-date">%3$s</span></a>',			get_permalink(),			esc_attr( get_the_time() ),			get_the_date()		),		sprintf( '<span class="author vcard"><a class="url fn n" href="%1$s" title="%2$s">%3$s</a></span>',			get_author_posts_url( get_the_author_meta( 'ID' ) ),			sprintf( esc_attr__( 'View all posts by %s', 'twentyten' ), get_the_author() ),			get_the_author()		)	);}endif;if ( ! function_exists( 'twentyten_posted_in' ) ) :/** * Prints HTML with meta information for the current post (category, tags and permalink). * * @since Twenty Ten 1.0 */function twentyten_posted_in() {	// Retrieves tag list of current post, separated by commas.	$tag_list = get_the_tag_list( '', ', ' );	if ( $tag_list ) {		$posted_in = __( 'This entry was posted in %1$s and tagged %2$s. Bookmark the <a href="%3$s" title="Permalink to %4$s" rel="bookmark">permalink</a>.', 'twentyten' );	} elseif ( is_object_in_taxonomy( get_post_type(), 'category' ) ) {		$posted_in = __( 'This entry was posted in %1$s. Bookmark the <a href="%3$s" title="Permalink to %4$s" rel="bookmark">permalink</a>.', 'twentyten' );	} else {		$posted_in = __( 'Bookmark the <a href="%3$s" title="Permalink to %4$s" rel="bookmark">permalink</a>.', 'twentyten' );	}	// Prints the string, replacing the placeholders.	printf(		$posted_in,		get_the_category_list( ', ' ),		$tag_list,		get_permalink(),		the_title_attribute( 'echo=0' )	);}endif;
<?php/** * Atom Publishing Protocol support for WordPress * * @version 1.0.5-dc *//** * WordPress is handling an Atom Publishing Protocol request. * * @var bool */define('APP_REQUEST', true);/** Set up WordPress environment */require_once('./wp-load.php');/** Atom Publishing Protocol Class */require_once(ABSPATH . WPINC . '/atomlib.php');/** Admin Image API for metadata updating */require_once(ABSPATH . '/wp-admin/includes/image.php');$_SERVER['PATH_INFO'] = preg_replace( '/.*\/wp-app\.php/', '', $_SERVER['REQUEST_URI'] );/** * Whether to enable Atom Publishing Protocol Logging. * * @name app_logging * @var int|bool */$app_logging = 0;/** * Whether to always authenticate user. Permanently set to true. * * @name always_authenticate * @var int|bool * @todo Should be an option somewhere */$always_authenticate = 1;/** * Writes logging info to a file. * * @since 2.2.0 * @uses $app_logging * @package WordPress * @subpackage Logging * * @param string $label Type of logging * @param string $msg Information describing logging reason. */function log_app($label,$msg) {	global $app_logging;	if ($app_logging) {		$fp = fopen( 'wp-app.log', 'a+');		$date = gmdate( 'Y-m-d H:i:s' );		fwrite($fp, "\n\n$date - $label\n$msg\n");		fclose($fp);	}}/** * Filter to add more post statuses. * * @since 2.2.0 * * @param string $where SQL statement to filter. * @return string Filtered SQL statement with added post_status for where clause. */function wa_posts_where_include_drafts_filter($where) {	$where = str_replace("post_status = 'publish'","post_status = 'publish' OR post_status = 'future' OR post_status = 'draft' OR post_status = 'inherit'", $where);	return $where;}add_filter('posts_where', 'wa_posts_where_include_drafts_filter');/** * WordPress AtomPub API implementation. * * @package WordPress * @subpackage Publishing * @since 2.2.0 */class AtomServer {	/**	 * ATOM content type.	 *	 * @since 2.2.0	 * @var string	 */	var $ATOM_CONTENT_TYPE = 'application/atom+xml';	/**	 * Categories ATOM content type.	 *	 * @since 2.2.0	 * @var string	 */	var $CATEGORIES_CONTENT_TYPE = 'application/atomcat+xml';	/**	 * Service ATOM content type.	 *	 * @since 2.3.0	 * @var string	 */	var $SERVICE_CONTENT_TYPE = 'application/atomsvc+xml';	/**	 * ATOM XML namespace.	 *	 * @since 2.3.0	 * @var string	 */	var $ATOM_NS = 'http://www.w3.org/2005/Atom';	/**	 * ATOMPUB XML namespace.	 *	 * @since 2.3.0	 * @var string	 */	var $ATOMPUB_NS = 'http://www.w3.org/2007/app';	/**	 * Entries path.	 *	 * @since 2.2.0	 * @var string	 */	var $ENTRIES_PATH = "posts";	/**	 * Categories path.	 *	 * @since 2.2.0	 * @var string	 */	var $CATEGORIES_PATH = "categories";	/**	 * Media path.	 *	 * @since 2.2.0	 * @var string	 */	var $MEDIA_PATH = "attachments";	/**	 * Entry path.	 *	 * @since 2.2.0	 * @var string	 */	var $ENTRY_PATH = "post";	/**	 * Service path.	 *	 * @since 2.2.0	 * @var string	 */	var $SERVICE_PATH = "service";	/**	 * Media single path.	 *	 * @since 2.2.0	 * @var string	 */	var $MEDIA_SINGLE_PATH = "attachment";	/**	 * ATOMPUB parameters.	 *	 * @since 2.2.0	 * @var array	 */	var $params = array();	/**	 * Supported ATOMPUB media types.	 *	 * @since 2.3.0	 * @var array	 */	var $media_content_types = array('image/*','audio/*','video/*');	/**	 * ATOMPUB content type(s).	 *	 * @since 2.2.0	 * @var array	 */	var $atom_content_types = array('application/atom+xml');	/**	 * ATOMPUB methods.	 *	 * @since 2.2.0	 * @var unknown_type	 */	var $selectors = array();	/**	 * Whether to do output.	 *	 * Support for head.	 *	 * @since 2.2.0	 * @var bool	 */	var $do_output = true;	/**	 * PHP4 constructor - Sets up object properties.	 *	 * @since 2.2.0	 * @return AtomServer	 */	function AtomServer() {		$this->script_name = array_pop(explode('/',$_SERVER['SCRIPT_NAME']));		$this->app_base = site_url( $this->script_name . '/' );		$this->selectors = array(			'@/service$@' =>				array('GET' => 'get_service'),			'@/categories$@' =>				array('GET' => 'get_categories_xml'),			'@/post/(\d+)$@' =>				array('GET' => 'get_post',						'PUT' => 'put_post',						'DELETE' => 'delete_post'),			'@/posts/?(\d+)?$@' =>				array('GET' => 'get_posts',						'POST' => 'create_post'),			'@/attachments/?(\d+)?$@' =>				array('GET' => 'get_attachment',						'POST' => 'create_attachment'),			'@/attachment/file/(\d+)$@' =>				array('GET' => 'get_file',						'PUT' => 'put_file',						'DELETE' => 'delete_file'),			'@/attachment/(\d+)$@' =>				array('GET' => 'get_attachment',						'PUT' => 'put_attachment',						'DELETE' => 'delete_attachment'),		);	}	/**	 * Handle ATOMPUB request.	 *	 * @since 2.2.0	 */	function handle_request() {		global $always_authenticate;		if ( !empty( $_SERVER['ORIG_PATH_INFO'] ) )			$path = $_SERVER['ORIG_PATH_INFO'];		else			$path = $_SERVER['PATH_INFO'];		$method = $_SERVER['REQUEST_METHOD'];		log_app('REQUEST',"$method $path\n================");		$this->process_conditionals();		//$this->process_conditionals();		// exception case for HEAD (treat exactly as GET, but don't output)		if ($method == 'HEAD') {			$this->do_output = false;			$method = 'GET';		}		// redirect to /service in case no path is found.		if (strlen($path) == 0 || $path == '/')			$this->redirect($this->get_service_url());		// check to see if AtomPub is enabled		if ( !get_option( 'enable_app' ) )			$this->forbidden( sprintf( __( 'AtomPub services are disabled on this site.  An admin user can enable them at %s' ), admin_url('options-writing.php') ) );		// dispatch		foreach ( $this->selectors as $regex => $funcs ) {			if ( preg_match($regex, $path, $matches) ) {				if ( isset($funcs[$method]) ) {					// authenticate regardless of the operation and set the current					// user. each handler will decide if auth is required or not.					if ( !$this->authenticate() ) {						if ( $always_authenticate )							$this->auth_required('Credentials required.');					}					array_shift($matches);					call_user_func_array(array(&$this,$funcs[$method]), $matches);					exit();				} else {					// only allow what we have handlers for...					$this->not_allowed(array_keys($funcs));				}			}		}		// oops, nothing found		$this->not_found();	}	/**	 * Retrieve XML for ATOMPUB service.	 *	 * @since 2.2.0	 */	function get_service() {		log_app('function','get_service()');		if ( !current_user_can( 'edit_posts' ) )			$this->auth_required( __( 'Sorry, you do not have the right to access this site.' ) );		$entries_url = esc_attr($this->get_entries_url());		$categories_url = esc_attr($this->get_categories_url());		$media_url = esc_attr($this->get_attachments_url());		$accepted_media_types = '';		foreach ($this->media_content_types as $med) {			$accepted_media_types = $accepted_media_types . "<accept>" . $med . "</accept>";		}		$atom_prefix="atom";		$atom_blogname = get_bloginfo('name');		$service_doc = <<<EOD<service xmlns="$this->ATOMPUB_NS" xmlns:$atom_prefix="$this->ATOM_NS">  <workspace>    <$atom_prefix:title>$atom_blogname Workspace</$atom_prefix:title>    <collection href="$entries_url">      <$atom_prefix:title>$atom_blogname Posts</$atom_prefix:title>      <accept>$this->ATOM_CONTENT_TYPE;type=entry</accept>      <categories href="$categories_url" />    </collection>    <collection href="$media_url">      <$atom_prefix:title>$atom_blogname Media</$atom_prefix:title>      $accepted_media_types    </collection>  </workspace></service>EOD;		$this->output($service_doc, $this->SERVICE_CONTENT_TYPE);	}	/**	 * Retrieve categories list in XML format.	 *	 * @since 2.2.0	 */	function get_categories_xml() {		log_app('function','get_categories_xml()');		if ( !current_user_can( 'edit_posts' ) )			$this->auth_required( __( 'Sorry, you do not have the right to access this site.' ) );		$home = esc_attr(get_bloginfo_rss('url'));		$categories = "";		$cats = get_categories(array('hierarchical' => 0, 'hide_empty' => 0));		foreach ( (array) $cats as $cat ) {			$categories .= "    <category term=\"" . esc_attr($cat->name) .  "\" />\n";		}		$output = <<<EOD<app:categories xmlns:app="$this->ATOMPUB_NS"	xmlns="$this->ATOM_NS"	fixed="yes" scheme="$home">	$categories</app:categories>EOD;		$this->output($output, $this->CATEGORIES_CONTENT_TYPE);	}	/**	 * Create new post.	 *	 * @since 2.2.0	 */	function create_post() {		global $blog_id, $user_ID;		$this->get_accepted_content_type($this->atom_content_types);		$parser = new AtomParser();		if ( !$parser->parse() )			$this->client_error();		$entry = array_pop($parser->feed->entries);		log_app('Received entry:', print_r($entry,true));		$catnames = array();		foreach ( $entry->categories as $cat ) {			array_push($catnames, $cat["term"]);		}		$wp_cats = get_categories(array('hide_empty' => false));		$post_category = array();		foreach ( $wp_cats as $cat ) {			if ( in_array($cat->name, $catnames) )				array_push($post_category, $cat->term_id);		}		$publish = ! ( isset( $entry->draft ) && 'yes' == trim( $entry->draft ) );		$cap = ($publish) ? 'publish_posts' : 'edit_posts';		if ( !current_user_can($cap) )			$this->auth_required(__('Sorry, you do not have the right to edit/publish new posts.'));		$blog_ID = (int ) $blog_id;		$post_status = ($publish) ? 'publish' : 'draft';		$post_author = (int) $user_ID;		$post_title = $entry->title[1];		$post_content = $entry->content[1];		$post_excerpt = $entry->summary[1];		$pubtimes = $this->get_publish_time($entry->published);		$post_date = $pubtimes[0];		$post_date_gmt = $pubtimes[1];		if ( isset( $_SERVER['HTTP_SLUG'] ) )			$post_name = $_SERVER['HTTP_SLUG'];		$post_data = compact('blog_ID', 'post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_title', 'post_category', 'post_status', 'post_excerpt', 'post_name');		$this->escape($post_data);		log_app('Inserting Post. Data:', print_r($post_data,true));		$postID = wp_insert_post($post_data);		if ( is_wp_error( $postID ) )			$this->internal_error($postID->get_error_message());		if ( !$postID )			$this->internal_error(__('Sorry, your entry could not be posted. Something wrong happened.'));		// getting warning here about unable to set headers		// because something in the cache is printing to the buffer		// could we clean up wp_set_post_categories or cache to not print		// this could affect our ability to send back the right headers		@wp_set_post_categories($postID, $post_category);		do_action( 'atompub_create_post', $postID, $entry );		$output = $this->get_entry($postID);		log_app('function',"create_post($postID)");		$this->created($postID, $output);	}	/**	 * Retrieve post.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 */	function get_post($postID) {		global $entry;		if ( !current_user_can( 'edit_post', $postID ) )			$this->auth_required( __( 'Sorry, you do not have the right to access this post.' ) );		$this->set_current_entry($postID);		$output = $this->get_entry($postID);		log_app('function',"get_post($postID)");		$this->output($output);	}	/**	 * Update post.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 */	function put_post($postID) {		// checked for valid content-types (atom+xml)		// quick check and exit		$this->get_accepted_content_type($this->atom_content_types);		$parser = new AtomParser();		if ( !$parser->parse() )			$this->bad_request();		$parsed = array_pop($parser->feed->entries);		log_app('Received UPDATED entry:', print_r($parsed,true));		// check for not found		global $entry;		$this->set_current_entry($postID);		if ( !current_user_can('edit_post', $entry['ID']) )			$this->auth_required(__('Sorry, you do not have the right to edit this post.'));		$publish = ! ( isset($parsed->draft) && 'yes' == trim($parsed->draft) );		$post_status = ($publish) ? 'publish' : 'draft';		extract($entry);		$post_title = $parsed->title[1];		$post_content = $parsed->content[1];		$post_excerpt = $parsed->summary[1];		$pubtimes = $this->get_publish_time($entry->published);		$post_date = $pubtimes[0];		$post_date_gmt = $pubtimes[1];		$pubtimes = $this->get_publish_time($parsed->updated);		$post_modified = $pubtimes[0];		$post_modified_gmt = $pubtimes[1];		$postdata = compact('ID', 'post_content', 'post_title', 'post_category', 'post_status', 'post_excerpt', 'post_date', 'post_date_gmt', 'post_modified', 'post_modified_gmt');		$this->escape($postdata);		$result = wp_update_post($postdata);		if ( !$result )			$this->internal_error(__('For some strange yet very annoying reason, this post could not be edited.'));		do_action( 'atompub_put_post', $ID, $parsed );		log_app('function',"put_post($postID)");		$this->ok();	}	/**	 * Remove post.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 */	function delete_post($postID) {		// check for not found		global $entry;		$this->set_current_entry($postID);		if ( !current_user_can('edit_post', $postID) )			$this->auth_required(__('Sorry, you do not have the right to delete this post.'));		if ( $entry['post_type'] == 'attachment' ) {			$this->delete_attachment($postID);		} else {			$result = wp_delete_post($postID);			if ( !$result ) {				$this->internal_error(__('For some strange yet very annoying reason, this post could not be deleted.'));			}			log_app('function',"delete_post($postID)");			$this->ok();		}	}	/**	 * Retrieve attachment.	 *	 * @since 2.2.0	 *	 * @param int $postID Optional. Post ID.	 */	function get_attachment($postID = null) {		if ( !current_user_can( 'upload_files' ) )			$this->auth_required( __( 'Sorry, you do not have permission to upload files.' ) );		if ( !isset($postID) ) {			$this->get_attachments();		} else {			$this->set_current_entry($postID);			$output = $this->get_entry($postID, 'attachment');			log_app('function',"get_attachment($postID)");			$this->output($output);		}	}	/**	 * Create new attachment.	 *	 * @since 2.2.0	 */	function create_attachment() {		$type = $this->get_accepted_content_type();		if ( !current_user_can('upload_files') )			$this->auth_required(__('You do not have permission to upload files.'));		$fp = fopen("php://input", "rb");		$bits = null;		while ( !feof($fp) ) {			$bits .= fread($fp, 4096);		}		fclose($fp);		$slug = '';		if ( isset( $_SERVER['HTTP_SLUG'] ) )			$slug = sanitize_file_name( $_SERVER['HTTP_SLUG'] );		elseif ( isset( $_SERVER['HTTP_TITLE'] ) )			$slug = sanitize_file_name( $_SERVER['HTTP_TITLE'] );		elseif ( empty( $slug ) ) // just make a random name			$slug = substr( md5( uniqid( microtime() ) ), 0, 7);		$ext = preg_replace( '|.*/([a-z0-9]+)|', '$1', $_SERVER['CONTENT_TYPE'] );		$slug = "$slug.$ext";		$file = wp_upload_bits( $slug, NULL, $bits);		log_app('wp_upload_bits returns:',print_r($file,true));		$url = $file['url'];		$file = $file['file'];		do_action('wp_create_file_in_uploads', $file); // replicate		// Construct the attachment array		$attachment = array(			'post_title' => $slug,			'post_content' => $slug,			'post_status' => 'attachment',			'post_parent' => 0,			'post_mime_type' => $type,			'guid' => $url			);		// Save the data		$postID = wp_insert_attachment($attachment, $file);		if (!$postID)			$this->internal_error(__('Sorry, your entry could not be posted. Something wrong happened.'));		$output = $this->get_entry($postID, 'attachment');		$this->created($postID, $output, 'attachment');		log_app('function',"create_attachment($postID)");	}	/**	 * Update attachment.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 */	function put_attachment($postID) {		// checked for valid content-types (atom+xml)		// quick check and exit		$this->get_accepted_content_type($this->atom_content_types);		$parser = new AtomParser();		if (!$parser->parse()) {			$this->bad_request();		}		$parsed = array_pop($parser->feed->entries);		// check for not found		global $entry;		$this->set_current_entry($postID);		if ( !current_user_can('edit_post', $entry['ID']) )			$this->auth_required(__('Sorry, you do not have the right to edit this post.'));		extract($entry);		$post_title = $parsed->title[1];		$post_content = $parsed->summary[1];		$pubtimes = $this->get_publish_time($parsed->updated);		$post_modified = $pubtimes[0];		$post_modified_gmt = $pubtimes[1];		$postdata = compact('ID', 'post_content', 'post_title', 'post_category', 'post_status', 'post_excerpt', 'post_modified', 'post_modified_gmt');		$this->escape($postdata);		$result = wp_update_post($postdata);		if ( !$result )			$this->internal_error(__('For some strange yet very annoying reason, this post could not be edited.'));		log_app('function',"put_attachment($postID)");		$this->ok();	}	/**	 * Remove attachment.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 */	function delete_attachment($postID) {		log_app('function',"delete_attachment($postID). File '$location' deleted.");		// check for not found		global $entry;		$this->set_current_entry($postID);		if ( !current_user_can('edit_post', $postID) )			$this->auth_required(__('Sorry, you do not have the right to delete this post.'));		$location = get_post_meta($entry['ID'], '_wp_attached_file', true);		$filetype = wp_check_filetype($location);		if ( !isset($location) || 'attachment' != $entry['post_type'] || empty($filetype['ext']) )			$this->internal_error(__('Error ocurred while accessing post metadata for file location.'));		// delete file		@unlink($location);		// delete attachment		$result = wp_delete_post($postID);		if ( !$result )			$this->internal_error(__('For some strange yet very annoying reason, this post could not be deleted.'));		log_app('function',"delete_attachment($postID). File '$location' deleted.");		$this->ok();	}	/**	 * Retrieve attachment from post.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 */	function get_file($postID) {		// check for not found		global $entry;		$this->set_current_entry($postID);		// then whether user can edit the specific post		if ( !current_user_can('edit_post', $postID) )			$this->auth_required(__('Sorry, you do not have the right to edit this post.'));		$location = get_post_meta($entry['ID'], '_wp_attached_file', true);		$location = get_option ('upload_path') . '/' . $location;		$filetype = wp_check_filetype($location);		if ( !isset($location) || 'attachment' != $entry['post_type'] || empty($filetype['ext']) )			$this->internal_error(__('Error ocurred while accessing post metadata for file location.'));		status_header('200');		header('Content-Type: ' . $entry['post_mime_type']);		header('Connection: close');		if ( $fp = fopen($location, "rb") ) {			status_header('200');			header('Content-Type: ' . $entry['post_mime_type']);			header('Connection: close');			while ( !feof($fp) ) {				echo fread($fp, 4096);			}			fclose($fp);		} else {			status_header ('404');		}		log_app('function',"get_file($postID)");		exit;	}	/**	 * Upload file to blog and add attachment to post.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 */	function put_file($postID) {		// first check if user can upload		if ( !current_user_can('upload_files') )			$this->auth_required(__('You do not have permission to upload files.'));		// check for not found		global $entry;		$this->set_current_entry($postID);		// then whether user can edit the specific post		if ( !current_user_can('edit_post', $postID) )			$this->auth_required(__('Sorry, you do not have the right to edit this post.'));		$upload_dir = wp_upload_dir( );		$location = get_post_meta($entry['ID'], '_wp_attached_file', true);		$filetype = wp_check_filetype($location);		$location = "{$upload_dir['basedir']}/{$location}";		if (!isset($location) || 'attachment' != $entry['post_type'] || empty($filetype['ext']))			$this->internal_error(__('Error ocurred while accessing post metadata for file location.'));		$fp = fopen("php://input", "rb");		$localfp = fopen($location, "w+");		while ( !feof($fp) ) {			fwrite($localfp,fread($fp, 4096));		}		fclose($fp);		fclose($localfp);		$ID = $entry['ID'];		$pubtimes = $this->get_publish_time($entry->published);		$post_date = $pubtimes[0];		$post_date_gmt = $pubtimes[1];		$pubtimes = $this->get_publish_time($parsed->updated);		$post_modified = $pubtimes[0];		$post_modified_gmt = $pubtimes[1];		$post_data = compact('ID', 'post_date', 'post_date_gmt', 'post_modified', 'post_modified_gmt');		$result = wp_update_post($post_data);		if ( !$result )			$this->internal_error(__('Sorry, your entry could not be posted. Something wrong happened.'));		wp_update_attachment_metadata( $postID, wp_generate_attachment_metadata( $postID, $location ) );		log_app('function',"put_file($postID)");		$this->ok();	}	/**	 * Retrieve entries URL.	 *	 * @since 2.2.0	 *	 * @param int $page Page ID.	 * @return string	 */	function get_entries_url($page = null) {		if ( isset($GLOBALS['post_type']) && ( $GLOBALS['post_type'] == 'attachment' ) )			$path = $this->MEDIA_PATH;		else			$path = $this->ENTRIES_PATH;		$url = $this->app_base . $path;		if ( isset($page) && is_int($page) )			$url .= "/$page";		return $url;	}	/**	 * Display entries URL.	 *	 * @since 2.2.0	 *	 * @param int $page Page ID.	 */	function the_entries_url($page = null) {		echo $this->get_entries_url($page);	}	/**	 * Retrieve categories URL.	 *	 * @since 2.2.0	 *	 * @param mixed $deprecated Not used.	 * @return string	 */	function get_categories_url($deprecated = '') {		if ( !empty( $deprecated ) )			_deprecated_argument( __FUNCTION__, '2.5' );		return $this->app_base . $this->CATEGORIES_PATH;	}	/**	 * Display category URL.	 *	 * @since 2.2.0	 */	function the_categories_url() {		echo $this->get_categories_url();	}	/**	 * Retrieve attachment URL.	 *	 * @since 2.2.0	 *	 * @param int $page Page ID.	 * @return string	 */	function get_attachments_url($page = null) {		$url = $this->app_base . $this->MEDIA_PATH;		if (isset($page) && is_int($page)) {			$url .= "/$page";		}		return $url;	}	/**	 * Display attachment URL.	 *	 * @since 2.2.0	 *	 * @param int $page Page ID.	 */	function the_attachments_url($page = null) {		echo $this->get_attachments_url($page);	}	/**	 * Retrieve service URL.	 *	 * @since 2.3.0	 *	 * @return string	 */	function get_service_url() {		return $this->app_base . $this->SERVICE_PATH;	}	/**	 * Retrieve entry URL.	 *	 * @since 2.7.0	 *	 * @param int $postID Post ID.	 * @return string	 */	function get_entry_url($postID = null) {		if (!isset($postID)) {			global $post;			$postID = (int) $post->ID;		}		$url = $this->app_base . $this->ENTRY_PATH . "/$postID";		log_app('function',"get_entry_url() = $url");		return $url;	}	/**	 * Display entry URL.	 *	 * @since 2.7.0	 *	 * @param int $postID Post ID.	 */	function the_entry_url($postID = null) {		echo $this->get_entry_url($postID);	}	/**	 * Retrieve media URL.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 * @return string	 */	function get_media_url($postID = null) {		if (!isset($postID)) {			global $post;			$postID = (int) $post->ID;		}		$url = $this->app_base . $this->MEDIA_SINGLE_PATH ."/file/$postID";		log_app('function',"get_media_url() = $url");		return $url;	}	/**	 * Display the media URL.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 */	function the_media_url($postID = null) {		echo $this->get_media_url($postID);	}	/**	 * Set the current entry to post ID.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 */	function set_current_entry($postID) {		global $entry;		log_app('function',"set_current_entry($postID)");		if (!isset($postID)) {			// $this->bad_request();			$this->not_found();		}		$entry = wp_get_single_post($postID,ARRAY_A);		if (!isset($entry) || !isset($entry['ID']))			$this->not_found();		return;	}	/**	 * Display posts XML.	 *	 * @since 2.2.0	 *	 * @param int $page Optional. Page ID.	 * @param string $post_type Optional, default is 'post'. Post Type.	 */	function get_posts($page = 1, $post_type = 'post') {			log_app('function',"get_posts($page, '$post_type')");			$feed = $this->get_feed($page, $post_type);			$this->output($feed);	}	/**	 * Display attachment XML.	 *	 * @since 2.2.0	 *	 * @param int $page Page ID.	 * @param string $post_type Optional, default is 'attachment'. Post type.	 */	function get_attachments($page = 1, $post_type = 'attachment') {		log_app('function',"get_attachments($page, '$post_type')");		$GLOBALS['post_type'] = $post_type;		$feed = $this->get_feed($page, $post_type);		$this->output($feed);	}	/**	 * Retrieve feed XML.	 *	 * @since 2.2.0	 *	 * @param int $page Page ID.	 * @param string $post_type Optional, default is post. Post type.	 * @return string	 */	function get_feed($page = 1, $post_type = 'post') {		global $post, $wp, $wp_query, $posts, $wpdb, $blog_id;		log_app('function',"get_feed($page, '$post_type')");		ob_start();		$this->ENTRY_PATH = $post_type;		if (!isset($page)) {			$page = 1;		}		$page = (int) $page;		$count = get_option('posts_per_rss');		wp('posts_per_page=' . $count . '&offset=' . ($count * ($page-1) . '&orderby=modified'));		$post = $GLOBALS['post'];		$posts = $GLOBALS['posts'];		$wp = $GLOBALS['wp'];		$wp_query = $GLOBALS['wp_query'];		$wpdb = $GLOBALS['wpdb'];		$blog_id = (int) $GLOBALS['blog_id'];		log_app('function',"query_posts(# " . print_r($wp_query, true) . "#)");		log_app('function',"total_count(# $wp_query->max_num_pages #)");		$last_page = $wp_query->max_num_pages;		$next_page = (($page + 1) > $last_page) ? NULL : $page + 1;		$prev_page = ($page - 1) < 1 ? NULL : $page - 1;		$last_page = ((int)$last_page == 1 || (int)$last_page == 0) ? NULL : (int) $last_page;		$self_page = $page > 1 ? $page : NULL;?><feed xmlns="<?php echo $this->ATOM_NS ?>" xmlns:app="<?php echo $this->ATOMPUB_NS ?>" xml:lang="<?php echo get_option('rss_language'); ?>" <?php do_action('app_ns'); ?> ><id><?php $this->the_entries_url() ?></id><updated><?php echo mysql2date('Y-m-d\TH:i:s\Z', get_lastpostmodified('GMT'), false); ?></updated><title type="text"><?php bloginfo_rss('name') ?></title><subtitle type="text"><?php bloginfo_rss("description") ?></subtitle><link rel="first" type="<?php echo $this->ATOM_CONTENT_TYPE ?>" href="<?php $this->the_entries_url() ?>" /><?php if (isset($prev_page)): ?><link rel="previous" type="<?php echo $this->ATOM_CONTENT_TYPE ?>" href="<?php $this->the_entries_url($prev_page) ?>" /><?php endif; ?><?php if (isset($next_page)): ?><link rel="next" type="<?php echo $this->ATOM_CONTENT_TYPE ?>" href="<?php $this->the_entries_url($next_page) ?>" /><?php endif; ?><link rel="last" type="<?php echo $this->ATOM_CONTENT_TYPE ?>" href="<?php $this->the_entries_url($last_page) ?>" /><link rel="self" type="<?php echo $this->ATOM_CONTENT_TYPE ?>" href="<?php $this->the_entries_url($self_page) ?>" /><rights type="text">Copyright <?php echo date('Y'); ?></rights><?php do_action('app_head'); ?><?php if ( have_posts() ) {			while ( have_posts() ) {				the_post();				$this->echo_entry();			}		}?></feed><?php		$feed = ob_get_contents();		ob_end_clean();		return $feed;	}	/**	 * Display entry XML.	 *	 * @since 2.2.0	 *	 * @param int $postID Post ID.	 * @param string $post_type Optional, default is post. Post type.	 * @return string.	 */	function get_entry($postID, $post_type = 'post') {		log_app('function',"get_entry($postID, '$post_type')");		ob_start();		switch($post_type) {			case 'post':				$varname = 'p';				break;			case 'attachment':				$this->ENTRY_PATH = 'attachment';				$varname = 'attachment_id';				break;		}		query_posts($varname . '=' . $postID);		if ( have_posts() ) {			while ( have_posts() ) {				the_post();				$this->echo_entry();				log_app('$post',print_r($GLOBALS['post'],true));				$entry = ob_get_contents();				break;			}		}		ob_end_clean();		log_app('get_entry returning:',$entry);		return $entry;	}	/**	 * Display post content XML.	 *	 * @since 2.3.0	 */	function echo_entry() { ?><entry xmlns="<?php echo $this->ATOM_NS ?>"       xmlns:app="<?php echo $this->ATOMPUB_NS ?>" xml:lang="<?php echo get_option('rss_language'); ?>">	<id><?php the_guid( $GLOBALS['post']->ID ); ?></id><?php list($content_type, $content) = prep_atom_text_construct(get_the_title()); ?>	<title type="<?php echo $content_type ?>"><?php echo $content ?></title>	<updated><?php echo get_post_modified_time('Y-m-d\TH:i:s\Z', true); ?></updated>	<published><?php echo get_post_time('Y-m-d\TH:i:s\Z', true); ?></published>	<app:edited><?php echo get_post_modified_time('Y-m-d\TH:i:s\Z', true); ?></app:edited>	<app:control>		<app:draft><?php echo ($GLOBALS['post']->post_status == 'draft' ? 'yes' : 'no') ?></app:draft>	</app:control>	<author>		<name><?php the_author()?></name><?php if ( get_the_author_meta('url') && get_the_author_meta('url') != 'http://' ) { ?>		<uri><?php the_author_meta('url') ?></uri><?php } ?>	</author><?php if ($GLOBALS['post']->post_type == 'attachment') { ?>	<link rel="edit-media" href="<?php $this->the_media_url() ?>" />	<content type="<?php echo $GLOBALS['post']->post_mime_type ?>" src="<?php the_guid() ; ?>"/><?php } else { ?>	<link href="<?php the_permalink_rss() ?>" /><?php if ( strlen( $GLOBALS['post']->post_content ) ) :list($content_type, $content) = prep_atom_text_construct(get_the_content()); ?>	<content type="<?php echo $content_type ?>"><?php echo $content ?></content><?php endif; ?><?php } ?>	<link rel="edit" href="<?php $this->the_entry_url() ?>" />	<?php the_category_rss( 'atom' ); ?><?php list($content_type, $content) = prep_atom_text_construct(get_the_excerpt()); ?>	<summary type="<?php echo $content_type ?>"><?php echo $content ?></summary>	<?php do_action('app_entry'); ?></entry><?php }	/**	 * Set 'OK' (200) status header.	 *	 * @since 2.2.0	 */	function ok() {		log_app('Status','200: OK');		header('Content-Type: text/plain');		status_header('200');		exit;	}	/**	 * Set 'No Content' (204) status header.	 *	 * @since 2.2.0	 */	function no_content() {		log_app('Status','204: No Content');		header('Content-Type: text/plain');		status_header('204');		echo "Moved to Trash.";		exit;	}	/**	 * Display 'Internal Server Error' (500) status header.	 *	 * @since 2.2.0	 *	 * @param string $msg Optional. Status string.	 */	function internal_error($msg = 'Internal Server Error') {		log_app('Status','500: Server Error');		header('Content-Type: text/plain');		status_header('500');		echo $msg;		exit;	}	/**	 * Set 'Bad Request' (400) status header.	 *	 * @since 2.2.0	 */	function bad_request() {		log_app('Status','400: Bad Request');		header('Content-Type: text/plain');		status_header('400');		exit;	}	/**	 * Set 'Length Required' (411) status header.	 *	 * @since 2.2.0	 */	function length_required() {		log_app('Status','411: Length Required');		header("HTTP/1.1 411 Length Required");		header('Content-Type: text/plain');		status_header('411');		exit;	}	/**	 * Set 'Unsupported Media Type' (415) status header.	 *	 * @since 2.2.0	 */	function invalid_media() {		log_app('Status','415: Unsupported Media Type');		header("HTTP/1.1 415 Unsupported Media Type");		header('Content-Type: text/plain');		exit;	}	/**	 * Set 'Forbidden' (403) status header.	 *	 * @since 2.6.0	 */	function forbidden($reason='') {		log_app('Status','403: Forbidden');		header('Content-Type: text/plain');		status_header('403');		echo $reason;		exit;	}	/**	 * Set 'Not Found' (404) status header.	 *	 * @since 2.2.0	 */	function not_found() {		log_app('Status','404: Not Found');		header('Content-Type: text/plain');		status_header('404');		exit;	}	/**	 * Set 'Not Allowed' (405) status header.	 *	 * @since 2.2.0	 */	function not_allowed($allow) {		log_app('Status','405: Not Allowed');		header('Allow: ' . join(',', $allow));		status_header('405');		exit;	}	/**	 * Display Redirect (302) content and set status headers.	 *	 * @since 2.3.0	 */	function redirect($url) {		log_app('Status','302: Redirect');		$escaped_url = esc_attr($url);		$content = <<<EOD<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"><html>  <head>    <title>302 Found</title>  </head><body>  <h1>Found</h1>  <p>The document has moved <a href="$escaped_url">here</a>.</p>  </body></html>EOD;		header('HTTP/1.1 302 Moved');		header('Content-Type: text/html');		header('Location: ' . $url);		echo $content;		exit;	}	/**	 * Set 'Client Error' (400) status header.	 *	 * @since 2.2.0	 */	function client_error($msg = 'Client Error') {		log_app('Status','400: Client Error');		header('Content-Type: text/plain');		status_header('400');		exit;	}	/**	 * Set created status headers (201).	 *	 * Sets the 'content-type', 'content-location', and 'location'.	 *	 * @since 2.2.0	 */	function created($post_ID, $content, $post_type = 'post') {		log_app('created()::$post_ID',"$post_ID, $post_type");		$edit = $this->get_entry_url($post_ID);		switch($post_type) {			case 'post':				$ctloc = $this->get_entry_url($post_ID);				break;			case 'attachment':				$edit = $this->app_base . "attachments/$post_ID";				break;		}		header("Content-Type: $this->ATOM_CONTENT_TYPE");		if (isset($ctloc))			header('Content-Location: ' . $ctloc);		header('Location: ' . $edit);		status_header('201');		echo $content;		exit;	}	/**	 * Set 'Auth Required' (401) headers.	 *	 * @since 2.2.0	 *	 * @param string $msg Status header content and HTML content.	 */	function auth_required($msg) {		log_app('Status','401: Auth Required');		nocache_headers();		header('WWW-Authenticate: Basic realm="WordPress Atom Protocol"');		header("HTTP/1.1 401 $msg");		header('Status: 401 ' . $msg);		header('Content-Type: text/html');		$content = <<<EOD<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"><html>  <head>    <title>401 Unauthorized</title>  </head><body>    <h1>401 Unauthorized</h1>    <p>$msg</p>  </body></html>EOD;		echo $content;		exit;	}	/**	 * Display XML and set headers with content type.	 *	 * @since 2.2.0	 *	 * @param string $xml Display feed content.	 * @param string $ctype Optional, default is 'atom+xml'. Feed content type.	 */	function output($xml, $ctype = 'application/atom+xml') {			status_header('200');			$xml = '<?xml version="1.0" encoding="' . strtolower(get_option('blog_charset')) . '"?>'."\n".$xml;			header('Connection: close');			header('Content-Length: '. strlen($xml));			header('Content-Type: ' . $ctype);			header('Content-Disposition: attachment; filename=atom.xml');			header('Date: '. date('r'));			if ($this->do_output)				echo $xml;			log_app('function', "output:\n$xml");			exit;	}	/**	 * Sanitize content for database usage.	 *	 * @since 2.2.0	 *	 * @param array $array Sanitize array and multi-dimension array.	 */	function escape(&$array) {		global $wpdb;		foreach ($array as $k => $v) {				if (is_array($v)) {						$this->escape($array[$k]);				} else if (is_object($v)) {						//skip				} else {						$array[$k] = $wpdb->escape($v);				}		}	}	/**	 * Access credential through various methods and perform login.	 *	 * @since 2.2.0	 *	 * @return bool	 */	function authenticate() {		log_app("authenticate()",print_r($_ENV, true));		// if using mod_rewrite/ENV hack		// http://www.besthostratings.com/articles/http-auth-php-cgi.html		if (isset($_SERVER['HTTP_AUTHORIZATION'])) {			list($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']) =				explode(':', base64_decode(substr($_SERVER['HTTP_AUTHORIZATION'], 6)));		} else if (isset($_SERVER['REDIRECT_REMOTE_USER'])) {			// Workaround for setups that do not forward HTTP_AUTHORIZATION			// See http://trac.wordpress.org/ticket/7361			list($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']) =				explode(':', base64_decode(substr($_SERVER['REDIRECT_REMOTE_USER'], 6)));		}		// If Basic Auth is working...		if (isset($_SERVER['PHP_AUTH_USER']) && isset($_SERVER['PHP_AUTH_PW'])) {			log_app("Basic Auth",$_SERVER['PHP_AUTH_USER']);			$user = wp_authenticate($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']);			if ( $user && !is_wp_error($user) ) {				wp_set_current_user($user->ID);				log_app("authenticate()", $user->user_login);				return true;			}		}		return false;	}	/**	 * Retrieve accepted content types.	 *	 * @since 2.2.0	 *	 * @param array $types Optional. Content Types.	 * @return string	 */	function get_accepted_content_type($types = null) {		if (!isset($types)) {			$types = $this->media_content_types;		}		if (!isset($_SERVER['CONTENT_LENGTH']) || !isset($_SERVER['CONTENT_TYPE'])) {			$this->length_required();		}		$type = $_SERVER['CONTENT_TYPE'];		list($type,$subtype) = explode('/',$type);		list($subtype) = explode(";",$subtype); // strip MIME parameters		log_app("get_accepted_content_type", "type=$type, subtype=$subtype");		foreach($types as $t) {			list($acceptedType,$acceptedSubtype) = explode('/',$t);			if ($acceptedType == '*' || $acceptedType == $type) {				if ($acceptedSubtype == '*' || $acceptedSubtype == $subtype)					return $type . "/" . $subtype;			}		}		$this->invalid_media();	}	/**	 * Process conditionals for posts.	 *	 * @since 2.2.0	 */	function process_conditionals() {		if (empty($this->params)) return;		if ($_SERVER['REQUEST_METHOD'] == 'DELETE') return;		switch($this->params[0]) {			case $this->ENTRY_PATH:				global $post;				$post = wp_get_single_post($this->params[1]);				$wp_last_modified = get_post_modified_time('D, d M Y H:i:s', true);				$post = NULL;				break;			case $this->ENTRIES_PATH:				$wp_last_modified = mysql2date('D, d M Y H:i:s', get_lastpostmodified('GMT'), 0).' GMT';				break;			default:				return;		}		$wp_etag = md5($wp_last_modified);		@header("Last-Modified: $wp_last_modified");		@header("ETag: $wp_etag");		// Support for Conditional GET		if (isset($_SERVER['HTTP_IF_NONE_MATCH']))			$client_etag = stripslashes($_SERVER['HTTP_IF_NONE_MATCH']);		else			$client_etag = false;		$client_last_modified = trim( $_SERVER['HTTP_IF_MODIFIED_SINCE']);		// If string is empty, return 0. If not, attempt to parse into a timestamp		$client_modified_timestamp = $client_last_modified ? strtotime($client_last_modified) : 0;		// Make a timestamp for our most recent modification...		$wp_modified_timestamp = strtotime($wp_last_modified);		if ( ($client_last_modified && $client_etag) ?		(($client_modified_timestamp >= $wp_modified_timestamp) && ($client_etag == $wp_etag)) :		(($client_modified_timestamp >= $wp_modified_timestamp) || ($client_etag == $wp_etag)) ) {			status_header( 304 );			exit;		}	}	/**	 * Convert RFC3339 time string to timestamp.	 *	 * @since 2.3.0	 *	 * @param string $str String to time.	 * @return bool|int false if format is incorrect.	 */	function rfc3339_str2time($str) {		$match = false;		if (!preg_match("/(\d{4}-\d{2}-\d{2})T(\d{2}\:\d{2}\:\d{2})\.?\d{0,3}(Z|[+-]+\d{2}\:\d{2})/", $str, $match))			return false;		if ($match[3] == 'Z')			$match[3] = '+0000';		return strtotime($match[1] . " " . $match[2] . " " . $match[3]);	}	/**	 * Retrieve published time to display in XML.	 *	 * @since 2.3.0	 *	 * @param string $published Time string.	 * @return string	 */	function get_publish_time($published) {		$pubtime = $this->rfc3339_str2time($published);		if (!$pubtime) {			return array(current_time('mysql'),current_time('mysql',1));		} else {			return array(date("Y-m-d H:i:s", $pubtime), gmdate("Y-m-d H:i:s", $pubtime));		}	}}/** * AtomServer * @var AtomServer * @global object $server */$server = new AtomServer();$server->handle_request();?>
<?php// -- Post related Meta Boxes/** * Display post submit form fields. * * @since 2.7.0 * * @param object $post */function post_submit_meta_box($post) {	global $action;	$post_type = $post->post_type;	$post_type_object = get_post_type_object($post_type);	$can_publish = current_user_can($post_type_object->cap->publish_posts);?><div class="submitbox" id="submitpost"><div id="minor-publishing"><?php // Hidden submit button early on so that the browser chooses the right button when form is submitted with Return key ?><div style="display:none;"><input type="submit" name="save" value="<?php esc_attr_e('Save'); ?>" /></div><div id="minor-publishing-actions"><div id="save-action"><?php if ( 'publish' != $post->post_status && 'future' != $post->post_status && 'pending' != $post->post_status )  { ?><input <?php if ( 'private' == $post->post_status ) { ?>style="display:none"<?php } ?> type="submit" name="save" id="save-post" value="<?php esc_attr_e('Save Draft'); ?>" tabindex="4" class="button button-highlighted" /><?php } elseif ( 'pending' == $post->post_status && $can_publish ) { ?><input type="submit" name="save" id="save-post" value="<?php esc_attr_e('Save as Pending'); ?>" tabindex="4" class="button button-highlighted" /><?php } ?></div><div id="preview-action"><?phpif ( 'publish' == $post->post_status ) {	$preview_link = esc_url(get_permalink($post->ID));	$preview_button = __('Preview Changes');} else {	$preview_link = esc_url(apply_filters('preview_post_link', add_query_arg('preview', 'true', get_permalink($post->ID))));	$preview_button = __('Preview');}?><a class="preview button" href="<?php echo $preview_link; ?>" target="wp-preview" id="post-preview" tabindex="4"><?php echo $preview_button; ?></a><input type="hidden" name="wp-preview" id="wp-preview" value="" /></div><div class="clear"></div></div><?php // /minor-publishing-actions ?><div id="misc-publishing-actions"><div class="misc-pub-section<?php if ( !$can_publish ) { echo ' misc-pub-section-last'; } ?>"><label for="post_status"><?php _e('Status:') ?></label><span id="post-status-display"><?phpswitch ( $post->post_status ) {	case 'private':		_e('Privately Published');		break;	case 'publish':		_e('Published');		break;	case 'future':		_e('Scheduled');		break;	case 'pending':		_e('Pending Review');		break;	case 'draft':	case 'auto-draft':		_e('Draft');		break;	case 'auto-draft':		_e('Unsaved');		break;}?></span><?php if ( 'publish' == $post->post_status || 'private' == $post->post_status || $can_publish ) { ?><a href="#post_status" <?php if ( 'private' == $post->post_status ) { ?>style="display:none;" <?php } ?>class="edit-post-status hide-if-no-js" tabindex='4'><?php _e('Edit') ?></a><div id="post-status-select" class="hide-if-js"><input type="hidden" name="hidden_post_status" id="hidden_post_status" value="<?php echo esc_attr( ('auto-draft' == $post->post_status ) ? 'draft' : $post->post_status); ?>" /><select name='post_status' id='post_status' tabindex='4'><?php if ( 'publish' == $post->post_status ) : ?><option<?php selected( $post->post_status, 'publish' ); ?> value='publish'><?php _e('Published') ?></option><?php elseif ( 'private' == $post->post_status ) : ?><option<?php selected( $post->post_status, 'private' ); ?> value='publish'><?php _e('Privately Published') ?></option><?php elseif ( 'future' == $post->post_status ) : ?><option<?php selected( $post->post_status, 'future' ); ?> value='future'><?php _e('Scheduled') ?></option><?php endif; ?><option<?php selected( $post->post_status, 'pending' ); ?> value='pending'><?php _e('Pending Review') ?></option><?php if ( 'auto-draft' == $post->post_status ) : ?><option<?php selected( $post->post_status, 'auto-draft' ); ?> value='draft'><?php _e('Draft') ?></option><?php else : ?><option<?php selected( $post->post_status, 'draft' ); ?> value='draft'><?php _e('Draft') ?></option><?php endif; ?></select> <a href="#post_status" class="save-post-status hide-if-no-js button"><?php _e('OK'); ?></a> <a href="#post_status" class="cancel-post-status hide-if-no-js"><?php _e('Cancel'); ?></a></div><?php } ?></div><?php // /misc-pub-section ?><div class="misc-pub-section " id="visibility"><?php _e('Visibility:'); ?> <span id="post-visibility-display"><?phpif ( 'private' == $post->post_status ) {	$post->post_password = '';	$visibility = 'private';	$visibility_trans = __('Private');} elseif ( !empty( $post->post_password ) ) {	$visibility = 'password';	$visibility_trans = __('Password protected');} elseif ( $post_type == 'post' && is_sticky( $post->ID ) ) {	$visibility = 'public';	$visibility_trans = __('Public, Sticky');} else {	$visibility = 'public';	$visibility_trans = __('Public');}echo esc_html( $visibility_trans ); ?></span><?php if ( $can_publish ) { ?><a href="#visibility" class="edit-visibility hide-if-no-js"><?php _e('Edit'); ?></a><div id="post-visibility-select" class="hide-if-js"><input type="hidden" name="hidden_post_password" id="hidden-post-password" value="<?php echo esc_attr($post->post_password); ?>" /><?php if ($post_type == 'post'): ?><input type="checkbox" style="display:none" name="hidden_post_sticky" id="hidden-post-sticky" value="sticky" <?php checked(is_sticky($post->ID)); ?> /><?php endif; ?><input type="hidden" name="hidden_post_visibility" id="hidden-post-visibility" value="<?php echo esc_attr( $visibility ); ?>" /><input type="radio" name="visibility" id="visibility-radio-public" value="public" <?php checked( $visibility, 'public' ); ?> /> <label for="visibility-radio-public" class="selectit"><?php _e('Public'); ?></label><br /><?php if ($post_type == 'post'): ?><span id="sticky-span"><input id="sticky" name="sticky" type="checkbox" value="sticky" <?php checked(is_sticky($post->ID)); ?> tabindex="4" /> <label for="sticky" class="selectit"><?php _e('Stick this post to the front page') ?></label><br /></span><?php endif; ?><input type="radio" name="visibility" id="visibility-radio-password" value="password" <?php checked( $visibility, 'password' ); ?> /> <label for="visibility-radio-password" class="selectit"><?php _e('Password protected'); ?></label><br /><span id="password-span"><label for="post_password"><?php _e('Password:'); ?></label> <input type="text" name="post_password" id="post_password" value="<?php echo esc_attr($post->post_password); ?>" /><br /></span><input type="radio" name="visibility" id="visibility-radio-private" value="private" <?php checked( $visibility, 'private' ); ?> /> <label for="visibility-radio-private" class="selectit"><?php _e('Private'); ?></label><br /><p> <a href="#visibility" class="save-post-visibility hide-if-no-js button"><?php _e('OK'); ?></a> <a href="#visibility" class="cancel-post-visibility hide-if-no-js"><?php _e('Cancel'); ?></a></p></div><?php } ?></div><?php // /misc-pub-section ?><?php// translators: Publish box date formt, see http://php.net/date$datef = __( 'M j, Y @ G:i' );if ( 0 != $post->ID ) {	if ( 'future' == $post->post_status ) { // scheduled for publishing at a future date		$stamp = __('Scheduled for: <b>%1$s</b>');	} else if ( 'publish' == $post->post_status || 'private' == $post->post_status ) { // already published		$stamp = __('Published on: <b>%1$s</b>');	} else if ( '0000-00-00 00:00:00' == $post->post_date_gmt ) { // draft, 1 or more saves, no date specified		$stamp = __('Publish <b>immediately</b>');	} else if ( time() < strtotime( $post->post_date_gmt . ' +0000' ) ) { // draft, 1 or more saves, future date specified		$stamp = __('Schedule for: <b>%1$s</b>');	} else { // draft, 1 or more saves, date specified		$stamp = __('Publish on: <b>%1$s</b>');	}	$date = date_i18n( $datef, strtotime( $post->post_date ) );} else { // draft (no saves, and thus no date specified)	$stamp = __('Publish <b>immediately</b>');	$date = date_i18n( $datef, strtotime( current_time('mysql') ) );}if ( $can_publish ) : // Contributors don't get to choose the date of publish ?><div class="misc-pub-section curtime misc-pub-section-last">	<span id="timestamp">	<?php printf($stamp, $date); ?></span>	<a href="#edit_timestamp" class="edit-timestamp hide-if-no-js" tabindex='4'><?php _e('Edit') ?></a>	<div id="timestampdiv" class="hide-if-js"><?php touch_time(($action == 'edit'),1,4); ?></div></div><?php // /misc-pub-section ?><?php endif; ?><?php do_action('post_submitbox_misc_actions'); ?></div><div class="clear"></div></div><div id="major-publishing-actions"><?php do_action('post_submitbox_start'); ?><div id="delete-action"><?phpif ( current_user_can( "delete_post", $post->ID ) ) {	if ( !EMPTY_TRASH_DAYS )		$delete_text = __('Delete Permanently');	else		$delete_text = __('Move to Trash');	?><a class="submitdelete deletion" href="<?php echo get_delete_post_link($post->ID); ?>"><?php echo $delete_text; ?></a><?php} ?></div><div id="publishing-action"><img src="<?php echo esc_url( admin_url( 'images/wpspin_light.gif' ) ); ?>" id="ajax-loading" style="visibility:hidden;" alt="" /><?phpif ( !in_array( $post->post_status, array('publish', 'future', 'private') ) || 0 == $post->ID ) {	if ( $can_publish ) :		if ( !empty($post->post_date_gmt) && time() < strtotime( $post->post_date_gmt . ' +0000' ) ) : ?>		<input name="original_publish" type="hidden" id="original_publish" value="<?php esc_attr_e('Schedule') ?>" />		<input name="publish" type="submit" class="button-primary" id="publish" tabindex="5" accesskey="p" value="<?php esc_attr_e('Schedule') ?>" /><?php	else : ?>		<input name="original_publish" type="hidden" id="original_publish" value="<?php esc_attr_e('Publish') ?>" />		<input name="publish" type="submit" class="button-primary" id="publish" tabindex="5" accesskey="p" value="<?php esc_attr_e('Publish') ?>" /><?php	endif;	else : ?>		<input name="original_publish" type="hidden" id="original_publish" value="<?php esc_attr_e('Submit for Review') ?>" />		<input name="publish" type="submit" class="button-primary" id="publish" tabindex="5" accesskey="p" value="<?php esc_attr_e('Submit for Review') ?>" /><?php	endif;} else { ?>		<input name="original_publish" type="hidden" id="original_publish" value="<?php esc_attr_e('Update') ?>" />		<input name="save" type="submit" class="button-primary" id="publish" tabindex="5" accesskey="p" value="<?php esc_attr_e('Update') ?>" /><?php} ?></div><div class="clear"></div></div></div><?php}/** * Display post tags form fields. * * @since 2.6.0 * * @param object $post */function post_tags_meta_box($post, $box) {	$defaults = array('taxonomy' => 'post_tag');	if ( !isset($box['args']) || !is_array($box['args']) )		$args = array();	else		$args = $box['args'];	extract( wp_parse_args($args, $defaults), EXTR_SKIP );	$tax_name = esc_attr($taxonomy);	$taxonomy = get_taxonomy($taxonomy);	$disabled = !current_user_can($taxonomy->cap->assign_terms) ? 'disabled="disabled"' : '';?><div class="tagsdiv" id="<?php echo $tax_name; ?>">	<div class="jaxtag">	<div class="nojs-tags hide-if-js">	<p><?php echo $taxonomy->labels->add_or_remove_items; ?></p>	<textarea name="<?php echo "tax_input[$tax_name]"; ?>" rows="3" cols="20" class="the-tags" id="tax-input-<?php echo $tax_name; ?>" <?php echo $disabled; ?>><?php echo esc_attr(get_terms_to_edit( $post->ID, $tax_name )); ?></textarea></div> 	<?php if ( current_user_can($taxonomy->cap->assign_terms) ) : ?>	<div class="ajaxtag hide-if-no-js">		<label class="screen-reader-text" for="new-tag-<?php echo $tax_name; ?>"><?php echo $box['title']; ?></label>		<div class="taghint"><?php echo $taxonomy->labels->add_new_item; ?></div>		<p><input type="text" id="new-tag-<?php echo $tax_name; ?>" name="newtag[<?php echo $tax_name; ?>]" class="newtag form-input-tip" size="16" autocomplete="off" value="" />		<input type="button" class="button tagadd" value="<?php esc_attr_e('Add'); ?>" tabindex="3" /></p>	</div>	<p class="howto"><?php echo esc_attr( $taxonomy->labels->separate_items_with_commas ); ?></p>	<?php endif; ?>	</div>	<div class="tagchecklist"></div></div><?php if ( current_user_can($taxonomy->cap->assign_terms) ) : ?><p class="hide-if-no-js"><a href="#titlediv" class="tagcloud-link" id="link-<?php echo $tax_name; ?>"><?php echo $taxonomy->labels->choose_from_most_used; ?></a></p><?php else : ?><p><em><?php _e('You cannot modify this taxonomy.'); ?></em></p><?php endif; ?><?php}/** * Display post categories form fields. * * @since 2.6.0 * * @param object $post */function post_categories_meta_box( $post, $box ) {	$defaults = array('taxonomy' => 'category');	if ( !isset($box['args']) || !is_array($box['args']) )		$args = array();	else		$args = $box['args'];	extract( wp_parse_args($args, $defaults), EXTR_SKIP );	$tax = get_taxonomy($taxonomy);	?>	<div id="taxonomy-<?php echo $taxonomy; ?>" class="categorydiv">		<ul id="<?php echo $taxonomy; ?>-tabs" class="category-tabs">			<li class="tabs"><a href="#<?php echo $taxonomy; ?>-all" tabindex="3"><?php echo $tax->labels->all_items; ?></a></li>			<li class="hide-if-no-js"><a href="#<?php echo $taxonomy; ?>-pop" tabindex="3"><?php _e( 'Most Used' ); ?></a></li>		</ul>		<div id="<?php echo $taxonomy; ?>-pop" class="tabs-panel" style="display: none;">			<ul id="<?php echo $taxonomy; ?>checklist-pop" class="categorychecklist form-no-clear" >				<?php $popular_ids = wp_popular_terms_checklist($taxonomy); ?>			</ul>		</div>		<div id="<?php echo $taxonomy; ?>-all" class="tabs-panel">			<?php            $name = ( $taxonomy == 'category' ) ? 'post_category' : 'tax_input[' . $taxonomy . ']';            echo "<input type='hidden' name='{$name}[]' value='0' />"; // Allows for an empty term set to be sent. 0 is an invalid Term ID and will be ignored by empty() checks.            ?>			<ul id="<?php echo $taxonomy; ?>checklist" class="list:<?php echo $taxonomy?> categorychecklist form-no-clear">				<?php wp_terms_checklist($post->ID, array( 'taxonomy' => $taxonomy, 'popular_cats' => $popular_ids ) ) ?>			</ul>		</div>	<?php if ( !current_user_can($tax->cap->assign_terms) ) : ?>	<p><em><?php _e('You cannot modify this taxonomy.'); ?></em></p>	<?php endif; ?>	<?php if ( current_user_can($tax->cap->edit_terms) ) : ?>			<div id="<?php echo $taxonomy; ?>-adder" class="wp-hidden-children">				<h4>					<a id="<?php echo $taxonomy; ?>-add-toggle" href="#<?php echo $taxonomy; ?>-add" class="hide-if-no-js" tabindex="3">						<?php							/* translators: %s: add new taxonomy label */							printf( __( '+ %s' ), $tax->labels->add_new_item );						?>					</a>				</h4>				<p id="<?php echo $taxonomy; ?>-add" class="category-add wp-hidden-child">					<label class="screen-reader-text" for="new<?php echo $taxonomy; ?>"><?php echo $tax->labels->add_new_item; ?></label>					<input type="text" name="new<?php echo $taxonomy; ?>" id="new<?php echo $taxonomy; ?>" class="form-required form-input-tip" value="<?php echo esc_attr( $tax->labels->new_item_name ); ?>" tabindex="3" aria-required="true"/>					<label class="screen-reader-text" for="new<?php echo $taxonomy; ?>_parent">						<?php echo $tax->labels->parent_item_colon; ?>					</label>					<?php wp_dropdown_categories( array( 'taxonomy' => $taxonomy, 'hide_empty' => 0, 'name' => 'new'.$taxonomy.'_parent', 'orderby' => 'name', 'hierarchical' => 1, 'show_option_none' => '&mdash; ' . $tax->labels->parent_item . ' &mdash;', 'tab_index' => 3 ) ); ?>					<input type="button" id="<?php echo $taxonomy; ?>-add-submit" class="add:<?php echo $taxonomy ?>checklist:<?php echo $taxonomy ?>-add button category-add-sumbit" value="<?php echo esc_attr( $tax->labels->add_new_item ); ?>" tabindex="3" />					<?php wp_nonce_field( 'add-'.$taxonomy, '_ajax_nonce-add-'.$taxonomy, false ); ?>					<span id="<?php echo $taxonomy; ?>-ajax-response"></span>				</p>			</div>		<?php endif; ?>	</div>	<?php}/** * Display post excerpt form fields. * * @since 2.6.0 * * @param object $post */function post_excerpt_meta_box($post) {?><label class="screen-reader-text" for="excerpt"><?php _e('Excerpt') ?></label><textarea rows="1" cols="40" name="excerpt" tabindex="6" id="excerpt"><?php echo $post->post_excerpt ?></textarea><p><?php _e('Excerpts are optional hand-crafted summaries of your content that can be used in your theme. <a href="http://codex.wordpress.org/Excerpt" target="_blank">Learn more about manual excerpts.</a>'); ?></p><?php}/** * Display trackback links form fields. * * @since 2.6.0 * * @param object $post */function post_trackback_meta_box($post) {	$form_trackback = '<input type="text" name="trackback_url" id="trackback_url" class="code" tabindex="7" value="'. esc_attr( str_replace("\n", ' ', $post->to_ping) ) .'" />';	if ('' != $post->pinged) {		$pings = '<p>'. __('Already pinged:') . '</p><ul>';		$already_pinged = explode("\n", trim($post->pinged));		foreach ($already_pinged as $pinged_url) {			$pings .= "\n\t<li>" . esc_html($pinged_url) . "</li>";		}		$pings .= '</ul>';	}?><p><label for="trackback_url"><?php _e('Send trackbacks to:'); ?></label> <?php echo $form_trackback; ?><br /> (<?php _e('Separate multiple URLs with spaces'); ?>)</p><p><?php _e('Trackbacks are a way to notify legacy blog systems that you&#8217;ve linked to them. If you link other WordPress sites they&#8217;ll be notified automatically using <a href="http://codex.wordpress.org/Introduction_to_Blogging#Managing_Comments" target="_blank">pingbacks</a>, no other action necessary.'); ?></p><?phpif ( ! empty($pings) )	echo $pings;}/** * Display custom fields form fields. * * @since 2.6.0 * * @param object $post */function post_custom_meta_box($post) {?><div id="postcustomstuff"><div id="ajax-response"></div><?php$metadata = has_meta($post->ID);list_meta($metadata);meta_form(); ?></div><p><?php _e('Custom fields can be used to add extra metadata to a post that you can <a href="http://codex.wordpress.org/Using_Custom_Fields" target="_blank">use in your theme</a>.'); ?></p><?php}/** * Display comments status form fields. * * @since 2.6.0 * * @param object $post */function post_comment_status_meta_box($post) {?><input name="advanced_view" type="hidden" value="1" /><p class="meta-options">	<label for="comment_status" class="selectit"><input name="comment_status" type="checkbox" id="comment_status" value="open" <?php checked($post->comment_status, 'open'); ?> /> <?php _e( 'Allow comments.' ) ?></label><br />	<label for="ping_status" class="selectit"><input name="ping_status" type="checkbox" id="ping_status" value="open" <?php checked($post->ping_status, 'open'); ?> /> <?php printf( __( 'Allow <a href="%s" target="_blank">trackbacks and pingbacks</a> on this page.' ), __( 'http://codex.wordpress.org/Introduction_to_Blogging#Managing_Comments' ) ); ?></label></p><?php}/** * Display comments for post table header * * @since 3.0.0 * * @param $result table header rows * @return */function post_comment_meta_box_thead($result) {	unset($result['cb'], $result['response']);	return $result;}/** * Display comments for post. * * @since 2.8.0 * * @param object $post */function post_comment_meta_box($post) {	global $wpdb, $post_ID;	$total = $wpdb->get_var($wpdb->prepare("SELECT count(1) FROM $wpdb->comments WHERE comment_post_ID = '%d' AND ( comment_approved = '0' OR comment_approved = '1')", $post_ID));	if ( 1 > $total ) {		echo '<p>' . __('No comments yet.') . '</p>';		return;	}	wp_nonce_field( 'get-comments', 'add_comment_nonce', false );	add_filter('manage_edit-comments_columns', 'post_comment_meta_box_thead', 8, 1);?><table class="widefat comments-box fixed" cellspacing="0" style="display:none;"><thead><tr>	<?php print_column_headers('edit-comments'); ?></tr></thead><tbody id="the-comment-list" class="list:comment"></tbody></table><p class="hide-if-no-js"><a href="#commentstatusdiv" id="show-comments" onclick="commentsBox.get(<?php echo $total; ?>);return false;"><?php _e('Show comments'); ?></a> <img class="waiting" style="display:none;" src="<?php echo esc_url( admin_url( 'images/wpspin_light.gif' ) ); ?>" alt="" /></p><?php	$hidden = get_hidden_meta_boxes('post');	if ( ! in_array('commentsdiv', $hidden) ) { ?>		<script type="text/javascript">jQuery(document).ready(function(){commentsBox.get(<?php echo $total; ?>, 10);});</script><?php	}	remove_filter('manage_edit-comments_columns', 'post_comment_meta_box_thead');	wp_comment_trashnotice();}/** * Display slug form fields. * * @since 2.6.0 * * @param object $post */function post_slug_meta_box($post) {?><label class="screen-reader-text" for="post_name"><?php _e('Slug') ?></label><input name="post_name" type="text" size="13" id="post_name" value="<?php echo esc_attr( $post->post_name ); ?>" /><?php}/** * Display form field with list of authors. * * @since 2.6.0 * * @param object $post */function post_author_meta_box($post) {	global $current_user, $user_ID;	$authors = get_editable_user_ids( $current_user->id, true, $post->post_type ); // TODO: ROLE SYSTEM	if ( $post->post_author && !in_array($post->post_author, $authors) )		$authors[] = $post->post_author;?><label class="screen-reader-text" for="post_author_override"><?php _e('Author'); ?></label><?php wp_dropdown_users( array('include' => $authors, 'name' => 'post_author_override', 'selected' => empty($post->ID) ? $user_ID : $post->post_author) ); ?><?php}/** * Display list of revisions. * * @since 2.6.0 * * @param object $post */function post_revisions_meta_box($post) {	wp_list_post_revisions();}// -- Page related Meta Boxes/** * Display page attributes form fields. * * @since 2.7.0 * * @param object $post */function page_attributes_meta_box($post) {	$post_type_object = get_post_type_object($post->post_type);	if ( $post_type_object->hierarchical ) {		$pages = wp_dropdown_pages(array('post_type' => $post->post_type, 'exclude_tree' => $post->ID, 'selected' => $post->post_parent, 'name' => 'parent_id', 'show_option_none' => __('(no parent)'), 'sort_column'=> 'menu_order, post_title', 'echo' => 0));		if ( ! empty($pages) ) {?><p><strong><?php _e('Parent') ?></strong></p><label class="screen-reader-text" for="parent_id"><?php _e('Parent') ?></label><?php echo $pages; ?><?php		} // end empty pages check	} // end hierarchical check.	if ( 'page' == $post->post_type && 0 != count( get_page_templates() ) ) {		$template = !empty($post->page_template) ? $post->page_template : false;		?><p><strong><?php _e('Template') ?></strong></p><label class="screen-reader-text" for="page_template"><?php _e('Page Template') ?></label><select name="page_template" id="page_template"><option value='default'><?php _e('Default Template'); ?></option><?php page_template_dropdown($template); ?></select><?php	} ?><p><strong><?php _e('Order') ?></strong></p><p><label class="screen-reader-text" for="menu_order"><?php _e('Order') ?></label><input name="menu_order" type="text" size="4" id="menu_order" value="<?php echo esc_attr($post->menu_order) ?>" /></p><p><?php if ( 'page' == $post->post_type ) _e( 'Need help? Use the Help tab in the upper right of your screen.' ); ?></p><?php}// -- Link related Meta Boxes/** * Display link create form fields. * * @since 2.7.0 * * @param object $link */function link_submit_meta_box($link) {?><div class="submitbox" id="submitlink"><div id="minor-publishing"><?php // Hidden submit button early on so that the browser chooses the right button when form is submitted with Return key ?><div style="display:none;"><input type="submit" name="save" value="<?php esc_attr_e('Save'); ?>" /></div><div id="minor-publishing-actions"><div id="preview-action"><?php if ( !empty($link->link_id) ) { ?>	<a class="preview button" href="<?php echo $link->link_url; ?>" target="_blank" tabindex="4"><?php _e('Visit Link'); ?></a><?php } ?></div><div class="clear"></div></div><div id="misc-publishing-actions"><div class="misc-pub-section misc-pub-section-last">	<label for="link_private" class="selectit"><input id="link_private" name="link_visible" type="checkbox" value="N" <?php checked($link->link_visible, 'N'); ?> /> <?php _e('Keep this link private') ?></label></div></div></div><div id="major-publishing-actions"><?php do_action('post_submitbox_start'); ?><div id="delete-action"><?phpif ( !empty($_GET['action']) && 'edit' == $_GET['action'] && current_user_can('manage_links') ) { ?>	<a class="submitdelete deletion" href="<?php echo wp_nonce_url("link.php?action=delete&amp;link_id=$link->link_id", 'delete-bookmark_' . $link->link_id); ?>" onclick="if ( confirm('<?php echo esc_js(sprintf(__("You are about to delete this link '%s'\n  'Cancel' to stop, 'OK' to delete."), $link->link_name )); ?>') ) {return true;}return false;"><?php _e('Delete'); ?></a><?php } ?></div><div id="publishing-action"><?php if ( !empty($link->link_id) ) { ?>	<input name="save" type="submit" class="button-primary" id="publish" tabindex="4" accesskey="p" value="<?php esc_attr_e('Update Link') ?>" /><?php } else { ?>	<input name="save" type="submit" class="button-primary" id="publish" tabindex="4" accesskey="p" value="<?php esc_attr_e('Add Link') ?>" /><?php } ?></div><div class="clear"></div></div><?php do_action('submitlink_box'); ?><div class="clear"></div></div><?php}/** * Display link categories form fields. * * @since 2.6.0 * * @param object $link */function link_categories_meta_box($link) { ?><ul id="category-tabs" class="category-tabs">	<li class="tabs"><a href="#categories-all"><?php _e( 'All Categories' ); ?></a></li>	<li class="hide-if-no-js"><a href="#categories-pop"><?php _e( 'Most Used' ); ?></a></li></ul><div id="categories-all" class="tabs-panel">	<ul id="categorychecklist" class="list:category categorychecklist form-no-clear">		<?php		if ( isset($link->link_id) )			wp_link_category_checklist($link->link_id);		else			wp_link_category_checklist();		?>	</ul></div><div id="categories-pop" class="tabs-panel" style="display: none;">	<ul id="categorychecklist-pop" class="categorychecklist form-no-clear">		<?php wp_popular_terms_checklist('link_category'); ?>	</ul></div><div id="category-adder" class="wp-hidden-children">	<h4><a id="category-add-toggle" href="#category-add"><?php _e( '+ Add New Category' ); ?></a></h4>	<p id="link-category-add" class="wp-hidden-child">		<label class="screen-reader-text" for="newcat"><?php _e( '+ Add New Category' ); ?></label>		<input type="text" name="newcat" id="newcat" class="form-required form-input-tip" value="<?php esc_attr_e( 'New category name' ); ?>" aria-required="true" />		<input type="button" id="category-add-submit" class="add:categorychecklist:linkcategorydiv button" value="<?php esc_attr_e( 'Add' ); ?>" />		<?php wp_nonce_field( 'add-link-category', '_ajax_nonce', false ); ?>		<span id="category-ajax-response"></span>	</p></div><?php}/** * Display form fields for changing link target. * * @since 2.6.0 * * @param object $link */function link_target_meta_box($link) { ?><fieldset><legend class="screen-reader-text"><span><?php _e('Target') ?></span></legend><p><label for="link_target_blank" class="selectit"><input id="link_target_blank" type="radio" name="link_target" value="_blank" <?php echo ( isset( $link->link_target ) && ($link->link_target == '_blank') ? 'checked="checked"' : ''); ?> /><?php _e('<code>_blank</code> &mdash; new window or tab.'); ?></label></p><p><label for="link_target_top" class="selectit"><input id="link_target_top" type="radio" name="link_target" value="_top" <?php echo ( isset( $link->link_target ) && ($link->link_target == '_top') ? 'checked="checked"' : ''); ?> /><?php _e('<code>_top</code> &mdash; current window or tab, with no frames.'); ?></label></p><p><label for="link_target_none" class="selectit"><input id="link_target_none" type="radio" name="link_target" value="" <?php echo ( isset( $link->link_target ) && ($link->link_target == '') ? 'checked="checked"' : ''); ?> /><?php _e('<code>_none</code> &mdash; same window or tab.'); ?></label></p></fieldset><p><?php _e('Choose the target frame for your link.'); ?></p><?php}/** * Display checked checkboxes attribute for xfn microformat options. * * @since 1.0.1 * * @param string $class * @param string $value * @param mixed $deprecated Never used. */function xfn_check( $class, $value = '', $deprecated = '' ) {	global $link;	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '0.0' ); // Never implemented	$link_rel = isset( $link->link_rel ) ? $link->link_rel : ''; // In PHP 5.3: $link_rel = $link->link_rel ?: '';	$rels = preg_split('/\s+/', $link_rel);	if ('' != $value && in_array($value, $rels) ) {		echo ' checked="checked"';	}	if ('' == $value) {		if ('family' == $class && strpos($link_rel, 'child') === false && strpos($link_rel, 'parent') === false && strpos($link_rel, 'sibling') === false && strpos($link_rel, 'spouse') === false && strpos($link_rel, 'kin') === false) echo ' checked="checked"';		if ('friendship' == $class && strpos($link_rel, 'friend') === false && strpos($link_rel, 'acquaintance') === false && strpos($link_rel, 'contact') === false) echo ' checked="checked"';		if ('geographical' == $class && strpos($link_rel, 'co-resident') === false && strpos($link_rel, 'neighbor') === false) echo ' checked="checked"';		if ('identity' == $class && in_array('me', $rels) ) echo ' checked="checked"';	}}/** * Display xfn form fields. * * @since 2.6.0 * * @param object $link */function link_xfn_meta_box($link) {?><table class="editform" style="width: 100%;" cellspacing="2" cellpadding="5">	<tr>		<th style="width: 20%;" scope="row"><label for="link_rel"><?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('rel:') ?></label></th>		<td style="width: 80%;"><input type="text" name="link_rel" id="link_rel" size="50" value="<?php echo ( isset( $link->link_rel ) ? esc_attr($link->link_rel) : ''); ?>" /></td>	</tr>	<tr>		<td colspan="2">			<table cellpadding="3" cellspacing="5" class="form-table">				<tr>					<th scope="row"> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('identity') ?> </th>					<td><fieldset><legend class="screen-reader-text"><span> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('identity') ?> </span></legend>						<label for="me">						<input type="checkbox" name="identity" value="me" id="me" <?php xfn_check('identity', 'me'); ?> />						<?php _e('another web address of mine') ?></label>					</fieldset></td>				</tr>				<tr>					<th scope="row"> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('friendship') ?> </th>					<td><fieldset><legend class="screen-reader-text"><span> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('friendship') ?> </span></legend>						<label for="contact">						<input class="valinp" type="radio" name="friendship" value="contact" id="contact" <?php xfn_check('friendship', 'contact'); ?> /> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('contact') ?></label>						<label for="acquaintance">						<input class="valinp" type="radio" name="friendship" value="acquaintance" id="acquaintance" <?php xfn_check('friendship', 'acquaintance'); ?> />  <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('acquaintance') ?></label>						<label for="friend">						<input class="valinp" type="radio" name="friendship" value="friend" id="friend" <?php xfn_check('friendship', 'friend'); ?> /> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('friend') ?></label>						<label for="friendship">						<input name="friendship" type="radio" class="valinp" value="" id="friendship" <?php xfn_check('friendship'); ?> /> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('none') ?></label>					</fieldset></td>				</tr>				<tr>					<th scope="row"> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('physical') ?> </th>					<td><fieldset><legend class="screen-reader-text"><span> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('physical') ?> </span></legend>						<label for="met">						<input class="valinp" type="checkbox" name="physical" value="met" id="met" <?php xfn_check('physical', 'met'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('met') ?></label>					</fieldset></td>				</tr>				<tr>					<th scope="row"> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('professional') ?> </th>					<td><fieldset><legend class="screen-reader-text"><span> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('professional') ?> </span></legend>						<label for="co-worker">						<input class="valinp" type="checkbox" name="professional" value="co-worker" id="co-worker" <?php xfn_check('professional', 'co-worker'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('co-worker') ?></label>						<label for="colleague">						<input class="valinp" type="checkbox" name="professional" value="colleague" id="colleague" <?php xfn_check('professional', 'colleague'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('colleague') ?></label>					</fieldset></td>				</tr>				<tr>					<th scope="row"> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('geographical') ?> </th>					<td><fieldset><legend class="screen-reader-text"><span> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('geographical') ?> </span></legend>						<label for="co-resident">						<input class="valinp" type="radio" name="geographical" value="co-resident" id="co-resident" <?php xfn_check('geographical', 'co-resident'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('co-resident') ?></label>						<label for="neighbor">						<input class="valinp" type="radio" name="geographical" value="neighbor" id="neighbor" <?php xfn_check('geographical', 'neighbor'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('neighbor') ?></label>						<label for="geographical">						<input class="valinp" type="radio" name="geographical" value="" id="geographical" <?php xfn_check('geographical'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('none') ?></label>					</fieldset></td>				</tr>				<tr>					<th scope="row"> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('family') ?> </th>					<td><fieldset><legend class="screen-reader-text"><span> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('family') ?> </span></legend>						<label for="child">						<input class="valinp" type="radio" name="family" value="child" id="child" <?php xfn_check('family', 'child'); ?>  />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('child') ?></label>						<label for="kin">						<input class="valinp" type="radio" name="family" value="kin" id="kin" <?php xfn_check('family', 'kin'); ?>  />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('kin') ?></label>						<label for="parent">						<input class="valinp" type="radio" name="family" value="parent" id="parent" <?php xfn_check('family', 'parent'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('parent') ?></label>						<label for="sibling">						<input class="valinp" type="radio" name="family" value="sibling" id="sibling" <?php xfn_check('family', 'sibling'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('sibling') ?></label>						<label for="spouse">						<input class="valinp" type="radio" name="family" value="spouse" id="spouse" <?php xfn_check('family', 'spouse'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('spouse') ?></label>						<label for="family">						<input class="valinp" type="radio" name="family" value="" id="family" <?php xfn_check('family'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('none') ?></label>					</fieldset></td>				</tr>				<tr>					<th scope="row"> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('romantic') ?> </th>					<td><fieldset><legend class="screen-reader-text"><span> <?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('romantic') ?> </span></legend>						<label for="muse">						<input class="valinp" type="checkbox" name="romantic" value="muse" id="muse" <?php xfn_check('romantic', 'muse'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('muse') ?></label>						<label for="crush">						<input class="valinp" type="checkbox" name="romantic" value="crush" id="crush" <?php xfn_check('romantic', 'crush'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('crush') ?></label>						<label for="date">						<input class="valinp" type="checkbox" name="romantic" value="date" id="date" <?php xfn_check('romantic', 'date'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('date') ?></label>						<label for="romantic">						<input class="valinp" type="checkbox" name="romantic" value="sweetheart" id="romantic" <?php xfn_check('romantic', 'sweetheart'); ?> />						<?php /* translators: xfn: http://gmpg.org/xfn/ */ _e('sweetheart') ?></label>					</fieldset></td>				</tr>			</table>		</td>	</tr></table><p><?php _e('If the link is to a person, you can specify your relationship with them using the above form. If you would like to learn more about the idea check out <a href="http://gmpg.org/xfn/">XFN</a>.'); ?></p><?php}/** * Display advanced link options form fields. * * @since 2.6.0 * * @param object $link */function link_advanced_meta_box($link) {?><table class="form-table" style="width: 100%;" cellspacing="2" cellpadding="5">	<tr class="form-field">		<th valign="top"  scope="row"><label for="link_image"><?php _e('Image Address') ?></label></th>		<td><input type="text" name="link_image" class="code" id="link_image" size="50" value="<?php echo ( isset( $link->link_image ) ? esc_attr($link->link_image) : ''); ?>" style="width: 95%" /></td>	</tr>	<tr class="form-field">		<th valign="top"  scope="row"><label for="rss_uri"><?php _e('RSS Address') ?></label></th>		<td><input name="link_rss" class="code" type="text" id="rss_uri" value="<?php echo  ( isset( $link->link_rss ) ? esc_attr($link->link_rss) : ''); ?>" size="50" style="width: 95%" /></td>	</tr>	<tr class="form-field">		<th valign="top"  scope="row"><label for="link_notes"><?php _e('Notes') ?></label></th>		<td><textarea name="link_notes" id="link_notes" cols="50" rows="10" style="width: 95%"><?php echo  ( isset( $link->link_notes ) ? $link->link_notes : ''); ?></textarea></td>	</tr>	<tr class="form-field">		<th valign="top"  scope="row"><label for="link_rating"><?php _e('Rating') ?></label></th>		<td><select name="link_rating" id="link_rating" size="1">		<?php			for ($r = 0; $r <= 10; $r++) {				echo('            <option value="'. esc_attr($r) .'" ');				if ( isset($link->link_rating) && $link->link_rating == $r)					echo 'selected="selected"';				echo('>'.$r.'</option>');			}		?></select>&nbsp;<?php _e('(Leave at 0 for no rating.)') ?>		</td>	</tr></table><?php}/** * Display post thumbnail meta box. * * @since 2.9.0 */function post_thumbnail_meta_box() {	global $post;	$thumbnail_id = get_post_meta( $post->ID, '_thumbnail_id', true );	echo _wp_post_thumbnail_html( $thumbnail_id );}
<?php/** * Comment template functions * * These functions are meant to live inside of the WordPress loop. * * @package WordPress * @subpackage Template *//** * Retrieve the author of the current comment. * * If the comment has an empty comment_author field, then 'Anonymous' person is * assumed. * * @since 1.5.0 * @uses apply_filters() Calls 'get_comment_author' hook on the comment author * * @param int $comment_ID The ID of the comment for which to retrieve the author. Optional. * @return string The comment author */function get_comment_author( $comment_ID = 0 ) {	$comment = get_comment( $comment_ID );	if ( empty($comment->comment_author) ) {		if (!empty($comment->user_id)){			$user=get_userdata($comment->user_id);			$author=$user->user_login;		} else {			$author = __('Anonymous');		}	} else {		$author = $comment->comment_author;	}	return apply_filters('get_comment_author', $author);}/** * Displays the author of the current comment. * * @since 0.71 * @uses apply_filters() Calls 'comment_author' on comment author before displaying * * @param int $comment_ID The ID of the comment for which to print the author. Optional. */function comment_author( $comment_ID = 0 ) {	$author = apply_filters('comment_author', get_comment_author( $comment_ID ) );	echo $author;}/** * Retrieve the email of the author of the current comment. * * @since 1.5.0 * @uses apply_filters() Calls the 'get_comment_author_email' hook on the comment author email * @uses $comment * * @param int $comment_ID The ID of the comment for which to get the author's email.  Optional. * @return string The current comment author's email */function get_comment_author_email( $comment_ID = 0 ) {	$comment = get_comment( $comment_ID );	return apply_filters('get_comment_author_email', $comment->comment_author_email);}/** * Display the email of the author of the current global $comment. * * Care should be taken to protect the email address and assure that email * harvesters do not capture your commentors' email address. Most assume that * their email address will not appear in raw form on the blog. Doing so will * enable anyone, including those that people don't want to get the email * address and use it for their own means good and bad. * * @since 0.71 * @uses apply_filters() Calls 'author_email' hook on the author email * * @param int $comment_ID The ID of the comment for which to print the author's email. Optional. */function comment_author_email( $comment_ID = 0 ) {	echo apply_filters('author_email', get_comment_author_email( $comment_ID ) );}/** * Display the html email link to the author of the current comment. * * Care should be taken to protect the email address and assure that email * harvesters do not capture your commentors' email address. Most assume that * their email address will not appear in raw form on the blog. Doing so will * enable anyone, including those that people don't want to get the email * address and use it for their own means good and bad. * * @since 0.71 * @uses apply_filters() Calls 'comment_email' hook for the display of the comment author's email * @uses get_comment_author_email_link() For generating the link * @global object $comment The current Comment row object * * @param string $linktext The text to display instead of the comment author's email address * @param string $before The text or HTML to display before the email link. * @param string $after The text or HTML to display after the email link. */function comment_author_email_link($linktext='', $before='', $after='') {	if ( $link = get_comment_author_email_link( $linktext, $before, $after ) )		echo $link;}/** * Return the html email link to the author of the current comment. * * Care should be taken to protect the email address and assure that email * harvesters do not capture your commentors' email address. Most assume that * their email address will not appear in raw form on the blog. Doing so will * enable anyone, including those that people don't want to get the email * address and use it for their own means good and bad. * * @since 2.7 * @uses apply_filters() Calls 'comment_email' hook for the display of the comment author's email * @global object $comment The current Comment row object * * @param string $linktext The text to display instead of the comment author's email address * @param string $before The text or HTML to display before the email link. * @param string $after The text or HTML to display after the email link. */function get_comment_author_email_link($linktext='', $before='', $after='') {	global $comment;	$email = apply_filters('comment_email', $comment->comment_author_email);	if ((!empty($email)) && ($email != '@')) {	$display = ($linktext != '') ? $linktext : $email;		$return  = $before;		$return .= "<a href='mailto:$email'>$display</a>";	 	$return .= $after;		return $return;	} else {		return '';	}}/** * Retrieve the html link to the url of the author of the current comment. * * @since 1.5.0 * @uses apply_filters() Calls 'get_comment_author_link' hook on the complete link HTML or author * * @param int $comment_ID The ID of the comment for which to get the author's link.  Optional. * @return string Comment Author name or HTML link for author's URL */function get_comment_author_link( $comment_ID = 0 ) {	/** @todo Only call these functions when they are needed. Include in if... else blocks */	$url    = get_comment_author_url( $comment_ID );	$author = get_comment_author( $comment_ID );	if ( empty( $url ) || 'http://' == $url )		$return = $author;	else		$return = "<a href='$url' rel='external nofollow' class='url'>$author</a>";	return apply_filters('get_comment_author_link', $return);}/** * Display the html link to the url of the author of the current comment. * * @since 0.71 * @see get_comment_author_link() Echoes result * * @param int The ID of the comment for which to print the author's link. Optional. */function comment_author_link( $comment_ID = 0 ) {	echo get_comment_author_link( $comment_ID );}/** * Retrieve the IP address of the author of the current comment. * * @since 1.5.0 * @uses $comment * @uses apply_filters() * * @param int $comment_ID The ID of the comment for which to get the author's IP address. Optional. * @return string The comment author's IP address. */function get_comment_author_IP( $comment_ID = 0 ) {	$comment = get_comment( $comment_ID );	return apply_filters('get_comment_author_IP', $comment->comment_author_IP);}/** * Display the IP address of the author of the current comment. * * @since 0.71 * @see get_comment_author_IP() Echoes Result * * @param int $comment_ID The ID of the comment for which to print the author's IP address.  Optional. */function comment_author_IP( $comment_ID = 0 ) {	echo get_comment_author_IP( $comment_ID );}/** * Retrieve the url of the author of the current comment. * * @since 1.5.0 * @uses apply_filters() Calls 'get_comment_author_url' hook on the comment author's URL * * @param int $comment_ID The ID of the comment for which to get the author's URL.  Optional. * @return string */function get_comment_author_url( $comment_ID = 0 ) {	$comment = get_comment( $comment_ID );	$url = ('http://' == $comment->comment_author_url) ? '' : $comment->comment_author_url;	$url = esc_url( $url, array('http', 'https') );	return apply_filters('get_comment_author_url', $url);}/** * Display the url of the author of the current comment. * * @since 0.71 * @uses apply_filters() * @uses get_comment_author_url() Retrieves the comment author's URL * * @param int $comment_ID The ID of the comment for which to print the author's URL. Optional. */function comment_author_url( $comment_ID = 0 ) {	echo apply_filters('comment_url', get_comment_author_url( $comment_ID ));}/** * Retrieves the HTML link of the url of the author of the current comment. * * $linktext parameter is only used if the URL does not exist for the comment * author. If the URL does exist then the URL will be used and the $linktext * will be ignored. * * Encapsulate the HTML link between the $before and $after. So it will appear * in the order of $before, link, and finally $after. * * @since 1.5.0 * @uses apply_filters() Calls the 'get_comment_author_url_link' on the complete HTML before returning. * * @param string $linktext The text to display instead of the comment author's email address * @param string $before The text or HTML to display before the email link. * @param string $after The text or HTML to display after the email link. * @return string The HTML link between the $before and $after parameters */function get_comment_author_url_link( $linktext = '', $before = '', $after = '' ) {	$url = get_comment_author_url();	$display = ($linktext != '') ? $linktext : $url;	$display = str_replace( 'http://www.', '', $display );	$display = str_replace( 'http://', '', $display );	if ( '/' == substr($display, -1) )		$display = substr($display, 0, -1);	$return = "$before<a href='$url' rel='external'>$display</a>$after";	return apply_filters('get_comment_author_url_link', $return);}/** * Displays the HTML link of the url of the author of the current comment. * * @since 0.71 * @see get_comment_author_url_link() Echoes result * * @param string $linktext The text to display instead of the comment author's email address * @param string $before The text or HTML to display before the email link. * @param string $after The text or HTML to display after the email link. */function comment_author_url_link( $linktext = '', $before = '', $after = '' ) {	echo get_comment_author_url_link( $linktext, $before, $after );}/** * Generates semantic classes for each comment element * * @since 2.7.0 * * @param string|array $class One or more classes to add to the class list * @param int $comment_id An optional comment ID * @param int $post_id An optional post ID * @param bool $echo Whether comment_class should echo or return */function comment_class( $class = '', $comment_id = null, $post_id = null, $echo = true ) {	// Separates classes with a single space, collates classes for comment DIV	$class = 'class="' . join( ' ', get_comment_class( $class, $comment_id, $post_id ) ) . '"';	if ( $echo)		echo $class;	else		return $class;}/** * Returns the classes for the comment div as an array * * @since 2.7.0 * * @param string|array $class One or more classes to add to the class list * @param int $comment_id An optional comment ID * @param int $post_id An optional post ID * @return array Array of classes */function get_comment_class( $class = '', $comment_id = null, $post_id = null ) {	global $comment_alt, $comment_depth, $comment_thread_alt;	$comment = get_comment($comment_id);	$classes = array();	// Get the comment type (comment, trackback),	$classes[] = ( empty( $comment->comment_type ) ) ? 'comment' : $comment->comment_type;	// If the comment author has an id (registered), then print the log in name	if ( $comment->user_id > 0 && $user = get_userdata($comment->user_id) ) {		// For all registered users, 'byuser'		$classes[] = 'byuser';		$classes[] = 'comment-author-' . sanitize_html_class($user->user_nicename, $comment->user_id);		// For comment authors who are the author of the post		if ( $post = get_post($post_id) ) {			if ( $comment->user_id === $post->post_author )				$classes[] = 'bypostauthor';		}	}	if ( empty($comment_alt) )		$comment_alt = 0;	if ( empty($comment_depth) )		$comment_depth = 1;	if ( empty($comment_thread_alt) )		$comment_thread_alt = 0;	if ( $comment_alt % 2 ) {		$classes[] = 'odd';		$classes[] = 'alt';	} else {		$classes[] = 'even';	}	$comment_alt++;	// Alt for top-level comments	if ( 1 == $comment_depth ) {		if ( $comment_thread_alt % 2 ) {			$classes[] = 'thread-odd';			$classes[] = 'thread-alt';		} else {			$classes[] = 'thread-even';		}		$comment_thread_alt++;	}	$classes[] = "depth-$comment_depth";	if ( !empty($class) ) {		if ( !is_array( $class ) )			$class = preg_split('#\s+#', $class);		$classes = array_merge($classes, $class);	}	$classes = array_map('esc_attr', $classes);	return apply_filters('comment_class', $classes, $class, $comment_id, $post_id);}/** * Retrieve the comment date of the current comment. * * @since 1.5.0 * @uses apply_filters() Calls 'get_comment_date' hook with the formated date and the $d parameter respectively * @uses $comment * * @param string $d The format of the date (defaults to user's config) * @param int $comment_ID The ID of the comment for which to get the date. Optional. * @return string The comment's date */function get_comment_date( $d = '', $comment_ID = 0 ) {	$comment = get_comment( $comment_ID );	if ( '' == $d )		$date = mysql2date(get_option('date_format'), $comment->comment_date);	else		$date = mysql2date($d, $comment->comment_date);	return apply_filters('get_comment_date', $date, $d);}/** * Display the comment date of the current comment. * * @since 0.71 * * @param string $d The format of the date (defaults to user's config) * @param int $comment_ID The ID of the comment for which to print the date.  Optional. */function comment_date( $d = '', $comment_ID = 0 ) {	echo get_comment_date( $d, $comment_ID );}/** * Retrieve the excerpt of the current comment. * * Will cut each word and only output the first 20 words with '...' at the end. * If the word count is less than 20, then no truncating is done and no '...' * will appear. * * @since 1.5.0 * @uses $comment * @uses apply_filters() Calls 'get_comment_excerpt' on truncated comment * * @param int $comment_ID The ID of the comment for which to get the excerpt. Optional. * @return string The maybe truncated comment with 20 words or less */function get_comment_excerpt( $comment_ID = 0 ) {	$comment = get_comment( $comment_ID );	$comment_text = strip_tags($comment->comment_content);	$blah = explode(' ', $comment_text);	if (count($blah) > 20) {		$k = 20;		$use_dotdotdot = 1;	} else {		$k = count($blah);		$use_dotdotdot = 0;	}	$excerpt = '';	for ($i=0; $i<$k; $i++) {		$excerpt .= $blah[$i] . ' ';	}	$excerpt .= ($use_dotdotdot) ? '...' : '';	return apply_filters('get_comment_excerpt', $excerpt);}/** * Display the excerpt of the current comment. * * @since 1.2.0 * @uses apply_filters() Calls 'comment_excerpt' hook before displaying excerpt * * @param int $comment_ID The ID of the comment for which to print the excerpt. Optional. */function comment_excerpt( $comment_ID = 0 ) {	echo apply_filters('comment_excerpt', get_comment_excerpt($comment_ID) );}/** * Retrieve the comment id of the current comment. * * @since 1.5.0 * @uses $comment * @uses apply_filters() Calls the 'get_comment_ID' hook for the comment ID * * @return int The comment ID */function get_comment_ID() {	global $comment;	return apply_filters('get_comment_ID', $comment->comment_ID);}/** * Displays the comment id of the current comment. * * @since 0.71 * @see get_comment_ID() Echoes Result */function comment_ID() {	echo get_comment_ID();}/** * Retrieve the link to a given comment. * * @since 1.5.0 * @uses $comment * * @param object|string|int $comment Comment to retrieve. * @param array $args Optional args. * @return string The permalink to the given comment. */function get_comment_link( $comment = null, $args = array() ) {	global $wp_rewrite, $in_comment_loop;	$comment = get_comment($comment);	// Backwards compat	if ( !is_array($args) ) {		$page = $args;		$args = array();		$args['page'] = $page;	}	$defaults = array( 'type' => 'all', 'page' => '', 'per_page' => '', 'max_depth' => '' );	$args = wp_parse_args( $args, $defaults );	if ( '' === $args['per_page'] && get_option('page_comments') )		$args['per_page'] = get_option('comments_per_page');	if ( empty($args['per_page']) ) {		$args['per_page'] = 0;		$args['page'] = 0;	}	if ( $args['per_page'] ) {		if ( '' == $args['page'] )			$args['page'] = ( !empty($in_comment_loop) ) ? get_query_var('cpage') : get_page_of_comment( $comment->comment_ID, $args );		if ( $wp_rewrite->using_permalinks() )			$link = user_trailingslashit( trailingslashit( get_permalink( $comment->comment_post_ID ) ) . 'comment-page-' . $args['page'], 'comment' );		else			$link = add_query_arg( 'cpage', $args['page'], get_permalink( $comment->comment_post_ID ) );	} else {		$link = get_permalink( $comment->comment_post_ID );	}	return apply_filters( 'get_comment_link', $link . '#comment-' . $comment->comment_ID, $comment, $args );}/** * Retrieves the link to the current post comments. * * @since 1.5.0 * * @param int $post_id Optional post id * @return string The link to the comments */function get_comments_link($post_id = 0) {	return get_permalink($post_id) . '#comments';}/** * Displays the link to the current post comments. * * @since 0.71 * * @param string $deprecated Not Used * @param bool $deprecated_2 Not Used */function comments_link( $deprecated = '', $deprecated_2 = '' ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '0.72' );	if ( !empty( $deprecated_2 ) )		_deprecated_argument( __FUNCTION__, '1.3' );	echo get_comments_link();}/** * Retrieve the amount of comments a post has. * * @since 1.5.0 * @uses apply_filters() Calls the 'get_comments_number' hook on the number of comments * * @param int $post_id The Post ID * @return int The number of comments a post has */function get_comments_number( $post_id = 0 ) {	global $id;	$post_id = (int) $post_id;	if ( !$post_id )		$post_id = (int) $id;	$post = get_post($post_id);	if ( ! isset($post->comment_count) )		$count = 0;	else		$count = $post->comment_count;	return apply_filters('get_comments_number', $count, $post_id);}/** * Display the language string for the number of comments the current post has. * * @since 0.71 * @uses $id * @uses apply_filters() Calls the 'comments_number' hook on the output and number of comments respectively. * * @param string $zero Text for no comments * @param string $one Text for one comment * @param string $more Text for more than one comment * @param string $deprecated Not used. */function comments_number( $zero = false, $one = false, $more = false, $deprecated = '' ) {	global $id;	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '1.3' );	$number = get_comments_number($id);	if ( $number > 1 )		$output = str_replace('%', number_format_i18n($number), ( false === $more ) ? __('% Comments') : $more);	elseif ( $number == 0 )		$output = ( false === $zero ) ? __('No Comments') : $zero;	else // must be one		$output = ( false === $one ) ? __('1 Comment') : $one;	echo apply_filters('comments_number', $output, $number);}/** * Retrieve the text of the current comment. * * @since 1.5.0 * @uses $comment * * @param int $comment_ID The ID of the comment for which to get the text. Optional. * @return string The comment content */function get_comment_text( $comment_ID = 0 ) {	$comment = get_comment( $comment_ID );	return apply_filters('get_comment_text', $comment->comment_content);}/** * Displays the text of the current comment. * * @since 0.71 * @uses apply_filters() Passes the comment content through the 'comment_text' hook before display * @uses get_comment_text() Gets the comment content * * @param int $comment_ID The ID of the comment for which to print the text. Optional. */function comment_text( $comment_ID = 0 ) {	echo apply_filters('comment_text', get_comment_text() );}/** * Retrieve the comment time of the current comment. * * @since 1.5.0 * @uses $comment * @uses apply_filter() Calls 'get_comment_time' hook with the formatted time, the $d parameter, and $gmt parameter passed. * * @param string $d Optional. The format of the time (defaults to user's config) * @param bool $gmt Whether to use the GMT date * @param bool $translate Whether to translate the time (for use in feeds) * @return string The formatted time */function get_comment_time( $d = '', $gmt = false, $translate = true ) {	global $comment;	$comment_date = $gmt ? $comment->comment_date_gmt : $comment->comment_date;	if ( '' == $d )		$date = mysql2date(get_option('time_format'), $comment_date, $translate);	else		$date = mysql2date($d, $comment_date, $translate);	return apply_filters('get_comment_time', $date, $d, $gmt, $translate);}/** * Display the comment time of the current comment. * * @since 0.71 * * @param string $d Optional. The format of the time (defaults to user's config) */function comment_time( $d = '' ) {	echo get_comment_time($d);}/** * Retrieve the comment type of the current comment. * * @since 1.5.0 * @uses $comment * @uses apply_filters() Calls the 'get_comment_type' hook on the comment type * * @param int $comment_ID The ID of the comment for which to get the type. Optional. * @return string The comment type */function get_comment_type( $comment_ID = 0 ) {	$comment = get_comment( $comment_ID );	if ( '' == $comment->comment_type )		$comment->comment_type = 'comment';	return apply_filters('get_comment_type', $comment->comment_type);}/** * Display the comment type of the current comment. * * @since 0.71 * * @param string $commenttxt The string to display for comment type * @param string $trackbacktxt The string to display for trackback type * @param string $pingbacktxt The string to display for pingback type */function comment_type($commenttxt = false, $trackbacktxt = false, $pingbacktxt = false) {    if ( false === $commenttxt ) $commenttxt = _x( 'Comment', 'noun' );    if ( false === $trackbacktxt ) $trackbacktxt = __( 'Trackback' );    if ( false === $pingbacktxt ) $pingbacktxt = __( 'Pingback' );	$type = get_comment_type();	switch( $type ) {		case 'trackback' :			echo $trackbacktxt;			break;		case 'pingback' :			echo $pingbacktxt;			break;		default :			echo $commenttxt;	}}/** * Retrieve The current post's trackback URL. * * There is a check to see if permalink's have been enabled and if so, will * retrieve the pretty path. If permalinks weren't enabled, the ID of the * current post is used and appended to the correct page to go to. * * @since 1.5.0 * @uses apply_filters() Calls 'trackback_url' on the resulting trackback URL * @uses $id * * @return string The trackback URL after being filtered */function get_trackback_url() {	global $id;	if ( '' != get_option('permalink_structure') ) {		$tb_url = trailingslashit(get_permalink()) . user_trailingslashit('trackback', 'single_trackback');	} else {		$tb_url = get_option('siteurl') . '/wp-trackback.php?p=' . $id;	}	return apply_filters('trackback_url', $tb_url);}/** * Displays the current post's trackback URL. * * @since 0.71 * @uses get_trackback_url() Gets the trackback url for the current post * * @param bool $deprecated_echo Remove backwards compat in 2.5 * @return void|string Should only be used to echo the trackback URL, use get_trackback_url() for the result instead. */function trackback_url( $deprecated_echo = true ) {	if ( $deprecated_echo !== true )		_deprecated_argument( __FUNCTION__, '2.5', __('Use <code>get_trackback_url()</code> instead if you do not want the value echoed.') );	if ( $deprecated_echo )		echo get_trackback_url();	else		return get_trackback_url();}/** * Whether the current post is open for comments. * * @since 1.5.0 * @uses $post * * @param int $post_id An optional post ID to check instead of the current post. * @return bool True if the comments are open */function comments_open( $post_id=NULL ) {	$_post = get_post($post_id);	$open = ( 'open' == $_post->comment_status );	return apply_filters( 'comments_open', $open, $post_id );}/** * Whether the current post is open for pings. * * @since 1.5.0 * @uses $post * * @param int $post_id An optional post ID to check instead of the current post. * @return bool True if pings are accepted */function pings_open( $post_id = NULL ) {	$_post = get_post($post_id);	$open = ( 'open' == $_post->ping_status );	return apply_filters( 'pings_open', $open, $post_id );}/** * Displays form token for unfiltered comments. * * Will only display nonce token if the current user has permissions for * unfiltered html. Won't display the token for other users. * * The function was backported to 2.0.10 and was added to versions 2.1.3 and * above. Does not exist in versions prior to 2.0.10 in the 2.0 branch and in * the 2.1 branch, prior to 2.1.3. Technically added in 2.2.0. * * Backported to 2.0.10. * * @since 2.1.3 * @uses $post Gets the ID of the current post for the token */function wp_comment_form_unfiltered_html_nonce() {	global $post;	$post_id = 0;	if ( !empty($post) )		$post_id = $post->ID;	if ( current_user_can('unfiltered_html') )		wp_nonce_field('unfiltered-html-comment_' . $post_id, '_wp_unfiltered_html_comment', false);}/** * Loads the comment template specified in $file. * * Will not display the comments template if not on single post or page, or if * the post does not have comments. * * Uses the WordPress database object to query for the comments. The comments * are passed through the 'comments_array' filter hook with the list of comments * and the post ID respectively. * * The $file path is passed through a filter hook called, 'comments_template' * which includes the TEMPLATEPATH and $file combined. Tries the $filtered path * first and if it fails it will require the default comment themplate from the * default theme. If either does not exist, then the WordPress process will be * halted. It is advised for that reason, that the default theme is not deleted. * * @since 1.5.0 * @global array $comment List of comment objects for the current post * @uses $wpdb * @uses $id * @uses $post * @uses $withcomments Will not try to get the comments if the post has none. * * @param string $file Optional, default '/comments.php'. The file to load * @param bool $separate_comments Optional, whether to separate the comments by comment type. Default is false. * @return null Returns null if no comments appear */function comments_template( $file = '/comments.php', $separate_comments = false ) {	global $wp_query, $withcomments, $post, $wpdb, $id, $comment, $user_login, $user_ID, $user_identity, $overridden_cpage;	if ( !(is_single() || is_page() || $withcomments) || empty($post) )		return;	if ( empty($file) )		$file = '/comments.php';	$req = get_option('require_name_email');	/**	 * Comment author information fetched from the comment cookies.	 *	 * @uses wp_get_current_commenter()	 */	$commenter = wp_get_current_commenter();	/**	 * The name of the current comment author escaped for use in attributes.	 */	$comment_author = $commenter['comment_author']; // Escaped by sanitize_comment_cookies()	/**	 * The email address of the current comment author escaped for use in attributes.	 */	$comment_author_email = $commenter['comment_author_email'];  // Escaped by sanitize_comment_cookies()	/**	 * The url of the current comment author escaped for use in attributes.	 */	$comment_author_url = esc_url($commenter['comment_author_url']);	/** @todo Use API instead of SELECTs. */	if ( $user_ID) {		$comments = $wpdb->get_results($wpdb->prepare("SELECT * FROM $wpdb->comments WHERE comment_post_ID = %d AND (comment_approved = '1' OR ( user_id = %d AND comment_approved = '0' ) )  ORDER BY comment_date_gmt", $post->ID, $user_ID));	} else if ( empty($comment_author) ) {		$comments = get_comments( array('post_id' => $post->ID, 'status' => 'approve', 'order' => 'ASC') );	} else {		$comments = $wpdb->get_results($wpdb->prepare("SELECT * FROM $wpdb->comments WHERE comment_post_ID = %d AND ( comment_approved = '1' OR ( comment_author = %s AND comment_author_email = %s AND comment_approved = '0' ) ) ORDER BY comment_date_gmt", $post->ID, wp_specialchars_decode($comment_author,ENT_QUOTES), $comment_author_email));	}	// keep $comments for legacy's sake	$wp_query->comments = apply_filters( 'comments_array', $comments, $post->ID );	$comments = &$wp_query->comments;	$wp_query->comment_count = count($wp_query->comments);	update_comment_cache($wp_query->comments);	if ( $separate_comments ) {		$wp_query->comments_by_type = &separate_comments($comments);		$comments_by_type = &$wp_query->comments_by_type;	}	$overridden_cpage = FALSE;	if ( '' == get_query_var('cpage') && get_option('page_comments') ) {		set_query_var( 'cpage', 'newest' == get_option('default_comments_page') ? get_comment_pages_count() : 1 );		$overridden_cpage = TRUE;	}	if ( !defined('COMMENTS_TEMPLATE') || !COMMENTS_TEMPLATE)		define('COMMENTS_TEMPLATE', true);	$include = apply_filters('comments_template', STYLESHEETPATH . $file );	if ( file_exists( $include ) )		require( $include );	elseif ( file_exists( TEMPLATEPATH . $file ) )		require( TEMPLATEPATH .  $file );	else // Backward compat code will be removed in a future release		require( WPINC . '/theme-compat/comments.php');}/** * Displays the JS popup script to show a comment. * * If the $file parameter is empty, then the home page is assumed. The defaults * for the window are 400px by 400px. * * For the comment link popup to work, this function has to be called or the * normal comment link will be assumed. * * @since 0.71 * @global string $wpcommentspopupfile The URL to use for the popup window * @global int $wpcommentsjavascript Whether to use JavaScript. Set when function is called * * @param int $width Optional. The width of the popup window * @param int $height Optional. The height of the popup window * @param string $file Optional. Sets the location of the popup window */function comments_popup_script($width=400, $height=400, $file='') {	global $wpcommentspopupfile, $wpcommentsjavascript;	if (empty ($file)) {		$wpcommentspopupfile = '';  // Use the index.	} else {		$wpcommentspopupfile = $file;	}	$wpcommentsjavascript = 1;	$javascript = "<script type='text/javascript'>\nfunction wpopen (macagna) {\n    window.open(macagna, '_blank', 'width=$width,height=$height,scrollbars=yes,status=yes');\n}\n</script>\n";	echo $javascript;}/** * Displays the link to the comments popup window for the current post ID. * * Is not meant to be displayed on single posts and pages. Should be used on the * lists of posts * * @since 0.71 * @uses $id * @uses $wpcommentspopupfile * @uses $wpcommentsjavascript * @uses $post * * @param string $zero The string to display when no comments * @param string $one The string to display when only one comment is available * @param string $more The string to display when there are more than one comment * @param string $css_class The CSS class to use for comments * @param string $none The string to display when comments have been turned off * @return null Returns null on single posts and pages. */function comments_popup_link( $zero = false, $one = false, $more = false, $css_class = '', $none = false ) {	global $id, $wpcommentspopupfile, $wpcommentsjavascript;    if ( false === $zero ) $zero = __( 'No Comments' );    if ( false === $one ) $one = __( '1 Comment' );    if ( false === $more ) $more = __( '% Comments' );    if ( false === $none ) $none = __( 'Comments Off' );	$number = get_comments_number( $id );	if ( 0 == $number && !comments_open() && !pings_open() ) {		echo '<span' . ((!empty($css_class)) ? ' class="' . esc_attr( $css_class ) . '"' : '') . '>' . $none . '</span>';		return;	}	if ( post_password_required() ) {		echo __('Enter your password to view comments.');		return;	}	echo '<a href="';	if ( $wpcommentsjavascript ) {		if ( empty( $wpcommentspopupfile ) )			$home = home_url();		else			$home = get_option('siteurl');		echo $home . '/' . $wpcommentspopupfile . '?comments_popup=' . $id;		echo '" onclick="wpopen(this.href); return false"';	} else { // if comments_popup_script() is not in the template, display simple comment link		if ( 0 == $number )			echo get_permalink() . '#respond';		else			comments_link();		echo '"';	}	if ( !empty( $css_class ) ) {		echo ' class="'.$css_class.'" ';	}	$title = the_title_attribute( array('echo' => 0 ) );	echo apply_filters( 'comments_popup_link_attributes', '' );	echo ' title="' . esc_attr( sprintf( __('Comment on %s'), $title ) ) . '">';	comments_number( $zero, $one, $more );	echo '</a>';}/** * Retrieve HTML content for reply to comment link. * * The default arguments that can be override are 'add_below', 'respond_id', * 'reply_text', 'login_text', and 'depth'. The 'login_text' argument will be * used, if the user must log in or register first before posting a comment. The * 'reply_text' will be used, if they can post a reply. The 'add_below' and * 'respond_id' arguments are for the JavaScript moveAddCommentForm() function * parameters. * * @since 2.7.0 * * @param array $args Optional. Override default options. * @param int $comment Optional. Comment being replied to. * @param int $post Optional. Post that the comment is going to be displayed on. * @return string|bool|null Link to show comment form, if successful. False, if comments are closed. */function get_comment_reply_link($args = array(), $comment = null, $post = null) {	global $user_ID;	$defaults = array('add_below' => 'comment', 'respond_id' => 'respond', 'reply_text' => __('Reply'),		'login_text' => __('Log in to Reply'), 'depth' => 0, 'before' => '', 'after' => '');	$args = wp_parse_args($args, $defaults);	if ( 0 == $args['depth'] || $args['max_depth'] <= $args['depth'] )		return;	extract($args, EXTR_SKIP);	$comment = get_comment($comment);	if ( empty($post) )		$post = $comment->comment_post_ID;	$post = get_post($post);	if ( !comments_open($post->ID) )		return false;	$link = '';	if ( get_option('comment_registration') && !$user_ID )		$link = '<a rel="nofollow" class="comment-reply-login" href="' . esc_url( wp_login_url( get_permalink() ) ) . '">' . $login_text . '</a>';	else		$link = "<a rel='nofollow' class='comment-reply-link' href='" . esc_url( add_query_arg( 'replytocom', $comment->comment_ID ) ) . "#" . $respond_id . "' onclick='return addComment.moveForm(\"$add_below-$comment->comment_ID\", \"$comment->comment_ID\", \"$respond_id\", \"$post->ID\")'>$reply_text</a>";	return apply_filters('comment_reply_link', $before . $link . $after, $args, $comment, $post);}/** * Displays the HTML content for reply to comment link. * * @since 2.7.0 * @see get_comment_reply_link() Echoes result * * @param array $args Optional. Override default options. * @param int $comment Optional. Comment being replied to. * @param int $post Optional. Post that the comment is going to be displayed on. * @return string|bool|null Link to show comment form, if successful. False, if comments are closed. */function comment_reply_link($args = array(), $comment = null, $post = null) {	echo get_comment_reply_link($args, $comment, $post);}/** * Retrieve HTML content for reply to post link. * * The default arguments that can be override are 'add_below', 'respond_id', * 'reply_text', 'login_text', and 'depth'. The 'login_text' argument will be * used, if the user must log in or register first before posting a comment. The * 'reply_text' will be used, if they can post a reply. The 'add_below' and * 'respond_id' arguments are for the JavaScript moveAddCommentForm() function * parameters. * * @since 2.7.0 * * @param array $args Optional. Override default options. * @param int|object $post Optional. Post that the comment is going to be displayed on.  Defaults to current post. * @return string|bool|null Link to show comment form, if successful. False, if comments are closed. */function get_post_reply_link($args = array(), $post = null) {	global $user_ID;	$defaults = array('add_below' => 'post', 'respond_id' => 'respond', 'reply_text' => __('Leave a Comment'),		'login_text' => __('Log in to leave a Comment'), 'before' => '', 'after' => '');	$args = wp_parse_args($args, $defaults);	extract($args, EXTR_SKIP);	$post = get_post($post);	if ( !comments_open($post->ID) )		return false;	if ( get_option('comment_registration') && !$user_ID ) {		$link = '<a rel="nofollow" href="' . wp_login_url( get_permalink() ) . '">' . $login_text . '</a>';	} else {		$link = "<a rel='nofollow' class='comment-reply-link' href='" . get_permalink($post->ID) . "#$respond_id' onclick='return addComment.moveForm(\"$add_below-$post->ID\", \"0\", \"$respond_id\", \"$post->ID\")'>$reply_text</a>";	}	return apply_filters('post_comments_link', $before . $link . $after, $post);}/** * Displays the HTML content for reply to post link. * @since 2.7.0 * @see get_post_reply_link() * * @param array $args Optional. Override default options. * @param int|object $post Optional. Post that the comment is going to be displayed on. * @return string|bool|null Link to show comment form, if successful. False, if comments are closed. */function post_reply_link($args = array(), $post = null) {	echo get_post_reply_link($args, $post);}/** * Retrieve HTML content for cancel comment reply link. * * @since 2.7.0 * * @param string $text Optional. Text to display for cancel reply link. */function get_cancel_comment_reply_link($text = '') {	if ( empty($text) )		$text = __('Click here to cancel reply.');	$style = isset($_GET['replytocom']) ? '' : ' style="display:none;"';	$link = esc_html( remove_query_arg('replytocom') ) . '#respond';	return apply_filters('cancel_comment_reply_link', '<a rel="nofollow" id="cancel-comment-reply-link" href="' . $link . '"' . $style . '>' . $text . '</a>', $link, $text);}/** * Display HTML content for cancel comment reply link. * * @since 2.7.0 * * @param string $text Optional. Text to display for cancel reply link. */function cancel_comment_reply_link($text = '') {	echo get_cancel_comment_reply_link($text);}/** * Retrieve hidden input HTML for replying to comments. * * @since 3.0.0 * * @return string Hidden input HTML for replying to comments */function get_comment_id_fields() {	global $id;	$replytoid = isset($_GET['replytocom']) ? (int) $_GET['replytocom'] : 0;	$result  = "<input type='hidden' name='comment_post_ID' value='$id' id='comment_post_ID' />\n";	$result .= "<input type='hidden' name='comment_parent' id='comment_parent' value='$replytoid' />\n";	return apply_filters('comment_id_fields', $result, $id, $replytoid);}/** * Output hidden input HTML for replying to comments. * * @since 2.7.0 * @see get_comment_id_fields() Echoes result */function comment_id_fields() {	echo get_comment_id_fields();}/** * Display text based on comment reply status. Only affects users with Javascript disabled. * * @since 2.7.0 * * @param string $noreplytext Optional. Text to display when not replying to a comment. * @param string $replytext Optional. Text to display when replying to a comment. Accepts "%s" for the author of the comment being replied to. * @param string $linktoparent Optional. Boolean to control making the author's name a link to their comment. */function comment_form_title( $noreplytext = false, $replytext = false, $linktoparent = TRUE ) {	global $comment;	if ( false === $noreplytext ) $noreplytext = __( 'Leave a Reply' );	if ( false === $replytext ) $replytext = __( 'Leave a Reply to %s' );	$replytoid = isset($_GET['replytocom']) ? (int) $_GET['replytocom'] : 0;	if ( 0 == $replytoid )		echo $noreplytext;	else {		$comment = get_comment($replytoid);		$author = ( $linktoparent ) ? '<a href="#comment-' . get_comment_ID() . '">' . get_comment_author() . '</a>' : get_comment_author();		printf( $replytext, $author );	}}/** * HTML comment list class. * * @package WordPress * @uses Walker * @since unknown */class Walker_Comment extends Walker {	/**	 * @see Walker::$tree_type	 * @since unknown	 * @var string	 */	var $tree_type = 'comment';	/**	 * @see Walker::$db_fields	 * @since unknown	 * @var array	 */	var $db_fields = array ('parent' => 'comment_parent', 'id' => 'comment_ID');	/**	 * @see Walker::start_lvl()	 * @since unknown	 *	 * @param string $output Passed by reference. Used to append additional content.	 * @param int $depth Depth of comment.	 * @param array $args Uses 'style' argument for type of HTML list.	 */	function start_lvl(&$output, $depth, $args) {		$GLOBALS['comment_depth'] = $depth + 1;		switch ( $args['style'] ) {			case 'div':				break;			case 'ol':				echo "<ol class='children'>\n";				break;			default:			case 'ul':				echo "<ul class='children'>\n";				break;		}	}	/**	 * @see Walker::end_lvl()	 * @since unknown	 *	 * @param string $output Passed by reference. Used to append additional content.	 * @param int $depth Depth of comment.	 * @param array $args Will only append content if style argument value is 'ol' or 'ul'.	 */	function end_lvl(&$output, $depth, $args) {		$GLOBALS['comment_depth'] = $depth + 1;		switch ( $args['style'] ) {			case 'div':				break;			case 'ol':				echo "</ol>\n";				break;			default:			case 'ul':				echo "</ul>\n";				break;		}	}	/**	 * This function is designed to enhance Walker::display_element() to	 * display children of higher nesting levels than selected inline on	 * the highest depth level displayed. This prevents them being orphaned	 * at the end of the comment list.	 *	 * Example: max_depth = 2, with 5 levels of nested content.	 * 1	 *  1.1	 *    1.1.1	 *    1.1.1.1	 *    1.1.1.1.1	 *    1.1.2	 *    1.1.2.1	 * 2	 *  2.2	 *	 */	function display_element( $element, &$children_elements, $max_depth, $depth=0, $args, &$output ) {		if ( !$element )			return;		$id_field = $this->db_fields['id'];		$id = $element->$id_field;		parent::display_element( $element, $children_elements, $max_depth, $depth, $args, $output );		// If we're at the max depth, and the current element still has children, loop over those and display them at this level		// This is to prevent them being orphaned to the end of the list.		if ( $max_depth <= $depth + 1 && isset( $children_elements[$id]) ) {			foreach ( $children_elements[ $id ] as $child )				$this->display_element( $child, $children_elements, $max_depth, $depth, $args, $output );			unset( $children_elements[ $id ] );		}	}	/**	 * @see Walker::start_el()	 * @since unknown	 *	 * @param string $output Passed by reference. Used to append additional content.	 * @param object $comment Comment data object.	 * @param int $depth Depth of comment in reference to parents.	 * @param array $args	 */	function start_el(&$output, $comment, $depth, $args) {		$depth++;		$GLOBALS['comment_depth'] = $depth;		if ( !empty($args['callback']) ) {			call_user_func($args['callback'], $comment, $args, $depth);			return;		}		$GLOBALS['comment'] = $comment;		extract($args, EXTR_SKIP);		if ( 'div' == $args['style'] ) {			$tag = 'div';			$add_below = 'comment';		} else {			$tag = 'li';			$add_below = 'div-comment';		}?>		<<?php echo $tag ?> <?php comment_class(empty( $args['has_children'] ) ? '' : 'parent') ?> id="comment-<?php comment_ID() ?>">		<?php if ( 'div' != $args['style'] ) : ?>		<div id="div-comment-<?php comment_ID() ?>" class="comment-body">		<?php endif; ?>		<div class="comment-author vcard">		<?php if ($args['avatar_size'] != 0) echo get_avatar( $comment, $args['avatar_size'] ); ?>		<?php printf(__('<cite class="fn">%s</cite> <span class="says">says:</span>'), get_comment_author_link()) ?>		</div><?php if ($comment->comment_approved == '0') : ?>		<em><?php _e('Your comment is awaiting moderation.') ?></em>		<br /><?php endif; ?>		<div class="comment-meta commentmetadata"><a href="<?php echo htmlspecialchars( get_comment_link( $comment->comment_ID ) ) ?>">			<?php				/* translators: 1: date, 2: time */				printf( __('%1$s at %2$s'), get_comment_date(),  get_comment_time()) ?></a><?php edit_comment_link(__('(Edit)'),'&nbsp;&nbsp;','' );			?>		</div>		<?php comment_text() ?>		<div class="reply">		<?php comment_reply_link(array_merge( $args, array('add_below' => $add_below, 'depth' => $depth, 'max_depth' => $args['max_depth']))) ?>		</div>		<?php if ( 'div' != $args['style'] ) : ?>		</div>		<?php endif; ?><?php	}	/**	 * @see Walker::end_el()	 * @since unknown	 *	 * @param string $output Passed by reference. Used to append additional content.	 * @param object $comment	 * @param int $depth Depth of comment.	 * @param array $args	 */	function end_el(&$output, $comment, $depth, $args) {		if ( !empty($args['end-callback']) ) {			call_user_func($args['end-callback'], $comment, $args, $depth);			return;		}		if ( 'div' == $args['style'] )			echo "</div>\n";		else			echo "</li>\n";	}}/** * List comments * * Used in the comments.php template to list comments for a particular post * * @since 2.7.0 * @uses Walker_Comment * * @param string|array $args Formatting options * @param array $comments Optional array of comment objects.  Defaults to $wp_query->comments */function wp_list_comments($args = array(), $comments = null ) {	global $wp_query, $comment_alt, $comment_depth, $comment_thread_alt, $overridden_cpage, $in_comment_loop;	$in_comment_loop = true;	$comment_alt = $comment_thread_alt = 0;	$comment_depth = 1;	$defaults = array('walker' => null, 'max_depth' => '', 'style' => 'ul', 'callback' => null, 'end-callback' => null, 'type' => 'all',		'page' => '', 'per_page' => '', 'avatar_size' => 32, 'reverse_top_level' => null, 'reverse_children' => '');	$r = wp_parse_args( $args, $defaults );	// Figure out what comments we'll be looping through ($_comments)	if ( null !== $comments ) {		$comments = (array) $comments;		if ( empty($comments) )			return;		if ( 'all' != $r['type'] ) {			$comments_by_type = &separate_comments($comments);			if ( empty($comments_by_type[$r['type']]) )				return;			$_comments = $comments_by_type[$r['type']];		} else {			$_comments = $comments;		}	} else {		if ( empty($wp_query->comments) )			return;		if ( 'all' != $r['type'] ) {			if ( empty($wp_query->comments_by_type) )				$wp_query->comments_by_type = &separate_comments($wp_query->comments);			if ( empty($wp_query->comments_by_type[$r['type']]) )				return;			$_comments = $wp_query->comments_by_type[$r['type']];		} else {			$_comments = $wp_query->comments;		}	}	if ( '' === $r['per_page'] && get_option('page_comments') )		$r['per_page'] = get_query_var('comments_per_page');	if ( empty($r['per_page']) ) {		$r['per_page'] = 0;		$r['page'] = 0;	}	if ( '' === $r['max_depth'] ) {		if ( get_option('thread_comments') )			$r['max_depth'] = get_option('thread_comments_depth');		else			$r['max_depth'] = -1;	}	if ( '' === $r['page'] ) {		if ( empty($overridden_cpage) ) {			$r['page'] = get_query_var('cpage');		} else {			$threaded = ( -1 != $r['max_depth'] );			$r['page'] = ( 'newest' == get_option('default_comments_page') ) ? get_comment_pages_count($_comments, $r['per_page'], $threaded) : 1;			set_query_var( 'cpage', $r['page'] );		}	}	// Validation check	$r['page'] = intval($r['page']);	if ( 0 == $r['page'] && 0 != $r['per_page'] )		$r['page'] = 1;	if ( null === $r['reverse_top_level'] )		$r['reverse_top_level'] = ( 'desc' == get_option('comment_order') );	extract( $r, EXTR_SKIP );	if ( empty($walker) )		$walker = new Walker_Comment;	$walker->paged_walk($_comments, $max_depth, $page, $per_page, $r);	$wp_query->max_num_comment_pages = $walker->max_pages;	$in_comment_loop = false;}/** * Outputs a complete commenting form for use within a template. * Most strings and form fields may be controlled through the $args array passed * into the function, while you may also choose to use the comment_form_default_fields * filter to modify the array of default fields if you'd just like to add a new * one or remove a single field. All fields are also individually passed through * a filter of the form comment_form_field_$name where $name is the key used * in the array of fields. * * @since 3.0.0 * @param array $args Options for strings, fields etc in the form * @param mixed $post_id Post ID to generate the form for, uses the current post if null * @return void */function comment_form( $args = array(), $post_id = null ) {	global $user_identity, $id;	if ( null === $post_id )		$post_id = $id;	else		$id = $post_id;	$commenter = wp_get_current_commenter();	$req = get_option( 'require_name_email' );	$aria_req = ( $req ? " aria-required='true'" : '' );	$fields =  array(		'author' => '<p class="comment-form-author">' . '<label for="author">' . __( 'Name' ) . '</label> ' . ( $req ? '<span class="required">*</span>' : '' ) .		            '<input id="author" name="author" type="text" value="' . esc_attr( $commenter['comment_author'] ) . '" size="30"' . $aria_req . ' /></p>',		'email'  => '<p class="comment-form-email"><label for="email">' . __( 'Email' ) . '</label> ' . ( $req ? '<span class="required">*</span>' : '' ) .		            '<input id="email" name="email" type="text" value="' . esc_attr(  $commenter['comment_author_email'] ) . '" size="30"' . $aria_req . ' /></p>',		'url'    => '<p class="comment-form-url"><label for="url">' . __( 'Website' ) . '</label>' .		            '<input id="url" name="url" type="text" value="' . esc_attr( $commenter['comment_author_url'] ) . '" size="30" /></p>',	);	$required_text = sprintf( ' ' . __('Required fields are marked %s'), '<span class="required">*</span>' );	$defaults = array(		'fields'               => apply_filters( 'comment_form_default_fields', $fields ),		'comment_field'        => '<p class="comment-form-comment"><label for="comment">' . _x( 'Comment', 'noun' ) . '</label><textarea id="comment" name="comment" cols="45" rows="8" aria-required="true"></textarea></p>',		'must_log_in'          => '<p class="must-log-in">' .  sprintf( __( 'You must be <a href="%s">logged in</a> to post a comment.' ), wp_login_url( apply_filters( 'the_permalink', get_permalink( $post_id ) ) ) ) . '</p>',		'logged_in_as'         => '<p class="logged-in-as">' . sprintf( __( 'Logged in as <a href="%1$s">%2$s</a>. <a href="%3$s" title="Log out of this account">Log out?</a>' ), admin_url( 'profile.php' ), $user_identity, wp_logout_url( apply_filters( 'the_permalink', get_permalink( $post_id ) ) ) ) . '</p>',		'comment_notes_before' => '<p class="comment-notes">' . __( 'Your email address will not be published.' ) . ( $req ? $required_text : '' ) . '</p>',		'comment_notes_after'  => '<p class="form-allowed-tags">' . sprintf( __( 'You may use these <abbr title="HyperText Markup Language">HTML</abbr> tags and attributes: %s' ), ' <code>' . allowed_tags() . '</code>' ) . '</p>',		'id_form'              => 'commentform',		'id_submit'            => 'submit',		'title_reply'          => __( 'Leave a Reply' ),		'title_reply_to'       => __( 'Leave a Reply to %s' ),		'cancel_reply_link'    => __( 'Cancel reply' ),		'label_submit'         => __( 'Post Comment' ),	);	$args = wp_parse_args( $args, apply_filters( 'comment_form_defaults', $defaults ) );	?>		<?php if ( comments_open() ) : ?>			<?php do_action( 'comment_form_before' ); ?>			<div id="respond">				<h3 id="reply-title"><?php comment_form_title( $args['title_reply'], $args['title_reply_to'] ); ?> <small><?php cancel_comment_reply_link( $args['cancel_reply_link'] ); ?></small></h3>				<?php if ( get_option( 'comment_registration' ) && !is_user_logged_in() ) : ?>					<?php echo $args['must_log_in']; ?>					<?php do_action( 'comment_form_must_log_in_after' ); ?>				<?php else : ?>					<form action="<?php echo site_url( '/wp-comments-post.php' ); ?>" method="post" id="<?php echo esc_attr( $args['id_form'] ); ?>">						<?php do_action( 'comment_form_top' ); ?>						<?php if ( is_user_logged_in() ) : ?>							<?php echo apply_filters( 'comment_form_logged_in', $args['logged_in_as'], $commenter, $user_identity ); ?>							<?php do_action( 'comment_form_logged_in_after', $commenter, $user_identity ); ?>						<?php else : ?>							<?php echo $args['comment_notes_before']; ?>							<?php							do_action( 'comment_form_before_fields' );							foreach ( (array) $args['fields'] as $name => $field ) {								echo apply_filters( "comment_form_field_{$name}", $field ) . "\n";							}							do_action( 'comment_form_after_fields' );							?>						<?php endif; ?>						<?php echo apply_filters( 'comment_form_field_comment', $args['comment_field'] ); ?>						<?php echo $args['comment_notes_after']; ?>						<p class="form-submit">							<input name="submit" type="submit" id="<?php echo esc_attr( $args['id_submit'] ); ?>" value="<?php echo esc_attr( $args['label_submit'] ); ?>" />							<?php comment_id_fields(); ?>						</p>						<?php do_action( 'comment_form', $post_id ); ?>					</form>				<?php endif; ?>			</div><!-- #respond -->			<?php do_action( 'comment_form_after' ); ?>		<?php else : ?>			<?php do_action( 'comment_form_comments_closed' ); ?>		<?php endif; ?>	<?php}?>
<?php/** * Retrieves and creates the wp-config.php file. * * The permissions for the base directory must allow for writing files in order * for the wp-config.php to be created using this page. * * @package WordPress * @subpackage Administration *//** * We are installing. * * @package WordPress */define('WP_INSTALLING', true);/** * We are blissfully unaware of anything. */define('WP_SETUP_CONFIG', true);/** * Disable error reporting * * Set this to error_reporting( E_ALL ) or error_reporting( E_ALL | E_STRICT ) for debugging */error_reporting(0);/**#@+ * These three defines are required to allow us to use require_wp_db() to load * the database class while being wp-content/db.php aware. * @ignore */define('ABSPATH', dirname(dirname(__FILE__)).'/');define('WPINC', 'wp-includes');define('WP_CONTENT_DIR', ABSPATH . 'wp-content');define('WP_DEBUG', false);/**#@-*/require_once(ABSPATH . WPINC . '/load.php');require_once(ABSPATH . WPINC . '/compat.php');require_once(ABSPATH . WPINC . '/functions.php');require_once(ABSPATH . WPINC . '/classes.php');require_once(ABSPATH . WPINC . '/version.php');if (!file_exists(ABSPATH . 'wp-config-sample.php'))	wp_die('Sorry, I need a wp-config-sample.php file to work from. Please re-upload this file from your WordPress installation.');$configFile = file(ABSPATH . 'wp-config-sample.php');// Check if wp-config.php has been createdif (file_exists(ABSPATH . 'wp-config.php'))	wp_die("<p>The file 'wp-config.php' already exists. If you need to reset any of the configuration items in this file, please delete it first. You may try <a href='install.php'>installing now</a>.</p>");// Check if wp-config.php exists above the root directory but is not part of another installif (file_exists(ABSPATH . '../wp-config.php') && ! file_exists(ABSPATH . '../wp-settings.php'))	wp_die("<p>The file 'wp-config.php' already exists one level above your WordPress installation. If you need to reset any of the configuration items in this file, please delete it first. You may try <a href='install.php'>installing now</a>.</p>");if ( version_compare( $required_php_version, phpversion(), '>' ) )	wp_die( sprintf( /*WP_I18N_OLD_PHP*/'Your server is running PHP version %1$s but WordPress requires at least %2$s.'/*/WP_I18N_OLD_PHP*/, phpversion(), $required_php_version ) );if ( !extension_loaded('mysql') && !file_exists(ABSPATH . 'wp-content/db.php') )	wp_die( /*WP_I18N_OLD_MYSQL*/'Your PHP installation appears to be missing the MySQL extension which is required by WordPress.'/*/WP_I18N_OLD_MYSQL*/ );if (isset($_GET['step']))	$step = $_GET['step'];else	$step = 0;/** * Display setup wp-config.php file header. * * @ignore * @since 2.3.0 * @package WordPress * @subpackage Installer_WP_Config */function display_header() {	header( 'Content-Type: text/html; charset=utf-8' );?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>WordPress &rsaquo; Setup Configuration File</title><link rel="stylesheet" href="css/install.css" type="text/css" /></head><body><h1 id="logo"><img alt="WordPress" src="images/wordpress-logo.png" /></h1><?php}//end function display_header();switch($step) {	case 0:		display_header();?><p>Welcome to WordPress. Before getting started, we need some information on the database. You will need to know the following items before proceeding.</p><ol>	<li>Database name</li>	<li>Database username</li>	<li>Database password</li>	<li>Database host</li>	<li>Table prefix (if you want to run more than one WordPress in a single database) </li></ol><p><strong>If for any reason this automatic file creation doesn't work, don't worry. All this does is fill in the database information to a configuration file. You may also simply open <code>wp-config-sample.php</code> in a text editor, fill in your information, and save it as <code>wp-config.php</code>. </strong></p><p>In all likelihood, these items were supplied to you by your Web Host. If you do not have this information, then you will need to contact them before you can continue. If you&#8217;re all ready&hellip;</p><p class="step"><a href="setup-config.php?step=1<?php if ( isset( $_GET['noapi'] ) ) echo '&amp;noapi'; ?>" class="button">Let&#8217;s go!</a></p><?php	break;	case 1:		display_header();	?><form method="post" action="setup-config.php?step=2">	<p>Below you should enter your database connection details. If you're not sure about these, contact your host. </p>	<table class="form-table">		<tr>			<th scope="row"><label for="dbname">Database Name</label></th>			<td><input name="dbname" id="dbname" type="text" size="25" value="wordpress" /></td>			<td>The name of the database you want to run WP in. </td>		</tr>		<tr>			<th scope="row"><label for="uname">User Name</label></th>			<td><input name="uname" id="uname" type="text" size="25" value="username" /></td>			<td>Your MySQL username</td>		</tr>		<tr>			<th scope="row"><label for="pwd">Password</label></th>			<td><input name="pwd" id="pwd" type="text" size="25" value="password" /></td>			<td>...and MySQL password.</td>		</tr>		<tr>			<th scope="row"><label for="dbhost">Database Host</label></th>			<td><input name="dbhost" id="dbhost" type="text" size="25" value="localhost" /></td>			<td>You should be able to get this info from your web host, if <code>localhost</code> does not work.</td>		</tr>		<tr>			<th scope="row"><label for="prefix">Table Prefix</label></th>			<td><input name="prefix" id="prefix" type="text" id="prefix" value="wp_" size="25" /></td>			<td>If you want to run multiple WordPress installations in a single database, change this.</td>		</tr>	</table>	<?php if ( isset( $_GET['noapi'] ) ) { ?><input name="noapi" type="hidden" value="true" /><?php } ?>	<p class="step"><input name="submit" type="submit" value="Submit" class="button" /></p></form><?php	break;	case 2:	$dbname  = trim($_POST['dbname']);	$uname   = trim($_POST['uname']);	$passwrd = trim($_POST['pwd']);	$dbhost  = trim($_POST['dbhost']);	$prefix  = trim($_POST['prefix']);	if ( empty($prefix) )		$prefix = 'wp_';	// Validate $prefix: it can only contain letters, numbers and underscores	if ( preg_match( '|[^a-z0-9_]|i', $prefix ) )		wp_die( /*WP_I18N_BAD_PREFIX*/'<strong>ERROR</strong>: "Table Prefix" can only contain numbers, letters, and underscores.'/*/WP_I18N_BAD_PREFIX*/ );	// Test the db connection.	/**#@+	 * @ignore	 */	define('DB_NAME', $dbname);	define('DB_USER', $uname);	define('DB_PASSWORD', $passwrd);	define('DB_HOST', $dbhost);	/**#@-*/	// We'll fail here if the values are no good.	require_wp_db();	if ( !empty($wpdb->error) )		wp_die($wpdb->error->get_error_message());	// Fetch or generate keys and salts.	$no_api = isset( $_POST['noapi'] );	require_once( ABSPATH . WPINC . '/plugin.php' );	require_once( ABSPATH . WPINC . '/l10n.php' );	require_once( ABSPATH . WPINC . '/pomo/translations.php' );	if ( ! $no_api ) {		require_once( ABSPATH . WPINC . '/class-http.php' );		require_once( ABSPATH . WPINC . '/http.php' );		wp_fix_server_vars();		/**#@+		 * @ignore		 */		function get_bloginfo() {			return ( ( is_ssl() ? 'https://' : 'http://' ) . $_SERVER['HTTP_HOST'] . str_replace( $_SERVER['PHP_SELF'], '/wp-admin/setup-config.php', '' ) );		}		/**#@-*/		$secret_keys = wp_remote_get( 'https://api.wordpress.org/secret-key/1.1/salt/' );	}	if ( $no_api || is_wp_error( $secret_keys ) ) {		$secret_keys = array();		require_once( ABSPATH . WPINC . '/pluggable.php' );		for ( $i = 0; $i < 8; $i++ ) {			$secret_keys[] = wp_generate_password( 64, true, true );		}	} else {		$secret_keys = explode( "\n", wp_remote_retrieve_body( $secret_keys ) );		foreach ( $secret_keys as $k => $v ) {			$secret_keys[$k] = substr( $v, 28, 64 );		}	}	$key = 0;	foreach ($configFile as $line_num => $line) {		switch (substr($line,0,16)) {			case "define('DB_NAME'":				$configFile[$line_num] = str_replace("database_name_here", $dbname, $line);				break;			case "define('DB_USER'":				$configFile[$line_num] = str_replace("'username_here'", "'$uname'", $line);				break;			case "define('DB_PASSW":				$configFile[$line_num] = str_replace("'password_here'", "'$passwrd'", $line);				break;			case "define('DB_HOST'":				$configFile[$line_num] = str_replace("localhost", $dbhost, $line);				break;			case '$table_prefix  =':				$configFile[$line_num] = str_replace('wp_', $prefix, $line);				break;			case "define('AUTH_KEY":			case "define('SECURE_A":			case "define('LOGGED_I":			case "define('NONCE_KE":			case "define('AUTH_SAL":			case "define('SECURE_A":			case "define('LOGGED_I":			case "define('NONCE_SA":				$configFile[$line_num] = str_replace('put your unique phrase here', $secret_keys[$key++], $line );				break;		}	}	if ( ! is_writable(ABSPATH) ) :		display_header();?><p>Sorry, but I can't write the <code>wp-config.php</code> file.</p><p>You can create the <code>wp-config.php</code> manually and paste the following text into it.</p><textarea cols="98" rows="15" class="code"><?php		foreach( $configFile as $line ) {			echo htmlentities($line, ENT_COMPAT, 'UTF-8');		}?></textarea><p>After you've done that, click "Run the install."</p><p class="step"><a href="install.php" class="button">Run the install</a></p><?php	else :		$handle = fopen(ABSPATH . 'wp-config.php', 'w');		foreach( $configFile as $line ) {			fwrite($handle, $line);		}		fclose($handle);		chmod(ABSPATH . 'wp-config.php', 0666);		display_header();?><p>All right sparky! You've made it through this part of the installation. WordPress can now communicate with your database. If you are ready, time now to&hellip;</p><p class="step"><a href="install.php" class="button">Run the install</a></p><?php	endif;	break;}?></body></html>
<?php/** * Taxonomy API * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 *///// Taxonomy Registration///** * Creates the initial taxonomies when 'init' action is fired. */function create_initial_taxonomies() {	register_taxonomy( 'category', 'post', array(		'hierarchical' => true,	 	'update_count_callback' => '_update_post_term_count',		'query_var' => false,		'rewrite' => false,		'public' => true,		'show_ui' => true,		'_builtin' => true,	) ) ;	register_taxonomy( 'post_tag', 'post', array(	 	'hierarchical' => false,		'update_count_callback' => '_update_post_term_count',		'query_var' => false,		'rewrite' => false,		'public' => true,		'show_ui' => true,		'_builtin' => true,	) );	register_taxonomy( 'nav_menu', 'nav_menu_item', array(		'hierarchical' => false,		'labels' => array(			'name' => __( 'Navigation Menus' ),			'singular_name' => __( 'Navigation Menu' ),		),		'query_var' => false,		'rewrite' => false,		'show_ui' => false,		'_builtin' => true,		'show_in_nav_menus' => false,	) ) ;	register_taxonomy( 'link_category', 'link', array(		'hierarchical' => false,		'labels' => array(			'name' => __( 'Categories' ),			'singular_name' => __( 'Category' ),			'update_item' => __( 'Update Category' ),		),		'query_var' => false,		'rewrite' => false,		'public' => false,		'show_ui' => false,		'_builtin' => true,	) ) ;}add_action( 'init', 'create_initial_taxonomies', 0 ); // highest priority/** * Get a list of registered taxonomy objects. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * @uses $wp_taxonomies * @see register_taxonomy * * @param array $args An array of key => value arguments to match against the taxonomy objects. * @param string $output The type of output to return, either taxonomy 'names' or 'objects'. 'names' is the default. * @param string $operator The logical operation to perform. 'or' means only one element *  from the array needs to match; 'and' means all elements must match. The default is 'and'. * @return array A list of taxonomy names or objects */function get_taxonomies( $args = array(), $output = 'names', $operator = 'and' ) {	global $wp_taxonomies;	$field = ('names' == $output) ? 'name' : false;	return wp_filter_object_list($wp_taxonomies, $args, $operator, $field);}/** * Return all of the taxonomy names that are of $object_type. * * It appears that this function can be used to find all of the names inside of * $wp_taxonomies global variable. * * <code><?php $taxonomies = get_object_taxonomies('post'); ?></code> Should * result in <code>Array('category', 'post_tag')</code> * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wp_taxonomies * * @param array|string|object $object Name of the type of taxonomy object, or an object (row from posts) * @param string $output The type of output to return, either taxonomy 'names' or 'objects'. 'names' is the default. * @return array The names of all taxonomy of $object_type. */function get_object_taxonomies($object, $output = 'names') {	global $wp_taxonomies;	if ( is_object($object) ) {		if ( $object->post_type == 'attachment' )			return get_attachment_taxonomies($object);		$object = $object->post_type;	}	$object = (array) $object;	$taxonomies = array();	foreach ( (array) $wp_taxonomies as $tax_name => $tax_obj ) {		if ( array_intersect($object, (array) $tax_obj->object_type) ) {			if ( 'names' == $output )				$taxonomies[] = $tax_name;			else				$taxonomies[ $tax_name ] = $tax_obj;		}	}	return $taxonomies;}/** * Retrieves the taxonomy object of $taxonomy. * * The get_taxonomy function will first check that the parameter string given * is a taxonomy object and if it is, it will return it. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wp_taxonomies * @uses taxonomy_exists() Checks whether taxonomy exists * * @param string $taxonomy Name of taxonomy object to return * @return object|bool The Taxonomy Object or false if $taxonomy doesn't exist */function get_taxonomy( $taxonomy ) {	global $wp_taxonomies;	if ( ! taxonomy_exists( $taxonomy ) )		return false;	return $wp_taxonomies[$taxonomy];}/** * Checks that the taxonomy name exists. * * Formerly is_taxonomy(), introduced in 2.3.0. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * * @uses $wp_taxonomies * * @param string $taxonomy Name of taxonomy object * @return bool Whether the taxonomy exists. */function taxonomy_exists( $taxonomy ) {	global $wp_taxonomies;	return isset( $wp_taxonomies[$taxonomy] );}/** * Whether the taxonomy object is hierarchical. * * Checks to make sure that the taxonomy is an object first. Then Gets the * object, and finally returns the hierarchical value in the object. * * A false return value might also mean that the taxonomy does not exist. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses taxonomy_exists() Checks whether taxonomy exists * @uses get_taxonomy() Used to get the taxonomy object * * @param string $taxonomy Name of taxonomy object * @return bool Whether the taxonomy is hierarchical */function is_taxonomy_hierarchical($taxonomy) {	if ( ! taxonomy_exists($taxonomy) )		return false;	$taxonomy = get_taxonomy($taxonomy);	return $taxonomy->hierarchical;}/** * Create or modify a taxonomy object. Do not use before init. * * A simple function for creating or modifying a taxonomy object based on the * parameters given. The function will accept an array (third optional * parameter), along with strings for the taxonomy name and another string for * the object type. * * Nothing is returned, so expect error maybe or use taxonomy_exists() to check * whether taxonomy exists. * * Optional $args contents: * * label - Name of the taxonomy shown in the menu. Usually plural. If not set, labels['name'] will be used. * * hierarchical - has some defined purpose at other parts of the API and is a * boolean value. * * update_count_callback - works much like a hook, in that it will be called * when the count is updated. * * rewrite - false to prevent rewrite, or array('slug'=>$slug) to customize * permastruct; default will use $taxonomy as slug. * * query_var - false to prevent queries, or string to customize query var * (?$query_var=$term); default will use $taxonomy as query var. * * public - If the taxonomy should be publically queryable; //@TODO not implemented. * defaults to true. * * show_ui - If the WordPress UI admin tags UI should apply to this taxonomy; * defaults to public. * * show_in_nav_menus - true makes this taxonomy available for selection in navigation menus. * Defaults to public. * * show_tagcloud - false to prevent the taxonomy being listed in the Tag Cloud Widget; * defaults to show_ui which defalts to public. * * labels - An array of labels for this taxonomy. You can see accepted values in {@link get_taxonomy_labels()}. By default tag labels are used for non-hierarchical types and category labels for hierarchical ones. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wp_taxonomies Inserts new taxonomy object into the list * @uses $wp_rewrite Adds rewrite tags and permastructs * @uses $wp Adds query vars * * @param string $taxonomy Name of taxonomy object * @param array|string $object_type Name of the object type for the taxonomy object. * @param array|string $args See above description for the two keys values. */function register_taxonomy( $taxonomy, $object_type, $args = array() ) {	global $wp_taxonomies, $wp_rewrite, $wp;	if ( ! is_array($wp_taxonomies) )		$wp_taxonomies = array();	$defaults = array(	'hierarchical' => false,						'update_count_callback' => '',						'rewrite' => true,						'query_var' => $taxonomy,						'public' => true,						'show_ui' => null,						'show_tagcloud' => null,						'_builtin' => false,						'labels' => array(),						'capabilities' => array(),						'show_in_nav_menus' => null,					);	$args = wp_parse_args($args, $defaults);	if ( false !== $args['query_var'] && !empty($wp) ) {		if ( true === $args['query_var'] )			$args['query_var'] = $taxonomy;		$args['query_var'] = sanitize_title_with_dashes($args['query_var']);		$wp->add_query_var($args['query_var']);	}	if ( false !== $args['rewrite'] && '' != get_option('permalink_structure') ) {		$args['rewrite'] = wp_parse_args($args['rewrite'], array(			'slug' => sanitize_title_with_dashes($taxonomy),			'with_front' => true,		));		$wp_rewrite->add_rewrite_tag("%$taxonomy%", '([^/]+)', $args['query_var'] ? "{$args['query_var']}=" : "taxonomy=$taxonomy&term=");		$wp_rewrite->add_permastruct($taxonomy, "{$args['rewrite']['slug']}/%$taxonomy%", $args['rewrite']['with_front']);	}	if ( is_null($args['show_ui']) )		$args['show_ui'] = $args['public'];	// Whether to show this type in nav-menus.php. Defaults to the setting for public.	if ( null === $args['show_in_nav_menus'] )		$args['show_in_nav_menus'] = $args['public'];	if ( is_null($args['show_tagcloud']) )		$args['show_tagcloud'] = $args['show_ui'];	$default_caps = array(		'manage_terms' => 'manage_categories',		'edit_terms'   => 'manage_categories',		'delete_terms' => 'manage_categories',		'assign_terms' => 'edit_posts',	);	$args['cap'] = (object) array_merge( $default_caps, $args['capabilities'] );	unset( $args['capabilities'] );	$args['name'] = $taxonomy;	$args['object_type'] = (array) $object_type;	$args['labels'] = get_taxonomy_labels( (object) $args );	$args['label'] = $args['labels']->name;	$wp_taxonomies[$taxonomy] = (object) $args;	// register callback handling for metabox 	add_filter('wp_ajax_add-'.$taxonomy, '_wp_ajax_add_hierarchical_term');}/** * Builds an object with all taxonomy labels out of a taxonomy object * * Accepted keys of the label array in the taxonomy object: * - name - general name for the taxonomy, usually plural. The same as and overriden by $tax->label. Default is Post Tags/Categories * - singular_name - name for one object of this taxonomy. Default is Post Tag/Category * - search_items - Default is Search Tags/Search Categories * - popular_items - This string isn't used on hierarchical taxonomies. Default is Popular Tags * - all_items - Default is All Tags/All Categories * - parent_item - This string isn't used on non-hierarchical taxonomies. In hierarchical ones the default is Parent Category * - parent_item_colon - The same as <code>parent_item</code>, but with colon <code>:</code> in the end * - edit_item - Default is Edit Tag/Edit Category * - update_item - Default is Update Tag/Update Category * - add_new_item - Default is Add New Tag/Add New Category * - new_item_name - Default is New Tag Name/New Category Name * - separate_items_with_commas - This string isn't used on hierarchical taxonomies. Default is "Separate tags with commas," used in the meta box. * - add_or_remove_items - This string isn't used on hierarchical taxonomies. Default is "Add or remove tags," used in the meta box when JavaScript is disabled. * - choose_from_most_used - This string isn't used on hierarchical taxonomies. Default is "Choose from the most used tags," used in the meta box. * * Above, the first default value is for non-hierarchical taxonomies (like tags) and the second one is for hierarchical taxonomies (like categories.) * * @since 3.0.0 * @param object $tax Taxonomy object * @return object object with all the labels as member variables */function get_taxonomy_labels( $tax ) {	if ( isset( $tax->helps ) && empty( $tax->labels['separate_items_with_commas'] ) )		$tax->labels['separate_items_with_commas'] = $tax->helps;	$nohier_vs_hier_defaults = array(		'name' => array( _x( 'Post Tags', 'taxonomy general name' ), _x( 'Categories', 'taxonomy general name' ) ),		'singular_name' => array( _x( 'Post Tag', 'taxonomy singular name' ), _x( 'Category', 'taxonomy singular name' ) ),		'search_items' => array( __( 'Search Tags' ), __( 'Search Categories' ) ),		'popular_items' => array( __( 'Popular Tags' ), null ),		'all_items' => array( __( 'All Tags' ), __( 'All Categories' ) ),		'parent_item' => array( null, __( 'Parent Category' ) ),		'parent_item_colon' => array( null, __( 'Parent Category:' ) ),		'edit_item' => array( __( 'Edit Tag' ), __( 'Edit Category' ) ),		'update_item' => array( __( 'Update Tag' ), __( 'Update Category' ) ),		'add_new_item' => array( __( 'Add New Tag' ), __( 'Add New Category' ) ),		'new_item_name' => array( __( 'New Tag Name' ), __( 'New Category Name' ) ),		'separate_items_with_commas' => array( __( 'Separate tags with commas' ), null ),		'add_or_remove_items' => array( __( 'Add or remove tags' ), null ),		'choose_from_most_used' => array( __( 'Choose from the most used tags' ), null ),	);	return _get_custom_object_labels( $tax, $nohier_vs_hier_defaults );}/** * Add an already registered taxonomy to an object type. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * @uses $wp_taxonomies Modifies taxonomy object * * @param string $taxonomy Name of taxonomy object * @param array|string $object_type Name of the object type * @return bool True if successful, false if not */function register_taxonomy_for_object_type( $taxonomy, $object_type) {	global $wp_taxonomies;	if ( !isset($wp_taxonomies[$taxonomy]) )		return false;	if ( ! get_post_type_object($object_type) )		return false;	$wp_taxonomies[$taxonomy]->object_type[] = $object_type;	return true;}//// Term API///** * Retrieve object_ids of valid taxonomy and term. * * The strings of $taxonomies must exist before this function will continue. On * failure of finding a valid taxonomy, it will return an WP_Error class, kind * of like Exceptions in PHP 5, except you can't catch them. Even so, you can * still test for the WP_Error class and get the error message. * * The $terms aren't checked the same as $taxonomies, but still need to exist * for $object_ids to be returned. * * It is possible to change the order that object_ids is returned by either * using PHP sort family functions or using the database by using $args with * either ASC or DESC array. The value should be in the key named 'order'. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses wp_parse_args() Creates an array from string $args. * * @param int|array $term_ids Term id or array of term ids of terms that will be used * @param string|array $taxonomies String of taxonomy name or Array of string values of taxonomy names * @param array|string $args Change the order of the object_ids, either ASC or DESC * @return WP_Error|array If the taxonomy does not exist, then WP_Error will be returned. On success *	the array can be empty meaning that there are no $object_ids found or it will return the $object_ids found. */function get_objects_in_term( $term_ids, $taxonomies, $args = array() ) {	global $wpdb;	if ( ! is_array( $term_ids ) )		$term_ids = array( $term_ids );	if ( ! is_array( $taxonomies ) )		$taxonomies = array( $taxonomies );	foreach ( (array) $taxonomies as $taxonomy ) {		if ( ! taxonomy_exists( $taxonomy ) )			return new WP_Error( 'invalid_taxonomy', __( 'Invalid Taxonomy' ) );	}	$defaults = array( 'order' => 'ASC' );	$args = wp_parse_args( $args, $defaults );	extract( $args, EXTR_SKIP );	$order = ( 'desc' == strtolower( $order ) ) ? 'DESC' : 'ASC';	$term_ids = array_map('intval', $term_ids );	$taxonomies = "'" . implode( "', '", $taxonomies ) . "'";	$term_ids = "'" . implode( "', '", $term_ids ) . "'";	$object_ids = $wpdb->get_col("SELECT tr.object_id FROM $wpdb->term_relationships AS tr INNER JOIN $wpdb->term_taxonomy AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy IN ($taxonomies) AND tt.term_id IN ($term_ids) ORDER BY tr.object_id $order");	if ( ! $object_ids )		return array();	return $object_ids;}/** * Get all Term data from database by Term ID. * * The usage of the get_term function is to apply filters to a term object. It * is possible to get a term object from the database before applying the * filters. * * $term ID must be part of $taxonomy, to get from the database. Failure, might * be able to be captured by the hooks. Failure would be the same value as $wpdb * returns for the get_row method. * * There are two hooks, one is specifically for each term, named 'get_term', and * the second is for the taxonomy name, 'term_$taxonomy'. Both hooks gets the * term object, and the taxonomy name as parameters. Both hooks are expected to * return a Term object. * * 'get_term' hook - Takes two parameters the term Object and the taxonomy name. * Must return term object. Used in get_term() as a catch-all filter for every * $term. * * 'get_$taxonomy' hook - Takes two parameters the term Object and the taxonomy * name. Must return term object. $taxonomy will be the taxonomy name, so for * example, if 'category', it would be 'get_category' as the filter name. Useful * for custom taxonomies or plugging into default taxonomies. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses sanitize_term() Cleanses the term based on $filter context before returning. * @see sanitize_term_field() The $context param lists the available values for get_term_by() $filter param. * * @param int|object $term If integer, will get from database. If object will apply filters and return $term. * @param string $taxonomy Taxonomy name that $term is part of. * @param string $output Constant OBJECT, ARRAY_A, or ARRAY_N * @param string $filter Optional, default is raw or no WordPress defined filter will applied. * @return mixed|null|WP_Error Term Row from database. Will return null if $term is empty. If taxonomy does not * exist then WP_Error will be returned. */function &get_term($term, $taxonomy, $output = OBJECT, $filter = 'raw') {	global $wpdb;	$null = null;	if ( empty($term) ) {		$error = new WP_Error('invalid_term', __('Empty Term'));		return $error;	}	if ( ! taxonomy_exists($taxonomy) ) {		$error = new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));		return $error;	}	if ( is_object($term) && empty($term->filter) ) {		wp_cache_add($term->term_id, $term, $taxonomy);		$_term = $term;	} else {		if ( is_object($term) )			$term = $term->term_id;		$term = (int) $term;		if ( ! $_term = wp_cache_get($term, $taxonomy) ) {			$_term = $wpdb->get_row( $wpdb->prepare( "SELECT t.*, tt.* FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy = %s AND t.term_id = %s LIMIT 1", $taxonomy, $term) );			if ( ! $_term )				return $null;			wp_cache_add($term, $_term, $taxonomy);		}	}	$_term = apply_filters('get_term', $_term, $taxonomy);	$_term = apply_filters("get_$taxonomy", $_term, $taxonomy);	$_term = sanitize_term($_term, $taxonomy, $filter);	if ( $output == OBJECT ) {		return $_term;	} elseif ( $output == ARRAY_A ) {		$__term = get_object_vars($_term);		return $__term;	} elseif ( $output == ARRAY_N ) {		$__term = array_values(get_object_vars($_term));		return $__term;	} else {		return $_term;	}}/** * Get all Term data from database by Term field and data. * * Warning: $value is not escaped for 'name' $field. You must do it yourself, if * required. * * The default $field is 'id', therefore it is possible to also use null for * field, but not recommended that you do so. * * If $value does not exist, the return value will be false. If $taxonomy exists * and $field and $value combinations exist, the Term will be returned. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses sanitize_term() Cleanses the term based on $filter context before returning. * @see sanitize_term_field() The $context param lists the available values for get_term_by() $filter param. * * @param string $field Either 'slug', 'name', or 'id' * @param string|int $value Search for this term value * @param string $taxonomy Taxonomy Name * @param string $output Constant OBJECT, ARRAY_A, or ARRAY_N * @param string $filter Optional, default is raw or no WordPress defined filter will applied. * @return mixed Term Row from database. Will return false if $taxonomy does not exist or $term was not found. */function get_term_by($field, $value, $taxonomy, $output = OBJECT, $filter = 'raw') {	global $wpdb;	if ( ! taxonomy_exists($taxonomy) )		return false;	if ( 'slug' == $field ) {		$field = 't.slug';		$value = sanitize_title($value);		if ( empty($value) )			return false;	} else if ( 'name' == $field ) {		// Assume already escaped		$value = stripslashes($value);		$field = 't.name';	} else {		return get_term( (int) $value, $taxonomy, $output, $filter);	}	$term = $wpdb->get_row( $wpdb->prepare( "SELECT t.*, tt.* FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy = %s AND $field = %s LIMIT 1", $taxonomy, $value) );	if ( !$term )		return false;	wp_cache_add($term->term_id, $term, $taxonomy);	$term = apply_filters('get_term', $term, $taxonomy);	$term = apply_filters("get_$taxonomy", $term, $taxonomy);	$term = sanitize_term($term, $taxonomy, $filter);	if ( $output == OBJECT ) {		return $term;	} elseif ( $output == ARRAY_A ) {		return get_object_vars($term);	} elseif ( $output == ARRAY_N ) {		return array_values(get_object_vars($term));	} else {		return $term;	}}/** * Merge all term children into a single array of their IDs. * * This recursive function will merge all of the children of $term into the same * array of term IDs. Only useful for taxonomies which are hierarchical. * * Will return an empty array if $term does not exist in $taxonomy. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses _get_term_hierarchy() * @uses get_term_children() Used to get the children of both $taxonomy and the parent $term * * @param string $term ID of Term to get children * @param string $taxonomy Taxonomy Name * @return array|WP_Error List of Term Objects. WP_Error returned if $taxonomy does not exist */function get_term_children( $term_id, $taxonomy ) {	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));	$term_id = intval( $term_id );	$terms = _get_term_hierarchy($taxonomy);	if ( ! isset($terms[$term_id]) )		return array();	$children = $terms[$term_id];	foreach ( (array) $terms[$term_id] as $child ) {		if ( isset($terms[$child]) )			$children = array_merge($children, get_term_children($child, $taxonomy));	}	return $children;}/** * Get sanitized Term field. * * Does checks for $term, based on the $taxonomy. The function is for contextual * reasons and for simplicity of usage. See sanitize_term_field() for more * information. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses sanitize_term_field() Passes the return value in sanitize_term_field on success. * * @param string $field Term field to fetch * @param int $term Term ID * @param string $taxonomy Taxonomy Name * @param string $context Optional, default is display. Look at sanitize_term_field() for available options. * @return mixed Will return an empty string if $term is not an object or if $field is not set in $term. */function get_term_field( $field, $term, $taxonomy, $context = 'display' ) {	$term = (int) $term;	$term = get_term( $term, $taxonomy );	if ( is_wp_error($term) )		return $term;	if ( !is_object($term) )		return '';	if ( !isset($term->$field) )		return '';	return sanitize_term_field($field, $term->$field, $term->term_id, $taxonomy, $context);}/** * Sanitizes Term for editing. * * Return value is sanitize_term() and usage is for sanitizing the term for * editing. Function is for contextual and simplicity. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses sanitize_term() Passes the return value on success * * @param int|object $id Term ID or Object * @param string $taxonomy Taxonomy Name * @return mixed|null|WP_Error Will return empty string if $term is not an object. */function get_term_to_edit( $id, $taxonomy ) {	$term = get_term( $id, $taxonomy );	if ( is_wp_error($term) )		return $term;	if ( !is_object($term) )		return '';	return sanitize_term($term, $taxonomy, 'edit');}/** * Retrieve the terms in a given taxonomy or list of taxonomies. * * You can fully inject any customizations to the query before it is sent, as * well as control the output with a filter. * * The 'get_terms' filter will be called when the cache has the term and will * pass the found term along with the array of $taxonomies and array of $args. * This filter is also called before the array of terms is passed and will pass * the array of terms, along with the $taxonomies and $args. * * The 'list_terms_exclusions' filter passes the compiled exclusions along with * the $args. * * The 'get_terms_orderby' filter passes the ORDER BY clause for the query * along with the $args array. * * The 'get_terms_fields' filter passes the fields for the SELECT query * along with the $args array. * * The list of arguments that $args can contain, which will overwrite the defaults: * * orderby - Default is 'name'. Can be name, count, term_group, slug or nothing * (will use term_id), Passing a custom value other than these will cause it to * order based on the custom value. * * order - Default is ASC. Can use DESC. * * hide_empty - Default is true. Will not return empty terms, which means * terms whose count is 0 according to the given taxonomy. * * exclude - Default is an empty array.  An array, comma- or space-delimited string * of term ids to exclude from the return array.  If 'include' is non-empty, * 'exclude' is ignored. * * exclude_tree - Default is an empty array.  An array, comma- or space-delimited * string of term ids to exclude from the return array, along with all of their * descendant terms according to the primary taxonomy.  If 'include' is non-empty, * 'exclude_tree' is ignored. * * include - Default is an empty array.  An array, comma- or space-delimited string * of term ids to include in the return array. * * number - The maximum number of terms to return.  Default is to return them all. * * offset - The number by which to offset the terms query. * * fields - Default is 'all', which returns an array of term objects. * If 'fields' is 'ids' or 'names', returns an array of * integers or strings, respectively. * * slug - Returns terms whose "slug" matches this value. Default is empty string. * * hierarchical - Whether to include terms that have non-empty descendants * (even if 'hide_empty' is set to true). * * search - Returned terms' names will contain the value of 'search', * case-insensitive.  Default is an empty string. * * name__like - Returned terms' names will begin with the value of 'name__like', * case-insensitive. Default is empty string. * * The argument 'pad_counts', if set to true will include the quantity of a term's * children in the quantity of each term's "count" object variable. * * The 'get' argument, if set to 'all' instead of its default empty string, * returns terms regardless of ancestry or whether the terms are empty. * * The 'child_of' argument, when used, should be set to the integer of a term ID.  Its default * is 0.  If set to a non-zero value, all returned terms will be descendants * of that term according to the given taxonomy.  Hence 'child_of' is set to 0 * if more than one taxonomy is passed in $taxonomies, because multiple taxonomies * make term ancestry ambiguous. * * The 'parent' argument, when used, should be set to the integer of a term ID.  Its default is * the empty string '', which has a different meaning from the integer 0. * If set to an integer value, all returned terms will have as an immediate * ancestor the term whose ID is specified by that integer according to the given taxonomy. * The 'parent' argument is different from 'child_of' in that a term X is considered a 'parent' * of term Y only if term X is the father of term Y, not its grandfather or great-grandfather, etc. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses wp_parse_args() Merges the defaults with those defined by $args and allows for strings. * * @param string|array Taxonomy name or list of Taxonomy names * @param string|array $args The values of what to search for when returning terms * @return array|WP_Error List of Term Objects and their children. Will return WP_Error, if any of $taxonomies do not exist. */function &get_terms($taxonomies, $args = '') {	global $wpdb;	$empty_array = array();	$single_taxonomy = false;	if ( !is_array($taxonomies) ) {		$single_taxonomy = true;		$taxonomies = array($taxonomies);	}	foreach ( (array) $taxonomies as $taxonomy ) {		if ( ! taxonomy_exists($taxonomy) ) {			$error = & new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));			return $error;		}	}	$in_taxonomies = "'" . implode("', '", $taxonomies) . "'";	$defaults = array('orderby' => 'name', 'order' => 'ASC',		'hide_empty' => true, 'exclude' => array(), 'exclude_tree' => array(), 'include' => array(),		'number' => '', 'fields' => 'all', 'slug' => '', 'parent' => '',		'hierarchical' => true, 'child_of' => 0, 'get' => '', 'name__like' => '',		'pad_counts' => false, 'offset' => '', 'search' => '');	$args = wp_parse_args( $args, $defaults );	$args['number'] = absint( $args['number'] );	$args['offset'] = absint( $args['offset'] );	if ( !$single_taxonomy || !is_taxonomy_hierarchical($taxonomies[0]) ||		'' !== $args['parent'] ) {		$args['child_of'] = 0;		$args['hierarchical'] = false;		$args['pad_counts'] = false;	}	if ( 'all' == $args['get'] ) {		$args['child_of'] = 0;		$args['hide_empty'] = 0;		$args['hierarchical'] = false;		$args['pad_counts'] = false;	}	extract($args, EXTR_SKIP);	if ( $child_of ) {		$hierarchy = _get_term_hierarchy($taxonomies[0]);		if ( !isset($hierarchy[$child_of]) )			return $empty_array;	}	if ( $parent ) {		$hierarchy = _get_term_hierarchy($taxonomies[0]);		if ( !isset($hierarchy[$parent]) )			return $empty_array;	}	// $args can be whatever, only use the args defined in defaults to compute the key	$filter_key = ( has_filter('list_terms_exclusions') ) ? serialize($GLOBALS['wp_filter']['list_terms_exclusions']) : '';	$key = md5( serialize( compact(array_keys($defaults)) ) . serialize( $taxonomies ) . $filter_key );	$last_changed = wp_cache_get('last_changed', 'terms');	if ( !$last_changed ) {		$last_changed = time();		wp_cache_set('last_changed', $last_changed, 'terms');	}	$cache_key = "get_terms:$key:$last_changed";	$cache = wp_cache_get( $cache_key, 'terms' );	if ( false !== $cache ) {		$cache = apply_filters('get_terms', $cache, $taxonomies, $args);		return $cache;	}	$_orderby = strtolower($orderby);	if ( 'count' == $_orderby )		$orderby = 'tt.count';	else if ( 'name' == $_orderby )		$orderby = 't.name';	else if ( 'slug' == $_orderby )		$orderby = 't.slug';	else if ( 'term_group' == $_orderby )		$orderby = 't.term_group';	else if ( 'none' == $_orderby )		$orderby = '';	elseif ( empty($_orderby) || 'id' == $_orderby )		$orderby = 't.term_id';	$orderby = apply_filters( 'get_terms_orderby', $orderby, $args );	if ( !empty($orderby) )		$orderby = "ORDER BY $orderby";	else		$order = '';	$where = '';	$inclusions = '';	if ( !empty($include) ) {		$exclude = '';		$exclude_tree = '';		$interms = wp_parse_id_list($include);		foreach ( $interms as $interm ) {			if ( empty($inclusions) )				$inclusions = ' AND ( t.term_id = ' . intval($interm) . ' ';			else				$inclusions .= ' OR t.term_id = ' . intval($interm) . ' ';		}	}	if ( !empty($inclusions) )		$inclusions .= ')';	$where .= $inclusions;	$exclusions = '';	if ( !empty( $exclude_tree ) ) {		$excluded_trunks = wp_parse_id_list($exclude_tree);		foreach ( $excluded_trunks as $extrunk ) {			$excluded_children = (array) get_terms($taxonomies[0], array('child_of' => intval($extrunk), 'fields' => 'ids'));			$excluded_children[] = $extrunk;			foreach( $excluded_children as $exterm ) {				if ( empty($exclusions) )					$exclusions = ' AND ( t.term_id <> ' . intval($exterm) . ' ';				else					$exclusions .= ' AND t.term_id <> ' . intval($exterm) . ' ';			}		}	}	if ( !empty($exclude) ) {		$exterms = wp_parse_id_list($exclude);		foreach ( $exterms as $exterm ) {			if ( empty($exclusions) )				$exclusions = ' AND ( t.term_id <> ' . intval($exterm) . ' ';			else				$exclusions .= ' AND t.term_id <> ' . intval($exterm) . ' ';		}	}	if ( !empty($exclusions) )		$exclusions .= ')';	$exclusions = apply_filters('list_terms_exclusions', $exclusions, $args );	$where .= $exclusions;	if ( !empty($slug) ) {		$slug = sanitize_title($slug);		$where .= " AND t.slug = '$slug'";	}	if ( !empty($name__like) )		$where .= " AND t.name LIKE '{$name__like}%'";	if ( '' !== $parent ) {		$parent = (int) $parent;		$where .= " AND tt.parent = '$parent'";	}	if ( $hide_empty && !$hierarchical )		$where .= ' AND tt.count > 0';	// don't limit the query results when we have to descend the family tree	if ( ! empty($number) && ! $hierarchical && empty( $child_of ) && '' === $parent ) {		if ( $offset )			$limit = 'LIMIT ' . $offset . ',' . $number;		else			$limit = 'LIMIT ' . $number;	} else {		$limit = '';	}	if ( !empty($search) ) {		$search = like_escape($search);		$where .= " AND (t.name LIKE '%$search%')";	}	$selects = array();	switch ( $fields ) { 		case 'all': 			$selects = array('t.*', 'tt.*'); 			break; 		case 'ids':		case 'id=>parent': 			$selects = array('t.term_id', 'tt.parent', 'tt.count'); 			break; 		case 'names': 			$selects = array('t.term_id', 'tt.parent', 'tt.count', 't.name'); 			break; 		case 'count':			$orderby = '';			$order = ''; 			$selects = array('COUNT(*)'); 	}    $select_this = implode(', ', apply_filters( 'get_terms_fields', $selects, $args ));	$query = "SELECT $select_this FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy IN ($in_taxonomies) $where $orderby $order $limit";	if ( 'count' == $fields ) {		$term_count = $wpdb->get_var($query);		return $term_count;	}	$terms = $wpdb->get_results($query);	if ( 'all' == $fields ) {		update_term_cache($terms);	}	if ( empty($terms) ) {		wp_cache_add( $cache_key, array(), 'terms' );		$terms = apply_filters('get_terms', array(), $taxonomies, $args);		return $terms;	}	if ( $child_of ) {		$children = _get_term_hierarchy($taxonomies[0]);		if ( ! empty($children) )			$terms = & _get_term_children($child_of, $terms, $taxonomies[0]);	}	// Update term counts to include children.	if ( $pad_counts && 'all' == $fields )		_pad_term_counts($terms, $taxonomies[0]);	// Make sure we show empty categories that have children.	if ( $hierarchical && $hide_empty && is_array($terms) ) {		foreach ( $terms as $k => $term ) {			if ( ! $term->count ) {				$children = _get_term_children($term->term_id, $terms, $taxonomies[0]);				if ( is_array($children) )					foreach ( $children as $child )						if ( $child->count )							continue 2;				// It really is empty				unset($terms[$k]);			}		}	}	reset ( $terms );	$_terms = array();	if ( 'id=>parent' == $fields ) {		while ( $term = array_shift($terms) )			$_terms[$term->term_id] = $term->parent;		$terms = $_terms;	} elseif ( 'ids' == $fields ) {		while ( $term = array_shift($terms) )			$_terms[] = $term->term_id;		$terms = $_terms;	} elseif ( 'names' == $fields ) {		while ( $term = array_shift($terms) )			$_terms[] = $term->name;		$terms = $_terms;	}	if ( 0 < $number && intval(@count($terms)) > $number ) {		$terms = array_slice($terms, $offset, $number);	}	wp_cache_add( $cache_key, $terms, 'terms' );	$terms = apply_filters('get_terms', $terms, $taxonomies, $args);	return $terms;}/** * Check if Term exists. * * Returns the index of a defined term, or 0 (false) if the term doesn't exist. * * Formerly is_term(), introduced in 2.3.0. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * * @uses $wpdb * * @param int|string $term The term to check * @param string $taxonomy The taxonomy name to use * @param int $parent ID of parent term under which to confine the exists search. * @return mixed Get the term id or Term Object, if exists. */function term_exists($term, $taxonomy = '', $parent = 0) {	global $wpdb;	$select = "SELECT term_id FROM $wpdb->terms as t WHERE ";	$tax_select = "SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy as tt ON tt.term_id = t.term_id WHERE ";	if ( is_int($term) ) {		if ( 0 == $term )			return 0;		$where = 't.term_id = %d';		if ( !empty($taxonomy) )			return $wpdb->get_row( $wpdb->prepare( $tax_select . $where . " AND tt.taxonomy = %s", $term, $taxonomy ), ARRAY_A );		else			return $wpdb->get_var( $wpdb->prepare( $select . $where, $term ) );	}	$term = trim( stripslashes( $term ) );	if ( '' === $slug = sanitize_title($term) )		return 0;	$where = 't.slug = %s';	$else_where = 't.name = %s';	$where_fields = array($slug);	$else_where_fields = array($term);	if ( !empty($taxonomy) ) {		$parent = (int) $parent;		if ( $parent > 0 ) {			$where_fields[] = $parent;			$else_where_fields[] = $parent;			$where .= ' AND tt.parent = %d';			$else_where .= ' AND tt.parent = %d';		}		$where_fields[] = $taxonomy;		$else_where_fields[] = $taxonomy;		if ( $result = $wpdb->get_row( $wpdb->prepare("SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy as tt ON tt.term_id = t.term_id WHERE $where AND tt.taxonomy = %s", $where_fields), ARRAY_A) )			return $result;		return $wpdb->get_row( $wpdb->prepare("SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy as tt ON tt.term_id = t.term_id WHERE $else_where AND tt.taxonomy = %s", $else_where_fields), ARRAY_A);	}	if ( $result = $wpdb->get_var( $wpdb->prepare("SELECT term_id FROM $wpdb->terms as t WHERE $where", $where_fields) ) )		return $result;	return $wpdb->get_var( $wpdb->prepare("SELECT term_id FROM $wpdb->terms as t WHERE $else_where", $else_where_fields) );}/** * Sanitize Term all fields. * * Relys on sanitize_term_field() to sanitize the term. The difference is that * this function will sanitize <strong>all</strong> fields. The context is based * on sanitize_term_field(). * * The $term is expected to be either an array or an object. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses sanitize_term_field Used to sanitize all fields in a term * * @param array|object $term The term to check * @param string $taxonomy The taxonomy name to use * @param string $context Default is 'display'. * @return array|object Term with all fields sanitized */function sanitize_term($term, $taxonomy, $context = 'display') {	if ( 'raw' == $context )		return $term;	$fields = array('term_id', 'name', 'description', 'slug', 'count', 'parent', 'term_group');	$do_object = false;	if ( is_object($term) )		$do_object = true;	$term_id = $do_object ? $term->term_id : (isset($term['term_id']) ? $term['term_id'] : 0);	foreach ( (array) $fields as $field ) {		if ( $do_object ) {			if ( isset($term->$field) )				$term->$field = sanitize_term_field($field, $term->$field, $term_id, $taxonomy, $context);		} else {			if ( isset($term[$field]) )				$term[$field] = sanitize_term_field($field, $term[$field], $term_id, $taxonomy, $context);		}	}	if ( $do_object )		$term->filter = $context;	else		$term['filter'] = $context;	return $term;}/** * Cleanse the field value in the term based on the context. * * Passing a term field value through the function should be assumed to have * cleansed the value for whatever context the term field is going to be used. * * If no context or an unsupported context is given, then default filters will * be applied. * * There are enough filters for each context to support a custom filtering * without creating your own filter function. Simply create a function that * hooks into the filter you need. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * * @param string $field Term field to sanitize * @param string $value Search for this term value * @param int $term_id Term ID * @param string $taxonomy Taxonomy Name * @param string $context Either edit, db, display, attribute, or js. * @return mixed sanitized field */function sanitize_term_field($field, $value, $term_id, $taxonomy, $context) {	if ( 'parent' == $field  || 'term_id' == $field || 'count' == $field || 'term_group' == $field ) {		$value = (int) $value;		if ( $value < 0 )			$value = 0;	}	if ( 'raw' == $context )		return $value;	if ( 'edit' == $context ) {		$value = apply_filters("edit_term_$field", $value, $term_id, $taxonomy);		$value = apply_filters("edit_${taxonomy}_$field", $value, $term_id);		if ( 'description' == $field )			$value = format_to_edit($value);		else			$value = esc_attr($value);	} else if ( 'db' == $context ) {		$value = apply_filters("pre_term_$field", $value, $taxonomy);		$value = apply_filters("pre_${taxonomy}_$field", $value);		// Back compat filters		if ( 'slug' == $field )			$value = apply_filters('pre_category_nicename', $value);	} else if ( 'rss' == $context ) {		$value = apply_filters("term_${field}_rss", $value, $taxonomy);		$value = apply_filters("${taxonomy}_${field}_rss", $value);	} else {		// Use display filters by default.		$value = apply_filters("term_$field", $value, $term_id, $taxonomy, $context);		$value = apply_filters("${taxonomy}_$field", $value, $term_id, $context);	}	if ( 'attribute' == $context )		$value = esc_attr($value);	else if ( 'js' == $context )		$value = esc_js($value);	return $value;}/** * Count how many terms are in Taxonomy. * * Default $args is 'hide_empty' which can be 'hide_empty=true' or array('hide_empty' => true). * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses get_terms() * @uses wp_parse_args() Turns strings into arrays and merges defaults into an array. * * @param string $taxonomy Taxonomy name * @param array|string $args Overwrite defaults. See get_terms() * @return int How many terms are in $taxonomy */function wp_count_terms( $taxonomy, $args = array() ) {	$defaults = array('hide_empty' => false);	$args = wp_parse_args($args, $defaults);	// backwards compatibility	if ( isset($args['ignore_empty']) ) {		$args['hide_empty'] = $args['ignore_empty'];		unset($args['ignore_empty']);	}	$args['fields'] = 'count';	return get_terms($taxonomy, $args);}/** * Will unlink the term from the taxonomy. * * Will remove the term's relationship to the taxonomy, not the term or taxonomy * itself. The term and taxonomy will still exist. Will require the term's * object ID to perform the operation. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int $object_id The term Object Id that refers to the term * @param string|array $taxonomy List of Taxonomy Names or single Taxonomy name. */function wp_delete_object_term_relationships( $object_id, $taxonomies ) {	global $wpdb;	$object_id = (int) $object_id;	if ( !is_array($taxonomies) )		$taxonomies = array($taxonomies);	foreach ( (array) $taxonomies as $taxonomy ) {		$tt_ids = wp_get_object_terms($object_id, $taxonomy, array('fields' => 'tt_ids'));		$in_tt_ids = "'" . implode("', '", $tt_ids) . "'";		do_action( 'delete_term_relationships', $object_id, $tt_ids );		$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->term_relationships WHERE object_id = %d AND term_taxonomy_id IN ($in_tt_ids)", $object_id) );		do_action( 'deleted_term_relationships', $object_id, $tt_ids );		wp_update_term_count($tt_ids, $taxonomy);	}}/** * Removes a term from the database. * * If the term is a parent of other terms, then the children will be updated to * that term's parent. * * The $args 'default' will only override the terms found, if there is only one * term found. Any other and the found terms are used. * * The $args 'force_default' will force the term supplied as default to be * assigned even if the object was not going to be termless * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses do_action() Calls both 'delete_term' and 'delete_$taxonomy' action *	hooks, passing term object, term id. 'delete_term' gets an additional *	parameter with the $taxonomy parameter. * * @param int $term Term ID * @param string $taxonomy Taxonomy Name * @param array|string $args Optional. Change 'default' term id and override found term ids. * @return bool|WP_Error Returns false if not term; true if completes delete action. */function wp_delete_term( $term, $taxonomy, $args = array() ) {	global $wpdb;	$term = (int) $term;	if ( ! $ids = term_exists($term, $taxonomy) )		return false;	if ( is_wp_error( $ids ) )		return $ids;	$tt_id = $ids['term_taxonomy_id'];	$defaults = array();	$args = wp_parse_args($args, $defaults);	extract($args, EXTR_SKIP);	if ( isset($default) ) {		$default = (int) $default;		if ( ! term_exists($default, $taxonomy) )			unset($default);	}	// Update children to point to new parent	if ( is_taxonomy_hierarchical($taxonomy) ) {		$term_obj = get_term($term, $taxonomy);		if ( is_wp_error( $term_obj ) )			return $term_obj;		$parent = $term_obj->parent;		$edit_tt_ids = $wpdb->get_col( "SELECT `term_taxonomy_id` FROM $wpdb->term_taxonomy WHERE `parent` = " . (int)$term_obj->term_id );		do_action( 'edit_term_taxonomies', $edit_tt_ids );		$wpdb->update( $wpdb->term_taxonomy, compact( 'parent' ), array( 'parent' => $term_obj->term_id) + compact( 'taxonomy' ) );		do_action( 'edited_term_taxonomies', $edit_tt_ids );	}	$objects = $wpdb->get_col( $wpdb->prepare( "SELECT object_id FROM $wpdb->term_relationships WHERE term_taxonomy_id = %d", $tt_id ) );	foreach ( (array) $objects as $object ) {		$terms = wp_get_object_terms($object, $taxonomy, array('fields' => 'ids', 'orderby' => 'none'));		if ( 1 == count($terms) && isset($default) ) {			$terms = array($default);		} else {			$terms = array_diff($terms, array($term));			if (isset($default) && isset($force_default) && $force_default)				$terms = array_merge($terms, array($default));		}		$terms = array_map('intval', $terms);		wp_set_object_terms($object, $terms, $taxonomy);	}	do_action( 'delete_term_taxonomy', $tt_id );	$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->term_taxonomy WHERE term_taxonomy_id = %d", $tt_id ) );	do_action( 'deleted_term_taxonomy', $tt_id );	// Delete the term if no taxonomies use it.	if ( !$wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM $wpdb->term_taxonomy WHERE term_id = %d", $term) ) )		$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->terms WHERE term_id = %d", $term) );	clean_term_cache($term, $taxonomy);	do_action('delete_term', $term, $tt_id, $taxonomy);	do_action("delete_$taxonomy", $term, $tt_id);	return true;}/** * Retrieves the terms associated with the given object(s), in the supplied taxonomies. * * The following information has to do the $args parameter and for what can be * contained in the string or array of that parameter, if it exists. * * The first argument is called, 'orderby' and has the default value of 'name'. * The other value that is supported is 'count'. * * The second argument is called, 'order' and has the default value of 'ASC'. * The only other value that will be acceptable is 'DESC'. * * The final argument supported is called, 'fields' and has the default value of * 'all'. There are multiple other options that can be used instead. Supported * values are as follows: 'all', 'ids', 'names', and finally * 'all_with_object_id'. * * The fields argument also decides what will be returned. If 'all' or * 'all_with_object_id' is choosen or the default kept intact, then all matching * terms objects will be returned. If either 'ids' or 'names' is used, then an * array of all matching term ids or term names will be returned respectively. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int|array $object_id The id of the object(s) to retrieve. * @param string|array $taxonomies The taxonomies to retrieve terms from. * @param array|string $args Change what is returned * @return array|WP_Error The requested term data or empty array if no terms found. WP_Error if $taxonomy does not exist. */function wp_get_object_terms($object_ids, $taxonomies, $args = array()) {	global $wpdb;	if ( !is_array($taxonomies) )		$taxonomies = array($taxonomies);	foreach ( (array) $taxonomies as $taxonomy ) {		if ( ! taxonomy_exists($taxonomy) )			return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));	}	if ( !is_array($object_ids) )		$object_ids = array($object_ids);	$object_ids = array_map('intval', $object_ids);	$defaults = array('orderby' => 'name', 'order' => 'ASC', 'fields' => 'all');	$args = wp_parse_args( $args, $defaults );	$terms = array();	if ( count($taxonomies) > 1 ) {		foreach ( $taxonomies as $index => $taxonomy ) {			$t = get_taxonomy($taxonomy);			if ( isset($t->args) && is_array($t->args) && $args != array_merge($args, $t->args) ) {				unset($taxonomies[$index]);				$terms = array_merge($terms, wp_get_object_terms($object_ids, $taxonomy, array_merge($args, $t->args)));			}		}	} else {		$t = get_taxonomy($taxonomies[0]);		if ( isset($t->args) && is_array($t->args) )			$args = array_merge($args, $t->args);	}	extract($args, EXTR_SKIP);	if ( 'count' == $orderby )		$orderby = 'tt.count';	else if ( 'name' == $orderby )		$orderby = 't.name';	else if ( 'slug' == $orderby )		$orderby = 't.slug';	else if ( 'term_group' == $orderby )		$orderby = 't.term_group';	else if ( 'term_order' == $orderby )		$orderby = 'tr.term_order';	else if ( 'none' == $orderby ) {		$orderby = '';		$order = '';	} else {		$orderby = 't.term_id';	}	// tt_ids queries can only be none or tr.term_taxonomy_id	if ( ('tt_ids' == $fields) && !empty($orderby) )		$orderby = 'tr.term_taxonomy_id';	if ( !empty($orderby) )		$orderby = "ORDER BY $orderby";	$taxonomies = "'" . implode("', '", $taxonomies) . "'";	$object_ids = implode(', ', $object_ids);	$select_this = '';	if ( 'all' == $fields )		$select_this = 't.*, tt.*';	else if ( 'ids' == $fields )		$select_this = 't.term_id';	else if ( 'names' == $fields )		$select_this = 't.name';	else if ( 'all_with_object_id' == $fields )		$select_this = 't.*, tt.*, tr.object_id';	$query = "SELECT $select_this FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON tt.term_id = t.term_id INNER JOIN $wpdb->term_relationships AS tr ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy IN ($taxonomies) AND tr.object_id IN ($object_ids) $orderby $order";	if ( 'all' == $fields || 'all_with_object_id' == $fields ) {		$terms = array_merge($terms, $wpdb->get_results($query));		update_term_cache($terms);	} else if ( 'ids' == $fields || 'names' == $fields ) {		$terms = array_merge($terms, $wpdb->get_col($query));	} else if ( 'tt_ids' == $fields ) {		$terms = $wpdb->get_col("SELECT tr.term_taxonomy_id FROM $wpdb->term_relationships AS tr INNER JOIN $wpdb->term_taxonomy AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tr.object_id IN ($object_ids) AND tt.taxonomy IN ($taxonomies) $orderby $order");	}	if ( ! $terms )		$terms = array();	return apply_filters('wp_get_object_terms', $terms, $object_ids, $taxonomies, $args);}/** * Adds a new term to the database. Optionally marks it as an alias of an existing term. * * Error handling is assigned for the nonexistance of the $taxonomy and $term * parameters before inserting. If both the term id and taxonomy exist * previously, then an array will be returned that contains the term id and the * contents of what is returned. The keys of the array are 'term_id' and * 'term_taxonomy_id' containing numeric values. * * It is assumed that the term does not yet exist or the above will apply. The * term will be first added to the term table and then related to the taxonomy * if everything is well. If everything is correct, then several actions will be * run prior to a filter and then several actions will be run after the filter * is run. * * The arguments decide how the term is handled based on the $args parameter. * The following is a list of the available overrides and the defaults. * * 'alias_of'. There is no default, but if added, expected is the slug that the * term will be an alias of. Expected to be a string. * * 'description'. There is no default. If exists, will be added to the database * along with the term. Expected to be a string. * * 'parent'. Expected to be numeric and default is 0 (zero). Will assign value * of 'parent' to the term. * * 'slug'. Expected to be a string. There is no default. * * If 'slug' argument exists then the slug will be checked to see if it is not * a valid term. If that check succeeds (it is not a valid term), then it is * added and the term id is given. If it fails, then a check is made to whether * the taxonomy is hierarchical and the parent argument is not empty. If the * second check succeeds, the term will be inserted and the term id will be * given. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @uses apply_filters() Calls 'pre_insert_term' hook with term and taxonomy as parameters. * @uses do_action() Calls 'create_term' hook with the term id and taxonomy id as parameters. * @uses do_action() Calls 'create_$taxonomy' hook with term id and taxonomy id as parameters. * @uses apply_filters() Calls 'term_id_filter' hook with term id and taxonomy id as parameters. * @uses do_action() Calls 'created_term' hook with the term id and taxonomy id as parameters. * @uses do_action() Calls 'created_$taxonomy' hook with term id and taxonomy id as parameters. * * @param string $term The term to add or update. * @param string $taxonomy The taxonomy to which to add the term * @param array|string $args Change the values of the inserted term * @return array|WP_Error The Term ID and Term Taxonomy ID */function wp_insert_term( $term, $taxonomy, $args = array() ) {	global $wpdb;	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid taxonomy'));	$term = apply_filters( 'pre_insert_term', $term, $taxonomy );		if ( is_wp_error( $term ) )			return $term;	if ( is_int($term) && 0 == $term )		return new WP_Error('invalid_term_id', __('Invalid term ID'));	if ( '' == trim($term) )		return new WP_Error('empty_term_name', __('A name is required for this term'));	$defaults = array( 'alias_of' => '', 'description' => '', 'parent' => 0, 'slug' => '');	$args = wp_parse_args($args, $defaults);	$args['name'] = $term;	$args['taxonomy'] = $taxonomy;	$args = sanitize_term($args, $taxonomy, 'db');	extract($args, EXTR_SKIP);	// expected_slashed ($name)	$name = stripslashes($name);	$description = stripslashes($description);	if ( empty($slug) )		$slug = sanitize_title($name);	$term_group = 0;	if ( $alias_of ) {		$alias = $wpdb->get_row( $wpdb->prepare( "SELECT term_id, term_group FROM $wpdb->terms WHERE slug = %s", $alias_of) );		if ( $alias->term_group ) {			// The alias we want is already in a group, so let's use that one.			$term_group = $alias->term_group;		} else {			// The alias isn't in a group, so let's create a new one and firstly add the alias term to it.			$term_group = $wpdb->get_var("SELECT MAX(term_group) FROM $wpdb->terms") + 1;			do_action( 'edit_terms', $alias->term_id );			$wpdb->update($wpdb->terms, compact('term_group'), array('term_id' => $alias->term_id) );			do_action( 'edited_terms', $alias->term_id );		}	}	if ( $term_id = term_exists($slug) ) {		$existing_term = $wpdb->get_row( $wpdb->prepare( "SELECT name FROM $wpdb->terms WHERE term_id = %d", $term_id), ARRAY_A );		// We've got an existing term in the same taxonomy, which matches the name of the new term:		if ( is_taxonomy_hierarchical($taxonomy) && $existing_term['name'] == $name && term_exists( (int) $term_id, $taxonomy ) ) {			// Hierarchical, and it matches an existing term, Do not allow same "name" in the same level.			$siblings = get_terms($taxonomy, array('fields' => 'names', 'get' => 'all', 'parent' => (int)$parent) );			if ( in_array($name, $siblings) ) {				return new WP_Error('term_exists', __('A term with the name provided already exists with this parent.'));			} else {				$slug = wp_unique_term_slug($slug, (object) $args);				if ( false === $wpdb->insert( $wpdb->terms, compact( 'name', 'slug', 'term_group' ) ) )					return new WP_Error('db_insert_error', __('Could not insert term into the database'), $wpdb->last_error);				$term_id = (int) $wpdb->insert_id;			}		} elseif ( $existing_term['name'] != $name ) {			// We've got an existing term, with a different name, Create the new term.			$slug = wp_unique_term_slug($slug, (object) $args);			if ( false === $wpdb->insert( $wpdb->terms, compact( 'name', 'slug', 'term_group' ) ) )				return new WP_Error('db_insert_error', __('Could not insert term into the database'), $wpdb->last_error);			$term_id = (int) $wpdb->insert_id;		} elseif ( term_exists( (int) $term_id, $taxonomy ) )  {			// Same name, same slug.			return new WP_Error('term_exists', __('A term with the name provided already exists.'));		}	} else {		// This term does not exist at all in the database, Create it.		$slug = wp_unique_term_slug($slug, (object) $args);		if ( false === $wpdb->insert( $wpdb->terms, compact( 'name', 'slug', 'term_group' ) ) )			return new WP_Error('db_insert_error', __('Could not insert term into the database'), $wpdb->last_error);		$term_id = (int) $wpdb->insert_id;	}	// Seems unreachable, However, Is used in the case that a term name is provided, which sanitizes to an empty string.	if ( empty($slug) ) {		$slug = sanitize_title($slug, $term_id);		do_action( 'edit_terms', $term_id );		$wpdb->update( $wpdb->terms, compact( 'slug' ), compact( 'term_id' ) );		do_action( 'edited_terms', $term_id );	}	$tt_id = $wpdb->get_var( $wpdb->prepare( "SELECT tt.term_taxonomy_id FROM $wpdb->term_taxonomy AS tt INNER JOIN $wpdb->terms AS t ON tt.term_id = t.term_id WHERE tt.taxonomy = %s AND t.term_id = %d", $taxonomy, $term_id ) );	if ( !empty($tt_id) )		return array('term_id' => $term_id, 'term_taxonomy_id' => $tt_id);	$wpdb->insert( $wpdb->term_taxonomy, compact( 'term_id', 'taxonomy', 'description', 'parent') + array( 'count' => 0 ) );	$tt_id = (int) $wpdb->insert_id;	do_action("create_term", $term_id, $tt_id, $taxonomy);	do_action("create_$taxonomy", $term_id, $tt_id);	$term_id = apply_filters('term_id_filter', $term_id, $tt_id);	clean_term_cache($term_id, $taxonomy);	do_action("created_term", $term_id, $tt_id, $taxonomy);	do_action("created_$taxonomy", $term_id, $tt_id);	return array('term_id' => $term_id, 'term_taxonomy_id' => $tt_id);}/** * Create Term and Taxonomy Relationships. * * Relates an object (post, link etc) to a term and taxonomy type. Creates the * term and taxonomy relationship if it doesn't already exist. Creates a term if * it doesn't exist (using the slug). * * A relationship means that the term is grouped in or belongs to the taxonomy. * A term has no meaning until it is given context by defining which taxonomy it * exists under. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int $object_id The object to relate to. * @param array|int|string $term The slug or id of the term, will replace all existing * related terms in this taxonomy. * @param array|string $taxonomy The context in which to relate the term to the object. * @param bool $append If false will delete difference of terms. * @return array|WP_Error Affected Term IDs */function wp_set_object_terms($object_id, $terms, $taxonomy, $append = false) {	global $wpdb;	$object_id = (int) $object_id;	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));	if ( !is_array($terms) )		$terms = array($terms);	if ( ! $append )		$old_tt_ids =  wp_get_object_terms($object_id, $taxonomy, array('fields' => 'tt_ids', 'orderby' => 'none'));	else		$old_tt_ids = array();	$tt_ids = array();	$term_ids = array();	foreach ( (array) $terms as $term) {		if ( !strlen(trim($term)) )			continue;		if ( !$term_info = term_exists($term, $taxonomy) ) {			// Skip if a non-existent term ID is passed.			if ( is_int($term) )				continue;			$term_info = wp_insert_term($term, $taxonomy);		}		if ( is_wp_error($term_info) )			return $term_info;		$term_ids[] = $term_info['term_id'];		$tt_id = $term_info['term_taxonomy_id'];		$tt_ids[] = $tt_id;		if ( $wpdb->get_var( $wpdb->prepare( "SELECT term_taxonomy_id FROM $wpdb->term_relationships WHERE object_id = %d AND term_taxonomy_id = %d", $object_id, $tt_id ) ) )			continue;		do_action( 'add_term_relationship', $object_id, $tt_id );		$wpdb->insert( $wpdb->term_relationships, array( 'object_id' => $object_id, 'term_taxonomy_id' => $tt_id ) );		do_action( 'added_term_relationship', $object_id, $tt_id );	}	wp_update_term_count($tt_ids, $taxonomy);	if ( ! $append ) {		$delete_terms = array_diff($old_tt_ids, $tt_ids);		if ( $delete_terms ) {			$in_delete_terms = "'" . implode("', '", $delete_terms) . "'";			do_action( 'delete_term_relationships', $object_id, $delete_terms );			$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->term_relationships WHERE object_id = %d AND term_taxonomy_id IN ($in_delete_terms)", $object_id) );			do_action( 'deleted_term_relationships', $object_id, $delete_terms );			wp_update_term_count($delete_terms, $taxonomy);		}	}	$t = get_taxonomy($taxonomy);	if ( ! $append && isset($t->sort) && $t->sort ) {		$values = array();		$term_order = 0;		$final_tt_ids = wp_get_object_terms($object_id, $taxonomy, array('fields' => 'tt_ids'));		foreach ( $tt_ids as $tt_id )			if ( in_array($tt_id, $final_tt_ids) )				$values[] = $wpdb->prepare( "(%d, %d, %d)", $object_id, $tt_id, ++$term_order);		if ( $values )			$wpdb->query("INSERT INTO $wpdb->term_relationships (object_id, term_taxonomy_id, term_order) VALUES " . join(',', $values) . " ON DUPLICATE KEY UPDATE term_order = VALUES(term_order)");	}	do_action('set_object_terms', $object_id, $terms, $tt_ids, $taxonomy, $append, $old_tt_ids);	return $tt_ids;}/** * Will make slug unique, if it isn't already. * * The $slug has to be unique global to every taxonomy, meaning that one * taxonomy term can't have a matching slug with another taxonomy term. Each * slug has to be globally unique for every taxonomy. * * The way this works is that if the taxonomy that the term belongs to is * hierarchical and has a parent, it will append that parent to the $slug. * * If that still doesn't return an unique slug, then it try to append a number * until it finds a number that is truely unique. * * The only purpose for $term is for appending a parent, if one exists. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param string $slug The string that will be tried for a unique slug * @param object $term The term object that the $slug will belong too * @return string Will return a true unique slug. */function wp_unique_term_slug($slug, $term) {	global $wpdb;	if ( ! term_exists( $slug ) )		return $slug;	// If the taxonomy supports hierarchy and the term has a parent, make the slug unique	// by incorporating parent slugs.	if ( is_taxonomy_hierarchical($term->taxonomy) && !empty($term->parent) ) {		$the_parent = $term->parent;		while ( ! empty($the_parent) ) {			$parent_term = get_term($the_parent, $term->taxonomy);			if ( is_wp_error($parent_term) || empty($parent_term) )				break;			$slug .= '-' . $parent_term->slug;			if ( ! term_exists( $slug ) )				return $slug;			if ( empty($parent_term->parent) )				break;			$the_parent = $parent_term->parent;		}	}	// If we didn't get a unique slug, try appending a number to make it unique.	if ( !empty($args['term_id']) )		$query = $wpdb->prepare( "SELECT slug FROM $wpdb->terms WHERE slug = %s AND term_id != %d", $slug, $args['term_id'] );	else		$query = $wpdb->prepare( "SELECT slug FROM $wpdb->terms WHERE slug = %s", $slug );	if ( $wpdb->get_var( $query ) ) {		$num = 2;		do {			$alt_slug = $slug . "-$num";			$num++;			$slug_check = $wpdb->get_var( $wpdb->prepare( "SELECT slug FROM $wpdb->terms WHERE slug = %s", $alt_slug ) );		} while ( $slug_check );		$slug = $alt_slug;	}	return $slug;}/** * Update term based on arguments provided. * * The $args will indiscriminately override all values with the same field name. * Care must be taken to not override important information need to update or * update will fail (or perhaps create a new term, neither would be acceptable). * * Defaults will set 'alias_of', 'description', 'parent', and 'slug' if not * defined in $args already. * * 'alias_of' will create a term group, if it doesn't already exist, and update * it for the $term. * * If the 'slug' argument in $args is missing, then the 'name' in $args will be * used. It should also be noted that if you set 'slug' and it isn't unique then * a WP_Error will be passed back. If you don't pass any slug, then a unique one * will be created for you. * * For what can be overrode in $args, check the term scheme can contain and stay * away from the term keys. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses do_action() Will call both 'edit_term' and 'edit_$taxonomy' twice. * @uses apply_filters() Will call the 'term_id_filter' filter and pass the term *	id and taxonomy id. * * @param int $term_id The ID of the term * @param string $taxonomy The context in which to relate the term to the object. * @param array|string $args Overwrite term field values * @return array|WP_Error Returns Term ID and Taxonomy Term ID */function wp_update_term( $term_id, $taxonomy, $args = array() ) {	global $wpdb;	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid taxonomy'));	$term_id = (int) $term_id;	// First, get all of the original args	$term = get_term ($term_id, $taxonomy, ARRAY_A);	if ( is_wp_error( $term ) )		return $term;	// Escape data pulled from DB.	$term = add_magic_quotes($term);	// Merge old and new args with new args overwriting old ones.	$args = array_merge($term, $args);	$defaults = array( 'alias_of' => '', 'description' => '', 'parent' => 0, 'slug' => '');	$args = wp_parse_args($args, $defaults);	$args = sanitize_term($args, $taxonomy, 'db');	extract($args, EXTR_SKIP);	// expected_slashed ($name)	$name = stripslashes($name);	$description = stripslashes($description);	if ( '' == trim($name) )		return new WP_Error('empty_term_name', __('A name is required for this term'));	$empty_slug = false;	if ( empty($slug) ) {		$empty_slug = true;		$slug = sanitize_title($name);	}	if ( $alias_of ) {		$alias = $wpdb->get_row( $wpdb->prepare( "SELECT term_id, term_group FROM $wpdb->terms WHERE slug = %s", $alias_of) );		if ( $alias->term_group ) {			// The alias we want is already in a group, so let's use that one.			$term_group = $alias->term_group;		} else {			// The alias isn't in a group, so let's create a new one and firstly add the alias term to it.			$term_group = $wpdb->get_var("SELECT MAX(term_group) FROM $wpdb->terms") + 1;			do_action( 'edit_terms', $alias->term_id );			$wpdb->update( $wpdb->terms, compact('term_group'), array( 'term_id' => $alias->term_id ) );			do_action( 'edited_terms', $alias->term_id );		}	}	// Check for duplicate slug	$id = $wpdb->get_var( $wpdb->prepare( "SELECT term_id FROM $wpdb->terms WHERE slug = %s", $slug ) );	if ( $id && ($id != $term_id) ) {		// If an empty slug was passed or the parent changed, reset the slug to something unique.		// Otherwise, bail.		if ( $empty_slug || ( $parent != $term['parent']) )			$slug = wp_unique_term_slug($slug, (object) $args);		else			return new WP_Error('duplicate_term_slug', sprintf(__('The slug &#8220;%s&#8221; is already in use by another term'), $slug));	}	do_action( 'edit_terms', $term_id );	$wpdb->update($wpdb->terms, compact( 'name', 'slug', 'term_group' ), compact( 'term_id' ) );	if ( empty($slug) ) {		$slug = sanitize_title($name, $term_id);		$wpdb->update( $wpdb->terms, compact( 'slug' ), compact( 'term_id' ) );	}	do_action( 'edited_terms', $term_id );	$tt_id = $wpdb->get_var( $wpdb->prepare( "SELECT tt.term_taxonomy_id FROM $wpdb->term_taxonomy AS tt INNER JOIN $wpdb->terms AS t ON tt.term_id = t.term_id WHERE tt.taxonomy = %s AND t.term_id = %d", $taxonomy, $term_id) );	do_action( 'edit_term_taxonomy', $tt_id, $taxonomy );	$wpdb->update( $wpdb->term_taxonomy, compact( 'term_id', 'taxonomy', 'description', 'parent' ), array( 'term_taxonomy_id' => $tt_id ) );	do_action( 'edited_term_taxonomy', $tt_id, $taxonomy );	do_action("edit_term", $term_id, $tt_id, $taxonomy);	do_action("edit_$taxonomy", $term_id, $tt_id);	$term_id = apply_filters('term_id_filter', $term_id, $tt_id);	clean_term_cache($term_id, $taxonomy);	do_action("edited_term", $term_id, $tt_id, $taxonomy);	do_action("edited_$taxonomy", $term_id, $tt_id);	return array('term_id' => $term_id, 'term_taxonomy_id' => $tt_id);}/** * Enable or disable term counting. * * @since 2.5.0 * * @param bool $defer Optional. Enable if true, disable if false. * @return bool Whether term counting is enabled or disabled. */function wp_defer_term_counting($defer=null) {	static $_defer = false;	if ( is_bool($defer) ) {		$_defer = $defer;		// flush any deferred counts		if ( !$defer )			wp_update_term_count( null, null, true );	}	return $_defer;}/** * Updates the amount of terms in taxonomy. * * If there is a taxonomy callback applyed, then it will be called for updating * the count. * * The default action is to count what the amount of terms have the relationship * of term ID. Once that is done, then update the database. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int|array $terms The term_taxonomy_id of the terms * @param string $taxonomy The context of the term. * @return bool If no terms will return false, and if successful will return true. */function wp_update_term_count( $terms, $taxonomy, $do_deferred=false ) {	static $_deferred = array();	if ( $do_deferred ) {		foreach ( (array) array_keys($_deferred) as $tax ) {			wp_update_term_count_now( $_deferred[$tax], $tax );			unset( $_deferred[$tax] );		}	}	if ( empty($terms) )		return false;	if ( !is_array($terms) )		$terms = array($terms);	if ( wp_defer_term_counting() ) {		if ( !isset($_deferred[$taxonomy]) )			$_deferred[$taxonomy] = array();		$_deferred[$taxonomy] = array_unique( array_merge($_deferred[$taxonomy], $terms) );		return true;	}	return wp_update_term_count_now( $terms, $taxonomy );}/** * Perform term count update immediately. * * @since 2.5.0 * * @param array $terms The term_taxonomy_id of terms to update. * @param string $taxonomy The context of the term. * @return bool Always true when complete. */function wp_update_term_count_now( $terms, $taxonomy ) {	global $wpdb;	$terms = array_map('intval', $terms);	$taxonomy = get_taxonomy($taxonomy);	if ( !empty($taxonomy->update_count_callback) ) {		call_user_func($taxonomy->update_count_callback, $terms, $taxonomy);	} else {		// Default count updater		foreach ( (array) $terms as $term) {			$count = $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM $wpdb->term_relationships WHERE term_taxonomy_id = %d", $term) );			do_action( 'edit_term_taxonomy', $term, $taxonomy );			$wpdb->update( $wpdb->term_taxonomy, compact( 'count' ), array( 'term_taxonomy_id' => $term ) );			do_action( 'edited_term_taxonomy', $term, $taxonomy );		}	}	clean_term_cache($terms, '', false);	return true;}//// Cache///** * Removes the taxonomy relationship to terms from the cache. * * Will remove the entire taxonomy relationship containing term $object_id. The * term IDs have to exist within the taxonomy $object_type for the deletion to * take place. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @see get_object_taxonomies() for more on $object_type * @uses do_action() Will call action hook named, 'clean_object_term_cache' after completion. *	Passes, function params in same order. * * @param int|array $object_ids Single or list of term object ID(s) * @param array|string $object_type The taxonomy object type */function clean_object_term_cache($object_ids, $object_type) {	if ( !is_array($object_ids) )		$object_ids = array($object_ids);	foreach ( $object_ids as $id )		foreach ( get_object_taxonomies($object_type) as $taxonomy )			wp_cache_delete($id, "{$taxonomy}_relationships");	do_action('clean_object_term_cache', $object_ids, $object_type);}/** * Will remove all of the term ids from the cache. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int|array $ids Single or list of Term IDs * @param string $taxonomy Can be empty and will assume tt_ids, else will use for context. * @param bool $clean_taxonomy Whether to clean taxonomy wide caches (true), or just individual term object caches (false). Default is true. */function clean_term_cache($ids, $taxonomy = '', $clean_taxonomy = true) {	global $wpdb;	static $cleaned = array();	if ( !is_array($ids) )		$ids = array($ids);	$taxonomies = array();	// If no taxonomy, assume tt_ids.	if ( empty($taxonomy) ) {		$tt_ids = array_map('intval', $ids);		$tt_ids = implode(', ', $tt_ids);		$terms = $wpdb->get_results("SELECT term_id, taxonomy FROM $wpdb->term_taxonomy WHERE term_taxonomy_id IN ($tt_ids)");		$ids = array();		foreach ( (array) $terms as $term ) {			$taxonomies[] = $term->taxonomy;			$ids[] = $term->term_id;			wp_cache_delete($term->term_id, $term->taxonomy);		}		$taxonomies = array_unique($taxonomies);	} else {		$taxonomies = array($taxonomy);		foreach ( $taxonomies as $taxonomy ) {			foreach ( $ids as $id ) {				wp_cache_delete($id, $taxonomy);			}		}	}	foreach ( $taxonomies as $taxonomy ) {		if ( isset($cleaned[$taxonomy]) )			continue;		$cleaned[$taxonomy] = true;		if ( $clean_taxonomy ) {			wp_cache_delete('all_ids', $taxonomy);			wp_cache_delete('get', $taxonomy);			delete_option("{$taxonomy}_children");			// Regenerate {$taxonomy}_children			_get_term_hierarchy($taxonomy);		}		do_action('clean_term_cache', $ids, $taxonomy);	}	wp_cache_set('last_changed', time(), 'terms');}/** * Retrieves the taxonomy relationship to the term object id. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses wp_cache_get() Retrieves taxonomy relationship from cache * * @param int|array $id Term object ID * @param string $taxonomy Taxonomy Name * @return bool|array Empty array if $terms found, but not $taxonomy. False if nothing is in cache for $taxonomy and $id. */function &get_object_term_cache($id, $taxonomy) {	$cache = wp_cache_get($id, "{$taxonomy}_relationships");	return $cache;}/** * Updates the cache for Term ID(s). * * Will only update the cache for terms not already cached. * * The $object_ids expects that the ids be separated by commas, if it is a * string. * * It should be noted that update_object_term_cache() is very time extensive. It * is advised that the function is not called very often or at least not for a * lot of terms that exist in a lot of taxonomies. The amount of time increases * for each term and it also increases for each taxonomy the term belongs to. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses wp_get_object_terms() Used to get terms from the database to update * * @param string|array $object_ids Single or list of term object ID(s) * @param array|string $object_type The taxonomy object type * @return null|bool Null value is given with empty $object_ids. False if */function update_object_term_cache($object_ids, $object_type) {	if ( empty($object_ids) )		return;	if ( !is_array($object_ids) )		$object_ids = explode(',', $object_ids);	$object_ids = array_map('intval', $object_ids);	$taxonomies = get_object_taxonomies($object_type);	$ids = array();	foreach ( (array) $object_ids as $id ) {		foreach ( $taxonomies as $taxonomy ) {			if ( false === wp_cache_get($id, "{$taxonomy}_relationships") ) {				$ids[] = $id;				break;			}		}	}	if ( empty( $ids ) )		return false;	$terms = wp_get_object_terms($ids, $taxonomies, array('fields' => 'all_with_object_id'));	$object_terms = array();	foreach ( (array) $terms as $term )		$object_terms[$term->object_id][$term->taxonomy][$term->term_id] = $term;	foreach ( $ids as $id ) {		foreach ( $taxonomies  as $taxonomy ) {			if ( ! isset($object_terms[$id][$taxonomy]) ) {				if ( !isset($object_terms[$id]) )					$object_terms[$id] = array();				$object_terms[$id][$taxonomy] = array();			}		}	}	foreach ( $object_terms as $id => $value ) {		foreach ( $value as $taxonomy => $terms ) {			wp_cache_set($id, $terms, "{$taxonomy}_relationships");		}	}}/** * Updates Terms to Taxonomy in cache. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @param array $terms List of Term objects to change * @param string $taxonomy Optional. Update Term to this taxonomy in cache */function update_term_cache($terms, $taxonomy = '') {	foreach ( (array) $terms as $term ) {		$term_taxonomy = $taxonomy;		if ( empty($term_taxonomy) )			$term_taxonomy = $term->taxonomy;		wp_cache_add($term->term_id, $term, $term_taxonomy);	}}//// Private///** * Retrieves children of taxonomy as Term IDs. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * * @uses update_option() Stores all of the children in "$taxonomy_children" *	 option. That is the name of the taxonomy, immediately followed by '_children'. * * @param string $taxonomy Taxonomy Name * @return array Empty if $taxonomy isn't hierarchical or returns children as Term IDs. */function _get_term_hierarchy($taxonomy) {	if ( !is_taxonomy_hierarchical($taxonomy) )		return array();	$children = get_option("{$taxonomy}_children");	if ( is_array($children) )		return $children;	$children = array();	$terms = get_terms($taxonomy, array('get' => 'all', 'orderby' => 'id', 'fields' => 'id=>parent'));	foreach ( $terms as $term_id => $parent ) {		if ( $parent > 0 )			$children[$parent][] = $term_id;	}	update_option("{$taxonomy}_children", $children);	return $children;}/** * Get the subset of $terms that are descendants of $term_id. * * If $terms is an array of objects, then _get_term_children returns an array of objects. * If $terms is an array of IDs, then _get_term_children returns an array of IDs. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * * @param int $term_id The ancestor term: all returned terms should be descendants of $term_id. * @param array $terms The set of terms---either an array of term objects or term IDs---from which those that are descendants of $term_id will be chosen. * @param string $taxonomy The taxonomy which determines the hierarchy of the terms. * @return array The subset of $terms that are descendants of $term_id. */function &_get_term_children($term_id, $terms, $taxonomy) {	$empty_array = array();	if ( empty($terms) )		return $empty_array;	$term_list = array();	$has_children = _get_term_hierarchy($taxonomy);	if  ( ( 0 != $term_id ) && ! isset($has_children[$term_id]) )		return $empty_array;	foreach ( (array) $terms as $term ) {		$use_id = false;		if ( !is_object($term) ) {			$term = get_term($term, $taxonomy);			if ( is_wp_error( $term ) )				return $term;			$use_id = true;		}		if ( $term->term_id == $term_id )			continue;		if ( $term->parent == $term_id ) {			if ( $use_id )				$term_list[] = $term->term_id;			else				$term_list[] = $term;			if ( !isset($has_children[$term->term_id]) )				continue;			if ( $children = _get_term_children($term->term_id, $terms, $taxonomy) )				$term_list = array_merge($term_list, $children);		}	}	return $term_list;}/** * Add count of children to parent count. * * Recalculates term counts by including items from child terms. Assumes all * relevant children are already in the $terms argument. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * @uses $wpdb * * @param array $terms List of Term IDs * @param string $taxonomy Term Context * @return null Will break from function if conditions are not met. */function _pad_term_counts(&$terms, $taxonomy) {	global $wpdb;	// This function only works for hierarchical taxonomies like post categories.	if ( !is_taxonomy_hierarchical( $taxonomy ) )		return;	$term_hier = _get_term_hierarchy($taxonomy);	if ( empty($term_hier) )		return;	$term_items = array();	foreach ( (array) $terms as $key => $term ) {		$terms_by_id[$term->term_id] = & $terms[$key];		$term_ids[$term->term_taxonomy_id] = $term->term_id;	}	// Get the object and term ids and stick them in a lookup table	$tax_obj = get_taxonomy($taxonomy);	$object_types = esc_sql($tax_obj->object_type);	$results = $wpdb->get_results("SELECT object_id, term_taxonomy_id FROM $wpdb->term_relationships INNER JOIN $wpdb->posts ON object_id = ID WHERE term_taxonomy_id IN (" . implode(',', array_keys($term_ids)) . ") AND post_type IN ('" . implode("', '", $object_types) . "') AND post_status = 'publish'");	foreach ( $results as $row ) {		$id = $term_ids[$row->term_taxonomy_id];		$term_items[$id][$row->object_id] = isset($term_items[$id][$row->object_id]) ? ++$term_items[$id][$row->object_id] : 1;	}	// Touch every ancestor's lookup row for each post in each term	foreach ( $term_ids as $term_id ) {		$child = $term_id;		while ( $parent = $terms_by_id[$child]->parent ) {			if ( !empty($term_items[$term_id]) )				foreach ( $term_items[$term_id] as $item_id => $touches ) {					$term_items[$parent][$item_id] = isset($term_items[$parent][$item_id]) ? ++$term_items[$parent][$item_id]: 1;				}			$child = $parent;		}	}	// Transfer the touched cells	foreach ( (array) $term_items as $id => $items )		if ( isset($terms_by_id[$id]) )			$terms_by_id[$id]->count = count($items);}//// Default callbacks///** * Will update term count based on object types of the current taxonomy. * * Private function for the default callback for post_tag and category * taxonomies. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * @uses $wpdb * * @param array $terms List of Term taxonomy IDs * @param object $taxonomy Current taxonomy object of terms */function _update_post_term_count( $terms, $taxonomy ) {	global $wpdb;	$object_types = is_array($taxonomy->object_type) ? $taxonomy->object_type : array($taxonomy->object_type);	$object_types = esc_sql($object_types);	foreach ( (array) $terms as $term ) {		$count = $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM $wpdb->term_relationships, $wpdb->posts WHERE $wpdb->posts.ID = $wpdb->term_relationships.object_id AND post_status = 'publish' AND post_type IN ('" . implode("', '", $object_types) . "') AND term_taxonomy_id = %d", $term ) );		do_action( 'edit_term_taxonomy', $term, $taxonomy );		$wpdb->update( $wpdb->term_taxonomy, compact( 'count' ), array( 'term_taxonomy_id' => $term ) );		do_action( 'edited_term_taxonomy', $term, $taxonomy );	}}/** * Generates a permalink for a taxonomy term archive. * * @since 2.5.0 * * @param object|int|string $term * @param string $taxonomy * @return string HTML link to taxonomy term archive */function get_term_link( $term, $taxonomy ) {	global $wp_rewrite;	if ( !is_object($term) ) {		if ( is_int($term) ) {			$term = &get_term($term, $taxonomy);		} else {			$term = &get_term_by('slug', $term, $taxonomy);		}	}	if ( !is_object($term) )		$term = new WP_Error('invalid_term', __('Empty Term'));	if ( is_wp_error( $term ) )		return $term;	// use legacy functions for core taxonomies until they are fully plugged in	if ( $taxonomy == 'category' )		return get_category_link((int) $term->term_id);	if ( $taxonomy == 'post_tag' )		return get_tag_link((int) $term->term_id);	$termlink = $wp_rewrite->get_extra_permastruct($taxonomy);	$slug = $term->slug;	if ( empty($termlink) ) {		$t = get_taxonomy($taxonomy);		if ( $t->query_var )			$termlink = "?$t->query_var=$slug";		else			$termlink = "?taxonomy=$taxonomy&term=$slug";		$termlink = home_url($termlink);	} else {		$termlink = str_replace("%$taxonomy%", $slug, $termlink);		$termlink = home_url( user_trailingslashit($termlink, 'category') );	}	return apply_filters('term_link', $termlink, $term, $taxonomy);}/** * Display the taxonomies of a post with available options. * * This function can be used within the loop to display the taxonomies for a * post without specifying the Post ID. You can also use it outside the Loop to * display the taxonomies for a specific post. * * The available defaults are: * 'post' : default is 0. The post ID to get taxonomies of. * 'before' : default is empty string. Display before taxonomies list. * 'sep' : default is empty string. Separate every taxonomy with value in this. * 'after' : default is empty string. Display this after the taxonomies list. * * @since 2.5.0 * @uses get_the_taxonomies() * * @param array $args Override the defaults. */function the_taxonomies($args = array()) {	$defaults = array(		'post' => 0,		'before' => '',		'sep' => ' ',		'after' => '',	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	echo $before . join($sep, get_the_taxonomies($post)) . $after;}/** * Retrieve all taxonomies associated with a post. * * This function can be used within the loop. It will also return an array of * the taxonomies with links to the taxonomy and name. * * @since 2.5.0 * * @param int $post Optional. Post ID or will use Global Post ID (in loop). * @return array */function get_the_taxonomies($post = 0) {	if ( is_int($post) )		$post =& get_post($post);	elseif ( !is_object($post) )		$post =& $GLOBALS['post'];	$taxonomies = array();	if ( !$post )		return $taxonomies;	$template = apply_filters('taxonomy_template', '%s: %l.');	foreach ( get_object_taxonomies($post) as $taxonomy ) {		$t = (array) get_taxonomy($taxonomy);		if ( empty($t['label']) )			$t['label'] = $taxonomy;		if ( empty($t['args']) )			$t['args'] = array();		if ( empty($t['template']) )			$t['template'] = $template;		$terms = get_object_term_cache($post->ID, $taxonomy);		if ( empty($terms) )			$terms = wp_get_object_terms($post->ID, $taxonomy, $t['args']);		$links = array();		foreach ( $terms as $term )			$links[] = "<a href='" . esc_attr(get_term_link($term, $taxonomy)) . "'>$term->name</a>";		if ( $links )			$taxonomies[$taxonomy] = wp_sprintf($t['template'], $t['label'], $links, $terms);	}	return $taxonomies;}/** * Retrieve all taxonomies of a post with just the names. * * @since 2.5.0 * @uses get_object_taxonomies() * * @param int $post Optional. Post ID * @return array */function get_post_taxonomies($post = 0) {	$post =& get_post($post);	return get_object_taxonomies($post);}/** * Determine if the given object is associated with any of the given terms. * * The given terms are checked against the object's terms' term_ids, names and slugs. * Terms given as integers will only be checked against the object's terms' term_ids. * If no terms are given, determines if object is associated with any terms in the given taxonomy. * * @since 2.7.0 * @uses get_object_term_cache() * @uses wp_get_object_terms() * * @param int $object_id.  ID of the object (post ID, link ID, ...) * @param string $taxonomy.  Single taxonomy name * @param int|string|array $terms Optional.  Term term_id, name, slug or array of said * @return bool|WP_Error. WP_Error on input error. */function is_object_in_term( $object_id, $taxonomy, $terms = null ) {	if ( !$object_id = (int) $object_id )		return new WP_Error( 'invalid_object', __( 'Invalid object ID' ) );	$object_terms = get_object_term_cache( $object_id, $taxonomy );	if ( empty( $object_terms ) )		 $object_terms = wp_get_object_terms( $object_id, $taxonomy );	if ( is_wp_error( $object_terms ) )		return $object_terms;	if ( empty( $object_terms ) )		return false;	if ( empty( $terms ) )		return ( !empty( $object_terms ) );	$terms = (array) $terms;	if ( $ints = array_filter( $terms, 'is_int' ) )		$strs = array_diff( $terms, $ints );	else		$strs =& $terms;	foreach ( $object_terms as $object_term ) {		if ( $ints && in_array( $object_term->term_id, $ints ) ) return true; // If int, check against term_id		if ( $strs ) {			if ( in_array( $object_term->term_id, $strs ) ) return true;			if ( in_array( $object_term->name, $strs ) )    return true;			if ( in_array( $object_term->slug, $strs ) )    return true;		}	}	return false;}/** * Determine if the given object type is associated with the given taxonomy. * * @since 3.0.0 * @uses get_object_taxonomies() * * @param string $object_type Object type string * @param string $taxonomy.  Single taxonomy name * @return bool True if object is associated with the taxonomy, otherwise false. */function is_object_in_taxonomy($object_type, $taxonomy) {	$taxonomies = get_object_taxonomies($object_type);	if ( empty($taxonomies) )		return false;	if ( in_array($taxonomy, $taxonomies) )		return true;	return false;}
<?php/** * WordPress Post Template Functions. * * Gets content for the current post in the loop. * * @package WordPress * @subpackage Template *//** * Display the ID of the current item in the WordPress Loop. * * @since 0.71 * @uses $id */function the_ID() {	global $id;	echo $id;}/** * Retrieve the ID of the current item in the WordPress Loop. * * @since 2.1.0 * @uses $id * * @return unknown */function get_the_ID() {	global $id;	return $id;}/** * Display or retrieve the current post title with optional content. * * @since 0.71 * * @param string $before Optional. Content to prepend to the title. * @param string $after Optional. Content to append to the title. * @param bool $echo Optional, default to true.Whether to display or return. * @return null|string Null on no title. String if $echo parameter is false. */function the_title($before = '', $after = '', $echo = true) {	$title = get_the_title();	if ( strlen($title) == 0 )		return;	$title = $before . $title . $after;	if ( $echo )		echo $title;	else		return $title;}/** * Sanitize the current title when retrieving or displaying. * * Works like {@link the_title()}, except the parameters can be in a string or * an array. See the function for what can be override in the $args parameter. * * The title before it is displayed will have the tags stripped and {@link * esc_attr()} before it is passed to the user or displayed. The default * as with {@link the_title()}, is to display the title. * * @since 2.3.0 * * @param string|array $args Optional. Override the defaults. * @return string|null Null on failure or display. String when echo is false. */function the_title_attribute( $args = '' ) {	$title = get_the_title();	if ( strlen($title) == 0 )		return;	$defaults = array('before' => '', 'after' =>  '', 'echo' => true);	$r = wp_parse_args($args, $defaults);	extract( $r, EXTR_SKIP );	$title = $before . $title . $after;	$title = esc_attr(strip_tags($title));	if ( $echo )		echo $title;	else		return $title;}/** * Retrieve post title. * * If the post is protected and the visitor is not an admin, then "Protected" * will be displayed before the post title. If the post is private, then * "Private" will be located before the post title. * * @since 0.71 * * @param int $id Optional. Post ID. * @return string */function get_the_title( $id = 0 ) {	$post = &get_post($id);	$title = isset($post->post_title) ? $post->post_title : '';	$id = isset($post->ID) ? $post->ID : (int) $id;	if ( !is_admin() ) {		if ( !empty($post->post_password) ) {			$protected_title_format = apply_filters('protected_title_format', __('Protected: %s'));			$title = sprintf($protected_title_format, $title);		} else if ( isset($post->post_status) && 'private' == $post->post_status ) {			$private_title_format = apply_filters('private_title_format', __('Private: %s'));			$title = sprintf($private_title_format, $title);		}	}	return apply_filters( 'the_title', $title, $id );}/** * Display the Post Global Unique Identifier (guid). * * The guid will appear to be a link, but should not be used as an link to the * post. The reason you should not use it as a link, is because of moving the * blog across domains. * * Url is escaped to make it xml safe * * @since 1.5.0 * * @param int $id Optional. Post ID. */function the_guid( $id = 0 ) {	echo esc_url( get_the_guid( $id ) );}/** * Retrieve the Post Global Unique Identifier (guid). * * The guid will appear to be a link, but should not be used as an link to the * post. The reason you should not use it as a link, is because of moving the * blog across domains. * * @since 1.5.0 * * @param int $id Optional. Post ID. * @return string */function get_the_guid( $id = 0 ) {	$post = &get_post($id);	return apply_filters('get_the_guid', $post->guid);}/** * Display the post content. * * @since 0.71 * * @param string $more_link_text Optional. Content for when there is more text. * @param string $stripteaser Optional. Teaser content before the more text. */function the_content($more_link_text = null, $stripteaser = 0) {	$content = get_the_content($more_link_text, $stripteaser);	$content = apply_filters('the_content', $content);	$content = str_replace(']]>', ']]&gt;', $content);	echo $content;}/** * Retrieve the post content. * * @since 0.71 * * @param string $more_link_text Optional. Content for when there is more text. * @param string $stripteaser Optional. Teaser content before the more text. * @return string */function get_the_content($more_link_text = null, $stripteaser = 0) {	global $id, $post, $more, $page, $pages, $multipage, $preview;	if ( null === $more_link_text )		$more_link_text = __( '(more...)' );	$output = '';	$hasTeaser = false;	// If post password required and it doesn't match the cookie.	if ( post_password_required($post) ) {		$output = get_the_password_form();		return $output;	}	if ( $page > count($pages) ) // if the requested page doesn't exist		$page = count($pages); // give them the highest numbered page that DOES exist	$content = $pages[$page-1];	if ( preg_match('/<!--more(.*?)?-->/', $content, $matches) ) {		$content = explode($matches[0], $content, 2);		if ( !empty($matches[1]) && !empty($more_link_text) )			$more_link_text = strip_tags(wp_kses_no_null(trim($matches[1])));		$hasTeaser = true;	} else {		$content = array($content);	}	if ( (false !== strpos($post->post_content, '<!--noteaser-->') && ((!$multipage) || ($page==1))) )		$stripteaser = 1;	$teaser = $content[0];	if ( ($more) && ($stripteaser) && ($hasTeaser) )		$teaser = '';	$output .= $teaser;	if ( count($content) > 1 ) {		if ( $more ) {			$output .= '<span id="more-' . $id . '"></span>' . $content[1];		} else {			if ( ! empty($more_link_text) )				$output .= apply_filters( 'the_content_more_link', ' <a href="' . get_permalink() . "#more-$id\" class=\"more-link\">$more_link_text</a>", $more_link_text );			$output = force_balance_tags($output);		}	}	if ( $preview ) // preview fix for javascript bug with foreign languages		$output =	preg_replace_callback('/\%u([0-9A-F]{4})/', create_function('$match', 'return "&#" . base_convert($match[1], 16, 10) . ";";'), $output);	return $output;}/** * Display the post excerpt. * * @since 0.71 * @uses apply_filters() Calls 'the_excerpt' hook on post excerpt. */function the_excerpt() {	echo apply_filters('the_excerpt', get_the_excerpt());}/** * Retrieve the post excerpt. * * @since 0.71 * * @param mixed $deprecated Not used. * @return string */function get_the_excerpt( $deprecated = '' ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.3' );	global $post;	$output = $post->post_excerpt;	if ( post_password_required($post) ) {		$output = __('There is no excerpt because this is a protected post.');		return $output;	}	return apply_filters('get_the_excerpt', $output);}/** * Whether post has excerpt. * * @since 2.3.0 * * @param int $id Optional. Post ID. * @return bool */function has_excerpt( $id = 0 ) {	$post = &get_post( $id );	return ( !empty( $post->post_excerpt ) );}/** * Display the classes for the post div. * * @since 2.7.0 * * @param string|array $class One or more classes to add to the class list. * @param int $post_id An optional post ID. */function post_class( $class = '', $post_id = null ) {	// Separates classes with a single space, collates classes for post DIV	echo 'class="' . join( ' ', get_post_class( $class, $post_id ) ) . '"';}/** * Retrieve the classes for the post div as an array. * * The class names are add are many. If the post is a sticky, then the 'sticky' * class name. The class 'hentry' is always added to each post. For each * category, the class will be added with 'category-' with category slug is * added. The tags are the same way as the categories with 'tag-' before the tag * slug. All classes are passed through the filter, 'post_class' with the list * of classes, followed by $class parameter value, with the post ID as the last * parameter. * * @since 2.7.0 * * @param string|array $class One or more classes to add to the class list. * @param int $post_id An optional post ID. * @return array Array of classes. */function get_post_class( $class = '', $post_id = null ) {	$post = get_post($post_id);	$classes = array();	if ( empty($post) )		return $classes;	$classes[] = 'post-' . $post->ID;	$classes[] = $post->post_type;	$classes[] = 'type-' . $post->post_type;	// sticky for Sticky Posts	if ( is_sticky($post->ID) && is_home() && !is_paged() )		$classes[] = 'sticky';	// hentry for hAtom compliace	$classes[] = 'hentry';	// Categories	foreach ( (array) get_the_category($post->ID) as $cat ) {		if ( empty($cat->slug ) )			continue;		$classes[] = 'category-' . sanitize_html_class($cat->slug, $cat->cat_ID);	}	// Tags	foreach ( (array) get_the_tags($post->ID) as $tag ) {		if ( empty($tag->slug ) )			continue;		$classes[] = 'tag-' . sanitize_html_class($tag->slug, $tag->term_id);	}	if ( !empty($class) ) {		if ( !is_array( $class ) )			$class = preg_split('#\s+#', $class);		$classes = array_merge($classes, $class);	}	$classes = array_map('esc_attr', $classes);	return apply_filters('post_class', $classes, $class, $post->ID);}/** * Display the classes for the body element. * * @since 2.8.0 * * @param string|array $class One or more classes to add to the class list. */function body_class( $class = '' ) {	// Separates classes with a single space, collates classes for body element	echo 'class="' . join( ' ', get_body_class( $class ) ) . '"';}/** * Retrieve the classes for the body element as an array. * * @since 2.8.0 * * @param string|array $class One or more classes to add to the class list. * @return array Array of classes. */function get_body_class( $class = '' ) {	global $wp_query, $wpdb;	$classes = array();	if ( is_rtl() )		$classes[] = 'rtl';	if ( is_front_page() )		$classes[] = 'home';	if ( is_home() )		$classes[] = 'blog';	if ( is_archive() )		$classes[] = 'archive';	if ( is_date() )		$classes[] = 'date';	if ( is_search() )		$classes[] = 'search';	if ( is_paged() )		$classes[] = 'paged';	if ( is_attachment() )		$classes[] = 'attachment';	if ( is_404() )		$classes[] = 'error404';	if ( is_single() ) {		$post_id = $wp_query->get_queried_object_id();		$post = $wp_query->get_queried_object();		$classes[] = 'single';		$classes[] = 'single-' . sanitize_html_class($post->post_type, $post_id);		$classes[] = 'postid-' . $post_id;		if ( is_attachment() ) {			$mime_type = get_post_mime_type($post_id);			$mime_prefix = array( 'application/', 'image/', 'text/', 'audio/', 'video/', 'music/' );			$classes[] = 'attachmentid-' . $post_id;			$classes[] = 'attachment-' . str_replace( $mime_prefix, '', $mime_type );		}	} elseif ( is_archive() ) {		if ( is_author() ) {			$author = $wp_query->get_queried_object();			$classes[] = 'author';			$classes[] = 'author-' . sanitize_html_class( $author->user_nicename , $author->ID );		} elseif ( is_category() ) {			$cat = $wp_query->get_queried_object();			$classes[] = 'category';			$classes[] = 'category-' . sanitize_html_class( $cat->slug, $cat->cat_ID );		} elseif ( is_tag() ) {			$tags = $wp_query->get_queried_object();			$classes[] = 'tag';			$classes[] = 'tag-' . sanitize_html_class( $tags->slug, $tags->term_id );		}	} elseif ( is_page() ) {		$classes[] = 'page';		$page_id = $wp_query->get_queried_object_id();		$post = get_page($page_id);		$classes[] = 'page-id-' . $page_id;		if ( $wpdb->get_var( $wpdb->prepare("SELECT ID FROM $wpdb->posts WHERE post_parent = %d AND post_type = 'page' AND post_status = 'publish' LIMIT 1", $page_id) ) )			$classes[] = 'page-parent';		if ( $post->post_parent ) {			$classes[] = 'page-child';			$classes[] = 'parent-pageid-' . $post->post_parent;		}		if ( is_page_template() ) {			$classes[] = 'page-template';			$classes[] = 'page-template-' . sanitize_html_class( str_replace( '.', '-', get_post_meta( $page_id, '_wp_page_template', true ) ), '' );		}	} elseif ( is_search() ) {		if ( !empty( $wp_query->posts ) )			$classes[] = 'search-results';		else			$classes[] = 'search-no-results';	}	if ( is_user_logged_in() )		$classes[] = 'logged-in';	$page = $wp_query->get( 'page' );	if ( !$page || $page < 2)		$page = $wp_query->get( 'paged' );	if ( $page && $page > 1 ) {		$classes[] = 'paged-' . $page;		if ( is_single() )			$classes[] = 'single-paged-' . $page;		elseif ( is_page() )			$classes[] = 'page-paged-' . $page;		elseif ( is_category() )			$classes[] = 'category-paged-' . $page;		elseif ( is_tag() )			$classes[] = 'tag-paged-' . $page;		elseif ( is_date() )			$classes[] = 'date-paged-' . $page;		elseif ( is_author() )			$classes[] = 'author-paged-' . $page;		elseif ( is_search() )			$classes[] = 'search-paged-' . $page;	}	if ( !empty( $class ) ) {		if ( !is_array( $class ) )			$class = preg_split( '#\s+#', $class );		$classes = array_merge( $classes, $class );	}	$classes = array_map( 'esc_attr', $classes );	return apply_filters( 'body_class', $classes, $class );}/** * Whether post requires password and correct password has been provided. * * @since 2.7.0 * * @param int|object $post An optional post.  Global $post used if not provided. * @return bool false if a password is not required or the correct password cookie is present, true otherwise. */function post_password_required( $post = null ) {	$post = get_post($post);	if ( empty($post->post_password) )		return false;	if ( !isset($_COOKIE['wp-postpass_' . COOKIEHASH]) )		return true;	if ( $_COOKIE['wp-postpass_' . COOKIEHASH] != $post->post_password )		return true;	return false;}/** * Display "sticky" CSS class, if a post is sticky. * * @since 2.7.0 * * @param int $post_id An optional post ID. */function sticky_class( $post_id = null ) {	if ( !is_sticky($post_id) )		return;	echo " sticky";}/** * Page Template Functions for usage in Themes * * @package WordPress * @subpackage Template *//** * The formatted output of a list of pages. * * Displays page links for paginated posts (i.e. includes the <!--nextpage-->. * Quicktag one or more times). This tag must be within The Loop. * * The defaults for overwriting are: * 'next_or_number' - Default is 'number' (string). Indicates whether page *      numbers should be used. Valid values are number and next. * 'nextpagelink' - Default is 'Next Page' (string). Text for link to next page. *      of the bookmark. * 'previouspagelink' - Default is 'Previous Page' (string). Text for link to *      previous page, if available. * 'pagelink' - Default is '%' (String).Format string for page numbers. The % in *      the parameter string will be replaced with the page number, so Page % *      generates "Page 1", "Page 2", etc. Defaults to %, just the page number. * 'before' - Default is '<p> Pages:' (string). The html or text to prepend to *      each bookmarks. * 'after' - Default is '</p>' (string). The html or text to append to each *      bookmarks. * 'link_before' - Default is '' (string). The html or text to prepend to each *      Pages link inside the <a> tag. Also prepended to the current item, which *      is not linked. * 'link_after' - Default is '' (string). The html or text to append to each *      Pages link inside the <a> tag. Also appended to the current item, which *      is not linked. * * @since 1.2.0 * @access private * * @param string|array $args Optional. Overwrite the defaults. * @return string Formatted output in HTML. */function wp_link_pages($args = '') {	$defaults = array(		'before' => '<p>' . __('Pages:'), 'after' => '</p>',		'link_before' => '', 'link_after' => '',		'next_or_number' => 'number', 'nextpagelink' => __('Next page'),		'previouspagelink' => __('Previous page'), 'pagelink' => '%',		'echo' => 1	);	$r = wp_parse_args( $args, $defaults );	$r = apply_filters( 'wp_link_pages_args', $r );	extract( $r, EXTR_SKIP );	global $post, $page, $numpages, $multipage, $more, $pagenow;	$output = '';	if ( $multipage ) {		if ( 'number' == $next_or_number ) {			$output .= $before;			for ( $i = 1; $i < ($numpages+1); $i = $i + 1 ) {				$j = str_replace('%',$i,$pagelink);				$output .= ' ';				if ( ($i != $page) || ((!$more) && ($page==1)) ) {					if ( 1 == $i ) {						$output .= '<a href="' . get_permalink() . '">';					} else {						if ( '' == get_option('permalink_structure') || in_array($post->post_status, array('draft', 'pending')) )							$output .= '<a href="' . add_query_arg('page', $i, get_permalink()) . '">';						elseif ( 'page' == get_option('show_on_front') && get_option('page_on_front') == $post->ID )							$output .= '<a href="' . trailingslashit(get_permalink()) . user_trailingslashit('page/' . $i, 'single_paged'). '">';						else							$output .= '<a href="' . trailingslashit(get_permalink()) . user_trailingslashit($i, 'single_paged') . '">';					}				}				$output .= $link_before;				$output .= $j;				$output .= $link_after;				if ( ($i != $page) || ((!$more) && ($page==1)) )					$output .= '</a>';			}			$output .= $after;		} else {			if ( $more ) {				$output .= $before;				$i = $page - 1;				if ( $i && $more ) {					if ( 1 == $i ) {						$output .= '<a href="' . get_permalink() . '">';					} else {						if ( '' == get_option('permalink_structure') || in_array($post->post_status, array('draft', 'pending')) )							$output .= '<a href="' . add_query_arg('page', $i, get_permalink()) . '">';						elseif ( 'page' == get_option('show_on_front') && get_option('page_on_front') == $post->ID )							$output .= '<a href="' . trailingslashit(get_permalink()) . user_trailingslashit('page/' . $i, 'single_paged'). '">';						else							$output .= '<a href="' . trailingslashit(get_permalink()) . user_trailingslashit($i, 'single_paged') . '">';					}					$output .= $link_before. $previouspagelink . $link_after . '</a>';				}				$i = $page + 1;				if ( $i <= $numpages && $more ) {					if ( 1 == $i ) {						$output .= '<a href="' . get_permalink() . '">';					} else {						if ( '' == get_option('permalink_structure') || in_array($post->post_status, array('draft', 'pending')) )							$output .= '<a href="' . add_query_arg('page', $i, get_permalink()) . '">';						elseif ( 'page' == get_option('show_on_front') && get_option('page_on_front') == $post->ID )							$output .= '<a href="' . trailingslashit(get_permalink()) . user_trailingslashit('page/' . $i, 'single_paged'). '">';						else							$output .= '<a href="' . trailingslashit(get_permalink()) . user_trailingslashit($i, 'single_paged') . '">';					}					$output .= $link_before. $nextpagelink . $link_after . '</a>';				}				$output .= $after;			}		}	}	if ( $echo )		echo $output;	return $output;}//// Post-meta: Custom per-post fields.///** * Retrieve post custom meta data field. * * @since 1.5.0 * * @param string $key Meta data key name. * @return bool|string|array Array of values or single value, if only one element exists. False will be returned if key does not exist. */function post_custom( $key = '' ) {	$custom = get_post_custom();	if ( !isset( $custom[$key] ) )		return false;	elseif ( 1 == count($custom[$key]) )		return $custom[$key][0];	else		return $custom[$key];}/** * Display list of post custom fields. * * @internal This will probably change at some point... * @since 1.2.0 * @uses apply_filters() Calls 'the_meta_key' on list item HTML content, with key and value as separate parameters. */function the_meta() {	if ( $keys = get_post_custom_keys() ) {		echo "<ul class='post-meta'>\n";		foreach ( (array) $keys as $key ) {			$keyt = trim($key);			if ( '_' == $keyt{0} )				continue;			$values = array_map('trim', get_post_custom_values($key));			$value = implode($values,', ');			echo apply_filters('the_meta_key', "<li><span class='post-meta-key'>$key:</span> $value</li>\n", $key, $value);		}		echo "</ul>\n";	}}//// Pages///** * Retrieve or display list of pages as a dropdown (select list). * * @since 2.1.0 * * @param array|string $args Optional. Override default arguments. * @return string HTML content, if not displaying. */function wp_dropdown_pages($args = '') {	$defaults = array(		'depth' => 0, 'child_of' => 0,		'selected' => 0, 'echo' => 1,		'name' => 'page_id', 'id' => '',		'show_option_none' => '', 'show_option_no_change' => '',		'option_none_value' => ''	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	$pages = get_pages($r);	$output = '';	$name = esc_attr($name);	// Back-compat with old system where both id and name were based on $name argument	if ( empty($id) )		$id = $name;	if ( ! empty($pages) ) {		$output = "<select name=\"$name\" id=\"$id\">\n";		if ( $show_option_no_change )			$output .= "\t<option value=\"-1\">$show_option_no_change</option>";		if ( $show_option_none )			$output .= "\t<option value=\"" . esc_attr($option_none_value) . "\">$show_option_none</option>\n";		$output .= walk_page_dropdown_tree($pages, $depth, $r);		$output .= "</select>\n";	}	$output = apply_filters('wp_dropdown_pages', $output);	if ( $echo )		echo $output;	return $output;}/** * Retrieve or display list of pages in list (li) format. * * @since 1.5.0 * * @param array|string $args Optional. Override default arguments. * @return string HTML content, if not displaying. */function wp_list_pages($args = '') {	$defaults = array(		'depth' => 0, 'show_date' => '',		'date_format' => get_option('date_format'),		'child_of' => 0, 'exclude' => '',		'title_li' => __('Pages'), 'echo' => 1,		'authors' => '', 'sort_column' => 'menu_order, post_title',		'link_before' => '', 'link_after' => '', 'walker' => '',	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	$output = '';	$current_page = 0;	// sanitize, mostly to keep spaces out	$r['exclude'] = preg_replace('/[^0-9,]/', '', $r['exclude']);	// Allow plugins to filter an array of excluded pages (but don't put a nullstring into the array)	$exclude_array = ( $r['exclude'] ) ? explode(',', $r['exclude']) : array();	$r['exclude'] = implode( ',', apply_filters('wp_list_pages_excludes', $exclude_array) );	// Query pages.	$r['hierarchical'] = 0;	$pages = get_pages($r);	if ( !empty($pages) ) {		if ( $r['title_li'] )			$output .= '<li class="pagenav">' . $r['title_li'] . '<ul>';		global $wp_query;		if ( is_page() || is_attachment() || $wp_query->is_posts_page )			$current_page = $wp_query->get_queried_object_id();		$output .= walk_page_tree($pages, $r['depth'], $current_page, $r);		if ( $r['title_li'] )			$output .= '</ul></li>';	}	$output = apply_filters('wp_list_pages', $output, $r);	if ( $r['echo'] )		echo $output;	else		return $output;}/** * Display or retrieve list of pages with optional home link. * * The arguments are listed below and part of the arguments are for {@link * wp_list_pages()} function. Check that function for more info on those * arguments. * * <ul> * <li><strong>sort_column</strong> - How to sort the list of pages. Defaults * to page title. Use column for posts table.</li> * <li><strong>menu_class</strong> - Class to use for the div ID which contains * the page list. Defaults to 'menu'.</li> * <li><strong>echo</strong> - Whether to echo list or return it. Defaults to * echo.</li> * <li><strong>link_before</strong> - Text before show_home argument text.</li> * <li><strong>link_after</strong> - Text after show_home argument text.</li> * <li><strong>show_home</strong> - If you set this argument, then it will * display the link to the home page. The show_home argument really just needs * to be set to the value of the text of the link.</li> * </ul> * * @since 2.7.0 * * @param array|string $args */function wp_page_menu( $args = array() ) {	$defaults = array('sort_column' => 'menu_order, post_title', 'menu_class' => 'menu', 'echo' => true, 'link_before' => '', 'link_after' => '');	$args = wp_parse_args( $args, $defaults );	$args = apply_filters( 'wp_page_menu_args', $args );	$menu = '';	$list_args = $args;	// Show Home in the menu	if ( ! empty($args['show_home']) ) {		if ( true === $args['show_home'] || '1' === $args['show_home'] || 1 === $args['show_home'] )			$text = __('Home');		else			$text = $args['show_home'];		$class = '';		if ( is_front_page() && !is_paged() )			$class = 'class="current_page_item"';		$menu .= '<li ' . $class . '><a href="' . home_url( '/' ) . '" title="' . esc_attr($text) . '">' . $args['link_before'] . $text . $args['link_after'] . '</a></li>';		// If the front page is a page, add it to the exclude list		if (get_option('show_on_front') == 'page') {			if ( !empty( $list_args['exclude'] ) ) {				$list_args['exclude'] .= ',';			} else {				$list_args['exclude'] = '';			}			$list_args['exclude'] .= get_option('page_on_front');		}	}	$list_args['echo'] = false;	$list_args['title_li'] = '';	$menu .= str_replace( array( "\r", "\n", "\t" ), '', wp_list_pages($list_args) );	if ( $menu )		$menu = '<ul>' . $menu . '</ul>';	$menu = '<div class="' . esc_attr($args['menu_class']) . '">' . $menu . "</div>\n";	$menu = apply_filters( 'wp_page_menu', $menu, $args );	if ( $args['echo'] )		echo $menu;	else		return $menu;}//// Page helpers///** * Retrieve HTML list content for page list. * * @uses Walker_Page to create HTML list content. * @since 2.1.0 * @see Walker_Page::walk() for parameters and return description. */function walk_page_tree($pages, $depth, $current_page, $r) {	if ( empty($r['walker']) )		$walker = new Walker_Page;	else		$walker = $r['walker'];	$args = array($pages, $depth, $r, $current_page);	return call_user_func_array(array(&$walker, 'walk'), $args);}/** * Retrieve HTML dropdown (select) content for page list. * * @uses Walker_PageDropdown to create HTML dropdown content. * @since 2.1.0 * @see Walker_PageDropdown::walk() for parameters and return description. */function walk_page_dropdown_tree() {	$args = func_get_args();	if ( empty($args[2]['walker']) ) // the user's options are the third parameter		$walker = new Walker_PageDropdown;	else		$walker = $args[2]['walker'];	return call_user_func_array(array(&$walker, 'walk'), $args);}//// Attachments///** * Display an attachment page link using an image or icon. * * @since 2.0.0 * * @param int $id Optional. Post ID. * @param bool $fullsize Optional, default is false. Whether to use full size. * @param bool $deprecated Deprecated. Not used. * @param bool $permalink Optional, default is false. Whether to include permalink. */function the_attachment_link( $id = 0, $fullsize = false, $deprecated = false, $permalink = false ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.5' );	if ( $fullsize )		echo wp_get_attachment_link($id, 'full', $permalink);	else		echo wp_get_attachment_link($id, 'thumbnail', $permalink);}/** * Retrieve an attachment page link using an image or icon, if possible. * * @since 2.5.0 * @uses apply_filters() Calls 'wp_get_attachment_link' filter on HTML content with same parameters as function. * * @param int $id Optional. Post ID. * @param string $size Optional, default is 'thumbnail'. Size of image, either array or string. * @param bool $permalink Optional, default is false. Whether to add permalink to image. * @param bool $icon Optional, default is false. Whether to include icon. * @param string $text Optional, default is false. If string, then will be link text. * @return string HTML content. */function wp_get_attachment_link($id = 0, $size = 'thumbnail', $permalink = false, $icon = false, $text = false) {	$id = intval($id);	$_post = & get_post( $id );	if ( ('attachment' != $_post->post_type) || !$url = wp_get_attachment_url($_post->ID) )		return __('Missing Attachment');	if ( $permalink )		$url = get_attachment_link($_post->ID);	$post_title = esc_attr($_post->post_title);	if ( $text ) {		$link_text = esc_attr($text);	} elseif ( ( is_int($size) && $size != 0 ) or ( is_string($size) && $size != 'none' ) or $size != false ) {		$link_text = wp_get_attachment_image($id, $size, $icon);	} else {		$link_text = '';	}	if( trim($link_text) == '' )		$link_text = $_post->post_title;	return apply_filters( 'wp_get_attachment_link', "<a href='$url' title='$post_title'>$link_text</a>", $id, $size, $permalink, $icon, $text );}/** * Wrap attachment in <<p>> element before content. * * @since 2.0.0 * @uses apply_filters() Calls 'prepend_attachment' hook on HTML content. * * @param string $content * @return string */function prepend_attachment($content) {	global $post;	if ( empty($post->post_type) || $post->post_type != 'attachment' )		return $content;	$p = '<p class="attachment">';	// show the medium sized image representation of the attachment if available, and link to the raw file	$p .= wp_get_attachment_link(0, 'medium', false);	$p .= '</p>';	$p = apply_filters('prepend_attachment', $p);	return "$p\n$content";}//// Misc///** * Retrieve protected post password form content. * * @since 1.0.0 * @uses apply_filters() Calls 'the_password_form' filter on output. * * @return string HTML content for password form for password protected post. */function get_the_password_form() {	global $post;	$label = 'pwbox-'.(empty($post->ID) ? rand() : $post->ID);	$output = '<form action="' . get_option('siteurl') . '/wp-pass.php" method="post">	<p>' . __("This post is password protected. To view it please enter your password below:") . '</p>	<p><label for="' . $label . '">' . __("Password:") . ' <input name="post_password" id="' . $label . '" type="password" size="20" /></label> <input type="submit" name="Submit" value="' . esc_attr__("Submit") . '" /></p>	</form>	';	return apply_filters('the_password_form', $output);}/** * Whether currently in a page template. * * This template tag allows you to determine if you are in a page template. * You can optionally provide a template name and then the check will be * specific to that template. * * @since 2.5.0 * @uses $wp_query * * @param string $template The specific template name if specific matching is required. * @return bool False on failure, true if success. */function is_page_template($template = '') {	if (!is_page()) {		return false;	}	global $wp_query;	$page = $wp_query->get_queried_object();	$custom_fields = get_post_custom_values('_wp_page_template',$page->ID);	$page_template = $custom_fields[0];	// We have no argument passed so just see if a page_template has been specified	if ( empty( $template ) ) {		if (!empty( $page_template ) ) {			return true;		}	} elseif ( $template == $page_template) {		return true;	}	return false;}/** * Retrieve formatted date timestamp of a revision (linked to that revisions's page). * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @uses date_i18n() * * @param int|object $revision Revision ID or revision object. * @param bool $link Optional, default is true. Link to revisions's page? * @return string i18n formatted datetimestamp or localized 'Current Revision'. */function wp_post_revision_title( $revision, $link = true ) {	if ( !$revision = get_post( $revision ) )		return $revision;	if ( !in_array( $revision->post_type, array( 'post', 'page', 'revision' ) ) )		return false;	/* translators: revision date format, see http://php.net/date */	$datef = _x( 'j F, Y @ G:i', 'revision date format');	/* translators: 1: date */	$autosavef = __( '%1$s [Autosave]' );	/* translators: 1: date */	$currentf  = __( '%1$s [Current Revision]' );	$date = date_i18n( $datef, strtotime( $revision->post_modified ) );	if ( $link && current_user_can( 'edit_post', $revision->ID ) && $link = get_edit_post_link( $revision->ID ) )		$date = "<a href='$link'>$date</a>";	if ( !wp_is_post_revision( $revision ) )		$date = sprintf( $currentf, $date );	elseif ( wp_is_post_autosave( $revision ) )		$date = sprintf( $autosavef, $date );	return $date;}/** * Display list of a post's revisions. * * Can output either a UL with edit links or a TABLE with diff interface, and * restore action links. * * Second argument controls parameters: *   (bool)   parent : include the parent (the "Current Revision") in the list. *   (string) format : 'list' or 'form-table'.  'list' outputs UL, 'form-table' *                     outputs TABLE with UI. *   (int)    right  : what revision is currently being viewed - used in *                     form-table format. *   (int)    left   : what revision is currently being diffed against right - *                     used in form-table format. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @uses wp_get_post_revisions() * @uses wp_post_revision_title() * @uses get_edit_post_link() * @uses get_the_author_meta() * * @todo split into two functions (list, form-table) ? * * @param int|object $post_id Post ID or post object. * @param string|array $args See description {@link wp_parse_args()}. * @return null */function wp_list_post_revisions( $post_id = 0, $args = null ) {	if ( !$post = get_post( $post_id ) )		return;	$defaults = array( 'parent' => false, 'right' => false, 'left' => false, 'format' => 'list', 'type' => 'all' );	extract( wp_parse_args( $args, $defaults ), EXTR_SKIP );	switch ( $type ) {		case 'autosave' :			if ( !$autosave = wp_get_post_autosave( $post->ID ) )				return;			$revisions = array( $autosave );			break;		case 'revision' : // just revisions - remove autosave later		case 'all' :		default :			if ( !$revisions = wp_get_post_revisions( $post->ID ) )				return;			break;	}	/* translators: post revision: 1: when, 2: author name */	$titlef = _x( '%1$s by %2$s', 'post revision' );	if ( $parent )		array_unshift( $revisions, $post );	$rows = '';	$class = false;	$can_edit_post = current_user_can( 'edit_post', $post->ID );	foreach ( $revisions as $revision ) {		if ( !current_user_can( 'read_post', $revision->ID ) )			continue;		if ( 'revision' === $type && wp_is_post_autosave( $revision ) )			continue;		$date = wp_post_revision_title( $revision );		$name = get_the_author_meta( 'display_name', $revision->post_author );		if ( 'form-table' == $format ) {			if ( $left )				$left_checked = $left == $revision->ID ? ' checked="checked"' : '';			else				$left_checked = $right_checked ? ' checked="checked"' : ''; // [sic] (the next one)			$right_checked = $right == $revision->ID ? ' checked="checked"' : '';			$class = $class ? '' : " class='alternate'";			if ( $post->ID != $revision->ID && $can_edit_post )				$actions = '<a href="' . wp_nonce_url( add_query_arg( array( 'revision' => $revision->ID, 'action' => 'restore' ) ), "restore-post_$post->ID|$revision->ID" ) . '">' . __( 'Restore' ) . '</a>';			else				$actions = '';			$rows .= "<tr$class>\n";			$rows .= "\t<th style='white-space: nowrap' scope='row'><input type='radio' name='left' value='$revision->ID'$left_checked /></th>\n";			$rows .= "\t<th style='white-space: nowrap' scope='row'><input type='radio' name='right' value='$revision->ID'$right_checked /></th>\n";			$rows .= "\t<td>$date</td>\n";			$rows .= "\t<td>$name</td>\n";			$rows .= "\t<td class='action-links'>$actions</td>\n";			$rows .= "</tr>\n";		} else {			$title = sprintf( $titlef, $date, $name );			$rows .= "\t<li>$title</li>\n";		}	}	if ( 'form-table' == $format ) : ?><form action="revision.php" method="get"><div class="tablenav">	<div class="alignleft">		<input type="submit" class="button-secondary" value="<?php esc_attr_e( 'Compare Revisions' ); ?>" />		<input type="hidden" name="action" value="diff" />		<input type="hidden" name="post_type" value="<?php echo esc_attr($post->post_type); ?>" />	</div></div><br class="clear" /><table class="widefat post-revisions" cellspacing="0" id="post-revisions">	<col />	<col />	<col style="width: 33%" />	<col style="width: 33%" />	<col style="width: 33%" /><thead><tr>	<th scope="col"><?php /* translators: column name in revisons */ _ex( 'Old', 'revisions column name' ); ?></th>	<th scope="col"><?php /* translators: column name in revisons */ _ex( 'New', 'revisions column name' ); ?></th>	<th scope="col"><?php /* translators: column name in revisons */ _ex( 'Date Created', 'revisions column name' ); ?></th>	<th scope="col"><?php _e( 'Author' ); ?></th>	<th scope="col" class="action-links"><?php _e( 'Actions' ); ?></th></tr></thead><tbody><?php echo $rows; ?></tbody></table></form><?php	else :		echo "<ul class='post-revisions'>\n";		echo $rows;		echo "</ul>";	endif;}
<?php/** * Canonical API to handle WordPress Redirecting * * Based on "Permalink Redirect" from Scott Yang and "Enforce www. Preference" * by Mark Jaquith * * @package WordPress * @since 2.3.0 *//** * Redirects incoming links to the proper URL based on the site url. * * Search engines consider www.somedomain.com and somedomain.com to be two * different URLs when they both go to the same location. This SEO enhancement * prevents penality for duplicate content by redirecting all incoming links to * one or the other. * * Prevents redirection for feeds, trackbacks, searches, comment popup, and * admin URLs. Does not redirect on IIS, page/post previews, and on form data. * * Will also attempt to find the correct link when a user enters a URL that does * not exist based on exact WordPress query. Will instead try to parse the URL * or query in an attempt to figure the correct page to go to. * * @since 2.3.0 * @uses $wp_rewrite * @uses $is_IIS * * @param string $requested_url Optional. The URL that was requested, used to *		figure if redirect is needed. * @param bool $do_redirect Optional. Redirect to the new URL. * @return null|false|string Null, if redirect not needed. False, if redirect *		not needed or the string of the URL */function redirect_canonical($requested_url=null, $do_redirect=true) {	global $wp_rewrite, $is_IIS, $wp_query, $wpdb;	if ( is_trackback() || is_search() || is_comments_popup() || is_admin() || $is_IIS || ( isset($_POST) && count($_POST) ) || is_preview() || is_robots() )		return;	if ( !$requested_url ) {		// build the URL in the address bar		$requested_url  = is_ssl() ? 'https://' : 'http://';		$requested_url .= $_SERVER['HTTP_HOST'];		$requested_url .= $_SERVER['REQUEST_URI'];	}	$original = @parse_url($requested_url);	if ( false === $original )		return;	// Some PHP setups turn requests for / into /index.php in REQUEST_URI	// See: http://trac.wordpress.org/ticket/5017	// See: http://trac.wordpress.org/ticket/7173	// Disabled, for now:	// $original['path'] = preg_replace('|/index\.php$|', '/', $original['path']);	$redirect = $original;	$redirect_url = false;	// Notice fixing	if ( !isset($redirect['path']) )		$redirect['path'] = '';	if ( !isset($redirect['query']) )		$redirect['query'] = '';	if ( is_singular() && 1 > $wp_query->post_count && ($id = get_query_var('p')) ) {		$vars = $wpdb->get_results( $wpdb->prepare("SELECT post_type, post_parent FROM $wpdb->posts WHERE ID = %d", $id) );		if ( isset($vars[0]) && $vars = $vars[0] ) {			if ( 'revision' == $vars->post_type && $vars->post_parent > 0 )				$id = $vars->post_parent;			if ( $redirect_url = get_permalink($id) )				$redirect['query'] = remove_query_arg(array('p', 'page_id', 'attachment_id', 'post_type'), $redirect['query']);		}	}	// These tests give us a WP-generated permalink	if ( is_404() ) {		// Redirect ?page_id, ?p=, ?attachment_id= to their respective url's		$id = max( get_query_var('p'), get_query_var('page_id'), get_query_var('attachment_id') );		if ( $id && $redirect_post = get_post($id) ) {			$post_type_obj = get_post_type_object($redirect_post->post_type);			if ( $post_type_obj->public ) {				$redirect_url = get_permalink($redirect_post);				$redirect['query'] = remove_query_arg(array('p', 'page_id', 'attachment_id', 'post_type'), $redirect['query']);			}		}		if ( ! $redirect_url )			$redirect_url = redirect_guess_404_permalink();	} elseif ( is_object($wp_rewrite) && $wp_rewrite->using_permalinks() ) {		// rewriting of old ?p=X, ?m=2004, ?m=200401, ?m=20040101		if ( is_attachment() && !empty($_GET['attachment_id']) && ! $redirect_url ) {			if ( $redirect_url = get_attachment_link(get_query_var('attachment_id')) )				$redirect['query'] = remove_query_arg('attachment_id', $redirect['query']);		} elseif ( is_single() && !empty($_GET['p']) && ! $redirect_url ) {			if ( $redirect_url = get_permalink(get_query_var('p')) )				$redirect['query'] = remove_query_arg(array('p', 'post_type'), $redirect['query']);			if ( get_query_var( 'page' ) ) {				$redirect_url = trailingslashit( $redirect_url ) . user_trailingslashit( get_query_var( 'page' ), 'single_paged' );				$redirect['query'] = remove_query_arg( 'page', $redirect['query'] );			}		} elseif ( is_single() && !empty($_GET['name'])  && ! $redirect_url ) {			if ( $redirect_url = get_permalink( $wp_query->get_queried_object_id() ) )				$redirect['query'] = remove_query_arg('name', $redirect['query']);		} elseif ( is_page() && !empty($_GET['page_id']) && ! $redirect_url ) {			if ( $redirect_url = get_permalink(get_query_var('page_id')) )				$redirect['query'] = remove_query_arg('page_id', $redirect['query']);		} elseif ( is_page() && !is_feed() && isset($wp_query->queried_object) && 'page' == get_option('show_on_front') && $wp_query->queried_object->ID == get_option('page_on_front')  && ! $redirect_url ) {			$redirect_url = home_url('/');		} elseif ( is_home() && !empty($_GET['page_id']) && 'page' == get_option('show_on_front') && get_query_var('page_id') == get_option('page_for_posts')  && ! $redirect_url ) {			if ( $redirect_url = get_permalink(get_option('page_for_posts')) )				$redirect['query'] = remove_query_arg('page_id', $redirect['query']);		} elseif ( !empty($_GET['m']) && ( is_year() || is_month() || is_day() ) ) {			$m = get_query_var('m');			switch ( strlen($m) ) {				case 4: // Yearly					$redirect_url = get_year_link($m);					break;				case 6: // Monthly					$redirect_url = get_month_link( substr($m, 0, 4), substr($m, 4, 2) );					break;				case 8: // Daily					$redirect_url = get_day_link(substr($m, 0, 4), substr($m, 4, 2), substr($m, 6, 2));					break;			}			if ( $redirect_url )				$redirect['query'] = remove_query_arg('m', $redirect['query']);		// now moving on to non ?m=X year/month/day links		} elseif ( is_day() && get_query_var('year') && get_query_var('monthnum') && !empty($_GET['day']) ) {			if ( $redirect_url = get_day_link(get_query_var('year'), get_query_var('monthnum'), get_query_var('day')) )				$redirect['query'] = remove_query_arg(array('year', 'monthnum', 'day'), $redirect['query']);		} elseif ( is_month() && get_query_var('year') && !empty($_GET['monthnum']) ) {			if ( $redirect_url = get_month_link(get_query_var('year'), get_query_var('monthnum')) )				$redirect['query'] = remove_query_arg(array('year', 'monthnum'), $redirect['query']);		} elseif ( is_year() && !empty($_GET['year']) ) {			if ( $redirect_url = get_year_link(get_query_var('year')) )				$redirect['query'] = remove_query_arg('year', $redirect['query']);		} elseif ( is_author() && !empty($_GET['author']) && preg_match( '|^[0-9]+$|', $_GET['author'] ) ) {			$author = get_userdata(get_query_var('author'));			if ( false !== $author && $redirect_url = get_author_posts_url($author->ID, $author->user_nicename) )				$redirect['query'] = remove_query_arg('author', $redirect['query']);		} elseif ( is_category() || is_tag() || is_tax() ) { // Terms (Tags/categories)			$term_count = 0;			foreach ( array('category__in', 'category__not_in', 'category__and', 'post__in', 'post__not_in',			'tag__in', 'tag__not_in', 'tag__and', 'tag_slug__in', 'tag_slug__and') as $key )				$term_count += count($wp_query->query_vars[$key]);			$obj = $wp_query->get_queried_object();			if ( $term_count <= 1 && !empty($obj->term_id) && ( $tax_url = get_term_link((int)$obj->term_id, $obj->taxonomy) ) && !is_wp_error($tax_url) ) {				if ( is_category() ) {					$redirect['query'] = remove_query_arg( array( 'category_name', 'category', 'cat'), $redirect['query']);				} elseif ( is_tag() ) {					$redirect['query'] = remove_query_arg( array( 'tag', 'tag_id'), $redirect['query']);				} elseif ( is_tax() ) { // Custom taxonomies will have a custom query var, remove those too:					$tax = get_taxonomy( $obj->taxonomy );					if ( false !== $tax->query_var)						$redirect['query'] = remove_query_arg($tax->query_var, $redirect['query']);					else						$redirect['query'] = remove_query_arg( array( 'term', 'taxonomy'), $redirect['query']);				}				$tax_url = parse_url($tax_url);				if ( ! empty($tax_url['query']) ) { // Custom taxonomies may only be accessable via ?taxonomy=..&term=..					parse_str($tax_url['query'], $query_vars);					$redirect['query'] = add_query_arg($query_vars, $redirect['query']);				} else { // Taxonomy is accessable via a "pretty-URL"					$redirect['path'] = $tax_url['path'];				}			}		} elseif ( is_single() && strpos($wp_rewrite->permalink_structure, '%category%') !== false ) {			$category = get_term_by('slug', get_query_var('category_name'), 'category');			$post_terms = wp_get_object_terms($wp_query->get_queried_object_id(), 'category', array('fields' => 'tt_ids'));			if ( (!$category || is_wp_error($category)) || ( !is_wp_error($post_terms) && !empty($post_terms) && !in_array($category->term_taxonomy_id, $post_terms) ) )				$redirect_url = get_permalink($wp_query->get_queried_object_id());		}		// paging and feeds		if ( get_query_var('paged') || is_feed() || get_query_var('cpage') ) {			if ( !$redirect_url )				$redirect_url = $requested_url;			$paged_redirect = @parse_url($redirect_url);			while ( preg_match( '#/page/?[0-9]+?(/+)?$#', $paged_redirect['path'] ) || preg_match( '#/(comments/?)?(feed|rss|rdf|atom|rss2)(/+)?$#', $paged_redirect['path'] ) || preg_match( '#/comment-page-[0-9]+(/+)?$#', $paged_redirect['path'] ) ) {				// Strip off paging and feed				$paged_redirect['path'] = preg_replace('#/page/?[0-9]+?(/+)?$#', '/', $paged_redirect['path']); // strip off any existing paging				$paged_redirect['path'] = preg_replace('#/(comments/?)?(feed|rss2?|rdf|atom)(/+|$)#', '/', $paged_redirect['path']); // strip off feed endings				$paged_redirect['path'] = preg_replace('#/comment-page-[0-9]+?(/+)?$#', '/', $paged_redirect['path']); // strip off any existing comment paging			}			$addl_path = '';			if ( is_feed() ) {				$addl_path = !empty( $addl_path ) ? trailingslashit($addl_path) : '';				if ( get_query_var( 'withcomments' ) )					$addl_path .= 'comments/';				$addl_path .= user_trailingslashit( 'feed/' . ( ( get_default_feed() ==  get_query_var('feed') || 'feed' == get_query_var('feed') ) ? '' : get_query_var('feed') ), 'feed' );				$redirect['query'] = remove_query_arg( 'feed', $redirect['query'] );			}			if ( get_query_var('paged') > 0 ) {				$paged = get_query_var('paged');				$redirect['query'] = remove_query_arg( 'paged', $redirect['query'] );				if ( !is_feed() ) {					if ( $paged > 1 && !is_single() ) {						$addl_path = ( !empty( $addl_path ) ? trailingslashit($addl_path) : '' ) . user_trailingslashit("page/$paged", 'paged');					} elseif ( !is_single() ) {						$addl_path = !empty( $addl_path ) ? trailingslashit($addl_path) : '';					}				} elseif ( $paged > 1 ) {					$redirect['query'] = add_query_arg( 'paged', $paged, $redirect['query'] );				}			}			if ( get_option('page_comments') && ( ( 'newest' == get_option('default_comments_page') && get_query_var('cpage') > 0 ) || ( 'newest' != get_option('default_comments_page') && get_query_var('cpage') > 1 ) ) ) {				$addl_path = ( !empty( $addl_path ) ? trailingslashit($addl_path) : '' ) . user_trailingslashit( 'comment-page-' . get_query_var('cpage'), 'commentpaged' );				$redirect['query'] = remove_query_arg( 'cpage', $redirect['query'] );			}			$paged_redirect['path'] = user_trailingslashit( preg_replace('|/index.php/?$|', '/', $paged_redirect['path']) ); // strip off trailing /index.php/			if ( !empty( $addl_path ) && $wp_rewrite->using_index_permalinks() && strpos($paged_redirect['path'], '/index.php/') === false )				$paged_redirect['path'] = trailingslashit($paged_redirect['path']) . 'index.php/';			if ( !empty( $addl_path ) )				$paged_redirect['path'] = trailingslashit($paged_redirect['path']) . $addl_path;			$redirect_url = $paged_redirect['scheme'] . '://' . $paged_redirect['host'] . $paged_redirect['path'];			$redirect['path'] = $paged_redirect['path'];		}	}	// tack on any additional query vars	$redirect['query'] = preg_replace( '#^\??&*?#', '', $redirect['query'] );	if ( $redirect_url && !empty($redirect['query']) ) {		if ( strpos($redirect_url, '?') !== false )			$redirect_url .= '&';		else			$redirect_url .= '?';		$redirect_url .= $redirect['query'];	}	if ( $redirect_url )		$redirect = @parse_url($redirect_url);	// www.example.com vs example.com	$user_home = @parse_url(home_url());	if ( !empty($user_home['host']) )		$redirect['host'] = $user_home['host'];	if ( empty($user_home['path']) )		$user_home['path'] = '/';	// Handle ports	if ( !empty($user_home['port']) )		$redirect['port'] = $user_home['port'];	else		unset($redirect['port']);	// trailing /index.php	$redirect['path'] = preg_replace('|/index.php/*?$|', '/', $redirect['path']);	// Remove trailing spaces from the path	$redirect['path'] = preg_replace( '#(%20| )+$#', '', $redirect['path'] );	if ( !empty( $redirect['query'] ) ) {		// Remove trailing spaces from certain terminating query string args		$redirect['query'] = preg_replace( '#((p|page_id|cat|tag)=[^&]*?)(%20| )+$#', '$1', $redirect['query'] );		// Clean up empty query strings		$redirect['query'] = trim(preg_replace( '#(^|&)(p|page_id|cat|tag)=?(&|$)#', '&', $redirect['query']), '&');		// Remove redundant leading ampersands		$redirect['query'] = preg_replace( '#^\??&*?#', '', $redirect['query'] );	}	// strip /index.php/ when we're not using PATHINFO permalinks	if ( !$wp_rewrite->using_index_permalinks() )		$redirect['path'] = str_replace('/index.php/', '/', $redirect['path']);	// trailing slashes	if ( is_object($wp_rewrite) && $wp_rewrite->using_permalinks() && !is_404() && (!is_front_page() || ( is_front_page() && (get_query_var('paged') > 1) ) ) ) {		$user_ts_type = '';		if ( get_query_var('paged') > 0 ) {			$user_ts_type = 'paged';		} else {			foreach ( array('single', 'category', 'page', 'day', 'month', 'year', 'home') as $type ) {				$func = 'is_' . $type;				if ( call_user_func($func) ) {					$user_ts_type = $type;					break;				}			}		}		$redirect['path'] = user_trailingslashit($redirect['path'], $user_ts_type);	} elseif ( is_front_page() ) {		$redirect['path'] = trailingslashit($redirect['path']);	}	// Strip multiple slashes out of the URL	if ( strpos($redirect['path'], '//') > -1 )		$redirect['path'] = preg_replace('|/+|', '/', $redirect['path']);	// Always trailing slash the Front Page URL	if ( trailingslashit( $redirect['path'] ) == trailingslashit( $user_home['path'] ) )		$redirect['path'] = trailingslashit($redirect['path']);	// Ignore differences in host capitalization, as this can lead to infinite redirects	// Only redirect no-www <=> yes-www	if ( strtolower($original['host']) == strtolower($redirect['host']) ||		( strtolower($original['host']) != 'www.' . strtolower($redirect['host']) && 'www.' . strtolower($original['host']) != strtolower($redirect['host']) ) )		$redirect['host'] = $original['host'];	$compare_original = array($original['host'], $original['path']);	if ( !empty( $original['port'] ) )		$compare_original[] = $original['port'];	if ( !empty( $original['query'] ) )		$compare_original[] = $original['query'];	$compare_redirect = array($redirect['host'], $redirect['path']);	if ( !empty( $redirect['port'] ) )		$compare_redirect[] = $redirect['port'];	if ( !empty( $redirect['query'] ) )		$compare_redirect[] = $redirect['query'];	if ( $compare_original !== $compare_redirect ) {		$redirect_url = $redirect['scheme'] . '://' . $redirect['host'];		if ( !empty($redirect['port']) )			$redirect_url .= ':' . $redirect['port'];		$redirect_url .= $redirect['path'];		if ( !empty($redirect['query']) )			$redirect_url .= '?' . $redirect['query'];	}	if ( !$redirect_url || $redirect_url == $requested_url )		return false;	// Note that you can use the "redirect_canonical" filter to cancel a canonical redirect for whatever reason by returning FALSE	$redirect_url = apply_filters('redirect_canonical', $redirect_url, $requested_url);	if ( !$redirect_url || $redirect_url == $requested_url ) // yes, again -- in case the filter aborted the request		return false;	if ( $do_redirect ) {		// protect against chained redirects		if ( !redirect_canonical($redirect_url, false) ) {			wp_redirect($redirect_url, 301);			exit();		} else {			// Debug			// die("1: $redirect_url<br />2: " . redirect_canonical( $redirect_url, false ) );			return false;		}	} else {		return $redirect_url;	}}/** * Attempts to guess correct post based on query vars. * * @since 2.3.0 * @uses $wpdb * * @return bool|string Returns False, if it can't find post, returns correct *		location on success. */function redirect_guess_404_permalink() {	global $wpdb;	if ( !get_query_var('name') )		return false;	$where = $wpdb->prepare("post_name LIKE %s", get_query_var('name') . '%');	// if any of post_type, year, monthnum, or day are set, use them to refine the query	if ( get_query_var('post_type') )		$where .= $wpdb->prepare(" AND post_type = %s", get_query_var('post_type'));	if ( get_query_var('year') )		$where .= $wpdb->prepare(" AND YEAR(post_date) = %d", get_query_var('year'));	if ( get_query_var('monthnum') )		$where .= $wpdb->prepare(" AND MONTH(post_date) = %d", get_query_var('monthnum'));	if ( get_query_var('day') )		$where .= $wpdb->prepare(" AND DAYOFMONTH(post_date) = %d", get_query_var('day'));	$post_id = $wpdb->get_var("SELECT ID FROM $wpdb->posts WHERE $where AND post_status = 'publish'");	if ( !$post_id )		return false;	return get_permalink($post_id);}add_action('template_redirect', 'redirect_canonical');?>
<?php/** * Install plugin administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can('install_plugins') )	wp_die(__('You do not have sufficient permissions to install plugins on this site.'));include(ABSPATH . 'wp-admin/includes/plugin-install.php');$title = __('Install Plugins');$parent_file = 'plugins.php';wp_reset_vars( array('tab', 'paged') );//These are the tabs which are shown on the page,$tabs = array();$tabs['dashboard'] = __('Search');if ( 'search' == $tab )	$tabs['search']	= __('Search Results');$tabs['upload'] = __('Upload');$tabs['featured'] = _x('Featured','Plugin Installer');$tabs['popular']  = _x('Popular','Plugin Installer');$tabs['new']      = _x('Newest','Plugin Installer');$tabs['updated']  = _x('Recently Updated','Plugin Installer');$nonmenu_tabs = array('plugin-information'); //Valid actions to perform which do not have a Menu item.$tabs = apply_filters('install_plugins_tabs', $tabs );$nonmenu_tabs = apply_filters('install_plugins_nonmenu_tabs', $nonmenu_tabs);//If a non-valid menu tab has been selected, And its not a non-menu action.if ( empty($tab) || ( ! isset($tabs[ $tab ]) && ! in_array($tab, (array)$nonmenu_tabs) ) ) {	$tab_actions = array_keys($tabs);	$tab = $tab_actions[0];}if ( empty($paged) )	$paged = 1;wp_enqueue_style( 'plugin-install' );wp_enqueue_script( 'plugin-install' );if ( 'plugin-information' != $tab )	add_thickbox();$body_id = $tab;do_action('install_plugins_pre_' . $tab); //Used to override the general interface, Eg, install or plugin information.add_contextual_help($current_screen,	'<p>' . sprintf(__('Plugins hook into WordPress to extend its functionality with custom features. Plugins are developed independently from WordPress core by thousands of developers all over the world. All plugins in the official <a href="%s" target="_blank">WordPress.org Plugin Directory</a> are compatible with the WordPress GPL v2 license. You can find new plugins to install by searching or browsing the Directory right here in your own Plugins section.'), 'http://wordpress.org/extend/plugins/') . '</p>' .	'<p>' . __('If you know what you&#8217;re looking for, Search is your best bet. The Search screen has options to search the WordPress.org Plugin Directory for a particular Term, Author, or Tag. You can also search the directory by selecting a popular tags. Tags in larger type mean more plugins have been labeled with that tag.') . '</p>' .	'<p>' . __('If you just want to get an idea of what&#8217;s available, you can browse Featured, Popular, Newest, and Recently Updated plugins by using the links in the upper left of the screen. These sections rotate regularly.') . '</p>' .	'<p>' . __('If you want to install a plugin that you&#8217;ve downloaded elsewhere, click Upload in the upper left. You will be prompted to upload the .zip package, and once uploaded, you can activate the new plugin.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Plugins_Add_New_SubPanel" target="_blank">Documentation on Installing Plugins</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');include('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2>	<ul class="subsubsub"><?php$display_tabs = array();foreach ( (array)$tabs as $action => $text ) {	$sep = ( end($tabs) != $text ) ? ' | ' : '';	$class = ( $action == $tab ) ? ' class="current"' : '';	$href = admin_url('plugin-install.php?tab=' . $action);	echo "\t\t<li><a href='$href'$class>$text</a>$sep</li>\n";}?>	</ul>	<br class="clear" />	<?php do_action('install_plugins_' . $tab, $paged); ?></div><?phpinclude('./admin-footer.php');
<?php/** * WordPress Roles and Capabilities. * * @package WordPress * @subpackage User *//** * WordPress User Roles. * * The role option is simple, the structure is organized by role name that store * the name in value of the 'name' key. The capabilities are stored as an array * in the value of the 'capability' key. * * <code> * array ( *		'rolename' => array ( *			'name' => 'rolename', *			'capabilities' => array() *		) * ) * </code> * * @since 2.0.0 * @package WordPress * @subpackage User */class WP_Roles {	/**	 * List of roles and capabilities.	 *	 * @since 2.0.0	 * @access public	 * @var array	 */	var $roles;	/**	 * List of the role objects.	 *	 * @since 2.0.0	 * @access public	 * @var array	 */	var $role_objects = array();	/**	 * List of role names.	 *	 * @since 2.0.0	 * @access public	 * @var array	 */	var $role_names = array();	/**	 * Option name for storing role list.	 *	 * @since 2.0.0	 * @access public	 * @var string	 */	var $role_key;	/**	 * Whether to use the database for retrieval and storage.	 *	 * @since 2.1.0	 * @access public	 * @var bool	 */	var $use_db = true;	/**	 * PHP4 Constructor - Call {@link WP_Roles::_init()} method.	 *	 * @since 2.0.0	 * @access public	 *	 * @return WP_Roles	 */	function WP_Roles() {		$this->_init();	}	/**	 * Set up the object properties.	 *	 * The role key is set to the current prefix for the $wpdb object with	 * 'user_roles' appended. If the $wp_user_roles global is set, then it will	 * be used and the role option will not be updated or used.	 *	 * @since 2.1.0	 * @access protected	 * @uses $wpdb Used to get the database prefix.	 * @global array $wp_user_roles Used to set the 'roles' property value.	 */	function _init () {		global $wpdb, $wp_user_roles;		$this->role_key = $wpdb->prefix . 'user_roles';		if ( ! empty( $wp_user_roles ) ) {			$this->roles = $wp_user_roles;			$this->use_db = false;		} else {			$this->roles = get_option( $this->role_key );		}		if ( empty( $this->roles ) )			return;		$this->role_objects = array();		$this->role_names =  array();		foreach ( (array) $this->roles as $role => $data ) {			$this->role_objects[$role] = new WP_Role( $role, $this->roles[$role]['capabilities'] );			$this->role_names[$role] = $this->roles[$role]['name'];		}	}	/**	 * Add role name with capabilities to list.	 *	 * Updates the list of roles, if the role doesn't already exist.	 *	 * The capabilities are defined in the following format `array( 'read' => true );`	 * To explicitly deny a role a capability you set the value for that capability to false.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $role Role name.	 * @param string $display_name Role display name.	 * @param array $capabilities List of role capabilities in the above format.	 * @return null|WP_Role WP_Role object if role is added, null if already exists.	 */	function add_role( $role, $display_name, $capabilities = array() ) {		if ( isset( $this->roles[$role] ) )			return;		$this->roles[$role] = array(			'name' => $display_name,			'capabilities' => $capabilities			);		if ( $this->use_db )			update_option( $this->role_key, $this->roles );		$this->role_objects[$role] = new WP_Role( $role, $capabilities );		$this->role_names[$role] = $display_name;		return $this->role_objects[$role];	}	/**	 * Remove role by name.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $role Role name.	 */	function remove_role( $role ) {		if ( ! isset( $this->role_objects[$role] ) )			return;		unset( $this->role_objects[$role] );		unset( $this->role_names[$role] );		unset( $this->roles[$role] );		if ( $this->use_db )			update_option( $this->role_key, $this->roles );	}	/**	 * Add capability to role.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $role Role name.	 * @param string $cap Capability name.	 * @param bool $grant Optional, default is true. Whether role is capable of performing capability.	 */	function add_cap( $role, $cap, $grant = true ) {		$this->roles[$role]['capabilities'][$cap] = $grant;		if ( $this->use_db )			update_option( $this->role_key, $this->roles );	}	/**	 * Remove capability from role.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $role Role name.	 * @param string $cap Capability name.	 */	function remove_cap( $role, $cap ) {		unset( $this->roles[$role]['capabilities'][$cap] );		if ( $this->use_db )			update_option( $this->role_key, $this->roles );	}	/**	 * Retrieve role object by name.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $role Role name.	 * @return object|null Null, if role does not exist. WP_Role object, if found.	 */	function &get_role( $role ) {		if ( isset( $this->role_objects[$role] ) )			return $this->role_objects[$role];		else			return null;	}	/**	 * Retrieve list of role names.	 *	 * @since 2.0.0	 * @access public	 *	 * @return array List of role names.	 */	function get_names() {		return $this->role_names;	}	/**	 * Whether role name is currently in the list of available roles.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $role Role name to look up.	 * @return bool	 */	function is_role( $role )	{		return isset( $this->role_names[$role] );	}}/** * WordPress Role class. * * @since 2.0.0 * @package WordPress * @subpackage User */class WP_Role {	/**	 * Role name.	 *	 * @since 2.0.0	 * @access public	 * @var string	 */	var $name;	/**	 * List of capabilities the role contains.	 *	 * @since 2.0.0	 * @access public	 * @var array	 */	var $capabilities;	/**	 * PHP4 Constructor - Set up object properties.	 *	 * The list of capabilities, must have the key as the name of the capability	 * and the value a boolean of whether it is granted to the role.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $role Role name.	 * @param array $capabilities List of capabilities.	 * @return WP_Role	 */	function WP_Role( $role, $capabilities ) {		$this->name = $role;		$this->capabilities = $capabilities;	}	/**	 * Assign role a capability.	 *	 * @see WP_Roles::add_cap() Method uses implementation for role.	 * @since 2.0.0	 * @access public	 *	 * @param string $cap Capability name.	 * @param bool $grant Whether role has capability privilege.	 */	function add_cap( $cap, $grant = true ) {		global $wp_roles;		if ( ! isset( $wp_roles ) )			$wp_roles = new WP_Roles();		$this->capabilities[$cap] = $grant;		$wp_roles->add_cap( $this->name, $cap, $grant );	}	/**	 * Remove capability from role.	 *	 * This is a container for {@link WP_Roles::remove_cap()} to remove the	 * capability from the role. That is to say, that {@link	 * WP_Roles::remove_cap()} implements the functionality, but it also makes	 * sense to use this class, because you don't need to enter the role name.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $cap Capability name.	 */	function remove_cap( $cap ) {		global $wp_roles;		if ( ! isset( $wp_roles ) )			$wp_roles = new WP_Roles();		unset( $this->capabilities[$cap] );		$wp_roles->remove_cap( $this->name, $cap );	}	/**	 * Whether role has capability.	 *	 * The capabilities is passed through the 'role_has_cap' filter. The first	 * parameter for the hook is the list of capabilities the class has	 * assigned. The second parameter is the capability name to look for. The	 * third and final parameter for the hook is the role name.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $cap Capability name.	 * @return bool True, if user has capability. False, if doesn't have capability.	 */	function has_cap( $cap ) {		$capabilities = apply_filters( 'role_has_cap', $this->capabilities, $cap, $this->name );		if ( !empty( $capabilities[$cap] ) )			return $capabilities[$cap];		else			return false;	}}/** * WordPress User class. * * @since 2.0.0 * @package WordPress * @subpackage User */class WP_User {	/**	 * User data container.	 *	 * This will be set as properties of the object.	 *	 * @since 2.0.0	 * @access private	 * @var array	 */	var $data;	/**	 * The user's ID.	 *	 * @since 2.1.0	 * @access public	 * @var int	 */	var $ID = 0;	/**	 * The deprecated user's ID.	 *	 * @since 2.0.0	 * @access public	 * @deprecated Use WP_User::$ID	 * @see WP_User::$ID	 * @var int	 */	var $id = 0;	/**	 * The individual capabilities the user has been given.	 *	 * @since 2.0.0	 * @access public	 * @var array	 */	var $caps = array();	/**	 * User metadata option name.	 *	 * @since 2.0.0	 * @access public	 * @var string	 */	var $cap_key;	/**	 * The roles the user is part of.	 *	 * @since 2.0.0	 * @access public	 * @var array	 */	var $roles = array();	/**	 * All capabilities the user has, including individual and role based.	 *	 * @since 2.0.0	 * @access public	 * @var array	 */	var $allcaps = array();	/**	 * First name of the user.	 *	 * Created to prevent notices.	 *	 * @since 2.7.0	 * @access public	 * @var string	 */	var $first_name = '';	/**	 * Last name of the user.	 *	 * Created to prevent notices.	 *	 * @since 2.7.0	 * @access public	 * @var string	 */	var $last_name = '';	/**	 * The filter context applied to user data fields.	 *	 * @since 2.9.0	 * @access private	 * @var string	 */	var $filter = null;	/**	 * PHP4 Constructor - Sets up the object properties.	 *	 * Retrieves the userdata and then assigns all of the data keys to direct	 * properties of the object. Calls {@link WP_User::_init_caps()} after	 * setting up the object's user data properties.	 *	 * @since 2.0.0	 * @access public	 *	 * @param int|string $id User's ID or username	 * @param int $name Optional. User's username	 * @return WP_User	 */	function WP_User( $id, $name = '' ) {		if ( empty( $id ) && empty( $name ) )			return;		if ( ! is_numeric( $id ) ) {			$name = $id;			$id = 0;		}		if ( ! empty( $id ) )			$this->data = get_userdata( $id );		else			$this->data = get_userdatabylogin( $name );		if ( empty( $this->data->ID ) )			return;		foreach ( get_object_vars( $this->data ) as $key => $value ) {			$this->{$key} = $value;		}		$this->id = $this->ID;		$this->_init_caps();	}	/**	 * Set up capability object properties.	 *	 * Will set the value for the 'cap_key' property to current database table	 * prefix, followed by 'capabilities'. Will then check to see if the	 * property matching the 'cap_key' exists and is an array. If so, it will be	 * used.	 *	 * @since 2.1.0	 *	 * @param string $cap_key Optional capability key	 * @access protected	 */	function _init_caps( $cap_key = '' ) {		global $wpdb;		if ( empty($cap_key) )			$this->cap_key = $wpdb->prefix . 'capabilities';		else			$this->cap_key = $cap_key;		$this->caps = &$this->{$this->cap_key};		if ( ! is_array( $this->caps ) )			$this->caps = array();		$this->get_role_caps();	}	/**	 * Retrieve all of the role capabilities and merge with individual capabilities.	 *	 * All of the capabilities of the roles the user belongs to are merged with	 * the users individual roles. This also means that the user can be denied	 * specific roles that their role might have, but the specific user isn't	 * granted permission to.	 *	 * @since 2.0.0	 * @uses $wp_roles	 * @access public	 */	function get_role_caps() {		global $wp_roles;		if ( ! isset( $wp_roles ) )			$wp_roles = new WP_Roles();		//Filter out caps that are not role names and assign to $this->roles		if ( is_array( $this->caps ) )			$this->roles = array_filter( array_keys( $this->caps ), array( &$wp_roles, 'is_role' ) );		//Build $allcaps from role caps, overlay user's $caps		$this->allcaps = array();		foreach ( (array) $this->roles as $role ) {			$the_role =& $wp_roles->get_role( $role );			$this->allcaps = array_merge( (array) $this->allcaps, (array) $the_role->capabilities );		}		$this->allcaps = array_merge( (array) $this->allcaps, (array) $this->caps );	}	/**	 * Add role to user.	 *	 * Updates the user's meta data option with capabilities and roles.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $role Role name.	 */	function add_role( $role ) {		$this->caps[$role] = true;		update_user_meta( $this->ID, $this->cap_key, $this->caps );		$this->get_role_caps();		$this->update_user_level_from_caps();	}	/**	 * Remove role from user.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $role Role name.	 */	function remove_role( $role ) {		if ( !in_array($role, $this->roles) )			return;		unset( $this->caps[$role] );		update_user_meta( $this->ID, $this->cap_key, $this->caps );		$this->get_role_caps();		$this->update_user_level_from_caps();	}	/**	 * Set the role of the user.	 *	 * This will remove the previous roles of the user and assign the user the	 * new one. You can set the role to an empty string and it will remove all	 * of the roles from the user.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $role Role name.	 */	function set_role( $role ) {		foreach ( (array) $this->roles as $oldrole )			unset( $this->caps[$oldrole] );		if ( !empty( $role ) ) {			$this->caps[$role] = true;			$this->roles = array( $role => true );		} else {			$this->roles = false;		}		update_user_meta( $this->ID, $this->cap_key, $this->caps );		$this->get_role_caps();		$this->update_user_level_from_caps();		do_action( 'set_user_role', $this->ID, $role );	}	/**	 * Choose the maximum level the user has.	 *	 * Will compare the level from the $item parameter against the $max	 * parameter. If the item is incorrect, then just the $max parameter value	 * will be returned.	 *	 * Used to get the max level based on the capabilities the user has. This	 * is also based on roles, so if the user is assigned the Administrator role	 * then the capability 'level_10' will exist and the user will get that	 * value.	 *	 * @since 2.0.0	 * @access public	 *	 * @param int $max Max level of user.	 * @param string $item Level capability name.	 * @return int Max Level.	 */	function level_reduction( $max, $item ) {		if ( preg_match( '/^level_(10|[0-9])$/i', $item, $matches ) ) {			$level = intval( $matches[1] );			return max( $max, $level );		} else {			return $max;		}	}	/**	 * Update the maximum user level for the user.	 *	 * Updates the 'user_level' user metadata (includes prefix that is the	 * database table prefix) with the maximum user level. Gets the value from	 * the all of the capabilities that the user has.	 *	 * @since 2.0.0	 * @access public	 */	function update_user_level_from_caps() {		global $wpdb;		$this->user_level = array_reduce( array_keys( $this->allcaps ), array( &$this, 'level_reduction' ), 0 );		update_user_meta( $this->ID, $wpdb->prefix . 'user_level', $this->user_level );	}	/**	 * Add capability and grant or deny access to capability.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $cap Capability name.	 * @param bool $grant Whether to grant capability to user.	 */	function add_cap( $cap, $grant = true ) {		$this->caps[$cap] = $grant;		update_user_meta( $this->ID, $this->cap_key, $this->caps );	}	/**	 * Remove capability from user.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string $cap Capability name.	 */	function remove_cap( $cap ) {		if ( empty( $this->caps[$cap] ) )			return;		unset( $this->caps[$cap] );		update_user_meta( $this->ID, $this->cap_key, $this->caps );	}	/**	 * Remove all of the capabilities of the user.	 *	 * @since 2.1.0	 * @access public	 */	function remove_all_caps() {		global $wpdb;		$this->caps = array();		delete_user_meta( $this->ID, $this->cap_key );		delete_user_meta( $this->ID, $wpdb->prefix . 'user_level' );		$this->get_role_caps();	}	/**	 * Whether user has capability or role name.	 *	 * This is useful for looking up whether the user has a specific role	 * assigned to the user. The second optional parameter can also be used to	 * check for capabilities against a specfic post.	 *	 * @since 2.0.0	 * @access public	 *	 * @param string|int $cap Capability or role name to search.	 * @param int $post_id Optional. Post ID to check capability against specific post.	 * @return bool True, if user has capability; false, if user does not have capability.	 */	function has_cap( $cap ) {		if ( is_numeric( $cap ) ) {			_deprecated_argument( __FUNCTION__, '2.0', __('Usage of user levels by plugins and themes is deprecated. Use roles and capabilities instead.') );			$cap = $this->translate_level_to_cap( $cap );		}		$args = array_slice( func_get_args(), 1 );		$args = array_merge( array( $cap, $this->ID ), $args );		$caps = call_user_func_array( 'map_meta_cap', $args );		// Multisite super admin has all caps by definition, Unless specifically denied.		if ( is_multisite() && is_super_admin() ) {			if ( in_array('do_not_allow', $caps) )				return false;			return true;		}		// Must have ALL requested caps		$capabilities = apply_filters( 'user_has_cap', $this->allcaps, $caps, $args );		foreach ( (array) $caps as $cap ) {			//echo "Checking cap $cap<br />";			if ( empty( $capabilities[$cap] ) || !$capabilities[$cap] )				return false;		}		return true;	}	/**	 * Convert numeric level to level capability name.	 *	 * Prepends 'level_' to level number.	 *	 * @since 2.0.0	 * @access public	 *	 * @param int $level Level number, 1 to 10.	 * @return string	 */	function translate_level_to_cap( $level ) {		return 'level_' . $level;	}	/**	 * Set the blog to operate on. Defaults to the current blog.	 *	 * @since 3.0.0	 *	 * @param int $blog_id Optional Blog ID, defaults to current blog.	 */	function for_blog( $blog_id = '' ) {		global $wpdb;		if ( ! empty( $blog_id ) )			$cap_key = $wpdb->get_blog_prefix( $blog_id ) . 'capabilities';		else			$cap_key = '';		$this->_init_caps( $cap_key );	}}/** * Map meta capabilities to primitive capabilities. * * This does not actually compare whether the user ID has the actual capability, * just what the capability or capabilities are. Meta capability list value can * be 'delete_user', 'edit_user', 'remove_user', 'promote_user', 'delete_post', * 'delete_page', 'edit_post', 'edit_page', 'read_post', or 'read_page'. * * @since 2.0.0 * * @param string $cap Capability name. * @param int $user_id User ID. * @return array Actual capabilities for meta capability. */function map_meta_cap( $cap, $user_id ) {	$args = array_slice( func_get_args(), 2 );	$caps = array();	switch ( $cap ) {	case 'remove_user':		$caps[] = 'remove_users';		break;	case 'delete_user':		$caps[] = 'delete_users';		break;	case 'promote_user':		$caps[] = 'promote_users';		break;	case 'edit_user':		// Allow user to edit itself		if ( isset( $args[0] ) && $user_id == $args[0] )			break;		// Fall through	case 'edit_users':		// If multisite these caps are allowed only for super admins.		if ( is_multisite() && !is_super_admin() )			$caps[] = 'do_not_allow';		else			$caps[] = 'edit_users'; // Explicit due to primitive fall through		break;	case 'delete_post':		$author_data = get_userdata( $user_id );		//echo "post ID: {$args[0]}<br />";		$post = get_post( $args[0] );		$post_type = get_post_type_object( $post->post_type );		if ( $post_type && 'post' != $post_type->capability_type ) {			$args = array_merge( array( $post_type->cap->delete_post, $user_id ), $args );			return call_user_func_array( 'map_meta_cap', $args );		}		if ( '' != $post->post_author ) {			$post_author_data = get_userdata( $post->post_author );		} else {			//No author set yet so default to current user for cap checks			$post_author_data = $author_data;		}		// If the user is the author...		if ( is_object( $post_author_data ) && $user_id == $post_author_data->ID ) {			// If the post is published...			if ( 'publish' == $post->post_status ) {				$caps[] = 'delete_published_posts';			} elseif ( 'trash' == $post->post_status ) {				if ('publish' == get_post_meta($post->ID, '_wp_trash_meta_status', true) )					$caps[] = 'delete_published_posts';			} else {				// If the post is draft...				$caps[] = 'delete_posts';			}		} else {			// The user is trying to edit someone else's post.			$caps[] = 'delete_others_posts';			// The post is published, extra cap required.			if ( 'publish' == $post->post_status )				$caps[] = 'delete_published_posts';			elseif ( 'private' == $post->post_status )				$caps[] = 'delete_private_posts';		}		break;	case 'delete_page':		$author_data = get_userdata( $user_id );		//echo "post ID: {$args[0]}<br />";		$page = get_page( $args[0] );		$page_author_data = get_userdata( $page->post_author );		//echo "current user id : $user_id, page author id: " . $page_author_data->ID . "<br />";		// If the user is the author...		if ('' != $page->post_author) {			$page_author_data = get_userdata( $page->post_author );		} else {			//No author set yet so default to current user for cap checks			$page_author_data = $author_data;		}		if ( is_object( $page_author_data ) && $user_id == $page_author_data->ID ) {			// If the page is published...			if ( $page->post_status == 'publish' ) {				$caps[] = 'delete_published_pages';			} elseif ( 'trash' == $page->post_status ) {				if ('publish' == get_post_meta($page->ID, '_wp_trash_meta_status', true) )					$caps[] = 'delete_published_pages';			} else {				// If the page is draft...				$caps[] = 'delete_pages';			}		} else {			// The user is trying to edit someone else's page.			$caps[] = 'delete_others_pages';			// The page is published, extra cap required.			if ( $page->post_status == 'publish' )				$caps[] = 'delete_published_pages';			elseif ( $page->post_status == 'private' )				$caps[] = 'delete_private_pages';		}		break;		// edit_post breaks down to edit_posts, edit_published_posts, or		// edit_others_posts	case 'edit_post':		$author_data = get_userdata( $user_id );		//echo "post ID: {$args[0]}<br />";		$post = get_post( $args[0] );		$post_type = get_post_type_object( $post->post_type );		if ( $post_type && 'post' != $post_type->capability_type ) {			$args = array_merge( array( $post_type->cap->edit_post, $user_id ), $args );			return call_user_func_array( 'map_meta_cap', $args );		}		$post_author_data = get_userdata( $post->post_author );		//echo "current user id : $user_id, post author id: " . $post_author_data->ID . "<br />";		// If the user is the author...		if ( is_object( $post_author_data ) && $user_id == $post_author_data->ID ) {			// If the post is published...			if ( 'publish' == $post->post_status ) {				$caps[] = 'edit_published_posts';			} elseif ( 'trash' == $post->post_status ) {				if ('publish' == get_post_meta($post->ID, '_wp_trash_meta_status', true) )					$caps[] = 'edit_published_posts';			} else {				// If the post is draft...				$caps[] = 'edit_posts';			}		} else {			// The user is trying to edit someone else's post.			$caps[] = 'edit_others_posts';			// The post is published, extra cap required.			if ( 'publish' == $post->post_status )				$caps[] = 'edit_published_posts';			elseif ( 'private' == $post->post_status )				$caps[] = 'edit_private_posts';		}		break;	case 'edit_page':		$author_data = get_userdata( $user_id );		//echo "post ID: {$args[0]}<br />";		$page = get_page( $args[0] );		$page_author_data = get_userdata( $page->post_author );		//echo "current user id : $user_id, page author id: " . $page_author_data->ID . "<br />";		// If the user is the author...		if ( is_object( $page_author_data ) && $user_id == $page_author_data->ID ) {			// If the page is published...			if ( 'publish' == $page->post_status ) {				$caps[] = 'edit_published_pages';			} elseif ( 'trash' == $page->post_status ) {				if ('publish' == get_post_meta($page->ID, '_wp_trash_meta_status', true) )					$caps[] = 'edit_published_pages';			} else {				// If the page is draft...				$caps[] = 'edit_pages';			}		} else {			// The user is trying to edit someone else's page.			$caps[] = 'edit_others_pages';			// The page is published, extra cap required.			if ( 'publish' == $page->post_status )				$caps[] = 'edit_published_pages';			elseif ( 'private' == $page->post_status )				$caps[] = 'edit_private_pages';		}		break;	case 'read_post':		$post = get_post( $args[0] );		$post_type = get_post_type_object( $post->post_type );		if ( $post_type && 'post' != $post_type->capability_type ) {			$args = array_merge( array( $post_type->cap->read_post, $user_id ), $args );			return call_user_func_array( 'map_meta_cap', $args );		}		if ( 'private' != $post->post_status ) {			$caps[] = 'read';			break;		}		$author_data = get_userdata( $user_id );		$post_author_data = get_userdata( $post->post_author );		if ( is_object( $post_author_data ) && $user_id == $post_author_data->ID )			$caps[] = 'read';		else			$caps[] = 'read_private_posts';		break;	case 'read_page':		$page = get_page( $args[0] );		if ( 'private' != $page->post_status ) {			$caps[] = 'read';			break;		}		$author_data = get_userdata( $user_id );		$page_author_data = get_userdata( $page->post_author );		if ( is_object( $page_author_data ) && $user_id == $page_author_data->ID )			$caps[] = 'read';		else			$caps[] = 'read_private_pages';		break;	case 'unfiltered_upload':		if ( defined('ALLOW_UNFILTERED_UPLOADS') && ALLOW_UNFILTERED_UPLOADS && ( !is_multisite() || is_super_admin() )  )			$caps[] = $cap;		else			$caps[] = 'do_not_allow';		break;	case 'edit_files':	case 'edit_plugins':	case 'edit_themes':		if ( defined('DISALLOW_FILE_EDIT') && DISALLOW_FILE_EDIT ) {			$caps[] = 'do_not_allow';			break;		}		// Fall through if not DISALLOW_FILE_EDIT.	case 'update_plugins':	case 'delete_plugins':	case 'install_plugins':	case 'update_themes':	case 'delete_themes':	case 'install_themes':	case 'update_core':		// Disallow anything that creates, deletes, or edits core, plugin, or theme files.		// Files in uploads are excepted.		if ( defined('DISALLOW_FILE_MODS') && DISALLOW_FILE_MODS ) {			$caps[] = 'do_not_allow';			break;		}		// Fall through if not DISALLOW_FILE_MODS.	case 'unfiltered_html':		// Disallow unfiltered_html for all users, even admins and super admins.		if ( defined('DISALLOW_UNFILTERED_HTML') && DISALLOW_UNFILTERED_HTML ) {			$caps[] = 'do_not_allow';			break;		}		// Fall through if not DISALLOW_UNFILTERED_HTML	case 'delete_user':	case 'delete_users':		// If multisite these caps are allowed only for super admins.		if ( is_multisite() && !is_super_admin() )			$caps[] = 'do_not_allow';		else			$caps[] = $cap;		break;	case 'create_users':		if ( is_multisite() && !get_site_option( 'add_new_users' ) )			$caps[] = 'do_not_allow';		else			$caps[] = $cap;		break;	default:		// If no meta caps match, return the original cap.		$caps[] = $cap;	}	return apply_filters('map_meta_cap', $caps, $cap, $user_id, $args);}/** * Whether current user has capability or role. * * @since 2.0.0 * * @param string $capability Capability or role name. * @return bool */function current_user_can( $capability ) {	$current_user = wp_get_current_user();	if ( empty( $current_user ) )		return false;	$args = array_slice( func_get_args(), 1 );	$args = array_merge( array( $capability ), $args );	return call_user_func_array( array( &$current_user, 'has_cap' ), $args );}/** * Whether current user has a capability or role for a given blog. * * @since 3.0.0 * * @param int $blog_id Blog ID * @param string $capability Capability or role name. * @return bool */function current_user_can_for_blog( $blog_id, $capability ) {	$current_user = wp_get_current_user();    if ( is_multisite() && is_super_admin() )		return true;	if ( empty( $current_user ) )		return false;	// Create new object to avoid stomping the global current_user.	$user = new WP_User( $current_user->id) ;	// Set the blog id.  @todo add blog id arg to WP_User constructor?	$user->for_blog( $blog_id );	$args = array_slice( func_get_args(), 2 );	$args = array_merge( array( $capability ), $args );	return call_user_func_array( array( &$user, 'has_cap' ), $args );}/** * Whether author of supplied post has capability or role. * * @since 2.9.0 * * @param int|object $post Post ID or post object. * @param string $capability Capability or role name. * @return bool */function author_can( $post, $capability ) {	if ( !$post = get_post($post) )		return false;	$author = new WP_User( $post->post_author );	if ( empty( $author ) )		return false;	$args = array_slice( func_get_args(), 2 );	$args = array_merge( array( $capability ), $args );	return call_user_func_array( array( &$author, 'has_cap' ), $args );}/** * Retrieve role object. * * @see WP_Roles::get_role() Uses method to retrieve role object. * @since 2.0.0 * * @param string $role Role name. * @return object */function get_role( $role ) {	global $wp_roles;	if ( ! isset( $wp_roles ) )		$wp_roles = new WP_Roles();	return $wp_roles->get_role( $role );}/** * Add role, if it does not exist. * * @see WP_Roles::add_role() Uses method to add role. * @since 2.0.0 * * @param string $role Role name. * @param string $display_name Display name for role. * @param array $capabilities List of capabilities. * @return null|WP_Role WP_Role object if role is added, null if already exists. */function add_role( $role, $display_name, $capabilities = array() ) {	global $wp_roles;	if ( ! isset( $wp_roles ) )		$wp_roles = new WP_Roles();	return $wp_roles->add_role( $role, $display_name, $capabilities );}/** * Remove role, if it exists. * * @see WP_Roles::remove_role() Uses method to remove role. * @since 2.0.0 * * @param string $role Role name. * @return null */function remove_role( $role ) {	global $wp_roles;	if ( ! isset( $wp_roles ) )		$wp_roles = new WP_Roles();	return $wp_roles->remove_role( $role );}/** * Retrieve a list of super admins. * * @since 3.0.0 * * @uses $super_admins Super admins global variable, if set. * * @return array List of super admin logins */function get_super_admins() {	global $super_admins;	if ( isset($super_admins) )		return $super_admins;	else		return get_site_option( 'site_admins', array('admin') );}/** * Determine if user is a site admin. * * @since 3.0.0 * * @param int $user_id (Optional) The ID of a user. Defaults to the current user. * @return bool True if the user is a site admin. */function is_super_admin( $user_id = false ) {	if ( ! $user_id ) {		$current_user = wp_get_current_user();		$user_id = ! empty($current_user) ? $current_user->id : 0;	}	if ( ! $user_id )		return false;	$user = new WP_User($user_id);	if ( is_multisite() ) {		$super_admins = get_super_admins();		if ( is_array( $super_admins ) && in_array( $user->user_login, $super_admins ) )			return true;	} else {		if ( $user->has_cap('delete_users') )			return true;	}	return false;}?>
<?php/** * WordPress Rewrite API * * @package WordPress * @subpackage Rewrite *//** * Add a straight rewrite rule. * * @see WP_Rewrite::add_rule() for long description. * @since 2.1.0 * * @param string $regex Regular Expression to match request against. * @param string $redirect Page to redirect to. * @param string $after Optional, default is 'bottom'. Where to add rule, can also be 'top'. */function add_rewrite_rule($regex, $redirect, $after = 'bottom') {	global $wp_rewrite;	$wp_rewrite->add_rule($regex, $redirect, $after);}/** * Add a new tag (like %postname%). * * Warning: you must call this on init or earlier, otherwise the query var * addition stuff won't work. * * @since 2.1.0 * * @param string $tagname * @param string $regex */function add_rewrite_tag($tagname, $regex) {	//validation	if ( strlen($tagname) < 3 || $tagname{0} != '%' || $tagname{strlen($tagname)-1} != '%' )		return;	$qv = trim($tagname, '%');	global $wp_rewrite, $wp;	$wp->add_query_var($qv);	$wp_rewrite->add_rewrite_tag($tagname, $regex, $qv . '=');}/** * Add permalink structure. * * @see WP_Rewrite::add_permastruct() * @since 3.0.0 * * @param string $name Name for permalink structure. * @param string $struct Permalink structure. * @param bool $with_front Prepend front base to permalink structure. */function add_permastruct( $name, $struct, $with_front = true, $ep_mask = EP_NONE ) {	global $wp_rewrite;	return $wp_rewrite->add_permastruct( $name, $struct, $with_front, $ep_mask );}/** * Add a new feed type like /atom1/. * * @since 2.1.0 * * @param string $feedname * @param callback $function Callback to run on feed display. * @return string Feed action name. */function add_feed($feedname, $function) {	global $wp_rewrite;	if ( ! in_array($feedname, $wp_rewrite->feeds) ) //override the file if it is		$wp_rewrite->feeds[] = $feedname;	$hook = 'do_feed_' . $feedname;	// Remove default function hook	remove_action($hook, $hook, 10, 1);	add_action($hook, $function, 10, 1);	return $hook;}/** * Remove rewrite rules and then recreate rewrite rules. * * @see WP_Rewrite::flush_rules() * @since 3.0.0 * * @param bool $hard Whether to update .htaccess (hard flush) or just update * 	rewrite_rules transient (soft flush). Default is true (hard). */function flush_rewrite_rules( $hard = true ) {	global $wp_rewrite;	$wp_rewrite->flush_rules( $hard );}//pseudo-places/** * Endpoint Mask for default, which is nothing. * * @since 2.1.0 */define('EP_NONE', 0);/** * Endpoint Mask for Permalink. * * @since 2.1.0 */define('EP_PERMALINK', 1);/** * Endpoint Mask for Attachment. * * @since 2.1.0 */define('EP_ATTACHMENT', 2);/** * Endpoint Mask for date. * * @since 2.1.0 */define('EP_DATE', 4);/** * Endpoint Mask for year * * @since 2.1.0 */define('EP_YEAR', 8);/** * Endpoint Mask for month. * * @since 2.1.0 */define('EP_MONTH', 16);/** * Endpoint Mask for day. * * @since 2.1.0 */define('EP_DAY', 32);/** * Endpoint Mask for root. * * @since 2.1.0 */define('EP_ROOT', 64);/** * Endpoint Mask for comments. * * @since 2.1.0 */define('EP_COMMENTS', 128);/** * Endpoint Mask for searches. * * @since 2.1.0 */define('EP_SEARCH', 256);/** * Endpoint Mask for categories. * * @since 2.1.0 */define('EP_CATEGORIES', 512);/** * Endpoint Mask for tags. * * @since 2.3.0 */define('EP_TAGS', 1024);/** * Endpoint Mask for authors. * * @since 2.1.0 */define('EP_AUTHORS', 2048);/** * Endpoint Mask for pages. * * @since 2.1.0 */define('EP_PAGES', 4096);/** * Endpoint Mask for everything. * * @since 2.1.0 */define('EP_ALL', 8191);/** * Add an endpoint, like /trackback/. * * The endpoints are added to the end of the request. So a request matching * "/2008/10/14/my_post/myep/", the endpoint will be "/myep/". * * Be sure to flush the rewrite rules (wp_rewrite->flush()) when your plugin gets * activated (register_activation_hook()) and deactivated (register_deactivation_hook()) * * @since 2.1.0 * @see WP_Rewrite::add_endpoint() Parameters and more description. * @uses $wp_rewrite * * @param unknown_type $name * @param unknown_type $places */function add_rewrite_endpoint($name, $places) {	global $wp_rewrite;	$wp_rewrite->add_endpoint($name, $places);}/** * Filter the URL base for taxonomies. * * To remove any manually prepended /index.php/. * * @access private * @since 2.6.0 * * @param string $base The taxonomy base that we're going to filter * @return string */function _wp_filter_taxonomy_base( $base ) {	if ( !empty( $base ) ) {		$base = preg_replace( '|^/index\.php/|', '', $base );		$base = trim( $base, '/' );	}	return $base;}/** * Examine a url and try to determine the post ID it represents. * * Checks are supposedly from the hosted site blog. * * @since 1.0.0 * * @param string $url Permalink to check. * @return int Post ID, or 0 on failure. */function url_to_postid($url) {	global $wp_rewrite;	$url = apply_filters('url_to_postid', $url);	// First, check to see if there is a 'p=N' or 'page_id=N' to match against	if ( preg_match('#[?&](p|page_id|attachment_id)=(\d+)#', $url, $values) )	{		$id = absint($values[2]);		if ( $id )			return $id;	}	// Check to see if we are using rewrite rules	$rewrite = $wp_rewrite->wp_rewrite_rules();	// Not using rewrite rules, and 'p=N' and 'page_id=N' methods failed, so we're out of options	if ( empty($rewrite) )		return 0;	// $url cleanup by Mark Jaquith	// This fixes things like #anchors, ?query=strings, missing 'www.',	// added 'www.', or added 'index.php/' that will mess up our WP_Query	// and return a false negative	// Get rid of the #anchor	$url_split = explode('#', $url);	$url = $url_split[0];	// Get rid of URL ?query=string	$url_split = explode('?', $url);	$url = $url_split[0];	// Add 'www.' if it is absent and should be there	if ( false !== strpos(home_url(), '://www.') && false === strpos($url, '://www.') )		$url = str_replace('://', '://www.', $url);	// Strip 'www.' if it is present and shouldn't be	if ( false === strpos(home_url(), '://www.') )		$url = str_replace('://www.', '://', $url);	// Strip 'index.php/' if we're not using path info permalinks	if ( !$wp_rewrite->using_index_permalinks() )		$url = str_replace('index.php/', '', $url);	if ( false !== strpos($url, home_url()) ) {		// Chop off http://domain.com		$url = str_replace(home_url(), '', $url);	} else {		// Chop off /path/to/blog		$home_path = parse_url(home_url());		$home_path = $home_path['path'];		$url = str_replace($home_path, '', $url);	}	// Trim leading and lagging slashes	$url = trim($url, '/');	$request = $url;	// Done with cleanup	// Look for matches.	$request_match = $request;	foreach ( (array)$rewrite as $match => $query) {		// If the requesting file is the anchor of the match, prepend it		// to the path info.		if ( !empty($url) && ($url != $request) && (strpos($match, $url) === 0) )			$request_match = $url . '/' . $request;		if ( preg_match("!^$match!", $request_match, $matches) ) {			// Got a match.			// Trim the query of everything up to the '?'.			$query = preg_replace("!^.+\?!", '', $query);			// Substitute the substring matches into the query.			$query = addslashes(WP_MatchesMapRegex::apply($query, $matches));			// Filter out non-public query vars			global $wp;			parse_str($query, $query_vars);			$query = array();			foreach ( (array) $query_vars as $key => $value ) {				if ( in_array($key, $wp->public_query_vars) )					$query[$key] = $value;			}			// Do the query			$query = new WP_Query($query);			if ( $query->is_single || $query->is_page )				return $query->post->ID;			else				return 0;		}	}	return 0;}/** * WordPress Rewrite Component. * * The WordPress Rewrite class writes the rewrite module rules to the .htaccess * file. It also handles parsing the request to get the correct setup for the * WordPress Query class. * * The Rewrite along with WP class function as a front controller for WordPress. * You can add rules to trigger your page view and processing using this * component. The full functionality of a front controller does not exist, * meaning you can't define how the template files load based on the rewrite * rules. * * @since 1.5.0 */class WP_Rewrite {	/**	 * Default permalink structure for WordPress.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $permalink_structure;	/**	 * Whether to add trailing slashes.	 *	 * @since 2.2.0	 * @access private	 * @var bool	 */	var $use_trailing_slashes;	/**	 * Customized or default category permalink base ( example.com/xx/tagname ).	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $category_base;	/**	 * Customized or default tag permalink base ( example.com/xx/tagname ).	 *	 * @since 2.3.0	 * @access private	 * @var string	 */	var $tag_base;	/**	 * Permalink request structure for categories.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $category_structure;	/**	 * Permalink request structure for tags.	 *	 * @since 2.3.0	 * @access private	 * @var string	 */	var $tag_structure;	/**	 * Permalink author request base ( example.com/author/authorname ).	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $author_base = 'author';	/**	 * Permalink request structure for author pages.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $author_structure;	/**	 * Permalink request structure for dates.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $date_structure;	/**	 * Permalink request structure for pages.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $page_structure;	/**	 * Search permalink base ( example.com/search/query ).	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $search_base = 'search';	/**	 * Permalink request structure for searches.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $search_structure;	/**	 * Comments permalink base.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $comments_base = 'comments';	/**	 * Feed permalink base.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $feed_base = 'feed';	/**	 * Comments feed request structure permalink.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $comments_feed_structure;	/**	 * Feed request structure permalink.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $feed_structure;	/**	 * Front URL path.	 *	 * The difference between the root property is that WordPress might be	 * located at example/WordPress/index.php, if permalinks are turned off. The	 * WordPress/index.php will be the front portion. If permalinks are turned	 * on, this will most likely be empty or not set.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $front;	/**	 * Root URL path to WordPress (without domain).	 *	 * The difference between front property is that WordPress might be located	 * at example.com/WordPress/. The root is the 'WordPress/' portion.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $root = '';	/**	 * Permalink to the home page.	 *	 * @since 1.5.0	 * @access public	 * @var string	 */	var $index = 'index.php';	/**	 * Request match string.	 *	 * @since 1.5.0	 * @access private	 * @var string	 */	var $matches = '';	/**	 * Rewrite rules to match against the request to find the redirect or query.	 *	 * @since 1.5.0	 * @access private	 * @var array	 */	var $rules;	/**	 * Additional rules added external to the rewrite class.	 *	 * Those not generated by the class, see add_rewrite_rule().	 *	 * @since 2.1.0	 * @access private	 * @var array	 */	var $extra_rules = array(); //	/**	 * Additional rules that belong at the beginning to match first.	 *	 * Those not generated by the class, see add_rewrite_rule().	 *	 * @since 2.3.0	 * @access private	 * @var array	 */	var $extra_rules_top = array(); //	/**	 * Rules that don't redirect to WP's index.php.	 *	 * These rules are written to the mod_rewrite portion of the .htaccess.	 *	 * @since 2.1.0	 * @access private	 * @var array	 */	var $non_wp_rules = array(); //	/**	 * Extra permalink structures.	 *	 * @since 2.1.0	 * @access private	 * @var array	 */	var $extra_permastructs = array();	/**	 * Endpoints permalinks	 *	 * @since unknown	 * @access private	 * @var array	 */	var $endpoints;	/**	 * Whether to write every mod_rewrite rule for WordPress.	 *	 * This is off by default, turning it on might print a lot of rewrite rules	 * to the .htaccess file.	 *	 * @since 2.0.0	 * @access public	 * @var bool	 */	var $use_verbose_rules = false;	/**	 * Whether to write every mod_rewrite rule for WordPress pages.	 *	 * @since 2.5.0	 * @access public	 * @var bool	 */	var $use_verbose_page_rules = true;	/**	 * Permalink structure search for preg_replace.	 *	 * @since 1.5.0	 * @access private	 * @var array	 */	var $rewritecode =		array(					'%year%',					'%monthnum%',					'%day%',					'%hour%',					'%minute%',					'%second%',					'%postname%',					'%post_id%',					'%category%',					'%tag%',					'%author%',					'%pagename%',					'%search%'					);	/**	 * Preg_replace values for the search, see {@link WP_Rewrite::$rewritecode}.	 *	 * @since 1.5.0	 * @access private	 * @var array	 */	var $rewritereplace =		array(					'([0-9]{4})',					'([0-9]{1,2})',					'([0-9]{1,2})',					'([0-9]{1,2})',					'([0-9]{1,2})',					'([0-9]{1,2})',					'([^/]+)',					'([0-9]+)',					'(.+?)',					'(.+?)',					'([^/]+)',					'([^/]+?)',					'(.+)'					);	/**	 * Search for the query to look for replacing.	 *	 * @since 1.5.0	 * @access private	 * @var array	 */	var $queryreplace =		array (					'year=',					'monthnum=',					'day=',					'hour=',					'minute=',					'second=',					'name=',					'p=',					'category_name=',					'tag=',					'author_name=',					'pagename=',					's='					);	/**	 * Supported default feeds.	 *	 * @since 1.5.0	 * @access private	 * @var array	 */	var $feeds = array ( 'feed', 'rdf', 'rss', 'rss2', 'atom' );	/**	 * Whether permalinks are being used.	 *	 * This can be either rewrite module or permalink in the HTTP query string.	 *	 * @since 1.5.0	 * @access public	 *	 * @return bool True, if permalinks are enabled.	 */	function using_permalinks() {		return ! empty($this->permalink_structure);	}	/**	 * Whether permalinks are being used and rewrite module is not enabled.	 *	 * Means that permalink links are enabled and index.php is in the URL.	 *	 * @since 1.5.0	 * @access public	 *	 * @return bool	 */	function using_index_permalinks() {		if ( empty($this->permalink_structure) )			return false;		// If the index is not in the permalink, we're using mod_rewrite.		if ( preg_match('#^/*' . $this->index . '#', $this->permalink_structure) )			return true;		return false;	}	/**	 * Whether permalinks are being used and rewrite module is enabled.	 *	 * Using permalinks and index.php is not in the URL.	 *	 * @since 1.5.0	 * @access public	 *	 * @return bool	 */	function using_mod_rewrite_permalinks() {		if ( $this->using_permalinks() && ! $this->using_index_permalinks() )			return true;		else			return false;	}	/**	 * Index for matches for usage in preg_*() functions.	 *	 * The format of the string is, with empty matches property value, '$NUM'.	 * The 'NUM' will be replaced with the value in the $number parameter. With	 * the matches property not empty, the value of the returned string will	 * contain that value of the matches property. The format then will be	 * '$MATCHES[NUM]', with MATCHES as the value in the property and NUM the	 * value of the $number parameter.	 *	 * @since 1.5.0	 * @access public	 *	 * @param int $number Index number.	 * @return string	 */	function preg_index($number) {		$match_prefix = '$';		$match_suffix = '';		if ( ! empty($this->matches) ) {			$match_prefix = '$' . $this->matches . '[';			$match_suffix = ']';		}		return "$match_prefix$number$match_suffix";	}	/**	 * Retrieve all page and attachments for pages URIs.	 *	 * The attachments are for those that have pages as parents and will be	 * retrieved.	 *	 * @since 2.5.0	 * @access public	 *	 * @return array Array of page URIs as first element and attachment URIs as second element.	 */	function page_uri_index() {		global $wpdb;		//get pages in order of hierarchy, i.e. children after parents		$posts = get_page_hierarchy($wpdb->get_results("SELECT ID, post_name, post_parent FROM $wpdb->posts WHERE post_type = 'page'"));		// If we have no pages get out quick		if ( !$posts )			return array( array(), array() );		//now reverse it, because we need parents after children for rewrite rules to work properly		$posts = array_reverse($posts, true);		$page_uris = array();		$page_attachment_uris = array();		foreach ( $posts as $id => $post ) {			// URL => page name			$uri = get_page_uri($id);			$attachments = $wpdb->get_results( $wpdb->prepare( "SELECT ID, post_name, post_parent FROM $wpdb->posts WHERE post_type = 'attachment' AND post_parent = %d", $id ));			if ( !empty($attachments) ) {				foreach ( $attachments as $attachment ) {					$attach_uri = get_page_uri($attachment->ID);					$page_attachment_uris[$attach_uri] = $attachment->ID;				}			}			$page_uris[$uri] = $id;		}		return array( $page_uris, $page_attachment_uris );	}	/**	 * Retrieve all of the rewrite rules for pages.	 *	 * If the 'use_verbose_page_rules' property is false, then there will only	 * be a single rewrite rule for pages for those matching '%pagename%'. With	 * the property set to true, the attachments and the pages will be added for	 * each individual attachment URI and page URI, respectively.	 *	 * @since 1.5.0	 * @access public	 *	 * @return array	 */	function page_rewrite_rules() {		$rewrite_rules = array();		$page_structure = $this->get_page_permastruct();		if ( ! $this->use_verbose_page_rules ) {			$this->add_rewrite_tag('%pagename%', "(.+?)", 'pagename=');			$rewrite_rules = array_merge($rewrite_rules, $this->generate_rewrite_rules($page_structure, EP_PAGES));			return $rewrite_rules;		}		$page_uris = $this->page_uri_index();		$uris = $page_uris[0];		$attachment_uris = $page_uris[1];		if ( is_array( $attachment_uris ) ) {			foreach ( $attachment_uris as $uri => $pagename ) {				$this->add_rewrite_tag('%pagename%', "($uri)", 'attachment=');				$rewrite_rules = array_merge($rewrite_rules, $this->generate_rewrite_rules($page_structure, EP_PAGES));			}		}		if ( is_array( $uris ) ) {			foreach ( $uris as $uri => $pagename ) {				$this->add_rewrite_tag('%pagename%', "($uri)", 'pagename=');				$rewrite_rules = array_merge($rewrite_rules, $this->generate_rewrite_rules($page_structure, EP_PAGES));			}		}		return $rewrite_rules;	}	/**	 * Retrieve date permalink structure, with year, month, and day.	 *	 * The permalink structure for the date, if not set already depends on the	 * permalink structure. It can be one of three formats. The first is year,	 * month, day; the second is day, month, year; and the last format is month,	 * day, year. These are matched against the permalink structure for which	 * one is used. If none matches, then the default will be used, which is	 * year, month, day.	 *	 * Prevents post ID and date permalinks from overlapping. In the case of	 * post_id, the date permalink will be prepended with front permalink with	 * 'date/' before the actual permalink to form the complete date permalink	 * structure.	 *	 * @since 1.5.0	 * @access public	 *	 * @return bool|string False on no permalink structure. Date permalink structure.	 */	function get_date_permastruct() {		if ( isset($this->date_structure) )			return $this->date_structure;		if ( empty($this->permalink_structure) ) {			$this->date_structure = '';			return false;		}		// The date permalink must have year, month, and day separated by slashes.		$endians = array('%year%/%monthnum%/%day%', '%day%/%monthnum%/%year%', '%monthnum%/%day%/%year%');		$this->date_structure = '';		$date_endian = '';		foreach ( $endians as $endian ) {			if ( false !== strpos($this->permalink_structure, $endian) ) {				$date_endian= $endian;				break;			}		}		if ( empty($date_endian) )			$date_endian = '%year%/%monthnum%/%day%';		// Do not allow the date tags and %post_id% to overlap in the permalink		// structure. If they do, move the date tags to $front/date/.		$front = $this->front;		preg_match_all('/%.+?%/', $this->permalink_structure, $tokens);		$tok_index = 1;		foreach ( (array) $tokens[0] as $token) {			if ( '%post_id%' == $token && ($tok_index <= 3) ) {				$front = $front . 'date/';				break;			}			$tok_index++;		}		$this->date_structure = $front . $date_endian;		return $this->date_structure;	}	/**	 * Retrieve the year permalink structure without month and day.	 *	 * Gets the date permalink structure and strips out the month and day	 * permalink structures.	 *	 * @since 1.5.0	 * @access public	 *	 * @return bool|string False on failure. Year structure on success.	 */	function get_year_permastruct() {		$structure = $this->get_date_permastruct($this->permalink_structure);		if ( empty($structure) )			return false;		$structure = str_replace('%monthnum%', '', $structure);		$structure = str_replace('%day%', '', $structure);		$structure = preg_replace('#/+#', '/', $structure);		return $structure;	}	/**	 * Retrieve the month permalink structure without day and with year.	 *	 * Gets the date permalink structure and strips out the day permalink	 * structures. Keeps the year permalink structure.	 *	 * @since 1.5.0	 * @access public	 *	 * @return bool|string False on failure. Year/Month structure on success.	 */	function get_month_permastruct() {		$structure = $this->get_date_permastruct($this->permalink_structure);		if ( empty($structure) )			return false;		$structure = str_replace('%day%', '', $structure);		$structure = preg_replace('#/+#', '/', $structure);		return $structure;	}	/**	 * Retrieve the day permalink structure with month and year.	 *	 * Keeps date permalink structure with all year, month, and day.	 *	 * @since 1.5.0	 * @access public	 *	 * @return bool|string False on failure. Year/Month/Day structure on success.	 */	function get_day_permastruct() {		return $this->get_date_permastruct($this->permalink_structure);	}	/**	 * Retrieve the permalink structure for categories.	 *	 * If the category_base property has no value, then the category structure	 * will have the front property value, followed by 'category', and finally	 * '%category%'. If it does, then the root property will be used, along with	 * the category_base property value.	 *	 * @since 1.5.0	 * @access public	 *	 * @return bool|string False on failure. Category permalink structure.	 */	function get_category_permastruct() {		if ( isset($this->category_structure) )			return $this->category_structure;		if ( empty($this->permalink_structure) ) {			$this->category_structure = '';			return false;		}		if ( empty($this->category_base) )			$this->category_structure = trailingslashit( $this->front . 'category' );		else			$this->category_structure = trailingslashit( '/' . $this->root . $this->category_base );		$this->category_structure .= '%category%';		return $this->category_structure;	}	/**	 * Retrieve the permalink structure for tags.	 *	 * If the tag_base property has no value, then the tag structure will have	 * the front property value, followed by 'tag', and finally '%tag%'. If it	 * does, then the root property will be used, along with the tag_base	 * property value.	 *	 * @since 2.3.0	 * @access public	 *	 * @return bool|string False on failure. Tag permalink structure.	 */	function get_tag_permastruct() {		if ( isset($this->tag_structure) )			return $this->tag_structure;		if ( empty($this->permalink_structure) ) {			$this->tag_structure = '';			return false;		}		if ( empty($this->tag_base) )			$this->tag_structure = trailingslashit( $this->front . 'tag' );		else			$this->tag_structure = trailingslashit( '/' . $this->root . $this->tag_base );		$this->tag_structure .= '%tag%';		return $this->tag_structure;	}	/**	 * Retrieve extra permalink structure by name.	 *	 * @since unknown	 * @access public	 *	 * @param string $name Permalink structure name.	 * @return string|bool False if not found. Permalink structure string.	 */	function get_extra_permastruct($name) {		if ( empty($this->permalink_structure) )			return false;		if ( isset($this->extra_permastructs[$name]) )			return $this->extra_permastructs[$name][0];		return false;	}	/**	 * Retrieve the author permalink structure.	 *	 * The permalink structure is front property, author base, and finally	 * '/%author%'. Will set the author_structure property and then return it	 * without attempting to set the value again.	 *	 * @since 1.5.0	 * @access public	 *	 * @return string|bool False if not found. Permalink structure string.	 */	function get_author_permastruct() {		if ( isset($this->author_structure) )			return $this->author_structure;		if ( empty($this->permalink_structure) ) {			$this->author_structure = '';			return false;		}		$this->author_structure = $this->front . $this->author_base . '/%author%';		return $this->author_structure;	}	/**	 * Retrieve the search permalink structure.	 *	 * The permalink structure is root property, search base, and finally	 * '/%search%'. Will set the search_structure property and then return it	 * without attempting to set the value again.	 *	 * @since 1.5.0	 * @access public	 *	 * @return string|bool False if not found. Permalink structure string.	 */	function get_search_permastruct() {		if ( isset($this->search_structure) )			return $this->search_structure;		if ( empty($this->permalink_structure) ) {			$this->search_structure = '';			return false;		}		$this->search_structure = $this->root . $this->search_base . '/%search%';		return $this->search_structure;	}	/**	 * Retrieve the page permalink structure.	 *	 * The permalink structure is root property, and '%pagename%'. Will set the	 * page_structure property and then return it without attempting to set the	 * value again.	 *	 * @since 1.5.0	 * @access public	 *	 * @return string|bool False if not found. Permalink structure string.	 */	function get_page_permastruct() {		if ( isset($this->page_structure) )			return $this->page_structure;		if (empty($this->permalink_structure)) {			$this->page_structure = '';			return false;		}		$this->page_structure = $this->root . '%pagename%';		return $this->page_structure;	}	/**	 * Retrieve the feed permalink structure.	 *	 * The permalink structure is root property, feed base, and finally	 * '/%feed%'. Will set the feed_structure property and then return it	 * without attempting to set the value again.	 *	 * @since 1.5.0	 * @access public	 *	 * @return string|bool False if not found. Permalink structure string.	 */	function get_feed_permastruct() {		if ( isset($this->feed_structure) )			return $this->feed_structure;		if ( empty($this->permalink_structure) ) {			$this->feed_structure = '';			return false;		}		$this->feed_structure = $this->root . $this->feed_base . '/%feed%';		return $this->feed_structure;	}	/**	 * Retrieve the comment feed permalink structure.	 *	 * The permalink structure is root property, comment base property, feed	 * base and finally '/%feed%'. Will set the comment_feed_structure property	 * and then return it without attempting to set the value again.	 *	 * @since 1.5.0	 * @access public	 *	 * @return string|bool False if not found. Permalink structure string.	 */	function get_comment_feed_permastruct() {		if ( isset($this->comment_feed_structure) )			return $this->comment_feed_structure;		if (empty($this->permalink_structure)) {			$this->comment_feed_structure = '';			return false;		}		$this->comment_feed_structure = $this->root . $this->comments_base . '/' . $this->feed_base . '/%feed%';		return $this->comment_feed_structure;	}	/**	 * Append or update tag, pattern, and query for replacement.	 *	 * If the tag already exists, replace the existing pattern and query for	 * that tag, otherwise add the new tag, pattern, and query to the end of the	 * arrays.	 *	 * @internal What is the purpose of this function again? Need to finish long	 *           description.	 *	 * @since 1.5.0	 * @access public	 *	 * @param string $tag Append tag to rewritecode property array.	 * @param string $pattern Append pattern to rewritereplace property array.	 * @param string $query Append query to queryreplace property array.	 */	function add_rewrite_tag($tag, $pattern, $query) {		$position = array_search($tag, $this->rewritecode);		if ( false !== $position && null !== $position ) {			$this->rewritereplace[$position] = $pattern;			$this->queryreplace[$position] = $query;		} else {			$this->rewritecode[] = $tag;			$this->rewritereplace[] = $pattern;			$this->queryreplace[] = $query;		}	}	/**	 * Generate the rules from permalink structure.	 *	 * The main WP_Rewrite function for building the rewrite rule list. The	 * contents of the function is a mix of black magic and regular expressions,	 * so best just ignore the contents and move to the parameters.	 *	 * @since 1.5.0	 * @access public	 *	 * @param string $permalink_structure The permalink structure.	 * @param int $ep_mask Optional, default is EP_NONE. Endpoint constant, see EP_* constants.	 * @param bool $paged Optional, default is true. Whether permalink request is paged.	 * @param bool $feed Optional, default is true. Whether for feed.	 * @param bool $forcomments Optional, default is false. Whether for comments.	 * @param bool $walk_dirs Optional, default is true. Whether to create list of directories to walk over.	 * @param bool $endpoints Optional, default is true. Whether endpoints are enabled.	 * @return array Rewrite rule list.	 */	function generate_rewrite_rules($permalink_structure, $ep_mask = EP_NONE, $paged = true, $feed = true, $forcomments = false, $walk_dirs = true, $endpoints = true) {		//build a regex to match the feed section of URLs, something like (feed|atom|rss|rss2)/?		$feedregex2 = '';		foreach ( (array) $this->feeds as $feed_name)			$feedregex2 .= $feed_name . '|';		$feedregex2 = '(' . trim($feedregex2, '|') .  ')/?$';		//$feedregex is identical but with /feed/ added on as well, so URLs like <permalink>/feed/atom		//and <permalink>/atom are both possible		$feedregex = $this->feed_base  . '/' . $feedregex2;		//build a regex to match the trackback and page/xx parts of URLs		$trackbackregex = 'trackback/?$';		$pageregex = 'page/?([0-9]{1,})/?$';		$commentregex = 'comment-page-([0-9]{1,})/?$';		//build up an array of endpoint regexes to append => queries to append		if ( $endpoints ) {			$ep_query_append = array ();			foreach ( (array) $this->endpoints as $endpoint) {				//match everything after the endpoint name, but allow for nothing to appear there				$epmatch = $endpoint[1] . '(/(.*))?/?$';				//this will be appended on to the rest of the query for each dir				$epquery = '&' . $endpoint[1] . '=';				$ep_query_append[$epmatch] = array ( $endpoint[0], $epquery );			}		}		//get everything up to the first rewrite tag		$front = substr($permalink_structure, 0, strpos($permalink_structure, '%'));		//build an array of the tags (note that said array ends up being in $tokens[0])		preg_match_all('/%.+?%/', $permalink_structure, $tokens);		$num_tokens = count($tokens[0]);		$index = $this->index; //probably 'index.php'		$feedindex = $index;		$trackbackindex = $index;		//build a list from the rewritecode and queryreplace arrays, that will look something like		//tagname=$matches[i] where i is the current $i		for ( $i = 0; $i < $num_tokens; ++$i ) {			if ( 0 < $i )				$queries[$i] = $queries[$i - 1] . '&';			else				$queries[$i] = '';			$query_token = str_replace($this->rewritecode, $this->queryreplace, $tokens[0][$i]) . $this->preg_index($i+1);			$queries[$i] .= $query_token;		}		//get the structure, minus any cruft (stuff that isn't tags) at the front		$structure = $permalink_structure;		if ( $front != '/' )			$structure = str_replace($front, '', $structure);		//create a list of dirs to walk over, making rewrite rules for each level		//so for example, a $structure of /%year%/%month%/%postname% would create		//rewrite rules for /%year%/, /%year%/%month%/ and /%year%/%month%/%postname%		$structure = trim($structure, '/');		$dirs = $walk_dirs ? explode('/', $structure) : array( $structure );		$num_dirs = count($dirs);		//strip slashes from the front of $front		$front = preg_replace('|^/+|', '', $front);		//the main workhorse loop		$post_rewrite = array();		$struct = $front;		for ( $j = 0; $j < $num_dirs; ++$j ) {			//get the struct for this dir, and trim slashes off the front			$struct .= $dirs[$j] . '/'; //accumulate. see comment near explode('/', $structure) above			$struct = ltrim($struct, '/');			//replace tags with regexes			$match = str_replace($this->rewritecode, $this->rewritereplace, $struct);			//make a list of tags, and store how many there are in $num_toks			$num_toks = preg_match_all('/%.+?%/', $struct, $toks);			//get the 'tagname=$matches[i]'			$query = ( isset($queries) && is_array($queries) ) ? $queries[$num_toks - 1] : '';			//set up $ep_mask_specific which is used to match more specific URL types			switch ( $dirs[$j] ) {				case '%year%':					$ep_mask_specific = EP_YEAR;					break;				case '%monthnum%':					$ep_mask_specific = EP_MONTH;					break;				case '%day%':					$ep_mask_specific = EP_DAY;					break;				default:					$ep_mask_specific = EP_NONE;			}			//create query for /page/xx			$pagematch = $match . $pageregex;			$pagequery = $index . '?' . $query . '&paged=' . $this->preg_index($num_toks + 1);			//create query for /comment-page-xx			$commentmatch = $match . $commentregex;			$commentquery = $index . '?' . $query . '&cpage=' . $this->preg_index($num_toks + 1);			if ( get_option('page_on_front') ) {				//create query for Root /comment-page-xx				$rootcommentmatch = $match . $commentregex;				$rootcommentquery = $index . '?' . $query . '&page_id=' . get_option('page_on_front') . '&cpage=' . $this->preg_index($num_toks + 1);			}			//create query for /feed/(feed|atom|rss|rss2|rdf)			$feedmatch = $match . $feedregex;			$feedquery = $feedindex . '?' . $query . '&feed=' . $this->preg_index($num_toks + 1);			//create query for /(feed|atom|rss|rss2|rdf) (see comment near creation of $feedregex)			$feedmatch2 = $match . $feedregex2;			$feedquery2 = $feedindex . '?' . $query . '&feed=' . $this->preg_index($num_toks + 1);			//if asked to, turn the feed queries into comment feed ones			if ( $forcomments ) {				$feedquery .= '&withcomments=1';				$feedquery2 .= '&withcomments=1';			}			//start creating the array of rewrites for this dir			$rewrite = array();			if ( $feed ) //...adding on /feed/ regexes => queries				$rewrite = array($feedmatch => $feedquery, $feedmatch2 => $feedquery2);			if ( $paged ) //...and /page/xx ones				$rewrite = array_merge($rewrite, array($pagematch => $pagequery));			//only on pages with comments add ../comment-page-xx/			if ( EP_PAGES & $ep_mask || EP_PERMALINK & $ep_mask )				$rewrite = array_merge($rewrite, array($commentmatch => $commentquery));			else if ( EP_ROOT & $ep_mask && get_option('page_on_front') )				$rewrite = array_merge($rewrite, array($rootcommentmatch => $rootcommentquery));			//do endpoints			if ( $endpoints ) {				foreach ( (array) $ep_query_append as $regex => $ep) {					//add the endpoints on if the mask fits					if ( $ep[0] & $ep_mask || $ep[0] & $ep_mask_specific )						$rewrite[$match . $regex] = $index . '?' . $query . $ep[1] . $this->preg_index($num_toks + 2);				}			}			//if we've got some tags in this dir			if ( $num_toks ) {				$post = false;				$page = false;				//check to see if this dir is permalink-level: i.e. the structure specifies an				//individual post. Do this by checking it contains at least one of 1) post name,				//2) post ID, 3) page name, 4) timestamp (year, month, day, hour, second and				//minute all present). Set these flags now as we need them for the endpoints.				if ( strpos($struct, '%postname%') !== false						|| strpos($struct, '%post_id%') !== false						|| strpos($struct, '%pagename%') !== false						|| (strpos($struct, '%year%') !== false && strpos($struct, '%monthnum%') !== false && strpos($struct, '%day%') !== false && strpos($struct, '%hour%') !== false && strpos($struct, '%minute%') !== false && strpos($struct, '%second%') !== false)						) {					$post = true;					if ( strpos($struct, '%pagename%') !== false )						$page = true;				}				if ( ! $post ) {					// For custom post types, we need to add on endpoints as well.					foreach ( get_post_types( array('_builtin' => false ) ) as $ptype ) {						if ( strpos($struct, "%$ptype%") !== false ) {							$post = true;							$page = is_post_type_hierarchical( $ptype ); // This is for page style attachment url's							break;						}					}				}				//if we're creating rules for a permalink, do all the endpoints like attachments etc				if ( $post ) {					//create query and regex for trackback					$trackbackmatch = $match . $trackbackregex;					$trackbackquery = $trackbackindex . '?' . $query . '&tb=1';					//trim slashes from the end of the regex for this dir					$match = rtrim($match, '/');					//get rid of brackets					$submatchbase = str_replace( array('(', ')'), '', $match);					//add a rule for at attachments, which take the form of <permalink>/some-text					$sub1 = $submatchbase . '/([^/]+)/';					$sub1tb = $sub1 . $trackbackregex; //add trackback regex <permalink>/trackback/...					$sub1feed = $sub1 . $feedregex; //and <permalink>/feed/(atom|...)					$sub1feed2 = $sub1 . $feedregex2; //and <permalink>/(feed|atom...)					$sub1comment = $sub1 . $commentregex; //and <permalink>/comment-page-xx					//add an ? as we don't have to match that last slash, and finally a $ so we					//match to the end of the URL					//add another rule to match attachments in the explicit form:					//<permalink>/attachment/some-text					$sub2 = $submatchbase . '/attachment/([^/]+)/';					$sub2tb = $sub2 . $trackbackregex; //and add trackbacks <permalink>/attachment/trackback					$sub2feed = $sub2 . $feedregex;    //feeds, <permalink>/attachment/feed/(atom|...)					$sub2feed2 = $sub2 . $feedregex2;  //and feeds again on to this <permalink>/attachment/(feed|atom...)					$sub2comment = $sub2 . $commentregex; //and <permalink>/comment-page-xx					//create queries for these extra tag-ons we've just dealt with					$subquery = $index . '?attachment=' . $this->preg_index(1);					$subtbquery = $subquery . '&tb=1';					$subfeedquery = $subquery . '&feed=' . $this->preg_index(2);					$subcommentquery = $subquery . '&cpage=' . $this->preg_index(2);					//do endpoints for attachments					if ( !empty($endpoints) ) {						foreach ( (array) $ep_query_append as $regex => $ep ) {							if ( $ep[0] & EP_ATTACHMENT ) {								$rewrite[$sub1 . $regex] = $subquery . $ep[1] . $this->preg_index(2);								$rewrite[$sub2 . $regex] = $subquery . $ep[1] . $this->preg_index(2);							}						}					}					//now we've finished with endpoints, finish off the $sub1 and $sub2 matches					$sub1 .= '?$';					$sub2 .= '?$';					//allow URLs like <permalink>/2 for <permalink>/page/2					$match = $match . '(/[0-9]+)?/?$';					$query = $index . '?' . $query . '&page=' . $this->preg_index($num_toks + 1);				} else { //not matching a permalink so this is a lot simpler					//close the match and finalise the query					$match .= '?$';					$query = $index . '?' . $query;				}				//create the final array for this dir by joining the $rewrite array (which currently				//only contains rules/queries for trackback, pages etc) to the main regex/query for				//this dir				$rewrite = array_merge($rewrite, array($match => $query));				//if we're matching a permalink, add those extras (attachments etc) on				if ( $post ) {					//add trackback					$rewrite = array_merge(array($trackbackmatch => $trackbackquery), $rewrite);					//add regexes/queries for attachments, attachment trackbacks and so on					if ( ! $page ) //require <permalink>/attachment/stuff form for pages because of confusion with subpages						$rewrite = array_merge($rewrite, array($sub1 => $subquery, $sub1tb => $subtbquery, $sub1feed => $subfeedquery, $sub1feed2 => $subfeedquery, $sub1comment => $subcommentquery));					$rewrite = array_merge(array($sub2 => $subquery, $sub2tb => $subtbquery, $sub2feed => $subfeedquery, $sub2feed2 => $subfeedquery, $sub2comment => $subcommentquery), $rewrite);				}			} //if($num_toks)			//add the rules for this dir to the accumulating $post_rewrite			$post_rewrite = array_merge($rewrite, $post_rewrite);		} //foreach ($dir)		return $post_rewrite; //the finished rules. phew!	}	/**	 * Generate Rewrite rules with permalink structure and walking directory only.	 *	 * Shorten version of {@link WP_Rewrite::generate_rewrite_rules()} that	 * allows for shorter list of parameters. See the method for longer	 * description of what generating rewrite rules does.	 *	 * @uses WP_Rewrite::generate_rewrite_rules() See for long description and rest of parameters.	 * @since 1.5.0	 * @access public	 *	 * @param string $permalink_structure The permalink structure to generate rules.	 * @param bool $walk_dirs Optional, default is false. Whether to create list of directories to walk over.	 * @return array	 */	function generate_rewrite_rule($permalink_structure, $walk_dirs = false) {		return $this->generate_rewrite_rules($permalink_structure, EP_NONE, false, false, false, $walk_dirs);	}	/**	 * Construct rewrite matches and queries from permalink structure.	 *	 * Runs the action 'generate_rewrite_rules' with the parameter that is an	 * reference to the current WP_Rewrite instance to further manipulate the	 * permalink structures and rewrite rules. Runs the 'rewrite_rules_array'	 * filter on the full rewrite rule array.	 *	 * There are two ways to manipulate the rewrite rules, one by hooking into	 * the 'generate_rewrite_rules' action and gaining full control of the	 * object or just manipulating the rewrite rule array before it is passed	 * from the function.	 *	 * @since 1.5.0	 * @access public	 *	 * @return array An associate array of matches and queries.	 */	function rewrite_rules() {		$rewrite = array();		if ( empty($this->permalink_structure) )			return $rewrite;		// robots.txt -only if installed at the root		$home_path = parse_url( home_url() );		$robots_rewrite = ( empty( $home_path['path'] ) || '/' == $home_path['path'] ) ? array( 'robots\.txt$' => $this->index . '?robots=1' ) : array();		// Default Feed rules - These are require to allow for the direct access files to work with permalink structure starting with %category%		$default_feeds = array(	'.*wp-atom.php$'	=>	$this->index . '?feed=atom',								'.*wp-rdf.php$'		=>	$this->index . '?feed=rdf',								'.*wp-rss.php$'		=>	$this->index . '?feed=rss',								'.*wp-rss2.php$'	=>	$this->index . '?feed=rss2',								'.*wp-feed.php$'	=>	$this->index . '?feed=feed',								'.*wp-commentsrss2.php$'	=>	$this->index . '?feed=rss2&withcomments=1');		// Registration rules		$registration_pages = array();		if ( is_multisite() && is_main_site() ) {			$registration_pages['.*wp-signup.php$'] = $this->index . '?signup=true';			$registration_pages['.*wp-activate.php$'] = $this->index . '?activate=true';		}		// Post		$post_rewrite = $this->generate_rewrite_rules($this->permalink_structure, EP_PERMALINK);		$post_rewrite = apply_filters('post_rewrite_rules', $post_rewrite);		// Date		$date_rewrite = $this->generate_rewrite_rules($this->get_date_permastruct(), EP_DATE);		$date_rewrite = apply_filters('date_rewrite_rules', $date_rewrite);		// Root		$root_rewrite = $this->generate_rewrite_rules($this->root . '/', EP_ROOT);		$root_rewrite = apply_filters('root_rewrite_rules', $root_rewrite);		// Comments		$comments_rewrite = $this->generate_rewrite_rules($this->root . $this->comments_base, EP_COMMENTS, true, true, true, false);		$comments_rewrite = apply_filters('comments_rewrite_rules', $comments_rewrite);		// Search		$search_structure = $this->get_search_permastruct();		$search_rewrite = $this->generate_rewrite_rules($search_structure, EP_SEARCH);		$search_rewrite = apply_filters('search_rewrite_rules', $search_rewrite);		// Categories		$category_rewrite = $this->generate_rewrite_rules($this->get_category_permastruct(), EP_CATEGORIES);		$category_rewrite = apply_filters('category_rewrite_rules', $category_rewrite);		// Tags		$tag_rewrite = $this->generate_rewrite_rules($this->get_tag_permastruct(), EP_TAGS);		$tag_rewrite = apply_filters('tag_rewrite_rules', $tag_rewrite);		// Authors		$author_rewrite = $this->generate_rewrite_rules($this->get_author_permastruct(), EP_AUTHORS);		$author_rewrite = apply_filters('author_rewrite_rules', $author_rewrite);		// Pages		$page_rewrite = $this->page_rewrite_rules();		$page_rewrite = apply_filters('page_rewrite_rules', $page_rewrite);		// Extra permastructs		foreach ( $this->extra_permastructs as $permastruct ) {			if ( is_array($permastruct) )				$this->extra_rules_top = array_merge($this->extra_rules_top, $this->generate_rewrite_rules($permastruct[0], $permastruct[1]));			else				$this->extra_rules_top = array_merge($this->extra_rules_top, $this->generate_rewrite_rules($permastruct, EP_NONE));		}		// Put them together.		if ( $this->use_verbose_page_rules )			$this->rules = array_merge($this->extra_rules_top, $robots_rewrite, $default_feeds, $registration_pages, $page_rewrite, $root_rewrite, $comments_rewrite, $search_rewrite, $category_rewrite, $tag_rewrite, $author_rewrite, $date_rewrite, $post_rewrite, $this->extra_rules);		else			$this->rules = array_merge($this->extra_rules_top, $robots_rewrite, $default_feeds, $registration_pages, $root_rewrite, $comments_rewrite, $search_rewrite, $category_rewrite, $tag_rewrite, $author_rewrite, $date_rewrite, $post_rewrite, $page_rewrite, $this->extra_rules);		do_action_ref_array('generate_rewrite_rules', array(&$this));		$this->rules = apply_filters('rewrite_rules_array', $this->rules);		return $this->rules;	}	/**	 * Retrieve the rewrite rules.	 *	 * The difference between this method and {@link	 * WP_Rewrite::rewrite_rules()} is that this method stores the rewrite rules	 * in the 'rewrite_rules' option and retrieves it. This prevents having to	 * process all of the permalinks to get the rewrite rules in the form of	 * caching.	 *	 * @since 1.5.0	 * @access public	 *	 * @return array Rewrite rules.	 */	function wp_rewrite_rules() {		$this->rules = get_option('rewrite_rules');		if ( empty($this->rules) ) {			$this->matches = 'matches';			$this->rewrite_rules();			update_option('rewrite_rules', $this->rules);		}		return $this->rules;	}	/**	 * Retrieve mod_rewrite formatted rewrite rules to write to .htaccess.	 *	 * Does not actually write to the .htaccess file, but creates the rules for	 * the process that will.	 *	 * Will add  the non_wp_rules property rules to the .htaccess file before	 * the WordPress rewrite rules one.	 *	 * @since 1.5.0	 * @access public	 *	 * @return string	 */	function mod_rewrite_rules() {		if ( ! $this->using_permalinks() )			return '';		$site_root = parse_url(get_option('siteurl'));		if ( isset( $site_root['path'] ) )			$site_root = trailingslashit($site_root['path']);		$home_root = parse_url(home_url());		if ( isset( $home_root['path'] ) )			$home_root = trailingslashit($home_root['path']);		else			$home_root = '/';		$rules = "<IfModule mod_rewrite.c>\n";		$rules .= "RewriteEngine On\n";		$rules .= "RewriteBase $home_root\n";		$rules .= "RewriteRule ^index\.php$ - [L]\n"; // Prevent -f checks on index.php.		//add in the rules that don't redirect to WP's index.php (and thus shouldn't be handled by WP at all)		foreach ( (array) $this->non_wp_rules as $match => $query) {			// Apache 1.3 does not support the reluctant (non-greedy) modifier.			$match = str_replace('.+?', '.+', $match);			// If the match is unanchored and greedy, prepend rewrite conditions			// to avoid infinite redirects and eclipsing of real files.			//if ($match == '(.+)/?$' || $match == '([^/]+)/?$' ) {				//nada.			//}			$rules .= 'RewriteRule ^' . $match . ' ' . $home_root . $query . " [QSA,L]\n";		}		if ( $this->use_verbose_rules ) {			$this->matches = '';			$rewrite = $this->rewrite_rules();			$num_rules = count($rewrite);			$rules .= "RewriteCond %{REQUEST_FILENAME} -f [OR]\n" .				"RewriteCond %{REQUEST_FILENAME} -d\n" .				"RewriteRule ^.*$ - [S=$num_rules]\n";			foreach ( (array) $rewrite as $match => $query) {				// Apache 1.3 does not support the reluctant (non-greedy) modifier.				$match = str_replace('.+?', '.+', $match);				// If the match is unanchored and greedy, prepend rewrite conditions				// to avoid infinite redirects and eclipsing of real files.				//if ($match == '(.+)/?$' || $match == '([^/]+)/?$' ) {					//nada.				//}				if ( strpos($query, $this->index) !== false )					$rules .= 'RewriteRule ^' . $match . ' ' . $home_root . $query . " [QSA,L]\n";				else					$rules .= 'RewriteRule ^' . $match . ' ' . $site_root . $query . " [QSA,L]\n";			}		} else {			$rules .= "RewriteCond %{REQUEST_FILENAME} !-f\n" .				"RewriteCond %{REQUEST_FILENAME} !-d\n" .				"RewriteRule . {$home_root}{$this->index} [L]\n";		}		$rules .= "</IfModule>\n";		$rules = apply_filters('mod_rewrite_rules', $rules);		$rules = apply_filters('rewrite_rules', $rules);  // Deprecated		return $rules;	}	/**	 * Retrieve IIS7 URL Rewrite formatted rewrite rules to write to web.config file.	 *	 * Does not actually write to the web.config file, but creates the rules for	 * the process that will.	 *	 * @since 2.8.0	 * @access public	 *	 * @return string	 */	function iis7_url_rewrite_rules( $add_parent_tags = false ) {		if ( ! $this->using_permalinks() )			return '';		$rules = '';		if ( $add_parent_tags ) {			$rules .= '<configuration>	<system.webServer>		<rewrite>			<rules>';		}		if ( !is_multisite() ) {			$rules .= '				<rule name="wordpress" patternSyntax="Wildcard">					<match url="*" />						<conditions>							<add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />							<add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />						</conditions>					<action type="Rewrite" url="index.php" />				</rule>';		} else {			if (is_subdomain_install()) {				$rules .= '				<rule name="wordpress - Rule 1" stopProcessing="true">					<match url="^index\.php$" ignoreCase="false" />					<action type="None" />				</rule>				<rule name="wordpress - Rule 2" stopProcessing="true">					<match url="^files/(.+)" ignoreCase="false" />					<action type="Rewrite" url="wp-includes/ms-files.php?file={R:1}" appendQueryString="false" />				</rule>				<rule name="wordpress - Rule 3" stopProcessing="true">					<match url="^" ignoreCase="false" />					<conditions logicalGrouping="MatchAny">						<add input="{REQUEST_FILENAME}" matchType="IsFile" ignoreCase="false" />						<add input="{REQUEST_FILENAME}" matchType="IsDirectory" ignoreCase="false" />					</conditions>					<action type="None" />				</rule>				<rule name="wordpress - Rule 4" stopProcessing="true">					<match url="." ignoreCase="false" />					<action type="Rewrite" url="index.php" />				</rule>';			} else {				$rules .= '				<rule name="wordpress - Rule 1" stopProcessing="true">					<match url="^index\.php$" ignoreCase="false" />					<action type="None" />				</rule>				<rule name="wordpress - Rule 2" stopProcessing="true">					<match url="^([_0-9a-zA-Z-]+/)?files/(.+)" ignoreCase="false" />					<action type="Rewrite" url="wp-includes/ms-files.php?file={R:2}" appendQueryString="false" />				</rule>				<rule name="wordpress - Rule 3" stopProcessing="true">					<match url="^([_0-9a-zA-Z-]+/)?wp-admin$" ignoreCase="false" />					<action type="Redirect" url="{R:1}wp-admin/" redirectType="Permanent" />				</rule>				<rule name="wordpress - Rule 4" stopProcessing="true">					<match url="^" ignoreCase="false" />					<conditions logicalGrouping="MatchAny">						<add input="{REQUEST_FILENAME}" matchType="IsFile" ignoreCase="false" />						<add input="{REQUEST_FILENAME}" matchType="IsDirectory" ignoreCase="false" />					</conditions>					<action type="None" />				</rule>				<rule name="wordpress - Rule 5" stopProcessing="true">					<match url="^([_0-9a-zA-Z-]+/)?(wp-(content|admin|includes).*)" ignoreCase="false" />					<action type="Rewrite" url="{R:2}" />				</rule>				<rule name="wordpress - Rule 6" stopProcessing="true">					<match url="^([_0-9a-zA-Z-]+/)?(.*\.php)$" ignoreCase="false" />					<action type="Rewrite" url="{R:2}" />				</rule>				<rule name="wordpress - Rule 7" stopProcessing="true">					<match url="." ignoreCase="false" />					<action type="Rewrite" url="index.php" />				</rule>';			}		}		if ( $add_parent_tags ) {			$rules .= '			</rules>		</rewrite>	</system.webServer></configuration>';		}		$rules = apply_filters('iis7_url_rewrite_rules', $rules);		return $rules;	}	/**	 * Add a straight rewrite rule.	 *	 * Any value in the $after parameter that isn't 'bottom' will be placed at	 * the top of the rules.	 *	 * @since 2.1.0	 * @access public	 *	 * @param string $regex Regular expression to match against request.	 * @param string $redirect URL regex redirects to when regex matches request.	 * @param string $after Optional, default is bottom. Location to place rule.	 */	function add_rule($regex, $redirect, $after = 'bottom') {		//get everything up to the first ?		$index = (strpos($redirect, '?') == false ? strlen($redirect) : strpos($redirect, '?'));		$front = substr($redirect, 0, $index);		if ( $front != $this->index ) { //it doesn't redirect to WP's index.php			$this->add_external_rule($regex, $redirect);		} else {			if ( 'bottom' == $after)				$this->extra_rules = array_merge($this->extra_rules, array($regex => $redirect));			else				$this->extra_rules_top = array_merge($this->extra_rules_top, array($regex => $redirect));			//$this->extra_rules[$regex] = $redirect;		}	}	/**	 * Add a rule that doesn't redirect to index.php.	 *	 * Can redirect to any place.	 *	 * @since 2.1.0	 * @access public	 *	 * @param string $regex Regular expression to match against request.	 * @param string $redirect URL regex redirects to when regex matches request.	 */	function add_external_rule($regex, $redirect) {		$this->non_wp_rules[$regex] = $redirect;	}	/**	 * Add an endpoint, like /trackback/.	 *	 * To be inserted after certain URL types (specified in $places).	 *	 * @since 2.1.0	 * @access public	 *	 * @param string $name Name of endpoint.	 * @param array $places URL types that endpoint can be used.	 */	function add_endpoint($name, $places) {		global $wp;		$this->endpoints[] = array ( $places, $name );		$wp->add_query_var($name);	}	/**	 * Add permalink structure.	 *	 * These are added along with the extra rewrite rules that are merged to the	 * top.	 *	 * @since unknown	 * @access public	 *	 * @param string $name Name for permalink structure.	 * @param string $struct Permalink structure.	 * @param bool $with_front Prepend front base to permalink structure.	 */	function add_permastruct($name, $struct, $with_front = true, $ep_mask = EP_NONE) {		if ( $with_front )			$struct = $this->front . $struct;		$this->extra_permastructs[$name] = array($struct, $ep_mask);	}	/**	 * Remove rewrite rules and then recreate rewrite rules.	 *	 * Calls {@link WP_Rewrite::wp_rewrite_rules()} after removing the	 * 'rewrite_rules' option. If the function named 'save_mod_rewrite_rules'	 * exists, it will be called.	 *	 * @since 2.0.1	 * @access public	 * @param $hard bool Whether to update .htaccess (hard flush) or just update rewrite_rules option (soft flush). Default is true (hard).	 */	function flush_rules($hard = true) {		delete_option('rewrite_rules');		$this->wp_rewrite_rules();		if ( $hard && function_exists('save_mod_rewrite_rules') )			save_mod_rewrite_rules();		if ( $hard && function_exists('iis7_save_url_rewrite_rules') )			iis7_save_url_rewrite_rules();	}	/**	 * Sets up the object's properties.	 *	 * The 'use_verbose_page_rules' object property will be set to true if the	 * permalink structure begins with one of the following: '%postname%', '%category%',	 * '%tag%', or '%author%'.	 *	 * @since 1.5.0	 * @access public	 */	function init() {		$this->extra_rules = $this->non_wp_rules = $this->endpoints = array();		$this->permalink_structure = get_option('permalink_structure');		$this->front = substr($this->permalink_structure, 0, strpos($this->permalink_structure, '%'));		$this->root = '';		if ( $this->using_index_permalinks() )			$this->root = $this->index . '/';		$this->category_base = get_option( 'category_base' );		$this->tag_base = get_option( 'tag_base' );		unset($this->category_structure);		unset($this->author_structure);		unset($this->date_structure);		unset($this->page_structure);		unset($this->search_structure);		unset($this->feed_structure);		unset($this->comment_feed_structure);		$this->use_trailing_slashes = ( '/' == substr($this->permalink_structure, -1, 1) );		// Enable generic rules for pages if permalink structure doesn't begin with a wildcard.		if ( preg_match("/^[^%]*%(?:postname|category|tag|author)%/", $this->permalink_structure) )			 $this->use_verbose_page_rules = true;		else			$this->use_verbose_page_rules = false;	}	/**	 * Set the main permalink structure for the blog.	 *	 * Will update the 'permalink_structure' option, if there is a difference	 * between the current permalink structure and the parameter value. Calls	 * {@link WP_Rewrite::init()} after the option is updated.	 *	 * Fires the 'permalink_structure_changed' action once the init call has	 * processed passing the old and new values	 *	 * @since 1.5.0	 * @access public	 *	 * @param string $permalink_structure Permalink structure.	 */	function set_permalink_structure($permalink_structure) {		if ( $permalink_structure != $this->permalink_structure ) {			update_option('permalink_structure', $permalink_structure);			$this->init();			do_action('permalink_structure_changed', $this->permalink_structure, $permalink_structure);		}	}	/**	 * Set the category base for the category permalink.	 *	 * Will update the 'category_base' option, if there is a difference between	 * the current category base and the parameter value. Calls	 * {@link WP_Rewrite::init()} after the option is updated.	 *	 * @since 1.5.0	 * @access public	 *	 * @param string $category_base Category permalink structure base.	 */	function set_category_base($category_base) {		if ( $category_base != $this->category_base ) {			update_option('category_base', $category_base);			$this->init();		}	}	/**	 * Set the tag base for the tag permalink.	 *	 * Will update the 'tag_base' option, if there is a difference between the	 * current tag base and the parameter value. Calls	 * {@link WP_Rewrite::init()} after the option is updated.	 *	 * @since 2.3.0	 * @access public	 *	 * @param string $tag_base Tag permalink structure base.	 */	function set_tag_base( $tag_base ) {		if ( $tag_base != $this->tag_base ) {			update_option( 'tag_base', $tag_base );			$this->init();		}	}	/**	 * PHP4 Constructor - Calls init(), which runs setup.	 *	 * @since 1.5.0	 * @access public	 *	 * @return WP_Rewrite	 */	function WP_Rewrite() {		$this->init();	}}?>
<?php/** * WordPress Upgrade API * * Most of the functions are pluggable and can be overwritten * * @package WordPress * @subpackage Administration *//** Include user install customize script. */if ( file_exists(WP_CONTENT_DIR . '/install.php') )	require (WP_CONTENT_DIR . '/install.php');/** WordPress Administration API */require_once(ABSPATH . 'wp-admin/includes/admin.php');/** WordPress Schema API */require_once(ABSPATH . 'wp-admin/includes/schema.php');if ( !function_exists('wp_install') ) :/** * Installs the blog * * {@internal Missing Long Description}} * * @since unknown * * @param string $blog_title Blog title. * @param string $user_name User's username. * @param string $user_email User's email. * @param bool $public Whether blog is public. * @param null $deprecated Optional. Not used. * @param string $user_password Optional. User's chosen password. Will default to a random password. * @return array Array keys 'url', 'user_id', 'password', 'password_message'. */function wp_install( $blog_title, $user_name, $user_email, $public, $deprecated = '', $user_password = '' ) {	global $wp_rewrite;	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.6' );	wp_check_mysql_version();	wp_cache_flush();	make_db_current_silent();	populate_options();	populate_roles();	update_option('blogname', $blog_title);	update_option('admin_email', $user_email);	update_option('blog_public', $public);	$guessurl = wp_guess_url();	update_option('siteurl', $guessurl);	// If not a public blog, don't ping.	if ( ! $public )		update_option('default_pingback_flag', 0);	// Create default user.  If the user already exists, the user tables are	// being shared among blogs.  Just set the role in that case.	$user_id = username_exists($user_name);	$user_password = trim($user_password);	$email_password = false;	if ( !$user_id && empty($user_password) ) {		$user_password = wp_generate_password();		$message = __('<strong><em>Note that password</em></strong> carefully! It is a <em>random</em> password that was generated just for you.');		$user_id = wp_create_user($user_name, $user_password, $user_email);		update_user_option($user_id, 'default_password_nag', true, true);		$email_password = true;	} else if ( !$user_id ) {		// Password has been provided		$message = '<em>'.__('Your chosen password.').'</em>';		$user_id = wp_create_user($user_name, $user_password, $user_email);	} else {		$message =  __('User already exists. Password inherited.');	}	$user = new WP_User($user_id);	$user->set_role('administrator');	wp_install_defaults($user_id);	$wp_rewrite->flush_rules();	wp_new_blog_notification($blog_title, $guessurl, $user_id, ($email_password ? $user_password : __('The password you chose during the install.') ) );	wp_cache_flush();	return array('url' => $guessurl, 'user_id' => $user_id, 'password' => $user_password, 'password_message' => $message);}endif;if ( !function_exists('wp_install_defaults') ) :/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param int $user_id User ID. */function wp_install_defaults($user_id) {	global $wpdb, $wp_rewrite, $current_site, $table_prefix;	// Default category	$cat_name = __('Uncategorized');	/* translators: Default category slug */	$cat_slug = sanitize_title(_x('Uncategorized', 'Default category slug'));	if ( global_terms_enabled() ) {		$cat_id = $wpdb->get_var( $wpdb->prepare( "SELECT cat_ID FROM {$wpdb->sitecategories} WHERE category_nicename = %s", $cat_slug ) );		if ( $cat_id == null ) {			$wpdb->insert( $wpdb->sitecategories, array('cat_ID' => 0, 'cat_name' => $cat_name, 'category_nicename' => $cat_slug, 'last_updated' => current_time('mysql', true)) );			$cat_id = $wpdb->insert_id;		}		update_option('default_category', $cat_id);	} else {		$cat_id = 1;	}	$wpdb->insert( $wpdb->terms, array('term_id' => $cat_id, 'name' => $cat_name, 'slug' => $cat_slug, 'term_group' => 0) );	$wpdb->insert( $wpdb->term_taxonomy, array('term_id' => $cat_id, 'taxonomy' => 'category', 'description' => '', 'parent' => 0, 'count' => 1));	$cat_tt_id = $wpdb->insert_id;	// Default link category	$cat_name = __('Blogroll');	/* translators: Default link category slug */	$cat_slug = sanitize_title(_x('Blogroll', 'Default link category slug'));	if ( global_terms_enabled() ) {		$blogroll_id = $wpdb->get_var( $wpdb->prepare( "SELECT cat_ID FROM {$wpdb->sitecategories} WHERE category_nicename = %s", $cat_slug ) );		if ( $blogroll_id == null ) {			$wpdb->insert( $wpdb->sitecategories, array('cat_ID' => 0, 'cat_name' => $cat_name, 'category_nicename' => $cat_slug, 'last_updated' => current_time('mysql', true)) );			$blogroll_id = $wpdb->insert_id;		}		update_option('default_link_category', $blogroll_id);	} else {		$blogroll_id = 2;	}	$wpdb->insert( $wpdb->terms, array('term_id' => $blogroll_id, 'name' => $cat_name, 'slug' => $cat_slug, 'term_group' => 0) );	$wpdb->insert( $wpdb->term_taxonomy, array('term_id' => $blogroll_id, 'taxonomy' => 'link_category', 'description' => '', 'parent' => 0, 'count' => 7));	$blogroll_tt_id = $wpdb->insert_id;	// Now drop in some default links	$default_links = array();	$default_links[] = array(	'link_url' => 'http://codex.wordpress.org/',								'link_name' => 'Documentation',								'link_rss' => '',								'link_notes' => '');	$default_links[] = array(	'link_url' => 'http://wordpress.org/development/',								'link_name' => 'WordPress Blog',								'link_rss' => 'http://wordpress.org/development/feed/',								'link_notes' => '');	$default_links[] = array(	'link_url' => 'http://wordpress.org/extend/ideas/',								'link_name' => 'Suggest Ideas',								'link_rss' => '',								'link_notes' =>'');	$default_links[] = array(	'link_url' => 'http://wordpress.org/support/',								'link_name' => 'Support Forum',								'link_rss' => '',								'link_notes' =>'');	$default_links[] = array(	'link_url' => 'http://wordpress.org/extend/plugins/',								'link_name' => 'Plugins',								'link_rss' => '',								'link_notes' =>'');	$default_links[] = array(	'link_url' => 'http://wordpress.org/extend/themes/',								'link_name' => 'Themes',								'link_rss' => '',								'link_notes' =>'');	$default_links[] = array(	'link_url' => 'http://planet.wordpress.org/',								'link_name' => 'WordPress Planet',								'link_rss' => '',								'link_notes' =>'');	foreach ( $default_links as $link ) {		$wpdb->insert( $wpdb->links, $link);		$wpdb->insert( $wpdb->term_relationships, array('term_taxonomy_id' => $blogroll_tt_id, 'object_id' => $wpdb->insert_id) );	}	// First post	$now = date('Y-m-d H:i:s');	$now_gmt = gmdate('Y-m-d H:i:s');	$first_post_guid = get_option('home') . '/?p=1';	if ( is_multisite() ) {		$first_post = get_site_option( 'first_post' );		if ( empty($first_post) )			$first_post = stripslashes( __( 'Welcome to <a href="SITE_URL">SITE_NAME</a>. This is your first post. Edit or delete it, then start blogging!' ) );		$first_post = str_replace( "SITE_URL", esc_url( network_home_url() ), $first_post );		$first_post = str_replace( "SITE_NAME", $current_site->site_name, $first_post );	} else {		$first_post = __('Welcome to WordPress. This is your first post. Edit or delete it, then start blogging!');	}	$wpdb->insert( $wpdb->posts, array(								'post_author' => $user_id,								'post_date' => $now,								'post_date_gmt' => $now_gmt,								'post_content' => $first_post,								'post_excerpt' => '',								'post_title' => __('Hello world!'),								/* translators: Default post slug */								'post_name' => sanitize_title( _x('hello-world', 'Default post slug') ),								'post_modified' => $now,								'post_modified_gmt' => $now_gmt,								'guid' => $first_post_guid,								'comment_count' => 1,								'to_ping' => '',								'pinged' => '',								'post_content_filtered' => ''								));	$wpdb->insert( $wpdb->term_relationships, array('term_taxonomy_id' => $cat_tt_id, 'object_id' => 1) );	// Default comment	$first_comment_author = __('Mr WordPress');	$first_comment_url = 'http://wordpress.org/';	$first_comment = __('Hi, this is a comment.<br />To delete a comment, just log in and view the post&#039;s comments. There you will have the option to edit or delete them.');	if ( is_multisite() ) {		$first_comment_author = get_site_option( 'first_comment_author', $first_comment_author );		$first_comment_url = get_site_option( 'first_comment_url', network_home_url() );		$first_comment = get_site_option( 'first_comment', $first_comment );	}	$wpdb->insert( $wpdb->comments, array(								'comment_post_ID' => 1,								'comment_author' => $first_comment_author,								'comment_author_email' => '',								'comment_author_url' => $first_comment_url,								'comment_date' => $now,								'comment_date_gmt' => $now_gmt,								'comment_content' => $first_comment								));	// First Page	$first_page = __('This is an example of a WordPress page, you could edit this to put information about yourself or your site so readers know where you are coming from. You can create as many pages like this one or sub-pages as you like and manage all of your content inside of WordPress.');	if ( is_multisite() )		$first_page = get_site_option( 'first_page', $first_page );	$first_post_guid = get_option('home') . '/?page_id=2';	$wpdb->insert( $wpdb->posts, array(								'post_author' => $user_id,								'post_date' => $now,								'post_date_gmt' => $now_gmt,								'post_content' => $first_page,								'post_excerpt' => '',								'post_title' => __('About'),								/* translators: Default page slug */								'post_name' => _x('about', 'Default page slug'),								'post_modified' => $now,								'post_modified_gmt' => $now_gmt,								'guid' => $first_post_guid,								'post_type' => 'page',								'to_ping' => '',								'pinged' => '',								'post_content_filtered' => ''								));	$wpdb->insert( $wpdb->postmeta, array( 'post_id' => 2, 'meta_key' => '_wp_page_template', 'meta_value' => 'default' ) );	// Setup default widgets for default theme.	update_option( 'widget_search', array ( 2 => array ( 'title' => '' ), '_multiwidget' => 1 ) );	update_option( 'widget_recent-posts', array ( 2 => array ( 'title' => '', 'number' => 5 ), '_multiwidget' => 1 ) );	update_option( 'widget_recent-comments', array ( 2 => array ( 'title' => '', 'number' => 5 ), '_multiwidget' => 1 ) );	update_option( 'widget_archives', array ( 2 => array ( 'title' => '', 'count' => 0, 'dropdown' => 0 ), '_multiwidget' => 1 ) );	update_option( 'widget_categories', array ( 2 => array ( 'title' => '', 'count' => 0, 'hierarchical' => 0, 'dropdown' => 0 ), '_multiwidget' => 1 ) );	update_option( 'widget_meta', array ( 2 => array ( 'title' => '' ), '_multiwidget' => 1 ) );	update_option( 'sidebars_widgets', array ( 'wp_inactive_widgets' => array ( ), 'primary-widget-area' => array ( 0 => 'search-2', 1 => 'recent-posts-2', 2 => 'recent-comments-2', 3 => 'archives-2', 4 => 'categories-2', 5 => 'meta-2', ), 'secondary-widget-area' => array ( ), 'first-footer-widget-area' => array ( ), 'second-footer-widget-area' => array ( ), 'third-footer-widget-area' => array ( ), 'fourth-footer-widget-area' => array ( ), 'array_version' => 3 ) );	if ( is_multisite() ) {		// Flush rules to pick up the new page.		$wp_rewrite->init();		$wp_rewrite->flush_rules();		$user = new WP_User($user_id);		$wpdb->update( $wpdb->options, array('option_value' => $user->user_email), array('option_name' => 'admin_email') );		// Remove all perms except for the login user.		$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->usermeta WHERE user_id != %d AND meta_key = %s", $user_id, $table_prefix.'user_level') );		$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->usermeta WHERE user_id != %d AND meta_key = %s", $user_id, $table_prefix.'capabilities') );		// Delete any caps that snuck into the previously active blog. (Hardcoded to blog 1 for now.) TODO: Get previous_blog_id.		if ( !is_super_admin( $user_id ) && $user_id != 1 )			$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->usermeta WHERE user_id = %d AND meta_key = %s", $user_id, $wpdb->base_prefix.'1_capabilities') );	}}endif;if ( !function_exists('wp_new_blog_notification') ) :/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param string $blog_title Blog title. * @param string $blog_url Blog url. * @param int $user_id User ID. * @param string $password User's Password. */function wp_new_blog_notification($blog_title, $blog_url, $user_id, $password) {	$user = new WP_User($user_id);	$email = $user->user_email;	$name = $user->user_login;	$message = sprintf(__("Your new WordPress site has been successfully set up at:%1\$sYou can log in to the administrator account with the following information:Username: %2\$sPassword: %3\$sWe hope you enjoy your new site. Thanks!--The WordPress Teamhttp://wordpress.org/"), $blog_url, $name, $password);	@wp_mail($email, __('New WordPress Site'), $message);}endif;if ( !function_exists('wp_upgrade') ) :/** * Run WordPress Upgrade functions. * * {@internal Missing Long Description}} * * @since unknown * * @return null */function wp_upgrade() {	global $wp_current_db_version, $wp_db_version, $wpdb;	$wp_current_db_version = __get_option('db_version');	// We are up-to-date.  Nothing to do.	if ( $wp_db_version == $wp_current_db_version )		return;	if ( ! is_blog_installed() )		return;	wp_check_mysql_version();	wp_cache_flush();	pre_schema_upgrade();	make_db_current_silent();	upgrade_all();	if ( is_multisite() && is_main_site() )		upgrade_network();	wp_cache_flush();	if ( is_multisite() ) {		if ( $wpdb->get_row( "SELECT blog_id FROM {$wpdb->blog_versions} WHERE blog_id = '{$wpdb->blogid}'" ) )			$wpdb->query( "UPDATE {$wpdb->blog_versions} SET db_version = '{$wp_db_version}' WHERE blog_id = '{$wpdb->blogid}'" );		else			$wpdb->query( "INSERT INTO {$wpdb->blog_versions} ( `blog_id` , `db_version` , `last_updated` ) VALUES ( '{$wpdb->blogid}', '{$wp_db_version}', NOW());" );	}}endif;/** * Functions to be called in install and upgrade scripts. * * {@internal Missing Long Description}} * * @since unknown */function upgrade_all() {	global $wp_current_db_version, $wp_db_version, $wp_rewrite;	$wp_current_db_version = __get_option('db_version');	// We are up-to-date.  Nothing to do.	if ( $wp_db_version == $wp_current_db_version )		return;	// If the version is not set in the DB, try to guess the version.	if ( empty($wp_current_db_version) ) {		$wp_current_db_version = 0;		// If the template option exists, we have 1.5.		$template = __get_option('template');		if ( !empty($template) )			$wp_current_db_version = 2541;	}	if ( $wp_current_db_version < 6039 )		upgrade_230_options_table();	populate_options();	if ( $wp_current_db_version < 2541 ) {		upgrade_100();		upgrade_101();		upgrade_110();		upgrade_130();	}	if ( $wp_current_db_version < 3308 )		upgrade_160();	if ( $wp_current_db_version < 4772 )		upgrade_210();	if ( $wp_current_db_version < 4351 )		upgrade_old_slugs();	if ( $wp_current_db_version < 5539 )		upgrade_230();	if ( $wp_current_db_version < 6124 )		upgrade_230_old_tables();	if ( $wp_current_db_version < 7499 )		upgrade_250();	if ( $wp_current_db_version < 7935 )		upgrade_252();	if ( $wp_current_db_version < 8201 )		upgrade_260();	if ( $wp_current_db_version < 8989 )		upgrade_270();	if ( $wp_current_db_version < 10360 )		upgrade_280();	if ( $wp_current_db_version < 11958 )		upgrade_290();	if ( $wp_current_db_version < 15260 )		upgrade_300();	maybe_disable_automattic_widgets();	update_option( 'db_version', $wp_db_version );	update_option( 'db_upgraded', true );}/** * Execute changes made in WordPress 1.0. * * @since 1.0.0 */function upgrade_100() {	global $wpdb;	// Get the title and ID of every post, post_name to check if it already has a value	$posts = $wpdb->get_results("SELECT ID, post_title, post_name FROM $wpdb->posts WHERE post_name = ''");	if ($posts) {		foreach($posts as $post) {			if ('' == $post->post_name) {				$newtitle = sanitize_title($post->post_title);				$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET post_name = %s WHERE ID = %d", $newtitle, $post->ID) );			}		}	}	$categories = $wpdb->get_results("SELECT cat_ID, cat_name, category_nicename FROM $wpdb->categories");	foreach ($categories as $category) {		if ('' == $category->category_nicename) {			$newtitle = sanitize_title($category->cat_name);			$wpdb>update( $wpdb->categories, array('category_nicename' => $newtitle), array('cat_ID' => $category->cat_ID) );		}	}	$wpdb->query("UPDATE $wpdb->options SET option_value = REPLACE(option_value, 'wp-links/links-images/', 'wp-images/links/')	WHERE option_name LIKE 'links_rating_image%'	AND option_value LIKE 'wp-links/links-images/%'");	$done_ids = $wpdb->get_results("SELECT DISTINCT post_id FROM $wpdb->post2cat");	if ($done_ids) :		foreach ($done_ids as $done_id) :			$done_posts[] = $done_id->post_id;		endforeach;		$catwhere = ' AND ID NOT IN (' . implode(',', $done_posts) . ')';	else:		$catwhere = '';	endif;	$allposts = $wpdb->get_results("SELECT ID, post_category FROM $wpdb->posts WHERE post_category != '0' $catwhere");	if ($allposts) :		foreach ($allposts as $post) {			// Check to see if it's already been imported			$cat = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->post2cat WHERE post_id = %d AND category_id = %d", $post->ID, $post->post_category) );			if (!$cat && 0 != $post->post_category) { // If there's no result				$wpdb->insert( $wpdb->post2cat, array('post_id' => $post->ID, 'category_id' => $post->post_category) );			}		}	endif;}/** * Execute changes made in WordPress 1.0.1. * * @since 1.0.1 */function upgrade_101() {	global $wpdb;	// Clean up indices, add a few	add_clean_index($wpdb->posts, 'post_name');	add_clean_index($wpdb->posts, 'post_status');	add_clean_index($wpdb->categories, 'category_nicename');	add_clean_index($wpdb->comments, 'comment_approved');	add_clean_index($wpdb->comments, 'comment_post_ID');	add_clean_index($wpdb->links , 'link_category');	add_clean_index($wpdb->links , 'link_visible');}/** * Execute changes made in WordPress 1.2. * * @since 1.2.0 */function upgrade_110() {	global $wpdb;	// Set user_nicename.	$users = $wpdb->get_results("SELECT ID, user_nickname, user_nicename FROM $wpdb->users");	foreach ($users as $user) {		if ('' == $user->user_nicename) {			$newname = sanitize_title($user->user_nickname);			$wpdb->update( $wpdb->users, array('user_nicename' => $newname), array('ID' => $user->ID) );		}	}	$users = $wpdb->get_results("SELECT ID, user_pass from $wpdb->users");	foreach ($users as $row) {		if (!preg_match('/^[A-Fa-f0-9]{32}$/', $row->user_pass)) {			$wpdb->update( $wpdb->users, array('user_pass' => md5($row->user_pass)), array('ID' => $row->ID) );		}	}	// Get the GMT offset, we'll use that later on	$all_options = get_alloptions_110();	$time_difference = $all_options->time_difference;	$server_time = time()+date('Z');	$weblogger_time = $server_time + $time_difference*3600;	$gmt_time = time();	$diff_gmt_server = ($gmt_time - $server_time) / 3600;	$diff_weblogger_server = ($weblogger_time - $server_time) / 3600;	$diff_gmt_weblogger = $diff_gmt_server - $diff_weblogger_server;	$gmt_offset = -$diff_gmt_weblogger;	// Add a gmt_offset option, with value $gmt_offset	add_option('gmt_offset', $gmt_offset);	// Check if we already set the GMT fields (if we did, then	// MAX(post_date_gmt) can't be '0000-00-00 00:00:00'	// <michel_v> I just slapped myself silly for not thinking about it earlier	$got_gmt_fields = ! ($wpdb->get_var("SELECT MAX(post_date_gmt) FROM $wpdb->posts") == '0000-00-00 00:00:00');	if (!$got_gmt_fields) {		// Add or substract time to all dates, to get GMT dates		$add_hours = intval($diff_gmt_weblogger);		$add_minutes = intval(60 * ($diff_gmt_weblogger - $add_hours));		$wpdb->query("UPDATE $wpdb->posts SET post_date_gmt = DATE_ADD(post_date, INTERVAL '$add_hours:$add_minutes' HOUR_MINUTE)");		$wpdb->query("UPDATE $wpdb->posts SET post_modified = post_date");		$wpdb->query("UPDATE $wpdb->posts SET post_modified_gmt = DATE_ADD(post_modified, INTERVAL '$add_hours:$add_minutes' HOUR_MINUTE) WHERE post_modified != '0000-00-00 00:00:00'");		$wpdb->query("UPDATE $wpdb->comments SET comment_date_gmt = DATE_ADD(comment_date, INTERVAL '$add_hours:$add_minutes' HOUR_MINUTE)");		$wpdb->query("UPDATE $wpdb->users SET user_registered = DATE_ADD(user_registered, INTERVAL '$add_hours:$add_minutes' HOUR_MINUTE)");	}}/** * Execute changes made in WordPress 1.5. * * @since 1.5.0 */function upgrade_130() {	global $wpdb;	// Remove extraneous backslashes.	$posts = $wpdb->get_results("SELECT ID, post_title, post_content, post_excerpt, guid, post_date, post_name, post_status, post_author FROM $wpdb->posts");	if ($posts) {		foreach($posts as $post) {			$post_content = addslashes(deslash($post->post_content));			$post_title = addslashes(deslash($post->post_title));			$post_excerpt = addslashes(deslash($post->post_excerpt));			if ( empty($post->guid) )				$guid = get_permalink($post->ID);			else				$guid = $post->guid;			$wpdb->update( $wpdb->posts, compact('post_title', 'post_content', 'post_excerpt', 'guid'), array('ID' => $post->ID) );		}	}	// Remove extraneous backslashes.	$comments = $wpdb->get_results("SELECT comment_ID, comment_author, comment_content FROM $wpdb->comments");	if ($comments) {		foreach($comments as $comment) {			$comment_content = deslash($comment->comment_content);			$comment_author = deslash($comment->comment_author);			$wpdb->update($wpdb->comments, compact('comment_content', 'comment_author'), array('comment_ID' => $comment->comment_ID) );		}	}	// Remove extraneous backslashes.	$links = $wpdb->get_results("SELECT link_id, link_name, link_description FROM $wpdb->links");	if ($links) {		foreach($links as $link) {			$link_name = deslash($link->link_name);			$link_description = deslash($link->link_description);			$wpdb->update( $wpdb->links, compact('link_name', 'link_description'), array('link_id' => $link->link_id) );		}	}	$active_plugins = __get_option('active_plugins');	// If plugins are not stored in an array, they're stored in the old	// newline separated format.  Convert to new format.	if ( !is_array( $active_plugins ) ) {		$active_plugins = explode("\n", trim($active_plugins));		update_option('active_plugins', $active_plugins);	}	// Obsolete tables	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'optionvalues');	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'optiontypes');	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'optiongroups');	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'optiongroup_options');	// Update comments table to use comment_type	$wpdb->query("UPDATE $wpdb->comments SET comment_type='trackback', comment_content = REPLACE(comment_content, '<trackback />', '') WHERE comment_content LIKE '<trackback />%'");	$wpdb->query("UPDATE $wpdb->comments SET comment_type='pingback', comment_content = REPLACE(comment_content, '<pingback />', '') WHERE comment_content LIKE '<pingback />%'");	// Some versions have multiple duplicate option_name rows with the same values	$options = $wpdb->get_results("SELECT option_name, COUNT(option_name) AS dupes FROM `$wpdb->options` GROUP BY option_name");	foreach ( $options as $option ) {		if ( 1 != $option->dupes ) { // Could this be done in the query?			$limit = $option->dupes - 1;			$dupe_ids = $wpdb->get_col( $wpdb->prepare("SELECT option_id FROM $wpdb->options WHERE option_name = %s LIMIT %d", $option->option_name, $limit) );			if ( $dupe_ids ) {				$dupe_ids = join($dupe_ids, ',');				$wpdb->query("DELETE FROM $wpdb->options WHERE option_id IN ($dupe_ids)");			}		}	}	make_site_theme();}/** * Execute changes made in WordPress 2.0. * * @since 2.0.0 */function upgrade_160() {	global $wpdb, $wp_current_db_version;	populate_roles_160();	$users = $wpdb->get_results("SELECT * FROM $wpdb->users");	foreach ( $users as $user ) :		if ( !empty( $user->user_firstname ) )			update_user_meta( $user->ID, 'first_name', $wpdb->escape($user->user_firstname) );		if ( !empty( $user->user_lastname ) )			update_user_meta( $user->ID, 'last_name', $wpdb->escape($user->user_lastname) );		if ( !empty( $user->user_nickname ) )			update_user_meta( $user->ID, 'nickname', $wpdb->escape($user->user_nickname) );		if ( !empty( $user->user_level ) )			update_user_meta( $user->ID, $wpdb->prefix . 'user_level', $user->user_level );		if ( !empty( $user->user_icq ) )			update_user_meta( $user->ID, 'icq', $wpdb->escape($user->user_icq) );		if ( !empty( $user->user_aim ) )			update_user_meta( $user->ID, 'aim', $wpdb->escape($user->user_aim) );		if ( !empty( $user->user_msn ) )			update_user_meta( $user->ID, 'msn', $wpdb->escape($user->user_msn) );		if ( !empty( $user->user_yim ) )			update_user_meta( $user->ID, 'yim', $wpdb->escape($user->user_icq) );		if ( !empty( $user->user_description ) )			update_user_meta( $user->ID, 'description', $wpdb->escape($user->user_description) );		if ( isset( $user->user_idmode ) ):			$idmode = $user->user_idmode;			if ($idmode == 'nickname') $id = $user->user_nickname;			if ($idmode == 'login') $id = $user->user_login;			if ($idmode == 'firstname') $id = $user->user_firstname;			if ($idmode == 'lastname') $id = $user->user_lastname;			if ($idmode == 'namefl') $id = $user->user_firstname.' '.$user->user_lastname;			if ($idmode == 'namelf') $id = $user->user_lastname.' '.$user->user_firstname;			if (!$idmode) $id = $user->user_nickname;			$wpdb->update( $wpdb->users, array('display_name' => $id), array('ID' => $user->ID) );		endif;		// FIXME: RESET_CAPS is temporary code to reset roles and caps if flag is set.		$caps = get_user_meta( $user->ID, $wpdb->prefix . 'capabilities');		if ( empty($caps) || defined('RESET_CAPS') ) {			$level = get_user_meta($user->ID, $wpdb->prefix . 'user_level', true);			$role = translate_level_to_role($level);			update_user_meta( $user->ID, $wpdb->prefix . 'capabilities', array($role => true) );		}	endforeach;	$old_user_fields = array( 'user_firstname', 'user_lastname', 'user_icq', 'user_aim', 'user_msn', 'user_yim', 'user_idmode', 'user_ip', 'user_domain', 'user_browser', 'user_description', 'user_nickname', 'user_level' );	$wpdb->hide_errors();	foreach ( $old_user_fields as $old )		$wpdb->query("ALTER TABLE $wpdb->users DROP $old");	$wpdb->show_errors();	// populate comment_count field of posts table	$comments = $wpdb->get_results( "SELECT comment_post_ID, COUNT(*) as c FROM $wpdb->comments WHERE comment_approved = '1' GROUP BY comment_post_ID" );	if ( is_array( $comments ) )		foreach ($comments as $comment)			$wpdb->update( $wpdb->posts, array('comment_count' => $comment->c), array('ID' => $comment->comment_post_ID) );	// Some alpha versions used a post status of object instead of attachment and put	// the mime type in post_type instead of post_mime_type.	if ( $wp_current_db_version > 2541 && $wp_current_db_version <= 3091 ) {		$objects = $wpdb->get_results("SELECT ID, post_type FROM $wpdb->posts WHERE post_status = 'object'");		foreach ($objects as $object) {			$wpdb->update( $wpdb->posts, array(	'post_status' => 'attachment',												'post_mime_type' => $object->post_type,												'post_type' => ''),										 array( 'ID' => $object->ID ) );			$meta = get_post_meta($object->ID, 'imagedata', true);			if ( ! empty($meta['file']) )				update_attached_file( $object->ID, $meta['file'] );		}	}}/** * Execute changes made in WordPress 2.1. * * @since 2.1.0 */function upgrade_210() {	global $wpdb, $wp_current_db_version;	if ( $wp_current_db_version < 3506 ) {		// Update status and type.		$posts = $wpdb->get_results("SELECT ID, post_status FROM $wpdb->posts");		if ( ! empty($posts) ) foreach ($posts as $post) {			$status = $post->post_status;			$type = 'post';			if ( 'static' == $status ) {				$status = 'publish';				$type = 'page';			} else if ( 'attachment' == $status ) {				$status = 'inherit';				$type = 'attachment';			}			$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET post_status = %s, post_type = %s WHERE ID = %d", $status, $type, $post->ID) );		}	}	if ( $wp_current_db_version < 3845 ) {		populate_roles_210();	}	if ( $wp_current_db_version < 3531 ) {		// Give future posts a post_status of future.		$now = gmdate('Y-m-d H:i:59');		$wpdb->query ("UPDATE $wpdb->posts SET post_status = 'future' WHERE post_status = 'publish' AND post_date_gmt > '$now'");		$posts = $wpdb->get_results("SELECT ID, post_date FROM $wpdb->posts WHERE post_status ='future'");		if ( !empty($posts) )			foreach ( $posts as $post )				wp_schedule_single_event(mysql2date('U', $post->post_date, false), 'publish_future_post', array($post->ID));	}}/** * Execute changes made in WordPress 2.3. * * @since 2.3.0 */function upgrade_230() {	global $wp_current_db_version, $wpdb;	if ( $wp_current_db_version < 5200 ) {		populate_roles_230();	}	// Convert categories to terms.	$tt_ids = array();	$have_tags = false;	$categories = $wpdb->get_results("SELECT * FROM $wpdb->categories ORDER BY cat_ID");	foreach ($categories as $category) {		$term_id = (int) $category->cat_ID;		$name = $category->cat_name;		$description = $category->category_description;		$slug = $category->category_nicename;		$parent = $category->category_parent;		$term_group = 0;		// Associate terms with the same slug in a term group and make slugs unique.		if ( $exists = $wpdb->get_results( $wpdb->prepare("SELECT term_id, term_group FROM $wpdb->terms WHERE slug = %s", $slug) ) ) {			$term_group = $exists[0]->term_group;			$id = $exists[0]->term_id;			$num = 2;			do {				$alt_slug = $slug . "-$num";				$num++;				$slug_check = $wpdb->get_var( $wpdb->prepare("SELECT slug FROM $wpdb->terms WHERE slug = %s", $alt_slug) );			} while ( $slug_check );			$slug = $alt_slug;			if ( empty( $term_group ) ) {				$term_group = $wpdb->get_var("SELECT MAX(term_group) FROM $wpdb->terms GROUP BY term_group") + 1;				$wpdb->query( $wpdb->prepare("UPDATE $wpdb->terms SET term_group = %d WHERE term_id = %d", $term_group, $id) );			}		}		$wpdb->query( $wpdb->prepare("INSERT INTO $wpdb->terms (term_id, name, slug, term_group) VALUES		(%d, %s, %s, %d)", $term_id, $name, $slug, $term_group) );		$count = 0;		if ( !empty($category->category_count) ) {			$count = (int) $category->category_count;			$taxonomy = 'category';			$wpdb->query( $wpdb->prepare("INSERT INTO $wpdb->term_taxonomy (term_id, taxonomy, description, parent, count) VALUES ( %d, %s, %s, %d, %d)", $term_id, $taxonomy, $description, $parent, $count) );			$tt_ids[$term_id][$taxonomy] = (int) $wpdb->insert_id;		}		if ( !empty($category->link_count) ) {			$count = (int) $category->link_count;			$taxonomy = 'link_category';			$wpdb->query( $wpdb->prepare("INSERT INTO $wpdb->term_taxonomy (term_id, taxonomy, description, parent, count) VALUES ( %d, %s, %s, %d, %d)", $term_id, $taxonomy, $description, $parent, $count) );			$tt_ids[$term_id][$taxonomy] = (int) $wpdb->insert_id;		}		if ( !empty($category->tag_count) ) {			$have_tags = true;			$count = (int) $category->tag_count;			$taxonomy = 'post_tag';			$wpdb->insert( $wpdb->term_taxonomy, compact('term_id', 'taxonomy', 'description', 'parent', 'count') );			$tt_ids[$term_id][$taxonomy] = (int) $wpdb->insert_id;		}		if ( empty($count) ) {			$count = 0;			$taxonomy = 'category';			$wpdb->insert( $wpdb->term_taxonomy, compact('term_id', 'taxonomy', 'description', 'parent', 'count') );			$tt_ids[$term_id][$taxonomy] = (int) $wpdb->insert_id;		}	}	$select = 'post_id, category_id';	if ( $have_tags )		$select .= ', rel_type';	$posts = $wpdb->get_results("SELECT $select FROM $wpdb->post2cat GROUP BY post_id, category_id");	foreach ( $posts as $post ) {		$post_id = (int) $post->post_id;		$term_id = (int) $post->category_id;		$taxonomy = 'category';		if ( !empty($post->rel_type) && 'tag' == $post->rel_type)			$taxonomy = 'tag';		$tt_id = $tt_ids[$term_id][$taxonomy];		if ( empty($tt_id) )			continue;		$wpdb->insert( $wpdb->term_relationships, array('object_id' => $post_id, 'term_taxonomy_id' => $tt_id) );	}	// < 3570 we used linkcategories.  >= 3570 we used categories and link2cat.	if ( $wp_current_db_version < 3570 ) {		// Create link_category terms for link categories.  Create a map of link cat IDs		// to link_category terms.		$link_cat_id_map = array();		$default_link_cat = 0;		$tt_ids = array();		$link_cats = $wpdb->get_results("SELECT cat_id, cat_name FROM " . $wpdb->prefix . 'linkcategories');		foreach ( $link_cats as $category) {			$cat_id = (int) $category->cat_id;			$term_id = 0;			$name = $wpdb->escape($category->cat_name);			$slug = sanitize_title($name);			$term_group = 0;			// Associate terms with the same slug in a term group and make slugs unique.			if ( $exists = $wpdb->get_results( $wpdb->prepare("SELECT term_id, term_group FROM $wpdb->terms WHERE slug = %s", $slug) ) ) {				$term_group = $exists[0]->term_group;				$term_id = $exists[0]->term_id;			}			if ( empty($term_id) ) {				$wpdb->insert( $wpdb->terms, compact('name', 'slug', 'term_group') );				$term_id = (int) $wpdb->insert_id;			}			$link_cat_id_map[$cat_id] = $term_id;			$default_link_cat = $term_id;			$wpdb->insert( $wpdb->term_taxonomy, array('term_id' => $term_id, 'taxonomy' => 'link_category', 'description' => '', 'parent' => 0, 'count' => 0) );			$tt_ids[$term_id] = (int) $wpdb->insert_id;		}		// Associate links to cats.		$links = $wpdb->get_results("SELECT link_id, link_category FROM $wpdb->links");		if ( !empty($links) ) foreach ( $links as $link ) {			if ( 0 == $link->link_category )				continue;			if ( ! isset($link_cat_id_map[$link->link_category]) )				continue;			$term_id = $link_cat_id_map[$link->link_category];			$tt_id = $tt_ids[$term_id];			if ( empty($tt_id) )				continue;			$wpdb->insert( $wpdb->term_relationships, array('object_id' => $link->link_id, 'term_taxonomy_id' => $tt_id) );		}		// Set default to the last category we grabbed during the upgrade loop.		update_option('default_link_category', $default_link_cat);	} else {		$links = $wpdb->get_results("SELECT link_id, category_id FROM $wpdb->link2cat GROUP BY link_id, category_id");		foreach ( $links as $link ) {			$link_id = (int) $link->link_id;			$term_id = (int) $link->category_id;			$taxonomy = 'link_category';			$tt_id = $tt_ids[$term_id][$taxonomy];			if ( empty($tt_id) )				continue;			$wpdb->insert( $wpdb->term_relationships, array('object_id' => $link_id, 'term_taxonomy_id' => $tt_id) );		}	}	if ( $wp_current_db_version < 4772 ) {		// Obsolete linkcategories table		$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'linkcategories');	}	// Recalculate all counts	$terms = $wpdb->get_results("SELECT term_taxonomy_id, taxonomy FROM $wpdb->term_taxonomy");	foreach ( (array) $terms as $term ) {		if ( ('post_tag' == $term->taxonomy) || ('category' == $term->taxonomy) )			$count = $wpdb->get_var( $wpdb->prepare("SELECT COUNT(*) FROM $wpdb->term_relationships, $wpdb->posts WHERE $wpdb->posts.ID = $wpdb->term_relationships.object_id AND post_status = 'publish' AND post_type = 'post' AND term_taxonomy_id = %d", $term->term_taxonomy_id) );		else			$count = $wpdb->get_var( $wpdb->prepare("SELECT COUNT(*) FROM $wpdb->term_relationships WHERE term_taxonomy_id = %d", $term->term_taxonomy_id) );		$wpdb->update( $wpdb->term_taxonomy, array('count' => $count), array('term_taxonomy_id' => $term->term_taxonomy_id) );	}}/** * Remove old options from the database. * * @since 2.3.0 */function upgrade_230_options_table() {	global $wpdb;	$old_options_fields = array( 'option_can_override', 'option_type', 'option_width', 'option_height', 'option_description', 'option_admin_level' );	$wpdb->hide_errors();	foreach ( $old_options_fields as $old )		$wpdb->query("ALTER TABLE $wpdb->options DROP $old");	$wpdb->show_errors();}/** * Remove old categories, link2cat, and post2cat database tables. * * @since 2.3.0 */function upgrade_230_old_tables() {	global $wpdb;	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'categories');	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'link2cat');	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'post2cat');}/** * Upgrade old slugs made in version 2.2. * * @since 2.2.0 */function upgrade_old_slugs() {	// upgrade people who were using the Redirect Old Slugs plugin	global $wpdb;	$wpdb->query("UPDATE $wpdb->postmeta SET meta_key = '_wp_old_slug' WHERE meta_key = 'old_slug'");}/** * Execute changes made in WordPress 2.5.0. * * @since 2.5.0 */function upgrade_250() {	global $wp_current_db_version;	if ( $wp_current_db_version < 6689 ) {		populate_roles_250();	}}/** * Execute changes made in WordPress 2.5.2. * * @since 2.5.2 */function upgrade_252() {	global $wpdb;	$wpdb->query("UPDATE $wpdb->users SET user_activation_key = ''");}/** * Execute changes made in WordPress 2.6. * * @since 2.6.0 */function upgrade_260() {	global $wp_current_db_version;	if ( $wp_current_db_version < 8000 )		populate_roles_260();	if ( $wp_current_db_version < 8201 ) {		update_option('enable_app', 1);		update_option('enable_xmlrpc', 1);	}}/** * Execute changes made in WordPress 2.7. * * @since 2.7.0 */function upgrade_270() {	global $wpdb, $wp_current_db_version;	if ( $wp_current_db_version < 8980 )		populate_roles_270();	// Update post_date for unpublished posts with empty timestamp	if ( $wp_current_db_version < 8921 )		$wpdb->query( "UPDATE $wpdb->posts SET post_date = post_modified WHERE post_date = '0000-00-00 00:00:00'" );}/** * Execute changes made in WordPress 2.8. * * @since 2.8.0 */function upgrade_280() {	global $wp_current_db_version, $wpdb;	if ( $wp_current_db_version < 10360 )		populate_roles_280();	if ( is_multisite() ) {		$start = 0;		while( $rows = $wpdb->get_results( "SELECT option_name, option_value FROM $wpdb->options ORDER BY option_id LIMIT $start, 20" ) ) {			foreach( $rows as $row ) {				$value = $row->option_value;				if ( !@unserialize( $value ) )					$value = stripslashes( $value );				if ( $value !== $row->option_value ) {					update_option( $row->option_name, $value );				}			}			$start += 20;		}		refresh_blog_details( $wpdb->blogid );	}}/** * Execute changes made in WordPress 2.9. * * @since 2.9.0 */function upgrade_290() {	global $wp_current_db_version;	if ( $wp_current_db_version < 11958 ) {		// Previously, setting depth to 1 would redundantly disable threading, but now 2 is the minimum depth to avoid confusion		if ( get_option( 'thread_comments_depth' ) == '1' ) {			update_option( 'thread_comments_depth', 2 );			update_option( 'thread_comments', 0 );		}	}}/** * Execute changes made in WordPress 3.0. * * @since 3.0.0 */function upgrade_300() {	global $wp_current_db_version, $wpdb;	if ( $wp_current_db_version < 15093 )		populate_roles_300();	if ( $wp_current_db_version < 14139 && is_multisite() && is_main_site() && ! defined( 'MULTISITE' ) && get_site_option( 'siteurl' ) === false )		add_site_option( 'siteurl', '' );	// 3.0-alpha nav menu postmeta changes. can be removed before release. // r13802	if ( $wp_current_db_version >= 13226 && $wp_current_db_version < 13974 )		$wpdb->query( "DELETE FROM $wpdb->postmeta WHERE meta_key IN( 'menu_type', 'object_id', 'menu_new_window', 'menu_link', '_menu_item_append', 'menu_item_append', 'menu_item_type', 'menu_item_object_id', 'menu_item_target', 'menu_item_classes', 'menu_item_xfn', 'menu_item_url' )" );	// 3.0-beta1 remove_user primitive->meta cap. can be removed before release. r13956	if ( $wp_current_db_version >= 12751 && $wp_current_db_version < 13974 ) {		$role =& get_role( 'administrator' );		if ( ! empty( $role ) )			$role->remove_cap( 'remove_user' );	}	// 3.0-beta1 nav menu postmeta changes. can be removed before release. r13974	if ( $wp_current_db_version >= 13802 && $wp_current_db_version < 13974 )		$wpdb->update( $wpdb->postmeta, array( 'meta_value' => '' ), array( 'meta_key' => '_menu_item_target', 'meta_value' => '_self' ) );	// 3.0 screen options key name changes.	if ( !is_multisite() || is_main_site() ) {		$prefix = like_escape($wpdb->base_prefix);		$wpdb->query( "DELETE FROM $wpdb->usermeta WHERE meta_key LIKE '{$prefix}%meta-box-hidden%' OR meta_key LIKE '{$prefix}%closedpostboxes%' OR meta_key LIKE '{$prefix}%manage-%-columns-hidden%' OR meta_key LIKE '{$prefix}%meta-box-order%' OR meta_key LIKE '{$prefix}%metaboxorder%' OR meta_key LIKE '{$prefix}%screen_layout%'					 OR meta_key = 'manageedittagscolumnshidden' OR meta_key='managecategoriescolumnshidden' OR meta_key = 'manageedit-tagscolumnshidden' OR meta_key = 'manageeditcolumnshidden' OR meta_key = 'categories_per_page' OR meta_key = 'edit_tags_per_page'" );	}}/** * Execute network level changes * * @since 3.0.0 */function upgrade_network() {	global $wp_current_db_version, $wpdb;	// 2.8	if ( $wp_current_db_version < 11549 ) {		$wpmu_sitewide_plugins = get_site_option( 'wpmu_sitewide_plugins' );		$active_sitewide_plugins = get_site_option( 'active_sitewide_plugins' );		if ( $wpmu_sitewide_plugins ) {			if ( !$active_sitewide_plugins )				$sitewide_plugins = (array) $wpmu_sitewide_plugins;			else				$sitewide_plugins = array_merge( (array) $active_sitewide_plugins, (array) $wpmu_sitewide_plugins );			update_site_option( 'active_sitewide_plugins', $sitewide_plugins );		}		delete_site_option( 'wpmu_sitewide_plugins' );		delete_site_option( 'deactivated_sitewide_plugins' );		$start = 0;		while( $rows = $wpdb->get_results( "SELECT meta_key, meta_value FROM {$wpdb->sitemeta} ORDER BY meta_id LIMIT $start, 20" ) ) {			foreach( $rows as $row ) {				$value = $row->meta_value;				if ( !@unserialize( $value ) )					$value = stripslashes( $value );				if ( $value !== $row->meta_value ) {					update_site_option( $row->meta_key, $value );				}			}			$start += 20;		}	}	// 3.0	if ( $wp_current_db_version < 13576 )		update_site_option( 'global_terms_enabled', '1' );}// The functions we use to actually do stuff// General/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param string $table_name Database table name to create. * @param string $create_ddl SQL statement to create table. * @return bool If table already exists or was created by function. */function maybe_create_table($table_name, $create_ddl) {	global $wpdb;	if ( $wpdb->get_var("SHOW TABLES LIKE '$table_name'") == $table_name )		return true;	//didn't find it try to create it.	$q = $wpdb->query($create_ddl);	// we cannot directly tell that whether this succeeded!	if ( $wpdb->get_var("SHOW TABLES LIKE '$table_name'") == $table_name )		return true;	return false;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param string $table Database table name. * @param string $index Index name to drop. * @return bool True, when finished. */function drop_index($table, $index) {	global $wpdb;	$wpdb->hide_errors();	$wpdb->query("ALTER TABLE `$table` DROP INDEX `$index`");	// Now we need to take out all the extra ones we may have created	for ($i = 0; $i < 25; $i++) {		$wpdb->query("ALTER TABLE `$table` DROP INDEX `{$index}_$i`");	}	$wpdb->show_errors();	return true;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param string $table Database table name. * @param string $index Database table index column. * @return bool True, when done with execution. */function add_clean_index($table, $index) {	global $wpdb;	drop_index($table, $index);	$wpdb->query("ALTER TABLE `$table` ADD INDEX ( `$index` )");	return true;}/** ** maybe_add_column() ** Add column to db table if it doesn't exist. ** Returns:  true if already exists or on successful completion **           false on error */function maybe_add_column($table_name, $column_name, $create_ddl) {	global $wpdb, $debug;	foreach ($wpdb->get_col("DESC $table_name", 0) as $column ) {		if ($debug) echo("checking $column == $column_name<br />");		if ($column == $column_name) {			return true;		}	}	//didn't find it try to create it.	$q = $wpdb->query($create_ddl);	// we cannot directly tell that whether this succeeded!	foreach ($wpdb->get_col("DESC $table_name", 0) as $column ) {		if ($column == $column_name) {			return true;		}	}	return false;}/** * Retrieve all options as it was for 1.2. * * @since 1.2.0 * * @return array List of options. */function get_alloptions_110() {	global $wpdb;	if ($options = $wpdb->get_results("SELECT option_name, option_value FROM $wpdb->options")) {		foreach ($options as $option) {			// "When trying to design a foolproof system,			//  never underestimate the ingenuity of the fools :)" -- Dougal			if ('siteurl' == $option->option_name) $option->option_value = preg_replace('|/+$|', '', $option->option_value);			if ('home' == $option->option_name) $option->option_value = preg_replace('|/+$|', '', $option->option_value);			if ('category_base' == $option->option_name) $option->option_value = preg_replace('|/+$|', '', $option->option_value);			$all_options->{$option->option_name} = stripslashes($option->option_value);		}	}	return $all_options;}/** * Version of get_option that is private to install/upgrade. * * @since unknown * @access private * * @param string $setting Option name. * @return mixed */function __get_option($setting) {	global $wpdb;	if ( $setting == 'home' && defined( 'WP_HOME' ) ) {		return preg_replace( '|/+$|', '', WP_HOME );	}	if ( $setting == 'siteurl' && defined( 'WP_SITEURL' ) ) {		return preg_replace( '|/+$|', '', WP_SITEURL );	}	$option = $wpdb->get_var( $wpdb->prepare("SELECT option_value FROM $wpdb->options WHERE option_name = %s", $setting) );	if ( 'home' == $setting && '' == $option )		return __get_option('siteurl');	if ( 'siteurl' == $setting || 'home' == $setting || 'category_base' == $setting )		$option = preg_replace('|/+$|', '', $option);	@ $kellogs = unserialize($option);	if ($kellogs !== FALSE)		return $kellogs;	else		return $option;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param string $content * @return string */function deslash($content) {	// Note: \\\ inside a regex denotes a single backslash.	// Replace one or more backslashes followed by a single quote with	// a single quote.	$content = preg_replace("/\\\+'/", "'", $content);	// Replace one or more backslashes followed by a double quote with	// a double quote.	$content = preg_replace('/\\\+"/', '"', $content);	// Replace one or more backslashes with one backslash.	$content = preg_replace("/\\\+/", "\\", $content);	return $content;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param unknown_type $queries * @param unknown_type $execute * @return unknown */function dbDelta($queries, $execute = true) {	global $wpdb;	// Separate individual queries into an array	if ( !is_array($queries) ) {		$queries = explode( ';', $queries );		if ('' == $queries[count($queries) - 1]) array_pop($queries);	}	$cqueries = array(); // Creation Queries	$iqueries = array(); // Insertion Queries	$for_update = array();	// Create a tablename index for an array ($cqueries) of queries	foreach($queries as $qry) {		if (preg_match("|CREATE TABLE ([^ ]*)|", $qry, $matches)) {			$cqueries[trim( strtolower($matches[1]), '`' )] = $qry;			$for_update[$matches[1]] = 'Created table '.$matches[1];		} else if (preg_match("|CREATE DATABASE ([^ ]*)|", $qry, $matches)) {			array_unshift($cqueries, $qry);		} else if (preg_match("|INSERT INTO ([^ ]*)|", $qry, $matches)) {			$iqueries[] = $qry;		} else if (preg_match("|UPDATE ([^ ]*)|", $qry, $matches)) {			$iqueries[] = $qry;		} else {			// Unrecognized query type		}	}	// Check to see which tables and fields exist	if ($tables = $wpdb->get_col('SHOW TABLES;')) {		// For every table in the database		foreach ($tables as $table) {			// If a table query exists for the database table...			if ( array_key_exists(strtolower($table), $cqueries) ) {				// Clear the field and index arrays				$cfields = $indices = array();				// Get all of the field names in the query from between the parens				preg_match("|\((.*)\)|ms", $cqueries[strtolower($table)], $match2);				$qryline = trim($match2[1]);				// Separate field lines into an array				$flds = explode("\n", $qryline);				//echo "<hr/><pre>\n".print_r(strtolower($table), true).":\n".print_r($cqueries, true)."</pre><hr/>";				// For every field line specified in the query				foreach ($flds as $fld) {					// Extract the field name					preg_match("|^([^ ]*)|", trim($fld), $fvals);					$fieldname = trim( $fvals[1], '`' );					// Verify the found field name					$validfield = true;					switch (strtolower($fieldname)) {					case '':					case 'primary':					case 'index':					case 'fulltext':					case 'unique':					case 'key':						$validfield = false;						$indices[] = trim(trim($fld), ", \n");						break;					}					$fld = trim($fld);					// If it's a valid field, add it to the field array					if ($validfield) {						$cfields[strtolower($fieldname)] = trim($fld, ", \n");					}				}				// Fetch the table column structure from the database				$tablefields = $wpdb->get_results("DESCRIBE {$table};");				// For every field in the table				foreach ($tablefields as $tablefield) {					// If the table field exists in the field array...					if (array_key_exists(strtolower($tablefield->Field), $cfields)) {						// Get the field type from the query						preg_match("|".$tablefield->Field." ([^ ]*( unsigned)?)|i", $cfields[strtolower($tablefield->Field)], $matches);						$fieldtype = $matches[1];						// Is actual field type different from the field type in query?						if ($tablefield->Type != $fieldtype) {							// Add a query to change the column type							$cqueries[] = "ALTER TABLE {$table} CHANGE COLUMN {$tablefield->Field} " . $cfields[strtolower($tablefield->Field)];							$for_update[$table.'.'.$tablefield->Field] = "Changed type of {$table}.{$tablefield->Field} from {$tablefield->Type} to {$fieldtype}";						}						// Get the default value from the array							//echo "{$cfields[strtolower($tablefield->Field)]}<br>";						if (preg_match("| DEFAULT '(.*)'|i", $cfields[strtolower($tablefield->Field)], $matches)) {							$default_value = $matches[1];							if ($tablefield->Default != $default_value) {								// Add a query to change the column's default value								$cqueries[] = "ALTER TABLE {$table} ALTER COLUMN {$tablefield->Field} SET DEFAULT '{$default_value}'";								$for_update[$table.'.'.$tablefield->Field] = "Changed default value of {$table}.{$tablefield->Field} from {$tablefield->Default} to {$default_value}";							}						}						// Remove the field from the array (so it's not added)						unset($cfields[strtolower($tablefield->Field)]);					} else {						// This field exists in the table, but not in the creation queries?					}				}				// For every remaining field specified for the table				foreach ($cfields as $fieldname => $fielddef) {					// Push a query line into $cqueries that adds the field to that table					$cqueries[] = "ALTER TABLE {$table} ADD COLUMN $fielddef";					$for_update[$table.'.'.$fieldname] = 'Added column '.$table.'.'.$fieldname;				}				// Index stuff goes here				// Fetch the table index structure from the database				$tableindices = $wpdb->get_results("SHOW INDEX FROM {$table};");				if ($tableindices) {					// Clear the index array					unset($index_ary);					// For every index in the table					foreach ($tableindices as $tableindex) {						// Add the index to the index data array						$keyname = $tableindex->Key_name;						$index_ary[$keyname]['columns'][] = array('fieldname' => $tableindex->Column_name, 'subpart' => $tableindex->Sub_part);						$index_ary[$keyname]['unique'] = ($tableindex->Non_unique == 0)?true:false;					}					// For each actual index in the index array					foreach ($index_ary as $index_name => $index_data) {						// Build a create string to compare to the query						$index_string = '';						if ($index_name == 'PRIMARY') {							$index_string .= 'PRIMARY ';						} else if($index_data['unique']) {							$index_string .= 'UNIQUE ';						}						$index_string .= 'KEY ';						if ($index_name != 'PRIMARY') {							$index_string .= $index_name;						}						$index_columns = '';						// For each column in the index						foreach ($index_data['columns'] as $column_data) {							if ($index_columns != '') $index_columns .= ',';							// Add the field to the column list string							$index_columns .= $column_data['fieldname'];							if ($column_data['subpart'] != '') {								$index_columns .= '('.$column_data['subpart'].')';							}						}						// Add the column list to the index create string						$index_string .= ' ('.$index_columns.')';						if (!(($aindex = array_search($index_string, $indices)) === false)) {							unset($indices[$aindex]);							//echo "<pre style=\"border:1px solid #ccc;margin-top:5px;\">{$table}:<br />Found index:".$index_string."</pre>\n";						}						//else echo "<pre style=\"border:1px solid #ccc;margin-top:5px;\">{$table}:<br /><b>Did not find index:</b>".$index_string."<br />".print_r($indices, true)."</pre>\n";					}				}				// For every remaining index specified for the table				foreach ( (array) $indices as $index ) {					// Push a query line into $cqueries that adds the index to that table					$cqueries[] = "ALTER TABLE {$table} ADD $index";					$for_update[$table.'.'.$fieldname] = 'Added index '.$table.' '.$index;				}				// Remove the original table creation query from processing				unset($cqueries[strtolower($table)]);				unset($for_update[strtolower($table)]);			} else {				// This table exists in the database, but not in the creation queries?			}		}	}	$allqueries = array_merge($cqueries, $iqueries);	if ($execute) {		foreach ($allqueries as $query) {			//echo "<pre style=\"border:1px solid #ccc;margin-top:5px;\">".print_r($query, true)."</pre>\n";			$wpdb->query($query);		}	}	return $for_update;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown */function make_db_current() {	global $wp_queries;	$alterations = dbDelta($wp_queries);	echo "<ol>\n";	foreach($alterations as $alteration) echo "<li>$alteration</li>\n";	echo "</ol>\n";}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown */function make_db_current_silent() {	global $wp_queries;	$alterations = dbDelta($wp_queries);}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param unknown_type $theme_name * @param unknown_type $template * @return unknown */function make_site_theme_from_oldschool($theme_name, $template) {	$home_path = get_home_path();	$site_dir = WP_CONTENT_DIR . "/themes/$template";	if (! file_exists("$home_path/index.php"))		return false;	// Copy files from the old locations to the site theme.	// TODO: This does not copy arbitarary include dependencies.  Only the	// standard WP files are copied.	$files = array('index.php' => 'index.php', 'wp-layout.css' => 'style.css', 'wp-comments.php' => 'comments.php', 'wp-comments-popup.php' => 'comments-popup.php');	foreach ($files as $oldfile => $newfile) {		if ($oldfile == 'index.php')			$oldpath = $home_path;		else			$oldpath = ABSPATH;		if ($oldfile == 'index.php') { // Check to make sure it's not a new index			$index = implode('', file("$oldpath/$oldfile"));			if (strpos($index, 'WP_USE_THEMES') !== false) {				if (! @copy(WP_CONTENT_DIR . '/themes/' . WP_DEFAULT_THEME . '/index.php', "$site_dir/$newfile"))					return false;				continue; // Don't copy anything				}		}		if (! @copy("$oldpath/$oldfile", "$site_dir/$newfile"))			return false;		chmod("$site_dir/$newfile", 0777);		// Update the blog header include in each file.		$lines = explode("\n", implode('', file("$site_dir/$newfile")));		if ($lines) {			$f = fopen("$site_dir/$newfile", 'w');			foreach ($lines as $line) {				if (preg_match('/require.*wp-blog-header/', $line))					$line = '//' . $line;				// Update stylesheet references.				$line = str_replace("<?php echo __get_option('siteurl'); ?>/wp-layout.css", "<?php bloginfo('stylesheet_url'); ?>", $line);				// Update comments template inclusion.				$line = str_replace("<?php include(ABSPATH . 'wp-comments.php'); ?>", "<?php comments_template(); ?>", $line);				fwrite($f, "{$line}\n");			}			fclose($f);		}	}	// Add a theme header.	$header = "/*\nTheme Name: $theme_name\nTheme URI: " . __get_option('siteurl') . "\nDescription: A theme automatically created by the upgrade.\nVersion: 1.0\nAuthor: Moi\n*/\n";	$stylelines = file_get_contents("$site_dir/style.css");	if ($stylelines) {		$f = fopen("$site_dir/style.css", 'w');		fwrite($f, $header);		fwrite($f, $stylelines);		fclose($f);	}	return true;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param unknown_type $theme_name * @param unknown_type $template * @return unknown */function make_site_theme_from_default($theme_name, $template) {	$site_dir = WP_CONTENT_DIR . "/themes/$template";	$default_dir = WP_CONTENT_DIR . '/themes/' . WP_DEFAULT_THEME;	// Copy files from the default theme to the site theme.	//$files = array('index.php', 'comments.php', 'comments-popup.php', 'footer.php', 'header.php', 'sidebar.php', 'style.css');	$theme_dir = @ opendir($default_dir);	if ($theme_dir) {		while(($theme_file = readdir( $theme_dir )) !== false) {			if (is_dir("$default_dir/$theme_file"))				continue;			if (! @copy("$default_dir/$theme_file", "$site_dir/$theme_file"))				return;			chmod("$site_dir/$theme_file", 0777);		}	}	@closedir($theme_dir);	// Rewrite the theme header.	$stylelines = explode("\n", implode('', file("$site_dir/style.css")));	if ($stylelines) {		$f = fopen("$site_dir/style.css", 'w');		foreach ($stylelines as $line) {			if (strpos($line, 'Theme Name:') !== false) $line = 'Theme Name: ' . $theme_name;			elseif (strpos($line, 'Theme URI:') !== false) $line = 'Theme URI: ' . __get_option('url');			elseif (strpos($line, 'Description:') !== false) $line = 'Description: Your theme.';			elseif (strpos($line, 'Version:') !== false) $line = 'Version: 1';			elseif (strpos($line, 'Author:') !== false) $line = 'Author: You';			fwrite($f, $line . "\n");		}		fclose($f);	}	// Copy the images.	umask(0);	if (! mkdir("$site_dir/images", 0777)) {		return false;	}	$images_dir = @ opendir("$default_dir/images");	if ($images_dir) {		while(($image = readdir($images_dir)) !== false) {			if (is_dir("$default_dir/images/$image"))				continue;			if (! @copy("$default_dir/images/$image", "$site_dir/images/$image"))				return;			chmod("$site_dir/images/$image", 0777);		}	}	@closedir($images_dir);}// Create a site theme from the default theme./** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @return unknown */function make_site_theme() {	// Name the theme after the blog.	$theme_name = __get_option('blogname');	$template = sanitize_title($theme_name);	$site_dir = WP_CONTENT_DIR . "/themes/$template";	// If the theme already exists, nothing to do.	if ( is_dir($site_dir)) {		return false;	}	// We must be able to write to the themes dir.	if (! is_writable(WP_CONTENT_DIR . "/themes")) {		return false;	}	umask(0);	if (! mkdir($site_dir, 0777)) {		return false;	}	if (file_exists(ABSPATH . 'wp-layout.css')) {		if (! make_site_theme_from_oldschool($theme_name, $template)) {			// TODO:  rm -rf the site theme directory.			return false;		}	} else {		if (! make_site_theme_from_default($theme_name, $template))			// TODO:  rm -rf the site theme directory.			return false;	}	// Make the new site theme active.	$current_template = __get_option('template');	if ($current_template == WP_DEFAULT_THEME) {		update_option('template', $template);		update_option('stylesheet', $template);	}	return $template;}/** * Translate user level to user role name. * * @since unknown * * @param int $level User level. * @return string User role name. */function translate_level_to_role($level) {	switch ($level) {	case 10:	case 9:	case 8:		return 'administrator';	case 7:	case 6:	case 5:		return 'editor';	case 4:	case 3:	case 2:		return 'author';	case 1:		return 'contributor';	case 0:		return 'subscriber';	}}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown */function wp_check_mysql_version() {	global $wpdb;	$result = $wpdb->check_database_version();	if ( is_wp_error( $result ) )		die( $result->get_error_message() );}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown */function maybe_disable_automattic_widgets() {	$plugins = __get_option( 'active_plugins' );	foreach ( (array) $plugins as $plugin ) {		if ( basename( $plugin ) == 'widgets.php' ) {			array_splice( $plugins, array_search( $plugin, $plugins ), 1 );			update_option( 'active_plugins', $plugins );			break;		}	}}/** * Runs before the schema is upgraded. */function pre_schema_upgrade() {	global $wp_current_db_version, $wp_db_version, $wpdb;	// Upgrade versions prior to 2.9	if ( $wp_current_db_version < 11557 ) {		// Delete duplicate options.  Keep the option with the highest option_id.		$wpdb->query("DELETE o1 FROM $wpdb->options AS o1 JOIN $wpdb->options AS o2 USING (`option_name`) WHERE o2.option_id > o1.option_id");		// Drop the old primary key and add the new.		$wpdb->query("ALTER TABLE $wpdb->options DROP PRIMARY KEY, ADD PRIMARY KEY(option_id)");		// Drop the old option_name index. dbDelta() doesn't do the drop.		$wpdb->query("ALTER TABLE $wpdb->options DROP INDEX option_name");	}}/** * Install Network. * * @since 3.0.0 * */if ( !function_exists( 'install_network' ) ) :function install_network() {	global $wpdb, $charset_collate;	$ms_queries = "CREATE TABLE $wpdb->users (  ID bigint(20) unsigned NOT NULL auto_increment,  user_login varchar(60) NOT NULL default '',  user_pass varchar(64) NOT NULL default '',  user_nicename varchar(50) NOT NULL default '',  user_email varchar(100) NOT NULL default '',  user_url varchar(100) NOT NULL default '',  user_registered datetime NOT NULL default '0000-00-00 00:00:00',  user_activation_key varchar(60) NOT NULL default '',  user_status int(11) NOT NULL default '0',  display_name varchar(250) NOT NULL default '',  spam tinyint(2) NOT NULL default '0',  deleted tinyint(2) NOT NULL default '0',  PRIMARY KEY  (ID),  KEY user_login_key (user_login),  KEY user_nicename (user_nicename)) $charset_collate;CREATE TABLE $wpdb->blogs (  blog_id bigint(20) NOT NULL auto_increment,  site_id bigint(20) NOT NULL default '0',  domain varchar(200) NOT NULL default '',  path varchar(100) NOT NULL default '',  registered datetime NOT NULL default '0000-00-00 00:00:00',  last_updated datetime NOT NULL default '0000-00-00 00:00:00',  public tinyint(2) NOT NULL default '1',  archived enum('0','1') NOT NULL default '0',  mature tinyint(2) NOT NULL default '0',  spam tinyint(2) NOT NULL default '0',  deleted tinyint(2) NOT NULL default '0',  lang_id int(11) NOT NULL default '0',  PRIMARY KEY  (blog_id),  KEY domain (domain(50),path(5)),  KEY lang_id (lang_id)) $charset_collate;CREATE TABLE $wpdb->blog_versions (  blog_id bigint(20) NOT NULL default '0',  db_version varchar(20) NOT NULL default '',  last_updated datetime NOT NULL default '0000-00-00 00:00:00',  PRIMARY KEY  (blog_id),  KEY db_version (db_version)) $charset_collate;CREATE TABLE $wpdb->registration_log (  ID bigint(20) NOT NULL auto_increment,  email varchar(255) NOT NULL default '',  IP varchar(30) NOT NULL default '',  blog_id bigint(20) NOT NULL default '0',  date_registered datetime NOT NULL default '0000-00-00 00:00:00',  PRIMARY KEY  (ID),  KEY IP (IP)) $charset_collate;CREATE TABLE $wpdb->site (  id bigint(20) NOT NULL auto_increment,  domain varchar(200) NOT NULL default '',  path varchar(100) NOT NULL default '',  PRIMARY KEY  (id),  KEY domain (domain,path)) $charset_collate;CREATE TABLE $wpdb->sitemeta (  meta_id bigint(20) NOT NULL auto_increment,  site_id bigint(20) NOT NULL default '0',  meta_key varchar(255) default NULL,  meta_value longtext,  PRIMARY KEY  (meta_id),  KEY meta_key (meta_key),  KEY site_id (site_id)) $charset_collate;CREATE TABLE $wpdb->signups (  domain varchar(200) NOT NULL default '',  path varchar(100) NOT NULL default '',  title longtext NOT NULL,  user_login varchar(60) NOT NULL default '',  user_email varchar(100) NOT NULL default '',  registered datetime NOT NULL default '0000-00-00 00:00:00',  activated datetime NOT NULL default '0000-00-00 00:00:00',  active tinyint(1) NOT NULL default '0',  activation_key varchar(50) NOT NULL default '',  meta longtext,  KEY activation_key (activation_key),  KEY domain (domain)) $charset_collate;";// now create tables	dbDelta( $ms_queries );}endif;/** * Install global terms. * * @since 3.0.0 * */if ( !function_exists( 'install_global_terms' ) ) :function install_global_terms() {	global $wpdb, $charset_collate;	$ms_queries = "CREATE TABLE $wpdb->sitecategories (  cat_ID bigint(20) NOT NULL auto_increment,  cat_name varchar(55) NOT NULL default '',  category_nicename varchar(200) NOT NULL default '',  last_updated timestamp NOT NULL,  PRIMARY KEY  (cat_ID),  KEY category_nicename (category_nicename),  KEY last_updated (last_updated)) $charset_collate;";// now create tables	dbDelta( $ms_queries );}endif;?>
<?php/** * Edit user administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');wp_reset_vars(array('action', 'redirect', 'profile', 'user_id', 'wp_http_referer'));$user_id = (int) $user_id;$current_user = wp_get_current_user();if ( ! defined( 'IS_PROFILE_PAGE' ) )	define( 'IS_PROFILE_PAGE', ( $user_id == $current_user->ID ) );if ( ! $user_id && IS_PROFILE_PAGE )	$user_id = $current_user->ID;elseif ( ! $user_id && ! IS_PROFILE_PAGE )	wp_die(__( 'Invalid user ID.' ) );elseif ( ! get_userdata( $user_id ) )	wp_die( __('Invalid user ID.') );wp_enqueue_script('user-profile');wp_enqueue_script('password-strength-meter');$title = IS_PROFILE_PAGE ? __('Profile') : __('Edit User');if ( current_user_can('edit_users') && !IS_PROFILE_PAGE )	$submenu_file = 'users.php';else	$submenu_file = 'profile.php';$parent_file = 'users.php';// contextual help - choose Help on the top right of admin panel to preview this.add_contextual_help($current_screen,    '<p>' . __('Your profile contains information about you (your &#8220;account&#8221;) as well as some personal options related to using WordPress.') . '</p>' .    '<p>' . __('You can change your password, turn on keyboard shortcuts, change the color scheme of your WordPress administration screens, and turn off the WYSIWYG (Visual) editor, among other things.') . '</p>' .    '<p>' . __('Your username cannot be changed, but you can use other fields to enter your real name or a nickname, and change which name to display on your posts.') . '</p>' .    '<p>' . __('Required fields are indicated; the rest are optional. Profile information will only be displayed if your theme is set up to do so.') . '</p>' .    '<p>' . __('Remember to click the Update Profile button when you are finished.') . '</p>' .    '<p><strong>' . __('For more information:') . '</strong></p>' .    '<p>' . __('<a href="http://codex.wordpress.org/Users_Your_Profile_SubPanel" target="_blank">Documentation on User Profiles</a>') . '</p>' .    '<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');$wp_http_referer = remove_query_arg(array('update', 'delete_count'), stripslashes($wp_http_referer));$all_post_caps = array('posts', 'pages');$user_can_edit = false;foreach ( $all_post_caps as $post_cap )	$user_can_edit |= current_user_can("edit_$post_cap");/** * Optional SSL preference that can be turned on by hooking to the 'personal_options' action. * * @since 2.7.0 * * @param object $user User data object */function use_ssl_preference($user) {?>	<tr>		<th scope="row"><?php _e('Use https')?></th>		<td><label for="use_ssl"><input name="use_ssl" type="checkbox" id="use_ssl" value="1" <?php checked('1', $user->use_ssl); ?> /> <?php _e('Always use https when visiting the admin'); ?></label></td>	</tr><?php}// Only allow super admins on multisite to edit every user.if ( is_multisite() && ! current_user_can( 'manage_network_users' ) && $user_id != $current_user->ID && ! apply_filters( 'enable_edit_any_user_configuration', true ) )	wp_die( __( 'You do not have permission to edit this user.' ) );// Execute confirmed email change. See send_confirmation_on_profile_email().if ( is_multisite() && IS_PROFILE_PAGE && isset( $_GET[ 'newuseremail' ] ) && $current_user->ID ) {	$new_email = get_option( $current_user->ID . '_new_email' );	if ( $new_email[ 'hash' ] == $_GET[ 'newuseremail' ] ) {		$user->ID = $current_user->ID;		$user->user_email = esc_html( trim( $new_email[ 'newemail' ] ) );		if ( $wpdb->get_var( $wpdb->prepare( "SELECT user_login FROM {$wpdb->signups} WHERE user_login = %s", $current_user->user_login ) ) )			$wpdb->query( $wpdb->prepare( "UPDATE {$wpdb->signups} SET user_email = %s WHERE user_login = %s", $user->user_email, $current_user->user_login ) );		wp_update_user( get_object_vars( $user ) );		delete_option( $current_user->ID . '_new_email' );		wp_redirect( add_query_arg( array('updated' => 'true'), admin_url( 'profile.php' ) ) );		die();	}} elseif ( is_multisite() && IS_PROFILE_PAGE && !empty( $_GET['dismiss'] ) && $current_user->ID . '_new_email' == $_GET['dismiss'] ) {	delete_option( $current_user->ID . '_new_email' );	wp_redirect( add_query_arg( array('updated' => 'true'), admin_url( 'profile.php' ) ) );	die();}switch ($action) {case 'switchposts':check_admin_referer();/* TODO: Switch all posts from one user to another user */break;case 'update':check_admin_referer('update-user_' . $user_id);if ( !current_user_can('edit_user', $user_id) )	wp_die(__('You do not have permission to edit this user.'));if ( IS_PROFILE_PAGE )	do_action('personal_options_update', $user_id);else	do_action('edit_user_profile_update', $user_id);if ( !is_multisite() ) {	$errors = edit_user($user_id);} else {	$user = get_userdata( $user_id );	// Update the email address in signups, if present.	if ( $user->user_login && isset( $_POST[ 'email' ] ) && is_email( $_POST[ 'email' ] ) && $wpdb->get_var( $wpdb->prepare( "SELECT user_login FROM {$wpdb->signups} WHERE user_login = %s", $user->user_login ) ) )		$wpdb->query( $wpdb->prepare( "UPDATE {$wpdb->signups} SET user_email = %s WHERE user_login = %s", $_POST[ 'email' ], $user_login ) );	// WPMU must delete the user from the current blog if WP added him after editing.	$delete_role = false;	$blog_prefix = $wpdb->get_blog_prefix();	if ( $user_id != $current_user->ID ) {		$cap = $wpdb->get_var( "SELECT meta_value FROM {$wpdb->usermeta} WHERE user_id = '{$user_id}' AND meta_key = '{$blog_prefix}capabilities' AND meta_value = 'a:0:{}'" );		if ( null == $cap && $_POST[ 'role' ] == '' ) {			$_POST[ 'role' ] = 'contributor';			$delete_role = true;		}	}	if ( !isset( $errors ) || ( isset( $errors ) && is_object( $errors ) && false == $errors->get_error_codes() ) )		$errors = edit_user($user_id);	if ( $delete_role ) // stops users being added to current blog when they are edited		delete_user_meta( $user_id, $blog_prefix . 'capabilities' );	if ( is_multisite() && !IS_PROFILE_PAGE && current_user_can( 'manage_network_options' ) && !isset($super_admins) && empty( $_POST['super_admin'] ) == is_super_admin( $user_id ) )		empty( $_POST['super_admin'] ) ? revoke_super_admin( $user_id ) : grant_super_admin( $user_id );}if ( !is_wp_error( $errors ) ) {	$redirect = (IS_PROFILE_PAGE ? "profile.php?" : "user-edit.php?user_id=$user_id&"). "updated=true";	$redirect = add_query_arg('wp_http_referer', urlencode($wp_http_referer), $redirect);	wp_redirect($redirect);	exit;}default:$profileuser = get_user_to_edit($user_id);if ( !current_user_can('edit_user', $user_id) )	wp_die(__('You do not have permission to edit this user.'));include ('admin-header.php');?><?php if ( !IS_PROFILE_PAGE && is_super_admin( $profileuser->ID ) && current_user_can( 'manage_network_options' ) ) { ?>	<div class="updated"><p><strong><?php _e('Important:'); ?></strong> <?php _e('This user has super admin privileges.'); ?></p></div><?php } ?><?php if ( isset($_GET['updated']) ) : ?><div id="message" class="updated">	<p><strong><?php _e('User updated.') ?></strong></p>	<?php if ( $wp_http_referer && !IS_PROFILE_PAGE ) : ?>	<p><a href="users.php"><?php _e('&larr; Back to Authors and Users'); ?></a></p>	<?php endif; ?></div><?php endif; ?><?php if ( isset( $errors ) && is_wp_error( $errors ) ) : ?><div class="error"><p><?php echo implode( "</p>\n<p>", $errors->get_error_messages() ); ?></p></div><?php endif; ?><div class="wrap" id="profile-page"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><form id="your-profile" action="<?php echo esc_url( admin_url( IS_PROFILE_PAGE ? 'profile.php' : 'user-edit.php' ) ); ?>" method="post"<?php do_action('user_edit_form_tag'); ?>><?php wp_nonce_field('update-user_' . $user_id) ?><?php if ( $wp_http_referer ) : ?>	<input type="hidden" name="wp_http_referer" value="<?php echo esc_url($wp_http_referer); ?>" /><?php endif; ?><p><input type="hidden" name="from" value="profile" /><input type="hidden" name="checkuser_id" value="<?php echo $user_ID ?>" /></p><h3><?php _e('Personal Options'); ?></h3><table class="form-table"><?php if ( rich_edit_exists() && !( IS_PROFILE_PAGE && !$user_can_edit ) ) : // don't bother showing the option if the editor has been removed ?>	<tr>		<th scope="row"><?php _e('Visual Editor')?></th>		<td><label for="rich_editing"><input name="rich_editing" type="checkbox" id="rich_editing" value="false" <?php checked('false', $profileuser->rich_editing); ?> /> <?php _e('Disable the visual editor when writing'); ?></label></td>	</tr><?php endif; ?><?php if ( count($_wp_admin_css_colors) > 1 && has_action('admin_color_scheme_picker') ) : ?><tr><th scope="row"><?php _e('Admin Color Scheme')?></th><td><?php do_action( 'admin_color_scheme_picker' ); ?></td></tr><?phpendif; // $_wp_admin_css_colorsif ( !( IS_PROFILE_PAGE && !$user_can_edit ) ) : ?><tr><th scope="row"><?php _e( 'Keyboard Shortcuts' ); ?></th><td><label for="comment_shortcuts"><input type="checkbox" name="comment_shortcuts" id="comment_shortcuts" value="true" <?php if ( !empty($profileuser->comment_shortcuts) ) checked('true', $profileuser->comment_shortcuts); ?> /> <?php _e('Enable keyboard shortcuts for comment moderation.'); ?></label> <?php _e('<a href="http://codex.wordpress.org/Keyboard_Shortcuts">More information</a>'); ?></td></tr><?phpendif;do_action('personal_options', $profileuser);?></table><?php	if ( IS_PROFILE_PAGE )		do_action('profile_personal_options', $profileuser);?><h3><?php _e('Name') ?></h3><table class="form-table">	<tr>		<th><label for="user_login"><?php _e('Username'); ?></label></th>		<td><input type="text" name="user_login" id="user_login" value="<?php echo esc_attr($profileuser->user_login); ?>" disabled="disabled" class="regular-text" /> <span class="description"><?php _e('Usernames cannot be changed.'); ?></span></td>	</tr><?php if ( !IS_PROFILE_PAGE ): ?><tr><th><label for="role"><?php _e('Role:') ?></label></th><td><select name="role" id="role"><?php// Get the highest/primary role for this user// TODO: create a function that does this: wp_get_user_role()$user_roles = $profileuser->roles;$user_role = array_shift($user_roles);// print the full list of roles with the primary one selected.wp_dropdown_roles($user_role);// print the 'no role' option. Make it selected if the user has no role yet.if ( $user_role )	echo '<option value="">' . __('&mdash; No role for this site &mdash;') . '</option>';else	echo '<option value="" selected="selected">' . __('&mdash; No role for this site &mdash;') . '</option>';?></select><?php if ( is_multisite() && current_user_can( 'manage_network_options' ) && !isset($super_admins) ) { ?><p><label><input type="checkbox" id="super_admin" name="super_admin"<?php checked( is_super_admin( $profileuser->ID ) ); ?> /> <?php _e( 'Grant this user super admin privileges for the Network.'); ?></label></p><?php } ?></td></tr><?php endif; //!IS_PROFILE_PAGE ?><tr>	<th><label for="first_name"><?php _e('First Name') ?></label></th>	<td><input type="text" name="first_name" id="first_name" value="<?php echo esc_attr($profileuser->first_name) ?>" class="regular-text" /></td></tr><tr>	<th><label for="last_name"><?php _e('Last Name') ?></label></th>	<td><input type="text" name="last_name" id="last_name" value="<?php echo esc_attr($profileuser->last_name) ?>" class="regular-text" /></td></tr><tr>	<th><label for="nickname"><?php _e('Nickname'); ?> <span class="description"><?php _e('(required)'); ?></span></label></th>	<td><input type="text" name="nickname" id="nickname" value="<?php echo esc_attr($profileuser->nickname) ?>" class="regular-text" /></td></tr><tr>	<th><label for="display_name"><?php _e('Display name publicly as') ?></label></th>	<td>		<select name="display_name" id="display_name">		<?php			$public_display = array();			$public_display['display_username']  = $profileuser->user_login;			$public_display['display_nickname']  = $profileuser->nickname;			if ( !empty($profileuser->first_name) )				$public_display['display_firstname'] = $profileuser->first_name;			if ( !empty($profileuser->last_name) )				$public_display['display_lastname'] = $profileuser->last_name;			if ( !empty($profileuser->first_name) && !empty($profileuser->last_name) ) {				$public_display['display_firstlast'] = $profileuser->first_name . ' ' . $profileuser->last_name;				$public_display['display_lastfirst'] = $profileuser->last_name . ' ' . $profileuser->first_name;			}			if ( !in_array( $profileuser->display_name, $public_display ) ) // Only add this if it isn't duplicated elsewhere				$public_display = array( 'display_displayname' => $profileuser->display_name ) + $public_display;			$public_display = array_map( 'trim', $public_display );			$public_display = array_unique( $public_display );			foreach ( $public_display as $id => $item ) {		?>			<option id="<?php echo $id; ?>" value="<?php echo esc_attr($item); ?>"<?php selected( $profileuser->display_name, $item ); ?>><?php echo $item; ?></option>		<?php			}		?>		</select>	</td></tr></table><h3><?php _e('Contact Info') ?></h3><table class="form-table"><tr>	<th><label for="email"><?php _e('E-mail'); ?> <span class="description"><?php _e('(required)'); ?></span></label></th>	<td><input type="text" name="email" id="email" value="<?php echo esc_attr($profileuser->user_email) ?>" class="regular-text" />	<?php	$new_email = get_option( $current_user->ID . '_new_email' );	if ( $new_email && $new_email != $current_user->user_email ) : ?>	<div class="updated inline">	<p><?php printf( __('There is a pending change of your e-mail to <code>%1$s</code>. <a href="%2$s">Cancel</a>'), $new_email['newemail'], esc_url( admin_url( 'profile.php?dismiss=' . $current_user->ID . '_new_email' ) ) ); ?></p>	</div>	<?php endif; ?>	</td></tr><tr>	<th><label for="url"><?php _e('Website') ?></label></th>	<td><input type="text" name="url" id="url" value="<?php echo esc_attr($profileuser->user_url) ?>" class="regular-text code" /></td></tr><?php	foreach (_wp_get_user_contactmethods() as $name => $desc) {?><tr>	<th><label for="<?php echo $name; ?>"><?php echo apply_filters('user_'.$name.'_label', $desc); ?></label></th>	<td><input type="text" name="<?php echo $name; ?>" id="<?php echo $name; ?>" value="<?php echo esc_attr($profileuser->$name) ?>" class="regular-text" /></td></tr><?php	}?></table><h3><?php IS_PROFILE_PAGE ? _e('About Yourself') : _e('About the user'); ?></h3><table class="form-table"><tr>	<th><label for="description"><?php _e('Biographical Info'); ?></label></th>	<td><textarea name="description" id="description" rows="5" cols="30"><?php echo esc_html($profileuser->description); ?></textarea><br />	<span class="description"><?php _e('Share a little biographical information to fill out your profile. This may be shown publicly.'); ?></span></td></tr><?php$show_password_fields = apply_filters('show_password_fields', true, $profileuser);if ( $show_password_fields ) :?><tr id="password">	<th><label for="pass1"><?php _e('New Password'); ?></label></th>	<td><input type="password" name="pass1" id="pass1" size="16" value="" autocomplete="off" /> <span class="description"><?php _e("If you would like to change the password type a new one. Otherwise leave this blank."); ?></span><br />		<input type="password" name="pass2" id="pass2" size="16" value="" autocomplete="off" /> <span class="description"><?php _e("Type your new password again."); ?></span><br />		<div id="pass-strength-result"><?php _e('Strength indicator'); ?></div>		<p class="description indicator-hint"><?php _e('Hint: The password should be at least seven characters long. To make it stronger, use upper and lower case letters, numbers and symbols like ! " ? $ % ^ &amp; ).'); ?></p>	</td></tr><?php endif; ?></table><?php	if ( IS_PROFILE_PAGE )		do_action( 'show_user_profile', $profileuser );	else		do_action( 'edit_user_profile', $profileuser );?><?php if ( count($profileuser->caps) > count($profileuser->roles) && apply_filters('additional_capabilities_display', true, $profileuser) ) { ?><br class="clear" />	<table width="99%" style="border: none;" cellspacing="2" cellpadding="3" class="editform">		<tr>			<th scope="row"><?php _e('Additional Capabilities') ?></th>			<td><?php			$output = '';			foreach ( $profileuser->caps as $cap => $value ) {				if ( !$wp_roles->is_role($cap) ) {					if ( $output != '' )						$output .= ', ';					$output .= $value ? $cap : "Denied: {$cap}";				}			}			echo $output;			?></td>		</tr>	</table><?php } ?><p class="submit">	<input type="hidden" name="action" value="update" />	<input type="hidden" name="user_id" id="user_id" value="<?php echo esc_attr($user_id); ?>" />	<input type="submit" class="button-primary" value="<?php IS_PROFILE_PAGE ? esc_attr_e('Update Profile') : esc_attr_e('Update User') ?>" name="submit" /></p></form></div><?phpbreak;}?><script type="text/javascript" charset="utf-8">	if (window.location.hash == '#password') {		document.getElementById('pass1').focus();	}</script><?phpinclude('./admin-footer.php');?>
<?php/** * Edit Posts Administration Panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( !isset($_GET['post_type']) )	$post_type = 'post';elseif ( in_array( $_GET['post_type'], get_post_types( array('show_ui' => true ) ) ) )	$post_type = $_GET['post_type'];else	wp_die( __('Invalid post type') );$_GET['post_type'] = $post_type;$post_type_object = get_post_type_object($post_type);if ( !current_user_can($post_type_object->cap->edit_posts) )	wp_die(__('Cheatin&#8217; uh?'));// Back-compat for viewing comments of an entryif ( $_redirect = intval( max( @$_GET['p'], @$_GET['attachment_id'], @$_GET['page_id'] ) ) ) {	wp_redirect( admin_url('edit-comments.php?p=' . $_redirect ) );	exit;} else {	unset( $_redirect );}if ( 'post' != $post_type ) {	$parent_file = "edit.php?post_type=$post_type";	$submenu_file = "edit.php?post_type=$post_type";	$post_new_file = "post-new.php?post_type=$post_type";} else {	$parent_file = 'edit.php';	$submenu_file = 'edit.php';	$post_new_file = 'post-new.php';}$pagenum = isset( $_GET['paged'] ) ? absint( $_GET['paged'] ) : 0;if ( empty($pagenum) )	$pagenum = 1;$per_page = 'edit_' . $post_type . '_per_page';$per_page = (int) get_user_option( $per_page );if ( empty( $per_page ) || $per_page < 1 )	$per_page = 20;// @todo filter based on type$per_page = apply_filters( 'edit_posts_per_page', $per_page );// Handle bulk actionsif ( isset($_GET['doaction']) || isset($_GET['doaction2']) || isset($_GET['delete_all']) || isset($_GET['delete_all2']) || isset($_GET['bulk_edit']) ) {	check_admin_referer('bulk-posts');	$sendback = remove_query_arg( array('trashed', 'untrashed', 'deleted', 'ids'), wp_get_referer() );	if ( strpos($sendback, 'post.php') !== false )		$sendback = admin_url($post_new_file);	if ( isset($_GET['delete_all']) || isset($_GET['delete_all2']) ) {		$post_status = preg_replace('/[^a-z0-9_-]+/i', '', $_GET['post_status']);		$post_ids = $wpdb->get_col( $wpdb->prepare( "SELECT ID FROM $wpdb->posts WHERE post_type=%s AND post_status = %s", $post_type, $post_status ) );		$doaction = 'delete';	} elseif ( ( $_GET['action'] != -1 || $_GET['action2'] != -1 ) && ( isset($_GET['post']) || isset($_GET['ids']) ) ) {		$post_ids = isset($_GET['post']) ? array_map( 'intval', (array) $_GET['post'] ) : explode(',', $_GET['ids']);		$doaction = ($_GET['action'] != -1) ? $_GET['action'] : $_GET['action2'];	} else {		wp_redirect( admin_url("edit.php?post_type=$post_type") );	}	switch ( $doaction ) {		case 'trash':			$trashed = 0;			foreach( (array) $post_ids as $post_id ) {				if ( !current_user_can($post_type_object->cap->delete_post, $post_id) )					wp_die( __('You are not allowed to move this item to the Trash.') );				if ( !wp_trash_post($post_id) )					wp_die( __('Error in moving to Trash.') );				$trashed++;			}			$sendback = add_query_arg( array('trashed' => $trashed, 'ids' => join(',', $post_ids)), $sendback );			break;		case 'untrash':			$untrashed = 0;			foreach( (array) $post_ids as $post_id ) {				if ( !current_user_can($post_type_object->cap->delete_post, $post_id) )					wp_die( __('You are not allowed to restore this item from the Trash.') );				if ( !wp_untrash_post($post_id) )					wp_die( __('Error in restoring from Trash.') );				$untrashed++;			}			$sendback = add_query_arg('untrashed', $untrashed, $sendback);			break;		case 'delete':			$deleted = 0;			foreach( (array) $post_ids as $post_id ) {				$post_del = & get_post($post_id);				if ( !current_user_can($post_type_object->cap->delete_post, $post_id) )					wp_die( __('You are not allowed to delete this item.') );				if ( $post_del->post_type == 'attachment' ) {					if ( ! wp_delete_attachment($post_id) )						wp_die( __('Error in deleting...') );				} else {					if ( !wp_delete_post($post_id) )						wp_die( __('Error in deleting...') );				}				$deleted++;			}			$sendback = add_query_arg('deleted', $deleted, $sendback);			break;		case 'edit':			$done = bulk_edit_posts($_GET);			if ( is_array($done) ) {				$done['updated'] = count( $done['updated'] );				$done['skipped'] = count( $done['skipped'] );				$done['locked'] = count( $done['locked'] );				$sendback = add_query_arg( $done, $sendback );			}			break;	}	if ( isset($_GET['action']) )		$sendback = remove_query_arg( array('action', 'action2', 'tags_input', 'post_author', 'comment_status', 'ping_status', '_status',  'post', 'bulk_edit', 'post_view'), $sendback );	wp_redirect($sendback);	exit();} elseif ( ! empty($_GET['_wp_http_referer']) ) {	 wp_redirect( remove_query_arg( array('_wp_http_referer', '_wpnonce'), stripslashes($_SERVER['REQUEST_URI']) ) );	 exit;}wp_enqueue_script('inline-edit-post');$user_posts = false;if ( !current_user_can($post_type_object->cap->edit_others_posts) ) {	$user_posts_count = $wpdb->get_var( $wpdb->prepare("SELECT COUNT(1) FROM $wpdb->posts WHERE post_type = '%s' AND post_status NOT IN ('trash', 'auto-draft') AND post_author = %d", $post_type, $current_user->ID) );	$user_posts = true;	if ( $user_posts_count && empty($_GET['post_status']) && empty($_GET['all_posts']) && empty($_GET['author']) )		$_GET['author'] = $current_user->ID;}$avail_post_stati = wp_edit_posts_query();if ( $post_type_object->hierarchical )	$num_pages = ceil($wp_query->post_count / $per_page);else	$num_pages = $wp_query->max_num_pages;$title = $post_type_object->labels->name;if ( 'post' == $post_type ) {	add_contextual_help($current_screen,	'<p>' . __('You can customize the display of this screen in a number of ways:') . '</p>' .	'<ul>' .	'<li>' . __('You can hide/display columns based on your needs and decide how many posts to list per screen using the Screen Options tab.') . '</li>' .	'<li>' . __('You can filter the list of posts by post status using the text links in the upper left to show All, Published, Draft, or Trashed posts. The default view is to show all posts.') . '</li>' .	'<li>' . __('You can view posts in a simple title list or with an excerpt. Choose the view you prefer by clicking on the icons at the top of the list on the right.') . '</li>' .	'<li>' . __('You can refine the list to show only posts in a specific category or from a specific month by using the dropdown menus above the posts list. Click the Filter button after making your selection. You also can refine the list by clicking on the post author, category or tag in the posts list.') . '</li>' .	'</ul>' .	'<p>' . __('Hovering over a row in the posts list will display action links that allow you to manage your post. You can perform the following actions:') . '</p>' .	'<ul>' .	'<li>' . __('Edit takes you to the editing screen for that post. You can also reach that screen by clicking on the post title.') . '</li>' .	'<li>' . __('Quick Edit provides inline access to the metadata of your post, allowing you to update post details without leaving this screen.') . '</li>' .	'<li>' . __('Trash removes your post from this list and places it in the trash, from which you can permanently delete it.') . '</li>' .	'<li>' . __('Preview will show you what your draft post will look like if you publish it. View will take you to your live site to view the post. Which link is available depends on your post&#8217;s status.') . '</li>' .	'</ul>' .	'<p>' . __('You can also edit multiple posts at once. Select the posts you want to edit using the checkboxes, select Edit from the Bulk Actions menu and click Apply. You will be able to change the metadata (categories, author, etc.) for all selected posts at once. To remove a post from the grouping, just click the x next to its name in the Bulk Edit area that appears.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Posts_Edit_SubPanel" target="_blank">Edit Posts Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>'	);} elseif ( 'page' == $post_type ) {	add_contextual_help($current_screen,	'<p>' . __('Pages are similar to to Posts in that they have a title, body text, and associated metadata, but they are different in that they are not part of the chronological blog stream, kind of like permanent posts. Pages are not categorized or tagged, but can have a hierarchy. You can nest Pages under other Pages by making one the &#8220;Parent&#8221; of the other, creating a group of Pages.') . '</p>' .	'<p>' . __('Managing Pages is very similar to managing Posts, and the screens can be customized in the same way.') . '</p>' .	'<p>' . __('You can also perform the same types of actions, including narrowing the list by using the filters, acting on a Page using the action links that appear when you hover over a row, or using the Bulk Actions menu to edit the metadata for multiple Pages at once.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Pages_Edit_SubPanel" target="_blank">Page Management Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>'	);}require_once('./admin-header.php');if ( empty($_GET['mode']) )	$mode = 'list';else	$mode = esc_attr($_GET['mode']); ?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $post_type_object->labels->name ); ?> <a href="<?php echo $post_new_file ?>" class="button add-new-h2"><?php echo esc_html($post_type_object->labels->add_new); ?></a> <?phpif ( isset($_GET['s']) && $_GET['s'] )	printf( '<span class="subtitle">' . __('Search results for &#8220;%s&#8221;') . '</span>', get_search_query() ); ?></h2><?phpif ( isset($_GET['posted']) && $_GET['posted'] ) : $_GET['posted'] = (int) $_GET['posted']; ?><div id="message" class="updated"><p><strong><?php _e('This has been saved.'); ?></strong> <a href="<?php echo get_permalink( $_GET['posted'] ); ?>"><?php _e('View Post'); ?></a> | <a href="<?php echo get_edit_post_link( $_GET['posted'] ); ?>"><?php _e('Edit Post'); ?></a></p></div><?php $_SERVER['REQUEST_URI'] = remove_query_arg(array('posted'), $_SERVER['REQUEST_URI']);endif; ?><?php if ( isset($_GET['locked']) || isset($_GET['skipped']) || isset($_GET['updated']) || isset($_GET['deleted']) || isset($_GET['trashed']) || isset($_GET['untrashed']) ) { ?><div id="message" class="updated"><p><?php if ( isset($_GET['updated']) && (int) $_GET['updated'] ) {	printf( _n( '%s post updated.', '%s posts updated.', $_GET['updated'] ), number_format_i18n( $_GET['updated'] ) );	unset($_GET['updated']);}if ( isset($_GET['skipped']) && (int) $_GET['skipped'] )	unset($_GET['skipped']);if ( isset($_GET['locked']) && (int) $_GET['locked'] ) {	printf( _n( '%s item not updated, somebody is editing it.', '%s items not updated, somebody is editing them.', $_GET['locked'] ), number_format_i18n( $_GET['locked'] ) );	unset($_GET['locked']);}if ( isset($_GET['deleted']) && (int) $_GET['deleted'] ) {	printf( _n( 'Item permanently deleted.', '%s items permanently deleted.', $_GET['deleted'] ), number_format_i18n( $_GET['deleted'] ) );	unset($_GET['deleted']);}if ( isset($_GET['trashed']) && (int) $_GET['trashed'] ) {	printf( _n( 'Item moved to the trash.', '%s items moved to the trash.', $_GET['trashed'] ), number_format_i18n( $_GET['trashed'] ) );	$ids = isset($_GET['ids']) ? $_GET['ids'] : 0;	echo ' <a href="' . esc_url( wp_nonce_url( "edit.php?post_type=$post_type&doaction=undo&action=untrash&ids=$ids", "bulk-posts" ) ) . '">' . __('Undo') . '</a><br />';	unset($_GET['trashed']);}if ( isset($_GET['untrashed']) && (int) $_GET['untrashed'] ) {	printf( _n( 'Item restored from the Trash.', '%s items restored from the Trash.', $_GET['untrashed'] ), number_format_i18n( $_GET['untrashed'] ) );	unset($_GET['undeleted']);}$_SERVER['REQUEST_URI'] = remove_query_arg( array('locked', 'skipped', 'updated', 'deleted', 'trashed', 'untrashed'), $_SERVER['REQUEST_URI'] );?></p></div><?php } ?><form id="posts-filter" action="<?php echo admin_url('edit.php'); ?>" method="get"><ul class="subsubsub"><?phpif ( empty($locked_post_status) ) :$status_links = array();$num_posts = wp_count_posts( $post_type, 'readable' );$class = '';$allposts = '';if ( $user_posts ) {	if ( isset( $_GET['author'] ) && ( $_GET['author'] == $current_user->ID ) )		$class = ' class="current"';	$status_links[] = "<li><a href='edit.php?post_type=$post_type&author=$current_user->ID'$class>" . sprintf( _nx( 'Mine <span class="count">(%s)</span>', 'Mine <span class="count">(%s)</span>', $user_posts_count, 'posts' ), number_format_i18n( $user_posts_count ) ) . '</a>';	$allposts = '&all_posts=1';}$total_posts = array_sum( (array) $num_posts );// Subtract post types that are not included in the admin all list.foreach ( get_post_stati( array('show_in_admin_all_list' => false) ) as $state )	$total_posts -= $num_posts->$state;$class = empty($class) && empty($_GET['post_status']) ? ' class="current"' : '';$status_links[] = "<li><a href='edit.php?post_type=$post_type{$allposts}'$class>" . sprintf( _nx( 'All <span class="count">(%s)</span>', 'All <span class="count">(%s)</span>', $total_posts, 'posts' ), number_format_i18n( $total_posts ) ) . '</a>';foreach ( get_post_stati(array('show_in_admin_status_list' => true), 'objects') as $status ) {	$class = '';	$status_name = $status->name;	if ( !in_array( $status_name, $avail_post_stati ) )		continue;	if ( empty( $num_posts->$status_name ) )		continue;	if ( isset($_GET['post_status']) && $status_name == $_GET['post_status'] )		$class = ' class="current"';	$status_links[] = "<li><a href='edit.php?post_status=$status_name&amp;post_type=$post_type'$class>" . sprintf( _n( $status->label_count[0], $status->label_count[1], $num_posts->$status_name ), number_format_i18n( $num_posts->$status_name ) ) . '</a>';}echo implode( " |</li>\n", $status_links ) . '</li>';unset( $status_links );endif;?></ul><p class="search-box">	<label class="screen-reader-text" for="post-search-input"><?php echo $post_type_object->labels->search_items; ?>:</label>	<input type="text" id="post-search-input" name="s" value="<?php the_search_query(); ?>" />	<input type="submit" value="<?php echo esc_attr( $post_type_object->labels->search_items  ); ?>" class="button" /></p><input type="hidden" name="post_status" class="post_status_page" value="<?php echo !empty($_GET['post_status']) ? esc_attr($_GET['post_status']) : 'all'; ?>" /><input type="hidden" name="post_type" class="post_type_page" value="<?php echo $post_type; ?>" /><input type="hidden" name="mode" value="<?php echo esc_attr($mode); ?>" /><?php if ( have_posts() ) { ?><div class="tablenav"><?php$page_links = paginate_links( array(	'base' => add_query_arg( 'paged', '%#%' ),	'format' => '',	'prev_text' => __('&laquo;'),	'next_text' => __('&raquo;'),	'total' => $num_pages,	'current' => $pagenum));$is_trash = isset($_GET['post_status']) && $_GET['post_status'] == 'trash';?><div class="alignleft actions"><select name="action"><option value="-1" selected="selected"><?php _e('Bulk Actions'); ?></option><?php if ( $is_trash ) { ?><option value="untrash"><?php _e('Restore'); ?></option><?php } else { ?><option value="edit"><?php _e('Edit'); ?></option><?php } if ( $is_trash || !EMPTY_TRASH_DAYS ) { ?><option value="delete"><?php _e('Delete Permanently'); ?></option><?php } else { ?><option value="trash"><?php _e('Move to Trash'); ?></option><?php } ?></select><input type="submit" value="<?php esc_attr_e('Apply'); ?>" name="doaction" id="doaction" class="button-secondary action" /><?php wp_nonce_field('bulk-posts'); ?><?php // view filtersif ( !is_singular() ) {$arc_query = $wpdb->prepare("SELECT DISTINCT YEAR(post_date) AS yyear, MONTH(post_date) AS mmonth FROM $wpdb->posts WHERE post_type = %s ORDER BY post_date DESC", $post_type);$arc_result = $wpdb->get_results( $arc_query );$month_count = count($arc_result);if ( $month_count && !( 1 == $month_count && 0 == $arc_result[0]->mmonth ) ) {$m = isset($_GET['m']) ? (int)$_GET['m'] : 0;?><select name='m'><option<?php selected( $m, 0 ); ?> value='0'><?php _e('Show all dates'); ?></option><?phpforeach ($arc_result as $arc_row) {	if ( $arc_row->yyear == 0 )		continue;	$arc_row->mmonth = zeroise( $arc_row->mmonth, 2 );	if ( $arc_row->yyear . $arc_row->mmonth == $m )		$default = ' selected="selected"';	else		$default = '';	echo "<option$default value='" . esc_attr("$arc_row->yyear$arc_row->mmonth") . "'>";	echo $wp_locale->get_month($arc_row->mmonth) . " $arc_row->yyear";	echo "</option>\n";}?></select><?php } ?><?phpif ( is_object_in_taxonomy($post_type, 'category') ) {	$dropdown_options = array('show_option_all' => __('View all categories'), 'hide_empty' => 0, 'hierarchical' => 1,		'show_count' => 0, 'orderby' => 'name', 'selected' => $cat);	wp_dropdown_categories($dropdown_options);}do_action('restrict_manage_posts');?><input type="submit" id="post-query-submit" value="<?php esc_attr_e('Filter'); ?>" class="button-secondary" /><?php }if ( $is_trash && current_user_can($post_type_object->cap->edit_others_posts) ) { ?><input type="submit" name="delete_all" id="delete_all" value="<?php esc_attr_e('Empty Trash'); ?>" class="button-secondary apply" /><?php } ?></div><?php if ( $page_links ) { ?><div class="tablenav-pages"><?php	$count_posts = $post_type_object->hierarchical ? $wp_query->post_count : $wp_query->found_posts;	$page_links_text = sprintf( '<span class="displaying-num">' . __( 'Displaying %s&#8211;%s of %s' ) . '</span>%s',						number_format_i18n( ( $pagenum - 1 ) * $per_page + 1 ),						number_format_i18n( min( $pagenum * $per_page, $count_posts ) ),						number_format_i18n( $count_posts ),						$page_links						);	echo $page_links_text;	?></div><?php}if ( !$post_type_object->hierarchical ) {?><div class="view-switch">	<a href="<?php echo esc_url(add_query_arg('mode', 'list', $_SERVER['REQUEST_URI'])) ?>"><img <?php if ( 'list' == $mode ) echo 'class="current"'; ?> id="view-switch-list" src="<?php echo esc_url( includes_url( 'images/blank.gif' ) ); ?>" width="20" height="20" title="<?php _e('List View') ?>" alt="<?php _e('List View') ?>" /></a>	<a href="<?php echo esc_url(add_query_arg('mode', 'excerpt', $_SERVER['REQUEST_URI'])) ?>"><img <?php if ( 'excerpt' == $mode ) echo 'class="current"'; ?> id="view-switch-excerpt" src="<?php echo esc_url( includes_url( 'images/blank.gif' ) ); ?>" width="20" height="20" title="<?php _e('Excerpt View') ?>" alt="<?php _e('Excerpt View') ?>" /></a></div><?php } ?><div class="clear"></div></div><div class="clear"></div><?php include( './edit-post-rows.php' ); ?><div class="tablenav"><?phpif ( $page_links )	echo "<div class='tablenav-pages'>$page_links_text</div>";?><div class="alignleft actions"><select name="action2"><option value="-1" selected="selected"><?php _e('Bulk Actions'); ?></option><?php if ( $is_trash ) { ?><option value="untrash"><?php _e('Restore'); ?></option><?php } else { ?><option value="edit"><?php _e('Edit'); ?></option><?php } if ( $is_trash || !EMPTY_TRASH_DAYS ) { ?><option value="delete"><?php _e('Delete Permanently'); ?></option><?php } else { ?><option value="trash"><?php _e('Move to Trash'); ?></option><?php } ?></select><input type="submit" value="<?php esc_attr_e('Apply'); ?>" name="doaction2" id="doaction2" class="button-secondary action" /><?php if ( $is_trash && current_user_can($post_type_object->cap->edit_others_posts) ) { ?><input type="submit" name="delete_all2" id="delete_all2" value="<?php esc_attr_e('Empty Trash'); ?>" class="button-secondary apply" /><?php } ?><br class="clear" /></div><br class="clear" /></div><?php } else { // have_posts() ?><div class="clear"></div><p><?phpif ( isset($_GET['post_status']) && 'trash' == $_GET['post_status'] )	echo $post_type_object->labels->not_found_in_trash;else	echo $post_type_object->labels->not_found;?></p><?php } ?></form><?php inline_edit_row( $current_screen ); ?><div id="ajax-response"></div><br class="clear" /></div><?phpinclude('./admin-footer.php');
<?php/** * Permalink settings administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can( 'manage_options' ) )	wp_die( __( 'You do not have sufficient permissions to manage options for this site.' ) );$title = __('Permalink Settings');$parent_file = 'options-general.php';add_contextual_help($current_screen,	'<p>' . __('This screen provides some common options for your default permalinks URL structure.') . '</p>' .	'<p>' . __('If you pick an option other than Default, your general URL path with structure tags, terms surrounded by <code>%</code>, will also appear in the custom structure field and your path can be further modified there.') . '</p>' .	'<p>' . __('When you assign multiple categories or tags to a post, only one can show up in the permalink: the lowest numbered category. This applies if your custom structure includes <code>%category%</code> or <code>%tag%</code>.') . '</p>' .	'<p>' . __('Note that permalinks beginning with the category, tag, author or postname structure tags require more advanced server resources. Double-check your hosting details to make sure those are in place or start your permalinks with other structure tags.') . '</p>' .	'<p>' . __('The Optional fields let you customize the &#8220;category&#8221; and &#8220;tag&#8221; base names that will appear in archive URLs. For example, the page listing all posts in the &#8220;Uncategorized&#8221; category could be <code>/topics/uncategorized</code> instead of <code>/category/uncategorized</code>.') . '</p>' .	'<p>' . __('You must click the Save Changes button at the bottom of the screen for new settings to take effect.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Settings_Permalinks_SubPanel" target="_blank">Permalinks Settings Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Using_Permalinks" target="_blank">Using Permalinks Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');/** * Display JavaScript on the page. * * @package WordPress * @subpackage Permalink_Settings_Panel */function add_js() {?><script type="text/javascript">//<![CDATA[function GetElementsWithClassName(elementName, className) {var allElements = document.getElementsByTagName(elementName);var elemColl = new Array();for (i = 0; i < allElements.length; i++) {if (allElements[i].className == className) {elemColl[elemColl.length] = allElements[i];}}return elemColl;}function upit() {var inputColl = GetElementsWithClassName('input', 'tog');var structure = document.getElementById('permalink_structure');var inputs = '';for (i = 0; i < inputColl.length; i++) {if ( inputColl[i].checked && inputColl[i].value != '') {inputs += inputColl[i].value + ' ';}}inputs = inputs.substr(0,inputs.length - 1);if ( 'custom' != inputs )structure.value = inputs;}function blurry() {if (!document.getElementById) return;var structure = document.getElementById('permalink_structure');structure.onfocus = function () { document.getElementById('custom_selection').checked = 'checked'; }var aInputs = document.getElementsByTagName('input');for (var i = 0; i < aInputs.length; i++) {aInputs[i].onclick = aInputs[i].onkeyup = upit;}}window.onload = blurry;//]]></script><?php}add_filter('admin_head', 'add_js');include('./admin-header.php');$home_path = get_home_path();$iis7_permalinks = iis7_supports_permalinks();$prefix = $blog_prefix = '';if ( ! got_mod_rewrite() && ! $iis7_permalinks )	$prefix = '/index.php';if ( is_multisite() && !is_subdomain_install() && is_main_site() )	$blog_prefix = '/blog';if ( isset($_POST['permalink_structure']) || isset($_POST['category_base']) ) {	check_admin_referer('update-permalink');	if ( isset( $_POST['permalink_structure'] ) ) {		if ( isset( $_POST['selection'] ) && 'custom' != $_POST['selection'] )			$permalink_structure = $_POST['selection'];		else			$permalink_structure = $_POST['permalink_structure'];		if ( ! empty( $permalink_structure ) ) {			$permalink_structure = preg_replace( '#/+#', '/', '/' . str_replace( '#', '', $permalink_structure ) );			if ( $prefix && $blog_prefix )				$permalink_structure = $prefix . preg_replace( '#^/?index\.php#', '', $permalink_structure );			else				$permalink_structure = $blog_prefix . $permalink_structure;		}		$wp_rewrite->set_permalink_structure( $permalink_structure );	}	if ( isset( $_POST['category_base'] ) ) {		$category_base = $_POST['category_base'];		if ( ! empty( $category_base ) )			$category_base = $blog_prefix . preg_replace('#/+#', '/', '/' . str_replace( '#', '', $category_base ) );		$wp_rewrite->set_category_base( $category_base );	}	if ( isset( $_POST['tag_base'] ) ) {		$tag_base = $_POST['tag_base'];		if ( ! empty( $tag_base ) )			$tag_base = $blog_prefix . preg_replace('#/+#', '/', '/' . str_replace( '#', '', $tag_base ) );		$wp_rewrite->set_tag_base( $tag_base );	}}$permalink_structure = get_option('permalink_structure');$category_base = get_option('category_base');$tag_base = get_option( 'tag_base' );if ( $iis7_permalinks ) {	if ( ( ! file_exists($home_path . 'web.config') && win_is_writable($home_path) ) || win_is_writable($home_path . 'web.config') )		$writable = true;	else		$writable = false;} else {	if ( ( ! file_exists($home_path . '.htaccess') && is_writable($home_path) ) || is_writable($home_path . '.htaccess') )		$writable = true;	else		$writable = false;}if ( $wp_rewrite->using_index_permalinks() )	$usingpi = true;else	$usingpi = false;$wp_rewrite->flush_rules();if (isset($_POST['submit'])) : ?><div id="message" class="updated"><p><?phpif ( ! is_multisite() ) {	if ( $iis7_permalinks ) {		if ( $permalink_structure && ! $usingpi && ! $writable )			_e('You should update your web.config now');		else if ( $permalink_structure && ! $usingpi && $writable )			_e('Permalink structure updated. Remove write access on web.config file now!');		else			_e('Permalink structure updated');	} else {		if ( $permalink_structure && ! $usingpi && ! $writable )			_e('You should update your .htaccess now.');		else			_e('Permalink structure updated.');	}} else {	_e('Permalink structure updated.');}?></p></div><?php endif; ?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><form name="form" action="options-permalink.php" method="post"><?php wp_nonce_field('update-permalink') ?>  <p><?php _e('By default WordPress uses web <abbr title="Universal Resource Locator">URL</abbr>s which have question marks and lots of numbers in them, however WordPress offers you the ability to create a custom URL structure for your permalinks and archives. This can improve the aesthetics, usability, and forward-compatibility of your links. A <a href="http://codex.wordpress.org/Using_Permalinks">number of tags are available</a>, and here are some examples to get you started.'); ?></p><?phpif ( is_multisite() && !is_subdomain_install() && is_main_site() ) {	$permalink_structure = preg_replace( '|^/?blog|', '', $permalink_structure );	$category_base = preg_replace( '|^/?blog|', '', $category_base );	$tag_base = preg_replace( '|^/?blog|', '', $tag_base );}$structures = array(	'',	$prefix . '/%year%/%monthnum%/%day%/%postname%/',	$prefix . '/%year%/%monthnum%/%postname%/',	$prefix . '/archives/%post_id%'	);?><h3><?php _e('Common settings'); ?></h3><table class="form-table">	<tr>		<th><label><input name="selection" type="radio" value="" class="tog" <?php checked('', $permalink_structure); ?> /> <?php _e('Default'); ?></label></th>		<td><code><?php echo get_option('home'); ?>/?p=123</code></td>	</tr>	<tr>		<th><label><input name="selection" type="radio" value="<?php echo esc_attr($structures[1]); ?>" class="tog" <?php checked($structures[1], $permalink_structure); ?> /> <?php _e('Day and name'); ?></label></th>		<td><code><?php echo get_option('home') . $blog_prefix . $prefix . '/' . date('Y') . '/' . date('m') . '/' . date('d') . '/sample-post/'; ?></code></td>	</tr>	<tr>		<th><label><input name="selection" type="radio" value="<?php echo esc_attr($structures[2]); ?>" class="tog" <?php checked($structures[2], $permalink_structure); ?> /> <?php _e('Month and name'); ?></label></th>		<td><code><?php echo get_option('home') . $blog_prefix . $prefix . '/' . date('Y') . '/' . date('m') . '/sample-post/'; ?></code></td>	</tr>	<tr>		<th><label><input name="selection" type="radio" value="<?php echo esc_attr($structures[3]); ?>" class="tog" <?php checked($structures[3], $permalink_structure); ?> /> <?php _e('Numeric'); ?></label></th>		<td><code><?php echo get_option('home') . $blog_prefix . $prefix; ?>/archives/123</code></td>	</tr>	<tr>		<th>			<label><input name="selection" id="custom_selection" type="radio" value="custom" class="tog" <?php checked( !in_array($permalink_structure, $structures) ); ?> />			<?php _e('Custom Structure'); ?>			</label>		</th>		<td>			<?php echo $blog_prefix; ?>			<input name="permalink_structure" id="permalink_structure" type="text" value="<?php echo esc_attr($permalink_structure); ?>" class="regular-text code" />		</td>	</tr></table><h3><?php _e('Optional'); ?></h3><?php if ( $is_apache || $iis7_permalinks ) : ?>	<p><?php _e('If you like, you may enter custom structures for your category and tag <abbr title="Universal Resource Locator">URL</abbr>s here. For example, using <kbd>topics</kbd> as your category base would make your category links like <code>http://example.org/topics/uncategorized/</code>. If you leave these blank the defaults will be used.') ?></p><?php else : ?>	<p><?php _e('If you like, you may enter custom structures for your category and tag <abbr title="Universal Resource Locator">URL</abbr>s here. For example, using <code>topics</code> as your category base would make your category links like <code>http://example.org/index.php/topics/uncategorized/</code>. If you leave these blank the defaults will be used.') ?></p><?php endif; ?><table class="form-table">	<tr>		<th><label for="category_base"><?php /* translators: prefix for category permalinks */ _e('Category base'); ?></label></th>		<td><?php echo $blog_prefix; ?> <input name="category_base" id="category_base" type="text" value="<?php echo esc_attr( $category_base ); ?>" class="regular-text code" /></td>	</tr>	<tr>		<th><label for="tag_base"><?php _e('Tag base'); ?></label></th>		<td><?php echo $blog_prefix; ?> <input name="tag_base" id="tag_base" type="text" value="<?php echo esc_attr($tag_base); ?>" class="regular-text code" /></td>	</tr>	<?php do_settings_fields('permalink', 'optional'); ?></table><?php do_settings_sections('permalink'); ?><p class="submit">	<input type="submit" name="submit" class="button-primary" value="<?php esc_attr_e('Save Changes') ?>" /></p>  </form><?php if ( !is_multisite() ) { ?><?php if ( $iis7_permalinks ) :	if ( isset($_POST['submit']) && $permalink_structure && ! $usingpi && ! $writable ) :		if ( file_exists($home_path . 'web.config') ) : ?><p><?php _e('If your <code>web.config</code> file were <a href="http://codex.wordpress.org/Changing_File_Permissions">writable</a>, we could do this automatically, but it isn&#8217;t so this is the url rewrite rule you should have in your <code>web.config</code> file. Click in the field and press <kbd>CTRL + a</kbd> to select all. Then insert this rule inside of the <code>/&lt;configuration&gt;/&lt;system.webServer&gt;/&lt;rewrite&gt;/&lt;rules&gt;</code> element in <code>web.config</code> file.') ?></p><form action="options-permalink.php" method="post"><?php wp_nonce_field('update-permalink') ?>	<p><textarea rows="9" class="large-text readonly" name="rules" id="rules" readonly="readonly"><?php echo esc_html($wp_rewrite->iis7_url_rewrite_rules()); ?></textarea></p></form><p><?php _e('If you temporarily make your <code>web.config</code> file writable for us to generate rewrite rules automatically, do not forget to revert the permissions after rule has been saved.')  ?></p>		<?php else : ?><p><?php _e('If the root directory of your site were <a href="http://codex.wordpress.org/Changing_File_Permissions">writable</a>, we could do this automatically, but it isn&#8217;t so this is the url rewrite rule you should have in your <code>web.config</code> file. Create a new file, called <code>web.config</code> in the root directory of your site. Click in the field and press <kbd>CTRL + a</kbd> to select all. Then insert this code into the <code>web.config</code> file.') ?></p><form action="options-permalink.php" method="post"><?php wp_nonce_field('update-permalink') ?>	<p><textarea rows="18" class="large-text readonly" name="rules" id="rules" readonly="readonly"><?php echo esc_html($wp_rewrite->iis7_url_rewrite_rules(true)); ?></textarea></p></form><p><?php _e('If you temporarily make your site&#8217;s root directory writable for us to generate the <code>web.config</code> file automatically, do not forget to revert the permissions after the file has been created.')  ?></p>		<?php endif; ?>	<?php endif; ?><?php else :	if ( $permalink_structure && ! $usingpi && ! $writable ) : ?><p><?php _e('If your <code>.htaccess</code> file were <a href="http://codex.wordpress.org/Changing_File_Permissions">writable</a>, we could do this automatically, but it isn&#8217;t so these are the mod_rewrite rules you should have in your <code>.htaccess</code> file. Click in the field and press <kbd>CTRL + a</kbd> to select all.') ?></p><form action="options-permalink.php" method="post"><?php wp_nonce_field('update-permalink') ?>	<p><textarea rows="6" class="large-text readonly" name="rules" id="rules" readonly="readonly"><?php echo esc_html($wp_rewrite->mod_rewrite_rules()); ?></textarea></p></form>	<?php endif; ?><?php endif; ?><?php } // multisite ?></div><?php require('./admin-footer.php'); ?>
<?php/** * WordPress Administration Update API * * @package WordPress * @subpackage Administration */// The admin side of our 1.1 update system/** * Selects the first update version from the update_core option * * @return object the response from the API */function get_preferred_from_update_core() {	$updates = get_core_updates();	if ( !is_array( $updates ) )		return false;	if ( empty( $updates ) )		return (object)array('response' => 'latest');	return $updates[0];}/** * Get available core updates * * @param array $options Set $options['dismissed'] to true to show dismissed upgrades too, * 	set $options['available'] to false to skip not-dimissed updates. * @return array Array of the update objects */function get_core_updates( $options = array() ) {	$options = array_merge( array('available' => true, 'dismissed' => false ), $options );	$dismissed = get_site_option( 'dismissed_update_core' );	if ( !is_array( $dismissed ) ) $dismissed = array();	$from_api = get_site_transient( 'update_core' );	if ( empty($from_api) )		return false;	if ( !isset( $from_api->updates ) || !is_array( $from_api->updates ) ) return false;	$updates = $from_api->updates;	if ( !is_array( $updates ) ) return false;	$result = array();	foreach($updates as $update) {		if ( array_key_exists( $update->current.'|'.$update->locale, $dismissed ) ) {			if ( $options['dismissed'] ) {				$update->dismissed = true;				$result[]= $update;			}		} else {			if ( $options['available'] ) {				$update->dismissed = false;				$result[]= $update;			}		}	}	return $result;}function dismiss_core_update( $update ) {	$dismissed = get_site_option( 'dismissed_update_core' );	$dismissed[ $update->current.'|'.$update->locale ] = true;	return update_site_option( 'dismissed_update_core', $dismissed );}function undismiss_core_update( $version, $locale ) {	$dismissed = get_site_option( 'dismissed_update_core' );	$key = $version.'|'.$locale;	if ( !isset( $dismissed[$key] ) ) return false;	unset( $dismissed[$key] );	return update_site_option( 'dismissed_update_core', $dismissed );}function find_core_update( $version, $locale ) {	$from_api = get_site_transient( 'update_core' );	if ( !is_array( $from_api->updates ) ) return false;	$updates = $from_api->updates;	foreach($updates as $update) {		if ( $update->current == $version && $update->locale == $locale )			return $update;	}	return false;}function core_update_footer( $msg = '' ) {	if ( is_multisite() && !current_user_can('update_core') )		return false;	if ( !current_user_can('update_core') )		return sprintf( __( 'Version %s' ), $GLOBALS['wp_version'] );	$cur = get_preferred_from_update_core();	if ( ! isset( $cur->current ) )		$cur->current = '';	if ( ! isset( $cur->url ) )		$cur->url = '';	if ( ! isset( $cur->response ) )		$cur->response = '';	switch ( $cur->response ) {	case 'development' :		return sprintf( __( 'You are using a development version (%1$s). Cool! Please <a href="%2$s">stay updated</a>.' ), $GLOBALS['wp_version'], 'update-core.php');	break;	case 'upgrade' :		return sprintf( '<strong>'.__( '<a href="%1$s">Get Version %2$s</a>' ).'</strong>', 'update-core.php', $cur->current);	break;	case 'latest' :	default :		return sprintf( __( 'Version %s' ), $GLOBALS['wp_version'] );	break;	}}add_filter( 'update_footer', 'core_update_footer' );function update_nag() {	if ( is_multisite() && !current_user_can('update_core') )		return false;	global $pagenow;	if ( 'update-core.php' == $pagenow )		return;	$cur = get_preferred_from_update_core();	if ( ! isset( $cur->response ) || $cur->response != 'upgrade' )		return false;	if ( current_user_can('update_core') )		$msg = sprintf( __('<a href="http://codex.wordpress.org/Version_%1$s">WordPress %1$s</a> is available! <a href="%2$s">Please update now</a>.'), $cur->current, 'update-core.php' );	else		$msg = sprintf( __('<a href="http://codex.wordpress.org/Version_%1$s">WordPress %1$s</a> is available! Please notify the site administrator.'), $cur->current );	echo "<div class='update-nag'>$msg</div>";}add_action( 'admin_notices', 'update_nag', 3 );// Called directly from dashboardfunction update_right_now_message() {	if ( is_multisite() && !current_user_can('update_core') )		return false;	$cur = get_preferred_from_update_core();	$msg = sprintf( __('You are using <span class="b">WordPress %s</span>.'), $GLOBALS['wp_version'] );	if ( isset( $cur->response ) && $cur->response == 'upgrade' && current_user_can('update_core') )		$msg .= " <a href='update-core.php' class='button'>" . sprintf( __('Update to %s'), $cur->current ? $cur->current : __( 'Latest' ) ) . '</a>';	echo "<span id='wp-version-message'>$msg</span>";}function get_plugin_updates() {	$all_plugins = get_plugins();	$upgrade_plugins = array();	$current = get_site_transient( 'update_plugins' );	foreach ( (array)$all_plugins as $plugin_file => $plugin_data) {		if ( isset( $current->response[ $plugin_file ] ) ) {			$upgrade_plugins[ $plugin_file ] = (object) $plugin_data;			$upgrade_plugins[ $plugin_file ]->update = $current->response[ $plugin_file ];		}	}	return $upgrade_plugins;}function wp_plugin_update_rows() {	if ( !current_user_can('update_plugins' ) )		return;	$plugins = get_site_transient( 'update_plugins' );	if ( isset($plugins->response) && is_array($plugins->response) ) {		$plugins = array_keys( $plugins->response );		foreach( $plugins as $plugin_file ) {			add_action( "after_plugin_row_$plugin_file", 'wp_plugin_update_row', 10, 2 );		}	}}add_action( 'admin_init', 'wp_plugin_update_rows' );function wp_plugin_update_row( $file, $plugin_data ) {	$current = get_site_transient( 'update_plugins' );	if ( !isset( $current->response[ $file ] ) )		return false;	$r = $current->response[ $file ];	$plugins_allowedtags = array('a' => array('href' => array(),'title' => array()),'abbr' => array('title' => array()),'acronym' => array('title' => array()),'code' => array(),'em' => array(),'strong' => array());	$plugin_name = wp_kses( $plugin_data['Name'], $plugins_allowedtags );	$details_url = admin_url('plugin-install.php?tab=plugin-information&plugin=' . $r->slug . '&TB_iframe=true&width=600&height=800');	echo '<tr class="plugin-update-tr"><td colspan="3" class="plugin-update"><div class="update-message">';	if ( ! current_user_can('update_plugins') )		printf( __('There is a new version of %1$s available. <a href="%2$s" class="thickbox" title="%3$s">View version %4$s Details</a>.'), $plugin_name, esc_url($details_url), esc_attr($plugin_name), $r->new_version );	else if ( empty($r->package) )		printf( __('There is a new version of %1$s available. <a href="%2$s" class="thickbox" title="%3$s">View version %4$s Details</a> <em>automatic upgrade unavailable for this plugin</em>.'), $plugin_name, esc_url($details_url), esc_attr($plugin_name), $r->new_version );	else		printf( __('There is a new version of %1$s available. <a href="%2$s" class="thickbox" title="%3$s">View version %4$s Details</a> or <a href="%5$s">upgrade automatically</a>.'), $plugin_name, esc_url($details_url), esc_attr($plugin_name), $r->new_version, wp_nonce_url('update.php?action=upgrade-plugin&plugin=' . $file, 'upgrade-plugin_' . $file) );	do_action( "in_plugin_update_message-$file", $plugin_data, $r );	echo '</div></td></tr>';}function wp_update_plugin($plugin, $feedback = '') {	if ( !empty($feedback) )		add_filter('update_feedback', $feedback);	include ABSPATH . 'wp-admin/includes/class-wp-upgrader.php';	$upgrader = new Plugin_Upgrader();	return $upgrader->upgrade($plugin);}function get_theme_updates() {	$themes = get_themes();	$current = get_site_transient('update_themes');	$update_themes = array();	foreach ( $themes as $theme ) {		$theme = (object) $theme;		if ( isset($current->response[ $theme->Stylesheet ]) ) {			$update_themes[$theme->Stylesheet] = $theme;			$update_themes[$theme->Stylesheet]->update = $current->response[ $theme->Stylesheet ];		}	}	return $update_themes;}function wp_update_theme($theme, $feedback = '') {	if ( !empty($feedback) )		add_filter('update_feedback', $feedback);	include ABSPATH . 'wp-admin/includes/class-wp-upgrader.php';	$upgrader = new Theme_Upgrader();	return $upgrader->upgrade($theme);}function wp_update_core($current, $feedback = '') {	if ( !empty($feedback) )		add_filter('update_feedback', $feedback);	include ABSPATH . 'wp-admin/includes/class-wp-upgrader.php';	$upgrader = new Core_Upgrader();	return $upgrader->upgrade($current);}function maintenance_nag() {	global $upgrading;	if ( ! isset( $upgrading ) )		return false;	if ( current_user_can('update_core') )		$msg = sprintf( __('An automated WordPress update has failed to complete - <a href="%s">please attempt the update again now</a>.'), 'update-core.php' );	else		$msg = __('An automated WordPress update has failed to complete! Please notify the site administrator.');	echo "<div class='update-nag'>$msg</div>";}add_action( 'admin_notices', 'maintenance_nag' );?>
