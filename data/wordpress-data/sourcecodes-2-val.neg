<?php/** * WordPress Administration Bootstrap * * @package WordPress * @subpackage Administration *//** * In WordPress Administration Panels * * @since unknown */if ( !defined('WP_ADMIN') )	define('WP_ADMIN', TRUE);if ( isset($_GET['import']) && !defined('WP_LOAD_IMPORTERS') )	define('WP_LOAD_IMPORTERS', true);require_once(dirname(dirname(__FILE__)) . '/wp-load.php');if ( get_option('db_upgraded') ) {	$wp_rewrite->flush_rules();	update_option( 'db_upgraded',  false );	/**	 * Runs on the next page load after successful upgrade	 *	 * @since 2.8	 */	do_action('after_db_upgrade');} elseif ( get_option('db_version') != $wp_db_version ) {	if ( !is_multisite() ) {		wp_redirect(admin_url('upgrade.php?_wp_http_referer=' . urlencode(stripslashes($_SERVER['REQUEST_URI']))));		exit;	} elseif ( apply_filters( 'do_mu_upgrade', true ) ) {		/**		 * On really small MU installs run the upgrader every time,		 * else run it less often to reduce load.		 *		 * @since 2.8.4b		 */		$c = get_blog_count();		if ( $c <= 50 || ( $c > 50 && mt_rand( 0, (int)( $c / 50 ) ) == 1 ) ) {			require_once( ABSPATH . WPINC . '/http.php' );			$response = wp_remote_get( admin_url( 'upgrade.php?step=1' ), array( 'timeout' => 120, 'httpversion' => '1.1' ) );			do_action( 'after_mu_upgrade', $response );			unset($response);		}		unset($c);	}}require_once(ABSPATH . 'wp-admin/includes/admin.php');auth_redirect();nocache_headers();update_category_cache();// Schedule trash collectionif ( !wp_next_scheduled('wp_scheduled_delete') && !defined('WP_INSTALLING') )	wp_schedule_event(time(), 'daily', 'wp_scheduled_delete');set_screen_options();$date_format = get_option('date_format');$time_format = get_option('time_format');wp_reset_vars(array('profile', 'redirect', 'redirect_url', 'a', 'text', 'trackback', 'pingback'));wp_enqueue_script( 'common' );wp_enqueue_script( 'jquery-color' );$editing = false;if ( isset($_GET['page']) ) {	$plugin_page = stripslashes($_GET['page']);	$plugin_page = plugin_basename($plugin_page);}if ( isset($_GET['post_type']) )	$typenow = sanitize_key($_GET['post_type']);else	$typenow = '';if ( isset($_GET['taxonomy']) )	$taxnow = sanitize_key($_GET['taxonomy']);else	$taxnow = '';require(ABSPATH . 'wp-admin/menu.php');if ( current_user_can( 'manage_options' ) )	@ini_set( 'memory_limit', apply_filters( 'admin_memory_limit', '256M' ) );do_action('admin_init');if ( isset($plugin_page) ) {	if ( !empty($typenow) )		$the_parent = $pagenow . '?post_type=' . $typenow;	else		$the_parent = $pagenow;	if ( ! $page_hook = get_plugin_page_hook($plugin_page, $the_parent) ) {		$page_hook = get_plugin_page_hook($plugin_page, $plugin_page);		// backwards compatibility for plugins using add_management_page		if ( empty( $page_hook ) && 'edit.php' == $pagenow && '' != get_plugin_page_hook($plugin_page, 'tools.php') ) {			// There could be plugin specific params on the URL, so we need the whole query string			if ( !empty($_SERVER[ 'QUERY_STRING' ]) )				$query_string = $_SERVER[ 'QUERY_STRING' ];			else				$query_string = 'page=' . $plugin_page;			wp_redirect( 'tools.php?' . $query_string );			exit;		}	}	unset($the_parent);}$hook_suffix = '';if ( isset($page_hook) )	$hook_suffix = $page_hook;else if ( isset($plugin_page) )	$hook_suffix = $plugin_page;else if ( isset($pagenow) )	$hook_suffix = $pagenow;set_current_screen();// Handle plugin admin pages.if ( isset($plugin_page) ) {	if ( $page_hook ) {		do_action('load-' . $page_hook);		if (! isset($_GET['noheader']))			require_once(ABSPATH . 'wp-admin/admin-header.php');		do_action($page_hook);	} else {		if ( validate_file($plugin_page) )			wp_die(__('Invalid plugin page'));		if ( !( file_exists(WP_PLUGIN_DIR . "/$plugin_page") && is_file(WP_PLUGIN_DIR . "/$plugin_page") ) && !( file_exists(WPMU_PLUGIN_DIR . "/$plugin_page") && is_file(WPMU_PLUGIN_DIR . "/$plugin_page") ) )			wp_die(sprintf(__('Cannot load %s.'), htmlentities($plugin_page)));		do_action('load-' . $plugin_page);		if ( !isset($_GET['noheader']))			require_once(ABSPATH . 'wp-admin/admin-header.php');		if ( file_exists(WPMU_PLUGIN_DIR . "/$plugin_page") )			include(WPMU_PLUGIN_DIR . "/$plugin_page");		else			include(ABSPATH . PLUGINDIR . "/$plugin_page");	}	include(ABSPATH . 'wp-admin/admin-footer.php');	exit();} else if (isset($_GET['import'])) {	$importer = $_GET['import'];	if ( ! current_user_can('import') )		wp_die(__('You are not allowed to import.'));	if ( validate_file($importer) )		wp_redirect( admin_url( 'import.php?invalid=' . $importer ) );	// Allow plugins to define importers as well	if ( !isset($wp_importers) || !isset($wp_importers[$importer]) || ! is_callable($wp_importers[$importer][2])) {		if (! file_exists(ABSPATH . "wp-admin/import/$importer.php"))			wp_redirect( admin_url( 'import.php?invalid=' . $importer ) );		include(ABSPATH . "wp-admin/import/$importer.php");	}	$parent_file = 'tools.php';	$submenu_file = 'import.php';	$title = __('Import');	if (! isset($_GET['noheader']))		require_once(ABSPATH . 'wp-admin/admin-header.php');	require_once(ABSPATH . 'wp-admin/includes/upgrade.php');	define('WP_IMPORTING', true);	if ( is_multisite() )		kses_init_filters();  // Always filter imported data with kses.	call_user_func($wp_importers[$importer][2]);	include(ABSPATH . 'wp-admin/admin-footer.php');	// Make sure rules are flushed	global $wp_rewrite;	$wp_rewrite->flush_rules(false);	exit();} else {	do_action("load-$pagenow");}if ( !empty($_REQUEST['action']) )	do_action('admin_action_' . $_REQUEST['action']);?>
<?php/** * WordPress Administration Scheme API * * Here we keep the DB structure and option values. * * @package WordPress * @subpackage Administration *//** * The database character collate. * @var string * @global string * @name $charset_collate */$charset_collate = '';// Declare these as global in case schema.php is included from a function.global $wpdb, $wp_queries;if ( ! empty($wpdb->charset) )	$charset_collate = "DEFAULT CHARACTER SET $wpdb->charset";if ( ! empty($wpdb->collate) )	$charset_collate .= " COLLATE $wpdb->collate";/** Create WordPress database tables SQL */$wp_queries = "CREATE TABLE $wpdb->terms ( term_id bigint(20) unsigned NOT NULL auto_increment, name varchar(200) NOT NULL default '', slug varchar(200) NOT NULL default '', term_group bigint(10) NOT NULL default 0, PRIMARY KEY  (term_id), UNIQUE KEY slug (slug), KEY name (name)) $charset_collate;CREATE TABLE $wpdb->term_taxonomy ( term_taxonomy_id bigint(20) unsigned NOT NULL auto_increment, term_id bigint(20) unsigned NOT NULL default 0, taxonomy varchar(32) NOT NULL default '', description longtext NOT NULL, parent bigint(20) unsigned NOT NULL default 0, count bigint(20) NOT NULL default 0, PRIMARY KEY  (term_taxonomy_id), UNIQUE KEY term_id_taxonomy (term_id,taxonomy), KEY taxonomy (taxonomy)) $charset_collate;CREATE TABLE $wpdb->term_relationships ( object_id bigint(20) unsigned NOT NULL default 0, term_taxonomy_id bigint(20) unsigned NOT NULL default 0, term_order int(11) NOT NULL default 0, PRIMARY KEY  (object_id,term_taxonomy_id), KEY term_taxonomy_id (term_taxonomy_id)) $charset_collate;CREATE TABLE $wpdb->commentmeta (  meta_id bigint(20) unsigned NOT NULL auto_increment,  comment_id bigint(20) unsigned NOT NULL default '0',  meta_key varchar(255) default NULL,  meta_value longtext,  PRIMARY KEY  (meta_id),  KEY comment_id (comment_id),  KEY meta_key (meta_key)) $charset_collate;CREATE TABLE $wpdb->comments (  comment_ID bigint(20) unsigned NOT NULL auto_increment,  comment_post_ID bigint(20) unsigned NOT NULL default '0',  comment_author tinytext NOT NULL,  comment_author_email varchar(100) NOT NULL default '',  comment_author_url varchar(200) NOT NULL default '',  comment_author_IP varchar(100) NOT NULL default '',  comment_date datetime NOT NULL default '0000-00-00 00:00:00',  comment_date_gmt datetime NOT NULL default '0000-00-00 00:00:00',  comment_content text NOT NULL,  comment_karma int(11) NOT NULL default '0',  comment_approved varchar(20) NOT NULL default '1',  comment_agent varchar(255) NOT NULL default '',  comment_type varchar(20) NOT NULL default '',  comment_parent bigint(20) unsigned NOT NULL default '0',  user_id bigint(20) unsigned NOT NULL default '0',  PRIMARY KEY  (comment_ID),  KEY comment_approved (comment_approved),  KEY comment_post_ID (comment_post_ID),  KEY comment_approved_date_gmt (comment_approved,comment_date_gmt),  KEY comment_date_gmt (comment_date_gmt),  KEY comment_parent (comment_parent)) $charset_collate;CREATE TABLE $wpdb->links (  link_id bigint(20) unsigned NOT NULL auto_increment,  link_url varchar(255) NOT NULL default '',  link_name varchar(255) NOT NULL default '',  link_image varchar(255) NOT NULL default '',  link_target varchar(25) NOT NULL default '',  link_description varchar(255) NOT NULL default '',  link_visible varchar(20) NOT NULL default 'Y',  link_owner bigint(20) unsigned NOT NULL default '1',  link_rating int(11) NOT NULL default '0',  link_updated datetime NOT NULL default '0000-00-00 00:00:00',  link_rel varchar(255) NOT NULL default '',  link_notes mediumtext NOT NULL,  link_rss varchar(255) NOT NULL default '',  PRIMARY KEY  (link_id),  KEY link_visible (link_visible)) $charset_collate;CREATE TABLE $wpdb->options (  option_id bigint(20) unsigned NOT NULL auto_increment,  blog_id int(11) NOT NULL default '0',  option_name varchar(64) NOT NULL default '',  option_value longtext NOT NULL,  autoload varchar(20) NOT NULL default 'yes',  PRIMARY KEY  (option_id),  UNIQUE KEY option_name (option_name)) $charset_collate;CREATE TABLE $wpdb->postmeta (  meta_id bigint(20) unsigned NOT NULL auto_increment,  post_id bigint(20) unsigned NOT NULL default '0',  meta_key varchar(255) default NULL,  meta_value longtext,  PRIMARY KEY  (meta_id),  KEY post_id (post_id),  KEY meta_key (meta_key)) $charset_collate;CREATE TABLE $wpdb->posts (  ID bigint(20) unsigned NOT NULL auto_increment,  post_author bigint(20) unsigned NOT NULL default '0',  post_date datetime NOT NULL default '0000-00-00 00:00:00',  post_date_gmt datetime NOT NULL default '0000-00-00 00:00:00',  post_content longtext NOT NULL,  post_title text NOT NULL,  post_excerpt text NOT NULL,  post_status varchar(20) NOT NULL default 'publish',  comment_status varchar(20) NOT NULL default 'open',  ping_status varchar(20) NOT NULL default 'open',  post_password varchar(20) NOT NULL default '',  post_name varchar(200) NOT NULL default '',  to_ping text NOT NULL,  pinged text NOT NULL,  post_modified datetime NOT NULL default '0000-00-00 00:00:00',  post_modified_gmt datetime NOT NULL default '0000-00-00 00:00:00',  post_content_filtered text NOT NULL,  post_parent bigint(20) unsigned NOT NULL default '0',  guid varchar(255) NOT NULL default '',  menu_order int(11) NOT NULL default '0',  post_type varchar(20) NOT NULL default 'post',  post_mime_type varchar(100) NOT NULL default '',  comment_count bigint(20) NOT NULL default '0',  PRIMARY KEY  (ID),  KEY post_name (post_name),  KEY type_status_date (post_type,post_status,post_date,ID),  KEY post_parent (post_parent),  KEY post_author (post_author)) $charset_collate;CREATE TABLE $wpdb->users (  ID bigint(20) unsigned NOT NULL auto_increment,  user_login varchar(60) NOT NULL default '',  user_pass varchar(64) NOT NULL default '',  user_nicename varchar(50) NOT NULL default '',  user_email varchar(100) NOT NULL default '',  user_url varchar(100) NOT NULL default '',  user_registered datetime NOT NULL default '0000-00-00 00:00:00',  user_activation_key varchar(60) NOT NULL default '',  user_status int(11) NOT NULL default '0',  display_name varchar(250) NOT NULL default '',  PRIMARY KEY  (ID),  KEY user_login_key (user_login),  KEY user_nicename (user_nicename)) $charset_collate;CREATE TABLE $wpdb->usermeta (  umeta_id bigint(20) unsigned NOT NULL auto_increment,  user_id bigint(20) unsigned NOT NULL default '0',  meta_key varchar(255) default NULL,  meta_value longtext,  PRIMARY KEY  (umeta_id),  KEY user_id (user_id),  KEY meta_key (meta_key)) $charset_collate;";/** * Create WordPress options and set the default values. * * @since 1.5.0 * @uses $wpdb * @uses $wp_db_version */function populate_options() {	global $wpdb, $wp_db_version, $current_site;	$guessurl = wp_guess_url();	do_action('populate_options');	if ( ini_get('safe_mode') ) {		// Safe mode can break mkdir() so use a flat structure by default.		$uploads_use_yearmonth_folders = 0;	} else {		$uploads_use_yearmonth_folders = 1;	}	$options = array(	'siteurl' => $guessurl,	'blogname' => __('My Site'),	/* translators: blog tagline */	'blogdescription' => __('Just another WordPress site'),	'users_can_register' => 0,	'admin_email' => 'you@example.com',	'start_of_week' => 1,	'use_balanceTags' => 0,	'use_smilies' => 1,	'require_name_email' => 1,	'comments_notify' => 1,	'posts_per_rss' => 10,	'rss_use_excerpt' => 0,	'mailserver_url' => 'mail.example.com',	'mailserver_login' => 'login@example.com',	'mailserver_pass' => 'password',	'mailserver_port' => 110,	'default_category' => 1,	'default_comment_status' => 'open',	'default_ping_status' => 'open',	'default_pingback_flag' => 1,	'default_post_edit_rows' => 10,	'posts_per_page' => 10,	/* translators: default date format, see http://php.net/date */	'date_format' => __('F j, Y'),	/* translators: default time format, see http://php.net/date */	'time_format' => __('g:i a'),	/* translators: links last updated date format, see http://php.net/date */	'links_updated_date_format' => __('F j, Y g:i a'),	'links_recently_updated_prepend' => '<em>',	'links_recently_updated_append' => '</em>',	'links_recently_updated_time' => 120,	'comment_moderation' => 0,	'moderation_notify' => 1,	'permalink_structure' => '',	'gzipcompression' => 0,	'hack_file' => 0,	'blog_charset' => 'UTF-8',	'moderation_keys' => '',	'active_plugins' => array(),	'home' => $guessurl,	'category_base' => '',	'ping_sites' => 'http://rpc.pingomatic.com/',	'advanced_edit' => 0,	'comment_max_links' => 2,	'gmt_offset' => date('Z') / 3600,	// 1.5	'default_email_category' => 1,	'recently_edited' => '',	'template' => WP_DEFAULT_THEME,	'stylesheet' => WP_DEFAULT_THEME,	'comment_whitelist' => 1,	'blacklist_keys' => '',	'comment_registration' => 0,	'rss_language' => 'en',	'html_type' => 'text/html',	// 1.5.1	'use_trackback' => 0,	// 2.0	'default_role' => 'subscriber',	'db_version' => $wp_db_version,	// 2.0.1	'uploads_use_yearmonth_folders' => $uploads_use_yearmonth_folders,	'upload_path' => '',	// 2.1	'blog_public' => '1',	'default_link_category' => 2,	'show_on_front' => 'posts',	// 2.2	'tag_base' => '',	// 2.5	'show_avatars' => '1',	'avatar_rating' => 'G',	'upload_url_path' => '',	'thumbnail_size_w' => 150,	'thumbnail_size_h' => 150,	'thumbnail_crop' => 1,	'medium_size_w' => 300,	'medium_size_h' => 300,	// 2.6	'avatar_default' => 'mystery',	'enable_app' => 0,	'enable_xmlrpc' => 0,	// 2.7	'large_size_w' => 1024,	'large_size_h' => 1024,	'image_default_link_type' => 'file',	'image_default_size' => '',	'image_default_align' => '',	'close_comments_for_old_posts' => 0,	'close_comments_days_old' => 14,	'thread_comments' => 1,	'thread_comments_depth' => 5,	'page_comments' => 0,	'comments_per_page' => 50,	'default_comments_page' => 'newest',	'comment_order' => 'asc',	'sticky_posts' => array(),	'widget_categories' => array(),	'widget_text' => array(),	'widget_rss' => array(),	// 2.8	'timezone_string' => '',	// 2.9	'embed_autourls' => 1,	'embed_size_w' => '',	'embed_size_h' => 600,	// 3.0	'page_for_posts' => 0,	'page_on_front' => 0,	);	// 3.0 multisite	if ( is_multisite() ) {		/* translators: blog tagline */		$options[ 'blogdescription' ] = sprintf(__('Just another %s site'), $current_site->site_name );		$options[ 'permalink_structure' ] = '/%year%/%monthnum%/%day%/%postname%/';	}	// Set autoload to no for these options	$fat_options = array( 'moderation_keys', 'recently_edited', 'blacklist_keys' );	$existing_options = $wpdb->get_col("SELECT option_name FROM $wpdb->options");	$insert = '';	foreach ( $options as $option => $value ) {		if ( in_array($option, $existing_options) )			continue;		if ( in_array($option, $fat_options) )			$autoload = 'no';		else			$autoload = 'yes';		$option = $wpdb->escape($option);		if ( is_array($value) )			$value = serialize($value);		$value = $wpdb->escape($value);		if ( !empty($insert) )			$insert .= ', ';		$insert .= "('$option', '$value', '$autoload')";	}	if ( !empty($insert) )		$wpdb->query("INSERT INTO $wpdb->options (option_name, option_value, autoload) VALUES " . $insert);	// in case it is set, but blank, update "home"	if ( !__get_option('home') ) update_option('home', $guessurl);	// Delete unused options	$unusedoptions = array ('blodotgsping_url', 'bodyterminator', 'emailtestonly', 'phoneemail_separator', 'smilies_directory', 'subjectprefix', 'use_bbcode', 'use_blodotgsping', 'use_phoneemail', 'use_quicktags', 'use_weblogsping', 'weblogs_cache_file', 'use_preview', 'use_htmltrans', 'smilies_directory', 'fileupload_allowedusers', 'use_phoneemail', 'default_post_status', 'default_post_category', 'archive_mode', 'time_difference', 'links_minadminlevel', 'links_use_adminlevels', 'links_rating_type', 'links_rating_char', 'links_rating_ignore_zero', 'links_rating_single_image', 'links_rating_image0', 'links_rating_image1', 'links_rating_image2', 'links_rating_image3', 'links_rating_image4', 'links_rating_image5', 'links_rating_image6', 'links_rating_image7', 'links_rating_image8', 'links_rating_image9', 'weblogs_cacheminutes', 'comment_allowed_tags', 'search_engine_friendly_urls', 'default_geourl_lat', 'default_geourl_lon', 'use_default_geourl', 'weblogs_xml_url', 'new_users_can_blog', '_wpnonce', '_wp_http_referer', 'Update', 'action', 'rich_editing', 'autosave_interval', 'deactivated_plugins', 'can_compress_scripts',		'page_uris', 'update_core', 'update_plugins', 'update_themes', 'doing_cron', 'random_seed', 'rss_excerpt_length', 'secret', 'use_linksupdate', 'default_comment_status_page' );	foreach ($unusedoptions as $option)		delete_option($option);	// delete obsolete magpie stuff	$wpdb->query("DELETE FROM $wpdb->options WHERE option_name REGEXP '^rss_[0-9a-f]{32}(_ts)?$'");}/** * Execute WordPress role creation for the various WordPress versions. * * @since 2.0.0 */function populate_roles() {	populate_roles_160();	populate_roles_210();	populate_roles_230();	populate_roles_250();	populate_roles_260();	populate_roles_270();	populate_roles_280();	populate_roles_300();}/** * Create the roles for WordPress 2.0 * * @since 2.0.0 */function populate_roles_160() {	// Add roles	// Dummy gettext calls to get strings in the catalog.	/* translators: user role */	_x('Administrator', 'User role');	/* translators: user role */	_x('Editor', 'User role');	/* translators: user role */	_x('Author', 'User role');	/* translators: user role */	_x('Contributor', 'User role');	/* translators: user role */	_x('Subscriber', 'User role');	add_role('administrator', 'Administrator');	add_role('editor', 'Editor');	add_role('author', 'Author');	add_role('contributor', 'Contributor');	add_role('subscriber', 'Subscriber');	// Add caps for Administrator role	$role =& get_role('administrator');	$role->add_cap('switch_themes');	$role->add_cap('edit_themes');	$role->add_cap('activate_plugins');	$role->add_cap('edit_plugins');	$role->add_cap('edit_users');	$role->add_cap('edit_files');	$role->add_cap('manage_options');	$role->add_cap('moderate_comments');	$role->add_cap('manage_categories');	$role->add_cap('manage_links');	$role->add_cap('upload_files');	$role->add_cap('import');	$role->add_cap('unfiltered_html');	$role->add_cap('edit_posts');	$role->add_cap('edit_others_posts');	$role->add_cap('edit_published_posts');	$role->add_cap('publish_posts');	$role->add_cap('edit_pages');	$role->add_cap('read');	$role->add_cap('level_10');	$role->add_cap('level_9');	$role->add_cap('level_8');	$role->add_cap('level_7');	$role->add_cap('level_6');	$role->add_cap('level_5');	$role->add_cap('level_4');	$role->add_cap('level_3');	$role->add_cap('level_2');	$role->add_cap('level_1');	$role->add_cap('level_0');	// Add caps for Editor role	$role =& get_role('editor');	$role->add_cap('moderate_comments');	$role->add_cap('manage_categories');	$role->add_cap('manage_links');	$role->add_cap('upload_files');	$role->add_cap('unfiltered_html');	$role->add_cap('edit_posts');	$role->add_cap('edit_others_posts');	$role->add_cap('edit_published_posts');	$role->add_cap('publish_posts');	$role->add_cap('edit_pages');	$role->add_cap('read');	$role->add_cap('level_7');	$role->add_cap('level_6');	$role->add_cap('level_5');	$role->add_cap('level_4');	$role->add_cap('level_3');	$role->add_cap('level_2');	$role->add_cap('level_1');	$role->add_cap('level_0');	// Add caps for Author role	$role =& get_role('author');	$role->add_cap('upload_files');	$role->add_cap('edit_posts');	$role->add_cap('edit_published_posts');	$role->add_cap('publish_posts');	$role->add_cap('read');	$role->add_cap('level_2');	$role->add_cap('level_1');	$role->add_cap('level_0');	// Add caps for Contributor role	$role =& get_role('contributor');	$role->add_cap('edit_posts');	$role->add_cap('read');	$role->add_cap('level_1');	$role->add_cap('level_0');	// Add caps for Subscriber role	$role =& get_role('subscriber');	$role->add_cap('read');	$role->add_cap('level_0');}/** * Create and modify WordPress roles for WordPress 2.1. * * @since 2.1.0 */function populate_roles_210() {	$roles = array('administrator', 'editor');	foreach ($roles as $role) {		$role =& get_role($role);		if ( empty($role) )			continue;		$role->add_cap('edit_others_pages');		$role->add_cap('edit_published_pages');		$role->add_cap('publish_pages');		$role->add_cap('delete_pages');		$role->add_cap('delete_others_pages');		$role->add_cap('delete_published_pages');		$role->add_cap('delete_posts');		$role->add_cap('delete_others_posts');		$role->add_cap('delete_published_posts');		$role->add_cap('delete_private_posts');		$role->add_cap('edit_private_posts');		$role->add_cap('read_private_posts');		$role->add_cap('delete_private_pages');		$role->add_cap('edit_private_pages');		$role->add_cap('read_private_pages');	}	$role =& get_role('administrator');	if ( ! empty($role) ) {		$role->add_cap('delete_users');		$role->add_cap('create_users');	}	$role =& get_role('author');	if ( ! empty($role) ) {		$role->add_cap('delete_posts');		$role->add_cap('delete_published_posts');	}	$role =& get_role('contributor');	if ( ! empty($role) ) {		$role->add_cap('delete_posts');	}}/** * Create and modify WordPress roles for WordPress 2.3. * * @since 2.3.0 */function populate_roles_230() {	$role =& get_role( 'administrator' );	if ( !empty( $role ) ) {		$role->add_cap( 'unfiltered_upload' );	}}/** * Create and modify WordPress roles for WordPress 2.5. * * @since 2.5.0 */function populate_roles_250() {	$role =& get_role( 'administrator' );	if ( !empty( $role ) ) {		$role->add_cap( 'edit_dashboard' );	}}/** * Create and modify WordPress roles for WordPress 2.6. * * @since 2.6.0 */function populate_roles_260() {	$role =& get_role( 'administrator' );	if ( !empty( $role ) ) {		$role->add_cap( 'update_plugins' );		$role->add_cap( 'delete_plugins' );	}}/** * Create and modify WordPress roles for WordPress 2.7. * * @since 2.7.0 */function populate_roles_270() {	$role =& get_role( 'administrator' );	if ( !empty( $role ) ) {		$role->add_cap( 'install_plugins' );		$role->add_cap( 'update_themes' );	}}/** * Create and modify WordPress roles for WordPress 2.8. * * @since 2.8.0 */function populate_roles_280() {	$role =& get_role( 'administrator' );	if ( !empty( $role ) ) {		$role->add_cap( 'install_themes' );	}}/** * Create and modify WordPress roles for WordPress 3.0. * * @since 3.0.0 */function populate_roles_300() {	$role =& get_role( 'administrator' );	if ( !empty( $role ) ) {		$role->add_cap( 'update_core' );		$role->add_cap( 'list_users' );		$role->add_cap( 'remove_users' );		$role->add_cap( 'add_users' );		$role->add_cap( 'promote_users' );		$role->add_cap( 'edit_theme_options' );		$role->add_cap( 'delete_themes' );		$role->add_cap( 'export' );	}}/** * populate network settings * * @since 3.0.0 * * @param int $network_id id of network to populate * @return bool|WP_Error True on success, or WP_Error on warning (with the install otherwise successful, * 	so the error code must be checked) or failure. */function populate_network( $network_id = 1, $domain = '', $email = '', $site_name = '', $path = '/', $subdomain_install = false ) {	global $wpdb, $current_site, $wp_db_version, $wp_rewrite;	$errors = new WP_Error();	if ( '' == $domain )		$errors->add( 'empty_domain', __( 'You must provide a domain name.' ) );	if ( '' == $site_name )		$errors->add( 'empty_sitename', __( 'You must provide a name for your network of sites.' ) );	// check for network collision	if ( $network_id == $wpdb->get_var( $wpdb->prepare( "SELECT id FROM $wpdb->site WHERE id = %d", $network_id ) ) )		$errors->add( 'siteid_exists', __( 'The network already exists.' ) );	$site_user = get_user_by_email( $email );	if ( ! is_email( $email ) )		$errors->add( 'invalid_email', __( 'You must provide a valid e-mail address.' ) );	if ( $errors->get_error_code() )		return $errors;	// set up site tables	$template = get_option( 'template' );	$stylesheet = get_option( 'stylesheet' );	$allowed_themes = array( $stylesheet => true );	if ( $template != $stylesheet )		$allowed_themes[ $template ] = true;	if ( WP_DEFAULT_THEME != $stylesheet && WP_DEFAULT_THEME != $template )		$allowed_themes[ WP_DEFAULT_THEME ] = true;	if ( 1 == $network_id ) {		$wpdb->insert( $wpdb->site, array( 'domain' => $domain, 'path' => $path ) );		$network_id = $wpdb->insert_id;	} else {		$wpdb->insert( $wpdb->site, array( 'domain' => $domain, 'path' => $path, 'id' => $network_id ) );	}	if ( !is_multisite() ) {		$site_admins = array( $site_user->user_login );		$users = get_users_of_blog();		if ( $users ) {			foreach ( $users as $user ) {				if ( is_super_admin( $user->ID ) && !in_array( $user->user_login, $site_admins ) )					$site_admins[] = $user->user_login;			}		}	} else {		$site_admins = get_site_option( 'site_admins' );	}	$welcome_email = __( 'Dear User,Your new SITE_NAME site has been successfully set up at:BLOG_URLYou can log in to the administrator account with the following information:Username: USERNAMEPassword: PASSWORDLogin Here: BLOG_URLwp-login.phpWe hope you enjoy your new site.Thanks!--The Team @ SITE_NAME' );	$sitemeta = array(		'site_name' => $site_name,		'admin_email' => $site_user->user_email,		'admin_user_id' => $site_user->ID,		'registration' => 'none',		'upload_filetypes' => 'jpg jpeg png gif mp3 mov avi wmv midi mid pdf',		'blog_upload_space' => 10,		'fileupload_maxk' => 1500,		'site_admins' => $site_admins,		'allowedthemes' => $allowed_themes,		'illegal_names' => array( 'www', 'web', 'root', 'admin', 'main', 'invite', 'administrator', 'files' ),		'wpmu_upgrade_site' => $wp_db_version,		'welcome_email' => $welcome_email,		'first_post' => __( 'Welcome to <a href="SITE_URL">SITE_NAME</a>. This is your first post. Edit or delete it, then start blogging!' ),		// @todo - network admins should have a method of editing the network siteurl (used for cookie hash)		'siteurl' => get_option( 'siteurl' ) . '/',		'add_new_users' => '0',		'upload_space_check_disabled' => '0',		'subdomain_install' => intval( $subdomain_install ),		'global_terms_enabled' => global_terms_enabled() ? '1' : '0'	);	if ( !intval( $subdomain_install ) )		$sitemeta['illegal_names'][] = 'blog';	$insert = '';	foreach ( $sitemeta as $meta_key => $meta_value ) {		$meta_key = $wpdb->escape( $meta_key );		if ( is_array( $meta_value ) )			$meta_value = serialize( $meta_value );		$meta_value = $wpdb->escape( $meta_value );		if ( !empty( $insert ) )			$insert .= ', ';		$insert .= "( $network_id, '$meta_key', '$meta_value')";	}	$wpdb->query( "INSERT INTO $wpdb->sitemeta ( site_id, meta_key, meta_value ) VALUES " . $insert );	$current_site->domain = $domain;	$current_site->path = $path;	$current_site->site_name = ucfirst( $domain );	if ( !is_multisite() ) {		$wpdb->insert( $wpdb->blogs, array( 'site_id' => $network_id, 'domain' => $domain, 'path' => $path, 'registered' => current_time( 'mysql' ) ) );		$blog_id = $wpdb->insert_id;		update_user_meta( $site_user->ID, 'source_domain', $domain );		update_user_meta( $site_user->ID, 'primary_blog', $blog_id );		if ( !$upload_path = get_option( 'upload_path' ) ) {			$upload_path = substr( WP_CONTENT_DIR, strlen( ABSPATH ) ) . '/uploads';			update_option( 'upload_path', $upload_path );		}		update_option( 'fileupload_url', get_option( 'siteurl' ) . '/' . $upload_path );	}	if ( $subdomain_install )		update_option( 'permalink_structure', '/%year%/%monthnum%/%day%/%postname%/');	else		update_option( 'permalink_structure', '/blog/%year%/%monthnum%/%day%/%postname%/');	$wp_rewrite->flush_rules();	if ( $subdomain_install ) {		$vhost_ok = false;		$errstr = '';		$hostname = substr( md5( time() ), 0, 6 ) . '.' . $domain; // Very random hostname!		$page = wp_remote_get( 'http://' . $hostname, array( 'timeout' => 5, 'httpversion' => '1.1' ) );		if ( is_wp_error( $page ) )			$errstr = $page->get_error_message();		elseif ( 200 == $page['response']['code'] )				$vhost_ok = true;		if ( ! $vhost_ok ) {			$msg = '<p><strong>' . __( 'Warning! Wildcard DNS may not be configured correctly!' ) . '</strong></p>';			$msg .= '<p>' . sprintf( __( 'The installer attempted to contact a random hostname (<code>%1$s</code>) on your domain.' ), $hostname );			if ( ! empty ( $errstr ) )				$msg .= ' ' . sprintf( __( 'This resulted in an error message: %s' ), '<code>' . $errstr . '</code>' );			$msg .= '</p>';			$msg .= '<p>' . _e( 'To use a subdomain configuration, you must have a wildcard entry in your DNS. This usually means adding a <code>*</code> hostname record pointing at your web server in your DNS configuration tool.' ) . '</p>';			$msg .= '<p>' . __( 'You can still use your site but any subdomain you create may not be accessible. If you know your DNS is correct, ignore this message.' ) . '</p>';			return new WP_Error( 'no_wildcard_dns', $msg );		}	}	return true;}?>
<?php/** * Upgrade WordPress Page. * * @package WordPress * @subpackage Administration *//** * We are upgrading WordPress. * * @since unknown * @var bool */define( 'WP_INSTALLING', true );/** Load WordPress Bootstrap */require( '../wp-load.php' );timer_start();require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );delete_site_transient('update_core');if ( isset( $_GET['step'] ) )	$step = $_GET['step'];else	$step = 0;// Do it.  No output.if ( 'upgrade_db' === $step ) {	wp_upgrade();	die( '0' );}$step = (int) $step;$php_version    = phpversion();$mysql_version  = $wpdb->db_version();$php_compat     = version_compare( $php_version, $required_php_version, '>=' );$mysql_compat   = version_compare( $mysql_version, $required_mysql_version, '>=' ) || file_exists( WP_CONTENT_DIR . '/db.php' );@header( 'Content-Type: ' . get_option( 'html_type' ) . '; charset=' . get_option( 'blog_charset' ) );?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" <?php language_attributes(); ?>><head>	<meta http-equiv="Content-Type" content="<?php bloginfo( 'html_type' ); ?>; charset=<?php echo get_option( 'blog_charset' ); ?>" />	<title><?php _e( 'WordPress &rsaquo; Upgrade' ); ?></title>	<?php	wp_admin_css( 'install', true );	wp_admin_css( 'ie', true );	?></head><body><h1 id="logo"><img alt="WordPress" src="images/wordpress-logo.png" /></h1><?php if ( get_option( 'db_version' ) == $wp_db_version || !is_blog_installed() ) : ?><h2><?php _e( 'No Upgrade Required' ); ?></h2><p><?php _e( 'Your WordPress database is already up-to-date!' ); ?></p><p class="step"><a class="button" href="<?php echo get_option( 'home' ); ?>/"><?php _e( 'Continue' ); ?></a></p><?php elseif ( !$php_compat || !$mysql_compat ) :	if ( !$mysql_compat && !$php_compat )		printf( __('You cannot upgrade because <a href="http://codex.wordpress.org/Version_%1$s">WordPress %1$s</a> requires PHP version %2$s or higher and MySQL version %3$s or higher. You are running PHP version %4$s and MySQL version %5$s.'), $wp_version, $required_php_version, $required_mysql_version, $php_version, $mysql_version );	elseif ( !$php_compat )		printf( __('You cannot upgrade because <a href="http://codex.wordpress.org/Version_%1$s">WordPress %1$s</a> requires PHP version %2$s or higher. You are running version %3$s.'), $wp_version, $required_php_version, $php_version );	elseif ( !$mysql_compat )		printf( __('You cannot upgrade because <a href="http://codex.wordpress.org/Version_%1$s">WordPress %1$s</a> requires MySQL version %2$s or higher. You are running version %3$s.'), $wp_version, $required_mysql_version, $mysql_version );?><?php else :switch ( $step ) :	case 0:		$goback = stripslashes( wp_get_referer() );		$goback = esc_url_raw( $goback );		$goback = urlencode( $goback );?><h2><?php _e( 'Database Upgrade Required' ); ?></h2><p><?php _e( 'WordPress has been updated! Before we send you on your way, we have to upgrade your database to the newest version.' ); ?></p><p><?php _e( 'The upgrade process may take a little while, so please be patient.' ); ?></p><p class="step"><a class="button" href="upgrade.php?step=1&amp;backto=<?php echo $goback; ?>"><?php _e( 'Upgrade WordPress Database' ); ?></a></p><?php		break;	case 1:		wp_upgrade();			$backto = !empty($_GET['backto']) ? stripslashes( urldecode( $_GET['backto'] ) ) :  __get_option( 'home' ) . '/';			$backto = esc_url_raw( $backto );			$backto = wp_validate_redirect($backto, __get_option( 'home' ) . '/');?><h2><?php _e( 'Upgrade Complete' ); ?></h2>	<p><?php _e( 'Your WordPress database has been successfully upgraded!' ); ?></p>	<p class="step"><a class="button" href="<?php echo $backto; ?>"><?php _e( 'Continue' ); ?></a></p><!--<pre><?php printf( __( '%s queries' ), $wpdb->num_queries ); ?><?php printf( __( '%s seconds' ), timer_stop( 0 ) ); ?></pre>--><?php		break;endswitch;endif;?></body></html>
<?php/** * Edit Tags Administration Panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');wp_reset_vars( array('action', 'tag', 'taxonomy', 'post_type') );if ( empty($taxonomy) )	$taxonomy = 'post_tag';if ( !taxonomy_exists($taxonomy) )	wp_die(__('Invalid taxonomy'));$tax = get_taxonomy($taxonomy);$title = $tax->labels->name;if ( empty($post_type) || !in_array( $post_type, get_post_types( array('public' => true) ) ) )	$post_type = 'post';if ( 'post' != $post_type ) {	$parent_file = "edit.php?post_type=$post_type";	$submenu_file = "edit-tags.php?taxonomy=$taxonomy&amp;post_type=$post_type";} else {	$parent_file = 'edit.php';	$submenu_file = "edit-tags.php?taxonomy=$taxonomy";}if ( isset( $_GET['action'] ) && isset($_GET['delete_tags']) && ( 'delete' == $_GET['action'] || 'delete' == $_GET['action2'] ) )	$action = 'bulk-delete';switch($action) {case 'add-tag':	check_admin_referer('add-tag');	if ( !current_user_can($tax->cap->edit_terms) )		wp_die(__('Cheatin&#8217; uh?'));	$ret = wp_insert_term($_POST['tag-name'], $taxonomy, $_POST);	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_original_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	if ( $ret && !is_wp_error( $ret ) )		$location = add_query_arg('message', 1, $location);	else		$location = add_query_arg('message', 4, $location);	wp_redirect($location);	exit;break;case 'delete':	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	if ( !isset( $_GET['tag_ID'] ) ) {		wp_redirect($location);		exit;	}	$tag_ID = (int) $_GET['tag_ID'];	check_admin_referer('delete-tag_' .  $tag_ID);	if ( !current_user_can($tax->cap->delete_terms) )		wp_die(__('Cheatin&#8217; uh?'));	wp_delete_term( $tag_ID, $taxonomy);	$location = add_query_arg('message', 2, $location);	wp_redirect($location);	exit;break;case 'bulk-delete':	check_admin_referer('bulk-tags');	if ( !current_user_can($tax->cap->delete_terms) )		wp_die(__('Cheatin&#8217; uh?'));	$tags = (array) $_GET['delete_tags'];	foreach( $tags as $tag_ID ) {		wp_delete_term( $tag_ID, $taxonomy);	}	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	$location = add_query_arg('message', 6, $location);	wp_redirect($location);	exit;break;case 'edit':	$title = $tax->labels->edit_item;	require_once ('admin-header.php');	$tag_ID = (int) $_GET['tag_ID'];	$tag = get_term($tag_ID, $taxonomy, OBJECT, 'edit');	include('./edit-tag-form.php');break;case 'editedtag':	$tag_ID = (int) $_POST['tag_ID'];	check_admin_referer('update-tag_' . $tag_ID);	if ( !current_user_can($tax->cap->edit_terms) )		wp_die(__('Cheatin&#8217; uh?'));	$ret = wp_update_term($tag_ID, $taxonomy, $_POST);	$location = 'edit-tags.php?taxonomy=' . $taxonomy;	if ( 'post' != $post_type )		$location .= '&post_type=' . $post_type;	if ( $referer = wp_get_original_referer() ) {		if ( false !== strpos($referer, 'edit-tags.php') )			$location = $referer;	}	if ( $ret && !is_wp_error( $ret ) )		$location = add_query_arg('message', 3, $location);	else		$location = add_query_arg('message', 5, $location);	wp_redirect($location);	exit;break;default:if ( ! empty($_GET['_wp_http_referer']) ) {	 wp_redirect( remove_query_arg( array('_wp_http_referer', '_wpnonce'), stripslashes($_SERVER['REQUEST_URI']) ) );	 exit;}wp_enqueue_script('admin-tags');if ( current_user_can($tax->cap->edit_terms) )	wp_enqueue_script('inline-edit-tax');if ( 'category' == $taxonomy || 'post_tag' == $taxonomy ) {	if ( 'category' == $taxonomy )		$help = '<p>' . sprintf(__('You can use categories to define sections of your site and group related posts. The default category is &#8220;Uncategorized&#8221; until you change it in your <a href="%s">writing settings</a>.'), 'options-writing.php') . '</p>';	else		$help = '<p>' . __('You can assign keywords to your posts using Post Tags. Unlike categories, tags have no hierarchy, meaning there&#8217;s no relationship from one tag to another.') . '</p>';	$help .='<p>' . __('What&#8217;s the difference between categories and tags? Normally, tags are ad-hoc keywords that identify important information in your post (names, subjects, etc) that may or may not recur in other posts, while categories are pre-determined sections. If you think of your site like a book, the categories are like the Table of Contents and the tags are like the terms in the index.') . '</p>';	if ( 'category' == $taxonomy )		$help .= '<p>' . __('When adding a new category on this screen, you&#8217;ll fill in the following fields:') . '</p>';	else		$help .= '<p>' . __('When adding a new tag on this screen, you&#8217;ll fill in the following fields:') . '</p>';	$help .= '<ul>' .		'<li>' . __('<strong>Name</strong> - The name is how it appears on your site.') . '</li>';	if ( ! global_terms_enabled() )		$help .= '<li>' . __('<strong>Slug</strong> - The &#8220;slug&#8221; is the URL-friendly version of the name. It is usually all lowercase and contains only letters, numbers, and hyphens.') . '</li>';	if ( 'category' == $taxonomy )		$help .= '<li>' . __('<strong>Parent</strong> - Categories, unlike tags, can have a hierarchy. You might have a Jazz category, and under that have children categories for Bebop and Big Band. Totally optional. To create a subcategory, just choose another category from the Parent dropdown.') . '</li>';	$help .= '<li>' . __('<strong>Description</strong> - The description is not prominent by default; however, some themes may display it.') . '</li>' .		'</ul>' .		'<p>' . __('You can change the display of this screen using the Screen Options tab to set how many items are displayed per screen and to display/hide columns in the table.') . '</p>' .		'<p><strong>' . __('For more information:') . '</strong></p>';	if ( 'category' == $taxonomy )		$help .= '<p>' . __('<a href="http://codex.wordpress.org/Manage_Categories_SubPanel" target="_blank">Categories Documentation</a>') . '</p>';	else		$help .= '<p>' . __('<a href="http://codex.wordpress.org/Post_Tags_SubPanel" target="_blank">Tags Documentation</a>') . '</p>';	$help .= '<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>';	add_contextual_help($current_screen, $help);	unset($help);}require_once ('admin-header.php');$messages[1] = __('Item added.');$messages[2] = __('Item deleted.');$messages[3] = __('Item updated.');$messages[4] = __('Item not added.');$messages[5] = __('Item not updated.');$messages[6] = __('Items deleted.');?><div class="wrap nosubsub"><?php screen_icon(); ?><h2><?php echo esc_html( $title );if ( !empty($_GET['s']) )	printf( '<span class="subtitle">' . __('Search results for &#8220;%s&#8221;') . '</span>', esc_html( stripslashes($_GET['s']) ) ); ?></h2><?php if ( isset($_GET['message']) && ( $msg = (int) $_GET['message'] ) ) : ?><div id="message" class="updated"><p><?php echo $messages[$msg]; ?></p></div><?php $_SERVER['REQUEST_URI'] = remove_query_arg(array('message'), $_SERVER['REQUEST_URI']);endif; ?><div id="ajax-response"></div><form class="search-form" action="" method="get"><input type="hidden" name="taxonomy" value="<?php echo esc_attr($taxonomy); ?>" /><input type="hidden" name="post_type" value="<?php echo esc_attr($post_type); ?>" /><p class="search-box">	<label class="screen-reader-text" for="tag-search-input"><?php echo $tax->labels->search_items; ?>:</label>	<input type="text" id="tag-search-input" name="s" value="<?php _admin_search_query(); ?>" />	<input type="submit" value="<?php echo esc_attr( $tax->labels->search_items );  ?>" class="button" /></p></form><br class="clear" /><div id="col-container"><div id="col-right"><div class="col-wrap"><form id="posts-filter" action="" method="get"><input type="hidden" name="taxonomy" value="<?php echo esc_attr($taxonomy); ?>" /><input type="hidden" name="post_type" value="<?php echo esc_attr($post_type); ?>" /><div class="tablenav"><?php$pagenum = isset( $_GET['pagenum'] ) ? absint( $_GET['pagenum'] ) : 0;if ( empty($pagenum) )	$pagenum = 1;$tags_per_page = (int) get_user_option( 'edit_' .  $taxonomy . '_per_page' );if ( empty($tags_per_page) || $tags_per_page < 1 )	$tags_per_page = 20;if ( 'post_tag' == $taxonomy ) {	$tags_per_page = apply_filters( 'edit_tags_per_page', $tags_per_page );	$tags_per_page = apply_filters( 'tagsperpage', $tags_per_page ); // Old filter} elseif ( 'category' == $taxonomy ) {	$tags_per_page = apply_filters( 'edit_categories_per_page', $tags_per_page ); // Old filter} else {	$tags_per_page = apply_filters( 'edit_' . $taxonomy . '_per_page', $tags_per_page );}$searchterms = !empty($_GET['s']) ? trim(stripslashes($_GET['s'])) : '';$page_links = paginate_links( array(	'base' => add_query_arg( 'pagenum', '%#%' ),	'format' => '',	'prev_text' => __('&laquo;'),	'next_text' => __('&raquo;'),	'total' => ceil(wp_count_terms($taxonomy, array('search' => $searchterms)) / $tags_per_page),	'current' => $pagenum));if ( $page_links )	echo "<div class='tablenav-pages'>$page_links</div>";?><div class="alignleft actions"><select name="action"><option value="" selected="selected"><?php _e('Bulk Actions'); ?></option><option value="delete"><?php _e('Delete'); ?></option></select><input type="submit" value="<?php esc_attr_e('Apply'); ?>" name="doaction" id="doaction" class="button-secondary action" /><?php wp_nonce_field('bulk-tags'); ?></div><br class="clear" /></div><div class="clear"></div><table class="widefat tag fixed" cellspacing="0">	<thead>	<tr><?php print_column_headers($current_screen); ?>	</tr>	</thead>	<tfoot>	<tr><?php print_column_headers($current_screen, false); ?>	</tr>	</tfoot>	<tbody id="the-list" class="list:tag"><?php tag_rows( $pagenum, $tags_per_page, $searchterms, $taxonomy ); ?>	</tbody></table><div class="tablenav"><?phpif ( $page_links )	echo "<div class='tablenav-pages'>$page_links</div>";?><div class="alignleft actions"><select name="action2"><option value="" selected="selected"><?php _e('Bulk Actions'); ?></option><option value="delete"><?php _e('Delete'); ?></option></select><input type="submit" value="<?php esc_attr_e('Apply'); ?>" name="doaction2" id="doaction2" class="button-secondary action" /></div><br class="clear" /></div><br class="clear" /></form><?php if ( 'category' == $taxonomy ) : ?><div class="form-wrap"><p><?php printf(__('<strong>Note:</strong><br />Deleting a category does not delete the posts in that category. Instead, posts that were only assigned to the deleted category are set to the category <strong>%s</strong>.'), apply_filters('the_category', get_cat_name(get_option('default_category')))) ?></p><?php if ( current_user_can( 'import' ) ) : ?><p><?php printf(__('Categories can be selectively converted to tags using the <a href="%s">category to tag converter</a>.'), 'import.php') ?></p><?php endif; ?></div><?php elseif ( 'post_tag' == $taxonomy && current_user_can( 'import' ) ) : ?><div class="form-wrap"><p><?php printf(__('Tags can be selectively converted to categories using the <a href="%s">tag to category converter</a>'), 'import.php') ;?>.</p></div><?php endif;do_action('after-' . $taxonomy . '-table', $taxonomy);?></div></div><!-- /col-right --><div id="col-left"><div class="col-wrap"><?phpif ( !is_taxonomy_hierarchical($taxonomy) ) {	if ( current_user_can( $tax->cap->edit_terms ) )		$tag_cloud = wp_tag_cloud( array( 'taxonomy' => $taxonomy, 'echo' => false, 'link' => 'edit' ) );	else		$tag_cloud = wp_tag_cloud( array( 'taxonomy' => $taxonomy, 'echo' => false ) );	if ( $tag_cloud ) :	?><div class="tagcloud"><h3><?php echo $tax->labels->popular_items; ?></h3><?php echo $tag_cloud; unset( $tag_cloud ); ?></div><?phpendif;}if ( current_user_can($tax->cap->edit_terms) ) {	if ( 'category' == $taxonomy )		do_action('add_category_form_pre', (object)array('parent' => 0) );  // Back compat hook. Deprecated in preference to $taxonomy_pre_add_form	else		do_action('add_tag_form_pre', $taxonomy); // Back compat hook. Applies to all Taxonomies -not- categories	do_action($taxonomy . '_pre_add_form', $taxonomy);?><div class="form-wrap"><h3><?php echo $tax->labels->add_new_item; ?></h3><form id="addtag" method="post" action="edit-tags.php" class="validate"><input type="hidden" name="action" value="add-tag" /><input type="hidden" name="screen" value="<?php echo esc_attr($current_screen->id); ?>" /><input type="hidden" name="taxonomy" value="<?php echo esc_attr($taxonomy); ?>" /><?php wp_nonce_field('add-tag'); ?><div class="form-field form-required">	<label for="tag-name"><?php _ex('Name', 'Taxonomy Name'); ?></label>	<input name="tag-name" id="tag-name" type="text" value="" size="40" aria-required="true" />	<p><?php _e('The name is how it appears on your site.'); ?></p></div><?php if ( ! global_terms_enabled() ) : ?><div class="form-field">	<label for="tag-slug"><?php _ex('Slug', 'Taxonomy Slug'); ?></label>	<input name="slug" id="tag-slug" type="text" value="" size="40" />	<p><?php _e('The &#8220;slug&#8221; is the URL-friendly version of the name. It is usually all lowercase and contains only letters, numbers, and hyphens.'); ?></p></div><?php endif; // is_multisite() ?><?php if ( is_taxonomy_hierarchical($taxonomy) ) : ?><div class="form-field">	<label for="parent"><?php _ex('Parent', 'Taxonomy Parent'); ?></label>	<?php wp_dropdown_categories(array('hide_empty' => 0, 'hide_if_empty' => false, 'taxonomy' => $taxonomy, 'name' => 'parent', 'orderby' => 'name', 'hierarchical' => true, 'show_option_none' => __('None'))); ?>	<?php if ( 'category' == $taxonomy ) : // @todo: Generic text for hierarchical taxonomies ?>		<p><?php _e('Categories, unlike tags, can have a hierarchy. You might have a Jazz category, and under that have children categories for Bebop and Big Band. Totally optional.'); ?></p>	<?php endif; ?></div><?php endif; // is_taxonomy_hierarchical() ?><div class="form-field">	<label for="tag-description"><?php _ex('Description', 'Taxonomy Description'); ?></label>	<textarea name="description" id="tag-description" rows="5" cols="40"></textarea>	<p><?php _e('The description is not prominent by default; however, some themes may show it.'); ?></p></div><?phpif ( ! is_taxonomy_hierarchical($taxonomy) )	do_action('add_tag_form_fields', $taxonomy);do_action($taxonomy . '_add_form_fields', $taxonomy);?><p class="submit"><input type="submit" class="button" name="submit" id="submit" value="<?php echo esc_attr( $tax->labels->add_new_item ); ?>" /></p><?phpif ( 'category' == $taxonomy )	do_action('edit_category_form',	(object)array('parent' => 0) );  // Back compat hook. Deprecated in preference to $taxonomy_add_formelse	do_action('add_tag_form', $taxonomy); // Back compat hook. Applies to all Taxonomies -not- categoriesdo_action($taxonomy . '_add_form', $taxonomy);?></form></div><?php } ?></div></div><!-- /col-left --></div><!-- /col-container --></div><!-- /wrap --><?php inline_edit_term_row('edit-tags', $taxonomy); ?><?phpbreak;}include('./admin-footer.php');?>
<?php/** * Manages WordPress comments * * @package WordPress * @subpackage Comment *//** * Checks whether a comment passes internal checks to be allowed to add. * * If comment moderation is set in the administration, then all comments, * regardless of their type and whitelist will be set to false. If the number of * links exceeds the amount in the administration, then the check fails. If any * of the parameter contents match the blacklist of words, then the check fails. * * If the number of links exceeds the amount in the administration, then the * check fails. If any of the parameter contents match the blacklist of words, * then the check fails. * * If the comment is a trackback and part of the blogroll, then the trackback is * automatically whitelisted. If the comment author was approved before, then * the comment is automatically whitelisted. * * If none of the checks fail, then the failback is to set the check to pass * (return true). * * @since 1.2.0 * @uses $wpdb * * @param string $author Comment Author's name * @param string $email Comment Author's email * @param string $url Comment Author's URL * @param string $comment Comment contents * @param string $user_ip Comment Author's IP address * @param string $user_agent Comment Author's User Agent * @param string $comment_type Comment type, either user submitted comment, *		trackback, or pingback * @return bool Whether the checks passed (true) and the comments should be *		displayed or set to moderated */function check_comment($author, $email, $url, $comment, $user_ip, $user_agent, $comment_type) {	global $wpdb;	if ( 1 == get_option('comment_moderation') )		return false; // If moderation is set to manual	// Check # of external links	if ( $max_links = get_option( 'comment_max_links' ) ) {		$num_links = preg_match_all( '/<a [^>]*href/i', apply_filters( 'comment_text', $comment ), $out );		$num_links = apply_filters( 'comment_max_links_url', $num_links, $url ); // provide for counting of $url as a link		if ( $num_links >= $max_links )			return false;	}	$mod_keys = trim(get_option('moderation_keys'));	if ( !empty($mod_keys) ) {		$words = explode("\n", $mod_keys );		foreach ( (array) $words as $word) {			$word = trim($word);			// Skip empty lines			if ( empty($word) )				continue;			// Do some escaping magic so that '#' chars in the			// spam words don't break things:			$word = preg_quote($word, '#');			$pattern = "#$word#i";			if ( preg_match($pattern, $author) ) return false;			if ( preg_match($pattern, $email) ) return false;			if ( preg_match($pattern, $url) ) return false;			if ( preg_match($pattern, $comment) ) return false;			if ( preg_match($pattern, $user_ip) ) return false;			if ( preg_match($pattern, $user_agent) ) return false;		}	}	// Comment whitelisting:	if ( 1 == get_option('comment_whitelist')) {		if ( 'trackback' == $comment_type || 'pingback' == $comment_type ) { // check if domain is in blogroll			$uri = parse_url($url);			$domain = $uri['host'];			$uri = parse_url( home_url() );			$home_domain = $uri['host'];			if ( $wpdb->get_var($wpdb->prepare("SELECT link_id FROM $wpdb->links WHERE link_url LIKE (%s) LIMIT 1", '%'.$domain.'%')) || $domain == $home_domain )				return true;			else				return false;		} elseif ( $author != '' && $email != '' ) {			// expected_slashed ($author, $email)			$ok_to_comment = $wpdb->get_var("SELECT comment_approved FROM $wpdb->comments WHERE comment_author = '$author' AND comment_author_email = '$email' and comment_approved = '1' LIMIT 1");			if ( ( 1 == $ok_to_comment ) &&				( empty($mod_keys) || false === strpos( $email, $mod_keys) ) )					return true;			else				return false;		} else {			return false;		}	}	return true;}/** * Retrieve the approved comments for post $post_id. * * @since 2.0.0 * @uses $wpdb * * @param int $post_id The ID of the post * @return array $comments The approved comments */function get_approved_comments($post_id) {	global $wpdb;	return $wpdb->get_results($wpdb->prepare("SELECT * FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved = '1' ORDER BY comment_date", $post_id));}/** * Retrieves comment data given a comment ID or comment object. * * If an object is passed then the comment data will be cached and then returned * after being passed through a filter. If the comment is empty, then the global * comment variable will be used, if it is set. * * If the comment is empty, then the global comment variable will be used, if it * is set. * * @since 2.0.0 * @uses $wpdb * * @param object|string|int $comment Comment to retrieve. * @param string $output Optional. OBJECT or ARRAY_A or ARRAY_N constants. * @return object|array|null Depends on $output value. */function &get_comment(&$comment, $output = OBJECT) {	global $wpdb;	$null = null;	if ( empty($comment) ) {		if ( isset($GLOBALS['comment']) )			$_comment = & $GLOBALS['comment'];		else			$_comment = null;	} elseif ( is_object($comment) ) {		wp_cache_add($comment->comment_ID, $comment, 'comment');		$_comment = $comment;	} else {		if ( isset($GLOBALS['comment']) && ($GLOBALS['comment']->comment_ID == $comment) ) {			$_comment = & $GLOBALS['comment'];		} elseif ( ! $_comment = wp_cache_get($comment, 'comment') ) {			$_comment = $wpdb->get_row($wpdb->prepare("SELECT * FROM $wpdb->comments WHERE comment_ID = %d LIMIT 1", $comment));			if ( ! $_comment )				return $null;			wp_cache_add($_comment->comment_ID, $_comment, 'comment');		}	}	$_comment = apply_filters('get_comment', $_comment);	if ( $output == OBJECT ) {		return $_comment;	} elseif ( $output == ARRAY_A ) {		$__comment = get_object_vars($_comment);		return $__comment;	} elseif ( $output == ARRAY_N ) {		$__comment = array_values(get_object_vars($_comment));		return $__comment;	} else {		return $_comment;	}}/** * Retrieve a list of comments. * * The comment list can be for the blog as a whole or for an individual post. * * The list of comment arguments are 'status', 'orderby', 'comment_date_gmt', * 'order', 'number', 'offset', and 'post_id'. * * @since 2.7.0 * @uses $wpdb * * @param mixed $args Optional. Array or string of options to override defaults. * @return array List of comments. */function get_comments( $args = '' ) {	global $wpdb;	$defaults = array(		'author_email' => '',		'ID' => '',		'karma' => '',		'number' => '',		'offset' => '',		'orderby' => '',		'order' => 'DESC',		'parent' => '',		'post_ID' => '',		'post_id' => 0,		'status' => '',		'type' => '',		'user_id' => '',	);	$args = wp_parse_args( $args, $defaults );	extract( $args, EXTR_SKIP );	// $args can be whatever, only use the args defined in defaults to compute the key	$key = md5( serialize( compact(array_keys($defaults)) )  );	$last_changed = wp_cache_get('last_changed', 'comment');	if ( !$last_changed ) {		$last_changed = time();		wp_cache_set('last_changed', $last_changed, 'comment');	}	$cache_key = "get_comments:$key:$last_changed";	if ( $cache = wp_cache_get( $cache_key, 'comment' ) ) {		return $cache;	}	$post_id = absint($post_id);	if ( 'hold' == $status )		$approved = "comment_approved = '0'";	elseif ( 'approve' == $status )		$approved = "comment_approved = '1'";	elseif ( 'spam' == $status )		$approved = "comment_approved = 'spam'";	elseif ( 'trash' == $status )		$approved = "comment_approved = 'trash'";	else		$approved = "( comment_approved = '0' OR comment_approved = '1' )";	$order = ( 'ASC' == $order ) ? 'ASC' : 'DESC';	if ( ! empty( $orderby ) ) {		$ordersby = is_array($orderby) ? $orderby : preg_split('/[,\s]/', $orderby);		$ordersby = array_intersect(			$ordersby,			array(				'comment_agent',				'comment_approved',				'comment_author',				'comment_author_email',				'comment_author_IP',				'comment_author_url',				'comment_content',				'comment_date',				'comment_date_gmt',				'comment_ID',				'comment_karma',				'comment_parent',				'comment_post_ID',				'comment_type',				'user_id',			)		);		$orderby = empty( $ordersby ) ? 'comment_date_gmt' : implode(', ', $ordersby);	} else {		$orderby = 'comment_date_gmt';	}	$number = absint($number);	$offset = absint($offset);	if ( !empty($number) ) {		if ( $offset )			$number = 'LIMIT ' . $offset . ',' . $number;		else			$number = 'LIMIT ' . $number;	} else {		$number = '';	}	$post_where = '';	if ( ! empty($post_id) )		$post_where .= $wpdb->prepare( 'comment_post_ID = %d AND ', $post_id );	if ( '' !== $author_email )		$post_where .= $wpdb->prepare( 'comment_author_email = %s AND ', $author_email );	if ( '' !== $karma )		$post_where .= $wpdb->prepare( 'comment_karma = %d AND ', $karma );	if ( 'comment' == $type )		$post_where .= "comment_type = '' AND ";	elseif ( ! empty( $type ) )		$post_where .= $wpdb->prepare( 'comment_type = %s AND ', $type );	if ( '' !== $parent )		$post_where .= $wpdb->prepare( 'comment_parent = %d AND ', $parent );	if ( '' !== $user_id )		$post_where .= $wpdb->prepare( 'user_id = %d AND ', $user_id );	$comments = $wpdb->get_results( "SELECT * FROM $wpdb->comments WHERE $post_where $approved ORDER BY $orderby $order $number" );	wp_cache_add( $cache_key, $comments, 'comment' );	return $comments;}/** * Retrieve all of the WordPress supported comment statuses. * * Comments have a limited set of valid status values, this provides the comment * status values and descriptions. * * @package WordPress * @subpackage Post * @since 2.7.0 * * @return array List of comment statuses. */function get_comment_statuses( ) {	$status = array(		'hold'		=> __('Unapproved'),		/* translators: comment status  */		'approve'	=> _x('Approved', 'adjective'),		/* translators: comment status */		'spam'		=> _x('Spam', 'adjective'),	);	return $status;}/** * The date the last comment was modified. * * @since 1.5.0 * @uses $wpdb * @global array $cache_lastcommentmodified * * @param string $timezone Which timezone to use in reference to 'gmt', 'blog', *		or 'server' locations. * @return string Last comment modified date. */function get_lastcommentmodified($timezone = 'server') {	global $cache_lastcommentmodified, $wpdb;	if ( isset($cache_lastcommentmodified[$timezone]) )		return $cache_lastcommentmodified[$timezone];	$add_seconds_server = date('Z');	switch ( strtolower($timezone)) {		case 'gmt':			$lastcommentmodified = $wpdb->get_var("SELECT comment_date_gmt FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1");			break;		case 'blog':			$lastcommentmodified = $wpdb->get_var("SELECT comment_date FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1");			break;		case 'server':			$lastcommentmodified = $wpdb->get_var($wpdb->prepare("SELECT DATE_ADD(comment_date_gmt, INTERVAL %s SECOND) FROM $wpdb->comments WHERE comment_approved = '1' ORDER BY comment_date_gmt DESC LIMIT 1", $add_seconds_server));			break;	}	$cache_lastcommentmodified[$timezone] = $lastcommentmodified;	return $lastcommentmodified;}/** * The amount of comments in a post or total comments. * * A lot like {@link wp_count_comments()}, in that they both return comment * stats (albeit with different types). The {@link wp_count_comments()} actual * caches, but this function does not. * * @since 2.0.0 * @uses $wpdb * * @param int $post_id Optional. Comment amount in post if > 0, else total comments blog wide. * @return array The amount of spam, approved, awaiting moderation, and total comments. */function get_comment_count( $post_id = 0 ) {	global $wpdb;	$post_id = (int) $post_id;	$where = '';	if ( $post_id > 0 ) {		$where = $wpdb->prepare("WHERE comment_post_ID = %d", $post_id);	}	$totals = (array) $wpdb->get_results("		SELECT comment_approved, COUNT( * ) AS total		FROM {$wpdb->comments}		{$where}		GROUP BY comment_approved	", ARRAY_A);	$comment_count = array(		"approved"              => 0,		"awaiting_moderation"   => 0,		"spam"                  => 0,		"total_comments"        => 0	);	foreach ( $totals as $row ) {		switch ( $row['comment_approved'] ) {			case 'spam':				$comment_count['spam'] = $row['total'];				$comment_count["total_comments"] += $row['total'];				break;			case 1:				$comment_count['approved'] = $row['total'];				$comment_count['total_comments'] += $row['total'];				break;			case 0:				$comment_count['awaiting_moderation'] = $row['total'];				$comment_count['total_comments'] += $row['total'];				break;			default:				break;		}	}	return $comment_count;}//// Comment meta functions///** * Add meta data field to a comment. * * @since 2.9.0 * @uses add_metadata * @link http://codex.wordpress.org/Function_Reference/add_comment_meta * * @param int $comment_id Comment ID. * @param string $key Metadata name. * @param mixed $value Metadata value. * @param bool $unique Optional, default is false. Whether the same key should not be added. * @return bool False for failure. True for success. */function add_comment_meta($comment_id, $meta_key, $meta_value, $unique = false) {	return add_metadata('comment', $comment_id, $meta_key, $meta_value, $unique);}/** * Remove metadata matching criteria from a comment. * * You can match based on the key, or key and value. Removing based on key and * value, will keep from removing duplicate metadata with the same key. It also * allows removing all metadata matching key, if needed. * * @since 2.9.0 * @uses delete_metadata * @link http://codex.wordpress.org/Function_Reference/delete_comment_meta * * @param int $comment_id comment ID * @param string $meta_key Metadata name. * @param mixed $meta_value Optional. Metadata value. * @return bool False for failure. True for success. */function delete_comment_meta($comment_id, $meta_key, $meta_value = '') {	return delete_metadata('comment', $comment_id, $meta_key, $meta_value);}/** * Retrieve comment meta field for a comment. * * @since 2.9.0 * @uses get_metadata * @link http://codex.wordpress.org/Function_Reference/get_comment_meta * * @param int $comment_id Comment ID. * @param string $key The meta key to retrieve. * @param bool $single Whether to return a single value. * @return mixed Will be an array if $single is false. Will be value of meta data field if $single *  is true. */function get_comment_meta($comment_id, $key, $single = false) {	return get_metadata('comment', $comment_id, $key, $single);}/** * Update comment meta field based on comment ID. * * Use the $prev_value parameter to differentiate between meta fields with the * same key and comment ID. * * If the meta field for the comment does not exist, it will be added. * * @since 2.9.0 * @uses update_metadata * @link http://codex.wordpress.org/Function_Reference/update_comment_meta * * @param int $comment_id Comment ID. * @param string $key Metadata key. * @param mixed $value Metadata value. * @param mixed $prev_value Optional. Previous value to check before removing. * @return bool False on failure, true if success. */function update_comment_meta($comment_id, $meta_key, $meta_value, $prev_value = '') {	return update_metadata('comment', $comment_id, $meta_key, $meta_value, $prev_value);}/** * Sanitizes the cookies sent to the user already. * * Will only do anything if the cookies have already been created for the user. * Mostly used after cookies had been sent to use elsewhere. * * @since 2.0.4 */function sanitize_comment_cookies() {	if ( isset($_COOKIE['comment_author_'.COOKIEHASH]) ) {		$comment_author = apply_filters('pre_comment_author_name', $_COOKIE['comment_author_'.COOKIEHASH]);		$comment_author = stripslashes($comment_author);		$comment_author = esc_attr($comment_author);		$_COOKIE['comment_author_'.COOKIEHASH] = $comment_author;	}	if ( isset($_COOKIE['comment_author_email_'.COOKIEHASH]) ) {		$comment_author_email = apply_filters('pre_comment_author_email', $_COOKIE['comment_author_email_'.COOKIEHASH]);		$comment_author_email = stripslashes($comment_author_email);		$comment_author_email = esc_attr($comment_author_email);		$_COOKIE['comment_author_email_'.COOKIEHASH] = $comment_author_email;	}	if ( isset($_COOKIE['comment_author_url_'.COOKIEHASH]) ) {		$comment_author_url = apply_filters('pre_comment_author_url', $_COOKIE['comment_author_url_'.COOKIEHASH]);		$comment_author_url = stripslashes($comment_author_url);		$_COOKIE['comment_author_url_'.COOKIEHASH] = $comment_author_url;	}}/** * Validates whether this comment is allowed to be made. * * @since 2.0.0 * @uses $wpdb * @uses apply_filters() Calls 'pre_comment_approved' hook on the type of comment * @uses apply_filters() Calls 'comment_duplicate_trigger' hook on commentdata. * @uses do_action() Calls 'check_comment_flood' hook on $comment_author_IP, $comment_author_email, and $comment_date_gmt * * @param array $commentdata Contains information on the comment * @return mixed Signifies the approval status (0|1|'spam') */function wp_allow_comment($commentdata) {	global $wpdb;	extract($commentdata, EXTR_SKIP);	// Simple duplicate check	// expected_slashed ($comment_post_ID, $comment_author, $comment_author_email, $comment_content)	$dupe = "SELECT comment_ID FROM $wpdb->comments WHERE comment_post_ID = '$comment_post_ID' AND comment_approved != 'trash' AND ( comment_author = '$comment_author' ";	if ( $comment_author_email )		$dupe .= "OR comment_author_email = '$comment_author_email' ";	$dupe .= ") AND comment_content = '$comment_content' LIMIT 1";	if ( $wpdb->get_var($dupe) ) {		do_action( 'comment_duplicate_trigger', $commentdata );		if ( defined('DOING_AJAX') )			die( __('Duplicate comment detected; it looks as though you&#8217;ve already said that!') );		wp_die( __('Duplicate comment detected; it looks as though you&#8217;ve already said that!') );	}	do_action( 'check_comment_flood', $comment_author_IP, $comment_author_email, $comment_date_gmt );	if ( isset($user_id) && $user_id) {		$userdata = get_userdata($user_id);		$user = new WP_User($user_id);		$post_author = $wpdb->get_var($wpdb->prepare("SELECT post_author FROM $wpdb->posts WHERE ID = %d LIMIT 1", $comment_post_ID));	}	if ( isset($userdata) && ( $user_id == $post_author || $user->has_cap('moderate_comments') ) ) {		// The author and the admins get respect.		$approved = 1;	 } else {		// Everyone else's comments will be checked.		if ( check_comment($comment_author, $comment_author_email, $comment_author_url, $comment_content, $comment_author_IP, $comment_agent, $comment_type) )			$approved = 1;		else			$approved = 0;		if ( wp_blacklist_check($comment_author, $comment_author_email, $comment_author_url, $comment_content, $comment_author_IP, $comment_agent) )			$approved = 'spam';	}	$approved = apply_filters('pre_comment_approved', $approved);	return $approved;}/** * Check whether comment flooding is occurring. * * Won't run, if current user can manage options, so to not block * administrators. * * @since 2.3.0 * @uses $wpdb * @uses apply_filters() Calls 'comment_flood_filter' filter with first *		parameter false, last comment timestamp, new comment timestamp. * @uses do_action() Calls 'comment_flood_trigger' action with parameters with *		last comment timestamp and new comment timestamp. * * @param string $ip Comment IP. * @param string $email Comment author email address. * @param string $date MySQL time string. */function check_comment_flood_db( $ip, $email, $date ) {	global $wpdb;	if ( current_user_can( 'manage_options' ) )		return; // don't throttle admins	$hour_ago = gmdate( 'Y-m-d H:i:s', time() - 3600 );	if ( $lasttime = $wpdb->get_var( $wpdb->prepare( "SELECT `comment_date_gmt` FROM `$wpdb->comments` WHERE `comment_date_gmt` >= %s AND ( `comment_author_IP` = %s OR `comment_author_email` = %s ) ORDER BY `comment_date_gmt` DESC LIMIT 1", $hour_ago, $ip, $email ) ) ) {		$time_lastcomment = mysql2date('U', $lasttime, false);		$time_newcomment  = mysql2date('U', $date, false);		$flood_die = apply_filters('comment_flood_filter', false, $time_lastcomment, $time_newcomment);		if ( $flood_die ) {			do_action('comment_flood_trigger', $time_lastcomment, $time_newcomment);			if ( defined('DOING_AJAX') )				die( __('You are posting comments too quickly.  Slow down.') );			wp_die( __('You are posting comments too quickly.  Slow down.'), '', array('response' => 403) );		}	}}/** * Separates an array of comments into an array keyed by comment_type. * * @since 2.7.0 * * @param array $comments Array of comments * @return array Array of comments keyed by comment_type. */function &separate_comments(&$comments) {	$comments_by_type = array('comment' => array(), 'trackback' => array(), 'pingback' => array(), 'pings' => array());	$count = count($comments);	for ( $i = 0; $i < $count; $i++ ) {		$type = $comments[$i]->comment_type;		if ( empty($type) )			$type = 'comment';		$comments_by_type[$type][] = &$comments[$i];		if ( 'trackback' == $type || 'pingback' == $type )			$comments_by_type['pings'][] = &$comments[$i];	}	return $comments_by_type;}/** * Calculate the total number of comment pages. * * @since 2.7.0 * @uses get_query_var() Used to fill in the default for $per_page parameter. * @uses get_option() Used to fill in defaults for parameters. * @uses Walker_Comment * * @param array $comments Optional array of comment objects.  Defaults to $wp_query->comments * @param int $per_page Optional comments per page. * @param boolean $threaded Optional control over flat or threaded comments. * @return int Number of comment pages. */function get_comment_pages_count( $comments = null, $per_page = null, $threaded = null ) {	global $wp_query;	if ( null === $comments && null === $per_page && null === $threaded && !empty($wp_query->max_num_comment_pages) )		return $wp_query->max_num_comment_pages;	if ( !$comments || !is_array($comments) )		$comments = $wp_query->comments;	if ( empty($comments) )		return 0;	if ( !isset($per_page) )		$per_page = (int) get_query_var('comments_per_page');	if ( 0 === $per_page )		$per_page = (int) get_option('comments_per_page');	if ( 0 === $per_page )		return 1;	if ( !isset($threaded) )		$threaded = get_option('thread_comments');	if ( $threaded ) {		$walker = new Walker_Comment;		$count = ceil( $walker->get_number_of_root_elements( $comments ) / $per_page );	} else {		$count = ceil( count( $comments ) / $per_page );	}	return $count;}/** * Calculate what page number a comment will appear on for comment paging. * * @since 2.7.0 * @uses get_comment() Gets the full comment of the $comment_ID parameter. * @uses get_option() Get various settings to control function and defaults. * @uses get_page_of_comment() Used to loop up to top level comment. * * @param int $comment_ID Comment ID. * @param array $args Optional args. * @return int|null Comment page number or null on error. */function get_page_of_comment( $comment_ID, $args = array() ) {	global $wpdb;	if ( !$comment = get_comment( $comment_ID ) )		return;	$defaults = array( 'type' => 'all', 'page' => '', 'per_page' => '', 'max_depth' => '' );	$args = wp_parse_args( $args, $defaults );	if ( '' === $args['per_page'] && get_option('page_comments') )		$args['per_page'] = get_query_var('comments_per_page');	if ( empty($args['per_page']) ) {		$args['per_page'] = 0;		$args['page'] = 0;	}	if ( $args['per_page'] < 1 )		return 1;	if ( '' === $args['max_depth'] ) {		if ( get_option('thread_comments') )			$args['max_depth'] = get_option('thread_comments_depth');		else			$args['max_depth'] = -1;	}	// Find this comment's top level parent if threading is enabled	if ( $args['max_depth'] > 1 && 0 != $comment->comment_parent )		return get_page_of_comment( $comment->comment_parent, $args );	$allowedtypes = array(		'comment' => '',		'pingback' => 'pingback',		'trackback' => 'trackback',	);	$comtypewhere = ( 'all' != $args['type'] && isset($allowedtypes[$args['type']]) ) ? " AND comment_type = '" . $allowedtypes[$args['type']] . "'" : '';	// Count comments older than this one	$oldercoms = $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(comment_ID) FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_parent = 0 AND comment_approved = '1' AND comment_date_gmt < '%s'" . $comtypewhere, $comment->comment_post_ID, $comment->comment_date_gmt ) );	// No older comments? Then it's page #1.	if ( 0 == $oldercoms )		return 1;	// Divide comments older than this one by comments per page to get this comment's page number	return ceil( ( $oldercoms + 1 ) / $args['per_page'] );}/** * Does comment contain blacklisted characters or words. * * @since 1.5.0 * @uses do_action() Calls 'wp_blacklist_check' hook for all parameters. * * @param string $author The author of the comment * @param string $email The email of the comment * @param string $url The url used in the comment * @param string $comment The comment content * @param string $user_ip The comment author IP address * @param string $user_agent The author's browser user agent * @return bool True if comment contains blacklisted content, false if comment does not */function wp_blacklist_check($author, $email, $url, $comment, $user_ip, $user_agent) {	do_action('wp_blacklist_check', $author, $email, $url, $comment, $user_ip, $user_agent);	$mod_keys = trim( get_option('blacklist_keys') );	if ( '' == $mod_keys )		return false; // If moderation keys are empty	$words = explode("\n", $mod_keys );	foreach ( (array) $words as $word ) {		$word = trim($word);		// Skip empty lines		if ( empty($word) ) { continue; }		// Do some escaping magic so that '#' chars in the		// spam words don't break things:		$word = preg_quote($word, '#');		$pattern = "#$word#i";		if (			   preg_match($pattern, $author)			|| preg_match($pattern, $email)			|| preg_match($pattern, $url)			|| preg_match($pattern, $comment)			|| preg_match($pattern, $user_ip)			|| preg_match($pattern, $user_agent)		 )			return true;	}	return false;}/** * Retrieve total comments for blog or single post. * * The properties of the returned object contain the 'moderated', 'approved', * and spam comments for either the entire blog or single post. Those properties * contain the amount of comments that match the status. The 'total_comments' * property contains the integer of total comments. * * The comment stats are cached and then retrieved, if they already exist in the * cache. * * @since 2.5.0 * * @param int $post_id Optional. Post ID. * @return object Comment stats. */function wp_count_comments( $post_id = 0 ) {	global $wpdb;	$post_id = (int) $post_id;	$stats = apply_filters('wp_count_comments', array(), $post_id);	if ( !empty($stats) )		return $stats;	$count = wp_cache_get("comments-{$post_id}", 'counts');	if ( false !== $count )		return $count;	$where = '';	if ( $post_id > 0 )		$where = $wpdb->prepare( "WHERE comment_post_ID = %d", $post_id );	$count = $wpdb->get_results( "SELECT comment_approved, COUNT( * ) AS num_comments FROM {$wpdb->comments} {$where} GROUP BY comment_approved", ARRAY_A );	$total = 0;	$approved = array('0' => 'moderated', '1' => 'approved', 'spam' => 'spam', 'trash' => 'trash', 'post-trashed' => 'post-trashed');	$known_types = array_keys( $approved );	foreach ( (array) $count as $row ) {		// Don't count post-trashed toward totals		if ( 'post-trashed' != $row['comment_approved'] && 'trash' != $row['comment_approved'] )			$total += $row['num_comments'];		if ( in_array( $row['comment_approved'], $known_types ) )			$stats[$approved[$row['comment_approved']]] = $row['num_comments'];	}	$stats['total_comments'] = $total;	foreach ( $approved as $key ) {		if ( empty($stats[$key]) )			$stats[$key] = 0;	}	$stats = (object) $stats;	wp_cache_set("comments-{$post_id}", $stats, 'counts');	return $stats;}/** * Trashes or deletes a comment. * * The comment is moved to trash instead of permanently deleted unless trash is * disabled, item is already in the trash, or $force_delete is true. * * The post comment count will be updated if the comment was approved and has a * post ID available. * * @since 2.0.0 * @uses $wpdb * @uses do_action() Calls 'delete_comment' hook on comment ID * @uses do_action() Calls 'deleted_comment' hook on comment ID after deletion, on success * @uses do_action() Calls 'wp_set_comment_status' hook on comment ID with 'delete' set for the second parameter * @uses wp_transition_comment_status() Passes new and old comment status along with $comment object * * @param int $comment_id Comment ID * @param bool $force_delete Whether to bypass trash and force deletion. Default is false. * @return bool False if delete comment query failure, true on success. */function wp_delete_comment($comment_id, $force_delete = false) {	global $wpdb;	if (!$comment = get_comment($comment_id))		return false;	if ( !$force_delete && EMPTY_TRASH_DAYS && !in_array( wp_get_comment_status($comment_id), array( 'trash', 'spam' ) ) )		return wp_trash_comment($comment_id);	do_action('delete_comment', $comment_id);	// Move children up a level.	$children = $wpdb->get_col( $wpdb->prepare("SELECT comment_ID FROM $wpdb->comments WHERE comment_parent = %d", $comment_id) );	if ( !empty($children) ) {		$wpdb->update($wpdb->comments, array('comment_parent' => $comment->comment_parent), array('comment_parent' => $comment_id));		clean_comment_cache($children);	}	// Delete metadata	$meta_ids = $wpdb->get_col( $wpdb->prepare( "SELECT meta_id FROM $wpdb->commentmeta WHERE comment_id = %d ", $comment_id ) );	if ( !empty($meta_ids) ) {		do_action( 'delete_commentmeta', $meta_ids );		$in_meta_ids = "'" . implode("', '", $meta_ids) . "'";		$wpdb->query( "DELETE FROM $wpdb->commentmeta WHERE meta_id IN ($in_meta_ids)" );		do_action( 'deleted_commentmeta', $meta_ids );	}	if ( ! $wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->comments WHERE comment_ID = %d LIMIT 1", $comment_id) ) )		return false;	do_action('deleted_comment', $comment_id);	$post_id = $comment->comment_post_ID;	if ( $post_id && $comment->comment_approved == 1 )		wp_update_comment_count($post_id);	clean_comment_cache($comment_id);	do_action('wp_set_comment_status', $comment_id, 'delete');	wp_transition_comment_status('delete', $comment->comment_approved, $comment);	return true;}/** * Moves a comment to the Trash * * If trash is disabled, comment is permanently deleted. * * @since 2.9.0 * @uses do_action() on 'trash_comment' before trashing * @uses do_action() on 'trashed_comment' after trashing * @uses wp_delete_comment() if trash is disabled * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_trash_comment($comment_id) {	if ( !EMPTY_TRASH_DAYS )		return wp_delete_comment($comment_id, true);	if ( !$comment = get_comment($comment_id) )		return false;	do_action('trash_comment', $comment_id);	if ( wp_set_comment_status($comment_id, 'trash') ) {		add_comment_meta($comment_id, '_wp_trash_meta_status', $comment->comment_approved);		add_comment_meta($comment_id, '_wp_trash_meta_time', time() );		do_action('trashed_comment', $comment_id);		return true;	}	return false;}/** * Removes a comment from the Trash * * @since 2.9.0 * @uses do_action() on 'untrash_comment' before untrashing * @uses do_action() on 'untrashed_comment' after untrashing * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_untrash_comment($comment_id) {	if ( ! (int)$comment_id )		return false;	do_action('untrash_comment', $comment_id);	$status = (string) get_comment_meta($comment_id, '_wp_trash_meta_status', true);	if ( empty($status) )		$status = '0';	if ( wp_set_comment_status($comment_id, $status) ) {		delete_comment_meta($comment_id, '_wp_trash_meta_time');		delete_comment_meta($comment_id, '_wp_trash_meta_status');		do_action('untrashed_comment', $comment_id);		return true;	}	return false;}/** * Marks a comment as Spam * * @since 2.9.0 * @uses do_action() on 'spam_comment' before spamming * @uses do_action() on 'spammed_comment' after spamming * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_spam_comment($comment_id) {	if ( !$comment = get_comment($comment_id) )		return false;	do_action('spam_comment', $comment_id);	if ( wp_set_comment_status($comment_id, 'spam') ) {		add_comment_meta($comment_id, '_wp_trash_meta_status', $comment->comment_approved);		do_action('spammed_comment', $comment_id);		return true;	}	return false;}/** * Removes a comment from the Spam * * @since 2.9.0 * @uses do_action() on 'unspam_comment' before unspamming * @uses do_action() on 'unspammed_comment' after unspamming * * @param int $comment_id Comment ID. * @return mixed False on failure */function wp_unspam_comment($comment_id) {	if ( ! (int)$comment_id )		return false;	do_action('unspam_comment', $comment_id);	$status = (string) get_comment_meta($comment_id, '_wp_trash_meta_status', true);	if ( empty($status) )		$status = '0';	if ( wp_set_comment_status($comment_id, $status) ) {		delete_comment_meta($comment_id, '_wp_trash_meta_status');		do_action('unspammed_comment', $comment_id);		return true;	}	return false;}/** * The status of a comment by ID. * * @since 1.0.0 * * @param int $comment_id Comment ID * @return string|bool Status might be 'trash', 'approved', 'unapproved', 'spam'. False on failure. */function wp_get_comment_status($comment_id) {	$comment = get_comment($comment_id);	if ( !$comment )		return false;	$approved = $comment->comment_approved;	if ( $approved == NULL )		return false;	elseif ( $approved == '1' )		return 'approved';	elseif ( $approved == '0' )		return 'unapproved';	elseif ( $approved == 'spam' )		return 'spam';	elseif ( $approved == 'trash' )		return 'trash';	else		return false;}/** * Call hooks for when a comment status transition occurs. * * Calls hooks for comment status transitions. If the new comment status is not the same * as the previous comment status, then two hooks will be ran, the first is * 'transition_comment_status' with new status, old status, and comment data. The * next action called is 'comment_OLDSTATUS_to_NEWSTATUS' the NEWSTATUS is the * $new_status parameter and the OLDSTATUS is $old_status parameter; it has the * comment data. * * The final action will run whether or not the comment statuses are the same. The * action is named 'comment_NEWSTATUS_COMMENTTYPE', NEWSTATUS is from the $new_status * parameter and COMMENTTYPE is comment_type comment data. * * @since 2.7.0 * * @param string $new_status New comment status. * @param string $old_status Previous comment status. * @param object $comment Comment data. */function wp_transition_comment_status($new_status, $old_status, $comment) {	// Translate raw statuses to human readable formats for the hooks	// This is not a complete list of comment status, it's only the ones that need to be renamed	$comment_statuses = array(		0         => 'unapproved',		'hold'    => 'unapproved', // wp_set_comment_status() uses "hold"		1         => 'approved',		'approve' => 'approved', // wp_set_comment_status() uses "approve"	);	if ( isset($comment_statuses[$new_status]) ) $new_status = $comment_statuses[$new_status];	if ( isset($comment_statuses[$old_status]) ) $old_status = $comment_statuses[$old_status];	// Call the hooks	if ( $new_status != $old_status ) {		do_action('transition_comment_status', $new_status, $old_status, $comment);		do_action("comment_${old_status}_to_$new_status", $comment);	}	do_action("comment_${new_status}_$comment->comment_type", $comment->comment_ID, $comment);}/** * Get current commenter's name, email, and URL. * * Expects cookies content to already be sanitized. User of this function might * wish to recheck the returned array for validity. * * @see sanitize_comment_cookies() Use to sanitize cookies * * @since 2.0.4 * * @return array Comment author, email, url respectively. */function wp_get_current_commenter() {	// Cookies should already be sanitized.	$comment_author = '';	if ( isset($_COOKIE['comment_author_'.COOKIEHASH]) )		$comment_author = $_COOKIE['comment_author_'.COOKIEHASH];	$comment_author_email = '';	if ( isset($_COOKIE['comment_author_email_'.COOKIEHASH]) )		$comment_author_email = $_COOKIE['comment_author_email_'.COOKIEHASH];	$comment_author_url = '';	if ( isset($_COOKIE['comment_author_url_'.COOKIEHASH]) )		$comment_author_url = $_COOKIE['comment_author_url_'.COOKIEHASH];	return compact('comment_author', 'comment_author_email', 'comment_author_url');}/** * Inserts a comment to the database. * * The available comment data key names are 'comment_author_IP', 'comment_date', * 'comment_date_gmt', 'comment_parent', 'comment_approved', and 'user_id'. * * @since 2.0.0 * @uses $wpdb * * @param array $commentdata Contains information on the comment. * @return int The new comment's ID. */function wp_insert_comment($commentdata) {	global $wpdb;	extract(stripslashes_deep($commentdata), EXTR_SKIP);	if ( ! isset($comment_author_IP) )		$comment_author_IP = '';	if ( ! isset($comment_date) )		$comment_date = current_time('mysql');	if ( ! isset($comment_date_gmt) )		$comment_date_gmt = get_gmt_from_date($comment_date);	if ( ! isset($comment_parent) )		$comment_parent = 0;	if ( ! isset($comment_approved) )		$comment_approved = 1;	if ( ! isset($comment_karma) )		$comment_karma = 0;	if ( ! isset($user_id) )		$user_id = 0;	if ( ! isset($comment_type) )		$comment_type = '';	$data = compact('comment_post_ID', 'comment_author', 'comment_author_email', 'comment_author_url', 'comment_author_IP', 'comment_date', 'comment_date_gmt', 'comment_content', 'comment_karma', 'comment_approved', 'comment_agent', 'comment_type', 'comment_parent', 'user_id');	$wpdb->insert($wpdb->comments, $data);	$id = (int) $wpdb->insert_id;	if ( $comment_approved == 1 )		wp_update_comment_count($comment_post_ID);	$comment = get_comment($id);	do_action('wp_insert_comment', $id, $comment);	return $id;}/** * Filters and sanitizes comment data. * * Sets the comment data 'filtered' field to true when finished. This can be * checked as to whether the comment should be filtered and to keep from * filtering the same comment more than once. * * @since 2.0.0 * @uses apply_filters() Calls 'pre_user_id' hook on comment author's user ID * @uses apply_filters() Calls 'pre_comment_user_agent' hook on comment author's user agent * @uses apply_filters() Calls 'pre_comment_author_name' hook on comment author's name * @uses apply_filters() Calls 'pre_comment_content' hook on the comment's content * @uses apply_filters() Calls 'pre_comment_user_ip' hook on comment author's IP * @uses apply_filters() Calls 'pre_comment_author_url' hook on comment author's URL * @uses apply_filters() Calls 'pre_comment_author_email' hook on comment author's email address * * @param array $commentdata Contains information on the comment. * @return array Parsed comment information. */function wp_filter_comment($commentdata) {	if ( isset($commentdata['user_ID']) )		$commentdata['user_id'] = apply_filters('pre_user_id', $commentdata['user_ID']);	elseif ( isset($commentdata['user_id']) )		$commentdata['user_id'] = apply_filters('pre_user_id', $commentdata['user_id']);	$commentdata['comment_agent']        = apply_filters('pre_comment_user_agent', ( isset( $commentdata['comment_agent'] ) ? $commentdata['comment_agent'] : '' ) );	$commentdata['comment_author']       = apply_filters('pre_comment_author_name', $commentdata['comment_author']);	$commentdata['comment_content']      = apply_filters('pre_comment_content', $commentdata['comment_content']);	$commentdata['comment_author_IP']    = apply_filters('pre_comment_user_ip', $commentdata['comment_author_IP']);	$commentdata['comment_author_url']   = apply_filters('pre_comment_author_url', $commentdata['comment_author_url']);	$commentdata['comment_author_email'] = apply_filters('pre_comment_author_email', $commentdata['comment_author_email']);	$commentdata['filtered'] = true;	return $commentdata;}/** * Whether comment should be blocked because of comment flood. * * @since 2.1.0 * * @param bool $block Whether plugin has already blocked comment. * @param int $time_lastcomment Timestamp for last comment. * @param int $time_newcomment Timestamp for new comment. * @return bool Whether comment should be blocked. */function wp_throttle_comment_flood($block, $time_lastcomment, $time_newcomment) {	if ( $block ) // a plugin has already blocked... we'll let that decision stand		return $block;	if ( ($time_newcomment - $time_lastcomment) < 15 )		return true;	return false;}/** * Adds a new comment to the database. * * Filters new comment to ensure that the fields are sanitized and valid before * inserting comment into database. Calls 'comment_post' action with comment ID * and whether comment is approved by WordPress. Also has 'preprocess_comment' * filter for processing the comment data before the function handles it. * * @since 1.5.0 * @uses apply_filters() Calls 'preprocess_comment' hook on $commentdata parameter array before processing * @uses do_action() Calls 'comment_post' hook on $comment_ID returned from adding the comment and if the comment was approved. * @uses wp_filter_comment() Used to filter comment before adding comment. * @uses wp_allow_comment() checks to see if comment is approved. * @uses wp_insert_comment() Does the actual comment insertion to the database. * * @param array $commentdata Contains information on the comment. * @return int The ID of the comment after adding. */function wp_new_comment( $commentdata ) {	$commentdata = apply_filters('preprocess_comment', $commentdata);	$commentdata['comment_post_ID'] = (int) $commentdata['comment_post_ID'];	if ( isset($commentdata['user_ID']) )		$commentdata['user_id'] = $commentdata['user_ID'] = (int) $commentdata['user_ID'];	elseif ( isset($commentdata['user_id']) )		$commentdata['user_id'] = (int) $commentdata['user_id'];	$commentdata['comment_parent'] = isset($commentdata['comment_parent']) ? absint($commentdata['comment_parent']) : 0;	$parent_status = ( 0 < $commentdata['comment_parent'] ) ? wp_get_comment_status($commentdata['comment_parent']) : '';	$commentdata['comment_parent'] = ( 'approved' == $parent_status || 'unapproved' == $parent_status ) ? $commentdata['comment_parent'] : 0;	$commentdata['comment_author_IP'] = preg_replace( '/[^0-9a-fA-F:., ]/', '',$_SERVER['REMOTE_ADDR'] );	$commentdata['comment_agent']     = substr($_SERVER['HTTP_USER_AGENT'], 0, 254);	$commentdata['comment_date']     = current_time('mysql');	$commentdata['comment_date_gmt'] = current_time('mysql', 1);	$commentdata = wp_filter_comment($commentdata);	$commentdata['comment_approved'] = wp_allow_comment($commentdata);	$comment_ID = wp_insert_comment($commentdata);	do_action('comment_post', $comment_ID, $commentdata['comment_approved']);	if ( 'spam' !== $commentdata['comment_approved'] ) { // If it's spam save it silently for later crunching		if ( '0' == $commentdata['comment_approved'] )			wp_notify_moderator($comment_ID);		$post = &get_post($commentdata['comment_post_ID']); // Don't notify if it's your own comment		if ( get_option('comments_notify') && $commentdata['comment_approved'] && ( ! isset( $commentdata['user_id'] ) || $post->post_author != $commentdata['user_id'] ) )			wp_notify_postauthor($comment_ID, empty( $commentdata['comment_type'] ) ? $commentdata['comment_type'] : '' );	}	return $comment_ID;}/** * Sets the status of a comment. * * The 'wp_set_comment_status' action is called after the comment is handled and * will only be called, if the comment status is either 'hold', 'approve', or * 'spam'. If the comment status is not in the list, then false is returned and * if the status is 'delete', then the comment is deleted without calling the * action. * * @since 1.0.0 * @uses wp_transition_comment_status() Passes new and old comment status along with $comment object * * @param int $comment_id Comment ID. * @param string $comment_status New comment status, either 'hold', 'approve', 'spam', or 'delete'. * @param bool $wp_error Whether to return a WP_Error object if there is a failure. Default is false. * @return bool False on failure or deletion and true on success. */function wp_set_comment_status($comment_id, $comment_status, $wp_error = false) {	global $wpdb;	$status = '0';	switch ( $comment_status ) {		case 'hold':		case '0':			$status = '0';			break;		case 'approve':		case '1':			$status = '1';			if ( get_option('comments_notify') ) {				$comment = get_comment($comment_id);				wp_notify_postauthor($comment_id, $comment->comment_type);			}			break;		case 'spam':			$status = 'spam';			break;		case 'trash':			$status = 'trash';			break;		default:			return false;	}	$comment_old = wp_clone(get_comment($comment_id));	if ( !$wpdb->update( $wpdb->comments, array('comment_approved' => $status), array('comment_ID' => $comment_id) ) ) {		if ( $wp_error )			return new WP_Error('db_update_error', __('Could not update comment status'), $wpdb->last_error);		else			return false;	}	clean_comment_cache($comment_id);	$comment = get_comment($comment_id);	do_action('wp_set_comment_status', $comment_id, $comment_status);	wp_transition_comment_status($comment_status, $comment_old->comment_approved, $comment);	wp_update_comment_count($comment->comment_post_ID);	return true;}/** * Updates an existing comment in the database. * * Filters the comment and makes sure certain fields are valid before updating. * * @since 2.0.0 * @uses $wpdb * @uses wp_transition_comment_status() Passes new and old comment status along with $comment object * * @param array $commentarr Contains information on the comment. * @return int Comment was updated if value is 1, or was not updated if value is 0. */function wp_update_comment($commentarr) {	global $wpdb;	// First, get all of the original fields	$comment = get_comment($commentarr['comment_ID'], ARRAY_A);	// Escape data pulled from DB.	$comment = esc_sql($comment);	$old_status = $comment['comment_approved'];	// Merge old and new fields with new fields overwriting old ones.	$commentarr = array_merge($comment, $commentarr);	$commentarr = wp_filter_comment( $commentarr );	// Now extract the merged array.	extract(stripslashes_deep($commentarr), EXTR_SKIP);	$comment_content = apply_filters('comment_save_pre', $comment_content);	$comment_date_gmt = get_gmt_from_date($comment_date);	if ( !isset($comment_approved) )		$comment_approved = 1;	else if ( 'hold' == $comment_approved )		$comment_approved = 0;	else if ( 'approve' == $comment_approved )		$comment_approved = 1;	$data = compact('comment_content', 'comment_author', 'comment_author_email', 'comment_approved', 'comment_karma', 'comment_author_url', 'comment_date', 'comment_date_gmt');	$rval = $wpdb->update( $wpdb->comments, $data, compact( 'comment_ID' ) );	clean_comment_cache($comment_ID);	wp_update_comment_count($comment_post_ID);	do_action('edit_comment', $comment_ID);	$comment = get_comment($comment_ID);	wp_transition_comment_status($comment->comment_approved, $old_status, $comment);	return $rval;}/** * Whether to defer comment counting. * * When setting $defer to true, all post comment counts will not be updated * until $defer is set to false. When $defer is set to false, then all * previously deferred updated post comment counts will then be automatically * updated without having to call wp_update_comment_count() after. * * @since 2.5.0 * @staticvar bool $_defer * * @param bool $defer * @return unknown */function wp_defer_comment_counting($defer=null) {	static $_defer = false;	if ( is_bool($defer) ) {		$_defer = $defer;		// flush any deferred counts		if ( !$defer )			wp_update_comment_count( null, true );	}	return $_defer;}/** * Updates the comment count for post(s). * * When $do_deferred is false (is by default) and the comments have been set to * be deferred, the post_id will be added to a queue, which will be updated at a * later date and only updated once per post ID. * * If the comments have not be set up to be deferred, then the post will be * updated. When $do_deferred is set to true, then all previous deferred post * IDs will be updated along with the current $post_id. * * @since 2.1.0 * @see wp_update_comment_count_now() For what could cause a false return value * * @param int $post_id Post ID * @param bool $do_deferred Whether to process previously deferred post comment counts * @return bool True on success, false on failure */function wp_update_comment_count($post_id, $do_deferred=false) {	static $_deferred = array();	if ( $do_deferred ) {		$_deferred = array_unique($_deferred);		foreach ( $_deferred as $i => $_post_id ) {			wp_update_comment_count_now($_post_id);			unset( $_deferred[$i] ); /** @todo Move this outside of the foreach and reset $_deferred to an array instead */		}	}	if ( wp_defer_comment_counting() ) {		$_deferred[] = $post_id;		return true;	}	elseif ( $post_id ) {		return wp_update_comment_count_now($post_id);	}}/** * Updates the comment count for the post. * * @since 2.5.0 * @uses $wpdb * @uses do_action() Calls 'wp_update_comment_count' hook on $post_id, $new, and $old * @uses do_action() Calls 'edit_posts' hook on $post_id and $post * * @param int $post_id Post ID * @return bool False on '0' $post_id or if post with ID does not exist. True on success. */function wp_update_comment_count_now($post_id) {	global $wpdb;	$post_id = (int) $post_id;	if ( !$post_id )		return false;	if ( !$post = get_post($post_id) )		return false;	$old = (int) $post->comment_count;	$new = (int) $wpdb->get_var( $wpdb->prepare("SELECT COUNT(*) FROM $wpdb->comments WHERE comment_post_ID = %d AND comment_approved = '1'", $post_id) );	$wpdb->update( $wpdb->posts, array('comment_count' => $new), array('ID' => $post_id) );	if ( 'page' == $post->post_type )		clean_page_cache( $post_id );	else		clean_post_cache( $post_id );	do_action('wp_update_comment_count', $post_id, $new, $old);	do_action('edit_post', $post_id, $post);	return true;}//// Ping and trackback functions.///** * Finds a pingback server URI based on the given URL. * * Checks the HTML for the rel="pingback" link and x-pingback headers. It does * a check for the x-pingback headers first and returns that, if available. The * check for the rel="pingback" has more overhead than just the header. * * @since 1.5.0 * * @param string $url URL to ping. * @param int $deprecated Not Used. * @return bool|string False on failure, string containing URI on success. */function discover_pingback_server_uri( $url, $deprecated = '' ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.7' );	$pingback_str_dquote = 'rel="pingback"';	$pingback_str_squote = 'rel=\'pingback\'';	/** @todo Should use Filter Extension or custom preg_match instead. */	$parsed_url = parse_url($url);	if ( ! isset( $parsed_url['host'] ) ) // Not an URL. This should never happen.		return false;	//Do not search for a pingback server on our own uploads	$uploads_dir = wp_upload_dir();	if ( 0 === strpos($url, $uploads_dir['baseurl']) )		return false;	$response = wp_remote_head( $url, array( 'timeout' => 2, 'httpversion' => '1.0' ) );	if ( is_wp_error( $response ) )		return false;	if ( isset( $response['headers']['x-pingback'] ) )		return $response['headers']['x-pingback'];	// Not an (x)html, sgml, or xml page, no use going further.	if ( isset( $response['headers']['content-type'] ) && preg_match('#(image|audio|video|model)/#is', $response['headers']['content-type']) )		return false;	// Now do a GET since we're going to look in the html headers (and we're sure its not a binary file)	$response = wp_remote_get( $url, array( 'timeout' => 2, 'httpversion' => '1.0' ) );	if ( is_wp_error( $response ) )		return false;	$contents = $response['body'];	$pingback_link_offset_dquote = strpos($contents, $pingback_str_dquote);	$pingback_link_offset_squote = strpos($contents, $pingback_str_squote);	if ( $pingback_link_offset_dquote || $pingback_link_offset_squote ) {		$quote = ($pingback_link_offset_dquote) ? '"' : '\'';		$pingback_link_offset = ($quote=='"') ? $pingback_link_offset_dquote : $pingback_link_offset_squote;		$pingback_href_pos = @strpos($contents, 'href=', $pingback_link_offset);		$pingback_href_start = $pingback_href_pos+6;		$pingback_href_end = @strpos($contents, $quote, $pingback_href_start);		$pingback_server_url_len = $pingback_href_end - $pingback_href_start;		$pingback_server_url = substr($contents, $pingback_href_start, $pingback_server_url_len);		// We may find rel="pingback" but an incomplete pingback URL		if ( $pingback_server_url_len > 0 ) { // We got it!			return $pingback_server_url;		}	}	return false;}/** * Perform all pingbacks, enclosures, trackbacks, and send to pingback services. * * @since 2.1.0 * @uses $wpdb */function do_all_pings() {	global $wpdb;	// Do pingbacks	while ($ping = $wpdb->get_row("SELECT * FROM {$wpdb->posts}, {$wpdb->postmeta} WHERE {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id AND {$wpdb->postmeta}.meta_key = '_pingme' LIMIT 1")) {		$mid = $wpdb->get_var( "SELECT meta_id FROM {$wpdb->postmeta} WHERE post_id = {$ping->ID} AND meta_key = '_pingme' LIMIT 1");		do_action( 'delete_postmeta', $mid );		$wpdb->query( $wpdb->prepare( "DELETE FROM {$wpdb->postmeta} WHERE meta_id = %d", $mid ) );		do_action( 'deleted_postmeta', $mid );		pingback($ping->post_content, $ping->ID);	}	// Do Enclosures	while ($enclosure = $wpdb->get_row("SELECT * FROM {$wpdb->posts}, {$wpdb->postmeta} WHERE {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id AND {$wpdb->postmeta}.meta_key = '_encloseme' LIMIT 1")) {		$mid = $wpdb->get_var( $wpdb->prepare("SELECT meta_id FROM {$wpdb->postmeta} WHERE post_id = %d AND meta_key = '_encloseme'", $enclosure->ID) );		do_action( 'delete_postmeta', $mid );		$wpdb->query( $wpdb->prepare("DELETE FROM {$wpdb->postmeta} WHERE meta_id =  %d", $mid) );		do_action( 'deleted_postmeta', $mid );		do_enclose($enclosure->post_content, $enclosure->ID);	}	// Do Trackbacks	$trackbacks = $wpdb->get_col("SELECT ID FROM $wpdb->posts WHERE to_ping <> '' AND post_status = 'publish'");	if ( is_array($trackbacks) )		foreach ( $trackbacks as $trackback )			do_trackbacks($trackback);	//Do Update Services/Generic Pings	generic_ping();}/** * Perform trackbacks. * * @since 1.5.0 * @uses $wpdb * * @param int $post_id Post ID to do trackbacks on. */function do_trackbacks($post_id) {	global $wpdb;	$post = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->posts WHERE ID = %d", $post_id) );	$to_ping = get_to_ping($post_id);	$pinged  = get_pung($post_id);	if ( empty($to_ping) ) {		$wpdb->update($wpdb->posts, array('to_ping' => ''), array('ID' => $post_id) );		return;	}	if ( empty($post->post_excerpt) )		$excerpt = apply_filters('the_content', $post->post_content);	else		$excerpt = apply_filters('the_excerpt', $post->post_excerpt);	$excerpt = str_replace(']]>', ']]&gt;', $excerpt);	$excerpt = wp_html_excerpt($excerpt, 252) . '...';	$post_title = apply_filters('the_title', $post->post_title);	$post_title = strip_tags($post_title);	if ( $to_ping ) {		foreach ( (array) $to_ping as $tb_ping ) {			$tb_ping = trim($tb_ping);			if ( !in_array($tb_ping, $pinged) ) {				trackback($tb_ping, $post_title, $excerpt, $post_id);				$pinged[] = $tb_ping;			} else {				$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET to_ping = TRIM(REPLACE(to_ping, '$tb_ping', '')) WHERE ID = %d", $post_id) );			}		}	}}/** * Sends pings to all of the ping site services. * * @since 1.2.0 * * @param int $post_id Post ID. Not actually used. * @return int Same as Post ID from parameter */function generic_ping($post_id = 0) {	$services = get_option('ping_sites');	$services = explode("\n", $services);	foreach ( (array) $services as $service ) {		$service = trim($service);		if ( '' != $service )			weblog_ping($service);	}	return $post_id;}/** * Pings back the links found in a post. * * @since 0.71 * @uses $wp_version * @uses IXR_Client * * @param string $content Post content to check for links. * @param int $post_ID Post ID. */function pingback($content, $post_ID) {	global $wp_version;	include_once(ABSPATH . WPINC . '/class-IXR.php');	// original code by Mort (http://mort.mine.nu:8080)	$post_links = array();	$pung = get_pung($post_ID);	// Variables	$ltrs = '\w';	$gunk = '/#~:.?+=&%@!\-';	$punc = '.:?\-';	$any = $ltrs . $gunk . $punc;	// Step 1	// Parsing the post, external links (if any) are stored in the $post_links array	// This regexp comes straight from phpfreaks.com	// http://www.phpfreaks.com/quickcode/Extract_All_URLs_on_a_Page/15.php	preg_match_all("{\b http : [$any] +? (?= [$punc] * [^$any] | $)}x", $content, $post_links_temp);	// Step 2.	// Walking thru the links array	// first we get rid of links pointing to sites, not to specific files	// Example:	// http://dummy-weblog.org	// http://dummy-weblog.org/	// http://dummy-weblog.org/post.php	// We don't wanna ping first and second types, even if they have a valid <link/>	foreach ( (array) $post_links_temp[0] as $link_test ) :		if ( !in_array($link_test, $pung) && (url_to_postid($link_test) != $post_ID) // If we haven't pung it already and it isn't a link to itself				&& !is_local_attachment($link_test) ) : // Also, let's never ping local attachments.			if ( $test = @parse_url($link_test) ) {				if ( isset($test['query']) )					$post_links[] = $link_test;				elseif ( ($test['path'] != '/') && ($test['path'] != '') )					$post_links[] = $link_test;			}		endif;	endforeach;	do_action_ref_array('pre_ping', array(&$post_links, &$pung));	foreach ( (array) $post_links as $pagelinkedto ) {		$pingback_server_url = discover_pingback_server_uri($pagelinkedto, 2048);		if ( $pingback_server_url ) {			@ set_time_limit( 60 );			 // Now, the RPC call			$pagelinkedfrom = get_permalink($post_ID);			// using a timeout of 3 seconds should be enough to cover slow servers			$client = new IXR_Client($pingback_server_url);			$client->timeout = 3;			$client->useragent = apply_filters( 'pingback_useragent', $client->useragent . ' -- WordPress/' . $wp_version, $client->useragent, $pingback_server_url, $pagelinkedto, $pagelinkedfrom);			// when set to true, this outputs debug messages by itself			$client->debug = false;			if ( $client->query('pingback.ping', $pagelinkedfrom, $pagelinkedto) || ( isset($client->error->code) && 48 == $client->error->code ) ) // Already registered				add_ping( $post_ID, $pagelinkedto );		}	}}/** * Check whether blog is public before returning sites. * * @since 2.1.0 * * @param mixed $sites Will return if blog is public, will not return if not public. * @return mixed Empty string if blog is not public, returns $sites, if site is public. */function privacy_ping_filter($sites) {	if ( '0' != get_option('blog_public') )		return $sites;	else		return '';}/** * Send a Trackback. * * Updates database when sending trackback to prevent duplicates. * * @since 0.71 * @uses $wpdb * * @param string $trackback_url URL to send trackbacks. * @param string $title Title of post. * @param string $excerpt Excerpt of post. * @param int $ID Post ID. * @return mixed Database query from update. */function trackback($trackback_url, $title, $excerpt, $ID) {	global $wpdb;	if ( empty($trackback_url) )		return;	$options = array();	$options['timeout'] = 4;	$options['body'] = array(		'title' => $title,		'url' => get_permalink($ID),		'blog_name' => get_option('blogname'),		'excerpt' => $excerpt	);	$response = wp_remote_post($trackback_url, $options);	if ( is_wp_error( $response ) )		return;	$tb_url = addslashes( $trackback_url );	$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET pinged = CONCAT(pinged, '\n', '$tb_url') WHERE ID = %d", $ID) );	return $wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET to_ping = TRIM(REPLACE(to_ping, '$tb_url', '')) WHERE ID = %d", $ID) );}/** * Send a pingback. * * @since 1.2.0 * @uses $wp_version * @uses IXR_Client * * @param string $server Host of blog to connect to. * @param string $path Path to send the ping. */function weblog_ping($server = '', $path = '') {	global $wp_version;	include_once(ABSPATH . WPINC . '/class-IXR.php');	// using a timeout of 3 seconds should be enough to cover slow servers	$client = new IXR_Client($server, ((!strlen(trim($path)) || ('/' == $path)) ? false : $path));	$client->timeout = 3;	$client->useragent .= ' -- WordPress/'.$wp_version;	// when set to true, this outputs debug messages by itself	$client->debug = false;	$home = trailingslashit( home_url() );	if ( !$client->query('weblogUpdates.extendedPing', get_option('blogname'), $home, get_bloginfo('rss2_url') ) ) // then try a normal ping		$client->query('weblogUpdates.ping', get_option('blogname'), $home);}//// Cache///** * Removes comment ID from the comment cache. * * @since 2.3.0 * @package WordPress * @subpackage Cache * * @param int|array $id Comment ID or array of comment IDs to remove from cache */function clean_comment_cache($ids) {	foreach ( (array) $ids as $id )		wp_cache_delete($id, 'comment');}/** * Updates the comment cache of given comments. * * Will add the comments in $comments to the cache. If comment ID already exists * in the comment cache then it will not be updated. The comment is added to the * cache using the comment group with the key using the ID of the comments. * * @since 2.3.0 * @package WordPress * @subpackage Cache * * @param array $comments Array of comment row objects */function update_comment_cache($comments) {	foreach ( (array) $comments as $comment )		wp_cache_add($comment->comment_ID, $comment, 'comment');}//// Internal///** * Close comments on old posts on the fly, without any extra DB queries.  Hooked to the_posts. * * @access private * @since 2.7.0 * * @param object $posts Post data object. * @return object */function _close_comments_for_old_posts( $posts ) {	if ( empty($posts) || !is_singular() || !get_option('close_comments_for_old_posts') )		return $posts;	$days_old = (int) get_option('close_comments_days_old');	if ( !$days_old )		return $posts;	if ( time() - strtotime( $posts[0]->post_date_gmt ) > ( $days_old * 24 * 60 * 60 ) ) {		$posts[0]->comment_status = 'closed';		$posts[0]->ping_status = 'closed';	}	return $posts;}/** * Close comments on an old post.  Hooked to comments_open and pings_open. * * @access private * @since 2.7.0 * * @param bool $open Comments open or closed * @param int $post_id Post ID * @return bool $open */function _close_comments_for_old_post( $open, $post_id ) {	if ( ! $open )		return $open;	if ( !get_option('close_comments_for_old_posts') )		return $open;	$days_old = (int) get_option('close_comments_days_old');	if ( !$days_old )		return $open;	$post = get_post($post_id);	if ( time() - strtotime( $post->post_date_gmt ) > ( $days_old * 24 * 60 * 60 ) )		return false;	return $open;}?>
<?php/** * Edit user administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');wp_reset_vars(array('action', 'redirect', 'profile', 'user_id', 'wp_http_referer'));$user_id = (int) $user_id;$current_user = wp_get_current_user();if ( ! defined( 'IS_PROFILE_PAGE' ) )	define( 'IS_PROFILE_PAGE', ( $user_id == $current_user->ID ) );if ( ! $user_id && IS_PROFILE_PAGE )	$user_id = $current_user->ID;elseif ( ! $user_id && ! IS_PROFILE_PAGE )	wp_die(__( 'Invalid user ID.' ) );elseif ( ! get_userdata( $user_id ) )	wp_die( __('Invalid user ID.') );wp_enqueue_script('user-profile');wp_enqueue_script('password-strength-meter');$title = IS_PROFILE_PAGE ? __('Profile') : __('Edit User');if ( current_user_can('edit_users') && !IS_PROFILE_PAGE )	$submenu_file = 'users.php';else	$submenu_file = 'profile.php';$parent_file = 'users.php';// contextual help - choose Help on the top right of admin panel to preview this.add_contextual_help($current_screen,    '<p>' . __('Your profile contains information about you (your &#8220;account&#8221;) as well as some personal options related to using WordPress.') . '</p>' .    '<p>' . __('You can change your password, turn on keyboard shortcuts, change the color scheme of your WordPress administration screens, and turn off the WYSIWYG (Visual) editor, among other things.') . '</p>' .    '<p>' . __('Your username cannot be changed, but you can use other fields to enter your real name or a nickname, and change which name to display on your posts.') . '</p>' .    '<p>' . __('Required fields are indicated; the rest are optional. Profile information will only be displayed if your theme is set up to do so.') . '</p>' .    '<p>' . __('Remember to click the Update Profile button when you are finished.') . '</p>' .    '<p><strong>' . __('For more information:') . '</strong></p>' .    '<p>' . __('<a href="http://codex.wordpress.org/Users_Your_Profile_SubPanel" target="_blank">Documentation on User Profiles</a>') . '</p>' .    '<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');$wp_http_referer = remove_query_arg(array('update', 'delete_count'), stripslashes($wp_http_referer));$all_post_caps = array('posts', 'pages');$user_can_edit = false;foreach ( $all_post_caps as $post_cap )	$user_can_edit |= current_user_can("edit_$post_cap");/** * Optional SSL preference that can be turned on by hooking to the 'personal_options' action. * * @since 2.7.0 * * @param object $user User data object */function use_ssl_preference($user) {?>	<tr>		<th scope="row"><?php _e('Use https')?></th>		<td><label for="use_ssl"><input name="use_ssl" type="checkbox" id="use_ssl" value="1" <?php checked('1', $user->use_ssl); ?> /> <?php _e('Always use https when visiting the admin'); ?></label></td>	</tr><?php}// Only allow super admins on multisite to edit every user.if ( is_multisite() && ! current_user_can( 'manage_network_users' ) && $user_id != $current_user->ID && ! apply_filters( 'enable_edit_any_user_configuration', true ) )	wp_die( __( 'You do not have permission to edit this user.' ) );// Execute confirmed email change. See send_confirmation_on_profile_email().if ( is_multisite() && IS_PROFILE_PAGE && isset( $_GET[ 'newuseremail' ] ) && $current_user->ID ) {	$new_email = get_option( $current_user->ID . '_new_email' );	if ( $new_email[ 'hash' ] == $_GET[ 'newuseremail' ] ) {		$user->ID = $current_user->ID;		$user->user_email = esc_html( trim( $new_email[ 'newemail' ] ) );		if ( $wpdb->get_var( $wpdb->prepare( "SELECT user_login FROM {$wpdb->signups} WHERE user_login = %s", $current_user->user_login ) ) )			$wpdb->query( $wpdb->prepare( "UPDATE {$wpdb->signups} SET user_email = %s WHERE user_login = %s", $user->user_email, $current_user->user_login ) );		wp_update_user( get_object_vars( $user ) );		delete_option( $current_user->ID . '_new_email' );		wp_redirect( add_query_arg( array('updated' => 'true'), admin_url( 'profile.php' ) ) );		die();	}} elseif ( is_multisite() && IS_PROFILE_PAGE && !empty( $_GET['dismiss'] ) && $current_user->ID . '_new_email' == $_GET['dismiss'] ) {	delete_option( $current_user->ID . '_new_email' );	wp_redirect( add_query_arg( array('updated' => 'true'), admin_url( 'profile.php' ) ) );	die();}switch ($action) {case 'switchposts':check_admin_referer();/* TODO: Switch all posts from one user to another user */break;case 'update':check_admin_referer('update-user_' . $user_id);if ( !current_user_can('edit_user', $user_id) )	wp_die(__('You do not have permission to edit this user.'));if ( IS_PROFILE_PAGE )	do_action('personal_options_update', $user_id);else	do_action('edit_user_profile_update', $user_id);if ( !is_multisite() ) {	$errors = edit_user($user_id);} else {	$user = get_userdata( $user_id );	// Update the email address in signups, if present.	if ( $user->user_login && isset( $_POST[ 'email' ] ) && is_email( $_POST[ 'email' ] ) && $wpdb->get_var( $wpdb->prepare( "SELECT user_login FROM {$wpdb->signups} WHERE user_login = %s", $user->user_login ) ) )		$wpdb->query( $wpdb->prepare( "UPDATE {$wpdb->signups} SET user_email = %s WHERE user_login = %s", $_POST[ 'email' ], $user_login ) );	// WPMU must delete the user from the current blog if WP added him after editing.	$delete_role = false;	$blog_prefix = $wpdb->get_blog_prefix();	if ( $user_id != $current_user->ID ) {		$cap = $wpdb->get_var( "SELECT meta_value FROM {$wpdb->usermeta} WHERE user_id = '{$user_id}' AND meta_key = '{$blog_prefix}capabilities' AND meta_value = 'a:0:{}'" );		if ( null == $cap && $_POST[ 'role' ] == '' ) {			$_POST[ 'role' ] = 'contributor';			$delete_role = true;		}	}	if ( !isset( $errors ) || ( isset( $errors ) && is_object( $errors ) && false == $errors->get_error_codes() ) )		$errors = edit_user($user_id);	if ( $delete_role ) // stops users being added to current blog when they are edited		delete_user_meta( $user_id, $blog_prefix . 'capabilities' );	if ( is_multisite() && !IS_PROFILE_PAGE && current_user_can( 'manage_network_options' ) && !isset($super_admins) && empty( $_POST['super_admin'] ) == is_super_admin( $user_id ) )		empty( $_POST['super_admin'] ) ? revoke_super_admin( $user_id ) : grant_super_admin( $user_id );}if ( !is_wp_error( $errors ) ) {	$redirect = (IS_PROFILE_PAGE ? "profile.php?" : "user-edit.php?user_id=$user_id&"). "updated=true";	$redirect = add_query_arg('wp_http_referer', urlencode($wp_http_referer), $redirect);	wp_redirect($redirect);	exit;}default:$profileuser = get_user_to_edit($user_id);if ( !current_user_can('edit_user', $user_id) )	wp_die(__('You do not have permission to edit this user.'));include ('admin-header.php');?><?php if ( !IS_PROFILE_PAGE && is_super_admin( $profileuser->ID ) && current_user_can( 'manage_network_options' ) ) { ?>	<div class="updated"><p><strong><?php _e('Important:'); ?></strong> <?php _e('This user has super admin privileges.'); ?></p></div><?php } ?><?php if ( isset($_GET['updated']) ) : ?><div id="message" class="updated">	<p><strong><?php _e('User updated.') ?></strong></p>	<?php if ( $wp_http_referer && !IS_PROFILE_PAGE ) : ?>	<p><a href="users.php"><?php _e('&larr; Back to Authors and Users'); ?></a></p>	<?php endif; ?></div><?php endif; ?><?php if ( isset( $errors ) && is_wp_error( $errors ) ) : ?><div class="error"><p><?php echo implode( "</p>\n<p>", $errors->get_error_messages() ); ?></p></div><?php endif; ?><div class="wrap" id="profile-page"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><form id="your-profile" action="<?php echo esc_url( admin_url( IS_PROFILE_PAGE ? 'profile.php' : 'user-edit.php' ) ); ?>" method="post"<?php do_action('user_edit_form_tag'); ?>><?php wp_nonce_field('update-user_' . $user_id) ?><?php if ( $wp_http_referer ) : ?>	<input type="hidden" name="wp_http_referer" value="<?php echo esc_url($wp_http_referer); ?>" /><?php endif; ?><p><input type="hidden" name="from" value="profile" /><input type="hidden" name="checkuser_id" value="<?php echo $user_ID ?>" /></p><h3><?php _e('Personal Options'); ?></h3><table class="form-table"><?php if ( rich_edit_exists() && !( IS_PROFILE_PAGE && !$user_can_edit ) ) : // don't bother showing the option if the editor has been removed ?>	<tr>		<th scope="row"><?php _e('Visual Editor')?></th>		<td><label for="rich_editing"><input name="rich_editing" type="checkbox" id="rich_editing" value="false" <?php checked('false', $profileuser->rich_editing); ?> /> <?php _e('Disable the visual editor when writing'); ?></label></td>	</tr><?php endif; ?><?php if ( count($_wp_admin_css_colors) > 1 && has_action('admin_color_scheme_picker') ) : ?><tr><th scope="row"><?php _e('Admin Color Scheme')?></th><td><?php do_action( 'admin_color_scheme_picker' ); ?></td></tr><?phpendif; // $_wp_admin_css_colorsif ( !( IS_PROFILE_PAGE && !$user_can_edit ) ) : ?><tr><th scope="row"><?php _e( 'Keyboard Shortcuts' ); ?></th><td><label for="comment_shortcuts"><input type="checkbox" name="comment_shortcuts" id="comment_shortcuts" value="true" <?php if ( !empty($profileuser->comment_shortcuts) ) checked('true', $profileuser->comment_shortcuts); ?> /> <?php _e('Enable keyboard shortcuts for comment moderation.'); ?></label> <?php _e('<a href="http://codex.wordpress.org/Keyboard_Shortcuts">More information</a>'); ?></td></tr><?phpendif;do_action('personal_options', $profileuser);?></table><?php	if ( IS_PROFILE_PAGE )		do_action('profile_personal_options', $profileuser);?><h3><?php _e('Name') ?></h3><table class="form-table">	<tr>		<th><label for="user_login"><?php _e('Username'); ?></label></th>		<td><input type="text" name="user_login" id="user_login" value="<?php echo esc_attr($profileuser->user_login); ?>" disabled="disabled" class="regular-text" /> <span class="description"><?php _e('Usernames cannot be changed.'); ?></span></td>	</tr><?php if ( !IS_PROFILE_PAGE ): ?><tr><th><label for="role"><?php _e('Role:') ?></label></th><td><select name="role" id="role"><?php// Get the highest/primary role for this user// TODO: create a function that does this: wp_get_user_role()$user_roles = $profileuser->roles;$user_role = array_shift($user_roles);// print the full list of roles with the primary one selected.wp_dropdown_roles($user_role);// print the 'no role' option. Make it selected if the user has no role yet.if ( $user_role )	echo '<option value="">' . __('&mdash; No role for this site &mdash;') . '</option>';else	echo '<option value="" selected="selected">' . __('&mdash; No role for this site &mdash;') . '</option>';?></select><?php if ( is_multisite() && current_user_can( 'manage_network_options' ) && !isset($super_admins) ) { ?><p><label><input type="checkbox" id="super_admin" name="super_admin"<?php checked( is_super_admin( $profileuser->ID ) ); ?> /> <?php _e( 'Grant this user super admin privileges for the Network.'); ?></label></p><?php } ?></td></tr><?php endif; //!IS_PROFILE_PAGE ?><tr>	<th><label for="first_name"><?php _e('First Name') ?></label></th>	<td><input type="text" name="first_name" id="first_name" value="<?php echo esc_attr($profileuser->first_name) ?>" class="regular-text" /></td></tr><tr>	<th><label for="last_name"><?php _e('Last Name') ?></label></th>	<td><input type="text" name="last_name" id="last_name" value="<?php echo esc_attr($profileuser->last_name) ?>" class="regular-text" /></td></tr><tr>	<th><label for="nickname"><?php _e('Nickname'); ?> <span class="description"><?php _e('(required)'); ?></span></label></th>	<td><input type="text" name="nickname" id="nickname" value="<?php echo esc_attr($profileuser->nickname) ?>" class="regular-text" /></td></tr><tr>	<th><label for="display_name"><?php _e('Display name publicly as') ?></label></th>	<td>		<select name="display_name" id="display_name">		<?php			$public_display = array();			$public_display['display_username']  = $profileuser->user_login;			$public_display['display_nickname']  = $profileuser->nickname;			if ( !empty($profileuser->first_name) )				$public_display['display_firstname'] = $profileuser->first_name;			if ( !empty($profileuser->last_name) )				$public_display['display_lastname'] = $profileuser->last_name;			if ( !empty($profileuser->first_name) && !empty($profileuser->last_name) ) {				$public_display['display_firstlast'] = $profileuser->first_name . ' ' . $profileuser->last_name;				$public_display['display_lastfirst'] = $profileuser->last_name . ' ' . $profileuser->first_name;			}			if ( !in_array( $profileuser->display_name, $public_display ) ) // Only add this if it isn't duplicated elsewhere				$public_display = array( 'display_displayname' => $profileuser->display_name ) + $public_display;			$public_display = array_map( 'trim', $public_display );			$public_display = array_unique( $public_display );			foreach ( $public_display as $id => $item ) {		?>			<option id="<?php echo $id; ?>" value="<?php echo esc_attr($item); ?>"<?php selected( $profileuser->display_name, $item ); ?>><?php echo $item; ?></option>		<?php			}		?>		</select>	</td></tr></table><h3><?php _e('Contact Info') ?></h3><table class="form-table"><tr>	<th><label for="email"><?php _e('E-mail'); ?> <span class="description"><?php _e('(required)'); ?></span></label></th>	<td><input type="text" name="email" id="email" value="<?php echo esc_attr($profileuser->user_email) ?>" class="regular-text" />	<?php	$new_email = get_option( $current_user->ID . '_new_email' );	if ( $new_email && $new_email != $current_user->user_email ) : ?>	<div class="updated inline">	<p><?php printf( __('There is a pending change of your e-mail to <code>%1$s</code>. <a href="%2$s">Cancel</a>'), $new_email['newemail'], esc_url( admin_url( 'profile.php?dismiss=' . $current_user->ID . '_new_email' ) ) ); ?></p>	</div>	<?php endif; ?>	</td></tr><tr>	<th><label for="url"><?php _e('Website') ?></label></th>	<td><input type="text" name="url" id="url" value="<?php echo esc_attr($profileuser->user_url) ?>" class="regular-text code" /></td></tr><?php	foreach (_wp_get_user_contactmethods() as $name => $desc) {?><tr>	<th><label for="<?php echo $name; ?>"><?php echo apply_filters('user_'.$name.'_label', $desc); ?></label></th>	<td><input type="text" name="<?php echo $name; ?>" id="<?php echo $name; ?>" value="<?php echo esc_attr($profileuser->$name) ?>" class="regular-text" /></td></tr><?php	}?></table><h3><?php IS_PROFILE_PAGE ? _e('About Yourself') : _e('About the user'); ?></h3><table class="form-table"><tr>	<th><label for="description"><?php _e('Biographical Info'); ?></label></th>	<td><textarea name="description" id="description" rows="5" cols="30"><?php echo esc_html($profileuser->description); ?></textarea><br />	<span class="description"><?php _e('Share a little biographical information to fill out your profile. This may be shown publicly.'); ?></span></td></tr><?php$show_password_fields = apply_filters('show_password_fields', true, $profileuser);if ( $show_password_fields ) :?><tr id="password">	<th><label for="pass1"><?php _e('New Password'); ?></label></th>	<td><input type="password" name="pass1" id="pass1" size="16" value="" autocomplete="off" /> <span class="description"><?php _e("If you would like to change the password type a new one. Otherwise leave this blank."); ?></span><br />		<input type="password" name="pass2" id="pass2" size="16" value="" autocomplete="off" /> <span class="description"><?php _e("Type your new password again."); ?></span><br />		<div id="pass-strength-result"><?php _e('Strength indicator'); ?></div>		<p class="description indicator-hint"><?php _e('Hint: The password should be at least seven characters long. To make it stronger, use upper and lower case letters, numbers and symbols like ! " ? $ % ^ &amp; ).'); ?></p>	</td></tr><?php endif; ?></table><?php	if ( IS_PROFILE_PAGE )		do_action( 'show_user_profile', $profileuser );	else		do_action( 'edit_user_profile', $profileuser );?><?php if ( count($profileuser->caps) > count($profileuser->roles) && apply_filters('additional_capabilities_display', true, $profileuser) ) { ?><br class="clear" />	<table width="99%" style="border: none;" cellspacing="2" cellpadding="3" class="editform">		<tr>			<th scope="row"><?php _e('Additional Capabilities') ?></th>			<td><?php			$output = '';			foreach ( $profileuser->caps as $cap => $value ) {				if ( !$wp_roles->is_role($cap) ) {					if ( $output != '' )						$output .= ', ';					$output .= $value ? $cap : "Denied: {$cap}";				}			}			echo $output;			?></td>		</tr>	</table><?php } ?><p class="submit">	<input type="hidden" name="action" value="update" />	<input type="hidden" name="user_id" id="user_id" value="<?php echo esc_attr($user_id); ?>" />	<input type="submit" class="button-primary" value="<?php IS_PROFILE_PAGE ? esc_attr_e('Update Profile') : esc_attr_e('Update User') ?>" name="submit" /></p></form></div><?phpbreak;}?><script type="text/javascript" charset="utf-8">	if (window.location.hash == '#password') {		document.getElementById('pass1').focus();	}</script><?phpinclude('./admin-footer.php');?>
<?php/** * TwentyTen functions and definitions * * Sets up the theme and provides some helper functions. Some helper functions * are used in the theme as custom template tags. Others are attached to action and * filter hooks in WordPress to change core functionality. * * The first function, twentyten_setup(), sets up the theme by registering support * for various features in WordPress, such as post thumbnails, navigation menus, and the like. * * When using a child theme (see http://codex.wordpress.org/Theme_Development and * http://codex.wordpress.org/Child_Themes), you can override certain functions * (those wrapped in a function_exists() call) by defining them first in your child theme's * functions.php file. The child theme's functions.php file is included before the parent * theme's file, so the child theme functions would be used. * * Functions that are not pluggable (not wrapped in function_exists()) are instead attached * to a filter or action hook. The hook can be removed by using remove_action() or * remove_filter() and you can attach your own function to the hook. * * We can remove the parent theme's hook only after it is attached, which means we need to * wait until setting up the child theme: * * <code> * add_action( 'after_setup_theme', 'my_child_theme_setup' ); * function my_child_theme_setup() { *     // We are providing our own filter for excerpt_length (or using the unfiltered value) *     remove_filter( 'excerpt_length', 'twentyten_excerpt_length' ); *     ... * } * </code> * * For more information on hooks, actions, and filters, see http://codex.wordpress.org/Plugin_API. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 *//** * Set the content width based on the theme's design and stylesheet. * * Used to set the width of images and content. Should be equal to the width the theme * is designed for, generally via the style.css stylesheet. */if ( ! isset( $content_width ) )	$content_width = 640;/** Tell WordPress to run twentyten_setup() when the 'after_setup_theme' hook is run. */add_action( 'after_setup_theme', 'twentyten_setup' );if ( ! function_exists( 'twentyten_setup' ) ):/** * Sets up theme defaults and registers support for various WordPress features. * * Note that this function is hooked into the after_setup_theme hook, which runs * before the init hook. The init hook is too late for some features, such as indicating * support post thumbnails. * * To override twentyten_setup() in a child theme, add your own twentyten_setup to your child theme's * functions.php file. * * @uses add_theme_support() To add support for post thumbnails and automatic feed links. * @uses register_nav_menus() To add support for navigation menus. * @uses add_custom_background() To add support for a custom background. * @uses add_editor_style() To style the visual editor. * @uses load_theme_textdomain() For translation/localization support. * @uses add_custom_image_header() To add support for a custom header. * @uses register_default_headers() To register the default custom header images provided with the theme. * @uses set_post_thumbnail_size() To set a custom post thumbnail size. * * @since Twenty Ten 1.0 */function twentyten_setup() {	// This theme styles the visual editor with editor-style.css to match the theme style.	add_editor_style();	// This theme uses post thumbnails	add_theme_support( 'post-thumbnails' );	// Add default posts and comments RSS feed links to head	add_theme_support( 'automatic-feed-links' );	// Make theme available for translation	// Translations can be filed in the /languages/ directory	load_theme_textdomain( 'twentyten', TEMPLATEPATH . '/languages' );	$locale = get_locale();	$locale_file = TEMPLATEPATH . "/languages/$locale.php";	if ( is_readable( $locale_file ) )		require_once( $locale_file );	// This theme uses wp_nav_menu() in one location.	register_nav_menus( array(		'primary' => __( 'Primary Navigation', 'twentyten' ),	) );	// This theme allows users to set a custom background	add_custom_background();	// Your changeable header business starts here	define( 'HEADER_TEXTCOLOR', '' );	// No CSS, just IMG call. The %s is a placeholder for the theme template directory URI.	define( 'HEADER_IMAGE', '%s/images/headers/path.jpg' );	// The height and width of your custom header. You can hook into the theme's own filters to change these values.	// Add a filter to twentyten_header_image_width and twentyten_header_image_height to change these values.	define( 'HEADER_IMAGE_WIDTH', apply_filters( 'twentyten_header_image_width', 940 ) );	define( 'HEADER_IMAGE_HEIGHT', apply_filters( 'twentyten_header_image_height', 198 ) );	// We'll be using post thumbnails for custom header images on posts and pages.	// We want them to be 940 pixels wide by 198 pixels tall.	// Larger images will be auto-cropped to fit, smaller ones will be ignored. See header.php.	set_post_thumbnail_size( HEADER_IMAGE_WIDTH, HEADER_IMAGE_HEIGHT, true );	// Don't support text inside the header image.	define( 'NO_HEADER_TEXT', true );	// Add a way for the custom header to be styled in the admin panel that controls	// custom headers. See twentyten_admin_header_style(), below.	add_custom_image_header( '', 'twentyten_admin_header_style' );	// ... and thus ends the changeable header business.	// Default custom headers packaged with the theme. %s is a placeholder for the theme template directory URI.	register_default_headers( array(		'berries' => array(			'url' => '%s/images/headers/berries.jpg',			'thumbnail_url' => '%s/images/headers/berries-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Berries', 'twentyten' )		),		'cherryblossom' => array(			'url' => '%s/images/headers/cherryblossoms.jpg',			'thumbnail_url' => '%s/images/headers/cherryblossoms-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Cherry Blossoms', 'twentyten' )		),		'concave' => array(			'url' => '%s/images/headers/concave.jpg',			'thumbnail_url' => '%s/images/headers/concave-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Concave', 'twentyten' )		),		'fern' => array(			'url' => '%s/images/headers/fern.jpg',			'thumbnail_url' => '%s/images/headers/fern-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Fern', 'twentyten' )		),		'forestfloor' => array(			'url' => '%s/images/headers/forestfloor.jpg',			'thumbnail_url' => '%s/images/headers/forestfloor-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Forest Floor', 'twentyten' )		),		'inkwell' => array(			'url' => '%s/images/headers/inkwell.jpg',			'thumbnail_url' => '%s/images/headers/inkwell-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Inkwell', 'twentyten' )		),		'path' => array(			'url' => '%s/images/headers/path.jpg',			'thumbnail_url' => '%s/images/headers/path-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Path', 'twentyten' )		),		'sunset' => array(			'url' => '%s/images/headers/sunset.jpg',			'thumbnail_url' => '%s/images/headers/sunset-thumbnail.jpg',			/* translators: header image description */			'description' => __( 'Sunset', 'twentyten' )		)	) );}endif;if ( ! function_exists( 'twentyten_admin_header_style' ) ) :/** * Styles the header image displayed on the Appearance > Header admin panel. * * Referenced via add_custom_image_header() in twentyten_setup(). * * @since Twenty Ten 1.0 */function twentyten_admin_header_style() {?><style type="text/css">/* Shows the same border as on front end */#headimg {	border-bottom: 1px solid #000;	border-top: 4px solid #000;}/* If NO_HEADER_TEXT is false, you would style the text with these selectors:	#headimg #name { }	#headimg #desc { }*/</style><?php}endif;/** * Makes some changes to the <title> tag, by filtering the output of wp_title(). * * If we have a site description and we're viewing the home page or a blog posts * page (when using a static front page), then we will add the site description. * * If we're viewing a search result, then we're going to recreate the title entirely. * We're going to add page numbers to all titles as well, to the middle of a search * result title and the end of all other titles. * * The site title also gets added to all titles. * * @since Twenty Ten 1.0 * * @param string $title Title generated by wp_title() * @param string $separator The separator passed to wp_title(). Twenty Ten uses a * 	vertical bar, "|", as a separator in header.php. * @return string The new title, ready for the <title> tag. */function twentyten_filter_wp_title( $title, $separator ) {	// Don't affect wp_title() calls in feeds.	if ( is_feed() )		return $title;	// The $paged global variable contains the page number of a listing of posts.	// The $page global variable contains the page number of a single post that is paged.	// We'll display whichever one applies, if we're not looking at the first page.	global $paged, $page;	if ( is_search() ) {		// If we're a search, let's start over:		$title = sprintf( __( 'Search results for %s', 'twentyten' ), '"' . get_search_query() . '"' );		// Add a page number if we're on page 2 or more:		if ( $paged >= 2 )			$title .= " $separator " . sprintf( __( 'Page %s', 'twentyten' ), $paged );		// Add the site name to the end:		$title .= " $separator " . get_bloginfo( 'name', 'display' );		// We're done. Let's send the new title back to wp_title():		return $title;	}	// Otherwise, let's start by adding the site name to the end:	$title .= get_bloginfo( 'name', 'display' );	// If we have a site description and we're on the home/front page, add the description:	$site_description = get_bloginfo( 'description', 'display' );	if ( $site_description && ( is_home() || is_front_page() ) )		$title .= " $separator " . $site_description;	// Add a page number if necessary:	if ( $paged >= 2 || $page >= 2 )		$title .= " $separator " . sprintf( __( 'Page %s', 'twentyten' ), max( $paged, $page ) );	// Return the new title to wp_title():	return $title;}add_filter( 'wp_title', 'twentyten_filter_wp_title', 10, 2 );/** * Get our wp_nav_menu() fallback, wp_page_menu(), to show a home link. * * To override this in a child theme, remove the filter and optionally add * your own function tied to the wp_page_menu_args filter hook. * * @since Twenty Ten 1.0 */function twentyten_page_menu_args( $args ) {	$args['show_home'] = true;	return $args;}add_filter( 'wp_page_menu_args', 'twentyten_page_menu_args' );/** * Sets the post excerpt length to 40 characters. * * To override this length in a child theme, remove the filter and add your own * function tied to the excerpt_length filter hook. * * @since Twenty Ten 1.0 * @return int */function twentyten_excerpt_length( $length ) {	return 40;}add_filter( 'excerpt_length', 'twentyten_excerpt_length' );/** * Returns a "Continue Reading" link for excerpts * * @since Twenty Ten 1.0 * @return string "Continue Reading" link */function twentyten_continue_reading_link() {	return ' <a href="'. get_permalink() . '">' . __( 'Continue reading <span class="meta-nav">&rarr;</span>', 'twentyten' ) . '</a>';}/** * Replaces "[...]" (appended to automatically generated excerpts) with an ellipsis and twentyten_continue_reading_link(). * * To override this in a child theme, remove the filter and add your own * function tied to the excerpt_more filter hook. * * @since Twenty Ten 1.0 * @return string An ellipsis */function twentyten_auto_excerpt_more( $more ) {	return ' &hellip;' . twentyten_continue_reading_link();}add_filter( 'excerpt_more', 'twentyten_auto_excerpt_more' );/** * Adds a pretty "Continue Reading" link to custom post excerpts. * * To override this link in a child theme, remove the filter and add your own * function tied to the get_the_excerpt filter hook. * * @since Twenty Ten 1.0 * @return string Excerpt with a pretty "Continue Reading" link */function twentyten_custom_excerpt_more( $output ) {	if ( has_excerpt() && ! is_attachment() ) {		$output .= twentyten_continue_reading_link();	}	return $output;}add_filter( 'get_the_excerpt', 'twentyten_custom_excerpt_more' );/** * Remove inline styles printed when the gallery shortcode is used. * * Galleries are styled by the theme in Twenty Ten's style.css. * * @since Twenty Ten 1.0 * @return string The gallery style filter, with the styles themselves removed. */function twentyten_remove_gallery_css( $css ) {	return preg_replace( "#<style type='text/css'>(.*?)</style>#s", '', $css );}add_filter( 'gallery_style', 'twentyten_remove_gallery_css' );if ( ! function_exists( 'twentyten_comment' ) ) :/** * Template for comments and pingbacks. * * To override this walker in a child theme without modifying the comments template * simply create your own twentyten_comment(), and that function will be used instead. * * Used as a callback by wp_list_comments() for displaying the comments. * * @since Twenty Ten 1.0 */function twentyten_comment( $comment, $args, $depth ) {	$GLOBALS['comment'] = $comment;	switch ( $comment->comment_type ) :		case '' :	?>	<li <?php comment_class(); ?> id="li-comment-<?php comment_ID(); ?>">		<div id="comment-<?php comment_ID(); ?>">		<div class="comment-author vcard">			<?php echo get_avatar( $comment, 40 ); ?>			<?php printf( __( '%s <span class="says">says:</span>', 'twentyten' ), sprintf( '<cite class="fn">%s</cite>', get_comment_author_link() ) ); ?>		</div><!-- .comment-author .vcard -->		<?php if ( $comment->comment_approved == '0' ) : ?>			<em><?php _e( 'Your comment is awaiting moderation.', 'twentyten' ); ?></em>			<br />		<?php endif; ?>		<div class="comment-meta commentmetadata"><a href="<?php echo esc_url( get_comment_link( $comment->comment_ID ) ); ?>">			<?php				/* translators: 1: date, 2: time */				printf( __( '%1$s at %2$s', 'twentyten' ), get_comment_date(),  get_comment_time() ); ?></a><?php edit_comment_link( __( '(Edit)', 'twentyten' ), ' ' );			?>		</div><!-- .comment-meta .commentmetadata -->		<div class="comment-body"><?php comment_text(); ?></div>		<div class="reply">			<?php comment_reply_link( array_merge( $args, array( 'depth' => $depth, 'max_depth' => $args['max_depth'] ) ) ); ?>		</div><!-- .reply -->	</div><!-- #comment-##  -->	<?php			break;		case 'pingback'  :		case 'trackback' :	?>	<li class="post pingback">		<p><?php _e( 'Pingback:', 'twentyten' ); ?> <?php comment_author_link(); ?><?php edit_comment_link( __('(Edit)', 'twentyten'), ' ' ); ?></p>	<?php			break;	endswitch;}endif;/** * Register widgetized areas, including two sidebars and four widget-ready columns in the footer. * * To override twentyten_widgets_init() in a child theme, remove the action hook and add your own * function tied to the init hook. * * @since Twenty Ten 1.0 * @uses register_sidebar */function twentyten_widgets_init() {	// Area 1, located at the top of the sidebar.	register_sidebar( array(		'name' => __( 'Primary Widget Area', 'twentyten' ),		'id' => 'primary-widget-area',		'description' => __( 'The primary widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );	// Area 2, located below the Primary Widget Area in the sidebar. Empty by default.	register_sidebar( array(		'name' => __( 'Secondary Widget Area', 'twentyten' ),		'id' => 'secondary-widget-area',		'description' => __( 'The secondary widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );	// Area 3, located in the footer. Empty by default.	register_sidebar( array(		'name' => __( 'First Footer Widget Area', 'twentyten' ),		'id' => 'first-footer-widget-area',		'description' => __( 'The first footer widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );	// Area 4, located in the footer. Empty by default.	register_sidebar( array(		'name' => __( 'Second Footer Widget Area', 'twentyten' ),		'id' => 'second-footer-widget-area',		'description' => __( 'The second footer widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );	// Area 5, located in the footer. Empty by default.	register_sidebar( array(		'name' => __( 'Third Footer Widget Area', 'twentyten' ),		'id' => 'third-footer-widget-area',		'description' => __( 'The third footer widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );	// Area 6, located in the footer. Empty by default.	register_sidebar( array(		'name' => __( 'Fourth Footer Widget Area', 'twentyten' ),		'id' => 'fourth-footer-widget-area',		'description' => __( 'The fourth footer widget area', 'twentyten' ),		'before_widget' => '<li id="%1$s" class="widget-container %2$s">',		'after_widget' => '</li>',		'before_title' => '<h3 class="widget-title">',		'after_title' => '</h3>',	) );}/** Register sidebars by running twentyten_widgets_init() on the widgets_init hook. */add_action( 'widgets_init', 'twentyten_widgets_init' );/** * Removes the default styles that are packaged with the Recent Comments widget. * * To override this in a child theme, remove the filter and optionally add your own * function tied to the widgets_init action hook. * * @since Twenty Ten 1.0 */function twentyten_remove_recent_comments_style() {	global $wp_widget_factory;	remove_action( 'wp_head', array( $wp_widget_factory->widgets['WP_Widget_Recent_Comments'], 'recent_comments_style' ) );}add_action( 'widgets_init', 'twentyten_remove_recent_comments_style' );if ( ! function_exists( 'twentyten_posted_on' ) ) :/** * Prints HTML with meta information for the current postdate/time and author. * * @since Twenty Ten 1.0 */function twentyten_posted_on() {	printf( __( '<span class="%1$s">Posted on</span> %2$s <span class="meta-sep">by</span> %3$s', 'twentyten' ),		'meta-prep meta-prep-author',		sprintf( '<a href="%1$s" title="%2$s" rel="bookmark"><span class="entry-date">%3$s</span></a>',			get_permalink(),			esc_attr( get_the_time() ),			get_the_date()		),		sprintf( '<span class="author vcard"><a class="url fn n" href="%1$s" title="%2$s">%3$s</a></span>',			get_author_posts_url( get_the_author_meta( 'ID' ) ),			sprintf( esc_attr__( 'View all posts by %s', 'twentyten' ), get_the_author() ),			get_the_author()		)	);}endif;if ( ! function_exists( 'twentyten_posted_in' ) ) :/** * Prints HTML with meta information for the current post (category, tags and permalink). * * @since Twenty Ten 1.0 */function twentyten_posted_in() {	// Retrieves tag list of current post, separated by commas.	$tag_list = get_the_tag_list( '', ', ' );	if ( $tag_list ) {		$posted_in = __( 'This entry was posted in %1$s and tagged %2$s. Bookmark the <a href="%3$s" title="Permalink to %4$s" rel="bookmark">permalink</a>.', 'twentyten' );	} elseif ( is_object_in_taxonomy( get_post_type(), 'category' ) ) {		$posted_in = __( 'This entry was posted in %1$s. Bookmark the <a href="%3$s" title="Permalink to %4$s" rel="bookmark">permalink</a>.', 'twentyten' );	} else {		$posted_in = __( 'Bookmark the <a href="%3$s" title="Permalink to %4$s" rel="bookmark">permalink</a>.', 'twentyten' );	}	// Prints the string, replacing the placeholders.	printf(		$posted_in,		get_the_category_list( ', ' ),		$tag_list,		get_permalink(),		the_title_attribute( 'echo=0' )	);}endif;
<?php/** * Edit post administration panel. * * Manage Post actions: post, edit, delete, etc. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');$parent_file = 'edit.php';$submenu_file = 'edit.php';wp_reset_vars(array('action', 'safe_mode', 'withcomments', 'posts', 'content', 'edited_post_title', 'comment_error', 'profile', 'trackback_url', 'excerpt', 'showcomments', 'commentstart', 'commentend', 'commentorder'));if ( isset($_GET['post']) )	$post_id = (int) $_GET['post'];elseif ( isset($_POST['post_ID']) )	$post_id = (int) $_POST['post_ID'];else	$post_id = 0;$post_ID = $post_id;$post = null;$post_type_object = null;$post_type = null;if ( $post_id ) {	$post = get_post($post_id);	if ( $post ) {		$post_type_object = get_post_type_object($post->post_type);		if ( $post_type_object ) {			$post_type = $post->post_type;			$current_screen->post_type = $post->post_type;			$current_screen->id = $current_screen->post_type;		}	}} elseif ( isset($_POST['post_type']) ) {	$post_type_object = get_post_type_object($_POST['post_type']);	if ( $post_type_object ) {		$post_type = $post_type_object->name;		$current_screen->post_type = $post_type;		$current_screen->id = $current_screen->post_type;	}}/** * Redirect to previous page. * * @param int $post_id Optional. Post ID. */function redirect_post($post_id = '') {	if ( !empty($_POST['mode']) && 'sidebar' == $_POST['mode'] ) {		if ( isset($_POST['saveasdraft']) )			$location = 'sidebar.php?a=c';		elseif ( isset($_POST['publish']) )			$location = 'sidebar.php?a=b';	} elseif ( isset($_POST['save']) || isset($_POST['publish']) ) {		$status = get_post_status( $post_id );		if ( isset( $_POST['publish'] ) ) {			switch ( $status ) {				case 'pending':					$message = 8;					break;				case 'future':					$message = 9;					break;				default:					$message = 6;			}		} else {				$message = 'draft' == $status ? 10 : 1;		}		$location = add_query_arg( 'message', $message, get_edit_post_link( $post_id, 'url' ) );	} elseif ( isset($_POST['addmeta']) && $_POST['addmeta'] ) {		$location = add_query_arg( 'message', 2, wp_get_referer() );		$location = explode('#', $location);		$location = $location[0] . '#postcustom';	} elseif ( isset($_POST['deletemeta']) && $_POST['deletemeta'] ) {		$location = add_query_arg( 'message', 3, wp_get_referer() );		$location = explode('#', $location);		$location = $location[0] . '#postcustom';	} elseif ( 'post-quickpress-save-cont' == $_POST['action'] ) {		$location = "post.php?action=edit&post=$post_id&message=7";	} else {		$location = add_query_arg( 'message', 4, get_edit_post_link( $post_id, 'url' ) );	}	wp_redirect( apply_filters( 'redirect_post_location', $location, $post_id ) );}if ( isset( $_POST['deletepost'] ) )	$action = 'delete';elseif ( isset($_POST['wp-preview']) && 'dopreview' == $_POST['wp-preview'] )	$action = 'preview';$sendback = wp_get_referer();if ( strpos($sendback, 'post.php') !== false || strpos($sendback, 'post-new.php') !== false ) {	$sendback = admin_url('edit.php');	$sendback .= ( !empty( $post_type ) ) ? '?post_type=' . $post_type : '';} else {	$sendback = remove_query_arg( array('trashed', 'untrashed', 'deleted', 'ids'), $sendback );}switch($action) {case 'postajaxpost':case 'post':case 'post-quickpress-publish':case 'post-quickpress-save':	check_admin_referer('add-' . $post_type);	if ( 'post-quickpress-publish' == $action )		$_POST['publish'] = 'publish'; // tell write_post() to publish	if ( 'post-quickpress-publish' == $action || 'post-quickpress-save' == $action ) {		$_POST['comment_status'] = get_option('default_comment_status');		$_POST['ping_status'] = get_option('default_ping_status');	}	if ( !empty( $_POST['quickpress_post_ID'] ) ) {		$_POST['post_ID'] = (int) $_POST['quickpress_post_ID'];		$post_id = edit_post();	} else {		$post_id = 'postajaxpost' == $action ? edit_post() : write_post();	}	if ( 0 === strpos( $action, 'post-quickpress' ) ) {		$_POST['post_ID'] = $post_id;		// output the quickpress dashboard widget		require_once(ABSPATH . 'wp-admin/includes/dashboard.php');		wp_dashboard_quick_press_output();		exit;	}	redirect_post($post_id);	exit();	break;case 'edit':	$editing = true;	if ( empty( $post_id ) ) {		wp_redirect("post.php");		exit();	}	$p = $post_id;	if ( empty($post->ID) )		wp_die( __('You attempted to edit an item that doesn&#8217;t exist. Perhaps it was deleted?') );	if ( !current_user_can($post_type_object->cap->edit_post, $post_id) )		wp_die( __('You are not allowed to edit this item.') );	if ( 'trash' == $post->post_status )		wp_die( __('You can&#8217;t edit this item because it is in the Trash. Please restore it and try again.') );	if ( null == $post_type_object )		wp_die( __('Unknown post type.') );	$post_type = $post->post_type;	if ( 'post' == $post_type ) {		$parent_file = "edit.php";		$submenu_file = "edit.php";	} else {		$parent_file = "edit.php?post_type=$post_type";		$submenu_file = "edit.php?post_type=$post_type";	}	if ( $last = wp_check_post_lock( $post->ID ) ) {		add_action('admin_notices', '_admin_notice_post_locked' );	} else {		wp_set_post_lock( $post->ID );		wp_enqueue_script('autosave');	}	$title = $post_type_object->labels->edit_item;	$post = get_post_to_edit($post_id);	if ( post_type_supports($post_type, 'comments') ) {		wp_enqueue_script('admin-comments');		enqueue_comment_hotkeys_js();	}	include('./edit-form-advanced.php');	break;case 'editattachment':	check_admin_referer('update-attachment_' . $post_id);	// Don't let these be changed	unset($_POST['guid']);	$_POST['post_type'] = 'attachment';	// Update the thumbnail filename	$newmeta = wp_get_attachment_metadata( $post_id, true );	$newmeta['thumb'] = $_POST['thumb'];	wp_update_attachment_metadata( $post_id, $newmeta );case 'editpost':	check_admin_referer('update-' . $post_type . '_' . $post_id);	$post_id = edit_post();	redirect_post($post_id); // Send user on their way while we keep working	exit();	break;case 'trash':	check_admin_referer('trash-' . $post_type . '_' . $post_id);	$post = & get_post($post_id);	if ( !current_user_can($post_type_object->cap->delete_post, $post_id) )		wp_die( __('You are not allowed to move this item to the Trash.') );	if ( ! wp_trash_post($post_id) )		wp_die( __('Error in moving to Trash.') );	wp_redirect( add_query_arg( array('trashed' => 1, 'ids' => $post_id), $sendback ) );	exit();	break;case 'untrash':	check_admin_referer('untrash-' . $post_type . '_' . $post_id);	if ( !current_user_can($post_type_object->cap->delete_post, $post_id) )		wp_die( __('You are not allowed to move this item out of the Trash.') );	if ( ! wp_untrash_post($post_id) )		wp_die( __('Error in restoring from Trash.') );	wp_redirect( add_query_arg('untrashed', 1, $sendback) );	exit();	break;case 'delete':	check_admin_referer('delete-' . $post_type . '_' . $post_id);	if ( !current_user_can($post_type_object->cap->delete_post, $post_id) )		wp_die( __('You are not allowed to delete this item.') );	$force = !EMPTY_TRASH_DAYS;	if ( $post->post_type == 'attachment' ) {		$force = ( $force || !MEDIA_TRASH );		if ( ! wp_delete_attachment($post_id, $force) )			wp_die( __('Error in deleting.') );	} else {		if ( !wp_delete_post($post_id, $force) )			wp_die( __('Error in deleting.') );	}	wp_redirect( add_query_arg('deleted', 1, $sendback) );	exit();	break;case 'preview':	check_admin_referer( 'autosave', 'autosavenonce' );	$url = post_preview();	wp_redirect($url);	exit();	break;default:		wp_redirect('edit.php');	exit();	break;} // end switchinclude('./admin-footer.php');?>
<?php/** * Multi-site WordPress API * * @package WordPress * @subpackage Multisite * @since 3.0.0 */function get_sitestats() {	global $wpdb;	$stats['blogs'] = get_blog_count();	$count_ts = get_site_option( 'user_count_ts' );	if ( time() - $count_ts > 3600 ) {		$count = $wpdb->get_var( "SELECT COUNT(ID) FROM $wpdb->users" );		update_site_option( 'user_count', $count );		update_site_option( 'user_count_ts', time() );	} else {		$count = get_site_option( 'user_count' );	}	$stats['users'] = $count;	return $stats;}function get_admin_users_for_domain( $sitedomain = '', $path = '' ) {	global $wpdb;	if ( ! $sitedomain )		$site_id = $wpdb->siteid;	else		$site_id = $wpdb->get_var( $wpdb->prepare( "SELECT id FROM $wpdb->site WHERE domain = %s AND path = %s", $sitedomain, $path ) );	if ( $site_id )		return $wpdb->get_results( $wpdb->prepare( "SELECT u.ID, u.user_login, u.user_pass FROM $wpdb->users AS u, $wpdb->sitemeta AS sm WHERE sm.meta_key = 'admin_user_id' AND u.ID = sm.meta_value AND sm.site_id = %d", $site_id ), ARRAY_A );	return false;}function get_blogs_of_user( $id, $all = false ) {	global $wpdb;	$cache_suffix = $all ? '_all' : '_short';	$return = wp_cache_get( 'blogs_of_user_' . $id . $cache_suffix, 'users' );	if ( $return )		return apply_filters( 'get_blogs_of_user', $return, $id, $all );	$user = get_userdata( (int) $id );	if ( !$user )		return false;	$blogs = $match = array();	$prefix_length = strlen($wpdb->base_prefix);	foreach ( (array) $user as $key => $value ) {		if ( $prefix_length && substr($key, 0, $prefix_length) != $wpdb->base_prefix )			continue;		if ( substr($key, -12, 12) != 'capabilities' )			continue;		if ( preg_match( '/^' . $wpdb->base_prefix . '((\d+)_)?capabilities$/', $key, $match ) ) {			if ( count( $match ) > 2 )				$blog_id = $match[ 2 ];			else				$blog_id = 1;			$blog = get_blog_details( $blog_id );			if ( $blog && isset( $blog->domain ) && ( $all == true || $all == false && ( $blog->archived == 0 && $blog->spam == 0 && $blog->deleted == 0 ) ) ) {				$blogs[ $blog_id ]->userblog_id	= $blog_id;				$blogs[ $blog_id ]->blogname		= $blog->blogname;				$blogs[ $blog_id ]->domain		= $blog->domain;				$blogs[ $blog_id ]->path			= $blog->path;				$blogs[ $blog_id ]->site_id		= $blog->site_id;				$blogs[ $blog_id ]->siteurl		= $blog->siteurl;			}		}	}	wp_cache_add( 'blogs_of_user_' . $id . $cache_suffix, $blogs, 'users', 5 );	return apply_filters( 'get_blogs_of_user', $blogs, $id, $all );}function get_active_blog_for_user( $user_id ) { // get an active blog for user - either primary blog or from blogs list	global $wpdb;	$blogs = get_blogs_of_user( $user_id );	if ( empty( $blogs ) ) {		$details = get_dashboard_blog();		add_user_to_blog( $details->blog_id, $user_id, 'subscriber' );		update_user_meta( $user_id, 'primary_blog', $details->blog_id );		wp_cache_delete( $user_id, 'users' );		return $details;	}	$primary_blog = get_user_meta( $user_id, 'primary_blog', true );	$details = get_dashboard_blog();	if ( $primary_blog ) {		$blogs = get_blogs_of_user( $user_id );		if ( isset( $blogs[ $primary_blog ] ) == false ) {			add_user_to_blog( $details->blog_id, $user_id, 'subscriber' );			update_user_meta( $user_id, 'primary_blog', $details->blog_id );			wp_cache_delete( $user_id, 'users' );		} else {			$details = get_blog_details( $primary_blog );		}	} else {		add_user_to_blog( $details->blog_id, $user_id, 'subscriber' ); // Add subscriber permission for dashboard blog		update_user_meta( $user_id, 'primary_blog', $details->blog_id );	}	if ( ( is_object( $details ) == false ) || ( is_object( $details ) && $details->archived == 1 || $details->spam == 1 || $details->deleted == 1 ) ) {		$blogs = get_blogs_of_user( $user_id, true ); // if a user's primary blog is shut down, check their other blogs.		$ret = false;		if ( is_array( $blogs ) && count( $blogs ) > 0 ) {			foreach ( (array) $blogs as $blog_id => $blog ) {				if ( $blog->site_id != $wpdb->siteid )					continue;				$details = get_blog_details( $blog_id );				if ( is_object( $details ) && $details->archived == 0 && $details->spam == 0 && $details->deleted == 0 ) {					$ret = $blog;					$changed = false;					if ( get_user_meta( $user_id , 'primary_blog', true ) != $blog_id ) {						update_user_meta( $user_id, 'primary_blog', $blog_id );						$changed = true;					}					if ( !get_user_meta($user_id , 'source_domain', true) ) {						update_user_meta( $user_id, 'source_domain', $blog->domain );						$changed = true;					}					if ( $changed )						wp_cache_delete( $user_id, 'users' );					break;				}			}		} else {			// Should never get here			$dashboard_blog = get_dashboard_blog();			add_user_to_blog( $dashboard_blog->blog_id, $user_id, 'subscriber' ); // Add subscriber permission for dashboard blog			update_user_meta( $user_id, 'primary_blog', $dashboard_blog->blog_id );			return $dashboard_blog;		}		return $ret;	} else {		return $details;	}}function is_user_member_of_blog( $user_id, $blog_id = 0 ) {	$user_id = (int) $user_id;	$blog_id = (int) $blog_id;	if ( $blog_id == 0 ) {		global $wpdb;		$blog_id = $wpdb->blogid;	}	$blogs = get_blogs_of_user( $user_id );	if ( is_array( $blogs ) )		return array_key_exists( $blog_id, $blogs );	else		return false;}function get_user_count() {	global $wpdb;	$count_ts = get_site_option( 'user_count_ts' );	if ( time() - $count_ts > 3600 ) {		$count = $wpdb->get_var( $wpdb->prepare("SELECT COUNT(ID) as c FROM $wpdb->users WHERE spam = '0' AND deleted = '0'") );		update_site_option( 'user_count', $count );		update_site_option( 'user_count_ts', time() );	}	$count = get_site_option( 'user_count' );	return $count;}function get_blog_count( $id = 0 ) {	global $wpdb;	if ( $id == 0 )		$id = $wpdb->siteid;	$count_ts = get_site_option( 'blog_count_ts' );	if ( time() - $count_ts > 3600 ) {		$count = $wpdb->get_var( $wpdb->prepare("SELECT COUNT(blog_id) as c FROM $wpdb->blogs WHERE site_id = %d AND spam = '0' AND deleted = '0' and archived = '0'", $id) );		update_site_option( 'blog_count', $count );		update_site_option( 'blog_count_ts', time() );	}	$count = get_site_option( 'blog_count' );	return $count;}function get_blog_post( $blog_id, $post_id ) {	global $wpdb;	$key = $blog_id . '-' . $post_id;	$post = wp_cache_get( $key, 'global-posts' );	if ( $post == false ) {		$post = $wpdb->get_row( $wpdb->prepare( 'SELECT * FROM ' . $wpdb->get_blog_prefix( $blog_id ) . 'posts WHERE ID = %d', $post_id ) );		wp_cache_add( $key, $post, 'global-posts' );	}	return $post;}function add_user_to_blog( $blog_id, $user_id, $role ) {	switch_to_blog($blog_id);	$user = new WP_User($user_id);	if ( empty($user) || !$user->ID )		return new WP_Error('user_does_not_exist', __('That user does not exist.'));	if ( !get_user_meta($user_id, 'primary_blog', true) ) {		update_user_meta($user_id, 'primary_blog', $blog_id);		$details = get_blog_details($blog_id);		update_user_meta($user_id, 'source_domain', $details->domain);	}	$user->set_role($role);	do_action('add_user_to_blog', $user_id, $role, $blog_id);	wp_cache_delete( $user_id, 'users' );	restore_current_blog();	return true;}function remove_user_from_blog($user_id, $blog_id = '', $reassign = '') {	global $wpdb;	switch_to_blog($blog_id);	$user_id = (int) $user_id;	do_action('remove_user_from_blog', $user_id, $blog_id);	// If being removed from the primary blog, set a new primary if the user is assigned	// to multiple blogs.	$primary_blog = get_user_meta($user_id, 'primary_blog', true);	if ( $primary_blog == $blog_id ) {		$new_id = '';		$new_domain = '';		$blogs = get_blogs_of_user($user_id);		foreach ( (array) $blogs as $blog ) {			if ( $blog->userblog_id == $blog_id )				continue;			$new_id = $blog->userblog_id;			$new_domain = $blog->domain;			break;		}		update_user_meta($user_id, 'primary_blog', $new_id);		update_user_meta($user_id, 'source_domain', $new_domain);	}	// wp_revoke_user($user_id);	$user = new WP_User($user_id);	$user->remove_all_caps();	$blogs = get_blogs_of_user($user_id);	if ( count($blogs) == 0 ) {		update_user_meta($user_id, 'primary_blog', '');		update_user_meta($user_id, 'source_domain', '');	}	if ( $reassign != '' ) {		$reassign = (int) $reassign;		$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET post_author = %d WHERE post_author = %d", $reassign, $user_id) );		$wpdb->query( $wpdb->prepare("UPDATE $wpdb->links SET link_owner = %d WHERE link_owner = %d", $reassign, $user_id) );	}	restore_current_blog();}function create_empty_blog( $domain, $path, $weblog_title, $site_id = 1 ) {	$domain			= addslashes( $domain );	$weblog_title	= addslashes( $weblog_title );	if ( empty($path) )		$path = '/';	// Check if the domain has been used already. We should return an error message.	if ( domain_exists($domain, $path, $site_id) )		return __( 'Error: Site URL already taken.' );	// Need to backup wpdb table names, and create a new wp_blogs entry for new blog.	// Need to get blog_id from wp_blogs, and create new table names.	// Must restore table names at the end of function.	if ( ! $blog_id = insert_blog($domain, $path, $site_id) )		return __( 'Error: problem creating site entry.' );	switch_to_blog($blog_id);	install_blog($blog_id);	restore_current_blog();	return $blog_id;}function get_blog_permalink( $_blog_id, $post_id ) {	$key = "{$_blog_id}-{$post_id}-blog_permalink";	$link = wp_cache_get( $key, 'site-options' );	if ( $link == false ) {		switch_to_blog( $_blog_id );		$link = get_permalink( $post_id );		restore_current_blog();		wp_cache_add( $key, $link, 'site-options', 360 );	}	return $link;}function get_blog_id_from_url( $domain, $path = '/' ) {	global $wpdb;	$domain = strtolower( $wpdb->escape( $domain ) );	$path = strtolower( $wpdb->escape( $path ) );	$id = wp_cache_get( md5( $domain . $path ), 'blog-id-cache' );	if ( $id == -1 ) { // blog does not exist		return 0;	} elseif ( $id ) {		return (int)$id;	}	$id = $wpdb->get_var( "SELECT blog_id FROM $wpdb->blogs WHERE domain = '$domain' and path = '$path' /* get_blog_id_from_url */" );	if ( !$id ) {		wp_cache_set( md5( $domain . $path ), -1, 'blog-id-cache' );		return false;	}	wp_cache_set( md5( $domain . $path ), $id, 'blog-id-cache' );	return $id;}// wpmu admin functionsfunction wpmu_admin_do_redirect( $url = '' ) {	$ref = '';	if ( isset( $_GET['ref'] ) )		$ref = $_GET['ref'];	if ( isset( $_POST['ref'] ) )		$ref = $_POST['ref'];	if ( $ref ) {		$ref = wpmu_admin_redirect_add_updated_param( $ref );		wp_redirect( $ref );		exit();	}	if ( empty( $_SERVER['HTTP_REFERER'] ) == false ) {		wp_redirect( $_SERVER['HTTP_REFERER'] );		exit();	}	$url = wpmu_admin_redirect_add_updated_param( $url );	if ( isset( $_GET['redirect'] ) ) {		if ( substr( $_GET['redirect'], 0, 2 ) == 's_' )			$url .= '&action=blogs&s='. esc_html( substr( $_GET['redirect'], 2 ) );	} elseif ( isset( $_POST['redirect'] ) ) {		$url = wpmu_admin_redirect_add_updated_param( $_POST['redirect'] );	}	wp_redirect( $url );	exit();}function wpmu_admin_redirect_add_updated_param( $url = '' ) {	if ( strpos( $url, 'updated=true' ) === false ) {		if ( strpos( $url, '?' ) === false )			return $url . '?updated=true';		else			return $url . '&updated=true';	}	return $url;}function is_blog_user( $blog_id = 0 ) {	global $current_user, $wpdb;	if ( !$blog_id )		$blog_id = $wpdb->blogid;	$cap_key = $wpdb->base_prefix . $blog_id . '_capabilities';	if ( is_array($current_user->$cap_key) && in_array(1, $current_user->$cap_key) )		return true;	return false;}function is_email_address_unsafe( $user_email ) {	$banned_names = get_site_option( 'banned_email_domains' );	if ($banned_names && !is_array( $banned_names ))		$banned_names = explode( "\n", $banned_names);	if ( is_array( $banned_names ) && empty( $banned_names ) == false ) {		$email_domain = strtolower( substr( $user_email, 1 + strpos( $user_email, '@' ) ) );		foreach ( (array) $banned_names as $banned_domain ) {			if ( $banned_domain == '' )				continue;			if (				strstr( $email_domain, $banned_domain ) ||				(					strstr( $banned_domain, '/' ) &&					preg_match( $banned_domain, $email_domain )				)			)			return true;		}	}	return false;}function wpmu_validate_user_signup($user_name, $user_email) {	global $wpdb;	$errors = new WP_Error();	$orig_username = $user_name;	$user_name = preg_replace( '/\s+/', '', sanitize_user( $user_name, true ) );	$maybe = array();	preg_match( '/[a-z0-9]+/', $user_name, $maybe );	if ( $user_name != $orig_username || $user_name != $maybe[0] ) {		$errors->add( 'user_name', __( "Only the lowercase letters a-z and numbers allowed" ) );		$user_name = $orig_username;	}	$user_email = sanitize_email( $user_email );	if ( empty( $user_name ) )	   	$errors->add('user_name', __('Please enter a username'));	$illegal_names = get_site_option( 'illegal_names' );	if ( is_array( $illegal_names ) == false ) {		$illegal_names = array(  'www', 'web', 'root', 'admin', 'main', 'invite', 'administrator' );		add_site_option( 'illegal_names', $illegal_names );	}	if ( in_array( $user_name, $illegal_names ) == true )		$errors->add('user_name',  __('That username is not allowed'));	if ( is_email_address_unsafe( $user_email ) )		$errors->add('user_email',  __('You cannot use that email address to signup. We are having problems with them blocking some of our email. Please use another email provider.'));	if ( strlen( $user_name ) < 4 )		$errors->add('user_name',  __('Username must be at least 4 characters'));	if ( strpos( ' ' . $user_name, '_' ) != false )		$errors->add( 'user_name', __( 'Sorry, usernames may not contain the character &#8220;_&#8221;!' ) );	// all numeric?	$match = array();	preg_match( '/[0-9]*/', $user_name, $match );	if ( $match[0] == $user_name )		$errors->add('user_name', __('Sorry, usernames must have letters too!'));	if ( !is_email( $user_email ) )		$errors->add('user_email', __('Please enter a correct email address'));	$limited_email_domains = get_site_option( 'limited_email_domains' );	if ( is_array( $limited_email_domains ) && empty( $limited_email_domains ) == false ) {		$emaildomain = substr( $user_email, 1 + strpos( $user_email, '@' ) );		if ( in_array( $emaildomain, $limited_email_domains ) == false )			$errors->add('user_email', __('Sorry, that email address is not allowed!'));	}	// Check if the username has been used already.	if ( username_exists($user_name) )		$errors->add('user_name', __('Sorry, that username already exists!'));	// Check if the email address has been used already.	if ( email_exists($user_email) )		$errors->add('user_email', __('Sorry, that email address is already used!'));	// Has someone already signed up for this username?	$signup = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->signups WHERE user_login = %s", $user_name) );	if ( $signup != null ) {		$registered_at =  mysql2date('U', $signup->registered);		$now = current_time( 'timestamp', true );		$diff = $now - $registered_at;		// If registered more than two days ago, cancel registration and let this signup go through.		if ( $diff > 172800 )			$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->signups WHERE user_login = %s", $user_name) );		else			$errors->add('user_name', __('That username is currently reserved but may be available in a couple of days.'));		if ( $signup->active == 0 && $signup->user_email == $user_email )			$errors->add('user_email_used', __('username and email used'));	}	$signup = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->signups WHERE user_email = %s", $user_email) );	if ( $signup != null ) {		$diff = current_time( 'timestamp', true ) - mysql2date('U', $signup->registered);		// If registered more than two days ago, cancel registration and let this signup go through.		if ( $diff > 172800 )			$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->signups WHERE user_email = %s", $user_email) );		else			$errors->add('user_email', __('That email address has already been used. Please check your inbox for an activation email. It will become available in a couple of days if you do nothing.'));	}	$result = array('user_name' => $user_name, 'orig_username' => $orig_username, 'user_email' => $user_email, 'errors' => $errors);	return apply_filters('wpmu_validate_user_signup', $result);}function wpmu_validate_blog_signup($blogname, $blog_title, $user = '') {	global $wpdb, $domain, $base, $current_site;	$blog_title = strip_tags( $blog_title );	$blog_title = substr( $blog_title, 0, 50 );	$errors = new WP_Error();	$illegal_names = get_site_option( 'illegal_names' );	if ( $illegal_names == false ) {		$illegal_names = array( 'www', 'web', 'root', 'admin', 'main', 'invite', 'administrator' );		add_site_option( 'illegal_names', $illegal_names );	}	// On sub dir installs, Some names are so illegal, only a filter can spring them from jail	if (! is_subdomain_install() )		$illegal_names = array_merge($illegal_names, apply_filters( 'subdirectory_reserved_names', array( 'page', 'comments', 'blog', 'files', 'feed' ) ) );	if ( empty( $blogname ) )		$errors->add('blogname', __('Please enter a site name'));	$maybe = array();	preg_match( '/[a-z0-9]+/', $blogname, $maybe );	if ( $blogname != $maybe[0] )		$errors->add('blogname', __('Only lowercase letters and numbers allowed'));	if ( in_array( $blogname, $illegal_names ) == true )		$errors->add('blogname',  __('That name is not allowed'));	if ( strlen( $blogname ) < 4 && !is_super_admin() )		$errors->add('blogname',  __('Site name must be at least 4 characters'));	if ( strpos( ' ' . $blogname, '_' ) != false )		$errors->add( 'blogname', __( 'Sorry, site names may not contain the character &#8220;_&#8221;!' ) );	// do not allow users to create a blog that conflicts with a page on the main blog.	if ( !is_subdomain_install() && $wpdb->get_var( $wpdb->prepare( "SELECT post_name FROM " . $wpdb->get_blog_prefix( $current_site->blog_id ) . "posts WHERE post_type = 'page' AND post_name = %s", $blogname ) ) )		$errors->add( 'blogname', __( 'Sorry, you may not use that site name.' ) );	// all numeric?	$match = array();	preg_match( '/[0-9]*/', $blogname, $match );	if ( $match[0] == $blogname )		$errors->add('blogname', __('Sorry, site names must have letters too!'));	$blogname = apply_filters( 'newblogname', $blogname );	$blog_title = stripslashes(  $blog_title );	if ( empty( $blog_title ) )		$errors->add('blog_title', __('Please enter a site title'));	// Check if the domain/path has been used already.	if ( is_subdomain_install() ) {		$mydomain = $blogname . '.' . preg_replace( '|^www\.|', '', $domain );		$path = $base;	} else {		$mydomain = "$domain";		$path = $base.$blogname.'/';	}	if ( domain_exists($mydomain, $path) )		$errors->add('blogname', __('Sorry, that site already exists!'));	if ( username_exists( $blogname ) ) {		if ( is_object( $user ) == false || ( is_object($user) && ( $user->user_login != $blogname ) ) )			$errors->add( 'blogname', __( 'Sorry, that site is reserved!' ) );	}	// Has someone already signed up for this domain?	$signup = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->signups WHERE domain = %s AND path = %s", $mydomain, $path) ); // TODO: Check email too?	if ( ! empty($signup) ) {		$diff = current_time( 'timestamp', true ) - mysql2date('U', $signup->registered);		// If registered more than two days ago, cancel registration and let this signup go through.		if ( $diff > 172800 )			$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->signups WHERE domain = %s AND path = %s", $mydomain, $path) );		else			$errors->add('blogname', __('That site is currently reserved but may be available in a couple days.'));	}	$result = array('domain' => $mydomain, 'path' => $path, 'blogname' => $blogname, 'blog_title' => $blog_title, 'errors' => $errors);	return apply_filters('wpmu_validate_blog_signup', $result);}// Record signup information for future activation. wpmu_validate_signup() should be run// on the inputs before calling wpmu_signup().function wpmu_signup_blog($domain, $path, $title, $user, $user_email, $meta = '') {	global $wpdb;	$key = substr( md5( time() . rand() . $domain ), 0, 16 );	$meta = serialize($meta);	$domain = $wpdb->escape($domain);	$path = $wpdb->escape($path);	$title = $wpdb->escape($title);	$wpdb->insert( $wpdb->signups, array(		'domain' => $domain,		'path' => $path,		'title' => $title,		'user_login' => $user,		'user_email' => $user_email,		'registered' => current_time('mysql', true),		'activation_key' => $key,		'meta' => $meta	) );	wpmu_signup_blog_notification($domain, $path, $title, $user, $user_email, $key, $meta);}function wpmu_signup_user($user, $user_email, $meta = '') {	global $wpdb;	// Format data	$user = preg_replace( '/\s+/', '', sanitize_user( $user, true ) );	$user_email = sanitize_email( $user_email );	$key = substr( md5( time() . rand() . $user_email ), 0, 16 );	$meta = serialize($meta);	$wpdb->insert( $wpdb->signups, array(		'domain' => '',		'path' => '',		'title' => '',		'user_login' => $user,		'user_email' => $user_email,		'registered' => current_time('mysql', true),		'activation_key' => $key,		'meta' => $meta	) );	wpmu_signup_user_notification($user, $user_email, $key, $meta);}// Notify user of signup success.function wpmu_signup_blog_notification($domain, $path, $title, $user, $user_email, $key, $meta = '') {	global $current_site;	if ( !apply_filters('wpmu_signup_blog_notification', $domain, $path, $title, $user, $user_email, $key, $meta) )		return false;	// Send email with activation link.	if ( !is_subdomain_install() || $current_site->id != 1 )		$activate_url = network_site_url("wp-activate.php?key=$key");	else		$activate_url = "http://{$domain}{$path}wp-activate.php?key=$key"; // @todo use *_url() API	$activate_url = esc_url($activate_url);	$admin_email = get_site_option( 'admin_email' );	if ( $admin_email == '' )		$admin_email = 'support@' . $_SERVER['SERVER_NAME'];	$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );	$message_headers = "From: \"{$from_name}\" <{$admin_email}>\n" . "Content-Type: text/plain; charset=\"" . get_option('blog_charset') . "\"\n";	$message = sprintf( apply_filters( 'wpmu_signup_blog_notification_email', __( "To activate your blog, please click the following link:\n\n%s\n\nAfter you activate, you will receive *another email* with your login.\n\nAfter you activate, you can visit your site here:\n\n%s" ) ), $activate_url, esc_url( "http://{$domain}{$path}" ), $key );	// TODO: Don't hard code activation link.	$subject = sprintf( apply_filters( 'wpmu_signup_blog_notification_subject', __( '[%1s] Activate %2s' ) ), $from_name, esc_url( 'http://' . $domain . $path ) );	wp_mail($user_email, $subject, $message, $message_headers);	return true;}function wpmu_signup_user_notification($user, $user_email, $key, $meta = '') {	if ( !apply_filters('wpmu_signup_user_notification', $user, $user_email, $key, $meta) )		return false;	// Send email with activation link.	$admin_email = get_site_option( 'admin_email' );	if ( $admin_email == '' )		$admin_email = 'support@' . $_SERVER['SERVER_NAME'];	$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );	$message_headers = "From: \"{$from_name}\" <{$admin_email}>\n" . "Content-Type: text/plain; charset=\"" . get_option('blog_charset') . "\"\n";	$message = sprintf( apply_filters( 'wpmu_signup_user_notification_email', __( "To activate your user, please click the following link:\n\n%s\n\nAfter you activate, you will receive *another email* with your login.\n\n" ) ), site_url( "wp-activate.php?key=$key" ), $key );	// TODO: Don't hard code activation link.	$subject = sprintf( __( apply_filters( 'wpmu_signup_user_notification_subject', '[%1s] Activate %2s' ) ), $from_name, $user);	wp_mail($user_email, $subject, $message, $message_headers);	return true;}function wpmu_activate_signup($key) {	global $wpdb, $current_site;	$signup = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->signups WHERE activation_key = %s", $key) );	if ( empty($signup) )		return new WP_Error('invalid_key', __('Invalid activation key.'));	if ( $signup->active )		return new WP_Error('already_active', __('The site is already active.'), $signup);	$meta = unserialize($signup->meta);	$user_login = $wpdb->escape($signup->user_login);	$user_email = $wpdb->escape($signup->user_email);	$password = wp_generate_password();	$user_id = username_exists($user_login);	if ( ! $user_id )		$user_id = wpmu_create_user($user_login, $password, $user_email);	else		$user_already_exists = true;	if ( ! $user_id )		return new WP_Error('create_user', __('Could not create user'), $signup);	$now = current_time('mysql', true);	if ( empty($signup->domain) ) {		$wpdb->update( $wpdb->signups, array('active' => 1, 'activated' => $now), array('activation_key' => $key) );		if ( isset( $user_already_exists ) )			return new WP_Error( 'user_already_exists', __( 'That username is already activated.' ), $signup);		wpmu_welcome_user_notification($user_id, $password, $meta);		$user_site = get_site_option( 'dashboard_blog', $current_site->blog_id );		if ( $user_site == false )			add_user_to_blog( '1', $user_id, get_site_option( 'default_user_role', 'subscriber' ) );		else			add_user_to_blog( $user_site, $user_id, get_site_option( 'default_user_role', 'subscriber' ) );		add_new_user_to_blog( $user_id, $user_email, $meta );		do_action('wpmu_activate_user', $user_id, $password, $meta);		return array('user_id' => $user_id, 'password' => $password, 'meta' => $meta);	}	$blog_id = wpmu_create_blog( $signup->domain, $signup->path, $signup->title, $user_id, $meta, $wpdb->siteid );	// TODO: What to do if we create a user but cannot create a blog?	if ( is_wp_error($blog_id) ) {		// If blog is taken, that means a previous attempt to activate this blog failed in between creating the blog and		// setting the activation flag.  Let's just set the active flag and instruct the user to reset their password.		if ( 'blog_taken' == $blog_id->get_error_code() ) {			$blog_id->add_data( $signup );			$wpdb->update( $wpdb->signups, array( 'active' => 1, 'activated' => $now ), array( 'activation_key' => $key ) );		}		return $blog_id;	}	$wpdb->update( $wpdb->signups, array('active' => 1, 'activated' => $now), array('activation_key' => $key) );	wpmu_welcome_notification($blog_id, $user_id, $password, $signup->title, $meta);	do_action('wpmu_activate_blog', $blog_id, $user_id, $password, $signup->title, $meta);	return array('blog_id' => $blog_id, 'user_id' => $user_id, 'password' => $password, 'title' => $signup->title, 'meta' => $meta);}function wpmu_create_user( $user_name, $password, $email) {	$user_name = preg_replace( '/\s+/', '', sanitize_user( $user_name, true ) );	$user_id = wp_create_user( $user_name, $password, $email );	if ( is_wp_error($user_id) )		return false;	// Newly created users have no roles or caps until they are added to a blog.	delete_user_option( $user_id, 'capabilities' );	delete_user_option( $user_id, 'user_level' );	do_action( 'wpmu_new_user', $user_id );	return $user_id;}function wpmu_create_blog($domain, $path, $title, $user_id, $meta = '', $site_id = 1) {	$domain = preg_replace( '/\s+/', '', sanitize_user( $domain, true ) );	if ( is_subdomain_install() )		$domain = str_replace( '@', '', $domain );	$title = strip_tags( $title );	$user_id = (int) $user_id;	if ( empty($path) )		$path = '/';	// Check if the domain has been used already. We should return an error message.	if ( domain_exists($domain, $path, $site_id) )		return new WP_Error('blog_taken', __('Site already exists.'));	if ( !defined('WP_INSTALLING') )		define( 'WP_INSTALLING', true );	if ( ! $blog_id = insert_blog($domain, $path, $site_id) )		return new WP_Error('insert_blog', __('Could not create site.'));	switch_to_blog($blog_id);	install_blog($blog_id, $title);	wp_install_defaults($user_id);	add_user_to_blog($blog_id, $user_id, 'administrator');	if ( is_array($meta) ) foreach ($meta as $key => $value) {		if ( $key == 'public' || $key == 'archived' || $key == 'mature' || $key == 'spam' || $key == 'deleted' || $key == 'lang_id' )			update_blog_status( $blog_id, $key, $value );		else			update_option( $key, $value );	}	add_option( 'WPLANG', get_site_option( 'WPLANG' ) );	update_option( 'blog_public', (int)$meta['public'] );	if ( !is_super_admin() && get_user_meta( $user_id, 'primary_blog', true ) == get_site_option( 'dashboard_blog', 1 ) )		update_user_meta( $user_id, 'primary_blog', $blog_id );	restore_current_blog();	do_action( 'wpmu_new_blog', $blog_id, $user_id, $domain, $path, $site_id, $meta );	return $blog_id;}function newblog_notify_siteadmin( $blog_id, $deprecated = '' ) {	if ( get_site_option( 'registrationnotification' ) != 'yes' )		return false;	$email = get_site_option( 'admin_email' );	if ( is_email($email) == false )		return false;	$options_site_url = esc_url(network_admin_url('ms-options.php'));	switch_to_blog( $blog_id );	$blogname = get_option( 'blogname' );	$siteurl = site_url();	restore_current_blog();	$msg = sprintf( __( 'New Site: %1sURL: %2sRemote IP: %3sDisable these notifications: %4s' ), $blogname, $siteurl, $_SERVER['REMOTE_ADDR'], $options_site_url);	$msg = apply_filters( 'newblog_notify_siteadmin', $msg );	wp_mail( $email, sprintf( __( 'New Site Registration: %s' ), $siteurl ), $msg );	return true;}function newuser_notify_siteadmin( $user_id ) {	if ( get_site_option( 'registrationnotification' ) != 'yes' )		return false;	$email = get_site_option( 'admin_email' );	if ( is_email($email) == false )		return false;	$user = new WP_User($user_id);	$options_site_url = esc_url(network_admin_url('ms-options.php'));	$msg = sprintf(__('New User: %1sRemote IP: %2sDisable these notifications: %3s'), $user->user_login, $_SERVER['REMOTE_ADDR'], $options_site_url);	$msg = apply_filters( 'newuser_notify_siteadmin', $msg );	wp_mail( $email, sprintf(__('New User Registration: %s'), $user->user_login), $msg );	return true;}function domain_exists($domain, $path, $site_id = 1) {	global $wpdb;	return $wpdb->get_var( $wpdb->prepare("SELECT blog_id FROM $wpdb->blogs WHERE domain = %s AND path = %s AND site_id = %d", $domain, $path, $site_id) );}function insert_blog($domain, $path, $site_id) {	global $wpdb;	$path = trailingslashit($path);	$site_id = (int) $site_id;	$result = $wpdb->insert( $wpdb->blogs, array('site_id' => $site_id, 'domain' => $domain, 'path' => $path, 'registered' => current_time('mysql')) );	if ( ! $result )		return false;	refresh_blog_details($wpdb->insert_id);	return $wpdb->insert_id;}// Install an empty blog.  wpdb should already be switched.function install_blog($blog_id, $blog_title = '') {	global $wpdb, $table_prefix, $wp_roles;	$wpdb->suppress_errors();	// Cast for security	$blog_id = (int) $blog_id;	require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );	if ( $wpdb->get_results("SELECT ID FROM $wpdb->posts") )		die(__('<h1>Already Installed</h1><p>You appear to have already installed WordPress. To reinstall please clear your old database tables first.</p>') . '</body></html>');	$wpdb->suppress_errors(false);	$url = get_blogaddress_by_id($blog_id);	// Set everything up	make_db_current_silent();	populate_options();	populate_roles();	$wp_roles->_init();	// fix url.	update_option('siteurl', $url);	update_option('home', $url);	update_option('fileupload_url', $url . "files" );	update_option('upload_path', "wp-content/blogs.dir/" . $blog_id . "/files");	update_option('blogname', stripslashes( $blog_title ) );	update_option('admin_email', '');	$wpdb->update( $wpdb->options, array('option_value' => ''), array('option_name' => 'admin_email') );	// remove all perms	$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->usermeta WHERE meta_key = %s", $table_prefix.'user_level') );	$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->usermeta WHERE meta_key = %s", $table_prefix.'capabilities') );	$wpdb->suppress_errors( false );}// Deprecated, use wp_install_defaults()// should be switched already as $blog_id is ignored.function install_blog_defaults($blog_id, $user_id) {	global $wpdb;	require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );	$wpdb->suppress_errors();	wp_install_defaults($user_id);	$wpdb->suppress_errors( false );}function wpmu_welcome_notification($blog_id, $user_id, $password, $title, $meta = '') {	global $current_site;	if ( !apply_filters('wpmu_welcome_notification', $blog_id, $user_id, $password, $title, $meta) )		return false;	$welcome_email = stripslashes( get_site_option( 'welcome_email' ) );	if ( $welcome_email == false )		$welcome_email = stripslashes( __( 'Dear User,Your new SITE_NAME site has been successfully set up at:BLOG_URLYou can log in to the administrator account with the following information:Username: USERNAMEPassword: PASSWORDLogin Here: BLOG_URLwp-login.phpWe hope you enjoy your new site.Thanks!--The Team @ SITE_NAME' ) );	$url = get_blogaddress_by_id($blog_id);	$user = new WP_User($user_id);	$welcome_email = str_replace( 'SITE_NAME', $current_site->site_name, $welcome_email );	$welcome_email = str_replace( 'BLOG_TITLE', $title, $welcome_email );	$welcome_email = str_replace( 'BLOG_URL', $url, $welcome_email );	$welcome_email = str_replace( 'USERNAME', $user->user_login, $welcome_email );	$welcome_email = str_replace( 'PASSWORD', $password, $welcome_email );	$welcome_email = apply_filters( 'update_welcome_email', $welcome_email, $blog_id, $user_id, $password, $title, $meta);	$admin_email = get_site_option( 'admin_email' );	if ( $admin_email == '' )		$admin_email = 'support@' . $_SERVER['SERVER_NAME'];	$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );	$message_headers = "From: \"{$from_name}\" <{$admin_email}>\n" . "Content-Type: text/plain; charset=\"" . get_option('blog_charset') . "\"\n";	$message = $welcome_email;	if ( empty( $current_site->site_name ) )		$current_site->site_name = 'WordPress MU';	$subject = apply_filters( 'update_welcome_subject', sprintf(__('New %1$s Site: %2$s'), $current_site->site_name, stripslashes( $title ) ) );	wp_mail($user->user_email, $subject, $message, $message_headers);	return true;}function wpmu_welcome_user_notification($user_id, $password, $meta = '') {	global $current_site;	if ( !apply_filters('wpmu_welcome_user_notification', $user_id, $password, $meta) )		return false;	$welcome_email = get_site_option( 'welcome_user_email' );	$user = new WP_User($user_id);	$welcome_email = apply_filters( 'update_welcome_user_email', $welcome_email, $user_id, $password, $meta);	$welcome_email = str_replace( 'SITE_NAME', $current_site->site_name, $welcome_email );	$welcome_email = str_replace( 'USERNAME', $user->user_login, $welcome_email );	$welcome_email = str_replace( 'PASSWORD', $password, $welcome_email );	$welcome_email = str_replace( 'LOGINLINK', wp_login_url(), $welcome_email );	$admin_email = get_site_option( 'admin_email' );	if ( $admin_email == '' )		$admin_email = 'support@' . $_SERVER['SERVER_NAME'];	$from_name = get_site_option( 'site_name' ) == '' ? 'WordPress' : esc_html( get_site_option( 'site_name' ) );	$message_headers = "From: \"{$from_name}\" <{$admin_email}>\n" . "Content-Type: text/plain; charset=\"" . get_option('blog_charset') . "\"\n";	$message = $welcome_email;	if ( empty( $current_site->site_name ) )		$current_site->site_name = 'WordPress MU';	$subject = apply_filters( 'update_welcome_user_subject', sprintf(__('New %1$s User: %2$s'), $current_site->site_name, $user->user_login) );	wp_mail($user->user_email, $subject, $message, $message_headers);	return true;}function get_current_site() {	global $current_site;	return $current_site;}function get_user_id_from_string( $string ) {	$user_id = 0;	if ( is_email( $string ) ) {		$user = get_user_by('email', $string);		if ( $user )			$user_id = $user->ID;	} elseif ( is_numeric( $string ) ) {		$user_id = $string;	} else {		$user = get_user_by('login', $string);		if ( $user )			$user_id = $user->ID;	}	return $user_id;}function get_most_recent_post_of_user( $user_id ) {	global $wpdb;	$user_blogs = get_blogs_of_user( (int) $user_id );	$most_recent_post = array();	// Walk through each blog and get the most recent post	// published by $user_id	foreach ( (array) $user_blogs as $blog ) {		$recent_post = $wpdb->get_row( $wpdb->prepare("SELECT ID, post_date_gmt FROM {$wpdb->base_prefix}{$blog->userblog_id}_posts WHERE post_author = %d AND post_type = 'post' AND post_status = 'publish' ORDER BY post_date_gmt DESC LIMIT 1", $user_id ), ARRAY_A);		// Make sure we found a post		if ( isset($recent_post['ID']) ) {			$post_gmt_ts = strtotime($recent_post['post_date_gmt']);			// If this is the first post checked or if this post is			// newer than the current recent post, make it the new			// most recent post.			if ( !isset($most_recent_post['post_gmt_ts']) || ( $post_gmt_ts > $most_recent_post['post_gmt_ts'] ) ) {				$most_recent_post = array(					'blog_id'		=> $blog->userblog_id,					'post_id'		=> $recent_post['ID'],					'post_date_gmt'	=> $recent_post['post_date_gmt'],					'post_gmt_ts'	=> $post_gmt_ts				);			}		}	}	return $most_recent_post;}/* Misc functions */function get_dirsize( $directory ) {	$dirsize = get_transient( 'dirsize_cache' );	if ( is_array( $dirsize ) && isset( $dirsize[ $directory ][ 'size' ] ) )		return $dirsize[ $directory ][ 'size' ];	if ( false == is_array( $dirsize ) )		$dirsize = array();	$dirsize[ $directory ][ 'size' ] = recurse_dirsize( $directory );	set_transient( 'dirsize_cache', $dirsize, 3600 );	return $dirsize[ $directory ][ 'size' ];}function recurse_dirsize( $directory ) {	$size = 0;	if ( substr( $directory, -1 ) == '/' )		$directory = substr($directory,0,-1);	if ( !file_exists($directory) || !is_dir( $directory ) || !is_readable( $directory ) )		return false;	if ($handle = opendir($directory)) {		while(($file = readdir($handle)) !== false) {			$path = $directory.'/'.$file;			if ($file != '.' && $file != '..') {				if (is_file($path)) {					$size += filesize($path);				} elseif (is_dir($path)) {					$handlesize = recurse_dirsize($path);					if ($handlesize > 0)						$size += $handlesize;				}			}		}		closedir($handle);	}	return $size;}function upload_is_user_over_quota( $echo = true ) {	if ( get_site_option( 'upload_space_check_disabled' ) )		return true;	$spaceAllowed = get_space_allowed();	if ( empty( $spaceAllowed ) || !is_numeric( $spaceAllowed ) )		$spaceAllowed = 10;	// Default space allowed is 10 MB	$dirName = BLOGUPLOADDIR;	$size = get_dirsize($dirName) / 1024 / 1024;	if ( ($spaceAllowed-$size) < 0 ) {		if ( $echo )			_e( 'Sorry, you have used your space allocation. Please delete some files to upload more files.' ); // No space left		return true;	} else {		return false;	}}function check_upload_mimes( $mimes ) {	$site_exts = explode( ' ', get_site_option( 'upload_filetypes' ) );	foreach ( $site_exts as $ext ) {		foreach ( $mimes as $ext_pattern => $mime ) {			if ( $ext != '' && strpos( $ext_pattern, $ext ) !== false )				$site_mimes[$ext_pattern] = $mime;		}	}	return $site_mimes;}function update_posts_count( $deprecated = '' ) {	global $wpdb;	update_option( 'post_count', (int) $wpdb->get_var( "SELECT COUNT(ID) FROM {$wpdb->posts} WHERE post_status = 'publish' and post_type = 'post'" ) );}function wpmu_log_new_registrations( $blog_id, $user_id ) {	global $wpdb;	$user = new WP_User( (int) $user_id );	$wpdb->insert( $wpdb->registration_log, array('email' => $user->user_email, 'IP' => preg_replace( '/[^0-9., ]/', '',$_SERVER['REMOTE_ADDR'] ), 'blog_id' => $blog_id, 'date_registered' => current_time('mysql')) );}function fix_import_form_size( $size ) {	if ( upload_is_user_over_quota( false ) == true )		return 0;	$spaceAllowed = 1024 * 1024 * get_space_allowed();	$dirName = BLOGUPLOADDIR;	$dirsize = get_dirsize($dirName) ;	if ( $size > $spaceAllowed - $dirsize )		return $spaceAllowed - $dirsize; // remaining space	else		return $size; // default}/** * Maintains a canonical list of terms by syncing terms created for each blog with the global terms table. * * @since 3.0.0 * * @see term_id_filter * * @param int $term_id An ID for a term on the current blog. * @return int An ID from the global terms table mapped from $term_id. */function global_terms( $term_id, $deprecated = '' ) {	global $wpdb;	static $global_terms_recurse = null;	if ( !global_terms_enabled() )		return $term_id;	// prevent a race condition	$recurse_start = false;	if ( $global_terms_recurse === null ) {		$recurse_start = true;		$global_terms_recurse = 1;	} elseif ( 10 < $global_terms_recurse++ ) {		return $term_id;	}	$term_id = intval( $term_id );	$c = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->terms WHERE term_id = %d", $term_id ) );	$global_id = $wpdb->get_var( $wpdb->prepare( "SELECT cat_ID FROM $wpdb->sitecategories WHERE category_nicename = %s", $c->slug ) );	if ( $global_id == null ) {		$used_global_id = $wpdb->get_var( $wpdb->prepare( "SELECT cat_ID FROM $wpdb->sitecategories WHERE cat_ID = %d", $c->term_id ) );		if ( null == $used_global_id ) {			$wpdb->insert( $wpdb->sitecategories, array( 'cat_ID' => $term_id, 'cat_name' => $c->name, 'category_nicename' => $c->slug ) );			$global_id = $wpdb->insert_id;			if ( empty( $global_id ) )				return $term_id;		} else {			$max_global_id = $wpdb->get_var( "SELECT MAX(cat_ID) FROM $wpdb->sitecategories" );			$max_local_id = $wpdb->get_var( "SELECT MAX(term_id) FROM $wpdb->terms" );			$new_global_id = max( $max_global_id, $max_local_id ) + mt_rand( 100, 400 );			$wpdb->insert( $wpdb->sitecategories, array( 'cat_ID' => $new_global_id, 'cat_name' => $c->name, 'category_nicename' => $c->slug ) );			$global_id = $wpdb->insert_id;		}	} elseif ( $global_id != $term_id ) {		$local_id = $wpdb->get_row( $wpdb->prepare( "SELECT term_id FROM $wpdb->terms WHERE term_id = %d", $global_id ) );		if ( null != $local_id )			$local_id = global_terms( $local_id );			if ( 10 < $global_terms_recurse )				$global_id = $term_id;	}	if ( $global_id != $term_id ) {		if ( get_option( 'default_category' ) == $term_id )			update_option( 'default_category', $global_id );		$wpdb->update( $wpdb->terms, array('term_id' => $global_id), array('term_id' => $term_id) );		$wpdb->update( $wpdb->term_taxonomy, array('term_id' => $global_id), array('term_id' => $term_id) );		$wpdb->update( $wpdb->term_taxonomy, array('parent' => $global_id), array('parent' => $term_id) );		clean_term_cache($term_id);	}	if( $recurse_start )		$global_terms_recurse = null;	return $global_id;}function redirect_this_site( $deprecated = '' ) {	global $current_site;	return array( $current_site->domain );}function upload_is_file_too_big( $upload ) {	if ( is_array( $upload ) == false || defined( 'WP_IMPORTING' ) )		return $upload;	if ( strlen( $upload['bits'] )  > ( 1024 * get_site_option( 'fileupload_maxk', 1500 ) ) )		return sprintf( __( 'This file is too big. Files must be less than %d KB in size.' ) . '<br />', get_site_option( 'fileupload_maxk', 1500 ));	return $upload;}function wordpressmu_wp_mail_from( $email ) {	if ( strpos( $email, 'wordpress@' ) !== false )		$email = get_option( 'admin_email' );	return $email;}function signup_nonce_fields() {	$id = mt_rand();	echo "<input type='hidden' name='signup_form_id' value='{$id}' />";	wp_nonce_field('signup_form_' . $id, '_signup_form', false);}function signup_nonce_check( $result ) {	if ( !strpos( $_SERVER[ 'PHP_SELF' ], 'wp-signup.php' ) )		return $result;	if ( wp_create_nonce('signup_form_' . $_POST[ 'signup_form_id' ]) != $_POST['_signup_form'] )		wp_die( __('Please try again!') );	return $result;}function maybe_redirect_404() {	global $current_site;	if ( is_main_site() && is_404() && defined( 'NOBLOGREDIRECT' ) && ( $destination = apply_filters( 'blog_redirect_404', NOBLOGREDIRECT ) ) ) {		if ( $destination == '%siteurl%' )			$destination = network_home_url();		wp_redirect( $destination );		exit();	}}function maybe_add_existing_user_to_blog() {	if ( false === strpos( $_SERVER[ 'REQUEST_URI' ], '/newbloguser/' ) )		return false;	$parts = explode( '/', $_SERVER[ 'REQUEST_URI' ] );	$key = array_pop( $parts );	if ( $key == '' )		$key = array_pop( $parts );	$details = get_option( 'new_user_' . $key );	if ( !empty( $details ) )		delete_option( 'new_user_' . $key );	if ( empty( $details ) || is_wp_error( add_existing_user_to_blog( $details ) ) )		wp_die( sprintf(__('An error occurred adding you to this site. Back to the <a href="%s">homepage</a>.'), site_url() ) );	wp_die( sprintf(__('You have been added to this site. Please visit the <a href="%s">homepage</a> or <a href="%s">login</a> using your username and password.'), site_url(), admin_url() ), __('Success') );}function add_existing_user_to_blog( $details = false ) {	if ( is_array( $details ) ) {		$result = add_user_to_blog( '', $details[ 'user_id' ], $details[ 'role' ] );		do_action( 'added_existing_user', $details[ 'user_id' ], $result );	}	return $result;}function add_new_user_to_blog( $user_id, $email, $meta ) {	global $current_site;	if ( $meta[ 'add_to_blog' ] ) {		$blog_id = $meta[ 'add_to_blog' ];		$role = $meta[ 'new_role' ];		remove_user_from_blog($user_id, $current_site->blogid); // remove user from main blog.		add_user_to_blog( $blog_id, $user_id, $role );		update_user_meta( $user_id, 'primary_blog', $blog_id );	}}function fix_phpmailer_messageid( $phpmailer ) {	global $current_site;	$phpmailer->Hostname = $current_site->domain;}function is_user_spammy( $username = 0 ) {	if ( $username == 0 ) {		global $current_user;		$user_id = $current_user->ID;	} else {		$user_id = get_user_id_from_string( $username );	}	$u = new WP_User( $user_id );	if ( $u->spam == 1 )		return true;	return false;}function update_blog_public( $old_value, $value ) {	global $wpdb;	do_action('update_blog_public');	update_blog_status( $wpdb->blogid, 'public', (int) $value );}add_action('update_option_blog_public', 'update_blog_public', 10, 2);/* Redirect all hits to "dashboard" blog to wp-admin/ Dashboard. */function redirect_mu_dashboard() {	global $current_site, $current_blog;	$dashboard_blog = get_dashboard_blog();	if ( $current_blog->blog_id == $dashboard_blog->blog_id && $dashboard_blog->blog_id != $current_site->blog_id ) {		$protocol = ( is_ssl() ? 'https://' : 'http://' );		wp_redirect( $protocol . $dashboard_blog->domain . trailingslashit( $dashboard_blog->path ) . 'wp-admin/' );		die();	}}add_action( 'template_redirect', 'redirect_mu_dashboard' );function get_dashboard_blog() {	if ( $blog = get_site_option( 'dashboard_blog' ) )		return get_blog_details( $blog );	return get_blog_details( $GLOBALS['current_site']->blog_id );}function is_user_option_local( $key, $user_id = 0, $blog_id = 0 ) {	global $current_user, $wpdb;	if ( $user_id == 0 )		$user_id = $current_user->ID;	if ( $blog_id == 0 )		$blog_id = $wpdb->blogid;	$local_key = $wpdb->base_prefix . $blog_id . '_' . $key;	if ( isset( $current_user->$local_key ) )		return true;	return false;}function users_can_register_signup_filter() {	$registration = get_site_option('registration');	if ( $registration == 'all' || $registration == 'user' )		return true;	return false;}add_filter('option_users_can_register', 'users_can_register_signup_filter');function welcome_user_msg_filter( $text ) {	if ( !$text ) {		return __( 'Dear User,Your new account is set up.You can log in with the following information:Username: USERNAMEPassword: PASSWORDLOGINLINKThanks!--The Team @ SITE_NAME' );	}	return $text;}add_filter( 'site_option_welcome_user_email', 'welcome_user_msg_filter' );/** * Whether to force SSL on content. * * @since 2.8.5 * * @param string|bool $force * @return bool True if forced, false if not forced. */function force_ssl_content( $force = '' ) {	static $forced_content;	if ( '' != $force ) {		$old_forced = $forced_content;		$forced_content = $force;		return $old_forced;	}	return $forced_content;}/** * Formats an String URL to use HTTPS if HTTP is found. * Useful as a filter. * * @since 2.8.5 **/function filter_SSL( $url ) {	if ( !is_string( $url ) )		return get_bloginfo( 'url' ); //return home blog url with proper scheme	$arrURL = parse_url( $url );	if ( force_ssl_content() && is_ssl() ) {		if ( 'http' === $arrURL['scheme'] && 'https' !== $arrURL['scheme'] )			$url = str_replace( $arrURL['scheme'], 'https', $url );	}	return $url;}?>
<?php/** * Post advanced form for inclusion in the administration panels. * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');wp_enqueue_script('post');if ( post_type_supports($post_type, 'editor') ) {	if ( user_can_richedit() )		wp_enqueue_script('editor');	wp_enqueue_script('word-count');}if ( post_type_supports($post_type, 'editor') || post_type_supports($post_type, 'thumbnail') ) {	add_thickbox();	wp_enqueue_script('media-upload');}/** * Post ID global * @name $post_ID * @var int */$post_ID = isset($post_ID) ? (int) $post_ID : 0;$temp_ID = isset($temp_ID) ? (int) $temp_ID : 0;$user_ID = isset($user_ID) ? (int) $user_ID : 0;$action = isset($action) ? $action : '';$messages = array();$messages['post'] = array(	 0 => '', // Unused. Messages start at index 1.	 1 => sprintf( __('Post updated. <a href="%s">View post</a>'), esc_url( get_permalink($post_ID) ) ),	 2 => __('Custom field updated.'),	 3 => __('Custom field deleted.'),	 4 => __('Post updated.'),	/* translators: %s: date and time of the revision */	 5 => isset($_GET['revision']) ? sprintf( __('Post restored to revision from %s'), wp_post_revision_title( (int) $_GET['revision'], false ) ) : false,	 6 => sprintf( __('Post published. <a href="%s">View post</a>'), esc_url( get_permalink($post_ID) ) ),	 7 => __('Post saved.'),	 8 => sprintf( __('Post submitted. <a target="_blank" href="%s">Preview post</a>'), esc_url( add_query_arg( 'preview', 'true', get_permalink($post_ID) ) ) ),	 9 => sprintf( __('Post scheduled for: <strong>%1$s</strong>. <a target="_blank" href="%2$s">Preview post</a>'),		// translators: Publish box date format, see http://php.net/date		date_i18n( __( 'M j, Y @ G:i' ), strtotime( $post->post_date ) ), esc_url( get_permalink($post_ID) ) ),	10 => sprintf( __('Post draft updated. <a target="_blank" href="%s">Preview post</a>'), esc_url( add_query_arg( 'preview', 'true', get_permalink($post_ID) ) ) ),);$messages['page'] = array(	 0 => '', // Unused. Messages start at index 1.	 1 => sprintf( __('Page updated. <a href="%s">View page</a>'), esc_url( get_permalink($post_ID) ) ),	 2 => __('Custom field updated.'),	 3 => __('Custom field deleted.'),	 4 => __('Page updated.'),	 5 => isset($_GET['revision']) ? sprintf( __('Page restored to revision from %s'), wp_post_revision_title( (int) $_GET['revision'], false ) ) : false,	 6 => sprintf( __('Page published. <a href="%s">View page</a>'), esc_url( get_permalink($post_ID) ) ),	 7 => __('Page saved.'),	 8 => sprintf( __('Page submitted. <a target="_blank" href="%s">Preview page</a>'), esc_url( add_query_arg( 'preview', 'true', get_permalink($post_ID) ) ) ),	 9 => sprintf( __('Page scheduled for: <strong>%1$s</strong>. <a target="_blank" href="%2$s">Preview page</a>'), date_i18n( __( 'M j, Y @ G:i' ), strtotime( $post->post_date ) ), esc_url( get_permalink($post_ID) ) ),	10 => sprintf( __('Page draft updated. <a target="_blank" href="%s">Preview page</a>'), esc_url( add_query_arg( 'preview', 'true', get_permalink($post_ID) ) ) ),);$messages = apply_filters( 'post_updated_messages', $messages );$message = false;if ( isset($_GET['message']) ) {	$_GET['message'] = absint( $_GET['message'] );	if ( isset($messages[$post_type][$_GET['message']]) )		$message = $messages[$post_type][$_GET['message']];	elseif ( !isset($messages[$post_type]) && isset($messages['post'][$_GET['message']]) )		$message = $messages['post'][$_GET['message']];}$notice = false;$form_extra = '';if ( 'auto-draft' == $post->post_status ) {	if ( 'edit' == $action )		$post->post_title = '';	$autosave = false;	$form_extra .= "<input type='hidden' id='auto_draft' name='auto_draft' value='1' />";} else {	$autosave = wp_get_post_autosave( $post_ID );}$form_action = 'editpost';$nonce_action = 'update-' . $post_type . '_' . $post_ID;$form_extra .= "<input type='hidden' id='post_ID' name='post_ID' value='" . esc_attr($post_ID) . "' />";// Detect if there exists an autosave newer than the post and if that autosave is different than the postif ( $autosave && mysql2date( 'U', $autosave->post_modified_gmt, false ) > mysql2date( 'U', $post->post_modified_gmt, false ) ) {	foreach ( _wp_post_revision_fields() as $autosave_field => $_autosave_field ) {		if ( normalize_whitespace( $autosave->$autosave_field ) != normalize_whitespace( $post->$autosave_field ) ) {			$notice = sprintf( __( 'There is an autosave of this post that is more recent than the version below.  <a href="%s">View the autosave</a>' ), get_edit_post_link( $autosave->ID ) );			break;		}	}	unset($autosave_field, $_autosave_field);}$post_type_object = get_post_type_object($post_type);// All meta boxes should be defined and added before the first do_meta_boxes() call (or potentially during the do_meta_boxes action).require_once('./includes/meta-boxes.php');add_meta_box('submitdiv', __('Publish'), 'post_submit_meta_box', $post_type, 'side', 'core');// all taxonomiesforeach ( get_object_taxonomies($post_type) as $tax_name ) {	$taxonomy = get_taxonomy($tax_name);	if ( ! $taxonomy->show_ui )		continue;	$label = $taxonomy->labels->name;	if ( !is_taxonomy_hierarchical($tax_name) )		add_meta_box('tagsdiv-' . $tax_name, $label, 'post_tags_meta_box', $post_type, 'side', 'core', array( 'taxonomy' => $tax_name ));	else		add_meta_box($tax_name . 'div', $label, 'post_categories_meta_box', $post_type, 'side', 'core', array( 'taxonomy' => $tax_name ));}if ( post_type_supports($post_type, 'page-attributes') )	add_meta_box('pageparentdiv', 'page' == $post_type ? __('Page Attributes') : __('Attributes'), 'page_attributes_meta_box', $post_type, 'side', 'core');if ( current_theme_supports( 'post-thumbnails', $post_type ) && post_type_supports( $post_type, 'thumbnail' )	&& ( ! is_multisite() || ( ( $mu_media_buttons = get_site_option( 'mu_media_buttons', array() ) ) && ! empty( $mu_media_buttons['image'] ) ) ) )		add_meta_box('postimagediv', __('Featured Image'), 'post_thumbnail_meta_box', $post_type, 'side', 'low');if ( post_type_supports($post_type, 'excerpt') )	add_meta_box('postexcerpt', __('Excerpt'), 'post_excerpt_meta_box', $post_type, 'normal', 'core');if ( post_type_supports($post_type, 'trackbacks') )	add_meta_box('trackbacksdiv', __('Send Trackbacks'), 'post_trackback_meta_box', $post_type, 'normal', 'core');if ( post_type_supports($post_type, 'custom-fields') )	add_meta_box('postcustom', __('Custom Fields'), 'post_custom_meta_box', $post_type, 'normal', 'core');do_action('dbx_post_advanced');if ( post_type_supports($post_type, 'comments') )	add_meta_box('commentstatusdiv', __('Discussion'), 'post_comment_status_meta_box', $post_type, 'normal', 'core');if ( ('publish' == $post->post_status || 'private' == $post->post_status) && post_type_supports($post_type, 'comments') )	add_meta_box('commentsdiv', __('Comments'), 'post_comment_meta_box', $post_type, 'normal', 'core');if ( !( 'pending' == $post->post_status && !current_user_can( $post_type_object->cap->publish_posts ) ) )	add_meta_box('slugdiv', __('Slug'), 'post_slug_meta_box', $post_type, 'normal', 'core');if ( post_type_supports($post_type, 'author') ) {	$authors = get_editable_user_ids( $current_user->id ); // TODO: ROLE SYSTEM	if ( $post->post_author && !in_array($post->post_author, $authors) )		$authors[] = $post->post_author;	if ( ( $authors && count( $authors ) > 1 ) || is_super_admin() )		add_meta_box('authordiv', __('Author'), 'post_author_meta_box', $post_type, 'normal', 'core');}if ( post_type_supports($post_type, 'revisions') && 0 < $post_ID && wp_get_post_revisions( $post_ID ) )	add_meta_box('revisionsdiv', __('Revisions'), 'post_revisions_meta_box', $post_type, 'normal', 'core');do_action('add_meta_boxes', $post_type, $post);do_action('add_meta_boxes_' . $post_type, $post);do_action('do_meta_boxes', $post_type, 'normal', $post);do_action('do_meta_boxes', $post_type, 'advanced', $post);do_action('do_meta_boxes', $post_type, 'side', $post);if ( 'post' == $post_type ) {	add_contextual_help($current_screen,	'<p>' . __('The title field and the big Post Editing Area are fixed in place, but you can reposition all the other boxes that allow you to add metadata to your post using drag and drop, and can minimize or expand them by clicking the title bar of the box. You can also hide any of the boxes by using the Screen Options tab, where you can also choose a 1- or 2-column layout for this screen.') . '</p>' .	'<p>' . __('<strong>Title</strong> - Enter a title for your post. After you enter a title, you&#8217;ll see the permalink below, which you can edit.') . '</p>' .	'<p>' . __('<strong>Post editor</strong> - Enter the text for your post. There are two modes of editing: Visual and HTML. Choose the mode by clicking on the appropriate tab. Visual mode gives you a WYSIWYG editor. Click the last icon in the row to get a second row of controls. The HTML mode allows you to enter raw HTML along with your post text. You can insert media files by clicking the icons above the post editor and following the directions.') . '</p>' .	'<p>' . __('<strong>Publish</strong> - You can set the terms of publishing your post in the Publish box. For Status, Visibility, and Publish (immediately), click on the Edit link to reveal more options. Visibility includes options for password-protecting a post or making it stay at the top of your blog indefinitely (sticky). Publish (immediately) allows you to set a future or past date and time, so you can schedule a post to be published in the future or backdate a post.') . '</p>' .	'<p>' . __('<strong>Featured Image</strong> - This allows you to associate an image with your post without inserting it. This is usually useful only if your theme makes use of the featured image as a post thumbnail on the home page, a custom header, etc.') . '</p>' .	'<p>' . __('<strong>Send Trackbacks</strong> - Trackbacks are a way to notify legacy blog systems that you&#8217;ve linked to them. Enter the URL(s) you want to send trackbacks. If you link to other WordPress sites they&#8217;ll be notified automatically using pingbacks, and this field is unnecessary.') . '</p>' .	'<p>' . __('<strong>Discussion</strong> - You can turn comments and pings on or off, and if there are comments on the post, you can see them here and moderate them.') . '</p>' .	'<p>' . sprintf(__('You can also create posts with the <a href="%s">Press This bookmarklet</a>.'), 'options-writing.php') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Writing_Posts" target="_blank">Documentation on Writing Posts</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>'	);} elseif ( 'page' == $post_type ) {	add_contextual_help($current_screen, '<p>' . __('Pages are similar to Posts in that they have a title, body text, and associated metadata, but they are different in that they are not part of the chronological blog stream, kind of like permanent posts. Pages are not categorized or tagged, but can have a hierarchy. You can nest Pages under other Pages by making one the &#8220;Parent&#8221; of the other, creating a group of Pages.') . '</p>' .	'<p>' . __('Creating a Page is very similar to creating a Post, and the screens can be customized in the same way using drag and drop, the Screen Options tab, and expanding/collapsing boxes as you choose. The Page editor mostly works the same Post editor, but there are some Page-specific features in the Page Attributes box:') . '</p>' .	'<p>' . __('<strong>Parent</strong> - You can arrange your pages in hierarchies. For example, you could have an &#8220;About&#8221; page that has &#8220;Life Story&#8221; and &#8220;My Dog&#8221; pages under it. There are no limits to how many levels you can nest pages.') . '</p>' .	'<p>' . __('<strong>Template</strong> - Some themes have custom templates you can use for certain pages that might have additional features or custom layouts. If so, you&#8217;ll see them in this dropdown menu.') . '</p>' .	'<p>' . __('<strong>Order</strong> - Pages are usually ordered alphabetically, but you can choose your own order by entering a number (1 for first, etc.) in this field.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Pages_Add_New_SubPanel" target="_blank">Page Creation Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>'	);}require_once('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><?php if ( $notice ) : ?><div id="notice" class="error"><p><?php echo $notice ?></p></div><?php endif; ?><?php if ( $message ) : ?><div id="message" class="updated"><p><?php echo $message; ?></p></div><?php endif; ?><form name="post" action="post.php" method="post" id="post"<?php do_action('post_edit_form_tag'); ?>><?php wp_nonce_field($nonce_action); ?><input type="hidden" id="user-id" name="user_ID" value="<?php echo (int) $user_ID ?>" /><input type="hidden" id="hiddenaction" name="action" value="<?php echo esc_attr($form_action) ?>" /><input type="hidden" id="originalaction" name="originalaction" value="<?php echo esc_attr($form_action) ?>" /><input type="hidden" id="post_author" name="post_author" value="<?php echo esc_attr( $post->post_author ); ?>" /><input type="hidden" id="post_type" name="post_type" value="<?php echo esc_attr($post_type) ?>" /><input type="hidden" id="original_post_status" name="original_post_status" value="<?php echo esc_attr($post->post_status) ?>" /><input type="hidden" id="referredby" name="referredby" value="<?php echo esc_url(stripslashes(wp_get_referer())); ?>" /><?phpif ( 'draft' != $post->post_status )	wp_original_referer_field(true, 'previous');echo $form_extra;wp_nonce_field( 'autosave', 'autosavenonce', false );wp_nonce_field( 'meta-box-order', 'meta-box-order-nonce', false );wp_nonce_field( 'closedpostboxes', 'closedpostboxesnonce', false );?><div id="poststuff" class="metabox-holder<?php echo 2 == $screen_layout_columns ? ' has-right-sidebar' : ''; ?>"><div id="side-info-column" class="inner-sidebar"><?php('page' == $post_type) ? do_action('submitpage_box') : do_action('submitpost_box');$side_meta_boxes = do_meta_boxes($post_type, 'side', $post);?></div><div id="post-body"><div id="post-body-content"><?php if ( post_type_supports($post_type, 'title') ) { ?><div id="titlediv"><div id="titlewrap">	<label class="hide-if-no-js" style="visibility:hidden" id="title-prompt-text" for="title"><?php _e('Enter title here') ?></label>	<input type="text" name="post_title" size="30" tabindex="1" value="<?php echo esc_attr( htmlspecialchars( $post->post_title ) ); ?>" id="title" autocomplete="off" /></div><div class="inside"><?php$sample_permalink_html = get_sample_permalink_html($post->ID);$shortlink = wp_get_shortlink($post->ID, 'post');if ( !empty($shortlink) )    $sample_permalink_html .= '<input id="shortlink" type="hidden" value="' . esc_attr($shortlink) . '" /><a href="#" class="button" onclick="prompt(&#39;URL:&#39;, jQuery(\'#shortlink\').val()); return false;">' . __('Get Shortlink') . '</a>';if ( !( 'pending' == $post->post_status && !current_user_can( $post_type_object->cap->publish_posts ) ) ) { ?>	<div id="edit-slug-box">	<?php		if ( ! empty($post->ID) && ! empty($sample_permalink_html) && 'auto-draft' != $post->post_status )			echo $sample_permalink_html;	?>	</div><?php}?></div><?phpwp_nonce_field( 'samplepermalink', 'samplepermalinknonce', false );?></div><?php } ?><?php if ( post_type_supports($post_type, 'editor') ) { ?><div id="<?php echo user_can_richedit() ? 'postdivrich' : 'postdiv'; ?>" class="postarea"><?php the_editor($post->post_content); ?><table id="post-status-info" cellspacing="0"><tbody><tr>	<td id="wp-word-count"></td>	<td class="autosave-info">	<span id="autosave">&nbsp;</span><?php	if ( 'auto-draft' != $post->post_status ) {		echo '<span id="last-edit">';		if ( $last_id = get_post_meta($post_ID, '_edit_last', true) ) {			$last_user = get_userdata($last_id);			printf(__('Last edited by %1$s on %2$s at %3$s'), esc_html( $last_user->display_name ), mysql2date(get_option('date_format'), $post->post_modified), mysql2date(get_option('time_format'), $post->post_modified));		} else {			printf(__('Last edited on %1$s at %2$s'), mysql2date(get_option('date_format'), $post->post_modified), mysql2date(get_option('time_format'), $post->post_modified));		}		echo '</span>';	} ?>	</td></tr></tbody></table></div><?php}do_meta_boxes($post_type, 'normal', $post);( 'page' == $post_type ) ? do_action('edit_page_form') : do_action('edit_form_advanced');do_meta_boxes($post_type, 'advanced', $post);do_action('dbx_post_sidebar'); ?></div></div><br class="clear" /></div><!-- /poststuff --></form></div><?php wp_comment_reply(); ?><?php if ((isset($post->post_title) && '' == $post->post_title) || (isset($_GET['message']) && 2 > $_GET['message'])) : ?><script type="text/javascript">try{document.post.title.focus();}catch(e){}</script><?php endif; ?>
<?php/** * General template tags that can go anywhere in a template. * * @package WordPress * @subpackage Template *//** * Load header template. * * Includes the header template for a theme or if a name is specified then a * specialised header will be included. * * For the parameter, if the file is called "header-special.php" then specify * "special". * * @uses locate_template() * @since 1.5.0 * @uses do_action() Calls 'get_header' action. * * @param string $name The name of the specialised header. */function get_header( $name = null ) {	do_action( 'get_header', $name );	$templates = array();	if ( isset($name) )		$templates[] = "header-{$name}.php";	$templates[] = "header.php";	// Backward compat code will be removed in a future release	if ('' == locate_template($templates, true))		load_template( WPINC . '/theme-compat/header.php');}/** * Load footer template. * * Includes the footer template for a theme or if a name is specified then a * specialised footer will be included. * * For the parameter, if the file is called "footer-special.php" then specify * "special". * * @uses locate_template() * @since 1.5.0 * @uses do_action() Calls 'get_footer' action. * * @param string $name The name of the specialised footer. */function get_footer( $name = null ) {	do_action( 'get_footer', $name );	$templates = array();	if ( isset($name) )		$templates[] = "footer-{$name}.php";	$templates[] = "footer.php";	// Backward compat code will be removed in a future release	if ('' == locate_template($templates, true))		load_template( WPINC . '/theme-compat/footer.php');}/** * Load sidebar template. * * Includes the sidebar template for a theme or if a name is specified then a * specialised sidebar will be included. * * For the parameter, if the file is called "sidebar-special.php" then specify * "special". * * @uses locate_template() * @since 1.5.0 * @uses do_action() Calls 'get_sidebar' action. * * @param string $name The name of the specialised sidebar. */function get_sidebar( $name = null ) {	do_action( 'get_sidebar', $name );	$templates = array();	if ( isset($name) )		$templates[] = "sidebar-{$name}.php";	$templates[] = "sidebar.php";	// Backward compat code will be removed in a future release	if ('' == locate_template($templates, true))		load_template( WPINC . '/theme-compat/sidebar.php');}/** * Load a template part into a template * * Makes it easy for a theme to reuse sections of code in a easy to overload way * for child themes. * * Includes the named template part for a theme or if a name is specified then a * specialised part will be included. If the theme contains no {slug}.php file * then no template will be included. * * The template is included using require, not require_once, so you may include the * same template part multiple times. * * For the parameter, if the file is called "{slug}-special.php" then specify * "special". * * @uses locate_template() * @since 3.0.0 * @uses do_action() Calls 'get_template_part{$slug}' action. * * @param string $slug The slug name for the generic template. * @param string $name The name of the specialised template. */function get_template_part( $slug, $name = null ) {	do_action( "get_template_part_{$slug}", $slug, $name );	$templates = array();	if ( isset($name) )		$templates[] = "{$slug}-{$name}.php";	$templates[] = "{$slug}.php";	locate_template($templates, true, false);}/** * Display search form. * * Will first attempt to locate the searchform.php file in either the child or * the parent, then load it. If it doesn't exist, then the default search form * will be displayed. The default search form is HTML, which will be displayed. * There is a filter applied to the search form HTML in order to edit or replace * it. The filter is 'get_search_form'. * * This function is primarily used by themes which want to hardcode the search * form into the sidebar and also by the search widget in WordPress. * * There is also an action that is called whenever the function is run called, * 'get_search_form'. This can be useful for outputting JavaScript that the * search relies on or various formatting that applies to the beginning of the * search. To give a few examples of what it can be used for. * * @since 2.7.0 * @param boolean $echo Default to echo and not return the form. */function get_search_form($echo = true) {	do_action( 'get_search_form' );	$search_form_template = locate_template(array('searchform.php'));	if ( '' != $search_form_template ) {		require($search_form_template);		return;	}	$form = '<form role="search" method="get" id="searchform" action="' . home_url( '/' ) . '" >	<div><label class="screen-reader-text" for="s">' . __('Search for:') . '</label>	<input type="text" value="' . get_search_query() . '" name="s" id="s" />	<input type="submit" id="searchsubmit" value="'. esc_attr__('Search') .'" />	</div>	</form>';	if ( $echo )		echo apply_filters('get_search_form', $form);	else		return apply_filters('get_search_form', $form);}/** * Display the Log In/Out link. * * Displays a link, which allows users to navigate to the Log In page to log in * or log out depending on whether they are currently logged in. * * @since 1.5.0 * @uses apply_filters() Calls 'loginout' hook on HTML link content. * * @param string $redirect Optional path to redirect to on login/logout. * @param boolean $echo Default to echo and not return the link. */function wp_loginout($redirect = '', $echo = true) {	if ( ! is_user_logged_in() )		$link = '<a href="' . esc_url( wp_login_url($redirect) ) . '">' . __('Log in') . '</a>';	else		$link = '<a href="' . esc_url( wp_logout_url($redirect) ) . '">' . __('Log out') . '</a>';	if ( $echo )		echo apply_filters('loginout', $link);	else		return apply_filters('loginout', $link);}/** * Returns the Log Out URL. * * Returns the URL that allows the user to log out of the site * * @since 2.7 * @uses wp_nonce_url() To protect against CSRF * @uses site_url() To generate the log in URL * @uses apply_filters() calls 'logout_url' hook on final logout url * * @param string $redirect Path to redirect to on logout. */function wp_logout_url($redirect = '') {	$args = array( 'action' => 'logout' );	if ( !empty($redirect) ) {		$args['redirect_to'] = urlencode( $redirect );	}	$logout_url = add_query_arg($args, site_url('wp-login.php', 'login'));	$logout_url = wp_nonce_url( $logout_url, 'log-out' );	return apply_filters('logout_url', $logout_url, $redirect);}/** * Returns the Log In URL. * * Returns the URL that allows the user to log in to the site * * @since 2.7 * @uses site_url() To generate the log in URL * @uses apply_filters() calls 'login_url' hook on final login url * * @param string $redirect Path to redirect to on login. * @param bool $force_reauth Whether to force reauthorization, even if a cookie is present. Default is false. * @return string A log in url */function wp_login_url($redirect = '', $force_reauth = false) {	$login_url = site_url('wp-login.php', 'login');	if ( !empty($redirect) )		$login_url = add_query_arg('redirect_to', urlencode($redirect), $login_url);	if ( $force_reauth )		$login_url = add_query_arg('reauth', '1', $login_url);	return apply_filters('login_url', $login_url, $redirect);}/** * Provides a simple login form for use anywhere within WordPress. By default, it echoes * the HTML immediately. Pass array('echo'=>false) to return the string instead. * * @since 3.0.0 * @param array $args Configuration options to modify the form output * @return Void, or string containing the form */function wp_login_form( $args = array() ) {	$defaults = array( 'echo' => true,						'redirect' => site_url( $_SERVER['REQUEST_URI'] ), // Default redirect is back to the current page	 					'form_id' => 'loginform',						'label_username' => __( 'Username' ),						'label_password' => __( 'Password' ),						'label_remember' => __( 'Remember Me' ),						'label_log_in' => __( 'Log In' ),						'id_username' => 'user_login',						'id_password' => 'user_pass',						'id_remember' => 'rememberme',						'id_submit' => 'wp-submit',						'remember' => true,						'value_username' => '',						'value_remember' => false, // Set this to true to default the "Remember me" checkbox to checked					);	$args = wp_parse_args( $args, apply_filters( 'login_form_defaults', $defaults ) );	$form = '		<form name="' . $args['form_id'] . '" id="' . $args['form_id'] . '" action="' . site_url( 'wp-login.php', 'login' ) . '" method="post">			' . apply_filters( 'login_form_top', '' ) . '			<p class="login-username">				<label for="' . esc_attr( $args['id_username'] ) . '">' . esc_html( $args['label_username'] ) . '</label>				<input type="text" name="log" id="' . esc_attr( $args['id_username'] ) . '" class="input" value="' . esc_attr( $args['value_username'] ) . '" size="20" tabindex="10" />			</p>			<p class="login-password">				<label for="' . esc_attr( $args['id_password'] ) . '">' . esc_html( $args['label_password'] ) . '</label>				<input type="password" name="pwd" id="' . esc_attr( $args['id_password'] ) . '" class="input" value="" size="20" tabindex="20" />			</p>			' . apply_filters( 'login_form_middle', '' ) . '			' . ( $args['remember'] ? '<p class="login-remember"><label><input name="rememberme" type="checkbox" id="' . esc_attr( $args['id_remember'] ) . '" value="forever" tabindex="90"' . ( $args['value_remember'] ? ' checked="checked"' : '' ) . ' /> ' . esc_html( $args['label_remember'] ) . '</label></p>' : '' ) . '			<p class="login-submit">				<input type="submit" name="wp-submit" id="' . esc_attr( $args['id_submit'] ) . '" class="button-primary" value="' . esc_attr( $args['label_log_in'] ) . '" tabindex="100" />				<input type="hidden" name="redirect_to" value="' . esc_attr( $args['redirect'] ) . '" />			</p>			' . apply_filters( 'login_form_bottom', '' ) . '		</form>';	if ( $args['echo'] )		echo $form;	else		return $form;}/** * Returns the Lost Password URL. * * Returns the URL that allows the user to retrieve the lost password * * @since 2.8.0 * @uses site_url() To generate the lost password URL * @uses apply_filters() calls 'lostpassword_url' hook on the lostpassword url * * @param string $redirect Path to redirect to on login. */function wp_lostpassword_url($redirect = '') {	$args = array( 'action' => 'lostpassword' );	if ( !empty($redirect) ) {		$args['redirect_to'] = $redirect;	}	$lostpassword_url = add_query_arg($args, site_url('wp-login.php', 'login'));	return apply_filters('lostpassword_url', $lostpassword_url, $redirect);}/** * Display the Registration or Admin link. * * Display a link which allows the user to navigate to the registration page if * not logged in and registration is enabled or to the dashboard if logged in. * * @since 1.5.0 * @uses apply_filters() Calls 'register' hook on register / admin link content. * * @param string $before Text to output before the link (defaults to <li>). * @param string $after Text to output after the link (defaults to </li>). * @param boolean $echo Default to echo and not return the link. */function wp_register( $before = '<li>', $after = '</li>', $echo = true ) {	if ( ! is_user_logged_in() ) {		if ( get_option('users_can_register') )			$link = $before . '<a href="' . site_url('wp-login.php?action=register', 'login') . '">' . __('Register') . '</a>' . $after;		else			$link = '';	} else {		$link = $before . '<a href="' . admin_url() . '">' . __('Site Admin') . '</a>' . $after;	}	if ( $echo )		echo apply_filters('register', $link);	else		return apply_filters('register', $link);}/** * Theme container function for the 'wp_meta' action. * * The 'wp_meta' action can have several purposes, depending on how you use it, * but one purpose might have been to allow for theme switching. * * @since 1.5.0 * @link http://trac.wordpress.org/ticket/1458 Explanation of 'wp_meta' action. * @uses do_action() Calls 'wp_meta' hook. */function wp_meta() {	do_action('wp_meta');}/** * Display information about the blog. * * @see get_bloginfo() For possible values for the parameter. * @since 0.71 * * @param string $show What to display. */function bloginfo( $show='' ) {	echo get_bloginfo( $show, 'display' );}/** * Retrieve information about the blog. * * Some show parameter values are deprecated and will be removed in future * versions. These options will trigger the _deprecated_argument() function. * The deprecated blog info options are listed in the function contents. * * The possible values for the 'show' parameter are listed below. * <ol> * <li><strong>url<strong> - Blog URI to homepage.</li> * <li><strong>wpurl</strong> - Blog URI path to WordPress.</li> * <li><strong>description</strong> - Secondary title</li> * </ol> * * The feed URL options can be retrieved from 'rdf_url' (RSS 0.91), * 'rss_url' (RSS 1.0), 'rss2_url' (RSS 2.0), or 'atom_url' (Atom feed). The * comment feeds can be retrieved from the 'comments_atom_url' (Atom comment * feed) or 'comments_rss2_url' (RSS 2.0 comment feed). * * @since 0.71 * * @param string $show Blog info to retrieve. * @param string $filter How to filter what is retrieved. * @return string Mostly string values, might be empty. */function get_bloginfo( $show = '', $filter = 'raw' ) {	switch( $show ) {		case 'home' : // DEPRECATED		case 'siteurl' : // DEPRECATED			_deprecated_argument( __FUNCTION__, '2.2', sprintf( __('The <code>%s</code> option is deprecated for the family of <code>bloginfo()</code> functions.' ), $show ) . ' ' . sprintf( __( 'Use the <code>%s</code> option instead.' ), 'url'  ) );		case 'url' :			$output = home_url();			break;		case 'wpurl' :			$output = site_url();			break;		case 'description':			$output = get_option('blogdescription');			break;		case 'rdf_url':			$output = get_feed_link('rdf');			break;		case 'rss_url':			$output = get_feed_link('rss');			break;		case 'rss2_url':			$output = get_feed_link('rss2');			break;		case 'atom_url':			$output = get_feed_link('atom');			break;		case 'comments_atom_url':			$output = get_feed_link('comments_atom');			break;		case 'comments_rss2_url':			$output = get_feed_link('comments_rss2');			break;		case 'pingback_url':			$output = get_option('siteurl') .'/xmlrpc.php';			break;		case 'stylesheet_url':			$output = get_stylesheet_uri();			break;		case 'stylesheet_directory':			$output = get_stylesheet_directory_uri();			break;		case 'template_directory':		case 'template_url':			$output = get_template_directory_uri();			break;		case 'admin_email':			$output = get_option('admin_email');			break;		case 'charset':			$output = get_option('blog_charset');			if ('' == $output) $output = 'UTF-8';			break;		case 'html_type' :			$output = get_option('html_type');			break;		case 'version':			global $wp_version;			$output = $wp_version;			break;		case 'language':			$output = get_locale();			$output = str_replace('_', '-', $output);			break;		case 'text_direction':			//_deprecated_argument( __FUNCTION__, '2.2', sprintf( __('The <code>%s</code> option is deprecated for the family of <code>bloginfo()</code> functions.' ), $show ) . ' ' . sprintf( __( 'Use the <code>%s</code> function instead.' ), 'is_rtl()'  ) );			if ( function_exists( 'is_rtl' ) ) {				$output = is_rtl() ? 'rtl' : 'ltr';			} else {				$output = 'ltr';			}			break;		case 'name':		default:			$output = get_option('blogname');			break;	}	$url = true;	if (strpos($show, 'url') === false &&		strpos($show, 'directory') === false &&		strpos($show, 'home') === false)		$url = false;	if ( 'display' == $filter ) {		if ( $url )			$output = apply_filters('bloginfo_url', $output, $show);		else			$output = apply_filters('bloginfo', $output, $show);	}	return $output;}/** * Display or retrieve page title for all areas of blog. * * By default, the page title will display the separator before the page title, * so that the blog title will be before the page title. This is not good for * title display, since the blog title shows up on most tabs and not what is * important, which is the page that the user is looking at. * * There are also SEO benefits to having the blog title after or to the 'right' * or the page title. However, it is mostly common sense to have the blog title * to the right with most browsers supporting tabs. You can achieve this by * using the seplocation parameter and setting the value to 'right'. This change * was introduced around 2.5.0, in case backwards compatibility of themes is * important. * * @since 1.0.0 * * @param string $sep Optional, default is '&raquo;'. How to separate the various items within the page title. * @param bool $display Optional, default is true. Whether to display or retrieve title. * @param string $seplocation Optional. Direction to display title, 'right'. * @return string|null String on retrieve, null when displaying. */function wp_title($sep = '&raquo;', $display = true, $seplocation = '') {	global $wpdb, $wp_locale, $wp_query;	$cat = get_query_var('cat');	$tag = get_query_var('tag_id');	$category_name = get_query_var('category_name');	$author = get_query_var('author');	$author_name = get_query_var('author_name');	$m = get_query_var('m');	$year = get_query_var('year');	$monthnum = get_query_var('monthnum');	$day = get_query_var('day');	$search = get_query_var('s');	$title = '';	$t_sep = '%WP_TITILE_SEP%'; // Temporary separator, for accurate flipping, if necessary	// If there's a category	if ( !empty($cat) ) {			// category exclusion			if ( !stristr($cat,'-') )				$title = apply_filters('single_cat_title', get_the_category_by_ID($cat));	} elseif ( !empty($category_name) ) {		if ( stristr($category_name,'/') ) {				$category_name = explode('/',$category_name);				if ( $category_name[count($category_name)-1] )					$category_name = $category_name[count($category_name)-1]; // no trailing slash				else					$category_name = $category_name[count($category_name)-2]; // there was a trailling slash		}		$cat = get_term_by('slug', $category_name, 'category', OBJECT, 'display');		if ( $cat )			$title = apply_filters('single_cat_title', $cat->name);	}	if ( !empty($tag) ) {		$tag = get_term($tag, 'post_tag', OBJECT, 'display');		if ( is_wp_error( $tag ) )			return $tag;		if ( ! empty($tag->name) )			$title = apply_filters('single_tag_title', $tag->name);	}	// If there's an author	if ( !empty($author) ) {		$title = get_userdata($author);		$title = $title->display_name;	}	if ( !empty($author_name) ) {		// We do a direct query here because we don't cache by nicename.		$title = $wpdb->get_var($wpdb->prepare("SELECT display_name FROM $wpdb->users WHERE user_nicename = %s", $author_name));	}	// If there's a month	if ( !empty($m) ) {		$my_year = substr($m, 0, 4);		$my_month = $wp_locale->get_month(substr($m, 4, 2));		$my_day = intval(substr($m, 6, 2));		$title = $my_year . ($my_month ? $t_sep . $my_month : "") . ($my_day ? $t_sep . $my_day : "");	}	if ( !empty($year) ) {		$title = $year;		if ( !empty($monthnum) )			$title .= $t_sep . $wp_locale->get_month($monthnum);		if ( !empty($day) )			$title .= $t_sep . zeroise($day, 2);	}	// If there is a post	if ( is_single() || ( is_home() && !is_front_page() ) || ( is_page() && !is_front_page() ) ) {		$post = $wp_query->get_queried_object();		$title = apply_filters( 'single_post_title', $post->post_title );	}	// If there's a taxonomy	if ( is_tax() ) {		$taxonomy = get_query_var( 'taxonomy' );		$tax = get_taxonomy( $taxonomy );		$term = $wp_query->get_queried_object();		$term = $term->name;		$title = $tax->labels->name . $t_sep . $term;	}	//If it's a search	if ( is_search() ) {		/* translators: 1: separator, 2: search phrase */		$title = sprintf(__('Search Results %1$s %2$s'), $t_sep, strip_tags($search));	}	if ( is_404() ) {		$title = __('Page not found');	}	$prefix = '';	if ( !empty($title) )		$prefix = " $sep "; 	// Determines position of the separator and direction of the breadcrumb	if ( 'right' == $seplocation ) { // sep on right, so reverse the order		$title_array = explode( $t_sep, $title );		$title_array = array_reverse( $title_array );		$title = implode( " $sep ", $title_array ) . $prefix;	} else {		$title_array = explode( $t_sep, $title );		$title = $prefix . implode( " $sep ", $title_array );	}	$title = apply_filters('wp_title', $title, $sep, $seplocation);	// Send it out	if ( $display )		echo $title;	else		return $title;}/** * Display or retrieve page title for post. * * This is optimized for single.php template file for displaying the post title. * Only useful for posts, does not support pages for example. * * It does not support placing the separator after the title, but by leaving the * prefix parameter empty, you can set the title separator manually. The prefix * does not automatically place a space between the prefix, so if there should * be a space, the parameter value will need to have it at the end. * * @since 0.71 * @uses $wpdb * * @param string $prefix Optional. What to display before the title. * @param bool $display Optional, default is true. Whether to display or retrieve title. * @return string|null Title when retrieving, null when displaying or failure. */function single_post_title($prefix = '', $display = true) {	global $wp_query, $post;	if ( ! $post )		$_post = $wp_query->get_queried_object();	else		$_post = $post;	if ( !isset($_post->post_title) )		return;	$title = apply_filters('single_post_title', $_post->post_title, $_post);	if ( $display )		echo $prefix . $title;	else		return $title;}/** * Display or retrieve page title for category archive. * * This is useful for category template file or files, because it is optimized * for category page title and with less overhead than {@link wp_title()}. * * It does not support placing the separator after the title, but by leaving the * prefix parameter empty, you can set the title separator manually. The prefix * does not automatically place a space between the prefix, so if there should * be a space, the parameter value will need to have it at the end. * * @since 0.71 * * @param string $prefix Optional. What to display before the title. * @param bool $display Optional, default is true. Whether to display or retrieve title. * @return string|null Title when retrieving, null when displaying or failure. */function single_cat_title($prefix = '', $display = true ) {	global $wp_query;	if ( is_tag() )		return single_tag_title($prefix, $display);	if ( !is_category() )		return;	$cat = $wp_query->get_queried_object();	$my_cat_name = apply_filters('single_cat_title', $cat->name);	if ( !empty($my_cat_name) ) {		if ( $display )			echo $prefix . $my_cat_name;		else			return $my_cat_name;	}}/** * Display or retrieve page title for tag post archive. * * Useful for tag template files for displaying the tag page title. It has less * overhead than {@link wp_title()}, because of its limited implementation. * * It does not support placing the separator after the title, but by leaving the * prefix parameter empty, you can set the title separator manually. The prefix * does not automatically place a space between the prefix, so if there should * be a space, the parameter value will need to have it at the end. * * @since 2.3.0 * * @param string $prefix Optional. What to display before the title. * @param bool $display Optional, default is true. Whether to display or retrieve title. * @return string|null Title when retrieving, null when displaying or failure. */function single_tag_title($prefix = '', $display = true ) {	global $wp_query;	if ( !is_tag() )		return;	$tag = $wp_query->get_queried_object();	if ( ! $tag )		return;	$my_tag_name = apply_filters('single_tag_title', $tag->name);	if ( !empty($my_tag_name) ) {		if ( $display )			echo $prefix . $my_tag_name;		else			return $my_tag_name;	}}/** * Display or retrieve page title for post archive based on date. * * Useful for when the template only needs to display the month and year, if * either are available. Optimized for just this purpose, so if it is all that * is needed, should be better than {@link wp_title()}. * * It does not support placing the separator after the title, but by leaving the * prefix parameter empty, you can set the title separator manually. The prefix * does not automatically place a space between the prefix, so if there should * be a space, the parameter value will need to have it at the end. * * @since 0.71 * * @param string $prefix Optional. What to display before the title. * @param bool $display Optional, default is true. Whether to display or retrieve title. * @return string|null Title when retrieving, null when displaying or failure. */function single_month_title($prefix = '', $display = true ) {	global $wp_locale;	$m = get_query_var('m');	$year = get_query_var('year');	$monthnum = get_query_var('monthnum');	if ( !empty($monthnum) && !empty($year) ) {		$my_year = $year;		$my_month = $wp_locale->get_month($monthnum);	} elseif ( !empty($m) ) {		$my_year = substr($m, 0, 4);		$my_month = $wp_locale->get_month(substr($m, 4, 2));	}	if ( empty($my_month) )		return false;	$result = $prefix . $my_month . $prefix . $my_year;	if ( !$display )		return $result;	echo $result;}/** * Retrieve archive link content based on predefined or custom code. * * The format can be one of four styles. The 'link' for head element, 'option' * for use in the select element, 'html' for use in list (either ol or ul HTML * elements). Custom content is also supported using the before and after * parameters. * * The 'link' format uses the link HTML element with the <em>archives</em> * relationship. The before and after parameters are not used. The text * parameter is used to describe the link. * * The 'option' format uses the option HTML element for use in select element. * The value is the url parameter and the before and after parameters are used * between the text description. * * The 'html' format, which is the default, uses the li HTML element for use in * the list HTML elements. The before parameter is before the link and the after * parameter is after the closing link. * * The custom format uses the before parameter before the link ('a' HTML * element) and the after parameter after the closing link tag. If the above * three values for the format are not used, then custom format is assumed. * * @since 1.0.0 * * @param string $url URL to archive. * @param string $text Archive text description. * @param string $format Optional, default is 'html'. Can be 'link', 'option', 'html', or custom. * @param string $before Optional. * @param string $after Optional. * @return string HTML link content for archive. */function get_archives_link($url, $text, $format = 'html', $before = '', $after = '') {	$text = wptexturize($text);	$title_text = esc_attr($text);	$url = esc_url($url);	if ('link' == $format)		$link_html = "\t<link rel='archives' title='$title_text' href='$url' />\n";	elseif ('option' == $format)		$link_html = "\t<option value='$url'>$before $text $after</option>\n";	elseif ('html' == $format)		$link_html = "\t<li>$before<a href='$url' title='$title_text'>$text</a>$after</li>\n";	else // custom		$link_html = "\t$before<a href='$url' title='$title_text'>$text</a>$after\n";	$link_html = apply_filters( "get_archives_link", $link_html );	return $link_html;}/** * Display archive links based on type and format. * * The 'type' argument offers a few choices and by default will display monthly * archive links. The other options for values are 'daily', 'weekly', 'monthly', * 'yearly', 'postbypost' or 'alpha'. Both 'postbypost' and 'alpha' display the * same archive link list, the difference between the two is that 'alpha' * will order by post title and 'postbypost' will order by post date. * * The date archives will logically display dates with links to the archive post * page. The 'postbypost' and 'alpha' values for 'type' argument will display * the post titles. * * The 'limit' argument will only display a limited amount of links, specified * by the 'limit' integer value. By default, there is no limit. The * 'show_post_count' argument will show how many posts are within the archive. * By default, the 'show_post_count' argument is set to false. * * For the 'format', 'before', and 'after' arguments, see {@link * get_archives_link()}. The values of these arguments have to do with that * function. * * @since 1.2.0 * * @param string|array $args Optional. Override defaults. */function wp_get_archives($args = '') {	global $wpdb, $wp_locale;	$defaults = array(		'type' => 'monthly', 'limit' => '',		'format' => 'html', 'before' => '',		'after' => '', 'show_post_count' => false,		'echo' => 1	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	if ( '' == $type )		$type = 'monthly';	if ( '' != $limit ) {		$limit = absint($limit);		$limit = ' LIMIT '.$limit;	}	// this is what will separate dates on weekly archive links	$archive_week_separator = '&#8211;';	// over-ride general date format ? 0 = no: use the date format set in Options, 1 = yes: over-ride	$archive_date_format_over_ride = 0;	// options for daily archive (only if you over-ride the general date format)	$archive_day_date_format = 'Y/m/d';	// options for weekly archive (only if you over-ride the general date format)	$archive_week_start_date_format = 'Y/m/d';	$archive_week_end_date_format	= 'Y/m/d';	if ( !$archive_date_format_over_ride ) {		$archive_day_date_format = get_option('date_format');		$archive_week_start_date_format = get_option('date_format');		$archive_week_end_date_format = get_option('date_format');	}	//filters	$where = apply_filters('getarchives_where', "WHERE post_type = 'post' AND post_status = 'publish'", $r );	$join = apply_filters('getarchives_join', "", $r);	$output = '';	if ( 'monthly' == $type ) {		$query = "SELECT YEAR(post_date) AS `year`, MONTH(post_date) AS `month`, count(ID) as posts FROM $wpdb->posts $join $where GROUP BY YEAR(post_date), MONTH(post_date) ORDER BY post_date DESC $limit";		$key = md5($query);		$cache = wp_cache_get( 'wp_get_archives' , 'general');		if ( !isset( $cache[ $key ] ) ) {			$arcresults = $wpdb->get_results($query);			$cache[ $key ] = $arcresults;			wp_cache_set( 'wp_get_archives', $cache, 'general' );		} else {			$arcresults = $cache[ $key ];		}		if ( $arcresults ) {			$afterafter = $after;			foreach ( (array) $arcresults as $arcresult ) {				$url = get_month_link( $arcresult->year, $arcresult->month );				/* translators: 1: month name, 2: 4-digit year */				$text = sprintf(__('%1$s %2$d'), $wp_locale->get_month($arcresult->month), $arcresult->year);				if ( $show_post_count )					$after = '&nbsp;('.$arcresult->posts.')' . $afterafter;				$output .= get_archives_link($url, $text, $format, $before, $after);			}		}	} elseif ('yearly' == $type) {		$query = "SELECT YEAR(post_date) AS `year`, count(ID) as posts FROM $wpdb->posts $join $where GROUP BY YEAR(post_date) ORDER BY post_date DESC $limit";		$key = md5($query);		$cache = wp_cache_get( 'wp_get_archives' , 'general');		if ( !isset( $cache[ $key ] ) ) {			$arcresults = $wpdb->get_results($query);			$cache[ $key ] = $arcresults;			wp_cache_set( 'wp_get_archives', $cache, 'general' );		} else {			$arcresults = $cache[ $key ];		}		if ($arcresults) {			$afterafter = $after;			foreach ( (array) $arcresults as $arcresult) {				$url = get_year_link($arcresult->year);				$text = sprintf('%d', $arcresult->year);				if ($show_post_count)					$after = '&nbsp;('.$arcresult->posts.')' . $afterafter;				$output .= get_archives_link($url, $text, $format, $before, $after);			}		}	} elseif ( 'daily' == $type ) {		$query = "SELECT YEAR(post_date) AS `year`, MONTH(post_date) AS `month`, DAYOFMONTH(post_date) AS `dayofmonth`, count(ID) as posts FROM $wpdb->posts $join $where GROUP BY YEAR(post_date), MONTH(post_date), DAYOFMONTH(post_date) ORDER BY post_date DESC $limit";		$key = md5($query);		$cache = wp_cache_get( 'wp_get_archives' , 'general');		if ( !isset( $cache[ $key ] ) ) {			$arcresults = $wpdb->get_results($query);			$cache[ $key ] = $arcresults;			wp_cache_set( 'wp_get_archives', $cache, 'general' );		} else {			$arcresults = $cache[ $key ];		}		if ( $arcresults ) {			$afterafter = $after;			foreach ( (array) $arcresults as $arcresult ) {				$url	= get_day_link($arcresult->year, $arcresult->month, $arcresult->dayofmonth);				$date = sprintf('%1$d-%2$02d-%3$02d 00:00:00', $arcresult->year, $arcresult->month, $arcresult->dayofmonth);				$text = mysql2date($archive_day_date_format, $date);				if ($show_post_count)					$after = '&nbsp;('.$arcresult->posts.')'.$afterafter;				$output .= get_archives_link($url, $text, $format, $before, $after);			}		}	} elseif ( 'weekly' == $type ) {		$week = _wp_mysql_week( '`post_date`' );		$query = "SELECT DISTINCT $week AS `week`, YEAR( `post_date` ) AS `yr`, DATE_FORMAT( `post_date`, '%Y-%m-%d' ) AS `yyyymmdd`, count( `ID` ) AS `posts` FROM `$wpdb->posts` $join $where GROUP BY $week, YEAR( `post_date` ) ORDER BY `post_date` DESC $limit";		$key = md5($query);		$cache = wp_cache_get( 'wp_get_archives' , 'general');		if ( !isset( $cache[ $key ] ) ) {			$arcresults = $wpdb->get_results($query);			$cache[ $key ] = $arcresults;			wp_cache_set( 'wp_get_archives', $cache, 'general' );		} else {			$arcresults = $cache[ $key ];		}		$arc_w_last = '';		$afterafter = $after;		if ( $arcresults ) {				foreach ( (array) $arcresults as $arcresult ) {					if ( $arcresult->week != $arc_w_last ) {						$arc_year = $arcresult->yr;						$arc_w_last = $arcresult->week;						$arc_week = get_weekstartend($arcresult->yyyymmdd, get_option('start_of_week'));						$arc_week_start = date_i18n($archive_week_start_date_format, $arc_week['start']);						$arc_week_end = date_i18n($archive_week_end_date_format, $arc_week['end']);						$url  = sprintf('%1$s/%2$s%3$sm%4$s%5$s%6$sw%7$s%8$d', home_url(), '', '?', '=', $arc_year, '&amp;', '=', $arcresult->week);						$text = $arc_week_start . $archive_week_separator . $arc_week_end;						if ($show_post_count)							$after = '&nbsp;('.$arcresult->posts.')'.$afterafter;						$output .= get_archives_link($url, $text, $format, $before, $after);					}				}		}	} elseif ( ( 'postbypost' == $type ) || ('alpha' == $type) ) {		$orderby = ('alpha' == $type) ? "post_title ASC " : "post_date DESC ";		$query = "SELECT * FROM $wpdb->posts $join $where ORDER BY $orderby $limit";		$key = md5($query);		$cache = wp_cache_get( 'wp_get_archives' , 'general');		if ( !isset( $cache[ $key ] ) ) {			$arcresults = $wpdb->get_results($query);			$cache[ $key ] = $arcresults;			wp_cache_set( 'wp_get_archives', $cache, 'general' );		} else {			$arcresults = $cache[ $key ];		}		if ( $arcresults ) {			foreach ( (array) $arcresults as $arcresult ) {				if ( $arcresult->post_date != '0000-00-00 00:00:00' ) {					$url  = get_permalink($arcresult);					$arc_title = $arcresult->post_title;					if ( $arc_title )						$text = strip_tags(apply_filters('the_title', $arc_title));					else						$text = $arcresult->ID;					$output .= get_archives_link($url, $text, $format, $before, $after);				}			}		}	}	if ( $echo )		echo $output;	else		return $output;}/** * Get number of days since the start of the week. * * @since 1.5.0 * @usedby get_calendar() * * @param int $num Number of day. * @return int Days since the start of the week. */function calendar_week_mod($num) {	$base = 7;	return ($num - $base*floor($num/$base));}/** * Display calendar with days that have posts as links. * * The calendar is cached, which will be retrieved, if it exists. If there are * no posts for the month, then it will not be displayed. * * @since 1.0.0 * * @param bool $initial Optional, default is true. Use initial calendar names. * @param bool $echo Optional, default is true. Set to false for return. */function get_calendar($initial = true, $echo = true) {	global $wpdb, $m, $monthnum, $year, $wp_locale, $posts;	$cache = array();	$key = md5( $m . $monthnum . $year );	if ( $cache = wp_cache_get( 'get_calendar', 'calendar' ) ) {		if ( is_array($cache) && isset( $cache[ $key ] ) ) {			if ( $echo ) {				echo apply_filters( 'get_calendar',  $cache[$key] );				return;			} else {				return apply_filters( 'get_calendar',  $cache[$key] );			}		}	}	if ( !is_array($cache) )		$cache = array();	// Quick check. If we have no posts at all, abort!	if ( !$posts ) {		$gotsome = $wpdb->get_var("SELECT 1 as test FROM $wpdb->posts WHERE post_type = 'post' AND post_status = 'publish' LIMIT 1");		if ( !$gotsome ) {			$cache[ $key ] = '';			wp_cache_set( 'get_calendar', $cache, 'calendar' );			return;		}	}	if ( isset($_GET['w']) )		$w = ''.intval($_GET['w']);	// week_begins = 0 stands for Sunday	$week_begins = intval(get_option('start_of_week'));	// Let's figure out when we are	if ( !empty($monthnum) && !empty($year) ) {		$thismonth = ''.zeroise(intval($monthnum), 2);		$thisyear = ''.intval($year);	} elseif ( !empty($w) ) {		// We need to get the month from MySQL		$thisyear = ''.intval(substr($m, 0, 4));		$d = (($w - 1) * 7) + 6; //it seems MySQL's weeks disagree with PHP's		$thismonth = $wpdb->get_var("SELECT DATE_FORMAT((DATE_ADD('${thisyear}0101', INTERVAL $d DAY) ), '%m')");	} elseif ( !empty($m) ) {		$thisyear = ''.intval(substr($m, 0, 4));		if ( strlen($m) < 6 )				$thismonth = '01';		else				$thismonth = ''.zeroise(intval(substr($m, 4, 2)), 2);	} else {		$thisyear = gmdate('Y', current_time('timestamp'));		$thismonth = gmdate('m', current_time('timestamp'));	}	$unixmonth = mktime(0, 0 , 0, $thismonth, 1, $thisyear);	// Get the next and previous month and year with at least one post	$previous = $wpdb->get_row("SELECT DISTINCT MONTH(post_date) AS month, YEAR(post_date) AS year		FROM $wpdb->posts		WHERE post_date < '$thisyear-$thismonth-01'		AND post_type = 'post' AND post_status = 'publish'			ORDER BY post_date DESC			LIMIT 1");	$next = $wpdb->get_row("SELECT	DISTINCT MONTH(post_date) AS month, YEAR(post_date) AS year		FROM $wpdb->posts		WHERE post_date >	'$thisyear-$thismonth-01'		AND MONTH( post_date ) != MONTH( '$thisyear-$thismonth-01' )		AND post_type = 'post' AND post_status = 'publish'			ORDER	BY post_date ASC			LIMIT 1");	/* translators: Calendar caption: 1: month name, 2: 4-digit year */	$calendar_caption = _x('%1$s %2$s', 'calendar caption');	$calendar_output = '<table id="wp-calendar" summary="' . esc_attr__('Calendar') . '">	<caption>' . sprintf($calendar_caption, $wp_locale->get_month($thismonth), date('Y', $unixmonth)) . '</caption>	<thead>	<tr>';	$myweek = array();	for ( $wdcount=0; $wdcount<=6; $wdcount++ ) {		$myweek[] = $wp_locale->get_weekday(($wdcount+$week_begins)%7);	}	foreach ( $myweek as $wd ) {		$day_name = (true == $initial) ? $wp_locale->get_weekday_initial($wd) : $wp_locale->get_weekday_abbrev($wd);		$wd = esc_attr($wd);		$calendar_output .= "\n\t\t<th scope=\"col\" title=\"$wd\">$day_name</th>";	}	$calendar_output .= '	</tr>	</thead>	<tfoot>	<tr>';	if ( $previous ) {		$calendar_output .= "\n\t\t".'<td colspan="3" id="prev"><a href="' . get_month_link($previous->year, $previous->month) . '" title="' . sprintf(__('View posts for %1$s %2$s'), $wp_locale->get_month($previous->month), date('Y', mktime(0, 0 , 0, $previous->month, 1, $previous->year))) . '">&laquo; ' . $wp_locale->get_month_abbrev($wp_locale->get_month($previous->month)) . '</a></td>';	} else {		$calendar_output .= "\n\t\t".'<td colspan="3" id="prev" class="pad">&nbsp;</td>';	}	$calendar_output .= "\n\t\t".'<td class="pad">&nbsp;</td>';	if ( $next ) {		$calendar_output .= "\n\t\t".'<td colspan="3" id="next"><a href="' . get_month_link($next->year, $next->month) . '" title="' . esc_attr( sprintf(__('View posts for %1$s %2$s'), $wp_locale->get_month($next->month), date('Y', mktime(0, 0 , 0, $next->month, 1, $next->year))) ) . '">' . $wp_locale->get_month_abbrev($wp_locale->get_month($next->month)) . ' &raquo;</a></td>';	} else {		$calendar_output .= "\n\t\t".'<td colspan="3" id="next" class="pad">&nbsp;</td>';	}	$calendar_output .= '	</tr>	</tfoot>	<tbody>	<tr>';	// Get days with posts	$dayswithposts = $wpdb->get_results("SELECT DISTINCT DAYOFMONTH(post_date)		FROM $wpdb->posts WHERE MONTH(post_date) = '$thismonth'		AND YEAR(post_date) = '$thisyear'		AND post_type = 'post' AND post_status = 'publish'		AND post_date < '" . current_time('mysql') . '\'', ARRAY_N);	if ( $dayswithposts ) {		foreach ( (array) $dayswithposts as $daywith ) {			$daywithpost[] = $daywith[0];		}	} else {		$daywithpost = array();	}	if (strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== false || stripos($_SERVER['HTTP_USER_AGENT'], 'camino') !== false || stripos($_SERVER['HTTP_USER_AGENT'], 'safari') !== false)		$ak_title_separator = "\n";	else		$ak_title_separator = ', ';	$ak_titles_for_day = array();	$ak_post_titles = $wpdb->get_results("SELECT ID, post_title, DAYOFMONTH(post_date) as dom "		."FROM $wpdb->posts "		."WHERE YEAR(post_date) = '$thisyear' "		."AND MONTH(post_date) = '$thismonth' "		."AND post_date < '".current_time('mysql')."' "		."AND post_type = 'post' AND post_status = 'publish'"	);	if ( $ak_post_titles ) {		foreach ( (array) $ak_post_titles as $ak_post_title ) {				$post_title = esc_attr( apply_filters( 'the_title', $ak_post_title->post_title, $ak_post_title->ID ) );				if ( empty($ak_titles_for_day['day_'.$ak_post_title->dom]) )					$ak_titles_for_day['day_'.$ak_post_title->dom] = '';				if ( empty($ak_titles_for_day["$ak_post_title->dom"]) ) // first one					$ak_titles_for_day["$ak_post_title->dom"] = $post_title;				else					$ak_titles_for_day["$ak_post_title->dom"] .= $ak_title_separator . $post_title;		}	}	// See how much we should pad in the beginning	$pad = calendar_week_mod(date('w', $unixmonth)-$week_begins);	if ( 0 != $pad )		$calendar_output .= "\n\t\t".'<td colspan="'. esc_attr($pad) .'" class="pad">&nbsp;</td>';	$daysinmonth = intval(date('t', $unixmonth));	for ( $day = 1; $day <= $daysinmonth; ++$day ) {		if ( isset($newrow) && $newrow )			$calendar_output .= "\n\t</tr>\n\t<tr>\n\t\t";		$newrow = false;		if ( $day == gmdate('j', current_time('timestamp')) && $thismonth == gmdate('m', current_time('timestamp')) && $thisyear == gmdate('Y', current_time('timestamp')) )			$calendar_output .= '<td id="today">';		else			$calendar_output .= '<td>';		if ( in_array($day, $daywithpost) ) // any posts today?				$calendar_output .= '<a href="' . get_day_link($thisyear, $thismonth, $day) . "\" title=\"" . esc_attr($ak_titles_for_day[$day]) . "\">$day</a>";		else			$calendar_output .= $day;		$calendar_output .= '</td>';		if ( 6 == calendar_week_mod(date('w', mktime(0, 0 , 0, $thismonth, $day, $thisyear))-$week_begins) )			$newrow = true;	}	$pad = 7 - calendar_week_mod(date('w', mktime(0, 0 , 0, $thismonth, $day, $thisyear))-$week_begins);	if ( $pad != 0 && $pad != 7 )		$calendar_output .= "\n\t\t".'<td class="pad" colspan="'. esc_attr($pad) .'">&nbsp;</td>';	$calendar_output .= "\n\t</tr>\n\t</tbody>\n\t</table>";	$cache[ $key ] = $calendar_output;	wp_cache_set( 'get_calendar', $cache, 'calendar' );	if ( $echo )		echo apply_filters( 'get_calendar',  $calendar_output );	else		return apply_filters( 'get_calendar',  $calendar_output );}/** * Purge the cached results of get_calendar. * * @see get_calendar * @since 2.1.0 */function delete_get_calendar_cache() {	wp_cache_delete( 'get_calendar', 'calendar' );}add_action( 'save_post', 'delete_get_calendar_cache' );add_action( 'delete_post', 'delete_get_calendar_cache' );add_action( 'update_option_start_of_week', 'delete_get_calendar_cache' );add_action( 'update_option_gmt_offset', 'delete_get_calendar_cache' );/** * Display all of the allowed tags in HTML format with attributes. * * This is useful for displaying in the comment area, which elements and * attributes are supported. As well as any plugins which want to display it. * * @since 1.0.1 * @uses $allowedtags * * @return string HTML allowed tags entity encoded. */function allowed_tags() {	global $allowedtags;	$allowed = '';	foreach ( (array) $allowedtags as $tag => $attributes ) {		$allowed .= '<'.$tag;		if ( 0 < count($attributes) ) {			foreach ( $attributes as $attribute => $limits ) {				$allowed .= ' '.$attribute.'=""';			}		}		$allowed .= '> ';	}	return htmlentities($allowed);}/***** Date/Time tags *****//** * Outputs the date in iso8601 format for xml files. * * @since 1.0.0 */function the_date_xml() {	global $post;	echo mysql2date('Y-m-d', $post->post_date, false);}/** * Display or Retrieve the date the current $post was written (once per date) * * Will only output the date if the current post's date is different from the * previous one output. * i.e. Only one date listing will show per day worth of posts shown in the loop, even if the * function is called several times for each post. * * HTML output can be filtered with 'the_date'. * Date string output can be filtered with 'get_the_date'. * * @since 0.71 * @uses get_the_date() * @param string $d Optional. PHP date format defaults to the date_format option if not specified. * @param string $before Optional. Output before the date. * @param string $after Optional. Output after the date. * @param bool $echo Optional, default is display. Whether to echo the date or return it. * @return string|null Null if displaying, string if retrieving. */function the_date( $d = '', $before = '', $after = '', $echo = true ) {	global $day, $previousday;	$the_date = '';	if ( $day != $previousday ) {		$the_date .= $before;		$the_date .= get_the_date( $d );		$the_date .= $after;		$previousday = $day;		$the_date = apply_filters('the_date', $the_date, $d, $before, $after);		if ( $echo )			echo $the_date;		else			return $the_date;	}	return null;}/** * Retrieve the date the current $post was written. * * Unlike the_date() this function will always return the date. * Modify output with 'get_the_date' filter. * * @since 3.0.0 * * @param string $d Optional. PHP date format defaults to the date_format option if not specified. * @return string|null Null if displaying, string if retrieving. */function get_the_date( $d = '' ) {	global $post;	$the_date = '';	if ( '' == $d )		$the_date .= mysql2date(get_option('date_format'), $post->post_date);	else		$the_date .= mysql2date($d, $post->post_date);	return apply_filters('get_the_date', $the_date, $d);}/** * Display the date on which the post was last modified. * * @since 2.1.0 * * @param string $d Optional. PHP date format defaults to the date_format option if not specified. * @param string $before Optional. Output before the date. * @param string $after Optional. Output after the date. * @param bool $echo Optional, default is display. Whether to echo the date or return it. * @return string|null Null if displaying, string if retrieving. */function the_modified_date($d = '', $before='', $after='', $echo = true) {	$the_modified_date = $before . get_the_modified_date($d) . $after;	$the_modified_date = apply_filters('the_modified_date', $the_modified_date, $d, $before, $after);	if ( $echo )		echo $the_modified_date;	else		return $the_modified_date;}/** * Retrieve the date on which the post was last modified. * * @since 2.1.0 * * @param string $d Optional. PHP date format. Defaults to the "date_format" option * @return string */function get_the_modified_date($d = '') {	if ( '' == $d )		$the_time = get_post_modified_time(get_option('date_format'), null, null, true);	else		$the_time = get_post_modified_time($d, null, null, true);	return apply_filters('get_the_modified_date', $the_time, $d);}/** * Display the time at which the post was written. * * @since 0.71 * * @param string $d Either 'G', 'U', or php date format. */function the_time( $d = '' ) {	echo apply_filters('the_time', get_the_time( $d ), $d);}/** * Retrieve the time at which the post was written. * * @since 1.5.0 * * @param string $d Optional Either 'G', 'U', or php date format defaults to the value specified in the time_format option. * @param int|object $post Optional post ID or object. Default is global $post object. * @return string */function get_the_time( $d = '', $post = null ) {	$post = get_post($post);	if ( '' == $d )		$the_time = get_post_time(get_option('time_format'), false, $post, true);	else		$the_time = get_post_time($d, false, $post, true);	return apply_filters('get_the_time', $the_time, $d, $post);}/** * Retrieve the time at which the post was written. * * @since 2.0.0 * * @param string $d Optional Either 'G', 'U', or php date format. * @param bool $gmt Optional, default is false. Whether to return the gmt time. * @param int|object $post Optional post ID or object. Default is global $post object. * @param bool $translate Whether to translate the time string * @return string */function get_post_time( $d = 'U', $gmt = false, $post = null, $translate = false ) { // returns timestamp	$post = get_post($post);	if ( $gmt )		$time = $post->post_date_gmt;	else		$time = $post->post_date;	$time = mysql2date($d, $time, $translate);	return apply_filters('get_post_time', $time, $d, $gmt);}/** * Display the time at which the post was last modified. * * @since 2.0.0 * * @param string $d Optional Either 'G', 'U', or php date format defaults to the value specified in the time_format option. */function the_modified_time($d = '') {	echo apply_filters('the_modified_time', get_the_modified_time($d), $d);}/** * Retrieve the time at which the post was last modified. * * @since 2.0.0 * * @param string $d Optional Either 'G', 'U', or php date format defaults to the value specified in the time_format option. * @return string */function get_the_modified_time($d = '') {	if ( '' == $d )		$the_time = get_post_modified_time(get_option('time_format'), null, null, true);	else		$the_time = get_post_modified_time($d, null, null, true);	return apply_filters('get_the_modified_time', $the_time, $d);}/** * Retrieve the time at which the post was last modified. * * @since 2.0.0 * * @param string $d Optional, default is 'U'. Either 'G', 'U', or php date format. * @param bool $gmt Optional, default is false. Whether to return the gmt time. * @param int|object $post Optional, default is global post object. A post_id or post object * @param bool $translate Optional, default is false. Whether to translate the result * @return string Returns timestamp */function get_post_modified_time( $d = 'U', $gmt = false, $post = null, $translate = false ) {	$post = get_post($post);	if ( $gmt )		$time = $post->post_modified_gmt;	else		$time = $post->post_modified;	$time = mysql2date($d, $time, $translate);	return apply_filters('get_post_modified_time', $time, $d, $gmt);}/** * Display the weekday on which the post was written. * * @since 0.71 * @uses $wp_locale * @uses $post */function the_weekday() {	global $wp_locale, $post;	$the_weekday = $wp_locale->get_weekday(mysql2date('w', $post->post_date, false));	$the_weekday = apply_filters('the_weekday', $the_weekday);	echo $the_weekday;}/** * Display the weekday on which the post was written. * * Will only output the weekday if the current post's weekday is different from * the previous one output. * * @since 0.71 * * @param string $before Optional Output before the date. * @param string $after Optional Output after the date.  */function the_weekday_date($before='',$after='') {	global $wp_locale, $post, $day, $previousweekday;	$the_weekday_date = '';	if ( $day != $previousweekday ) {		$the_weekday_date .= $before;		$the_weekday_date .= $wp_locale->get_weekday(mysql2date('w', $post->post_date, false));		$the_weekday_date .= $after;		$previousweekday = $day;	}	$the_weekday_date = apply_filters('the_weekday_date', $the_weekday_date, $before, $after);	echo $the_weekday_date;}/** * Fire the wp_head action * * @since 1.2.0 * @uses do_action() Calls 'wp_head' hook. */function wp_head() {	do_action('wp_head');}/** * Fire the wp_footer action * * @since 1.5.1 * @uses do_action() Calls 'wp_footer' hook. */function wp_footer() {	do_action('wp_footer');}/** * Display the links to the general feeds. * * @since 2.8.0 * * @param array $args Optional arguments. */function feed_links( $args = array() ) {	if ( !current_theme_supports('automatic-feed-links') )		return;	$defaults = array(		/* translators: Separator between blog name and feed type in feed links */		'separator'	=> _x('&raquo;', 'feed link'),		/* translators: 1: blog title, 2: separator (raquo) */		'feedtitle'	=> __('%1$s %2$s Feed'),		/* translators: %s: blog title, 2: separator (raquo) */		'comstitle'	=> __('%1$s %2$s Comments Feed'),	);	$args = wp_parse_args( $args, $defaults );	echo '<link rel="alternate" type="' . feed_content_type() . '" title="' . esc_attr(sprintf( $args['feedtitle'], get_bloginfo('name'), $args['separator'] )) . '" href="' . get_feed_link() . "\" />\n";	echo '<link rel="alternate" type="' . feed_content_type() . '" title="' . esc_attr(sprintf( $args['comstitle'], get_bloginfo('name'), $args['separator'] )) . '" href="' . get_feed_link( 'comments_' . get_default_feed() ) . "\" />\n";}/** * Display the links to the extra feeds such as category feeds. * * @since 2.8.0 * * @param array $args Optional arguments. */function feed_links_extra( $args = array() ) {	$defaults = array(		/* translators: Separator between blog name and feed type in feed links */		'separator'   => _x('&raquo;', 'feed link'),		/* translators: 1: blog name, 2: separator(raquo), 3: post title */		'singletitle' => __('%1$s %2$s %3$s Comments Feed'),		/* translators: 1: blog name, 2: separator(raquo), 3: category name */		'cattitle'    => __('%1$s %2$s %3$s Category Feed'),		/* translators: 1: blog name, 2: separator(raquo), 3: tag name */		'tagtitle'    => __('%1$s %2$s %3$s Tag Feed'),		/* translators: 1: blog name, 2: separator(raquo), 3: author name  */		'authortitle' => __('%1$s %2$s Posts by %3$s Feed'),		/* translators: 1: blog name, 2: separator(raquo), 3: search phrase */		'searchtitle' => __('%1$s %2$s Search Results for &#8220;%3$s&#8221; Feed'),	);	$args = wp_parse_args( $args, $defaults );	if ( is_single() || is_page() ) {		$post = &get_post( $id = 0 );		if ( comments_open() || pings_open() || $post->comment_count > 0 ) {			$title = esc_attr(sprintf( $args['singletitle'], get_bloginfo('name'), $args['separator'], esc_html( get_the_title() ) ));			$href = get_post_comments_feed_link( $post->ID );		}	} elseif ( is_category() ) {		$cat_id = intval( get_query_var('cat') );		$title = esc_attr(sprintf( $args['cattitle'], get_bloginfo('name'), $args['separator'], get_cat_name( $cat_id ) ));		$href = get_category_feed_link( $cat_id );	} elseif ( is_tag() ) {		$tag_id = intval( get_query_var('tag_id') );		$tag = get_tag( $tag_id );		$title = esc_attr(sprintf( $args['tagtitle'], get_bloginfo('name'), $args['separator'], $tag->name ));		$href = get_tag_feed_link( $tag_id );	} elseif ( is_author() ) {		$author_id = intval( get_query_var('author') );		$title = esc_attr(sprintf( $args['authortitle'], get_bloginfo('name'), $args['separator'], get_the_author_meta( 'display_name', $author_id ) ));		$href = get_author_feed_link( $author_id );	} elseif ( is_search() ) {		$title = esc_attr(sprintf( $args['searchtitle'], get_bloginfo('name'), $args['separator'], get_search_query( false ) ));		$href = get_search_feed_link();	}	if ( isset($title) && isset($href) )		echo '<link rel="alternate" type="' . feed_content_type() . '" title="' . $title . '" href="' . $href . '" />' . "\n";}/** * Display the link to the Really Simple Discovery service endpoint. * * @link http://archipelago.phrasewise.com/rsd * @since 2.0.0 */function rsd_link() {	echo '<link rel="EditURI" type="application/rsd+xml" title="RSD" href="' . get_bloginfo('wpurl') . "/xmlrpc.php?rsd\" />\n";}/** * Display the link to the Windows Live Writer manifest file. * * @link http://msdn.microsoft.com/en-us/library/bb463265.aspx * @since 2.3.1 */function wlwmanifest_link() {	echo '<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="'		. get_bloginfo('wpurl') . '/wp-includes/wlwmanifest.xml" /> ' . "\n";}/** * Display a noindex meta tag if required by the blog configuration. * * If a blog is marked as not being public then the noindex meta tag will be * output to tell web robots not to index the page content. * * @since 2.1.0 */function noindex() {	// If the blog is not public, tell robots to go away.	if ( '0' == get_option('blog_public') )		echo "<meta name='robots' content='noindex,nofollow' />\n";}/** * Determine if TinyMCE is available. * * Checks to see if the user has deleted the tinymce files to slim down there WordPress install. * * @since 2.1.0 * * @return bool Whether TinyMCE exists. */function rich_edit_exists() {	global $wp_rich_edit_exists;	if ( !isset($wp_rich_edit_exists) )		$wp_rich_edit_exists = file_exists(ABSPATH . WPINC . '/js/tinymce/tiny_mce.js');	return $wp_rich_edit_exists;}/** * Whether the user should have a WYSIWIG editor. * * Checks that the user requires a WYSIWIG editor and that the editor is * supported in the users browser. * * @since 2.0.0 * * @return bool */function user_can_richedit() {	global $wp_rich_edit, $pagenow;	if ( !isset( $wp_rich_edit) ) {		if ( get_user_option( 'rich_editing' ) == 'true' &&			( ( preg_match( '!AppleWebKit/(\d+)!', $_SERVER['HTTP_USER_AGENT'], $match ) && intval($match[1]) >= 420 ) ||				!preg_match( '!opera[ /][2-8]|konqueror|safari!i', $_SERVER['HTTP_USER_AGENT'] ) )				&& 'comment.php' != $pagenow ) {			$wp_rich_edit = true;		} else {			$wp_rich_edit = false;		}	}	return apply_filters('user_can_richedit', $wp_rich_edit);}/** * Find out which editor should be displayed by default. * * Works out which of the two editors to display as the current editor for a * user. * * @since 2.5.0 * * @return string Either 'tinymce', or 'html', or 'test' */function wp_default_editor() {	$r = user_can_richedit() ? 'tinymce' : 'html'; // defaults	if ( $user = wp_get_current_user() ) { // look for cookie		$ed = get_user_setting('editor', 'tinymce');		$r = ( in_array($ed, array('tinymce', 'html', 'test') ) ) ? $ed : $r;	}	return apply_filters( 'wp_default_editor', $r ); // filter}/** * Display visual editor forms: TinyMCE, or HTML, or both. * * The amount of rows the text area will have for the content has to be between * 3 and 100 or will default at 12. There is only one option used for all users, * named 'default_post_edit_rows'. * * If the user can not use the rich editor (TinyMCE), then the switch button * will not be displayed. * * @since 2.1.0 * * @param string $content Textarea content. * @param string $id Optional, default is 'content'. HTML ID attribute value. * @param string $prev_id Optional, default is 'title'. HTML ID name for switching back and forth between visual editors. * @param bool $media_buttons Optional, default is true. Whether to display media buttons. * @param int $tab_index Optional, default is 2. Tabindex for textarea element. */function the_editor($content, $id = 'content', $prev_id = 'title', $media_buttons = true, $tab_index = 2) {	$rows = get_option('default_post_edit_rows');	if (($rows < 3) || ($rows > 100))		$rows = 12;	if ( !current_user_can( 'upload_files' ) )		$media_buttons = false;	$richedit =  user_can_richedit();	$class = '';	if ( $richedit || $media_buttons ) { ?>	<div id="editor-toolbar"><?php	if ( $richedit ) {		$wp_default_editor = wp_default_editor(); ?>		<div class="zerosize"><input accesskey="e" type="button" onclick="switchEditors.go('<?php echo $id; ?>')" /></div><?php	if ( 'html' == $wp_default_editor ) {			add_filter('the_editor_content', 'wp_htmledit_pre'); ?>			<a id="edButtonHTML" class="active hide-if-no-js" onclick="switchEditors.go('<?php echo $id; ?>', 'html');"><?php _e('HTML'); ?></a>			<a id="edButtonPreview" class="hide-if-no-js" onclick="switchEditors.go('<?php echo $id; ?>', 'tinymce');"><?php _e('Visual'); ?></a><?php	} else {			$class = " class='theEditor'";			add_filter('the_editor_content', 'wp_richedit_pre'); ?>			<a id="edButtonHTML" class="hide-if-no-js" onclick="switchEditors.go('<?php echo $id; ?>', 'html');"><?php _e('HTML'); ?></a>			<a id="edButtonPreview" class="active hide-if-no-js" onclick="switchEditors.go('<?php echo $id; ?>', 'tinymce');"><?php _e('Visual'); ?></a><?php	}	}	if ( $media_buttons ) { ?>		<div id="media-buttons" class="hide-if-no-js"><?php	do_action( 'media_buttons' ); ?>		</div><?php	} ?>	</div><?php	}?>	<div id="quicktags"><?php	wp_print_scripts( 'quicktags' ); ?>	<script type="text/javascript">edToolbar()</script>	</div><?php	$the_editor = apply_filters('the_editor', "<div id='editorcontainer'><textarea rows='$rows'$class cols='40' name='$id' tabindex='$tab_index' id='$id'>%s</textarea></div>\n");	$the_editor_content = apply_filters('the_editor_content', $content);	printf($the_editor, $the_editor_content);?>	<script type="text/javascript">	edCanvas = document.getElementById('<?php echo $id; ?>');	</script><?php}/** * Retrieve the contents of the search WordPress query variable. * * The search query string is passed through {@link esc_attr()} * to ensure that it is safe for placing in an html attribute. * * @since 2.3.0 * @uses esc_attr() * * @param bool $escaped Whether the result is escaped. Default true. * 	Only use when you are later escaping it. Do not use unescaped. * @return string */function get_search_query( $escaped = true ) {	$query = apply_filters( 'get_search_query', get_query_var( 's' ) );	if ( $escaped )		$query = esc_attr( $query );	return $query;}/** * Display the contents of the search query variable. * * The search query string is passed through {@link esc_attr()} * to ensure that it is safe for placing in an html attribute. * * @uses esc_attr() * @since 2.1.0 */function the_search_query() {	echo esc_attr( apply_filters( 'the_search_query', get_search_query( false ) ) );}/** * Display the language attributes for the html tag. * * Builds up a set of html attributes containing the text direction and language * information for the page. * * @since 2.1.0 * * @param string $doctype The type of html document (xhtml|html). */function language_attributes($doctype = 'html') {	$attributes = array();	$output = '';	if ( function_exists( 'is_rtl' ) )		$attributes[] = 'dir="' . ( is_rtl() ? 'rtl' : 'ltr' ) . '"';	if ( $lang = get_bloginfo('language') ) {		if ( get_option('html_type') == 'text/html' || $doctype == 'html' )			$attributes[] = "lang=\"$lang\"";		if ( get_option('html_type') != 'text/html' || $doctype == 'xhtml' )			$attributes[] = "xml:lang=\"$lang\"";	}	$output = implode(' ', $attributes);	$output = apply_filters('language_attributes', $output);	echo $output;}/** * Retrieve paginated link for archive post pages. * * Technically, the function can be used to create paginated link list for any * area. The 'base' argument is used to reference the url, which will be used to * create the paginated links. The 'format' argument is then used for replacing * the page number. It is however, most likely and by default, to be used on the * archive post pages. * * The 'type' argument controls format of the returned value. The default is * 'plain', which is just a string with the links separated by a newline * character. The other possible values are either 'array' or 'list'. The * 'array' value will return an array of the paginated link list to offer full * control of display. The 'list' value will place all of the paginated links in * an unordered HTML list. * * The 'total' argument is the total amount of pages and is an integer. The * 'current' argument is the current page number and is also an integer. * * An example of the 'base' argument is "http://example.com/all_posts.php%_%" * and the '%_%' is required. The '%_%' will be replaced by the contents of in * the 'format' argument. An example for the 'format' argument is "?page=%#%" * and the '%#%' is also required. The '%#%' will be replaced with the page * number. * * You can include the previous and next links in the list by setting the * 'prev_next' argument to true, which it is by default. You can set the * previous text, by using the 'prev_text' argument. You can set the next text * by setting the 'next_text' argument. * * If the 'show_all' argument is set to true, then it will show all of the pages * instead of a short list of the pages near the current page. By default, the * 'show_all' is set to false and controlled by the 'end_size' and 'mid_size' * arguments. The 'end_size' argument is how many numbers on either the start * and the end list edges, by default is 1. The 'mid_size' argument is how many * numbers to either side of current page, but not including current page. * * It is possible to add query vars to the link by using the 'add_args' argument * and see {@link add_query_arg()} for more information. * * @since 2.1.0 * * @param string|array $args Optional. Override defaults. * @return array|string String of page links or array of page links. */function paginate_links( $args = '' ) {	$defaults = array(		'base' => '%_%', // http://example.com/all_posts.php%_% : %_% is replaced by format (below)		'format' => '?page=%#%', // ?page=%#% : %#% is replaced by the page number		'total' => 1,		'current' => 0,		'show_all' => false,		'prev_next' => true,		'prev_text' => __('&laquo; Previous'),		'next_text' => __('Next &raquo;'),		'end_size' => 1,		'mid_size' => 2,		'type' => 'plain',		'add_args' => false, // array of query args to add		'add_fragment' => ''	);	$args = wp_parse_args( $args, $defaults );	extract($args, EXTR_SKIP);	// Who knows what else people pass in $args	$total = (int) $total;	if ( $total < 2 )		return;	$current  = (int) $current;	$end_size = 0  < (int) $end_size ? (int) $end_size : 1; // Out of bounds?  Make it the default.	$mid_size = 0 <= (int) $mid_size ? (int) $mid_size : 2;	$add_args = is_array($add_args) ? $add_args : false;	$r = '';	$page_links = array();	$n = 0;	$dots = false;	if ( $prev_next && $current && 1 < $current ) :		$link = str_replace('%_%', 2 == $current ? '' : $format, $base);		$link = str_replace('%#%', $current - 1, $link);		if ( $add_args )			$link = add_query_arg( $add_args, $link );		$link .= $add_fragment;		$page_links[] = "<a class='prev page-numbers' href='" . esc_url( apply_filters( 'paginate_links', $link ) ) . "'>$prev_text</a>";	endif;	for ( $n = 1; $n <= $total; $n++ ) :		$n_display = number_format_i18n($n);		if ( $n == $current ) :			$page_links[] = "<span class='page-numbers current'>$n_display</span>";			$dots = true;		else :			if ( $show_all || ( $n <= $end_size || ( $current && $n >= $current - $mid_size && $n <= $current + $mid_size ) || $n > $total - $end_size ) ) :				$link = str_replace('%_%', 1 == $n ? '' : $format, $base);				$link = str_replace('%#%', $n, $link);				if ( $add_args )					$link = add_query_arg( $add_args, $link );				$link .= $add_fragment;				$page_links[] = "<a class='page-numbers' href='" . esc_url( apply_filters( 'paginate_links', $link ) ) . "'>$n_display</a>";				$dots = true;			elseif ( $dots && !$show_all ) :				$page_links[] = "<span class='page-numbers dots'>...</span>";				$dots = false;			endif;		endif;	endfor;	if ( $prev_next && $current && ( $current < $total || -1 == $total ) ) :		$link = str_replace('%_%', $format, $base);		$link = str_replace('%#%', $current + 1, $link);		if ( $add_args )			$link = add_query_arg( $add_args, $link );		$link .= $add_fragment;		$page_links[] = "<a class='next page-numbers' href='" . esc_url( apply_filters( 'paginate_links', $link ) ) . "'>$next_text</a>";	endif;	switch ( $type ) :		case 'array' :			return $page_links;			break;		case 'list' :			$r .= "<ul class='page-numbers'>\n\t<li>";			$r .= join("</li>\n\t<li>", $page_links);			$r .= "</li>\n</ul>\n";			break;		default :			$r = join("\n", $page_links);			break;	endswitch;	return $r;}/** * Registers an admin colour scheme css file. * * Allows a plugin to register a new admin colour scheme. For example: * <code> * wp_admin_css_color('classic', __('Classic'), admin_url("css/colors-classic.css"), * array('#07273E', '#14568A', '#D54E21', '#2683AE')); * </code> * * @since 2.5.0 * * @param string $key The unique key for this theme. * @param string $name The name of the theme. * @param string $url The url of the css file containing the colour scheme. * @param array @colors Optional An array of CSS color definitions which are used to give the user a feel for the theme. */function wp_admin_css_color($key, $name, $url, $colors = array()) {	global $_wp_admin_css_colors;	if ( !isset($_wp_admin_css_colors) )		$_wp_admin_css_colors = array();	$_wp_admin_css_colors[$key] = (object) array('name' => $name, 'url' => $url, 'colors' => $colors);}/** * Registers the default Admin color schemes * * @since 3.0.0 */function register_admin_color_schemes() {	wp_admin_css_color('classic', __('Blue'), admin_url("css/colors-classic.css"), array('#073447', '#21759B', '#EAF3FA', '#BBD8E7'));	wp_admin_css_color('fresh', __('Gray'), admin_url("css/colors-fresh.css"), array('#464646', '#6D6D6D', '#F1F1F1', '#DFDFDF'));}/** * Display the URL of a WordPress admin CSS file. * * @see WP_Styles::_css_href and its style_loader_src filter. * * @since 2.3.0 * * @param string $file file relative to wp-admin/ without its ".css" extension. */function wp_admin_css_uri( $file = 'wp-admin' ) {	if ( defined('WP_INSTALLING') ) {		$_file = "./$file.css";	} else {		$_file = admin_url("$file.css");	}	$_file = add_query_arg( 'version', get_bloginfo( 'version' ),  $_file );	return apply_filters( 'wp_admin_css_uri', $_file, $file );}/** * Enqueues or directly prints a stylesheet link to the specified CSS file. * * "Intelligently" decides to enqueue or to print the CSS file. If the * 'wp_print_styles' action has *not* yet been called, the CSS file will be * enqueued. If the wp_print_styles action *has* been called, the CSS link will * be printed. Printing may be forced by passing TRUE as the $force_echo * (second) parameter. * * For backward compatibility with WordPress 2.3 calling method: If the $file * (first) parameter does not correspond to a registered CSS file, we assume * $file is a file relative to wp-admin/ without its ".css" extension. A * stylesheet link to that generated URL is printed. * * @package WordPress * @since 2.3.0 * @uses $wp_styles WordPress Styles Object * * @param string $file Style handle name or file name (without ".css" extension) relative to wp-admin/ * @param bool $force_echo Optional.  Force the stylesheet link to be printed rather than enqueued. */function wp_admin_css( $file = 'wp-admin', $force_echo = false ) {	global $wp_styles;	if ( !is_a($wp_styles, 'WP_Styles') )		$wp_styles = new WP_Styles();	// For backward compatibility	$handle = 0 === strpos( $file, 'css/' ) ? substr( $file, 4 ) : $file;	if ( $wp_styles->query( $handle ) ) {		if ( $force_echo || did_action( 'wp_print_styles' ) ) // we already printed the style queue.  Print this one immediately			wp_print_styles( $handle );		else // Add to style queue			wp_enqueue_style( $handle );		return;	}	echo apply_filters( 'wp_admin_css', "<link rel='stylesheet' href='" . esc_url( wp_admin_css_uri( $file ) ) . "' type='text/css' />\n", $file );	if ( is_rtl() )		echo apply_filters( 'wp_admin_css', "<link rel='stylesheet' href='" . esc_url( wp_admin_css_uri( "$file-rtl" ) ) . "' type='text/css' />\n", "$file-rtl" );}/** * Enqueues the default ThickBox js and css. * * If any of the settings need to be changed, this can be done with another js * file similar to media-upload.js and theme-preview.js. That file should * require array('thickbox') to ensure it is loaded after. * * @since 2.5.0 */function add_thickbox() {	wp_enqueue_script( 'thickbox' );	wp_enqueue_style( 'thickbox' );}/** * Display the XHTML generator that is generated on the wp_head hook. * * @since 2.5.0 */function wp_generator() {	the_generator( apply_filters( 'wp_generator_type', 'xhtml' ) );}/** * Display the generator XML or Comment for RSS, ATOM, etc. * * Returns the correct generator type for the requested output format. Allows * for a plugin to filter generators overall the the_generator filter. * * @since 2.5.0 * @uses apply_filters() Calls 'the_generator' hook. * * @param string $type The type of generator to output - (html|xhtml|atom|rss2|rdf|comment|export). */function the_generator( $type ) {	echo apply_filters('the_generator', get_the_generator($type), $type) . "\n";}/** * Creates the generator XML or Comment for RSS, ATOM, etc. * * Returns the correct generator type for the requested output format. Allows * for a plugin to filter generators on an individual basis using the * 'get_the_generator_{$type}' filter. * * @since 2.5.0 * @uses apply_filters() Calls 'get_the_generator_$type' hook. * * @param string $type The type of generator to return - (html|xhtml|atom|rss2|rdf|comment|export). * @return string The HTML content for the generator. */function get_the_generator( $type = '' ) {	if ( empty( $type ) ) {		$current_filter = current_filter();		if ( empty( $current_filter ) )			return;		switch ( $current_filter ) {			case 'rss2_head' :			case 'commentsrss2_head' :				$type = 'rss2';				break;			case 'rss_head' :			case 'opml_head' :				$type = 'comment';				break;			case 'rdf_header' :				$type = 'rdf';				break;			case 'atom_head' :			case 'comments_atom_head' :			case 'app_head' :				$type = 'atom';				break;		}	}	switch ( $type ) {		case 'html':			$gen = '<meta name="generator" content="WordPress ' . get_bloginfo( 'version' ) . '">';			break;		case 'xhtml':			$gen = '<meta name="generator" content="WordPress ' . get_bloginfo( 'version' ) . '" />';			break;		case 'atom':			$gen = '<generator uri="http://wordpress.org/" version="' . get_bloginfo_rss( 'version' ) . '">WordPress</generator>';			break;		case 'rss2':			$gen = '<generator>http://wordpress.org/?v=' . get_bloginfo_rss( 'version' ) . '</generator>';			break;		case 'rdf':			$gen = '<admin:generatorAgent rdf:resource="http://wordpress.org/?v=' . get_bloginfo_rss( 'version' ) . '" />';			break;		case 'comment':			$gen = '<!-- generator="WordPress/' . get_bloginfo( 'version' ) . '" -->';			break;		case 'export':			$gen = '<!-- generator="WordPress/' . get_bloginfo_rss('version') . '" created="'. date('Y-m-d H:i') . '"-->';			break;	}	return apply_filters( "get_the_generator_{$type}", $gen, $type );}/** * Outputs the html checked attribute. * * Compares the first two arguments and if identical marks as checked * * @since 1.0 * * @param mixed $checked One of the values to compare * @param mixed $current (true) The other value to compare if not just true * @param bool $echo Whether to echo or just return the string * @return string html attribute or empty string */function checked( $checked, $current = true, $echo = true ) {	return __checked_selected_helper( $checked, $current, $echo, 'checked' );}/** * Outputs the html selected attribute. * * Compares the first two arguments and if identical marks as selected * * @since 1.0 * * @param mixed selected One of the values to compare * @param mixed $current (true) The other value to compare if not just true * @param bool $echo Whether to echo or just return the string * @return string html attribute or empty string */function selected( $selected, $current = true, $echo = true ) {	return __checked_selected_helper( $selected, $current, $echo, 'selected' );}/** * Outputs the html disabled attribute. * * Compares the first two arguments and if identical marks as disabled * * @since 3.0.0 * * @param mixed $disabled One of the values to compare * @param mixed $current (true) The other value to compare if not just true * @param bool $echo Whether to echo or just return the string * @return string html attribute or empty string */function disabled( $disabled, $current = true, $echo = true ) {	return __checked_selected_helper( $disabled, $current, $echo, 'disabled' );}/** * Private helper function for checked, selected, and disabled. * * Compares the first two arguments and if identical marks as $type * * @since 2.8 * @access private * * @param any $helper One of the values to compare * @param any $current (true) The other value to compare if not just true * @param bool $echo Whether to echo or just return the string * @param string $type The type of checked|selected|disabled we are doing * @return string html attribute or empty string */function __checked_selected_helper( $helper, $current, $echo, $type ) {	if ( (string) $helper === (string) $current )		$result = " $type='$type'";	else		$result = '';	if ( $echo )		echo $result;	return $result;}?>
<?php/** * Theme, template, and stylesheet functions. * * @package WordPress * @subpackage Template *//** * Whether a child theme is in use. * * @since 3.0.0 * * @return bool true if a child theme is in use, false otherwise. **/function is_child_theme() {	return ( TEMPLATEPATH !== STYLESHEETPATH );}/** * Retrieve name of the current stylesheet. * * The theme name that the administrator has currently set the front end theme * as. * * For all extensive purposes, the template name and the stylesheet name are * going to be the same for most cases. * * @since 1.5.0 * @uses apply_filters() Calls 'stylesheet' filter on stylesheet name. * * @return string Stylesheet name. */function get_stylesheet() {	return apply_filters('stylesheet', get_option('stylesheet'));}/** * Retrieve stylesheet directory path for current theme. * * @since 1.5.0 * @uses apply_filters() Calls 'stylesheet_directory' filter on stylesheet directory and theme name. * * @return string Path to current theme directory. */function get_stylesheet_directory() {	$stylesheet = get_stylesheet();	$theme_root = get_theme_root( $stylesheet );	$stylesheet_dir = "$theme_root/$stylesheet";	return apply_filters( 'stylesheet_directory', $stylesheet_dir, $stylesheet, $theme_root );}/** * Retrieve stylesheet directory URI. * * @since 1.5.0 * * @return string */function get_stylesheet_directory_uri() {	$stylesheet = get_stylesheet();	$theme_root_uri = get_theme_root_uri( $stylesheet );	$stylesheet_dir_uri = "$theme_root_uri/$stylesheet";	return apply_filters( 'stylesheet_directory_uri', $stylesheet_dir_uri, $stylesheet, $theme_root_uri );}/** * Retrieve URI of current theme stylesheet. * * The stylesheet file name is 'style.css' which is appended to {@link * get_stylesheet_directory_uri() stylesheet directory URI} path. * * @since 1.5.0 * @uses apply_filters() Calls 'stylesheet_uri' filter on stylesheet URI path and stylesheet directory URI. * * @return string */function get_stylesheet_uri() {	$stylesheet_dir_uri = get_stylesheet_directory_uri();	$stylesheet_uri = $stylesheet_dir_uri . "/style.css";	return apply_filters('stylesheet_uri', $stylesheet_uri, $stylesheet_dir_uri);}/** * Retrieve localized stylesheet URI. * * The stylesheet directory for the localized stylesheet files are located, by * default, in the base theme directory. The name of the locale file will be the * locale followed by '.css'. If that does not exist, then the text direction * stylesheet will be checked for existence, for example 'ltr.css'. * * The theme may change the location of the stylesheet directory by either using * the 'stylesheet_directory_uri' filter or the 'locale_stylesheet_uri' filter. * If you want to change the location of the stylesheet files for the entire * WordPress workflow, then change the former. If you just have the locale in a * separate folder, then change the latter. * * @since 2.1.0 * @uses apply_filters() Calls 'locale_stylesheet_uri' filter on stylesheet URI path and stylesheet directory URI. * * @return string */function get_locale_stylesheet_uri() {	global $wp_locale;	$stylesheet_dir_uri = get_stylesheet_directory_uri();	$dir = get_stylesheet_directory();	$locale = get_locale();	if ( file_exists("$dir/$locale.css") )		$stylesheet_uri = "$stylesheet_dir_uri/$locale.css";	elseif ( !empty($wp_locale->text_direction) && file_exists("$dir/{$wp_locale->text_direction}.css") )		$stylesheet_uri = "$stylesheet_dir_uri/{$wp_locale->text_direction}.css";	else		$stylesheet_uri = '';	return apply_filters('locale_stylesheet_uri', $stylesheet_uri, $stylesheet_dir_uri);}/** * Retrieve name of the current theme. * * @since 1.5.0 * @uses apply_filters() Calls 'template' filter on template option. * * @return string Template name. */function get_template() {	return apply_filters('template', get_option('template'));}/** * Retrieve current theme directory. * * @since 1.5.0 * @uses apply_filters() Calls 'template_directory' filter on template directory path and template name. * * @return string Template directory path. */function get_template_directory() {	$template = get_template();	$theme_root = get_theme_root( $template );	$template_dir = "$theme_root/$template";	return apply_filters( 'template_directory', $template_dir, $template, $theme_root );}/** * Retrieve theme directory URI. * * @since 1.5.0 * @uses apply_filters() Calls 'template_directory_uri' filter on template directory URI path and template name. * * @return string Template directory URI. */function get_template_directory_uri() {	$template = get_template();	$theme_root_uri = get_theme_root_uri( $template );	$template_dir_uri = "$theme_root_uri/$template";	return apply_filters( 'template_directory_uri', $template_dir_uri, $template, $theme_root_uri );}/** * Retrieve theme data from parsed theme file. * * The description will have the tags filtered with the following HTML elements * whitelisted. The <b>'a'</b> element with the <em>href</em> and <em>title</em> * attributes. The <b>abbr</b> element with the <em>title</em> attribute. The * <b>acronym<b> element with the <em>title</em> attribute allowed. The * <b>code</b>, <b>em</b>, and <b>strong</b> elements also allowed. * * The style.css file must contain theme name, theme URI, and description. The * data can also contain author URI, author, template (parent template), * version, status, and finally tags. Some of these are not used by WordPress * administration panels, but are used by theme directory web sites which list * the theme. * * @since 1.5.0 * * @param string $theme_file Theme file path. * @return array Theme data. */function get_theme_data( $theme_file ) {	$default_headers = array(		'Name' => 'Theme Name',		'URI' => 'Theme URI',		'Description' => 'Description',		'Author' => 'Author',		'AuthorURI' => 'Author URI',		'Version' => 'Version',		'Template' => 'Template',		'Status' => 'Status',		'Tags' => 'Tags'		);	$themes_allowed_tags = array(		'a' => array(			'href' => array(),'title' => array()			),		'abbr' => array(			'title' => array()			),		'acronym' => array(			'title' => array()			),		'code' => array(),		'em' => array(),		'strong' => array()	);	$theme_data = get_file_data( $theme_file, $default_headers, 'theme' );	$theme_data['Name'] = $theme_data['Title'] = wp_kses( $theme_data['Name'], $themes_allowed_tags );	$theme_data['URI'] = esc_url( $theme_data['URI'] );	$theme_data['Description'] = wptexturize( wp_kses( $theme_data['Description'], $themes_allowed_tags ) );	$theme_data['AuthorURI'] = esc_url( $theme_data['AuthorURI'] );	$theme_data['Template'] = wp_kses( $theme_data['Template'], $themes_allowed_tags );	$theme_data['Version'] = wp_kses( $theme_data['Version'], $themes_allowed_tags );	if ( $theme_data['Status'] == '' )		$theme_data['Status'] = 'publish';	else		$theme_data['Status'] = wp_kses( $theme_data['Status'], $themes_allowed_tags );	if ( $theme_data['Tags'] == '' )		$theme_data['Tags'] = array();	else		$theme_data['Tags'] = array_map( 'trim', explode( ',', wp_kses( $theme_data['Tags'], array() ) ) );	if ( $theme_data['Author'] == '' ) {		$theme_data['Author'] = $theme_data['AuthorName'] = __('Anonymous');	} else {		$theme_data['AuthorName'] = wp_kses( $theme_data['Author'], $themes_allowed_tags );		if ( empty( $theme_data['AuthorURI'] ) ) {			$theme_data['Author'] = $theme_data['AuthorName'];		} else {			$theme_data['Author'] = sprintf( '<a href="%1$s" title="%2$s">%3$s</a>', $theme_data['AuthorURI'], __( 'Visit author homepage' ), $theme_data['AuthorName'] );		}	}	return $theme_data;}/** * Retrieve list of themes with theme data in theme directory. * * The theme is broken, if it doesn't have a parent theme and is missing either * style.css and, or index.php. If the theme has a parent theme then it is * broken, if it is missing style.css; index.php is optional. The broken theme * list is saved in the {@link $wp_broken_themes} global, which is displayed on * the theme list in the administration panels. * * @since 1.5.0 * @global array $wp_broken_themes Stores the broken themes. * @global array $wp_themes Stores the working themes. * * @return array Theme list with theme data. */function get_themes() {	global $wp_themes, $wp_broken_themes;	if ( isset($wp_themes) )		return $wp_themes;	/* Register the default root as a theme directory */	register_theme_directory( get_theme_root() );	if ( !$theme_files = search_theme_directories() )		return false;	asort( $theme_files );	$wp_themes = array();	foreach ( (array) $theme_files as $theme_file ) {		$theme_root = $theme_file['theme_root'];		$theme_file = $theme_file['theme_file'];		if ( !is_readable("$theme_root/$theme_file") ) {			$wp_broken_themes[$theme_file] = array('Name' => $theme_file, 'Title' => $theme_file, 'Description' => __('File not readable.'));			continue;		}		$theme_data = get_theme_data("$theme_root/$theme_file");		$name        = $theme_data['Name'];		$title       = $theme_data['Title'];		$description = wptexturize($theme_data['Description']);		$version     = $theme_data['Version'];		$author      = $theme_data['Author'];		$template    = $theme_data['Template'];		$stylesheet  = dirname($theme_file);		$screenshot = false;		foreach ( array('png', 'gif', 'jpg', 'jpeg') as $ext ) {			if (file_exists("$theme_root/$stylesheet/screenshot.$ext")) {				$screenshot = "screenshot.$ext";				break;			}		}		if ( empty($name) ) {			$name = dirname($theme_file);			$title = $name;		}		$parent_template = $template;		if ( empty($template) ) {			if ( file_exists("$theme_root/$stylesheet/index.php") )				$template = $stylesheet;			else				continue;		}		$template = trim( $template );		if ( !file_exists("$theme_root/$template/index.php") ) {			$parent_dir = dirname(dirname($theme_file));			if ( file_exists("$theme_root/$parent_dir/$template/index.php") ) {				$template = "$parent_dir/$template";				$template_directory = "$theme_root/$template";			} else {				/**				 * The parent theme doesn't exist in the current theme's folder or sub folder				 * so lets use the theme root for the parent template.				 */				if ( isset($theme_files[$template]) && file_exists( $theme_files[$template]['theme_root'] . "/$template/index.php" ) ) {					$template_directory = $theme_files[$template]['theme_root'] . "/$template";				} else {					if ( empty( $parent_template) )						$wp_broken_themes[$name] = array('Name' => $name, 'Title' => $title, 'Description' => __('Template is missing.'), 'error' => 'no_template');					else						$wp_broken_themes[$name] = array('Name' => $name, 'Title' => $title, 'Description' => sprintf( __('The parent theme is missing. Please install the "%s" parent theme.'),  $parent_template ), 'error' => 'no_parent', 'parent' => $parent_template );					continue;				}			}		} else {			$template_directory = trim( $theme_root . '/' . $template );		}		$stylesheet_files = array();		$template_files = array();		$stylesheet_dir = @ dir("$theme_root/$stylesheet");		if ( $stylesheet_dir ) {			while ( ($file = $stylesheet_dir->read()) !== false ) {				if ( !preg_match('|^\.+$|', $file) ) {					if ( preg_match('|\.css$|', $file) )						$stylesheet_files[] = "$theme_root/$stylesheet/$file";					elseif ( preg_match('|\.php$|', $file) )						$template_files[] = "$theme_root/$stylesheet/$file";				}			}			@ $stylesheet_dir->close();		}		$template_dir = @ dir("$template_directory");		if ( $template_dir ) {			while ( ($file = $template_dir->read()) !== false ) {				if ( preg_match('|^\.+$|', $file) )					continue;				if ( preg_match('|\.php$|', $file) ) {					$template_files[] = "$template_directory/$file";				} elseif ( is_dir("$template_directory/$file") ) {					$template_subdir = @ dir("$template_directory/$file");					if ( !$template_subdir )						continue;					while ( ($subfile = $template_subdir->read()) !== false ) {						if ( preg_match('|^\.+$|', $subfile) )							continue;						if ( preg_match('|\.php$|', $subfile) )							$template_files[] = "$template_directory/$file/$subfile";					}					@ $template_subdir->close();				}			}			@ $template_dir->close();		}		//Make unique and remove duplicates when stylesheet and template are the same i.e. most themes		$template_files = array_unique($template_files);		$stylesheet_files = array_unique($stylesheet_files);		$template_dir = dirname($template_files[0]);		$stylesheet_dir = dirname($stylesheet_files[0]);		if ( empty($template_dir) )			$template_dir = '/';		if ( empty($stylesheet_dir) )			$stylesheet_dir = '/';		// Check for theme name collision.  This occurs if a theme is copied to		// a new theme directory and the theme header is not updated.  Whichever		// theme is first keeps the name.  Subsequent themes get a suffix applied.		// The Default and Classic themes always trump their pretenders.		if ( isset($wp_themes[$name]) ) {			if ( ('WordPress Default' == $name || 'WordPress Classic' == $name) &&					 ('default' == $stylesheet || 'classic' == $stylesheet) ) {				// If another theme has claimed to be one of our default themes, move				// them aside.				$suffix = $wp_themes[$name]['Stylesheet'];				$new_name = "$name/$suffix";				$wp_themes[$new_name] = $wp_themes[$name];				$wp_themes[$new_name]['Name'] = $new_name;			} else {				$name = "$name/$stylesheet";			}		}		$theme_roots[$stylesheet] = str_replace( WP_CONTENT_DIR, '', $theme_root );		$wp_themes[$name] = array(			'Name' => $name,			'Title' => $title,			'Description' => $description,			'Author' => $author,			'Author Name' => $theme_data['AuthorName'],			'Author URI' => $theme_data['AuthorURI'],			'Version' => $version,			'Template' => $template,			'Stylesheet' => $stylesheet,			'Template Files' => $template_files,			'Stylesheet Files' => $stylesheet_files,			'Template Dir' => $template_dir,			'Stylesheet Dir' => $stylesheet_dir,			'Status' => $theme_data['Status'],			'Screenshot' => $screenshot,			'Tags' => $theme_data['Tags'],			'Theme Root' => $theme_root,			'Theme Root URI' => str_replace( WP_CONTENT_DIR, content_url(), $theme_root ),		);	}	unset($theme_files);	/* Store theme roots in the DB */	if ( get_site_transient( 'theme_roots' ) != $theme_roots )		set_site_transient( 'theme_roots', $theme_roots, 7200 ); // cache for two hours	unset($theme_roots);	/* Resolve theme dependencies. */	$theme_names = array_keys( $wp_themes );	foreach ( (array) $theme_names as $theme_name ) {		$wp_themes[$theme_name]['Parent Theme'] = '';		if ( $wp_themes[$theme_name]['Stylesheet'] != $wp_themes[$theme_name]['Template'] ) {			foreach ( (array) $theme_names as $parent_theme_name ) {				if ( ($wp_themes[$parent_theme_name]['Stylesheet'] == $wp_themes[$parent_theme_name]['Template']) && ($wp_themes[$parent_theme_name]['Template'] == $wp_themes[$theme_name]['Template']) ) {					$wp_themes[$theme_name]['Parent Theme'] = $wp_themes[$parent_theme_name]['Name'];					break;				}			}		}	}	return $wp_themes;}/** * Retrieve theme roots. * * @since 2.9.0 * * @return array Theme roots */function get_theme_roots() {	$theme_roots = get_site_transient( 'theme_roots' );	if ( false === $theme_roots ) {		get_themes();		$theme_roots = get_site_transient( 'theme_roots' ); // this is set in get_theme()	}	return $theme_roots;}/** * Retrieve theme data. * * @since 1.5.0 * * @param string $theme Theme name. * @return array|null Null, if theme name does not exist. Theme data, if exists. */function get_theme($theme) {	$themes = get_themes();	if ( array_key_exists($theme, $themes) )		return $themes[$theme];	return null;}/** * Retrieve current theme display name. * * If the 'current_theme' option has already been set, then it will be returned * instead. If it is not set, then each theme will be iterated over until both * the current stylesheet and current template name. * * @since 1.5.0 * * @return string */function get_current_theme() {	if ( $theme = get_option('current_theme') )		return $theme;	$themes = get_themes();	$theme_names = array_keys($themes);	$current_template = get_option('template');	$current_stylesheet = get_option('stylesheet');	$current_theme = 'WordPress Default';	if ( $themes ) {		foreach ( (array) $theme_names as $theme_name ) {			if ( $themes[$theme_name]['Stylesheet'] == $current_stylesheet &&					$themes[$theme_name]['Template'] == $current_template ) {				$current_theme = $themes[$theme_name]['Name'];				break;			}		}	}	update_option('current_theme', $current_theme);	return $current_theme;}/** * Register a directory that contains themes. * * @since 2.9.0 * * @param string $directory Either the full filesystem path to a theme folder or a folder within WP_CONTENT_DIR * @return bool */function register_theme_directory( $directory) {	global $wp_theme_directories;	/* If this folder does not exist, return and do not register */	if ( !file_exists( $directory ) )			/* Try prepending as the theme directory could be relative to the content directory */		$registered_directory = WP_CONTENT_DIR . '/' . $directory;	else		$registered_directory = $directory;	/* If this folder does not exist, return and do not register */	if ( !file_exists( $registered_directory ) )		return false;	$wp_theme_directories[] = $registered_directory;	return true;}/** * Search all registered theme directories for complete and valid themes. * * @since 2.9.0 * * @return array Valid themes found */function search_theme_directories() {	global $wp_theme_directories, $wp_broken_themes;	if ( empty( $wp_theme_directories ) )		return false;	$theme_files = array();	$wp_broken_themes = array();	/* Loop the registered theme directories and extract all themes */	foreach ( (array) $wp_theme_directories as $theme_root ) {		$theme_loc = $theme_root;		/* We don't want to replace all forward slashes, see Trac #4541 */		if ( '/' != WP_CONTENT_DIR )			$theme_loc = str_replace(WP_CONTENT_DIR, '', $theme_root);		/* Files in the root of the current theme directory and one subdir down */		$themes_dir = @ opendir($theme_root);		if ( !$themes_dir )			return false;		while ( ($theme_dir = readdir($themes_dir)) !== false ) {			if ( is_dir($theme_root . '/' . $theme_dir) && is_readable($theme_root . '/' . $theme_dir) ) {				if ( $theme_dir{0} == '.' || $theme_dir == 'CVS' )					continue;				$stylish_dir = @opendir($theme_root . '/' . $theme_dir);				$found_stylesheet = false;				while ( ($theme_file = readdir($stylish_dir)) !== false ) {					if ( $theme_file == 'style.css' ) {						$theme_files[$theme_dir] = array( 'theme_file' => $theme_dir . '/' . $theme_file, 'theme_root' => $theme_root );						$found_stylesheet = true;						break;					}				}				@closedir($stylish_dir);				if ( !$found_stylesheet ) { // look for themes in that dir					$subdir = "$theme_root/$theme_dir";					$subdir_name = $theme_dir;					$theme_subdirs = @opendir( $subdir );					$found_subdir_themes = false;					while ( ($theme_subdir = readdir($theme_subdirs)) !== false ) {						if ( is_dir( $subdir . '/' . $theme_subdir) && is_readable($subdir . '/' . $theme_subdir) ) {							if ( $theme_subdir{0} == '.' || $theme_subdir == 'CVS' )								continue;							$stylish_dir = @opendir($subdir . '/' . $theme_subdir);							$found_stylesheet = false;							while ( ($theme_file = readdir($stylish_dir)) !== false ) {								if ( $theme_file == 'style.css' ) {									$theme_files["$theme_dir/$theme_subdir"] = array( 'theme_file' => $subdir_name . '/' . $theme_subdir . '/' . $theme_file, 'theme_root' => $theme_root );									$found_stylesheet = true;									$found_subdir_themes = true;									break;								}							}							@closedir($stylish_dir);						}					}					@closedir($theme_subdirs);					if ( !$found_subdir_themes )						$wp_broken_themes[$theme_dir] = array('Name' => $theme_dir, 'Title' => $theme_dir, 'Description' => __('Stylesheet is missing.'));				}			}		}		@closedir( $themes_dir );	}	return $theme_files;}/** * Retrieve path to themes directory. * * Does not have trailing slash. * * @since 1.5.0 * @param $stylesheet_or_template The stylesheet or template name of the theme * @uses apply_filters() Calls 'theme_root' filter on path. * * @return string Theme path. */function get_theme_root( $stylesheet_or_template = false ) {	if ($stylesheet_or_template) {		$theme_roots = get_theme_roots();		if ( ! empty( $theme_roots[$stylesheet_or_template] ) )			$theme_root = WP_CONTENT_DIR . $theme_roots[$stylesheet_or_template];		else			$theme_root = WP_CONTENT_DIR . '/themes';	} else {		$theme_root = WP_CONTENT_DIR . '/themes';	}	return apply_filters( 'theme_root', $theme_root );}/** * Retrieve URI for themes directory. * * Does not have trailing slash. * * @since 1.5.0 * @param $stylesheet_or_template The stylesheet or template name of the theme * * @return string Themes URI. */function get_theme_root_uri( $stylesheet_or_template = false ) {	$theme_roots = get_theme_roots();	if ( isset( $theme_roots[$stylesheet_or_template] ) && $theme_roots[$stylesheet_or_template] )		$theme_root_uri = content_url( $theme_roots[$stylesheet_or_template] );	else		$theme_root_uri = content_url( 'themes' );	return apply_filters( 'theme_root_uri', $theme_root_uri, get_option('siteurl'), $stylesheet_or_template );}/** * Retrieve path to file without the use of extension. * * Used to quickly retrieve the path of file without including the file * extension. It will also check the parent template, if the file exists, with * the use of {@link locate_template()}. Allows for more generic file location * without the use of the other get_*_template() functions. * * Can be used with include() or require() to retrieve path. * <code> * if( '' != get_query_template( '404' ) ) *     include( get_query_template( '404' ) ); * </code> * or the same can be accomplished with * <code> * if( '' != get_404_template() ) *     include( get_404_template() ); * </code> * * @since 1.5.0 * * @param string $type Filename without extension. * @return string Full path to file. */function get_query_template($type) {	$type = preg_replace( '|[^a-z0-9-]+|', '', $type );	return apply_filters("{$type}_template", locate_template(array("{$type}.php")));}/** * Retrieve path of index template in current or parent template. * * @since 3.0.0 * * @return string */function get_index_template() {	return get_query_template('index');}/** * Retrieve path of 404 template in current or parent template. * * @since 1.5.0 * * @return string */function get_404_template() {	return get_query_template('404');}/** * Retrieve path of archive template in current or parent template. * * @since 1.5.0 * * @return string */function get_archive_template() {	return get_query_template('archive');}/** * Retrieve path of author template in current or parent template. * * @since 1.5.0 * * @return string */function get_author_template() {	$author_id = absint( get_query_var( 'author' ) );	$author = get_user_by( 'id', $author_id );	$author = $author->user_nicename;	$templates = array();	if ( $author )		$templates[] = "author-{$author}.php";	if ( $author_id )		$templates[] = "author-{$author_id}.php";	$templates[] = 'author.php';	$template = locate_template( $templates );	return apply_filters( 'author_template', $template );}/** * Retrieve path of category template in current or parent template. * * Works by first retrieving the current slug for example 'category-default.php' and then * trying category ID, for example 'category-1.php' and will finally fallback to category.php * template, if those files don't exist. * * @since 1.5.0 * @uses apply_filters() Calls 'category_template' on file path of category template. * * @return string */function get_category_template() {	$cat_ID = absint( get_query_var('cat') );	$category = get_category( $cat_ID );	$templates = array();	if ( !is_wp_error($category) )		$templates[] = "category-{$category->slug}.php";	$templates[] = "category-$cat_ID.php";	$templates[] = "category.php";	$template = locate_template($templates);	return apply_filters('category_template', $template);}/** * Retrieve path of tag template in current or parent template. * * Works by first retrieving the current tag name, for example 'tag-wordpress.php' and then * trying tag ID, for example 'tag-1.php' and will finally fallback to tag.php * template, if those files don't exist. * * @since 2.3.0 * @uses apply_filters() Calls 'tag_template' on file path of tag template. * * @return string */function get_tag_template() {	$tag_id = absint( get_query_var('tag_id') );	$tag_name = get_query_var('tag');	$templates = array();	if ( $tag_name )		$templates[] = "tag-$tag_name.php";	if ( $tag_id )		$templates[] = "tag-$tag_id.php";	$templates[] = "tag.php";	$template = locate_template($templates);	return apply_filters('tag_template', $template);}/** * Retrieve path of taxonomy template in current or parent template. * * Retrieves the taxonomy and term, if term is available. The template is * prepended with 'taxonomy-' and followed by both the taxonomy string and * the taxonomy string followed by a dash and then followed by the term. * * The taxonomy and term template is checked and used first, if it exists. * Second, just the taxonomy template is checked, and then finally, taxonomy.php * template is used. If none of the files exist, then it will fall back on to * index.php. * * @since unknown (2.6.0 most likely) * @uses apply_filters() Calls 'taxonomy_template' filter on found path. * * @return string */function get_taxonomy_template() {	$taxonomy = get_query_var('taxonomy');	$term = get_query_var('term');	$templates = array();	if ( $taxonomy && $term )		$templates[] = "taxonomy-$taxonomy-$term.php";	if ( $taxonomy )		$templates[] = "taxonomy-$taxonomy.php";	$templates[] = "taxonomy.php";	$template = locate_template($templates);	return apply_filters('taxonomy_template', $template);}/** * Retrieve path of date template in current or parent template. * * @since 1.5.0 * * @return string */function get_date_template() {	return get_query_template('date');}/** * Retrieve path of home template in current or parent template. * * This is the template used for the page containing the blog posts * * Attempts to locate 'home.php' first before falling back to 'index.php'. * * @since 1.5.0 * @uses apply_filters() Calls 'home_template' on file path of home template. * * @return string */function get_home_template() {	$template = locate_template(array('home.php', 'index.php'));	return apply_filters('home_template', $template);}/** * Retrieve path of front-page template in current or parent template. * * Looks for 'front-page.php'. * * @since 3.0.0 * @uses apply_filters() Calls 'front_page_template' on file path of template. * * @return string */function get_front_page_template() {	return apply_filters( 'front_page_template', locate_template( array('front-page.php') ) );}/** * Retrieve path of page template in current or parent template. * * Will first look for the specifically assigned page template * The will search for 'page-{slug}.php' followed by 'page-id.php' * and finally 'page.php' * * @since 1.5.0 * * @return string */function get_page_template() {	global $wp_query;	$id = (int) $wp_query->get_queried_object_id();	$template = get_post_meta($id, '_wp_page_template', true);	$pagename = get_query_var('pagename');	if ( !$pagename && $id > 0 ) {		// If a static page is set as the front page, $pagename will not be set. Retrieve it from the queried object		$post = $wp_query->get_queried_object();		$pagename = $post->post_name;	}	if ( 'default' == $template )		$template = '';	$templates = array();	if ( !empty($template) && !validate_file($template) )		$templates[] = $template;	if ( $pagename )		$templates[] = "page-$pagename.php";	if ( $id )		$templates[] = "page-$id.php";	$templates[] = "page.php";	return apply_filters('page_template', locate_template($templates));}/** * Retrieve path of paged template in current or parent template. * * @since 1.5.0 * * @return string */function get_paged_template() {	return get_query_template('paged');}/** * Retrieve path of search template in current or parent template. * * @since 1.5.0 * * @return string */function get_search_template() {	return get_query_template('search');}/** * Retrieve path of single template in current or parent template. * * @since 1.5.0 * * @return string */function get_single_template() {	global $wp_query;	$object = $wp_query->get_queried_object();	$templates = array('single-' . $object->post_type . '.php', 'single.php');	return apply_filters('single_template', locate_template($templates));}/** * Retrieve path of attachment template in current or parent template. * * The attachment path first checks if the first part of the mime type exists. * The second check is for the second part of the mime type. The last check is * for both types separated by an underscore. If neither are found then the file * 'attachment.php' is checked and returned. * * Some examples for the 'text/plain' mime type are 'text.php', 'plain.php', and * finally 'text_plain.php'. * * @since 2.0.0 * * @return string */function get_attachment_template() {	global $posts;	$type = explode('/', $posts[0]->post_mime_type);	if ( $template = get_query_template($type[0]) )		return $template;	elseif ( $template = get_query_template($type[1]) )		return $template;	elseif ( $template = get_query_template("$type[0]_$type[1]") )		return $template;	else		return get_query_template('attachment');}/** * Retrieve path of comment popup template in current or parent template. * * Checks for comment popup template in current template, if it exists or in the * parent template. * * @since 1.5.0 * @uses apply_filters() Calls 'comments_popup_template' filter on path. * * @return string */function get_comments_popup_template() {	$template = locate_template(array("comments-popup.php"));	// Backward compat code will be removed in a future release	if ('' == $template)		$template = WPINC . '/theme-compat/comments-popup.php';	return apply_filters('comments_popup_template', $template);}/** * Retrieve the name of the highest priority template file that exists. * * Searches in the STYLESHEETPATH before TEMPLATEPATH so that themes which * inherit from a parent theme can just overload one file. * * @since 2.7.0 * * @param array $template_names Array of template files to search for in priority order. * @param bool $load If true the template file will be loaded if it is found. * @param bool $require_once Whether to require_once or require. Default true. Has no effect if $load is false. * @return string The template filename if one is located. */function locate_template($template_names, $load = false, $require_once = true ) {	if ( !is_array($template_names) )		return '';	$located = '';	foreach ( $template_names as $template_name ) {		if ( !$template_name )			continue;		if ( file_exists(STYLESHEETPATH . '/' . $template_name)) {			$located = STYLESHEETPATH . '/' . $template_name;			break;		} else if ( file_exists(TEMPLATEPATH . '/' . $template_name) ) {			$located = TEMPLATEPATH . '/' . $template_name;			break;		}	}	if ( $load && '' != $located )		load_template( $located, $require_once );	return $located;}/** * Require the template file with WordPress environment. * * The globals are set up for the template file to ensure that the WordPress * environment is available from within the function. The query variables are * also available. * * @since 1.5.0 * * @param string $_template_file Path to template file. * @param bool $require_once Whether to require_once or require. Default true. */function load_template( $_template_file, $require_once = true ) {	global $posts, $post, $wp_did_header, $wp_did_template_redirect, $wp_query, $wp_rewrite, $wpdb, $wp_version, $wp, $id, $comment, $user_ID;	if ( is_array( $wp_query->query_vars ) )		extract( $wp_query->query_vars, EXTR_SKIP );	if ( $require_once )		require_once( $_template_file );	else		require( $_template_file );}/** * Display localized stylesheet link element. * * @since 2.1.0 */function locale_stylesheet() {	$stylesheet = get_locale_stylesheet_uri();	if ( empty($stylesheet) )		return;	echo '<link rel="stylesheet" href="' . $stylesheet . '" type="text/css" media="screen" />';}/** * Start preview theme output buffer. * * Will only preform task if the user has permissions and template and preview * query variables exist. * * @since 2.6.0 */function preview_theme() {	if ( ! (isset($_GET['template']) && isset($_GET['preview'])) )		return;	if ( !current_user_can( 'switch_themes' ) )		return;	$_GET['template'] = preg_replace('|[^a-z0-9_./-]|i', '', $_GET['template']);	if ( validate_file($_GET['template']) )		return;	add_filter( 'template', '_preview_theme_template_filter' );	if ( isset($_GET['stylesheet']) ) {		$_GET['stylesheet'] = preg_replace('|[^a-z0-9_./-]|i', '', $_GET['stylesheet']);		if ( validate_file($_GET['stylesheet']) )			return;		add_filter( 'stylesheet', '_preview_theme_stylesheet_filter' );	}	// Prevent theme mods to current theme being used on theme being previewed	add_filter( 'pre_option_mods_' . get_current_theme(), '__return_empty_array' );	ob_start( 'preview_theme_ob_filter' );}add_action('setup_theme', 'preview_theme');/** * Private function to modify the current template when previewing a theme * * @since 2.9.0 * @access private * * @return string */function _preview_theme_template_filter() {	return isset($_GET['template']) ? $_GET['template'] : '';}/** * Private function to modify the current stylesheet when previewing a theme * * @since 2.9.0 * @access private * * @return string */function _preview_theme_stylesheet_filter() {	return isset($_GET['stylesheet']) ? $_GET['stylesheet'] : '';}/** * Callback function for ob_start() to capture all links in the theme. * * @since 2.6.0 * @access private * * @param string $content * @return string */function preview_theme_ob_filter( $content ) {	return preg_replace_callback( "|(<a.*?href=([\"']))(.*?)([\"'].*?>)|", 'preview_theme_ob_filter_callback', $content );}/** * Manipulates preview theme links in order to control and maintain location. * * Callback function for preg_replace_callback() to accept and filter matches. * * @since 2.6.0 * @access private * * @param array $matches * @return string */function preview_theme_ob_filter_callback( $matches ) {	if ( strpos($matches[4], 'onclick') !== false )		$matches[4] = preg_replace('#onclick=([\'"]).*?(?<!\\\)\\1#i', '', $matches[4]); //Strip out any onclicks from rest of <a>. (?<!\\\) means to ignore the '" if its escaped by \  to prevent breaking mid-attribute.	if (		( false !== strpos($matches[3], '/wp-admin/') )	||		( false !== strpos( $matches[3], '://' ) && 0 !== strpos( $matches[3], home_url() ) )	||		( false !== strpos($matches[3], '/feed/') )	||		( false !== strpos($matches[3], '/trackback/') )	)		return $matches[1] . "#$matches[2] onclick=$matches[2]return false;" . $matches[4];	$link = add_query_arg( array('preview' => 1, 'template' => $_GET['template'], 'stylesheet' => @$_GET['stylesheet'] ), $matches[3] );	if ( 0 === strpos($link, 'preview=1') )		$link = "?$link";	return $matches[1] . esc_attr( $link ) . $matches[4];}/** * Switches current theme to new template and stylesheet names. * * @since unknown * @uses do_action() Calls 'switch_theme' action on updated theme display name. * * @param string $template Template name * @param string $stylesheet Stylesheet name. */function switch_theme($template, $stylesheet) {	update_option('template', $template);	update_option('stylesheet', $stylesheet);	delete_option('current_theme');	$theme = get_current_theme();	do_action('switch_theme', $theme);}/** * Checks that current theme files 'index.php' and 'style.css' exists. * * Does not check the default theme, which is the fallback and should always exist. * Will switch theme to the fallback theme if current theme does not validate. * You can use the 'validate_current_theme' filter to return FALSE to * disable this functionality. * * @since 1.5.0 * @see WP_DEFAULT_THEME * * @return bool */function validate_current_theme() {	// Don't validate during an install/upgrade.	if ( defined('WP_INSTALLING') || !apply_filters( 'validate_current_theme', true ) )		return true;	if ( get_template() != WP_DEFAULT_THEME && !file_exists(get_template_directory() . '/index.php') ) {		switch_theme( WP_DEFAULT_THEME, WP_DEFAULT_THEME );		return false;	}	if ( get_stylesheet() != WP_DEFAULT_THEME && !file_exists(get_template_directory() . '/style.css') ) {		switch_theme( WP_DEFAULT_THEME, WP_DEFAULT_THEME );		return false;	}	return true;}/** * Retrieve theme modification value for the current theme. * * If the modification name does not exist, then the $default will be passed * through {@link http://php.net/sprintf sprintf()} PHP function with the first * string the template directory URI and the second string the stylesheet * directory URI. * * @since 2.1.0 * @uses apply_filters() Calls 'theme_mod_$name' filter on the value. * * @param string $name Theme modification name. * @param bool|string $default * @return string */function get_theme_mod($name, $default = false) {	$theme = get_current_theme();	$mods = get_option( "mods_$theme" );	if ( isset($mods[$name]) )		return apply_filters( "theme_mod_$name", $mods[$name] );	return apply_filters( "theme_mod_$name", sprintf($default, get_template_directory_uri(), get_stylesheet_directory_uri()) );}/** * Update theme modification value for the current theme. * * @since 2.1.0 * * @param string $name Theme modification name. * @param string $value theme modification value. */function set_theme_mod($name, $value) {	$theme = get_current_theme();	$mods = get_option("mods_$theme");	$mods[$name] = $value;	update_option("mods_$theme", $mods);	wp_cache_delete("mods_$theme", 'options');}/** * Remove theme modification name from current theme list. * * If removing the name also removes all elements, then the entire option will * be removed. * * @since 2.1.0 * * @param string $name Theme modification name. * @return null */function remove_theme_mod( $name ) {	$theme = get_current_theme();	$mods = get_option("mods_$theme");	if ( !isset($mods[$name]) )		return;	unset($mods[$name]);	if ( empty($mods) )		return remove_theme_mods();	update_option("mods_$theme", $mods);	wp_cache_delete("mods_$theme", 'options');}/** * Remove theme modifications option for current theme. * * @since 2.1.0 */function remove_theme_mods() {	$theme = get_current_theme();	delete_option("mods_$theme");}/** * Retrieve text color for custom header. * * @since 2.1.0 * @uses HEADER_TEXTCOLOR * * @return string */function get_header_textcolor() {	$default = defined('HEADER_TEXTCOLOR') ? HEADER_TEXTCOLOR : '';	return get_theme_mod('header_textcolor', $default);}/** * Display text color for custom header. * * @since 2.1.0 */function header_textcolor() {	echo get_header_textcolor();}/** * Retrieve header image for custom header. * * @since 2.1.0 * @uses HEADER_IMAGE * * @return string */function get_header_image() {	$default = defined('HEADER_IMAGE') ? HEADER_IMAGE : '';	return get_theme_mod('header_image', $default);}/** * Display header image path. * * @since 2.1.0 */function header_image() {	echo get_header_image();}/** * Add callbacks for image header display. * * The parameter $header_callback callback will be required to display the * content for the 'wp_head' action. The parameter $admin_header_callback * callback will be added to Custom_Image_Header class and that will be added * to the 'admin_menu' action. * * @since 2.1.0 * @uses Custom_Image_Header Sets up for $admin_header_callback for administration panel display. * * @param callback $header_callback Call on 'wp_head' action. * @param callback $admin_header_callback Call on custom header administration screen. * @param callback $admin_image_div_callback Output a custom header image div on the custom header administration screen. Optional. */function add_custom_image_header($header_callback, $admin_header_callback, $admin_image_div_callback = '') {	if ( ! empty($header_callback) )		add_action('wp_head', $header_callback);	add_theme_support( 'custom-header' );	if ( ! is_admin() )		return;	require_once(ABSPATH . 'wp-admin/custom-header.php');	$GLOBALS['custom_image_header'] =& new Custom_Image_Header($admin_header_callback, $admin_image_div_callback);	add_action('admin_menu', array(&$GLOBALS['custom_image_header'], 'init'));}/** * Register a selection of default headers to be displayed by the custom header admin UI. * * @since 3.0.0 * * @param array $headers Array of headers keyed by a string id. The ids point to arrays containing 'url', 'thumbnail_url', and 'description' keys. */function register_default_headers( $headers ) {	global $_wp_default_headers;	$_wp_default_headers = array_merge( (array) $_wp_default_headers, (array) $headers );}/** * Unregister default headers. * * This function must be called after register_default_headers() has already added the * header you want to remove. * * @see register_default_headers() * @since 3.0.0 * * @param string|array The header string id (key of array) to remove, or an array thereof. * @return True on success, false on failure. */function unregister_default_headers( $header ) {	global $_wp_default_headers;	if ( is_array( $header ) ) {		array_map( 'unregister_default_headers', $header );	} elseif ( isset( $_wp_default_headers[ $header ] ) ) {		unset( $_wp_default_headers[ $header ] );		return true;	} else {		return false;	}}/** * Retrieve background image for custom background. * * @since 3.0.0 * * @return string */function get_background_image() {	$default = defined('BACKGROUND_IMAGE') ? BACKGROUND_IMAGE : '';	return get_theme_mod('background_image', $default);}/** * Display background image path. * * @since 3.0.0 */function background_image() {	echo get_background_image();}/** * Retrieve value for custom background color. * * @since 3.0.0 * @uses BACKGROUND_COLOR * * @return string */function get_background_color() {	$default = defined('BACKGROUND_COLOR') ? BACKGROUND_COLOR : '';	return get_theme_mod('background_color', $default);}/** * Display background color value. * * @since 3.0.0 */function background_color() {	echo get_background_color();}/** * Add callbacks for background image display. * * The parameter $header_callback callback will be required to display the * content for the 'wp_head' action. The parameter $admin_header_callback * callback will be added to Custom_Background class and that will be added * to the 'admin_menu' action. * * @since 3.0.0 * @uses Custom_Background Sets up for $admin_header_callback for administration panel display. * * @param callback $header_callback Call on 'wp_head' action. * @param callback $admin_header_callback Call on custom background administration screen. * @param callback $admin_image_div_callback Output a custom background image div on the custom background administration screen. Optional. */function add_custom_background($header_callback = '', $admin_header_callback = '', $admin_image_div_callback = '') {	if ( isset($GLOBALS['custom_background']) )		return;	if ( empty($header_callback) )		$header_callback = '_custom_background_cb';	add_action('wp_head', $header_callback);	add_theme_support( 'custom-background' );	if ( ! is_admin() )		return;	require_once(ABSPATH . 'wp-admin/custom-background.php');	$GLOBALS['custom_background'] =& new Custom_Background($admin_header_callback, $admin_image_div_callback);	add_action('admin_menu', array(&$GLOBALS['custom_background'], 'init'));}/** * Default custom background callback. * * @since 3.0.0 * @see add_custom_background() * @access protected */function _custom_background_cb() {	$background = get_background_image();	$color = get_background_color();	if ( ! $background && ! $color )		return;	$style = $color ? "background-color: #$color;" : '';	if ( $background ) {		$image = " background-image: url('$background');";		$repeat = get_theme_mod( 'background_repeat', 'repeat' );		if ( ! in_array( $repeat, array( 'no-repeat', 'repeat-x', 'repeat-y', 'repeat' ) ) )			$repeat = 'repeat';		$repeat = " background-repeat: $repeat;";		$position = get_theme_mod( 'background_position_x', 'left' );		if ( ! in_array( $position, array( 'center', 'right', 'left' ) ) )			$position = 'left';		$position = " background-position: top $position;";		$attachment = get_theme_mod( 'background_attachment', 'scroll' );		if ( ! in_array( $attachment, array( 'fixed', 'scroll' ) ) )			$attachment = 'scroll';		$attachment = " background-attachment: $attachment;";		$style .= $image . $repeat . $position . $attachment;	}?><style type="text/css">body { <?php echo trim( $style ); ?> }</style><?php}/** * Add callback for custom TinyMCE editor stylesheets. * * The parameter $stylesheet is the name of the stylesheet, relative to * the theme root. It also accepts an array of stylesheets. * It is optional and defaults to 'editor-style.css'. * * @since 3.0.0 * * @param mixed $stylesheet Optional. Stylesheet name or array thereof, relative to theme root. * 	Defaults to 'editor-style.css' */function add_editor_style( $stylesheet = 'editor-style.css' ) {	add_theme_support( 'editor-style' );	if ( ! is_admin() )		return;	global $editor_styles;	$editor_styles = (array) $editor_styles;	$stylesheet    = (array) $stylesheet;	if ( is_rtl() ) {		$rtl_stylesheet = str_replace('.css', '-rtl.css', $stylesheet[0]);		$stylesheet[] = $rtl_stylesheet;	}	$editor_styles = array_merge( $editor_styles, $stylesheet );}/** * Allows a theme to register its support of a certain feature * * Must be called in the theme's functions.php file to work. * If attached to a hook, it must be after_setup_theme. * The init hook may be too late for some features. * * @since 2.9.0 * @param string $feature the feature being added */function add_theme_support( $feature ) {	global $_wp_theme_features;	if ( func_num_args() == 1 )		$_wp_theme_features[$feature] = true;	else		$_wp_theme_features[$feature] = array_slice( func_get_args(), 1 );}/** * Allows a theme to de-register its support of a certain feature * * Should be called in the theme's functions.php file. Generally would * be used for child themes to override support from the parent theme. * * @since 3.0.0 * @see add_theme_support() * @param string $feature the feature being added * @return bool Whether feature was removed. */function remove_theme_support( $feature ) {	// Blacklist: for internal registrations not used directly by themes.	if ( in_array( $feature, array( 'custom-background', 'custom-header', 'editor-style', 'widgets' ) ) )		return false;	global $_wp_theme_features;	if ( ! isset( $_wp_theme_features[$feature] ) )		return false;	unset( $_wp_theme_features[$feature] );	return true;}/** * Checks a theme's support for a given feature * * @since 2.9.0 * @param string $feature the feature being checked * @return boolean */function current_theme_supports( $feature ) {	global $_wp_theme_features;	if ( !isset( $_wp_theme_features[$feature] ) )		return false;	// If no args passed then no extra checks need be performed	if ( func_num_args() <= 1 )		return true;	$args = array_slice( func_get_args(), 1 );	// @todo Allow pluggable arg checking	switch ( $feature ) {		case 'post-thumbnails':			// post-thumbnails can be registered for only certain content/post types by passing			// an array of types to add_theme_support().  If no array was passed, then			// any type is accepted			if ( true === $_wp_theme_features[$feature] )  // Registered for all types				return true;			$content_type = $args[0];			if ( in_array($content_type, $_wp_theme_features[$feature][0]) )				return true;			else				return false;			break;	}	return true;}/** * Checks a theme's support for a given feature before loading the functions which implement it. * * @since 2.9.0 * @param string $feature the feature being checked * @param string $include the file containing the functions that implement the feature */function require_if_theme_supports( $feature, $include) {	if ( current_theme_supports( $feature ) )		require ( $include );}/** * Checks an attachment being deleted to see if it's a header or background image. * * If true it removes the theme modification which would be pointing at the deleted * attachment * * @access private * @since 3.0.0 * @param int $id the attachment id */function _delete_attachment_theme_mod( $id ) {	$attachment_image = wp_get_attachment_url( $id );	$header_image = get_header_image();	$background_image = get_background_image();	if ( $header_image && $header_image == $attachment_image )		remove_theme_mod( 'header_image' );	if ( $background_image && $background_image == $attachment_image )		remove_theme_mod( 'background_image' );}add_action( 'delete_attachment', '_delete_attachment_theme_mod' );?>
<?php/** * Post functions and post utility function. * * @package WordPress * @subpackage Post * @since 1.5.0 *///// Post Type Registration///** * Creates the initial post types when 'init' action is fired. */function create_initial_post_types() {	register_post_type( 'post', array(		'public'  => true,		'_builtin' => true, /* internal use only. don't use this when registering your own post type. */		'_edit_link' => 'post.php?post=%d', /* internal use only. don't use this when registering your own post type. */		'capability_type' => 'post',		'hierarchical' => false,		'rewrite' => false,		'query_var' => false,		'supports' => array( 'title', 'editor', 'author', 'thumbnail', 'excerpt', 'trackbacks', 'custom-fields', 'comments', 'revisions' ),	) );	register_post_type( 'page', array(		'public' => true,		'_builtin' => true, /* internal use only. don't use this when registering your own post type. */		'_edit_link' => 'post.php?post=%d', /* internal use only. don't use this when registering your own post type. */		'capability_type' => 'page',		'hierarchical' => true,		'rewrite' => false,		'query_var' => false,		'supports' => array( 'title', 'editor', 'author', 'thumbnail', 'page-attributes', 'custom-fields', 'comments', 'revisions' ),	) );	register_post_type( 'attachment', array(		'labels' => array(			'name' => __( 'Media' ),		),		'public' => true,		'show_ui' => false,		'_builtin' => true, /* internal use only. don't use this when registering your own post type. */		'_edit_link' => 'media.php?attachment_id=%d', /* internal use only. don't use this when registering your own post type. */		'capability_type' => 'post',		'hierarchical' => false,		'rewrite' => false,		'query_var' => false,		'can_export' => false,		'show_in_nav_menus' => false,	) );	register_post_type( 'revision', array(		'labels' => array(			'name' => __( 'Revisions' ),			'singular_name' => __( 'Revision' ),		),		'public' => false,		'_builtin' => true, /* internal use only. don't use this when registering your own post type. */		'_edit_link' => 'revision.php?revision=%d', /* internal use only. don't use this when registering your own post type. */		'capability_type' => 'post',		'hierarchical' => false,		'rewrite' => false,		'query_var' => false,	) );	register_post_type( 'nav_menu_item', array(		'labels' => array(			'name' => __( 'Navigation Menu Items' ),			'singular_name' => __( 'Navigation Menu Item' ),		),		'public' => false,		'_builtin' => true, /* internal use only. don't use this when registering your own post type. */		'capability_type' => 'post',		'hierarchical' => false,		'rewrite' => false,		'query_var' => false,	) );	register_post_status( 'publish', array(		'label'       => _x( 'Published', 'post' ),		'public'      => true,		'_builtin'    => true, /* internal use only. */		'label_count' => _n_noop( 'Published <span class="count">(%s)</span>', 'Published <span class="count">(%s)</span>' ),	) );	register_post_status( 'future', array(		'label'       => _x( 'Scheduled', 'post' ),		'protected'   => true,		'_builtin'    => true, /* internal use only. */		'label_count' => _n_noop('Scheduled <span class="count">(%s)</span>', 'Scheduled <span class="count">(%s)</span>' ),	) );	register_post_status( 'draft', array(		'label'       => _x( 'Draft', 'post' ),		'protected'   => true,		'_builtin'    => true, /* internal use only. */		'label_count' => _n_noop( 'Draft <span class="count">(%s)</span>', 'Drafts <span class="count">(%s)</span>' ),	) );	register_post_status( 'pending', array(		'label'       => _x( 'Pending', 'post' ),		'protected'   => true,		'_builtin'    => true, /* internal use only. */		'label_count' => _n_noop( 'Pending <span class="count">(%s)</span>', 'Pending <span class="count">(%s)</span>' ),	) );	register_post_status( 'private', array(		'label'       => _x( 'Private', 'post' ),		'private'     => true,		'_builtin'    => true, /* internal use only. */		'label_count' => _n_noop( 'Private <span class="count">(%s)</span>', 'Private <span class="count">(%s)</span>' ),	) );	register_post_status( 'trash', array(		'label'       => _x( 'Trash', 'post' ),		'internal'    => true,		'_builtin'    => true, /* internal use only. */		'label_count' => _n_noop( 'Trash <span class="count">(%s)</span>', 'Trash <span class="count">(%s)</span>' ),		'show_in_admin_status_list' => true,	) );	register_post_status( 'auto-draft', array(		'label'    => 'auto-draft',		'internal' => true,		'_builtin' => true, /* internal use only. */	) );	register_post_status( 'inherit', array(		'label'    => 'inherit',		'internal' => true,		'_builtin' => true, /* internal use only. */		'exclude_from_search' => false,	) );}add_action( 'init', 'create_initial_post_types', 0 ); // highest priority/** * Retrieve attached file path based on attachment ID. * * You can optionally send it through the 'get_attached_file' filter, but by * default it will just return the file path unfiltered. * * The function works by getting the single post meta name, named * '_wp_attached_file' and returning it. This is a convenience function to * prevent looking up the meta name and provide a mechanism for sending the * attached filename through a filter. * * @since 2.0.0 * @uses apply_filters() Calls 'get_attached_file' on file path and attachment ID. * * @param int $attachment_id Attachment ID. * @param bool $unfiltered Whether to apply filters. * @return string The file path to the attached file. */function get_attached_file( $attachment_id, $unfiltered = false ) {	$file = get_post_meta( $attachment_id, '_wp_attached_file', true );	// If the file is relative, prepend upload dir	if ( 0 !== strpos($file, '/') && !preg_match('|^.:\\\|', $file) && ( ($uploads = wp_upload_dir()) && false === $uploads['error'] ) )		$file = $uploads['basedir'] . "/$file";	if ( $unfiltered )		return $file;	return apply_filters( 'get_attached_file', $file, $attachment_id );}/** * Update attachment file path based on attachment ID. * * Used to update the file path of the attachment, which uses post meta name * '_wp_attached_file' to store the path of the attachment. * * @since 2.1.0 * @uses apply_filters() Calls 'update_attached_file' on file path and attachment ID. * * @param int $attachment_id Attachment ID * @param string $file File path for the attachment * @return bool False on failure, true on success. */function update_attached_file( $attachment_id, $file ) {	if ( !get_post( $attachment_id ) )		return false;	$file = apply_filters( 'update_attached_file', $file, $attachment_id );	$file = _wp_relative_upload_path($file);	return update_post_meta( $attachment_id, '_wp_attached_file', $file );}/** * Return relative path to an uploaded file. * * The path is relative to the current upload dir. * * @since 2.9.0 * @uses apply_filters() Calls '_wp_relative_upload_path' on file path. * * @param string $path Full path to the file * @return string relative path on success, unchanged path on failure. */function _wp_relative_upload_path( $path ) {	$new_path = $path;	if ( ($uploads = wp_upload_dir()) && false === $uploads['error'] ) {		if ( 0 === strpos($new_path, $uploads['basedir']) ) {				$new_path = str_replace($uploads['basedir'], '', $new_path);				$new_path = ltrim($new_path, '/');		}	}	return apply_filters( '_wp_relative_upload_path', $new_path, $path );}/** * Retrieve all children of the post parent ID. * * Normally, without any enhancements, the children would apply to pages. In the * context of the inner workings of WordPress, pages, posts, and attachments * share the same table, so therefore the functionality could apply to any one * of them. It is then noted that while this function does not work on posts, it * does not mean that it won't work on posts. It is recommended that you know * what context you wish to retrieve the children of. * * Attachments may also be made the child of a post, so if that is an accurate * statement (which needs to be verified), it would then be possible to get * all of the attachments for a post. Attachments have since changed since * version 2.5, so this is most likely unaccurate, but serves generally as an * example of what is possible. * * The arguments listed as defaults are for this function and also of the * {@link get_posts()} function. The arguments are combined with the * get_children defaults and are then passed to the {@link get_posts()} * function, which accepts additional arguments. You can replace the defaults in * this function, listed below and the additional arguments listed in the * {@link get_posts()} function. * * The 'post_parent' is the most important argument and important attention * needs to be paid to the $args parameter. If you pass either an object or an * integer (number), then just the 'post_parent' is grabbed and everything else * is lost. If you don't specify any arguments, then it is assumed that you are * in The Loop and the post parent will be grabbed for from the current post. * * The 'post_parent' argument is the ID to get the children. The 'numberposts' * is the amount of posts to retrieve that has a default of '-1', which is * used to get all of the posts. Giving a number higher than 0 will only * retrieve that amount of posts. * * The 'post_type' and 'post_status' arguments can be used to choose what * criteria of posts to retrieve. The 'post_type' can be anything, but WordPress * post types are 'post', 'pages', and 'attachments'. The 'post_status' * argument will accept any post status within the write administration panels. * * @see get_posts() Has additional arguments that can be replaced. * @internal Claims made in the long description might be inaccurate. * * @since 2.0.0 * * @param mixed $args Optional. User defined arguments for replacing the defaults. * @param string $output Optional. Constant for return type, either OBJECT (default), ARRAY_A, ARRAY_N. * @return array|bool False on failure and the type will be determined by $output parameter. */function &get_children($args = '', $output = OBJECT) {	$kids = array();	if ( empty( $args ) ) {		if ( isset( $GLOBALS['post'] ) ) {			$args = array('post_parent' => (int) $GLOBALS['post']->post_parent );		} else {			return $kids;		}	} elseif ( is_object( $args ) ) {		$args = array('post_parent' => (int) $args->post_parent );	} elseif ( is_numeric( $args ) ) {		$args = array('post_parent' => (int) $args);	}	$defaults = array(		'numberposts' => -1, 'post_type' => 'any',		'post_status' => 'any', 'post_parent' => 0,	);	$r = wp_parse_args( $args, $defaults );	$children = get_posts( $r );	if ( !$children )		return $kids;	update_post_cache($children);	foreach ( $children as $key => $child )		$kids[$child->ID] =& $children[$key];	if ( $output == OBJECT ) {		return $kids;	} elseif ( $output == ARRAY_A ) {		foreach ( (array) $kids as $kid )			$weeuns[$kid->ID] = get_object_vars($kids[$kid->ID]);		return $weeuns;	} elseif ( $output == ARRAY_N ) {		foreach ( (array) $kids as $kid )			$babes[$kid->ID] = array_values(get_object_vars($kids[$kid->ID]));		return $babes;	} else {		return $kids;	}}/** * Get extended entry info (<!--more-->). * * There should not be any space after the second dash and before the word * 'more'. There can be text or space(s) after the word 'more', but won't be * referenced. * * The returned array has 'main' and 'extended' keys. Main has the text before * the <code><!--more--></code>. The 'extended' key has the content after the * <code><!--more--></code> comment. * * @since 1.0.0 * * @param string $post Post content. * @return array Post before ('main') and after ('extended'). */function get_extended($post) {	//Match the new style more links	if ( preg_match('/<!--more(.*?)?-->/', $post, $matches) ) {		list($main, $extended) = explode($matches[0], $post, 2);	} else {		$main = $post;		$extended = '';	}	// Strip leading and trailing whitespace	$main = preg_replace('/^[\s]*(.*)[\s]*$/', '\\1', $main);	$extended = preg_replace('/^[\s]*(.*)[\s]*$/', '\\1', $extended);	return array('main' => $main, 'extended' => $extended);}/** * Retrieves post data given a post ID or post object. * * See {@link sanitize_post()} for optional $filter values. Also, the parameter * $post, must be given as a variable, since it is passed by reference. * * @since 1.5.1 * @uses $wpdb * @link http://codex.wordpress.org/Function_Reference/get_post * * @param int|object $post Post ID or post object. * @param string $output Optional, default is Object. Either OBJECT, ARRAY_A, or ARRAY_N. * @param string $filter Optional, default is raw. * @return mixed Post data */function &get_post(&$post, $output = OBJECT, $filter = 'raw') {	global $wpdb;	$null = null;	if ( empty($post) ) {		if ( isset($GLOBALS['post']) )			$_post = & $GLOBALS['post'];		else			return $null;	} elseif ( is_object($post) && empty($post->filter) ) {		_get_post_ancestors($post);		$_post = sanitize_post($post, 'raw');		wp_cache_add($post->ID, $_post, 'posts');	} else {		if ( is_object($post) )			$post_id = $post->ID;		else			$post_id = $post;		$post_id = (int) $post_id;		if ( ! $_post = wp_cache_get($post_id, 'posts') ) {			$_post = $wpdb->get_row($wpdb->prepare("SELECT * FROM $wpdb->posts WHERE ID = %d LIMIT 1", $post_id));			if ( ! $_post )				return $null;			_get_post_ancestors($_post);			$_post = sanitize_post($_post, 'raw');			wp_cache_add($_post->ID, $_post, 'posts');		}	}	if ($filter != 'raw')		$_post = sanitize_post($_post, $filter);	if ( $output == OBJECT ) {		return $_post;	} elseif ( $output == ARRAY_A ) {		$__post = get_object_vars($_post);		return $__post;	} elseif ( $output == ARRAY_N ) {		$__post = array_values(get_object_vars($_post));		return $__post;	} else {		return $_post;	}}/** * Retrieve ancestors of a post. * * @since 2.5.0 * * @param int|object $post Post ID or post object * @return array Ancestor IDs or empty array if none are found. */function get_post_ancestors($post) {	$post = get_post($post);	if ( !empty($post->ancestors) )		return $post->ancestors;	return array();}/** * Retrieve data from a post field based on Post ID. * * Examples of the post field will be, 'post_type', 'post_status', 'content', * etc and based off of the post object property or key names. * * The context values are based off of the taxonomy filter functions and * supported values are found within those functions. * * @since 2.3.0 * @uses sanitize_post_field() See for possible $context values. * * @param string $field Post field name * @param id $post Post ID * @param string $context Optional. How to filter the field. Default is display. * @return WP_Error|string Value in post field or WP_Error on failure */function get_post_field( $field, $post, $context = 'display' ) {	$post = (int) $post;	$post = get_post( $post );	if ( is_wp_error($post) )		return $post;	if ( !is_object($post) )		return '';	if ( !isset($post->$field) )		return '';	return sanitize_post_field($field, $post->$field, $post->ID, $context);}/** * Retrieve the mime type of an attachment based on the ID. * * This function can be used with any post type, but it makes more sense with * attachments. * * @since 2.0.0 * * @param int $ID Optional. Post ID. * @return bool|string False on failure or returns the mime type */function get_post_mime_type($ID = '') {	$post = & get_post($ID);	if ( is_object($post) )		return $post->post_mime_type;	return false;}/** * Retrieve the post status based on the Post ID. * * If the post ID is of an attachment, then the parent post status will be given * instead. * * @since 2.0.0 * * @param int $ID Post ID * @return string|bool Post status or false on failure. */function get_post_status($ID = '') {	$post = get_post($ID);	if ( !is_object($post) )		return false;	// Unattached attachments are assumed to be published.	if ( ('attachment' == $post->post_type) && ('inherit' == $post->post_status) && ( 0 == $post->post_parent) )		return 'publish';	if ( ('attachment' == $post->post_type) && $post->post_parent && ($post->ID != $post->post_parent) )		return get_post_status($post->post_parent);	return $post->post_status;}/** * Retrieve all of the WordPress supported post statuses. * * Posts have a limited set of valid status values, this provides the * post_status values and descriptions. * * @since 2.5.0 * * @return array List of post statuses. */function get_post_statuses( ) {	$status = array(		'draft'			=> __('Draft'),		'pending'		=> __('Pending Review'),		'private'		=> __('Private'),		'publish'		=> __('Published')	);	return $status;}/** * Retrieve all of the WordPress support page statuses. * * Pages have a limited set of valid status values, this provides the * post_status values and descriptions. * * @since 2.5.0 * * @return array List of page statuses. */function get_page_statuses( ) {	$status = array(		'draft'			=> __('Draft'),		'private'		=> __('Private'),		'publish'		=> __('Published')	);	return $status;}/** * Register a post type. Do not use before init. * * A simple function for creating or modifying a post status based on the * parameters given. The function will accept an array (second optional * parameter), along with a string for the post status name. * * * Optional $args contents: * * label - A descriptive name for the post status marked for translation. Defaults to $post_status. * public - Whether posts of this status should be shown in the admin UI. Defaults to true. * exclude_from_search - Whether to exclude posts with this post status from search results. Defaults to true. * * @package WordPress * @subpackage Post * @since 3.0.0 * @uses $wp_post_statuses Inserts new post status object into the list * * @param string $post_status Name of the post status. * @param array|string $args See above description. */function register_post_status($post_status, $args = array()) {	global $wp_post_statuses;	if (!is_array($wp_post_statuses))		$wp_post_statuses = array();	// Args prefixed with an underscore are reserved for internal use.	$defaults = array('label' => false, 'label_count' => false, 'exclude_from_search' => null, '_builtin' => false, '_edit_link' => 'post.php?post=%d', 'capability_type' => 'post', 'hierarchical' => false, 'public' => null, 'internal' => null, 'protected' => null, 'private' => null, 'show_in_admin_all' => null, 'publicly_queryable' => null, 'show_in_admin_status_list' => null, 'show_in_admin_all_list' => null, 'single_view_cap' => null);	$args = wp_parse_args($args, $defaults);	$args = (object) $args;	$post_status = sanitize_user($post_status, true);	$args->name = $post_status;	if ( null === $args->public && null === $args->internal && null === $args->protected && null === $args->private )		$args->internal = true;	if ( null === $args->public  )		$args->public = false;	if ( null === $args->private  )		$args->private = false;	if ( null === $args->protected  )		$args->protected = false;	if ( null === $args->internal  )		$args->internal = false;	if ( null === $args->publicly_queryable )		$args->publicly_queryable = $args->public;	if ( null === $args->exclude_from_search )		$args->exclude_from_search = $args->internal;	if ( null === $args->show_in_admin_all_list )		$args->show_in_admin_all_list = !$args->internal;	if ( null === $args->show_in_admin_status_list )			$args->show_in_admin_status_list = !$args->internal;	if ( null === $args->single_view_cap )		$args->single_view_cap = $args->public ? '' : 'edit';	if ( false === $args->label )		$args->label = $post_status;	if ( false === $args->label_count )		$args->label_count = array( $args->label, $args->label );	$wp_post_statuses[$post_status] = $args;	return $args;}/** * Retrieve a post status object by name * * @package WordPress * @subpackage Post * @since 3.0.0 * @uses $wp_post_statuses * @see register_post_status * @see get_post_statuses * * @param string $post_type The name of a registered post status * @return object A post status object */function get_post_status_object( $post_status ) {	global $wp_post_statuses;	if ( empty($wp_post_statuses[$post_status]) )		return null;	return $wp_post_statuses[$post_status];}/** * Get a list of all registered post status objects. * * @package WordPress * @subpackage Post * @since 3.0.0 * @uses $wp_post_statuses * @see register_post_status * @see get_post_status_object * * @param array|string $args An array of key => value arguments to match against the post status objects. * @param string $output The type of output to return, either post status 'names' or 'objects'. 'names' is the default. * @param string $operator The logical operation to perform. 'or' means only one element *  from the array needs to match; 'and' means all elements must match. The default is 'and'. * @return array A list of post type names or objects */function get_post_stati( $args = array(), $output = 'names', $operator = 'and' ) {	global $wp_post_statuses;	$field = ('names' == $output) ? 'name' : false;	return wp_filter_object_list($wp_post_statuses, $args, $operator, $field);}/** * Whether the post type is hierarchical. * * A false return value might also mean that the post type does not exist. * * @since 3.0.0 * @see get_post_type_object * * @param string $post Post type name * @return bool Whether post type is hierarchical. */function is_post_type_hierarchical( $post_type ) {	if ( ! post_type_exists( $post_type ) )		return false;	$post_type = get_post_type_object( $post_type );	return $post_type->hierarchical;}/** * Checks if a post type is registered. * * @since 3.0.0 * @uses get_post_type_object() * * @param string Post type name * @return bool Whether post type is registered. */function post_type_exists( $post_type ) {	return (bool) get_post_type_object( $post_type );}/** * Retrieve the post type of the current post or of a given post. * * @since 2.1.0 * * @uses $post The Loop current post global * * @param mixed $the_post Optional. Post object or post ID. * @return bool|string post type or false on failure. */function get_post_type( $the_post = false ) {	global $post;	if ( false === $the_post )		$the_post = $post;	elseif ( is_numeric($the_post) )		$the_post = get_post($the_post);	if ( is_object($the_post) )		return $the_post->post_type;	return false;}/** * Retrieve a post type object by name * * @package WordPress * @subpackage Post * @since 3.0.0 * @uses $wp_post_types * @see register_post_type * @see get_post_types * * @param string $post_type The name of a registered post type * @return object A post type object */function get_post_type_object( $post_type ) {	global $wp_post_types;	if ( empty($wp_post_types[$post_type]) )		return null;	return $wp_post_types[$post_type];}/** * Get a list of all registered post type objects. * * @package WordPress * @subpackage Post * @since 2.9.0 * @uses $wp_post_types * @see register_post_type * * @param array|string $args An array of key => value arguments to match against the post type objects. * @param string $output The type of output to return, either post type 'names' or 'objects'. 'names' is the default. * @param string $operator The logical operation to perform. 'or' means only one element *  from the array needs to match; 'and' means all elements must match. The default is 'and'. * @return array A list of post type names or objects */function get_post_types( $args = array(), $output = 'names', $operator = 'and' ) {	global $wp_post_types;	$field = ('names' == $output) ? 'name' : false;	return wp_filter_object_list($wp_post_types, $args, $operator, $field);}/** * Register a post type. Do not use before init. * * A simple function for creating or modifying a post type based on the * parameters given. The function will accept an array (second optional * parameter), along with a string for the post type name. * * * Optional $args contents: * * - label - Name of the post type shown in the menu. Usually plural. If not set, labels['name'] will be used. * - description - A short descriptive summary of what the post type is. Defaults to blank. * - public - Whether posts of this type should be shown in the admin UI. Defaults to false. * - exclude_from_search - Whether to exclude posts with this post type from search results. Defaults to true if the type is not public, false if the type is public. * - publicly_queryable - Whether post_type queries can be performed from the front page.  Defaults to whatever public is set as. * - show_ui - Whether to generate a default UI for managing this post type. Defaults to true if the type is public, false if the type is not public. * - menu_position - The position in the menu order the post type should appear. Defaults to the bottom. * - menu_icon - The url to the icon to be used for this menu. Defaults to use the posts icon. * - capability_type - The post type to use for checking read, edit, and delete capabilities. Defaults to "post". * - capabilities - Array of capabilities for this post type. You can see accepted values in {@link get_post_type_capabilities()}. By default the capability_type is used to construct capabilities. * - hierarchical - Whether the post type is hierarchical. Defaults to false. * - supports - An alias for calling add_post_type_support() directly. See add_post_type_support() for Documentation. Defaults to none. * - register_meta_box_cb - Provide a callback function that will be called when setting up the meta boxes for the edit form.  Do remove_meta_box() and add_meta_box() calls in the callback. * - taxonomies - An array of taxonomy identifiers that will be registered for the post type.  Default is no taxonomies. Taxonomies can be registered later with register_taxonomy() or register_taxonomy_for_object_type(). * - labels - An array of labels for this post type. You can see accepted values in {@link get_post_type_labels()}. By default post labels are used for non-hierarchical types and page labels for hierarchical ones. * - permalink_epmask - The default rewrite endpoint bitmasks. * - rewrite - false to prevent rewrite, or array('slug'=>$slug) to customize permastruct; default will use $post_type as slug. * - query_var - false to prevent queries, or string to value of the query var to use for this post type * - can_export - true allows this post type to be exported. * - show_in_nav_menus - true makes this post type available for selection in navigation menus. * - _builtin - true if this post type is a native or "built-in" post_type.  THIS IS FOR INTERNAL USE ONLY! * - _edit_link - URL segement to use for edit link of this post type.  Set to 'post.php?post=%d'.  THIS IS FOR INTERNAL USE ONLY! * * @since 2.9.0 * @uses $wp_post_types Inserts new post type object into the list * * @param string $post_type Name of the post type. * @param array|string $args See above description. * @return object the registered post type object */function register_post_type($post_type, $args = array()) {	global $wp_post_types, $wp_rewrite, $wp;	if ( !is_array($wp_post_types) )		$wp_post_types = array();	// Args prefixed with an underscore are reserved for internal use.	$defaults = array(		'labels' => array(), 'description' => '', 'publicly_queryable' => null, 'exclude_from_search' => null,		'_builtin' => false, '_edit_link' => 'post.php?post=%d', 'capability_type' => 'post', 'capabilities' => array(), 'hierarchical' => false,		'public' => false, 'rewrite' => true, 'query_var' => true, 'supports' => array(), 'register_meta_box_cb' => null,		'taxonomies' => array(), 'show_ui' => null, 'menu_position' => null, 'menu_icon' => null,		'permalink_epmask' => EP_PERMALINK, 'can_export' => true, 'show_in_nav_menus' => null	);	$args = wp_parse_args($args, $defaults);	$args = (object) $args;	$post_type = sanitize_user($post_type, true);	$args->name = $post_type;	// If not set, default to the setting for public.	if ( null === $args->publicly_queryable )		$args->publicly_queryable = $args->public;	// If not set, default to the setting for public.	if ( null === $args->show_ui )		$args->show_ui = $args->public;	// Whether to show this type in nav-menus.php.  Defaults to the setting for public.	if ( null === $args->show_in_nav_menus )		$args->show_in_nav_menus = $args->public;	// If not set, default to true if not public, false if public.	if ( null === $args->exclude_from_search )		$args->exclude_from_search = !$args->public;	if ( empty($args->capability_type) )		$args->capability_type = 'post';	$args->cap = get_post_type_capabilities( $args );	unset($args->capabilities);	if ( ! empty($args->supports) ) {		add_post_type_support($post_type, $args->supports);		unset($args->supports);	} else {		// Add default features		add_post_type_support($post_type, array('title', 'editor'));	}	if ( false !== $args->query_var && !empty($wp) ) {		if ( true === $args->query_var )			$args->query_var = $post_type;		$args->query_var = sanitize_title_with_dashes($args->query_var);		$wp->add_query_var($args->query_var);	}	if ( false !== $args->rewrite && '' != get_option('permalink_structure') ) {		if ( !is_array($args->rewrite) )			$args->rewrite = array();		if ( !isset($args->rewrite['slug']) )			$args->rewrite['slug'] = $post_type;		if ( !isset($args->rewrite['with_front']) )			$args->rewrite['with_front'] = true;		if ( $args->hierarchical )			$wp_rewrite->add_rewrite_tag("%$post_type%", '(.+?)', $args->query_var ? "{$args->query_var}=" : "post_type=$post_type&name=");		else			$wp_rewrite->add_rewrite_tag("%$post_type%", '([^/]+)', $args->query_var ? "{$args->query_var}=" : "post_type=$post_type&name=");		$wp_rewrite->add_permastruct($post_type, "{$args->rewrite['slug']}/%$post_type%", $args->rewrite['with_front'], $args->permalink_epmask);	}	if ( $args->register_meta_box_cb )		add_action('add_meta_boxes_' . $post_type, $args->register_meta_box_cb, 10, 1);	$args->labels = get_post_type_labels( $args );	$args->label = $args->labels->name;	$wp_post_types[$post_type] = $args;	add_action( 'future_' . $post_type, '_future_post_hook', 5, 2 );	foreach ( $args->taxonomies as $taxonomy ) {		register_taxonomy_for_object_type( $taxonomy, $post_type );	}	return $args;}/** * Builds an object with all post type capabilities out of a post type object * * Accepted keys of the capabilities array in the post type object: * - edit_post - The meta capability that controls editing a particular object of this post type. Defaults to "edit_ . $capability_type" (edit_post). * - edit_posts - The capability that controls editing objects of this post type as a class. Defaults to "edit_ . $capability_type . s" (edit_posts). * - edit_others_posts - The capability that controls editing objects of this post type that are owned by other users. Defaults to "edit_others_ . $capability_type . s" (edit_others_posts). * - publish_posts - The capability that controls publishing objects of this post type. Defaults to "publish_ . $capability_type . s" (publish_posts). * - read_post - The meta capability that controls reading a particular object of this post type. Defaults to "read_ . $capability_type" (read_post). * - read_private_posts - The capability that controls reading private posts. Defaults to "read_private . $capability_type . s" (read_private_posts). * - delete_post - The meta capability that controls deleting a particular object of this post type. Defaults to "delete_ . $capability_type" (delete_post). * * @since 3.0.0 * @param object $args * @return object object with all the capabilities as member variables */function get_post_type_capabilities( $args ) {	$defaults = array(		'edit_post'          => 'edit_'         . $args->capability_type,		'edit_posts'         => 'edit_'         . $args->capability_type . 's',		'edit_others_posts'  => 'edit_others_'  . $args->capability_type . 's',		'publish_posts'      => 'publish_'      . $args->capability_type . 's',		'read_post'          => 'read_'         . $args->capability_type,		'read_private_posts' => 'read_private_' . $args->capability_type . 's',		'delete_post'        => 'delete_'       . $args->capability_type,	);	$labels = array_merge( $defaults, $args->capabilities );	return (object) $labels;}/** * Builds an object with all post type labels out of a post type object * * Accepted keys of the label array in the post type object: * - name - general name for the post type, usually plural. The same and overriden by $post_type_object->label. Default is Posts/Pages * - singular_name - name for one object of this post type. Default is Post/Page * - add_new - Default is Add New for both hierarchical and non-hierarchical types. When internationalizing this string, please use a {@link http://codex.wordpress.org/I18n_for_WordPress_Developers#Disambiguation_by_context gettext context} matching your post type. Example: <code>_x('Add New', 'product');</code> * - add_new_item - Default is Add New Post/Add New Page * - edit_item - Default is Edit Post/Edit Page * - new_item - Default is New Post/New Page * - view_item - Default is View Post/View Page * - search_items - Default is Search Posts/Search Pages * - not_found - Default is No posts found/No pages found * - not_found_in_trash - Default is No posts found in Trash/No pages found in Trash * - parent_item_colon - This string isn't used on non-hierarchical types. In hierarchical ones the default is Parent Page: * * Above, the first default value is for non-hierarchical post types (like posts) and the second one is for hierarchical post types (like pages.) * * @since 3.0.0 * @param object $post_type_object * @return object object with all the labels as member variables */function get_post_type_labels( $post_type_object ) {	$nohier_vs_hier_defaults = array(		'name' => array( _x('Posts', 'post type general name'), _x('Pages', 'post type general name') ),		'singular_name' => array( _x('Post', 'post type singular name'), _x('Page', 'post type singular name') ),		'add_new' => array( _x('Add New', 'post'), _x('Add New', 'page') ),		'add_new_item' => array( __('Add New Post'), __('Add New Page') ),		'edit_item' => array( __('Edit Post'), __('Edit Page') ),		'new_item' => array( __('New Post'), __('New Page') ),		'view_item' => array( __('View Post'), __('View Page') ),		'search_items' => array( __('Search Posts'), __('Search Pages') ),		'not_found' => array( __('No posts found'), __('No pages found') ),		'not_found_in_trash' => array( __('No posts found in Trash'), __('No pages found in Trash') ),		'parent_item_colon' => array( null, __('Parent Page:') )	);	return _get_custom_object_labels( $post_type_object, $nohier_vs_hier_defaults );}/** * Builds an object with custom-something object (post type, taxonomy) labels out of a custom-something object * * @access private */function _get_custom_object_labels( $object, $nohier_vs_hier_defaults ) {	if ( isset( $object->label ) && empty( $object->labels['name'] ) )		$object->labels['name'] = $object->label;	if ( !isset( $object->labels['singular_name'] ) && isset( $object->labels['name'] ) )		$object->labels['singular_name'] = $object->labels['name'];	$defaults = array_map( create_function( '$x', $object->hierarchical? 'return $x[1];' : 'return $x[0];' ), $nohier_vs_hier_defaults );	$labels = array_merge( $defaults, $object->labels );	return (object)$labels;}/** * Register support of certain features for a post type. * * All features are directly associated with a functional area of the edit screen, such as the * editor or a meta box: 'title', 'editor', 'comments', 'revisions', 'trackbacks', 'author', * 'excerpt', 'page-attributes', 'thumbnail', and 'custom-fields'. * * Additionally, the 'revisions' feature dictates whether the post type will store revisions, * and the 'comments' feature dicates whether the comments count will show on the edit screen. * * @since 3.0.0 * @param string $post_type The post type for which to add the feature * @param string|array $feature the feature being added, can be an array of feature strings or a single string */function add_post_type_support( $post_type, $feature ) {	global $_wp_post_type_features;	$features = (array) $feature;	foreach ($features as $feature) {		if ( func_num_args() == 2 )			$_wp_post_type_features[$post_type][$feature] = true;		else			$_wp_post_type_features[$post_type][$feature] = array_slice( func_get_args(), 2 );	}}/** * Remove support for a feature from a post type. * * @since 3.0.0 * @param string $post_type The post type for which to remove the feature * @param string $feature The feature being removed */function remove_post_type_support( $post_type, $feature ) {	global $_wp_post_type_features;	if ( !isset($_wp_post_type_features[$post_type]) )		return;	if ( isset($_wp_post_type_features[$post_type][$feature]) )		unset($_wp_post_type_features[$post_type][$feature]);}/** * Checks a post type's support for a given feature * * @since 3.0.0 * @param string $post_type The post type being checked * @param string $feature the feature being checked * @return boolean */function post_type_supports( $post_type, $feature ) {	global $_wp_post_type_features;	if ( !isset( $_wp_post_type_features[$post_type][$feature] ) )		return false;	// If no args passed then no extra checks need be performed	if ( func_num_args() <= 2 )		return true;	// @todo Allow pluggable arg checking	//$args = array_slice( func_get_args(), 2 );	return true;}/** * Updates the post type for the post ID. * * The page or post cache will be cleaned for the post ID. * * @since 2.5.0 * * @uses $wpdb * * @param int $post_id Post ID to change post type. Not actually optional. * @param string $post_type Optional, default is post. Supported values are 'post' or 'page' to *  name a few. * @return int Amount of rows changed. Should be 1 for success and 0 for failure. */function set_post_type( $post_id = 0, $post_type = 'post' ) {	global $wpdb;	$post_type = sanitize_post_field('post_type', $post_type, $post_id, 'db');	$return = $wpdb->update($wpdb->posts, array('post_type' => $post_type), array('ID' => $post_id) );	if ( 'page' == $post_type )		clean_page_cache($post_id);	else		clean_post_cache($post_id);	return $return;}/** * Retrieve list of latest posts or posts matching criteria. * * The defaults are as follows: *     'numberposts' - Default is 5. Total number of posts to retrieve. *     'offset' - Default is 0. See {@link WP_Query::query()} for more. *     'category' - What category to pull the posts from. *     'orderby' - Default is 'post_date'. How to order the posts. *     'order' - Default is 'DESC'. The order to retrieve the posts. *     'include' - See {@link WP_Query::query()} for more. *     'exclude' - See {@link WP_Query::query()} for more. *     'meta_key' - See {@link WP_Query::query()} for more. *     'meta_value' - See {@link WP_Query::query()} for more. *     'post_type' - Default is 'post'. Can be 'page', or 'attachment' to name a few. *     'post_parent' - The parent of the post or post type. *     'post_status' - Default is 'published'. Post status to retrieve. * * @since 1.2.0 * @uses $wpdb * @uses WP_Query::query() See for more default arguments and information. * @link http://codex.wordpress.org/Template_Tags/get_posts * * @param array $args Optional. Overrides defaults. * @return array List of posts. */function get_posts($args = null) {	$defaults = array(		'numberposts' => 5, 'offset' => 0,		'category' => 0, 'orderby' => 'post_date',		'order' => 'DESC', 'include' => array(),		'exclude' => array(), 'meta_key' => '',		'meta_value' =>'', 'post_type' => 'post',		'suppress_filters' => true	);	$r = wp_parse_args( $args, $defaults );	if ( empty( $r['post_status'] ) )		$r['post_status'] = ( 'attachment' == $r['post_type'] ) ? 'inherit' : 'publish';	if ( ! empty($r['numberposts']) )		$r['posts_per_page'] = $r['numberposts'];	if ( ! empty($r['category']) )		$r['cat'] = $r['category'];	if ( ! empty($r['include']) ) {		$incposts = wp_parse_id_list( $r['include'] );		$r['posts_per_page'] = count($incposts);  // only the number of posts included		$r['post__in'] = $incposts;	} elseif ( ! empty($r['exclude']) )		$r['post__not_in'] = wp_parse_id_list( $r['exclude'] );	$r['caller_get_posts'] = true;	$get_posts = new WP_Query;	return $get_posts->query($r);}//// Post meta functions///** * Add meta data field to a post. * * Post meta data is called "Custom Fields" on the Administration Panels. * * @since 1.5.0 * @uses $wpdb * @link http://codex.wordpress.org/Function_Reference/add_post_meta * * @param int $post_id Post ID. * @param string $key Metadata name. * @param mixed $value Metadata value. * @param bool $unique Optional, default is false. Whether the same key should not be added. * @return bool False for failure. True for success. */function add_post_meta($post_id, $meta_key, $meta_value, $unique = false) {	// make sure meta is added to the post, not a revision	if ( $the_post = wp_is_post_revision($post_id) )		$post_id = $the_post;	return add_metadata('post', $post_id, $meta_key, $meta_value, $unique);}/** * Remove metadata matching criteria from a post. * * You can match based on the key, or key and value. Removing based on key and * value, will keep from removing duplicate metadata with the same key. It also * allows removing all metadata matching key, if needed. * * @since 1.5.0 * @uses $wpdb * @link http://codex.wordpress.org/Function_Reference/delete_post_meta * * @param int $post_id post ID * @param string $meta_key Metadata name. * @param mixed $meta_value Optional. Metadata value. * @return bool False for failure. True for success. */function delete_post_meta($post_id, $meta_key, $meta_value = '') {	// make sure meta is added to the post, not a revision	if ( $the_post = wp_is_post_revision($post_id) )		$post_id = $the_post;	return delete_metadata('post', $post_id, $meta_key, $meta_value);}/** * Retrieve post meta field for a post. * * @since 1.5.0 * @uses $wpdb * @link http://codex.wordpress.org/Function_Reference/get_post_meta * * @param int $post_id Post ID. * @param string $key The meta key to retrieve. * @param bool $single Whether to return a single value. * @return mixed Will be an array if $single is false. Will be value of meta data field if $single *  is true. */function get_post_meta($post_id, $key, $single = false) {	return get_metadata('post', $post_id, $key, $single);}/** * Update post meta field based on post ID. * * Use the $prev_value parameter to differentiate between meta fields with the * same key and post ID. * * If the meta field for the post does not exist, it will be added. * * @since 1.5 * @uses $wpdb * @link http://codex.wordpress.org/Function_Reference/update_post_meta * * @param int $post_id Post ID. * @param string $key Metadata key. * @param mixed $value Metadata value. * @param mixed $prev_value Optional. Previous value to check before removing. * @return bool False on failure, true if success. */function update_post_meta($post_id, $meta_key, $meta_value, $prev_value = '') {	// make sure meta is added to the post, not a revision	if ( $the_post = wp_is_post_revision($post_id) )		$post_id = $the_post;	return update_metadata('post', $post_id, $meta_key, $meta_value, $prev_value);}/** * Delete everything from post meta matching meta key. * * @since 2.3.0 * @uses $wpdb * * @param string $post_meta_key Key to search for when deleting. * @return bool Whether the post meta key was deleted from the database */function delete_post_meta_by_key($post_meta_key) {	if ( !$post_meta_key )		return false;	global $wpdb;	$post_ids = $wpdb->get_col($wpdb->prepare("SELECT DISTINCT post_id FROM $wpdb->postmeta WHERE meta_key = %s", $post_meta_key));	if ( $post_ids ) {		$postmetaids = $wpdb->get_col( $wpdb->prepare( "SELECT meta_id FROM $wpdb->postmeta WHERE meta_key = %s", $post_meta_key ) );		$in = implode( ',', array_fill(1, count($postmetaids), '%d'));		do_action( 'delete_postmeta', $postmetaids );		$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->postmeta WHERE meta_id IN($in)", $postmetaids ));		do_action( 'deleted_postmeta', $postmetaids );		foreach ( $post_ids as $post_id )			wp_cache_delete($post_id, 'post_meta');		return true;	}	return false;}/** * Retrieve post meta fields, based on post ID. * * The post meta fields are retrieved from the cache, so the function is * optimized to be called more than once. It also applies to the functions, that * use this function. * * @since 1.2.0 * @link http://codex.wordpress.org/Function_Reference/get_post_custom * * @uses $id Current Loop Post ID * * @param int $post_id post ID * @return array */function get_post_custom($post_id = 0) {	global $id;	if ( !$post_id )		$post_id = (int) $id;	$post_id = (int) $post_id;	if ( ! wp_cache_get($post_id, 'post_meta') )		update_postmeta_cache($post_id);	return wp_cache_get($post_id, 'post_meta');}/** * Retrieve meta field names for a post. * * If there are no meta fields, then nothing (null) will be returned. * * @since 1.2.0 * @link http://codex.wordpress.org/Function_Reference/get_post_custom_keys * * @param int $post_id post ID * @return array|null Either array of the keys, or null if keys could not be retrieved. */function get_post_custom_keys( $post_id = 0 ) {	$custom = get_post_custom( $post_id );	if ( !is_array($custom) )		return;	if ( $keys = array_keys($custom) )		return $keys;}/** * Retrieve values for a custom post field. * * The parameters must not be considered optional. All of the post meta fields * will be retrieved and only the meta field key values returned. * * @since 1.2.0 * @link http://codex.wordpress.org/Function_Reference/get_post_custom_values * * @param string $key Meta field key. * @param int $post_id Post ID * @return array Meta field values. */function get_post_custom_values( $key = '', $post_id = 0 ) {	if ( !$key )		return null;	$custom = get_post_custom($post_id);	return isset($custom[$key]) ? $custom[$key] : null;}/** * Check if post is sticky. * * Sticky posts should remain at the top of The Loop. If the post ID is not * given, then The Loop ID for the current post will be used. * * @since 2.7.0 * * @param int $post_id Optional. Post ID. * @return bool Whether post is sticky. */function is_sticky($post_id = null) {	global $id;	$post_id = absint($post_id);	if ( !$post_id )		$post_id = absint($id);	$stickies = get_option('sticky_posts');	if ( !is_array($stickies) )		return false;	if ( in_array($post_id, $stickies) )		return true;	return false;}/** * Sanitize every post field. * * If the context is 'raw', then the post object or array will get minimal santization of the int fields. * * @since 2.3.0 * @uses sanitize_post_field() Used to sanitize the fields. * * @param object|array $post The Post Object or Array * @param string $context Optional, default is 'display'. How to sanitize post fields. * @return object|array The now sanitized Post Object or Array (will be the same type as $post) */function sanitize_post($post, $context = 'display') {	if ( is_object($post) ) {		// Check if post already filtered for this context		if ( isset($post->filter) && $context == $post->filter )			return $post;		if ( !isset($post->ID) )			$post->ID = 0;		foreach ( array_keys(get_object_vars($post)) as $field )			$post->$field = sanitize_post_field($field, $post->$field, $post->ID, $context);		$post->filter = $context;	} else {		// Check if post already filtered for this context		if ( isset($post['filter']) && $context == $post['filter'] )			return $post;		if ( !isset($post['ID']) )			$post['ID'] = 0;		foreach ( array_keys($post) as $field )			$post[$field] = sanitize_post_field($field, $post[$field], $post['ID'], $context);		$post['filter'] = $context;	}	return $post;}/** * Sanitize post field based on context. * * Possible context values are:  'raw', 'edit', 'db', 'display', 'attribute' and 'js'. The * 'display' context is used by default. 'attribute' and 'js' contexts are treated like 'display' * when calling filters. * * @since 2.3.0 * @uses apply_filters() Calls 'edit_$field' and '${field_no_prefix}_edit_pre' passing $value and *  $post_id if $context == 'edit' and field name prefix == 'post_'. * * @uses apply_filters() Calls 'edit_post_$field' passing $value and $post_id if $context == 'db'. * @uses apply_filters() Calls 'pre_$field' passing $value if $context == 'db' and field name prefix == 'post_'. * @uses apply_filters() Calls '${field}_pre' passing $value if $context == 'db' and field name prefix != 'post_'. * * @uses apply_filters() Calls '$field' passing $value, $post_id and $context if $context == anything *  other than 'raw', 'edit' and 'db' and field name prefix == 'post_'. * @uses apply_filters() Calls 'post_$field' passing $value if $context == anything other than 'raw', *  'edit' and 'db' and field name prefix != 'post_'. * * @param string $field The Post Object field name. * @param mixed $value The Post Object value. * @param int $post_id Post ID. * @param string $context How to sanitize post fields. Looks for 'raw', 'edit', 'db', 'display', *               'attribute' and 'js'. * @return mixed Sanitized value. */function sanitize_post_field($field, $value, $post_id, $context) {	$int_fields = array('ID', 'post_parent', 'menu_order');	if ( in_array($field, $int_fields) )		$value = (int) $value;	// Fields which contain arrays of ints.	$array_int_fields = array( 'ancestors' );	if ( in_array($field, $array_int_fields) ) {		$value = array_map( 'absint', $value);		return $value;	}	if ( 'raw' == $context )		return $value;	$prefixed = false;	if ( false !== strpos($field, 'post_') ) {		$prefixed = true;		$field_no_prefix = str_replace('post_', '', $field);	}	if ( 'edit' == $context ) {		$format_to_edit = array('post_content', 'post_excerpt', 'post_title', 'post_password');		if ( $prefixed ) {			$value = apply_filters("edit_$field", $value, $post_id);			// Old school			$value = apply_filters("${field_no_prefix}_edit_pre", $value, $post_id);		} else {			$value = apply_filters("edit_post_$field", $value, $post_id);		}		if ( in_array($field, $format_to_edit) ) {			if ( 'post_content' == $field )				$value = format_to_edit($value, user_can_richedit());			else				$value = format_to_edit($value);		} else {			$value = esc_attr($value);		}	} else if ( 'db' == $context ) {		if ( $prefixed ) {			$value = apply_filters("pre_$field", $value);			$value = apply_filters("${field_no_prefix}_save_pre", $value);		} else {			$value = apply_filters("pre_post_$field", $value);			$value = apply_filters("${field}_pre", $value);		}	} else {		// Use display filters by default.		if ( $prefixed )			$value = apply_filters($field, $value, $post_id, $context);		else			$value = apply_filters("post_$field", $value, $post_id, $context);	}	if ( 'attribute' == $context )		$value = esc_attr($value);	else if ( 'js' == $context )		$value = esc_js($value);	return $value;}/** * Make a post sticky. * * Sticky posts should be displayed at the top of the front page. * * @since 2.7.0 * * @param int $post_id Post ID. */function stick_post($post_id) {	$stickies = get_option('sticky_posts');	if ( !is_array($stickies) )		$stickies = array($post_id);	if ( ! in_array($post_id, $stickies) )		$stickies[] = $post_id;	update_option('sticky_posts', $stickies);}/** * Unstick a post. * * Sticky posts should be displayed at the top of the front page. * * @since 2.7.0 * * @param int $post_id Post ID. */function unstick_post($post_id) {	$stickies = get_option('sticky_posts');	if ( !is_array($stickies) )		return;	if ( ! in_array($post_id, $stickies) )		return;	$offset = array_search($post_id, $stickies);	if ( false === $offset )		return;	array_splice($stickies, $offset, 1);	update_option('sticky_posts', $stickies);}/** * Count number of posts of a post type and is user has permissions to view. * * This function provides an efficient method of finding the amount of post's * type a blog has. Another method is to count the amount of items in * get_posts(), but that method has a lot of overhead with doing so. Therefore, * when developing for 2.5+, use this function instead. * * The $perm parameter checks for 'readable' value and if the user can read * private posts, it will display that for the user that is signed in. * * @since 2.5.0 * @link http://codex.wordpress.org/Template_Tags/wp_count_posts * * @param string $type Optional. Post type to retrieve count * @param string $perm Optional. 'readable' or empty. * @return object Number of posts for each status */function wp_count_posts( $type = 'post', $perm = '' ) {	global $wpdb;	$user = wp_get_current_user();	$cache_key = $type;	$query = "SELECT post_status, COUNT( * ) AS num_posts FROM {$wpdb->posts} WHERE post_type = %s";	if ( 'readable' == $perm && is_user_logged_in() ) {		$post_type_object = get_post_type_object($type);		if ( !current_user_can( $post_type_object->cap->read_private_posts ) ) {			$cache_key .= '_' . $perm . '_' . $user->ID;			$query .= " AND (post_status != 'private' OR ( post_author = '$user->ID' AND post_status = 'private' ))";		}	}	$query .= ' GROUP BY post_status';	$count = wp_cache_get($cache_key, 'counts');	if ( false !== $count )		return $count;	$count = $wpdb->get_results( $wpdb->prepare( $query, $type ), ARRAY_A );	$stats = array();	foreach ( get_post_stati() as $state )		$stats[$state] = 0;	foreach ( (array) $count as $row )		$stats[$row['post_status']] = $row['num_posts'];	$stats = (object) $stats;	wp_cache_set($cache_key, $stats, 'counts');	return $stats;}/** * Count number of attachments for the mime type(s). * * If you set the optional mime_type parameter, then an array will still be * returned, but will only have the item you are looking for. It does not give * you the number of attachments that are children of a post. You can get that * by counting the number of children that post has. * * @since 2.5.0 * * @param string|array $mime_type Optional. Array or comma-separated list of MIME patterns. * @return array Number of posts for each mime type. */function wp_count_attachments( $mime_type = '' ) {	global $wpdb;	$and = wp_post_mime_type_where( $mime_type );	$count = $wpdb->get_results( "SELECT post_mime_type, COUNT( * ) AS num_posts FROM $wpdb->posts WHERE post_type = 'attachment' AND post_status != 'trash' $and GROUP BY post_mime_type", ARRAY_A );	$stats = array( );	foreach( (array) $count as $row ) {		$stats[$row['post_mime_type']] = $row['num_posts'];	}	$stats['trash'] = $wpdb->get_var( "SELECT COUNT( * ) FROM $wpdb->posts WHERE post_type = 'attachment' AND post_status = 'trash' $and");	return (object) $stats;}/** * Check a MIME-Type against a list. * * If the wildcard_mime_types parameter is a string, it must be comma separated * list. If the real_mime_types is a string, it is also comma separated to * create the list. * * @since 2.5.0 * * @param string|array $wildcard_mime_types e.g. audio/mpeg or image (same as image/*) or *  flash (same as *flash*). * @param string|array $real_mime_types post_mime_type values * @return array array(wildcard=>array(real types)) */function wp_match_mime_types($wildcard_mime_types, $real_mime_types) {	$matches = array();	if ( is_string($wildcard_mime_types) )		$wildcard_mime_types = array_map('trim', explode(',', $wildcard_mime_types));	if ( is_string($real_mime_types) )		$real_mime_types = array_map('trim', explode(',', $real_mime_types));	$wild = '[-._a-z0-9]*';	foreach ( (array) $wildcard_mime_types as $type ) {		$type = str_replace('*', $wild, $type);		$patternses[1][$type] = "^$type$";		if ( false === strpos($type, '/') ) {			$patternses[2][$type] = "^$type/";			$patternses[3][$type] = $type;		}	}	asort($patternses);	foreach ( $patternses as $patterns )		foreach ( $patterns as $type => $pattern )			foreach ( (array) $real_mime_types as $real )				if ( preg_match("#$pattern#", $real) && ( empty($matches[$type]) || false === array_search($real, $matches[$type]) ) )					$matches[$type][] = $real;	return $matches;}/** * Convert MIME types into SQL. * * @since 2.5.0 * * @param string|array $mime_types List of mime types or comma separated string of mime types. * @param string $table_alias Optional. Specify a table alias, if needed. * @return string The SQL AND clause for mime searching. */function wp_post_mime_type_where($post_mime_types, $table_alias = '') {	$where = '';	$wildcards = array('', '%', '%/%');	if ( is_string($post_mime_types) )		$post_mime_types = array_map('trim', explode(',', $post_mime_types));	foreach ( (array) $post_mime_types as $mime_type ) {		$mime_type = preg_replace('/\s/', '', $mime_type);		$slashpos = strpos($mime_type, '/');		if ( false !== $slashpos ) {			$mime_group = preg_replace('/[^-*.a-zA-Z0-9]/', '', substr($mime_type, 0, $slashpos));			$mime_subgroup = preg_replace('/[^-*.+a-zA-Z0-9]/', '', substr($mime_type, $slashpos + 1));			if ( empty($mime_subgroup) )				$mime_subgroup = '*';			else				$mime_subgroup = str_replace('/', '', $mime_subgroup);			$mime_pattern = "$mime_group/$mime_subgroup";		} else {			$mime_pattern = preg_replace('/[^-*.a-zA-Z0-9]/', '', $mime_type);			if ( false === strpos($mime_pattern, '*') )				$mime_pattern .= '/*';		}		$mime_pattern = preg_replace('/\*+/', '%', $mime_pattern);		if ( in_array( $mime_type, $wildcards ) )			return '';		if ( false !== strpos($mime_pattern, '%') )			$wheres[] = empty($table_alias) ? "post_mime_type LIKE '$mime_pattern'" : "$table_alias.post_mime_type LIKE '$mime_pattern'";		else			$wheres[] = empty($table_alias) ? "post_mime_type = '$mime_pattern'" : "$table_alias.post_mime_type = '$mime_pattern'";	}	if ( !empty($wheres) )		$where = ' AND (' . join(' OR ', $wheres) . ') ';	return $where;}/** * Trashes or deletes a post or page. * * When the post and page is permanently deleted, everything that is tied to it is deleted also. * This includes comments, post meta fields, and terms associated with the post. * * The post or page is moved to trash instead of permanently deleted unless trash is * disabled, item is already in the trash, or $force_delete is true. * * @since 1.0.0 * @uses do_action() on 'delete_post' before deletion unless post type is 'attachment'. * @uses do_action() on 'deleted_post' after deletion unless post type is 'attachment'. * @uses wp_delete_attachment() if post type is 'attachment'. * @uses wp_trash_post() if item should be trashed. * * @param int $postid Post ID. * @param bool $force_delete Whether to bypass trash and force deletion. Defaults to false. * @return mixed False on failure */function wp_delete_post( $postid = 0, $force_delete = false ) {	global $wpdb, $wp_rewrite;	if ( !$post = $wpdb->get_row($wpdb->prepare("SELECT * FROM $wpdb->posts WHERE ID = %d", $postid)) )		return $post;	if ( !$force_delete && ( $post->post_type == 'post' || $post->post_type == 'page') && get_post_status( $postid ) != 'trash' && EMPTY_TRASH_DAYS )			return wp_trash_post($postid);	if ( $post->post_type == 'attachment' )		return wp_delete_attachment( $postid, $force_delete );	do_action('delete_post', $postid);	delete_post_meta($postid,'_wp_trash_meta_status');	delete_post_meta($postid,'_wp_trash_meta_time');	wp_delete_object_term_relationships($postid, get_object_taxonomies($post->post_type));	$parent_data = array( 'post_parent' => $post->post_parent );	$parent_where = array( 'post_parent' => $postid );	if ( 'page' == $post->post_type) {	 	// if the page is defined in option page_on_front or post_for_posts,		// adjust the corresponding options		if ( get_option('page_on_front') == $postid ) {			update_option('show_on_front', 'posts');			delete_option('page_on_front');		}		if ( get_option('page_for_posts') == $postid ) {			delete_option('page_for_posts');		}		// Point children of this page to its parent, also clean the cache of affected children		$children_query = $wpdb->prepare("SELECT * FROM $wpdb->posts WHERE post_parent = %d AND post_type='page'", $postid);		$children = $wpdb->get_results($children_query);		$wpdb->update( $wpdb->posts, $parent_data, $parent_where + array( 'post_type' => 'page' ) );	} else {		unstick_post($postid);	}	// Do raw query.  wp_get_post_revisions() is filtered	$revision_ids = $wpdb->get_col( $wpdb->prepare( "SELECT ID FROM $wpdb->posts WHERE post_parent = %d AND post_type = 'revision'", $postid ) );	// Use wp_delete_post (via wp_delete_post_revision) again.  Ensures any meta/misplaced data gets cleaned up.	foreach ( $revision_ids as $revision_id )		wp_delete_post_revision( $revision_id );	// Point all attachments to this post up one level	$wpdb->update( $wpdb->posts, $parent_data, $parent_where + array( 'post_type' => 'attachment' ) );	$comment_ids = $wpdb->get_col( $wpdb->prepare( "SELECT comment_ID FROM $wpdb->comments WHERE comment_post_ID = %d", $postid ));	if ( ! empty($comment_ids) ) {		do_action( 'delete_comment', $comment_ids );		foreach ( $comment_ids as $comment_id )			wp_delete_comment( $comment_id, true );		do_action( 'deleted_comment', $comment_ids );	}	$post_meta_ids = $wpdb->get_col( $wpdb->prepare( "SELECT meta_id FROM $wpdb->postmeta WHERE post_id = %d ", $postid ));	if ( !empty($post_meta_ids) ) {		do_action( 'delete_postmeta', $post_meta_ids );		$in_post_meta_ids = "'" . implode("', '", $post_meta_ids) . "'";		$wpdb->query( "DELETE FROM $wpdb->postmeta WHERE meta_id IN($in_post_meta_ids)" );		do_action( 'deleted_postmeta', $post_meta_ids );	}	do_action( 'delete_post', $postid );	$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->posts WHERE ID = %d", $postid ));	do_action( 'deleted_post', $postid );	if ( 'page' == $post->post_type ) {		clean_page_cache($postid);		foreach ( (array) $children as $child )			clean_page_cache($child->ID);		$wp_rewrite->flush_rules(false);	} else {		clean_post_cache($postid);	}	wp_clear_scheduled_hook('publish_future_post', array( $postid ) );	do_action('deleted_post', $postid);	return $post;}/** * Moves a post or page to the Trash * * If trash is disabled, the post or page is permanently deleted. * * @since 2.9.0 * @uses do_action() on 'trash_post' before trashing * @uses do_action() on 'trashed_post' after trashing * @uses wp_delete_post() if trash is disabled * * @param int $postid Post ID. * @return mixed False on failure */function wp_trash_post($post_id = 0) {	if ( !EMPTY_TRASH_DAYS )		return wp_delete_post($post_id, true);	if ( !$post = wp_get_single_post($post_id, ARRAY_A) )		return $post;	if ( $post['post_status'] == 'trash' )		return false;	do_action('trash_post', $post_id);	add_post_meta($post_id,'_wp_trash_meta_status', $post['post_status']);	add_post_meta($post_id,'_wp_trash_meta_time', time());	$post['post_status'] = 'trash';	wp_insert_post($post);	wp_trash_post_comments($post_id);	do_action('trashed_post', $post_id);	return $post;}/** * Restores a post or page from the Trash * * @since 2.9.0 * @uses do_action() on 'untrash_post' before undeletion * @uses do_action() on 'untrashed_post' after undeletion * * @param int $postid Post ID. * @return mixed False on failure */function wp_untrash_post($post_id = 0) {	if ( !$post = wp_get_single_post($post_id, ARRAY_A) )		return $post;	if ( $post['post_status'] != 'trash' )		return false;	do_action('untrash_post', $post_id);	$post_status = get_post_meta($post_id, '_wp_trash_meta_status', true);	$post['post_status'] = $post_status;	delete_post_meta($post_id, '_wp_trash_meta_status');	delete_post_meta($post_id, '_wp_trash_meta_time');	wp_insert_post($post);	wp_untrash_post_comments($post_id);	do_action('untrashed_post', $post_id);	return $post;}/** * Moves comments for a post to the trash * * @since 2.9.0 * @uses do_action() on 'trash_post_comments' before trashing * @uses do_action() on 'trashed_post_comments' after trashing * * @param int $post Post ID or object. * @return mixed False on failure */function wp_trash_post_comments($post = null) {	global $wpdb;	$post = get_post($post);	if ( empty($post) )		return;	$post_id = $post->ID;	do_action('trash_post_comments', $post_id);	$comments = $wpdb->get_results( $wpdb->prepare("SELECT comment_ID, comment_approved FROM $wpdb->comments WHERE comment_post_ID = %d", $post_id) );	if ( empty($comments) )		return;	// Cache current status for each comment	$statuses = array();	foreach ( $comments as $comment )		$statuses[$comment->comment_ID] = $comment->comment_approved;	add_post_meta($post_id, '_wp_trash_meta_comments_status', $statuses);	// Set status for all comments to post-trashed	$result = $wpdb->update($wpdb->comments, array('comment_approved' => 'post-trashed'), array('comment_post_ID' => $post_id));	clean_comment_cache( array_keys($statuses) );	do_action('trashed_post_comments', $post_id, $statuses);	return $result;}/** * Restore comments for a post from the trash * * @since 2.9.0 * @uses do_action() on 'untrash_post_comments' before trashing * @uses do_action() on 'untrashed_post_comments' after trashing * * @param int $post Post ID or object. * @return mixed False on failure */function wp_untrash_post_comments($post = null) {	global $wpdb;	$post = get_post($post);	if ( empty($post) )		return;	$post_id = $post->ID;	$statuses = get_post_meta($post_id, '_wp_trash_meta_comments_status', true);	if ( empty($statuses) )		return true;	do_action('untrash_post_comments', $post_id);	// Restore each comment to its original status	$group_by_status = array();	foreach ( $statuses as $comment_id => $comment_status )		$group_by_status[$comment_status][] = $comment_id;	foreach ( $group_by_status as $status => $comments ) {		// Sanity check. This shouldn't happen.		if ( 'post-trashed' == $status )			$status = '0';		$comments_in = implode( "', '", $comments );		$wpdb->query( "UPDATE $wpdb->comments SET comment_approved = '$status' WHERE comment_ID IN ('" . $comments_in . "')" );	}	clean_comment_cache( array_keys($statuses) );	delete_post_meta($post_id, '_wp_trash_meta_comments_status');	do_action('untrashed_post_comments', $post_id);}/** * Retrieve the list of categories for a post. * * Compatibility layer for themes and plugins. Also an easy layer of abstraction * away from the complexity of the taxonomy layer. * * @since 2.1.0 * * @uses wp_get_object_terms() Retrieves the categories. Args details can be found here. * * @param int $post_id Optional. The Post ID. * @param array $args Optional. Overwrite the defaults. * @return array */function wp_get_post_categories( $post_id = 0, $args = array() ) {	$post_id = (int) $post_id;	$defaults = array('fields' => 'ids');	$args = wp_parse_args( $args, $defaults );	$cats = wp_get_object_terms($post_id, 'category', $args);	return $cats;}/** * Retrieve the tags for a post. * * There is only one default for this function, called 'fields' and by default * is set to 'all'. There are other defaults that can be overridden in * {@link wp_get_object_terms()}. * * @package WordPress * @subpackage Post * @since 2.3.0 * * @uses wp_get_object_terms() Gets the tags for returning. Args can be found here * * @param int $post_id Optional. The Post ID * @param array $args Optional. Overwrite the defaults * @return array List of post tags. */function wp_get_post_tags( $post_id = 0, $args = array() ) {	return wp_get_post_terms( $post_id, 'post_tag', $args);}/** * Retrieve the terms for a post. * * There is only one default for this function, called 'fields' and by default * is set to 'all'. There are other defaults that can be overridden in * {@link wp_get_object_terms()}. * * @package WordPress * @subpackage Post * @since 2.8.0 * * @uses wp_get_object_terms() Gets the tags for returning. Args can be found here * * @param int $post_id Optional. The Post ID * @param string $taxonomy The taxonomy for which to retrieve terms. Defaults to post_tag. * @param array $args Optional. Overwrite the defaults * @return array List of post tags. */function wp_get_post_terms( $post_id = 0, $taxonomy = 'post_tag', $args = array() ) {	$post_id = (int) $post_id;	$defaults = array('fields' => 'all');	$args = wp_parse_args( $args, $defaults );	$tags = wp_get_object_terms($post_id, $taxonomy, $args);	return $tags;}/** * Retrieve number of recent posts. * * @since 1.0.0 * @uses $wpdb * * @param int $num Optional, default is 10. Number of posts to get. * @return array List of posts. */function wp_get_recent_posts($num = 10) {	global $wpdb;	// Set the limit clause, if we got a limit	$num = (int) $num;	if ( $num ) {		$limit = "LIMIT $num";	}	$sql = "SELECT * FROM $wpdb->posts WHERE post_type = 'post' AND post_status IN ( 'draft', 'publish', 'future', 'pending', 'private' ) ORDER BY post_date DESC $limit";	$result = $wpdb->get_results($sql, ARRAY_A);	return $result ? $result : array();}/** * Retrieve a single post, based on post ID. * * Has categories in 'post_category' property or key. Has tags in 'tags_input' * property or key. * * @since 1.0.0 * * @param int $postid Post ID. * @param string $mode How to return result, either OBJECT, ARRAY_N, or ARRAY_A. * @return object|array Post object or array holding post contents and information */function wp_get_single_post($postid = 0, $mode = OBJECT) {	$postid = (int) $postid;	$post = get_post($postid, $mode);	// Set categories and tags	if ( $mode == OBJECT ) {		$post->post_category = array();		if ( is_object_in_taxonomy($post->post_type, 'category') )			$post->post_category = wp_get_post_categories($postid);		$post->tags_input = array();		if ( is_object_in_taxonomy($post->post_type, 'post_tag') )			$post->tags_input = wp_get_post_tags($postid, array('fields' => 'names'));	} else {		$post['post_category'] = array();		if ( is_object_in_taxonomy($post['post_type'], 'category') )			$post['post_category'] = wp_get_post_categories($postid);		$post['tags_input'] = array();		if ( is_object_in_taxonomy($post['post_type'], 'post_tag') )			$post['tags_input'] = wp_get_post_tags($postid, array('fields' => 'names'));	}	return $post;}/** * Insert a post. * * If the $postarr parameter has 'ID' set to a value, then post will be updated. * * You can set the post date manually, but setting the values for 'post_date' * and 'post_date_gmt' keys. You can close the comments or open the comments by * setting the value for 'comment_status' key. * * The defaults for the parameter $postarr are: *     'post_status'   - Default is 'draft'. *     'post_type'     - Default is 'post'. *     'post_author'   - Default is current user ID ($user_ID). The ID of the user who added the post. *     'ping_status'   - Default is the value in 'default_ping_status' option. *                       Whether the attachment can accept pings. *     'post_parent'   - Default is 0. Set this for the post it belongs to, if any. *     'menu_order'    - Default is 0. The order it is displayed. *     'to_ping'       - Whether to ping. *     'pinged'        - Default is empty string. *     'post_password' - Default is empty string. The password to access the attachment. *     'guid'          - Global Unique ID for referencing the attachment. *     'post_content_filtered' - Post content filtered. *     'post_excerpt'  - Post excerpt. * * @since 1.0.0 * @link http://core.trac.wordpress.org/ticket/9084 Bug report on 'wp_insert_post_data' filter. * @uses $wpdb * @uses $wp_rewrite * @uses $user_ID * * @uses do_action() Calls 'pre_post_update' on post ID if this is an update. * @uses do_action() Calls 'edit_post' action on post ID and post data if this is an update. * @uses do_action() Calls 'save_post' and 'wp_insert_post' on post id and post data just before *                   returning. * * @uses apply_filters() Calls 'wp_insert_post_data' passing $data, $postarr prior to database *                       update or insert. * @uses wp_transition_post_status() * * @param array $postarr Optional. Overrides defaults. * @param bool $wp_error Optional. Allow return of WP_Error on failure. * @return int|WP_Error The value 0 or WP_Error on failure. The post ID on success. */function wp_insert_post($postarr = array(), $wp_error = false) {	global $wpdb, $wp_rewrite, $user_ID;	$defaults = array('post_status' => 'draft', 'post_type' => 'post', 'post_author' => $user_ID,		'ping_status' => get_option('default_ping_status'), 'post_parent' => 0,		'menu_order' => 0, 'to_ping' =>  '', 'pinged' => '', 'post_password' => '',		'guid' => '', 'post_content_filtered' => '', 'post_excerpt' => '', 'import_id' => 0,		'post_content' => '', 'post_title' => '');	$postarr = wp_parse_args($postarr, $defaults);	$postarr = sanitize_post($postarr, 'db');	// export array as variables	extract($postarr, EXTR_SKIP);	// Are we updating or creating?	$update = false;	if ( !empty($ID) ) {		$update = true;		$previous_status = get_post_field('post_status', $ID);	} else {		$previous_status = 'new';	}	if ( ('' == $post_content) && ('' == $post_title) && ('' == $post_excerpt) && ('attachment' != $post_type) ) {		if ( $wp_error )			return new WP_Error('empty_content', __('Content, title, and excerpt are empty.'));		else			return 0;	}	if ( empty($post_type) )		$post_type = 'post';	if ( empty($post_status) )		$post_status = 'draft';	if ( !empty($post_category) )		$post_category = array_filter($post_category); // Filter out empty terms	// Make sure we set a valid category.	if ( empty($post_category) || 0 == count($post_category) || !is_array($post_category) ) {		// 'post' requires at least one category.		if ( 'post' == $post_type && 'auto-draft' != $post_status )			$post_category = array( get_option('default_category') );		else			$post_category = array();	}	if ( empty($post_author) )		$post_author = $user_ID;	$post_ID = 0;	// Get the post ID and GUID	if ( $update ) {		$post_ID = (int) $ID;		$guid = get_post_field( 'guid', $post_ID );		$post_before = get_post($post_ID);	}	// Don't allow contributors to set to set the post slug for pending review posts	if ( 'pending' == $post_status && !current_user_can( 'publish_posts' ) )		$post_name = '';	// Create a valid post name.  Drafts and pending posts are allowed to have an empty	// post name.	if ( empty($post_name) ) {		if ( !in_array( $post_status, array( 'draft', 'pending', 'auto-draft' ) ) )			$post_name = sanitize_title($post_title);		else			$post_name = '';	} else {		$post_name = sanitize_title($post_name);	}	// If the post date is empty (due to having been new or a draft) and status is not 'draft' or 'pending', set date to now	if ( empty($post_date) || '0000-00-00 00:00:00' == $post_date )		$post_date = current_time('mysql');	if ( empty($post_date_gmt) || '0000-00-00 00:00:00' == $post_date_gmt ) {		if ( !in_array( $post_status, array( 'draft', 'pending', 'auto-draft' ) ) )			$post_date_gmt = get_gmt_from_date($post_date);		else			$post_date_gmt = '0000-00-00 00:00:00';	}	if ( $update || '0000-00-00 00:00:00' == $post_date ) {		$post_modified     = current_time( 'mysql' );		$post_modified_gmt = current_time( 'mysql', 1 );	} else {		$post_modified     = $post_date;		$post_modified_gmt = $post_date_gmt;	}	if ( 'publish' == $post_status ) {		$now = gmdate('Y-m-d H:i:59');		if ( mysql2date('U', $post_date_gmt, false) > mysql2date('U', $now, false) )			$post_status = 'future';	} elseif( 'future' == $post_status ) {		$now = gmdate('Y-m-d H:i:59');		if ( mysql2date('U', $post_date_gmt, false) <= mysql2date('U', $now, false) )			$post_status = 'publish';	}	if ( empty($comment_status) ) {		if ( $update )			$comment_status = 'closed';		else			$comment_status = get_option('default_comment_status');	}	if ( empty($ping_status) )		$ping_status = get_option('default_ping_status');	if ( isset($to_ping) )		$to_ping = preg_replace('|\s+|', "\n", $to_ping);	else		$to_ping = '';	if ( ! isset($pinged) )		$pinged = '';	if ( isset($post_parent) )		$post_parent = (int) $post_parent;	else		$post_parent = 0;	if ( !empty($post_ID) ) {		if ( $post_parent == $post_ID ) {			// Post can't be its own parent			$post_parent = 0;		} elseif ( !empty($post_parent) ) {			$parent_post = get_post($post_parent);			// Check for circular dependency			if ( isset( $parent_post->post_parent ) && $parent_post->post_parent == $post_ID )				$post_parent = 0;		}	}	if ( isset($menu_order) )		$menu_order = (int) $menu_order;	else		$menu_order = 0;	if ( !isset($post_password) || 'private' == $post_status )		$post_password = '';	$post_name = wp_unique_post_slug($post_name, $post_ID, $post_status, $post_type, $post_parent);	// expected_slashed (everything!)	$data = compact( array( 'post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_content_filtered', 'post_title', 'post_excerpt', 'post_status', 'post_type', 'comment_status', 'ping_status', 'post_password', 'post_name', 'to_ping', 'pinged', 'post_modified', 'post_modified_gmt', 'post_parent', 'menu_order', 'guid' ) );	$data = apply_filters('wp_insert_post_data', $data, $postarr);	$data = stripslashes_deep( $data );	$where = array( 'ID' => $post_ID );	if ( $update ) {		do_action( 'pre_post_update', $post_ID );		if ( false === $wpdb->update( $wpdb->posts, $data, $where ) ) {			if ( $wp_error )				return new WP_Error('db_update_error', __('Could not update post in the database'), $wpdb->last_error);			else				return 0;		}	} else {		if ( isset($post_mime_type) )			$data['post_mime_type'] = stripslashes( $post_mime_type ); // This isn't in the update		// If there is a suggested ID, use it if not already present		if ( !empty($import_id) ) {			$import_id = (int) $import_id;			if ( ! $wpdb->get_var( $wpdb->prepare("SELECT ID FROM $wpdb->posts WHERE ID = %d", $import_id) ) ) {				$data['ID'] = $import_id;			}		}		if ( false === $wpdb->insert( $wpdb->posts, $data ) ) {			if ( $wp_error )				return new WP_Error('db_insert_error', __('Could not insert post into the database'), $wpdb->last_error);			else				return 0;		}		$post_ID = (int) $wpdb->insert_id;		// use the newly generated $post_ID		$where = array( 'ID' => $post_ID );	}	if ( empty($data['post_name']) && !in_array( $data['post_status'], array( 'draft', 'pending', 'auto-draft' ) ) ) {		$data['post_name'] = sanitize_title($data['post_title'], $post_ID);		$wpdb->update( $wpdb->posts, array( 'post_name' => $data['post_name'] ), $where );	}	if ( is_object_in_taxonomy($post_type, 'category') )		wp_set_post_categories( $post_ID, $post_category );	if ( isset( $tags_input ) && is_object_in_taxonomy($post_type, 'post_tag') )		wp_set_post_tags( $post_ID, $tags_input );	// new-style support for all custom taxonomies	if ( !empty($tax_input) ) {		foreach ( $tax_input as $taxonomy => $tags ) {			$taxonomy_obj = get_taxonomy($taxonomy);			if ( is_array($tags) ) // array = hierarchical, string = non-hierarchical.				$tags = array_filter($tags);			if ( current_user_can($taxonomy_obj->cap->assign_terms) )				wp_set_post_terms( $post_ID, $tags, $taxonomy );		}	}	$current_guid = get_post_field( 'guid', $post_ID );	if ( 'page' == $data['post_type'] )		clean_page_cache($post_ID);	else		clean_post_cache($post_ID);	// Set GUID	if ( !$update && '' == $current_guid )		$wpdb->update( $wpdb->posts, array( 'guid' => get_permalink( $post_ID ) ), $where );	$post = get_post($post_ID);	if ( !empty($page_template) && 'page' == $data['post_type'] ) {		$post->page_template = $page_template;		$page_templates = get_page_templates();		if ( 'default' != $page_template && !in_array($page_template, $page_templates) ) {			if ( $wp_error )				return new WP_Error('invalid_page_template', __('The page template is invalid.'));			else				return 0;		}		update_post_meta($post_ID, '_wp_page_template',  $page_template);	}	wp_transition_post_status($data['post_status'], $previous_status, $post);	if ( $update ) {		do_action('edit_post', $post_ID, $post);		$post_after = get_post($post_ID);		do_action( 'post_updated', $post_ID, $post_after, $post_before);	}	do_action('save_post', $post_ID, $post);	do_action('wp_insert_post', $post_ID, $post);	return $post_ID;}/** * Update a post with new post data. * * The date does not have to be set for drafts. You can set the date and it will * not be overridden. * * @since 1.0.0 * * @param array|object $postarr Post data. Arrays are expected to be escaped, objects are not. * @return int 0 on failure, Post ID on success. */function wp_update_post($postarr = array()) {	if ( is_object($postarr) ) {		// non-escaped post was passed		$postarr = get_object_vars($postarr);		$postarr = add_magic_quotes($postarr);	}	// First, get all of the original fields	$post = wp_get_single_post($postarr['ID'], ARRAY_A);	// Escape data pulled from DB.	$post = add_magic_quotes($post);	// Passed post category list overwrites existing category list if not empty.	if ( isset($postarr['post_category']) && is_array($postarr['post_category'])			 && 0 != count($postarr['post_category']) )		$post_cats = $postarr['post_category'];	else		$post_cats = $post['post_category'];	// Drafts shouldn't be assigned a date unless explicitly done so by the user	if ( in_array($post['post_status'], array('draft', 'pending', 'auto-draft')) && empty($postarr['edit_date']) &&			 ('0000-00-00 00:00:00' == $post['post_date_gmt']) )		$clear_date = true;	else		$clear_date = false;	// Merge old and new fields with new fields overwriting old ones.	$postarr = array_merge($post, $postarr);	$postarr['post_category'] = $post_cats;	if ( $clear_date ) {		$postarr['post_date'] = current_time('mysql');		$postarr['post_date_gmt'] = '';	}	if ($postarr['post_type'] == 'attachment')		return wp_insert_attachment($postarr);	return wp_insert_post($postarr);}/** * Publish a post by transitioning the post status. * * @since 2.1.0 * @uses $wpdb * @uses do_action() Calls 'edit_post', 'save_post', and 'wp_insert_post' on post_id and post data. * * @param int $post_id Post ID. * @return null */function wp_publish_post($post_id) {	global $wpdb;	$post = get_post($post_id);	if ( empty($post) )		return;	if ( 'publish' == $post->post_status )		return;	$wpdb->update( $wpdb->posts, array( 'post_status' => 'publish' ), array( 'ID' => $post_id ) );	$old_status = $post->post_status;	$post->post_status = 'publish';	wp_transition_post_status('publish', $old_status, $post);	// Update counts for the post's terms.	foreach ( (array) get_object_taxonomies('post') as $taxonomy ) {		$tt_ids = wp_get_object_terms($post_id, $taxonomy, array('fields' => 'tt_ids'));		wp_update_term_count($tt_ids, $taxonomy);	}	do_action('edit_post', $post_id, $post);	do_action('save_post', $post_id, $post);	do_action('wp_insert_post', $post_id, $post);}/** * Publish future post and make sure post ID has future post status. * * Invoked by cron 'publish_future_post' event. This safeguard prevents cron * from publishing drafts, etc. * * @since 2.5.0 * * @param int $post_id Post ID. * @return null Nothing is returned. Which can mean that no action is required or post was published. */function check_and_publish_future_post($post_id) {	$post = get_post($post_id);	if ( empty($post) )		return;	if ( 'future' != $post->post_status )		return;	$time = strtotime( $post->post_date_gmt . ' GMT' );	if ( $time > time() ) { // Uh oh, someone jumped the gun!		wp_clear_scheduled_hook( 'publish_future_post', array( $post_id ) ); // clear anything else in the system		wp_schedule_single_event( $time, 'publish_future_post', array( $post_id ) );		return;	}	return wp_publish_post($post_id);}/** * Computes a unique slug for the post, when given the desired slug and some post details. * * @global wpdb $wpdb * @global WP_Rewrite $wp_rewrite * @param string $slug the desired slug (post_name) * @param integer $post_ID * @param string $post_status no uniqueness checks are made if the post is still draft or pending * @param string $post_type * @param integer $post_parent * @return string unique slug for the post, based on $post_name (with a -1, -2, etc. suffix) */function wp_unique_post_slug( $slug, $post_ID, $post_status, $post_type, $post_parent ) {	if ( in_array( $post_status, array( 'draft', 'pending', 'auto-draft' ) ) )		return $slug;	global $wpdb, $wp_rewrite;	$feeds = $wp_rewrite->feeds;	if ( ! is_array( $feeds ) )		$feeds = array();	$hierarchical_post_types = apply_filters( 'hierarchical_post_types', array( 'page' ) );	if ( 'attachment' == $post_type ) {		// Attachment slugs must be unique across all types.		$check_sql = "SELECT post_name FROM $wpdb->posts WHERE post_name = %s AND ID != %d LIMIT 1";		$post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $slug, $post_ID ) );		if ( $post_name_check || in_array( $slug, $feeds ) ) {			$suffix = 2;			do {				$alt_post_name = substr ($slug, 0, 200 - ( strlen( $suffix ) + 1 ) ) . "-$suffix";				$post_name_check = $wpdb->get_var( $wpdb->prepare($check_sql, $alt_post_name, $post_ID ) );				$suffix++;			} while ( $post_name_check );			$slug = $alt_post_name;		}	} elseif ( in_array( $post_type, $hierarchical_post_types ) ) {		// Page slugs must be unique within their own trees. Pages are in a separate		// namespace than posts so page slugs are allowed to overlap post slugs.		$check_sql = "SELECT post_name FROM $wpdb->posts WHERE post_name = %s AND post_type IN ( '" . implode( "', '", esc_sql( $hierarchical_post_types ) ) . "' ) AND ID != %d AND post_parent = %d LIMIT 1";		$post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $slug, $post_ID, $post_parent ) );		if ( $post_name_check || in_array( $slug, $feeds ) || preg_match( '@^(page)?\d+$@', $slug ) ) {			$suffix = 2;			do {				$alt_post_name = substr( $slug, 0, 200 - ( strlen( $suffix ) + 1 ) ) . "-$suffix";				$post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $alt_post_name, $post_ID, $post_parent ) );				$suffix++;			} while ( $post_name_check );			$slug = $alt_post_name;		}	} else {		// Post slugs must be unique across all posts.		$check_sql = "SELECT post_name FROM $wpdb->posts WHERE post_name = %s AND post_type = %s AND ID != %d LIMIT 1";		$post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $slug, $post_type, $post_ID ) );		if ( $post_name_check || in_array( $slug, $feeds ) ) {			$suffix = 2;			do {				$alt_post_name = substr( $slug, 0, 200 - ( strlen( $suffix ) + 1 ) ) . "-$suffix";				$post_name_check = $wpdb->get_var( $wpdb->prepare( $check_sql, $alt_post_name, $post_type, $post_ID ) );				$suffix++;			} while ( $post_name_check );			$slug = $alt_post_name;		}	}	return $slug;}/** * Adds tags to a post. * * @uses wp_set_post_tags() Same first two parameters, but the last parameter is always set to true. * * @package WordPress * @subpackage Post * @since 2.3.0 * * @param int $post_id Post ID * @param string $tags The tags to set for the post, separated by commas. * @return bool|null Will return false if $post_id is not an integer or is 0. Will return null otherwise */function wp_add_post_tags($post_id = 0, $tags = '') {	return wp_set_post_tags($post_id, $tags, true);}/** * Set the tags for a post. * * @since 2.3.0 * @uses wp_set_object_terms() Sets the tags for the post. * * @param int $post_id Post ID. * @param string $tags The tags to set for the post, separated by commas. * @param bool $append If true, don't delete existing tags, just add on. If false, replace the tags with the new tags. * @return bool|null Will return false if $post_id is not an integer or is 0. Will return null otherwise */function wp_set_post_tags( $post_id = 0, $tags = '', $append = false ) {	return wp_set_post_terms( $post_id, $tags, 'post_tag', $append);}/** * Set the terms for a post. * * @since 2.8.0 * @uses wp_set_object_terms() Sets the tags for the post. * * @param int $post_id Post ID. * @param string $tags The tags to set for the post, separated by commas. * @param bool $append If true, don't delete existing tags, just add on. If false, replace the tags with the new tags. * @return bool|null Will return false if $post_id is not an integer or is 0. Will return null otherwise */function wp_set_post_terms( $post_id = 0, $tags = '', $taxonomy = 'post_tag', $append = false ) {	$post_id = (int) $post_id;	if ( !$post_id )		return false;	if ( empty($tags) )		$tags = array();	$tags = is_array($tags) ? $tags : explode( ',', trim($tags, " \n\t\r\0\x0B,") );	// Hierarchical taxonomies must always pass IDs rather than names so that children with the same	// names but different parents aren't confused.	if ( is_taxonomy_hierarchical( $taxonomy ) ) {		$tags = array_map( 'intval', $tags );		$tags = array_unique( $tags );	}	wp_set_object_terms($post_id, $tags, $taxonomy, $append);}/** * Set categories for a post. * * If the post categories parameter is not set, then the default category is * going used. * * @since 2.1.0 * * @param int $post_ID Post ID. * @param array $post_categories Optional. List of categories. * @return bool|mixed */function wp_set_post_categories($post_ID = 0, $post_categories = array()) {	$post_ID = (int) $post_ID;	$post_type = get_post_type( $post_ID );	$post_status = get_post_status( $post_ID );	// If $post_categories isn't already an array, make it one:	if ( !is_array($post_categories) || empty($post_categories) ) {		if ( 'post' == $post_type && 'auto-draft' != $post_status )			$post_categories = array( get_option('default_category') );		else			$post_categories = array();	} else if ( 1 == count($post_categories) && '' == reset($post_categories) ) {		return true;	}	if ( !empty($post_categories) ) {		$post_categories = array_map('intval', $post_categories);		$post_categories = array_unique($post_categories);	}	return wp_set_object_terms($post_ID, $post_categories, 'category');}/** * Transition the post status of a post. * * Calls hooks to transition post status. * * The first is 'transition_post_status' with new status, old status, and post data. * * The next action called is 'OLDSTATUS_to_NEWSTATUS' the 'NEWSTATUS' is the * $new_status parameter and the 'OLDSTATUS' is $old_status parameter; it has the * post data. * * The final action is named 'NEWSTATUS_POSTTYPE', 'NEWSTATUS' is from the $new_status * parameter and POSTTYPE is post_type post data. * * @since 2.3.0 * @link http://codex.wordpress.org/Post_Status_Transitions * * @uses do_action() Calls 'transition_post_status' on $new_status, $old_status and *  $post if there is a status change. * @uses do_action() Calls '${old_status}_to_$new_status' on $post if there is a status change. * @uses do_action() Calls '${new_status}_$post->post_type' on post ID and $post. * * @param string $new_status Transition to this post status. * @param string $old_status Previous post status. * @param object $post Post data. */function wp_transition_post_status($new_status, $old_status, $post) {	do_action('transition_post_status', $new_status, $old_status, $post);	do_action("${old_status}_to_$new_status", $post);	do_action("${new_status}_$post->post_type", $post->ID, $post);}//// Trackback and ping functions///** * Add a URL to those already pung. * * @since 1.5.0 * @uses $wpdb * * @param int $post_id Post ID. * @param string $uri Ping URI. * @return int How many rows were updated. */function add_ping($post_id, $uri) {	global $wpdb;	$pung = $wpdb->get_var( $wpdb->prepare( "SELECT pinged FROM $wpdb->posts WHERE ID = %d", $post_id ));	$pung = trim($pung);	$pung = preg_split('/\s/', $pung);	$pung[] = $uri;	$new = implode("\n", $pung);	$new = apply_filters('add_ping', $new);	// expected_slashed ($new)	$new = stripslashes($new);	return $wpdb->update( $wpdb->posts, array( 'pinged' => $new ), array( 'ID' => $post_id ) );}/** * Retrieve enclosures already enclosed for a post. * * @since 1.5.0 * @uses $wpdb * * @param int $post_id Post ID. * @return array List of enclosures */function get_enclosed($post_id) {	$custom_fields = get_post_custom( $post_id );	$pung = array();	if ( !is_array( $custom_fields ) )		return $pung;	foreach ( $custom_fields as $key => $val ) {		if ( 'enclosure' != $key || !is_array( $val ) )			continue;		foreach( $val as $enc ) {			$enclosure = split( "\n", $enc );			$pung[] = trim( $enclosure[ 0 ] );		}	}	$pung = apply_filters('get_enclosed', $pung);	return $pung;}/** * Retrieve URLs already pinged for a post. * * @since 1.5.0 * @uses $wpdb * * @param int $post_id Post ID. * @return array */function get_pung($post_id) {	global $wpdb;	$pung = $wpdb->get_var( $wpdb->prepare( "SELECT pinged FROM $wpdb->posts WHERE ID = %d", $post_id ));	$pung = trim($pung);	$pung = preg_split('/\s/', $pung);	$pung = apply_filters('get_pung', $pung);	return $pung;}/** * Retrieve URLs that need to be pinged. * * @since 1.5.0 * @uses $wpdb * * @param int $post_id Post ID * @return array */function get_to_ping($post_id) {	global $wpdb;	$to_ping = $wpdb->get_var( $wpdb->prepare( "SELECT to_ping FROM $wpdb->posts WHERE ID = %d", $post_id ));	$to_ping = trim($to_ping);	$to_ping = preg_split('/\s/', $to_ping, -1, PREG_SPLIT_NO_EMPTY);	$to_ping = apply_filters('get_to_ping',  $to_ping);	return $to_ping;}/** * Do trackbacks for a list of URLs. * * @since 1.0.0 * * @param string $tb_list Comma separated list of URLs * @param int $post_id Post ID */function trackback_url_list($tb_list, $post_id) {	if ( ! empty( $tb_list ) ) {		// get post data		$postdata = wp_get_single_post($post_id, ARRAY_A);		// import postdata as variables		extract($postdata, EXTR_SKIP);		// form an excerpt		$excerpt = strip_tags($post_excerpt ? $post_excerpt : $post_content);		if (strlen($excerpt) > 255) {			$excerpt = substr($excerpt,0,252) . '...';		}		$trackback_urls = explode(',', $tb_list);		foreach( (array) $trackback_urls as $tb_url) {			$tb_url = trim($tb_url);			trackback($tb_url, stripslashes($post_title), $excerpt, $post_id);		}	}}//// Page functions///** * Get a list of page IDs. * * @since 2.0.0 * @uses $wpdb * * @return array List of page IDs. */function get_all_page_ids() {	global $wpdb;	if ( ! $page_ids = wp_cache_get('all_page_ids', 'posts') ) {		$page_ids = $wpdb->get_col("SELECT ID FROM $wpdb->posts WHERE post_type = 'page'");		wp_cache_add('all_page_ids', $page_ids, 'posts');	}	return $page_ids;}/** * Retrieves page data given a page ID or page object. * * @since 1.5.1 * * @param mixed $page Page object or page ID. Passed by reference. * @param string $output What to output. OBJECT, ARRAY_A, or ARRAY_N. * @param string $filter How the return value should be filtered. * @return mixed Page data. */function &get_page(&$page, $output = OBJECT, $filter = 'raw') {	$p = get_post($page, $output, $filter);	return $p;}/** * Retrieves a page given its path. * * @since 2.1.0 * @uses $wpdb * * @param string $page_path Page path * @param string $output Optional. Output type. OBJECT, ARRAY_N, or ARRAY_A. Default OBJECT. * @param string $post_type Optional. Post type. Default page. * @return mixed Null when complete. */function get_page_by_path($page_path, $output = OBJECT, $post_type = 'page') {	global $wpdb;	$page_path = rawurlencode(urldecode($page_path));	$page_path = str_replace('%2F', '/', $page_path);	$page_path = str_replace('%20', ' ', $page_path);	$page_paths = '/' . trim($page_path, '/');	$leaf_path  = sanitize_title(basename($page_paths));	$page_paths = explode('/', $page_paths);	$full_path = '';	foreach ( (array) $page_paths as $pathdir )		$full_path .= ( $pathdir != '' ? '/' : '' ) . sanitize_title($pathdir);	$pages = $wpdb->get_results( $wpdb->prepare( "SELECT ID, post_name, post_parent FROM $wpdb->posts WHERE post_name = %s AND (post_type = %s OR post_type = 'attachment')", $leaf_path, $post_type ));	if ( empty($pages) )		return null;	foreach ( $pages as $page ) {		$path = '/' . $leaf_path;		$curpage = $page;		while ( $curpage->post_parent != 0 ) {			$curpage = $wpdb->get_row( $wpdb->prepare( "SELECT ID, post_name, post_parent FROM $wpdb->posts WHERE ID = %d and post_type = %s", $curpage->post_parent, $post_type ));			$path = '/' . $curpage->post_name . $path;		}		if ( $path == $full_path )			return get_page($page->ID, $output, $post_type);	}	return null;}/** * Retrieve a page given its title. * * @since 2.1.0 * @uses $wpdb * * @param string $page_title Page title * @param string $output Optional. Output type. OBJECT, ARRAY_N, or ARRAY_A. Default OBJECT. * @param string $post_type Optional. Post type. Default page. * @return mixed */function get_page_by_title($page_title, $output = OBJECT, $post_type = 'page' ) {	global $wpdb;	$page = $wpdb->get_var( $wpdb->prepare( "SELECT ID FROM $wpdb->posts WHERE post_title = %s AND post_type= %s", $page_title, $post_type ) );	if ( $page )		return get_page($page, $output);	return null;}/** * Retrieve child pages from list of pages matching page ID. * * Matches against the pages parameter against the page ID. Also matches all * children for the same to retrieve all children of a page. Does not make any * SQL queries to get the children. * * @since 1.5.1 * * @param int $page_id Page ID. * @param array $pages List of pages' objects. * @return array */function &get_page_children($page_id, $pages) {	$page_list = array();	foreach ( (array) $pages as $page ) {		if ( $page->post_parent == $page_id ) {			$page_list[] = $page;			if ( $children = get_page_children($page->ID, $pages) )				$page_list = array_merge($page_list, $children);		}	}	return $page_list;}/** * Order the pages with children under parents in a flat list. * * It uses auxiliary structure to hold parent-children relationships and * runs in O(N) complexity * * @since 2.0.0 * * @param array $posts Posts array. * @param int $parent Parent page ID. * @return array A list arranged by hierarchy. Children immediately follow their parents. */function &get_page_hierarchy( &$pages, $page_id = 0 ) {	if ( empty( $pages ) ) {		$result = array();		return $result;	}	$children = array();	foreach ( (array) $pages as $p ) {		$parent_id = intval( $p->post_parent );		$children[ $parent_id ][] = $p;	 }	 $result = array();	 _page_traverse_name( $page_id, $children, $result );	return $result;}/** * function to traverse and return all the nested children post names of a root page. * $children contains parent-chilren relations * */function _page_traverse_name( $page_id, &$children, &$result ){	if ( isset( $children[ $page_id ] ) ){		foreach( (array)$children[ $page_id ] as $child ) {			$result[ $child->ID ] = $child->post_name;			_page_traverse_name( $child->ID, $children, $result );		}	}}/** * Builds URI for a page. * * Sub pages will be in the "directory" under the parent page post name. * * @since 1.5.0 * * @param mixed $page Page object or page ID. * @return string Page URI. */function get_page_uri($page) {	if ( ! is_object($page) )		$page = get_page($page);	$uri = $page->post_name;	// A page cannot be it's own parent.	if ( $page->post_parent == $page->ID )		return $uri;	while ($page->post_parent != 0) {		$page = get_page($page->post_parent);		$uri = $page->post_name . "/" . $uri;	}	return $uri;}/** * Retrieve a list of pages. * * The defaults that can be overridden are the following: 'child_of', * 'sort_order', 'sort_column', 'post_title', 'hierarchical', 'exclude', * 'include', 'meta_key', 'meta_value','authors', 'number', and 'offset'. * * @since 1.5.0 * @uses $wpdb * * @param mixed $args Optional. Array or string of options that overrides defaults. * @return array List of pages matching defaults or $args */function &get_pages($args = '') {	global $wpdb;	$defaults = array(		'child_of' => 0, 'sort_order' => 'ASC',		'sort_column' => 'post_title', 'hierarchical' => 1,		'exclude' => array(), 'include' => array(),		'meta_key' => '', 'meta_value' => '',		'authors' => '', 'parent' => -1, 'exclude_tree' => '',		'number' => '', 'offset' => 0,		'post_type' => 'page', 'post_status' => 'publish',	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	$number = (int) $number;	$offset = (int) $offset;	// Make sure the post type is hierarchical	$hierarchical_post_types = get_post_types( array( 'hierarchical' => true ) );	if ( !in_array( $post_type, $hierarchical_post_types ) )		return false;	// Make sure we have a valid post status	if ( !in_array($post_status, get_post_stati()) )		return false;	$cache = array();	$key = md5( serialize( compact(array_keys($defaults)) ) );	if ( $cache = wp_cache_get( 'get_pages', 'posts' ) ) {		if ( is_array($cache) && isset( $cache[ $key ] ) ) {			$pages = apply_filters('get_pages', $cache[ $key ], $r );			return $pages;		}	}	if ( !is_array($cache) )		$cache = array();	$inclusions = '';	if ( !empty($include) ) {		$child_of = 0; //ignore child_of, parent, exclude, meta_key, and meta_value params if using include		$parent = -1;		$exclude = '';		$meta_key = '';		$meta_value = '';		$hierarchical = false;		$incpages = wp_parse_id_list( $include );		if ( ! empty( $incpages ) ) {			foreach ( $incpages as $incpage ) {				if (empty($inclusions))					$inclusions = $wpdb->prepare(' AND ( ID = %d ', $incpage);				else					$inclusions .= $wpdb->prepare(' OR ID = %d ', $incpage);			}		}	}	if (!empty($inclusions))		$inclusions .= ')';	$exclusions = '';	if ( !empty($exclude) ) {		$expages = wp_parse_id_list( $exclude );		if ( ! empty( $expages ) ) {			foreach ( $expages as $expage ) {				if (empty($exclusions))					$exclusions = $wpdb->prepare(' AND ( ID <> %d ', $expage);				else					$exclusions .= $wpdb->prepare(' AND ID <> %d ', $expage);			}		}	}	if (!empty($exclusions))		$exclusions .= ')';	$author_query = '';	if (!empty($authors)) {		$post_authors = preg_split('/[\s,]+/',$authors);		if ( ! empty( $post_authors ) ) {			foreach ( $post_authors as $post_author ) {				//Do we have an author id or an author login?				if ( 0 == intval($post_author) ) {					$post_author = get_userdatabylogin($post_author);					if ( empty($post_author) )						continue;					if ( empty($post_author->ID) )						continue;					$post_author = $post_author->ID;				}				if ( '' == $author_query )					$author_query = $wpdb->prepare(' post_author = %d ', $post_author);				else					$author_query .= $wpdb->prepare(' OR post_author = %d ', $post_author);			}			if ( '' != $author_query )				$author_query = " AND ($author_query)";		}	}	$join = '';	$where = "$exclusions $inclusions ";	if ( ! empty( $meta_key ) || ! empty( $meta_value ) ) {		$join = " LEFT JOIN $wpdb->postmeta ON ( $wpdb->posts.ID = $wpdb->postmeta.post_id )";		// meta_key and meta_value might be slashed		$meta_key = stripslashes($meta_key);		$meta_value = stripslashes($meta_value);		if ( ! empty( $meta_key ) )			$where .= $wpdb->prepare(" AND $wpdb->postmeta.meta_key = %s", $meta_key);		if ( ! empty( $meta_value ) )			$where .= $wpdb->prepare(" AND $wpdb->postmeta.meta_value = %s", $meta_value);	}	if ( $parent >= 0 )		$where .= $wpdb->prepare(' AND post_parent = %d ', $parent);	$where_post_type = $wpdb->prepare( "post_type = '%s' AND post_status = '%s'", $post_type, $post_status );	$query = "SELECT * FROM $wpdb->posts $join WHERE ($where_post_type) $where ";	$query .= $author_query;	$query .= " ORDER BY " . $sort_column . " " . $sort_order ;	if ( !empty($number) )		$query .= ' LIMIT ' . $offset . ',' . $number;	$pages = $wpdb->get_results($query);	if ( empty($pages) ) {		$pages = apply_filters('get_pages', array(), $r);		return $pages;	}	// Sanitize before caching so it'll only get done once	$num_pages = count($pages);	for ($i = 0; $i < $num_pages; $i++) {		$pages[$i] = sanitize_post($pages[$i], 'raw');	}	// Update cache.	update_page_cache($pages);	if ( $child_of || $hierarchical )		$pages = & get_page_children($child_of, $pages);	if ( !empty($exclude_tree) ) {		$exclude = (int) $exclude_tree;		$children = get_page_children($exclude, $pages);		$excludes = array();		foreach ( $children as $child )			$excludes[] = $child->ID;		$excludes[] = $exclude;		$num_pages = count($pages);		for ( $i = 0; $i < $num_pages; $i++ ) {			if ( in_array($pages[$i]->ID, $excludes) )				unset($pages[$i]);		}	}	$cache[ $key ] = $pages;	wp_cache_set( 'get_pages', $cache, 'posts' );	$pages = apply_filters('get_pages', $pages, $r);	return $pages;}//// Attachment functions///** * Check if the attachment URI is local one and is really an attachment. * * @since 2.0.0 * * @param string $url URL to check * @return bool True on success, false on failure. */function is_local_attachment($url) {	if (strpos($url, home_url()) === false)		return false;	if (strpos($url, home_url('/?attachment_id=')) !== false)		return true;	if ( $id = url_to_postid($url) ) {		$post = & get_post($id);		if ( 'attachment' == $post->post_type )			return true;	}	return false;}/** * Insert an attachment. * * If you set the 'ID' in the $object parameter, it will mean that you are * updating and attempt to update the attachment. You can also set the * attachment name or title by setting the key 'post_name' or 'post_title'. * * You can set the dates for the attachment manually by setting the 'post_date' * and 'post_date_gmt' keys' values. * * By default, the comments will use the default settings for whether the * comments are allowed. You can close them manually or keep them open by * setting the value for the 'comment_status' key. * * The $object parameter can have the following: *     'post_status'   - Default is 'draft'. Can not be overridden, set the same as parent post. *     'post_type'     - Default is 'post', will be set to attachment. Can not override. *     'post_author'   - Default is current user ID. The ID of the user, who added the attachment. *     'ping_status'   - Default is the value in default ping status option. Whether the attachment *                       can accept pings. *     'post_parent'   - Default is 0. Can use $parent parameter or set this for the post it belongs *                       to, if any. *     'menu_order'    - Default is 0. The order it is displayed. *     'to_ping'       - Whether to ping. *     'pinged'        - Default is empty string. *     'post_password' - Default is empty string. The password to access the attachment. *     'guid'          - Global Unique ID for referencing the attachment. *     'post_content_filtered' - Attachment post content filtered. *     'post_excerpt'  - Attachment excerpt. * * @since 2.0.0 * @uses $wpdb * @uses $user_ID * @uses do_action() Calls 'edit_attachment' on $post_ID if this is an update. * @uses do_action() Calls 'add_attachment' on $post_ID if this is not an update. * * @param string|array $object Arguments to override defaults. * @param string $file Optional filename. * @param int $post_parent Parent post ID. * @return int Attachment ID. */function wp_insert_attachment($object, $file = false, $parent = 0) {	global $wpdb, $user_ID;	$defaults = array('post_status' => 'draft', 'post_type' => 'post', 'post_author' => $user_ID,		'ping_status' => get_option('default_ping_status'), 'post_parent' => 0,		'menu_order' => 0, 'to_ping' =>  '', 'pinged' => '', 'post_password' => '',		'guid' => '', 'post_content_filtered' => '', 'post_excerpt' => '', 'import_id' => 0);	$object = wp_parse_args($object, $defaults);	if ( !empty($parent) )		$object['post_parent'] = $parent;	$object = sanitize_post($object, 'db');	// export array as variables	extract($object, EXTR_SKIP);	if ( empty($post_author) )		$post_author = $user_ID;	$post_type = 'attachment';	$post_status = 'inherit';	// Make sure we set a valid category.	if ( !isset($post_category) || 0 == count($post_category) || !is_array($post_category) ) {		// 'post' requires at least one category.		if ( 'post' == $post_type )			$post_category = array( get_option('default_category') );		else			$post_category = array();	}	// Are we updating or creating?	if ( !empty($ID) ) {		$update = true;		$post_ID = (int) $ID;	} else {		$update = false;		$post_ID = 0;	}	// Create a valid post name.	if ( empty($post_name) )		$post_name = sanitize_title($post_title);	else		$post_name = sanitize_title($post_name);	// expected_slashed ($post_name)	$post_name = wp_unique_post_slug($post_name, $post_ID, $post_status, $post_type, $post_parent);	if ( empty($post_date) )		$post_date = current_time('mysql');	if ( empty($post_date_gmt) )		$post_date_gmt = current_time('mysql', 1);	if ( empty($post_modified) )		$post_modified = $post_date;	if ( empty($post_modified_gmt) )		$post_modified_gmt = $post_date_gmt;	if ( empty($comment_status) ) {		if ( $update )			$comment_status = 'closed';		else			$comment_status = get_option('default_comment_status');	}	if ( empty($ping_status) )		$ping_status = get_option('default_ping_status');	if ( isset($to_ping) )		$to_ping = preg_replace('|\s+|', "\n", $to_ping);	else		$to_ping = '';	if ( isset($post_parent) )		$post_parent = (int) $post_parent;	else		$post_parent = 0;	if ( isset($menu_order) )		$menu_order = (int) $menu_order;	else		$menu_order = 0;	if ( !isset($post_password) )		$post_password = '';	if ( ! isset($pinged) )		$pinged = '';	// expected_slashed (everything!)	$data = compact( array( 'post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_content_filtered', 'post_title', 'post_excerpt', 'post_status', 'post_type', 'comment_status', 'ping_status', 'post_password', 'post_name', 'to_ping', 'pinged', 'post_modified', 'post_modified_gmt', 'post_parent', 'menu_order', 'post_mime_type', 'guid' ) );	$data = stripslashes_deep( $data );	if ( $update ) {		$wpdb->update( $wpdb->posts, $data, array( 'ID' => $post_ID ) );	} else {		// If there is a suggested ID, use it if not already present		if ( !empty($import_id) ) {			$import_id = (int) $import_id;			if ( ! $wpdb->get_var( $wpdb->prepare("SELECT ID FROM $wpdb->posts WHERE ID = %d", $import_id) ) ) {				$data['ID'] = $import_id;			}		}		$wpdb->insert( $wpdb->posts, $data );		$post_ID = (int) $wpdb->insert_id;	}	if ( empty($post_name) ) {		$post_name = sanitize_title($post_title, $post_ID);		$wpdb->update( $wpdb->posts, compact("post_name"), array( 'ID' => $post_ID ) );	}	wp_set_post_categories($post_ID, $post_category);	if ( $file )		update_attached_file( $post_ID, $file );	clean_post_cache($post_ID);	if ( isset($post_parent) && $post_parent < 0 )		add_post_meta($post_ID, '_wp_attachment_temp_parent', $post_parent, true);	if ( $update) {		do_action('edit_attachment', $post_ID);	} else {		do_action('add_attachment', $post_ID);	}	return $post_ID;}/** * Trashes or deletes an attachment. * * When an attachment is permanently deleted, the file will also be removed. * Deletion removes all post meta fields, taxonomy, comments, etc. associated * with the attachment (except the main post). * * The attachment is moved to the trash instead of permanently deleted unless trash * for media is disabled, item is already in the trash, or $force_delete is true. * * @since 2.0.0 * @uses $wpdb * @uses do_action() Calls 'delete_attachment' hook on Attachment ID. * * @param int $postid Attachment ID. * @param bool $force_delete Whether to bypass trash and force deletion. Defaults to false. * @return mixed False on failure. Post data on success. */function wp_delete_attachment( $post_id, $force_delete = false ) {	global $wpdb;	if ( !$post = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->posts WHERE ID = %d", $post_id) ) )		return $post;	if ( 'attachment' != $post->post_type )		return false;	if ( !$force_delete && EMPTY_TRASH_DAYS && MEDIA_TRASH && 'trash' != $post->post_status )		return wp_trash_post( $post_id );	delete_post_meta($post_id, '_wp_trash_meta_status');	delete_post_meta($post_id, '_wp_trash_meta_time');	$meta = wp_get_attachment_metadata( $post_id );	$backup_sizes = get_post_meta( $post->ID, '_wp_attachment_backup_sizes', true );	$file = get_attached_file( $post_id );	if ( is_multisite() )		delete_transient( 'dirsize_cache' );	do_action('delete_attachment', $post_id);	wp_delete_object_term_relationships($post_id, array('category', 'post_tag'));	wp_delete_object_term_relationships($post_id, get_object_taxonomies($post->post_type));	$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->postmeta WHERE meta_key = '_thumbnail_id' AND meta_value = %d", $post_id ));	$comment_ids = $wpdb->get_col( $wpdb->prepare( "SELECT comment_ID FROM $wpdb->comments WHERE comment_post_ID = %d", $post_id ));	if ( ! empty( $comment_ids ) ) {		do_action( 'delete_comment', $comment_ids );		foreach ( $comment_ids as $comment_id )			wp_delete_comment( $comment_id, true );		do_action( 'deleted_comment', $comment_ids );	}	$post_meta_ids = $wpdb->get_col( $wpdb->prepare( "SELECT meta_id FROM $wpdb->postmeta WHERE post_id = %d ", $post_id ));	if ( !empty($post_meta_ids) ) {		do_action( 'delete_postmeta', $post_meta_ids );		$in_post_meta_ids = "'" . implode("', '", $post_meta_ids) . "'";		$wpdb->query( "DELETE FROM $wpdb->postmeta WHERE meta_id IN($in_post_meta_ids)" );		do_action( 'deleted_postmeta', $post_meta_ids );	}	do_action( 'delete_post', $post_id );	$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->posts WHERE ID = %d", $post_id ));	do_action( 'deleted_post', $post_id );	$uploadpath = wp_upload_dir();	if ( ! empty($meta['thumb']) ) {		// Don't delete the thumb if another attachment uses it		if (! $wpdb->get_row( $wpdb->prepare( "SELECT meta_id FROM $wpdb->postmeta WHERE meta_key = '_wp_attachment_metadata' AND meta_value LIKE %s AND post_id <> %d", '%' . $meta['thumb'] . '%', $post_id)) ) {			$thumbfile = str_replace(basename($file), $meta['thumb'], $file);			$thumbfile = apply_filters('wp_delete_file', $thumbfile);			@ unlink( path_join($uploadpath['basedir'], $thumbfile) );		}	}	// remove intermediate and backup images if there are any	foreach ( get_intermediate_image_sizes() as $size ) {		if ( $intermediate = image_get_intermediate_size($post_id, $size) ) {			$intermediate_file = apply_filters('wp_delete_file', $intermediate['path']);			@ unlink( path_join($uploadpath['basedir'], $intermediate_file) );		}	}	if ( is_array($backup_sizes) ) {		foreach ( $backup_sizes as $size ) {			$del_file = path_join( dirname($meta['file']), $size['file'] );			$del_file = apply_filters('wp_delete_file', $del_file);            @ unlink( path_join($uploadpath['basedir'], $del_file) );		}	}	$file = apply_filters('wp_delete_file', $file);	if ( ! empty($file) )		@ unlink($file);	clean_post_cache($post_id);	return $post;}/** * Retrieve attachment meta field for attachment ID. * * @since 2.1.0 * * @param int $post_id Attachment ID * @param bool $unfiltered Optional, default is false. If true, filters are not run. * @return string|bool Attachment meta field. False on failure. */function wp_get_attachment_metadata( $post_id = 0, $unfiltered = false ) {	$post_id = (int) $post_id;	if ( !$post =& get_post( $post_id ) )		return false;	$data = get_post_meta( $post->ID, '_wp_attachment_metadata', true );	if ( $unfiltered )		return $data;	return apply_filters( 'wp_get_attachment_metadata', $data, $post->ID );}/** * Update metadata for an attachment. * * @since 2.1.0 * * @param int $post_id Attachment ID. * @param array $data Attachment data. * @return int */function wp_update_attachment_metadata( $post_id, $data ) {	$post_id = (int) $post_id;	if ( !$post =& get_post( $post_id ) )		return false;	$data = apply_filters( 'wp_update_attachment_metadata', $data, $post->ID );	return update_post_meta( $post->ID, '_wp_attachment_metadata', $data);}/** * Retrieve the URL for an attachment. * * @since 2.1.0 * * @param int $post_id Attachment ID. * @return string */function wp_get_attachment_url( $post_id = 0 ) {	$post_id = (int) $post_id;	if ( !$post =& get_post( $post_id ) )		return false;	$url = '';	if ( $file = get_post_meta( $post->ID, '_wp_attached_file', true) ) { //Get attached file		if ( ($uploads = wp_upload_dir()) && false === $uploads['error'] ) { //Get upload directory			if ( 0 === strpos($file, $uploads['basedir']) ) //Check that the upload base exists in the file location				$url = str_replace($uploads['basedir'], $uploads['baseurl'], $file); //replace file location with url location            elseif ( false !== strpos($file, 'wp-content/uploads') )                $url = $uploads['baseurl'] . substr( $file, strpos($file, 'wp-content/uploads') + 18 );            else                $url = $uploads['baseurl'] . "/$file"; //Its a newly uploaded file, therefor $file is relative to the basedir.		}	}	if ( empty($url) ) //If any of the above options failed, Fallback on the GUID as used pre-2.7, not recomended to rely upon this.		$url = get_the_guid( $post->ID );	if ( 'attachment' != $post->post_type || empty($url) )		return false;	return apply_filters( 'wp_get_attachment_url', $url, $post->ID );}/** * Retrieve thumbnail for an attachment. * * @since 2.1.0 * * @param int $post_id Attachment ID. * @return mixed False on failure. Thumbnail file path on success. */function wp_get_attachment_thumb_file( $post_id = 0 ) {	$post_id = (int) $post_id;	if ( !$post =& get_post( $post_id ) )		return false;	if ( !is_array( $imagedata = wp_get_attachment_metadata( $post->ID ) ) )		return false;	$file = get_attached_file( $post->ID );	if ( !empty($imagedata['thumb']) && ($thumbfile = str_replace(basename($file), $imagedata['thumb'], $file)) && file_exists($thumbfile) )		return apply_filters( 'wp_get_attachment_thumb_file', $thumbfile, $post->ID );	return false;}/** * Retrieve URL for an attachment thumbnail. * * @since 2.1.0 * * @param int $post_id Attachment ID * @return string|bool False on failure. Thumbnail URL on success. */function wp_get_attachment_thumb_url( $post_id = 0 ) {	$post_id = (int) $post_id;	if ( !$post =& get_post( $post_id ) )		return false;	if ( !$url = wp_get_attachment_url( $post->ID ) )		return false;	$sized = image_downsize( $post_id, 'thumbnail' );	if ( $sized )		return $sized[0];	if ( !$thumb = wp_get_attachment_thumb_file( $post->ID ) )		return false;	$url = str_replace(basename($url), basename($thumb), $url);	return apply_filters( 'wp_get_attachment_thumb_url', $url, $post->ID );}/** * Check if the attachment is an image. * * @since 2.1.0 * * @param int $post_id Attachment ID * @return bool */function wp_attachment_is_image( $post_id = 0 ) {	$post_id = (int) $post_id;	if ( !$post =& get_post( $post_id ) )		return false;	if ( !$file = get_attached_file( $post->ID ) )		return false;	$ext = preg_match('/\.([^.]+)$/', $file, $matches) ? strtolower($matches[1]) : false;	$image_exts = array('jpg', 'jpeg', 'gif', 'png');	if ( 'image/' == substr($post->post_mime_type, 0, 6) || $ext && 'import' == $post->post_mime_type && in_array($ext, $image_exts) )		return true;	return false;}/** * Retrieve the icon for a MIME type. * * @since 2.1.0 * * @param string $mime MIME type * @return string|bool */function wp_mime_type_icon( $mime = 0 ) {	if ( !is_numeric($mime) )		$icon = wp_cache_get("mime_type_icon_$mime");	if ( empty($icon) ) {		$post_id = 0;		$post_mimes = array();		if ( is_numeric($mime) ) {			$mime = (int) $mime;			if ( $post =& get_post( $mime ) ) {				$post_id = (int) $post->ID;				$ext = preg_replace('/^.+?\.([^.]+)$/', '$1', $post->guid);				if ( !empty($ext) ) {					$post_mimes[] = $ext;					if ( $ext_type = wp_ext2type( $ext ) )						$post_mimes[] = $ext_type;				}				$mime = $post->post_mime_type;			} else {				$mime = 0;			}		} else {			$post_mimes[] = $mime;		}		$icon_files = wp_cache_get('icon_files');		if ( !is_array($icon_files) ) {			$icon_dir = apply_filters( 'icon_dir', ABSPATH . WPINC . '/images/crystal' );			$icon_dir_uri = apply_filters( 'icon_dir_uri', includes_url('images/crystal') );			$dirs = apply_filters( 'icon_dirs', array($icon_dir => $icon_dir_uri) );			$icon_files = array();			while ( $dirs ) {				$dir = array_shift($keys = array_keys($dirs));				$uri = array_shift($dirs);				if ( $dh = opendir($dir) ) {					while ( false !== $file = readdir($dh) ) {						$file = basename($file);						if ( substr($file, 0, 1) == '.' )							continue;						if ( !in_array(strtolower(substr($file, -4)), array('.png', '.gif', '.jpg') ) ) {							if ( is_dir("$dir/$file") )								$dirs["$dir/$file"] = "$uri/$file";							continue;						}						$icon_files["$dir/$file"] = "$uri/$file";					}					closedir($dh);				}			}			wp_cache_set('icon_files', $icon_files, 600);		}		// Icon basename - extension = MIME wildcard		foreach ( $icon_files as $file => $uri )			$types[ preg_replace('/^([^.]*).*$/', '$1', basename($file)) ] =& $icon_files[$file];		if ( ! empty($mime) ) {			$post_mimes[] = substr($mime, 0, strpos($mime, '/'));			$post_mimes[] = substr($mime, strpos($mime, '/') + 1);			$post_mimes[] = str_replace('/', '_', $mime);		}		$matches = wp_match_mime_types(array_keys($types), $post_mimes);		$matches['default'] = array('default');		foreach ( $matches as $match => $wilds ) {			if ( isset($types[$wilds[0]])) {				$icon = $types[$wilds[0]];				if ( !is_numeric($mime) )					wp_cache_set("mime_type_icon_$mime", $icon);				break;			}		}	}	return apply_filters( 'wp_mime_type_icon', $icon, $mime, $post_id ); // Last arg is 0 if function pass mime type.}/** * Checked for changed slugs for published posts and save old slug. * * The function is used along with form POST data. It checks for the wp-old-slug * POST field. Will only be concerned with published posts and the slug actually * changing. * * If the slug was changed and not already part of the old slugs then it will be * added to the post meta field ('_wp_old_slug') for storing old slugs for that * post. * * The most logically usage of this function is redirecting changed posts, so * that those that linked to an changed post will be redirected to the new post. * * @since 2.1.0 * * @param int $post_id Post ID. * @return int Same as $post_id */function wp_check_for_changed_slugs($post_id, $post, $post_before) {	// dont bother if it hasnt changed	if ( $post->post_name == $post_before->post_name )		return;	// we're only concerned with published posts	if ( $post->post_status != 'publish' || $post->post_type != 'post' )		return;	$old_slugs = (array) get_post_meta($post_id, '_wp_old_slug');	// if we haven't added this old slug before, add it now	if ( !in_array($post_before->post_name, $old_slugs) )		add_post_meta($post_id, '_wp_old_slug', $post_before->post_name);	// if the new slug was used previously, delete it from the list	if ( in_array($post->post_name, $old_slugs) )		delete_post_meta($post_id, '_wp_old_slug', $post->post_name);}/** * Retrieve the private post SQL based on capability. * * This function provides a standardized way to appropriately select on the * post_status of posts/pages. The function will return a piece of SQL code that * can be added to a WHERE clause; this SQL is constructed to allow all * published posts, and all private posts to which the user has access. * * It also allows plugins that define their own post type to control the cap by * using the hook 'pub_priv_sql_capability'. The plugin is expected to return * the capability the user must have to read the private post type. * * @since 2.2.0 * * @uses $user_ID * @uses apply_filters() Call 'pub_priv_sql_capability' filter for plugins with different post types. * * @param string $post_type currently only supports 'post' or 'page'. * @return string SQL code that can be added to a where clause. */function get_private_posts_cap_sql($post_type) {	return get_posts_by_author_sql($post_type, FALSE);}/** * Retrieve the post SQL based on capability, author, and type. * * See above for full description. * * @since 3.0.0 * @param string $post_type currently only supports 'post' or 'page'. * @param bool $full Optional.  Returns a full WHERE statement instead of just an 'andalso' term. * @param int $post_author Optional.  Query posts having a single author ID. * @return string SQL WHERE code that can be added to a query. */function get_posts_by_author_sql($post_type, $full = TRUE, $post_author = NULL) {	global $user_ID, $wpdb;	// Private posts	if ($post_type == 'post') {		$cap = 'read_private_posts';	// Private pages	} elseif ($post_type == 'page') {		$cap = 'read_private_pages';	// Dunno what it is, maybe plugins have their own post type?	} else {		$cap = '';		$cap = apply_filters('pub_priv_sql_capability', $cap);		if (empty($cap)) {			// We don't know what it is, filters don't change anything,			// so set the SQL up to return nothing.			return ' 1 = 0 ';		}	}	if ($full) {		if (is_null($post_author)) {			$sql = $wpdb->prepare('WHERE post_type = %s AND ', $post_type);		} else {			$sql = $wpdb->prepare('WHERE post_author = %d AND post_type = %s AND ', $post_author, $post_type);		}	} else {		$sql = '';	}	$sql .= "(post_status = 'publish'";	if (current_user_can($cap)) {		// Does the user have the capability to view private posts? Guess so.		$sql .= " OR post_status = 'private'";	} elseif (is_user_logged_in()) {		// Users can view their own private posts.		$id = (int) $user_ID;		if (is_null($post_author) || !$full) {			$sql .= " OR post_status = 'private' AND post_author = $id";		} elseif ($id == (int)$post_author) {			$sql .= " OR post_status = 'private'";		} // else none	} // else none	$sql .= ')';	return $sql;}/** * Retrieve the date that the last post was published. * * The server timezone is the default and is the difference between GMT and * server time. The 'blog' value is the date when the last post was posted. The * 'gmt' is when the last post was posted in GMT formatted date. * * @since 0.71 * * @uses $wpdb * @uses $blog_id * @uses apply_filters() Calls 'get_lastpostdate' filter * * @global mixed $cache_lastpostdate Stores the last post date * @global mixed $pagenow The current page being viewed * * @param string $timezone The location to get the time. Can be 'gmt', 'blog', or 'server'. * @return string The date of the last post. */function get_lastpostdate($timezone = 'server') {	global $cache_lastpostdate, $wpdb, $blog_id;	$add_seconds_server = date('Z');	if ( !isset($cache_lastpostdate[$blog_id][$timezone]) ) {		switch(strtolower($timezone)) {			case 'gmt':				$lastpostdate = $wpdb->get_var("SELECT post_date_gmt FROM $wpdb->posts WHERE post_status = 'publish' AND post_type = 'post' ORDER BY post_date_gmt DESC LIMIT 1");				break;			case 'blog':				$lastpostdate = $wpdb->get_var("SELECT post_date FROM $wpdb->posts WHERE post_status = 'publish' AND post_type = 'post' ORDER BY post_date_gmt DESC LIMIT 1");				break;			case 'server':				$lastpostdate = $wpdb->get_var("SELECT DATE_ADD(post_date_gmt, INTERVAL '$add_seconds_server' SECOND) FROM $wpdb->posts WHERE post_status = 'publish' AND post_type = 'post' ORDER BY post_date_gmt DESC LIMIT 1");				break;		}		$cache_lastpostdate[$blog_id][$timezone] = $lastpostdate;	} else {		$lastpostdate = $cache_lastpostdate[$blog_id][$timezone];	}	return apply_filters( 'get_lastpostdate', $lastpostdate, $timezone );}/** * Retrieve last post modified date depending on timezone. * * The server timezone is the default and is the difference between GMT and * server time. The 'blog' value is just when the last post was modified. The * 'gmt' is when the last post was modified in GMT time. * * @since 1.2.0 * @uses $wpdb * @uses $blog_id * @uses apply_filters() Calls 'get_lastpostmodified' filter * * @param string $timezone The location to get the time. Can be 'gmt', 'blog', or 'server'. * @return string The date the post was last modified. */function get_lastpostmodified($timezone = 'server') {	global $wpdb;	$add_seconds_server = date('Z');	$timezone = strtolower( $timezone );	$lastpostmodified = wp_cache_get( "lastpostmodified:$timezone", 'timeinfo' );	if ( $lastpostmodified )		return apply_filters( 'get_lastpostmodified', $lastpostmodified, $timezone );	switch ( strtolower($timezone) ) {		case 'gmt':			$lastpostmodified = $wpdb->get_var("SELECT post_modified_gmt FROM $wpdb->posts WHERE post_status = 'publish' AND post_type = 'post' ORDER BY post_modified_gmt DESC LIMIT 1");			break;		case 'blog':			$lastpostmodified = $wpdb->get_var("SELECT post_modified FROM $wpdb->posts WHERE post_status = 'publish' AND post_type = 'post' ORDER BY post_modified_gmt DESC LIMIT 1");			break;		case 'server':			$lastpostmodified = $wpdb->get_var("SELECT DATE_ADD(post_modified_gmt, INTERVAL '$add_seconds_server' SECOND) FROM $wpdb->posts WHERE post_status = 'publish' AND post_type = 'post' ORDER BY post_modified_gmt DESC LIMIT 1");			break;	}	$lastpostdate = get_lastpostdate($timezone);	if ( $lastpostdate > $lastpostmodified )		$lastpostmodified = $lastpostdate;	if ( $lastpostmodified )		wp_cache_set( "lastpostmodified:$timezone", $lastpostmodified, 'timeinfo' );	return apply_filters( 'get_lastpostmodified', $lastpostmodified, $timezone );}/** * Updates posts in cache. * * @usedby update_page_cache() Aliased by this function. * * @package WordPress * @subpackage Cache * @since 1.5.1 * * @param array $posts Array of post objects */function update_post_cache(&$posts) {	if ( !$posts )		return;	foreach ( $posts as $post )		wp_cache_add($post->ID, $post, 'posts');}/** * Will clean the post in the cache. * * Cleaning means delete from the cache of the post. Will call to clean the term * object cache associated with the post ID. * * clean_post_cache() will call itself recursively for each child post. * * This function not run if $_wp_suspend_cache_invalidation is not empty. See * wp_suspend_cache_invalidation(). * * @package WordPress * @subpackage Cache * @since 2.0.0 * * @uses do_action() Calls 'clean_post_cache' on $id before adding children (if any). * * @param int $id The Post ID in the cache to clean */function clean_post_cache($id) {	global $_wp_suspend_cache_invalidation, $wpdb;	if ( !empty($_wp_suspend_cache_invalidation) )		return;	$id = (int) $id;	wp_cache_delete($id, 'posts');	wp_cache_delete($id, 'post_meta');	clean_object_term_cache($id, 'post');	wp_cache_delete( 'wp_get_archives', 'general' );	do_action('clean_post_cache', $id);	if ( $children = $wpdb->get_col( $wpdb->prepare("SELECT ID FROM $wpdb->posts WHERE post_parent = %d", $id) ) ) {		foreach( $children as $cid )			clean_post_cache( $cid );	}	if ( is_multisite() )		wp_cache_delete( $wpdb->blogid . '-' . $id, 'global-posts' );}/** * Alias of update_post_cache(). * * @see update_post_cache() Posts and pages are the same, alias is intentional * * @package WordPress * @subpackage Cache * @since 1.5.1 * * @param array $pages list of page objects */function update_page_cache(&$pages) {	update_post_cache($pages);}/** * Will clean the page in the cache. * * Clean (read: delete) page from cache that matches $id. Will also clean cache * associated with 'all_page_ids' and 'get_pages'. * * @package WordPress * @subpackage Cache * @since 2.0.0 * * @uses do_action() Will call the 'clean_page_cache' hook action. * * @param int $id Page ID to clean */function clean_page_cache($id) {	clean_post_cache($id);	wp_cache_delete( 'all_page_ids', 'posts' );	wp_cache_delete( 'get_pages', 'posts' );	do_action('clean_page_cache', $id);}/** * Call major cache updating functions for list of Post objects. * * @package WordPress * @subpackage Cache * @since 1.5.0 * * @uses $wpdb * @uses update_post_cache() * @uses update_object_term_cache() * @uses update_postmeta_cache() * * @param array $posts Array of Post objects * @param string $post_type The post type of the posts in $posts. Default is 'post'. * @param bool $update_term_cache Whether to update the term cache. Default is true. * @param bool $update_meta_cache Whether to update the meta cache. Default is true. */function update_post_caches(&$posts, $post_type = 'post', $update_term_cache = true, $update_meta_cache = true) {	// No point in doing all this work if we didn't match any posts.	if ( !$posts )		return;	update_post_cache($posts);	$post_ids = array();	foreach ( $posts as $post )		$post_ids[] = $post->ID;	if ( empty($post_type) )		$post_type = 'post';	if ( !is_array($post_type) && 'any' != $post_type && $update_term_cache )		update_object_term_cache($post_ids, $post_type);	if ( $update_meta_cache )		update_postmeta_cache($post_ids);}/** * Updates metadata cache for list of post IDs. * * Performs SQL query to retrieve the metadata for the post IDs and updates the * metadata cache for the posts. Therefore, the functions, which call this * function, do not need to perform SQL queries on their own. * * @package WordPress * @subpackage Cache * @since 2.1.0 * * @uses $wpdb * * @param array $post_ids List of post IDs. * @return bool|array Returns false if there is nothing to update or an array of metadata. */function update_postmeta_cache($post_ids) {	return update_meta_cache('post', $post_ids);}/** * Will clean the attachment in the cache. * * Cleaning means delete from the cache. Optionaly will clean the term * object cache associated with the attachment ID. * * This function will not run if $_wp_suspend_cache_invalidation is not empty. See * wp_suspend_cache_invalidation(). * * @package WordPress * @subpackage Cache * @since 3.0.0 * * @uses do_action() Calls 'clean_attachment_cache' on $id. * * @param int $id The attachment ID in the cache to clean * @param bool $clean_terms optional. Whether to clean terms cache */function clean_attachment_cache($id, $clean_terms = false) {	global $_wp_suspend_cache_invalidation;	if ( !empty($_wp_suspend_cache_invalidation) )		return;	$id = (int) $id;	wp_cache_delete($id, 'posts');	wp_cache_delete($id, 'post_meta');	if ( $clean_terms )		clean_object_term_cache($id, 'attachment');	do_action('clean_attachment_cache', $id);}//// Hooks///** * Hook for managing future post transitions to published. * * @since 2.3.0 * @access private * @uses $wpdb * @uses do_action() Calls 'private_to_published' on post ID if this is a 'private_to_published' call. * @uses wp_clear_scheduled_hook() with 'publish_future_post' and post ID. * * @param string $new_status New post status * @param string $old_status Previous post status * @param object $post Object type containing the post information */function _transition_post_status($new_status, $old_status, $post) {	global $wpdb;	if ( $old_status != 'publish' && $new_status == 'publish' ) {		// Reset GUID if transitioning to publish and it is empty		if ( '' == get_the_guid($post->ID) )			$wpdb->update( $wpdb->posts, array( 'guid' => get_permalink( $post->ID ) ), array( 'ID' => $post->ID ) );		do_action('private_to_published', $post->ID);  // Deprecated, use private_to_publish	}	// If published posts changed clear the lastpostmodified cache	if ( 'publish' == $new_status || 'publish' == $old_status) {		wp_cache_delete( 'lastpostmodified:server', 'timeinfo' );		wp_cache_delete( 'lastpostmodified:gmt',    'timeinfo' );		wp_cache_delete( 'lastpostmodified:blog',   'timeinfo' );	}	// Always clears the hook in case the post status bounced from future to draft.	wp_clear_scheduled_hook('publish_future_post', array( $post->ID ) );}/** * Hook used to schedule publication for a post marked for the future. * * The $post properties used and must exist are 'ID' and 'post_date_gmt'. * * @since 2.3.0 * @access private * * @param int $deprecated Not used. Can be set to null. Never implemented. *   Not marked as deprecated with _deprecated_argument() as it conflicts with *   wp_transition_post_status() and the default filter for _future_post_hook(). * @param object $post Object type containing the post information */function _future_post_hook( $deprecated = '', $post ) {	wp_clear_scheduled_hook( 'publish_future_post', array( $post->ID ) );	wp_schedule_single_event( strtotime( get_gmt_from_date( $post->post_date ) . ' GMT') , 'publish_future_post', array( $post->ID ) );}/** * Hook to schedule pings and enclosures when a post is published. * * @since 2.3.0 * @access private * @uses $wpdb * @uses XMLRPC_REQUEST and APP_REQUEST constants. * @uses do_action() Calls 'xmlprc_publish_post' on post ID if XMLRPC_REQUEST is defined. * @uses do_action() Calls 'app_publish_post' on post ID if APP_REQUEST is defined. * * @param int $post_id The ID in the database table of the post being published */function _publish_post_hook($post_id) {	global $wpdb;	if ( defined('XMLRPC_REQUEST') )		do_action('xmlrpc_publish_post', $post_id);	if ( defined('APP_REQUEST') )		do_action('app_publish_post', $post_id);	if ( defined('WP_IMPORTING') )		return;	$data = array( 'post_id' => $post_id, 'meta_value' => '1' );	if ( get_option('default_pingback_flag') ) {		$wpdb->insert( $wpdb->postmeta, $data + array( 'meta_key' => '_pingme' ) );		do_action( 'added_postmeta', $wpdb->insert_id, $post_id, '_pingme', 1 );	}	$wpdb->insert( $wpdb->postmeta, $data + array( 'meta_key' => '_encloseme' ) );	do_action( 'added_postmeta', $wpdb->insert_id, $post_id, '_encloseme', 1 );	wp_schedule_single_event(time(), 'do_pings');}/** * Hook used to prevent page/post cache and rewrite rules from staying dirty. * * Does two things. If the post is a page and has a template then it will * update/add that template to the meta. For both pages and posts, it will clean * the post cache to make sure that the cache updates to the changes done * recently. For pages, the rewrite rules of WordPress are flushed to allow for * any changes. * * The $post parameter, only uses 'post_type' property and 'page_template' * property. * * @since 2.3.0 * @access private * @uses $wp_rewrite Flushes Rewrite Rules. * * @param int $post_id The ID in the database table for the $post * @param object $post Object type containing the post information */function _save_post_hook($post_id, $post) {	if ( $post->post_type == 'page' ) {		clean_page_cache($post_id);		// Avoid flushing rules for every post during import.		if ( !defined('WP_IMPORTING') ) {			global $wp_rewrite;			$wp_rewrite->flush_rules(false);		}	} else {		clean_post_cache($post_id);	}}/** * Retrieve post ancestors and append to post ancestors property. * * Will only retrieve ancestors once, if property is already set, then nothing * will be done. If there is not a parent post, or post ID and post parent ID * are the same then nothing will be done. * * The parameter is passed by reference, so nothing needs to be returned. The * property will be updated and can be referenced after the function is * complete. The post parent will be an ancestor and the parent of the post * parent will be an ancestor. There will only be two ancestors at the most. * * @since unknown * @access private * @uses $wpdb * * @param object $_post Post data. * @return null When nothing needs to be done. */function _get_post_ancestors(&$_post) {	global $wpdb;	if ( isset($_post->ancestors) )		return;	$_post->ancestors = array();	if ( empty($_post->post_parent) || $_post->ID == $_post->post_parent )		return;	$id = $_post->ancestors[] = $_post->post_parent;	while ( $ancestor = $wpdb->get_var( $wpdb->prepare("SELECT `post_parent` FROM $wpdb->posts WHERE ID = %d LIMIT 1", $id) ) ) {		if ( $id == $ancestor )			break;		$id = $_post->ancestors[] = $ancestor;	}}/** * Determines which fields of posts are to be saved in revisions. * * Does two things. If passed a post *array*, it will return a post array ready * to be insterted into the posts table as a post revision. Otherwise, returns * an array whose keys are the post fields to be saved for post revisions. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * @access private * @uses apply_filters() Calls '_wp_post_revision_fields' on 'title', 'content' and 'excerpt' fields. * * @param array $post Optional a post array to be processed for insertion as a post revision. * @param bool $autosave optional Is the revision an autosave? * @return array Post array ready to be inserted as a post revision or array of fields that can be versioned. */function _wp_post_revision_fields( $post = null, $autosave = false ) {	static $fields = false;	if ( !$fields ) {		// Allow these to be versioned		$fields = array(			'post_title' => __( 'Title' ),			'post_content' => __( 'Content' ),			'post_excerpt' => __( 'Excerpt' ),		);		// Runs only once		$fields = apply_filters( '_wp_post_revision_fields', $fields );		// WP uses these internally either in versioning or elsewhere - they cannot be versioned		foreach ( array( 'ID', 'post_name', 'post_parent', 'post_date', 'post_date_gmt', 'post_status', 'post_type', 'comment_count', 'post_author' ) as $protect )			unset( $fields[$protect] );	}	if ( !is_array($post) )		return $fields;	$return = array();	foreach ( array_intersect( array_keys( $post ), array_keys( $fields ) ) as $field )		$return[$field] = $post[$field];	$return['post_parent']   = $post['ID'];	$return['post_status']   = 'inherit';	$return['post_type']     = 'revision';	$return['post_name']     = $autosave ? "$post[ID]-autosave" : "$post[ID]-revision";	$return['post_date']     = isset($post['post_modified']) ? $post['post_modified'] : '';	$return['post_date_gmt'] = isset($post['post_modified_gmt']) ? $post['post_modified_gmt'] : '';	return $return;}/** * Saves an already existing post as a post revision. * * Typically used immediately prior to post updates. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @uses _wp_put_post_revision() * * @param int $post_id The ID of the post to save as a revision. * @return mixed Null or 0 if error, new revision ID, if success. */function wp_save_post_revision( $post_id ) {	// We do autosaves manually with wp_create_post_autosave()	if ( defined( 'DOING_AUTOSAVE' ) && DOING_AUTOSAVE )		return;	// WP_POST_REVISIONS = 0, false	if ( ! WP_POST_REVISIONS )		return;	if ( !$post = get_post( $post_id, ARRAY_A ) )		return;	if ( !post_type_supports($post['post_type'], 'revisions') )		return;	$return = _wp_put_post_revision( $post );	// WP_POST_REVISIONS = true (default), -1	if ( !is_numeric( WP_POST_REVISIONS ) || WP_POST_REVISIONS < 0 )		return $return;	// all revisions and (possibly) one autosave	$revisions = wp_get_post_revisions( $post_id, array( 'order' => 'ASC' ) );	// WP_POST_REVISIONS = (int) (# of autosaves to save)	$delete = count($revisions) - WP_POST_REVISIONS;	if ( $delete < 1 )		return $return;	$revisions = array_slice( $revisions, 0, $delete );	for ( $i = 0; isset($revisions[$i]); $i++ ) {		if ( false !== strpos( $revisions[$i]->post_name, 'autosave' ) )			continue;		wp_delete_post_revision( $revisions[$i]->ID );	}	return $return;}/** * Retrieve the autosaved data of the specified post. * * Returns a post object containing the information that was autosaved for the * specified post. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @param int $post_id The post ID. * @return object|bool The autosaved data or false on failure or when no autosave exists. */function wp_get_post_autosave( $post_id ) {	if ( !$post = get_post( $post_id ) )		return false;	$q = array(		'name' => "{$post->ID}-autosave",		'post_parent' => $post->ID,		'post_type' => 'revision',		'post_status' => 'inherit'	);	// Use WP_Query so that the result gets cached	$autosave_query = new WP_Query;	add_action( 'parse_query', '_wp_get_post_autosave_hack' );	$autosave = $autosave_query->query( $q );	remove_action( 'parse_query', '_wp_get_post_autosave_hack' );	if ( $autosave && is_array($autosave) && is_object($autosave[0]) )		return $autosave[0];	return false;}/** * Internally used to hack WP_Query into submission. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @param object $query WP_Query object */function _wp_get_post_autosave_hack( $query ) {	$query->is_single = false;}/** * Determines if the specified post is a revision. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @param int|object $post Post ID or post object. * @return bool|int False if not a revision, ID of revision's parent otherwise. */function wp_is_post_revision( $post ) {	if ( !$post = wp_get_post_revision( $post ) )		return false;	return (int) $post->post_parent;}/** * Determines if the specified post is an autosave. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @param int|object $post Post ID or post object. * @return bool|int False if not a revision, ID of autosave's parent otherwise */function wp_is_post_autosave( $post ) {	if ( !$post = wp_get_post_revision( $post ) )		return false;	if ( "{$post->post_parent}-autosave" !== $post->post_name )		return false;	return (int) $post->post_parent;}/** * Inserts post data into the posts table as a post revision. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @uses wp_insert_post() * * @param int|object|array $post Post ID, post object OR post array. * @param bool $autosave Optional. Is the revision an autosave? * @return mixed Null or 0 if error, new revision ID if success. */function _wp_put_post_revision( $post = null, $autosave = false ) {	if ( is_object($post) )		$post = get_object_vars( $post );	elseif ( !is_array($post) )		$post = get_post($post, ARRAY_A);	if ( !$post || empty($post['ID']) )		return;	if ( isset($post['post_type']) && 'revision' == $post['post_type'] )		return new WP_Error( 'post_type', __( 'Cannot create a revision of a revision' ) );	$post = _wp_post_revision_fields( $post, $autosave );	$post = add_magic_quotes($post); //since data is from db	$revision_id = wp_insert_post( $post );	if ( is_wp_error($revision_id) )		return $revision_id;	if ( $revision_id )		do_action( '_wp_put_post_revision', $revision_id );	return $revision_id;}/** * Gets a post revision. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @uses get_post() * * @param int|object $post Post ID or post object * @param string $output Optional. OBJECT, ARRAY_A, or ARRAY_N. * @param string $filter Optional sanitation filter.  @see sanitize_post() * @return mixed Null if error or post object if success */function &wp_get_post_revision(&$post, $output = OBJECT, $filter = 'raw') {	$null = null;	if ( !$revision = get_post( $post, OBJECT, $filter ) )		return $revision;	if ( 'revision' !== $revision->post_type )		return $null;	if ( $output == OBJECT ) {		return $revision;	} elseif ( $output == ARRAY_A ) {		$_revision = get_object_vars($revision);		return $_revision;	} elseif ( $output == ARRAY_N ) {		$_revision = array_values(get_object_vars($revision));		return $_revision;	}	return $revision;}/** * Restores a post to the specified revision. * * Can restore a past revision using all fields of the post revision, or only selected fields. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @uses wp_get_post_revision() * @uses wp_update_post() * @uses do_action() Calls 'wp_restore_post_revision' on post ID and revision ID if wp_update_post() *  is successful. * * @param int|object $revision_id Revision ID or revision object. * @param array $fields Optional. What fields to restore from. Defaults to all. * @return mixed Null if error, false if no fields to restore, (int) post ID if success. */function wp_restore_post_revision( $revision_id, $fields = null ) {	if ( !$revision = wp_get_post_revision( $revision_id, ARRAY_A ) )		return $revision;	if ( !is_array( $fields ) )		$fields = array_keys( _wp_post_revision_fields() );	$update = array();	foreach( array_intersect( array_keys( $revision ), $fields ) as $field )		$update[$field] = $revision[$field];	if ( !$update )		return false;	$update['ID'] = $revision['post_parent'];	$update = add_magic_quotes( $update ); //since data is from db	$post_id = wp_update_post( $update );	if ( is_wp_error( $post_id ) )		return $post_id;	if ( $post_id )		do_action( 'wp_restore_post_revision', $post_id, $revision['ID'] );	return $post_id;}/** * Deletes a revision. * * Deletes the row from the posts table corresponding to the specified revision. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @uses wp_get_post_revision() * @uses wp_delete_post() * * @param int|object $revision_id Revision ID or revision object. * @param array $fields Optional. What fields to restore from.  Defaults to all. * @return mixed Null if error, false if no fields to restore, (int) post ID if success. */function wp_delete_post_revision( $revision_id ) {	if ( !$revision = wp_get_post_revision( $revision_id ) )		return $revision;	$delete = wp_delete_post( $revision->ID );	if ( is_wp_error( $delete ) )		return $delete;	if ( $delete )		do_action( 'wp_delete_post_revision', $revision->ID, $revision );	return $delete;}/** * Returns all revisions of specified post. * * @package WordPress * @subpackage Post_Revisions * @since 2.6.0 * * @uses get_children() * * @param int|object $post_id Post ID or post object * @return array empty if no revisions */function wp_get_post_revisions( $post_id = 0, $args = null ) {	if ( ! WP_POST_REVISIONS )		return array();	if ( ( !$post = get_post( $post_id ) ) || empty( $post->ID ) )		return array();	$defaults = array( 'order' => 'DESC', 'orderby' => 'date' );	$args = wp_parse_args( $args, $defaults );	$args = array_merge( $args, array( 'post_parent' => $post->ID, 'post_type' => 'revision', 'post_status' => 'inherit' ) );	if ( !$revisions = get_children( $args ) )		return array();	return $revisions;}function _set_preview($post) {	if ( ! is_object($post) )		return $post;	$preview = wp_get_post_autosave($post->ID);	if ( ! is_object($preview) )		return $post;	$preview = sanitize_post($preview);	$post->post_content = $preview->post_content;	$post->post_title = $preview->post_title;	$post->post_excerpt = $preview->post_excerpt;	return $post;}function _show_post_preview() {	if ( isset($_GET['preview_id']) && isset($_GET['preview_nonce']) ) {		$id = (int) $_GET['preview_id'];		if ( false == wp_verify_nonce( $_GET['preview_nonce'], 'post_preview_' . $id ) )			wp_die( __('You do not have permission to preview drafts.') );		add_filter('the_preview', '_set_preview');	}}
