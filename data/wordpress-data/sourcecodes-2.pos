<?php/** * HTML/XHTML filter that only allows some elements and attributes * * Added wp_ prefix to avoid conflicts with existing kses users * * @version 0.2.2 * @copyright (C) 2002, 2003, 2005 * @author Ulf Harnhammar <metaur@users.sourceforge.net> * * @package External * @subpackage KSES * * @internal * *** CONTACT INFORMATION *** * E-mail:      metaur at users dot sourceforge dot net * Web page:    http://sourceforge.net/projects/kses * Paper mail:  Ulf Harnhammar *              Ymergatan 17 C *              753 25  Uppsala *              SWEDEN * * [kses strips evil scripts!] *//** * You can override this in a plugin. * * @since 1.2.0 */if ( ! defined( 'CUSTOM_TAGS' ) )	define( 'CUSTOM_TAGS', false );if ( ! CUSTOM_TAGS ) {	/**	 * Kses global for default allowable HTML tags.	 *	 * Can be override by using CUSTOM_TAGS constant.	 *	 * @global array $allowedposttags	 * @since 2.0.0	 */	$allowedposttags = array(		'address' => array(),		'a' => array(			'class' => array (),			'href' => array (),			'id' => array (),			'title' => array (),			'rel' => array (),			'rev' => array (),			'name' => array (),			'target' => array()),		'abbr' => array(			'class' => array (),			'title' => array ()),		'acronym' => array(			'title' => array ()),		'article' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array(),		),		'aside' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array(),		),		'b' => array(),		'big' => array(),		'blockquote' => array(			'id' => array (),			'cite' => array (),			'class' => array(),			'lang' => array(),			'xml:lang' => array()),		'br' => array (			'class' => array ()),		'button' => array(			'disabled' => array (),			'name' => array (),			'type' => array (),			'value' => array ()),		'caption' => array(			'align' => array (),			'class' => array ()),		'cite' => array (			'class' => array(),			'dir' => array(),			'lang' => array(),			'title' => array ()),		'code' => array (			'style' => array()),		'col' => array(			'align' => array (),			'char' => array (),			'charoff' => array (),			'span' => array (),			'dir' => array(),			'style' => array (),			'valign' => array (),			'width' => array ()),		'del' => array(			'datetime' => array ()),		'dd' => array(),		'details' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'open' => array (),			'style' => array (),			'xml:lang' => array(),		),		'div' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array()),		'dl' => array(),		'dt' => array(),		'em' => array(),		'fieldset' => array(),		'figure' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array(),		),		'figcaption' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array(),		),		'font' => array(			'color' => array (),			'face' => array (),			'size' => array ()),		'footer' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array(),		),		'form' => array(			'action' => array (),			'accept' => array (),			'accept-charset' => array (),			'enctype' => array (),			'method' => array (),			'name' => array (),			'target' => array ()),		'h1' => array(			'align' => array (),			'class' => array (),			'id'    => array (),			'style' => array ()),		'h2' => array (			'align' => array (),			'class' => array (),			'id'    => array (),			'style' => array ()),		'h3' => array (			'align' => array (),			'class' => array (),			'id'    => array (),			'style' => array ()),		'h4' => array (			'align' => array (),			'class' => array (),			'id'    => array (),			'style' => array ()),		'h5' => array (			'align' => array (),			'class' => array (),			'id'    => array (),			'style' => array ()),		'h6' => array (			'align' => array (),			'class' => array (),			'id'    => array (),			'style' => array ()),		'header' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array(),		),		'hgroup' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array(),		),		'hr' => array (			'align' => array (),			'class' => array (),			'noshade' => array (),			'size' => array (),			'width' => array ()),		'i' => array(),		'img' => array(			'alt' => array (),			'align' => array (),			'border' => array (),			'class' => array (),			'height' => array (),			'hspace' => array (),			'longdesc' => array (),			'vspace' => array (),			'src' => array (),			'style' => array (),			'width' => array ()),		'ins' => array(			'datetime' => array (),			'cite' => array ()),		'kbd' => array(),		'label' => array(			'for' => array ()),		'legend' => array(			'align' => array ()),		'li' => array (			'align' => array (),			'class' => array ()),		'menu' => array (			'class' => array (),			'style' => array (),			'type' => array ()),		'nav' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array(),		),		'p' => array(			'class' => array (),			'align' => array (),			'dir' => array(),			'lang' => array(),			'style' => array (),			'xml:lang' => array()),		'pre' => array(			'style' => array(),			'width' => array ()),		'q' => array(			'cite' => array ()),		's' => array(),		'span' => array (			'class' => array (),			'dir' => array (),			'align' => array (),			'lang' => array (),			'style' => array (),			'title' => array (),			'xml:lang' => array()),		'section' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array(),		),		'strike' => array(),		'strong' => array(),		'sub' => array(),		'summary' => array(			'align' => array (),			'class' => array (),			'dir' => array (),			'lang' => array(),			'style' => array (),			'xml:lang' => array(),		),		'sup' => array(),		'table' => array(			'align' => array (),			'bgcolor' => array (),			'border' => array (),			'cellpadding' => array (),			'cellspacing' => array (),			'class' => array (),			'dir' => array(),			'id' => array(),			'rules' => array (),			'style' => array (),			'summary' => array (),			'width' => array ()),		'tbody' => array(			'align' => array (),			'char' => array (),			'charoff' => array (),			'valign' => array ()),		'td' => array(			'abbr' => array (),			'align' => array (),			'axis' => array (),			'bgcolor' => array (),			'char' => array (),			'charoff' => array (),			'class' => array (),			'colspan' => array (),			'dir' => array(),			'headers' => array (),			'height' => array (),			'nowrap' => array (),			'rowspan' => array (),			'scope' => array (),			'style' => array (),			'valign' => array (),			'width' => array ()),		'textarea' => array(			'cols' => array (),			'rows' => array (),			'disabled' => array (),			'name' => array (),			'readonly' => array ()),		'tfoot' => array(			'align' => array (),			'char' => array (),			'class' => array (),			'charoff' => array (),			'valign' => array ()),		'th' => array(			'abbr' => array (),			'align' => array (),			'axis' => array (),			'bgcolor' => array (),			'char' => array (),			'charoff' => array (),			'class' => array (),			'colspan' => array (),			'headers' => array (),			'height' => array (),			'nowrap' => array (),			'rowspan' => array (),			'scope' => array (),			'valign' => array (),			'width' => array ()),		'thead' => array(			'align' => array (),			'char' => array (),			'charoff' => array (),			'class' => array (),			'valign' => array ()),		'title' => array(),		'tr' => array(			'align' => array (),			'bgcolor' => array (),			'char' => array (),			'charoff' => array (),			'class' => array (),			'style' => array (),			'valign' => array ()),		'tt' => array(),		'u' => array(),		'ul' => array (			'class' => array (),			'style' => array (),			'type' => array ()),		'ol' => array (			'class' => array (),			'start' => array (),			'style' => array (),			'type' => array ()),		'var' => array ());	/**	 * Kses allowed HTML elements.	 *	 * @global array $allowedtags	 * @since 1.0.0	 */	$allowedtags = array(		'a' => array(			'href' => array (),			'title' => array ()),		'abbr' => array(			'title' => array ()),		'acronym' => array(			'title' => array ()),		'b' => array(),		'blockquote' => array(			'cite' => array ()),		//	'br' => array(),		'cite' => array (),		'code' => array(),		'del' => array(			'datetime' => array ()),		//	'dd' => array(),		//	'dl' => array(),		//	'dt' => array(),		'em' => array (), 'i' => array (),		//	'ins' => array('datetime' => array(), 'cite' => array()),		//	'li' => array(),		//	'ol' => array(),		//	'p' => array(),		'q' => array(			'cite' => array ()),		'strike' => array(),		'strong' => array(),		//	'sub' => array(),		//	'sup' => array(),		//	'u' => array(),		//	'ul' => array(),	);	$allowedentitynames = array(		'nbsp',    'iexcl',  'cent',    'pound',  'curren', 'yen',		'brvbar',  'sect',   'uml',     'copy',   'ordf',   'laquo',		'not',     'shy',    'reg',     'macr',   'deg',    'plusmn',		'acute',   'micro',  'para',    'middot', 'cedil',  'ordm',		'raquo',   'iquest', 'Agrave',  'Aacute', 'Acirc',  'Atilde',		'Auml',    'Aring',  'AElig',   'Ccedil', 'Egrave', 'Eacute',		'Ecirc',   'Euml',   'Igrave',  'Iacute', 'Icirc',  'Iuml',		'ETH',     'Ntilde', 'Ograve',  'Oacute', 'Ocirc',  'Otilde',		'Ouml',    'times',  'Oslash',  'Ugrave', 'Uacute', 'Ucirc',		'Uuml',    'Yacute', 'THORN',   'szlig',  'agrave', 'aacute',		'acirc',   'atilde', 'auml',    'aring',  'aelig',  'ccedil',		'egrave',  'eacute', 'ecirc',   'euml',   'igrave', 'iacute',		'icirc',   'iuml',   'eth',     'ntilde', 'ograve', 'oacute',		'ocirc',   'otilde', 'ouml',    'divide', 'oslash', 'ugrave',		'uacute',  'ucirc',  'uuml',    'yacute', 'thorn',  'yuml',		'quot',    'amp',    'lt',      'gt',     'apos',   'OElig',		'oelig',   'Scaron', 'scaron',  'Yuml',   'circ',   'tilde',		'ensp',    'emsp',   'thinsp',  'zwnj',   'zwj',    'lrm',		'rlm',     'ndash',  'mdash',   'lsquo',  'rsquo',  'sbquo',		'ldquo',   'rdquo',  'bdquo',   'dagger', 'Dagger', 'permil',		'lsaquo',  'rsaquo', 'euro',    'fnof',   'Alpha',  'Beta',		'Gamma',   'Delta',  'Epsilon', 'Zeta',   'Eta',    'Theta',		'Iota',    'Kappa',  'Lambda',  'Mu',     'Nu',     'Xi',		'Omicron', 'Pi',     'Rho',     'Sigma',  'Tau',    'Upsilon',		'Phi',     'Chi',    'Psi',     'Omega',  'alpha',  'beta',		'gamma',   'delta',  'epsilon', 'zeta',   'eta',    'theta',		'iota',    'kappa',  'lambda',  'mu',     'nu',     'xi',		'omicron', 'pi',     'rho',     'sigmaf', 'sigma',  'tau',		'upsilon', 'phi',    'chi',     'psi',    'omega',  'thetasym',		'upsih',   'piv',    'bull',    'hellip', 'prime',  'Prime',		'oline',   'frasl',  'weierp',  'image',  'real',   'trade',		'alefsym', 'larr',   'uarr',    'rarr',   'darr',   'harr',		'crarr',   'lArr',   'uArr',    'rArr',   'dArr',   'hArr',		'forall',  'part',   'exist',   'empty',  'nabla',  'isin',		'notin',   'ni',     'prod',    'sum',    'minus',  'lowast',		'radic',   'prop',   'infin',   'ang',    'and',    'or',		'cap',     'cup',    'int',     'sim',    'cong',   'asymp',		'ne',      'equiv',  'le',      'ge',     'sub',    'sup',		'nsub',    'sube',   'supe',    'oplus',  'otimes', 'perp',		'sdot',    'lceil',  'rceil',   'lfloor', 'rfloor', 'lang',		'rang',    'loz',    'spades',  'clubs',  'hearts', 'diams',	);}/** * Filters content and keeps only allowable HTML elements. * * This function makes sure that only the allowed HTML element names, attribute * names and attribute values plus only sane HTML entities will occur in * $string. You have to remove any slashes from PHP's magic quotes before you * call this function. * * The default allowed protocols are 'http', 'https', 'ftp', 'mailto', 'news', * 'irc', 'gopher', 'nntp', 'feed', 'telnet, 'mms', 'rtsp' and 'svn'. This * covers all common link protocols, except for 'javascript' which should not * be allowed for untrusted users. * * @since 1.0.0 * * @param string $string Content to filter through kses * @param array $allowed_html List of allowed HTML elements * @param array $allowed_protocols Optional. Allowed protocol in links. * @return string Filtered content with only allowed HTML elements */function wp_kses($string, $allowed_html, $allowed_protocols = array ()) {	$allowed_protocols = wp_parse_args( $allowed_protocols, apply_filters('kses_allowed_protocols', array ('http', 'https', 'ftp', 'ftps', 'mailto', 'news', 'irc', 'gopher', 'nntp', 'feed', 'telnet', 'mms', 'rtsp', 'svn') ));	$string = wp_kses_no_null($string);	$string = wp_kses_js_entities($string);	$string = wp_kses_normalize_entities($string);	$allowed_html_fixed = wp_kses_array_lc($allowed_html);	$string = wp_kses_hook($string, $allowed_html_fixed, $allowed_protocols); // WP changed the order of these funcs and added args to wp_kses_hook	return wp_kses_split($string, $allowed_html_fixed, $allowed_protocols);}/** * You add any kses hooks here. * * There is currently only one kses WordPress hook and it is called here. All * parameters are passed to the hooks and expected to recieve a string. * * @since 1.0.0 * * @param string $string Content to filter through kses * @param array $allowed_html List of allowed HTML elements * @param array $allowed_protocols Allowed protocol in links * @return string Filtered content through 'pre_kses' hook */function wp_kses_hook($string, $allowed_html, $allowed_protocols) {	$string = apply_filters('pre_kses', $string, $allowed_html, $allowed_protocols);	return $string;}/** * This function returns kses' version number. * * @since 1.0.0 * * @return string KSES Version Number */function wp_kses_version() {	return '0.2.2';}/** * Searches for HTML tags, no matter how malformed. * * It also matches stray ">" characters. * * @since 1.0.0 * * @param string $string Content to filter * @param array $allowed_html Allowed HTML elements * @param array $allowed_protocols Allowed protocols to keep * @return string Content with fixed HTML tags */function wp_kses_split($string, $allowed_html, $allowed_protocols) {	global $pass_allowed_html, $pass_allowed_protocols;	$pass_allowed_html = $allowed_html;	$pass_allowed_protocols = $allowed_protocols;	return preg_replace_callback('%((<!--.*?(-->|$))|(<[^>]*(>|$)|>))%',		create_function('$match', 'global $pass_allowed_html, $pass_allowed_protocols; return wp_kses_split2($match[1], $pass_allowed_html, $pass_allowed_protocols);'), $string);}/** * Callback for wp_kses_split for fixing malformed HTML tags. * * This function does a lot of work. It rejects some very malformed things like * <:::>. It returns an empty string, if the element isn't allowed (look ma, no * strip_tags()!). Otherwise it splits the tag into an element and an attribute * list. * * After the tag is split into an element and an attribute list, it is run * through another filter which will remove illegal attributes and once that is * completed, will be returned. * * @access private * @since 1.0.0 * @uses wp_kses_attr() * * @param string $string Content to filter * @param array $allowed_html Allowed HTML elements * @param array $allowed_protocols Allowed protocols to keep * @return string Fixed HTML element */function wp_kses_split2($string, $allowed_html, $allowed_protocols) {	$string = wp_kses_stripslashes($string);	if (substr($string, 0, 1) != '<')		return '&gt;';	# It matched a ">" character	if (preg_match('%^<!--(.*?)(-->)?$%', $string, $matches)) {		$string = str_replace(array('<!--', '-->'), '', $matches[1]);		while ( $string != $newstring = wp_kses($string, $allowed_html, $allowed_protocols) )			$string = $newstring;		if ( $string == '' )			return '';		// prevent multiple dashes in comments		$string = preg_replace('/--+/', '-', $string);		// prevent three dashes closing a comment		$string = preg_replace('/-$/', '', $string);		return "<!--{$string}-->";	}	# Allow HTML comments	if (!preg_match('%^<\s*(/\s*)?([a-zA-Z0-9]+)([^>]*)>?$%', $string, $matches))		return '';	# It's seriously malformed	$slash = trim($matches[1]);	$elem = $matches[2];	$attrlist = $matches[3];	if (!@isset($allowed_html[strtolower($elem)]))		return '';	# They are using a not allowed HTML element	if ($slash != '')		return "<$slash$elem>";	# No attributes are allowed for closing elements	return wp_kses_attr("$slash$elem", $attrlist, $allowed_html, $allowed_protocols);}/** * Removes all attributes, if none are allowed for this element. * * If some are allowed it calls wp_kses_hair() to split them further, and then * it builds up new HTML code from the data that kses_hair() returns. It also * removes "<" and ">" characters, if there are any left. One more thing it does * is to check if the tag has a closing XHTML slash, and if it does, it puts one * in the returned code as well. * * @since 1.0.0 * * @param string $element HTML element/tag * @param string $attr HTML attributes from HTML element to closing HTML element tag * @param array $allowed_html Allowed HTML elements * @param array $allowed_protocols Allowed protocols to keep * @return string Sanitized HTML element */function wp_kses_attr($element, $attr, $allowed_html, $allowed_protocols) {	# Is there a closing XHTML slash at the end of the attributes?	$xhtml_slash = '';	if (preg_match('%\s*/\s*$%', $attr))		$xhtml_slash = ' /';	# Are any attributes allowed at all for this element?	if (@ count($allowed_html[strtolower($element)]) == 0)		return "<$element$xhtml_slash>";	# Split it	$attrarr = wp_kses_hair($attr, $allowed_protocols);	# Go through $attrarr, and save the allowed attributes for this element	# in $attr2	$attr2 = '';	foreach ($attrarr as $arreach) {		if (!@ isset ($allowed_html[strtolower($element)][strtolower($arreach['name'])]))			continue; # the attribute is not allowed		$current = $allowed_html[strtolower($element)][strtolower($arreach['name'])];		if ($current == '')			continue; # the attribute is not allowed		if (!is_array($current))			$attr2 .= ' '.$arreach['whole'];		# there are no checks		else {			# there are some checks			$ok = true;			foreach ($current as $currkey => $currval)				if (!wp_kses_check_attr_val($arreach['value'], $arreach['vless'], $currkey, $currval)) {					$ok = false;					break;				}			if ( $arreach['name'] == 'style' ) {				$orig_value = $arreach['value'];				$value = safecss_filter_attr($orig_value);				if ( empty($value) )					continue;				$arreach['value'] = $value;				$arreach['whole'] = str_replace($orig_value, $value, $arreach['whole']);			}			if ($ok)				$attr2 .= ' '.$arreach['whole']; # it passed them		} # if !is_array($current)	} # foreach	# Remove any "<" or ">" characters	$attr2 = preg_replace('/[<>]/', '', $attr2);	return "<$element$attr2$xhtml_slash>";}/** * Builds an attribute list from string containing attributes. * * This function does a lot of work. It parses an attribute list into an array * with attribute data, and tries to do the right thing even if it gets weird * input. It will add quotes around attribute values that don't have any quotes * or apostrophes around them, to make it easier to produce HTML code that will * conform to W3C's HTML specification. It will also remove bad URL protocols * from attribute values.  It also reduces duplicate attributes by using the * attribute defined first (foo='bar' foo='baz' will result in foo='bar'). * * @since 1.0.0 * * @param string $attr Attribute list from HTML element to closing HTML element tag * @param array $allowed_protocols Allowed protocols to keep * @return array List of attributes after parsing */function wp_kses_hair($attr, $allowed_protocols) {	$attrarr = array ();	$mode = 0;	$attrname = '';	$uris = array('xmlns', 'profile', 'href', 'src', 'cite', 'classid', 'codebase', 'data', 'usemap', 'longdesc', 'action');	# Loop through the whole attribute list	while (strlen($attr) != 0) {		$working = 0; # Was the last operation successful?		switch ($mode) {			case 0 : # attribute name, href for instance				if (preg_match('/^([-a-zA-Z]+)/', $attr, $match)) {					$attrname = $match[1];					$working = $mode = 1;					$attr = preg_replace('/^[-a-zA-Z]+/', '', $attr);				}				break;			case 1 : # equals sign or valueless ("selected")				if (preg_match('/^\s*=\s*/', $attr)) # equals sign					{					$working = 1;					$mode = 2;					$attr = preg_replace('/^\s*=\s*/', '', $attr);					break;				}				if (preg_match('/^\s+/', $attr)) # valueless					{					$working = 1;					$mode = 0;					if(FALSE === array_key_exists($attrname, $attrarr)) {						$attrarr[$attrname] = array ('name' => $attrname, 'value' => '', 'whole' => $attrname, 'vless' => 'y');					}					$attr = preg_replace('/^\s+/', '', $attr);				}				break;			case 2 : # attribute value, a URL after href= for instance				if (preg_match('%^"([^"]*)"(\s+|/?$)%', $attr, $match))					# "value"					{					$thisval = $match[1];					if ( in_array($attrname, $uris) )						$thisval = wp_kses_bad_protocol($thisval, $allowed_protocols);					if(FALSE === array_key_exists($attrname, $attrarr)) {						$attrarr[$attrname] = array ('name' => $attrname, 'value' => $thisval, 'whole' => "$attrname=\"$thisval\"", 'vless' => 'n');					}					$working = 1;					$mode = 0;					$attr = preg_replace('/^"[^"]*"(\s+|$)/', '', $attr);					break;				}				if (preg_match("%^'([^']*)'(\s+|/?$)%", $attr, $match))					# 'value'					{					$thisval = $match[1];					if ( in_array($attrname, $uris) )						$thisval = wp_kses_bad_protocol($thisval, $allowed_protocols);					if(FALSE === array_key_exists($attrname, $attrarr)) {						$attrarr[$attrname] = array ('name' => $attrname, 'value' => $thisval, 'whole' => "$attrname='$thisval'", 'vless' => 'n');					}					$working = 1;					$mode = 0;					$attr = preg_replace("/^'[^']*'(\s+|$)/", '', $attr);					break;				}				if (preg_match("%^([^\s\"']+)(\s+|/?$)%", $attr, $match))					# value					{					$thisval = $match[1];					if ( in_array($attrname, $uris) )						$thisval = wp_kses_bad_protocol($thisval, $allowed_protocols);					if(FALSE === array_key_exists($attrname, $attrarr)) {						$attrarr[$attrname] = array ('name' => $attrname, 'value' => $thisval, 'whole' => "$attrname=\"$thisval\"", 'vless' => 'n');					}					# We add quotes to conform to W3C's HTML spec.					$working = 1;					$mode = 0;					$attr = preg_replace("%^[^\s\"']+(\s+|$)%", '', $attr);				}				break;		} # switch		if ($working == 0) # not well formed, remove and try again		{			$attr = wp_kses_html_error($attr);			$mode = 0;		}	} # while	if ($mode == 1 && FALSE === array_key_exists($attrname, $attrarr))		# special case, for when the attribute list ends with a valueless		# attribute like "selected"		$attrarr[$attrname] = array ('name' => $attrname, 'value' => '', 'whole' => $attrname, 'vless' => 'y');	return $attrarr;}/** * Performs different checks for attribute values. * * The currently implemented checks are "maxlen", "minlen", "maxval", "minval" * and "valueless" with even more checks to come soon. * * @since 1.0.0 * * @param string $value Attribute value * @param string $vless Whether the value is valueless. Use 'y' or 'n' * @param string $checkname What $checkvalue is checking for. * @param mixed $checkvalue What constraint the value should pass * @return bool Whether check passes */function wp_kses_check_attr_val($value, $vless, $checkname, $checkvalue) {	$ok = true;	switch (strtolower($checkname)) {		case 'maxlen' :			# The maxlen check makes sure that the attribute value has a length not			# greater than the given value. This can be used to avoid Buffer Overflows			# in WWW clients and various Internet servers.			if (strlen($value) > $checkvalue)				$ok = false;			break;		case 'minlen' :			# The minlen check makes sure that the attribute value has a length not			# smaller than the given value.			if (strlen($value) < $checkvalue)				$ok = false;			break;		case 'maxval' :			# The maxval check does two things: it checks that the attribute value is			# an integer from 0 and up, without an excessive amount of zeroes or			# whitespace (to avoid Buffer Overflows). It also checks that the attribute			# value is not greater than the given value.			# This check can be used to avoid Denial of Service attacks.			if (!preg_match('/^\s{0,6}[0-9]{1,6}\s{0,6}$/', $value))				$ok = false;			if ($value > $checkvalue)				$ok = false;			break;		case 'minval' :			# The minval check checks that the attribute value is a positive integer,			# and that it is not smaller than the given value.			if (!preg_match('/^\s{0,6}[0-9]{1,6}\s{0,6}$/', $value))				$ok = false;			if ($value < $checkvalue)				$ok = false;			break;		case 'valueless' :			# The valueless check checks if the attribute has a value			# (like <a href="blah">) or not (<option selected>). If the given value			# is a "y" or a "Y", the attribute must not have a value.			# If the given value is an "n" or an "N", the attribute must have one.			if (strtolower($checkvalue) != $vless)				$ok = false;			break;	} # switch	return $ok;}/** * Sanitize string from bad protocols. * * This function removes all non-allowed protocols from the beginning of * $string. It ignores whitespace and the case of the letters, and it does * understand HTML entities. It does its work in a while loop, so it won't be * fooled by a string like "javascript:javascript:alert(57)". * * @since 1.0.0 * * @param string $string Content to filter bad protocols from * @param array $allowed_protocols Allowed protocols to keep * @return string Filtered content */function wp_kses_bad_protocol($string, $allowed_protocols) {	$string = wp_kses_no_null($string);	$string2 = $string.'a';	while ($string != $string2) {		$string2 = $string;		$string = wp_kses_bad_protocol_once($string, $allowed_protocols);	} # while	return $string;}/** * Removes any NULL characters in $string. * * @since 1.0.0 * * @param string $string * @return string */function wp_kses_no_null($string) {	$string = preg_replace('/\0+/', '', $string);	$string = preg_replace('/(\\\\0)+/', '', $string);	return $string;}/** * Strips slashes from in front of quotes. * * This function changes the character sequence  \"  to just  ". It leaves all * other slashes alone. It's really weird, but the quoting from * preg_replace(//e) seems to require this. * * @since 1.0.0 * * @param string $string String to strip slashes * @return string Fixed strings with quoted slashes */function wp_kses_stripslashes($string) {	return preg_replace('%\\\\"%', '"', $string);}/** * Goes through an array and changes the keys to all lower case. * * @since 1.0.0 * * @param array $inarray Unfiltered array * @return array Fixed array with all lowercase keys */function wp_kses_array_lc($inarray) {	$outarray = array ();	foreach ( (array) $inarray as $inkey => $inval) {		$outkey = strtolower($inkey);		$outarray[$outkey] = array ();		foreach ( (array) $inval as $inkey2 => $inval2) {			$outkey2 = strtolower($inkey2);			$outarray[$outkey][$outkey2] = $inval2;		} # foreach $inval	} # foreach $inarray	return $outarray;}/** * Removes the HTML JavaScript entities found in early versions of Netscape 4. * * @since 1.0.0 * * @param string $string * @return string */function wp_kses_js_entities($string) {	return preg_replace('%&\s*\{[^}]*(\}\s*;?|$)%', '', $string);}/** * Handles parsing errors in wp_kses_hair(). * * The general plan is to remove everything to and including some whitespace, * but it deals with quotes and apostrophes as well. * * @since 1.0.0 * * @param string $string * @return string */function wp_kses_html_error($string) {	return preg_replace('/^("[^"]*("|$)|\'[^\']*(\'|$)|\S)*\s*/', '', $string);}/** * Sanitizes content from bad protocols and other characters. * * This function searches for URL protocols at the beginning of $string, while * handling whitespace and HTML entities. * * @since 1.0.0 * * @param string $string Content to check for bad protocols * @param string $allowed_protocols Allowed protocols * @return string Sanitized content */function wp_kses_bad_protocol_once($string, $allowed_protocols) {	global $_kses_allowed_protocols;	$_kses_allowed_protocols = $allowed_protocols;	$string2 = preg_split('/:|&#58;|&#x3a;/i', $string, 2);	if ( isset($string2[1]) && !preg_match('%/\?%', $string2[0]) )		$string = wp_kses_bad_protocol_once2($string2[0]) . trim($string2[1]);	else		$string = preg_replace_callback('/^((&[^;]*;|[\sA-Za-z0-9])*)'.'(:|&#58;|&#[Xx]3[Aa];)\s*/', 'wp_kses_bad_protocol_once2', $string);	return $string;}/** * Callback for wp_kses_bad_protocol_once() regular expression. * * This function processes URL protocols, checks to see if they're in the * white-list or not, and returns different data depending on the answer. * * @access private * @since 1.0.0 * * @param mixed $matches string or preg_replace_callback() matches array to check for bad protocols * @return string Sanitized content */function wp_kses_bad_protocol_once2($matches) {	global $_kses_allowed_protocols;	if ( is_array($matches) ) {		if ( empty($matches[1]) )			return '';		$string = $matches[1];	} else {		$string = $matches;	}	$string2 = wp_kses_decode_entities($string);	$string2 = preg_replace('/\s/', '', $string2);	$string2 = wp_kses_no_null($string2);	$string2 = strtolower($string2);	$allowed = false;	foreach ( (array) $_kses_allowed_protocols as $one_protocol)		if (strtolower($one_protocol) == $string2) {			$allowed = true;			break;		}	if ($allowed)		return "$string2:";	else		return '';}/** * Converts and fixes HTML entities. * * This function normalizes HTML entities. It will convert "AT&T" to the correct * "AT&amp;T", "&#00058;" to "&#58;", "&#XYZZY;" to "&amp;#XYZZY;" and so on. * * @since 1.0.0 * * @param string $string Content to normalize entities * @return string Content with normalized entities */function wp_kses_normalize_entities($string) {	# Disarm all entities by converting & to &amp;	$string = str_replace('&', '&amp;', $string);	# Change back the allowed entities in our entity whitelist	$string = preg_replace_callback('/&amp;([A-Za-z]{2,8});/', 'wp_kses_named_entities', $string);	$string = preg_replace_callback('/&amp;#(0*[0-9]{1,7});/', 'wp_kses_normalize_entities2', $string);	$string = preg_replace_callback('/&amp;#[Xx](0*[0-9A-Fa-f]{1,6});/', 'wp_kses_normalize_entities3', $string);	return $string;}/** * Callback for wp_kses_normalize_entities() regular expression. * * This function only accepts valid named entity references, which are finite, * case-sensitive, and highly scrutinized by HTML and XML validators. * * @since 3.0.0 * * @param array $matches preg_replace_callback() matches array * @return string Correctly encoded entity */function wp_kses_named_entities($matches) {	global $allowedentitynames;	if ( empty($matches[1]) )		return '';	$i = $matches[1];	return ( ( ! in_array($i, $allowedentitynames) ) ? "&amp;$i;" : "&$i;" );}/** * Callback for wp_kses_normalize_entities() regular expression. * * This function helps wp_kses_normalize_entities() to only accept 16 bit values * and nothing more for &#number; entities. * * @access private * @since 1.0.0 * * @param array $matches preg_replace_callback() matches array * @return string Correctly encoded entity */function wp_kses_normalize_entities2($matches) {	if ( empty($matches[1]) )		return '';	$i = $matches[1];	if (valid_unicode($i)) {		$i = str_pad(ltrim($i,'0'), 3, '0', STR_PAD_LEFT);		$i = "&#$i;";	} else {		$i = "&amp;#$i;";	}	return $i;}/** * Callback for wp_kses_normalize_entities() for regular expression. * * This function helps wp_kses_normalize_entities() to only accept valid Unicode * numeric entities in hex form. * * @access private * * @param array $matches preg_replace_callback() matches array * @return string Correctly encoded entity */function wp_kses_normalize_entities3($matches) {	if ( empty($matches[1]) )		return '';	$hexchars = $matches[1];	return ( ( ! valid_unicode(hexdec($hexchars)) ) ? "&amp;#x$hexchars;" : '&#x'.ltrim($hexchars,'0').';' );}/** * Helper function to determine if a Unicode value is valid. * * @param int $i Unicode value * @return bool true if the value was a valid Unicode number */function valid_unicode($i) {	return ( $i == 0x9 || $i == 0xa || $i == 0xd ||			($i >= 0x20 && $i <= 0xd7ff) ||			($i >= 0xe000 && $i <= 0xfffd) ||			($i >= 0x10000 && $i <= 0x10ffff) );}/** * Convert all entities to their character counterparts. * * This function decodes numeric HTML entities (&#65; and &#x41;). It doesn't do * anything with other entities like &auml;, but we don't need them in the URL * protocol whitelisting system anyway. * * @since 1.0.0 * * @param string $string Content to change entities * @return string Content after decoded entities */function wp_kses_decode_entities($string) {	$string = preg_replace_callback('/&#([0-9]+);/', '_wp_kses_decode_entities_chr', $string);	$string = preg_replace_callback('/&#[Xx]([0-9A-Fa-f]+);/', '_wp_kses_decode_entities_chr_hexdec', $string);	return $string;}/** * Regex callback for wp_kses_decode_entities() * * @param array $match preg match * @return string */function _wp_kses_decode_entities_chr( $match ) {	return chr( $match[1] );}/** * Regex callback for wp_kses_decode_entities() * * @param array $match preg match * @return string */function _wp_kses_decode_entities_chr_hexdec( $match ) {	return chr( hexdec( $match[1] ) );}/** * Sanitize content with allowed HTML Kses rules. * * @since 1.0.0 * @uses $allowedtags * * @param string $data Content to filter, expected to be escaped with slashes * @return string Filtered content */function wp_filter_kses($data) {	global $allowedtags;	return addslashes( wp_kses(stripslashes( $data ), $allowedtags) );}/** * Sanitize content with allowed HTML Kses rules. * * @since 2.9.0 * @uses $allowedtags * * @param string $data Content to filter, expected to not be escaped * @return string Filtered content */function wp_kses_data($data) {	global $allowedtags;	return wp_kses( $data , $allowedtags );}/** * Sanitize content for allowed HTML tags for post content. * * Post content refers to the page contents of the 'post' type and not $_POST * data from forms. * * @since 2.0.0 * @uses $allowedposttags * * @param string $data Post content to filter, expected to be escaped with slashes * @return string Filtered post content with allowed HTML tags and attributes intact. */function wp_filter_post_kses($data) {	global $allowedposttags;	return addslashes ( wp_kses(stripslashes( $data ), $allowedposttags) );}/** * Sanitize content for allowed HTML tags for post content. * * Post content refers to the page contents of the 'post' type and not $_POST * data from forms. * * @since 2.9.0 * @uses $allowedposttags * * @param string $data Post content to filter * @return string Filtered post content with allowed HTML tags and attributes intact. */function wp_kses_post($data) {	global $allowedposttags;	return wp_kses( $data , $allowedposttags );}/** * Strips all of the HTML in the content. * * @since 2.1.0 * * @param string $data Content to strip all HTML from * @return string Filtered content without any HTML */function wp_filter_nohtml_kses($data) {	return addslashes ( wp_kses(stripslashes( $data ), array()) );}/** * Adds all Kses input form content filters. * * All hooks have default priority. The wp_filter_kses() function is added to * the 'pre_comment_content' and 'title_save_pre' hooks. * * The wp_filter_post_kses() function is added to the 'content_save_pre', * 'excerpt_save_pre', and 'content_filtered_save_pre' hooks. * * @since 2.0.0 * @uses add_filter() See description for what functions are added to what hooks. */function kses_init_filters() {	// Normal filtering.	add_filter('pre_comment_content', 'wp_filter_kses');	add_filter('title_save_pre', 'wp_filter_kses');	// Post filtering	add_filter('content_save_pre', 'wp_filter_post_kses');	add_filter('excerpt_save_pre', 'wp_filter_post_kses');	add_filter('content_filtered_save_pre', 'wp_filter_post_kses');}/** * Removes all Kses input form content filters. * * A quick procedural method to removing all of the filters that kses uses for * content in WordPress Loop. * * Does not remove the kses_init() function from 'init' hook (priority is * default). Also does not remove kses_init() function from 'set_current_user' * hook (priority is also default). * * @since 2.0.6 */function kses_remove_filters() {	// Normal filtering.	remove_filter('pre_comment_content', 'wp_filter_kses');	remove_filter('title_save_pre', 'wp_filter_kses');	// Post filtering	remove_filter('content_save_pre', 'wp_filter_post_kses');	remove_filter('excerpt_save_pre', 'wp_filter_post_kses');	remove_filter('content_filtered_save_pre', 'wp_filter_post_kses');}/** * Sets up most of the Kses filters for input form content. * * If you remove the kses_init() function from 'init' hook and * 'set_current_user' (priority is default), then none of the Kses filter hooks * will be added. * * First removes all of the Kses filters in case the current user does not need * to have Kses filter the content. If the user does not have unfiltered html * capability, then Kses filters are added. * * @uses kses_remove_filters() Removes the Kses filters * @uses kses_init_filters() Adds the Kses filters back if the user *		does not have unfiltered HTML capability. * @since 2.0.0 */function kses_init() {	kses_remove_filters();	if (current_user_can('unfiltered_html') == false)		kses_init_filters();}add_action('init', 'kses_init');add_action('set_current_user', 'kses_init');/** * Inline CSS filter * * @since 2.8.1 */function safecss_filter_attr( $css, $deprecated = '' ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.8.1' ); // Never implemented	$css = wp_kses_no_null($css);	$css = str_replace(array("\n","\r","\t"), '', $css);	if ( preg_match( '%[\\(&]|/\*%', $css ) ) // remove any inline css containing \ ( & or comments		return '';	$css_array = split( ';', trim( $css ) );	$allowed_attr = apply_filters( 'safe_style_css', array( 'text-align', 'margin', 'color', 'float',	'border', 'background', 'background-color', 'border-bottom', 'border-bottom-color',	'border-bottom-style', 'border-bottom-width', 'border-collapse', 'border-color', 'border-left',	'border-left-color', 'border-left-style', 'border-left-width', 'border-right', 'border-right-color',	'border-right-style', 'border-right-width', 'border-spacing', 'border-style', 'border-top',	'border-top-color', 'border-top-style', 'border-top-width', 'border-width', 'caption-side',	'clear', 'cursor', 'direction', 'font', 'font-family', 'font-size', 'font-style',	'font-variant', 'font-weight', 'height', 'letter-spacing', 'line-height', 'margin-bottom',	'margin-left', 'margin-right', 'margin-top', 'overflow', 'padding', 'padding-bottom',	'padding-left', 'padding-right', 'padding-top', 'text-decoration', 'text-indent', 'vertical-align',	'width' ) );	if ( empty($allowed_attr) )		return $css;	$css = '';	foreach ( $css_array as $css_item ) {		if ( $css_item == '' )			continue;		$css_item = trim( $css_item );		$found = false;		if ( strpos( $css_item, ':' ) === false ) {			$found = true;		} else {			$parts = split( ':', $css_item );			if ( in_array( trim( $parts[0] ), $allowed_attr ) )				$found = true;		}		if ( $found ) {			if( $css != '' )				$css .= ';';			$css .= $css_item;		}	}	return $css;}
<?php/** * Simple and uniform HTTP request API. * * Will eventually replace and standardize the WordPress HTTP requests made. * * @link http://trac.wordpress.org/ticket/4779 HTTP API Proposal * * @package WordPress * @subpackage HTTP * @since 2.7.0 *//** * Returns the initialized WP_Http Object * * @since 2.7.0 * @access private * * @return WP_Http HTTP Transport object. */function &_wp_http_get_object() {	static $http;	if ( is_null($http) )		$http = new WP_Http();	return $http;}/** * Retrieve the raw response from the HTTP request. * * The array structure is a little complex. * * <code> * $res = array( 'headers' => array(), 'response' => array('code' => int, 'message' => string) ); * </code> * * All of the headers in $res['headers'] are with the name as the key and the * value as the value. So to get the User-Agent, you would do the following. * * <code> * $user_agent = $res['headers']['user-agent']; * </code> * * The body is the raw response content and can be retrieved from $res['body']. * * This function is called first to make the request and there are other API * functions to abstract out the above convoluted setup. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_request($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->request($url, $args);}/** * Retrieve the raw response from the HTTP request using the GET method. * * @see wp_remote_request() For more information on the response array format. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_get($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->get($url, $args);}/** * Retrieve the raw response from the HTTP request using the POST method. * * @see wp_remote_request() For more information on the response array format. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_post($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->post($url, $args);}/** * Retrieve the raw response from the HTTP request using the HEAD method. * * @see wp_remote_request() For more information on the response array format. * * @since 2.7.0 * * @param string $url Site URL to retrieve. * @param array $args Optional. Override the defaults. * @return WP_Error|array The response or WP_Error on failure. */function wp_remote_head($url, $args = array()) {	$objFetchSite = _wp_http_get_object();	return $objFetchSite->head($url, $args);}/** * Retrieve only the headers from the raw response. * * @since 2.7.0 * * @param array $response HTTP response. * @return array The headers of the response. Empty array if incorrect parameter given. */function wp_remote_retrieve_headers(&$response) {	if ( is_wp_error($response) || ! isset($response['headers']) || ! is_array($response['headers']))		return array();	return $response['headers'];}/** * Retrieve a single header by name from the raw response. * * @since 2.7.0 * * @param array $response * @param string $header Header name to retrieve value from. * @return string The header value. Empty string on if incorrect parameter given, or if the header doesnt exist. */function wp_remote_retrieve_header(&$response, $header) {	if ( is_wp_error($response) || ! isset($response['headers']) || ! is_array($response['headers']))		return '';	if ( array_key_exists($header, $response['headers']) )		return $response['headers'][$header];	return '';}/** * Retrieve only the response code from the raw response. * * Will return an empty array if incorrect parameter value is given. * * @since 2.7.0 * * @param array $response HTTP response. * @return string the response code. Empty string on incorrect parameter given. */function wp_remote_retrieve_response_code(&$response) {	if ( is_wp_error($response) || ! isset($response['response']) || ! is_array($response['response']))		return '';	return $response['response']['code'];}/** * Retrieve only the response message from the raw response. * * Will return an empty array if incorrect parameter value is given. * * @since 2.7.0 * * @param array $response HTTP response. * @return string The response message. Empty string on incorrect parameter given. */function wp_remote_retrieve_response_message(&$response) {	if ( is_wp_error($response) || ! isset($response['response']) || ! is_array($response['response']))		return '';	return $response['response']['message'];}/** * Retrieve only the body from the raw response. * * @since 2.7.0 * * @param array $response HTTP response. * @return string The body of the response. Empty string if no body or incorrect parameter given. */function wp_remote_retrieve_body(&$response) {	if ( is_wp_error($response) || ! isset($response['body']) )		return '';	return $response['body'];}?>
<?php/** * Upload new media Administration Panel. * * @package WordPress * @subpackage Administration */$_GET['inline'] = 'true';/** Administration bootstrap */require_once('./admin.php');require_once('./media-upload.php');?>
<?php/** * Plugins may load this file to gain access to special helper functions for * plugin installation. This file is not included by WordPress and it is * recommended, to prevent fatal errors, that this file is included using * require_once(). * * These functions are not optimized for speed, but they should only be used * once in a while, so speed shouldn't be a concern. If it is and you are * needing to use these functions a lot, you might experience time outs. If you * do, then it is advised to just write the SQL code yourself. * * You can turn debugging on, by setting $debug to 1 after you include this * file. * * <code> * check_column('wp_links', 'link_description', 'mediumtext'); * if (check_column($wpdb->comments, 'comment_author', 'tinytext')) *     echo "ok\n"; * * $error_count = 0; * $tablename = $wpdb->links; * // check the column * if (!check_column($wpdb->links, 'link_description', 'varchar(255)')) { *     $ddl = "ALTER TABLE $wpdb->links MODIFY COLUMN link_description varchar(255) NOT NULL DEFAULT '' "; *     $q = $wpdb->query($ddl); * } * * if (check_column($wpdb->links, 'link_description', 'varchar(255)')) { *     $res .= $tablename . ' - ok <br />'; * } else { *     $res .= 'There was a problem with ' . $tablename . '<br />'; *     ++$error_count; * } * </code> * * @package WordPress * @subpackage Plugin *//** * @global bool $wp_only_load_config * @name $wp_only_load_config * @var bool * @since unknown */$wp_only_load_config = true;/** Load WordPress Bootstrap */require_once(dirname(dirname(__FILE__)).'/wp-load.php');/** * Turn debugging on or off. * @global bool|int $debug * @name $debug * @var bool|int * @since unknown */$debug = 0;if ( ! function_exists('maybe_create_table') ) :/** * Create database table, if it doesn't already exist. * * @since unknown * @package WordPress * @subpackage Plugin * @uses $wpdb * * @param string $table_name Database table name. * @param string $create_ddl Create database table SQL. * @return bool False on error, true if already exists or success. */function maybe_create_table($table_name, $create_ddl) {	global $wpdb;	foreach ($wpdb->get_col("SHOW TABLES",0) as $table ) {		if ($table == $table_name) {			return true;		}	}	//didn't find it try to create it.	$wpdb->query($create_ddl);	// we cannot directly tell that whether this succeeded!	foreach ($wpdb->get_col("SHOW TABLES",0) as $table ) {		if ($table == $table_name) {			return true;		}	}	return false;}endif;if ( ! function_exists('maybe_add_column') ) :/** * Add column to database table, if column doesn't already exist in table. * * @since unknown * @package WordPress * @subpackage Plugin * @uses $wpdb * @uses $debug * * @param string $table_name Database table name * @param string $column_name Table column name * @param string $create_ddl SQL to add column to table. * @return bool False on failure. True, if already exists or was successful. */function maybe_add_column($table_name, $column_name, $create_ddl) {	global $wpdb, $debug;	foreach ($wpdb->get_col("DESC $table_name",0) as $column ) {		if ($debug) echo("checking $column == $column_name<br />");		if ($column == $column_name) {			return true;		}	}	//didn't find it try to create it.	$wpdb->query($create_ddl);	// we cannot directly tell that whether this succeeded!	foreach ($wpdb->get_col("DESC $table_name",0) as $column ) {		if ($column == $column_name) {			return true;		}	}	return false;}endif;/** * Drop column from database table, if it exists. * * @since unknown * @package WordPress * @subpackage Plugin * @uses $wpdb * * @param string $table_name Table name * @param string $column_name Column name * @param string $drop_ddl SQL statement to drop column. * @return bool False on failure, true on success or doesn't exist. */function maybe_drop_column($table_name, $column_name, $drop_ddl) {	global $wpdb;	foreach ($wpdb->get_col("DESC $table_name",0) as $column ) {		if ($column == $column_name) {			//found it try to drop it.			$wpdb->query($drop_ddl);			// we cannot directly tell that whether this succeeded!			foreach ($wpdb->get_col("DESC $table_name",0) as $column ) {				if ($column == $column_name) {					return false;				}			}		}	}	// else didn't find it	return true;}/** * Check column matches criteria. * * Uses the SQL DESC for retrieving the table info for the column. It will help * understand the parameters, if you do more research on what column information * is returned by the SQL statement. Pass in null to skip checking that * criteria. * * Column names returned from DESC table are case sensitive and are listed: *      Field *      Type *      Null *      Key *      Default *      Extra * * @since unknown * @package WordPress * @subpackage Plugin * * @param string $table_name Table name * @param string $col_name Column name * @param string $col_type Column type * @param bool $is_null Optional. Check is null. * @param mixed $key Optional. Key info. * @param mixed $default Optional. Default value. * @param mixed $extra Optional. Extra value. * @return bool True, if matches. False, if not matching. */function check_column($table_name, $col_name, $col_type, $is_null = null, $key = null, $default = null, $extra = null) {	global $wpdb, $debug;	$diffs = 0;	$results = $wpdb->get_results("DESC $table_name");	foreach ($results as $row ) {		if ($debug > 1) print_r($row);		if ($row->Field == $col_name) {			// got our column, check the params			if ($debug) echo ("checking $row->Type against $col_type\n");			if (($col_type != null) && ($row->Type != $col_type)) {				++$diffs;			}			if (($is_null != null) && ($row->Null != $is_null)) {				++$diffs;			}			if (($key != null) && ($row->Key  != $key)) {				++$diffs;			}			if (($default != null) && ($row->Default != $default)) {				++$diffs;			}			if (($extra != null) && ($row->Extra != $extra)) {				++$diffs;			}			if ($diffs > 0) {				if ($debug) echo ("diffs = $diffs returning false\n");				return false;			}			return true;		} // end if found our column	}	return false;}?>
<?php/** * WordPress API for creating bbcode like tags or what WordPress calls * "shortcodes." The tag and attribute parsing or regular expression code is * based on the Textpattern tag parser. * * A few examples are below: * * [shortcode /] * [shortcode foo="bar" baz="bing" /] * [shortcode foo="bar"]content[/shortcode] * * Shortcode tags support attributes and enclosed content, but does not entirely * support inline shortcodes in other shortcodes. You will have to call the * shortcode parser in your function to account for that. * * {@internal * Please be aware that the above note was made during the beta of WordPress 2.6 * and in the future may not be accurate. Please update the note when it is no * longer the case.}} * * To apply shortcode tags to content: * * <code> * $out = do_shortcode($content); * </code> * * @link http://codex.wordpress.org/Shortcode_API * * @package WordPress * @subpackage Shortcodes * @since 2.5 *//** * Container for storing shortcode tags and their hook to call for the shortcode * * @since 2.5 * @name $shortcode_tags * @var array * @global array $shortcode_tags */$shortcode_tags = array();/** * Add hook for shortcode tag. * * There can only be one hook for each shortcode. Which means that if another * plugin has a similar shortcode, it will override yours or yours will override * theirs depending on which order the plugins are included and/or ran. * * Simplest example of a shortcode tag using the API: * * <code> * // [footag foo="bar"] * function footag_func($atts) { * 	return "foo = {$atts[foo]}"; * } * add_shortcode('footag', 'footag_func'); * </code> * * Example with nice attribute defaults: * * <code> * // [bartag foo="bar"] * function bartag_func($atts) { * 	extract(shortcode_atts(array( * 		'foo' => 'no foo', * 		'baz' => 'default baz', * 	), $atts)); * * 	return "foo = {$foo}"; * } * add_shortcode('bartag', 'bartag_func'); * </code> * * Example with enclosed content: * * <code> * // [baztag]content[/baztag] * function baztag_func($atts, $content='') { * 	return "content = $content"; * } * add_shortcode('baztag', 'baztag_func'); * </code> * * @since 2.5 * @uses $shortcode_tags * * @param string $tag Shortcode tag to be searched in post content. * @param callable $func Hook to run when shortcode is found. */function add_shortcode($tag, $func) {	global $shortcode_tags;	if ( is_callable($func) )		$shortcode_tags[$tag] = $func;}/** * Removes hook for shortcode. * * @since 2.5 * @uses $shortcode_tags * * @param string $tag shortcode tag to remove hook for. */function remove_shortcode($tag) {	global $shortcode_tags;	unset($shortcode_tags[$tag]);}/** * Clear all shortcodes. * * This function is simple, it clears all of the shortcode tags by replacing the * shortcodes global by a empty array. This is actually a very efficient method * for removing all shortcodes. * * @since 2.5 * @uses $shortcode_tags */function remove_all_shortcodes() {	global $shortcode_tags;	$shortcode_tags = array();}/** * Search content for shortcodes and filter shortcodes through their hooks. * * If there are no shortcode tags defined, then the content will be returned * without any filtering. This might cause issues when plugins are disabled but * the shortcode will still show up in the post or content. * * @since 2.5 * @uses $shortcode_tags * @uses get_shortcode_regex() Gets the search pattern for searching shortcodes. * * @param string $content Content to search for shortcodes * @return string Content with shortcodes filtered out. */function do_shortcode($content) {	global $shortcode_tags;	if (empty($shortcode_tags) || !is_array($shortcode_tags))		return $content;	$pattern = get_shortcode_regex();	return preg_replace_callback('/'.$pattern.'/s', 'do_shortcode_tag', $content);}/** * Retrieve the shortcode regular expression for searching. * * The regular expression combines the shortcode tags in the regular expression * in a regex class. * * The regular expresion contains 6 different sub matches to help with parsing. * * 1/6 - An extra [ or ] to allow for escaping shortcodes with double [[]] * 2 - The shortcode name * 3 - The shortcode argument list * 4 - The self closing / * 5 - The content of a shortcode when it wraps some content. * * @since 2.5 * @uses $shortcode_tags * * @return string The shortcode search regular expression */function get_shortcode_regex() {	global $shortcode_tags;	$tagnames = array_keys($shortcode_tags);	$tagregexp = join( '|', array_map('preg_quote', $tagnames) );	// WARNING! Do not change this regex without changing do_shortcode_tag() and strip_shortcodes()	return '(.?)\[('.$tagregexp.')\b(.*?)(?:(\/))?\](?:(.+?)\[\/\2\])?(.?)';}/** * Regular Expression callable for do_shortcode() for calling shortcode hook. * @see get_shortcode_regex for details of the match array contents. * * @since 2.5 * @access private * @uses $shortcode_tags * * @param array $m Regular expression match array * @return mixed False on failure. */function do_shortcode_tag( $m ) {	global $shortcode_tags;	// allow [[foo]] syntax for escaping a tag	if ( $m[1] == '[' && $m[6] == ']' ) {		return substr($m[0], 1, -1);	}	$tag = $m[2];	$attr = shortcode_parse_atts( $m[3] );	if ( isset( $m[5] ) ) {		// enclosing tag - extra parameter		return $m[1] . call_user_func( $shortcode_tags[$tag], $attr, $m[5], $tag ) . $m[6];	} else {		// self-closing tag		return $m[1] . call_user_func( $shortcode_tags[$tag], $attr, NULL,  $tag ) . $m[6];	}}/** * Retrieve all attributes from the shortcodes tag. * * The attributes list has the attribute name as the key and the value of the * attribute as the value in the key/value pair. This allows for easier * retrieval of the attributes, since all attributes have to be known. * * @since 2.5 * * @param string $text * @return array List of attributes and their value. */function shortcode_parse_atts($text) {	$atts = array();	$pattern = '/(\w+)\s*=\s*"([^"]*)"(?:\s|$)|(\w+)\s*=\s*\'([^\']*)\'(?:\s|$)|(\w+)\s*=\s*([^\s\'"]+)(?:\s|$)|"([^"]*)"(?:\s|$)|(\S+)(?:\s|$)/';	$text = preg_replace("/[\x{00a0}\x{200b}]+/u", " ", $text);	if ( preg_match_all($pattern, $text, $match, PREG_SET_ORDER) ) {		foreach ($match as $m) {			if (!empty($m[1]))				$atts[strtolower($m[1])] = stripcslashes($m[2]);			elseif (!empty($m[3]))				$atts[strtolower($m[3])] = stripcslashes($m[4]);			elseif (!empty($m[5]))				$atts[strtolower($m[5])] = stripcslashes($m[6]);			elseif (isset($m[7]) and strlen($m[7]))				$atts[] = stripcslashes($m[7]);			elseif (isset($m[8]))				$atts[] = stripcslashes($m[8]);		}	} else {		$atts = ltrim($text);	}	return $atts;}/** * Combine user attributes with known attributes and fill in defaults when needed. * * The pairs should be considered to be all of the attributes which are * supported by the caller and given as a list. The returned attributes will * only contain the attributes in the $pairs list. * * If the $atts list has unsupported attributes, then they will be ignored and * removed from the final returned list. * * @since 2.5 * * @param array $pairs Entire list of supported attributes and their defaults. * @param array $atts User defined attributes in shortcode tag. * @return array Combined and filtered attribute list. */function shortcode_atts($pairs, $atts) {	$atts = (array)$atts;	$out = array();	foreach($pairs as $name => $default) {		if ( array_key_exists($name, $atts) )			$out[$name] = $atts[$name];		else			$out[$name] = $default;	}	return $out;}/** * Remove all shortcode tags from the given content. * * @since 2.5 * @uses $shortcode_tags * * @param string $content Content to remove shortcode tags. * @return string Content without shortcode tags. */function strip_shortcodes( $content ) {	global $shortcode_tags;	if (empty($shortcode_tags) || !is_array($shortcode_tags))		return $content;	$pattern = get_shortcode_regex();	return preg_replace('/'.$pattern.'/s', '$1$6', $content);}add_filter('the_content', 'do_shortcode', 11); // AFTER wpautop()?>
<?php/** * "Inline" diff renderer. * * Copyright 2004-2010 The Horde Project (http://www.horde.org/) * * See the enclosed file COPYING for license information (LGPL). If you did * not receive this file, see http://opensource.org/licenses/lgpl-license.php. * * @author  Ciprian Popovici * @package Text_Diff *//** Text_Diff_Renderer */// WP #7391require_once dirname(dirname(__FILE__)) . '/Renderer.php';/** * "Inline" diff renderer. * * This class renders diffs in the Wiki-style "inline" format. * * @author  Ciprian Popovici * @package Text_Diff */class Text_Diff_Renderer_inline extends Text_Diff_Renderer {    /**     * Number of leading context "lines" to preserve.     *     * @var integer     */    var $_leading_context_lines = 10000;    /**     * Number of trailing context "lines" to preserve.     *     * @var integer     */    var $_trailing_context_lines = 10000;    /**     * Prefix for inserted text.     *     * @var string     */    var $_ins_prefix = '<ins>';    /**     * Suffix for inserted text.     *     * @var string     */    var $_ins_suffix = '</ins>';    /**     * Prefix for deleted text.     *     * @var string     */    var $_del_prefix = '<del>';    /**     * Suffix for deleted text.     *     * @var string     */    var $_del_suffix = '</del>';    /**     * Header for each change block.     *     * @var string     */    var $_block_header = '';    /**     * Whether to split down to character-level.     *     * @var boolean     */    var $_split_characters = false;    /**     * What are we currently splitting on? Used to recurse to show word-level     * or character-level changes.     *     * @var string     */    var $_split_level = 'lines';    function _blockHeader($xbeg, $xlen, $ybeg, $ylen)    {        return $this->_block_header;    }    function _startBlock($header)    {        return $header;    }    function _lines($lines, $prefix = ' ', $encode = true)    {        if ($encode) {            array_walk($lines, array(&$this, '_encode'));        }        if ($this->_split_level == 'lines') {            return implode("\n", $lines) . "\n";        } else {            return implode('', $lines);        }    }    function _added($lines)    {        array_walk($lines, array(&$this, '_encode'));        $lines[0] = $this->_ins_prefix . $lines[0];        $lines[count($lines) - 1] .= $this->_ins_suffix;        return $this->_lines($lines, ' ', false);    }    function _deleted($lines, $words = false)    {        array_walk($lines, array(&$this, '_encode'));        $lines[0] = $this->_del_prefix . $lines[0];        $lines[count($lines) - 1] .= $this->_del_suffix;        return $this->_lines($lines, ' ', false);    }    function _changed($orig, $final)    {        /* If we've already split on characters, just display. */        if ($this->_split_level == 'characters') {            return $this->_deleted($orig)                . $this->_added($final);        }        /* If we've already split on words, just display. */        if ($this->_split_level == 'words') {            $prefix = '';            while ($orig[0] !== false && $final[0] !== false &&                   substr($orig[0], 0, 1) == ' ' &&                   substr($final[0], 0, 1) == ' ') {                $prefix .= substr($orig[0], 0, 1);                $orig[0] = substr($orig[0], 1);                $final[0] = substr($final[0], 1);            }            return $prefix . $this->_deleted($orig) . $this->_added($final);        }        $text1 = implode("\n", $orig);        $text2 = implode("\n", $final);        /* Non-printing newline marker. */        $nl = "\0";        if ($this->_split_characters) {            $diff = new Text_Diff('native',                                  array(preg_split('//', $text1),                                        preg_split('//', $text2)));        } else {            /* We want to split on word boundaries, but we need to preserve             * whitespace as well. Therefore we split on words, but include             * all blocks of whitespace in the wordlist. */            $diff = new Text_Diff('native',                                  array($this->_splitOnWords($text1, $nl),                                        $this->_splitOnWords($text2, $nl)));        }        /* Get the diff in inline format. */        $renderer = new Text_Diff_Renderer_inline            (array_merge($this->getParams(),                         array('split_level' => $this->_split_characters ? 'characters' : 'words')));        /* Run the diff and get the output. */        return str_replace($nl, "\n", $renderer->render($diff)) . "\n";    }    function _splitOnWords($string, $newlineEscape = "\n")    {        // Ignore \0; otherwise the while loop will never finish.        $string = str_replace("\0", '', $string);        $words = array();        $length = strlen($string);        $pos = 0;        while ($pos < $length) {            // Eat a word with any preceding whitespace.            $spaces = strspn(substr($string, $pos), " \n");            $nextpos = strcspn(substr($string, $pos + $spaces), " \n");            $words[] = str_replace("\n", $newlineEscape, substr($string, $pos, $spaces + $nextpos));            $pos += $spaces + $nextpos;        }        return $words;    }    function _encode(&$string)    {        $string = htmlspecialchars($string);    }}
<?php/** * Edit link category form for inclusion in administration panels. * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');if ( !current_user_can('manage_categories') )	wp_die(__('You do not have sufficient permissions to edit link categories for this site.'));/** * @var object */if ( ! isset( $category ) )	$category = (object) array();if ( ! empty($cat_ID) ) {	/**	 * @var string	 */	$heading = '<h2>' . __('Edit Link Category') . '</h2>';	$submit_text = __('Update Category');	$form = '<form name="editcat" id="editcat" method="post" action="link-category.php" class="validate">';	$action = 'editedcat';	$nonce_action = 'update-link-category_' . $cat_ID;	do_action('edit_link_category_form_pre', $category);} else {	$heading = '<h2>' . __('Add Link Category') . '</h2>';	$submit_text = __('Add Category');	$form = '<form name="addcat" id="addcat" class="add:the-list: validate" method="post" action="link-category.php">';	$action = 'addcat';	$nonce_action = 'add-link-category';	do_action('add_link_category_form_pre', $category);}/** * @ignore * @since 2.7 * @internal Used to prevent errors in page when no category is being edited. * * @param object $category */function _fill_empty_link_category(&$category) {	if ( ! isset( $category->name ) )		$category->name = '';	if ( ! isset( $category->slug ) )		$category->slug = '';	if ( ! isset( $category->description ) )		$category->description = '';}_fill_empty_link_category($category);?><div class="wrap"><?php screen_icon(); ?><?php echo $heading ?><div id="ajax-response"></div><?php echo $form ?><input type="hidden" name="action" value="<?php echo esc_attr($action) ?>" /><input type="hidden" name="cat_ID" value="<?php echo esc_attr($category->term_id) ?>" /><?php wp_original_referer_field(true, 'previous'); wp_nonce_field($nonce_action); ?>	<table class="form-table">		<tr class="form-field form-required">			<th scope="row" valign="top"><label for="name"><?php _e('Link Category name') ?></label></th>			<td><input name="name" id="name" type="text" value="<?php echo esc_attr($category->name); ?>" size="40" aria-required="true" /></td>		</tr><?php if ( !is_multisite() ) { ?>		<tr class="form-field">			<th scope="row" valign="top"><label for="slug"><?php _e('Link Category slug') ?></label></th>			<td><input name="slug" id="slug" type="text" value="<?php echo esc_attr(apply_filters('editable_slug', $category->slug)); ?>" size="40" /><br />            <?php _e('The &#8220;slug&#8221; is the URL-friendly version of the name. It is usually all lowercase and contains only letters, numbers, and hyphens.'); ?></td>		</tr><?php } ?>		<tr class="form-field">			<th scope="row" valign="top"><label for="description"><?php _e('Description (optional)') ?></label></th>			<td><textarea name="description" id="description" rows="5" cols="50" style="width: 97%;"><?php echo $category->description; ?></textarea><br />			<span class="description"><?php _e('The description is not prominent by default; however, some themes may show it.'); ?></span></td>		</tr>		<?php do_action('edit_link_category_form_fields', $category); ?>	</table><p class="submit"><input type="submit" class="button-primary" name="submit" value="<?php echo esc_attr($submit_text) ?>" /></p><?php do_action('edit_link_category_form', $category); ?></form></div>
<?php/** * Disable error reporting * * Set this to error_reporting( E_ALL ) or error_reporting( E_ALL | E_STRICT ) for debugging */error_reporting(0);/** Set ABSPATH for execution */define( 'ABSPATH', dirname(dirname(__FILE__)) . '/' );define( 'WPINC', 'wp-includes' );/** * @ignore */function __() {}/** * @ignore */function _x() {}/** * @ignore */function add_filter() {}/** * @ignore */function esc_attr() {}/** * @ignore */function apply_filters() {}/** * @ignore */function get_option() {}/** * @ignore */function is_lighttpd_before_150() {}/** * @ignore */function add_action() {}/** * @ignore */function do_action_ref_array() {}/** * @ignore */function get_bloginfo() {}/** * @ignore */function is_admin() {return true;}/** * @ignore */function site_url() {}/** * @ignore */function admin_url() {}/** * @ignore */function home_url() {}/** * @ignore */function wp_guess_url() {}function get_file($path) {	if ( function_exists('realpath') )		$path = realpath($path);	if ( ! $path || ! @is_file($path) )		return '';	return @file_get_contents($path);}$load = preg_replace( '/[^a-z0-9,_-]+/i', '', $_GET['load'] );$load = explode(',', $load);if ( empty($load) )	exit;require(ABSPATH . WPINC . '/script-loader.php');require(ABSPATH . WPINC . '/version.php');$compress = ( isset($_GET['c']) && $_GET['c'] );$force_gzip = ( $compress && 'gzip' == $_GET['c'] );$expires_offset = 31536000;$out = '';$wp_scripts = new WP_Scripts();wp_default_scripts($wp_scripts);foreach( $load as $handle ) {	if ( !array_key_exists($handle, $wp_scripts->registered) )		continue;	$path = ABSPATH . $wp_scripts->registered[$handle]->src;	$out .= get_file($path) . "\n";}header('Content-Type: application/x-javascript; charset=UTF-8');header('Expires: ' . gmdate( "D, d M Y H:i:s", time() + $expires_offset ) . ' GMT');header("Cache-Control: public, max-age=$expires_offset");if ( $compress && ! ini_get('zlib.output_compression') && 'ob_gzhandler' != ini_get('output_handler') && isset($_SERVER['HTTP_ACCEPT_ENCODING']) ) {	header('Vary: Accept-Encoding'); // Handle proxies	if ( false !== strpos( strtolower($_SERVER['HTTP_ACCEPT_ENCODING']), 'deflate') && function_exists('gzdeflate') && ! $force_gzip ) {		header('Content-Encoding: deflate');		$out = gzdeflate( $out, 3 );	} elseif ( false !== strpos( strtolower($_SERVER['HTTP_ACCEPT_ENCODING']), 'gzip') && function_exists('gzencode') ) {		header('Content-Encoding: gzip');		$out = gzencode( $out, 3 );	}}echo $out;exit;
<?php/** * Loads the WordPress environment and template. * * @package WordPress */if ( !isset($wp_did_header) ) {	$wp_did_header = true;	require_once( dirname(__FILE__) . '/wp-load.php' );	wp();	require_once( ABSPATH . WPINC . '/template-loader.php' );}?>
<?php/** * The template for displaying Archive pages. * * Used to display archive-type pages if nothing more specific matches a query. * For example, puts together date-based pages if no date.php file exists. * * Learn more: http://codex.wordpress.org/Template_Hierarchy * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main"><?php	/* Queue the first post, that way we know	 * what date we're dealing with (if that is the case).	 *	 * We reset this later so we can run the loop	 * properly with a call to rewind_posts().	 */	if ( have_posts() )		the_post();?>			<h1 class="page-title"><?php if ( is_day() ) : ?>				<?php printf( __( 'Daily Archives: <span>%s</span>', 'twentyten' ), get_the_date() ); ?><?php elseif ( is_month() ) : ?>				<?php printf( __( 'Monthly Archives: <span>%s</span>', 'twentyten' ), get_the_date('F Y') ); ?><?php elseif ( is_year() ) : ?>				<?php printf( __( 'Yearly Archives: <span>%s</span>', 'twentyten' ), get_the_date('Y') ); ?><?php else : ?>				<?php _e( 'Blog Archives', 'twentyten' ); ?><?php endif; ?>			</h1><?php	/* Since we called the_post() above, we need to	 * rewind the loop back to the beginning that way	 * we can run the loop properly, in full.	 */	rewind_posts();	/* Run the loop for the archives page to output the posts.	 * If you want to overload this in a child theme then include a file	 * called loop-archives.php and that will be used instead.	 */	 get_template_part( 'loop', 'archive' );?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
<?php/** * Used to set up and fix common variables and include * the Multisite procedural and class library. * * Allows for some configuration in wp-config.php (see ms-default-constants.php) * * @package WordPress * @subpackage Multisite * @since 3.0.0 */// $base sanity check.if ( 'BASE' == $base )	die( /*WP_I18N_BASE_ERROR*/'Configuration error in <code>wp-config.php</code>. <code>$base</code> is set to <code>BASE</code> when it should be like <code>/</code> or <code>/blogs/</code>.'/*/WP_I18N_BASE_ERROR*/ );/** Include Multisite initialization functions */require( ABSPATH . WPINC . '/ms-load.php' );require( ABSPATH . WPINC . '/ms-default-constants.php' );if ( defined( 'SUNRISE' ) )	include_once( WP_CONTENT_DIR . '/sunrise.php' );/** Check for and define SUBDOMAIN_INSTALL and the deprecated VHOST constant. */ms_subdomain_constants();if ( !isset( $current_site ) || !isset( $current_blog ) ) {	$domain = addslashes( $_SERVER['HTTP_HOST'] );	if ( false !== strpos( $domain, ':' ) ) {		if ( substr( $domain, -3 ) == ':80' ) {			$domain = substr( $domain, 0, -3 );			$_SERVER['HTTP_HOST'] = substr( $_SERVER['HTTP_HOST'], 0, -3 );		} elseif ( substr( $domain, -4 ) == ':443' ) {			$domain = substr( $domain, 0, -4 );			$_SERVER['HTTP_HOST'] = substr( $_SERVER['HTTP_HOST'], 0, -4 );		} else {			wp_die( /*WP_I18N_NO_PORT_NUMBER*/'Multisite only works without the port number in the URL.'/*/WP_I18N_NO_PORT_NUMBER*/ );		}	}	$domain = rtrim( $domain, '.' );	$cookie_domain = $domain;	if ( substr( $cookie_domain, 0, 4 ) == 'www.' )		$cookie_domain = substr( $cookie_domain, 4 );	$path = preg_replace( '|([a-z0-9-]+.php.*)|', '', $_SERVER['REQUEST_URI'] );	$path = str_replace ( '/wp-admin/', '/', $path );	$path = preg_replace( '|(/[a-z0-9-]+?/).*|', '$1', $path );	$current_site = wpmu_current_site();	if ( ! isset( $current_site->blog_id ) )		$current_site->blog_id = $wpdb->get_var( $wpdb->prepare( "SELECT blog_id FROM $wpdb->blogs WHERE domain = %s AND path = %s", $current_site->domain, $current_site->path ) );	if ( is_subdomain_install() ) {		$current_blog = wp_cache_get( 'current_blog_' . $domain, 'site-options' );		if ( !$current_blog ) {			$current_blog = get_blog_details( array( 'domain' => $domain ), false );			if ( $current_blog )				wp_cache_set( 'current_blog_' . $domain, $current_blog, 'site-options' );		}		if ( $current_blog && $current_blog->site_id != $current_site->id )			$current_site = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->site WHERE id = %d", $current_blog->site_id ) );		else			$blogname = substr( $domain, 0, strpos( $domain, '.' ) );	} else {		$blogname = htmlspecialchars( substr( $_SERVER[ 'REQUEST_URI' ], strlen( $path ) ) );		if ( false !== strpos( $blogname, '/' ) )			$blogname = substr( $blogname, 0, strpos( $blogname, '/' ) );		if ( false !== strpos( $blogname, '?' ) )			$blogname = substr( $blogname, 0, strpos( $blogname, '?' ) );		$reserved_blognames = array( 'page', 'comments', 'blog', 'wp-admin', 'wp-includes', 'wp-content', 'files', 'feed' );		if ( $blogname != '' && ! in_array( $blogname, $reserved_blognames ) && ! is_file( $blogname ) )			$path .= $blogname . '/';		$current_blog = wp_cache_get( 'current_blog_' . $domain . $path, 'site-options' );		if ( ! $current_blog ) {			$current_blog = get_blog_details( array( 'domain' => $domain, 'path' => $path ), false );			if ( $current_blog )				wp_cache_set( 'current_blog_' . $domain . $path, $current_blog, 'site-options' );		}	}	if ( ! defined( 'WP_INSTALLING' ) && is_subdomain_install() && ! is_object( $current_blog ) ) {		if ( defined( 'NOBLOGREDIRECT' ) ) {			$destination = NOBLOGREDIRECT;			if ( '%siteurl%' == $destination )				$destination = "http://" . $current_site->domain . $current_site->path;		} else {			$destination = 'http://' . $current_site->domain . $current_site->path . 'wp-signup.php?new=' . str_replace( '.' . $current_site->domain, '', $domain );		}		header( 'Location: ' . $destination );		die();	}	if ( ! defined( 'WP_INSTALLING' ) ) {		if ( $current_site && ! $current_blog ) {			if ( $current_site->domain != $_SERVER[ 'HTTP_HOST' ] ) {				header( 'Location: http://' . $current_site->domain . $current_site->path );				exit;			}			$current_blog = get_blog_details( array( 'domain' => $current_site->domain, 'path' => $current_site->path ), false );		}		if ( ! $current_blog || ! $current_site )			ms_not_installed();	}	$blog_id = $current_blog->blog_id;	$public  = $current_blog->public;	if ( empty( $current_blog->site_id ) )		$current_blog->site_id = 1;	$site_id = $current_blog->site_id;	$current_site = get_current_site_name( $current_site );	if ( ! $blog_id ) {		if ( defined( 'WP_INSTALLING' ) ) {			$current_blog->blog_id = $blog_id = 1;		} else {			$msg = ! $wpdb->get_var( "SHOW TABLES LIKE '$wpdb->site'" ) ? ' ' . /*WP_I18N_TABLES_MISSING*/'Database tables are missing.'/*/WP_I18N_TABLES_MISSING*/ : '';			wp_die( /*WP_I18N_NO_BLOG*/'No site by that name on this system.'/*/WP_I18N_NO_BLOG*/ . $msg );		}	}}$wpdb->set_prefix( $table_prefix, false ); // $table_prefix can be set in sunrise.php$wpdb->set_blog_id( $current_blog->blog_id, $current_blog->site_id );$table_prefix = $wpdb->get_blog_prefix();// need to init cache again after blog_id is setwp_start_object_cache();// Define upload directory constantsms_upload_constants();
<?php/** * MagpieRSS: a simple RSS integration tool * * A compiled file for RSS syndication * * @author Kellan Elliott-McCrea <kellan@protest.net> * @version 0.51 * @license GPL * * @package External * @subpackage MagpieRSS *//** * Deprecated. Use SimplePie (class-simplepie.php) instead. */_deprecated_file( basename( __FILE__ ), '3.0', WPINC . '/class-simplepie.php' );/* * Hook to use another RSS object instead of MagpieRSS */do_action('load_feed_engine');/** RSS feed constant. */define('RSS', 'RSS');define('ATOM', 'Atom');define('MAGPIE_USER_AGENT', 'WordPress/' . $GLOBALS['wp_version']);class MagpieRSS {	var $parser;	var $current_item	= array();	// item currently being parsed	var $items			= array();	// collection of parsed items	var $channel		= array();	// hash of channel fields	var $textinput		= array();	var $image			= array();	var $feed_type;	var $feed_version;	// parser variables	var $stack				= array(); // parser stack	var $inchannel			= false;	var $initem 			= false;	var $incontent			= false; // if in Atom <content mode="xml"> field	var $intextinput		= false;	var $inimage 			= false;	var $current_field		= '';	var $current_namespace	= false;	//var $ERROR = "";	var $_CONTENT_CONSTRUCTS = array('content', 'summary', 'info', 'title', 'tagline', 'copyright');	function MagpieRSS ($source) {		# if PHP xml isn't compiled in, die		#		if ( !function_exists('xml_parser_create') )			trigger_error( "Failed to load PHP's XML Extension. http://www.php.net/manual/en/ref.xml.php" );		$parser = @xml_parser_create();		if ( !is_resource($parser) )			trigger_error( "Failed to create an instance of PHP's XML parser. http://www.php.net/manual/en/ref.xml.php");		$this->parser = $parser;		# pass in parser, and a reference to this object		# set up handlers		#		xml_set_object( $this->parser, $this );		xml_set_element_handler($this->parser,				'feed_start_element', 'feed_end_element' );		xml_set_character_data_handler( $this->parser, 'feed_cdata' );		$status = xml_parse( $this->parser, $source );		if (! $status ) {			$errorcode = xml_get_error_code( $this->parser );			if ( $errorcode != XML_ERROR_NONE ) {				$xml_error = xml_error_string( $errorcode );				$error_line = xml_get_current_line_number($this->parser);				$error_col = xml_get_current_column_number($this->parser);				$errormsg = "$xml_error at line $error_line, column $error_col";				$this->error( $errormsg );			}		}		xml_parser_free( $this->parser );		$this->normalize();	}	function feed_start_element($p, $element, &$attrs) {		$el = $element = strtolower($element);		$attrs = array_change_key_case($attrs, CASE_LOWER);		// check for a namespace, and split if found		$ns	= false;		if ( strpos( $element, ':' ) ) {			list($ns, $el) = split( ':', $element, 2);		}		if ( $ns and $ns != 'rdf' ) {			$this->current_namespace = $ns;		}		# if feed type isn't set, then this is first element of feed		# identify feed from root element		#		if (!isset($this->feed_type) ) {			if ( $el == 'rdf' ) {				$this->feed_type = RSS;				$this->feed_version = '1.0';			}			elseif ( $el == 'rss' ) {				$this->feed_type = RSS;				$this->feed_version = $attrs['version'];			}			elseif ( $el == 'feed' ) {				$this->feed_type = ATOM;				$this->feed_version = $attrs['version'];				$this->inchannel = true;			}			return;		}		if ( $el == 'channel' )		{			$this->inchannel = true;		}		elseif ($el == 'item' or $el == 'entry' )		{			$this->initem = true;			if ( isset($attrs['rdf:about']) ) {				$this->current_item['about'] = $attrs['rdf:about'];			}		}		// if we're in the default namespace of an RSS feed,		//  record textinput or image fields		elseif (			$this->feed_type == RSS and			$this->current_namespace == '' and			$el == 'textinput' )		{			$this->intextinput = true;		}		elseif (			$this->feed_type == RSS and			$this->current_namespace == '' and			$el == 'image' )		{			$this->inimage = true;		}		# handle atom content constructs		elseif ( $this->feed_type == ATOM and in_array($el, $this->_CONTENT_CONSTRUCTS) )		{			// avoid clashing w/ RSS mod_content			if ($el == 'content' ) {				$el = 'atom_content';			}			$this->incontent = $el;		}		// if inside an Atom content construct (e.g. content or summary) field treat tags as text		elseif ($this->feed_type == ATOM and $this->incontent )		{			// if tags are inlined, then flatten			$attrs_str = join(' ',					array_map(array('MagpieRSS', 'map_attrs'),					array_keys($attrs),					array_values($attrs) ) );			$this->append_content( "<$element $attrs_str>"  );			array_unshift( $this->stack, $el );		}		// Atom support many links per containging element.		// Magpie treats link elements of type rel='alternate'		// as being equivalent to RSS's simple link element.		//		elseif ($this->feed_type == ATOM and $el == 'link' )		{			if ( isset($attrs['rel']) and $attrs['rel'] == 'alternate' )			{				$link_el = 'link';			}			else {				$link_el = 'link_' . $attrs['rel'];			}			$this->append($link_el, $attrs['href']);		}		// set stack[0] to current element		else {			array_unshift($this->stack, $el);		}	}	function feed_cdata ($p, $text) {		if ($this->feed_type == ATOM and $this->incontent)		{			$this->append_content( $text );		}		else {			$current_el = join('_', array_reverse($this->stack));			$this->append($current_el, $text);		}	}	function feed_end_element ($p, $el) {		$el = strtolower($el);		if ( $el == 'item' or $el == 'entry' )		{			$this->items[] = $this->current_item;			$this->current_item = array();			$this->initem = false;		}		elseif ($this->feed_type == RSS and $this->current_namespace == '' and $el == 'textinput' )		{			$this->intextinput = false;		}		elseif ($this->feed_type == RSS and $this->current_namespace == '' and $el == 'image' )		{			$this->inimage = false;		}		elseif ($this->feed_type == ATOM and in_array($el, $this->_CONTENT_CONSTRUCTS) )		{			$this->incontent = false;		}		elseif ($el == 'channel' or $el == 'feed' )		{			$this->inchannel = false;		}		elseif ($this->feed_type == ATOM and $this->incontent  ) {			// balance tags properly			// note:  i don't think this is actually neccessary			if ( $this->stack[0] == $el )			{				$this->append_content("</$el>");			}			else {				$this->append_content("<$el />");			}			array_shift( $this->stack );		}		else {			array_shift( $this->stack );		}		$this->current_namespace = false;	}	function concat (&$str1, $str2="") {		if (!isset($str1) ) {			$str1="";		}		$str1 .= $str2;	}	function append_content($text) {		if ( $this->initem ) {			$this->concat( $this->current_item[ $this->incontent ], $text );		}		elseif ( $this->inchannel ) {			$this->concat( $this->channel[ $this->incontent ], $text );		}	}	// smart append - field and namespace aware	function append($el, $text) {		if (!$el) {			return;		}		if ( $this->current_namespace )		{			if ( $this->initem ) {				$this->concat(					$this->current_item[ $this->current_namespace ][ $el ], $text);			}			elseif ($this->inchannel) {				$this->concat(					$this->channel[ $this->current_namespace][ $el ], $text );			}			elseif ($this->intextinput) {				$this->concat(					$this->textinput[ $this->current_namespace][ $el ], $text );			}			elseif ($this->inimage) {				$this->concat(					$this->image[ $this->current_namespace ][ $el ], $text );			}		}		else {			if ( $this->initem ) {				$this->concat(					$this->current_item[ $el ], $text);			}			elseif ($this->intextinput) {				$this->concat(					$this->textinput[ $el ], $text );			}			elseif ($this->inimage) {				$this->concat(					$this->image[ $el ], $text );			}			elseif ($this->inchannel) {				$this->concat(					$this->channel[ $el ], $text );			}		}	}	function normalize () {		// if atom populate rss fields		if ( $this->is_atom() ) {			$this->channel['descripton'] = $this->channel['tagline'];			for ( $i = 0; $i < count($this->items); $i++) {				$item = $this->items[$i];				if ( isset($item['summary']) )					$item['description'] = $item['summary'];				if ( isset($item['atom_content']))					$item['content']['encoded'] = $item['atom_content'];				$this->items[$i] = $item;			}		}		elseif ( $this->is_rss() ) {			$this->channel['tagline'] = $this->channel['description'];			for ( $i = 0; $i < count($this->items); $i++) {				$item = $this->items[$i];				if ( isset($item['description']))					$item['summary'] = $item['description'];				if ( isset($item['content']['encoded'] ) )					$item['atom_content'] = $item['content']['encoded'];				$this->items[$i] = $item;			}		}	}	function is_rss () {		if ( $this->feed_type == RSS ) {			return $this->feed_version;		}		else {			return false;		}	}	function is_atom() {		if ( $this->feed_type == ATOM ) {			return $this->feed_version;		}		else {			return false;		}	}	function map_attrs($k, $v) {		return "$k=\"$v\"";	}	function error( $errormsg, $lvl = E_USER_WARNING ) {		// append PHP's error message if track_errors enabled		if ( isset($php_errormsg) ) {			$errormsg .= " ($php_errormsg)";		}		if ( MAGPIE_DEBUG ) {			trigger_error( $errormsg, $lvl);		} else {			error_log( $errormsg, 0);		}	}}if ( !function_exists('fetch_rss') ) :/** * Build Magpie object based on RSS from URL. * * @since unknown * @package External * @subpackage MagpieRSS * * @param string $url URL to retrieve feed * @return bool|MagpieRSS false on failure or MagpieRSS object on success. */function fetch_rss ($url) {	// initialize constants	init();	if ( !isset($url) ) {		// error("fetch_rss called without a url");		return false;	}	// if cache is disabled	if ( !MAGPIE_CACHE_ON ) {		// fetch file, and parse it		$resp = _fetch_remote_file( $url );		if ( is_success( $resp->status ) ) {			return _response_to_rss( $resp );		}		else {			// error("Failed to fetch $url and cache is off");			return false;		}	}	// else cache is ON	else {		// Flow		// 1. check cache		// 2. if there is a hit, make sure its fresh		// 3. if cached obj fails freshness check, fetch remote		// 4. if remote fails, return stale object, or error		$cache = new RSSCache( MAGPIE_CACHE_DIR, MAGPIE_CACHE_AGE );		if (MAGPIE_DEBUG and $cache->ERROR) {			debug($cache->ERROR, E_USER_WARNING);		}		$cache_status 	 = 0;		// response of check_cache		$request_headers = array(); // HTTP headers to send with fetch		$rss 			 = 0;		// parsed RSS object		$errormsg		 = 0;		// errors, if any		if (!$cache->ERROR) {			// return cache HIT, MISS, or STALE			$cache_status = $cache->check_cache( $url );		}		// if object cached, and cache is fresh, return cached obj		if ( $cache_status == 'HIT' ) {			$rss = $cache->get( $url );			if ( isset($rss) and $rss ) {				$rss->from_cache = 1;				if ( MAGPIE_DEBUG > 1) {				debug("MagpieRSS: Cache HIT", E_USER_NOTICE);			}				return $rss;			}		}		// else attempt a conditional get		// set up headers		if ( $cache_status == 'STALE' ) {			$rss = $cache->get( $url );			if ( isset($rss->etag) and $rss->last_modified ) {				$request_headers['If-None-Match'] = $rss->etag;				$request_headers['If-Last-Modified'] = $rss->last_modified;			}		}		$resp = _fetch_remote_file( $url, $request_headers );		if (isset($resp) and $resp) {			if ($resp->status == '304' ) {				// we have the most current copy				if ( MAGPIE_DEBUG > 1) {					debug("Got 304 for $url");				}				// reset cache on 304 (at minutillo insistent prodding)				$cache->set($url, $rss);				return $rss;			}			elseif ( is_success( $resp->status ) ) {				$rss = _response_to_rss( $resp );				if ( $rss ) {					if (MAGPIE_DEBUG > 1) {						debug("Fetch successful");					}					// add object to cache					$cache->set( $url, $rss );					return $rss;				}			}			else {				$errormsg = "Failed to fetch $url. ";				if ( $resp->error ) {					# compensate for Snoopy's annoying habbit to tacking					# on '\n'					$http_error = substr($resp->error, 0, -2);					$errormsg .= "(HTTP Error: $http_error)";				}				else {					$errormsg .=  "(HTTP Response: " . $resp->response_code .')';				}			}		}		else {			$errormsg = "Unable to retrieve RSS file for unknown reasons.";		}		// else fetch failed		// attempt to return cached object		if ($rss) {			if ( MAGPIE_DEBUG ) {				debug("Returning STALE object for $url");			}			return $rss;		}		// else we totally failed		// error( $errormsg );		return false;	} // end if ( !MAGPIE_CACHE_ON ) {} // end fetch_rss()endif;/** * Retrieve URL headers and content using WP HTTP Request API. * * @since unknown * @package External * @subpackage MagpieRSS * * @param string $url URL to retrieve * @param array $headers Optional. Headers to send to the URL. * @return Snoopy style response */function _fetch_remote_file($url, $headers = "" ) {	$resp = wp_remote_request($url, array('headers' => $headers, 'timeout' => MAGPIE_FETCH_TIME_OUT));	if ( is_wp_error($resp) ) {		$error = array_shift($resp->errors);		$resp = new stdClass;		$resp->status = 500;		$resp->response_code = 500;		$resp->error = $error[0] . "\n"; //\n = Snoopy compatibility		return $resp;	}	// Snoopy returns headers unprocessed.	// Also note, WP_HTTP lowercases all keys, Snoopy did not.	$return_headers = array();	foreach ( $resp['headers'] as $key => $value ) {		if ( !is_array($value) ) {			$return_headers[] = "$key: $value";		} else {			foreach ( $value as $v )				$return_headers[] = "$key: $v";		}	}	$response = new stdClass;	$response->status = $resp['response']['code'];	$response->response_code = $resp['response']['code'];	$response->headers = $return_headers;	$response->results = $resp['body'];	return $response;}/** * Retrieve * * @since unknown * @package External * @subpackage MagpieRSS * * @param unknown_type $resp * @return unknown */function _response_to_rss ($resp) {	$rss = new MagpieRSS( $resp->results );	// if RSS parsed successfully	if ( $rss && (!isset($rss->ERROR) || !$rss->ERROR) ) {		// find Etag, and Last-Modified		foreach( (array) $resp->headers as $h) {			// 2003-03-02 - Nicola Asuni (www.tecnick.com) - fixed bug "Undefined offset: 1"			if (strpos($h, ": ")) {				list($field, $val) = explode(": ", $h, 2);			}			else {				$field = $h;				$val = "";			}			if ( $field == 'etag' ) {				$rss->etag = $val;			}			if ( $field == 'last-modified' ) {				$rss->last_modified = $val;			}		}		return $rss;	} // else construct error message	else {		$errormsg = "Failed to parse RSS file.";		if ($rss) {			$errormsg .= " (" . $rss->ERROR . ")";		}		// error($errormsg);		return false;	} // end if ($rss and !$rss->error)}/** * Set up constants with default values, unless user overrides. * * @since unknown * @package External * @subpackage MagpieRSS */function init () {	if ( defined('MAGPIE_INITALIZED') ) {		return;	}	else {		define('MAGPIE_INITALIZED', 1);	}	if ( !defined('MAGPIE_CACHE_ON') ) {		define('MAGPIE_CACHE_ON', 1);	}	if ( !defined('MAGPIE_CACHE_DIR') ) {		define('MAGPIE_CACHE_DIR', './cache');	}	if ( !defined('MAGPIE_CACHE_AGE') ) {		define('MAGPIE_CACHE_AGE', 60*60); // one hour	}	if ( !defined('MAGPIE_CACHE_FRESH_ONLY') ) {		define('MAGPIE_CACHE_FRESH_ONLY', 0);	}		if ( !defined('MAGPIE_DEBUG') ) {		define('MAGPIE_DEBUG', 0);	}	if ( !defined('MAGPIE_USER_AGENT') ) {		$ua = 'WordPress/' . $GLOBALS['wp_version'];		if ( MAGPIE_CACHE_ON ) {			$ua = $ua . ')';		}		else {			$ua = $ua . '; No cache)';		}		define('MAGPIE_USER_AGENT', $ua);	}	if ( !defined('MAGPIE_FETCH_TIME_OUT') ) {		define('MAGPIE_FETCH_TIME_OUT', 2);	// 2 second timeout	}	// use gzip encoding to fetch rss files if supported?	if ( !defined('MAGPIE_USE_GZIP') ) {		define('MAGPIE_USE_GZIP', true);	}}function is_info ($sc) {	return $sc >= 100 && $sc < 200;}function is_success ($sc) {	return $sc >= 200 && $sc < 300;}function is_redirect ($sc) {	return $sc >= 300 && $sc < 400;}function is_error ($sc) {	return $sc >= 400 && $sc < 600;}function is_client_error ($sc) {	return $sc >= 400 && $sc < 500;}function is_server_error ($sc) {	return $sc >= 500 && $sc < 600;}class RSSCache {	var $BASE_CACHE;	// where the cache files are stored	var $MAX_AGE	= 43200;  		// when are files stale, default twelve hours	var $ERROR 		= '';			// accumulate error messages	function RSSCache ($base='', $age='') {		$this->BASE_CACHE = WP_CONTENT_DIR . '/cache';		if ( $base ) {			$this->BASE_CACHE = $base;		}		if ( $age ) {			$this->MAX_AGE = $age;		}	}/*=======================================================================*\	Function:	set	Purpose:	add an item to the cache, keyed on url	Input:		url from wich the rss file was fetched	Output:		true on sucess\*=======================================================================*/	function set ($url, $rss) {		$cache_option = 'rss_' . $this->file_name( $url );		set_transient($cache_option, $rss, $this->MAX_AGE);		return $cache_option;	}/*=======================================================================*\	Function:	get	Purpose:	fetch an item from the cache	Input:		url from wich the rss file was fetched	Output:		cached object on HIT, false on MISS\*=======================================================================*/	function get ($url) {		$this->ERROR = "";		$cache_option = 'rss_' . $this->file_name( $url );		if ( ! $rss = get_transient( $cache_option ) ) {			$this->debug(				"Cache doesn't contain: $url (cache option: $cache_option)"			);			return 0;		}		return $rss;	}/*=======================================================================*\	Function:	check_cache	Purpose:	check a url for membership in the cache				and whether the object is older then MAX_AGE (ie. STALE)	Input:		url from wich the rss file was fetched	Output:		cached object on HIT, false on MISS\*=======================================================================*/	function check_cache ( $url ) {		$this->ERROR = "";		$cache_option = 'rss_' . $this->file_name( $url );		if ( get_transient($cache_option) ) {			// object exists and is current				return 'HIT';		} else {			// object does not exist			return 'MISS';		}	}/*=======================================================================*\	Function:	serialize\*=======================================================================*/	function serialize ( $rss ) {		return serialize( $rss );	}/*=======================================================================*\	Function:	unserialize\*=======================================================================*/	function unserialize ( $data ) {		return unserialize( $data );	}/*=======================================================================*\	Function:	file_name	Purpose:	map url to location in cache	Input:		url from wich the rss file was fetched	Output:		a file name\*=======================================================================*/	function file_name ($url) {		return md5( $url );	}/*=======================================================================*\	Function:	error	Purpose:	register error\*=======================================================================*/	function error ($errormsg, $lvl=E_USER_WARNING) {		// append PHP's error message if track_errors enabled		if ( isset($php_errormsg) ) {			$errormsg .= " ($php_errormsg)";		}		$this->ERROR = $errormsg;		if ( MAGPIE_DEBUG ) {			trigger_error( $errormsg, $lvl);		}		else {			error_log( $errormsg, 0);		}	}			function debug ($debugmsg, $lvl=E_USER_NOTICE) {		if ( MAGPIE_DEBUG ) {			$this->error("MagpieRSS [debug] $debugmsg", $lvl);		}	}}if ( !function_exists('parse_w3cdtf') ) :function parse_w3cdtf ( $date_str ) {	# regex to match wc3dtf	$pat = "/(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(:(\d{2}))?(?:([-+])(\d{2}):?(\d{2})|(Z))?/";	if ( preg_match( $pat, $date_str, $match ) ) {		list( $year, $month, $day, $hours, $minutes, $seconds) =			array( $match[1], $match[2], $match[3], $match[4], $match[5], $match[7]);		# calc epoch for current date assuming GMT		$epoch = gmmktime( $hours, $minutes, $seconds, $month, $day, $year);		$offset = 0;		if ( $match[11] == 'Z' ) {			# zulu time, aka GMT		}		else {			list( $tz_mod, $tz_hour, $tz_min ) =				array( $match[8], $match[9], $match[10]);			# zero out the variables			if ( ! $tz_hour ) { $tz_hour = 0; }			if ( ! $tz_min ) { $tz_min = 0; }			$offset_secs = (($tz_hour*60)+$tz_min)*60;			# is timezone ahead of GMT?  then subtract offset			#			if ( $tz_mod == '+' ) {				$offset_secs = $offset_secs * -1;			}			$offset = $offset_secs;		}		$epoch = $epoch + $offset;		return $epoch;	}	else {		return -1;	}}endif;if ( !function_exists('wp_rss') ) :/** * Display all RSS items in a HTML ordered list. * * @since unknown * @package External * @subpackage MagpieRSS * * @param string $url URL of feed to display. Will not auto sense feed URL. * @param int $num_items Optional. Number of items to display, default is all. */function wp_rss( $url, $num_items = -1 ) {	if ( $rss = fetch_rss( $url ) ) {		echo '<ul>';		if ( $num_items !== -1 ) {			$rss->items = array_slice( $rss->items, 0, $num_items );		}		foreach ( (array) $rss->items as $item ) {			printf(				'<li><a href="%1$s" title="%2$s">%3$s</a></li>',				esc_url( $item['link'] ),				esc_attr( strip_tags( $item['description'] ) ),				htmlentities( $item['title'] )			);		}		echo '</ul>';	} else {		_e( 'An error has occurred, which probably means the feed is down. Try again later.' );	}}endif;if ( !function_exists('get_rss') ) :/** * Display RSS items in HTML list items. * * You have to specify which HTML list you want, either ordered or unordered * before using the function. You also have to specify how many items you wish * to display. You can't display all of them like you can with wp_rss() * function. * * @since unknown * @package External * @subpackage MagpieRSS * * @param string $url URL of feed to display. Will not auto sense feed URL. * @param int $num_items Optional. Number of items to display, default is all. * @return bool False on failure. */function get_rss ($url, $num_items = 5) { // Like get posts, but for RSS	$rss = fetch_rss($url);	if ( $rss ) {		$rss->items = array_slice($rss->items, 0, $num_items);		foreach ( (array) $rss->items as $item ) {			echo "<li>\n";			echo "<a href='$item[link]' title='$item[description]'>";			echo htmlentities($item['title']);			echo "</a><br />\n";			echo "</li>\n";		}	} else {		return false;	}}endif;?>
<?php/** * Creates common globals for the rest of WordPress * * Sets $pagenow global which is the current page. Checks * for the browser to set which one is currently being used. * * Detects which user environment WordPress is being used on. * Only attempts to check for Apache and IIS. Two web servers * with known permalink capability. * * @package WordPress */// On which page are we ?if ( is_admin() ) {	// wp-admin pages are checked more carefully	preg_match('#/wp-admin/?(.*?)$#i', $PHP_SELF, $self_matches);	$pagenow = $self_matches[1];	$pagenow = trim($pagenow, '/');	$pagenow = preg_replace('#\?.*?$#', '', $pagenow);	if ( '' === $pagenow || 'index' === $pagenow || 'index.php' === $pagenow ) {		$pagenow = 'index.php';	} else {		preg_match('#(.*?)(/|$)#', $pagenow, $self_matches);		$pagenow = strtolower($self_matches[1]);		if ( '.php' !== substr($pagenow, -4, 4) )			$pagenow .= '.php'; // for Options +Multiviews: /wp-admin/themes/index.php (themes.php is queried)	}} else {	if ( preg_match('#([^/]+\.php)([?/].*?)?$#i', $PHP_SELF, $self_matches) )		$pagenow = strtolower($self_matches[1]);	else		$pagenow = 'index.php';}// Simple browser detection$is_lynx = $is_gecko = $is_winIE = $is_macIE = $is_opera = $is_NS4 = $is_safari = $is_chrome = $is_iphone = false;if ( isset($_SERVER['HTTP_USER_AGENT']) ) {	if ( strpos($_SERVER['HTTP_USER_AGENT'], 'Lynx') !== false ) {		$is_lynx = true;	} elseif ( stripos($_SERVER['HTTP_USER_AGENT'], 'chrome') !== false ) {		$is_chrome = true;	} elseif ( stripos($_SERVER['HTTP_USER_AGENT'], 'safari') !== false ) {		$is_safari = true;	} elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'Gecko') !== false ) {		$is_gecko = true;	} elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== false && strpos($_SERVER['HTTP_USER_AGENT'], 'Win') !== false ) {		$is_winIE = true;	} elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'MSIE') !== false && strpos($_SERVER['HTTP_USER_AGENT'], 'Mac') !== false ) {		$is_macIE = true;	} elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'Opera') !== false ) {		$is_opera = true;	} elseif ( strpos($_SERVER['HTTP_USER_AGENT'], 'Nav') !== false && strpos($_SERVER['HTTP_USER_AGENT'], 'Mozilla/4.') !== false ) {		$is_NS4 = true;	}}if ( $is_safari && stripos($_SERVER['HTTP_USER_AGENT'], 'mobile') !== false )	$is_iphone = true;$is_IE = ( $is_macIE || $is_winIE );// Server detection/** * Whether the server software is Apache or something else * @global bool $is_apache */$is_apache = (strpos($_SERVER['SERVER_SOFTWARE'], 'Apache') !== false || strpos($_SERVER['SERVER_SOFTWARE'], 'LiteSpeed') !== false);/** * Whether the server software is IIS or something else * @global bool $is_IIS */$is_IIS = (strpos($_SERVER['SERVER_SOFTWARE'], 'Microsoft-IIS') !== false || strpos($_SERVER['SERVER_SOFTWARE'], 'ExpressionDevServer') !== false);/** * Whether the server software is IIS 7.X * @global bool $is_iis7 */$is_iis7 = (strpos($_SERVER['SERVER_SOFTWARE'], 'Microsoft-IIS/7.') !== false);?>
<?php/** * WordPress implementation for PHP functions missing from older PHP versions. * * @package PHP * @access private */// Added in PHP 5.0if (!function_exists('http_build_query')) {	function http_build_query($data, $prefix=null, $sep=null) {		return _http_build_query($data, $prefix, $sep);	}}// from php.net (modified by Mark Jaquith to behave like the native PHP5 function)function _http_build_query($data, $prefix=null, $sep=null, $key='', $urlencode=true) {	$ret = array();	foreach ( (array) $data as $k => $v ) {		if ( $urlencode)			$k = urlencode($k);		if ( is_int($k) && $prefix != null )			$k = $prefix.$k;		if ( !empty($key) )			$k = $key . '%5B' . $k . '%5D';		if ( $v === NULL )			continue;		elseif ( $v === FALSE )			$v = '0';		if ( is_array($v) || is_object($v) )			array_push($ret,_http_build_query($v, '', $sep, $k, $urlencode));		elseif ( $urlencode )			array_push($ret, $k.'='.urlencode($v));		else			array_push($ret, $k.'='.$v);	}	if ( NULL === $sep )		$sep = ini_get('arg_separator.output');	return implode($sep, $ret);}if ( !function_exists('_') ) {	function _($string) {		return $string;	}}if (!function_exists('stripos')) {	function stripos($haystack, $needle, $offset = 0) {		return strpos(strtolower($haystack), strtolower($needle), $offset);	}}if ( !function_exists('hash_hmac') ):function hash_hmac($algo, $data, $key, $raw_output = false) {	return _hash_hmac($algo, $data, $key, $raw_output);}endif;function _hash_hmac($algo, $data, $key, $raw_output = false) {	$packs = array('md5' => 'H32', 'sha1' => 'H40');	if ( !isset($packs[$algo]) )		return false;	$pack = $packs[$algo];	if (strlen($key) > 64)		$key = pack($pack, $algo($key));	$key = str_pad($key, 64, chr(0));	$ipad = (substr($key, 0, 64) ^ str_repeat(chr(0x36), 64));	$opad = (substr($key, 0, 64) ^ str_repeat(chr(0x5C), 64));	$hmac = $algo($opad . pack($pack, $algo($ipad . $data)));	if ( $raw_output )		return pack( $pack, $hmac );	return $hmac;}if ( !function_exists('mb_substr') ):	function mb_substr( $str, $start, $length=null, $encoding=null ) {		return _mb_substr($str, $start, $length, $encoding);	}endif;function _mb_substr( $str, $start, $length=null, $encoding=null ) {	// the solution below, works only for utf-8, so in case of a different	// charset, just use built-in substr	$charset = get_option( 'blog_charset' );	if ( !in_array( $charset, array('utf8', 'utf-8', 'UTF8', 'UTF-8') ) ) {		return is_null( $length )? substr( $str, $start ) : substr( $str, $start, $length);	}	// use the regex unicode support to separate the UTF-8 characters into an array	preg_match_all( '/./us', $str, $match );	$chars = is_null( $length )? array_slice( $match[0], $start ) : array_slice( $match[0], $start, $length );	return implode( '', $chars );}if ( !function_exists( 'htmlspecialchars_decode' ) ) {	// Added in PHP 5.1.0	// Error checks from PEAR::PHP_Compat	function htmlspecialchars_decode( $string, $quote_style = ENT_COMPAT )	{		if ( !is_scalar( $string ) ) {			trigger_error( 'htmlspecialchars_decode() expects parameter 1 to be string, ' . gettype( $string ) . ' given', E_USER_WARNING );			return;		}		if ( !is_int( $quote_style ) && $quote_style !== null ) {			trigger_error( 'htmlspecialchars_decode() expects parameter 2 to be integer, ' . gettype( $quote_style ) . ' given', E_USER_WARNING );			return;		}		return wp_specialchars_decode( $string, $quote_style );	}}// For PHP < 5.2.0if ( !function_exists('json_encode') ) {	function json_encode( $string ) {		global $wp_json;		if ( !is_a($wp_json, 'Services_JSON') ) {			require_once( ABSPATH . WPINC . '/class-json.php' );			$wp_json = new Services_JSON();		}		return $wp_json->encodeUnsafe( $string );	}}if ( !function_exists('json_decode') ) {	function json_decode( $string, $assoc_array = false ) {		global $wp_json;		if ( !is_a($wp_json, 'Services_JSON') ) {			require_once( ABSPATH . WPINC . '/class-json.php' );			$wp_json = new Services_JSON();		}		$res = $wp_json->decode( $string );		if ( $assoc_array )			$res = _json_decode_object_helper( $res );		return $res;	}	function _json_decode_object_helper($data) {		if ( is_object($data) )			$data = get_object_vars($data);		return is_array($data) ? array_map(__FUNCTION__, $data) : $data;	}}// pathinfo that fills 'filename' without extension like in PHP 5.2+function pathinfo52($path) {	$parts = pathinfo($path);	if ( !isset($parts['filename']) ) {		$parts['filename'] = substr( $parts['basename'], 0, strrpos($parts['basename'], '.') );		if ( empty($parts['filename']) ) // there's no extension			$parts['filename'] = $parts['basename'];	}	return $parts;}
<?php/** * WordPress FTP Filesystem. * * @package WordPress * @subpackage Filesystem *//** * WordPress Filesystem Class for implementing FTP. * * @since 2.5 * @package WordPress * @subpackage Filesystem * @uses WP_Filesystem_Base Extends class */class WP_Filesystem_FTPext extends WP_Filesystem_Base {	var $link;	var $errors = null;	var $options = array();	function WP_Filesystem_FTPext($opt='') {		$this->method = 'ftpext';		$this->errors = new WP_Error();		//Check if possible to use ftp functions.		if ( ! extension_loaded('ftp') ) {			$this->errors->add('no_ftp_ext', __('The ftp PHP extension is not available'));			return false;		}		// Set defaults:		//This Class uses the timeout on a per-connection basis, Others use it on a per-action basis.		if ( ! defined('FS_TIMEOUT') )			define('FS_TIMEOUT', 240);		if ( empty($opt['port']) )			$this->options['port'] = 21;		else			$this->options['port'] = $opt['port'];		if ( empty($opt['hostname']) )			$this->errors->add('empty_hostname', __('FTP hostname is required'));		else			$this->options['hostname'] = $opt['hostname'];		if ( ! empty($opt['base']) )			$this->wp_base = $opt['base'];		// Check if the options provided are OK.		if ( empty($opt['username']) )			$this->errors->add('empty_username', __('FTP username is required'));		else			$this->options['username'] = $opt['username'];		if ( empty($opt['password']) )			$this->errors->add('empty_password', __('FTP password is required'));		else			$this->options['password'] = $opt['password'];		$this->options['ssl'] = false;		if ( isset($opt['connection_type']) && 'ftps' == $opt['connection_type'] )			$this->options['ssl'] = true;	}	function connect() {		if ( isset($this->options['ssl']) && $this->options['ssl'] && function_exists('ftp_ssl_connect') )			$this->link = @ftp_ssl_connect($this->options['hostname'], $this->options['port'], FS_CONNECT_TIMEOUT);		else			$this->link = @ftp_connect($this->options['hostname'], $this->options['port'], FS_CONNECT_TIMEOUT);		if ( ! $this->link ) {			$this->errors->add('connect', sprintf(__('Failed to connect to FTP Server %1$s:%2$s'), $this->options['hostname'], $this->options['port']));			return false;		}		if ( ! @ftp_login($this->link,$this->options['username'], $this->options['password']) ) {			$this->errors->add('auth', sprintf(__('Username/Password incorrect for %s'), $this->options['username']));			return false;		}		//Set the Connection to use Passive FTP		@ftp_pasv( $this->link, true );		if ( @ftp_get_option($this->link, FTP_TIMEOUT_SEC) < FS_TIMEOUT )			@ftp_set_option($this->link, FTP_TIMEOUT_SEC, FS_TIMEOUT);		return true;	}	function get_contents($file, $type = '', $resumepos = 0 ) {		if ( empty($type) )			$type = FTP_BINARY;		$tempfile = wp_tempnam($file);		$temp = fopen($tempfile, 'w+');		if ( ! $temp )			return false;		if ( ! @ftp_fget($this->link, $temp, $file, $type, $resumepos) )			return false;		fseek($temp, 0); //Skip back to the start of the file being written to		$contents = '';		while ( ! feof($temp) )			$contents .= fread($temp, 8192);		fclose($temp);		unlink($tempfile);		return $contents;	}	function get_contents_array($file) {		return explode("\n", $this->get_contents($file));	}	function put_contents($file, $contents, $mode = false ) {		$tempfile = wp_tempnam($file);		$temp = fopen($tempfile, 'w+');		if ( ! $temp )			return false;		fwrite($temp, $contents);		fseek($temp, 0); //Skip back to the start of the file being written to		$type = $this->is_binary($contents) ? FTP_BINARY : FTP_ASCII;		$ret = @ftp_fput($this->link, $file, $temp, $type);		fclose($temp);		unlink($tempfile);		$this->chmod($file, $mode);		return $ret;	}	function cwd() {		$cwd = @ftp_pwd($this->link);		if ( $cwd )			$cwd = trailingslashit($cwd);		return $cwd;	}	function chdir($dir) {		return @ftp_chdir($this->link, $dir);	}	function chgrp($file, $group, $recursive = false ) {		return false;	}	function chmod($file, $mode = false, $recursive = false) {		if ( ! $mode ) {			if ( $this->is_file($file) )				$mode = FS_CHMOD_FILE;			elseif ( $this->is_dir($file) )				$mode = FS_CHMOD_DIR;			else				return false;		}		// chmod any sub-objects if recursive.		if ( $recursive && $this->is_dir($file) ) {			$filelist = $this->dirlist($file);			foreach ( (array)$filelist as $filename => $filemeta )				$this->chmod($file . '/' . $filename, $mode, $recursive);		}		// chmod the file or directory		if ( ! function_exists('ftp_chmod') )			return (bool)@ftp_site($this->link, sprintf('CHMOD %o %s', $mode, $file));		return (bool)@ftp_chmod($this->link, $mode, $file);	}	function chown($file, $owner, $recursive = false ) {		return false;	}	function owner($file) {		$dir = $this->dirlist($file);		return $dir[$file]['owner'];	}	function getchmod($file) {		$dir = $this->dirlist($file);		return $dir[$file]['permsn'];	}	function group($file) {		$dir = $this->dirlist($file);		return $dir[$file]['group'];	}	function copy($source, $destination, $overwrite = false ) {		if ( ! $overwrite && $this->exists($destination) )			return false;		$content = $this->get_contents($source);		if ( false === $content)			return false;		return $this->put_contents($destination, $content);	}	function move($source, $destination, $overwrite = false) {		return ftp_rename($this->link, $source, $destination);	}	function delete($file, $recursive = false ) {		if ( empty($file) )			return false;		if ( $this->is_file($file) )			return @ftp_delete($this->link, $file);		if ( !$recursive )			return @ftp_rmdir($this->link, $file);		$filelist = $this->dirlist( trailingslashit($file) );		if ( !empty($filelist) )			foreach ( $filelist as $delete_file )				$this->delete( trailingslashit($file) . $delete_file['name'], $recursive);		return @ftp_rmdir($this->link, $file);	}	function exists($file) {		$list = @ftp_nlist($this->link, $file);		return !empty($list); //empty list = no file, so invert.	}	function is_file($file) {		return $this->exists($file) && !$this->is_dir($file);	}	function is_dir($path) {		$cwd = $this->cwd();		$result = @ftp_chdir($this->link, trailingslashit($path) );		if ( $result && $path == $this->cwd() || $this->cwd() != $cwd ) {			@ftp_chdir($this->link, $cwd);			return true;		}		return false;	}	function is_readable($file) {		//Get dir list, Check if the file is readable by the current user??		return true;	}	function is_writable($file) {		//Get dir list, Check if the file is writable by the current user??		return true;	}	function atime($file) {		return false;	}	function mtime($file) {		return ftp_mdtm($this->link, $file);	}	function size($file) {		return ftp_size($this->link, $file);	}	function touch($file, $time = 0, $atime = 0) {		return false;	}	function mkdir($path, $chmod = false, $chown = false, $chgrp = false) {		if ( !@ftp_mkdir($this->link, $path) )			return false;		$this->chmod($path, $chmod);		if ( $chown )			$this->chown($path, $chown);		if ( $chgrp )			$this->chgrp($path, $chgrp);		return true;	}	function rmdir($path, $recursive = false) {		return $this->delete($path, $recursive);	}	function parselisting($line) {		static $is_windows;		if ( is_null($is_windows) )			$is_windows = stripos( ftp_systype($this->link), 'win') !== false;		if ( $is_windows && preg_match('/([0-9]{2})-([0-9]{2})-([0-9]{2}) +([0-9]{2}):([0-9]{2})(AM|PM) +([0-9]+|<DIR>) +(.+)/', $line, $lucifer) ) {			$b = array();			if ( $lucifer[3] < 70 )				$lucifer[3] +=2000;			else				$lucifer[3] += 1900; // 4digit year fix			$b['isdir'] = ( $lucifer[7] == '<DIR>');			if ( $b['isdir'] )				$b['type'] = 'd';			else				$b['type'] = 'f';			$b['size'] = $lucifer[7];			$b['month'] = $lucifer[1];			$b['day'] = $lucifer[2];			$b['year'] = $lucifer[3];			$b['hour'] = $lucifer[4];			$b['minute'] = $lucifer[5];			$b['time'] = @mktime($lucifer[4] + (strcasecmp($lucifer[6], "PM") == 0 ? 12 : 0), $lucifer[5], 0, $lucifer[1], $lucifer[2], $lucifer[3]);			$b['am/pm'] = $lucifer[6];			$b['name'] = $lucifer[8];		} elseif ( !$is_windows && $lucifer = preg_split('/[ ]/', $line, 9, PREG_SPLIT_NO_EMPTY)) {			//echo $line."\n";			$lcount = count($lucifer);			if ( $lcount < 8 )				return '';			$b = array();			$b['isdir'] = $lucifer[0]{0} === 'd';			$b['islink'] = $lucifer[0]{0} === 'l';			if ( $b['isdir'] )				$b['type'] = 'd';			elseif ( $b['islink'] )				$b['type'] = 'l';			else				$b['type'] = 'f';			$b['perms'] = $lucifer[0];			$b['number'] = $lucifer[1];			$b['owner'] = $lucifer[2];			$b['group'] = $lucifer[3];			$b['size'] = $lucifer[4];			if ( $lcount == 8 ) {				sscanf($lucifer[5], '%d-%d-%d', $b['year'], $b['month'], $b['day']);				sscanf($lucifer[6], '%d:%d', $b['hour'], $b['minute']);				$b['time'] = @mktime($b['hour'], $b['minute'], 0, $b['month'], $b['day'], $b['year']);				$b['name'] = $lucifer[7];			} else {				$b['month'] = $lucifer[5];				$b['day'] = $lucifer[6];				if ( preg_match('/([0-9]{2}):([0-9]{2})/', $lucifer[7], $l2) ) {					$b['year'] = date("Y");					$b['hour'] = $l2[1];					$b['minute'] = $l2[2];				} else {					$b['year'] = $lucifer[7];					$b['hour'] = 0;					$b['minute'] = 0;				}				$b['time'] = strtotime( sprintf('%d %s %d %02d:%02d', $b['day'], $b['month'], $b['year'], $b['hour'], $b['minute']) );				$b['name'] = $lucifer[8];			}		}		return $b;	}	function dirlist($path = '.', $include_hidden = true, $recursive = false) {		if ( $this->is_file($path) ) {			$limit_file = basename($path);			$path = dirname($path) . '/';		} else {			$limit_file = false;		}		$pwd = @ftp_pwd($this->link);		if ( ! @ftp_chdir($this->link, $path) ) // Cant change to folder = folder doesnt exist			return false;		$list = @ftp_rawlist($this->link, '-a', false);		@ftp_chdir($this->link, $pwd);		if ( empty($list) ) // Empty array = non-existent folder (real folder will show . at least)			return false;		$dirlist = array();		foreach ( $list as $k => $v ) {			$entry = $this->parselisting($v);			if ( empty($entry) )				continue;			if ( '.' == $entry['name'] || '..' == $entry['name'] )				continue;			if ( ! $include_hidden && '.' == $entry['name'][0] )				continue;			if ( $limit_file && $entry['name'] != $limit_file)				continue;			$dirlist[ $entry['name'] ] = $entry;		}		$ret = array();		foreach ( (array)$dirlist as $struc ) {			if ( 'd' == $struc['type'] ) {				if ( $recursive )					$struc['files'] = $this->dirlist($path . '/' . $struc['name'], $include_hidden, $recursive);				else					$struc['files'] = array();			}			$ret[ $struc['name'] ] = $struc;		}		return $ret;	}	function __destruct() {		if ( $this->link )			ftp_close($this->link);	}}?>
<?php/** * IXR - The Inutio XML-RPC Library * * @package IXR * @since 1.5 * * @copyright Incutio Ltd 2002-2005 * @version 1.7 (beta) 23rd May 2005 * @author Simon Willison * @link http://scripts.incutio.com/xmlrpc/ Site * @link http://scripts.incutio.com/xmlrpc/manual.php Manual * @license BSD License http://www.opensource.org/licenses/bsd-license.php *//** * IXR_Value * * @package IXR * @since 1.5 */class IXR_Value {    var $data;    var $type;    function IXR_Value ($data, $type = false) {        $this->data = $data;        if (!$type) {            $type = $this->calculateType();        }        $this->type = $type;        if ($type == 'struct') {            /* Turn all the values in the array in to new IXR_Value objects */            foreach ($this->data as $key => $value) {                $this->data[$key] = new IXR_Value($value);            }        }        if ($type == 'array') {            for ($i = 0, $j = count($this->data); $i < $j; $i++) {                $this->data[$i] = new IXR_Value($this->data[$i]);            }        }    }    function calculateType() {        if ($this->data === true || $this->data === false) {            return 'boolean';        }        if (is_integer($this->data)) {            return 'int';        }        if (is_double($this->data)) {            return 'double';        }        // Deal with IXR object types base64 and date        if (is_object($this->data) && is_a($this->data, 'IXR_Date')) {            return 'date';        }        if (is_object($this->data) && is_a($this->data, 'IXR_Base64')) {            return 'base64';        }        // If it is a normal PHP object convert it in to a struct        if (is_object($this->data)) {            $this->data = get_object_vars($this->data);            return 'struct';        }        if (!is_array($this->data)) {            return 'string';        }        /* We have an array - is it an array or a struct ? */        if ($this->isStruct($this->data)) {            return 'struct';        } else {            return 'array';        }    }    function getXml() {        /* Return XML for this value */        switch ($this->type) {            case 'boolean':                return '<boolean>'.(($this->data) ? '1' : '0').'</boolean>';                break;            case 'int':                return '<int>'.$this->data.'</int>';                break;            case 'double':                return '<double>'.$this->data.'</double>';                break;            case 'string':                return '<string>'.htmlspecialchars($this->data).'</string>';                break;            case 'array':                $return = '<array><data>'."\n";                foreach ($this->data as $item) {                    $return .= '  <value>'.$item->getXml()."</value>\n";                }                $return .= '</data></array>';                return $return;                break;            case 'struct':                $return = '<struct>'."\n";                foreach ($this->data as $name => $value) {					$name = htmlspecialchars($name);                    $return .= "  <member><name>$name</name><value>";                    $return .= $value->getXml()."</value></member>\n";                }                $return .= '</struct>';                return $return;                break;            case 'date':            case 'base64':                return $this->data->getXml();                break;        }        return false;    }    function isStruct($array) {        /* Nasty function to check if an array is a struct or not */        $expected = 0;        foreach ($array as $key => $value) {            if ((string)$key != (string)$expected) {                return true;            }            $expected++;        }        return false;    }}/** * IXR_Message * * @package IXR * @since 1.5 */class IXR_Message {    var $message;    var $messageType;  // methodCall / methodResponse / fault    var $faultCode;    var $faultString;    var $methodName;    var $params;    // Current variable stacks    var $_arraystructs = array();   // The stack used to keep track of the current array/struct    var $_arraystructstypes = array(); // Stack keeping track of if things are structs or array    var $_currentStructName = array();  // A stack as well    var $_param;    var $_value;    var $_currentTag;    var $_currentTagContents;    // The XML parser    var $_parser;    function IXR_Message (&$message) {        $this->message = &$message;    }    function parse() {		// first remove the XML declaration		// this method avoids the RAM usage of preg_replace on very large messages		$header = preg_replace( '/<\?xml.*?\?'.'>/', '', substr( $this->message, 0, 100 ), 1 );		$this->message = substr_replace($this->message, $header, 0, 100);        if (trim($this->message) == '') {            return false;		}        $this->_parser = xml_parser_create();        // Set XML parser to take the case of tags in to account        xml_parser_set_option($this->_parser, XML_OPTION_CASE_FOLDING, false);        // Set XML parser callback functions        xml_set_object($this->_parser, $this);        xml_set_element_handler($this->_parser, 'tag_open', 'tag_close');		xml_set_character_data_handler($this->_parser, 'cdata');		$chunk_size = 262144; // 256Kb, parse in chunks to avoid the RAM usage on very large messages		do {			if ( strlen($this->message) <= $chunk_size )				$final=true;			$part = substr( $this->message, 0, $chunk_size );			$this->message = substr( $this->message, $chunk_size );			if ( !xml_parse( $this->_parser, $part, $final ) )				return false;			if ( $final )				break;		} while ( true );		xml_parser_free($this->_parser);        // Grab the error messages, if any        if ($this->messageType == 'fault') {            $this->faultCode = $this->params[0]['faultCode'];            $this->faultString = $this->params[0]['faultString'];		}        return true;    }    function tag_open($parser, $tag, $attr) {        $this->_currentTagContents = '';        $this->currentTag = $tag;        switch($tag) {            case 'methodCall':            case 'methodResponse':            case 'fault':                $this->messageType = $tag;                break;            /* Deal with stacks of arrays and structs */            case 'data':    // data is to all intents and puposes more interesting than array                $this->_arraystructstypes[] = 'array';                $this->_arraystructs[] = array();                break;            case 'struct':                $this->_arraystructstypes[] = 'struct';                $this->_arraystructs[] = array();                break;        }    }    function cdata($parser, $cdata) {        $this->_currentTagContents .= $cdata;    }    function tag_close($parser, $tag) {        $valueFlag = false;        switch($tag) {            case 'int':            case 'i4':                $value = (int) trim($this->_currentTagContents);                $valueFlag = true;                break;            case 'double':                $value = (double) trim($this->_currentTagContents);                $valueFlag = true;                break;            case 'string':                $value = $this->_currentTagContents;                $valueFlag = true;                break;            case 'dateTime.iso8601':                $value = new IXR_Date(trim($this->_currentTagContents));                // $value = $iso->getTimestamp();                $valueFlag = true;                break;            case 'value':                // "If no type is indicated, the type is string."                if (trim($this->_currentTagContents) != '') {                    $value = (string)$this->_currentTagContents;                    $valueFlag = true;                }                break;            case 'boolean':                $value = (boolean) trim($this->_currentTagContents);                $valueFlag = true;                break;            case 'base64':                $value = base64_decode( trim( $this->_currentTagContents ) );                $valueFlag = true;                break;            /* Deal with stacks of arrays and structs */            case 'data':            case 'struct':                $value = array_pop($this->_arraystructs);                array_pop($this->_arraystructstypes);                $valueFlag = true;                break;            case 'member':                array_pop($this->_currentStructName);                break;            case 'name':                $this->_currentStructName[] = trim($this->_currentTagContents);                break;            case 'methodName':                $this->methodName = trim($this->_currentTagContents);                break;        }        if ($valueFlag) {            if (count($this->_arraystructs) > 0) {                // Add value to struct or array                if ($this->_arraystructstypes[count($this->_arraystructstypes)-1] == 'struct') {                    // Add to struct                    $this->_arraystructs[count($this->_arraystructs)-1][$this->_currentStructName[count($this->_currentStructName)-1]] = $value;                } else {                    // Add to array                    $this->_arraystructs[count($this->_arraystructs)-1][] = $value;                }            } else {                // Just add as a paramater                $this->params[] = $value;            }        }        $this->_currentTagContents = '';    }}/** * IXR_Server * * @package IXR * @since 1.5 */class IXR_Server {    var $data;    var $callbacks = array();    var $message;    var $capabilities;    function IXR_Server($callbacks = false, $data = false) {        $this->setCapabilities();        if ($callbacks) {            $this->callbacks = $callbacks;        }        $this->setCallbacks();        $this->serve($data);    }    function serve($data = false) {        if (!$data) {            global $HTTP_RAW_POST_DATA;            if (!$HTTP_RAW_POST_DATA) {               header( 'Content-Type: text/plain' );               die('XML-RPC server accepts POST requests only.');            }            $data = &$HTTP_RAW_POST_DATA;        }        $this->message = new IXR_Message($data);        if (!$this->message->parse()) {            $this->error(-32700, 'parse error. not well formed');        }        if ($this->message->messageType != 'methodCall') {            $this->error(-32600, 'server error. invalid xml-rpc. not conforming to spec. Request must be a methodCall');        }        $result = $this->call($this->message->methodName, $this->message->params);        // Is the result an error?        if (is_a($result, 'IXR_Error')) {            $this->error($result);        }        // Encode the result        $r = new IXR_Value($result);        $resultxml = $r->getXml();        // Create the XML        $xml = <<<EOD<methodResponse>  <params>    <param>      <value>        $resultxml      </value>    </param>  </params></methodResponse>EOD;        // Send it        $this->output($xml);    }    function call($methodname, $args) {        if (!$this->hasMethod($methodname)) {            return new IXR_Error(-32601, 'server error. requested method '.                $methodname.' does not exist.');        }        $method = $this->callbacks[$methodname];        // Perform the callback and send the response        if (count($args) == 1) {            // If only one paramater just send that instead of the whole array            $args = $args[0];        }        // Are we dealing with a function or a method?        if ( is_string( $method ) && substr($method, 0, 5) == 'this:' ) {            // It's a class method - check it exists            $method = substr($method, 5);            if (!method_exists($this, $method)) {                return new IXR_Error(-32601, 'server error. requested class method "'.                    $method.'" does not exist.');            }            // Call the method            $result = $this->$method($args);        } else {            // It's a function - does it exist?            if (is_array($method)) {                if (!method_exists($method[0], $method[1])) {                    return new IXR_Error(-32601, 'server error. requested object method "'.                        $method[1].'" does not exist.');                }            } else if (!function_exists($method)) {                return new IXR_Error(-32601, 'server error. requested function "'.                    $method.'" does not exist.');            }            // Call the function            $result = call_user_func($method, $args);        }        return $result;    }    function error($error, $message = false) {        // Accepts either an error object or an error code and message        if ($message && !is_object($error)) {            $error = new IXR_Error($error, $message);        }        $this->output($error->getXml());    }    function output($xml) {        $xml = '<?xml version="1.0"?>'."\n".$xml;        $length = strlen($xml);        header('Connection: close');        header('Content-Length: '.$length);        header('Content-Type: text/xml');        header('Date: '.date('r'));        echo $xml;        exit;    }    function hasMethod($method) {        return in_array($method, array_keys($this->callbacks));    }    function setCapabilities() {        // Initialises capabilities array        $this->capabilities = array(            'xmlrpc' => array(                'specUrl' => 'http://www.xmlrpc.com/spec',                'specVersion' => 1            ),            'faults_interop' => array(                'specUrl' => 'http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php',                'specVersion' => 20010516            ),            'system.multicall' => array(                'specUrl' => 'http://www.xmlrpc.com/discuss/msgReader$1208',                'specVersion' => 1            ),        );    }    function getCapabilities($args) {        return $this->capabilities;    }    function setCallbacks() {        $this->callbacks['system.getCapabilities'] = 'this:getCapabilities';        $this->callbacks['system.listMethods'] = 'this:listMethods';        $this->callbacks['system.multicall'] = 'this:multiCall';    }    function listMethods($args) {        // Returns a list of methods - uses array_reverse to ensure user defined        // methods are listed before server defined methods        return array_reverse(array_keys($this->callbacks));    }    function multiCall($methodcalls) {        // See http://www.xmlrpc.com/discuss/msgReader$1208        $return = array();        foreach ($methodcalls as $call) {            $method = $call['methodName'];            $params = $call['params'];            if ($method == 'system.multicall') {                $result = new IXR_Error(-32600, 'Recursive calls to system.multicall are forbidden');            } else {                $result = $this->call($method, $params);            }            if (is_a($result, 'IXR_Error')) {                $return[] = array(                    'faultCode' => $result->code,                    'faultString' => $result->message                );            } else {                $return[] = array($result);            }        }        return $return;    }}/** * IXR_Request * * @package IXR * @since 1.5 */class IXR_Request {    var $method;    var $args;    var $xml;    function IXR_Request($method, $args) {        $this->method = $method;        $this->args = $args;        $this->xml = <<<EOD<?xml version="1.0"?><methodCall><methodName>{$this->method}</methodName><params>EOD;        foreach ($this->args as $arg) {            $this->xml .= '<param><value>';            $v = new IXR_Value($arg);            $this->xml .= $v->getXml();            $this->xml .= "</value></param>\n";        }        $this->xml .= '</params></methodCall>';    }    function getLength() {        return strlen($this->xml);    }    function getXml() {        return $this->xml;    }}/** * IXR_Client * * @package IXR * @since 1.5 */class IXR_Client {    var $server;    var $port;    var $path;    var $useragent;	var $headers;    var $response;    var $message = false;    var $debug = false;    var $timeout;    // Storage place for an error message    var $error = false;    function IXR_Client($server, $path = false, $port = 80, $timeout = false) {        if (!$path) {            // Assume we have been given a URL instead            $bits = parse_url($server);            $this->server = $bits['host'];            $this->port = isset($bits['port']) ? $bits['port'] : 80;            $this->path = isset($bits['path']) ? $bits['path'] : '/';            // Make absolutely sure we have a path            if (!$this->path) {                $this->path = '/';            }        } else {            $this->server = $server;            $this->path = $path;            $this->port = $port;        }        $this->useragent = 'The Incutio XML-RPC PHP Library';        $this->timeout = $timeout;    }    function query() {        $args = func_get_args();        $method = array_shift($args);        $request = new IXR_Request($method, $args);        $length = $request->getLength();        $xml = $request->getXml();        $r = "\r\n";        $request  = "POST {$this->path} HTTP/1.0$r";		$this->headers['Host']			= $this->server;		$this->headers['Content-Type']	= 'text/xml';		$this->headers['User-Agent']	= $this->useragent;		$this->headers['Content-Length']= $length;		foreach( $this->headers as $header => $value ) {			$request .= "{$header}: {$value}{$r}";		}		$request .= $r;        $request .= $xml;        // Now send the request        if ($this->debug) {            echo '<pre class="ixr_request">'.htmlspecialchars($request)."\n</pre>\n\n";        }        if ($this->timeout) {            $fp = @fsockopen($this->server, $this->port, $errno, $errstr, $this->timeout);        } else {            $fp = @fsockopen($this->server, $this->port, $errno, $errstr);        }        if (!$fp) {            $this->error = new IXR_Error(-32300, "transport error - could not open socket: $errno $errstr");            return false;        }        fputs($fp, $request);        $contents = '';        $debug_contents = '';        $gotFirstLine = false;        $gettingHeaders = true;        while (!feof($fp)) {            $line = fgets($fp, 4096);            if (!$gotFirstLine) {                // Check line for '200'                if (strstr($line, '200') === false) {                    $this->error = new IXR_Error(-32301, 'transport error - HTTP status code was not 200');                    return false;                }                $gotFirstLine = true;            }            if (trim($line) == '') {                $gettingHeaders = false;            }            if (!$gettingHeaders) {            	// WP#12559 remove trim so as to not strip newlines from received response.                $contents .= $line;            }            if ($this->debug) {                $debug_contents .= $line;            }        }        if ($this->debug) {            echo '<pre class="ixr_response">'.htmlspecialchars($debug_contents)."\n</pre>\n\n";        }        // Now parse what we've got back        $this->message = new IXR_Message($contents);        if (!$this->message->parse()) {            // XML error            $this->error = new IXR_Error(-32700, 'parse error. not well formed');            return false;        }        // Is the message a fault?        if ($this->message->messageType == 'fault') {            $this->error = new IXR_Error($this->message->faultCode, $this->message->faultString);            return false;        }        // Message must be OK        return true;    }    function getResponse() {        // methodResponses can only have one param - return that        return $this->message->params[0];    }    function isError() {        return (is_object($this->error));    }    function getErrorCode() {        return $this->error->code;    }    function getErrorMessage() {        return $this->error->message;    }}/** * IXR_Error * * @package IXR * @since 1.5 */class IXR_Error {    var $code;    var $message;    function IXR_Error($code, $message) {        $this->code = $code;        // WP adds htmlspecialchars(). See #5666        $this->message = htmlspecialchars($message);    }    function getXml() {        $xml = <<<EOD<methodResponse>  <fault>    <value>      <struct>        <member>          <name>faultCode</name>          <value><int>{$this->code}</int></value>        </member>        <member>          <name>faultString</name>          <value><string>{$this->message}</string></value>        </member>      </struct>    </value>  </fault></methodResponse>EOD;        return $xml;    }}/** * IXR_Date * * @package IXR * @since 1.5 */class IXR_Date {    var $year;    var $month;    var $day;    var $hour;    var $minute;    var $second;    var $timezone;    function IXR_Date($time) {        // $time can be a PHP timestamp or an ISO one        if (is_numeric($time)) {            $this->parseTimestamp($time);        } else {            $this->parseIso($time);        }    }    function parseTimestamp($timestamp) {        $this->year = date('Y', $timestamp);        $this->month = date('m', $timestamp);        $this->day = date('d', $timestamp);        $this->hour = date('H', $timestamp);        $this->minute = date('i', $timestamp);        $this->second = date('s', $timestamp);        // WP adds timezone. See #2036        $this->timezone = '';    }    function parseIso($iso) {        $this->year = substr($iso, 0, 4);        $this->month = substr($iso, 4, 2);        $this->day = substr($iso, 6, 2);        $this->hour = substr($iso, 9, 2);        $this->minute = substr($iso, 12, 2);        $this->second = substr($iso, 15, 2);        // WP adds timezone. See #2036        $this->timezone = substr($iso, 17);    }    function getIso() {    	// WP adds timezone. See #2036        return $this->year.$this->month.$this->day.'T'.$this->hour.':'.$this->minute.':'.$this->second.$this->timezone;    }    function getXml() {        return '<dateTime.iso8601>'.$this->getIso().'</dateTime.iso8601>';    }    function getTimestamp() {        return mktime($this->hour, $this->minute, $this->second, $this->month, $this->day, $this->year);    }}/** * IXR_Base64 * * @package IXR * @since 1.5 */class IXR_Base64 {    var $data;    function IXR_Base64($data) {        $this->data = $data;    }    function getXml() {        return '<base64>'.base64_encode($this->data).'</base64>';    }}/** * IXR_IntrospectionServer * * @package IXR * @since 1.5 */class IXR_IntrospectionServer extends IXR_Server {    var $signatures;    var $help;    function IXR_IntrospectionServer() {        $this->setCallbacks();        $this->setCapabilities();        $this->capabilities['introspection'] = array(            'specUrl' => 'http://xmlrpc.usefulinc.com/doc/reserved.html',            'specVersion' => 1        );        $this->addCallback(            'system.methodSignature',            'this:methodSignature',            array('array', 'string'),            'Returns an array describing the return type and required parameters of a method'        );        $this->addCallback(            'system.getCapabilities',            'this:getCapabilities',            array('struct'),            'Returns a struct describing the XML-RPC specifications supported by this server'        );        $this->addCallback(            'system.listMethods',            'this:listMethods',            array('array'),            'Returns an array of available methods on this server'        );        $this->addCallback(            'system.methodHelp',            'this:methodHelp',            array('string', 'string'),            'Returns a documentation string for the specified method'        );    }    function addCallback($method, $callback, $args, $help) {        $this->callbacks[$method] = $callback;        $this->signatures[$method] = $args;        $this->help[$method] = $help;    }    function call($methodname, $args) {        // Make sure it's in an array        if ($args && !is_array($args)) {            $args = array($args);        }        // Over-rides default call method, adds signature check        if (!$this->hasMethod($methodname)) {            return new IXR_Error(-32601, 'server error. requested method "'.$this->message->methodName.'" not specified.');        }        $method = $this->callbacks[$methodname];        $signature = $this->signatures[$methodname];        $returnType = array_shift($signature);        // Check the number of arguments        if (count($args) != count($signature)) {            return new IXR_Error(-32602, 'server error. wrong number of method parameters');        }        // Check the argument types        $ok = true;        $argsbackup = $args;        for ($i = 0, $j = count($args); $i < $j; $i++) {            $arg = array_shift($args);            $type = array_shift($signature);            switch ($type) {                case 'int':                case 'i4':                    if (is_array($arg) || !is_int($arg)) {                        $ok = false;                    }                    break;                case 'base64':                case 'string':                    if (!is_string($arg)) {                        $ok = false;                    }                    break;                case 'boolean':                    if ($arg !== false && $arg !== true) {                        $ok = false;                    }                    break;                case 'float':                case 'double':                    if (!is_float($arg)) {                        $ok = false;                    }                    break;                case 'date':                case 'dateTime.iso8601':                    if (!is_a($arg, 'IXR_Date')) {                        $ok = false;                    }                    break;            }            if (!$ok) {                return new IXR_Error(-32602, 'server error. invalid method parameters');            }        }        // It passed the test - run the "real" method call        return parent::call($methodname, $argsbackup);    }    function methodSignature($method) {        if (!$this->hasMethod($method)) {            return new IXR_Error(-32601, 'server error. requested method "'.$method.'" not specified.');        }        // We should be returning an array of types        $types = $this->signatures[$method];        $return = array();        foreach ($types as $type) {            switch ($type) {                case 'string':                    $return[] = 'string';                    break;                case 'int':                case 'i4':                    $return[] = 42;                    break;                case 'double':                    $return[] = 3.1415;                    break;                case 'dateTime.iso8601':                    $return[] = new IXR_Date(time());                    break;                case 'boolean':                    $return[] = true;                    break;                case 'base64':                    $return[] = new IXR_Base64('base64');                    break;                case 'array':                    $return[] = array('array');                    break;                case 'struct':                    $return[] = array('struct' => 'struct');                    break;            }        }        return $return;    }    function methodHelp($method) {        return $this->help[$method];    }}/** * IXR_ClientMulticall * * @package IXR * @since 1.5 */class IXR_ClientMulticall extends IXR_Client {    var $calls = array();    function IXR_ClientMulticall($server, $path = false, $port = 80) {        parent::IXR_Client($server, $path, $port);        $this->useragent = 'The Incutio XML-RPC PHP Library (multicall client)';    }    function addCall() {        $args = func_get_args();        $methodName = array_shift($args);        $struct = array(            'methodName' => $methodName,            'params' => $args        );        $this->calls[] = $struct;    }    function query() {        // Prepare multicall, then call the parent::query() method        return parent::query('system.multicall', $this->calls);    }}?>
<?php/** * Media management action handler. * * @package WordPress * @subpackage Administration *//** Load WordPress Administration Bootstrap */require_once('./admin.php');$parent_file = 'upload.php';$submenu_file = 'upload.php';wp_reset_vars(array('action'));switch( $action ) :case 'editattachment' :	$attachment_id = (int) $_POST['attachment_id'];	check_admin_referer('media-form');	if ( !current_user_can('edit_post', $attachment_id) )		wp_die ( __('You are not allowed to edit this attachment.') );	$errors = media_upload_form_handler();	if ( empty($errors) ) {		$location = 'media.php';		if ( $referer = wp_get_original_referer() ) {			if ( false !== strpos($referer, 'upload.php') || ( url_to_postid($referer) == $attachment_id )  )				$location = $referer;		}		if ( false !== strpos($location, 'upload.php') ) {			$location = remove_query_arg('message', $location);			$location = add_query_arg('posted',	$attachment_id, $location);		} elseif ( false !== strpos($location, 'media.php') ) {			$location = add_query_arg('message', 'updated', $location);		}		wp_redirect($location);		exit;	}	// no breakcase 'edit' :	$title = __('Edit Media');	if ( empty($errors) )		$errors = null;	if ( empty( $_GET['attachment_id'] ) ) {		wp_redirect('upload.php');		exit();	}	$att_id = (int) $_GET['attachment_id'];	if ( !current_user_can('edit_post', $att_id) )		wp_die ( __('You are not allowed to edit this attachment.') );	$att = get_post($att_id);	if ( empty($att->ID) ) wp_die( __('You attempted to edit an attachment that doesn&#8217;t exist. Perhaps it was deleted?') );	if ( $att->post_status == 'trash' ) wp_die( __('You can&#8217;t edit this attachment because it is in the Trash. Please move it out of the Trash and try again.') );	add_filter('attachment_fields_to_edit', 'media_single_attachment_fields_to_edit', 10, 2);	wp_enqueue_script( 'wp-ajax-response' );	wp_enqueue_script('image-edit');	wp_enqueue_style('imgareaselect');	require( './admin-header.php' );	$parent_file = 'upload.php';	$message = '';	$class = '';	if ( isset($_GET['message']) ) {		switch ( $_GET['message'] ) :		case 'updated' :			$message = __('Media attachment updated.');			$class = 'updated';			break;		endswitch;	}	if ( $message )		echo "<div id='message' class='$class'><p>$message</p></div>\n";?><div class="wrap"><?php screen_icon(); ?><h2><?php _e( 'Edit Media' ); ?></h2><form method="post" action="" class="media-upload-form" id="media-single-form"><p class="submit" style="padding-bottom: 0;"><input type="submit" class="button-primary" name="save" value="<?php esc_attr_e('Update Media'); ?>" /></p><div class="media-single"><div id='media-item-<?php echo $att_id; ?>' class='media-item'><?php echo get_media_item( $att_id, array( 'toggle' => false, 'send' => false, 'delete' => false, 'show_title' => false, 'errors' => $errors ) ); ?></div></div><p class="submit"><input type="submit" class="button-primary" name="save" value="<?php esc_attr_e('Update Media'); ?>" /><input type="hidden" name="post_id" id="post_id" value="<?php echo isset($post_id) ? esc_attr($post_id) : ''; ?>" /><input type="hidden" name="attachment_id" id="attachment_id" value="<?php echo esc_attr($att_id); ?>" /><input type="hidden" name="action" value="editattachment" /><?php wp_original_referer_field(true, 'previous'); ?><?php wp_nonce_field('media-form'); ?></p></form></div><?php	require( './admin-footer.php' );	exit;default:	wp_redirect( 'upload.php' );	exit;endswitch;?>
<?php/** * API for creating dynamic sidebar without hardcoding functionality into * themes. Includes both internal WordPress routines and theme use routines. * * This functionality was found in a plugin before WordPress 2.2 release which * included it in the core from that point on. * * @link http://codex.wordpress.org/Plugins/WordPress_Widgets WordPress Widgets * @link http://codex.wordpress.org/Plugins/WordPress_Widgets_Api Widgets API * * @package WordPress * @subpackage Widgets *//** * This class must be extended for each widget and WP_Widget::widget(), WP_Widget::update() * and WP_Widget::form() need to be over-ridden. * * @package WordPress * @subpackage Widgets * @since 2.8 */class WP_Widget {	var $id_base;			// Root id for all widgets of this type.	var $name;				// Name for this widget type.	var $widget_options;	// Option array passed to wp_register_sidebar_widget()	var $control_options;	// Option array passed to wp_register_widget_control()	var $number = false;	// Unique ID number of the current instance.	var $id = false;		// Unique ID string of the current instance (id_base-number)	var $updated = false;	// Set true when we update the data after a POST submit - makes sure we don't do it twice.	// Member functions that you must over-ride.	/** Echo the widget content.	 *	 * Subclasses should over-ride this function to generate their widget code.	 *	 * @param array $args Display arguments including before_title, after_title, before_widget, and after_widget.	 * @param array $instance The settings for the particular instance of the widget	 */	function widget($args, $instance) {		die('function WP_Widget::widget() must be over-ridden in a sub-class.');	}	/** Update a particular instance.	 *	 * This function should check that $new_instance is set correctly.	 * The newly calculated value of $instance should be returned.	 * If "false" is returned, the instance won't be saved/updated.	 *	 * @param array $new_instance New settings for this instance as input by the user via form()	 * @param array $old_instance Old settings for this instance	 * @return array Settings to save or bool false to cancel saving	 */	function update($new_instance, $old_instance) {		return $new_instance;	}	/** Echo the settings update form	 *	 * @param array $instance Current settings	 */	function form($instance) {		echo '<p class="no-options-widget">' . __('There are no options for this widget.') . '</p>';		return 'noform';	}	// Functions you'll need to call.	/**	 * PHP4 constructor	 */	function WP_Widget( $id_base = false, $name, $widget_options = array(), $control_options = array() ) {		$this->__construct( $id_base, $name, $widget_options, $control_options );	}	/**	 * PHP5 constructor	 *	 * @param string $id_base Optional Base ID for the widget, lower case,	 * if left empty a portion of the widget's class name will be used. Has to be unique.	 * @param string $name Name for the widget displayed on the configuration page.	 * @param array $widget_options Optional Passed to wp_register_sidebar_widget()	 *	 - description: shown on the configuration page	 *	 - classname	 * @param array $control_options Optional Passed to wp_register_widget_control()	 *	 - width: required if more than 250px	 *	 - height: currently not used but may be needed in the future	 */	function __construct( $id_base = false, $name, $widget_options = array(), $control_options = array() ) {		$this->id_base = empty($id_base) ? preg_replace( '/(wp_)?widget_/', '', strtolower(get_class($this)) ) : strtolower($id_base);		$this->name = $name;		$this->option_name = 'widget_' . $this->id_base;		$this->widget_options = wp_parse_args( $widget_options, array('classname' => $this->option_name) );		$this->control_options = wp_parse_args( $control_options, array('id_base' => $this->id_base) );	}	/**	 * Constructs name attributes for use in form() fields	 *	 * This function should be used in form() methods to create name attributes for fields to be saved by update()	 *	 * @param string $field_name Field name	 * @return string Name attribute for $field_name	 */	function get_field_name($field_name) {		return 'widget-' . $this->id_base . '[' . $this->number . '][' . $field_name . ']';	}	/**	 * Constructs id attributes for use in form() fields	 *	 * This function should be used in form() methods to create id attributes for fields to be saved by update()	 *	 * @param string $field_name Field name	 * @return string ID attribute for $field_name	 */	function get_field_id($field_name) {		return 'widget-' . $this->id_base . '-' . $this->number . '-' . $field_name;	}	// Private Functions. Don't worry about these.	function _register() {		$settings = $this->get_settings();		$empty = true;		if ( is_array($settings) ) {			foreach ( array_keys($settings) as $number ) {				if ( is_numeric($number) ) {					$this->_set($number);					$this->_register_one($number);					$empty = false;				}			}		}		if ( $empty ) {			// If there are none, we register the widget's existance with a			// generic template			$this->_set(1);			$this->_register_one();		}	}	function _set($number) {		$this->number = $number;		$this->id = $this->id_base . '-' . $number;	}	function _get_display_callback() {		return array(&$this, 'display_callback');	}	function _get_update_callback() {		return array(&$this, 'update_callback');	}	function _get_form_callback() {		return array(&$this, 'form_callback');	}	/** Generate the actual widget content.	 *	Just finds the instance and calls widget().	 *	Do NOT over-ride this function. */	function display_callback( $args, $widget_args = 1 ) {		if ( is_numeric($widget_args) )			$widget_args = array( 'number' => $widget_args );		$widget_args = wp_parse_args( $widget_args, array( 'number' => -1 ) );		$this->_set( $widget_args['number'] );		$instance = $this->get_settings();		if ( array_key_exists( $this->number, $instance ) ) {			$instance = $instance[$this->number];			// filters the widget's settings, return false to stop displaying the widget			$instance = apply_filters('widget_display_callback', $instance, $this, $args);			if ( false !== $instance )				$this->widget($args, $instance);		}	}	/** Deal with changed settings.	 *	Do NOT over-ride this function. */	function update_callback( $widget_args = 1 ) {		global $wp_registered_widgets;		if ( is_numeric($widget_args) )			$widget_args = array( 'number' => $widget_args );		$widget_args = wp_parse_args( $widget_args, array( 'number' => -1 ) );		$all_instances = $this->get_settings();		// We need to update the data		if ( $this->updated )			return;		$sidebars_widgets = wp_get_sidebars_widgets();		if ( isset($_POST['delete_widget']) && $_POST['delete_widget'] ) {			// Delete the settings for this instance of the widget			if ( isset($_POST['the-widget-id']) )				$del_id = $_POST['the-widget-id'];			else				return;			if ( isset($wp_registered_widgets[$del_id]['params'][0]['number']) ) {				$number = $wp_registered_widgets[$del_id]['params'][0]['number'];				if ( $this->id_base . '-' . $number == $del_id )					unset($all_instances[$number]);			}		} else {			if ( isset($_POST['widget-' . $this->id_base]) && is_array($_POST['widget-' . $this->id_base]) ) {				$settings = $_POST['widget-' . $this->id_base];			} elseif ( isset($_POST['id_base']) && $_POST['id_base'] == $this->id_base ) {				$num = $_POST['multi_number'] ? (int) $_POST['multi_number'] : (int) $_POST['widget_number'];				$settings = array( $num => array() );			} else {				return;			}			foreach ( $settings as $number => $new_instance ) {				$new_instance = stripslashes_deep($new_instance);				$this->_set($number);				$old_instance = isset($all_instances[$number]) ? $all_instances[$number] : array();				$instance = $this->update($new_instance, $old_instance);				// filters the widget's settings before saving, return false to cancel saving (keep the old settings if updating)				$instance = apply_filters('widget_update_callback', $instance, $new_instance, $old_instance, $this);				if ( false !== $instance )					$all_instances[$number] = $instance;				break; // run only once			}		}		$this->save_settings($all_instances);		$this->updated = true;	}	/** Generate the control form.	 *	Do NOT over-ride this function. */	function form_callback( $widget_args = 1 ) {		if ( is_numeric($widget_args) )			$widget_args = array( 'number' => $widget_args );		$widget_args = wp_parse_args( $widget_args, array( 'number' => -1 ) );		$all_instances = $this->get_settings();		if ( -1 == $widget_args['number'] ) {			// We echo out a form where 'number' can be set later			$this->_set('__i__');			$instance = array();		} else {			$this->_set($widget_args['number']);			$instance = $all_instances[ $widget_args['number'] ];		}		// filters the widget admin form before displaying, return false to stop displaying it		$instance = apply_filters('widget_form_callback', $instance, $this);		$return = null;		if ( false !== $instance ) {			$return = $this->form($instance);			// add extra fields in the widget form - be sure to set $return to null if you add any			// if the widget has no form the text echoed from the default form method can be hidden using css			do_action_ref_array( 'in_widget_form', array(&$this, &$return, $instance) );		}		return $return;	}	/** Helper function: Registers a single instance. */	function _register_one($number = -1) {		wp_register_sidebar_widget(	$this->id, $this->name,	$this->_get_display_callback(), $this->widget_options, array( 'number' => $number ) );		_register_widget_update_callback( $this->id_base, $this->_get_update_callback(), $this->control_options, array( 'number' => -1 ) );		_register_widget_form_callback(	$this->id, $this->name,	$this->_get_form_callback(), $this->control_options, array( 'number' => $number ) );	}	function save_settings($settings) {		$settings['_multiwidget'] = 1;		update_option( $this->option_name, $settings );	}	function get_settings() {		$settings = get_option($this->option_name);		if ( false === $settings && isset($this->alt_option_name) )			$settings = get_option($this->alt_option_name);		if ( !is_array($settings) )			$settings = array();		if ( !array_key_exists('_multiwidget', $settings) ) {			// old format, conver if single widget			$settings = wp_convert_widget_settings($this->id_base, $this->option_name, $settings);		}		unset($settings['_multiwidget'], $settings['__i__']);		return $settings;	}}/** * Singleton that registers and instantiates WP_Widget classes. * * @package WordPress * @subpackage Widgets * @since 2.8 */class WP_Widget_Factory {	var $widgets = array();	function WP_Widget_Factory() {		add_action( 'widgets_init', array( &$this, '_register_widgets' ), 100 );	}	function register($widget_class) {		$this->widgets[$widget_class] = & new $widget_class();	}	function unregister($widget_class) {		if ( isset($this->widgets[$widget_class]) )			unset($this->widgets[$widget_class]);	}	function _register_widgets() {		global $wp_registered_widgets;		$keys = array_keys($this->widgets);		$registered = array_keys($wp_registered_widgets);		$registered = array_map('_get_widget_id_base', $registered);		foreach ( $keys as $key ) {			// don't register new widget if old widget with the same id is already registered			if ( in_array($this->widgets[$key]->id_base, $registered, true) ) {				unset($this->widgets[$key]);				continue;			}			$this->widgets[$key]->_register();		}	}}/* Global Variables *//** @ignore */global $wp_registered_sidebars, $wp_registered_widgets, $wp_registered_widget_controls, $wp_registered_widget_updates;/** * Stores the sidebars, since many themes can have more than one. * * @global array $wp_registered_sidebars * @since 2.2.0 */$wp_registered_sidebars = array();/** * Stores the registered widgets. * * @global array $wp_registered_widgets * @since 2.2.0 */$wp_registered_widgets = array();/** * Stores the registered widget control (options). * * @global array $wp_registered_widget_controls * @since 2.2.0 */$wp_registered_widget_controls = array();$wp_registered_widget_updates = array();/** * Private */$_wp_sidebars_widgets = array();/** * Private */ $_wp_deprecated_widgets_callbacks = array( 	'wp_widget_pages',	'wp_widget_pages_control',	'wp_widget_calendar',	'wp_widget_calendar_control',	'wp_widget_archives',	'wp_widget_archives_control',	'wp_widget_links',	'wp_widget_meta',	'wp_widget_meta_control',	'wp_widget_search',	'wp_widget_recent_entries',	'wp_widget_recent_entries_control',	'wp_widget_tag_cloud',	'wp_widget_tag_cloud_control',	'wp_widget_categories',	'wp_widget_categories_control',	'wp_widget_text',	'wp_widget_text_control',	'wp_widget_rss',	'wp_widget_rss_control',	'wp_widget_recent_comments',	'wp_widget_recent_comments_control' );/* Template tags & API functions *//** * Register a widget * * Registers a WP_Widget widget * * @since 2.8.0 * * @see WP_Widget * @see WP_Widget_Factory * @uses WP_Widget_Factory * * @param string $widget_class The name of a class that extends WP_Widget */function register_widget($widget_class) {	global $wp_widget_factory;	$wp_widget_factory->register($widget_class);}/** * Unregister a widget * * Unregisters a WP_Widget widget. Useful for unregistering default widgets. * Run within a function hooked to the widgets_init action. * * @since 2.8.0 * * @see WP_Widget * @see WP_Widget_Factory * @uses WP_Widget_Factory * * @param string $widget_class The name of a class that extends WP_Widget */function unregister_widget($widget_class) {	global $wp_widget_factory;	$wp_widget_factory->unregister($widget_class);}/** * Creates multiple sidebars. * * If you wanted to quickly create multiple sidebars for a theme or internally. * This function will allow you to do so. If you don't pass the 'name' and/or * 'id' in $args, then they will be built for you. * * The default for the name is "Sidebar #", with '#' being replaced with the * number the sidebar is currently when greater than one. If first sidebar, the * name will be just "Sidebar". The default for id is "sidebar-" followed by the * number the sidebar creation is currently at. If the id is provided, and mutliple * sidebars are being defined, the id will have "-2" appended, and so on. * * @since 2.2.0 * * @see register_sidebar() The second parameter is documented by register_sidebar() and is the same here. * @uses parse_str() Converts a string to an array to be used in the rest of the function. * @uses register_sidebar() Sends single sidebar information [name, id] to this *	function to handle building the sidebar. * * @param int $number Number of sidebars to create. * @param string|array $args Builds Sidebar based off of 'name' and 'id' values. */function register_sidebars($number = 1, $args = array()) {	global $wp_registered_sidebars;	$number = (int) $number;	if ( is_string($args) )		parse_str($args, $args);	for ( $i = 1; $i <= $number; $i++ ) {		$_args = $args;		if ( $number > 1 )			$_args['name'] = isset($args['name']) ? sprintf($args['name'], $i) : sprintf(__('Sidebar %d'), $i);		else			$_args['name'] = isset($args['name']) ? $args['name'] : __('Sidebar');		// Custom specified ID's are suffixed if they exist already.		// Automatically generated sidebar names need to be suffixed regardless starting at -0		if ( isset($args['id']) ) {			$_args['id'] = $args['id'];			$n = 2; // Start at -2 for conflicting custom ID's			while ( isset($wp_registered_sidebars[$_args['id']]) )				$_args['id'] = $args['id'] . '-' . $n++;		} else {			$n = count($wp_registered_sidebars);			do {				$_args['id'] = 'sidebar-' . ++$n;			} while ( isset($wp_registered_sidebars[$_args['id']]) );		}		register_sidebar($_args);	}}/** * Builds the definition for a single sidebar and returns the ID. * * The $args parameter takes either a string or an array with 'name' and 'id' * contained in either usage. It will be noted that the values will be applied * to all sidebars, so if creating more than one, it will be advised to allow * for WordPress to create the defaults for you. * * Example for string would be <code>'name=whatever;id=whatever1'</code> and for * the array it would be <code>array( *    'name' => 'whatever', *    'id' => 'whatever1')</code>. * * name - The name of the sidebar, which presumably the title which will be *     displayed. * id - The unique identifier by which the sidebar will be called by. * before_widget - The content that will prepended to the widgets when they are *     displayed. * after_widget - The content that will be appended to the widgets when they are *     displayed. * before_title - The content that will be prepended to the title when displayed. * after_title - the content that will be appended to the title when displayed. * * <em>Content</em> is assumed to be HTML and should be formatted as such, but * doesn't have to be. * * @since 2.2.0 * @uses $wp_registered_sidebars Stores the new sidebar in this array by sidebar ID. * * @param string|array $args Builds Sidebar based off of 'name' and 'id' values * @return string The sidebar id that was added. */function register_sidebar($args = array()) {	global $wp_registered_sidebars;	$i = count($wp_registered_sidebars) + 1;	$defaults = array(		'name' => sprintf(__('Sidebar %d'), $i ),		'id' => "sidebar-$i",		'description' => '',		'before_widget' => '<li id="%1$s" class="widget %2$s">',		'after_widget' => "</li>\n",		'before_title' => '<h2 class="widgettitle">',		'after_title' => "</h2>\n",	);	$sidebar = wp_parse_args( $args, $defaults );	$wp_registered_sidebars[$sidebar['id']] = $sidebar;	add_theme_support('widgets');	do_action( 'register_sidebar', $sidebar );	return $sidebar['id'];}/** * Removes a sidebar from the list. * * @since 2.2.0 * * @uses $wp_registered_sidebars Stores the new sidebar in this array by sidebar ID. * * @param string $name The ID of the sidebar when it was added. */function unregister_sidebar( $name ) {	global $wp_registered_sidebars;	if ( isset( $wp_registered_sidebars[$name] ) )		unset( $wp_registered_sidebars[$name] );}/** * Register widget for use in sidebars. * * The default widget option is 'classname' that can be override. * * The function can also be used to unregister widgets when $output_callback * parameter is an empty string. * * @since 2.2.0 * * @uses $wp_registered_widgets Uses stored registered widgets. * @uses $wp_register_widget_defaults Retrieves widget defaults. * * @param int|string $id Widget ID. * @param string $name Widget display title. * @param callback $output_callback Run when widget is called. * @param array|string Optional. $options Widget Options. * @param mixed $params,... Widget parameters to add to widget. * @return null Will return if $output_callback is empty after removing widget. */function wp_register_sidebar_widget($id, $name, $output_callback, $options = array()) {	global $wp_registered_widgets, $wp_registered_widget_controls, $wp_registered_widget_updates, $_wp_deprecated_widgets_callbacks;	$id = strtolower($id);	if ( empty($output_callback) ) {		unset($wp_registered_widgets[$id]);		return;	}	$id_base = _get_widget_id_base($id);	if ( in_array($output_callback, $_wp_deprecated_widgets_callbacks, true) && !is_callable($output_callback) ) {		if ( isset($wp_registered_widget_controls[$id]) )			unset($wp_registered_widget_controls[$id]);		if ( isset($wp_registered_widget_updates[$id_base]) )			unset($wp_registered_widget_updates[$id_base]);		return;	}	$defaults = array('classname' => $output_callback);	$options = wp_parse_args($options, $defaults);	$widget = array(		'name' => $name,		'id' => $id,		'callback' => $output_callback,		'params' => array_slice(func_get_args(), 4)	);	$widget = array_merge($widget, $options);	if ( is_callable($output_callback) && ( !isset($wp_registered_widgets[$id]) || did_action( 'widgets_init' ) ) ) {		do_action( 'wp_register_sidebar_widget', $widget );		$wp_registered_widgets[$id] = $widget;	}}/** * Retrieve description for widget. * * When registering widgets, the options can also include 'description' that * describes the widget for display on the widget administration panel or * in the theme. * * @since 2.5.0 * * @param int|string $id Widget ID. * @return string Widget description, if available. Null on failure to retrieve description. */function wp_widget_description( $id ) {	if ( !is_scalar($id) )		return;	global $wp_registered_widgets;	if ( isset($wp_registered_widgets[$id]['description']) )		return esc_html( $wp_registered_widgets[$id]['description'] );}/** * Retrieve description for a sidebar. * * When registering sidebars a 'description' parameter can be included that * describes the sidebar for display on the widget administration panel. * * @since 2.9.0 * * @param int|string $id sidebar ID. * @return string Sidebar description, if available. Null on failure to retrieve description. */function wp_sidebar_description( $id ) {	if ( !is_scalar($id) )		return;	global $wp_registered_sidebars;	if ( isset($wp_registered_sidebars[$id]['description']) )		return esc_html( $wp_registered_sidebars[$id]['description'] );}/** * Remove widget from sidebar. * * @since 2.2.0 * * @param int|string $id Widget ID. */function wp_unregister_sidebar_widget($id) {	do_action( 'wp_unregister_sidebar_widget', $id );	wp_register_sidebar_widget($id, '', '');	wp_unregister_widget_control($id);}/** * Registers widget control callback for customizing options. * * The options contains the 'height', 'width', and 'id_base' keys. The 'height' * option is never used. The 'width' option is the width of the fully expanded * control form, but try hard to use the default width. The 'id_base' is for * multi-widgets (widgets which allow multiple instances such as the text * widget), an id_base must be provided. The widget id will end up looking like * {$id_base}-{$unique_number}. * * @since 2.2.0 * * @param int|string $id Sidebar ID. * @param string $name Sidebar display name. * @param callback $control_callback Run when sidebar is displayed. * @param array|string $options Optional. Widget options. See above long description. * @param mixed $params,... Optional. Additional parameters to add to widget. */function wp_register_widget_control($id, $name, $control_callback, $options = array()) {	global $wp_registered_widget_controls, $wp_registered_widget_updates, $wp_registered_widgets, $_wp_deprecated_widgets_callbacks;	$id = strtolower($id);	$id_base = _get_widget_id_base($id);	if ( empty($control_callback) ) {		unset($wp_registered_widget_controls[$id]);		unset($wp_registered_widget_updates[$id_base]);		return;	}	if ( in_array($control_callback, $_wp_deprecated_widgets_callbacks, true) && !is_callable($control_callback) ) {		if ( isset($wp_registered_widgets[$id]) )			unset($wp_registered_widgets[$id]);		return;	}	if ( isset($wp_registered_widget_controls[$id]) && !did_action( 'widgets_init' ) )		return;	$defaults = array('width' => 250, 'height' => 200 ); // height is never used	$options = wp_parse_args($options, $defaults);	$options['width'] = (int) $options['width'];	$options['height'] = (int) $options['height'];	$widget = array(		'name' => $name,		'id' => $id,		'callback' => $control_callback,		'params' => array_slice(func_get_args(), 4)	);	$widget = array_merge($widget, $options);	$wp_registered_widget_controls[$id] = $widget;	if ( isset($wp_registered_widget_updates[$id_base]) )		return;	if ( isset($widget['params'][0]['number']) )		$widget['params'][0]['number'] = -1;	unset($widget['width'], $widget['height'], $widget['name'], $widget['id']);	$wp_registered_widget_updates[$id_base] = $widget;}function _register_widget_update_callback($id_base, $update_callback, $options = array()) {	global $wp_registered_widget_updates;	if ( isset($wp_registered_widget_updates[$id_base]) ) {		if ( empty($update_callback) )			unset($wp_registered_widget_updates[$id_base]);		return;	}	$widget = array(		'callback' => $update_callback,		'params' => array_slice(func_get_args(), 3)	);	$widget = array_merge($widget, $options);	$wp_registered_widget_updates[$id_base] = $widget;}function _register_widget_form_callback($id, $name, $form_callback, $options = array()) {	global $wp_registered_widget_controls;	$id = strtolower($id);	if ( empty($form_callback) ) {		unset($wp_registered_widget_controls[$id]);		return;	}	if ( isset($wp_registered_widget_controls[$id]) && !did_action( 'widgets_init' ) )		return;	$defaults = array('width' => 250, 'height' => 200 );	$options = wp_parse_args($options, $defaults);	$options['width'] = (int) $options['width'];	$options['height'] = (int) $options['height'];	$widget = array(		'name' => $name,		'id' => $id,		'callback' => $form_callback,		'params' => array_slice(func_get_args(), 4)	);	$widget = array_merge($widget, $options);	$wp_registered_widget_controls[$id] = $widget;}/** * Remove control callback for widget. * * @since 2.2.0 * @uses wp_register_widget_control() Unregisters by using empty callback. * * @param int|string $id Widget ID. */function wp_unregister_widget_control($id) {	return wp_register_widget_control($id, '', '');}/** * Display dynamic sidebar. * * By default it displays the default sidebar or 'sidebar-1'. The 'sidebar-1' is * not named by the theme, the actual name is '1', but 'sidebar-' is added to * the registered sidebars for the name. If you named your sidebar 'after-post', * then the parameter $index will still be 'after-post', but the lookup will be * for 'sidebar-after-post'. * * It is confusing for the $index parameter, but just know that it should just * work. When you register the sidebar in the theme, you will use the same name * for this function or "Pay no heed to the man behind the curtain." Just accept * it as an oddity of WordPress sidebar register and display. * * @since 2.2.0 * * @param int|string $index Optional, default is 1. Name or ID of dynamic sidebar. * @return bool True, if widget sidebar was found and called. False if not found or not called. */function dynamic_sidebar($index = 1) {	global $wp_registered_sidebars, $wp_registered_widgets;	if ( is_int($index) ) {		$index = "sidebar-$index";	} else {		$index = sanitize_title($index);		foreach ( (array) $wp_registered_sidebars as $key => $value ) {			if ( sanitize_title($value['name']) == $index ) {				$index = $key;				break;			}		}	}	$sidebars_widgets = wp_get_sidebars_widgets();	if ( empty($wp_registered_sidebars[$index]) || !array_key_exists($index, $sidebars_widgets) || !is_array($sidebars_widgets[$index]) || empty($sidebars_widgets[$index]) )		return false;	$sidebar = $wp_registered_sidebars[$index];	$did_one = false;	foreach ( (array) $sidebars_widgets[$index] as $id ) {		if ( !isset($wp_registered_widgets[$id]) ) continue;		$params = array_merge(			array( array_merge( $sidebar, array('widget_id' => $id, 'widget_name' => $wp_registered_widgets[$id]['name']) ) ),			(array) $wp_registered_widgets[$id]['params']		);		// Substitute HTML id and class attributes into before_widget		$classname_ = '';		foreach ( (array) $wp_registered_widgets[$id]['classname'] as $cn ) {			if ( is_string($cn) )				$classname_ .= '_' . $cn;			elseif ( is_object($cn) )				$classname_ .= '_' . get_class($cn);		}		$classname_ = ltrim($classname_, '_');		$params[0]['before_widget'] = sprintf($params[0]['before_widget'], $id, $classname_);		$params = apply_filters( 'dynamic_sidebar_params', $params );		$callback = $wp_registered_widgets[$id]['callback'];		do_action( 'dynamic_sidebar', $wp_registered_widgets[$id] );		if ( is_callable($callback) ) {			call_user_func_array($callback, $params);			$did_one = true;		}	}	return $did_one;}/** * Whether widget is displayied on the front-end. * * Either $callback or $id_base can be used * $id_base is the first argument when extending WP_Widget class * Without the optional $widget_id parameter, returns the ID of the first sidebar * in which the first instance of the widget with the given callback or $id_base is found. * With the $widget_id parameter, returns the ID of the sidebar where * the widget with that callback/$id_base AND that ID is found. * * NOTE: $widget_id and $id_base are the same for single widgets. To be effective * this function has to run after widgets have initialized, at action 'init' or later. * * @since 2.2.0 * * @param callback Optional, Widget callback to check. * @param int $widget_id Optional, but needed for checking. Widget ID. * @param string $id_base Optional, the base ID of a widget created by extending WP_Widget. * @param bool $skip_inactive Optional, whether to check in 'wp_inactive_widgets'. * @return mixed false if widget is not active or id of sidebar in which the widget is active. */function is_active_widget($callback = false, $widget_id = false, $id_base = false, $skip_inactive = true) {	global $wp_registered_widgets;	$sidebars_widgets = wp_get_sidebars_widgets();	if ( is_array($sidebars_widgets) ) {		foreach ( $sidebars_widgets as $sidebar => $widgets ) {			if ( $skip_inactive && 'wp_inactive_widgets' == $sidebar )				continue;			if ( is_array($widgets) ) {				foreach ( $widgets as $widget ) {					if ( ( $callback && isset($wp_registered_widgets[$widget]['callback']) && $wp_registered_widgets[$widget]['callback'] == $callback ) || ( $id_base && _get_widget_id_base($widget) == $id_base ) ) {						if ( !$widget_id || $widget_id == $wp_registered_widgets[$widget]['id'] )							return $sidebar;					}				}			}		}	}	return false;}/** * Whether the dynamic sidebar is enabled and used by theme. * * @since 2.2.0 * * @return bool True, if using widgets. False, if not using widgets. */function is_dynamic_sidebar() {	global $wp_registered_widgets, $wp_registered_sidebars;	$sidebars_widgets = get_option('sidebars_widgets');	foreach ( (array) $wp_registered_sidebars as $index => $sidebar ) {		if ( count($sidebars_widgets[$index]) ) {			foreach ( (array) $sidebars_widgets[$index] as $widget )				if ( array_key_exists($widget, $wp_registered_widgets) )					return true;		}	}	return false;}/** * Whether a sidebar is in use. * * @since 2.8 * * @param mixed $index, sidebar name, id or number to check. * @return bool true if the sidebar is in use, false otherwise. */function is_active_sidebar( $index ) {	$index = ( is_int($index) ) ? "sidebar-$index" : sanitize_title($index);	$sidebars_widgets = wp_get_sidebars_widgets();	if ( !empty($sidebars_widgets[$index]) )		return true;	return false;}/* Internal Functions *//** * Retrieve full list of sidebars and their widgets. * * Will upgrade sidebar widget list, if needed. Will also save updated list, if * needed. * * @since 2.2.0 * @access private * * @param bool $deprecated. Not used. * @return array Upgraded list of widgets to version 3 array format when called from the admin. */function wp_get_sidebars_widgets($deprecated = true) {	if ( $deprecated !== true )		_deprecated_argument( __FUNCTION__, '2.8.1' );	global $wp_registered_widgets, $wp_registered_sidebars, $_wp_sidebars_widgets;	// If loading from front page, consult $_wp_sidebars_widgets rather than options	// to see if wp_convert_widget_settings() has made manipulations in memory.	if ( !is_admin() ) {		if ( empty($_wp_sidebars_widgets) )			$_wp_sidebars_widgets = get_option('sidebars_widgets', array());		$sidebars_widgets = $_wp_sidebars_widgets;	} else {		$sidebars_widgets = get_option('sidebars_widgets', array());		$_sidebars_widgets = array();		if ( isset($sidebars_widgets['wp_inactive_widgets']) || empty($sidebars_widgets) )			$sidebars_widgets['array_version'] = 3;		elseif ( !isset($sidebars_widgets['array_version']) )			$sidebars_widgets['array_version'] = 1;		switch ( $sidebars_widgets['array_version'] ) {			case 1 :				foreach ( (array) $sidebars_widgets as $index => $sidebar )				if ( is_array($sidebar) )				foreach ( (array) $sidebar as $i => $name ) {					$id = strtolower($name);					if ( isset($wp_registered_widgets[$id]) ) {						$_sidebars_widgets[$index][$i] = $id;						continue;					}					$id = sanitize_title($name);					if ( isset($wp_registered_widgets[$id]) ) {						$_sidebars_widgets[$index][$i] = $id;						continue;					}					$found = false;					foreach ( $wp_registered_widgets as $widget_id => $widget ) {						if ( strtolower($widget['name']) == strtolower($name) ) {							$_sidebars_widgets[$index][$i] = $widget['id'];							$found = true;							break;						} elseif ( sanitize_title($widget['name']) == sanitize_title($name) ) {							$_sidebars_widgets[$index][$i] = $widget['id'];							$found = true;							break;						}					}					if ( $found )						continue;					unset($_sidebars_widgets[$index][$i]);				}				$_sidebars_widgets['array_version'] = 2;				$sidebars_widgets = $_sidebars_widgets;				unset($_sidebars_widgets);			case 2 :				$sidebars = array_keys( $wp_registered_sidebars );				if ( !empty( $sidebars ) ) {					// Move the known-good ones first					foreach ( (array) $sidebars as $id ) {						if ( array_key_exists( $id, $sidebars_widgets ) ) {							$_sidebars_widgets[$id] = $sidebars_widgets[$id];							unset($sidebars_widgets[$id], $sidebars[$id]);						}					}					// move the rest to wp_inactive_widgets					if ( !isset($_sidebars_widgets['wp_inactive_widgets']) )						$_sidebars_widgets['wp_inactive_widgets'] = array();					if ( !empty($sidebars_widgets) ) {						foreach ( $sidebars_widgets as $lost => $val ) {							if ( is_array($val) )								$_sidebars_widgets['wp_inactive_widgets'] = array_merge( (array) $_sidebars_widgets['wp_inactive_widgets'], $val );						}					}					$sidebars_widgets = $_sidebars_widgets;					unset($_sidebars_widgets);				}		}	}	if ( is_array( $sidebars_widgets ) && isset($sidebars_widgets['array_version']) )		unset($sidebars_widgets['array_version']);	$sidebars_widgets = apply_filters('sidebars_widgets', $sidebars_widgets);	return $sidebars_widgets;}/** * Set the sidebar widget option to update sidebars. * * @since 2.2.0 * @access private * * @param array $sidebars_widgets Sidebar widgets and their settings. */function wp_set_sidebars_widgets( $sidebars_widgets ) {	if ( !isset( $sidebars_widgets['array_version'] ) )		$sidebars_widgets['array_version'] = 3;	update_option( 'sidebars_widgets', $sidebars_widgets );}/** * Retrieve default registered sidebars list. * * @since 2.2.0 * @access private * * @return array */function wp_get_widget_defaults() {	global $wp_registered_sidebars;	$defaults = array();	foreach ( (array) $wp_registered_sidebars as $index => $sidebar )		$defaults[$index] = array();	return $defaults;}/** * Convert the widget settings from single to multi-widget format. * * @since 2.8.0 * * @return array */function wp_convert_widget_settings($base_name, $option_name, $settings) {	// This test may need expanding.	$single = $changed = false;	if ( empty($settings) ) {		$single = true;	} else {		foreach ( array_keys($settings) as $number ) {			if ( 'number' == $number )				continue;			if ( !is_numeric($number) ) {				$single = true;				break;			}		}	}	if ( $single ) {		$settings = array( 2 => $settings );		// If loading from the front page, update sidebar in memory but don't save to options		if ( is_admin() ) {			$sidebars_widgets = get_option('sidebars_widgets');		} else {			if ( empty($GLOBALS['_wp_sidebars_widgets']) )				$GLOBALS['_wp_sidebars_widgets'] = get_option('sidebars_widgets', array());			$sidebars_widgets = &$GLOBALS['_wp_sidebars_widgets'];		}		foreach ( (array) $sidebars_widgets as $index => $sidebar ) {			if ( is_array($sidebar) ) {				foreach ( $sidebar as $i => $name ) {					if ( $base_name == $name ) {						$sidebars_widgets[$index][$i] = "$name-2";						$changed = true;						break 2;					}				}			}		}		if ( is_admin() && $changed )			update_option('sidebars_widgets', $sidebars_widgets);	}	$settings['_multiwidget'] = 1;	if ( is_admin() )		update_option( $option_name, $settings );	return $settings;}/** * Output an arbitrary widget as a template tag * * @since 2.8 * * @param string $widget the widget's PHP class name (see default-widgets.php) * @param array $instance the widget's instance settings * @param array $args the widget's sidebar args * @return void **/function the_widget($widget, $instance = array(), $args = array()) {	global $wp_widget_factory;	$widget_obj = $wp_widget_factory->widgets[$widget];	if ( !is_a($widget_obj, 'WP_Widget') )		return;	$before_widget = sprintf('<div class="widget %s">', $widget_obj->widget_options['classname']);	$default_args = array('before_widget' => $before_widget, 'after_widget' => "</div>", 'before_title' => '<h2 class="widgettitle">', 'after_title' => '</h2>');	$args = wp_parse_args($args, $default_args);	$instance = wp_parse_args($instance);	do_action( 'the_widget', $widget, $instance, $args );	$widget_obj->_set(-1);	$widget_obj->widget($args, $instance);}/** * Private */function _get_widget_id_base($id) {	return preg_replace( '/-[0-9]+$/', '', $id );}
<?php/** * The main template file. * * This is the most generic template file in a WordPress theme * and one of the two required files for a theme (the other being style.css). * It is used to display a page when nothing more specific matches a query.  * E.g., it puts together the home page when no home.php file exists. * Learn more: http://codex.wordpress.org/Template_Hierarchy * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main">			<?php			/* Run the loop to output the posts.			 * If you want to overload this in a child theme then include a file			 * called loop-index.php and that will be used instead.			 */			 get_template_part( 'loop', 'index' );			?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
<?php/** * Sets up the default filters and actions for Multisite. * * If you need to remove a default hook, this file will give you the priority * for which to use to remove the hook. * * Not all of the Multisite default hooks are found in ms-default-filters.php * * @package WordPress * @subpackage Multisite * @see default-filters.php * @since 3.0.0 */// Usersadd_filter( 'wpmu_validate_user_signup', 'signup_nonce_check' );add_action( 'init', 'maybe_add_existing_user_to_blog' );add_action( 'wpmu_new_user', 'newuser_notify_siteadmin' );add_action( 'wpmu_activate_user', 'add_new_user_to_blog', 10, 3 );add_action( 'sanitize_user', 'strtolower' );// Blogsadd_filter( 'wpmu_validate_blog_signup', 'signup_nonce_check' );add_action( 'wpmu_new_blog', 'wpmu_log_new_registrations', 10, 2 );add_action( 'wpmu_new_blog', 'newblog_notify_siteadmin', 10, 2 );// Register Nonceadd_action( 'signup_hidden_fields', 'signup_nonce_fields' );// Templateadd_action( 'template_redirect', 'maybe_redirect_404' );add_filter( 'allowed_redirect_hosts', 'redirect_this_site' );// Administrationadd_filter( 'term_id_filter', 'global_terms', 10, 2 );add_action( 'publish_post', 'update_posts_count' );add_action( 'delete_post', 'wpmu_update_blogs_date' );add_action( 'private_to_published', 'wpmu_update_blogs_date' );add_action( 'publish_phone', 'wpmu_update_blogs_date' );add_action( 'publish_post', 'wpmu_update_blogs_date' );// Filesadd_filter( 'wp_upload_bits', 'upload_is_file_too_big' );add_filter( 'import_upload_size_limit', 'fix_import_form_size' );add_filter( 'upload_mimes', 'check_upload_mimes' );add_filter( 'upload_size_limit', 'upload_size_limit_filter' );// Mailadd_filter( 'wp_mail_from', 'wordpressmu_wp_mail_from' );add_action( 'phpmailer_init', 'fix_phpmailer_messageid' );// Disable somethings by default for multisiteadd_filter( 'enable_update_services_configuration', '__return_false' );if ( ! defined('POST_BY_EMAIL') || ! POST_BY_EMAIL ) // back compat constant.	add_filter( 'enable_post_by_email_configuration', '__return_false' );if ( ! defined('EDIT_ANY_USER') || ! EDIT_ANY_USER ) // back compat constant.	add_filter( 'enable_edit_any_user_configuration', '__return_false' );// WP_HOME and WP_SITEURL should not have any effect in MSremove_filter( 'option_siteurl', '_config_wp_siteurl' );remove_filter( 'option_home',    '_config_wp_home'    );?>
<?php/** * These functions can be replaced via plugins. If plugins do not redefine these * functions, then these will be used instead. * * @package WordPress */if ( !function_exists('wp_set_current_user') ) :/** * Changes the current user by ID or name. * * Set $id to null and specify a name if you do not know a user's ID. * * Some WordPress functionality is based on the current user and not based on * the signed in user. Therefore, it opens the ability to edit and perform * actions on users who aren't signed in. * * @since 2.0.3 * @global object $current_user The current user object which holds the user data. * @uses do_action() Calls 'set_current_user' hook after setting the current user. * * @param int $id User ID * @param string $name User's username * @return WP_User Current user User object */function wp_set_current_user($id, $name = '') {	global $current_user;	if ( isset($current_user) && ($id == $current_user->ID) )		return $current_user;	$current_user = new WP_User($id, $name);	setup_userdata($current_user->ID);	do_action('set_current_user');	return $current_user;}endif;if ( !function_exists('wp_get_current_user') ) :/** * Retrieve the current user object. * * @since 2.0.3 * * @return WP_User Current user WP_User object */function wp_get_current_user() {	global $current_user;	get_currentuserinfo();	return $current_user;}endif;if ( !function_exists('get_currentuserinfo') ) :/** * Populate global variables with information about the currently logged in user. * * Will set the current user, if the current user is not set. The current user * will be set to the logged in person. If no user is logged in, then it will * set the current user to 0, which is invalid and won't have any permissions. * * @since 0.71 * @uses $current_user Checks if the current user is set * @uses wp_validate_auth_cookie() Retrieves current logged in user. * * @return bool|null False on XMLRPC Request and invalid auth cookie. Null when current user set */function get_currentuserinfo() {	global $current_user;	if ( defined('XMLRPC_REQUEST') && XMLRPC_REQUEST )		return false;	if ( ! empty($current_user) )		return;	if ( ! $user = wp_validate_auth_cookie() ) {		 if ( is_admin() || empty($_COOKIE[LOGGED_IN_COOKIE]) || !$user = wp_validate_auth_cookie($_COOKIE[LOGGED_IN_COOKIE], 'logged_in') ) {		 	wp_set_current_user(0);		 	return false;		 }	}	wp_set_current_user($user);}endif;if ( !function_exists('get_userdata') ) :/** * Retrieve user info by user ID. * * @since 0.71 * * @param int $user_id User ID * @return bool|object False on failure, User DB row object */function get_userdata( $user_id ) {	global $wpdb;	if ( ! is_numeric( $user_id ) )		return false;	$user_id = absint( $user_id );	if ( ! $user_id )		return false;	$user = wp_cache_get( $user_id, 'users' );	if ( $user )		return $user;	if ( ! $user = $wpdb->get_row( $wpdb->prepare( "SELECT * FROM $wpdb->users WHERE ID = %d LIMIT 1", $user_id ) ) )		return false;	_fill_user( $user );	return $user;}endif;if ( !function_exists('cache_users') ) :/** * Retrieve info for user lists to prevent multiple queries by get_userdata() * * @since 3.0.0 * * @param array $users User ID numbers list */function cache_users( $users ) {	global $wpdb;	$clean = array();	foreach($users as $id) {		$id = (int) $id;		if (wp_cache_get($id, 'users')) {			// seems to be cached already		} else {			$clean[] = $id;		}	}	if ( 0 == count($clean) )		return;	$list = implode(',', $clean);	$results = $wpdb->get_results("SELECT * FROM $wpdb->users WHERE ID IN ($list)");	_fill_many_users($results);}endif;if ( !function_exists('get_user_by') ) :/** * Retrieve user info by a given field * * @since 2.8.0 * * @param string $field The field to retrieve the user with.  id | slug | email | login * @param int|string $value A value for $field.  A user ID, slug, email address, or login name. * @return bool|object False on failure, User DB row object */function get_user_by($field, $value) {	global $wpdb;	switch ($field) {		case 'id':			return get_userdata($value);			break;		case 'slug':			$user_id = wp_cache_get($value, 'userslugs');			$field = 'user_nicename';			break;		case 'email':			$user_id = wp_cache_get($value, 'useremail');			$field = 'user_email';			break;		case 'login':			$value = sanitize_user( $value );			$user_id = wp_cache_get($value, 'userlogins');			$field = 'user_login';			break;		default:			return false;	}	 if ( false !== $user_id )		return get_userdata($user_id);	if ( !$user = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->users WHERE $field = %s", $value) ) )		return false;	_fill_user($user);	return $user;}endif;if ( !function_exists('get_userdatabylogin') ) :/** * Retrieve user info by login name. * * @since 0.71 * * @param string $user_login User's username * @return bool|object False on failure, User DB row object */function get_userdatabylogin($user_login) {	return get_user_by('login', $user_login);}endif;if ( !function_exists('get_user_by_email') ) :/** * Retrieve user info by email. * * @since 2.5 * * @param string $email User's email address * @return bool|object False on failure, User DB row object */function get_user_by_email($email) {	return get_user_by('email', $email);}endif;if ( !function_exists( 'wp_mail' ) ) :/** * Send mail, similar to PHP's mail * * A true return value does not automatically mean that the user received the * email successfully. It just only means that the method used was able to * process the request without any errors. * * Using the two 'wp_mail_from' and 'wp_mail_from_name' hooks allow from * creating a from address like 'Name <email@address.com>' when both are set. If * just 'wp_mail_from' is set, then just the email address will be used with no * name. * * The default content type is 'text/plain' which does not allow using HTML. * However, you can set the content type of the email by using the * 'wp_mail_content_type' filter. * * The default charset is based on the charset used on the blog. The charset can * be set using the 'wp_mail_charset' filter. * * @since 1.2.1 * @uses apply_filters() Calls 'wp_mail' hook on an array of all of the parameters. * @uses apply_filters() Calls 'wp_mail_from' hook to get the from email address. * @uses apply_filters() Calls 'wp_mail_from_name' hook to get the from address name. * @uses apply_filters() Calls 'wp_mail_content_type' hook to get the email content type. * @uses apply_filters() Calls 'wp_mail_charset' hook to get the email charset * @uses do_action_ref_array() Calls 'phpmailer_init' hook on the reference to *		phpmailer object. * @uses PHPMailer * @ * * @param string|array $to Array or comma-separated list of email addresses to send message. * @param string $subject Email subject * @param string $message Message contents * @param string|array $headers Optional. Additional headers. * @param string|array $attachments Optional. Files to attach. * @return bool Whether the email contents were sent successfully. */function wp_mail( $to, $subject, $message, $headers = '', $attachments = array() ) {	// Compact the input, apply the filters, and extract them back out	extract( apply_filters( 'wp_mail', compact( 'to', 'subject', 'message', 'headers', 'attachments' ) ) );	if ( !is_array($attachments) )		$attachments = explode( "\n", str_replace( "\r\n", "\n", $attachments ) );	global $phpmailer;	// (Re)create it, if it's gone missing	if ( !is_object( $phpmailer ) || !is_a( $phpmailer, 'PHPMailer' ) ) {		require_once ABSPATH . WPINC . '/class-phpmailer.php';		require_once ABSPATH . WPINC . '/class-smtp.php';		$phpmailer = new PHPMailer();	}	// Headers	if ( empty( $headers ) ) {		$headers = array();	} else {		if ( !is_array( $headers ) ) {			// Explode the headers out, so this function can take both			// string headers and an array of headers.			$tempheaders = explode( "\n", str_replace( "\r\n", "\n", $headers ) );		} else {			$tempheaders = $headers;		}		$headers = array();		// If it's actually got contents		if ( !empty( $tempheaders ) ) {			// Iterate through the raw headers			foreach ( (array) $tempheaders as $header ) {				if ( strpos($header, ':') === false ) {					if ( false !== stripos( $header, 'boundary=' ) ) {						$parts = preg_split('/boundary=/i', trim( $header ) );						$boundary = trim( str_replace( array( "'", '"' ), '', $parts[1] ) );					}					continue;				}				// Explode them out				list( $name, $content ) = explode( ':', trim( $header ), 2 );				// Cleanup crew				$name    = trim( $name    );				$content = trim( $content );				switch ( strtolower( $name ) ) {					// Mainly for legacy -- process a From: header if it's there					case 'from':						if ( strpos($content, '<' ) !== false ) {							// So... making my life hard again?							$from_name = substr( $content, 0, strpos( $content, '<' ) - 1 );							$from_name = str_replace( '"', '', $from_name );							$from_name = trim( $from_name );							$from_email = substr( $content, strpos( $content, '<' ) + 1 );							$from_email = str_replace( '>', '', $from_email );							$from_email = trim( $from_email );						} else {							$from_email = trim( $content );						}						break;					case 'content-type':						if ( strpos( $content, ';' ) !== false ) {							list( $type, $charset ) = explode( ';', $content );							$content_type = trim( $type );							if ( false !== stripos( $charset, 'charset=' ) ) {								$charset = trim( str_replace( array( 'charset=', '"' ), '', $charset ) );							} elseif ( false !== stripos( $charset, 'boundary=' ) ) {								$boundary = trim( str_replace( array( 'BOUNDARY=', 'boundary=', '"' ), '', $charset ) );								$charset = '';							}						} else {							$content_type = trim( $content );						}						break;					case 'cc':						$cc = array_merge( (array) $cc, explode( ',', $content ) );						break;					case 'bcc':						$bcc = array_merge( (array) $bcc, explode( ',', $content ) );						break;					default:						// Add it to our grand headers array						$headers[trim( $name )] = trim( $content );						break;				}			}		}	}	// Empty out the values that may be set	$phpmailer->ClearAddresses();	$phpmailer->ClearAllRecipients();	$phpmailer->ClearAttachments();	$phpmailer->ClearBCCs();	$phpmailer->ClearCCs();	$phpmailer->ClearCustomHeaders();	$phpmailer->ClearReplyTos();	// From email and name	// If we don't have a name from the input headers	if ( !isset( $from_name ) )		$from_name = 'WordPress';	/* If we don't have an email from the input headers default to wordpress@$sitename	 * Some hosts will block outgoing mail from this address if it doesn't exist but	 * there's no easy alternative. Defaulting to admin_email might appear to be another	 * option but some hosts may refuse to relay mail from an unknown domain. See	 * http://trac.wordpress.org/ticket/5007.	 */	if ( !isset( $from_email ) ) {		// Get the site domain and get rid of www.		$sitename = strtolower( $_SERVER['SERVER_NAME'] );		if ( substr( $sitename, 0, 4 ) == 'www.' ) {			$sitename = substr( $sitename, 4 );		}		$from_email = 'wordpress@' . $sitename;	}	// Plugin authors can override the potentially troublesome default	$phpmailer->From     = apply_filters( 'wp_mail_from'     , $from_email );	$phpmailer->FromName = apply_filters( 'wp_mail_from_name', $from_name  );	// Set destination addresses	if ( !is_array( $to ) )		$to = explode( ',', $to );	foreach ( (array) $to as $recipient ) {		$phpmailer->AddAddress( trim( $recipient ) );	}	// Set mail's subject and body	$phpmailer->Subject = $subject;	$phpmailer->Body    = $message;	// Add any CC and BCC recipients	if ( !empty( $cc ) ) {		foreach ( (array) $cc as $recipient ) {			$phpmailer->AddCc( trim($recipient) );		}	}	if ( !empty( $bcc ) ) {		foreach ( (array) $bcc as $recipient) {			$phpmailer->AddBcc( trim($recipient) );		}	}	// Set to use PHP's mail()	$phpmailer->IsMail();	// Set Content-Type and charset	// If we don't have a content-type from the input headers	if ( !isset( $content_type ) )		$content_type = 'text/plain';	$content_type = apply_filters( 'wp_mail_content_type', $content_type );	$phpmailer->ContentType = $content_type;	// Set whether it's plaintext, depending on $content_type	if ( 'text/html' == $content_type )		$phpmailer->IsHTML( true );	// If we don't have a charset from the input headers	if ( !isset( $charset ) )		$charset = get_bloginfo( 'charset' );	// Set the content-type and charset	$phpmailer->CharSet = apply_filters( 'wp_mail_charset', $charset );	// Set custom headers	if ( !empty( $headers ) ) {		foreach( (array) $headers as $name => $content ) {			$phpmailer->AddCustomHeader( sprintf( '%1$s: %2$s', $name, $content ) );		}		if ( false !== stripos( $content_type, 'multipart' ) && ! empty($boundary) )			$phpmailer->AddCustomHeader( sprintf( "Content-Type: %s;\n\t boundary=\"%s\"", $content_type, $boundary ) );	}	if ( !empty( $attachments ) ) {		foreach ( $attachments as $attachment ) {			$phpmailer->AddAttachment($attachment);		}	}	do_action_ref_array( 'phpmailer_init', array( &$phpmailer ) );	// Send!	$result = @$phpmailer->Send();	return $result;}endif;if ( !function_exists('wp_authenticate') ) :/** * Checks a user's login information and logs them in if it checks out. * * @since 2.5.0 * * @param string $username User's username * @param string $password User's password * @return WP_Error|WP_User WP_User object if login successful, otherwise WP_Error object. */function wp_authenticate($username, $password) {	$username = sanitize_user($username);	$password = trim($password);	$user = apply_filters('authenticate', null, $username, $password);	if ( $user == null ) {		// TODO what should the error message be? (Or would these even happen?)		// Only needed if all authentication handlers fail to return anything.		$user = new WP_Error('authentication_failed', __('<strong>ERROR</strong>: Invalid username or incorrect password.'));	}	$ignore_codes = array('empty_username', 'empty_password');	if (is_wp_error($user) && !in_array($user->get_error_code(), $ignore_codes) ) {		do_action('wp_login_failed', $username);	}	return $user;}endif;if ( !function_exists('wp_logout') ) :/** * Log the current user out. * * @since 2.5.0 */function wp_logout() {	wp_clear_auth_cookie();	do_action('wp_logout');}endif;if ( !function_exists('wp_validate_auth_cookie') ) :/** * Validates authentication cookie. * * The checks include making sure that the authentication cookie is set and * pulling in the contents (if $cookie is not used). * * Makes sure the cookie is not expired. Verifies the hash in cookie is what is * should be and compares the two. * * @since 2.5 * * @param string $cookie Optional. If used, will validate contents instead of cookie's * @param string $scheme Optional. The cookie scheme to use: auth, secure_auth, or logged_in * @return bool|int False if invalid cookie, User ID if valid. */function wp_validate_auth_cookie($cookie = '', $scheme = '') {	if ( ! $cookie_elements = wp_parse_auth_cookie($cookie, $scheme) ) {		do_action('auth_cookie_malformed', $cookie, $scheme);		return false;	}	extract($cookie_elements, EXTR_OVERWRITE);	$expired = $expiration;	// Allow a grace period for POST and AJAX requests	if ( defined('DOING_AJAX') || 'POST' == $_SERVER['REQUEST_METHOD'] )		$expired += 3600;	// Quick check to see if an honest cookie has expired	if ( $expired < time() ) {		do_action('auth_cookie_expired', $cookie_elements);		return false;	}	$user = get_userdatabylogin($username);	if ( ! $user ) {		do_action('auth_cookie_bad_username', $cookie_elements);		return false;	}	$pass_frag = substr($user->user_pass, 8, 4);	$key = wp_hash($username . $pass_frag . '|' . $expiration, $scheme);	$hash = hash_hmac('md5', $username . '|' . $expiration, $key);	if ( $hmac != $hash ) {		do_action('auth_cookie_bad_hash', $cookie_elements);		return false;	}	if ( $expiration < time() ) // AJAX/POST grace period set above		$GLOBALS['login_grace_period'] = 1;	do_action('auth_cookie_valid', $cookie_elements, $user);	return $user->ID;}endif;if ( !function_exists('wp_generate_auth_cookie') ) :/** * Generate authentication cookie contents. * * @since 2.5 * @uses apply_filters() Calls 'auth_cookie' hook on $cookie contents, User ID *		and expiration of cookie. * * @param int $user_id User ID * @param int $expiration Cookie expiration in seconds * @param string $scheme Optional. The cookie scheme to use: auth, secure_auth, or logged_in * @return string Authentication cookie contents */function wp_generate_auth_cookie($user_id, $expiration, $scheme = 'auth') {	$user = get_userdata($user_id);	$pass_frag = substr($user->user_pass, 8, 4);	$key = wp_hash($user->user_login . $pass_frag . '|' . $expiration, $scheme);	$hash = hash_hmac('md5', $user->user_login . '|' . $expiration, $key);	$cookie = $user->user_login . '|' . $expiration . '|' . $hash;	return apply_filters('auth_cookie', $cookie, $user_id, $expiration, $scheme);}endif;if ( !function_exists('wp_parse_auth_cookie') ) :/** * Parse a cookie into its components * * @since 2.7 * * @param string $cookie * @param string $scheme Optional. The cookie scheme to use: auth, secure_auth, or logged_in * @return array Authentication cookie components */function wp_parse_auth_cookie($cookie = '', $scheme = '') {	if ( empty($cookie) ) {		switch ($scheme){			case 'auth':				$cookie_name = AUTH_COOKIE;				break;			case 'secure_auth':				$cookie_name = SECURE_AUTH_COOKIE;				break;			case "logged_in":				$cookie_name = LOGGED_IN_COOKIE;				break;			default:				if ( is_ssl() ) {					$cookie_name = SECURE_AUTH_COOKIE;					$scheme = 'secure_auth';				} else {					$cookie_name = AUTH_COOKIE;					$scheme = 'auth';				}	    }		if ( empty($_COOKIE[$cookie_name]) )			return false;		$cookie = $_COOKIE[$cookie_name];	}	$cookie_elements = explode('|', $cookie);	if ( count($cookie_elements) != 3 )		return false;	list($username, $expiration, $hmac) = $cookie_elements;	return compact('username', 'expiration', 'hmac', 'scheme');}endif;if ( !function_exists('wp_set_auth_cookie') ) :/** * Sets the authentication cookies based User ID. * * The $remember parameter increases the time that the cookie will be kept. The * default the cookie is kept without remembering is two days. When $remember is * set, the cookies will be kept for 14 days or two weeks. * * @since 2.5 * * @param int $user_id User ID * @param bool $remember Whether to remember the user */function wp_set_auth_cookie($user_id, $remember = false, $secure = '') {	if ( $remember ) {		$expiration = $expire = time() + apply_filters('auth_cookie_expiration', 1209600, $user_id, $remember);	} else {		$expiration = time() + apply_filters('auth_cookie_expiration', 172800, $user_id, $remember);		$expire = 0;	}	if ( '' === $secure )		$secure = is_ssl();	if ( $secure ) {		$auth_cookie_name = SECURE_AUTH_COOKIE;		$scheme = 'secure_auth';	} else {		$auth_cookie_name = AUTH_COOKIE;		$scheme = 'auth';	}	$auth_cookie = wp_generate_auth_cookie($user_id, $expiration, $scheme);	$logged_in_cookie = wp_generate_auth_cookie($user_id, $expiration, 'logged_in');	do_action('set_auth_cookie', $auth_cookie, $expire, $expiration, $user_id, $scheme);	do_action('set_logged_in_cookie', $logged_in_cookie, $expire, $expiration, $user_id, 'logged_in');	// Set httponly if the php version is >= 5.2.0	if ( version_compare(phpversion(), '5.2.0', 'ge') ) {		setcookie($auth_cookie_name, $auth_cookie, $expire, PLUGINS_COOKIE_PATH, COOKIE_DOMAIN, $secure, true);		setcookie($auth_cookie_name, $auth_cookie, $expire, ADMIN_COOKIE_PATH, COOKIE_DOMAIN, $secure, true);		setcookie(LOGGED_IN_COOKIE, $logged_in_cookie, $expire, COOKIEPATH, COOKIE_DOMAIN, false, true);		if ( COOKIEPATH != SITECOOKIEPATH )			setcookie(LOGGED_IN_COOKIE, $logged_in_cookie, $expire, SITECOOKIEPATH, COOKIE_DOMAIN, false, true);	} else {		$cookie_domain = COOKIE_DOMAIN;		if ( !empty($cookie_domain) )			$cookie_domain .= '; HttpOnly';		setcookie($auth_cookie_name, $auth_cookie, $expire, PLUGINS_COOKIE_PATH, $cookie_domain, $secure);		setcookie($auth_cookie_name, $auth_cookie, $expire, ADMIN_COOKIE_PATH, $cookie_domain, $secure);		setcookie(LOGGED_IN_COOKIE, $logged_in_cookie, $expire, COOKIEPATH, $cookie_domain);		if ( COOKIEPATH != SITECOOKIEPATH )			setcookie(LOGGED_IN_COOKIE, $logged_in_cookie, $expire, SITECOOKIEPATH, $cookie_domain);	}}endif;if ( !function_exists('wp_clear_auth_cookie') ) :/** * Removes all of the cookies associated with authentication. * * @since 2.5 */function wp_clear_auth_cookie() {	do_action('clear_auth_cookie');	setcookie(AUTH_COOKIE, ' ', time() - 31536000, ADMIN_COOKIE_PATH, COOKIE_DOMAIN);	setcookie(SECURE_AUTH_COOKIE, ' ', time() - 31536000, ADMIN_COOKIE_PATH, COOKIE_DOMAIN);	setcookie(AUTH_COOKIE, ' ', time() - 31536000, PLUGINS_COOKIE_PATH, COOKIE_DOMAIN);	setcookie(SECURE_AUTH_COOKIE, ' ', time() - 31536000, PLUGINS_COOKIE_PATH, COOKIE_DOMAIN);	setcookie(LOGGED_IN_COOKIE, ' ', time() - 31536000, COOKIEPATH, COOKIE_DOMAIN);	setcookie(LOGGED_IN_COOKIE, ' ', time() - 31536000, SITECOOKIEPATH, COOKIE_DOMAIN);	// Old cookies	setcookie(AUTH_COOKIE, ' ', time() - 31536000, COOKIEPATH, COOKIE_DOMAIN);	setcookie(AUTH_COOKIE, ' ', time() - 31536000, SITECOOKIEPATH, COOKIE_DOMAIN);	setcookie(SECURE_AUTH_COOKIE, ' ', time() - 31536000, COOKIEPATH, COOKIE_DOMAIN);	setcookie(SECURE_AUTH_COOKIE, ' ', time() - 31536000, SITECOOKIEPATH, COOKIE_DOMAIN);	// Even older cookies	setcookie(USER_COOKIE, ' ', time() - 31536000, COOKIEPATH, COOKIE_DOMAIN);	setcookie(PASS_COOKIE, ' ', time() - 31536000, COOKIEPATH, COOKIE_DOMAIN);	setcookie(USER_COOKIE, ' ', time() - 31536000, SITECOOKIEPATH, COOKIE_DOMAIN);	setcookie(PASS_COOKIE, ' ', time() - 31536000, SITECOOKIEPATH, COOKIE_DOMAIN);}endif;if ( !function_exists('is_user_logged_in') ) :/** * Checks if the current visitor is a logged in user. * * @since 2.0.0 * * @return bool True if user is logged in, false if not logged in. */function is_user_logged_in() {	$user = wp_get_current_user();	if ( $user->id == 0 )		return false;	return true;}endif;if ( !function_exists('auth_redirect') ) :/** * Checks if a user is logged in, if not it redirects them to the login page. * * @since 1.5 */function auth_redirect() {	// Checks if a user is logged in, if not redirects them to the login page	$secure = ( is_ssl() || force_ssl_admin() );	// If https is required and request is http, redirect	if ( $secure && !is_ssl() && false !== strpos($_SERVER['REQUEST_URI'], 'wp-admin') ) {		if ( 0 === strpos($_SERVER['REQUEST_URI'], 'http') ) {			wp_redirect(preg_replace('|^http://|', 'https://', $_SERVER['REQUEST_URI']));			exit();		} else {			wp_redirect('https://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI']);			exit();		}	}	if ( $user_id = wp_validate_auth_cookie( '', apply_filters( 'auth_redirect_scheme', '' ) ) ) {		do_action('auth_redirect', $user_id);		// If the user wants ssl but the session is not ssl, redirect.		if ( !$secure && get_user_option('use_ssl', $user_id) && false !== strpos($_SERVER['REQUEST_URI'], 'wp-admin') ) {			if ( 0 === strpos($_SERVER['REQUEST_URI'], 'http') ) {				wp_redirect(preg_replace('|^http://|', 'https://', $_SERVER['REQUEST_URI']));				exit();			} else {				wp_redirect('https://' . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI']);				exit();			}		}		return;  // The cookie is good so we're done	}	// The cookie is no good so force login	nocache_headers();	if ( is_ssl() )		$proto = 'https://';	else		$proto = 'http://';	$redirect = ( strpos($_SERVER['REQUEST_URI'], '/options.php') && wp_get_referer() ) ? wp_get_referer() : $proto . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];	$login_url = wp_login_url($redirect, true);	wp_redirect($login_url);	exit();}endif;if ( !function_exists('check_admin_referer') ) :/** * Makes sure that a user was referred from another admin page. * * To avoid security exploits. * * @since 1.2.0 * @uses do_action() Calls 'check_admin_referer' on $action. * * @param string $action Action nonce * @param string $query_arg where to look for nonce in $_REQUEST (since 2.5) */function check_admin_referer($action = -1, $query_arg = '_wpnonce') {	$adminurl = strtolower(admin_url());	$referer = strtolower(wp_get_referer());	$result = isset($_REQUEST[$query_arg]) ? wp_verify_nonce($_REQUEST[$query_arg], $action) : false;	if ( !$result && !(-1 == $action && strpos($referer, $adminurl) !== false) ) {		wp_nonce_ays($action);		die();	}	do_action('check_admin_referer', $action, $result);	return $result;}endif;if ( !function_exists('check_ajax_referer') ) :/** * Verifies the AJAX request to prevent processing requests external of the blog. * * @since 2.0.3 * * @param string $action Action nonce * @param string $query_arg where to look for nonce in $_REQUEST (since 2.5) */function check_ajax_referer( $action = -1, $query_arg = false, $die = true ) {	if ( $query_arg )		$nonce = $_REQUEST[$query_arg];	else		$nonce = isset($_REQUEST['_ajax_nonce']) ? $_REQUEST['_ajax_nonce'] : $_REQUEST['_wpnonce'];	$result = wp_verify_nonce( $nonce, $action );	if ( $die && false == $result )		die('-1');	do_action('check_ajax_referer', $action, $result);	return $result;}endif;if ( !function_exists('wp_redirect') ) :/** * Redirects to another page, with a workaround for the IIS Set-Cookie bug. * * @link http://support.microsoft.com/kb/q176113/ * @since 1.5.1 * @uses apply_filters() Calls 'wp_redirect' hook on $location and $status. * * @param string $location The path to redirect to * @param int $status Status code to use * @return bool False if $location is not set */function wp_redirect($location, $status = 302) {	global $is_IIS;	$location = apply_filters('wp_redirect', $location, $status);	$status = apply_filters('wp_redirect_status', $status, $location);	if ( !$location ) // allows the wp_redirect filter to cancel a redirect		return false;	$location = wp_sanitize_redirect($location);	if ( $is_IIS ) {		header("Refresh: 0;url=$location");	} else {		if ( php_sapi_name() != 'cgi-fcgi' )			status_header($status); // This causes problems on IIS and some FastCGI setups		header("Location: $location", true, $status);	}}endif;if ( !function_exists('wp_sanitize_redirect') ) :/** * Sanitizes a URL for use in a redirect. * * @since 2.3 * * @return string redirect-sanitized URL **/function wp_sanitize_redirect($location) {	$location = preg_replace('|[^a-z0-9-~+_.?#=&;,/:%!]|i', '', $location);	$location = wp_kses_no_null($location);	// remove %0d and %0a from location	$strip = array('%0d', '%0a', '%0D', '%0A');	$location = _deep_replace($strip, $location);	return $location;}endif;if ( !function_exists('wp_safe_redirect') ) :/** * Performs a safe (local) redirect, using wp_redirect(). * * Checks whether the $location is using an allowed host, if it has an absolute * path. A plugin can therefore set or remove allowed host(s) to or from the * list. * * If the host is not allowed, then the redirect is to wp-admin on the siteurl * instead. This prevents malicious redirects which redirect to another host, * but only used in a few places. * * @since 2.3 * @uses wp_validate_redirect() To validate the redirect is to an allowed host. * * @return void Does not return anything **/function wp_safe_redirect($location, $status = 302) {	// Need to look at the URL the way it will end up in wp_redirect()	$location = wp_sanitize_redirect($location);	$location = wp_validate_redirect($location, admin_url());	wp_redirect($location, $status);}endif;if ( !function_exists('wp_validate_redirect') ) :/** * Validates a URL for use in a redirect. * * Checks whether the $location is using an allowed host, if it has an absolute * path. A plugin can therefore set or remove allowed host(s) to or from the * list. * * If the host is not allowed, then the redirect is to $default supplied * * @since 2.8.1 * @uses apply_filters() Calls 'allowed_redirect_hosts' on an array containing *		WordPress host string and $location host string. * * @param string $location The redirect to validate * @param string $default The value to return is $location is not allowed * @return string redirect-sanitized URL **/function wp_validate_redirect($location, $default = '') {	// browsers will assume 'http' is your protocol, and will obey a redirect to a URL starting with '//'	if ( substr($location, 0, 2) == '//' )		$location = 'http:' . $location;	// In php 5 parse_url may fail if the URL query part contains http://, bug #38143	$test = ( $cut = strpos($location, '?') ) ? substr( $location, 0, $cut ) : $location;	$lp  = parse_url($test);	// Give up if malformed URL	if ( false === $lp )		return $default;	// Allow only http and https schemes. No data:, etc.	if ( isset($lp['scheme']) && !('http' == $lp['scheme'] || 'https' == $lp['scheme']) )		return $default;	// Reject if scheme is set but host is not. This catches urls like https:host.com for which parse_url does not set the host field.	if ( isset($lp['scheme'])  && !isset($lp['host']) )		return $default;	$wpp = parse_url(home_url());	$allowed_hosts = (array) apply_filters('allowed_redirect_hosts', array($wpp['host']), isset($lp['host']) ? $lp['host'] : '');	if ( isset($lp['host']) && ( !in_array($lp['host'], $allowed_hosts) && $lp['host'] != strtolower($wpp['host'])) )		$location = $default;	return $location;}endif;if ( ! function_exists('wp_notify_postauthor') ) :/** * Notify an author of a comment/trackback/pingback to one of their posts. * * @since 1.0.0 * * @param int $comment_id Comment ID * @param string $comment_type Optional. The comment type either 'comment' (default), 'trackback', or 'pingback' * @return bool False if user email does not exist. True on completion. */function wp_notify_postauthor($comment_id, $comment_type='') {	$comment = get_comment($comment_id);	$post    = get_post($comment->comment_post_ID);	$user    = get_userdata( $post->post_author );	if ( $comment->user_id == $post->post_author ) return false; // The author moderated a comment on his own post	if ('' == $user->user_email) return false; // If there's no email to send the comment to	$comment_author_domain = @gethostbyaddr($comment->comment_author_IP);	// The blogname option is escaped with esc_html on the way into the database in sanitize_option	// we want to reverse this for the plain text arena of emails.	$blogname = wp_specialchars_decode(get_option('blogname'), ENT_QUOTES);	if ( empty( $comment_type ) ) $comment_type = 'comment';	if ('comment' == $comment_type) {		$notify_message  = sprintf( __( 'New comment on your post "%s"' ), $post->post_title ) . "\r\n";		/* translators: 1: comment author, 2: author IP, 3: author domain */		$notify_message .= sprintf( __('Author : %1$s (IP: %2$s , %3$s)'), $comment->comment_author, $comment->comment_author_IP, $comment_author_domain ) . "\r\n";		$notify_message .= sprintf( __('E-mail : %s'), $comment->comment_author_email ) . "\r\n";		$notify_message .= sprintf( __('URL    : %s'), $comment->comment_author_url ) . "\r\n";		$notify_message .= sprintf( __('Whois  : http://ws.arin.net/cgi-bin/whois.pl?queryinput=%s'), $comment->comment_author_IP ) . "\r\n";		$notify_message .= __('Comment: ') . "\r\n" . $comment->comment_content . "\r\n\r\n";		$notify_message .= __('You can see all comments on this post here: ') . "\r\n";		/* translators: 1: blog name, 2: post title */		$subject = sprintf( __('[%1$s] Comment: "%2$s"'), $blogname, $post->post_title );	} elseif ('trackback' == $comment_type) {		$notify_message  = sprintf( __( 'New trackback on your post "%s"' ), $post->post_title ) . "\r\n";		/* translators: 1: website name, 2: author IP, 3: author domain */		$notify_message .= sprintf( __('Website: %1$s (IP: %2$s , %3$s)'), $comment->comment_author, $comment->comment_author_IP, $comment_author_domain ) . "\r\n";		$notify_message .= sprintf( __('URL    : %s'), $comment->comment_author_url ) . "\r\n";		$notify_message .= __('Excerpt: ') . "\r\n" . $comment->comment_content . "\r\n\r\n";		$notify_message .= __('You can see all trackbacks on this post here: ') . "\r\n";		/* translators: 1: blog name, 2: post title */		$subject = sprintf( __('[%1$s] Trackback: "%2$s"'), $blogname, $post->post_title );	} elseif ('pingback' == $comment_type) {		$notify_message  = sprintf( __( 'New pingback on your post "%s"' ), $post->post_title ) . "\r\n";		/* translators: 1: comment author, 2: author IP, 3: author domain */		$notify_message .= sprintf( __('Website: %1$s (IP: %2$s , %3$s)'), $comment->comment_author, $comment->comment_author_IP, $comment_author_domain ) . "\r\n";		$notify_message .= sprintf( __('URL    : %s'), $comment->comment_author_url ) . "\r\n";		$notify_message .= __('Excerpt: ') . "\r\n" . sprintf('[...] %s [...]', $comment->comment_content ) . "\r\n\r\n";		$notify_message .= __('You can see all pingbacks on this post here: ') . "\r\n";		/* translators: 1: blog name, 2: post title */		$subject = sprintf( __('[%1$s] Pingback: "%2$s"'), $blogname, $post->post_title );	}	$notify_message .= get_permalink($comment->comment_post_ID) . "#comments\r\n\r\n";	if ( EMPTY_TRASH_DAYS )		$notify_message .= sprintf( __('Trash it: %s'), admin_url("comment.php?action=trash&c=$comment_id") ) . "\r\n";	else		$notify_message .= sprintf( __('Delete it: %s'), admin_url("comment.php?action=delete&c=$comment_id") ) . "\r\n";	$notify_message .= sprintf( __('Spam it: %s'), admin_url("comment.php?action=spam&c=$comment_id") ) . "\r\n";	$wp_email = 'wordpress@' . preg_replace('#^www\.#', '', strtolower($_SERVER['SERVER_NAME']));	if ( '' == $comment->comment_author ) {		$from = "From: \"$blogname\" <$wp_email>";		if ( '' != $comment->comment_author_email )			$reply_to = "Reply-To: $comment->comment_author_email";	} else {		$from = "From: \"$comment->comment_author\" <$wp_email>";		if ( '' != $comment->comment_author_email )			$reply_to = "Reply-To: \"$comment->comment_author_email\" <$comment->comment_author_email>";	}	$message_headers = "$from\n"		. "Content-Type: text/plain; charset=\"" . get_option('blog_charset') . "\"\n";	if ( isset($reply_to) )		$message_headers .= $reply_to . "\n";	$notify_message = apply_filters('comment_notification_text', $notify_message, $comment_id);	$subject = apply_filters('comment_notification_subject', $subject, $comment_id);	$message_headers = apply_filters('comment_notification_headers', $message_headers, $comment_id);	@wp_mail($user->user_email, $subject, $notify_message, $message_headers);	return true;}endif;if ( !function_exists('wp_notify_moderator') ) :/** * Notifies the moderator of the blog about a new comment that is awaiting approval. * * @since 1.0 * @uses $wpdb * * @param int $comment_id Comment ID * @return bool Always returns true */function wp_notify_moderator($comment_id) {	global $wpdb;	if( get_option( "moderation_notify" ) == 0 )		return true;	$comment = $wpdb->get_row($wpdb->prepare("SELECT * FROM $wpdb->comments WHERE comment_ID=%d LIMIT 1", $comment_id));	$post = $wpdb->get_row($wpdb->prepare("SELECT * FROM $wpdb->posts WHERE ID=%d LIMIT 1", $comment->comment_post_ID));	$comment_author_domain = @gethostbyaddr($comment->comment_author_IP);	$comments_waiting = $wpdb->get_var("SELECT count(comment_ID) FROM $wpdb->comments WHERE comment_approved = '0'");	// The blogname option is escaped with esc_html on the way into the database in sanitize_option	// we want to reverse this for the plain text arena of emails.	$blogname = wp_specialchars_decode(get_option('blogname'), ENT_QUOTES);	switch ($comment->comment_type)	{		case 'trackback':			$notify_message  = sprintf( __('A new trackback on the post "%s" is waiting for your approval'), $post->post_title ) . "\r\n";			$notify_message .= get_permalink($comment->comment_post_ID) . "\r\n\r\n";			$notify_message .= sprintf( __('Website : %1$s (IP: %2$s , %3$s)'), $comment->comment_author, $comment->comment_author_IP, $comment_author_domain ) . "\r\n";			$notify_message .= sprintf( __('URL    : %s'), $comment->comment_author_url ) . "\r\n";			$notify_message .= __('Trackback excerpt: ') . "\r\n" . $comment->comment_content . "\r\n\r\n";			break;		case 'pingback':			$notify_message  = sprintf( __('A new pingback on the post "%s" is waiting for your approval'), $post->post_title ) . "\r\n";			$notify_message .= get_permalink($comment->comment_post_ID) . "\r\n\r\n";			$notify_message .= sprintf( __('Website : %1$s (IP: %2$s , %3$s)'), $comment->comment_author, $comment->comment_author_IP, $comment_author_domain ) . "\r\n";			$notify_message .= sprintf( __('URL    : %s'), $comment->comment_author_url ) . "\r\n";			$notify_message .= __('Pingback excerpt: ') . "\r\n" . $comment->comment_content . "\r\n\r\n";			break;		default: //Comments			$notify_message  = sprintf( __('A new comment on the post "%s" is waiting for your approval'), $post->post_title ) . "\r\n";			$notify_message .= get_permalink($comment->comment_post_ID) . "\r\n\r\n";			$notify_message .= sprintf( __('Author : %1$s (IP: %2$s , %3$s)'), $comment->comment_author, $comment->comment_author_IP, $comment_author_domain ) . "\r\n";			$notify_message .= sprintf( __('E-mail : %s'), $comment->comment_author_email ) . "\r\n";			$notify_message .= sprintf( __('URL    : %s'), $comment->comment_author_url ) . "\r\n";			$notify_message .= sprintf( __('Whois  : http://ws.arin.net/cgi-bin/whois.pl?queryinput=%s'), $comment->comment_author_IP ) . "\r\n";			$notify_message .= __('Comment: ') . "\r\n" . $comment->comment_content . "\r\n\r\n";			break;	}	$notify_message .= sprintf( __('Approve it: %s'),  admin_url("comment.php?action=approve&c=$comment_id") ) . "\r\n";	if ( EMPTY_TRASH_DAYS )		$notify_message .= sprintf( __('Trash it: %s'), admin_url("comment.php?action=trash&c=$comment_id") ) . "\r\n";	else		$notify_message .= sprintf( __('Delete it: %s'), admin_url("comment.php?action=delete&c=$comment_id") ) . "\r\n";	$notify_message .= sprintf( __('Spam it: %s'), admin_url("comment.php?action=spam&c=$comment_id") ) . "\r\n";	$notify_message .= sprintf( _n('Currently %s comment is waiting for approval. Please visit the moderation panel:', 		'Currently %s comments are waiting for approval. Please visit the moderation panel:', $comments_waiting), number_format_i18n($comments_waiting) ) . "\r\n";	$notify_message .= admin_url("edit-comments.php?comment_status=moderated") . "\r\n";	$subject = sprintf( __('[%1$s] Please moderate: "%2$s"'), $blogname, $post->post_title );	$admin_email = get_option('admin_email');	$message_headers = '';	$notify_message = apply_filters('comment_moderation_text', $notify_message, $comment_id);	$subject = apply_filters('comment_moderation_subject', $subject, $comment_id);	$message_headers = apply_filters('comment_moderation_headers', $message_headers);	@wp_mail($admin_email, $subject, $notify_message, $message_headers);	return true;}endif;if ( !function_exists('wp_password_change_notification') ) :/** * Notify the blog admin of a user changing password, normally via email. * * @since 2.7 * * @param object $user User Object */function wp_password_change_notification(&$user) {	// send a copy of password change notification to the admin	// but check to see if it's the admin whose password we're changing, and skip this	if ( $user->user_email != get_option('admin_email') ) {		$message = sprintf(__('Password Lost and Changed for user: %s'), $user->user_login) . "\r\n";		// The blogname option is escaped with esc_html on the way into the database in sanitize_option		// we want to reverse this for the plain text arena of emails.		$blogname = wp_specialchars_decode(get_option('blogname'), ENT_QUOTES);		wp_mail(get_option('admin_email'), sprintf(__('[%s] Password Lost/Changed'), $blogname), $message);	}}endif;if ( !function_exists('wp_new_user_notification') ) :/** * Notify the blog admin of a new user, normally via email. * * @since 2.0 * * @param int $user_id User ID * @param string $plaintext_pass Optional. The user's plaintext password */function wp_new_user_notification($user_id, $plaintext_pass = '') {	$user = new WP_User($user_id);	$user_login = stripslashes($user->user_login);	$user_email = stripslashes($user->user_email);	// The blogname option is escaped with esc_html on the way into the database in sanitize_option	// we want to reverse this for the plain text arena of emails.	$blogname = wp_specialchars_decode(get_option('blogname'), ENT_QUOTES);	$message  = sprintf(__('New user registration on your site %s:'), $blogname) . "\r\n\r\n";	$message .= sprintf(__('Username: %s'), $user_login) . "\r\n\r\n";	$message .= sprintf(__('E-mail: %s'), $user_email) . "\r\n";	@wp_mail(get_option('admin_email'), sprintf(__('[%s] New User Registration'), $blogname), $message);	if ( empty($plaintext_pass) )		return;	$message  = sprintf(__('Username: %s'), $user_login) . "\r\n";	$message .= sprintf(__('Password: %s'), $plaintext_pass) . "\r\n";	$message .= wp_login_url() . "\r\n";	wp_mail($user_email, sprintf(__('[%s] Your username and password'), $blogname), $message);}endif;if ( !function_exists('wp_nonce_tick') ) :/** * Get the time-dependent variable for nonce creation. * * A nonce has a lifespan of two ticks. Nonces in their second tick may be * updated, e.g. by autosave. * * @since 2.5 * * @return int */function wp_nonce_tick() {	$nonce_life = apply_filters('nonce_life', 86400);	return ceil(time() / ( $nonce_life / 2 ));}endif;if ( !function_exists('wp_verify_nonce') ) :/** * Verify that correct nonce was used with time limit. * * The user is given an amount of time to use the token, so therefore, since the * UID and $action remain the same, the independent variable is the time. * * @since 2.0.3 * * @param string $nonce Nonce that was used in the form to verify * @param string|int $action Should give context to what is taking place and be the same when nonce was created. * @return bool Whether the nonce check passed or failed. */function wp_verify_nonce($nonce, $action = -1) {	$user = wp_get_current_user();	$uid = (int) $user->id;	$i = wp_nonce_tick();	// Nonce generated 0-12 hours ago	if ( substr(wp_hash($i . $action . $uid, 'nonce'), -12, 10) == $nonce )		return 1;	// Nonce generated 12-24 hours ago	if ( substr(wp_hash(($i - 1) . $action . $uid, 'nonce'), -12, 10) == $nonce )		return 2;	// Invalid nonce	return false;}endif;if ( !function_exists('wp_create_nonce') ) :/** * Creates a random, one time use token. * * @since 2.0.3 * * @param string|int $action Scalar value to add context to the nonce. * @return string The one use form token */function wp_create_nonce($action = -1) {	$user = wp_get_current_user();	$uid = (int) $user->id;	$i = wp_nonce_tick();	return substr(wp_hash($i . $action . $uid, 'nonce'), -12, 10);}endif;if ( !function_exists('wp_salt') ) :/** * Get salt to add to hashes to help prevent attacks. * * The secret key is located in two places: the database in case the secret key * isn't defined in the second place, which is in the wp-config.php file. If you * are going to set the secret key, then you must do so in the wp-config.php * file. * * The secret key in the database is randomly generated and will be appended to * the secret key that is in wp-config.php file in some instances. It is * important to have the secret key defined or changed in wp-config.php. * * If you have installed WordPress 2.5 or later, then you will have the * SECRET_KEY defined in the wp-config.php already. You will want to change the * value in it because hackers will know what it is. If you have upgraded to * WordPress 2.5 or later version from a version before WordPress 2.5, then you * should add the constant to your wp-config.php file. * * Below is an example of how the SECRET_KEY constant is defined with a value. * You must not copy the below example and paste into your wp-config.php. If you * need an example, then you can have a * {@link https://api.wordpress.org/secret-key/1.1/ secret key created} for you. * * <code> * define('SECRET_KEY', 'mAry1HadA15|\/|b17w55w1t3asSn09w'); * </code> * * Salting passwords helps against tools which has stored hashed values of * common dictionary strings. The added values makes it harder to crack if given * salt string is not weak. * * @since 2.5 * @link https://api.wordpress.org/secret-key/1.1/ Create a Secret Key for wp-config.php * * @param string $scheme Authentication scheme * @return string Salt value */function wp_salt($scheme = 'auth') {	global $wp_default_secret_key;	$secret_key = '';	if ( defined('SECRET_KEY') && ('' != SECRET_KEY) && ( $wp_default_secret_key != SECRET_KEY) )		$secret_key = SECRET_KEY;	if ( 'auth' == $scheme ) {		if ( defined('AUTH_KEY') && ('' != AUTH_KEY) && ( $wp_default_secret_key != AUTH_KEY) )			$secret_key = AUTH_KEY;		if ( defined('AUTH_SALT') && ('' != AUTH_SALT) && ( $wp_default_secret_key != AUTH_SALT) ) {			$salt = AUTH_SALT;		} elseif ( defined('SECRET_SALT') && ('' != SECRET_SALT) && ( $wp_default_secret_key != SECRET_SALT) ) {			$salt = SECRET_SALT;		} else {			$salt = get_site_option('auth_salt');			if ( empty($salt) ) {				$salt = wp_generate_password( 64, true, true );				update_site_option('auth_salt', $salt);			}		}	} elseif ( 'secure_auth' == $scheme ) {		if ( defined('SECURE_AUTH_KEY') && ('' != SECURE_AUTH_KEY) && ( $wp_default_secret_key != SECURE_AUTH_KEY) )			$secret_key = SECURE_AUTH_KEY;		if ( defined('SECURE_AUTH_SALT') && ('' != SECURE_AUTH_SALT) && ( $wp_default_secret_key != SECURE_AUTH_SALT) ) {			$salt = SECURE_AUTH_SALT;		} else {			$salt = get_site_option('secure_auth_salt');			if ( empty($salt) ) {				$salt = wp_generate_password( 64, true, true );				update_site_option('secure_auth_salt', $salt);			}		}	} elseif ( 'logged_in' == $scheme ) {		if ( defined('LOGGED_IN_KEY') && ('' != LOGGED_IN_KEY) && ( $wp_default_secret_key != LOGGED_IN_KEY) )			$secret_key = LOGGED_IN_KEY;		if ( defined('LOGGED_IN_SALT') && ('' != LOGGED_IN_SALT) && ( $wp_default_secret_key != LOGGED_IN_SALT) ) {			$salt = LOGGED_IN_SALT;		} else {			$salt = get_site_option('logged_in_salt');			if ( empty($salt) ) {				$salt = wp_generate_password( 64, true, true );				update_site_option('logged_in_salt', $salt);			}		}	} elseif ( 'nonce' == $scheme ) {		if ( defined('NONCE_KEY') && ('' != NONCE_KEY) && ( $wp_default_secret_key != NONCE_KEY) )			$secret_key = NONCE_KEY;		if ( defined('NONCE_SALT') && ('' != NONCE_SALT) && ( $wp_default_secret_key != NONCE_SALT) ) {			$salt = NONCE_SALT;		} else {			$salt = get_site_option('nonce_salt');			if ( empty($salt) ) {				$salt = wp_generate_password( 64, true, true );				update_site_option('nonce_salt', $salt);			}		}	} else {		// ensure each auth scheme has its own unique salt		$salt = hash_hmac('md5', $scheme, $secret_key);	}	return apply_filters('salt', $secret_key . $salt, $scheme);}endif;if ( !function_exists('wp_hash') ) :/** * Get hash of given string. * * @since 2.0.3 * @uses wp_salt() Get WordPress salt * * @param string $data Plain text to hash * @return string Hash of $data */function wp_hash($data, $scheme = 'auth') {	$salt = wp_salt($scheme);	return hash_hmac('md5', $data, $salt);}endif;if ( !function_exists('wp_hash_password') ) :/** * Create a hash (encrypt) of a plain text password. * * For integration with other applications, this function can be overwritten to * instead use the other package password checking algorithm. * * @since 2.5 * @global object $wp_hasher PHPass object * @uses PasswordHash::HashPassword * * @param string $password Plain text user password to hash * @return string The hash string of the password */function wp_hash_password($password) {	global $wp_hasher;	if ( empty($wp_hasher) ) {		require_once( ABSPATH . 'wp-includes/class-phpass.php');		// By default, use the portable hash from phpass		$wp_hasher = new PasswordHash(8, TRUE);	}	return $wp_hasher->HashPassword($password);}endif;if ( !function_exists('wp_check_password') ) :/** * Checks the plaintext password against the encrypted Password. * * Maintains compatibility between old version and the new cookie authentication * protocol using PHPass library. The $hash parameter is the encrypted password * and the function compares the plain text password when encypted similarly * against the already encrypted password to see if they match. * * For integration with other applications, this function can be overwritten to * instead use the other package password checking algorithm. * * @since 2.5 * @global object $wp_hasher PHPass object used for checking the password *	against the $hash + $password * @uses PasswordHash::CheckPassword * * @param string $password Plaintext user's password * @param string $hash Hash of the user's password to check against. * @return bool False, if the $password does not match the hashed password */function wp_check_password($password, $hash, $user_id = '') {	global $wp_hasher;	// If the hash is still md5...	if ( strlen($hash) <= 32 ) {		$check = ( $hash == md5($password) );		if ( $check && $user_id ) {			// Rehash using new hash.			wp_set_password($password, $user_id);			$hash = wp_hash_password($password);		}		return apply_filters('check_password', $check, $password, $hash, $user_id);	}	// If the stored hash is longer than an MD5, presume the	// new style phpass portable hash.	if ( empty($wp_hasher) ) {		require_once( ABSPATH . 'wp-includes/class-phpass.php');		// By default, use the portable hash from phpass		$wp_hasher = new PasswordHash(8, TRUE);	}	$check = $wp_hasher->CheckPassword($password, $hash);	return apply_filters('check_password', $check, $password, $hash, $user_id);}endif;if ( !function_exists('wp_generate_password') ) :/** * Generates a random password drawn from the defined set of characters. * * @since 2.5 * * @param int $length The length of password to generate * @param bool $special_chars Whether to include standard special characters. Default true. * @param bool $extra_special_chars Whether to include other special characters. Used when *   generating secret keys and salts. Default false. * @return string The random password **/function wp_generate_password( $length = 12, $special_chars = true, $extra_special_chars = false ) {	$chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';	if ( $special_chars )		$chars .= '!@#$%^&*()';	if ( $extra_special_chars )		$chars .= '-_ []{}<>~`+=,.;:/?|';	$password = '';	for ( $i = 0; $i < $length; $i++ ) {		$password .= substr($chars, wp_rand(0, strlen($chars) - 1), 1);	}	// random_password filter was previously in random_password function which was deprecated	return apply_filters('random_password', $password);}endif;if ( !function_exists('wp_rand') ) : /** * Generates a random number * * @since 2.6.2 * * @param int $min Lower limit for the generated number (optional, default is 0) * @param int $max Upper limit for the generated number (optional, default is 4294967295) * @return int A random number between min and max */function wp_rand( $min = 0, $max = 0 ) {	global $rnd_value;	// Reset $rnd_value after 14 uses	// 32(md5) + 40(sha1) + 40(sha1) / 8 = 14 random numbers from $rnd_value	if ( strlen($rnd_value) < 8 ) {		if ( defined( 'WP_SETUP_CONFIG' ) )			static $seed = '';		else			$seed = get_transient('random_seed');		$rnd_value = md5( uniqid(microtime() . mt_rand(), true ) . $seed );		$rnd_value .= sha1($rnd_value);		$rnd_value .= sha1($rnd_value . $seed);		$seed = md5($seed . $rnd_value);		if ( ! defined( 'WP_SETUP_CONFIG' ) )			set_transient('random_seed', $seed);	}	// Take the first 8 digits for our value	$value = substr($rnd_value, 0, 8);	// Strip the first eight, leaving the remainder for the next call to wp_rand().	$rnd_value = substr($rnd_value, 8);	$value = abs(hexdec($value));	// Reduce the value to be within the min - max range	// 4294967295 = 0xffffffff = max random number	if ( $max != 0 )		$value = $min + (($max - $min + 1) * ($value / (4294967295 + 1)));	return abs(intval($value));}endif;if ( !function_exists('wp_set_password') ) :/** * Updates the user's password with a new encrypted one. * * For integration with other applications, this function can be overwritten to * instead use the other package password checking algorithm. * * @since 2.5 * @uses $wpdb WordPress database object for queries * @uses wp_hash_password() Used to encrypt the user's password before passing to the database * * @param string $password The plaintext new user password * @param int $user_id User ID */function wp_set_password( $password, $user_id ) {	global $wpdb;	$hash = wp_hash_password($password);	$wpdb->update($wpdb->users, array('user_pass' => $hash, 'user_activation_key' => ''), array('ID' => $user_id) );	wp_cache_delete($user_id, 'users');}endif;if ( !function_exists( 'get_avatar' ) ) :/** * Retrieve the avatar for a user who provided a user ID or email address. * * @since 2.5 * @param int|string|object $id_or_email A user ID,  email address, or comment object * @param int $size Size of the avatar image * @param string $default URL to a default image to use if no avatar is available * @param string $alt Alternate text to use in image tag. Defaults to blank * @return string <img> tag for the user's avatar*/function get_avatar( $id_or_email, $size = '96', $default = '', $alt = false ) {	if ( ! get_option('show_avatars') )		return false;	if ( false === $alt)		$safe_alt = '';	else		$safe_alt = esc_attr( $alt );	if ( !is_numeric($size) )		$size = '96';	$email = '';	if ( is_numeric($id_or_email) ) {		$id = (int) $id_or_email;		$user = get_userdata($id);		if ( $user )			$email = $user->user_email;	} elseif ( is_object($id_or_email) ) {		// No avatar for pingbacks or trackbacks		$allowed_comment_types = apply_filters( 'get_avatar_comment_types', array( 'comment' ) );		if ( ! empty( $id_or_email->comment_type ) && ! in_array( $id_or_email->comment_type, (array) $allowed_comment_types ) )			return false;		if ( !empty($id_or_email->user_id) ) {			$id = (int) $id_or_email->user_id;			$user = get_userdata($id);			if ( $user)				$email = $user->user_email;		} elseif ( !empty($id_or_email->comment_author_email) ) {			$email = $id_or_email->comment_author_email;		}	} else {		$email = $id_or_email;	}	if ( empty($default) ) {		$avatar_default = get_option('avatar_default');		if ( empty($avatar_default) )			$default = 'mystery';		else			$default = $avatar_default;	}	if ( !empty($email) )		$email_hash = md5( strtolower( $email ) );	if ( is_ssl() ) {		$host = 'https://secure.gravatar.com';	} else {		if ( !empty($email) )			$host = sprintf( "http://%d.gravatar.com", ( hexdec( $email_hash{0} ) % 2 ) );		else			$host = 'http://0.gravatar.com';	}	if ( 'mystery' == $default )		$default = "$host/avatar/ad516503a11cd5ca435acc9bb6523536?s={$size}"; // ad516503a11cd5ca435acc9bb6523536 == md5('unknown@gravatar.com')	elseif ( 'blank' == $default )		$default = includes_url('images/blank.gif');	elseif ( !empty($email) && 'gravatar_default' == $default )		$default = '';	elseif ( 'gravatar_default' == $default )		$default = "$host/avatar/s={$size}";	elseif ( empty($email) )		$default = "$host/avatar/?d=$default&amp;s={$size}";	elseif ( strpos($default, 'http://') === 0 )		$default = add_query_arg( 's', $size, $default );	if ( !empty($email) ) {		$out = "$host/avatar/";		$out .= $email_hash;		$out .= '?s='.$size;		$out .= '&amp;d=' . urlencode( $default );		$rating = get_option('avatar_rating');		if ( !empty( $rating ) )			$out .= "&amp;r={$rating}";		$avatar = "<img alt='{$safe_alt}' src='{$out}' class='avatar avatar-{$size} photo' height='{$size}' width='{$size}' />";	} else {		$avatar = "<img alt='{$safe_alt}' src='{$default}' class='avatar avatar-{$size} photo avatar-default' height='{$size}' width='{$size}' />";	}	return apply_filters('get_avatar', $avatar, $id_or_email, $size, $default, $alt);}endif;if ( !function_exists( 'wp_text_diff' ) ) :/** * Displays a human readable HTML representation of the difference between two strings. * * The Diff is available for getting the changes between versions. The output is * HTML, so the primary use is for displaying the changes. If the two strings * are equivalent, then an empty string will be returned. * * The arguments supported and can be changed are listed below. * * 'title' : Default is an empty string. Titles the diff in a manner compatible *		with the output. * 'title_left' : Default is an empty string. Change the HTML to the left of the *		title. * 'title_right' : Default is an empty string. Change the HTML to the right of *		the title. * * @since 2.6 * @see wp_parse_args() Used to change defaults to user defined settings. * @uses Text_Diff * @uses WP_Text_Diff_Renderer_Table * * @param string $left_string "old" (left) version of string * @param string $right_string "new" (right) version of string * @param string|array $args Optional. Change 'title', 'title_left', and 'title_right' defaults. * @return string Empty string if strings are equivalent or HTML with differences. */function wp_text_diff( $left_string, $right_string, $args = null ) {	$defaults = array( 'title' => '', 'title_left' => '', 'title_right' => '' );	$args = wp_parse_args( $args, $defaults );	if ( !class_exists( 'WP_Text_Diff_Renderer_Table' ) )		require( ABSPATH . WPINC . '/wp-diff.php' );	$left_string  = normalize_whitespace($left_string);	$right_string = normalize_whitespace($right_string);	$left_lines  = split("\n", $left_string);	$right_lines = split("\n", $right_string);	$text_diff = new Text_Diff($left_lines, $right_lines);	$renderer  = new WP_Text_Diff_Renderer_Table();	$diff = $renderer->render($text_diff);	if ( !$diff )		return '';	$r  = "<table class='diff'>\n";	$r .= "<col class='ltype' /><col class='content' /><col class='ltype' /><col class='content' />";	if ( $args['title'] || $args['title_left'] || $args['title_right'] )		$r .= "<thead>";	if ( $args['title'] )		$r .= "<tr class='diff-title'><th colspan='4'>$args[title]</th></tr>\n";	if ( $args['title_left'] || $args['title_right'] ) {		$r .= "<tr class='diff-sub-title'>\n";		$r .= "\t<td></td><th>$args[title_left]</th>\n";		$r .= "\t<td></td><th>$args[title_right]</th>\n";		$r .= "</tr>\n";	}	if ( $args['title'] || $args['title_left'] || $args['title_right'] )		$r .= "</thead>\n";	$r .= "<tbody>\n$diff\n</tbody>\n";	$r .= "</table>";	return $r;}endif;
<?php/** * Comment Moderation Administration Panel. * * Redirects to edit-comments.php?comment_status=moderated. * * @package WordPress * @subpackage Administration */require_once('../wp-load.php');wp_redirect('edit-comments.php?comment_status=moderated');?>
<?php/** * BackPress styles procedural API. * * @package BackPress * @since r79 *//** * Display styles that are in the queue or part of $handles. * * @since r79 * @uses do_action() Calls 'wp_print_styles' hook. * @global object $wp_styles The WP_Styles object for printing styles. * * @param array|bool $handles Styles to be printed. An empty array prints the queue, *  an array with one string prints that style, and an array of strings prints those styles. * @return bool True on success, false on failure. */function wp_print_styles( $handles = false ) {	do_action( 'wp_print_styles' );	if ( '' === $handles ) // for wp_head		$handles = false;	global $wp_styles;	if ( !is_a($wp_styles, 'WP_Styles') ) {		if ( !$handles )			return array(); // No need to instantiate if nothing's there.		else			$wp_styles = new WP_Styles();	}	return $wp_styles->do_items( $handles );}/** * Register CSS style file. * * @since r79 * @see WP_Styles::add() For additional information. * @global object $wp_styles The WP_Styles object for printing styles. * @link http://www.w3.org/TR/CSS2/media.html#media-types List of CSS media types. * * @param string $handle Name of the stylesheet. * @param string|bool $src Path to the stylesheet from the root directory of WordPress. Example: '/css/mystyle.css'. * @param array $deps Array of handles of any stylesheet that this stylesheet depends on. *  (Stylesheets that must be loaded before this stylesheet.) Pass an empty array if there are no dependencies. * @param string|bool $ver String specifying the stylesheet version number. Set to NULL to disable. *  Used to ensure that the correct version is sent to the client regardless of caching. * @param string $media The media for which this stylesheet has been defined. */function wp_register_style( $handle, $src, $deps = array(), $ver = false, $media = 'all' ) {	global $wp_styles;	if ( !is_a($wp_styles, 'WP_Styles') )		$wp_styles = new WP_Styles();	$wp_styles->add( $handle, $src, $deps, $ver, $media );}/** * Remove a registered CSS file. * * @since r79 * @see WP_Styles::remove() For additional information. * @global object $wp_styles The WP_Styles object for printing styles. * * @param string $handle Name of the stylesheet. */function wp_deregister_style( $handle ) {	global $wp_styles;	if ( !is_a($wp_styles, 'WP_Styles') )		$wp_styles = new WP_Styles();	$wp_styles->remove( $handle );}/** * Enqueue a CSS style file. * * Registers the style if src provided (does NOT overwrite) and enqueues. * * @since r79 * @see WP_Styles::add(), WP_Styles::enqueue() * @global object $wp_styles The WP_Styles object for printing styles. * @link http://www.w3.org/TR/CSS2/media.html#media-types List of CSS media types. * * @param string $handle Name of the stylesheet. * @param string|bool $src Path to the stylesheet from the root directory of WordPress. Example: '/css/mystyle.css'. * @param array $deps Array of handles (names) of any stylesheet that this stylesheet depends on. *  (Stylesheets that must be loaded before this stylesheet.) Pass an empty array if there are no dependencies. * @param string|bool $ver String specifying the stylesheet version number, if it has one. This parameter *  is used to ensure that the correct version is sent to the client regardless of caching, and so should be included *  if a version number is available and makes sense for the stylesheet. * @param string $media The media for which this stylesheet has been defined. */function wp_enqueue_style( $handle, $src = false, $deps = array(), $ver = false, $media = 'all' ) {	global $wp_styles;	if ( !is_a($wp_styles, 'WP_Styles') )		$wp_styles = new WP_Styles();	if ( $src ) {		$_handle = explode('?', $handle);		$wp_styles->add( $_handle[0], $src, $deps, $ver, $media );	}	$wp_styles->enqueue( $handle );}/** * Check whether style has been added to WordPress Styles. * * The values for list defaults to 'queue', which is the same as wp_enqueue_style(). * * @since WP unknown; BP unknown * @global object $wp_styles The WP_Styles object for printing styles. * * @param string $handle Name of the stylesheet. * @param string $list Values are 'registered', 'done', 'queue' and 'to_do'. * @return bool True on success, false on failure. */function wp_style_is( $handle, $list = 'queue' ) {	global $wp_styles;	if ( !is_a($wp_styles, 'WP_Styles') )		$wp_styles = new WP_Styles();	$query = $wp_styles->query( $handle, $list );	if ( is_object( $query ) )		return true;	return $query;}
<?php/** * Quick way to create a WordPress Post. * * @package WordPress * @subpackage Administration *//** * @var string * @name $mode */$mode = 'sidebar';/** WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can('edit_posts') )	wp_die(__('Cheatin&#8217; uh?'));$post = get_default_post_to_edit();?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="<?php bloginfo('html_type'); ?>; charset=<?php bloginfo('blog_charset'); ?>" /><title><?php bloginfo('name') ?> &rsaquo; <?php _e('Sidebar'); ?></title><style type="text/css" media="screen">body {	font-size: 0.9em;	margin: 0;	padding: 0;}form {	padding: 1%;}.tags-wrap p {	font-size: 0.75em;	margin-top: 0.4em;}.button-highlighted, #wphead, label {	font-weight: bold;}#post-title, #tags-input, #content {	width: 99%;	padding: 2px;}#wphead {	font-size: 1.4em;	background-color: #E4F2FD;	color: #555555;	padding: 0.2em 1%;}#wphead p {	margin: 3px;}.button {	font-family: "Lucida Grande", "Lucida Sans Unicode", Tahoma, Verdana, sans-serif;	padding: 3px 5px;	margin-right: 5px;	font-size: 0.75em;	line-height: 1.5em;	border: 1px solid #80b5d0;	-moz-border-radius: 3px;	-khtml-border-radius: 3px;	-webkit-border-radius: 3px;	border-radius: 3px;	cursor: pointer;	background-color: #e5e5e5;	color: #246;}.button:hover {	border-color: #535353;}.updated {	background-color: #FFFBCC;	border: 1px solid #E6DB55;	margin-bottom: 1em;	padding: 0 0.6em;}.updated p {	margin: 0.6em;}</style></head><body id="sidebar"><div id="wphead"><p><?php bloginfo('name') ?> &rsaquo; <?php _e('Sidebar'); ?></p></div><form name="post" action="post.php" method="post"><div><input type="hidden" name="action" value="post" /><input type="hidden" name="user_ID" value="<?php echo esc_attr($user_ID) ?>" /><input type="hidden" name="mode" value="sidebar" /><input type="hidden" name="ping_status" value="<?php echo esc_attr($post->ping_status); ?>" /><input type="hidden" name="comment_status" value="<?php echo esc_attr($post->comment_status); ?>" /><?php wp_nonce_field('add-post');if ( 'b' == $_GET['a'] )	echo '<div class="updated"><p>' . __('Post published.') . '</p></div>';elseif ( 'c' == $_GET['a'] )	echo '<div class="updated"><p>' . __('Post saved.') . '</p></div>';?><p><label for="post-title"><?php _e('Title:'); ?></label><input type="text" name="post_title" id="post-title" size="20" tabindex="1" autocomplete="off" value="" /></p><p><label for="content"><?php _e('Post:'); ?></label><textarea rows="8" cols="12" name="content" id="content" style="height:10em;line-height:1.4em;" tabindex="2"></textarea></p><div class="tags-wrap"><label for="tags-input"><?php _e('Tags:') ?></label><input type="text" name="tags_input" id="tags-input" tabindex="3" value="" /><p><?php _e('Separate tags with commas'); ?></p></div><p><input name="saveasdraft" type="submit" id="saveasdraft" tabindex="9" accesskey="s" class="button" value="<?php esc_attr_e('Save as Draft'); ?>" /><?php if ( current_user_can('publish_posts') ) : ?><input name="publish" type="submit" id="publish" tabindex="6" accesskey="p" value="<?php esc_attr_e('Publish') ?>" class="button button-highlighted" /><?php endif; ?></p></div></form></body></html>
<?php/** * Bookmark Template Functions for usage in Themes * * @package WordPress * @subpackage Template *//** * The formatted output of a list of bookmarks. * * The $bookmarks array must contain bookmark objects and will be iterated over * to retrieve the bookmark to be used in the output. * * The output is formatted as HTML with no way to change that format. However, * what is between, before, and after can be changed. The link itself will be * HTML. * * This function is used internally by wp_list_bookmarks() and should not be * used by themes. * * The defaults for overwriting are: * 'show_updated' - Default is 0 (integer). Will show the time of when the *		bookmark was last updated. * 'show_description' - Default is 0 (integer). Whether to show the description *		of the bookmark. * 'show_images' - Default is 1 (integer). Whether to show link image if *		available. * 'show_name' - Default is 0 (integer). Whether to show link name if *		available. * 'before' - Default is '<li>' (string). The html or text to prepend to each *		bookmarks. * 'after' - Default is '</li>' (string). The html or text to append to each *		bookmarks. * 'link_before' - Default is '' (string). The html or text to prepend to each *		bookmarks inside the <a> tag. * 'link_after' - Default is '' (string). The html or text to append to each *		bookmarks inside the <a> tag. * 'between' - Default is '\n' (string). The string for use in between the link, *		description, and image. * 'show_rating' - Default is 0 (integer). Whether to show the link rating. * * @since 2.1.0 * @access private * @usedby wp_list_bookmarks() * * @param array $bookmarks List of bookmarks to traverse * @param string|array $args Optional. Overwrite the defaults. * @return string Formatted output in HTML */function _walk_bookmarks($bookmarks, $args = '' ) {	$defaults = array(		'show_updated' => 0, 'show_description' => 0,		'show_images' => 1, 'show_name' => 0,		'before' => '<li>', 'after' => '</li>', 'between' => "\n",		'show_rating' => 0, 'link_before' => '', 'link_after' => ''	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	$output = ''; // Blank string to start with.	foreach ( (array) $bookmarks as $bookmark ) {		if ( !isset($bookmark->recently_updated) )			$bookmark->recently_updated = false;		$output .= $before;		if ( $show_updated && $bookmark->recently_updated )			$output .= get_option('links_recently_updated_prepend');		$the_link = '#';		if ( !empty($bookmark->link_url) )			$the_link = esc_url($bookmark->link_url);		$desc = esc_attr(sanitize_bookmark_field('link_description', $bookmark->link_description, $bookmark->link_id, 'display'));		$name = esc_attr(sanitize_bookmark_field('link_name', $bookmark->link_name, $bookmark->link_id, 'display')); 		$title = $desc;		if ( $show_updated )			if ( '00' != substr($bookmark->link_updated_f, 0, 2) ) {				$title .= ' (';				$title .= sprintf(__('Last updated: %s'), date(get_option('links_updated_date_format'), $bookmark->link_updated_f + (get_option('gmt_offset') * 3600)));				$title .= ')';			}		$alt = ' alt="' . $name . ( $show_description ? ' ' . $title : '' ) . '"';		if ( '' != $title )			$title = ' title="' . $title . '"';		$rel = $bookmark->link_rel;		if ( '' != $rel )			$rel = ' rel="' . esc_attr($rel) . '"';		$target = $bookmark->link_target;		if ( '' != $target )			$target = ' target="' . $target . '"';		$output .= '<a href="' . $the_link . '"' . $rel . $title . $target . '>';		$output .= $link_before;		if ( $bookmark->link_image != null && $show_images ) {			if ( strpos($bookmark->link_image, 'http') === 0 )				$output .= "<img src=\"$bookmark->link_image\" $alt $title />";			else // If it's a relative path				$output .= "<img src=\"" . get_option('siteurl') . "$bookmark->link_image\" $alt $title />";			if ( $show_name )				$output .= " $name";		} else {			$output .= $name;		}		$output .= $link_after;		$output .= '</a>';		if ( $show_updated && $bookmark->recently_updated )			$output .= get_option('links_recently_updated_append');		if ( $show_description && '' != $desc )			$output .= $between . $desc;		if ( $show_rating )			$output .= $between . sanitize_bookmark_field('link_rating', $bookmark->link_rating, $bookmark->link_id, 'display');		$output .= "$after\n";	} // end while	return $output;}/** * Retrieve or echo all of the bookmarks. * * List of default arguments are as follows: * 'orderby' - Default is 'name' (string). How to order the links by. String is *		based off of the bookmark scheme. * 'order' - Default is 'ASC' (string). Either 'ASC' or 'DESC'. Orders in either *		ascending or descending order. * 'limit' - Default is -1 (integer) or show all. The amount of bookmarks to *		display. * 'category' - Default is empty string (string). Include the links in what *		category ID(s). * 'category_name' - Default is empty string (string). Get links by category *		name. * 'hide_invisible' - Default is 1 (integer). Whether to show (default) or hide *		links marked as 'invisible'. * 'show_updated' - Default is 0 (integer). Will show the time of when the *		bookmark was last updated. * 'echo' - Default is 1 (integer). Whether to echo (default) or return the *		formatted bookmarks. * 'categorize' - Default is 1 (integer). Whether to show links listed by *		category (default) or show links in one column. * 'show_description' - Default is 0 (integer). Whether to show the description *		of the bookmark. * * These options define how the Category name will appear before the category * links are displayed, if 'categorize' is 1. If 'categorize' is 0, then it will * display for only the 'title_li' string and only if 'title_li' is not empty. * 'title_li' - Default is 'Bookmarks' (translatable string). What to show *		before the links appear. * 'title_before' - Default is '<h2>' (string). The HTML or text to show before *		the 'title_li' string. * 'title_after' - Default is '</h2>' (string). The HTML or text to show after *		the 'title_li' string. * 'class' - Default is 'linkcat' (string). The CSS class to use for the *		'title_li'. * * 'category_before' - Default is '<li id="%id" class="%class">'. String must *		contain '%id' and '%class' to get * the id of the category and the 'class' argument. These are used for *		formatting in themes. * Argument will be displayed before the 'title_before' argument. * 'category_after' - Default is '</li>' (string). The HTML or text that will *		appear after the list of links. * * These are only used if 'categorize' is set to 1 or true. * 'category_orderby' - Default is 'name'. How to order the bookmark category *		based on term scheme. * 'category_order' - Default is 'ASC'. Set the order by either ASC (ascending) *		or DESC (descending). * * @see _walk_bookmarks() For other arguments that can be set in this function *		and passed to _walk_bookmarks(). * @see get_bookmarks() For other arguments that can be set in this function and *		passed to get_bookmarks(). * @link http://codex.wordpress.org/Template_Tags/wp_list_bookmarks * * @since 2.1.0 * @uses _list_bookmarks() Used to iterate over all of the bookmarks and return *		the html * @uses get_terms() Gets all of the categories that are for links. * * @param string|array $args Optional. Overwrite the defaults of the function * @return string|null Will only return if echo option is set to not echo. *		Default is not return anything. */function wp_list_bookmarks($args = '') {	$defaults = array(		'orderby' => 'name', 'order' => 'ASC',		'limit' => -1, 'category' => '', 'exclude_category' => '',		'category_name' => '', 'hide_invisible' => 1,		'show_updated' => 0, 'echo' => 1,		'categorize' => 1, 'title_li' => __('Bookmarks'),		'title_before' => '<h2>', 'title_after' => '</h2>',		'category_orderby' => 'name', 'category_order' => 'ASC',		'class' => 'linkcat', 'category_before' => '<li id="%id" class="%class">',		'category_after' => '</li>'	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	$output = '';	if ( $categorize ) {		//Split the bookmarks into ul's for each category		$cats = get_terms('link_category', array('name__like' => $category_name, 'include' => $category, 'exclude' => $exclude_category, 'orderby' => $category_orderby, 'order' => $category_order, 'hierarchical' => 0));		foreach ( (array) $cats as $cat ) {			$params = array_merge($r, array('category'=>$cat->term_id));			$bookmarks = get_bookmarks($params);			if ( empty($bookmarks) )				continue;			$output .= str_replace(array('%id', '%class'), array("linkcat-$cat->term_id", $class), $category_before);			$catname = apply_filters( "link_category", $cat->name );			$output .= "$title_before$catname$title_after\n\t<ul class='xoxo blogroll'>\n";			$output .= _walk_bookmarks($bookmarks, $r);			$output .= "\n\t</ul>\n$category_after\n";		}	} else {		//output one single list using title_li for the title		$bookmarks = get_bookmarks($r);		if ( !empty($bookmarks) ) {			if ( !empty( $title_li ) ){				$output .= str_replace(array('%id', '%class'), array("linkcat-$category", $class), $category_before);				$output .= "$title_before$title_li$title_after\n\t<ul class='xoxo blogroll'>\n";				$output .= _walk_bookmarks($bookmarks, $r);				$output .= "\n\t</ul>\n$category_after\n";			} else {				$output .= _walk_bookmarks($bookmarks, $r);			}		}	}	$output = apply_filters( 'wp_list_bookmarks', $output );	if ( !$echo )		return $output;	echo $output;}?>
<?php/** * The template for displaying 404 pages (Not Found). * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>	<div id="container">		<div id="content" role="main">			<div id="post-0" class="post error404 not-found">				<h1 class="entry-title"><?php _e( 'Not Found', 'twentyten' ); ?></h1>				<div class="entry-content">					<p><?php _e( 'Apologies, but the page you requested could not be found. Perhaps searching will help.', 'twentyten' ); ?></p>					<?php get_search_form(); ?>				</div><!-- .entry-content -->			</div><!-- #post-0 -->		</div><!-- #content -->	</div><!-- #container -->	<script type="text/javascript">		// focus on search field after it has loaded		document.getElementById('s') && document.getElementById('s').focus();	</script><?php get_footer(); ?>
<?phpfunction mce_put_file( $path, $content ) {	if ( function_exists('file_put_contents') )		return @file_put_contents( $path, $content );	$newfile = false;	$fp = @fopen( $path, 'wb' );	if ($fp) {		$newfile = fwrite( $fp, $content );		fclose($fp);	}	return $newfile;}// escape text only if it needs translatingfunction mce_escape($text) {	global $language;	if ( 'en' == $language ) return $text;	else return esc_js($text);}$lang = 'tinyMCE.addI18n({' . $language . ':{common:{edit_confirm:"' . mce_escape( __('Do you want to use the WYSIWYG mode for this textarea?') ) . '",apply:"' . mce_escape( __('Apply') ) . '",insert:"' . mce_escape( __('Insert') ) . '",update:"' . mce_escape( __('Update') ) . '",cancel:"' . mce_escape( __('Cancel') ) . '",close:"' . mce_escape( __('Close') ) . '",browse:"' . mce_escape( __('Browse') ) . '",class_name:"' . mce_escape( __('Class') ) . '",not_set:"' . mce_escape( __('-- Not set --') ) . '",clipboard_msg:"' . mce_escape( __('Copy/Cut/Paste is not available in Mozilla and Firefox.') ) . '",clipboard_no_support:"' . mce_escape( __('Currently not supported by your browser, use keyboard shortcuts instead.') ) . '",popup_blocked:"' . mce_escape( __('Sorry, but we have noticed that your popup-blocker has disabled a window that provides application functionality. You will need to disable popup blocking on this site in order to fully utilize this tool.') ) . '",invalid_data:"' . mce_escape( __('Error: Invalid values entered, these are marked in red.') ) . '",more_colors:"' . mce_escape( __('More colors') ) . '"},contextmenu:{align:"' . mce_escape( /* translators: alignment */ __('Alignment') ) . '",left:"' . mce_escape( /* translators: alignment */ __('Left') ) . '",center:"' . mce_escape( /* translators: alignment */ __('Center') ) . '",right:"' . mce_escape( /* translators: alignment */ __('Right') ) . '",full:"' . mce_escape( /* translators: alignment */ __('Full') ) . '"},insertdatetime:{date_fmt:"' . mce_escape( /* translators: year, month, date */ __('%Y-%m-%d') ) . '",time_fmt:"' . mce_escape( /* translators: hours, minutes, seconds */ __('%H:%M:%S') ) . '",insertdate_desc:"' . mce_escape( __('Insert date') ) . '",inserttime_desc:"' . mce_escape( __('Insert time') ) . '",months_long:"' . mce_escape( __('January').','.__('February').','.__('March').','.__('April').','.__('May').','.__('June').','.__('July').','.__('August').','.__('September').','.__('October').','.__('November').','.__('December') ) . '",months_short:"' . mce_escape( __('Jan_January_abbreviation').','.__('Feb_February_abbreviation').','.__('Mar_March_abbreviation').','.__('Apr_April_abbreviation').','.__('May_May_abbreviation').','.__('Jun_June_abbreviation').','.__('Jul_July_abbreviation').','.__('Aug_August_abbreviation').','.__('Sep_September_abbreviation').','.__('Oct_October_abbreviation').','.__('Nov_November_abbreviation').','.__('Dec_December_abbreviation') ) . '",day_long:"' . mce_escape( __('Sunday').','.__('Monday').','.__('Tuesday').','.__('Wednesday').','.__('Thursday').','.__('Friday').','.__('Saturday') ) . '",day_short:"' . mce_escape( __('Sun').','.__('Mon').','.__('Tue').','.__('Wed').','.__('Thu').','.__('Fri').','.__('Sat') ) . '"},print:{print_desc:"' . mce_escape( __('Print') ) . '"},preview:{preview_desc:"' . mce_escape( __('Preview') ) . '"},directionality:{ltr_desc:"' . mce_escape( __('Direction left to right') ) . '",rtl_desc:"' . mce_escape( __('Direction right to left') ) . '"},layer:{insertlayer_desc:"' . mce_escape( __('Insert new layer') ) . '",forward_desc:"' . mce_escape( __('Move forward') ) . '",backward_desc:"' . mce_escape( __('Move backward') ) . '",absolute_desc:"' . mce_escape( __('Toggle absolute positioning') ) . '",content:"' . mce_escape( __('New layer...') ) . '"},save:{save_desc:"' . mce_escape( __('Save') ) . '",cancel_desc:"' . mce_escape( __('Cancel all changes') ) . '"},nonbreaking:{nonbreaking_desc:"' . mce_escape( __('Insert non-breaking space character') ) . '"},iespell:{iespell_desc:"' . mce_escape( __('Run spell checking') ) . '",download:"' . mce_escape( __('ieSpell not detected. Do you want to install it now?') ) . '"},advhr:{advhr_desc:"' . mce_escape( __('Horizontale rule') ) . '"},emotions:{emotions_desc:"' . mce_escape( __('Emotions') ) . '"},searchreplace:{search_desc:"' . mce_escape( __('Find') ) . '",replace_desc:"' . mce_escape( __('Find/Replace') ) . '"},advimage:{image_desc:"' . mce_escape( __('Insert/edit image') ) . '"},advlink:{link_desc:"' . mce_escape( __('Insert/edit link') ) . '"},xhtmlxtras:{cite_desc:"' . mce_escape( __('Citation') ) . '",abbr_desc:"' . mce_escape( __('Abbreviation') ) . '",acronym_desc:"' . mce_escape( __('Acronym') ) . '",del_desc:"' . mce_escape( __('Deletion') ) . '",ins_desc:"' . mce_escape( __('Insertion') ) . '",attribs_desc:"' . mce_escape( __('Insert/Edit Attributes') ) . '"},style:{desc:"' . mce_escape( __('Edit CSS Style') ) . '"},paste:{paste_text_desc:"' . mce_escape( __('Paste as Plain Text') ) . '",paste_word_desc:"' . mce_escape( __('Paste from Word') ) . '",selectall_desc:"' . mce_escape( __('Select All') ) . '"},paste_dlg:{text_title:"' . mce_escape( __('Use CTRL+V on your keyboard to paste the text into the window.') ) . '",text_linebreaks:"' . mce_escape( __('Keep linebreaks') ) . '",word_title:"' . mce_escape( __('Use CTRL+V on your keyboard to paste the text into the window.') ) . '"},table:{desc:"' . mce_escape( __('Inserts a new table') ) . '",row_before_desc:"' . mce_escape( __('Insert row before') ) . '",row_after_desc:"' . mce_escape( __('Insert row after') ) . '",delete_row_desc:"' . mce_escape( __('Delete row') ) . '",col_before_desc:"' . mce_escape( __('Insert column before') ) . '",col_after_desc:"' . mce_escape( __('Insert column after') ) . '",delete_col_desc:"' . mce_escape( __('Remove column') ) . '",split_cells_desc:"' . mce_escape( __('Split merged table cells') ) . '",merge_cells_desc:"' . mce_escape( __('Merge table cells') ) . '",row_desc:"' . mce_escape( __('Table row properties') ) . '",cell_desc:"' . mce_escape( __('Table cell properties') ) . '",props_desc:"' . mce_escape( __('Table properties') ) . '",paste_row_before_desc:"' . mce_escape( __('Paste table row before') ) . '",paste_row_after_desc:"' . mce_escape( __('Paste table row after') ) . '",cut_row_desc:"' . mce_escape( __('Cut table row') ) . '",copy_row_desc:"' . mce_escape( __('Copy table row') ) . '",del:"' . mce_escape( __('Delete table') ) . '",row:"' . mce_escape( __('Row') ) . '",col:"' . mce_escape( __('Column') ) . '",cell:"' . mce_escape( __('Cell') ) . '"},autosave:{unload_msg:"' . mce_escape( __('The changes you made will be lost if you navigate away from this page.') ) . '"},fullscreen:{desc:"' . mce_escape( __('Toggle fullscreen mode') ) . ' (Alt+Shift+G)"},media:{desc:"' . mce_escape( __('Insert / edit embedded media') ) . '",delta_width:"' . /* translators: Extra width for the media popup in pixels */ mce_escape( _x('0', 'media popup width') ) . '",delta_height:"' . /* translators: Extra height for the media popup in pixels */ mce_escape( _x('0', 'media popup height') ) . '",edit:"' . mce_escape( __('Edit embedded media') ) . '"},fullpage:{desc:"' . mce_escape( __('Document properties') ) . '"},template:{desc:"' . mce_escape( __('Insert predefined template content') ) . '"},visualchars:{desc:"' . mce_escape( __('Visual control characters on/off.') ) . '"},spellchecker:{desc:"' . mce_escape( __('Toggle spellchecker') ) . ' (Alt+Shift+N)",menu:"' . mce_escape( __('Spellchecker settings') ) . '",ignore_word:"' . mce_escape( __('Ignore word') ) . '",ignore_words:"' . mce_escape( __('Ignore all') ) . '",langs:"' . mce_escape( __('Languages') ) . '",wait:"' . mce_escape( __('Please wait...') ) . '",sug:"' . mce_escape( __('Suggestions') ) . '",no_sug:"' . mce_escape( __('No suggestions') ) . '",no_mpell:"' . mce_escape( __('No misspellings found.') ) . '"},pagebreak:{desc:"' . mce_escape( __('Insert Page Break') ) . '"}}});tinyMCE.addI18n("' . $language . '.advanced",{style_select:"' . mce_escape( /* translators: TinyMCE font styles */ _x('Styles', 'TinyMCE font styles') ) . '",font_size:"' . mce_escape( __('Font size') ) . '",fontdefault:"' . mce_escape( __('Font family') ) . '",block:"' . mce_escape( __('Format') ) . '",paragraph:"' . mce_escape( __('Paragraph') ) . '",div:"' . mce_escape( __('Div') ) . '",address:"' . mce_escape( __('Address') ) . '",pre:"' . mce_escape( __('Preformatted') ) . '",h1:"' . mce_escape( __('Heading 1') ) . '",h2:"' . mce_escape( __('Heading 2') ) . '",h3:"' . mce_escape( __('Heading 3') ) . '",h4:"' . mce_escape( __('Heading 4') ) . '",h5:"' . mce_escape( __('Heading 5') ) . '",h6:"' . mce_escape( __('Heading 6') ) . '",blockquote:"' . mce_escape( __('Blockquote') ) . '",code:"' . mce_escape( __('Code') ) . '",samp:"' . mce_escape( __('Code sample') ) . '",dt:"' . mce_escape( __('Definition term ') ) . '",dd:"' . mce_escape( __('Definition description') ) . '",bold_desc:"' . mce_escape( __('Bold') ) . ' (Ctrl / Alt+Shift + B)",italic_desc:"' . mce_escape( __('Italic') ) . ' (Ctrl / Alt+Shift + I)",underline_desc:"' . mce_escape( __('Underline') ) . '",striketrough_desc:"' . mce_escape( __('Strikethrough') ) . ' (Alt+Shift+D)",justifyleft_desc:"' . mce_escape( __('Align Left') ) . ' (Alt+Shift+L)",justifycenter_desc:"' . mce_escape( __('Align Center') ) . ' (Alt+Shift+C)",justifyright_desc:"' . mce_escape( __('Align Right') ) . ' (Alt+Shift+R)",justifyfull_desc:"' . mce_escape( __('Align Full') ) . ' (Alt+Shift+J)",bullist_desc:"' . mce_escape( __('Unordered list') ) . ' (Alt+Shift+U)",numlist_desc:"' . mce_escape( __('Ordered list') ) . ' (Alt+Shift+O)",outdent_desc:"' . mce_escape( __('Outdent') ) . '",indent_desc:"' . mce_escape( __('Indent') ) . '",undo_desc:"' . mce_escape( __('Undo') ) . ' (Ctrl+Z)",redo_desc:"' . mce_escape( __('Redo') ) . ' (Ctrl+Y)",link_desc:"' . mce_escape( __('Insert/edit link') ) . ' (Alt+Shift+A)",link_delta_width:"' . /* translators: Extra width for the link popup in pixels */ mce_escape( _x('0', 'link popup width') ) . '",link_delta_height:"' . /* translators: Extra height for the link popup in pixels */ mce_escape( _x('0', 'link popup height') ) . '",unlink_desc:"' . mce_escape( __('Unlink') ) . ' (Alt+Shift+S)",image_desc:"' . mce_escape( __('Insert/edit image') ) . ' (Alt+Shift+M)",image_delta_width:"' . /* translators: Extra width for the image popup in pixels */ mce_escape( _x('0', 'image popup width') ) . '",image_delta_height:"' . /* translators: Extra height for the image popup in pixels */ mce_escape( _x('0', 'image popup height') ) . '",cleanup_desc:"' . mce_escape( __('Cleanup messy code') ) . '",code_desc:"' . mce_escape( __('Edit HTML Source') ) . '",sub_desc:"' . mce_escape( __('Subscript') ) . '",sup_desc:"' . mce_escape( __('Superscript') ) . '",hr_desc:"' . mce_escape( __('Insert horizontal ruler') ) . '",removeformat_desc:"' . mce_escape( __('Remove formatting') ) . '",forecolor_desc:"' . mce_escape( __('Select text color') ) . '",backcolor_desc:"' . mce_escape( __('Select background color') ) . '",charmap_desc:"' . mce_escape( __('Insert custom character') ) . '",visualaid_desc:"' . mce_escape( __('Toggle guidelines/invisible elements') ) . '",anchor_desc:"' . mce_escape( __('Insert/edit anchor') ) . '",cut_desc:"' . mce_escape( __('Cut') ) . '",copy_desc:"' . mce_escape( __('Copy') ) . '",paste_desc:"' . mce_escape( __('Paste') ) . '",image_props_desc:"' . mce_escape( __('Image properties') ) . '",newdocument_desc:"' . mce_escape( __('New document') ) . '",help_desc:"' . mce_escape( __('Help') ) . '",blockquote_desc:"' . mce_escape( __('Blockquote') ) . ' (Alt+Shift+Q)",clipboard_msg:"' . mce_escape( __('Copy/Cut/Paste is not available in Mozilla and Firefox.') ) . '",path:"' . mce_escape( __('Path') ) . '",newdocument:"' . mce_escape( __('Are you sure you want to clear all contents?') ) . '",toolbar_focus:"' . mce_escape( __('Jump to tool buttons - Alt+Q, Jump to editor - Alt-Z, Jump to element path - Alt-X') ) . '",more_colors:"' . mce_escape( __('More colors') ) . '",colorpicker_delta_width:"' . /* translators: Extra width for the colorpicker popup in pixels */ mce_escape( _x('0', 'colorpicker popup width') ) . '",colorpicker_delta_height:"' . /* translators: Extra height for the colorpicker popup in pixels */ mce_escape( _x('0', 'colorpicker popup height') ) . '"});tinyMCE.addI18n("' . $language . '.advanced_dlg",{about_title:"' . mce_escape( __('About TinyMCE') ) . '",about_general:"' . mce_escape( __('About') ) . '",about_help:"' . mce_escape( __('Help') ) . '",about_license:"' . mce_escape( __('License') ) . '",about_plugins:"' . mce_escape( __('Plugins') ) . '",about_plugin:"' . mce_escape( __('Plugin') ) . '",about_author:"' . mce_escape( __('Author') ) . '",about_version:"' . mce_escape( __('Version') ) . '",about_loaded:"' . mce_escape( __('Loaded plugins') ) . '",anchor_title:"' . mce_escape( __('Insert/edit anchor') ) . '",anchor_name:"' . mce_escape( __('Anchor name') ) . '",code_title:"' . mce_escape( __('HTML Source Editor') ) . '",code_wordwrap:"' . mce_escape( __('Word wrap') ) . '",colorpicker_title:"' . mce_escape( __('Select a color') ) . '",colorpicker_picker_tab:"' . mce_escape( __('Picker') ) . '",colorpicker_picker_title:"' . mce_escape( __('Color picker') ) . '",colorpicker_palette_tab:"' . mce_escape( __('Palette') ) . '",colorpicker_palette_title:"' . mce_escape( __('Palette colors') ) . '",colorpicker_named_tab:"' . mce_escape( __('Named') ) . '",colorpicker_named_title:"' . mce_escape( __('Named colors') ) . '",colorpicker_color:"' . mce_escape( __('Color:') ) . '",colorpicker_name:"' . mce_escape( __('Name:') ) . '",charmap_title:"' . mce_escape( __('Select custom character') ) . '",image_title:"' . mce_escape( __('Insert/edit image') ) . '",image_src:"' . mce_escape( __('Image URL') ) . '",image_alt:"' . mce_escape( __('Image description') ) . '",image_list:"' . mce_escape( __('Image list') ) . '",image_border:"' . mce_escape( __('Border') ) . '",image_dimensions:"' . mce_escape( __('Dimensions') ) . '",image_vspace:"' . mce_escape( __('Vertical space') ) . '",image_hspace:"' . mce_escape( __('Horizontal space') ) . '",image_align:"' . mce_escape( __('Alignment') ) . '",image_align_baseline:"' . mce_escape( __('Baseline') ) . '",image_align_top:"' . mce_escape( __('Top') ) . '",image_align_middle:"' . mce_escape( __('Middle') ) . '",image_align_bottom:"' . mce_escape( __('Bottom') ) . '",image_align_texttop:"' . mce_escape( __('Text top') ) . '",image_align_textbottom:"' . mce_escape( __('Text bottom') ) . '",image_align_left:"' . mce_escape( __('Left') ) . '",image_align_right:"' . mce_escape( __('Right') ) . '",link_title:"' . mce_escape( __('Insert/edit link') ) . '",link_url:"' . mce_escape( __('Link URL') ) . '",link_target:"' . mce_escape( __('Target') ) . '",link_target_same:"' . mce_escape( __('Open link in the same window') ) . '",link_target_blank:"' . mce_escape( __('Open link in a new window') ) . '",link_titlefield:"' . mce_escape( __('Title') ) . '",link_is_email:"' . mce_escape( __('The URL you entered seems to be an email address, do you want to add the required mailto: prefix?') ) . '",link_is_external:"' . mce_escape( __('The URL you entered seems to external link, do you want to add the required http:// prefix?') ) . '",link_list:"' . mce_escape( __('Link list') ) . '"});tinyMCE.addI18n("' . $language . '.media_dlg",{title:"' . mce_escape( __('Insert / edit embedded media') ) . '",general:"' . mce_escape( __('General') ) . '",advanced:"' . mce_escape( __('Advanced') ) . '",file:"' . mce_escape( __('File/URL') ) . '",list:"' . mce_escape( __('List') ) . '",size:"' . mce_escape( __('Dimensions') ) . '",preview:"' . mce_escape( __('Preview') ) . '",constrain_proportions:"' . mce_escape( __('Constrain proportions') ) . '",type:"' . mce_escape( __('Type') ) . '",id:"' . mce_escape( __('Id') ) . '",name:"' . mce_escape( __('Name') ) . '",class_name:"' . mce_escape( __('Class') ) . '",vspace:"' . mce_escape( __('V-Space') ) . '",hspace:"' . mce_escape( __('H-Space') ) . '",play:"' . mce_escape( __('Auto play') ) . '",loop:"' . mce_escape( __('Loop') ) . '",menu:"' . mce_escape( __('Show menu') ) . '",quality:"' . mce_escape( __('Quality') ) . '",scale:"' . mce_escape( __('Scale') ) . '",align:"' . mce_escape( __('Align') ) . '",salign:"' . mce_escape( __('SAlign') ) . '",wmode:"' . mce_escape( __('WMode') ) . '",bgcolor:"' . mce_escape( __('Background') ) . '",base:"' . mce_escape( __('Base') ) . '",flashvars:"' . mce_escape( __('Flashvars') ) . '",liveconnect:"' . mce_escape( __('SWLiveConnect') ) . '",autohref:"' . mce_escape( __('AutoHREF') ) . '",cache:"' . mce_escape( __('Cache') ) . '",hidden:"' . mce_escape( __('Hidden') ) . '",controller:"' . mce_escape( __('Controller') ) . '",kioskmode:"' . mce_escape( __('Kiosk mode') ) . '",playeveryframe:"' . mce_escape( __('Play every frame') ) . '",targetcache:"' . mce_escape( __('Target cache') ) . '",correction:"' . mce_escape( __('No correction') ) . '",enablejavascript:"' . mce_escape( __('Enable JavaScript') ) . '",starttime:"' . mce_escape( __('Start time') ) . '",endtime:"' . mce_escape( __('End time') ) . '",href:"' . mce_escape( __('href') ) . '",qtsrcchokespeed:"' . mce_escape( __('Choke speed') ) . '",target:"' . mce_escape( __('Target') ) . '",volume:"' . mce_escape( __('Volume') ) . '",autostart:"' . mce_escape( __('Auto start') ) . '",enabled:"' . mce_escape( __('Enabled') ) . '",fullscreen:"' . mce_escape( __('Fullscreen') ) . '",invokeurls:"' . mce_escape( __('Invoke URLs') ) . '",mute:"' . mce_escape( __('Mute') ) . '",stretchtofit:"' . mce_escape( __('Stretch to fit') ) . '",windowlessvideo:"' . mce_escape( __('Windowless video') ) . '",balance:"' . mce_escape( __('Balance') ) . '",baseurl:"' . mce_escape( __('Base URL') ) . '",captioningid:"' . mce_escape( __('Captioning id') ) . '",currentmarker:"' . mce_escape( __('Current marker') ) . '",currentposition:"' . mce_escape( __('Current position') ) . '",defaultframe:"' . mce_escape( __('Default frame') ) . '",playcount:"' . mce_escape( __('Play count') ) . '",rate:"' . mce_escape( __('Rate') ) . '",uimode:"' . mce_escape( __('UI Mode') ) . '",flash_options:"' . mce_escape( __('Flash options') ) . '",qt_options:"' . mce_escape( __('Quicktime options') ) . '",wmp_options:"' . mce_escape( __('Windows media player options') ) . '",rmp_options:"' . mce_escape( __('Real media player options') ) . '",shockwave_options:"' . mce_escape( __('Shockwave options') ) . '",autogotourl:"' . mce_escape( __('Auto goto URL') ) . '",center:"' . mce_escape( __('Center') ) . '",imagestatus:"' . mce_escape( __('Image status') ) . '",maintainaspect:"' . mce_escape( __('Maintain aspect') ) . '",nojava:"' . mce_escape( __('No java') ) . '",prefetch:"' . mce_escape( __('Prefetch') ) . '",shuffle:"' . mce_escape( __('Shuffle') ) . '",console:"' . mce_escape( __('Console') ) . '",numloop:"' . mce_escape( __('Num loops') ) . '",controls:"' . mce_escape( __('Controls') ) . '",scriptcallbacks:"' . mce_escape( __('Script callbacks') ) . '",swstretchstyle:"' . mce_escape( __('Stretch style') ) . '",swstretchhalign:"' . mce_escape( __('Stretch H-Align') ) . '",swstretchvalign:"' . mce_escape( __('Stretch V-Align') ) . '",sound:"' . mce_escape( __('Sound') ) . '",progress:"' . mce_escape( __('Progress') ) . '",qtsrc:"' . mce_escape( __('QT Src') ) . '",qt_stream_warn:"' . mce_escape( __('Streamed rtsp resources should be added to the QT Src field under the advanced tab.') ) . '",align_top:"' . mce_escape( __('Top') ) . '",align_right:"' . mce_escape( __('Right') ) . '",align_bottom:"' . mce_escape( __('Bottom') ) . '",align_left:"' . mce_escape( __('Left') ) . '",align_center:"' . mce_escape( __('Center') ) . '",align_top_left:"' . mce_escape( __('Top left') ) . '",align_top_right:"' . mce_escape( __('Top right') ) . '",align_bottom_left:"' . mce_escape( __('Bottom left') ) . '",align_bottom_right:"' . mce_escape( __('Bottom right') ) . '",flv_options:"' . mce_escape( __('Flash video options') ) . '",flv_scalemode:"' . mce_escape( __('Scale mode') ) . '",flv_buffer:"' . mce_escape( __('Buffer') ) . '",flv_startimage:"' . mce_escape( __('Start image') ) . '",flv_starttime:"' . mce_escape( __('Start time') ) . '",flv_defaultvolume:"' . mce_escape( __('Default volume') ) . '",flv_hiddengui:"' . mce_escape( __('Hidden GUI') ) . '",flv_autostart:"' . mce_escape( __('Auto start') ) . '",flv_loop:"' . mce_escape( __('Loop') ) . '",flv_showscalemodes:"' . mce_escape( __('Show scale modes') ) . '",flv_smoothvideo:"' . mce_escape( __('Smooth video') ) . '",flv_jscallback:"' . mce_escape( __('JS Callback') ) . '"});tinyMCE.addI18n("' . $language . '.wordpress",{wp_adv_desc:"' . mce_escape( __('Show/Hide Kitchen Sink') )  . ' (Alt+Shift+Z)",wp_more_desc:"' . mce_escape( __('Insert More Tag') ) . ' (Alt+Shift+T)",wp_page_desc:"' . mce_escape( __('Insert Page break') ) . ' (Alt+Shift+P)",wp_help_desc:"' . mce_escape( __('Help') ) . ' (Alt+Shift+H)",wp_more_alt:"' . mce_escape( __('More...') ) . '",wp_page_alt:"' . mce_escape( __('Next page...') ) . '",add_media:"' . mce_escape( __('Add Media') ) . '",add_image:"' . mce_escape( __('Add an Image') ) . '",add_video:"' . mce_escape( __('Add Video') ) . '",add_audio:"' . mce_escape( __('Add Audio') ) . '",editgallery:"' . mce_escape( __('Edit Gallery') ) . '",delgallery:"' . mce_escape( __('Delete Gallery') ) . '"});tinyMCE.addI18n("' . $language . '.wpeditimage",{edit_img:"' . mce_escape( __('Edit Image') )  . '",del_img:"' . mce_escape( __('Delete Image') )  . '",adv_settings:"' . mce_escape( __('Advanced Settings') )  . '",none:"' . mce_escape( __('None') )  . '",size:"' . mce_escape( __('Size') ) . '",thumbnail:"' . mce_escape( __('Thumbnail') ) . '",medium:"' . mce_escape( __('Medium') ) . '",full_size:"' . mce_escape( __('Full Size') ) . '",current_link:"' . mce_escape( __('Current Link') ) . '",link_to_img:"' . mce_escape( __('Link to Image') ) . '",link_help:"' . mce_escape( __('Enter a link URL or click above for presets.') ) . '",adv_img_settings:"' . mce_escape( __('Advanced Image Settings') ) . '",source:"' . mce_escape( __('Source') )  . '",width:"' . mce_escape( __('Width') ) . '",height:"' . mce_escape( __('Height') ) . '",orig_size:"' . mce_escape( __('Original Size') ) . '",css:"' . mce_escape( __('CSS Class') ) . '",adv_link_settings:"' . mce_escape( __('Advanced Link Settings') )  . '",link_rel:"' . mce_escape( __('Link Rel') ) . '",height:"' . mce_escape( __('Height') ) . '",orig_size:"' . mce_escape( __('Original Size') ) . '",css:"' . mce_escape( __('CSS Class') ) . '",s60:"' . mce_escape( __('60%') ) . '",s70:"' . mce_escape( __('70%') ) . '",s80:"' . mce_escape( __('80%') ) . '",s90:"' . mce_escape( __('90%') ) . '",s100:"' . mce_escape( __('100%') ) . '",s110:"' . mce_escape( __('110%') ) . '",s120:"' . mce_escape( __('120%') ) . '",s130:"' . mce_escape( __('130%') ) . '",img_title:"' . mce_escape( __('Edit Image Title') ) . '",caption:"' . mce_escape( __('Edit Image Caption') ) . '",alt:"' . mce_escape( __('Edit Alternate Text') ) . '"});';
<?php/** * Class for a set of entries for translation and their associated headers * * @version $Id: translations.php 406 2010-02-07 11:10:24Z nbachiyski $ * @package pomo * @subpackage translations */require_once dirname(__FILE__) . '/entry.php';if ( !class_exists( 'Translations' ) ):class Translations {	var $entries = array();	var $headers = array();	/**	 * Add entry to the PO structure	 *	 * @param object &$entry	 * @return bool true on success, false if the entry doesn't have a key	 */	function add_entry($entry) {		if (is_array($entry)) {			$entry = new Translation_Entry($entry);		}		$key = $entry->key();		if (false === $key) return false;		$this->entries[$key] = &$entry;		return true;	}	/**	 * Sets $header PO header to $value	 *	 * If the header already exists, it will be overwritten	 *	 * TODO: this should be out of this class, it is gettext specific	 *	 * @param string $header header name, without trailing :	 * @param string $value header value, without trailing \n	 */	function set_header($header, $value) {		$this->headers[$header] = $value;	}	function set_headers(&$headers) {		foreach($headers as $header => $value) {			$this->set_header($header, $value);		}	}	function get_header($header) {		return isset($this->headers[$header])? $this->headers[$header] : false;	}	function translate_entry(&$entry) {		$key = $entry->key();		return isset($this->entries[$key])? $this->entries[$key] : false;	}	function translate($singular, $context=null) {		$entry = new Translation_Entry(array('singular' => $singular, 'context' => $context));		$translated = $this->translate_entry($entry);		return ($translated && !empty($translated->translations))? $translated->translations[0] : $singular;	}	/**	 * Given the number of items, returns the 0-based index of the plural form to use	 *	 * Here, in the base Translations class, the commong logic for English is implmented:	 * 	0 if there is one element, 1 otherwise	 *	 * This function should be overrided by the sub-classes. For example MO/PO can derive the logic	 * from their headers.	 *	 * @param integer $count number of items	 */	function select_plural_form($count) {		return 1 == $count? 0 : 1;	}	function get_plural_forms_count() {		return 2;	}	function translate_plural($singular, $plural, $count, $context = null) {		$entry = new Translation_Entry(array('singular' => $singular, 'plural' => $plural, 'context' => $context));		$translated = $this->translate_entry($entry);		$index = $this->select_plural_form($count);		$total_plural_forms = $this->get_plural_forms_count();		if ($translated && 0 <= $index && $index < $total_plural_forms &&				is_array($translated->translations) &&				isset($translated->translations[$index]))			return $translated->translations[$index];		else			return 1 == $count? $singular : $plural;	}	/**	 * Merge $other in the current object.	 *	 * @param Object &$other Another Translation object, whose translations will be merged in this one	 * @return void	 **/	function merge_with(&$other) {		foreach( $other->entries as $entry ) {			$this->entries[$entry->key()] = $entry;		}	}}class Gettext_Translations extends Translations {	/**	 * The gettext implmentation of select_plural_form.	 *	 * It lives in this class, because there are more than one descendand, which will use it and	 * they can't share it effectively.	 *	 */	function gettext_select_plural_form($count) {		if (!isset($this->_gettext_select_plural_form) || is_null($this->_gettext_select_plural_form)) {			list( $nplurals, $expression ) = $this->nplurals_and_expression_from_header($this->get_header('Plural-Forms'));			$this->_nplurals = $nplurals;			$this->_gettext_select_plural_form = $this->make_plural_form_function($nplurals, $expression);		}		return call_user_func($this->_gettext_select_plural_form, $count);	}	function nplurals_and_expression_from_header($header) {		if (preg_match('/^\s*nplurals\s*=\s*(\d+)\s*;\s+plural\s*=\s*(.+)$/', $header, $matches)) {			$nplurals = (int)$matches[1];			$expression = trim($this->parenthesize_plural_exression($matches[2]));			return array($nplurals, $expression);		} else {			return array(2, 'n != 1');		}	}	/**	 * Makes a function, which will return the right translation index, according to the	 * plural forms header	 */	function make_plural_form_function($nplurals, $expression) {		$expression = str_replace('n', '$n', $expression);		$func_body = "			\$index = (int)($expression);			return (\$index < $nplurals)? \$index : $nplurals - 1;";		return create_function('$n', $func_body);	}	/**	 * Adds parantheses to the inner parts of ternary operators in	 * plural expressions, because PHP evaluates ternary oerators from left to right	 *	 * @param string $expression the expression without parentheses	 * @return string the expression with parentheses added	 */	function parenthesize_plural_exression($expression) {		$expression .= ';';		$res = '';		$depth = 0;		for ($i = 0; $i < strlen($expression); ++$i) {			$char = $expression[$i];			switch ($char) {				case '?':					$res .= ' ? (';					$depth++;					break;				case ':':					$res .= ') : (';					break;				case ';':					$res .= str_repeat(')', $depth) . ';';					$depth= 0;					break;				default:					$res .= $char;			}		}		return rtrim($res, ';');	}	function make_headers($translation) {		$headers = array();		// sometimes \ns are used instead of real new lines		$translation = str_replace('\n', "\n", $translation);		$lines = explode("\n", $translation);		foreach($lines as $line) {			$parts = explode(':', $line, 2);			if (!isset($parts[1])) continue;			$headers[trim($parts[0])] = trim($parts[1]);		}		return $headers;	}	function set_header($header, $value) {		parent::set_header($header, $value);		if ('Plural-Forms' == $header) {			list( $nplurals, $expression ) = $this->nplurals_and_expression_from_header($this->get_header('Plural-Forms'));			$this->_nplurals = $nplurals;			$this->_gettext_select_plural_form = $this->make_plural_form_function($nplurals, $expression);		}	}}endif;if ( !class_exists( 'NOOP_Translations' ) ):/** * Provides the same interface as Translations, but doesn't do anything */class NOOP_Translations {	var $entries = array();	var $headers = array();	function add_entry($entry) {		return true;	}	function set_header($header, $value) {	}	function set_headers(&$headers) {	}	function get_header($header) {		return false;	}	function translate_entry(&$entry) {		return false;	}	function translate($singular, $context=null) {		return $singular;	}	function select_plural_form($count) {		return 1 == $count? 0 : 1;	}	function get_plural_forms_count() {		return 2;	}	function translate_plural($singular, $plural, $count, $context = null) {			return 1 == $count? $singular : $plural;	}	function merge_with(&$other) {	}}endif;
<?php/** * The Template for displaying all single posts. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container">			<div id="content" role="main"><?php if ( have_posts() ) while ( have_posts() ) : the_post(); ?>				<div id="nav-above" class="navigation">					<div class="nav-previous"><?php previous_post_link( '%link', '<span class="meta-nav">' . _x( '&larr;', 'Previous post link', 'twentyten' ) . '</span> %title' ); ?></div>					<div class="nav-next"><?php next_post_link( '%link', '%title <span class="meta-nav">' . _x( '&rarr;', 'Next post link', 'twentyten' ) . '</span>' ); ?></div>				</div><!-- #nav-above -->				<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>					<h1 class="entry-title"><?php the_title(); ?></h1>					<div class="entry-meta">						<?php twentyten_posted_on(); ?>					</div><!-- .entry-meta -->					<div class="entry-content">						<?php the_content(); ?>						<?php wp_link_pages( array( 'before' => '<div class="page-link">' . __( 'Pages:', 'twentyten' ), 'after' => '</div>' ) ); ?>					</div><!-- .entry-content --><?php if ( get_the_author_meta( 'description' ) ) : // If a user has filled out their description, show a bio on their entries  ?>					<div id="entry-author-info">						<div id="author-avatar">							<?php echo get_avatar( get_the_author_meta( 'user_email' ), apply_filters( 'twentyten_author_bio_avatar_size', 60 ) ); ?>						</div><!-- #author-avatar -->						<div id="author-description">							<h2><?php printf( esc_attr__( 'About %s', 'twentyten' ), get_the_author() ); ?></h2>							<?php the_author_meta( 'description' ); ?>							<div id="author-link">								<a href="<?php echo get_author_posts_url( get_the_author_meta( 'ID' ) ); ?>">									<?php printf( __( 'View all posts by %s <span class="meta-nav">&rarr;</span>', 'twentyten' ), get_the_author() ); ?>								</a>							</div><!-- #author-link	-->						</div><!-- #author-description -->					</div><!-- #entry-author-info --><?php endif; ?>					<div class="entry-utility">						<?php twentyten_posted_in(); ?>						<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="edit-link">', '</span>' ); ?>					</div><!-- .entry-utility -->				</div><!-- #post-## -->				<div id="nav-below" class="navigation">					<div class="nav-previous"><?php previous_post_link( '%link', '<span class="meta-nav">' . _x( '&larr;', 'Previous post link', 'twentyten' ) . '</span> %title' ); ?></div>					<div class="nav-next"><?php next_post_link( '%link', '%title <span class="meta-nav">' . _x( '&rarr;', 'Next post link', 'twentyten' ) . '</span>' ); ?></div>				</div><!-- #nav-below -->				<?php comments_template( '', true ); ?><?php endwhile; // end of the loop. ?>			</div><!-- #content -->		</div><!-- #container --><?php get_sidebar(); ?><?php get_footer(); ?>
<?php/** * API for fetching the HTML to embed remote content based on a provided URL. * Used internally by the {@link WP_Embed} class, but is designed to be generic. * * @link http://codex.wordpress.org/oEmbed oEmbed Codex Article * @link http://oembed.com/ oEmbed Homepage * * @package WordPress * @subpackage oEmbed *//** * oEmbed class. * * @package WordPress * @subpackage oEmbed * @since 2.9.0 */class WP_oEmbed {	var $providers = array();	/**	 * PHP4 constructor	 */	function WP_oEmbed() {		return $this->__construct();	}	/**	 * PHP5 constructor	 *	 * @uses apply_filters() Filters a list of pre-defined oEmbed providers.	 */	function __construct() {		// List out some popular sites that support oEmbed.		// The WP_Embed class disables discovery for non-unfiltered_html users, so only providers in this array will be used for them.		// Add to this list using the wp_oembed_add_provider() function (see it's PHPDoc for details).		$this->providers = apply_filters( 'oembed_providers', array(			'#http://(www\.)?youtube.com/watch.*#i'         => array( 'http://www.youtube.com/oembed',            true  ),			'http://youtu.be/*'                             => array( 'http://www.youtube.com/oembed',            false ),			'http://blip.tv/file/*'                         => array( 'http://blip.tv/oembed/',                   false ),			'#http://(www\.)?vimeo\.com/.*#i'               => array( 'http://www.vimeo.com/api/oembed.{format}', true  ),			'#http://(www\.)?dailymotion\.com/.*#i'         => array( 'http://www.dailymotion.com/api/oembed',    true  ),			'#http://(www\.)?flickr\.com/.*#i'              => array( 'http://www.flickr.com/services/oembed/',   true  ),			'#http://(.+)?smugmug\.com/.*#i'                => array( 'http://api.smugmug.com/services/oembed/',  true  ),			'#http://(www\.)?hulu\.com/watch/.*#i'          => array( 'http://www.hulu.com/api/oembed.{format}',  true  ),			'#http://(www\.)?viddler\.com/.*#i'             => array( 'http://lab.viddler.com/services/oembed/',  true  ),			'http://qik.com/*'                              => array( 'http://qik.com/api/oembed.{format}',       false ),			'http://revision3.com/*'                        => array( 'http://revision3.com/api/oembed/',         false ),			'http://i*.photobucket.com/albums/*'            => array( 'http://photobucket.com/oembed',            false ),			'http://gi*.photobucket.com/groups/*'           => array( 'http://photobucket.com/oembed',            false ),			'#http://(www\.)?scribd\.com/.*#i'              => array( 'http://www.scribd.com/services/oembed',    true  ),			'http://wordpress.tv/*'                         => array( 'http://wordpress.tv/oembed/',              false ),			'#http://(answers|surveys)\.polldaddy.com/.*#i' => array( 'http://polldaddy.com/oembed/',             true  ),			'#http://(www\.)?funnyordie\.com/videos/.*#i'   => array( 'http://www.funnyordie.com/oembed',         true  ),		) );		// Fix any embeds that contain new lines in the middle of the HTML which breaks wpautop().		add_filter( 'oembed_dataparse', array(&$this, '_strip_newlines'), 10, 3 );	}	/**	 * The do-it-all function that takes a URL and attempts to return the HTML.	 *	 * @see WP_oEmbed::discover()	 * @see WP_oEmbed::fetch()	 * @see WP_oEmbed::data2html()	 *	 * @param string $url The URL to the content that should be attempted to be embedded.	 * @param array $args Optional arguments. Usually passed from a shortcode.	 * @return bool|string False on failure, otherwise the UNSANITIZED (and potentially unsafe) HTML that should be used to embed.	 */	function get_html( $url, $args = '' ) {		$provider = false;		if ( !isset($args['discover']) )			$args['discover'] = true;		foreach ( $this->providers as $matchmask => $data ) {			list( $providerurl, $regex ) = $data;			// Turn the asterisk-type provider URLs into regex			if ( !$regex )				$matchmask = '#' . str_replace( '___wildcard___', '(.+)', preg_quote( str_replace( '*', '___wildcard___', $matchmask ), '#' ) ) . '#i';			if ( preg_match( $matchmask, $url ) ) {				$provider = str_replace( '{format}', 'json', $providerurl ); // JSON is easier to deal with than XML				break;			}		}		if ( !$provider && $args['discover'] )			$provider = $this->discover( $url );		if ( !$provider || false === $data = $this->fetch( $provider, $url, $args ) )			return false;		return apply_filters( 'oembed_result', $this->data2html( $data, $url ), $url, $args );	}	/**	 * Attempts to find oEmbed provider discovery <link> tags at the given URL.	 *	 * @param string $url The URL that should be inspected for discovery <link> tags.	 * @return bool|string False on failure, otherwise the oEmbed provider URL.	 */	function discover( $url ) {		$providers = array();		// Fetch URL content		if ( $html = wp_remote_retrieve_body( wp_remote_get( $url ) ) ) {			// <link> types that contain oEmbed provider URLs			$linktypes = apply_filters( 'oembed_linktypes', array(				'application/json+oembed' => 'json',				'text/xml+oembed' => 'xml',				'application/xml+oembed' => 'xml', // Incorrect, but used by at least Vimeo			) );			// Strip <body>			$html = substr( $html, 0, stripos( $html, '</head>' ) );			// Do a quick check			$tagfound = false;			foreach ( $linktypes as $linktype => $format ) {				if ( stripos($html, $linktype) ) {					$tagfound = true;					break;				}			}			if ( $tagfound && preg_match_all( '/<link([^<>]+)>/i', $html, $links ) ) {				foreach ( $links[1] as $link ) {					$atts = shortcode_parse_atts( $link );					if ( !empty($atts['type']) && !empty($linktypes[$atts['type']]) && !empty($atts['href']) ) {						$providers[$linktypes[$atts['type']]] = $atts['href'];						// Stop here if it's JSON (that's all we need)						if ( 'json' == $linktypes[$atts['type']] )							break;					}				}			}		}		// JSON is preferred to XML		if ( !empty($providers['json']) )			return $providers['json'];		elseif ( !empty($providers['xml']) )			return $providers['xml'];		else			return false;	}	/**	 * Connects to a oEmbed provider and returns the result.	 *	 * @param string $provider The URL to the oEmbed provider.	 * @param string $url The URL to the content that is desired to be embedded.	 * @param array $args Optional arguments. Usually passed from a shortcode.	 * @return bool|object False on failure, otherwise the result in the form of an object.	 */	function fetch( $provider, $url, $args = '' ) {		$args = wp_parse_args( $args, wp_embed_defaults() );		$provider = add_query_arg( 'maxwidth', $args['width'], $provider );		$provider = add_query_arg( 'maxheight', $args['height'], $provider );		$provider = add_query_arg( 'url', urlencode($url), $provider );		foreach( array( 'json', 'xml' ) as $format ) {			$result = $this->_fetch_with_format( $provider, $format );			if ( is_wp_error( $result ) && 'not-implemented' == $result->get_error_code() )				continue;			return ( $result && ! is_wp_error( $result ) ) ? $result : false;		}		return false;	}	/**	 * Fetches result from an oEmbed provider for a specific format and complete provider URL	 *	 * @since 3.0.0	 * @access private	 * @param string $provider_url_with_args URL to the provider with full arguments list (url, maxheight, etc.)	 * @param string $format Format to use	 * @return bool|object False on failure, otherwise the result in the form of an object.	 */	function _fetch_with_format( $provider_url_with_args, $format ) {		$provider_url_with_args = add_query_arg( 'format', $format, $provider_url_with_args );		$response = wp_remote_get( $provider_url_with_args );		if ( 501 == wp_remote_retrieve_response_code( $response ) )			return new WP_Error( 'not-implemented' );		if ( ! $body = wp_remote_retrieve_body( $response ) )			return false;		$parse_method = "_parse_$format";		return $this->$parse_method( $body );	}	/**	 * Parses a json response body.	 *	 * @since 3.0.0	 * @access private	 */	function _parse_json( $response_body ) {		return ( ( $data = json_decode( trim( $response_body ) ) ) && is_object( $data ) ) ? $data : false;	}	/**	 * Parses an XML response body.	 *	 * @since 3.0.0	 * @access private	 */	function _parse_xml( $response_body ) {		if ( function_exists('simplexml_load_string') ) {			$errors = libxml_use_internal_errors( 'true' );			$data = simplexml_load_string( $response_body );			libxml_use_internal_errors( $errors );			if ( is_object( $data ) )				return $data;		}		return false;	}	/**	 * Converts a data object from {@link WP_oEmbed::fetch()} and returns the HTML.	 *	 * @param object $data A data object result from an oEmbed provider.	 * @param string $url The URL to the content that is desired to be embedded.	 * @return bool|string False on error, otherwise the HTML needed to embed.	 */	function data2html( $data, $url ) {		if ( !is_object($data) || empty($data->type) )			return false;		switch ( $data->type ) {			case 'photo':				if ( empty($data->url) || empty($data->width) || empty($data->height) )					return false;				$title = ( !empty($data->title) ) ? $data->title : '';				$return = '<img src="' . esc_url( $data->url ) . '" alt="' . esc_attr($title) . '" width="' . esc_attr($data->width) . '" height="' . esc_attr($data->height) . '" />';				break;			case 'video':			case 'rich':				$return = ( !empty($data->html) ) ? $data->html : false;				break;			case 'link':				$return = ( !empty($data->title) ) ? '<a href="' . esc_url($url) . '">' . esc_html($data->title) . '</a>' : false;				break;			default;				$return = false;		}		// You can use this filter to add support for custom data types or to filter the result		return apply_filters( 'oembed_dataparse', $return, $data, $url );	}	/**	 * Strip any new lines from the HTML.	 *	 * @access private	 * @param string $html Existing HTML.	 * @param object $data Data object from WP_oEmbed::data2html()	 * @param string $url The original URL passed to oEmbed.	 * @return string Possibly modified $html	 */	function _strip_newlines( $html, $data, $url ) {		if ( false !== strpos( $html, "\n" ) )			$html = str_replace( array( "\r\n", "\n" ), '', $html );		return $html;	}}/** * Returns the initialized {@link WP_oEmbed} object * * @since 2.9.0 * @access private * * @see WP_oEmbed * @uses WP_oEmbed * * @return WP_oEmbed object. */function &_wp_oembed_get_object() {	static $wp_oembed;	if ( is_null($wp_oembed) )		$wp_oembed = new WP_oEmbed();	return $wp_oembed;}?>
<?php/** * A simple set of functions to check our version 1.0 update service. * * @package WordPress * @since 2.3.0 *//** * Check WordPress version against the newest version. * * The WordPress version, PHP version, and Locale is sent. Checks against the * WordPress server at api.wordpress.org server. Will only check if WordPress * isn't installing. * * @package WordPress * @since 2.3.0 * @uses $wp_version Used to check against the newest WordPress version. * * @return mixed Returns null if update is unsupported. Returns false if check is too soon. */function wp_version_check() {	if ( defined('WP_INSTALLING') )		return;	global $wp_version, $wpdb, $wp_local_package;	$php_version = phpversion();	$current = get_site_transient( 'update_core' );	if ( ! is_object($current) ) {		$current = new stdClass;		$current->updates = array();		$current->version_checked = $wp_version;	}	$locale = apply_filters( 'core_version_check_locale', get_locale() );	// Update last_checked for current to prevent multiple blocking requests if request hangs	$current->last_checked = time();	set_site_transient( 'update_core', $current );	if ( method_exists( $wpdb, 'db_version' ) )		$mysql_version = preg_replace('/[^0-9.].*/', '', $wpdb->db_version());	else		$mysql_version = 'N/A';	$num_blogs = 1;	$wp_install = home_url( '/' );	$multisite_enabled = 0;	$user_count = count_users( );	if ( is_multisite( ) ) {		$num_blogs = get_blog_count( );		$wp_install = network_site_url( );		$multisite_enabled = 1;	}	$local_package = isset( $wp_local_package )? $wp_local_package : '';	$url = "http://api.wordpress.org/core/version-check/1.5/?version=$wp_version&php=$php_version&locale=$locale&mysql=$mysql_version&local_package=$local_package&blogs=$num_blogs&users={$user_count['total_users']}&multisite_enabled=$multisite_enabled";	$options = array(		'timeout' => ( ( defined('DOING_CRON') && DOING_CRON ) ? 30 : 3 ),		'user-agent' => 'WordPress/' . $wp_version . '; ' . home_url( '/' ),		'headers' => array(			'wp_install' => $wp_install,			'wp_blog' => home_url( '/' )		)	);	$response = wp_remote_get($url, $options);	if ( is_wp_error( $response ) )		return false;	if ( 200 != $response['response']['code'] )		return false;	$body = trim( $response['body'] );	$body = str_replace(array("\r\n", "\r"), "\n", $body);	$new_options = array();	foreach ( explode( "\n\n", $body ) as $entry ) {		$returns = explode("\n", $entry);		$new_option = new stdClass();		$new_option->response = esc_attr( $returns[0] );		if ( isset( $returns[1] ) )			$new_option->url = esc_url( $returns[1] );		if ( isset( $returns[2] ) )			$new_option->package = esc_url( $returns[2] );		if ( isset( $returns[3] ) )			$new_option->current = esc_attr( $returns[3] );		if ( isset( $returns[4] ) )			$new_option->locale = esc_attr( $returns[4] );		if ( isset( $returns[5] ) )			$new_option->php_version = esc_attr( $returns[5] );		if ( isset( $returns[6] ) )			$new_option->mysql_version = esc_attr( $returns[6] );		$new_options[] = $new_option;	}	$updates = new stdClass();	$updates->updates = $new_options;	$updates->last_checked = time();	$updates->version_checked = $wp_version;	set_site_transient( 'update_core',  $updates);}/** * Check plugin versions against the latest versions hosted on WordPress.org. * * The WordPress version, PHP version, and Locale is sent along with a list of * all plugins installed. Checks against the WordPress server at * api.wordpress.org. Will only check if WordPress isn't installing. * * @package WordPress * @since 2.3.0 * @uses $wp_version Used to notidy the WordPress version. * * @return mixed Returns null if update is unsupported. Returns false if check is too soon. */function wp_update_plugins() {	global $wp_version;	if ( defined('WP_INSTALLING') )		return false;	// If running blog-side, bail unless we've not checked in the last 12 hours	if ( !function_exists( 'get_plugins' ) )		require_once( ABSPATH . 'wp-admin/includes/plugin.php' );	$plugins = get_plugins();	$active  = get_option( 'active_plugins', array() );	$current = get_site_transient( 'update_plugins' );	if ( ! is_object($current) )		$current = new stdClass;	$new_option = new stdClass;	$new_option->last_checked = time();	$timeout = 'load-plugins.php' == current_filter() ? 3600 : 43200; //Check for updated every 60 minutes if hitting the themes page, Else, check every 12 hours	$time_not_changed = isset( $current->last_checked ) && $timeout > ( time() - $current->last_checked );	$plugin_changed = false;	foreach ( $plugins as $file => $p ) {		$new_option->checked[ $file ] = $p['Version'];		if ( !isset( $current->checked[ $file ] ) || strval($current->checked[ $file ]) !== strval($p['Version']) )			$plugin_changed = true;	}	if ( isset ( $current->response ) && is_array( $current->response ) ) {		foreach ( $current->response as $plugin_file => $update_details ) {			if ( ! isset($plugins[ $plugin_file ]) ) {				$plugin_changed = true;				break;			}		}	}	// Bail if we've checked in the last 12 hours and if nothing has changed	if ( $time_not_changed && !$plugin_changed )		return false;	// Update last_checked for current to prevent multiple blocking requests if request hangs	$current->last_checked = time();	set_site_transient( 'update_plugins', $current );	$to_send = (object) compact('plugins', 'active');	$options = array(		'timeout' => ( ( defined('DOING_CRON') && DOING_CRON ) ? 30 : 3),		'body' => array( 'plugins' => serialize( $to_send ) ),		'user-agent' => 'WordPress/' . $wp_version . '; ' . get_bloginfo( 'url' )	);	$raw_response = wp_remote_post('http://api.wordpress.org/plugins/update-check/1.0/', $options);	if ( is_wp_error( $raw_response ) )		return false;	if ( 200 != $raw_response['response']['code'] )		return false;	$response = unserialize( $raw_response['body'] );	if ( false !== $response )		$new_option->response = $response;	else		$new_option->response = array();	set_site_transient( 'update_plugins', $new_option );}/** * Check theme versions against the latest versions hosted on WordPress.org. * * A list of all themes installed in sent to WP. Checks against the * WordPress server at api.wordpress.org. Will only check if WordPress isn't * installing. * * @package WordPress * @since 2.7.0 * @uses $wp_version Used to notidy the WordPress version. * * @return mixed Returns null if update is unsupported. Returns false if check is too soon. */function wp_update_themes( ) {	global $wp_version;	if ( defined( 'WP_INSTALLING' ) )		return false;	if ( !function_exists( 'get_themes' ) )		require_once( ABSPATH . 'wp-includes/theme.php' );	$installed_themes = get_themes( );	$current_theme = get_site_transient( 'update_themes' );	if ( ! is_object($current_theme) )		$current_theme = new stdClass;	$new_option = new stdClass;	$new_option->last_checked = time( );	$timeout = 'load-themes.php' == current_filter() ? 3600 : 43200; //Check for updated every 60 minutes if hitting the themes page, Else, check every 12 hours	$time_not_changed = isset( $current_theme->last_checked ) && $timeout > ( time( ) - $current_theme->last_checked );	$themes = array();	$checked = array();	$themes['current_theme'] = (array) $current_theme;	foreach ( (array) $installed_themes as $theme_title => $theme ) {		$themes[$theme['Stylesheet']] = array();		$checked[$theme['Stylesheet']] = $theme['Version'];		foreach ( (array) $theme as $key => $value )			$themes[$theme['Stylesheet']][$key] = $value;	}	$theme_changed = false;	foreach ( $checked as $slug => $v ) {		$new_option->checked[ $slug ] = $v;		if ( !isset( $current_theme->checked[ $slug ] ) || strval($current_theme->checked[ $slug ]) !== strval($v) )			$theme_changed = true;	}	if ( isset ( $current_theme->response ) && is_array( $current_theme->response ) ) {		foreach ( $current_theme->response as $slug => $update_details ) {			if ( ! isset($checked[ $slug ]) ) {				$theme_changed = true;				break;			}		}	}	if ( $time_not_changed && !$theme_changed )		return false;	// Update last_checked for current to prevent multiple blocking requests if request hangs	$current_theme->last_checked = time();	set_site_transient( 'update_themes', $current_theme );	$current_theme->template = get_option( 'template' );	$options = array(		'timeout' => ( ( defined('DOING_CRON') && DOING_CRON ) ? 30 : 3),		'body'			=> array( 'themes' => serialize( $themes ) ),		'user-agent'	=> 'WordPress/' . $wp_version . '; ' . get_bloginfo( 'url' )	);	$raw_response = wp_remote_post( 'http://api.wordpress.org/themes/update-check/1.0/', $options );	if ( is_wp_error( $raw_response ) )		return false;	if ( 200 != $raw_response['response']['code'] )		return false;	$response = unserialize( $raw_response['body'] );	if ( $response ) {		$new_option->checked = $checked;		$new_option->response = $response;	}	set_site_transient( 'update_themes', $new_option );}function _maybe_update_core() {	global $wp_version;	$current = get_site_transient( 'update_core' );	if ( isset( $current->last_checked ) &&		43200 > ( time() - $current->last_checked ) &&		isset( $current->version_checked ) &&		$current->version_checked == $wp_version )		return;	wp_version_check();}/** * Check the last time plugins were run before checking plugin versions. * * This might have been backported to WordPress 2.6.1 for performance reasons. * This is used for the wp-admin to check only so often instead of every page * load. * * @since 2.7.0 * @access private */function _maybe_update_plugins() {	$current = get_site_transient( 'update_plugins' );	if ( isset( $current->last_checked ) && 43200 > ( time() - $current->last_checked ) )		return;	wp_update_plugins();}/** * Check themes versions only after a duration of time. * * This is for performance reasons to make sure that on the theme version * checker is not run on every page load. * * @since 2.7.0 * @access private */function _maybe_update_themes( ) {	$current = get_site_transient( 'update_themes' );	if ( isset( $current->last_checked ) && 43200 > ( time( ) - $current->last_checked ) )		return;	wp_update_themes();}add_action( 'admin_init', '_maybe_update_core' );add_action( 'wp_version_check', 'wp_version_check' );add_action( 'load-plugins.php', 'wp_update_plugins' );add_action( 'load-update.php', 'wp_update_plugins' );add_action( 'load-update-core.php', 'wp_update_plugins' );add_action( 'admin_init', '_maybe_update_plugins' );add_action( 'wp_update_plugins', 'wp_update_plugins' );add_action( 'load-themes.php', 'wp_update_themes' );add_action( 'load-update.php', 'wp_update_themes' );add_action( 'load-update-core.php', 'wp_update_themes' );add_action( 'admin_init', '_maybe_update_themes' );add_action( 'wp_update_themes', 'wp_update_themes' );if ( !wp_next_scheduled('wp_version_check') && !defined('WP_INSTALLING') )	wp_schedule_event(time(), 'twicedaily', 'wp_version_check');if ( !wp_next_scheduled('wp_update_plugins') && !defined('WP_INSTALLING') )	wp_schedule_event(time(), 'twicedaily', 'wp_update_plugins');if ( !wp_next_scheduled('wp_update_themes') && !defined('WP_INSTALLING') )	wp_schedule_event(time(), 'twicedaily', 'wp_update_themes');?>
<?php/** * Class used internally by Diff to actually compute the diffs. * * This class uses the Unix `diff` program via shell_exec to compute the * differences between the two input arrays. * * Copyright 2007-2010 The Horde Project (http://www.horde.org/) * * See the enclosed file COPYING for license information (LGPL). If you did * not receive this file, see http://opensource.org/licenses/lgpl-license.php. * * @author  Milian Wolff <mail@milianw.de> * @package Text_Diff * @since   0.3.0 */class Text_Diff_Engine_shell {    /**     * Path to the diff executable     *     * @var string     */    var $_diffCommand = 'diff';    /**     * Returns the array of differences.     *     * @param array $from_lines lines of text from old file     * @param array $to_lines   lines of text from new file     *     * @return array all changes made (array with Text_Diff_Op_* objects)     */    function diff($from_lines, $to_lines)    {        array_walk($from_lines, array('Text_Diff', 'trimNewlines'));        array_walk($to_lines, array('Text_Diff', 'trimNewlines'));        $temp_dir = Text_Diff::_getTempDir();        // Execute gnu diff or similar to get a standard diff file.        $from_file = tempnam($temp_dir, 'Text_Diff');        $to_file = tempnam($temp_dir, 'Text_Diff');        $fp = fopen($from_file, 'w');        fwrite($fp, implode("\n", $from_lines));        fclose($fp);        $fp = fopen($to_file, 'w');        fwrite($fp, implode("\n", $to_lines));        fclose($fp);        $diff = shell_exec($this->_diffCommand . ' ' . $from_file . ' ' . $to_file);        unlink($from_file);        unlink($to_file);        if (is_null($diff)) {            // No changes were made            return array(new Text_Diff_Op_copy($from_lines));        }        $from_line_no = 1;        $to_line_no = 1;        $edits = array();        // Get changed lines by parsing something like:        // 0a1,2        // 1,2c4,6        // 1,5d6        preg_match_all('#^(\d+)(?:,(\d+))?([adc])(\d+)(?:,(\d+))?$#m', $diff,            $matches, PREG_SET_ORDER);        foreach ($matches as $match) {            if (!isset($match[5])) {                // This paren is not set every time (see regex).                $match[5] = false;            }            if ($match[3] == 'a') {                $from_line_no--;            }            if ($match[3] == 'd') {                $to_line_no--;            }            if ($from_line_no < $match[1] || $to_line_no < $match[4]) {                // copied lines                assert('$match[1] - $from_line_no == $match[4] - $to_line_no');                array_push($edits,                    new Text_Diff_Op_copy(                        $this->_getLines($from_lines, $from_line_no, $match[1] - 1),                        $this->_getLines($to_lines, $to_line_no, $match[4] - 1)));            }            switch ($match[3]) {            case 'd':                // deleted lines                array_push($edits,                    new Text_Diff_Op_delete(                        $this->_getLines($from_lines, $from_line_no, $match[2])));                $to_line_no++;                break;            case 'c':                // changed lines                array_push($edits,                    new Text_Diff_Op_change(                        $this->_getLines($from_lines, $from_line_no, $match[2]),                        $this->_getLines($to_lines, $to_line_no, $match[5])));                break;            case 'a':                // added lines                array_push($edits,                    new Text_Diff_Op_add(                        $this->_getLines($to_lines, $to_line_no, $match[5])));                $from_line_no++;                break;            }        }        if (!empty($from_lines)) {            // Some lines might still be pending. Add them as copied            array_push($edits,                new Text_Diff_Op_copy(                    $this->_getLines($from_lines, $from_line_no,                                     $from_line_no + count($from_lines) - 1),                    $this->_getLines($to_lines, $to_line_no,                                     $to_line_no + count($to_lines) - 1)));        }        return $edits;    }    /**     * Get lines from either the old or new text     *     * @access private     *     * @param array &$text_lines Either $from_lines or $to_lines     * @param int   &$line_no    Current line number     * @param int   $end         Optional end line, when we want to chop more     *                           than one line.     *     * @return array The chopped lines     */    function _getLines(&$text_lines, &$line_no, $end = false)    {        if (!empty($end)) {            $lines = array();            // We can shift even more            while ($line_no <= $end) {                array_push($lines, array_shift($text_lines));                $line_no++;            }        } else {            $lines = array(array_shift($text_lines));            $line_no++;        }        return $lines;    }}
<?php/** * Link/Bookmark API * * @package WordPress * @subpackage Bookmark *//** * Retrieve Bookmark data based on ID * * @since 2.1.0 * @uses $wpdb Database Object * * @param int $bookmark_id * @param string $output Optional. Either OBJECT, ARRAY_N, or ARRAY_A constant * @param string $filter Optional, default is 'raw'. * @return array|object Type returned depends on $output value. */function get_bookmark($bookmark, $output = OBJECT, $filter = 'raw') {	global $wpdb;	if ( empty($bookmark) ) {		if ( isset($GLOBALS['link']) )			$_bookmark = & $GLOBALS['link'];		else			$_bookmark = null;	} elseif ( is_object($bookmark) ) {		wp_cache_add($bookmark->link_id, $bookmark, 'bookmark');		$_bookmark = $bookmark;	} else {		if ( isset($GLOBALS['link']) && ($GLOBALS['link']->link_id == $bookmark) ) {			$_bookmark = & $GLOBALS['link'];		} elseif ( ! $_bookmark = wp_cache_get($bookmark, 'bookmark') ) {			$_bookmark = $wpdb->get_row($wpdb->prepare("SELECT * FROM $wpdb->links WHERE link_id = %d LIMIT 1", $bookmark));			$_bookmark->link_category = array_unique( wp_get_object_terms($_bookmark->link_id, 'link_category', array('fields' => 'ids')) );			wp_cache_add($_bookmark->link_id, $_bookmark, 'bookmark');		}	}	$_bookmark = sanitize_bookmark($_bookmark, $filter);	if ( $output == OBJECT ) {		return $_bookmark;	} elseif ( $output == ARRAY_A ) {		return get_object_vars($_bookmark);	} elseif ( $output == ARRAY_N ) {		return array_values(get_object_vars($_bookmark));	} else {		return $_bookmark;	}}/** * Retrieve single bookmark data item or field. * * @since 2.3.0 * @uses get_bookmark() Gets bookmark object using $bookmark as ID * @uses sanitize_bookmark_field() Sanitizes Bookmark field based on $context. * * @param string $field The name of the data field to return * @param int $bookmark The bookmark ID to get field * @param string $context Optional. The context of how the field will be used. * @return string */function get_bookmark_field( $field, $bookmark, $context = 'display' ) {	$bookmark = (int) $bookmark;	$bookmark = get_bookmark( $bookmark );	if ( is_wp_error($bookmark) )		return $bookmark;	if ( !is_object($bookmark) )		return '';	if ( !isset($bookmark->$field) )		return '';	return sanitize_bookmark_field($field, $bookmark->$field, $bookmark->link_id, $context);}/** * Retrieves the list of bookmarks * * Attempts to retrieve from the cache first based on MD5 hash of arguments. If * that fails, then the query will be built from the arguments and executed. The * results will be stored to the cache. * * List of default arguments are as follows: * 'orderby' - Default is 'name' (string). How to order the links by. String is *		based off of the bookmark scheme. * 'order' - Default is 'ASC' (string). Either 'ASC' or 'DESC'. Orders in either *		ascending or descending order. * 'limit' - Default is -1 (integer) or show all. The amount of bookmarks to *		display. * 'category' - Default is empty string (string). Include the links in what *		category ID(s). * 'category_name' - Default is empty string (string). Get links by category *		name. * 'hide_invisible' - Default is 1 (integer). Whether to show (default) or hide *		links marked as 'invisible'. * 'show_updated' - Default is 0 (integer). Will show the time of when the *		bookmark was last updated. * 'include' - Default is empty string (string). Include other categories *		separated by commas. * 'exclude' - Default is empty string (string). Exclude other categories *		separated by commas. * * @since 2.1.0 * @uses $wpdb Database Object * @link http://codex.wordpress.org/Template_Tags/get_bookmarks * * @param string|array $args List of arguments to overwrite the defaults * @return array List of bookmark row objects */function get_bookmarks($args = '') {	global $wpdb;	$defaults = array(		'orderby' => 'name', 'order' => 'ASC',		'limit' => -1, 'category' => '',		'category_name' => '', 'hide_invisible' => 1,		'show_updated' => 0, 'include' => '',		'exclude' => '', 'search' => ''	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	$cache = array();	$key = md5( serialize( $r ) );	if ( $cache = wp_cache_get( 'get_bookmarks', 'bookmark' ) ) {		if ( is_array($cache) && isset( $cache[ $key ] ) )			return apply_filters('get_bookmarks', $cache[ $key ], $r );	}	if ( !is_array($cache) )		$cache = array();	$inclusions = '';	if ( !empty($include) ) {		$exclude = '';  //ignore exclude, category, and category_name params if using include		$category = '';		$category_name = '';		$inclinks = preg_split('/[\s,]+/',$include);		if ( count($inclinks) ) {			foreach ( $inclinks as $inclink ) {				if (empty($inclusions))					$inclusions = ' AND ( link_id = ' . intval($inclink) . ' ';				else					$inclusions .= ' OR link_id = ' . intval($inclink) . ' ';			}		}	}	if (!empty($inclusions))		$inclusions .= ')';	$exclusions = '';	if ( !empty($exclude) ) {		$exlinks = preg_split('/[\s,]+/',$exclude);		if ( count($exlinks) ) {			foreach ( $exlinks as $exlink ) {				if (empty($exclusions))					$exclusions = ' AND ( link_id <> ' . intval($exlink) . ' ';				else					$exclusions .= ' AND link_id <> ' . intval($exlink) . ' ';			}		}	}	if (!empty($exclusions))		$exclusions .= ')';	if ( !empty($category_name) ) {		if ( $category = get_term_by('name', $category_name, 'link_category') ) {			$category = $category->term_id;		} else {			$cache[ $key ] = array();			wp_cache_set( 'get_bookmarks', $cache, 'bookmark' );			return apply_filters( 'get_bookmarks', array(), $r );		}	}	if ( ! empty($search) ) {		$search = like_escape($search);		$search = " AND ( (link_url LIKE '%$search%') OR (link_name LIKE '%$search%') OR (link_description LIKE '%$search%') ) ";	}	$category_query = '';	$join = '';	if ( !empty($category) ) {		$incategories = preg_split('/[\s,]+/',$category);		if ( count($incategories) ) {			foreach ( $incategories as $incat ) {				if (empty($category_query))					$category_query = ' AND ( tt.term_id = ' . intval($incat) . ' ';				else					$category_query .= ' OR tt.term_id = ' . intval($incat) . ' ';			}		}	}	if (!empty($category_query)) {		$category_query .= ") AND taxonomy = 'link_category'";		$join = " INNER JOIN $wpdb->term_relationships AS tr ON ($wpdb->links.link_id = tr.object_id) INNER JOIN $wpdb->term_taxonomy as tt ON tt.term_taxonomy_id = tr.term_taxonomy_id";	}	if ( $show_updated && get_option('links_recently_updated_time') ) {		$recently_updated_test = ", IF (DATE_ADD(link_updated, INTERVAL " . get_option('links_recently_updated_time') . " MINUTE) >= NOW(), 1,0) as recently_updated ";	} else {		$recently_updated_test = '';	}	$get_updated = ( $show_updated ) ? ', UNIX_TIMESTAMP(link_updated) AS link_updated_f ' : '';	$orderby = strtolower($orderby);	$length = '';	switch ($orderby) {		case 'length':			$length = ", CHAR_LENGTH(link_name) AS length";			break;		case 'rand':			$orderby = 'rand()';			break;		default:			$orderparams = array();			foreach ( explode(',', $orderby) as $ordparam )				$orderparams[] = 'link_' . trim($ordparam);			$orderby = implode(',', $orderparams);	}	if ( 'link_id' == $orderby )		$orderby = "$wpdb->links.link_id";	$visible = '';	if ( $hide_invisible )		$visible = "AND link_visible = 'Y'";	$query = "SELECT * $length $recently_updated_test $get_updated FROM $wpdb->links $join WHERE 1=1 $visible $category_query";	$query .= " $exclusions $inclusions $search";	$query .= " ORDER BY $orderby $order";	if ($limit != -1)		$query .= " LIMIT $limit";	$results = $wpdb->get_results($query);	$cache[ $key ] = $results;	wp_cache_set( 'get_bookmarks', $cache, 'bookmark' );	return apply_filters('get_bookmarks', $results, $r);}/** * Sanitizes all bookmark fields * * @since 2.3.0 * * @param object|array $bookmark Bookmark row * @param string $context Optional, default is 'display'. How to filter the *		fields * @return object|array Same type as $bookmark but with fields sanitized. */function sanitize_bookmark($bookmark, $context = 'display') {	$fields = array('link_id', 'link_url', 'link_name', 'link_image', 'link_target', 'link_category',		'link_description', 'link_visible', 'link_owner', 'link_rating', 'link_updated',		'link_rel', 'link_notes', 'link_rss', );	if ( is_object($bookmark) ) {		$do_object = true;		$link_id = $bookmark->link_id;	} else {		$do_object = false;		$link_id = $bookmark['link_id'];	}	foreach ( $fields as $field ) {		if ( $do_object ) {			if ( isset($bookmark->$field) )				$bookmark->$field = sanitize_bookmark_field($field, $bookmark->$field, $link_id, $context);		} else {			if ( isset($bookmark[$field]) )				$bookmark[$field] = sanitize_bookmark_field($field, $bookmark[$field], $link_id, $context);		}	}	return $bookmark;}/** * Sanitizes a bookmark field * * Sanitizes the bookmark fields based on what the field name is. If the field * has a strict value set, then it will be tested for that, else a more generic * filtering is applied. After the more strict filter is applied, if the * $context is 'raw' then the value is immediately return. * * Hooks exist for the more generic cases. With the 'edit' context, the * 'edit_$field' filter will be called and passed the $value and $bookmark_id * respectively. With the 'db' context, the 'pre_$field' filter is called and * passed the value. The 'display' context is the final context and has the * $field has the filter name and is passed the $value, $bookmark_id, and * $context respectively. * * @since 2.3.0 * * @param string $field The bookmark field * @param mixed $value The bookmark field value * @param int $bookmark_id Bookmark ID * @param string $context How to filter the field value. Either 'raw', 'edit', *		'attribute', 'js', 'db', or 'display' * @return mixed The filtered value */function sanitize_bookmark_field($field, $value, $bookmark_id, $context) {	switch ( $field ) {	case 'link_id' : // ints	case 'link_rating' :		$value = (int) $value;		break;	case 'link_category' : // array( ints )		$value = array_map('absint', (array) $value);		// We return here so that the categories aren't filtered.		// The 'link_category' filter is for the name of a link category, not an array of a link's link categories		return $value;		break;	case 'link_visible' : // bool stored as Y|N		$value = preg_replace('/[^YNyn]/', '', $value);		break;	case 'link_target' : // "enum"		$targets = array('_top', '_blank');		if ( ! in_array($value, $targets) )			$value = '';		break;	}	if ( 'raw' == $context )		return $value;	if ( 'edit' == $context ) {		$format_to_edit = array('link_notes');		$value = apply_filters("edit_$field", $value, $bookmark_id);		if ( in_array($field, $format_to_edit) ) {			$value = format_to_edit($value);		} else {			$value = esc_attr($value);		}	} else if ( 'db' == $context ) {		$value = apply_filters("pre_$field", $value);	} else {		// Use display filters by default.		$value = apply_filters($field, $value, $bookmark_id, $context);		if ( 'attribute' == $context )			$value = esc_attr($value);		else if ( 'js' == $context )			$value = esc_js($value);	}	return $value;}/** * Deletes bookmark cache * * @since 2.7.0 * @uses wp_cache_delete() Deletes the contents of 'get_bookmarks' */function clean_bookmark_cache($bookmark_id) {	wp_cache_delete( $bookmark_id, 'bookmark' );	wp_cache_delete( 'get_bookmarks', 'bookmark' );}?>
<?php/** * Add Link Administration Panel. * * @package WordPress * @subpackage Administration *//** Load WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can('manage_links') )	wp_die(__('You do not have sufficient permissions to add links to this site.'));$title = __('Add New Link');$parent_file = 'link-manager.php';wp_reset_vars(array('action', 'cat_id', 'linkurl', 'name', 'image',	'description', 'visible', 'target', 'category', 'link_id',	'submit', 'order_by', 'links_show_cat_id', 'rating', 'rel',	'notes', 'linkcheck[]'));wp_enqueue_script('link');wp_enqueue_script('xfn');$link = get_default_link_to_edit();include('./edit-link-form.php');require('./admin-footer.php');?>
<?php/** * BackPress Styles enqueue. * * These classes were refactored from the WordPress WP_Scripts and WordPress * script enqueue API. * * @package BackPress * @since r74 *//** * BackPress Styles enqueue class. * * @package BackPress * @uses WP_Dependencies * @since r74 */class WP_Styles extends WP_Dependencies {	var $base_url;	var $content_url;	var $default_version;	var $text_direction = 'ltr';	var $concat = '';	var $concat_version = '';	var $do_concat = false;	var $print_html = '';	var $default_dirs;	function __construct() {		do_action_ref_array( 'wp_default_styles', array(&$this) );	}	function do_item( $handle ) {		if ( !parent::do_item($handle) )			return false;		if ( null === $this->registered[$handle]->ver )			$ver = '';		else			$ver = $this->registered[$handle]->ver ? $this->registered[$handle]->ver : $this->default_version;		if ( isset($this->args[$handle]) )			$ver = $ver ? $ver . '&amp;' . $this->args[$handle] : $this->args[$handle];		if ( $this->do_concat ) {			if ( $this->in_default_dir($this->registered[$handle]->src) && !isset($this->registered[$handle]->extra['conditional']) && !isset($this->registered[$handle]->extra['alt']) ) {				$this->concat .= "$handle,";				$this->concat_version .= "$handle$ver";				return true;			}		}		if ( isset($this->registered[$handle]->args) )			$media = esc_attr( $this->registered[$handle]->args );		else			$media = 'all';		$href = $this->_css_href( $this->registered[$handle]->src, $ver, $handle );		$rel = isset($this->registered[$handle]->extra['alt']) && $this->registered[$handle]->extra['alt'] ? 'alternate stylesheet' : 'stylesheet';		$title = isset($this->registered[$handle]->extra['title']) ? "title='" . esc_attr( $this->registered[$handle]->extra['title'] ) . "'" : '';		$end_cond = $tag = '';		if ( isset($this->registered[$handle]->extra['conditional']) && $this->registered[$handle]->extra['conditional'] ) {			$tag .= "<!--[if {$this->registered[$handle]->extra['conditional']}]>\n";			$end_cond = "<![endif]-->\n";		}		$tag .= apply_filters( 'style_loader_tag', "<link rel='$rel' id='$handle-css' $title href='$href' type='text/css' media='$media' />\n", $handle );		if ( 'rtl' === $this->text_direction && isset($this->registered[$handle]->extra['rtl']) && $this->registered[$handle]->extra['rtl'] ) {			if ( is_bool( $this->registered[$handle]->extra['rtl'] ) ) {				$suffix = isset( $this->registered[$handle]->extra['suffix'] ) ? $this->registered[$handle]->extra['suffix'] : '';				$rtl_href = str_replace( "{$suffix}.css", "-rtl{$suffix}.css", $this->_css_href( $this->registered[$handle]->src , $ver, "$handle-rtl" ));			} else {				$rtl_href = $this->_css_href( $this->registered[$handle]->extra['rtl'], $ver, "$handle-rtl" );			}			$tag .= apply_filters( 'style_loader_tag', "<link rel='$rel' id='$handle-rtl-css' $title href='$rtl_href' type='text/css' media='$media' />\n", $handle );		}		$tag .= $end_cond;		if ( $this->do_concat )			$this->print_html .= $tag;		else			echo $tag;		// Could do something with $this->registered[$handle]->extra here to print out extra CSS rules//		echo "<style type='text/css'>\n";//		echo "/* <![CDATA[ */\n";//		echo "/* ]]> */\n";//		echo "</style>\n";		return true;	}	function all_deps( $handles, $recursion = false, $group = false ) {		$r = parent::all_deps( $handles, $recursion );		if ( !$recursion )			$this->to_do = apply_filters( 'print_styles_array', $this->to_do );		return $r;	}	function _css_href( $src, $ver, $handle ) {		if ( !is_bool($src) && !preg_match('|^https?://|', $src) && ! ( $this->content_url && 0 === strpos($src, $this->content_url) ) ) {			$src = $this->base_url . $src;		}		if ( !empty($ver) )			$src = add_query_arg('ver', $ver, $src);		$src = apply_filters( 'style_loader_src', $src, $handle );		return esc_url( $src );	}	function in_default_dir($src) {		if ( ! $this->default_dirs )			return true;		foreach ( (array) $this->default_dirs as $test ) {			if ( 0 === strpos($src, $test) )				return true;		}		return false;	}}
<?php/** * PemFTP - A Ftp implementation in pure PHP * * @package PemFTP * @since 2.5 * * @version 1.0 * @copyright Alexey Dotsenko * @author Alexey Dotsenko * @link http://www.phpclasses.org/browse/package/1743.html Site * @license LGPL License http://www.opensource.org/licenses/lgpl-license.html *//** * Socket Based FTP implementation * * @package PemFTP * @subpackage Socket * @since 2.5 * * @version 1.0 * @copyright Alexey Dotsenko * @author Alexey Dotsenko * @link http://www.phpclasses.org/browse/package/1743.html Site * @license LGPL License http://www.opensource.org/licenses/lgpl-license.html */class ftp extends ftp_base {	function ftp($verb=FALSE, $le=FALSE) {		$this->__construct($verb, $le);	}	function __construct($verb=FALSE, $le=FALSE) {		parent::__construct(true, $verb, $le);	}// <!-- --------------------------------------------------------------------------------------- -->// <!--       Private functions                                                                 -->// <!-- --------------------------------------------------------------------------------------- -->	function _settimeout($sock) {		if(!@socket_set_option($sock, SOL_SOCKET, SO_RCVTIMEO, array("sec"=>$this->_timeout, "usec"=>0))) {			$this->PushError('_connect','socket set receive timeout',socket_strerror(socket_last_error($sock)));			@socket_close($sock);			return FALSE;		}		if(!@socket_set_option($sock, SOL_SOCKET , SO_SNDTIMEO, array("sec"=>$this->_timeout, "usec"=>0))) {			$this->PushError('_connect','socket set send timeout',socket_strerror(socket_last_error($sock)));			@socket_close($sock);			return FALSE;		}		return true;	}	function _connect($host, $port) {		$this->SendMSG("Creating socket");		if(!($sock = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP))) {			$this->PushError('_connect','socket create failed',socket_strerror(socket_last_error($sock)));			return FALSE;		}		if(!$this->_settimeout($sock)) return FALSE;		$this->SendMSG("Connecting to \"".$host.":".$port."\"");		if (!($res = @socket_connect($sock, $host, $port))) {			$this->PushError('_connect','socket connect failed',socket_strerror(socket_last_error($sock)));			@socket_close($sock);			return FALSE;		}		$this->_connected=true;		return $sock;	}	function _readmsg($fnction="_readmsg"){		if(!$this->_connected) {			$this->PushError($fnction,'Connect first');			return FALSE;		}		$result=true;		$this->_message="";		$this->_code=0;		$go=true;		do {			$tmp=@socket_read($this->_ftp_control_sock, 4096, PHP_BINARY_READ);			if($tmp===false) {				$go=$result=false;				$this->PushError($fnction,'Read failed', socket_strerror(socket_last_error($this->_ftp_control_sock)));			} else {				$this->_message.=$tmp;				$go = !preg_match("/^([0-9]{3})(-.+\\1)? [^".CRLF."]+".CRLF."$/Us", $this->_message, $regs);			}		} while($go);		if($this->LocalEcho) echo "GET < ".rtrim($this->_message, CRLF).CRLF;		$this->_code=(int)$regs[1];		return $result;	}	function _exec($cmd, $fnction="_exec") {		if(!$this->_ready) {			$this->PushError($fnction,'Connect first');			return FALSE;		}		if($this->LocalEcho) echo "PUT > ",$cmd,CRLF;		$status=@socket_write($this->_ftp_control_sock, $cmd.CRLF);		if($status===false) {			$this->PushError($fnction,'socket write failed', socket_strerror(socket_last_error($this->stream)));			return FALSE;		}		$this->_lastaction=time();		if(!$this->_readmsg($fnction)) return FALSE;		return TRUE;	}	function _data_prepare($mode=FTP_ASCII) {		if(!$this->_settype($mode)) return FALSE;		$this->SendMSG("Creating data socket");		$this->_ftp_data_sock = @socket_create(AF_INET, SOCK_STREAM, SOL_TCP);		if ($this->_ftp_data_sock < 0) {			$this->PushError('_data_prepare','socket create failed',socket_strerror(socket_last_error($this->_ftp_data_sock)));			return FALSE;		}		if(!$this->_settimeout($this->_ftp_data_sock)) {			$this->_data_close();			return FALSE;		}		if($this->_passive) {			if(!$this->_exec("PASV", "pasv")) {				$this->_data_close();				return FALSE;			}			if(!$this->_checkCode()) {				$this->_data_close();				return FALSE;			}			$ip_port = explode(",", ereg_replace("^.+ \\(?([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},[0-9]{1,3},[0-9]+,[0-9]+)\\)?.*".CRLF."$", "\\1", $this->_message));			$this->_datahost=$ip_port[0].".".$ip_port[1].".".$ip_port[2].".".$ip_port[3];            $this->_dataport=(((int)$ip_port[4])<<8) + ((int)$ip_port[5]);			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			if(!@socket_connect($this->_ftp_data_sock, $this->_datahost, $this->_dataport)) {				$this->PushError("_data_prepare","socket_connect", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			else $this->_ftp_temp_sock=$this->_ftp_data_sock;		} else {			if(!@socket_getsockname($this->_ftp_control_sock, $addr, $port)) {				$this->PushError("_data_prepare","can't get control socket information", socket_strerror(socket_last_error($this->_ftp_control_sock)));				$this->_data_close();				return FALSE;			}			if(!@socket_bind($this->_ftp_data_sock,$addr)){				$this->PushError("_data_prepare","can't bind data socket", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			if(!@socket_listen($this->_ftp_data_sock)) {				$this->PushError("_data_prepare","can't listen data socket", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			if(!@socket_getsockname($this->_ftp_data_sock, $this->_datahost, $this->_dataport)) {				$this->PushError("_data_prepare","can't get data socket information", socket_strerror(socket_last_error($this->_ftp_data_sock)));				$this->_data_close();				return FALSE;			}			if(!$this->_exec('PORT '.str_replace('.',',',$this->_datahost.'.'.($this->_dataport>>8).'.'.($this->_dataport&0x00FF)), "_port")) {				$this->_data_close();				return FALSE;			}			if(!$this->_checkCode()) {				$this->_data_close();				return FALSE;			}		}		return TRUE;	}	function _data_read($mode=FTP_ASCII, $fp=NULL) {		$NewLine=$this->_eol_code[$this->OS_local];		if(is_resource($fp)) $out=0;		else $out="";		if(!$this->_passive) {			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			$this->_ftp_temp_sock=socket_accept($this->_ftp_data_sock);			if($this->_ftp_temp_sock===FALSE) {				$this->PushError("_data_read","socket_accept", socket_strerror(socket_last_error($this->_ftp_temp_sock)));				$this->_data_close();				return FALSE;			}		}		while(($block=@socket_read($this->_ftp_temp_sock, $this->_ftp_buff_size, PHP_BINARY_READ))!==false) {			if($block==="") break;			if($mode!=FTP_BINARY) $block=preg_replace("/\r\n|\r|\n/", $this->_eol_code[$this->OS_local], $block);			if(is_resource($fp)) $out+=fwrite($fp, $block, strlen($block));			else $out.=$block;		}		return $out;	}	function _data_write($mode=FTP_ASCII, $fp=NULL) {		$NewLine=$this->_eol_code[$this->OS_local];		if(is_resource($fp)) $out=0;		else $out="";		if(!$this->_passive) {			$this->SendMSG("Connecting to ".$this->_datahost.":".$this->_dataport);			$this->_ftp_temp_sock=socket_accept($this->_ftp_data_sock);			if($this->_ftp_temp_sock===FALSE) {				$this->PushError("_data_write","socket_accept", socket_strerror(socket_last_error($this->_ftp_temp_sock)));				$this->_data_close();				return false;			}		}		if(is_resource($fp)) {			while(!feof($fp)) {				$block=fread($fp, $this->_ftp_buff_size);				if(!$this->_data_write_block($mode, $block)) return false;			}		} elseif(!$this->_data_write_block($mode, $fp)) return false;		return true;	}	function _data_write_block($mode, $block) {		if($mode!=FTP_BINARY) $block=preg_replace("/\r\n|\r|\n/", $this->_eol_code[$this->OS_remote], $block);		do {			if(($t=@socket_write($this->_ftp_temp_sock, $block))===FALSE) {				$this->PushError("_data_write","socket_write", socket_strerror(socket_last_error($this->_ftp_temp_sock)));				$this->_data_close();				return FALSE;			}			$block=substr($block, $t);		} while(!empty($block));		return true;	}	function _data_close() {		@socket_close($this->_ftp_temp_sock);		@socket_close($this->_ftp_data_sock);		$this->SendMSG("Disconnected data from remote host");		return TRUE;	}	function _quit() {		if($this->_connected) {			@socket_close($this->_ftp_control_sock);			$this->_connected=false;			$this->SendMSG("Socket closed");		}	}}?>
<?php/** * Parse OPML XML files and store in globals. * * @package WordPress * @subpackage Administration */if ( ! defined('ABSPATH') )	die();global $opml, $map;// columns we wish to find are:  link_url, link_name, link_target, link_description// we need to map XML attribute names to our columns$opml_map = array('URL'         => 'link_url',	'HTMLURL'     => 'link_url',	'TEXT'        => 'link_name',	'TITLE'       => 'link_name',	'TARGET'      => 'link_target',	'DESCRIPTION' => 'link_description',	'XMLURL'      => 'link_rss');$map = $opml_map;/** * XML callback function for the start of a new XML tag. * * @since unknown * @access private * * @uses $updated_timestamp Not used inside function. * @uses $all_links Not used inside function. * @uses $map Stores names of attributes to use. * @global array $names * @global array $urls * @global array $targets * @global array $descriptions * @global array $feeds * * @param mixed $parser XML Parser resource. * @param string $tagName XML element name. * @param array $attrs XML element attributes. */function startElement($parser, $tagName, $attrs) {	global $updated_timestamp, $all_links, $map;	global $names, $urls, $targets, $descriptions, $feeds;	if ($tagName == 'OUTLINE') {		foreach (array_keys($map) as $key) {			if (isset($attrs[$key])) {				$$map[$key] = $attrs[$key];			}		}		//echo("got data: link_url = [$link_url], link_name = [$link_name], link_target = [$link_target], link_description = [$link_description]<br />\n");		// save the data away.		$names[] = $link_name;		$urls[] = $link_url;		$targets[] = $link_target;		$feeds[] = $link_rss;		$descriptions[] = $link_description;	} // end if outline}/** * XML callback function that is called at the end of a XML tag. * * @since unknown * @access private * @package WordPress * @subpackage Dummy * * @param mixed $parser XML Parser resource. * @param string $tagName XML tag name. */function endElement($parser, $tagName) {	// nothing to do.}// Create an XML parser$xml_parser = xml_parser_create();// Set the functions to handle opening and closing tagsxml_set_element_handler($xml_parser, "startElement", "endElement");if (!xml_parse($xml_parser, $opml, true)) {	echo(sprintf(__('XML error: %1$s at line %2$s'),	xml_error_string(xml_get_error_code($xml_parser)),	xml_get_current_line_number($xml_parser)));}// Free up memory used by the XML parserxml_parser_free($xml_parser);?>
<?php/** * WordPress Diff bastard child of old MediaWiki Diff Formatter. * * Basically all that remains is the table structure and some method names. * * @package WordPress * @subpackage Diff */if ( !class_exists( 'Text_Diff' ) ) {	/** Text_Diff class */	require( dirname(__FILE__).'/Text/Diff.php' );	/** Text_Diff_Renderer class */	require( dirname(__FILE__).'/Text/Diff/Renderer.php' );	/** Text_Diff_Renderer_inline class */	require( dirname(__FILE__).'/Text/Diff/Renderer/inline.php' );}/** * Table renderer to display the diff lines. * * @since 2.6.0 * @uses Text_Diff_Renderer Extends */class WP_Text_Diff_Renderer_Table extends Text_Diff_Renderer {	/**	 * @see Text_Diff_Renderer::_leading_context_lines	 * @var int	 * @access protected	 * @since 2.6.0	 */	var $_leading_context_lines  = 10000;	/**	 * @see Text_Diff_Renderer::_trailing_context_lines	 * @var int	 * @access protected	 * @since 2.6.0	 */	var $_trailing_context_lines = 10000;	/**	 * {@internal Missing Description}}	 *	 * @var float	 * @access protected	 * @since 2.6.0	 */	var $_diff_threshold = 0.6;	/**	 * Inline display helper object name.	 *	 * @var string	 * @access protected	 * @since 2.6.0	 */	var $inline_diff_renderer = 'WP_Text_Diff_Renderer_inline';	/**	 * PHP4 Constructor - Call parent constructor with params array.	 *	 * This will set class properties based on the key value pairs in the array.	 *	 * @since unknown	 *	 * @param array $params	 */	function Text_Diff_Renderer_Table( $params = array() ) {		$parent = get_parent_class($this);		$this->$parent( $params );	}	/**	 * @ignore	 *	 * @param string $header	 * @return string	 */	function _startBlock( $header ) {		return '';	}	/**	 * @ignore	 *	 * @param array $lines	 * @param string $prefix	 */	function _lines( $lines, $prefix=' ' ) {	}	/**	 * @ignore	 *	 * @param string $line HTML-escape the value.	 * @return string	 */	function addedLine( $line ) {		return "<td>+</td><td class='diff-addedline'>{$line}</td>";	}	/**	 * @ignore	 *	 * @param string $line HTML-escape the value.	 * @return string	 */	function deletedLine( $line ) {		return "<td>-</td><td class='diff-deletedline'>{$line}</td>";	}	/**	 * @ignore	 *	 * @param string $line HTML-escape the value.	 * @return string	 */	function contextLine( $line ) {		return "<td> </td><td class='diff-context'>{$line}</td>";	}	/**	 * @ignore	 *	 * @return string	 */	function emptyLine() {		return '<td colspan="2">&nbsp;</td>';	}	/**	 * @ignore	 * @access private	 *	 * @param array $lines	 * @param bool $encode	 * @return string	 */	function _added( $lines, $encode = true ) {		$r = '';		foreach ($lines as $line) {			if ( $encode )				$line = htmlspecialchars( $line );			$r .= '<tr>' . $this->emptyLine() . $this->addedLine( $line ) . "</tr>\n";		}		return $r;	}	/**	 * @ignore	 * @access private	 *	 * @param array $lines	 * @param bool $encode	 * @return string	 */	function _deleted( $lines, $encode = true ) {		$r = '';		foreach ($lines as $line) {			if ( $encode )				$line = htmlspecialchars( $line );			$r .= '<tr>' . $this->deletedLine( $line ) . $this->emptyLine() . "</tr>\n";		}		return $r;	}	/**	 * @ignore	 * @access private	 *	 * @param array $lines	 * @param bool $encode	 * @return string	 */	function _context( $lines, $encode = true ) {		$r = '';		foreach ($lines as $line) {			if ( $encode )				$line = htmlspecialchars( $line );			$r .= '<tr>' .				$this->contextLine( $line ) . $this->contextLine( $line ) . "</tr>\n";		}		return $r;	}	/**	 * Process changed lines to do word-by-word diffs for extra highlighting.	 *	 * (TRAC style) sometimes these lines can actually be deleted or added rows.	 * We do additional processing to figure that out	 *	 * @access private	 * @since 2.6.0	 *	 * @param array $orig	 * @param array $final	 * @return string	 */	function _changed( $orig, $final ) {		$r = '';		// Does the aforementioned additional processing		// *_matches tell what rows are "the same" in orig and final.  Those pairs will be diffed to get word changes		//	match is numeric: an index in other column		//	match is 'X': no match.  It is a new row		// *_rows are column vectors for the orig column and the final column.		//	row >= 0: an indix of the $orig or $final array		//	row  < 0: a blank row for that column		list($orig_matches, $final_matches, $orig_rows, $final_rows) = $this->interleave_changed_lines( $orig, $final );		// These will hold the word changes as determined by an inline diff		$orig_diffs  = array();		$final_diffs = array();		// Compute word diffs for each matched pair using the inline diff		foreach ( $orig_matches as $o => $f ) {			if ( is_numeric($o) && is_numeric($f) ) {				$text_diff = new Text_Diff( 'auto', array( array($orig[$o]), array($final[$f]) ) );				$renderer = new $this->inline_diff_renderer;				$diff = $renderer->render( $text_diff );				// If they're too different, don't include any <ins> or <dels>				if ( $diff_count = preg_match_all( '!(<ins>.*?</ins>|<del>.*?</del>)!', $diff, $diff_matches ) ) {					// length of all text between <ins> or <del>					$stripped_matches = strlen(strip_tags( join(' ', $diff_matches[0]) ));					// since we count lengith of text between <ins> or <del> (instead of picking just one),					//	we double the length of chars not in those tags.					$stripped_diff = strlen(strip_tags( $diff )) * 2 - $stripped_matches;					$diff_ratio = $stripped_matches / $stripped_diff;					if ( $diff_ratio > $this->_diff_threshold )						continue; // Too different.  Don't save diffs.				}				// Un-inline the diffs by removing del or ins				$orig_diffs[$o]  = preg_replace( '|<ins>.*?</ins>|', '', $diff );				$final_diffs[$f] = preg_replace( '|<del>.*?</del>|', '', $diff );			}		}		foreach ( array_keys($orig_rows) as $row ) {			// Both columns have blanks.  Ignore them.			if ( $orig_rows[$row] < 0 && $final_rows[$row] < 0 )				continue;			// If we have a word based diff, use it.  Otherwise, use the normal line.			if ( isset( $orig_diffs[$orig_rows[$row]] ) )				$orig_line = $orig_diffs[$orig_rows[$row]];			elseif ( isset( $orig[$orig_rows[$row]] ) )				$orig_line = htmlspecialchars($orig[$orig_rows[$row]]);			else				$orig_line = '';			if ( isset( $final_diffs[$final_rows[$row]] ) )				$final_line = $final_diffs[$final_rows[$row]];			elseif ( isset( $final[$final_rows[$row]] ) )				$final_line = htmlspecialchars($final[$final_rows[$row]]);			else				$final_line = '';			if ( $orig_rows[$row] < 0 ) { // Orig is blank.  This is really an added row.				$r .= $this->_added( array($final_line), false );			} elseif ( $final_rows[$row] < 0 ) { // Final is blank.  This is really a deleted row.				$r .= $this->_deleted( array($orig_line), false );			} else { // A true changed row.				$r .= '<tr>' . $this->deletedLine( $orig_line ) . $this->addedLine( $final_line ) . "</tr>\n";			}		}		return $r;	}	/**	 * Takes changed blocks and matches which rows in orig turned into which rows in final.	 *	 * Returns	 *	*_matches ( which rows match with which )	 *	*_rows ( order of rows in each column interleaved with blank rows as	 *		necessary )	 *	 * @since 2.6.0	 *	 * @param unknown_type $orig	 * @param unknown_type $final	 * @return unknown	 */	function interleave_changed_lines( $orig, $final ) {		// Contains all pairwise string comparisons.  Keys are such that this need only be a one dimensional array.		$matches = array();		foreach ( array_keys($orig) as $o ) {			foreach ( array_keys($final) as $f ) {				$matches["$o,$f"] = $this->compute_string_distance( $orig[$o], $final[$f] );			}		}		asort($matches); // Order by string distance.		$orig_matches  = array();		$final_matches = array();		foreach ( $matches as $keys => $difference ) {			list($o, $f) = explode(',', $keys);			$o = (int) $o;			$f = (int) $f;			// Already have better matches for these guys			if ( isset($orig_matches[$o]) && isset($final_matches[$f]) )				continue;			// First match for these guys.  Must be best match			if ( !isset($orig_matches[$o]) && !isset($final_matches[$f]) ) {				$orig_matches[$o] = $f;				$final_matches[$f] = $o;				continue;			}			// Best match of this final is already taken?  Must mean this final is a new row.			if ( isset($orig_matches[$o]) )				$final_matches[$f] = 'x';			// Best match of this orig is already taken?  Must mean this orig is a deleted row.			elseif ( isset($final_matches[$f]) )				$orig_matches[$o] = 'x';		}		// We read the text in this order		ksort($orig_matches);		ksort($final_matches);		// Stores rows and blanks for each column.		$orig_rows = $orig_rows_copy = array_keys($orig_matches);		$final_rows = array_keys($final_matches);		// Interleaves rows with blanks to keep matches aligned.		// We may end up with some extraneous blank rows, but we'll just ignore them later.		foreach ( $orig_rows_copy as $orig_row ) {			$final_pos = array_search($orig_matches[$orig_row], $final_rows, true);			$orig_pos = (int) array_search($orig_row, $orig_rows, true);			if ( false === $final_pos ) { // This orig is paired with a blank final.				array_splice( $final_rows, $orig_pos, 0, -1 );			} elseif ( $final_pos < $orig_pos ) { // This orig's match is up a ways.  Pad final with blank rows.				$diff_pos = $final_pos - $orig_pos;				while ( $diff_pos < 0 )					array_splice( $final_rows, $orig_pos, 0, $diff_pos++ );			} elseif ( $final_pos > $orig_pos ) { // This orig's match is down a ways.  Pad orig with blank rows.				$diff_pos = $orig_pos - $final_pos;				while ( $diff_pos < 0 )					array_splice( $orig_rows, $orig_pos, 0, $diff_pos++ );			}		}		// Pad the ends with blank rows if the columns aren't the same length		$diff_count = count($orig_rows) - count($final_rows);		if ( $diff_count < 0 ) {			while ( $diff_count < 0 )				array_push($orig_rows, $diff_count++);		} elseif ( $diff_count > 0 ) {			$diff_count = -1 * $diff_count;			while ( $diff_count < 0 )				array_push($final_rows, $diff_count++);		}		return array($orig_matches, $final_matches, $orig_rows, $final_rows);/*		// Debug		echo "\n\n\n\n\n";		echo "-- DEBUG Matches: Orig -> Final --";		foreach ( $orig_matches as $o => $f ) {			echo "\n\n\n\n\n";			echo "ORIG: $o, FINAL: $f\n";			var_dump($orig[$o],$final[$f]);		}		echo "\n\n\n\n\n";		echo "-- DEBUG Matches: Final -> Orig --";		foreach ( $final_matches as $f => $o ) {			echo "\n\n\n\n\n";			echo "FINAL: $f, ORIG: $o\n";			var_dump($final[$f],$orig[$o]);		}		echo "\n\n\n\n\n";		echo "-- DEBUG Rows: Orig -- Final --";		echo "\n\n\n\n\n";		foreach ( $orig_rows as $row => $o ) {			if ( $o < 0 )				$o = 'X';			$f = $final_rows[$row];			if ( $f < 0 )				$f = 'X';			echo "$o -- $f\n";		}		echo "\n\n\n\n\n";		echo "-- END DEBUG --";		echo "\n\n\n\n\n";		return array($orig_matches, $final_matches, $orig_rows, $final_rows);*/	}	/**	 * Computes a number that is intended to reflect the "distance" between two strings.	 *	 * @since 2.6.0	 *	 * @param string $string1	 * @param string $string2	 * @return int	 */	function compute_string_distance( $string1, $string2 ) {		// Vectors containing character frequency for all chars in each string		$chars1 = count_chars($string1);		$chars2 = count_chars($string2);		// L1-norm of difference vector.		$difference = array_sum( array_map( array(&$this, 'difference'), $chars1, $chars2 ) );		// $string1 has zero length? Odd.  Give huge penalty by not dividing.		if ( !$string1 )			return $difference;		// Return distance per charcter (of string1)		return $difference / strlen($string1);	}	/**	 * @ignore	 * @since 2.6.0	 *	 * @param int $a	 * @param int $b	 * @return int	 */	function difference( $a, $b ) {		return abs( $a - $b );	}}/** * Better word splitting than the PEAR package provides. * * @since 2.6.0 * @uses Text_Diff_Renderer_inline Extends */class WP_Text_Diff_Renderer_inline extends Text_Diff_Renderer_inline {	/**	 * @ignore	 * @since 2.6.0	 *	 * @param string $string	 * @param string $newlineEscape	 * @return string	 */	function _splitOnWords($string, $newlineEscape = "\n") {		$string = str_replace("\0", '', $string);		$words  = preg_split( '/([^\w])/u', $string, -1, PREG_SPLIT_DELIM_CAPTURE );		$words  = str_replace( "\n", $newlineEscape, $words );		return $words;	}}?>
<?php/** * WordPress Direct Filesystem. * * @package WordPress * @subpackage Filesystem *//** * WordPress Filesystem Class for direct PHP file and folder manipulation. * * @since 2.5 * @package WordPress * @subpackage Filesystem * @uses WP_Filesystem_Base Extends class */class WP_Filesystem_Direct extends WP_Filesystem_Base {	var $errors = null;	/**	 * constructor	 *	 * @param $arg mixed ingored argument	 */	function WP_Filesystem_Direct($arg) {		$this->method = 'direct';		$this->errors = new WP_Error();	}	/**	 * connect filesystem.	 *	 * @return bool Returns true on success or false on failure (always true for WP_Filesystem_Direct).	 */	function connect() {		return true;	}	/**	 * Reads entire file into a string	 *	 * @param $file string Name of the file to read.	 * @return string|bool The function returns the read data or false on failure.	 */	function get_contents($file) {		return @file_get_contents($file);	}	/**	 * Reads entire file into an array	 *	 * @param $file string Path to the file.	 * @return array|bool the file contents in an array or false on failure.	 */	function get_contents_array($file) {		return @file($file);	}	/**	 * Write a string to a file	 *	 * @param $file string Remote path to the file where to write the data.	 * @param $contents string The data to write.	 * @param $mode int (optional) The file permissions as octal number, usually 0644.	 * @return bool False upon failure.	 */	function put_contents($file, $contents, $mode = false ) {		if ( ! ($fp = @fopen($file, 'w')) )			return false;		@fwrite($fp, $contents);		@fclose($fp);		$this->chmod($file, $mode);		return true;	}	/**	 * Gets the current working directory	 *	 * @return string|bool the current working directory on success, or false on failure.	 */	function cwd() {		return @getcwd();	}	/**	 * Change directory	 *	 * @param $dir string The new current directory.	 * @return bool Returns true on success or false on failure.	 */	function chdir($dir) {		return @chdir($dir);	}	/**	 * Changes file group	 *	 * @param $file string Path to the file.	 * @param $group mixed A group name or number.	 * @param $recursive bool (optional) If set True changes file group recursivly. Defaults to False.	 * @return bool Returns true on success or false on failure.	 */	function chgrp($file, $group, $recursive = false) {		if ( ! $this->exists($file) )			return false;		if ( ! $recursive )			return @chgrp($file, $group);		if ( ! $this->is_dir($file) )			return @chgrp($file, $group);		//Is a directory, and we want recursive		$file = trailingslashit($file);		$filelist = $this->dirlist($file);		foreach ($filelist as $filename)			$this->chgrp($file . $filename, $group, $recursive);		return true;	}	/**	 * Changes filesystem permissions	 *	 * @param $file string Path to the file.	 * @param $mode int (optional) The permissions as octal number, usually 0644 for files, 0755 for dirs.	 * @param $recursive bool (optional) If set True changes file group recursivly. Defaults to False.	 * @return bool Returns true on success or false on failure.	 */	function chmod($file, $mode = false, $recursive = false) {		if ( ! $mode ) {			if ( $this->is_file($file) )				$mode = FS_CHMOD_FILE;			elseif ( $this->is_dir($file) )				$mode = FS_CHMOD_DIR;			else				return false;		}		if ( ! $recursive || ! $this->is_dir($file) )			return @chmod($file, $mode);		//Is a directory, and we want recursive		$file = trailingslashit($file);		$filelist = $this->dirlist($file);		foreach ( (array)$filelist as $filename => $filemeta)			$this->chmod($file . $filename, $mode, $recursive);		return true;	}	/**	 * Changes file owner	 *	 * @param $file string Path to the file.	 * @param $owner mixed A user name or number.	 * @param $recursive bool (optional) If set True changes file owner recursivly. Defaults to False.	 * @return bool Returns true on success or false on failure.	 */	function chown($file, $owner, $recursive = false) {		if ( ! $this->exists($file) )			return false;		if ( ! $recursive )			return @chown($file, $owner);		if ( ! $this->is_dir($file) )			return @chown($file, $owner);		//Is a directory, and we want recursive		$filelist = $this->dirlist($file);		foreach ($filelist as $filename) {			$this->chown($file . '/' . $filename, $owner, $recursive);		}		return true;	}	/**	 * Gets file owner	 *	 * @param $file string Path to the file.	 * @return string Username of the user.	 */	function owner($file) {		$owneruid = @fileowner($file);		if ( ! $owneruid )			return false;		if ( ! function_exists('posix_getpwuid') )			return $owneruid;		$ownerarray = posix_getpwuid($owneruid);		return $ownerarray['name'];	}	/**	 * Gets file permissions	 *	 * FIXME does not handle errors in fileperms()	 *	 * @param $file string Path to the file.	 * @return string Mode of the file (last 4 digits).	 */	function getchmod($file) {		return substr(decoct(@fileperms($file)),3);	}	function group($file) {		$gid = @filegroup($file);		if ( ! $gid )			return false;		if ( ! function_exists('posix_getgrgid') )			return $gid;		$grouparray = posix_getgrgid($gid);		return $grouparray['name'];	}	function copy($source, $destination, $overwrite = false) {		if ( ! $overwrite && $this->exists($destination) )			return false;		return copy($source, $destination);	}	function move($source, $destination, $overwrite = false) {		if ( ! $overwrite && $this->exists($destination) )			return false;		// try using rename first.  if that fails (for example, source is read only) try copy		if ( @rename($source, $destination) )			return true;		if ( $this->copy($source, $destination, $overwrite) && $this->exists($destination) ) {			$this->delete($source);			return true;		} else {			return false;		}	}	function delete($file, $recursive = false) {		if ( empty($file) ) //Some filesystems report this as /, which can cause non-expected recursive deletion of all files in the filesystem.			return false;		$file = str_replace('\\', '/', $file); //for win32, occasional problems deleteing files otherwise		if ( $this->is_file($file) )			return @unlink($file);		if ( ! $recursive && $this->is_dir($file) )			return @rmdir($file);		//At this point its a folder, and we're in recursive mode		$file = trailingslashit($file);		$filelist = $this->dirlist($file, true);		$retval = true;		if ( is_array($filelist) ) //false if no files, So check first.			foreach ($filelist as $filename => $fileinfo)				if ( ! $this->delete($file . $filename, $recursive) )					$retval = false;		if ( file_exists($file) && ! @rmdir($file) )			$retval = false;		return $retval;	}	function exists($file) {		return @file_exists($file);	}	function is_file($file) {		return @is_file($file);	}	function is_dir($path) {		return @is_dir($path);	}	function is_readable($file) {		return @is_readable($file);	}	function is_writable($file) {		return @is_writable($file);	}	function atime($file) {		return @fileatime($file);	}	function mtime($file) {		return @filemtime($file);	}	function size($file) {		return @filesize($file);	}	function touch($file, $time = 0, $atime = 0) {		if ($time == 0)			$time = time();		if ($atime == 0)			$atime = time();		return @touch($file, $time, $atime);	}	function mkdir($path, $chmod = false, $chown = false, $chgrp = false) {		// safe mode fails with a trailing slash under certain PHP versions.		$path = untrailingslashit($path);		if ( empty($path) )			$path = '/';		if ( ! $chmod )			$chmod = FS_CHMOD_DIR;		if ( ! @mkdir($path) )			return false;		$this->chmod($path, $chmod);		if ( $chown )			$this->chown($path, $chown);		if ( $chgrp )			$this->chgrp($path, $chgrp);		return true;	}	function rmdir($path, $recursive = false) {		return $this->delete($path, $recursive);	}	function dirlist($path, $include_hidden = true, $recursive = false) {		if ( $this->is_file($path) ) {			$limit_file = basename($path);			$path = dirname($path);		} else {			$limit_file = false;		}		if ( ! $this->is_dir($path) )			return false;		$dir = @dir($path);		if ( ! $dir )			return false;		$ret = array();		while (false !== ($entry = $dir->read()) ) {			$struc = array();			$struc['name'] = $entry;			if ( '.' == $struc['name'] || '..' == $struc['name'] )				continue;			if ( ! $include_hidden && '.' == $struc['name'][0] )				continue;			if ( $limit_file && $struc['name'] != $limit_file)				continue;			$struc['perms'] 	= $this->gethchmod($path.'/'.$entry);			$struc['permsn']	= $this->getnumchmodfromh($struc['perms']);			$struc['number'] 	= false;			$struc['owner']    	= $this->owner($path.'/'.$entry);			$struc['group']    	= $this->group($path.'/'.$entry);			$struc['size']    	= $this->size($path.'/'.$entry);			$struc['lastmodunix']= $this->mtime($path.'/'.$entry);			$struc['lastmod']   = date('M j',$struc['lastmodunix']);			$struc['time']    	= date('h:i:s',$struc['lastmodunix']);			$struc['type']		= $this->is_dir($path.'/'.$entry) ? 'd' : 'f';			if ( 'd' == $struc['type'] ) {				if ( $recursive )					$struc['files'] = $this->dirlist($path . '/' . $struc['name'], $include_hidden, $recursive);				else					$struc['files'] = array();			}			$ret[ $struc['name'] ] = $struc;		}		$dir->close();		unset($dir);		return $ret;	}}?>
<?php/** * @package WordPress * @subpackage Theme_Compat * @deprecated 3.0 *  * This file is here for Backwards compatibility with old themes and will be removed in a future version *  */_deprecated_file( sprintf( __( 'Theme without %1$s' ), basename(__FILE__) ), '3.0', null, sprintf( __('Please include a %1$s template in your theme.'), basename(__FILE__) ) );?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" <?php language_attributes(); ?>><head profile="http://gmpg.org/xfn/11"><meta http-equiv="Content-Type" content="<?php bloginfo('html_type'); ?>; charset=<?php bloginfo('charset'); ?>" /><title><?php wp_title('&laquo;', true, 'right'); ?> <?php bloginfo('name'); ?></title><link rel="stylesheet" href="<?php bloginfo('stylesheet_url'); ?>" type="text/css" media="screen" /><link rel="pingback" href="<?php bloginfo('pingback_url'); ?>" /><style type="text/css" media="screen"><?php// Checks to see whether it needs a sidebarif ( empty($withcomments) && !is_single() ) {?>	#page { background: url("<?php bloginfo('stylesheet_directory'); ?>/images/kubrickbg-<?php bloginfo('text_direction'); ?>.jpg") repeat-y top; border: none; }<?php } else { // No sidebar ?>	#page { background: url("<?php bloginfo('stylesheet_directory'); ?>/images/kubrickbgwide.jpg") repeat-y top; border: none; }<?php } ?></style><?php if ( is_singular() ) wp_enqueue_script( 'comment-reply' ); ?><?php wp_head(); ?></head><body <?php body_class(); ?>><div id="page"><div id="header" role="banner">	<div id="headerimg">		<h1><a href="<?php echo home_url(); ?>/"><?php bloginfo('name'); ?></a></h1>		<div class="description"><?php bloginfo('description'); ?></div>	</div></div><hr />
<?php/** * @package Hello_Dolly * @version 1.5.1 *//*Plugin Name: Hello DollyPlugin URI: http://wordpress.org/#Description: This is not just a plugin, it symbolizes the hope and enthusiasm of an entire generation summed up in two words sung most famously by Louis Armstrong: Hello, Dolly. When activated you will randomly see a lyric from <cite>Hello, Dolly</cite> in the upper right of your admin screen on every page.Author: Matt MullenwegVersion: 1.5.1Author URI: http://ma.tt/*/function hello_dolly_get_lyric() {	/** These are the lyrics to Hello Dolly */	$lyrics = "Hello, DollyWell, hello, DollyIt's so nice to have you back where you belongYou're lookin' swell, DollyI can tell, DollyYou're still glowin', you're still crowin'You're still goin' strongWe feel the room swayin'While the band's playin'One of your old favourite songs from way back whenSo, take her wrap, fellasFind her an empty lap, fellasDolly'll never go away againHello, DollyWell, hello, DollyIt's so nice to have you back where you belongYou're lookin' swell, DollyI can tell, DollyYou're still glowin', you're still crowin'You're still goin' strongWe feel the room swayin'While the band's playin'One of your old favourite songs from way back whenGolly, gee, fellasFind her a vacant knee, fellasDolly'll never go awayDolly'll never go awayDolly'll never go away again";	// Here we split it into lines	$lyrics = explode("\n", $lyrics);	// And then randomly choose a line	return wptexturize( $lyrics[ mt_rand(0, count($lyrics) - 1) ] );}// This just echoes the chosen line, we'll position it laterfunction hello_dolly() {	$chosen = hello_dolly_get_lyric();	echo "<p id='dolly'>$chosen</p>";}// Now we set that function up to execute when the admin_footer action is calledadd_action('admin_footer', 'hello_dolly');// We need some CSS to position the paragraphfunction dolly_css() {	// This makes sure that the posinioning is also good for right-to-left languages	$x = ( is_rtl() ) ? 'left' : 'right';	echo "	<style type='text/css'>	#dolly {		position: absolute;		top: 4.5em;		margin: 0;		padding: 0;		$x: 215px;		font-size: 11px;	}	</style>	";}add_action('admin_head', 'dolly_css');?>
<?php/** * Multisite users administration panel. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */require_once( './admin.php' );if ( !is_multisite() )	wp_die( __( 'Multisite support is not enabled.' ) );if ( ! current_user_can( 'manage_network_users' ) )	wp_die( __( 'You do not have permission to access this page.' ) );$title = __( 'Users' );$parent_file = 'ms-admin.php';add_contextual_help($current_screen,	'<p>' . __('This table shows all users across the network and the sites to which they are assigned.') . '</p>' .	'<p>' . __('Hover over any user on the list to make the edit links appear. The Edit link on the left will take you to his or her Edit User profile page; the Edit link on the right by any site name goes to an Edit Site screen for that site.') . '</p>' .	'<p>' . __('You can also go to the user&#8217;s profile page by clicking on the individual username.') . '</p>' .	'<p>' . __('You can sort the table by clicking on any of the bold headings and switch between list and excerpt views by using the icons in the upper right.') . '</p>' .	'<p>' . __('The bulk action will permanently delete selected users, or mark/unmark those selected as spam. Spam users will have posts removed and will be unable to sign up again with the same email addresses.') . '</p>' .	'<p>' . __('Add User will add that person to this table and send them an email.') . '</p>' .	'<p>' . __('Users who are signed up to the network without a site are added as subscribers to the main or primary dashboard site, giving them profile pages to manage their accounts. These users will only see Dashboard and My Sites in the main navigation until a site is created for them.') . '</p>' .	'<p>' . __('You can make an existing user an additional super admin by going to the Edit User profile page and checking the box to grant that privilege.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Super_Admin_Users_SubPanel" target="_blank">Network Users Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');wp_enqueue_script( 'admin-forms' );require_once( './admin-header.php' );if ( isset( $_GET['updated'] ) && $_GET['updated'] == 'true' && ! empty( $_GET['action'] ) ) {	?>	<div id="message" class="updated"><p>		<?php		switch ( $_GET['action'] ) {			case 'delete':				_e( 'User deleted.' );			break;			case 'all_spam':				_e( 'Users marked as spam.' );			break;			case 'all_notspam':				_e( 'Users removed from spam.' );			break;			case 'all_delete':				_e( 'Users deleted.' );			break;			case 'add':				_e( 'User added.' );			break;		}		?>	</p></div>	<?php}	$pagenum = isset( $_GET['paged'] ) ? absint( $_GET['paged'] ) : 0;	if ( empty( $pagenum ) )		$pagenum = 1;	$per_page = (int) get_user_option( 'ms_users_per_page' );	if ( empty( $per_page ) || $per_page < 1 )		$per_page = 15;	$per_page = apply_filters( 'ms_users_per_page', $per_page );	$s = isset( $_GET['s'] ) ? stripslashes( trim( $_GET[ 's' ] ) ) : '';	$like_s = esc_sql( like_escape( $s ) );	$query = "SELECT * FROM {$wpdb->users}";	if ( !empty( $like_s ) ) {		$query .= " WHERE user_login LIKE '%$like_s%' OR user_email LIKE '%$like_s%'";	}	$order_by = isset( $_GET['sortby'] ) ? $_GET['sortby'] : 'id';	if ( $order_by == 'email' ) {		$query .= ' ORDER BY user_email ';	} elseif ( $order_by == 'login' ) {		$query .= ' ORDER BY user_login ';	} elseif ( $order_by == 'name' ) {		$query .= ' ORDER BY display_name ';	} elseif ( $order_by == 'registered' ) {		$query .= ' ORDER BY user_registered ';	} else {		$order_by = 'id';		$query .= ' ORDER BY ID ';	}	$order = ( isset( $_GET['order'] ) && 'DESC' == $_GET['order'] ) ? 'DESC' : 'ASC';	$query .= $order;	$total = $wpdb->get_var( str_replace( 'SELECT *', 'SELECT COUNT(ID)', $query ) );	$query .= " LIMIT " . intval( ( $pagenum - 1 ) * $per_page) . ", " . intval( $per_page );	$user_list = $wpdb->get_results( $query, ARRAY_A );	$num_pages = ceil( $total / $per_page );	$page_links = paginate_links( array(		'base' => add_query_arg( 'paged', '%#%' ),		'format' => '',		'prev_text' => __( '&laquo;' ),		'next_text' => __( '&raquo;' ),		'total' => $num_pages,		'current' => $pagenum	));	if ( empty( $_GET['mode'] ) )		$mode = 'list';	else		$mode = esc_attr( $_GET['mode'] );	?>	<div class="wrap">	<?php screen_icon(); ?>	<h2><?php esc_html_e( 'Users' ); ?>	<a href="#form-add-user" class="button add-new-h2"><?php echo esc_html_x( 'Add New' , 'users'); ?></a>	<?php	if ( isset( $_GET['s'] ) && $_GET['s'] )	printf( '<span class="subtitle">' . __( 'Search results for &#8220;%s&#8221;' ) . '</span>', esc_html( $s ) );	?>	</h2>	<form action="ms-users.php" method="get" class="search-form">		<p class="search-box">		<input type="text" name="s" value="<?php echo esc_attr( $s ); ?>" class="search-input" id="user-search-input" />		<input type="submit" id="post-query-submit" value="<?php esc_attr_e( 'Search Users' ) ?>" class="button" />		</p>	</form>	<form id="form-user-list" action='ms-edit.php?action=allusers' method='post'>		<input type="hidden" name="mode" value="<?php echo esc_attr( $mode ); ?>" />		<div class="tablenav">			<div class="alignleft actions">				<select name="action">					<option value="-1" selected="selected"><?php _e( 'Bulk Actions' ); ?></option>					<option value="delete"><?php _e( 'Delete' ); ?></option>					<option value="spam"><?php _ex( 'Mark as Spam', 'user' ); ?></option>					<option value="notspam"><?php _ex( 'Not Spam', 'user' ); ?></option>				</select>				<input type="submit" value="<?php esc_attr_e( 'Apply' ); ?>" name="doaction" id="doaction" class="button-secondary action" />				<?php wp_nonce_field( 'bulk-ms-users', '_wpnonce_bulk-ms-users' ); ?>			</div>			<?php if ( $page_links ) { ?>			<div class="tablenav-pages">			<?php $page_links_text = sprintf( '<span class="displaying-num">' . __( 'Displaying %s&#8211;%s of %s' ) . '</span>%s',			number_format_i18n( ( $pagenum - 1 ) * $per_page + 1 ),			number_format_i18n( min( $pagenum * $per_page, $total ) ),			number_format_i18n( $total ),			$page_links			); echo $page_links_text; ?>			</div>			<?php } ?>			<div class="view-switch">				<a href="<?php echo esc_url( add_query_arg( 'mode', 'list', $_SERVER['REQUEST_URI'] ) ) ?>"><img <?php if ( 'list' == $mode ) echo 'class="current"'; ?> id="view-switch-list" src="<?php echo esc_url( includes_url( 'images/blank.gif' ) ); ?>" width="20" height="20" title="<?php _e( 'List View' ) ?>" alt="<?php _e( 'List View' ) ?>" /></a>				<a href="<?php echo esc_url( add_query_arg( 'mode', 'excerpt', $_SERVER['REQUEST_URI'] ) ) ?>"><img <?php if ( 'excerpt' == $mode ) echo 'class="current"'; ?> id="view-switch-excerpt" src="<?php echo esc_url( includes_url( 'images/blank.gif' ) ); ?>" width="20" height="20" title="<?php _e( 'Excerpt View' ) ?>" alt="<?php _e( 'Excerpt View' ) ?>" /></a>			</div>		</div>		<div class="clear"></div>		<?php		// define the columns to display, the syntax is 'internal name' => 'display name'		$users_columns = array(			'id'           => __( 'ID' ),			'login'      => __( 'Username' ),			'name'       => __( 'Name' ),			'email'      => __( 'E-mail' ),			'registered' => _x( 'Registered', 'user' ),			'blogs'      => __( 'Sites' )		);		$users_columns = apply_filters( 'wpmu_users_columns', $users_columns );		?>		<table class="widefat">			<thead>			<tr>				<th class="manage-column column-cb check-column" scope="col">					<input type="checkbox" />				</th>				<?php				$col_url = '';				foreach($users_columns as $column_id => $column_display_name) {					$column_link = "<a href='";					$order2 = '';					if ( $order_by == $column_id )						$order2 = ( $order == 'DESC' ) ? 'ASC' : 'DESC';					$column_link .= esc_url( add_query_arg( array( 'order' => $order2, 'paged' => $pagenum, 'sortby' => $column_id ), remove_query_arg( array( 'action', 'updated' ), $_SERVER['REQUEST_URI'] ) ) );					$column_link .= "'>{$column_display_name}</a>";					$col_url .= '<th scope="col">' . ( $column_id == 'blogs' ? $column_display_name : $column_link ) . '</th>';				}				echo $col_url; ?>			</tr>			</thead>			<tfoot>			<tr>				<th class="manage-column column-cb check-column" scope="col">					<input type="checkbox" />				</th>				<?php echo $col_url; ?>			</tr>			</tfoot>			<tbody id="the-user-list" class="list:user">			<?php if ( $user_list ) {				$class = '';				$super_admins = get_super_admins();				foreach ( (array) $user_list as $user ) {					$class = ( 'alternate' == $class ) ? '' : 'alternate';					$status_list = array( 'spam' => 'site-spammed', 'deleted' => 'site-deleted' );					foreach ( $status_list as $status => $col ) {						if ( $user[$status] )							$class = $col;					}					?>					<tr class="<?php echo $class; ?>">					<?php					foreach( (array) $users_columns as $column_name=>$column_display_name ) :						switch( $column_name ) {							case 'id': ?>								<th scope="row" class="check-column">									<input type="checkbox" id="blog_<?php echo $user['ID'] ?>" name="allusers[]" value="<?php echo esc_attr( $user['ID'] ) ?>" />								</th>								<th valign="top" scope="row">									<?php echo $user['ID'] ?>								</th>							<?php							break;							case 'login':								$avatar	= get_avatar( $user['user_email'], 32 );								$edit_link = ( $current_user->ID == $user['ID'] ) ? 'profile.php' : 'user-edit.php?user_id=' . $user['ID'];								?>								<td class="username column-username">									<?php echo $avatar; ?><strong><a href="<?php echo esc_url( admin_url( $edit_link ) ); ?>" class="edit"><?php echo stripslashes( $user['user_login'] ); ?></a><?php									if ( in_array( $user['user_login'], $super_admins ) )										echo ' - ' . __( 'Super admin' );									?></strong>									<br/>									<div class="row-actions">										<span class="edit"><a href="<?php echo esc_url( admin_url( $edit_link ) ); ?>"><?php _e( 'Edit' ); ?></a></span>										<?php if ( ! in_array( $user['user_login'], $super_admins ) ) { ?>										| <span class="delete"><a href="<?php echo $delete	= esc_url( admin_url( add_query_arg( '_wp_http_referer', urlencode( stripslashes( $_SERVER['REQUEST_URI'] ) ), wp_nonce_url( 'ms-edit.php', 'deleteuser' ) . '&amp;action=deleteuser&amp;id=' . $user['ID'] ) ) ); ?>" class="delete"><?php _e( 'Delete' ); ?></a></span>										<?php } ?>									</div>								</td>							<?php							break;							case 'name': ?>								<td class="name column-name"><?php echo $user['display_name'] ?></td>							<?php							break;							case 'email': ?>								<td class="email column-email"><a href="mailto:<?php echo $user['user_email'] ?>"><?php echo $user['user_email'] ?></a></td>							<?php							break;							case 'registered':								if ( 'list' == $mode )									$date = 'Y/m/d';								else									$date = 'Y/m/d \<\b\r \/\> g:i:s a';							?>								<td><?php echo mysql2date( __( $date ), $user['user_registered'] ); ?></td>							<?php							break;							case 'blogs':								$blogs = get_blogs_of_user( $user['ID'], true );								?>								<td>									<?php									if ( is_array( $blogs ) ) {										foreach ( (array) $blogs as $key => $val ) {											$path	= ( $val->path == '/' ) ? '' : $val->path;											echo '<a href="'. esc_url( admin_url( 'ms-sites.php?action=editblog&amp;id=' . $val->userblog_id  ) ) .'">' . str_replace( '.' . $current_site->domain, '', $val->domain . $path ) . '</a>';											echo ' <small class="row-actions">';											// Edit											echo '<a href="'. esc_url( admin_url( 'ms-sites.php?action=editblog&amp;id=' . $val->userblog_id  ) ) .'">' . __( 'Edit' ) . '</a> | ';											// View											echo '<a ';											if ( get_blog_status( $val->userblog_id, 'spam' ) == 1 )												echo 'style="background-color: #faa" ';											echo 'href="' .  esc_url( get_home_url( $val->userblog_id ) )  . '">' . __( 'View' ) . '</a>';											echo '</small><br />';										}									}									?>								</td>							<?php							break;							default: ?>								<td><?php do_action( 'manage_users_custom_column', $column_name, $user['ID'] ); ?></td>							<?php							break;						}					endforeach					?>					</tr>					<?php				}			} else {			?>				<tr>					<td colspan="<?php echo (int) count($users_columns); ?>"><?php _e( 'No users found.' ) ?></td>				</tr>				<?php			} // end if ($users)			?>			</tbody>		</table>		<div class="tablenav">			<?php			if ( $page_links )				echo "<div class='tablenav-pages'>$page_links_text</div>";			?>			<div class="alignleft actions">				<select name="action2">					<option value="-1" selected="selected"><?php _e( 'Bulk Actions' ); ?></option>					<option value="delete"><?php _e( 'Delete' ); ?></option>					<option value="spam"><?php _ex( 'Mark as Spam', 'user' ); ?></option>					<option value="notspam"><?php _ex( 'Not Spam', 'user' ); ?></option>				</select>				<input type="submit" value="<?php esc_attr_e( 'Apply' ); ?>" name="doaction2" id="doaction2" class="button-secondary action" />			</div>			<br class="clear" />		</div>		</form>		</div><?phpif ( apply_filters( 'show_adduser_fields', true ) ) :?><div class="wrap" id="form-add-user">	<h3><?php _e( 'Add User' ) ?></h3>	<form action="ms-edit.php?action=adduser" method="post">	<table class="form-table">		<tr class="form-field form-required">			<th scope="row"><?php _e( 'Username' ) ?></th>			<td><input type="text" class="regular-text" name="user[username]" /></td>		</tr>		<tr class="form-field form-required">			<th scope="row"><?php _e( 'Email' ) ?></th>			<td><input type="text" class="regular-text" name="user[email]" /></td>		</tr>		<tr class="form-field">			<td colspan="2"><?php _e( 'Username and password will be mailed to the above email address.' ) ?></td>		</tr>	</table>	<p class="submit">		<?php wp_nonce_field( 'add-user', '_wpnonce_add-user' ) ?>		<input class="button" type="submit" value="<?php esc_attr_e( 'Add user' ) ?>" /></p>	</form></div><?php endif; ?><?php include( './admin-footer.php' ); ?>
<?php/** * WordPress Translation API * * @package WordPress * @subpackage i18n *//** * Gets the current locale. * * If the locale is set, then it will filter the locale in the 'locale' filter * hook and return the value. * * If the locale is not set already, then the WPLANG constant is used if it is * defined. Then it is filtered through the 'locale' filter hook and the value * for the locale global set and the locale is returned. * * The process to get the locale should only be done once but the locale will * always be filtered using the 'locale' hook. * * @since 1.5.0 * @uses apply_filters() Calls 'locale' hook on locale value. * @uses $locale Gets the locale stored in the global. * * @return string The locale of the blog or from the 'locale' hook. */function get_locale() {	global $locale;	if ( isset( $locale ) )		return apply_filters( 'locale', $locale );	// WPLANG is defined in wp-config.	if ( defined( 'WPLANG' ) )		$locale = WPLANG;	// If multisite, check options.	if ( is_multisite() && !defined('WP_INSTALLING') ) {		$ms_locale = get_option('WPLANG');		if ( $ms_locale === false )			$ms_locale = get_site_option('WPLANG');		if ( $ms_locale !== false )			$locale = $ms_locale;	}	if ( empty( $locale ) )		$locale = 'en_US';	return apply_filters( 'locale', $locale );}/** * Retrieves the translation of $text. If there is no translation, or * the domain isn't loaded the original text is returned. * * @see __() Don't use translate() directly, use __() * @since 2.2.0 * @uses apply_filters() Calls 'gettext' on domain translated text *		with the untranslated text as second parameter. * * @param string $text Text to translate. * @param string $domain Domain to retrieve the translated text. * @return string Translated text */function translate( $text, $domain = 'default' ) {	$translations = &get_translations_for_domain( $domain );	return apply_filters( 'gettext', $translations->translate( $text ), $text, $domain );}function before_last_bar( $string ) {	$last_bar = strrpos( $string, '|' );	if ( false == $last_bar )		return $string;	else		return substr( $string, 0, $last_bar );}function translate_with_gettext_context( $text, $context, $domain = 'default' ) {	$translations = &get_translations_for_domain( $domain );	return apply_filters( 'gettext_with_context', $translations->translate( $text, $context ), $text, $context, $domain );}/** * Retrieves the translation of $text. If there is no translation, or * the domain isn't loaded the original text is returned. * * @see translate() An alias of translate() * @since 2.1.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text * @return string Translated text */function __( $text, $domain = 'default' ) {	return translate( $text, $domain );}/** * Retrieves the translation of $text and escapes it for safe use in an attribute. * If there is no translation, or the domain isn't loaded the original text is returned. * * @see translate() An alias of translate() * @see esc_attr() * @since 2.8.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text * @return string Translated text */function esc_attr__( $text, $domain = 'default' ) {	return esc_attr( translate( $text, $domain ) );}/** * Retrieves the translation of $text and escapes it for safe use in HTML output. * If there is no translation, or the domain isn't loaded the original text is returned. * * @see translate() An alias of translate() * @see esc_html() * @since 2.8.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text * @return string Translated text */function esc_html__( $text, $domain = 'default' ) {	return esc_html( translate( $text, $domain ) );}/** * Displays the returned translated text from translate(). * * @see translate() Echoes returned translate() string * @since 1.2.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text */function _e( $text, $domain = 'default' ) {	echo translate( $text, $domain );}/** * Displays translated text that has been escaped for safe use in an attribute. * * @see translate() Echoes returned translate() string * @see esc_attr() * @since 2.8.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text */function esc_attr_e( $text, $domain = 'default' ) {	echo esc_attr( translate( $text, $domain ) );}/** * Displays translated text that has been escaped for safe use in HTML output. * * @see translate() Echoes returned translate() string * @see esc_html() * @since 2.8.0 * * @param string $text Text to translate * @param string $domain Optional. Domain to retrieve the translated text */function esc_html_e( $text, $domain = 'default' ) {	echo esc_html( translate( $text, $domain ) );}/** * Retrieve translated string with gettext context * * Quite a few times, there will be collisions with similar translatable text * found in more than two places but with different translated context. * * By including the context in the pot file translators can translate the two * string differently. * * @since 2.8.0 * * @param string $text Text to translate * @param string $context Context information for the translators * @param string $domain Optional. Domain to retrieve the translated text * @return string Translated context string without pipe */function _x( $single, $context, $domain = 'default' ) {	return translate_with_gettext_context( $single, $context, $domain );}/** * Displays translated string with gettext context * * @see _x * @since 3.0.0 * * @param string $text Text to translate * @param string $context Context information for the translators * @param string $domain Optional. Domain to retrieve the translated text * @return string Translated context string without pipe */function _ex( $single, $context, $domain = 'default' ) {	echo _x( $single, $context, $domain );}function esc_attr_x( $single, $context, $domain = 'default' ) {	return esc_attr( translate_with_gettext_context( $single, $context, $domain ) );}function esc_html_x( $single, $context, $domain = 'default' ) {	return esc_html( translate_with_gettext_context( $single, $context, $domain ) );}/** * Retrieve the plural or single form based on the amount. * * If the domain is not set in the $l10n list, then a comparison will be made * and either $plural or $single parameters returned. * * If the domain does exist, then the parameters $single, $plural, and $number * will first be passed to the domain's ngettext method. Then it will be passed * to the 'ngettext' filter hook along with the same parameters. The expected * type will be a string. * * @since 2.8.0 * @uses $l10n Gets list of domain translated string (gettext_reader) objects * @uses apply_filters() Calls 'ngettext' hook on domains text returned, *		along with $single, $plural, and $number parameters. Expected to return string. * * @param string $single The text that will be used if $number is 1 * @param string $plural The text that will be used if $number is not 1 * @param int $number The number to compare against to use either $single or $plural * @param string $domain Optional. The domain identifier the text should be retrieved in * @return string Either $single or $plural translated text */function _n( $single, $plural, $number, $domain = 'default' ) {	$translations = &get_translations_for_domain( $domain );	$translation = $translations->translate_plural( $single, $plural, $number );	return apply_filters( 'ngettext', $translation, $single, $plural, $number, $domain );}/** * A hybrid of _n() and _x(). It supports contexts and plurals. * * @see _n() * @see _x() * */function _nx($single, $plural, $number, $context, $domain = 'default') {	$translations = &get_translations_for_domain( $domain );	$translation = $translations->translate_plural( $single, $plural, $number, $context );	return apply_filters( 'ngettext_with_context', $translation, $single, $plural, $number, $context, $domain );}/** * Register plural strings in POT file, but don't translate them. * * Used when you want do keep structures with translatable plural strings and * use them later. * * Example: *  $messages = array( *  	'post' => _n_noop('%s post', '%s posts'), *  	'page' => _n_noop('%s pages', '%s pages') *  ); *  ... *  $message = $messages[$type]; *  $usable_text = sprintf(_n($message[0], $message[1], $count), $count); * * @since 2.5 * @param $single Single form to be i18ned * @param $plural Plural form to be i18ned * @return array array($single, $plural) */function _n_noop( $single, $plural ) {	return array( $single, $plural );}/** * Register plural strings with context in POT file, but don't translate them. * * @see _n_noop() */function _nx_noop( $single, $plural, $context ) {	return array( $single, $plural, $context );}/** * Loads a MO file into the domain $domain. * * If the domain already exists, the translations will be merged. If both * sets have the same string, the translation from the original value will be taken. * * On success, the .mo file will be placed in the $l10n global by $domain * and will be a MO object. * * @since 1.5.0 * @uses $l10n Gets list of domain translated string objects * * @param string $domain Unique identifier for retrieving translated strings * @param string $mofile Path to the .mo file * @return bool true on success, false on failure */function load_textdomain( $domain, $mofile ) {	global $l10n;	$plugin_override = apply_filters( 'override_load_textdomain', false, $domain, $mofile );	if ( true == $plugin_override ) {		return true;	}	do_action( 'load_textdomain', $domain, $mofile );	$mofile = apply_filters( 'load_textdomain_mofile', $mofile, $domain );	if ( !is_readable( $mofile ) ) return false;	$mo = new MO();	if ( !$mo->import_from_file( $mofile ) ) return false;	if ( isset( $l10n[$domain] ) )		$mo->merge_with( $l10n[$domain] );	$l10n[$domain] = &$mo;	return true;}/** * Unloads translations for a domain * * @since 3.0.0 * @param string $domain Textdomain to be unloaded * @return bool Whether textdomain was unloaded */function unload_textdomain( $domain ) {	global $l10n;	$plugin_override = apply_filters( 'override_unload_textdomain', false, $domain );	if ( $plugin_override )		return true;	do_action( 'unload_textdomain', $domain );	if ( isset( $l10n[$domain] ) ) {		unset( $l10n[$domain] );		return true;	}	return false;}/** * Loads default translated strings based on locale. * * Loads the .mo file in WP_LANG_DIR constant path from WordPress root. The * translated (.mo) file is named based off of the locale. * * @since 1.5.0 */function load_default_textdomain() {	$locale = get_locale();	load_textdomain( 'default', WP_LANG_DIR . "/$locale.mo" );	if ( is_multisite() || ( defined( 'WP_NETWORK_ADMIN_PAGE' ) && WP_NETWORK_ADMIN_PAGE ) ) {		load_textdomain( 'default', WP_LANG_DIR . "/ms-$locale.mo" );	}}/** * Loads the plugin's translated strings. * * If the path is not given then it will be the root of the plugin directory. * The .mo file should be named based on the domain with a dash, and then the locale exactly. * * @since 1.5.0 * * @param string $domain Unique identifier for retrieving translated strings * @param string $abs_rel_path Optional. Relative path to ABSPATH of a folder, * 	where the .mo file resides. Deprecated, but still functional until 2.7 * @param string $plugin_rel_path Optional. Relative path to WP_PLUGIN_DIR. This is the preferred argument to use. It takes precendence over $abs_rel_path */function load_plugin_textdomain( $domain, $abs_rel_path = false, $plugin_rel_path = false ) {	$locale = apply_filters( 'plugin_locale', get_locale(), $domain );	if ( false !== $plugin_rel_path	) {		$path = WP_PLUGIN_DIR . '/' . trim( $plugin_rel_path, '/' );	} else if ( false !== $abs_rel_path ) {		_deprecated_argument( __FUNCTION__, '2.7' );		$path = ABSPATH . trim( $abs_rel_path, '/' );	} else {		$path = WP_PLUGIN_DIR;	}	$mofile = $path . '/'. $domain . '-' . $locale . '.mo';	return load_textdomain( $domain, $mofile );}/** * Load the translated strings for a plugin residing in the mu-plugins dir. * * @since 3.0.0 * * @param string $domain Unique identifier for retrieving translated strings * @param strings $mu_plugin_rel_path Relative to WPMU_PLUGIN_DIR directory in which * the MO file resides. Defaults is empty string. */function load_muplugin_textdomain( $domain, $mu_plugin_rel_path = '' ) {	$locale = apply_filters( 'plugin_locale', get_locale(), $domain );	$path = WPMU_PLUGIN_DIR . '/' . ltrim( $mu_plugin_rel_path, '/' );	load_textdomain( $domain, trailingslashit( $path ) . "$domain-$locale.mo" );}/** * Loads the theme's translated strings. * * If the current locale exists as a .mo file in the theme's root directory, it * will be included in the translated strings by the $domain. * * The .mo files must be named based on the locale exactly. * * @since 1.5.0 * * @param string $domain Unique identifier for retrieving translated strings */function load_theme_textdomain( $domain, $path = false ) {	$locale = apply_filters( 'theme_locale', get_locale(), $domain );	$path = ( empty( $path ) ) ? get_template_directory() : $path;	$mofile = "$path/$locale.mo";	return load_textdomain($domain, $mofile);}/** * Loads the child themes translated strings. * * If the current locale exists as a .mo file in the child themes root directory, it * will be included in the translated strings by the $domain. * * The .mo files must be named based on the locale exactly. * * @since 2.9.0 * * @param string $domain Unique identifier for retrieving translated strings */function load_child_theme_textdomain( $domain, $path = false ) {	$locale = apply_filters( 'theme_locale', get_locale(), $domain );	$path = ( empty( $path ) ) ? get_stylesheet_directory() : $path;	$mofile = "$path/$locale.mo";	return load_textdomain($domain, $mofile);}/** * Returns the Translations instance for a domain. If there isn't one, * returns empty Translations instance. * * @param string $domain * @return object A Translation instance */function &get_translations_for_domain( $domain ) {	global $l10n;	if ( !isset( $l10n[$domain] ) ) {		$l10n[$domain] = &new NOOP_Translations;	}	return $l10n[$domain];}/** * Whether there are translations for the domain * * @since 3.0.0 * @param string $domain * @return bool Whether there are translations */function is_textdomain_loaded( $domain ) {	global $l10n;	return isset( $l10n[$domain] );}/** * Translates role name. Since the role names are in the database and * not in the source there are dummy gettext calls to get them into the POT * file and this function properly translates them back. * * The before_last_bar() call is needed, because older installs keep the roles * using the old context format: 'Role name|User role' and just skipping the * content after the last bar is easier than fixing them in the DB. New installs * won't suffer from that problem. */function translate_user_role( $name ) {	return translate_with_gettext_context( before_last_bar($name), 'User role' );}/** * Get all available languages based on the presence of *.mo files in a given directory. The default directory is WP_LANG_DIR. * * @since 3.0.0 * * @param string $dir A directory in which to search for language files. The default directory is WP_LANG_DIR. * @return array Array of language codes or an empty array if no languages are present.  Language codes are formed by stripping the .mo extension from the language file names. */function get_available_languages( $dir = null ) {	$languages = array();	foreach( (array)glob( ( is_null( $dir) ? WP_LANG_DIR : $dir ) . '/*.mo' ) as $lang_file ) {		$lang_file = basename($lang_file, '.mo');		if ( 0 !== strpos( $lang_file, 'continents-cities' ) && 0 !== strpos( $lang_file, 'ms-' ) )			$languages[] = $lang_file;	}	return $languages;}
<?php/** * @package WordPress * @subpackage Theme_Compat * @deprecated 3.0 *  * This file is here for Backwards compatibility with old themes and will be removed in a future version *  */_deprecated_file( sprintf( __( 'Theme without %1$s' ), basename(__FILE__) ), '3.0', null, sprintf( __('Please include a %1$s template in your theme.'), basename(__FILE__) ) );?><hr /><div id="footer" role="contentinfo"><!-- If you'd like to support WordPress, having the "powered by" link somewhere on your blog is the best way; it's our only promotion or advertising. -->	<p>		<?php printf(__('%1$s is proudly powered by %2$s'), get_bloginfo('name'),		'<a href="http://wordpress.org/">WordPress</a>'); ?>		<br /><?php printf(__('%1$s and %2$s.'), '<a href="' . get_bloginfo('rss2_url') . '">' . __('Entries (RSS)') . '</a>', '<a href="' . get_bloginfo('comments_rss2_url') . '">' . __('Comments (RSS)') . '</a>'); ?>		<!-- <?php printf(__('%d queries. %s seconds.'), get_num_queries(), timer_stop(0, 3)); ?> -->	</p></div></div><!-- Gorgeous design by Michael Heilemann - http://binarybonsai.com/kubrick/ --><?php /* "Just what do you think you're doing Dave?" */ ?>		<?php wp_footer(); ?></body></html>
<?php/** * Gets the email message from the user's mailbox to add as * a WordPress post. Mailbox connection information must be * configured under Settings > Writing * * @package WordPress *//** Make sure that the WordPress bootstrap has run before continuing. */require(dirname(__FILE__) . '/wp-load.php');if ( ! apply_filters( 'enable_post_by_email_configuration', true ) )	wp_die( __( 'This action has been disabled by the administrator.' ) );/** Allow a plugin to do a complete takeover of Post by Email **/do_action('wp-mail.php');/** Get the POP3 class with which to access the mailbox. */require_once( ABSPATH . WPINC . '/class-pop3.php' );/** Only check at this interval for new messages. */if ( !defined('WP_MAIL_INTERVAL') )	define('WP_MAIL_INTERVAL', 300); // 5 minutes$last_checked = get_transient('mailserver_last_checked');if ( $last_checked )	wp_die(__('Slow down cowboy, no need to check for new mails so often!'));set_transient('mailserver_last_checked', true, WP_MAIL_INTERVAL);$time_difference = get_option('gmt_offset') * 3600;$phone_delim = '::';$pop3 = new POP3();if ( !$pop3->connect( get_option('mailserver_url'), get_option('mailserver_port') ) || !$pop3->user( get_option('mailserver_login') ) )	wp_die( esc_html( $pop3->ERROR ) );$count = $pop3->pass( get_option('mailserver_pass') );if( false === $count )	wp_die( esc_html( $pop3->ERROR ) );if( 0 === $count ) {	$pop3->quit();	wp_die( __('There doesn&#8217;t seem to be any new mail.') );}for ( $i = 1; $i <= $count; $i++ ) {	$message = $pop3->get($i);	$bodysignal = false;	$boundary = '';	$charset = '';	$content = '';	$content_type = '';	$content_transfer_encoding = '';	$post_author = 1;	$author_found = false;	$dmonths = array('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec');	foreach ($message as $line) {		// body signal		if ( strlen($line) < 3 )			$bodysignal = true;		if ( $bodysignal ) {			$content .= $line;		} else {			if ( preg_match('/Content-Type: /i', $line) ) {				$content_type = trim($line);				$content_type = substr($content_type, 14, strlen($content_type) - 14);				$content_type = explode(';', $content_type);				if ( ! empty( $content_type[1] ) ) {					$charset = explode('=', $content_type[1]);					$charset = ( ! empty( $charset[1] ) ) ? trim($charset[1]) : '';				}				$content_type = $content_type[0];			}			if ( preg_match('/Content-Transfer-Encoding: /i', $line) ) {				$content_transfer_encoding = trim($line);				$content_transfer_encoding = substr($content_transfer_encoding, 27, strlen($content_transfer_encoding) - 27);				$content_transfer_encoding = explode(';', $content_transfer_encoding);				$content_transfer_encoding = $content_transfer_encoding[0];			}			if ( ( $content_type == 'multipart/alternative' ) && ( false !== strpos($line, 'boundary="') ) && ( '' == $boundary ) ) {				$boundary = trim($line);				$boundary = explode('"', $boundary);				$boundary = $boundary[1];			}			if (preg_match('/Subject: /i', $line)) {				$subject = trim($line);				$subject = substr($subject, 9, strlen($subject) - 9);				// Captures any text in the subject before $phone_delim as the subject				if ( function_exists('iconv_mime_decode') ) {					$subject = iconv_mime_decode($subject, 2, get_option('blog_charset'));				} else {					$subject = wp_iso_descrambler($subject);				}				$subject = explode($phone_delim, $subject);				$subject = $subject[0];			}			// Set the author using the email address (From or Reply-To, the last used)			// otherwise use the site admin			if ( preg_match('/(From|Reply-To): /', $line) )  {				if ( preg_match('|[a-z0-9_.-]+@[a-z0-9_.-]+(?!.*<)|i', $line, $matches) )					$author = $matches[0];				else					$author = trim($line);				$author = sanitize_email($author);				if ( is_email($author) ) {					echo '<p>' . sprintf(__('Author is %s'), $author) . '</p>';					$userdata = get_user_by_email($author);					if ( empty($userdata) ) {						$author_found = false;					} else {						$post_author = $userdata->ID;						$author_found = true;					}				} else {					$author_found = false;				}			}			if (preg_match('/Date: /i', $line)) { // of the form '20 Mar 2002 20:32:37'				$ddate = trim($line);				$ddate = str_replace('Date: ', '', $ddate);				if (strpos($ddate, ',')) {					$ddate = trim(substr($ddate, strpos($ddate, ',') + 1, strlen($ddate)));				}				$date_arr = explode(' ', $ddate);				$date_time = explode(':', $date_arr[3]);				$ddate_H = $date_time[0];				$ddate_i = $date_time[1];				$ddate_s = $date_time[2];				$ddate_m = $date_arr[1];				$ddate_d = $date_arr[0];				$ddate_Y = $date_arr[2];				for ( $j = 0; $j < 12; $j++ ) {					if ( $ddate_m == $dmonths[$j] ) {						$ddate_m = $j+1;					}				}				$time_zn = intval($date_arr[4]) * 36;				$ddate_U = gmmktime($ddate_H, $ddate_i, $ddate_s, $ddate_m, $ddate_d, $ddate_Y);				$ddate_U = $ddate_U - $time_zn;				$post_date = gmdate('Y-m-d H:i:s', $ddate_U + $time_difference);				$post_date_gmt = gmdate('Y-m-d H:i:s', $ddate_U);			}		}	}	// Set $post_status based on $author_found and on author's publish_posts capability	if ( $author_found ) {		$user = new WP_User($post_author);		$post_status = ( $user->has_cap('publish_posts') ) ? 'publish' : 'pending';	} else {		// Author not found in DB, set status to pending.  Author already set to admin.		$post_status = 'pending';	}	$subject = trim($subject);	if ( $content_type == 'multipart/alternative' ) {		$content = explode('--'.$boundary, $content);		$content = $content[2];		// match case-insensitive content-transfer-encoding		if ( preg_match( '/Content-Transfer-Encoding: quoted-printable/i', $content, $delim) ) {			$content = explode($delim[0], $content);			$content = $content[1];		}		$content = strip_tags($content, '<img><p><br><i><b><u><em><strong><strike><font><span><div>');	}	$content = trim($content);	//Give Post-By-Email extending plugins full access to the content	//Either the raw content or the content of the last quoted-printable section	$content = apply_filters('wp_mail_original_content', $content);	if ( false !== stripos($content_transfer_encoding, "quoted-printable") ) {		$content = quoted_printable_decode($content);	}	if ( function_exists('iconv') && ! empty( $charset ) ) {		$content = iconv($charset, get_option('blog_charset'), $content);	}	// Captures any text in the body after $phone_delim as the body	$content = explode($phone_delim, $content);	$content = empty( $content[1] ) ? $content[0] : $content[1];	$content = trim($content);	$post_content = apply_filters('phone_content', $content);	$post_title = xmlrpc_getposttitle($content);	if ($post_title == '') $post_title = $subject;	$post_category = array(get_option('default_email_category'));	$post_data = compact('post_content','post_title','post_date','post_date_gmt','post_author','post_category', 'post_status');	$post_data = add_magic_quotes($post_data);	$post_ID = wp_insert_post($post_data);	if ( is_wp_error( $post_ID ) )		echo "\n" . $post_ID->get_error_message();	// We couldn't post, for whatever reason. Better move forward to the next email.	if ( empty( $post_ID ) )		continue;	do_action('publish_phone', $post_ID);	echo "\n<p>" . sprintf(__('<strong>Author:</strong> %s'), esc_html($post_author)) . '</p>';	echo "\n<p>" . sprintf(__('<strong>Posted title:</strong> %s'), esc_html($post_title)) . '</p>';	if(!$pop3->delete($i)) {		echo '<p>' . sprintf(__('Oops: %s'), esc_html($pop3->ERROR)) . '</p>';		$pop3->reset();		exit;	} else {		echo '<p>' . sprintf(__('Mission complete.  Message <strong>%s</strong> deleted.'), $i) . '</p>';	}}$pop3->quit();?>
<?php/** * The template for displaying the footer. * * Contains the closing of the id=main div and all content * after.  Calls sidebar-footer.php for bottom widgets. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */?>	</div><!-- #main -->	<div id="footer" role="contentinfo">		<div id="colophon"><?php	/* A sidebar in the footer? Yep. You can can customize	 * your footer with four columns of widgets.	 */	get_sidebar( 'footer' );?>			<div id="site-info">				<a href="<?php echo home_url( '/' ) ?>" title="<?php echo esc_attr( get_bloginfo( 'name', 'display' ) ); ?>" rel="home">					<?php bloginfo( 'name' ); ?>				</a>			</div><!-- #site-info -->			<div id="site-generator">				<?php do_action( 'twentyten_credits' ); ?>				<a href="<?php echo esc_url( __('http://wordpress.org/', 'twentyten') ); ?>"						title="<?php esc_attr_e('Semantic Personal Publishing Platform', 'twentyten'); ?>" rel="generator">					<?php printf( __('Proudly powered by %s.', 'twentyten'), 'WordPress' ); ?>				</a>			</div><!-- #site-generator -->		</div><!-- #colophon -->	</div><!-- #footer --></div><!-- #wrapper --><?php	/* Always have wp_footer() just before the closing </body>	 * tag of your theme, or you will break many plugins, which	 * generally use this hook to reference JavaScript files.	 */	wp_footer();?></body></html>
<?php/** * Class used internally by Diff to actually compute the diffs. * * This class uses the xdiff PECL package (http://pecl.php.net/package/xdiff) * to compute the differences between the two input arrays. * * Copyright 2004-2010 The Horde Project (http://www.horde.org/) * * See the enclosed file COPYING for license information (LGPL). If you did * not receive this file, see http://opensource.org/licenses/lgpl-license.php. * * @author  Jon Parise <jon@horde.org> * @package Text_Diff */class Text_Diff_Engine_xdiff {    /**     */    function diff($from_lines, $to_lines)    {        array_walk($from_lines, array('Text_Diff', 'trimNewlines'));        array_walk($to_lines, array('Text_Diff', 'trimNewlines'));        /* Convert the two input arrays into strings for xdiff processing. */        $from_string = implode("\n", $from_lines);        $to_string = implode("\n", $to_lines);        /* Diff the two strings and convert the result to an array. */        $diff = xdiff_string_diff($from_string, $to_string, count($to_lines));        $diff = explode("\n", $diff);        /* Walk through the diff one line at a time.  We build the $edits         * array of diff operations by reading the first character of the         * xdiff output (which is in the "unified diff" format).         *         * Note that we don't have enough information to detect "changed"         * lines using this approach, so we can't add Text_Diff_Op_changed         * instances to the $edits array.  The result is still perfectly         * valid, albeit a little less descriptive and efficient. */        $edits = array();        foreach ($diff as $line) {            if (!strlen($line)) {                continue;            }            switch ($line[0]) {            case ' ':                $edits[] = &new Text_Diff_Op_copy(array(substr($line, 1)));                break;            case '+':                $edits[] = &new Text_Diff_Op_add(array(substr($line, 1)));                break;            case '-':                $edits[] = &new Text_Diff_Op_delete(array(substr($line, 1)));                break;            }        }        return $edits;    }}
<?php/** * Redirects to the RDF feed * This file is deprecated and only exists for backwards compatibility * * @package WordPress */require( './wp-load.php' );wp_redirect( get_bloginfo( 'rdf_url' ), 301 );?>
<?php/** * Media settings administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can( 'manage_options' ) )	wp_die( __( 'You do not have sufficient permissions to manage options for this site.' ) );$title = __('Media Settings');$parent_file = 'options-general.php';add_contextual_help($current_screen,	'<p>' . __('You can set maximum sizes for images inserted into your written content; you can also insert an image as Full Size.') . '</p>' .	'<p>' . __('The Embed option allows you embed a video, image, or other media content into your content automatically by typing the URL (of the web page where the file lives) on its own line when you create your content.') . '</p>' .	'<p>' . __('Uploading Options gives you folder and path choices for storing your files in your installation&#8217;s directory.') . '</p>' .	'<p>' . __('You must click the Save Changes button at the bottom of the screen for new settings to take effect.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Settings_Media_SubPanel" target="_blank">Documentation on Media Settings</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');include('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><form action="options.php" method="post"><?php settings_fields('media'); ?><h3><?php _e('Image sizes') ?></h3><p><?php _e('The sizes listed below determine the maximum dimensions in pixels to use when inserting an image into the body of a post.'); ?></p><table class="form-table"><tr valign="top"><th scope="row"><?php _e('Thumbnail size') ?></th><td><label for="thumbnail_size_w"><?php _e('Width'); ?></label><input name="thumbnail_size_w" type="text" id="thumbnail_size_w" value="<?php form_option('thumbnail_size_w'); ?>" class="small-text" /><label for="thumbnail_size_h"><?php _e('Height'); ?></label><input name="thumbnail_size_h" type="text" id="thumbnail_size_h" value="<?php form_option('thumbnail_size_h'); ?>" class="small-text" /><br /><input name="thumbnail_crop" type="checkbox" id="thumbnail_crop" value="1" <?php checked('1', get_option('thumbnail_crop')); ?>/><label for="thumbnail_crop"><?php _e('Crop thumbnail to exact dimensions (normally thumbnails are proportional)'); ?></label></td></tr><tr valign="top"><th scope="row"><?php _e('Medium size') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Medium size'); ?></span></legend><label for="medium_size_w"><?php _e('Max Width'); ?></label><input name="medium_size_w" type="text" id="medium_size_w" value="<?php form_option('medium_size_w'); ?>" class="small-text" /><label for="medium_size_h"><?php _e('Max Height'); ?></label><input name="medium_size_h" type="text" id="medium_size_h" value="<?php form_option('medium_size_h'); ?>" class="small-text" /></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('Large size') ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Large size'); ?></span></legend><label for="large_size_w"><?php _e('Max Width'); ?></label><input name="large_size_w" type="text" id="large_size_w" value="<?php form_option('large_size_w'); ?>" class="small-text" /><label for="large_size_h"><?php _e('Max Height'); ?></label><input name="large_size_h" type="text" id="large_size_h" value="<?php form_option('large_size_h'); ?>" class="small-text" /></fieldset></td></tr><?php do_settings_fields('media', 'default'); ?></table><h3><?php _e('Embeds') ?></h3><table class="form-table"><tr valign="top"><th scope="row"><?php _e('Auto-embeds'); ?></th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Attempt to automatically embed all plain text URLs'); ?></span></legend><label for="embed_autourls"><input name="embed_autourls" type="checkbox" id="embed_autourls" value="1" <?php checked( '1', get_option('embed_autourls') ); ?>/> <?php _e('Attempt to automatically embed all plain text URLs'); ?></label></fieldset></td></tr><tr valign="top"><th scope="row"><?php _e('Maximum embed size') ?></th><td><label for="embed_size_w"><?php _e('Width'); ?></label><input name="embed_size_w" type="text" id="embed_size_w" value="<?php form_option('embed_size_w'); ?>" class="small-text" /><label for="embed_size_h"><?php _e('Height'); ?></label><input name="embed_size_h" type="text" id="embed_size_h" value="<?php form_option('embed_size_h'); ?>" class="small-text" /><?php if ( !empty($content_width) ) echo '<br />' . __("If the width value is left blank, embeds will default to the max width of your theme."); ?></td></tr><?php do_settings_fields('media', 'embeds'); ?></table><?php if ( !is_multisite() ) : ?><h3><?php _e('Uploading Files'); ?></h3><table class="form-table"><tr valign="top"><th scope="row"><label for="upload_path"><?php _e('Store uploads in this folder'); ?></label></th><td><input name="upload_path" type="text" id="upload_path" value="<?php echo esc_attr(get_option('upload_path')); ?>" class="regular-text code" /><span class="description"><?php _e('Default is <code>wp-content/uploads</code>'); ?></span></td></tr><tr valign="top"><th scope="row"><label for="upload_url_path"><?php _e('Full URL path to files'); ?></label></th><td><input name="upload_url_path" type="text" id="upload_url_path" value="<?php echo esc_attr( get_option('upload_url_path')); ?>" class="regular-text code" /><span class="description"><?php _e('Configuring this is optional. By default, it should be blank.'); ?></span></td></tr><tr><th scope="row" colspan="2" class="th-full"><label for="uploads_use_yearmonth_folders"><input name="uploads_use_yearmonth_folders" type="checkbox" id="uploads_use_yearmonth_folders" value="1"<?php checked('1', get_option('uploads_use_yearmonth_folders')); ?> /><?php _e('Organize my uploads into month- and year-based folders'); ?></label></th></tr><?php do_settings_fields('media', 'uploads'); ?></table><?php endif; ?><?php do_settings_sections('media'); ?><p class="submit">	<input type="submit" name="Submit" class="button-primary" value="<?php esc_attr_e('Save Changes') ?>" /></p></form></div><?php include('./admin-footer.php'); ?>
<?php/** * WordPress CRON API * * @package WordPress *//** * Schedules a hook to run only once. * * Schedules a hook which will be executed once by the WordPress actions core at * a time which you specify. The action will fire off when someone visits your * WordPress site, if the schedule time has passed. * * @since 2.1.0 * @link http://codex.wordpress.org/Function_Reference/wp_schedule_single_event * * @param int $timestamp Timestamp for when to run the event. * @param string $hook Action hook to execute when cron is run. * @param array $args Optional. Arguments to pass to the hook's callback function. */function wp_schedule_single_event( $timestamp, $hook, $args = array()) {	// don't schedule a duplicate if there's already an identical event due in the next 10 minutes	$next = wp_next_scheduled($hook, $args);	if ( $next && $next <= $timestamp + 600 )		return;	$crons = _get_cron_array();	$key = md5(serialize($args));	$crons[$timestamp][$hook][$key] = array( 'schedule' => false, 'args' => $args );	uksort( $crons, "strnatcasecmp" );	_set_cron_array( $crons );}/** * Schedule a periodic event. * * Schedules a hook which will be executed by the WordPress actions core on a * specific interval, specified by you. The action will trigger when someone * visits your WordPress site, if the scheduled time has passed. * * Valid values for the recurrence are hourly, daily and twicedaily.  These can * be extended using the cron_schedules filter in wp_get_schedules(). * * @since 2.1.0 * * @param int $timestamp Timestamp for when to run the event. * @param string $recurrence How often the event should recur. * @param string $hook Action hook to execute when cron is run. * @param array $args Optional. Arguments to pass to the hook's callback function. * @return bool|null False on failure, null when complete with scheduling event. */function wp_schedule_event( $timestamp, $recurrence, $hook, $args = array()) {	$crons = _get_cron_array();	$schedules = wp_get_schedules();	$key = md5(serialize($args));	if ( !isset( $schedules[$recurrence] ) )		return false;	$crons[$timestamp][$hook][$key] = array( 'schedule' => $recurrence, 'args' => $args, 'interval' => $schedules[$recurrence]['interval'] );	uksort( $crons, "strnatcasecmp" );	_set_cron_array( $crons );}/** * Reschedule a recurring event. * * @since 2.1.0 * * @param int $timestamp Timestamp for when to run the event. * @param string $recurrence How often the event should recur. * @param string $hook Action hook to execute when cron is run. * @param array $args Optional. Arguments to pass to the hook's callback function. * @return bool|null False on failure. Null when event is rescheduled. */function wp_reschedule_event( $timestamp, $recurrence, $hook, $args = array()) {	$crons = _get_cron_array();	$schedules = wp_get_schedules();	$key = md5(serialize($args));	$interval = 0;	// First we try to get it from the schedule	if ( 0 == $interval )		$interval = $schedules[$recurrence]['interval'];	// Now we try to get it from the saved interval in case the schedule disappears	if ( 0 == $interval )		$interval = $crons[$timestamp][$hook][$key]['interval'];	// Now we assume something is wrong and fail to schedule	if ( 0 == $interval )		return false;	$now = time();    if ( $timestamp >= $now )        $timestamp = $now + $interval;    else        $timestamp = $now + ($interval - (($now - $timestamp) % $interval));	wp_schedule_event( $timestamp, $recurrence, $hook, $args );}/** * Unschedule a previously scheduled cron job. * * The $timestamp and $hook parameters are required, so that the event can be * identified. * * @since 2.1.0 * * @param int $timestamp Timestamp for when to run the event. * @param string $hook Action hook, the execution of which will be unscheduled. * @param array $args Arguments to pass to the hook's callback function. * Although not passed to a callback function, these arguments are used * to uniquely identify the scheduled event, so they should be the same * as those used when originally scheduling the event. */function wp_unschedule_event( $timestamp, $hook, $args = array() ) {	$crons = _get_cron_array();	$key = md5(serialize($args));	unset( $crons[$timestamp][$hook][$key] );	if ( empty($crons[$timestamp][$hook]) )		unset( $crons[$timestamp][$hook] );	if ( empty($crons[$timestamp]) )		unset( $crons[$timestamp] );	_set_cron_array( $crons );}/** * Unschedule all cron jobs attached to a specific hook. * * @since 2.1.0 * * @param string $hook Action hook, the execution of which will be unscheduled. * @param array $args Optional. Arguments that were to be pass to the hook's callback function. */function wp_clear_scheduled_hook( $hook, $args = array() ) {	// Backward compatibility	// Previously this function took the arguments as discrete vars rather than an array like the rest of the API	if ( !is_array($args) ) {		_deprecated_argument( __FUNCTION__, '3.0.0', __('This argument has changed to an array to match the behavior of the other cron functions.') );		$args = array_slice( func_get_args(), 1 );	}	while ( $timestamp = wp_next_scheduled( $hook, $args ) )		wp_unschedule_event( $timestamp, $hook, $args );}/** * Retrieve the next timestamp for a cron event. * * @since 2.1.0 * * @param string $hook Action hook to execute when cron is run. * @param array $args Optional. Arguments to pass to the hook's callback function. * @return bool|int The UNIX timestamp of the next time the scheduled event will occur. */function wp_next_scheduled( $hook, $args = array() ) {	$crons = _get_cron_array();	$key = md5(serialize($args));	if ( empty($crons) )		return false;	foreach ( $crons as $timestamp => $cron ) {		if ( isset( $cron[$hook][$key] ) )			return $timestamp;	}	return false;}/** * Send request to run cron through HTTP request that doesn't halt page loading. * * @since 2.1.0 * * @return null Cron could not be spawned, because it is not needed to run. */function spawn_cron( $local_time = 0 ) {	if ( !$local_time )		$local_time = time();	if ( defined('DOING_CRON') || isset($_GET['doing_wp_cron']) )		return;	/*	 * do not even start the cron if local server timer has drifted	 * such as due to power failure, or misconfiguration	 */	$timer_accurate = check_server_timer( $local_time );	if ( !$timer_accurate )		return;	/*	* multiple processes on multiple web servers can run this code concurrently	* try to make this as atomic as possible by setting doing_cron switch	*/	$flag = get_transient('doing_cron');	if ( $flag > $local_time + 10*60 )		$flag = 0;	// don't run if another process is currently running it or more than once every 60 sec.	if ( $flag + 60 > $local_time )		return;	//sanity check	$crons = _get_cron_array();	if ( !is_array($crons) )		return;	$keys = array_keys( $crons );	if ( isset($keys[0]) && $keys[0] > $local_time )		return;	if ( defined('ALTERNATE_WP_CRON') && ALTERNATE_WP_CRON ) {		if ( !empty($_POST) || defined('DOING_AJAX') )			return;		set_transient( 'doing_cron', $local_time );		ob_start();		wp_redirect( add_query_arg('doing_wp_cron', '', stripslashes($_SERVER['REQUEST_URI'])) );		echo ' ';		// flush any buffers and send the headers		while ( @ob_end_flush() );		flush();		WP_DEBUG ? include_once( ABSPATH . 'wp-cron.php' ) : @include_once( ABSPATH . 'wp-cron.php' );		return;	}	set_transient( 'doing_cron', $local_time );	$cron_url = get_option( 'siteurl' ) . '/wp-cron.php?doing_wp_cron';	wp_remote_post( $cron_url, array('timeout' => 0.01, 'blocking' => false, 'sslverify' => apply_filters('https_local_ssl_verify', true)) );}/** * Run scheduled callbacks or spawn cron for all scheduled events. * * @since 2.1.0 * * @return null When doesn't need to run Cron. */function wp_cron() {	// Prevent infinite loops caused by lack of wp-cron.php	if ( strpos($_SERVER['REQUEST_URI'], '/wp-cron.php') !== false || ( defined('DISABLE_WP_CRON') && DISABLE_WP_CRON ) )		return;	if ( false === $crons = _get_cron_array() )		return;	$local_time = time();	$keys = array_keys( $crons );	if ( isset($keys[0]) && $keys[0] > $local_time )		return;	$schedules = wp_get_schedules();	foreach ( $crons as $timestamp => $cronhooks ) {		if ( $timestamp > $local_time ) break;		foreach ( (array) $cronhooks as $hook => $args ) {			if ( isset($schedules[$hook]['callback']) && !call_user_func( $schedules[$hook]['callback'] ) )				continue;			spawn_cron( $local_time );			break 2;		}	}}/** * Retrieve supported and filtered Cron recurrences. * * The supported recurrences are 'hourly' and 'daily'. A plugin may add more by * hooking into the 'cron_schedules' filter. The filter accepts an array of * arrays. The outer array has a key that is the name of the schedule or for * example 'weekly'. The value is an array with two keys, one is 'interval' and * the other is 'display'. * * The 'interval' is a number in seconds of when the cron job should run. So for * 'hourly', the time is 3600 or 60*60. For weekly, the value would be * 60*60*24*7 or 604800. The value of 'interval' would then be 604800. * * The 'display' is the description. For the 'weekly' key, the 'display' would * be <code>__('Once Weekly')</code>. * * For your plugin, you will be passed an array. you can easily add your * schedule by doing the following. * <code> * // filter parameter variable name is 'array' *	$array['weekly'] = array( *		'interval' => 604800, *		'display' => __('Once Weekly') *	); * </code> * * @since 2.1.0 * * @return array */function wp_get_schedules() {	$schedules = array(		'hourly' => array( 'interval' => 3600, 'display' => __('Once Hourly') ),		'twicedaily' => array( 'interval' => 43200, 'display' => __('Twice Daily') ),		'daily' => array( 'interval' => 86400, 'display' => __('Once Daily') ),	);	return array_merge( apply_filters( 'cron_schedules', array() ), $schedules );}/** * Retrieve Cron schedule for hook with arguments. * * @since 2.1.0 * * @param string $hook Action hook to execute when cron is run. * @param array $args Optional. Arguments to pass to the hook's callback function. * @return string|bool False, if no schedule. Schedule on success. */function wp_get_schedule($hook, $args = array()) {	$crons = _get_cron_array();	$key = md5(serialize($args));	if ( empty($crons) )		return false;	foreach ( $crons as $timestamp => $cron ) {		if ( isset( $cron[$hook][$key] ) )			return $cron[$hook][$key]['schedule'];	}	return false;}//// Private functions///** * Retrieve cron info array option. * * @since 2.1.0 * @access private * * @return array CRON info array. */function _get_cron_array()  {	$cron = get_option('cron');	if ( ! is_array($cron) )		return false;	if ( !isset($cron['version']) )		$cron = _upgrade_cron_array($cron);	unset($cron['version']);	return $cron;}/** * Updates the CRON option with the new CRON array. * * @since 2.1.0 * @access private * * @param array $cron Cron info array from {@link _get_cron_array()}. */function _set_cron_array($cron) {	$cron['version'] = 2;	update_option( 'cron', $cron );}/** * Upgrade a Cron info array. * * This function upgrades the Cron info array to version 2. * * @since 2.1.0 * @access private * * @param array $cron Cron info array from {@link _get_cron_array()}. * @return array An upgraded Cron info array. */function _upgrade_cron_array($cron) {	if ( isset($cron['version']) && 2 == $cron['version'])		return $cron;	$new_cron = array();	foreach ( (array) $cron as $timestamp => $hooks) {		foreach ( (array) $hooks as $hook => $args ) {			$key = md5(serialize($args['args']));			$new_cron[$timestamp][$hook][$key] = $args;		}	}	$new_cron['version'] = 2;	update_option( 'cron', $new_cron );	return $new_cron;}// stub for checking server timer accuracy, using outside standard time sourcesfunction check_server_timer( $local_time ) {	return true;}
<?php// --------------------------------------------------------------------------------// PhpConcept Library - Zip Module 2.8.2// --------------------------------------------------------------------------------// License GNU/LGPL - Vincent Blavet - August 2009// http://www.phpconcept.net// --------------------------------------------------------------------------------//// Presentation ://   PclZip is a PHP library that manage ZIP archives.//   So far tests show that archives generated by PclZip are readable by//   WinZip application and other tools.//// Description ://   See readme.txt and http://www.phpconcept.net//// Warning ://   This library and the associated files are non commercial, non professional//   work.//   It should not have unexpected results. However if any damage is caused by//   this software the author can not be responsible.//   The use of this software is at the risk of the user.//// --------------------------------------------------------------------------------// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $// --------------------------------------------------------------------------------  // ----- Constants  if (!defined('PCLZIP_READ_BLOCK_SIZE')) {    define( 'PCLZIP_READ_BLOCK_SIZE', 2048 );  }  // ----- File list separator  // In version 1.x of PclZip, the separator for file list is a space  // (which is not a very smart choice, specifically for windows paths !).  // A better separator should be a comma (,). This constant gives you the  // abilty to change that.  // However notice that changing this value, may have impact on existing  // scripts, using space separated filenames.  // Recommanded values for compatibility with older versions :  //define( 'PCLZIP_SEPARATOR', ' ' );  // Recommanded values for smart separation of filenames.  if (!defined('PCLZIP_SEPARATOR')) {    define( 'PCLZIP_SEPARATOR', ',' );  }  // ----- Error configuration  // 0 : PclZip Class integrated error handling  // 1 : PclError external library error handling. By enabling this  //     you must ensure that you have included PclError library.  // [2,...] : reserved for futur use  if (!defined('PCLZIP_ERROR_EXTERNAL')) {    define( 'PCLZIP_ERROR_EXTERNAL', 0 );  }  // ----- Optional static temporary directory  //       By default temporary files are generated in the script current  //       path.  //       If defined :  //       - MUST BE terminated by a '/'.  //       - MUST be a valid, already created directory  //       Samples :  // define( 'PCLZIP_TEMPORARY_DIR', '/temp/' );  // define( 'PCLZIP_TEMPORARY_DIR', 'C:/Temp/' );  if (!defined('PCLZIP_TEMPORARY_DIR')) {    define( 'PCLZIP_TEMPORARY_DIR', '' );  }  // ----- Optional threshold ratio for use of temporary files  //       Pclzip sense the size of the file to add/extract and decide to  //       use or not temporary file. The algorythm is looking for  //       memory_limit of PHP and apply a ratio.  //       threshold = memory_limit * ratio.  //       Recommended values are under 0.5. Default 0.47.  //       Samples :  // define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.5 );  if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) {    define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.47 );  }// --------------------------------------------------------------------------------// ***** UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED *****// --------------------------------------------------------------------------------  // ----- Global variables  $g_pclzip_version = "2.8.2";  // ----- Error codes  //   -1 : Unable to open file in binary write mode  //   -2 : Unable to open file in binary read mode  //   -3 : Invalid parameters  //   -4 : File does not exist  //   -5 : Filename is too long (max. 255)  //   -6 : Not a valid zip file  //   -7 : Invalid extracted file size  //   -8 : Unable to create directory  //   -9 : Invalid archive extension  //  -10 : Invalid archive format  //  -11 : Unable to delete file (unlink)  //  -12 : Unable to rename file (rename)  //  -13 : Invalid header checksum  //  -14 : Invalid archive size  define( 'PCLZIP_ERR_USER_ABORTED', 2 );  define( 'PCLZIP_ERR_NO_ERROR', 0 );  define( 'PCLZIP_ERR_WRITE_OPEN_FAIL', -1 );  define( 'PCLZIP_ERR_READ_OPEN_FAIL', -2 );  define( 'PCLZIP_ERR_INVALID_PARAMETER', -3 );  define( 'PCLZIP_ERR_MISSING_FILE', -4 );  define( 'PCLZIP_ERR_FILENAME_TOO_LONG', -5 );  define( 'PCLZIP_ERR_INVALID_ZIP', -6 );  define( 'PCLZIP_ERR_BAD_EXTRACTED_FILE', -7 );  define( 'PCLZIP_ERR_DIR_CREATE_FAIL', -8 );  define( 'PCLZIP_ERR_BAD_EXTENSION', -9 );  define( 'PCLZIP_ERR_BAD_FORMAT', -10 );  define( 'PCLZIP_ERR_DELETE_FILE_FAIL', -11 );  define( 'PCLZIP_ERR_RENAME_FILE_FAIL', -12 );  define( 'PCLZIP_ERR_BAD_CHECKSUM', -13 );  define( 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14 );  define( 'PCLZIP_ERR_MISSING_OPTION_VALUE', -15 );  define( 'PCLZIP_ERR_INVALID_OPTION_VALUE', -16 );  define( 'PCLZIP_ERR_ALREADY_A_DIRECTORY', -17 );  define( 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18 );  define( 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19 );  define( 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20 );  define( 'PCLZIP_ERR_DIRECTORY_RESTRICTION', -21 );  // ----- Options values  define( 'PCLZIP_OPT_PATH', 77001 );  define( 'PCLZIP_OPT_ADD_PATH', 77002 );  define( 'PCLZIP_OPT_REMOVE_PATH', 77003 );  define( 'PCLZIP_OPT_REMOVE_ALL_PATH', 77004 );  define( 'PCLZIP_OPT_SET_CHMOD', 77005 );  define( 'PCLZIP_OPT_EXTRACT_AS_STRING', 77006 );  define( 'PCLZIP_OPT_NO_COMPRESSION', 77007 );  define( 'PCLZIP_OPT_BY_NAME', 77008 );  define( 'PCLZIP_OPT_BY_INDEX', 77009 );  define( 'PCLZIP_OPT_BY_EREG', 77010 );  define( 'PCLZIP_OPT_BY_PREG', 77011 );  define( 'PCLZIP_OPT_COMMENT', 77012 );  define( 'PCLZIP_OPT_ADD_COMMENT', 77013 );  define( 'PCLZIP_OPT_PREPEND_COMMENT', 77014 );  define( 'PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015 );  define( 'PCLZIP_OPT_REPLACE_NEWER', 77016 );  define( 'PCLZIP_OPT_STOP_ON_ERROR', 77017 );  // Having big trouble with crypt. Need to multiply 2 long int  // which is not correctly supported by PHP ...  //define( 'PCLZIP_OPT_CRYPT', 77018 );  define( 'PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019 );  define( 'PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020 );  define( 'PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD', 77020 ); // alias  define( 'PCLZIP_OPT_TEMP_FILE_ON', 77021 );  define( 'PCLZIP_OPT_ADD_TEMP_FILE_ON', 77021 ); // alias  define( 'PCLZIP_OPT_TEMP_FILE_OFF', 77022 );  define( 'PCLZIP_OPT_ADD_TEMP_FILE_OFF', 77022 ); // alias  // ----- File description attributes  define( 'PCLZIP_ATT_FILE_NAME', 79001 );  define( 'PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002 );  define( 'PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003 );  define( 'PCLZIP_ATT_FILE_MTIME', 79004 );  define( 'PCLZIP_ATT_FILE_CONTENT', 79005 );  define( 'PCLZIP_ATT_FILE_COMMENT', 79006 );  // ----- Call backs values  define( 'PCLZIP_CB_PRE_EXTRACT', 78001 );  define( 'PCLZIP_CB_POST_EXTRACT', 78002 );  define( 'PCLZIP_CB_PRE_ADD', 78003 );  define( 'PCLZIP_CB_POST_ADD', 78004 );  /* For futur use  define( 'PCLZIP_CB_PRE_LIST', 78005 );  define( 'PCLZIP_CB_POST_LIST', 78006 );  define( 'PCLZIP_CB_PRE_DELETE', 78007 );  define( 'PCLZIP_CB_POST_DELETE', 78008 );  */  // --------------------------------------------------------------------------------  // Class : PclZip  // Description :  //   PclZip is the class that represent a Zip archive.  //   The public methods allow the manipulation of the archive.  // Attributes :  //   Attributes must not be accessed directly.  // Methods :  //   PclZip() : Object creator  //   create() : Creates the Zip archive  //   listContent() : List the content of the Zip archive  //   extract() : Extract the content of the archive  //   properties() : List the properties of the archive  // --------------------------------------------------------------------------------  class PclZip  {    // ----- Filename of the zip file    var $zipname = '';    // ----- File descriptor of the zip file    var $zip_fd = 0;    // ----- Internal error handling    var $error_code = 1;    var $error_string = '';    // ----- Current status of the magic_quotes_runtime    // This value store the php configuration for magic_quotes    // The class can then disable the magic_quotes and reset it after    var $magic_quotes_status;  // --------------------------------------------------------------------------------  // Function : PclZip()  // Description :  //   Creates a PclZip object and set the name of the associated Zip archive  //   filename.  //   Note that no real action is taken, if the archive does not exist it is not  //   created. Use create() for that.  // --------------------------------------------------------------------------------  function PclZip($p_zipname)  {    // ----- Tests the zlib    if (!function_exists('gzopen'))    {      die('Abort '.basename(__FILE__).' : Missing zlib extensions');    }    // ----- Set the attributes    $this->zipname = $p_zipname;    $this->zip_fd = 0;    $this->magic_quotes_status = -1;    // ----- Return    return;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   create($p_filelist, $p_add_dir="", $p_remove_dir="")  //   create($p_filelist, $p_option, $p_option_value, ...)  // Description :  //   This method supports two different synopsis. The first one is historical.  //   This method creates a Zip Archive. The Zip file is created in the  //   filesystem. The files and directories indicated in $p_filelist  //   are added in the archive. See the parameters description for the  //   supported format of $p_filelist.  //   When a directory is in the list, the directory and its content is added  //   in the archive.  //   In this synopsis, the function takes an optional variable list of  //   options. See bellow the supported options.  // Parameters :  //   $p_filelist : An array containing file or directory names, or  //                 a string containing one filename or one directory name, or  //                 a string containing a list of filenames and/or directory  //                 names separated by spaces.  //   $p_add_dir : A path to add before the real path of the archived file,  //                in order to have it memorized in the archive.  //   $p_remove_dir : A path to remove from the real path of the file to archive,  //                   in order to have a shorter path memorized in the archive.  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir  //                   is removed first, before $p_add_dir is added.  // Options :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_OPT_COMMENT :  //   PCLZIP_CB_PRE_ADD :  //   PCLZIP_CB_POST_ADD :  // Return Values :  //   0 on failure,  //   The list of the added files, with a status of the add action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function create($p_filelist)  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Set default values    $v_options = array();    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Look for arguments    if ($v_size > 1) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Remove from the options list the first argument      array_shift($v_arg_list);      $v_size--;      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_ADD => 'optional',                                                   PCLZIP_CB_POST_ADD => 'optional',                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',                                                   PCLZIP_OPT_COMMENT => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'                                                   //, PCLZIP_OPT_CRYPT => 'optional'                                             ));        if ($v_result != 1) {          return 0;        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];        }        else if ($v_size > 2) {          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,		                       "Invalid number / type of arguments");          return 0;        }      }    }    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Init    $v_string_list = array();    $v_att_list = array();    $v_filedescr_list = array();    $p_result_list = array();    // ----- Look if the $p_filelist is really an array    if (is_array($p_filelist)) {      // ----- Look if the first element is also an array      //       This will mean that this is a file description entry      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {        $v_att_list = $p_filelist;      }      // ----- The list is a list of string names      else {        $v_string_list = $p_filelist;      }    }    // ----- Look if the $p_filelist is a string    else if (is_string($p_filelist)) {      // ----- Create a list from the string      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);    }    // ----- Invalid variable type for $p_filelist    else {      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_filelist");      return 0;    }    // ----- Reformat the string list    if (sizeof($v_string_list) != 0) {      foreach ($v_string_list as $v_string) {        if ($v_string != '') {          $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;        }        else {        }      }    }    // ----- For each file in the list check the attributes    $v_supported_attributes    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'             ,PCLZIP_ATT_FILE_MTIME => 'optional'             ,PCLZIP_ATT_FILE_CONTENT => 'optional'             ,PCLZIP_ATT_FILE_COMMENT => 'optional'						);    foreach ($v_att_list as $v_entry) {      $v_result = $this->privFileDescrParseAtt($v_entry,                                               $v_filedescr_list[],                                               $v_options,                                               $v_supported_attributes);      if ($v_result != 1) {        return 0;      }    }    // ----- Expand the filelist (expand directories)    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Call the create fct    $v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Return    return $p_result_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   add($p_filelist, $p_add_dir="", $p_remove_dir="")  //   add($p_filelist, $p_option, $p_option_value, ...)  // Description :  //   This method supports two synopsis. The first one is historical.  //   This methods add the list of files in an existing archive.  //   If a file with the same name already exists, it is added at the end of the  //   archive, the first one is still present.  //   If the archive does not exist, it is created.  // Parameters :  //   $p_filelist : An array containing file or directory names, or  //                 a string containing one filename or one directory name, or  //                 a string containing a list of filenames and/or directory  //                 names separated by spaces.  //   $p_add_dir : A path to add before the real path of the archived file,  //                in order to have it memorized in the archive.  //   $p_remove_dir : A path to remove from the real path of the file to archive,  //                   in order to have a shorter path memorized in the archive.  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir  //                   is removed first, before $p_add_dir is added.  // Options :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_OPT_COMMENT :  //   PCLZIP_OPT_ADD_COMMENT :  //   PCLZIP_OPT_PREPEND_COMMENT :  //   PCLZIP_CB_PRE_ADD :  //   PCLZIP_CB_POST_ADD :  // Return Values :  //   0 on failure,  //   The list of the added files, with a status of the add action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function add($p_filelist)  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Set default values    $v_options = array();    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Look for arguments    if ($v_size > 1) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Remove form the options list the first argument      array_shift($v_arg_list);      $v_size--;      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_ADD => 'optional',                                                   PCLZIP_CB_POST_ADD => 'optional',                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',                                                   PCLZIP_OPT_COMMENT => 'optional',                                                   PCLZIP_OPT_ADD_COMMENT => 'optional',                                                   PCLZIP_OPT_PREPEND_COMMENT => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'                                                   //, PCLZIP_OPT_CRYPT => 'optional'												   ));        if ($v_result != 1) {          return 0;        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];        }        else if ($v_size > 2) {          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");          // ----- Return          return 0;        }      }    }    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Init    $v_string_list = array();    $v_att_list = array();    $v_filedescr_list = array();    $p_result_list = array();    // ----- Look if the $p_filelist is really an array    if (is_array($p_filelist)) {      // ----- Look if the first element is also an array      //       This will mean that this is a file description entry      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {        $v_att_list = $p_filelist;      }      // ----- The list is a list of string names      else {        $v_string_list = $p_filelist;      }    }    // ----- Look if the $p_filelist is a string    else if (is_string($p_filelist)) {      // ----- Create a list from the string      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);    }    // ----- Invalid variable type for $p_filelist    else {      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type '".gettype($p_filelist)."' for p_filelist");      return 0;    }    // ----- Reformat the string list    if (sizeof($v_string_list) != 0) {      foreach ($v_string_list as $v_string) {        $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;      }    }    // ----- For each file in the list check the attributes    $v_supported_attributes    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'             ,PCLZIP_ATT_FILE_MTIME => 'optional'             ,PCLZIP_ATT_FILE_CONTENT => 'optional'             ,PCLZIP_ATT_FILE_COMMENT => 'optional'						);    foreach ($v_att_list as $v_entry) {      $v_result = $this->privFileDescrParseAtt($v_entry,                                               $v_filedescr_list[],                                               $v_options,                                               $v_supported_attributes);      if ($v_result != 1) {        return 0;      }    }    // ----- Expand the filelist (expand directories)    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Call the create fct    $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options);    if ($v_result != 1) {      return 0;    }    // ----- Return    return $p_result_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : listContent()  // Description :  //   This public method, gives the list of the files and directories, with their  //   properties.  //   The properties of each entries in the list are (used also in other functions) :  //     filename : Name of the file. For a create or add action it is the filename  //                given by the user. For an extract function it is the filename  //                of the extracted file.  //     stored_filename : Name of the file / directory stored in the archive.  //     size : Size of the stored file.  //     compressed_size : Size of the file's data compressed in the archive  //                       (without the headers overhead)  //     mtime : Last known modification date of the file (UNIX timestamp)  //     comment : Comment associated with the file  //     folder : true | false  //     index : index of the file in the archive  //     status : status of the action (depending of the action) :  //              Values are :  //                ok : OK !  //                filtered : the file / dir is not extracted (filtered by user)  //                already_a_directory : the file can not be extracted because a  //                                      directory with the same name already exists  //                write_protected : the file can not be extracted because a file  //                                  with the same name already exists and is  //                                  write protected  //                newer_exist : the file was not extracted because a newer file exists  //                path_creation_fail : the file is not extracted because the folder  //                                     does not exist and can not be created  //                write_error : the file was not extracted because there was a  //                              error while writing the file  //                read_error : the file was not extracted because there was a error  //                             while reading the file  //                invalid_header : the file was not extracted because of an archive  //                                 format error (bad file header)  //   Note that each time a method can continue operating when there  //   is an action error on a file, the error is only logged in the file status.  // Return Values :  //   0 on an unrecoverable failure,  //   The list of the files in the archive.  // --------------------------------------------------------------------------------  function listContent()  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Call the extracting fct    $p_list = array();    if (($v_result = $this->privList($p_list)) != 1)    {      unset($p_list);      return(0);    }    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   extract($p_path="./", $p_remove_path="")  //   extract([$p_option, $p_option_value, ...])  // Description :  //   This method supports two synopsis. The first one is historical.  //   This method extract all the files / directories from the archive to the  //   folder indicated in $p_path.  //   If you want to ignore the 'root' part of path of the memorized files  //   you can indicate this in the optional $p_remove_path parameter.  //   By default, if a newer file with the same name already exists, the  //   file is not extracted.  //  //   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions  //   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append  //   at the end of the path value of PCLZIP_OPT_PATH.  // Parameters :  //   $p_path : Path where the files and directories are to be extracted  //   $p_remove_path : First part ('root' part) of the memorized path  //                    (if any similar) to remove while extracting.  // Options :  //   PCLZIP_OPT_PATH :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_CB_PRE_EXTRACT :  //   PCLZIP_CB_POST_EXTRACT :  // Return Values :  //   0 or a negative value on failure,  //   The list of the extracted files, with a status of the action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function extract()  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Set default values    $v_options = array();//    $v_path = "./";    $v_path = '';    $v_remove_path = "";    $v_remove_all_path = false;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Default values for option    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;    // ----- Look for arguments    if ($v_size > 0) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',                                                   PCLZIP_CB_POST_EXTRACT => 'optional',                                                   PCLZIP_OPT_SET_CHMOD => 'optional',                                                   PCLZIP_OPT_BY_NAME => 'optional',                                                   PCLZIP_OPT_BY_EREG => 'optional',                                                   PCLZIP_OPT_BY_PREG => 'optional',                                                   PCLZIP_OPT_BY_INDEX => 'optional',                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',                                                   PCLZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'												    ));        if ($v_result != 1) {          return 0;        }        // ----- Set the arguments        if (isset($v_options[PCLZIP_OPT_PATH])) {          $v_path = $v_options[PCLZIP_OPT_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];        }        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {          // ----- Check for '/' in last path char          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {            $v_path .= '/';          }          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_path = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_remove_path = $v_arg_list[1];        }        else if ($v_size > 2) {          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");          // ----- Return          return 0;        }      }    }    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Trace    // ----- Call the extracting fct    $p_list = array();    $v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path,	                                     $v_remove_all_path, $v_options);    if ($v_result < 1) {      unset($p_list);      return(0);    }    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   extractByIndex($p_index, $p_path="./", $p_remove_path="")  //   extractByIndex($p_index, [$p_option, $p_option_value, ...])  // Description :  //   This method supports two synopsis. The first one is historical.  //   This method is doing a partial extract of the archive.  //   The extracted files or folders are identified by their index in the  //   archive (from 0 to n).  //   Note that if the index identify a folder, only the folder entry is  //   extracted, not all the files included in the archive.  // Parameters :  //   $p_index : A single index (integer) or a string of indexes of files to  //              extract. The form of the string is "0,4-6,8-12" with only numbers  //              and '-' for range or ',' to separate ranges. No spaces or ';'  //              are allowed.  //   $p_path : Path where the files and directories are to be extracted  //   $p_remove_path : First part ('root' part) of the memorized path  //                    (if any similar) to remove while extracting.  // Options :  //   PCLZIP_OPT_PATH :  //   PCLZIP_OPT_ADD_PATH :  //   PCLZIP_OPT_REMOVE_PATH :  //   PCLZIP_OPT_REMOVE_ALL_PATH :  //   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and  //     not as files.  //     The resulting content is in a new field 'content' in the file  //     structure.  //     This option must be used alone (any other options are ignored).  //   PCLZIP_CB_PRE_EXTRACT :  //   PCLZIP_CB_POST_EXTRACT :  // Return Values :  //   0 on failure,  //   The list of the extracted files, with a status of the action.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  //function extractByIndex($p_index, options...)  function extractByIndex($p_index)  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Set default values    $v_options = array();//    $v_path = "./";    $v_path = '';    $v_remove_path = "";    $v_remove_all_path = false;    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Default values for option    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;    // ----- Look for arguments    if ($v_size > 1) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Remove form the options list the first argument      array_shift($v_arg_list);      $v_size--;      // ----- Look for first arg      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {        // ----- Parse the options        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                            array (PCLZIP_OPT_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',                                                   PCLZIP_OPT_ADD_PATH => 'optional',                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',                                                   PCLZIP_CB_POST_EXTRACT => 'optional',                                                   PCLZIP_OPT_SET_CHMOD => 'optional',                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'												   ));        if ($v_result != 1) {          return 0;        }        // ----- Set the arguments        if (isset($v_options[PCLZIP_OPT_PATH])) {          $v_path = $v_options[PCLZIP_OPT_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];        }        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];        }        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {          // ----- Check for '/' in last path char          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {            $v_path .= '/';          }          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];        }        if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {          $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;        }        else {        }      }      // ----- Look for 2 args      // Here we need to support the first historic synopsis of the      // method.      else {        // ----- Get the first argument        $v_path = $v_arg_list[0];        // ----- Look for the optional second argument        if ($v_size == 2) {          $v_remove_path = $v_arg_list[1];        }        else if ($v_size > 2) {          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");          // ----- Return          return 0;        }      }    }    // ----- Trace    // ----- Trick    // Here I want to reuse extractByRule(), so I need to parse the $p_index    // with privParseOptions()    $v_arg_trick = array (PCLZIP_OPT_BY_INDEX, $p_index);    $v_options_trick = array();    $v_result = $this->privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick,                                        array (PCLZIP_OPT_BY_INDEX => 'optional' ));    if ($v_result != 1) {        return 0;    }    $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];    // ----- Look for default option values    $this->privOptionDefaultThreshold($v_options);    // ----- Call the extracting fct    if (($v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) < 1) {        return(0);    }    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function :  //   delete([$p_option, $p_option_value, ...])  // Description :  //   This method removes files from the archive.  //   If no parameters are given, then all the archive is emptied.  // Parameters :  //   None or optional arguments.  // Options :  //   PCLZIP_OPT_BY_INDEX :  //   PCLZIP_OPT_BY_NAME :  //   PCLZIP_OPT_BY_EREG :  //   PCLZIP_OPT_BY_PREG :  // Return Values :  //   0 on failure,  //   The list of the files which are still present in the archive.  //   (see PclZip::listContent() for list entry format)  // --------------------------------------------------------------------------------  function delete()  {    $v_result=1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Set default values    $v_options = array();    // ----- Look for variable options arguments    $v_size = func_num_args();    // ----- Look for arguments    if ($v_size > 0) {      // ----- Get the arguments      $v_arg_list = func_get_args();      // ----- Parse the options      $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,                                        array (PCLZIP_OPT_BY_NAME => 'optional',                                               PCLZIP_OPT_BY_EREG => 'optional',                                               PCLZIP_OPT_BY_PREG => 'optional',                                               PCLZIP_OPT_BY_INDEX => 'optional' ));      if ($v_result != 1) {          return 0;      }    }    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Call the delete fct    $v_list = array();    if (($v_result = $this->privDeleteByRule($v_list, $v_options)) != 1) {      $this->privSwapBackMagicQuotes();      unset($v_list);      return(0);    }    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : deleteByIndex()  // Description :  //   ***** Deprecated *****  //   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.  // --------------------------------------------------------------------------------  function deleteByIndex($p_index)  {    $p_list = $this->delete(PCLZIP_OPT_BY_INDEX, $p_index);    // ----- Return    return $p_list;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : properties()  // Description :  //   This method gives the properties of the archive.  //   The properties are :  //     nb : Number of files in the archive  //     comment : Comment associated with the archive file  //     status : not_exist, ok  // Parameters :  //   None  // Return Values :  //   0 on failure,  //   An array with the archive properties.  // --------------------------------------------------------------------------------  function properties()  {    // ----- Reset the error handler    $this->privErrorReset();    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Check archive    if (!$this->privCheckFormat()) {      $this->privSwapBackMagicQuotes();      return(0);    }    // ----- Default properties    $v_prop = array();    $v_prop['comment'] = '';    $v_prop['nb'] = 0;    $v_prop['status'] = 'not_exist';    // ----- Look if file exists    if (@is_file($this->zipname))    {      // ----- Open the zip file      if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)      {        $this->privSwapBackMagicQuotes();        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in binary read mode');        // ----- Return        return 0;      }      // ----- Read the central directory informations      $v_central_dir = array();      if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)      {        $this->privSwapBackMagicQuotes();        return 0;      }      // ----- Close the zip file      $this->privCloseFd();      // ----- Set the user attributes      $v_prop['comment'] = $v_central_dir['comment'];      $v_prop['nb'] = $v_central_dir['entries'];      $v_prop['status'] = 'ok';    }    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_prop;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : duplicate()  // Description :  //   This method creates an archive by copying the content of an other one. If  //   the archive already exist, it is replaced by the new one without any warning.  // Parameters :  //   $p_archive : The filename of a valid archive, or  //                a valid PclZip object.  // Return Values :  //   1 on success.  //   0 or a negative value on error (error code).  // --------------------------------------------------------------------------------  function duplicate($p_archive)  {    $v_result = 1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Look if the $p_archive is a PclZip object    if ((is_object($p_archive)) && (get_class($p_archive) == 'pclzip'))    {      // ----- Duplicate the archive      $v_result = $this->privDuplicate($p_archive->zipname);    }    // ----- Look if the $p_archive is a string (so a filename)    else if (is_string($p_archive))    {      // ----- Check that $p_archive is a valid zip file      // TBC : Should also check the archive format      if (!is_file($p_archive)) {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "No file with filename '".$p_archive."'");        $v_result = PCLZIP_ERR_MISSING_FILE;      }      else {        // ----- Duplicate the archive        $v_result = $this->privDuplicate($p_archive);      }    }    // ----- Invalid variable    else    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add");      $v_result = PCLZIP_ERR_INVALID_PARAMETER;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : merge()  // Description :  //   This method merge the $p_archive_to_add archive at the end of the current  //   one ($this).  //   If the archive ($this) does not exist, the merge becomes a duplicate.  //   If the $p_archive_to_add archive does not exist, the merge is a success.  // Parameters :  //   $p_archive_to_add : It can be directly the filename of a valid zip archive,  //                       or a PclZip object archive.  // Return Values :  //   1 on success,  //   0 or negative values on error (see below).  // --------------------------------------------------------------------------------  function merge($p_archive_to_add)  {    $v_result = 1;    // ----- Reset the error handler    $this->privErrorReset();    // ----- Check archive    if (!$this->privCheckFormat()) {      return(0);    }    // ----- Look if the $p_archive_to_add is a PclZip object    if ((is_object($p_archive_to_add)) && (get_class($p_archive_to_add) == 'pclzip'))    {      // ----- Merge the archive      $v_result = $this->privMerge($p_archive_to_add);    }    // ----- Look if the $p_archive_to_add is a string (so a filename)    else if (is_string($p_archive_to_add))    {      // ----- Create a temporary archive      $v_object_archive = new PclZip($p_archive_to_add);      // ----- Merge the archive      $v_result = $this->privMerge($v_object_archive);    }    // ----- Invalid variable    else    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_archive_to_add");      $v_result = PCLZIP_ERR_INVALID_PARAMETER;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : errorCode()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function errorCode()  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      return(PclErrorCode());    }    else {      return($this->error_code);    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : errorName()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function errorName($p_with_code=false)  {    $v_name = array ( PCLZIP_ERR_NO_ERROR => 'PCLZIP_ERR_NO_ERROR',                      PCLZIP_ERR_WRITE_OPEN_FAIL => 'PCLZIP_ERR_WRITE_OPEN_FAIL',                      PCLZIP_ERR_READ_OPEN_FAIL => 'PCLZIP_ERR_READ_OPEN_FAIL',                      PCLZIP_ERR_INVALID_PARAMETER => 'PCLZIP_ERR_INVALID_PARAMETER',                      PCLZIP_ERR_MISSING_FILE => 'PCLZIP_ERR_MISSING_FILE',                      PCLZIP_ERR_FILENAME_TOO_LONG => 'PCLZIP_ERR_FILENAME_TOO_LONG',                      PCLZIP_ERR_INVALID_ZIP => 'PCLZIP_ERR_INVALID_ZIP',                      PCLZIP_ERR_BAD_EXTRACTED_FILE => 'PCLZIP_ERR_BAD_EXTRACTED_FILE',                      PCLZIP_ERR_DIR_CREATE_FAIL => 'PCLZIP_ERR_DIR_CREATE_FAIL',                      PCLZIP_ERR_BAD_EXTENSION => 'PCLZIP_ERR_BAD_EXTENSION',                      PCLZIP_ERR_BAD_FORMAT => 'PCLZIP_ERR_BAD_FORMAT',                      PCLZIP_ERR_DELETE_FILE_FAIL => 'PCLZIP_ERR_DELETE_FILE_FAIL',                      PCLZIP_ERR_RENAME_FILE_FAIL => 'PCLZIP_ERR_RENAME_FILE_FAIL',                      PCLZIP_ERR_BAD_CHECKSUM => 'PCLZIP_ERR_BAD_CHECKSUM',                      PCLZIP_ERR_INVALID_ARCHIVE_ZIP => 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP',                      PCLZIP_ERR_MISSING_OPTION_VALUE => 'PCLZIP_ERR_MISSING_OPTION_VALUE',                      PCLZIP_ERR_INVALID_OPTION_VALUE => 'PCLZIP_ERR_INVALID_OPTION_VALUE',                      PCLZIP_ERR_UNSUPPORTED_COMPRESSION => 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION',                      PCLZIP_ERR_UNSUPPORTED_ENCRYPTION => 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION'                      ,PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE => 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE'                      ,PCLZIP_ERR_DIRECTORY_RESTRICTION => 'PCLZIP_ERR_DIRECTORY_RESTRICTION'                    );    if (isset($v_name[$this->error_code])) {      $v_value = $v_name[$this->error_code];    }    else {      $v_value = 'NoName';    }    if ($p_with_code) {      return($v_value.' ('.$this->error_code.')');    }    else {      return($v_value);    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : errorInfo()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function errorInfo($p_full=false)  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      return(PclErrorString());    }    else {      if ($p_full) {        return($this->errorName(true)." : ".$this->error_string);      }      else {        return($this->error_string." [code ".$this->error_code."]");      }    }  }  // --------------------------------------------------------------------------------// --------------------------------------------------------------------------------// ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****// *****                                                        *****// *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****// --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCheckFormat()  // Description :  //   This method check that the archive exists and is a valid zip archive.  //   Several level of check exists. (futur)  // Parameters :  //   $p_level : Level of check. Default 0.  //              0 : Check the first bytes (magic codes) (default value))  //              1 : 0 + Check the central directory (futur)  //              2 : 1 + Check each file header (futur)  // Return Values :  //   true on success,  //   false on error, the error code is set.  // --------------------------------------------------------------------------------  function privCheckFormat($p_level=0)  {    $v_result = true;	// ----- Reset the file system cache    clearstatcache();    // ----- Reset the error handler    $this->privErrorReset();    // ----- Look if the file exits    if (!is_file($this->zipname)) {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "Missing archive file '".$this->zipname."'");      return(false);    }    // ----- Check that the file is readeable    if (!is_readable($this->zipname)) {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to read archive '".$this->zipname."'");      return(false);    }    // ----- Check the magic code    // TBC    // ----- Check the central header    // TBC    // ----- Check each file header    // TBC    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privParseOptions()  // Description :  //   This internal methods reads the variable list of arguments ($p_options_list,  //   $p_size) and generate an array with the options and values ($v_result_list).  //   $v_requested_options contains the options that can be present and those that  //   must be present.  //   $v_requested_options is an array, with the option value as key, and 'optional',  //   or 'mandatory' as value.  // Parameters :  //   See above.  // Return Values :  //   1 on success.  //   0 on failure.  // --------------------------------------------------------------------------------  function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options=false)  {    $v_result=1;    // ----- Read the options    $i=0;    while ($i<$p_size) {      // ----- Check if the option is supported      if (!isset($v_requested_options[$p_options_list[$i]])) {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid optional parameter '".$p_options_list[$i]."' for this method");        // ----- Return        return PclZip::errorCode();      }      // ----- Look for next option      switch ($p_options_list[$i]) {        // ----- Look for options that request a path value        case PCLZIP_OPT_PATH :        case PCLZIP_OPT_REMOVE_PATH :        case PCLZIP_OPT_ADD_PATH :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);          $i++;        break;        case PCLZIP_OPT_TEMP_FILE_THRESHOLD :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            return PclZip::errorCode();          }          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");            return PclZip::errorCode();          }          // ----- Check the value          $v_value = $p_options_list[$i+1];          if ((!is_integer($v_value)) || ($v_value<0)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Integer expected for option '".PclZipUtilOptionText($p_options_list[$i])."'");            return PclZip::errorCode();          }          // ----- Get the value (and convert it in bytes)          $v_result_list[$p_options_list[$i]] = $v_value*1048576;          $i++;        break;        case PCLZIP_OPT_TEMP_FILE_ON :          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");            return PclZip::errorCode();          }          $v_result_list[$p_options_list[$i]] = true;        break;        case PCLZIP_OPT_TEMP_FILE_OFF :          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'");            return PclZip::errorCode();          }          // ----- Check for incompatible options          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'");            return PclZip::errorCode();          }          $v_result_list[$p_options_list[$i]] = true;        break;        case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (   is_string($p_options_list[$i+1])              && ($p_options_list[$i+1] != '')) {            $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);            $i++;          }          else {          }        break;        // ----- Look for options that request an array of string for value        case PCLZIP_OPT_BY_NAME :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (is_string($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i+1];          }          else if (is_array($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          $i++;        break;        // ----- Look for options that request an EREG or PREG expression        case PCLZIP_OPT_BY_EREG :          // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG          // to PCLZIP_OPT_BY_PREG          $p_options_list[$i] = PCLZIP_OPT_BY_PREG;        case PCLZIP_OPT_BY_PREG :        //case PCLZIP_OPT_CRYPT :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (is_string($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          $i++;        break;        // ----- Look for options that takes a string        case PCLZIP_OPT_COMMENT :        case PCLZIP_OPT_ADD_COMMENT :        case PCLZIP_OPT_PREPEND_COMMENT :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE,			                     "Missing parameter value for option '"								 .PclZipUtilOptionText($p_options_list[$i])								 ."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          if (is_string($p_options_list[$i+1])) {              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE,			                     "Wrong parameter value for option '"								 .PclZipUtilOptionText($p_options_list[$i])								 ."'");            // ----- Return            return PclZip::errorCode();          }          $i++;        break;        // ----- Look for options that request an array of index        case PCLZIP_OPT_BY_INDEX :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_work_list = array();          if (is_string($p_options_list[$i+1])) {              // ----- Remove spaces              $p_options_list[$i+1] = strtr($p_options_list[$i+1], ' ', '');              // ----- Parse items              $v_work_list = explode(",", $p_options_list[$i+1]);          }          else if (is_integer($p_options_list[$i+1])) {              $v_work_list[0] = $p_options_list[$i+1].'-'.$p_options_list[$i+1];          }          else if (is_array($p_options_list[$i+1])) {              $v_work_list = $p_options_list[$i+1];          }          else {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Value must be integer, string or array for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Reduce the index list          // each index item in the list must be a couple with a start and          // an end value : [0,3], [5-5], [8-10], ...          // ----- Check the format of each item          $v_sort_flag=false;          $v_sort_value=0;          for ($j=0; $j<sizeof($v_work_list); $j++) {              // ----- Explode the item              $v_item_list = explode("-", $v_work_list[$j]);              $v_size_item_list = sizeof($v_item_list);              // ----- TBC : Here we might check that each item is a              // real integer ...              // ----- Look for single value              if ($v_size_item_list == 1) {                  // ----- Set the option value                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];              }              elseif ($v_size_item_list == 2) {                  // ----- Set the option value                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];              }              else {                  // ----- Error log                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Too many values in index range for option '".PclZipUtilOptionText($p_options_list[$i])."'");                  // ----- Return                  return PclZip::errorCode();              }              // ----- Look for list sort              if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {                  $v_sort_flag=true;                  // ----- TBC : An automatic sort should be writen ...                  // ----- Error log                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Invalid order of index range for option '".PclZipUtilOptionText($p_options_list[$i])."'");                  // ----- Return                  return PclZip::errorCode();              }              $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];          }          // ----- Sort the items          if ($v_sort_flag) {              // TBC : To Be Completed          }          // ----- Next option          $i++;        break;        // ----- Look for options that request no value        case PCLZIP_OPT_REMOVE_ALL_PATH :        case PCLZIP_OPT_EXTRACT_AS_STRING :        case PCLZIP_OPT_NO_COMPRESSION :        case PCLZIP_OPT_EXTRACT_IN_OUTPUT :        case PCLZIP_OPT_REPLACE_NEWER :        case PCLZIP_OPT_STOP_ON_ERROR :          $v_result_list[$p_options_list[$i]] = true;        break;        // ----- Look for options that request an octal value        case PCLZIP_OPT_SET_CHMOD :          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];          $i++;        break;        // ----- Look for options that request a call-back        case PCLZIP_CB_PRE_EXTRACT :        case PCLZIP_CB_POST_EXTRACT :        case PCLZIP_CB_PRE_ADD :        case PCLZIP_CB_POST_ADD :        /* for futur use        case PCLZIP_CB_PRE_DELETE :        case PCLZIP_CB_POST_DELETE :        case PCLZIP_CB_PRE_LIST :        case PCLZIP_CB_POST_LIST :        */          // ----- Check the number of parameters          if (($i+1) >= $p_size) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Get the value          $v_function_name = $p_options_list[$i+1];          // ----- Check that the value is a valid existing function          if (!function_exists($v_function_name)) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Function '".$v_function_name."()' is not an existing function for option '".PclZipUtilOptionText($p_options_list[$i])."'");            // ----- Return            return PclZip::errorCode();          }          // ----- Set the attribute          $v_result_list[$p_options_list[$i]] = $v_function_name;          $i++;        break;        default :          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,		                       "Unknown parameter '"							   .$p_options_list[$i]."'");          // ----- Return          return PclZip::errorCode();      }      // ----- Next options      $i++;    }    // ----- Look for mandatory options    if ($v_requested_options !== false) {      for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {        // ----- Look for mandatory option        if ($v_requested_options[$key] == 'mandatory') {          // ----- Look if present          if (!isset($v_result_list[$key])) {            // ----- Error log            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter ".PclZipUtilOptionText($key)."(".$key.")");            // ----- Return            return PclZip::errorCode();          }        }      }    }    // ----- Look for default values    if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privOptionDefaultThreshold()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privOptionDefaultThreshold(&$p_options)  {    $v_result=1;    if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])        || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {      return $v_result;    }    // ----- Get 'memory_limit' configuration value    $v_memory_limit = ini_get('memory_limit');    $v_memory_limit = trim($v_memory_limit);    $last = strtolower(substr($v_memory_limit, -1));    if($last == 'g')        //$v_memory_limit = $v_memory_limit*1024*1024*1024;        $v_memory_limit = $v_memory_limit*1073741824;    if($last == 'm')        //$v_memory_limit = $v_memory_limit*1024*1024;        $v_memory_limit = $v_memory_limit*1048576;    if($last == 'k')        $v_memory_limit = $v_memory_limit*1024;    $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit*PCLZIP_TEMPORARY_FILE_RATIO);    // ----- Sanity check : No threshold if value lower than 1M    if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) {      unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privFileDescrParseAtt()  // Description :  // Parameters :  // Return Values :  //   1 on success.  //   0 on failure.  // --------------------------------------------------------------------------------  function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options=false)  {    $v_result=1;    // ----- For each file in the list check the attributes    foreach ($p_file_list as $v_key => $v_value) {      // ----- Check if the option is supported      if (!isset($v_requested_options[$v_key])) {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file attribute '".$v_key."' for this file");        // ----- Return        return PclZip::errorCode();      }      // ----- Look for attribute      switch ($v_key) {        case PCLZIP_ATT_FILE_NAME :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['filename'] = PclZipUtilPathReduction($v_value);          if ($p_filedescr['filename'] == '') {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty filename for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }        break;        case PCLZIP_ATT_FILE_NEW_SHORT_NAME :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value);          if ($p_filedescr['new_short_name'] == '') {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty short filename for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }        break;        case PCLZIP_ATT_FILE_NEW_FULL_NAME :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value);          if ($p_filedescr['new_full_name'] == '') {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty full filename for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }        break;        // ----- Look for options that takes a string        case PCLZIP_ATT_FILE_COMMENT :          if (!is_string($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['comment'] = $v_value;        break;        case PCLZIP_ATT_FILE_MTIME :          if (!is_integer($v_value)) {            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". Integer expected for attribute '".PclZipUtilOptionText($v_key)."'");            return PclZip::errorCode();          }          $p_filedescr['mtime'] = $v_value;        break;        case PCLZIP_ATT_FILE_CONTENT :          $p_filedescr['content'] = $v_value;        break;        default :          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,		                           "Unknown parameter '".$v_key."'");          // ----- Return          return PclZip::errorCode();      }      // ----- Look for mandatory options      if ($v_requested_options !== false) {        for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {          // ----- Look for mandatory option          if ($v_requested_options[$key] == 'mandatory') {            // ----- Look if present            if (!isset($p_file_list[$key])) {              PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter ".PclZipUtilOptionText($key)."(".$key.")");              return PclZip::errorCode();            }          }        }      }    // end foreach    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privFileDescrExpand()  // Description :  //   This method look for each item of the list to see if its a file, a folder  //   or a string to be added as file. For any other type of files (link, other)  //   just ignore the item.  //   Then prepare the information that will be stored for that file.  //   When its a folder, expand the folder with all the files that are in that  //   folder (recursively).  // Parameters :  // Return Values :  //   1 on success.  //   0 on failure.  // --------------------------------------------------------------------------------  function privFileDescrExpand(&$p_filedescr_list, &$p_options)  {    $v_result=1;    // ----- Create a result list    $v_result_list = array();    // ----- Look each entry    for ($i=0; $i<sizeof($p_filedescr_list); $i++) {      // ----- Get filedescr      $v_descr = $p_filedescr_list[$i];      // ----- Reduce the filename      $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false);      $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']);      // ----- Look for real file or folder      if (file_exists($v_descr['filename'])) {        if (@is_file($v_descr['filename'])) {          $v_descr['type'] = 'file';        }        else if (@is_dir($v_descr['filename'])) {          $v_descr['type'] = 'folder';        }        else if (@is_link($v_descr['filename'])) {          // skip          continue;        }        else {          // skip          continue;        }      }      // ----- Look for string added as file      else if (isset($v_descr['content'])) {        $v_descr['type'] = 'virtual_file';      }      // ----- Missing file      else {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '".$v_descr['filename']."' does not exist");        // ----- Return        return PclZip::errorCode();      }      // ----- Calculate the stored filename      $this->privCalculateStoredFilename($v_descr, $p_options);      // ----- Add the descriptor in result list      $v_result_list[sizeof($v_result_list)] = $v_descr;      // ----- Look for folder      if ($v_descr['type'] == 'folder') {        // ----- List of items in folder        $v_dirlist_descr = array();        $v_dirlist_nb = 0;        if ($v_folder_handler = @opendir($v_descr['filename'])) {          while (($v_item_handler = @readdir($v_folder_handler)) !== false) {            // ----- Skip '.' and '..'            if (($v_item_handler == '.') || ($v_item_handler == '..')) {                continue;            }            // ----- Compose the full filename            $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'].'/'.$v_item_handler;            // ----- Look for different stored filename            // Because the name of the folder was changed, the name of the            // files/sub-folders also change            if (($v_descr['stored_filename'] != $v_descr['filename'])                 && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {              if ($v_descr['stored_filename'] != '') {                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'].'/'.$v_item_handler;              }              else {                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler;              }            }            $v_dirlist_nb++;          }          @closedir($v_folder_handler);        }        else {          // TBC : unable to open folder in read mode        }        // ----- Expand each element of the list        if ($v_dirlist_nb != 0) {          // ----- Expand          if (($v_result = $this->privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) {            return $v_result;          }          // ----- Concat the resulting list          $v_result_list = array_merge($v_result_list, $v_dirlist_descr);        }        else {        }        // ----- Free local array        unset($v_dirlist_descr);      }    }    // ----- Get the result list    $p_filedescr_list = $v_result_list;    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCreate()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privCreate($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    $v_list_detail = array();    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Open the file in write mode    if (($v_result = $this->privOpenFd('wb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Add the list of files    $v_result = $this->privAddList($p_filedescr_list, $p_result_list, $p_options);    // ----- Close    $this->privCloseFd();    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAdd()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privAdd($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    $v_list_detail = array();    // ----- Look if the archive exists or is empty    if ((!is_file($this->zipname)) || (filesize($this->zipname) == 0))    {      // ----- Do a create      $v_result = $this->privCreate($p_filedescr_list, $p_result_list, $p_options);      // ----- Return      return $v_result;    }    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Open the zip file    if (($v_result=$this->privOpenFd('rb')) != 1)    {      // ----- Magic quotes trick      $this->privSwapBackMagicQuotes();      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privCloseFd();      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Go to beginning of File    @rewind($this->zip_fd);    // ----- Creates a temporay file    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';    // ----- Open the temporary file in write mode    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)    {      $this->privCloseFd();      $this->privSwapBackMagicQuotes();      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_zip_temp_name.'\' in binary write mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Copy the files from the archive to the temporary file    // TBC : Here I should better append the file and go back to erase the central dir    $v_size = $v_central_dir['offset'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($this->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Swap the file descriptor    // Here is a trick : I swap the temporary fd with the zip fd, in order to use    // the following methods on the temporary fil and not the real archive    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Add the files    $v_header_list = array();    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)    {      fclose($v_zip_temp_fd);      $this->privCloseFd();      @unlink($v_zip_temp_name);      $this->privSwapBackMagicQuotes();      // ----- Return      return $v_result;    }    // ----- Store the offset of the central dir    $v_offset = @ftell($this->zip_fd);    // ----- Copy the block of file headers from the old archive    $v_size = $v_central_dir['size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($v_zip_temp_fd, $v_read_size);      @fwrite($this->zip_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Create the Central Dir files header    for ($i=0, $v_count=0; $i<sizeof($v_header_list); $i++)    {      // ----- Create the file header      if ($v_header_list[$i]['status'] == 'ok') {        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {          fclose($v_zip_temp_fd);          $this->privCloseFd();          @unlink($v_zip_temp_name);          $this->privSwapBackMagicQuotes();          // ----- Return          return $v_result;        }        $v_count++;      }      // ----- Transform the header to a 'usable' info      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);    }    // ----- Zip file comment    $v_comment = $v_central_dir['comment'];    if (isset($p_options[PCLZIP_OPT_COMMENT])) {      $v_comment = $p_options[PCLZIP_OPT_COMMENT];    }    if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) {      $v_comment = $v_comment.$p_options[PCLZIP_OPT_ADD_COMMENT];    }    if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) {      $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT].$v_comment;    }    // ----- Calculate the size of the central header    $v_size = @ftell($this->zip_fd)-$v_offset;    // ----- Create the central dir footer    if (($v_result = $this->privWriteCentralHeader($v_count+$v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1)    {      // ----- Reset the file list      unset($v_header_list);      $this->privSwapBackMagicQuotes();      // ----- Return      return $v_result;    }    // ----- Swap back the file descriptor    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Close    $this->privCloseFd();    // ----- Close the temporary file    @fclose($v_zip_temp_fd);    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Delete the zip file    // TBC : I should test the result ...    @unlink($this->zipname);    // ----- Rename the temporary file    // TBC : I should test the result ...    //@rename($v_zip_temp_name, $this->zipname);    PclZipUtilRename($v_zip_temp_name, $this->zipname);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privOpenFd()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privOpenFd($p_mode)  {    $v_result=1;    // ----- Look if already open    if ($this->zip_fd != 0)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \''.$this->zipname.'\' already open');      // ----- Return      return PclZip::errorCode();    }    // ----- Open the zip file    if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in '.$p_mode.' mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCloseFd()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privCloseFd()  {    $v_result=1;    if ($this->zip_fd != 0)      @fclose($this->zip_fd);    $this->zip_fd = 0;    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddList()  // Description :  //   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is  //   different from the real path of the file. This is usefull if you want to have PclTar  //   running in any directory, and memorize relative path from an other directory.  // Parameters :  //   $p_list : An array containing the file or directory names to add in the tar  //   $p_result_list : list of added files with their properties (specially the status field)  //   $p_add_dir : Path to add in the filename path archived  //   $p_remove_dir : Path to remove in the filename path archived  // Return Values :  // --------------------------------------------------------------------------------//  function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)  function privAddList($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    // ----- Add the files    $v_header_list = array();    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)    {      // ----- Return      return $v_result;    }    // ----- Store the offset of the central dir    $v_offset = @ftell($this->zip_fd);    // ----- Create the Central Dir files header    for ($i=0,$v_count=0; $i<sizeof($v_header_list); $i++)    {      // ----- Create the file header      if ($v_header_list[$i]['status'] == 'ok') {        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {          // ----- Return          return $v_result;        }        $v_count++;      }      // ----- Transform the header to a 'usable' info      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);    }    // ----- Zip file comment    $v_comment = '';    if (isset($p_options[PCLZIP_OPT_COMMENT])) {      $v_comment = $p_options[PCLZIP_OPT_COMMENT];    }    // ----- Calculate the size of the central header    $v_size = @ftell($this->zip_fd)-$v_offset;    // ----- Create the central dir footer    if (($v_result = $this->privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1)    {      // ----- Reset the file list      unset($v_header_list);      // ----- Return      return $v_result;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddFileList()  // Description :  // Parameters :  //   $p_filedescr_list : An array containing the file description  //                      or directory names to add in the zip  //   $p_result_list : list of added files with their properties (specially the status field)  // Return Values :  // --------------------------------------------------------------------------------  function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options)  {    $v_result=1;    $v_header = array();    // ----- Recuperate the current number of elt in list    $v_nb = sizeof($p_result_list);    // ----- Loop on the files    for ($j=0; ($j<sizeof($p_filedescr_list)) && ($v_result==1); $j++) {      // ----- Format the filename      $p_filedescr_list[$j]['filename']      = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false);      // ----- Skip empty file names      // TBC : Can this be possible ? not checked in DescrParseAtt ?      if ($p_filedescr_list[$j]['filename'] == "") {        continue;      }      // ----- Check the filename      if (   ($p_filedescr_list[$j]['type'] != 'virtual_file')          && (!file_exists($p_filedescr_list[$j]['filename']))) {        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '".$p_filedescr_list[$j]['filename']."' does not exist");        return PclZip::errorCode();      }      // ----- Look if it is a file or a dir with no all path remove option      // or a dir with all its path removed//      if (   (is_file($p_filedescr_list[$j]['filename']))//          || (   is_dir($p_filedescr_list[$j]['filename'])      if (   ($p_filedescr_list[$j]['type'] == 'file')          || ($p_filedescr_list[$j]['type'] == 'virtual_file')          || (   ($p_filedescr_list[$j]['type'] == 'folder')              && (   !isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])                  || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))          ) {        // ----- Add the file        $v_result = $this->privAddFile($p_filedescr_list[$j], $v_header,                                       $p_options);        if ($v_result != 1) {          return $v_result;        }        // ----- Store the file infos        $p_result_list[$v_nb++] = $v_header;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddFile()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privAddFile($p_filedescr, &$p_header, &$p_options)  {    $v_result=1;    // ----- Working variable    $p_filename = $p_filedescr['filename'];    // TBC : Already done in the fileAtt check ... ?    if ($p_filename == "") {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file list parameter (invalid or empty list)");      // ----- Return      return PclZip::errorCode();    }    // ----- Look for a stored different filename    /* TBC : Removed    if (isset($p_filedescr['stored_filename'])) {      $v_stored_filename = $p_filedescr['stored_filename'];    }    else {      $v_stored_filename = $p_filedescr['stored_filename'];    }    */    // ----- Set the file properties    clearstatcache();    $p_header['version'] = 20;    $p_header['version_extracted'] = 10;    $p_header['flag'] = 0;    $p_header['compression'] = 0;    $p_header['crc'] = 0;    $p_header['compressed_size'] = 0;    $p_header['filename_len'] = strlen($p_filename);    $p_header['extra_len'] = 0;    $p_header['disk'] = 0;    $p_header['internal'] = 0;    $p_header['offset'] = 0;    $p_header['filename'] = $p_filename;// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;    $p_header['stored_filename'] = $p_filedescr['stored_filename'];    $p_header['extra'] = '';    $p_header['status'] = 'ok';    $p_header['index'] = -1;    // ----- Look for regular file    if ($p_filedescr['type']=='file') {      $p_header['external'] = 0x00000000;      $p_header['size'] = filesize($p_filename);    }    // ----- Look for regular folder    else if ($p_filedescr['type']=='folder') {      $p_header['external'] = 0x00000010;      $p_header['mtime'] = filemtime($p_filename);      $p_header['size'] = filesize($p_filename);    }    // ----- Look for virtual file    else if ($p_filedescr['type'] == 'virtual_file') {      $p_header['external'] = 0x00000000;      $p_header['size'] = strlen($p_filedescr['content']);    }    // ----- Look for filetime    if (isset($p_filedescr['mtime'])) {      $p_header['mtime'] = $p_filedescr['mtime'];    }    else if ($p_filedescr['type'] == 'virtual_file') {      $p_header['mtime'] = time();    }    else {      $p_header['mtime'] = filemtime($p_filename);    }    // ------ Look for file comment    if (isset($p_filedescr['comment'])) {      $p_header['comment_len'] = strlen($p_filedescr['comment']);      $p_header['comment'] = $p_filedescr['comment'];    }    else {      $p_header['comment_len'] = 0;      $p_header['comment'] = '';    }    // ----- Look for pre-add callback    if (isset($p_options[PCLZIP_CB_PRE_ADD])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_header, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_header['status'] = "skipped";        $v_result = 1;      }      // ----- Update the informations      // Only some fields can be modified      if ($p_header['stored_filename'] != $v_local_header['stored_filename']) {        $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']);      }    }    // ----- Look for empty stored filename    if ($p_header['stored_filename'] == "") {      $p_header['status'] = "filtered";    }    // ----- Check the path length    if (strlen($p_header['stored_filename']) > 0xFF) {      $p_header['status'] = 'filename_too_long';    }    // ----- Look if no error, or file not skipped    if ($p_header['status'] == 'ok') {      // ----- Look for a file      if ($p_filedescr['type'] == 'file') {        // ----- Look for using temporary file to zip        if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))            && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])                || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])                    && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_header['size'])) ) ) {          $v_result = $this->privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);          if ($v_result < PCLZIP_ERR_NO_ERROR) {            return $v_result;          }        }        // ----- Use "in memory" zip algo        else {        // ----- Open the source file        if (($v_file = @fopen($p_filename, "rb")) == 0) {          PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode");          return PclZip::errorCode();        }        // ----- Read the file content        $v_content = @fread($v_file, $p_header['size']);        // ----- Close the file        @fclose($v_file);        // ----- Calculate the CRC        $p_header['crc'] = @crc32($v_content);        // ----- Look for no compression        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {          // ----- Set header parameters          $p_header['compressed_size'] = $p_header['size'];          $p_header['compression'] = 0;        }        // ----- Look for normal compression        else {          // ----- Compress the content          $v_content = @gzdeflate($v_content);          // ----- Set header parameters          $p_header['compressed_size'] = strlen($v_content);          $p_header['compression'] = 8;        }        // ----- Call the header generation        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {          @fclose($v_file);          return $v_result;        }        // ----- Write the compressed (or not) content        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);        }      }      // ----- Look for a virtual file (a file from string)      else if ($p_filedescr['type'] == 'virtual_file') {        $v_content = $p_filedescr['content'];        // ----- Calculate the CRC        $p_header['crc'] = @crc32($v_content);        // ----- Look for no compression        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {          // ----- Set header parameters          $p_header['compressed_size'] = $p_header['size'];          $p_header['compression'] = 0;        }        // ----- Look for normal compression        else {          // ----- Compress the content          $v_content = @gzdeflate($v_content);          // ----- Set header parameters          $p_header['compressed_size'] = strlen($v_content);          $p_header['compression'] = 8;        }        // ----- Call the header generation        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {          @fclose($v_file);          return $v_result;        }        // ----- Write the compressed (or not) content        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);      }      // ----- Look for a directory      else if ($p_filedescr['type'] == 'folder') {        // ----- Look for directory last '/'        if (@substr($p_header['stored_filename'], -1) != '/') {          $p_header['stored_filename'] .= '/';        }        // ----- Set the file properties        $p_header['size'] = 0;        //$p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked        $p_header['external'] = 0x00000010;   // Value for a folder : to be checked        // ----- Call the header generation        if (($v_result = $this->privWriteFileHeader($p_header)) != 1)        {          return $v_result;        }      }    }    // ----- Look for post-add callback    if (isset($p_options[PCLZIP_CB_POST_ADD])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_header, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);      if ($v_result == 0) {        // ----- Ignored        $v_result = 1;      }      // ----- Update the informations      // Nothing can be modified    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privAddFileUsingTempFile()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options)  {    $v_result=PCLZIP_ERR_NO_ERROR;    // ----- Working variable    $p_filename = $p_filedescr['filename'];    // ----- Open the source file    if (($v_file = @fopen($p_filename, "rb")) == 0) {      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode");      return PclZip::errorCode();    }    // ----- Creates a compressed temporary file    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';    if (($v_file_compressed = @gzopen($v_gzip_temp_name, "wb")) == 0) {      fclose($v_file);      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary write mode');      return PclZip::errorCode();    }    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    $v_size = filesize($p_filename);    while ($v_size != 0) {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($v_file, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @gzputs($v_file_compressed, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Close the file    @fclose($v_file);    @gzclose($v_file_compressed);    // ----- Check the minimum file size    if (filesize($v_gzip_temp_name) < 18) {      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'gzip temporary file \''.$v_gzip_temp_name.'\' has invalid filesize - should be minimum 18 bytes');      return PclZip::errorCode();    }    // ----- Extract the compressed attributes    if (($v_file_compressed = @fopen($v_gzip_temp_name, "rb")) == 0) {      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');      return PclZip::errorCode();    }    // ----- Read the gzip file header    $v_binary_data = @fread($v_file_compressed, 10);    $v_data_header = unpack('a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os', $v_binary_data);    // ----- Check some parameters    $v_data_header['os'] = bin2hex($v_data_header['os']);    // ----- Read the gzip file footer    @fseek($v_file_compressed, filesize($v_gzip_temp_name)-8);    $v_binary_data = @fread($v_file_compressed, 8);    $v_data_footer = unpack('Vcrc/Vcompressed_size', $v_binary_data);    // ----- Set the attributes    $p_header['compression'] = ord($v_data_header['cm']);    //$p_header['mtime'] = $v_data_header['mtime'];    $p_header['crc'] = $v_data_footer['crc'];    $p_header['compressed_size'] = filesize($v_gzip_temp_name)-18;    // ----- Close the file    @fclose($v_file_compressed);    // ----- Call the header generation    if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {      return $v_result;    }    // ----- Add the compressed data    if (($v_file_compressed = @fopen($v_gzip_temp_name, "rb")) == 0)    {      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');      return PclZip::errorCode();    }    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    fseek($v_file_compressed, 10);    $v_size = $p_header['compressed_size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($v_file_compressed, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @fwrite($this->zip_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Close the file    @fclose($v_file_compressed);    // ----- Unlink the temporary file    @unlink($v_gzip_temp_name);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCalculateStoredFilename()  // Description :  //   Based on file descriptor properties and global options, this method  //   calculate the filename that will be stored in the archive.  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privCalculateStoredFilename(&$p_filedescr, &$p_options)  {    $v_result=1;    // ----- Working variables    $p_filename = $p_filedescr['filename'];    if (isset($p_options[PCLZIP_OPT_ADD_PATH])) {      $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH];    }    else {      $p_add_dir = '';    }    if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) {      $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH];    }    else {      $p_remove_dir = '';    }    if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {      $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH];    }    else {      $p_remove_all_dir = 0;    }    // ----- Look for full name change    if (isset($p_filedescr['new_full_name'])) {      // ----- Remove drive letter if any      $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']);    }    // ----- Look for path and/or short name change    else {      // ----- Look for short name change      // Its when we cahnge just the filename but not the path      if (isset($p_filedescr['new_short_name'])) {        $v_path_info = pathinfo($p_filename);        $v_dir = '';        if ($v_path_info['dirname'] != '') {          $v_dir = $v_path_info['dirname'].'/';        }        $v_stored_filename = $v_dir.$p_filedescr['new_short_name'];      }      else {        // ----- Calculate the stored filename        $v_stored_filename = $p_filename;      }      // ----- Look for all path to remove      if ($p_remove_all_dir) {        $v_stored_filename = basename($p_filename);      }      // ----- Look for partial path remove      else if ($p_remove_dir != "") {        if (substr($p_remove_dir, -1) != '/')          $p_remove_dir .= "/";        if (   (substr($p_filename, 0, 2) == "./")            || (substr($p_remove_dir, 0, 2) == "./")) {          if (   (substr($p_filename, 0, 2) == "./")              && (substr($p_remove_dir, 0, 2) != "./")) {            $p_remove_dir = "./".$p_remove_dir;          }          if (   (substr($p_filename, 0, 2) != "./")              && (substr($p_remove_dir, 0, 2) == "./")) {            $p_remove_dir = substr($p_remove_dir, 2);          }        }        $v_compare = PclZipUtilPathInclusion($p_remove_dir,                                             $v_stored_filename);        if ($v_compare > 0) {          if ($v_compare == 2) {            $v_stored_filename = "";          }          else {            $v_stored_filename = substr($v_stored_filename,                                        strlen($p_remove_dir));          }        }      }      // ----- Remove drive letter if any      $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);      // ----- Look for path to add      if ($p_add_dir != "") {        if (substr($p_add_dir, -1) == "/")          $v_stored_filename = $p_add_dir.$v_stored_filename;        else          $v_stored_filename = $p_add_dir."/".$v_stored_filename;      }    }    // ----- Filename (reduce the path of stored name)    $v_stored_filename = PclZipUtilPathReduction($v_stored_filename);    $p_filedescr['stored_filename'] = $v_stored_filename;    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privWriteFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privWriteFileHeader(&$p_header)  {    $v_result=1;    // ----- Store the offset position of the file    $p_header['offset'] = ftell($this->zip_fd);    // ----- Transform UNIX mtime to DOS format mdate/mtime    $v_date = getdate($p_header['mtime']);    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];    // ----- Packed data    $v_binary_data = pack("VvvvvvVVVvv", 0x04034b50,	                      $p_header['version_extracted'], $p_header['flag'],                          $p_header['compression'], $v_mtime, $v_mdate,                          $p_header['crc'], $p_header['compressed_size'],						  $p_header['size'],                          strlen($p_header['stored_filename']),						  $p_header['extra_len']);    // ----- Write the first 148 bytes of the header in the archive    fputs($this->zip_fd, $v_binary_data, 30);    // ----- Write the variable fields    if (strlen($p_header['stored_filename']) != 0)    {      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));    }    if ($p_header['extra_len'] != 0)    {      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privWriteCentralFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privWriteCentralFileHeader(&$p_header)  {    $v_result=1;    // TBC    //for(reset($p_header); $key = key($p_header); next($p_header)) {    //}    // ----- Transform UNIX mtime to DOS format mdate/mtime    $v_date = getdate($p_header['mtime']);    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];    // ----- Packed data    $v_binary_data = pack("VvvvvvvVVVvvvvvVV", 0x02014b50,	                      $p_header['version'], $p_header['version_extracted'],                          $p_header['flag'], $p_header['compression'],						  $v_mtime, $v_mdate, $p_header['crc'],                          $p_header['compressed_size'], $p_header['size'],                          strlen($p_header['stored_filename']),						  $p_header['extra_len'], $p_header['comment_len'],                          $p_header['disk'], $p_header['internal'],						  $p_header['external'], $p_header['offset']);    // ----- Write the 42 bytes of the header in the zip file    fputs($this->zip_fd, $v_binary_data, 46);    // ----- Write the variable fields    if (strlen($p_header['stored_filename']) != 0)    {      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));    }    if ($p_header['extra_len'] != 0)    {      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);    }    if ($p_header['comment_len'] != 0)    {      fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']);    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privWriteCentralHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment)  {    $v_result=1;    // ----- Packed data    $v_binary_data = pack("VvvvvVVv", 0x06054b50, 0, 0, $p_nb_entries,	                      $p_nb_entries, $p_size,						  $p_offset, strlen($p_comment));    // ----- Write the 22 bytes of the header in the zip file    fputs($this->zip_fd, $v_binary_data, 22);    // ----- Write the variable fields    if (strlen($p_comment) != 0)    {      fputs($this->zip_fd, $p_comment, strlen($p_comment));    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privList()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privList(&$p_list)  {    $v_result=1;    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Open the zip file    if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)    {      // ----- Magic quotes trick      $this->privSwapBackMagicQuotes();      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in binary read mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Go to beginning of Central Dir    @rewind($this->zip_fd);    if (@fseek($this->zip_fd, $v_central_dir['offset']))    {      $this->privSwapBackMagicQuotes();      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');      // ----- Return      return PclZip::errorCode();    }    // ----- Read each entry    for ($i=0; $i<$v_central_dir['entries']; $i++)    {      // ----- Read the file header      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)      {        $this->privSwapBackMagicQuotes();        return $v_result;      }      $v_header['index'] = $i;      // ----- Get the only interesting attributes      $this->privConvertHeader2FileInfo($v_header, $p_list[$i]);      unset($v_header);    }    // ----- Close the zip file    $this->privCloseFd();    // ----- Magic quotes trick    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privConvertHeader2FileInfo()  // Description :  //   This function takes the file informations from the central directory  //   entries and extract the interesting parameters that will be given back.  //   The resulting file infos are set in the array $p_info  //     $p_info['filename'] : Filename with full path. Given by user (add),  //                           extracted in the filesystem (extract).  //     $p_info['stored_filename'] : Stored filename in the archive.  //     $p_info['size'] = Size of the file.  //     $p_info['compressed_size'] = Compressed size of the file.  //     $p_info['mtime'] = Last modification date of the file.  //     $p_info['comment'] = Comment associated with the file.  //     $p_info['folder'] = true/false : indicates if the entry is a folder or not.  //     $p_info['status'] = status of the action on the file.  //     $p_info['crc'] = CRC of the file content.  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privConvertHeader2FileInfo($p_header, &$p_info)  {    $v_result=1;    // ----- Get the interesting attributes    $v_temp_path = PclZipUtilPathReduction($p_header['filename']);    $p_info['filename'] = $v_temp_path;    $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']);    $p_info['stored_filename'] = $v_temp_path;    $p_info['size'] = $p_header['size'];    $p_info['compressed_size'] = $p_header['compressed_size'];    $p_info['mtime'] = $p_header['mtime'];    $p_info['comment'] = $p_header['comment'];    $p_info['folder'] = (($p_header['external']&0x00000010)==0x00000010);    $p_info['index'] = $p_header['index'];    $p_info['status'] = $p_header['status'];    $p_info['crc'] = $p_header['crc'];    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractByRule()  // Description :  //   Extract a file or directory depending of rules (by index, by name, ...)  // Parameters :  //   $p_file_list : An array where will be placed the properties of each  //                  extracted file  //   $p_path : Path to add while writing the extracted files  //   $p_remove_path : Path to remove (from the file memorized path) while writing the  //                    extracted files. If the path does not match the file path,  //                    the file is extracted with its memorized path.  //                    $p_remove_path does not apply to 'list' mode.  //                    $p_path and $p_remove_path are commulative.  // Return Values :  //   1 on success,0 or less on error (see error code list)  // --------------------------------------------------------------------------------  function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)  {    $v_result=1;    // ----- Magic quotes trick    $this->privDisableMagicQuotes();    // ----- Check the path    if (   ($p_path == "")	    || (   (substr($p_path, 0, 1) != "/")		    && (substr($p_path, 0, 3) != "../")			&& (substr($p_path,1,2)!=":/")))      $p_path = "./".$p_path;    // ----- Reduce the path last (and duplicated) '/'    if (($p_path != "./") && ($p_path != "/"))    {      // ----- Look for the path end '/'      while (substr($p_path, -1) == "/")      {        $p_path = substr($p_path, 0, strlen($p_path)-1);      }    }    // ----- Look for path to remove format (should end by /)    if (($p_remove_path != "") && (substr($p_remove_path, -1) != '/'))    {      $p_remove_path .= '/';    }    $p_remove_path_size = strlen($p_remove_path);    // ----- Open the zip file    if (($v_result = $this->privOpenFd('rb')) != 1)    {      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      // ----- Close the zip file      $this->privCloseFd();      $this->privSwapBackMagicQuotes();      return $v_result;    }    // ----- Start at beginning of Central Dir    $v_pos_entry = $v_central_dir['offset'];    // ----- Read each entry    $j_start = 0;    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)    {      // ----- Read next Central dir entry      @rewind($this->zip_fd);      if (@fseek($this->zip_fd, $v_pos_entry))      {        // ----- Close the zip file        $this->privCloseFd();        $this->privSwapBackMagicQuotes();        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');        // ----- Return        return PclZip::errorCode();      }      // ----- Read the file header      $v_header = array();      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)      {        // ----- Close the zip file        $this->privCloseFd();        $this->privSwapBackMagicQuotes();        return $v_result;      }      // ----- Store the index      $v_header['index'] = $i;      // ----- Store the file position      $v_pos_entry = ftell($this->zip_fd);      // ----- Look for the specific extract rules      $v_extract = false;      // ----- Look for extract by name rule      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {          // ----- Look if the filename is in the list          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {              // ----- Look for a directory              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == "/") {                  // ----- Look if the directory is in the filename path                  if (   (strlen($v_header['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))                      && (substr($v_header['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {                      $v_extract = true;                  }              }              // ----- Look for a filename              elseif ($v_header['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {                  $v_extract = true;              }          }      }      // ----- Look for extract by ereg rule      // ereg() is deprecated with PHP 5.3      /*      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))               && ($p_options[PCLZIP_OPT_BY_EREG] != "")) {          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header['stored_filename'])) {              $v_extract = true;          }      }      */      // ----- Look for extract by preg rule      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))               && ($p_options[PCLZIP_OPT_BY_PREG] != "")) {          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header['stored_filename'])) {              $v_extract = true;          }      }      // ----- Look for extract by index rule      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {          // ----- Look if the index is in the list          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {                  $v_extract = true;              }              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {                  $j_start = $j+1;              }              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {                  break;              }          }      }      // ----- Look for no rule, which means extract all the archive      else {          $v_extract = true;      }	  // ----- Check compression method	  if (   ($v_extract)	      && (   ($v_header['compression'] != 8)		      && ($v_header['compression'] != 0))) {          $v_header['status'] = 'unsupported_compression';          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		      && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {              $this->privSwapBackMagicQuotes();              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION,			                       "Filename '".$v_header['stored_filename']."' is "				  	    	  	   ."compressed by an unsupported compression "				  	    	  	   ."method (".$v_header['compression'].") ");              return PclZip::errorCode();		  }	  }	  // ----- Check encrypted files	  if (($v_extract) && (($v_header['flag'] & 1) == 1)) {          $v_header['status'] = 'unsupported_encryption';          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		      && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {              $this->privSwapBackMagicQuotes();              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION,			                       "Unsupported encryption for "				  	    	  	   ." filename '".$v_header['stored_filename']								   ."'");              return PclZip::errorCode();		  }    }      // ----- Look for real extraction      if (($v_extract) && ($v_header['status'] != 'ok')) {          $v_result = $this->privConvertHeader2FileInfo($v_header,		                                        $p_file_list[$v_nb_extracted++]);          if ($v_result != 1) {              $this->privCloseFd();              $this->privSwapBackMagicQuotes();              return $v_result;          }          $v_extract = false;      }      // ----- Look for real extraction      if ($v_extract)      {        // ----- Go to the file position        @rewind($this->zip_fd);        if (@fseek($this->zip_fd, $v_header['offset']))        {          // ----- Close the zip file          $this->privCloseFd();          $this->privSwapBackMagicQuotes();          // ----- Error log          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');          // ----- Return          return PclZip::errorCode();        }        // ----- Look for extraction as string        if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {          $v_string = '';          // ----- Extracting the file          $v_result1 = $this->privExtractFileAsString($v_header, $v_string, $p_options);          if ($v_result1 < 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result1;          }          // ----- Get the only interesting attributes          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1)          {            // ----- Close the zip file            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result;          }          // ----- Set the file content          $p_file_list[$v_nb_extracted]['content'] = $v_string;          // ----- Next extracted file          $v_nb_extracted++;          // ----- Look for user callback abort          if ($v_result1 == 2) {          	break;          }        }        // ----- Look for extraction in standard output        elseif (   (isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT]))		        && ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {          // ----- Extracting the file in standard output          $v_result1 = $this->privExtractFileInOutput($v_header, $p_options);          if ($v_result1 < 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result1;          }          // ----- Get the only interesting attributes          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result;          }          // ----- Look for user callback abort          if ($v_result1 == 2) {          	break;          }        }        // ----- Look for normal extraction        else {          // ----- Extracting the file          $v_result1 = $this->privExtractFile($v_header,		                                      $p_path, $p_remove_path,											  $p_remove_all_path,											  $p_options);          if ($v_result1 < 1) {            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result1;          }          // ----- Get the only interesting attributes          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1)          {            // ----- Close the zip file            $this->privCloseFd();            $this->privSwapBackMagicQuotes();            return $v_result;          }          // ----- Look for user callback abort          if ($v_result1 == 2) {          	break;          }        }      }    }    // ----- Close the zip file    $this->privCloseFd();    $this->privSwapBackMagicQuotes();    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFile()  // Description :  // Parameters :  // Return Values :  //  // 1 : ... ?  // PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback  // --------------------------------------------------------------------------------  function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)  {    $v_result=1;    // ----- Read the file header    if (($v_result = $this->privReadFileHeader($v_header)) != 1)    {      // ----- Return      return $v_result;    }    // ----- Check that the file header is coherent with $p_entry info    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {        // TBC    }    // ----- Look for all path to remove    if ($p_remove_all_path == true) {        // ----- Look for folder entry that not need to be extracted        if (($p_entry['external']&0x00000010)==0x00000010) {            $p_entry['status'] = "filtered";            return $v_result;        }        // ----- Get the basename of the path        $p_entry['filename'] = basename($p_entry['filename']);    }    // ----- Look for path to remove    else if ($p_remove_path != "")    {      if (PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2)      {        // ----- Change the file status        $p_entry['status'] = "filtered";        // ----- Return        return $v_result;      }      $p_remove_path_size = strlen($p_remove_path);      if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path)      {        // ----- Remove the path        $p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);      }    }    // ----- Add the path    if ($p_path != '') {      $p_entry['filename'] = $p_path."/".$p_entry['filename'];    }    // ----- Check a base_dir_restriction    if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {      $v_inclusion      = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION],                                $p_entry['filename']);      if ($v_inclusion == 0) {        PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION,			                     "Filename '".$p_entry['filename']."' is "								 ."outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION");        return PclZip::errorCode();      }    }    // ----- Look for pre-extract callback    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_entry['status'] = "skipped";        $v_result = 1;      }      // ----- Look for abort result      if ($v_result == 2) {        // ----- This status is internal and will be changed in 'skipped'        $p_entry['status'] = "aborted";      	$v_result = PCLZIP_ERR_USER_ABORTED;      }      // ----- Update the informations      // Only some fields can be modified      $p_entry['filename'] = $v_local_header['filename'];    }    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {    // ----- Look for specific actions while the file exist    if (file_exists($p_entry['filename']))    {      // ----- Look if file is a directory      if (is_dir($p_entry['filename']))      {        // ----- Change the file status        $p_entry['status'] = "already_a_directory";        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR        // For historical reason first PclZip implementation does not stop        // when this kind of error occurs.        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		    && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {            PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY,			                     "Filename '".$p_entry['filename']."' is "								 ."already used by an existing directory");            return PclZip::errorCode();		    }      }      // ----- Look if file is write protected      else if (!is_writeable($p_entry['filename']))      {        // ----- Change the file status        $p_entry['status'] = "write_protected";        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR        // For historical reason first PclZip implementation does not stop        // when this kind of error occurs.        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		    && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,			                     "Filename '".$p_entry['filename']."' exists "								 ."and is write protected");            return PclZip::errorCode();		    }      }      // ----- Look if the extracted file is older      else if (filemtime($p_entry['filename']) > $p_entry['mtime'])      {        // ----- Change the file status        if (   (isset($p_options[PCLZIP_OPT_REPLACE_NEWER]))		    && ($p_options[PCLZIP_OPT_REPLACE_NEWER]===true)) {	  	  }		    else {            $p_entry['status'] = "newer_exist";            // ----- Look for PCLZIP_OPT_STOP_ON_ERROR            // For historical reason first PclZip implementation does not stop            // when this kind of error occurs.            if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))		        && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {                PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,			             "Newer version of '".$p_entry['filename']."' exists "					    ."and option PCLZIP_OPT_REPLACE_NEWER is not selected");                return PclZip::errorCode();		      }		    }      }      else {      }    }    // ----- Check the directory availability and create it if necessary    else {      if ((($p_entry['external']&0x00000010)==0x00000010) || (substr($p_entry['filename'], -1) == '/'))        $v_dir_to_check = $p_entry['filename'];      else if (!strstr($p_entry['filename'], "/"))        $v_dir_to_check = "";      else        $v_dir_to_check = dirname($p_entry['filename']);        if (($v_result = $this->privDirCheck($v_dir_to_check, (($p_entry['external']&0x00000010)==0x00000010))) != 1) {          // ----- Change the file status          $p_entry['status'] = "path_creation_fail";          // ----- Return          //return $v_result;          $v_result = 1;        }      }    }    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {      // ----- Do the extraction (if not a folder)      if (!(($p_entry['external']&0x00000010)==0x00000010))      {        // ----- Look for not compressed file        if ($p_entry['compression'] == 0) {    		  // ----- Opening destination file          if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0)          {            // ----- Change the file status            $p_entry['status'] = "write_error";            // ----- Return            return $v_result;          }          // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks          $v_size = $p_entry['compressed_size'];          while ($v_size != 0)          {            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);            $v_buffer = @fread($this->zip_fd, $v_read_size);            /* Try to speed up the code            $v_binary_data = pack('a'.$v_read_size, $v_buffer);            @fwrite($v_dest_file, $v_binary_data, $v_read_size);            */            @fwrite($v_dest_file, $v_buffer, $v_read_size);            $v_size -= $v_read_size;          }          // ----- Closing the destination file          fclose($v_dest_file);          // ----- Change the file mtime          touch($p_entry['filename'], $p_entry['mtime']);        }        else {          // ----- TBC          // Need to be finished          if (($p_entry['flag'] & 1) == 1) {            PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, 'File \''.$p_entry['filename'].'\' is encrypted. Encrypted files are not supported.');            return PclZip::errorCode();          }          // ----- Look for using temporary file to unzip          if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))              && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])                  || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])                      && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_entry['size'])) ) ) {            $v_result = $this->privExtractFileUsingTempFile($p_entry, $p_options);            if ($v_result < PCLZIP_ERR_NO_ERROR) {              return $v_result;            }          }          // ----- Look for extract in memory          else {            // ----- Read the compressed file in a buffer (one shot)            $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);            // ----- Decompress the file            $v_file_content = @gzinflate($v_buffer);            unset($v_buffer);            if ($v_file_content === FALSE) {              // ----- Change the file status              // TBC              $p_entry['status'] = "error";              return $v_result;            }            // ----- Opening destination file            if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {              // ----- Change the file status              $p_entry['status'] = "write_error";              return $v_result;            }            // ----- Write the uncompressed data            @fwrite($v_dest_file, $v_file_content, $p_entry['size']);            unset($v_file_content);            // ----- Closing the destination file            @fclose($v_dest_file);          }          // ----- Change the file mtime          @touch($p_entry['filename'], $p_entry['mtime']);        }        // ----- Look for chmod option        if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {          // ----- Change the mode of the file          @chmod($p_entry['filename'], $p_options[PCLZIP_OPT_SET_CHMOD]);        }      }    }  	// ----- Change abort status  	if ($p_entry['status'] == "aborted") {        $p_entry['status'] = "skipped";  	}    // ----- Look for post-extract callback    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);      // ----- Look for abort result      if ($v_result == 2) {      	$v_result = PCLZIP_ERR_USER_ABORTED;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFileUsingTempFile()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privExtractFileUsingTempFile(&$p_entry, &$p_options)  {    $v_result=1;    // ----- Creates a temporary file    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';    if (($v_dest_file = @fopen($v_gzip_temp_name, "wb")) == 0) {      fclose($v_file);      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary write mode');      return PclZip::errorCode();    }    // ----- Write gz file format header    $v_binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($p_entry['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));    @fwrite($v_dest_file, $v_binary_data, 10);    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    $v_size = $p_entry['compressed_size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($this->zip_fd, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @fwrite($v_dest_file, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Write gz file format footer    $v_binary_data = pack('VV', $p_entry['crc'], $p_entry['size']);    @fwrite($v_dest_file, $v_binary_data, 8);    // ----- Close the temporary file    @fclose($v_dest_file);    // ----- Opening destination file    if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {      $p_entry['status'] = "write_error";      return $v_result;    }    // ----- Open the temporary gz file    if (($v_src_file = @gzopen($v_gzip_temp_name, 'rb')) == 0) {      @fclose($v_dest_file);      $p_entry['status'] = "read_error";      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');      return PclZip::errorCode();    }    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks    $v_size = $p_entry['size'];    while ($v_size != 0) {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @gzread($v_src_file, $v_read_size);      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);      @fwrite($v_dest_file, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    @fclose($v_dest_file);    @gzclose($v_src_file);    // ----- Delete the temporary file    @unlink($v_gzip_temp_name);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFileInOutput()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privExtractFileInOutput(&$p_entry, &$p_options)  {    $v_result=1;    // ----- Read the file header    if (($v_result = $this->privReadFileHeader($v_header)) != 1) {      return $v_result;    }    // ----- Check that the file header is coherent with $p_entry info    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {        // TBC    }    // ----- Look for pre-extract callback    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_entry['status'] = "skipped";        $v_result = 1;      }      // ----- Look for abort result      if ($v_result == 2) {        // ----- This status is internal and will be changed in 'skipped'        $p_entry['status'] = "aborted";      	$v_result = PCLZIP_ERR_USER_ABORTED;      }      // ----- Update the informations      // Only some fields can be modified      $p_entry['filename'] = $v_local_header['filename'];    }    // ----- Trace    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {      // ----- Do the extraction (if not a folder)      if (!(($p_entry['external']&0x00000010)==0x00000010)) {        // ----- Look for not compressed file        if ($p_entry['compressed_size'] == $p_entry['size']) {          // ----- Read the file in a buffer (one shot)          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);          // ----- Send the file to the output          echo $v_buffer;          unset($v_buffer);        }        else {          // ----- Read the compressed file in a buffer (one shot)          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);          // ----- Decompress the file          $v_file_content = gzinflate($v_buffer);          unset($v_buffer);          // ----- Send the file to the output          echo $v_file_content;          unset($v_file_content);        }      }    }	// ----- Change abort status	if ($p_entry['status'] == "aborted") {      $p_entry['status'] = "skipped";	}    // ----- Look for post-extract callback    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);      // ----- Look for abort result      if ($v_result == 2) {      	$v_result = PCLZIP_ERR_USER_ABORTED;      }    }    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privExtractFileAsString()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privExtractFileAsString(&$p_entry, &$p_string, &$p_options)  {    $v_result=1;    // ----- Read the file header    $v_header = array();    if (($v_result = $this->privReadFileHeader($v_header)) != 1)    {      // ----- Return      return $v_result;    }    // ----- Check that the file header is coherent with $p_entry info    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {        // TBC    }    // ----- Look for pre-extract callback    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);      if ($v_result == 0) {        // ----- Change the file status        $p_entry['status'] = "skipped";        $v_result = 1;      }      // ----- Look for abort result      if ($v_result == 2) {        // ----- This status is internal and will be changed in 'skipped'        $p_entry['status'] = "aborted";      	$v_result = PCLZIP_ERR_USER_ABORTED;      }      // ----- Update the informations      // Only some fields can be modified      $p_entry['filename'] = $v_local_header['filename'];    }    // ----- Look if extraction should be done    if ($p_entry['status'] == 'ok') {      // ----- Do the extraction (if not a folder)      if (!(($p_entry['external']&0x00000010)==0x00000010)) {        // ----- Look for not compressed file  //      if ($p_entry['compressed_size'] == $p_entry['size'])        if ($p_entry['compression'] == 0) {          // ----- Reading the file          $p_string = @fread($this->zip_fd, $p_entry['compressed_size']);        }        else {          // ----- Reading the file          $v_data = @fread($this->zip_fd, $p_entry['compressed_size']);          // ----- Decompress the file          if (($p_string = @gzinflate($v_data)) === FALSE) {              // TBC          }        }        // ----- Trace      }      else {          // TBC : error : can not extract a folder in a string      }    }  	// ----- Change abort status  	if ($p_entry['status'] == "aborted") {        $p_entry['status'] = "skipped";  	}    // ----- Look for post-extract callback    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {      // ----- Generate a local information      $v_local_header = array();      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);      // ----- Swap the content to header      $v_local_header['content'] = $p_string;      $p_string = '';      // ----- Call the callback      // Here I do not use call_user_func() because I need to send a reference to the      // header.      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);      // ----- Swap back the content to header      $p_string = $v_local_header['content'];      unset($v_local_header['content']);      // ----- Look for abort result      if ($v_result == 2) {      	$v_result = PCLZIP_ERR_USER_ABORTED;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privReadFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privReadFileHeader(&$p_header)  {    $v_result=1;    // ----- Read the 4 bytes signature    $v_binary_data = @fread($this->zip_fd, 4);    $v_data = unpack('Vid', $v_binary_data);    // ----- Check signature    if ($v_data['id'] != 0x04034b50)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');      // ----- Return      return PclZip::errorCode();    }    // ----- Read the first 42 bytes of the header    $v_binary_data = fread($this->zip_fd, 26);    // ----- Look for invalid block size    if (strlen($v_binary_data) != 26)    {      $p_header['filename'] = "";      $p_header['status'] = "invalid_header";      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : ".strlen($v_binary_data));      // ----- Return      return PclZip::errorCode();    }    // ----- Extract the values    $v_data = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);    // ----- Get filename    $p_header['filename'] = fread($this->zip_fd, $v_data['filename_len']);    // ----- Get extra_fields    if ($v_data['extra_len'] != 0) {      $p_header['extra'] = fread($this->zip_fd, $v_data['extra_len']);    }    else {      $p_header['extra'] = '';    }    // ----- Extract properties    $p_header['version_extracted'] = $v_data['version'];    $p_header['compression'] = $v_data['compression'];    $p_header['size'] = $v_data['size'];    $p_header['compressed_size'] = $v_data['compressed_size'];    $p_header['crc'] = $v_data['crc'];    $p_header['flag'] = $v_data['flag'];    $p_header['filename_len'] = $v_data['filename_len'];    // ----- Recuperate date in UNIX format    $p_header['mdate'] = $v_data['mdate'];    $p_header['mtime'] = $v_data['mtime'];    if ($p_header['mdate'] && $p_header['mtime'])    {      // ----- Extract time      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;      $v_seconde = ($p_header['mtime'] & 0x001F)*2;      // ----- Extract date      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;      $v_day = $p_header['mdate'] & 0x001F;      // ----- Get UNIX date format      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);    }    else    {      $p_header['mtime'] = time();    }    // TBC    //for(reset($v_data); $key = key($v_data); next($v_data)) {    //}    // ----- Set the stored filename    $p_header['stored_filename'] = $p_header['filename'];    // ----- Set the status field    $p_header['status'] = "ok";    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privReadCentralFileHeader()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privReadCentralFileHeader(&$p_header)  {    $v_result=1;    // ----- Read the 4 bytes signature    $v_binary_data = @fread($this->zip_fd, 4);    $v_data = unpack('Vid', $v_binary_data);    // ----- Check signature    if ($v_data['id'] != 0x02014b50)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');      // ----- Return      return PclZip::errorCode();    }    // ----- Read the first 42 bytes of the header    $v_binary_data = fread($this->zip_fd, 42);    // ----- Look for invalid block size    if (strlen($v_binary_data) != 42)    {      $p_header['filename'] = "";      $p_header['status'] = "invalid_header";      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : ".strlen($v_binary_data));      // ----- Return      return PclZip::errorCode();    }    // ----- Extract the values    $p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);    // ----- Get filename    if ($p_header['filename_len'] != 0)      $p_header['filename'] = fread($this->zip_fd, $p_header['filename_len']);    else      $p_header['filename'] = '';    // ----- Get extra    if ($p_header['extra_len'] != 0)      $p_header['extra'] = fread($this->zip_fd, $p_header['extra_len']);    else      $p_header['extra'] = '';    // ----- Get comment    if ($p_header['comment_len'] != 0)      $p_header['comment'] = fread($this->zip_fd, $p_header['comment_len']);    else      $p_header['comment'] = '';    // ----- Extract properties    // ----- Recuperate date in UNIX format    //if ($p_header['mdate'] && $p_header['mtime'])    // TBC : bug : this was ignoring time with 0/0/0    if (1)    {      // ----- Extract time      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;      $v_seconde = ($p_header['mtime'] & 0x001F)*2;      // ----- Extract date      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;      $v_day = $p_header['mdate'] & 0x001F;      // ----- Get UNIX date format      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);    }    else    {      $p_header['mtime'] = time();    }    // ----- Set the stored filename    $p_header['stored_filename'] = $p_header['filename'];    // ----- Set default status to ok    $p_header['status'] = 'ok';    // ----- Look if it is a directory    if (substr($p_header['filename'], -1) == '/') {      //$p_header['external'] = 0x41FF0010;      $p_header['external'] = 0x00000010;    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privCheckFileHeaders()  // Description :  // Parameters :  // Return Values :  //   1 on success,  //   0 on error;  // --------------------------------------------------------------------------------  function privCheckFileHeaders(&$p_local_header, &$p_central_header)  {    $v_result=1;  	// ----- Check the static values  	// TBC  	if ($p_local_header['filename'] != $p_central_header['filename']) {  	}  	if ($p_local_header['version_extracted'] != $p_central_header['version_extracted']) {  	}  	if ($p_local_header['flag'] != $p_central_header['flag']) {  	}  	if ($p_local_header['compression'] != $p_central_header['compression']) {  	}  	if ($p_local_header['mtime'] != $p_central_header['mtime']) {  	}  	if ($p_local_header['filename_len'] != $p_central_header['filename_len']) {  	}  	// ----- Look for flag bit 3  	if (($p_local_header['flag'] & 8) == 8) {          $p_local_header['size'] = $p_central_header['size'];          $p_local_header['compressed_size'] = $p_central_header['compressed_size'];          $p_local_header['crc'] = $p_central_header['crc'];  	}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privReadEndCentralDir()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privReadEndCentralDir(&$p_central_dir)  {    $v_result=1;    // ----- Go to the end of the zip file    $v_size = filesize($this->zipname);    @fseek($this->zip_fd, $v_size);    if (@ftell($this->zip_fd) != $v_size)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \''.$this->zipname.'\'');      // ----- Return      return PclZip::errorCode();    }    // ----- First try : look if this is an archive with no commentaries (most of the time)    // in this case the end of central dir is at 22 bytes of the file end    $v_found = 0;    if ($v_size > 26) {      @fseek($this->zip_fd, $v_size-22);      if (($v_pos = @ftell($this->zip_fd)) != ($v_size-22))      {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\'');        // ----- Return        return PclZip::errorCode();      }      // ----- Read for bytes      $v_binary_data = @fread($this->zip_fd, 4);      $v_data = @unpack('Vid', $v_binary_data);      // ----- Check signature      if ($v_data['id'] == 0x06054b50) {        $v_found = 1;      }      $v_pos = ftell($this->zip_fd);    }    // ----- Go back to the maximum possible size of the Central Dir End Record    if (!$v_found) {      $v_maximum_size = 65557; // 0xFFFF + 22;      if ($v_maximum_size > $v_size)        $v_maximum_size = $v_size;      @fseek($this->zip_fd, $v_size-$v_maximum_size);      if (@ftell($this->zip_fd) != ($v_size-$v_maximum_size))      {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\'');        // ----- Return        return PclZip::errorCode();      }      // ----- Read byte per byte in order to find the signature      $v_pos = ftell($this->zip_fd);      $v_bytes = 0x00000000;      while ($v_pos < $v_size)      {        // ----- Read a byte        $v_byte = @fread($this->zip_fd, 1);        // -----  Add the byte        //$v_bytes = ($v_bytes << 8) | Ord($v_byte);        // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number        // Otherwise on systems where we have 64bit integers the check below for the magic number will fail.        $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte);        // ----- Compare the bytes        if ($v_bytes == 0x504b0506)        {          $v_pos++;          break;        }        $v_pos++;      }      // ----- Look if not found end of central dir      if ($v_pos == $v_size)      {        // ----- Error log        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Unable to find End of Central Dir Record signature");        // ----- Return        return PclZip::errorCode();      }    }    // ----- Read the first 18 bytes of the header    $v_binary_data = fread($this->zip_fd, 18);    // ----- Look for invalid block size    if (strlen($v_binary_data) != 18)    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid End of Central Dir Record size : ".strlen($v_binary_data));      // ----- Return      return PclZip::errorCode();    }    // ----- Extract the values    $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);    // ----- Check the global size    if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {	  // ----- Removed in release 2.2 see readme file	  // The check of the file size is a little too strict.	  // Some bugs where found when a zip is encrypted/decrypted with 'crypt'.	  // While decrypted, zip has training 0 bytes	  if (0) {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT,	                       'The central dir is not at the end of the archive.'						   .' Some trailing bytes exists after the archive.');      // ----- Return      return PclZip::errorCode();	  }    }    // ----- Get comment    if ($v_data['comment_size'] != 0) {      $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);    }    else      $p_central_dir['comment'] = '';    $p_central_dir['entries'] = $v_data['entries'];    $p_central_dir['disk_entries'] = $v_data['disk_entries'];    $p_central_dir['offset'] = $v_data['offset'];    $p_central_dir['size'] = $v_data['size'];    $p_central_dir['disk'] = $v_data['disk'];    $p_central_dir['disk_start'] = $v_data['disk_start'];    // TBC    //for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {    //}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDeleteByRule()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privDeleteByRule(&$p_result_list, &$p_options)  {    $v_result=1;    $v_list_detail = array();    // ----- Open the zip file    if (($v_result=$this->privOpenFd('rb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privCloseFd();      return $v_result;    }    // ----- Go to beginning of File    @rewind($this->zip_fd);    // ----- Scan all the files    // ----- Start at beginning of Central Dir    $v_pos_entry = $v_central_dir['offset'];    @rewind($this->zip_fd);    if (@fseek($this->zip_fd, $v_pos_entry))    {      // ----- Close the zip file      $this->privCloseFd();      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');      // ----- Return      return PclZip::errorCode();    }    // ----- Read each entry    $v_header_list = array();    $j_start = 0;    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)    {      // ----- Read the file header      $v_header_list[$v_nb_extracted] = array();      if (($v_result = $this->privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1)      {        // ----- Close the zip file        $this->privCloseFd();        return $v_result;      }      // ----- Store the index      $v_header_list[$v_nb_extracted]['index'] = $i;      // ----- Look for the specific extract rules      $v_found = false;      // ----- Look for extract by name rule      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {          // ----- Look if the filename is in the list          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_found); $j++) {              // ----- Look for a directory              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == "/") {                  // ----- Look if the directory is in the filename path                  if (   (strlen($v_header_list[$v_nb_extracted]['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))                      && (substr($v_header_list[$v_nb_extracted]['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {                      $v_found = true;                  }                  elseif (   (($v_header_list[$v_nb_extracted]['external']&0x00000010)==0x00000010) /* Indicates a folder */                          && ($v_header_list[$v_nb_extracted]['stored_filename'].'/' == $p_options[PCLZIP_OPT_BY_NAME][$j])) {                      $v_found = true;                  }              }              // ----- Look for a filename              elseif ($v_header_list[$v_nb_extracted]['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {                  $v_found = true;              }          }      }      // ----- Look for extract by ereg rule      // ereg() is deprecated with PHP 5.3      /*      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))               && ($p_options[PCLZIP_OPT_BY_EREG] != "")) {          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {              $v_found = true;          }      }      */      // ----- Look for extract by preg rule      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))               && ($p_options[PCLZIP_OPT_BY_PREG] != "")) {          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {              $v_found = true;          }      }      // ----- Look for extract by index rule      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {          // ----- Look if the index is in the list          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_found); $j++) {              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {                  $v_found = true;              }              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {                  $j_start = $j+1;              }              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {                  break;              }          }      }      else {      	$v_found = true;      }      // ----- Look for deletion      if ($v_found)      {        unset($v_header_list[$v_nb_extracted]);      }      else      {        $v_nb_extracted++;      }    }    // ----- Look if something need to be deleted    if ($v_nb_extracted > 0) {        // ----- Creates a temporay file        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';        // ----- Creates a temporary zip archive        $v_temp_zip = new PclZip($v_zip_temp_name);        // ----- Open the temporary zip file in write mode        if (($v_result = $v_temp_zip->privOpenFd('wb')) != 1) {            $this->privCloseFd();            // ----- Return            return $v_result;        }        // ----- Look which file need to be kept        for ($i=0; $i<sizeof($v_header_list); $i++) {            // ----- Calculate the position of the header            @rewind($this->zip_fd);            if (@fseek($this->zip_fd,  $v_header_list[$i]['offset'])) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Error log                PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');                // ----- Return                return PclZip::errorCode();            }            // ----- Read the file header            $v_local_header = array();            if (($v_result = $this->privReadFileHeader($v_local_header)) != 1) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }            // ----- Check that local file header is same as central file header            if ($this->privCheckFileHeaders($v_local_header,			                                $v_header_list[$i]) != 1) {                // TBC            }            unset($v_local_header);            // ----- Write the file header            if (($v_result = $v_temp_zip->privWriteFileHeader($v_header_list[$i])) != 1) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }            // ----- Read/write the data block            if (($v_result = PclZipUtilCopyBlock($this->zip_fd, $v_temp_zip->zip_fd, $v_header_list[$i]['compressed_size'])) != 1) {                // ----- Close the zip file                $this->privCloseFd();                $v_temp_zip->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }        }        // ----- Store the offset of the central dir        $v_offset = @ftell($v_temp_zip->zip_fd);        // ----- Re-Create the Central Dir files header        for ($i=0; $i<sizeof($v_header_list); $i++) {            // ----- Create the file header            if (($v_result = $v_temp_zip->privWriteCentralFileHeader($v_header_list[$i])) != 1) {                $v_temp_zip->privCloseFd();                $this->privCloseFd();                @unlink($v_zip_temp_name);                // ----- Return                return $v_result;            }            // ----- Transform the header to a 'usable' info            $v_temp_zip->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);        }        // ----- Zip file comment        $v_comment = '';        if (isset($p_options[PCLZIP_OPT_COMMENT])) {          $v_comment = $p_options[PCLZIP_OPT_COMMENT];        }        // ----- Calculate the size of the central header        $v_size = @ftell($v_temp_zip->zip_fd)-$v_offset;        // ----- Create the central dir footer        if (($v_result = $v_temp_zip->privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) {            // ----- Reset the file list            unset($v_header_list);            $v_temp_zip->privCloseFd();            $this->privCloseFd();            @unlink($v_zip_temp_name);            // ----- Return            return $v_result;        }        // ----- Close        $v_temp_zip->privCloseFd();        $this->privCloseFd();        // ----- Delete the zip file        // TBC : I should test the result ...        @unlink($this->zipname);        // ----- Rename the temporary file        // TBC : I should test the result ...        //@rename($v_zip_temp_name, $this->zipname);        PclZipUtilRename($v_zip_temp_name, $this->zipname);        // ----- Destroy the temporary archive        unset($v_temp_zip);    }    // ----- Remove every files : reset the file    else if ($v_central_dir['entries'] != 0) {        $this->privCloseFd();        if (($v_result = $this->privOpenFd('wb')) != 1) {          return $v_result;        }        if (($v_result = $this->privWriteCentralHeader(0, 0, 0, '')) != 1) {          return $v_result;        }        $this->privCloseFd();    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDirCheck()  // Description :  //   Check if a directory exists, if not it creates it and all the parents directory  //   which may be useful.  // Parameters :  //   $p_dir : Directory path to check.  // Return Values :  //    1 : OK  //   -1 : Unable to create directory  // --------------------------------------------------------------------------------  function privDirCheck($p_dir, $p_is_dir=false)  {    $v_result = 1;    // ----- Remove the final '/'    if (($p_is_dir) && (substr($p_dir, -1)=='/'))    {      $p_dir = substr($p_dir, 0, strlen($p_dir)-1);    }    // ----- Check the directory availability    if ((is_dir($p_dir)) || ($p_dir == ""))    {      return 1;    }    // ----- Extract parent directory    $p_parent_dir = dirname($p_dir);    // ----- Just a check    if ($p_parent_dir != $p_dir)    {      // ----- Look for parent directory      if ($p_parent_dir != "")      {        if (($v_result = $this->privDirCheck($p_parent_dir)) != 1)        {          return $v_result;        }      }    }    // ----- Create the directory    if (!@mkdir($p_dir, 0777))    {      // ----- Error log      PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, "Unable to create directory '$p_dir'");      // ----- Return      return PclZip::errorCode();    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privMerge()  // Description :  //   If $p_archive_to_add does not exist, the function exit with a success result.  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privMerge(&$p_archive_to_add)  {    $v_result=1;    // ----- Look if the archive_to_add exists    if (!is_file($p_archive_to_add->zipname))    {      // ----- Nothing to merge, so merge is a success      $v_result = 1;      // ----- Return      return $v_result;    }    // ----- Look if the archive exists    if (!is_file($this->zipname))    {      // ----- Do a duplicate      $v_result = $this->privDuplicate($p_archive_to_add->zipname);      // ----- Return      return $v_result;    }    // ----- Open the zip file    if (($v_result=$this->privOpenFd('rb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir = array();    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)    {      $this->privCloseFd();      return $v_result;    }    // ----- Go to beginning of File    @rewind($this->zip_fd);    // ----- Open the archive_to_add file    if (($v_result=$p_archive_to_add->privOpenFd('rb')) != 1)    {      $this->privCloseFd();      // ----- Return      return $v_result;    }    // ----- Read the central directory informations    $v_central_dir_to_add = array();    if (($v_result = $p_archive_to_add->privReadEndCentralDir($v_central_dir_to_add)) != 1)    {      $this->privCloseFd();      $p_archive_to_add->privCloseFd();      return $v_result;    }    // ----- Go to beginning of File    @rewind($p_archive_to_add->zip_fd);    // ----- Creates a temporay file    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';    // ----- Open the temporary file in write mode    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)    {      $this->privCloseFd();      $p_archive_to_add->privCloseFd();      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_zip_temp_name.'\' in binary write mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Copy the files from the archive to the temporary file    // TBC : Here I should better append the file and go back to erase the central dir    $v_size = $v_central_dir['offset'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($this->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Copy the files from the archive_to_add into the temporary file    $v_size = $v_central_dir_to_add['offset'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($p_archive_to_add->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Store the offset of the central dir    $v_offset = @ftell($v_zip_temp_fd);    // ----- Copy the block of file headers from the old archive    $v_size = $v_central_dir['size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($this->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Copy the block of file headers from the archive_to_add    $v_size = $v_central_dir_to_add['size'];    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = @fread($p_archive_to_add->zip_fd, $v_read_size);      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Merge the file comments    $v_comment = $v_central_dir['comment'].' '.$v_central_dir_to_add['comment'];    // ----- Calculate the size of the (new) central header    $v_size = @ftell($v_zip_temp_fd)-$v_offset;    // ----- Swap the file descriptor    // Here is a trick : I swap the temporary fd with the zip fd, in order to use    // the following methods on the temporary fil and not the real archive fd    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Create the central dir footer    if (($v_result = $this->privWriteCentralHeader($v_central_dir['entries']+$v_central_dir_to_add['entries'], $v_size, $v_offset, $v_comment)) != 1)    {      $this->privCloseFd();      $p_archive_to_add->privCloseFd();      @fclose($v_zip_temp_fd);      $this->zip_fd = null;      // ----- Reset the file list      unset($v_header_list);      // ----- Return      return $v_result;    }    // ----- Swap back the file descriptor    $v_swap = $this->zip_fd;    $this->zip_fd = $v_zip_temp_fd;    $v_zip_temp_fd = $v_swap;    // ----- Close    $this->privCloseFd();    $p_archive_to_add->privCloseFd();    // ----- Close the temporary file    @fclose($v_zip_temp_fd);    // ----- Delete the zip file    // TBC : I should test the result ...    @unlink($this->zipname);    // ----- Rename the temporary file    // TBC : I should test the result ...    //@rename($v_zip_temp_name, $this->zipname);    PclZipUtilRename($v_zip_temp_name, $this->zipname);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDuplicate()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privDuplicate($p_archive_filename)  {    $v_result=1;    // ----- Look if the $p_archive_filename exists    if (!is_file($p_archive_filename))    {      // ----- Nothing to duplicate, so duplicate is a success.      $v_result = 1;      // ----- Return      return $v_result;    }    // ----- Open the zip file    if (($v_result=$this->privOpenFd('wb')) != 1)    {      // ----- Return      return $v_result;    }    // ----- Open the temporary file in write mode    if (($v_zip_temp_fd = @fopen($p_archive_filename, 'rb')) == 0)    {      $this->privCloseFd();      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive file \''.$p_archive_filename.'\' in binary write mode');      // ----- Return      return PclZip::errorCode();    }    // ----- Copy the files from the archive to the temporary file    // TBC : Here I should better append the file and go back to erase the central dir    $v_size = filesize($p_archive_filename);    while ($v_size != 0)    {      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);      $v_buffer = fread($v_zip_temp_fd, $v_read_size);      @fwrite($this->zip_fd, $v_buffer, $v_read_size);      $v_size -= $v_read_size;    }    // ----- Close    $this->privCloseFd();    // ----- Close the temporary file    @fclose($v_zip_temp_fd);    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privErrorLog()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privErrorLog($p_error_code=0, $p_error_string='')  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      PclError($p_error_code, $p_error_string);    }    else {      $this->error_code = $p_error_code;      $this->error_string = $p_error_string;    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privErrorReset()  // Description :  // Parameters :  // --------------------------------------------------------------------------------  function privErrorReset()  {    if (PCLZIP_ERROR_EXTERNAL == 1) {      PclErrorReset();    }    else {      $this->error_code = 0;      $this->error_string = '';    }  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privDisableMagicQuotes()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privDisableMagicQuotes()  {    $v_result=1;    // ----- Look if function exists    if (   (!function_exists("get_magic_quotes_runtime"))	    || (!function_exists("set_magic_quotes_runtime"))) {      return $v_result;	}    // ----- Look if already done    if ($this->magic_quotes_status != -1) {      return $v_result;	}	// ----- Get and memorize the magic_quote value	$this->magic_quotes_status = @get_magic_quotes_runtime();	// ----- Disable magic_quotes	if ($this->magic_quotes_status == 1) {	  @set_magic_quotes_runtime(0);	}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : privSwapBackMagicQuotes()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function privSwapBackMagicQuotes()  {    $v_result=1;    // ----- Look if function exists    if (   (!function_exists("get_magic_quotes_runtime"))	    || (!function_exists("set_magic_quotes_runtime"))) {      return $v_result;	}    // ----- Look if something to do    if ($this->magic_quotes_status != -1) {      return $v_result;	}	// ----- Swap back magic_quotes	if ($this->magic_quotes_status == 1) {  	  @set_magic_quotes_runtime($this->magic_quotes_status);	}    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  }  // End of class  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilPathReduction()  // Description :  // Parameters :  // Return Values :  // --------------------------------------------------------------------------------  function PclZipUtilPathReduction($p_dir)  {    $v_result = "";    // ----- Look for not empty path    if ($p_dir != "") {      // ----- Explode path by directory names      $v_list = explode("/", $p_dir);      // ----- Study directories from last to first      $v_skip = 0;      for ($i=sizeof($v_list)-1; $i>=0; $i--) {        // ----- Look for current path        if ($v_list[$i] == ".") {          // ----- Ignore this directory          // Should be the first $i=0, but no check is done        }        else if ($v_list[$i] == "..") {		  $v_skip++;        }        else if ($v_list[$i] == "") {		  // ----- First '/' i.e. root slash		  if ($i == 0) {            $v_result = "/".$v_result;		    if ($v_skip > 0) {		        // ----- It is an invalid path, so the path is not modified		        // TBC		        $v_result = $p_dir;                $v_skip = 0;		    }		  }		  // ----- Last '/' i.e. indicates a directory		  else if ($i == (sizeof($v_list)-1)) {            $v_result = $v_list[$i];		  }		  // ----- Double '/' inside the path		  else {            // ----- Ignore only the double '//' in path,            // but not the first and last '/'		  }        }        else {		  // ----- Look for item to skip		  if ($v_skip > 0) {		    $v_skip--;		  }		  else {            $v_result = $v_list[$i].($i!=(sizeof($v_list)-1)?"/".$v_result:"");		  }        }      }      // ----- Look for skip      if ($v_skip > 0) {        while ($v_skip > 0) {            $v_result = '../'.$v_result;            $v_skip--;        }      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilPathInclusion()  // Description :  //   This function indicates if the path $p_path is under the $p_dir tree. Or,  //   said in an other way, if the file or sub-dir $p_path is inside the dir  //   $p_dir.  //   The function indicates also if the path is exactly the same as the dir.  //   This function supports path with duplicated '/' like '//', but does not  //   support '.' or '..' statements.  // Parameters :  // Return Values :  //   0 if $p_path is not inside directory $p_dir  //   1 if $p_path is inside directory $p_dir  //   2 if $p_path is exactly the same as $p_dir  // --------------------------------------------------------------------------------  function PclZipUtilPathInclusion($p_dir, $p_path)  {    $v_result = 1;    // ----- Look for path beginning by ./    if (   ($p_dir == '.')        || ((strlen($p_dir) >=2) && (substr($p_dir, 0, 2) == './'))) {      $p_dir = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_dir, 1);    }    if (   ($p_path == '.')        || ((strlen($p_path) >=2) && (substr($p_path, 0, 2) == './'))) {      $p_path = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_path, 1);    }    // ----- Explode dir and path by directory separator    $v_list_dir = explode("/", $p_dir);    $v_list_dir_size = sizeof($v_list_dir);    $v_list_path = explode("/", $p_path);    $v_list_path_size = sizeof($v_list_path);    // ----- Study directories paths    $i = 0;    $j = 0;    while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {      // ----- Look for empty dir (path reduction)      if ($v_list_dir[$i] == '') {        $i++;        continue;      }      if ($v_list_path[$j] == '') {        $j++;        continue;      }      // ----- Compare the items      if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != ''))  {        $v_result = 0;      }      // ----- Next items      $i++;      $j++;    }    // ----- Look if everything seems to be the same    if ($v_result) {      // ----- Skip all the empty items      while (($j < $v_list_path_size) && ($v_list_path[$j] == '')) $j++;      while (($i < $v_list_dir_size) && ($v_list_dir[$i] == '')) $i++;      if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) {        // ----- There are exactly the same        $v_result = 2;      }      else if ($i < $v_list_dir_size) {        // ----- The path is shorter than the dir        $v_result = 0;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilCopyBlock()  // Description :  // Parameters :  //   $p_mode : read/write compression mode  //             0 : src & dest normal  //             1 : src gzip, dest normal  //             2 : src normal, dest gzip  //             3 : src & dest gzip  // Return Values :  // --------------------------------------------------------------------------------  function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode=0)  {    $v_result = 1;    if ($p_mode==0)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @fread($p_src, $v_read_size);        @fwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    else if ($p_mode==1)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @gzread($p_src, $v_read_size);        @fwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    else if ($p_mode==2)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @fread($p_src, $v_read_size);        @gzwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    else if ($p_mode==3)    {      while ($p_size != 0)      {        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);        $v_buffer = @gzread($p_src, $v_read_size);        @gzwrite($p_dest, $v_buffer, $v_read_size);        $p_size -= $v_read_size;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilRename()  // Description :  //   This function tries to do a simple rename() function. If it fails, it  //   tries to copy the $p_src file in a new $p_dest file and then unlink the  //   first one.  // Parameters :  //   $p_src : Old filename  //   $p_dest : New filename  // Return Values :  //   1 on success, 0 on failure.  // --------------------------------------------------------------------------------  function PclZipUtilRename($p_src, $p_dest)  {    $v_result = 1;    // ----- Try to rename the files    if (!@rename($p_src, $p_dest)) {      // ----- Try to copy & unlink the src      if (!@copy($p_src, $p_dest)) {        $v_result = 0;      }      else if (!@unlink($p_src)) {        $v_result = 0;      }    }    // ----- Return    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilOptionText()  // Description :  //   Translate option value in text. Mainly for debug purpose.  // Parameters :  //   $p_option : the option value.  // Return Values :  //   The option text value.  // --------------------------------------------------------------------------------  function PclZipUtilOptionText($p_option)  {    $v_list = get_defined_constants();    for (reset($v_list); $v_key = key($v_list); next($v_list)) {	    $v_prefix = substr($v_key, 0, 10);	    if ((   ($v_prefix == 'PCLZIP_OPT')           || ($v_prefix == 'PCLZIP_CB_')           || ($v_prefix == 'PCLZIP_ATT'))	        && ($v_list[$v_key] == $p_option)) {        return $v_key;	    }    }    $v_result = 'Unknown';    return $v_result;  }  // --------------------------------------------------------------------------------  // --------------------------------------------------------------------------------  // Function : PclZipUtilTranslateWinPath()  // Description :  //   Translate windows path by replacing '\' by '/' and optionally removing  //   drive letter.  // Parameters :  //   $p_path : path to translate.  //   $p_remove_disk_letter : true | false  // Return Values :  //   The path translated.  // --------------------------------------------------------------------------------  function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter=true)  {    if (stristr(php_uname(), 'windows')) {      // ----- Look for potential disk letter      if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {          $p_path = substr($p_path, $v_position+1);      }      // ----- Change potential windows directory separator      if ((strpos($p_path, '\\') > 0) || (substr($p_path, 0,1) == '\\')) {          $p_path = strtr($p_path, '\\', '/');      }    }    return $p_path;  }  // --------------------------------------------------------------------------------?>
<?php/** * BackPress script procedural API. * * @package BackPress * @since r16 *//** * Prints script tags in document head. * * Called by admin-header.php and by wp_head hook. Since it is called by wp_head * on every page load, the function does not instantiate the WP_Scripts object * unless script names are explicitly passed. Does make use of already * instantiated $wp_scripts if present. Use provided wp_print_scripts hook to * register/enqueue new scripts. * * @since r16 * @see WP_Dependencies::print_scripts() */function wp_print_scripts( $handles = false ) {	do_action( 'wp_print_scripts' );	if ( '' === $handles ) // for wp_head		$handles = false;	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') ) {		if ( !$handles )			return array(); // No need to instantiate if nothing's there.		else			$wp_scripts = new WP_Scripts();	}	return $wp_scripts->do_items( $handles );}/** * Register new JavaScript file. * * @since r16 * @param string $handle Script name * @param string $src Script url * @param array $deps (optional) Array of script names on which this script depends * @param string|bool $ver (optional) Script version (used for cache busting), set to NULL to disable * @param bool (optional) Wether to enqueue the script before </head> or before </body> * @return null */function wp_register_script( $handle, $src, $deps = array(), $ver = false, $in_footer = false ) {	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') )		$wp_scripts = new WP_Scripts();	$wp_scripts->add( $handle, $src, $deps, $ver );	if ( $in_footer )		$wp_scripts->add_data( $handle, 'group', 1 );}/** * Localizes a script. * * Localizes only if script has already been added. * * @since r16 * @see WP_Scripts::localize() */function wp_localize_script( $handle, $object_name, $l10n ) {	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') )		return false;	return $wp_scripts->localize( $handle, $object_name, $l10n );}/** * Remove a registered script. * * @since r16 * @see WP_Scripts::remove() For parameter information. */function wp_deregister_script( $handle ) {	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') )		$wp_scripts = new WP_Scripts();	$wp_scripts->remove( $handle );}/** * Enqueues script. * * Registers the script if src provided (does NOT overwrite) and enqueues. * * @since r16 * @see wp_register_script() For parameter information. */function wp_enqueue_script( $handle, $src = false, $deps = array(), $ver = false, $in_footer = false ) {	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') )		$wp_scripts = new WP_Scripts();	if ( $src ) {		$_handle = explode('?', $handle);		$wp_scripts->add( $_handle[0], $src, $deps, $ver );		if ( $in_footer )			$wp_scripts->add_data( $_handle[0], 'group', 1 );	}	$wp_scripts->enqueue( $handle );}/** * Check whether script has been added to WordPress Scripts. * * The values for list defaults to 'queue', which is the same as enqueue for * scripts. * * @since WP unknown; BP unknown * * @param string $handle Handle used to add script. * @param string $list Optional, defaults to 'queue'. Others values are 'registered', 'queue', 'done', 'to_do' * @return bool */function wp_script_is( $handle, $list = 'queue' ) {	global $wp_scripts;	if ( !is_a($wp_scripts, 'WP_Scripts') )		$wp_scripts = new WP_Scripts();	$query = $wp_scripts->query( $handle, $list );	if ( is_object( $query ) )		return true;	return $query;}
<?php/** * WordPress Administration Importer API. * * @package WordPress * @subpackage Administration *//** * Retrieve list of importers. * * @since 2.0.0 * * @return array */function get_importers() {	global $wp_importers;	if ( is_array($wp_importers) )		uasort($wp_importers, create_function('$a, $b', 'return strcmp($a[0], $b[0]);'));	return $wp_importers;}/** * Register importer for WordPress. * * @since 2.0.0 * * @param string $id Importer tag. Used to uniquely identify importer. * @param string $name Importer name and title. * @param string $description Importer description. * @param callback $callback Callback to run. * @return WP_Error Returns WP_Error when $callback is WP_Error. */function register_importer( $id, $name, $description, $callback ) {	global $wp_importers;	if ( is_wp_error( $callback ) )		return $callback;	$wp_importers[$id] = array ( $name, $description, $callback );}/** * Cleanup importer. * * Removes attachment based on ID. * * @since 2.0.0 * * @param string $id Importer ID. */function wp_import_cleanup( $id ) {	wp_delete_attachment( $id );}/** * Handle importer uploading and add attachment. * * @since 2.0.0 * * @return array */function wp_import_handle_upload() {	if ( !isset($_FILES['import']) ) {		$file['error'] = __( 'File is empty. Please upload something more substantial. This error could also be caused by uploads being disabled in your php.ini or by post_max_size being defined as smaller than upload_max_filesize in php.ini.' );		return $file;	}	$overrides = array( 'test_form' => false, 'test_type' => false );	$_FILES['import']['name'] .= '.txt';	$file = wp_handle_upload( $_FILES['import'], $overrides );	if ( isset( $file['error'] ) )		return $file;	$url = $file['url'];	$type = $file['type'];	$file = addslashes( $file['file'] );	$filename = basename( $file );	// Construct the object array	$object = array( 'post_title' => $filename,		'post_content' => $url,		'post_mime_type' => $type,		'guid' => $url	);	// Save the data	$id = wp_insert_attachment( $object, $file );	return array( 'file' => $file, 'id' => $id );}?>
<?php/** * WordPress Upgrade Functions. Old file, must not be used. Include * wp-admin/includes/upgrade.php instead. * * @deprecated 2.5 * @package WordPress * @subpackage Administration */_deprecated_file( basename(__FILE__), '2.5', 'wp-admin/includes/upgrade.php' );require_once(ABSPATH . 'wp-admin/includes/upgrade.php');?>
<?php/** * Widgets administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once( './admin.php' );/** WordPress Administration Widgets API */require_once(ABSPATH . 'wp-admin/includes/widgets.php');if ( ! current_user_can('edit_theme_options') )	wp_die( __( 'Cheatin&#8217; uh?' ));wp_admin_css( 'widgets' );$widgets_access = get_user_setting( 'widgets_access' );if ( isset($_GET['widgets-access']) ) {	$widgets_access = 'on' == $_GET['widgets-access'] ? 'on' : 'off';	set_user_setting( 'widgets_access', $widgets_access );}if ( 'on' == $widgets_access )	add_filter( 'admin_body_class', create_function('', '{return " widgets_access ";}') );else	wp_enqueue_script('admin-widgets');do_action( 'sidebar_admin_setup' );$title = __( 'Widgets' );$parent_file = 'themes.php';$help = '	<p>' . __('Widgets are independent sections of content that can be placed into any widgetized area provided by your theme (commonly called sidebars). To populate your sidebars/widget areas with individual widgets, drag and drop the title bars into the desired area. By default, only the first widget area is expanded. To populate additional widget areas, click on their title bars to expand them.') . '</p>	<p>' . __('Available Widgets section contains all the widgets you can choose from. Once you drag a widget into a sidebar, it will open to allow you to configure its settings. When you are happy with the widget settings, click the Save button and the widget will go live on your site. If you click Delete, it will remove the widget.') . '</p>	<p>' . __('If you want to remove the widget but save its setting for possible future use, just drag it into the Inactive Widgets area. You can add them back anytime from there. This is especially helpful when you switch to a theme with fewer or different widget areas.') . '</p>	<p>' . __('Widgets may be used multiple times. You can give each widget a title, to display on your site, but it&#8217;s not required.') . '</p>	<p>' . __('Enabling Accessibility Mode, via Screen Options, allows you to use Add and Edit buttons instead of using drag and drop.') . '</p>	<p>' . __('Many themes show some sidebar widgets by default until you edit your sidebars, but they are not automatically displayed in your sidebar management tool. After you make your first widget change, you can re-add the default widgets by adding them from the Available Widgets area.') . '</p>';$help .= '<p><strong>' . __('For more information:') . '</strong></p>';$help .= '<p>' . __('<a href="http://codex.wordpress.org/Appearance_Widgets_SubPanel" target="_blank">Widgets Documentation</a>') . '</p>';$help .= '<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>';add_contextual_help($current_screen, $help);// register the inactive_widgets area as sidebarregister_sidebar(array(	'name' => __('Inactive Widgets'),	'id' => 'wp_inactive_widgets',	'description' => '',	'before_widget' => '',	'after_widget' => '',	'before_title' => '',	'after_title' => '',));// These are the widgets grouped by sidebar$sidebars_widgets = wp_get_sidebars_widgets();if ( empty( $sidebars_widgets ) )	$sidebars_widgets = wp_get_widget_defaults();// look for "lost" widgets, this has to run at least on each theme changefunction retrieve_widgets() {	global $wp_registered_widget_updates, $wp_registered_sidebars, $sidebars_widgets, $wp_registered_widgets;	$_sidebars_widgets = array();	$sidebars = array_keys($wp_registered_sidebars);	unset( $sidebars_widgets['array_version'] );	$old = array_keys($sidebars_widgets);	sort($old);	sort($sidebars);	if ( $old == $sidebars )		return;	// Move the known-good ones first	foreach ( $sidebars as $id ) {		if ( array_key_exists( $id, $sidebars_widgets ) ) {			$_sidebars_widgets[$id] = $sidebars_widgets[$id];			unset($sidebars_widgets[$id], $sidebars[$id]);		}	}	// if new theme has less sidebars than the old theme	if ( !empty($sidebars_widgets) ) {		foreach ( $sidebars_widgets as $lost => $val ) {			if ( is_array($val) )				$_sidebars_widgets['wp_inactive_widgets'] = array_merge( (array) $_sidebars_widgets['wp_inactive_widgets'], $val );		}	}	// discard invalid, theme-specific widgets from sidebars	$shown_widgets = array();	foreach ( $_sidebars_widgets as $sidebar => $widgets ) {		if ( !is_array($widgets) )			continue;		$_widgets = array();		foreach ( $widgets as $widget ) {			if ( isset($wp_registered_widgets[$widget]) )				$_widgets[] = $widget;		}		$_sidebars_widgets[$sidebar] = $_widgets;		$shown_widgets = array_merge($shown_widgets, $_widgets);	}	$sidebars_widgets = $_sidebars_widgets;	unset($_sidebars_widgets, $_widgets);	// find hidden/lost multi-widget instances	$lost_widgets = array();	foreach ( $wp_registered_widgets as $key => $val ) {		if ( in_array($key, $shown_widgets, true) )			continue;		$number = preg_replace('/.+?-([0-9]+)$/', '$1', $key);		if ( 2 > (int) $number )			continue;		$lost_widgets[] = $key;	}	$sidebars_widgets['wp_inactive_widgets'] = array_merge($lost_widgets, (array) $sidebars_widgets['wp_inactive_widgets']);	wp_set_sidebars_widgets($sidebars_widgets);}retrieve_widgets();if ( count($wp_registered_sidebars) == 1 ) {	// If only "wp_inactive_widgets" is defined the theme has no sidebars, die.	require_once( './admin-header.php' );?>	<div class="wrap">	<?php screen_icon(); ?>	<h2><?php echo esc_html( $title ); ?></h2>		<div class="error">			<p><?php _e( 'No Sidebars Defined' ); ?></p>		</div>		<p><?php _e( 'The theme you are currently using isn&#8217;t widget-aware, meaning that it has no sidebars that you are able to change. For information on making your theme widget-aware, please <a href="http://codex.wordpress.org/Widgetizing_Themes">follow these instructions</a>.' ); ?></p>	</div><?php	require_once( './admin-footer.php' );	exit;}// We're saving a widget without jsif ( isset($_POST['savewidget']) || isset($_POST['removewidget']) ) {	$widget_id = $_POST['widget-id'];	check_admin_referer("save-delete-widget-$widget_id");	$number = isset($_POST['multi_number']) ? (int) $_POST['multi_number'] : '';	if ( $number ) {		foreach ( $_POST as $key => $val ) {			if ( is_array($val) && preg_match('/__i__|%i%/', key($val)) ) {				$_POST[$key] = array( $number => array_shift($val) );				break;			}		}	}	$sidebar_id = $_POST['sidebar'];	$position = isset($_POST[$sidebar_id . '_position']) ? (int) $_POST[$sidebar_id . '_position'] - 1 : 0;	$id_base = $_POST['id_base'];	$sidebar = isset($sidebars_widgets[$sidebar_id]) ? $sidebars_widgets[$sidebar_id] : array();	// delete	if ( isset($_POST['removewidget']) && $_POST['removewidget'] ) {		if ( !in_array($widget_id, $sidebar, true) ) {			wp_redirect('widgets.php?error=0');			exit;		}		$sidebar = array_diff( $sidebar, array($widget_id) );		$_POST = array('sidebar' => $sidebar_id, 'widget-' . $id_base => array(), 'the-widget-id' => $widget_id, 'delete_widget' => '1');	}	$_POST['widget-id'] = $sidebar;	foreach ( (array) $wp_registered_widget_updates as $name => $control ) {		if ( $name != $id_base || !is_callable($control['callback']) )			continue;		ob_start();			call_user_func_array( $control['callback'], $control['params'] );		ob_end_clean();		break;	}	$sidebars_widgets[$sidebar_id] = $sidebar;	// remove old position	if ( !isset($_POST['delete_widget']) ) {		foreach ( $sidebars_widgets as $key => $sb ) {			if ( is_array($sb) )				$sidebars_widgets[$key] = array_diff( $sb, array($widget_id) );		}		array_splice( $sidebars_widgets[$sidebar_id], $position, 0, $widget_id );	}	wp_set_sidebars_widgets($sidebars_widgets);	wp_redirect('widgets.php?message=0');	exit;}// Output the widget form without jsif ( isset($_GET['editwidget']) && $_GET['editwidget'] ) {	$widget_id = $_GET['editwidget'];	if ( isset($_GET['addnew']) ) {		// Default to the first sidebar		$sidebar = array_shift( $keys = array_keys($wp_registered_sidebars) );		if ( isset($_GET['base']) && isset($_GET['num']) ) { // multi-widget			// Copy minimal info from an existing instance of this widget to a new instance			foreach ( $wp_registered_widget_controls as $control ) {				if ( $_GET['base'] === $control['id_base'] ) {					$control_callback = $control['callback'];					$multi_number = (int) $_GET['num'];					$control['params'][0]['number'] = -1;					$widget_id = $control['id'] = $control['id_base'] . '-' . $multi_number;					$wp_registered_widget_controls[$control['id']] = $control;					break;				}			}		}	}	if ( isset($wp_registered_widget_controls[$widget_id]) && !isset($control) ) {		$control = $wp_registered_widget_controls[$widget_id];		$control_callback = $control['callback'];	} elseif ( !isset($wp_registered_widget_controls[$widget_id]) && isset($wp_registered_widgets[$widget_id]) ) {		$name = esc_html( strip_tags($wp_registered_widgets[$widget_id]['name']) );	}	if ( !isset($name) )		$name = esc_html( strip_tags($control['name']) );	if ( !isset($sidebar) )		$sidebar = isset($_GET['sidebar']) ? $_GET['sidebar'] : 'wp_inactive_widgets';	if ( !isset($multi_number) )		$multi_number = isset($control['params'][0]['number']) ? $control['params'][0]['number'] : '';	$id_base = isset($control['id_base']) ? $control['id_base'] : $control['id'];	// show the widget form	$width = ' style="width:' . max($control['width'], 350) . 'px"';	$key = isset($_GET['key']) ? (int) $_GET['key'] : 0;	require_once( './admin-header.php' ); ?>	<div class="wrap">	<?php screen_icon(); ?>	<h2><?php echo esc_html( $title ); ?></h2>	<div class="editwidget"<?php echo $width; ?>>	<h3><?php printf( __( 'Widget %s' ), $name ); ?></h3>	<form action="widgets.php" method="post">	<div class="widget-inside"><?php	if ( is_callable( $control_callback ) )		call_user_func_array( $control_callback, $control['params'] );	else		echo '<p>' . __('There are no options for this widget.') . "</p>\n"; ?>	</div>	<p class="describe"><?php _e('Select both the sidebar for this widget and the position of the widget in that sidebar.'); ?></p>	<div class="widget-position">	<table class="widefat"><thead><tr><th><?php _e('Sidebar'); ?></th><th><?php _e('Position'); ?></th></tr></thead><tbody><?php	foreach ( $wp_registered_sidebars as $sbname => $sbvalue ) {		echo "\t\t<tr><td><label><input type='radio' name='sidebar' value='" . esc_attr($sbname) . "'" . checked( $sbname, $sidebar, false ) . " /> $sbvalue[name]</label></td><td>";		if ( 'wp_inactive_widgets' == $sbname ) {			echo '&nbsp;';		} else {			if ( !isset($sidebars_widgets[$sbname]) || !is_array($sidebars_widgets[$sbname]) ) {				$j = 1;				$sidebars_widgets[$sbname] = array();			} else {				$j = count($sidebars_widgets[$sbname]);				if ( isset($_GET['addnew']) || !in_array($widget_id, $sidebars_widgets[$sbname], true) )					$j++;			}			$selected = '';			echo "\t\t<select name='{$sbname}_position'>\n";			echo "\t\t<option value=''>" . __('&mdash; Select &mdash;') . "</option>\n";			for ( $i = 1; $i <= $j; $i++ ) {				if ( in_array($widget_id, $sidebars_widgets[$sbname], true) )					$selected = selected( $i, $key + 1, false );				echo "\t\t<option value='$i'$selected> $i </option>\n";			}			echo "\t\t</select>\n";		}		echo "</td></tr>\n";	} ?>	</tbody></table>	</div>	<div class="widget-control-actions"><?php	if ( isset($_GET['addnew']) ) { ?>	<a href="widgets.php" class="button alignleft"><?php _e('Cancel'); ?></a><?php	} else { ?>	<input type="submit" name="removewidget" class="button alignleft" value="<?php esc_attr_e('Delete'); ?>" /><?php	} ?>	<input type="submit" name="savewidget" class="button-primary alignright" value="<?php esc_attr_e('Save Widget'); ?>" />	<input type="hidden" name="widget-id" class="widget-id" value="<?php echo esc_attr($widget_id); ?>" />	<input type="hidden" name="id_base" class="id_base" value="<?php echo esc_attr($id_base); ?>" />	<input type="hidden" name="multi_number" class="multi_number" value="<?php echo esc_attr($multi_number); ?>" /><?php	wp_nonce_field("save-delete-widget-$widget_id"); ?>	<br class="clear" />	</div>	</form>	</div>	</div><?php	require_once( './admin-footer.php' );	exit;}$messages = array(	__('Changes saved.'));$errors = array(	__('Error while saving.'),	__('Error in displaying the widget settings form.'));require_once( './admin-header.php' ); ?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><?php if ( isset($_GET['message']) && isset($messages[$_GET['message']]) ) { ?><div id="message" class="updated"><p><?php echo $messages[$_GET['message']]; ?></p></div><?php } ?><?php if ( isset($_GET['error']) && isset($errors[$_GET['error']]) ) { ?><div id="message" class="error"><p><?php echo $errors[$_GET['error']]; ?></p></div><?php } ?><?php do_action( 'widgets_admin_page' ); ?><div class="widget-liquid-left"><div id="widgets-left">	<div id="available-widgets" class="widgets-holder-wrap">		<div class="sidebar-name">		<div class="sidebar-name-arrow"><br /></div>		<h3><?php _e('Available Widgets'); ?> <span id="removing-widget"><?php _e('Deactivate'); ?> <span></span></span></h3></div>		<div class="widget-holder">		<p class="description"><?php _e('Drag widgets from here to a sidebar on the right to activate them. Drag widgets back here to deactivate them and delete their settings.'); ?></p>		<div id="widget-list">		<?php wp_list_widgets(); ?>		</div>		<br class='clear' />		</div>		<br class="clear" />	</div>	<div class="widgets-holder-wrap">		<div class="sidebar-name">		<div class="sidebar-name-arrow"><br /></div>		<h3><?php _e('Inactive Widgets'); ?>		<span><img src="<?php echo esc_url( admin_url( 'images/wpspin_light.gif' ) ); ?>" class="ajax-feedback" title="" alt="" /></span></h3></div>		<div class="widget-holder inactive">		<p class="description"><?php _e('Drag widgets here to remove them from the sidebar but keep their settings.'); ?></p>		<?php wp_list_widget_controls('wp_inactive_widgets'); ?>		<br class="clear" />		</div>	</div></div></div><div class="widget-liquid-right"><div id="widgets-right"><?php$i = 0;foreach ( $wp_registered_sidebars as $sidebar => $registered_sidebar ) {	if ( 'wp_inactive_widgets' == $sidebar )		continue;	$closed = $i ? ' closed' : ''; ?>	<div class="widgets-holder-wrap<?php echo $closed; ?>">	<div class="sidebar-name">	<div class="sidebar-name-arrow"><br /></div>	<h3><?php echo esc_html( $registered_sidebar['name'] ); ?>	<span><img src="<?php echo esc_url( admin_url( 'images/wpspin_dark.gif' ) ); ?>" class="ajax-feedback" title="" alt="" /></span></h3></div>	<?php wp_list_widget_controls( $sidebar ); // Show the control forms for each of the widgets in this sidebar ?>	</div><?php	$i++;} ?></div></div><form action="" method="post"><?php wp_nonce_field( 'save-sidebar-widgets', '_wpnonce_widgets', false ); ?></form><br class="clear" /></div><?phpdo_action( 'sidebar_admin_page' );require_once( './admin-footer.php' );
<?php/** * Privacy Options Settings Administration Panel. * * @package WordPress * @subpackage Administration *//** Load WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can( 'manage_options' ) )	wp_die( __( 'You do not have sufficient permissions to manage options for this site.' ) );$title = __('Privacy Settings');$parent_file = 'options-general.php';add_contextual_help($current_screen,	'<p>' . __('You can choose whether or not your site will be crawled by robots, ping services, and spiders. If you want those services to ignore your site, click the second option here. Note that your privacy is not complete; your site is still visible on the web.') . '</p>' .	'<p>' . __('When this setting is in effect a reminder is shown in the header of these administration screens that says, &#8220;Search Engines Blocked,&#8221; to remind you that your site is not being crawled.') . '</p>' .	'<p>' . __('You must click the Save Changes button at the bottom of the screen for new settings to take effect.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Settings_Privacy_SubPanel" target="_blank">Privacy Settings Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');include('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><form method="post" action="options.php"><?php settings_fields('privacy'); ?><table class="form-table"><tr valign="top"><th scope="row"><?php _e('Site Visibility') ?> </th><td><fieldset><legend class="screen-reader-text"><span><?php _e('Site Visibility') ?> </span></legend><input id="blog-public" type="radio" name="blog_public" value="1" <?php checked('1', get_option('blog_public')); ?> /><label for="blog-public"><?php _e('I would like my site to be visible to everyone, including search engines (like Google, Bing, Technorati) and archivers');?></label><br/><input id="blog-norobots" type="radio" name="blog_public" value="0" <?php checked('0', get_option('blog_public')); ?> /><label for="blog-norobots"><?php _e('I would like to block search engines, but allow normal visitors'); ?></label><?php do_action('blog_privacy_selector'); ?></fieldset></td></tr><?php do_settings_fields('privacy', 'default'); ?></table><?php do_settings_sections('privacy'); ?><p class="submit">	<input type="submit" name="Submit" class="button-primary" value="<?php esc_attr_e('Save Changes') ?>" /></p></form></div><?php include('./admin-footer.php') ?>
<?php/** * Classes, which help reading streams of data from files. * Based on the classes from Danilo Segan <danilo@kvota.net> * * @version $Id: streams.php 406 2010-02-07 11:10:24Z nbachiyski $ * @package pomo * @subpackage streams */if ( !class_exists( 'POMO_Reader' ) ):class POMO_Reader {	var $endian = 'little';	var $_post = '';	function POMO_Reader() {		$this->is_overloaded = ((ini_get("mbstring.func_overload") & 2) != 0) && function_exists('mb_substr');		$this->_pos = 0;	}	/**	 * Sets the endianness of the file.	 *	 * @param $endian string 'big' or 'little'	 */	function setEndian($endian) {		$this->endian = $endian;	}	/**	 * Reads a 32bit Integer from the Stream	 *	 * @return mixed The integer, corresponding to the next 32 bits from	 * 	the stream of false if there are not enough bytes or on error	 */	function readint32() {		$bytes = $this->read(4);		if (4 != $this->strlen($bytes))			return false;		$endian_letter = ('big' == $this->endian)? 'N' : 'V';		$int = unpack($endian_letter, $bytes);		return array_shift($int);	}	/**	 * Reads an array of 32-bit Integers from the Stream	 *	 * @param integer count How many elements should be read	 * @return mixed Array of integers or false if there isn't	 * 	enough data or on error	 */	function readint32array($count) {		$bytes = $this->read(4 * $count);		if (4*$count != $this->strlen($bytes))			return false;		$endian_letter = ('big' == $this->endian)? 'N' : 'V';		return unpack($endian_letter.$count, $bytes);	}	function substr($string, $start, $length) {		if ($this->is_overloaded) {			return mb_substr($string, $start, $length, 'ascii');		} else {			return substr($string, $start, $length);		}	}	function strlen($string) {		if ($this->is_overloaded) {			return mb_strlen($string, 'ascii');		} else {			return strlen($string);		}	}	function str_split($string, $chunk_size) {		if (!function_exists('str_split')) {			$length = $this->strlen($string);			$out = array();			for ($i = 0; $i < $length; $i += $chunk_size)				$out[] = $this->substr($string, $i, $chunk_size);			return $out;		} else {			return str_split( $string, $chunk_size );		}	}	function pos() {		return $this->_pos;	}	function is_resource() {		return true;	}	function close() {		return true;	}}endif;if ( !class_exists( 'POMO_FileReader' ) ):class POMO_FileReader extends POMO_Reader {	function POMO_FileReader($filename) {		parent::POMO_Reader();		$this->_f = fopen($filename, 'r');	}	function read($bytes) {		return fread($this->_f, $bytes);	}	function seekto($pos) {		if ( -1 == fseek($this->_f, $pos, SEEK_SET)) {			return false;		}		$this->_pos = $pos;		return true;	}	function is_resource() {		return is_resource($this->_f);	}	function feof() {		return feof($this->_f);	}	function close() {		return fclose($this->_f);	}	function read_all() {		$all = '';		while ( !$this->feof() )			$all .= $this->read(4096);		return $all;	}}endif;if ( !class_exists( 'POMO_StringReader' ) ):/** * Provides file-like methods for manipulating a string instead * of a physical file. */class POMO_StringReader extends POMO_Reader {	var $_str = '';	function POMO_StringReader($str = '') {		parent::POMO_Reader();		$this->_str = $str;		$this->_pos = 0;	}	function read($bytes) {		$data = $this->substr($this->_str, $this->_pos, $bytes);		$this->_pos += $bytes;		if ($this->strlen($this->_str) < $this->_pos) $this->_pos = $this->strlen($this->_str);		return $data;	}	function seekto($pos) {		$this->_pos = $pos;		if ($this->strlen($this->_str) < $this->_pos) $this->_pos = $this->strlen($this->_str);		return $this->_pos;	}	function length() {		return $this->strlen($this->_str);	}	function read_all() {		return $this->substr($this->_str, $this->_pos, $this->strlen($this->_str));	}}endif;if ( !class_exists( 'POMO_CachedFileReader' ) ):/** * Reads the contents of the file in the beginning. */class POMO_CachedFileReader extends POMO_StringReader {	function POMO_CachedFileReader($filename) {		parent::POMO_StringReader();		$this->_str = file_get_contents($filename);		if (false === $this->_str)			return false;		$this->_pos = 0;	}}endif;if ( !class_exists( 'POMO_CachedIntFileReader' ) ):/** * Reads the contents of the file in the beginning. */class POMO_CachedIntFileReader extends POMO_CachedFileReader {	function POMO_CachedIntFileReader($filename) {		parent::POMO_CachedFileReader($filename);	}}endif;
<?php/** * Deprecated. Use registration.php. * * @package WordPress */_deprecated_file( basename(__FILE__), '2.1', WPINC .  '/registration.php' );require_once(ABSPATH . WPINC .  '/registration.php');?>
<?php/** * User Registration API * * @package WordPress *//** * Checks whether the given username exists. * * @since 2.0.0 * * @param string $username Username. * @return null|int The user's ID on success, and null on failure. */function username_exists( $username ) {	if ( $user = get_userdatabylogin( $username ) ) {		return $user->ID;	} else {		return null;	}}/** * Checks whether the given email exists. * * @since 2.1.0 * @uses $wpdb * * @param string $email Email. * @return bool|int The user's ID on success, and false on failure. */function email_exists( $email ) {	if ( $user = get_user_by_email($email) )		return $user->ID;	return false;}/** * Checks whether an username is valid. * * @since 2.0.1 * @uses apply_filters() Calls 'validate_username' hook on $valid check and $username as parameters * * @param string $username Username. * @return bool Whether username given is valid */function validate_username( $username ) {	$sanitized = sanitize_user( $username, true );	$valid = ( $sanitized == $username );	return apply_filters( 'validate_username', $valid, $username );}/** * Insert an user into the database. * * Can update a current user or insert a new user based on whether the user's ID * is present. * * Can be used to update the user's info (see below), set the user's role, and * set the user's preference on whether they want the rich editor on. * * Most of the $userdata array fields have filters associated with the values. * The exceptions are 'rich_editing', 'role', 'jabber', 'aim', 'yim', * 'user_registered', and 'ID'. The filters have the prefix 'pre_user_' followed * by the field name. An example using 'description' would have the filter * called, 'pre_user_description' that can be hooked into. * * The $userdata array can contain the following fields: * 'ID' - An integer that will be used for updating an existing user. * 'user_pass' - A string that contains the plain text password for the user. * 'user_login' - A string that contains the user's username for logging in. * 'user_nicename' - A string that contains a nicer looking name for the user. *		The default is the user's username. * 'user_url' - A string containing the user's URL for the user's web site. * 'user_email' - A string containing the user's email address. * 'display_name' - A string that will be shown on the site. Defaults to user's *		username. It is likely that you will want to change this, for both *		appearance and security through obscurity (that is if you don't use and *		delete the default 'admin' user). * 'nickname' - The user's nickname, defaults to the user's username. * 'first_name' - The user's first name. * 'last_name' - The user's last name. * 'description' - A string containing content about the user. * 'rich_editing' - A string for whether to enable the rich editor. False *		if not empty. * 'user_registered' - The date the user registered. Format is 'Y-m-d H:i:s'. * 'role' - A string used to set the user's role. * 'jabber' - User's Jabber account. * 'aim' - User's AOL IM account. * 'yim' - User's Yahoo IM account. * * @since 2.0.0 * @uses $wpdb WordPress database layer. * @uses apply_filters() Calls filters for most of the $userdata fields with the prefix 'pre_user'. See note above. * @uses do_action() Calls 'profile_update' hook when updating giving the user's ID * @uses do_action() Calls 'user_register' hook when creating a new user giving the user's ID * * @param array $userdata An array of user data. * @return int|WP_Error The newly created user's ID or a WP_Error object if the user could not be created. */function wp_insert_user($userdata) {	global $wpdb;	extract($userdata, EXTR_SKIP);	// Are we updating or creating?	if ( !empty($ID) ) {		$ID = (int) $ID;		$update = true;		$old_user_data = get_userdata($ID);	} else {		$update = false;		// Hash the password		$user_pass = wp_hash_password($user_pass);	}	$user_login = sanitize_user($user_login, true);	$user_login = apply_filters('pre_user_login', $user_login);	//Remove any non-printable chars from the login string to see if we have ended up with an empty username	$user_login = trim($user_login);	if ( empty($user_login) )		return new WP_Error('empty_user_login', __('Cannot create a user with an empty login name.') );	if ( !$update && username_exists( $user_login ) )		return new WP_Error('existing_user_login', __('This username is already registered.') );	if ( empty($user_nicename) )		$user_nicename = sanitize_title( $user_login );	$user_nicename = apply_filters('pre_user_nicename', $user_nicename);	if ( empty($user_url) )		$user_url = '';	$user_url = apply_filters('pre_user_url', $user_url);	if ( empty($user_email) )		$user_email = '';	$user_email = apply_filters('pre_user_email', $user_email);	if ( !$update && ! defined( 'WP_IMPORTING' ) && email_exists($user_email) )		return new WP_Error('existing_user_email', __('This email address is already registered.') );	if ( empty($display_name) )		$display_name = $user_login;	$display_name = apply_filters('pre_user_display_name', $display_name);	if ( empty($nickname) )		$nickname = $user_login;	$nickname = apply_filters('pre_user_nickname', $nickname);	if ( empty($first_name) )		$first_name = '';	$first_name = apply_filters('pre_user_first_name', $first_name);	if ( empty($last_name) )		$last_name = '';	$last_name = apply_filters('pre_user_last_name', $last_name);	if ( empty($description) )		$description = '';	$description = apply_filters('pre_user_description', $description);	if ( empty($rich_editing) )		$rich_editing = 'true';	if ( empty($comment_shortcuts) )		$comment_shortcuts = 'false';	if ( empty($admin_color) )		$admin_color = 'fresh';	$admin_color = preg_replace('|[^a-z0-9 _.\-@]|i', '', $admin_color);	if ( empty($use_ssl) )		$use_ssl = 0;	if ( empty($user_registered) )		$user_registered = gmdate('Y-m-d H:i:s');	$user_nicename_check = $wpdb->get_var( $wpdb->prepare("SELECT ID FROM $wpdb->users WHERE user_nicename = %s AND user_login != %s LIMIT 1" , $user_nicename, $user_login));	if ( $user_nicename_check ) {		$suffix = 2;		while ($user_nicename_check) {			$alt_user_nicename = $user_nicename . "-$suffix";			$user_nicename_check = $wpdb->get_var( $wpdb->prepare("SELECT ID FROM $wpdb->users WHERE user_nicename = %s AND user_login != %s LIMIT 1" , $alt_user_nicename, $user_login));			$suffix++;		}		$user_nicename = $alt_user_nicename;	}	$data = compact( 'user_pass', 'user_email', 'user_url', 'user_nicename', 'display_name', 'user_registered' );	$data = stripslashes_deep( $data );	if ( $update ) {		$wpdb->update( $wpdb->users, $data, compact( 'ID' ) );		$user_id = (int) $ID;	} else {		$wpdb->insert( $wpdb->users, $data + compact( 'user_login' ) );		$user_id = (int) $wpdb->insert_id;	}	update_user_meta( $user_id, 'first_name', $first_name);	update_user_meta( $user_id, 'last_name', $last_name);	update_user_meta( $user_id, 'nickname', $nickname );	update_user_meta( $user_id, 'description', $description );	update_user_meta( $user_id, 'rich_editing', $rich_editing);	update_user_meta( $user_id, 'comment_shortcuts', $comment_shortcuts);	update_user_meta( $user_id, 'admin_color', $admin_color);	update_user_meta( $user_id, 'use_ssl', $use_ssl);	foreach ( _wp_get_user_contactmethods() as $method => $name ) {		if ( empty($$method) )			$$method = '';		update_user_meta( $user_id, $method, $$method );	}	if ( isset($role) ) {		$user = new WP_User($user_id);		$user->set_role($role);	} elseif ( !$update ) {		$user = new WP_User($user_id);		$user->set_role(get_option('default_role'));	}	wp_cache_delete($user_id, 'users');	wp_cache_delete($user_login, 'userlogins');	if ( $update )		do_action('profile_update', $user_id, $old_user_data);	else		do_action('user_register', $user_id);	return $user_id;}/** * Update an user in the database. * * It is possible to update a user's password by specifying the 'user_pass' * value in the $userdata parameter array. * * If $userdata does not contain an 'ID' key, then a new user will be created * and the new user's ID will be returned. * * If current user's password is being updated, then the cookies will be * cleared. * * @since 2.0.0 * @see wp_insert_user() For what fields can be set in $userdata * @uses wp_insert_user() Used to update existing user or add new one if user doesn't exist already * * @param array $userdata An array of user data. * @return int The updated user's ID. */function wp_update_user($userdata) {	$ID = (int) $userdata['ID'];	// First, get all of the original fields	$user = get_userdata($ID);	// Escape data pulled from DB.	$user = add_magic_quotes(get_object_vars($user));	// If password is changing, hash it now.	if ( ! empty($userdata['user_pass']) ) {		$plaintext_pass = $userdata['user_pass'];		$userdata['user_pass'] = wp_hash_password($userdata['user_pass']);	}	wp_cache_delete($user[ 'user_email' ], 'useremail');	// Merge old and new fields with new fields overwriting old ones.	$userdata = array_merge($user, $userdata);	$user_id = wp_insert_user($userdata);	// Update the cookies if the password changed.	$current_user = wp_get_current_user();	if ( $current_user->id == $ID ) {		if ( isset($plaintext_pass) ) {			wp_clear_auth_cookie();			wp_set_auth_cookie($ID);		}	}	return $user_id;}/** * A simpler way of inserting an user into the database. * * Creates a new user with just the username, password, and email. For a more * detail creation of a user, use wp_insert_user() to specify more infomation. * * @since 2.0.0 * @see wp_insert_user() More complete way to create a new user * * @param string $username The user's username. * @param string $password The user's password. * @param string $email The user's email (optional). * @return int The new user's ID. */function wp_create_user($username, $password, $email = '') {	$user_login = esc_sql( $username );	$user_email = esc_sql( $email    );	$user_pass = $password;	$userdata = compact('user_login', 'user_email', 'user_pass');	return wp_insert_user($userdata);}/** * Set up the default contact methods * * @access private * @since * * @return array $user_contactmethods Array of contact methods and their labels. */function _wp_get_user_contactmethods() {	$user_contactmethods = array(		'aim' => __('AIM'),		'yim' => __('Yahoo IM'),		'jabber' => __('Jabber / Google Talk')	);	return apply_filters('user_contactmethods',$user_contactmethods);}?>
<?php/** * The plugin API is located in this file, which allows for creating actions * and filters and hooking functions, and methods. The functions or methods will * then be run when the action or filter is called. * * The API callback examples reference functions, but can be methods of classes. * To hook methods, you'll need to pass an array one of two ways. * * Any of the syntaxes explained in the PHP documentation for the * {@link http://us2.php.net/manual/en/language.pseudo-types.php#language.types.callback 'callback'} * type are valid. * * Also see the {@link http://codex.wordpress.org/Plugin_API Plugin API} for * more information and examples on how to use a lot of these functions. * * @package WordPress * @subpackage Plugin * @since 1.5 *//** * Hooks a function or method to a specific filter action. * * Filters are the hooks that WordPress launches to modify text of various types * before adding it to the database or sending it to the browser screen. Plugins * can specify that one or more of its PHP functions is executed to * modify specific types of text at these times, using the Filter API. * * To use the API, the following code should be used to bind a callback to the * filter. * * <code> * function example_hook($example) { echo $example; } * add_filter('example_filter', 'example_hook'); * </code> * * In WordPress 1.5.1+, hooked functions can take extra arguments that are set * when the matching do_action() or apply_filters() call is run. The * $accepted_args allow for calling functions only when the number of args * match. Hooked functions can take extra arguments that are set when the * matching do_action() or apply_filters() call is run. For example, the action * comment_id_not_found will pass any functions that hook onto it the ID of the * requested comment. * * <strong>Note:</strong> the function will return true no matter if the * function was hooked fails or not. There are no checks for whether the * function exists beforehand and no checks to whether the <tt>$function_to_add * is even a string. It is up to you to take care and this is done for * optimization purposes, so everything is as quick as possible. * * @package WordPress * @subpackage Plugin * @since 0.71 * @global array $wp_filter Stores all of the filters added in the form of *	wp_filter['tag']['array of priorities']['array of functions serialized']['array of ['array (functions, accepted_args)']'] * @global array $merged_filters Tracks the tags that need to be merged for later. If the hook is added, it doesn't need to run through that process. * * @param string $tag The name of the filter to hook the $function_to_add to. * @param callback $function_to_add The name of the function to be called when the filter is applied. * @param int $priority optional. Used to specify the order in which the functions associated with a particular action are executed (default: 10). Lower numbers correspond with earlier execution, and functions with the same priority are executed in the order in which they were added to the action. * @param int $accepted_args optional. The number of arguments the function accept (default 1). * @return boolean true */function add_filter($tag, $function_to_add, $priority = 10, $accepted_args = 1) {	global $wp_filter, $merged_filters;	$idx = _wp_filter_build_unique_id($tag, $function_to_add, $priority);	$wp_filter[$tag][$priority][$idx] = array('function' => $function_to_add, 'accepted_args' => $accepted_args);	unset( $merged_filters[ $tag ] );	return true;}/** * Check if any filter has been registered for a hook. * * @package WordPress * @subpackage Plugin * @since 2.5 * @global array $wp_filter Stores all of the filters * * @param string $tag The name of the filter hook. * @param callback $function_to_check optional.  If specified, return the priority of that function on this hook or false if not attached. * @return int|boolean Optionally returns the priority on that hook for the specified function. */function has_filter($tag, $function_to_check = false) {	global $wp_filter;	$has = !empty($wp_filter[$tag]);	if ( false === $function_to_check || false == $has )		return $has;	if ( !$idx = _wp_filter_build_unique_id($tag, $function_to_check, false) )		return false;	foreach ( (array) array_keys($wp_filter[$tag]) as $priority ) {		if ( isset($wp_filter[$tag][$priority][$idx]) )			return $priority;	}	return false;}/** * Call the functions added to a filter hook. * * The callback functions attached to filter hook $tag are invoked by calling * this function. This function can be used to create a new filter hook by * simply calling this function with the name of the new hook specified using * the $tag parameter. * * The function allows for additional arguments to be added and passed to hooks. * <code> * function example_hook($string, $arg1, $arg2) * { *		//Do stuff *		return $string; * } * $value = apply_filters('example_filter', 'filter me', 'arg1', 'arg2'); * </code> * * @package WordPress * @subpackage Plugin * @since 0.71 * @global array $wp_filter Stores all of the filters * @global array $merged_filters Merges the filter hooks using this function. * @global array $wp_current_filter stores the list of current filters with the current one last * * @param string $tag The name of the filter hook. * @param mixed $value The value on which the filters hooked to <tt>$tag</tt> are applied on. * @param mixed $var,... Additional variables passed to the functions hooked to <tt>$tag</tt>. * @return mixed The filtered value after all hooked functions are applied to it. */function apply_filters($tag, $value) {	global $wp_filter, $merged_filters, $wp_current_filter;	$args = array();	$wp_current_filter[] = $tag;	// Do 'all' actions first	if ( isset($wp_filter['all']) ) {		$args = func_get_args();		_wp_call_all_hook($args);	}	if ( !isset($wp_filter[$tag]) ) {		array_pop($wp_current_filter);		return $value;	}	// Sort	if ( !isset( $merged_filters[ $tag ] ) ) {		ksort($wp_filter[$tag]);		$merged_filters[ $tag ] = true;	}	reset( $wp_filter[ $tag ] );	if ( empty($args) )		$args = func_get_args();	do {		foreach( (array) current($wp_filter[$tag]) as $the_ )			if ( !is_null($the_['function']) ){				$args[1] = $value;				$value = call_user_func_array($the_['function'], array_slice($args, 1, (int) $the_['accepted_args']));			}	} while ( next($wp_filter[$tag]) !== false );	array_pop( $wp_current_filter );	return $value;}/** * Execute functions hooked on a specific filter hook, specifying arguments in an array. * * @see apply_filters() This function is identical, but the arguments passed to the * functions hooked to <tt>$tag</tt> are supplied using an array. * * @package WordPress * @subpackage Plugin * @since 3.0.0 * @global array $wp_filter Stores all of the filters * @global array $merged_filters Merges the filter hooks using this function. * @global array $wp_current_filter stores the list of current filters with the current one last * * @param string $tag The name of the filter hook. * @param array $args The arguments supplied to the functions hooked to <tt>$tag</tt> * @return mixed The filtered value after all hooked functions are applied to it. */function apply_filters_ref_array($tag, $args) {	global $wp_filter, $merged_filters, $wp_current_filter;	$wp_current_filter[] = $tag;	// Do 'all' actions first	if ( isset($wp_filter['all']) ) {		$all_args = func_get_args();		_wp_call_all_hook($all_args);	}	if ( !isset($wp_filter[$tag]) ) {		array_pop($wp_current_filter);		return $args[0];	}	// Sort	if ( !isset( $merged_filters[ $tag ] ) ) {		ksort($wp_filter[$tag]);		$merged_filters[ $tag ] = true;	}	reset( $wp_filter[ $tag ] );	do {		foreach( (array) current($wp_filter[$tag]) as $the_ )			if ( !is_null($the_['function']) )				$args[0] = call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));	} while ( next($wp_filter[$tag]) !== false );	array_pop( $wp_current_filter );	return $args[0];}/** * Removes a function from a specified filter hook. * * This function removes a function attached to a specified filter hook. This * method can be used to remove default functions attached to a specific filter * hook and possibly replace them with a substitute. * * To remove a hook, the $function_to_remove and $priority arguments must match * when the hook was added. This goes for both filters and actions. No warning * will be given on removal failure. * * @package WordPress * @subpackage Plugin * @since 1.2 * * @param string $tag The filter hook to which the function to be removed is hooked. * @param callback $function_to_remove The name of the function which should be removed. * @param int $priority optional. The priority of the function (default: 10). * @param int $accepted_args optional. The number of arguments the function accpets (default: 1). * @return boolean Whether the function existed before it was removed. */function remove_filter($tag, $function_to_remove, $priority = 10, $accepted_args = 1) {	$function_to_remove = _wp_filter_build_unique_id($tag, $function_to_remove, $priority);	$r = isset($GLOBALS['wp_filter'][$tag][$priority][$function_to_remove]);	if ( true === $r) {		unset($GLOBALS['wp_filter'][$tag][$priority][$function_to_remove]);		if ( empty($GLOBALS['wp_filter'][$tag][$priority]) )			unset($GLOBALS['wp_filter'][$tag][$priority]);		unset($GLOBALS['merged_filters'][$tag]);	}	return $r;}/** * Remove all of the hooks from a filter. * * @since 2.7 * * @param string $tag The filter to remove hooks from. * @param int $priority The priority number to remove. * @return bool True when finished. */function remove_all_filters($tag, $priority = false) {	global $wp_filter, $merged_filters;	if( isset($wp_filter[$tag]) ) {		if( false !== $priority && isset($wp_filter[$tag][$priority]) )			unset($wp_filter[$tag][$priority]);		else			unset($wp_filter[$tag]);	}	if( isset($merged_filters[$tag]) )		unset($merged_filters[$tag]);	return true;}/** * Retrieve the name of the current filter or action. * * @package WordPress * @subpackage Plugin * @since 2.5 * * @return string Hook name of the current filter or action. */function current_filter() {	global $wp_current_filter;	return end( $wp_current_filter );}/** * Hooks a function on to a specific action. * * Actions are the hooks that the WordPress core launches at specific points * during execution, or when specific events occur. Plugins can specify that * one or more of its PHP functions are executed at these points, using the * Action API. * * @uses add_filter() Adds an action. Parameter list and functionality are the same. * * @package WordPress * @subpackage Plugin * @since 1.2 * * @param string $tag The name of the action to which the $function_to_add is hooked. * @param callback $function_to_add The name of the function you wish to be called. * @param int $priority optional. Used to specify the order in which the functions associated with a particular action are executed (default: 10). Lower numbers correspond with earlier execution, and functions with the same priority are executed in the order in which they were added to the action. * @param int $accepted_args optional. The number of arguments the function accept (default 1). */function add_action($tag, $function_to_add, $priority = 10, $accepted_args = 1) {	return add_filter($tag, $function_to_add, $priority, $accepted_args);}/** * Execute functions hooked on a specific action hook. * * This function invokes all functions attached to action hook $tag. It is * possible to create new action hooks by simply calling this function, * specifying the name of the new hook using the <tt>$tag</tt> parameter. * * You can pass extra arguments to the hooks, much like you can with * apply_filters(). * * @see apply_filters() This function works similar with the exception that * nothing is returned and only the functions or methods are called. * * @package WordPress * @subpackage Plugin * @since 1.2 * @global array $wp_filter Stores all of the filters * @global array $wp_actions Increments the amount of times action was triggered. * * @param string $tag The name of the action to be executed. * @param mixed $arg,... Optional additional arguments which are passed on to the functions hooked to the action. * @return null Will return null if $tag does not exist in $wp_filter array */function do_action($tag, $arg = '') {	global $wp_filter, $wp_actions, $merged_filters, $wp_current_filter;	if ( ! isset($wp_actions) )		$wp_actions = array();	if ( ! isset($wp_actions[$tag]) )		$wp_actions[$tag] = 1;	else		++$wp_actions[$tag];	$wp_current_filter[] = $tag;	// Do 'all' actions first	if ( isset($wp_filter['all']) ) {		$all_args = func_get_args();		_wp_call_all_hook($all_args);	}	if ( !isset($wp_filter[$tag]) ) {		array_pop($wp_current_filter);		return;	}	$args = array();	if ( is_array($arg) && 1 == count($arg) && isset($arg[0]) && is_object($arg[0]) ) // array(&$this)		$args[] =& $arg[0];	else		$args[] = $arg;	for ( $a = 2; $a < func_num_args(); $a++ )		$args[] = func_get_arg($a);	// Sort	if ( !isset( $merged_filters[ $tag ] ) ) {		ksort($wp_filter[$tag]);		$merged_filters[ $tag ] = true;	}	reset( $wp_filter[ $tag ] );	do {		foreach ( (array) current($wp_filter[$tag]) as $the_ )			if ( !is_null($the_['function']) )				call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));	} while ( next($wp_filter[$tag]) !== false );	array_pop($wp_current_filter);}/** * Retrieve the number times an action is fired. * * @package WordPress * @subpackage Plugin * @since 2.1 * @global array $wp_actions Increments the amount of times action was triggered. * * @param string $tag The name of the action hook. * @return int The number of times action hook <tt>$tag</tt> is fired */function did_action($tag) {	global $wp_actions;	if ( ! isset( $wp_actions ) || ! isset( $wp_actions[$tag] ) )		return 0;	return $wp_actions[$tag];}/** * Execute functions hooked on a specific action hook, specifying arguments in an array. * * @see do_action() This function is identical, but the arguments passed to the * functions hooked to <tt>$tag</tt> are supplied using an array. * * @package WordPress * @subpackage Plugin * @since 2.1 * @global array $wp_filter Stores all of the filters * @global array $wp_actions Increments the amount of times action was triggered. * * @param string $tag The name of the action to be executed. * @param array $args The arguments supplied to the functions hooked to <tt>$tag</tt> * @return null Will return null if $tag does not exist in $wp_filter array */function do_action_ref_array($tag, $args) {	global $wp_filter, $wp_actions, $merged_filters, $wp_current_filter;	if ( ! isset($wp_actions) )		$wp_actions = array();	if ( ! isset($wp_actions[$tag]) )		$wp_actions[$tag] = 1;	else		++$wp_actions[$tag];	$wp_current_filter[] = $tag;	// Do 'all' actions first	if ( isset($wp_filter['all']) ) {		$all_args = func_get_args();		_wp_call_all_hook($all_args);	}	if ( !isset($wp_filter[$tag]) ) {		array_pop($wp_current_filter);		return;	}	// Sort	if ( !isset( $merged_filters[ $tag ] ) ) {		ksort($wp_filter[$tag]);		$merged_filters[ $tag ] = true;	}	reset( $wp_filter[ $tag ] );	do {		foreach( (array) current($wp_filter[$tag]) as $the_ )			if ( !is_null($the_['function']) )				call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));	} while ( next($wp_filter[$tag]) !== false );	array_pop($wp_current_filter);}/** * Check if any action has been registered for a hook. * * @package WordPress * @subpackage Plugin * @since 2.5 * @see has_filter() has_action() is an alias of has_filter(). * * @param string $tag The name of the action hook. * @param callback $function_to_check optional.  If specified, return the priority of that function on this hook or false if not attached. * @return int|boolean Optionally returns the priority on that hook for the specified function. */function has_action($tag, $function_to_check = false) {	return has_filter($tag, $function_to_check);}/** * Removes a function from a specified action hook. * * This function removes a function attached to a specified action hook. This * method can be used to remove default functions attached to a specific filter * hook and possibly replace them with a substitute. * * @package WordPress * @subpackage Plugin * @since 1.2 * * @param string $tag The action hook to which the function to be removed is hooked. * @param callback $function_to_remove The name of the function which should be removed. * @param int $priority optional The priority of the function (default: 10). * @param int $accepted_args optional. The number of arguments the function accpets (default: 1). * @return boolean Whether the function is removed. */function remove_action($tag, $function_to_remove, $priority = 10, $accepted_args = 1) {	return remove_filter($tag, $function_to_remove, $priority, $accepted_args);}/** * Remove all of the hooks from an action. * * @since 2.7 * * @param string $tag The action to remove hooks from. * @param int $priority The priority number to remove them from. * @return bool True when finished. */function remove_all_actions($tag, $priority = false) {	return remove_all_filters($tag, $priority);}//// Functions for handling plugins.///** * Gets the basename of a plugin. * * This method extracts the name of a plugin from its filename. * * @package WordPress * @subpackage Plugin * @since 1.5 * * @access private * * @param string $file The filename of plugin. * @return string The name of a plugin. * @uses WP_PLUGIN_DIR */function plugin_basename($file) {	$file = str_replace('\\','/',$file); // sanitize for Win32 installs	$file = preg_replace('|/+|','/', $file); // remove any duplicate slash	$plugin_dir = str_replace('\\','/',WP_PLUGIN_DIR); // sanitize for Win32 installs	$plugin_dir = preg_replace('|/+|','/', $plugin_dir); // remove any duplicate slash	$mu_plugin_dir = str_replace('\\','/',WPMU_PLUGIN_DIR); // sanitize for Win32 installs	$mu_plugin_dir = preg_replace('|/+|','/', $mu_plugin_dir); // remove any duplicate slash	$file = preg_replace('#^' . preg_quote($plugin_dir, '#') . '/|^' . preg_quote($mu_plugin_dir, '#') . '/#','',$file); // get relative path from plugins dir	$file = trim($file, '/');	return $file;}/** * Gets the filesystem directory path (with trailing slash) for the plugin __FILE__ passed in * @package WordPress * @subpackage Plugin * @since 2.8 * * @param string $file The filename of the plugin (__FILE__) * @return string the filesystem path of the directory that contains the plugin */function plugin_dir_path( $file ) {	return trailingslashit( dirname( $file ) );}/** * Gets the URL directory path (with trailing slash) for the plugin __FILE__ passed in * @package WordPress * @subpackage Plugin * @since 2.8 * * @param string $file The filename of the plugin (__FILE__) * @return string the URL path of the directory that contains the plugin */function plugin_dir_url( $file ) {	return trailingslashit( plugins_url( '', $file ) );}/** * Set the activation hook for a plugin. * * When a plugin is activated, the action 'activate_PLUGINNAME' hook is * activated. In the name of this hook, PLUGINNAME is replaced with the name of * the plugin, including the optional subdirectory. For example, when the plugin * is located in wp-content/plugin/sampleplugin/sample.php, then the name of * this hook will become 'activate_sampleplugin/sample.php'. When the plugin * consists of only one file and is (as by default) located at * wp-content/plugin/sample.php the name of this hook will be * 'activate_sample.php'. * * @package WordPress * @subpackage Plugin * @since 2.0 * * @param string $file The filename of the plugin including the path. * @param callback $function the function hooked to the 'activate_PLUGIN' action. */function register_activation_hook($file, $function) {	$file = plugin_basename($file);	add_action('activate_' . $file, $function);}/** * Set the deactivation hook for a plugin. * * When a plugin is deactivated, the action 'deactivate_PLUGINNAME' hook is * deactivated. In the name of this hook, PLUGINNAME is replaced with the name * of the plugin, including the optional subdirectory. For example, when the * plugin is located in wp-content/plugin/sampleplugin/sample.php, then * the name of this hook will become 'activate_sampleplugin/sample.php'. * * When the plugin consists of only one file and is (as by default) located at * wp-content/plugin/sample.php the name of this hook will be * 'activate_sample.php'. * * @package WordPress * @subpackage Plugin * @since 2.0 * * @param string $file The filename of the plugin including the path. * @param callback $function the function hooked to the 'activate_PLUGIN' action. */function register_deactivation_hook($file, $function) {	$file = plugin_basename($file);	add_action('deactivate_' . $file, $function);}/** * Set the uninstallation hook for a plugin. * * Registers the uninstall hook that will be called when the user clicks on the * uninstall link that calls for the plugin to uninstall itself. The link won't * be active unless the plugin hooks into the action. * * The plugin should not run arbitrary code outside of functions, when * registering the uninstall hook. In order to run using the hook, the plugin * will have to be included, which means that any code laying outside of a * function will be run during the uninstall process. The plugin should not * hinder the uninstall process. * * If the plugin can not be written without running code within the plugin, then * the plugin should create a file named 'uninstall.php' in the base plugin * folder. This file will be called, if it exists, during the uninstall process * bypassing the uninstall hook. The plugin, when using the 'uninstall.php' * should always check for the 'WP_UNINSTALL_PLUGIN' constant, before * executing. * * @since 2.7 * * @param string $file * @param callback $callback The callback to run when the hook is called. */function register_uninstall_hook($file, $callback) {	// The option should not be autoloaded, because it is not needed in most	// cases. Emphasis should be put on using the 'uninstall.php' way of	// uninstalling the plugin.	$uninstallable_plugins = (array) get_option('uninstall_plugins');	$uninstallable_plugins[plugin_basename($file)] = $callback;	update_option('uninstall_plugins', $uninstallable_plugins);}/** * Calls the 'all' hook, which will process the functions hooked into it. * * The 'all' hook passes all of the arguments or parameters that were used for * the hook, which this function was called for. * * This function is used internally for apply_filters(), do_action(), and * do_action_ref_array() and is not meant to be used from outside those * functions. This function does not check for the existence of the all hook, so * it will fail unless the all hook exists prior to this function call. * * @package WordPress * @subpackage Plugin * @since 2.5 * @access private * * @uses $wp_filter Used to process all of the functions in the 'all' hook * * @param array $args The collected parameters from the hook that was called. * @param string $hook Optional. The hook name that was used to call the 'all' hook. */function _wp_call_all_hook($args) {	global $wp_filter;	reset( $wp_filter['all'] );	do {		foreach( (array) current($wp_filter['all']) as $the_ )			if ( !is_null($the_['function']) )				call_user_func_array($the_['function'], $args);	} while ( next($wp_filter['all']) !== false );}/** * Build Unique ID for storage and retrieval. * * The old way to serialize the callback caused issues and this function is the * solution. It works by checking for objects and creating an a new property in * the class to keep track of the object and new objects of the same class that * need to be added. * * It also allows for the removal of actions and filters for objects after they * change class properties. It is possible to include the property $wp_filter_id * in your class and set it to "null" or a number to bypass the workaround. * However this will prevent you from adding new classes and any new classes * will overwrite the previous hook by the same class. * * Functions and static method callbacks are just returned as strings and * shouldn't have any speed penalty. * * @package WordPress * @subpackage Plugin * @access private * @since 2.2.3 * @link http://trac.wordpress.org/ticket/3875 * * @global array $wp_filter Storage for all of the filters and actions * @param string $tag Used in counting how many hooks were applied * @param callback $function Used for creating unique id * @param int|bool $priority Used in counting how many hooks were applied.  If === false and $function is an object reference, we return the unique id only if it already has one, false otherwise. * @param string $type filter or action * @return string|bool Unique ID for usage as array key or false if $priority === false and $function is an object reference, and it does not already have a uniqe id. */function _wp_filter_build_unique_id($tag, $function, $priority) {	global $wp_filter;	static $filter_id_count = 0;	if ( is_string($function) )		return $function;	if ( is_object($function) ) {		// Closures are currently implemented as objects		$function = array( $function, '' );	} else {		$function = (array) $function;	}	if (is_object($function[0]) ) {		// Object Class Calling		if ( function_exists('spl_object_hash') ) {			return spl_object_hash($function[0]) . $function[1];		} else {			$obj_idx = get_class($function[0]).$function[1];			if ( !isset($function[0]->wp_filter_id) ) {				if ( false === $priority )					return false;				$obj_idx .= isset($wp_filter[$tag][$priority]) ? count((array)$wp_filter[$tag][$priority]) : $filter_id_count;				$function[0]->wp_filter_id = $filter_id_count;				++$filter_id_count;			} else {				$obj_idx .= $function[0]->wp_filter_id;			}			return $obj_idx;		}	} else if ( is_string($function[0]) ) {		// Static Calling		return $function[0].$function[1];	}}?>
<?php/** * Redirects to the RSS2 feed * This file is deprecated and only exists for backwards compatibility * * @package WordPress */require( './wp-load.php' );wp_redirect( get_bloginfo( 'rss2_url' ), 301 );?>
<?php/** * Creates the password cookie and redirects back to where the * visitor was before. * * @package WordPress *//** Make sure that the WordPress bootstrap has run before continuing. */require( dirname(__FILE__) . '/wp-load.php');if ( get_magic_quotes_gpc() )	$_POST['post_password'] = stripslashes($_POST['post_password']);// 10 dayssetcookie('wp-postpass_' . COOKIEHASH, $_POST['post_password'], time() + 864000, COOKIEPATH);wp_safe_redirect(wp_get_referer());?>
<?php/** * WordPress API for media display. * * @package WordPress *//** * Scale down the default size of an image. * * This is so that the image is a better fit for the editor and theme. * * The $size parameter accepts either an array or a string. The supported string * values are 'thumb' or 'thumbnail' for the given thumbnail size or defaults at * 128 width and 96 height in pixels. Also supported for the string value is * 'medium' and 'full'. The 'full' isn't actually supported, but any value other * than the supported will result in the content_width size or 500 if that is * not set. * * Finally, there is a filter named, 'editor_max_image_size' that will be called * on the calculated array for width and height, respectively. The second * parameter will be the value that was in the $size parameter. The returned * type for the hook is an array with the width as the first element and the * height as the second element. * * @since 2.5.0 * @uses wp_constrain_dimensions() This function passes the widths and the heights. * * @param int $width Width of the image * @param int $height Height of the image * @param string|array $size Size of what the result image should be. * @return array Width and height of what the result image should resize to. */function image_constrain_size_for_editor($width, $height, $size = 'medium') {	global $content_width, $_wp_additional_image_sizes;	if ( is_array($size) ) {		$max_width = $size[0];		$max_height = $size[1];	}	elseif ( $size == 'thumb' || $size == 'thumbnail' ) {		$max_width = intval(get_option('thumbnail_size_w'));		$max_height = intval(get_option('thumbnail_size_h'));		// last chance thumbnail size defaults		if ( !$max_width && !$max_height ) {			$max_width = 128;			$max_height = 96;		}	}	elseif ( $size == 'medium' ) {		$max_width = intval(get_option('medium_size_w'));		$max_height = intval(get_option('medium_size_h'));		// if no width is set, default to the theme content width if available	}	elseif ( $size == 'large' ) {		// we're inserting a large size image into the editor.  if it's a really		// big image we'll scale it down to fit reasonably within the editor		// itself, and within the theme's content width if it's known.  the user		// can resize it in the editor if they wish.		$max_width = intval(get_option('large_size_w'));		$max_height = intval(get_option('large_size_h'));		if ( intval($content_width) > 0 )			$max_width = min( intval($content_width), $max_width );	} elseif ( isset( $_wp_additional_image_sizes ) && count( $_wp_additional_image_sizes ) && in_array( $size, array_keys( $_wp_additional_image_sizes ) ) ) {		$max_width = intval( $_wp_additional_image_sizes[$size]['width'] );		$max_height = intval( $_wp_additional_image_sizes[$size]['height'] );		if ( intval($content_width) > 0 && is_admin() ) // Only in admin. Assume that theme authors know what they're doing.			$max_width = min( intval($content_width), $max_width );	}	// $size == 'full' has no constraint	else {		$max_width = $width;		$max_height = $height;	}	list( $max_width, $max_height ) = apply_filters( 'editor_max_image_size', array( $max_width, $max_height ), $size );	return wp_constrain_dimensions( $width, $height, $max_width, $max_height );}/** * Retrieve width and height attributes using given width and height values. * * Both attributes are required in the sense that both parameters must have a * value, but are optional in that if you set them to false or null, then they * will not be added to the returned string. * * You can set the value using a string, but it will only take numeric values. * If you wish to put 'px' after the numbers, then it will be stripped out of * the return. * * @since 2.5.0 * * @param int|string $width Optional. Width attribute value. * @param int|string $height Optional. Height attribute value. * @return string HTML attributes for width and, or height. */function image_hwstring($width, $height) {	$out = '';	if ($width)		$out .= 'width="'.intval($width).'" ';	if ($height)		$out .= 'height="'.intval($height).'" ';	return $out;}/** * Scale an image to fit a particular size (such as 'thumb' or 'medium'). * * Array with image url, width, height, and whether is intermediate size, in * that order is returned on success is returned. $is_intermediate is true if * $url is a resized image, false if it is the original. * * The URL might be the original image, or it might be a resized version. This * function won't create a new resized copy, it will just return an already * resized one if it exists. * * A plugin may use the 'image_downsize' filter to hook into and offer image * resizing services for images. The hook must return an array with the same * elements that are returned in the function. The first element being the URL * to the new image that was resized. * * @since 2.5.0 * @uses apply_filters() Calls 'image_downsize' on $id and $size to provide *		resize services. * * @param int $id Attachment ID for image. * @param string $size Optional, default is 'medium'. Size of image, can be 'thumbnail'. * @return bool|array False on failure, array on success. */function image_downsize($id, $size = 'medium') {	if ( !wp_attachment_is_image($id) )		return false;	$img_url = wp_get_attachment_url($id);	$meta = wp_get_attachment_metadata($id);	$width = $height = 0;	$is_intermediate = false;	// plugins can use this to provide resize services	if ( $out = apply_filters('image_downsize', false, $id, $size) )		return $out;	// try for a new style intermediate size	if ( $intermediate = image_get_intermediate_size($id, $size) ) {		$img_url = str_replace(basename($img_url), $intermediate['file'], $img_url);		$width = $intermediate['width'];		$height = $intermediate['height'];		$is_intermediate = true;	}	elseif ( $size == 'thumbnail' ) {		// fall back to the old thumbnail		if ( ($thumb_file = wp_get_attachment_thumb_file($id)) && $info = getimagesize($thumb_file) ) {			$img_url = str_replace(basename($img_url), basename($thumb_file), $img_url);			$width = $info[0];			$height = $info[1];			$is_intermediate = true;		}	}	if ( !$width && !$height && isset($meta['width'], $meta['height']) ) {		// any other type: use the real image		$width = $meta['width'];		$height = $meta['height'];	}	if ( $img_url) {		// we have the actual image size, but might need to further constrain it if content_width is narrower		list( $width, $height ) = image_constrain_size_for_editor( $width, $height, $size );		return array( $img_url, $width, $height, $is_intermediate );	}	return false;}/** * Registers a new image size */function add_image_size( $name, $width = 0, $height = 0, $crop = FALSE ) {	global $_wp_additional_image_sizes;	$_wp_additional_image_sizes[$name] = array( 'width' => absint( $width ), 'height' => absint( $height ), 'crop' => !!$crop );}/** * Registers an image size for the post thumbnail */function set_post_thumbnail_size( $width = 0, $height = 0, $crop = FALSE ) {	add_image_size( 'post-thumbnail', $width, $height, $crop );}/** * An <img src /> tag for an image attachment, scaling it down if requested. * * The filter 'get_image_tag_class' allows for changing the class name for the * image without having to use regular expressions on the HTML content. The * parameters are: what WordPress will use for the class, the Attachment ID, * image align value, and the size the image should be. * * The second filter 'get_image_tag' has the HTML content, which can then be * further manipulated by a plugin to change all attribute values and even HTML * content. * * @since 2.5.0 * * @uses apply_filters() The 'get_image_tag_class' filter is the IMG element *		class attribute. * @uses apply_filters() The 'get_image_tag' filter is the full IMG element with *		all attributes. * * @param int $id Attachment ID. * @param string $alt Image Description for the alt attribute. * @param string $title Image Description for the title attribute. * @param string $align Part of the class name for aligning the image. * @param string $size Optional. Default is 'medium'. * @return string HTML IMG element for given image attachment */function get_image_tag($id, $alt, $title, $align, $size='medium') {	list( $img_src, $width, $height ) = image_downsize($id, $size);	$hwstring = image_hwstring($width, $height);	$class = 'align' . esc_attr($align) .' size-' . esc_attr($size) . ' wp-image-' . $id;	$class = apply_filters('get_image_tag_class', $class, $id, $align, $size);	$html = '<img src="' . esc_attr($img_src) . '" alt="' . esc_attr($alt) . '" title="' . esc_attr($title).'" '.$hwstring.'class="'.$class.'" />';	$html = apply_filters( 'get_image_tag', $html, $id, $alt, $title, $align, $size );	return $html;}/** * Load an image from a string, if PHP supports it. * * @since 2.1.0 * * @param string $file Filename of the image to load. * @return resource The resulting image resource on success, Error string on failure. */function wp_load_image( $file ) {	if ( is_numeric( $file ) )		$file = get_attached_file( $file );	if ( ! file_exists( $file ) )		return sprintf(__('File &#8220;%s&#8221; doesn&#8217;t exist?'), $file);	if ( ! function_exists('imagecreatefromstring') )		return __('The GD image library is not installed.');	// Set artificially high because GD uses uncompressed images in memory	@ini_set('memory_limit', '256M');	$image = imagecreatefromstring( file_get_contents( $file ) );	if ( !is_resource( $image ) )		return sprintf(__('File &#8220;%s&#8221; is not an image.'), $file);	return $image;}/** * Calculates the new dimentions for a downsampled image. * * If either width or height are empty, no constraint is applied on * that dimension. * * @since 2.5.0 * * @param int $current_width Current width of the image. * @param int $current_height Current height of the image. * @param int $max_width Optional. Maximum wanted width. * @param int $max_height Optional. Maximum wanted height. * @return array First item is the width, the second item is the height. */function wp_constrain_dimensions( $current_width, $current_height, $max_width=0, $max_height=0 ) {	if ( !$max_width and !$max_height )		return array( $current_width, $current_height );	$width_ratio = $height_ratio = 1.0;	$did_width = $did_height = false;	if ( $max_width > 0 && $current_width > 0 && $current_width > $max_width ) {		$width_ratio = $max_width / $current_width;		$did_width = true;	}	if ( $max_height > 0 && $current_height > 0 && $current_height > $max_height ) {		$height_ratio = $max_height / $current_height;		$did_height = true;	}	// Calculate the larger/smaller ratios	$smaller_ratio = min( $width_ratio, $height_ratio );	$larger_ratio  = max( $width_ratio, $height_ratio );	if ( intval( $current_width * $larger_ratio ) > $max_width || intval( $current_height * $larger_ratio ) > $max_height ) 		// The larger ratio is too big. It would result in an overflow.		$ratio = $smaller_ratio;	else		// The larger ratio fits, and is likely to be a more "snug" fit.		$ratio = $larger_ratio;	$w = intval( $current_width  * $ratio );	$h = intval( $current_height * $ratio );	// Sometimes, due to rounding, we'll end up with a result like this: 465x700 in a 177x177 box is 117x176... a pixel short	// We also have issues with recursive calls resulting in an ever-changing result. Contraining to the result of a constraint should yield the original result.	// Thus we look for dimensions that are one pixel shy of the max value and bump them up	if ( $did_width && $w == $max_width - 1 )		$w = $max_width; // Round it up	if ( $did_height && $h == $max_height - 1 )		$h = $max_height; // Round it up	return array( $w, $h );}/** * Retrieve calculated resized dimensions for use in imagecopyresampled(). * * Calculate dimensions and coordinates for a resized image that fits within a * specified width and height. If $crop is true, the largest matching central * portion of the image will be cropped out and resized to the required size. * * @since 2.5.0 * * @param int $orig_w Original width. * @param int $orig_h Original height. * @param int $dest_w New width. * @param int $dest_h New height. * @param bool $crop Optional, default is false. Whether to crop image or resize. * @return bool|array False, on failure. Returned array matches parameters for imagecopyresampled() PHP function. */function image_resize_dimensions($orig_w, $orig_h, $dest_w, $dest_h, $crop = false) {	if ($orig_w <= 0 || $orig_h <= 0)		return false;	// at least one of dest_w or dest_h must be specific	if ($dest_w <= 0 && $dest_h <= 0)		return false;	if ( $crop ) {		// crop the largest possible portion of the original image that we can size to $dest_w x $dest_h		$aspect_ratio = $orig_w / $orig_h;		$new_w = min($dest_w, $orig_w);		$new_h = min($dest_h, $orig_h);		if ( !$new_w ) {			$new_w = intval($new_h * $aspect_ratio);		}		if ( !$new_h ) {			$new_h = intval($new_w / $aspect_ratio);		}		$size_ratio = max($new_w / $orig_w, $new_h / $orig_h);		$crop_w = round($new_w / $size_ratio);		$crop_h = round($new_h / $size_ratio);		$s_x = floor( ($orig_w - $crop_w) / 2 );		$s_y = floor( ($orig_h - $crop_h) / 2 );	} else {		// don't crop, just resize using $dest_w x $dest_h as a maximum bounding box		$crop_w = $orig_w;		$crop_h = $orig_h;		$s_x = 0;		$s_y = 0;		list( $new_w, $new_h ) = wp_constrain_dimensions( $orig_w, $orig_h, $dest_w, $dest_h );	}	// if the resulting image would be the same size or larger we don't want to resize it	if ( $new_w >= $orig_w && $new_h >= $orig_h )		return false;	// the return array matches the parameters to imagecopyresampled()	// int dst_x, int dst_y, int src_x, int src_y, int dst_w, int dst_h, int src_w, int src_h	return array( 0, 0, (int) $s_x, (int) $s_y, (int) $new_w, (int) $new_h, (int) $crop_w, (int) $crop_h );}/** * Scale down an image to fit a particular size and save a new copy of the image. * * The PNG transparency will be preserved using the function, as well as the * image type. If the file going in is PNG, then the resized image is going to * be PNG. The only supported image types are PNG, GIF, and JPEG. * * Some functionality requires API to exist, so some PHP version may lose out * support. This is not the fault of WordPress (where functionality is * downgraded, not actual defects), but of your PHP version. * * @since 2.5.0 * * @param string $file Image file path. * @param int $max_w Maximum width to resize to. * @param int $max_h Maximum height to resize to. * @param bool $crop Optional. Whether to crop image or resize. * @param string $suffix Optional. File Suffix. * @param string $dest_path Optional. New image file path. * @param int $jpeg_quality Optional, default is 90. Image quality percentage. * @return mixed WP_Error on failure. String with new destination path. */function image_resize( $file, $max_w, $max_h, $crop = false, $suffix = null, $dest_path = null, $jpeg_quality = 90 ) {	$image = wp_load_image( $file );	if ( !is_resource( $image ) )		return new WP_Error( 'error_loading_image', $image, $file );	$size = @getimagesize( $file );	if ( !$size )		return new WP_Error('invalid_image', __('Could not read image size'), $file);	list($orig_w, $orig_h, $orig_type) = $size;	$dims = image_resize_dimensions($orig_w, $orig_h, $max_w, $max_h, $crop);	if ( !$dims )		return new WP_Error( 'error_getting_dimensions', __('Could not calculate resized image dimensions') );	list($dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h) = $dims;	$newimage = wp_imagecreatetruecolor( $dst_w, $dst_h );	imagecopyresampled( $newimage, $image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h);	// convert from full colors to index colors, like original PNG.	if ( IMAGETYPE_PNG == $orig_type && function_exists('imageistruecolor') && !imageistruecolor( $image ) )		imagetruecolortopalette( $newimage, false, imagecolorstotal( $image ) );	// we don't need the original in memory anymore	imagedestroy( $image );	// $suffix will be appended to the destination filename, just before the extension	if ( !$suffix )		$suffix = "{$dst_w}x{$dst_h}";	$info = pathinfo($file);	$dir = $info['dirname'];	$ext = $info['extension'];	$name = basename($file, ".{$ext}");	if ( !is_null($dest_path) and $_dest_path = realpath($dest_path) )		$dir = $_dest_path;	$destfilename = "{$dir}/{$name}-{$suffix}.{$ext}";	if ( IMAGETYPE_GIF == $orig_type ) {		if ( !imagegif( $newimage, $destfilename ) )			return new WP_Error('resize_path_invalid', __( 'Resize path invalid' ));	} elseif ( IMAGETYPE_PNG == $orig_type ) {		if ( !imagepng( $newimage, $destfilename ) )			return new WP_Error('resize_path_invalid', __( 'Resize path invalid' ));	} else {		// all other formats are converted to jpg		$destfilename = "{$dir}/{$name}-{$suffix}.jpg";		if ( !imagejpeg( $newimage, $destfilename, apply_filters( 'jpeg_quality', $jpeg_quality, 'image_resize' ) ) )			return new WP_Error('resize_path_invalid', __( 'Resize path invalid' ));	}	imagedestroy( $newimage );	// Set correct file permissions	$stat = stat( dirname( $destfilename ));	$perms = $stat['mode'] & 0000666; //same permissions as parent folder, strip off the executable bits	@ chmod( $destfilename, $perms );	return $destfilename;}/** * Resize an image to make a thumbnail or intermediate size. * * The returned array has the file size, the image width, and image height. The * filter 'image_make_intermediate_size' can be used to hook in and change the * values of the returned array. The only parameter is the resized file path. * * @since 2.5.0 * * @param string $file File path. * @param int $width Image width. * @param int $height Image height. * @param bool $crop Optional, default is false. Whether to crop image to specified height and width or resize. * @return bool|array False, if no image was created. Metadata array on success. */function image_make_intermediate_size($file, $width, $height, $crop=false) {	if ( $width || $height ) {		$resized_file = image_resize($file, $width, $height, $crop);		if ( !is_wp_error($resized_file) && $resized_file && $info = getimagesize($resized_file) ) {			$resized_file = apply_filters('image_make_intermediate_size', $resized_file);			return array(				'file' => basename( $resized_file ),				'width' => $info[0],				'height' => $info[1],			);		}	}	return false;}/** * Retrieve the image's intermediate size (resized) path, width, and height. * * The $size parameter can be an array with the width and height respectively. * If the size matches the 'sizes' metadata array for width and height, then it * will be used. If there is no direct match, then the nearest image size larger * than the specified size will be used. If nothing is found, then the function * will break out and return false. * * The metadata 'sizes' is used for compatible sizes that can be used for the * parameter $size value. * * The url path will be given, when the $size parameter is a string. * * If you are passing an array for the $size, you should consider using * add_image_size() so that a cropped version is generated. It's much more * efficient than having to find the closest-sized image and then having the * browser scale down the image. * * @since 2.5.0 * @see add_image_size() * * @param int $post_id Attachment ID for image. * @param array|string $size Optional, default is 'thumbnail'. Size of image, either array or string. * @return bool|array False on failure or array of file path, width, and height on success. */function image_get_intermediate_size($post_id, $size='thumbnail') {	if ( !is_array( $imagedata = wp_get_attachment_metadata( $post_id ) ) )		return false;	// get the best one for a specified set of dimensions	if ( is_array($size) && !empty($imagedata['sizes']) ) {		foreach ( $imagedata['sizes'] as $_size => $data ) {			// already cropped to width or height; so use this size			if ( ( $data['width'] == $size[0] && $data['height'] <= $size[1] ) || ( $data['height'] == $size[1] && $data['width'] <= $size[0] ) ) {				$file = $data['file'];				list($width, $height) = image_constrain_size_for_editor( $data['width'], $data['height'], $size );				return compact( 'file', 'width', 'height' );			}			// add to lookup table: area => size			$areas[$data['width'] * $data['height']] = $_size;		}		if ( !$size || !empty($areas) ) {			// find for the smallest image not smaller than the desired size			ksort($areas);			foreach ( $areas as $_size ) {				$data = $imagedata['sizes'][$_size];				if ( $data['width'] >= $size[0] || $data['height'] >= $size[1] ) {					// Skip images with unexpectedly divergent aspect ratios (crops)					// First, we calculate what size the original image would be if constrained to a box the size of the current image in the loop					$maybe_cropped = image_resize_dimensions($imagedata['width'], $imagedata['height'], $data['width'], $data['height'], false );					// If the size doesn't match within one pixel, then it is of a different aspect ratio, so we skip it, unless it's the thumbnail size					if ( 'thumbnail' != $_size && ( !$maybe_cropped || ( $maybe_cropped[4] != $data['width'] && $maybe_cropped[4] + 1 != $data['width'] ) || ( $maybe_cropped[5] != $data['height'] && $maybe_cropped[5] + 1 != $data['height'] ) ) )						continue;					// If we're still here, then we're going to use this size					$file = $data['file'];					list($width, $height) = image_constrain_size_for_editor( $data['width'], $data['height'], $size );					return compact( 'file', 'width', 'height' );				}			}		}	}	if ( is_array($size) || empty($size) || empty($imagedata['sizes'][$size]) )		return false;	$data = $imagedata['sizes'][$size];	// include the full filesystem path of the intermediate file	if ( empty($data['path']) && !empty($data['file']) ) {		$file_url = wp_get_attachment_url($post_id);		$data['path'] = path_join( dirname($imagedata['file']), $data['file'] );		$data['url'] = path_join( dirname($file_url), $data['file'] );	}	return $data;}/** * Get the available image sizes * @since 3.0.0 * @return array Returns a filtered array of image size strings */function get_intermediate_image_sizes() {	global $_wp_additional_image_sizes;	$image_sizes = array('thumbnail', 'medium', 'large'); // Standard sizes	if ( isset( $_wp_additional_image_sizes ) && count( $_wp_additional_image_sizes ) )		$image_sizes = array_merge( $image_sizes, array_keys( $_wp_additional_image_sizes ) );	return apply_filters( 'intermediate_image_sizes', $image_sizes );}/** * Retrieve an image to represent an attachment. * * A mime icon for files, thumbnail or intermediate size for images. * * @since 2.5.0 * * @param int $attachment_id Image attachment ID. * @param string $size Optional, default is 'thumbnail'. * @param bool $icon Optional, default is false. Whether it is an icon. * @return bool|array Returns an array (url, width, height), or false, if no image is available. */function wp_get_attachment_image_src($attachment_id, $size='thumbnail', $icon = false) {	// get a thumbnail or intermediate image if there is one	if ( $image = image_downsize($attachment_id, $size) )		return $image;	$src = false;	if ( $icon && $src = wp_mime_type_icon($attachment_id) ) {		$icon_dir = apply_filters( 'icon_dir', ABSPATH . WPINC . '/images/crystal' );		$src_file = $icon_dir . '/' . basename($src);		@list($width, $height) = getimagesize($src_file);	}	if ( $src && $width && $height )		return array( $src, $width, $height );	return false;}/** * Get an HTML img element representing an image attachment * * While $size will accept an array, it is better to register a size with * add_image_size() so that a cropped version is generated. It's much more * efficient than having to find the closest-sized image and then having the * browser scale down the image. * * @see add_image_size() * @uses apply_filters() Calls 'wp_get_attachment_image_attributes' hook on attributes array * @uses wp_get_attachment_image_src() Gets attachment file URL and dimensions * @since 2.5.0 * * @param int $attachment_id Image attachment ID. * @param string $size Optional, default is 'thumbnail'. * @param bool $icon Optional, default is false. Whether it is an icon. * @return string HTML img element or empty string on failure. */function wp_get_attachment_image($attachment_id, $size = 'thumbnail', $icon = false, $attr = '') {	$html = '';	$image = wp_get_attachment_image_src($attachment_id, $size, $icon);	if ( $image ) {		list($src, $width, $height) = $image;		$hwstring = image_hwstring($width, $height);		if ( is_array($size) )			$size = join('x', $size);		$attachment =& get_post($attachment_id);		$default_attr = array(			'src'	=> $src,			'class'	=> "attachment-$size",			'alt'	=> trim(strip_tags( get_post_meta($attachment_id, '_wp_attachment_image_alt', true) )), // Use Alt field first			'title'	=> trim(strip_tags( $attachment->post_title )),		);		if ( empty($default_attr['alt']) )			$default_attr['alt'] = trim(strip_tags( $attachment->post_excerpt )); // If not, Use the Caption		if ( empty($default_attr['alt']) )			$default_attr['alt'] = trim(strip_tags( $attachment->post_title )); // Finally, use the title		$attr = wp_parse_args($attr, $default_attr);		$attr = apply_filters( 'wp_get_attachment_image_attributes', $attr, $attachment );		$attr = array_map( 'esc_attr', $attr );		$html = rtrim("<img $hwstring");		foreach ( $attr as $name => $value ) {			$html .= " $name=" . '"' . $value . '"';		}		$html .= ' />';	}	return $html;}/** * Adds a 'wp-post-image' class to post thumbnail thumbnails * Uses the begin_fetch_post_thumbnail_html and end_fetch_post_thumbnail_html action hooks to * dynamically add/remove itself so as to only filter post thumbnail thumbnails * * @since 2.9.0 * @param array $attr Attributes including src, class, alt, title * @return array */function _wp_post_thumbnail_class_filter( $attr ) {	$attr['class'] .= ' wp-post-image';	return $attr;}/** * Adds _wp_post_thumbnail_class_filter to the wp_get_attachment_image_attributes filter * * @since 2.9.0 */function _wp_post_thumbnail_class_filter_add( $attr ) {	add_filter( 'wp_get_attachment_image_attributes', '_wp_post_thumbnail_class_filter' );}/** * Removes _wp_post_thumbnail_class_filter from the wp_get_attachment_image_attributes filter * * @since 2.9.0 */function _wp_post_thumbnail_class_filter_remove( $attr ) {	remove_filter( 'wp_get_attachment_image_attributes', '_wp_post_thumbnail_class_filter' );}add_shortcode('wp_caption', 'img_caption_shortcode');add_shortcode('caption', 'img_caption_shortcode');/** * The Caption shortcode. * * Allows a plugin to replace the content that would otherwise be returned. The * filter is 'img_caption_shortcode' and passes an empty string, the attr * parameter and the content parameter values. * * The supported attributes for the shortcode are 'id', 'align', 'width', and * 'caption'. * * @since 2.6.0 * * @param array $attr Attributes attributed to the shortcode. * @param string $content Optional. Shortcode content. * @return string */function img_caption_shortcode($attr, $content = null) {	// Allow plugins/themes to override the default caption template.	$output = apply_filters('img_caption_shortcode', '', $attr, $content);	if ( $output != '' )		return $output;	extract(shortcode_atts(array(		'id'	=> '',		'align'	=> 'alignnone',		'width'	=> '',		'caption' => ''	), $attr));	if ( 1 > (int) $width || empty($caption) )		return $content;	if ( $id ) $id = 'id="' . esc_attr($id) . '" ';	return '<div ' . $id . 'class="wp-caption ' . esc_attr($align) . '" style="width: ' . (10 + (int) $width) . 'px">'	. do_shortcode( $content ) . '<p class="wp-caption-text">' . $caption . '</p></div>';}add_shortcode('gallery', 'gallery_shortcode');/** * The Gallery shortcode. * * This implements the functionality of the Gallery Shortcode for displaying * WordPress images on a post. * * @since 2.5.0 * * @param array $attr Attributes attributed to the shortcode. * @return string HTML content to display gallery. */function gallery_shortcode($attr) {	global $post, $wp_locale;	static $instance = 0;	$instance++;	// Allow plugins/themes to override the default gallery template.	$output = apply_filters('post_gallery', '', $attr);	if ( $output != '' )		return $output;	// We're trusting author input, so let's at least make sure it looks like a valid orderby statement	if ( isset( $attr['orderby'] ) ) {		$attr['orderby'] = sanitize_sql_orderby( $attr['orderby'] );		if ( !$attr['orderby'] )			unset( $attr['orderby'] );	}	extract(shortcode_atts(array(		'order'      => 'ASC',		'orderby'    => 'menu_order ID',		'id'         => $post->ID,		'itemtag'    => 'dl',		'icontag'    => 'dt',		'captiontag' => 'dd',		'columns'    => 3,		'size'       => 'thumbnail',		'include'    => '',		'exclude'    => ''	), $attr));	$id = intval($id);	if ( 'RAND' == $order )		$orderby = 'none';	if ( !empty($include) ) {		$include = preg_replace( '/[^0-9,]+/', '', $include );		$_attachments = get_posts( array('include' => $include, 'post_status' => 'inherit', 'post_type' => 'attachment', 'post_mime_type' => 'image', 'order' => $order, 'orderby' => $orderby) );		$attachments = array();		foreach ( $_attachments as $key => $val ) {			$attachments[$val->ID] = $_attachments[$key];		}	} elseif ( !empty($exclude) ) {		$exclude = preg_replace( '/[^0-9,]+/', '', $exclude );		$attachments = get_children( array('post_parent' => $id, 'exclude' => $exclude, 'post_status' => 'inherit', 'post_type' => 'attachment', 'post_mime_type' => 'image', 'order' => $order, 'orderby' => $orderby) );	} else {		$attachments = get_children( array('post_parent' => $id, 'post_status' => 'inherit', 'post_type' => 'attachment', 'post_mime_type' => 'image', 'order' => $order, 'orderby' => $orderby) );	}	if ( empty($attachments) )		return '';	if ( is_feed() ) {		$output = "\n";		foreach ( $attachments as $att_id => $attachment )			$output .= wp_get_attachment_link($att_id, $size, true) . "\n";		return $output;	}	$itemtag = tag_escape($itemtag);	$captiontag = tag_escape($captiontag);	$columns = intval($columns);	$itemwidth = $columns > 0 ? floor(100/$columns) : 100;	$float = is_rtl() ? 'right' : 'left';	$selector = "gallery-{$instance}";	$output = apply_filters('gallery_style', "		<style type='text/css'>			#{$selector} {				margin: auto;			}			#{$selector} .gallery-item {				float: {$float};				margin-top: 10px;				text-align: center;				width: {$itemwidth}%;			}			#{$selector} img {				border: 2px solid #cfcfcf;			}			#{$selector} .gallery-caption {				margin-left: 0;			}		</style>		<!-- see gallery_shortcode() in wp-includes/media.php -->		<div id='$selector' class='gallery galleryid-{$id}'>");	$i = 0;	foreach ( $attachments as $id => $attachment ) {		$link = isset($attr['link']) && 'file' == $attr['link'] ? wp_get_attachment_link($id, $size, false, false) : wp_get_attachment_link($id, $size, true, false);		$output .= "<{$itemtag} class='gallery-item'>";		$output .= "			<{$icontag} class='gallery-icon'>				$link			</{$icontag}>";		if ( $captiontag && trim($attachment->post_excerpt) ) {			$output .= "				<{$captiontag} class='gallery-caption'>				" . wptexturize($attachment->post_excerpt) . "				</{$captiontag}>";		}		$output .= "</{$itemtag}>";		if ( $columns > 0 && ++$i % $columns == 0 )			$output .= '<br style="clear: both" />';	}	$output .= "			<br style='clear: both;' />		</div>\n";	return $output;}/** * Display previous image link that has the same post parent. * * @since 2.5.0 * @param string $size Optional, default is 'thumbnail'. Size of image, either array or string. 0 or 'none' will default to post_title or $text; * @param string $text Optional, default is false. If included, link will reflect $text variable. * @return string HTML content. */function previous_image_link($size = 'thumbnail', $text = false) {	adjacent_image_link(true, $size, $text);}/** * Display next image link that has the same post parent. * * @since 2.5.0 * @param string $size Optional, default is 'thumbnail'. Size of image, either array or string. 0 or 'none' will default to post_title or $text; * @param string $text Optional, default is false. If included, link will reflect $text variable. * @return string HTML content. */function next_image_link($size = 'thumbnail', $text = false) {	adjacent_image_link(false, $size, $text);}/** * Display next or previous image link that has the same post parent. * * Retrieves the current attachment object from the $post global. * * @since 2.5.0 * * @param bool $prev Optional. Default is true to display previous link, true for next. */function adjacent_image_link($prev = true, $size = 'thumbnail', $text = false) {	global $post;	$post = get_post($post);	$attachments = array_values(get_children( array('post_parent' => $post->post_parent, 'post_status' => 'inherit', 'post_type' => 'attachment', 'post_mime_type' => 'image', 'order' => 'ASC', 'orderby' => 'menu_order ID') ));	foreach ( $attachments as $k => $attachment )		if ( $attachment->ID == $post->ID )			break;	$k = $prev ? $k - 1 : $k + 1;	if ( isset($attachments[$k]) )		echo wp_get_attachment_link($attachments[$k]->ID, $size, true, false, $text);}/** * Retrieve taxonomies attached to the attachment. * * @since 2.5.0 * * @param int|array|object $attachment Attachment ID, Attachment data array, or Attachment data object. * @return array Empty array on failure. List of taxonomies on success. */function get_attachment_taxonomies($attachment) {	if ( is_int( $attachment ) )		$attachment = get_post($attachment);	else if ( is_array($attachment) )		$attachment = (object) $attachment;	if ( ! is_object($attachment) )		return array();	$filename = basename($attachment->guid);	$objects = array('attachment');	if ( false !== strpos($filename, '.') )		$objects[] = 'attachment:' . substr($filename, strrpos($filename, '.') + 1);	if ( !empty($attachment->post_mime_type) ) {		$objects[] = 'attachment:' . $attachment->post_mime_type;		if ( false !== strpos($attachment->post_mime_type, '/') )			foreach ( explode('/', $attachment->post_mime_type) as $token )				if ( !empty($token) )					$objects[] = "attachment:$token";	}	$taxonomies = array();	foreach ( $objects as $object )		if ( $taxes = get_object_taxonomies($object) )			$taxonomies = array_merge($taxonomies, $taxes);	return array_unique($taxonomies);}/** * Check if the installed version of GD supports particular image type * * @since 2.9.0 * * @param $mime_type string * @return bool */function gd_edit_image_support($mime_type) {	if ( function_exists('imagetypes') ) {		switch( $mime_type ) {			case 'image/jpeg':				return (imagetypes() & IMG_JPG) != 0;			case 'image/png':				return (imagetypes() & IMG_PNG) != 0;			case 'image/gif':				return (imagetypes() & IMG_GIF) != 0;		}	} else {		switch( $mime_type ) {			case 'image/jpeg':				return function_exists('imagecreatefromjpeg');			case 'image/png':				return function_exists('imagecreatefrompng');			case 'image/gif':				return function_exists('imagecreatefromgif');		}	}	return false;}/** * Create new GD image resource with transparency support * * @since 2.9.0 * * @param $width * @param $height * @return image resource */function wp_imagecreatetruecolor($width, $height) {	$img = imagecreatetruecolor($width, $height);	if ( is_resource($img) && function_exists('imagealphablending') && function_exists('imagesavealpha') ) {		imagealphablending($img, false);		imagesavealpha($img, true);	}	return $img;}/** * API for easily embedding rich media such as videos and images into content. * * @package WordPress * @subpackage Embed * @since 2.9.0 */class WP_Embed {	var $handlers = array();	var $post_ID;	var $usecache = true;	var $linkifunknown = true;	/**	 * PHP4 constructor	 */	function WP_Embed() {		return $this->__construct();	}	/**	 * PHP5 constructor	 */	function __construct() {		// Hack to get the [embed] shortcode to run before wpautop()		add_filter( 'the_content', array(&$this, 'run_shortcode'), 8 );		// Shortcode placeholder for strip_shortcodes()		add_shortcode( 'embed', '__return_false' );		// Attempts to embed all URLs in a post		if ( get_option('embed_autourls') )			add_filter( 'the_content', array(&$this, 'autoembed'), 8 );		// After a post is saved, invalidate the oEmbed cache		add_action( 'save_post', array(&$this, 'delete_oembed_caches') );		// After a post is saved, cache oEmbed items via AJAX		add_action( 'edit_form_advanced', array(&$this, 'maybe_run_ajax_cache') );	}	/**	 * Process the [embed] shortcode.	 *	 * Since the [embed] shortcode needs to be run earlier than other shortcodes,	 * this function removes all existing shortcodes, registers the [embed] shortcode,	 * calls {@link do_shortcode()}, and then re-registers the old shortcodes.	 *	 * @uses $shortcode_tags	 * @uses remove_all_shortcodes()	 * @uses add_shortcode()	 * @uses do_shortcode()	 *	 * @param string $content Content to parse	 * @return string Content with shortcode parsed	 */	function run_shortcode( $content ) {		global $shortcode_tags;		// Backup current registered shortcodes and clear them all out		$orig_shortcode_tags = $shortcode_tags;		remove_all_shortcodes();		add_shortcode( 'embed', array(&$this, 'shortcode') );		// Do the shortcode (only the [embed] one is registered)		$content = do_shortcode( $content );		// Put the original shortcodes back		$shortcode_tags = $orig_shortcode_tags;		return $content;	}	/**	 * If a post/page was saved, then output Javascript to make	 * an AJAX request that will call WP_Embed::cache_oembed().	 */	function maybe_run_ajax_cache() {		global $post_ID;		if ( empty($post_ID) || empty($_GET['message']) || 1 != $_GET['message'] )			return;?><script type="text/javascript">/* <![CDATA[ */	jQuery(document).ready(function($){		$.get("<?php echo admin_url( 'admin-ajax.php?action=oembed-cache&post=' . $post_ID ); ?>");	});/* ]]> */</script><?php	}	/**	 * Register an embed handler. Do not use this function directly, use {@link wp_embed_register_handler()} instead.	 * This function should probably also only be used for sites that do not support oEmbed.	 *	 * @param string $id An internal ID/name for the handler. Needs to be unique.	 * @param string $regex The regex that will be used to see if this handler should be used for a URL.	 * @param callback $callback The callback function that will be called if the regex is matched.	 * @param int $priority Optional. Used to specify the order in which the registered handlers will be tested (default: 10). Lower numbers correspond with earlier testing, and handlers with the same priority are tested in the order in which they were added to the action.	 */	function register_handler( $id, $regex, $callback, $priority = 10 ) {		$this->handlers[$priority][$id] = array(			'regex'    => $regex,			'callback' => $callback,		);	}	/**	 * Unregister a previously registered embed handler. Do not use this function directly, use {@link wp_embed_unregister_handler()} instead.	 *	 * @param string $id The handler ID that should be removed.	 * @param int $priority Optional. The priority of the handler to be removed (default: 10).	 */	function unregister_handler( $id, $priority = 10 ) {		if ( isset($this->handlers[$priority][$id]) )			unset($this->handlers[$priority][$id]);	}	/**	 * The {@link do_shortcode()} callback function.	 *	 * Attempts to convert a URL into embed HTML. Starts by checking the URL against the regex of the registered embed handlers.	 * If none of the regex matches and it's enabled, then the URL will be given to the {@link WP_oEmbed} class.	 *	 * @uses wp_oembed_get()	 * @uses wp_parse_args()	 * @uses wp_embed_defaults()	 * @uses WP_Embed::maybe_make_link()	 * @uses get_option()	 * @uses current_user_can()	 * @uses wp_cache_get()	 * @uses wp_cache_set()	 * @uses get_post_meta()	 * @uses update_post_meta()	 *	 * @param array $attr Shortcode attributes.	 * @param string $url The URL attempting to be embeded.	 * @return string The embed HTML on success, otherwise the original URL.	 */	function shortcode( $attr, $url = '' ) {		global $post;		if ( empty($url) )			return '';		$rawattr = $attr;		$attr = wp_parse_args( $attr, wp_embed_defaults() );		// Look for known internal handlers		ksort( $this->handlers );		foreach ( $this->handlers as $priority => $handlers ) {			foreach ( $handlers as $id => $handler ) {				if ( preg_match( $handler['regex'], $url, $matches ) && is_callable( $handler['callback'] ) ) {					if ( false !== $return = call_user_func( $handler['callback'], $matches, $attr, $url, $rawattr ) )						return apply_filters( 'embed_handler_html', $return, $url, $attr );				}			}		}		$post_ID = ( !empty($post->ID) ) ? $post->ID : null;		if ( !empty($this->post_ID) ) // Potentially set by WP_Embed::cache_oembed()			$post_ID = $this->post_ID;		// Unknown URL format. Let oEmbed have a go.		if ( $post_ID ) {			// Check for a cached result (stored in the post meta)			$cachekey = '_oembed_' . md5( $url . serialize( $attr ) );			if ( $this->usecache ) {				$cache = get_post_meta( $post_ID, $cachekey, true );				// Failures are cached				if ( '{{unknown}}' === $cache )					return $this->maybe_make_link( $url );				if ( !empty($cache) )					return apply_filters( 'embed_oembed_html', $cache, $url, $attr );			}			// Use oEmbed to get the HTML			$attr['discover'] = ( apply_filters('embed_oembed_discover', false) && author_can( $post_ID, 'unfiltered_html' ) );			$html = wp_oembed_get( $url, $attr );			// Cache the result			$cache = ( $html ) ? $html : '{{unknown}}';			update_post_meta( $post_ID, $cachekey, $cache );			// If there was a result, return it			if ( $html )				return apply_filters( 'embed_oembed_html', $html, $url, $attr );		}		// Still unknown		return $this->maybe_make_link( $url );	}	/**	 * Delete all oEmbed caches.	 *	 * @param int $post_ID Post ID to delete the caches for.	 */	function delete_oembed_caches( $post_ID ) {		$post_metas = get_post_custom_keys( $post_ID );		if ( empty($post_metas) )			return;		foreach( $post_metas as $post_meta_key ) {			if ( '_oembed_' == substr( $post_meta_key, 0, 8 ) )				delete_post_meta( $post_ID, $post_meta_key );		}	}	/**	 * Triggers a caching of all oEmbed results.	 *	 * @param int $post_ID Post ID to do the caching for.	 */	function cache_oembed( $post_ID ) {		$post = get_post( $post_ID );		if ( empty($post->ID) || !in_array( $post->post_type, apply_filters( 'embed_cache_oembed_types', array( 'post', 'page' ) ) ) )			return;		// Trigger a caching		if ( !empty($post->post_content) ) {			$this->post_ID = $post->ID;			$this->usecache = false;			$content = $this->run_shortcode( $post->post_content );			if ( get_option('embed_autourls') )				$this->autoembed( $content );			$this->usecache = true;		}	}	/**	 * Passes any unlinked URLs that are on their own line to {@link WP_Embed::shortcode()} for potential embedding.	 *	 * @uses WP_Embed::autoembed_callback()	 *	 * @param string $content The content to be searched.	 * @return string Potentially modified $content.	 */	function autoembed( $content ) {		return preg_replace_callback( '|^\s*(https?://[^\s"]+)\s*$|im', array(&$this, 'autoembed_callback'), $content );	}	/**	 * Callback function for {@link WP_Embed::autoembed()}.	 *	 * @uses WP_Embed::shortcode()	 *	 * @param array $match A regex match array.	 * @return string The embed HTML on success, otherwise the original URL.	 */	function autoembed_callback( $match ) {		$oldval = $this->linkifunknown;		$this->linkifunknown = false;		$return = $this->shortcode( array(), $match[1] );		$this->linkifunknown = $oldval;		return "\n$return\n";	}	/**	 * Conditionally makes a hyperlink based on an internal class variable.	 *	 * @param string $url URL to potentially be linked.	 * @return string Linked URL or the original URL.	 */	function maybe_make_link( $url ) {		$output = ( $this->linkifunknown ) ? '<a href="' . esc_attr($url) . '">' . esc_html($url) . '</a>' : $url;		return apply_filters( 'embed_maybe_make_link', $output, $url );	}}$wp_embed = new WP_Embed();/** * Register an embed handler. This function should probably only be used for sites that do not support oEmbed. * * @since 2.9.0 * @see WP_Embed::register_handler() */function wp_embed_register_handler( $id, $regex, $callback, $priority = 10 ) {	global $wp_embed;	$wp_embed->register_handler( $id, $regex, $callback, $priority );}/** * Unregister a previously registered embed handler. * * @since 2.9.0 * @see WP_Embed::unregister_handler() */function wp_embed_unregister_handler( $id, $priority = 10 ) {	global $wp_embed;	$wp_embed->unregister_handler( $id, $priority );}/** * Create default array of embed parameters. * * @since 2.9.0 * * @return array Default embed parameters. */function wp_embed_defaults() {	if ( !empty($GLOBALS['content_width']) )		$theme_width = (int) $GLOBALS['content_width'];	$width = get_option('embed_size_w');	if ( empty($width) && !empty($theme_width) )		$width = $theme_width;	if ( empty($width) )		$width = 500;	$height = get_option('embed_size_h');	if ( empty($height) )		$height = 700;	return apply_filters( 'embed_defaults', array(		'width'  => $width,		'height' => $height,	) );}/** * Based on a supplied width/height example, return the biggest possible dimensions based on the max width/height. * * @since 2.9.0 * @uses wp_constrain_dimensions() This function passes the widths and the heights. * * @param int $example_width The width of an example embed. * @param int $example_height The height of an example embed. * @param int $max_width The maximum allowed width. * @param int $max_height The maximum allowed height. * @return array The maximum possible width and height based on the example ratio. */function wp_expand_dimensions( $example_width, $example_height, $max_width, $max_height ) {	$example_width  = (int) $example_width;	$example_height = (int) $example_height;	$max_width      = (int) $max_width;	$max_height     = (int) $max_height;	return wp_constrain_dimensions( $example_width * 1000000, $example_height * 1000000, $max_width, $max_height );}/** * Attempts to fetch the embed HTML for a provided URL using oEmbed. * * @since 2.9.0 * @see WP_oEmbed * * @uses _wp_oembed_get_object() * @uses WP_oEmbed::get_html() * * @param string $url The URL that should be embeded. * @param array $args Addtional arguments and parameters. * @return string The original URL on failure or the embed HTML on success. */function wp_oembed_get( $url, $args = '' ) {	require_once( ABSPATH . WPINC . '/class-oembed.php' );	$oembed = _wp_oembed_get_object();	return $oembed->get_html( $url, $args );}/** * Adds a URL format and oEmbed provider URL pair. * * @since 2.9.0 * @see WP_oEmbed * * @uses _wp_oembed_get_object() * * @param string $format The format of URL that this provider can handle. You can use asterisks as wildcards. * @param string $provider The URL to the oEmbed provider. * @param boolean $regex Whether the $format parameter is in a regex format. */function wp_oembed_add_provider( $format, $provider, $regex = false ) {	require_once( ABSPATH . WPINC . '/class-oembed.php' );	$oembed = _wp_oembed_get_object();	$oembed->providers[$format] = array( $provider, $regex );}
<?php/** * WordPress Administration Template Footer * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');?><div class="clear"></div></div><!-- wpbody-content --><div class="clear"></div></div><!-- wpbody --><div class="clear"></div></div><!-- wpcontent --></div><!-- wpwrap --><div id="footer"><p id="footer-left" class="alignleft"><?phpdo_action( 'in_admin_footer' );$upgrade = apply_filters( 'update_footer', '' );echo apply_filters( 'admin_footer_text', '<span id="footer-thankyou">' . __('Thank you for creating with <a href="http://wordpress.org/">WordPress</a>.').'</span> | '.__('<a href="http://codex.wordpress.org/">Documentation</a>').' | '.__('<a href="http://wordpress.org/support/forum/4">Feedback</a>') ); ?></p><p id="footer-upgrade" class="alignright"><?php echo $upgrade; ?></p><div class="clear"></div></div><?phpdo_action('admin_footer', '');do_action('admin_print_footer_scripts');do_action("admin_footer-" . $GLOBALS['hook_suffix']);// get_site_option() won't exist when auto upgrading from <= 2.7if ( function_exists('get_site_option') ) {	if ( false === get_site_option('can_compress_scripts') )		compression_test();}?><script type="text/javascript">if(typeof wpOnload=='function')wpOnload();</script></body></html>
<?php/** * Template Name: One column, no sidebar * * A custom page template without sidebar. * * The "Template Name:" bit above allows this to be selectable * from a dropdown menu on the edit page screen. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */get_header(); ?>		<div id="container" class="one-column">			<div id="content" role="main"><?php if ( have_posts() ) while ( have_posts() ) : the_post(); ?>				<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>					<h1 class="entry-title"><?php the_title(); ?></h1>					<div class="entry-content">						<?php the_content(); ?>						<?php wp_link_pages( array( 'before' => '<div class="page-link">' . __( 'Pages:', 'twentyten' ), 'after' => '</div>' ) ); ?>						<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="edit-link">', '</span>' ); ?>					</div><!-- .entry-content -->				</div><!-- #post-## -->				<?php comments_template( '', true ); ?><?php endwhile; ?>			</div><!-- #content -->		</div><!-- #container --><?php get_footer(); ?>
<?php/** * Dashboard Administration Panel * * @package WordPress * @subpackage Administration *//** Load WordPress Bootstrap */require_once('./admin.php');/** Load WordPress dashboard API */require_once(ABSPATH . 'wp-admin/includes/dashboard.php');wp_dashboard_setup();wp_enqueue_script( 'dashboard' );wp_enqueue_script( 'plugin-install' );wp_enqueue_script( 'media-upload' );wp_admin_css( 'dashboard' );wp_admin_css( 'plugin-install' );add_thickbox();$title = __('Dashboard');$parent_file = 'index.php';add_contextual_help($current_screen,	'<p>' . __('Welcome to your WordPress Dashboard! You will find helpful tips in the Help tab of each screen to assist you as you get to know the application.') . '</p>' .	'<p>' . __('The left-hand navigation menu provides links to the administration screens in your WordPress application. You can expand or collapse navigation sections by clicking on the arrow that appears on the right side of each navigation item when you hover over it. You can also minimize the navigation menu to a narrow icon strip by clicking on the separator lines between navigation sections that end in double arrowheads; when minimized, the submenu items will be displayed on hover.') . '</p>' .	'<p>' . __('You can configure your dashboard by choosing which modules to display, how many columns to display them in, and where each module should be placed. You can hide/show modules and select the number of columns in the Screen Options tab. To rearrange the modules, drag and drop by clicking on the title bar of the selected module and releasing when you see a gray dotted-line box appear in the location you want to place the module. You can also expand or collapse each module by clicking once on the the module&#8217;s title bar. In addition, some modules are configurable, and will show a &#8220;Configure&#8221; link in the title bar when you hover over it.') . '</p>' .	'<p>' . __('The modules on your Dashboard screen are:') . '</p>' .	'<p>' . __('<strong>Right Now</strong> - Displays a summary of the content on your site and identifies which theme and version of WordPress you are using.') . '</p>' .	'<p>' . __('<strong>Recent Comments</strong> - Shows the most recent comments on your posts (configurable, up to 30) and allows you to moderate them.') . '</p>' .	'<p>' . __('<strong>Incoming Links</strong> - Shows links to your site found by Google Blog Search.') . '</p>' .	'<p>' . __('<strong>QuickPress</strong> - Allows you to create a new post and either publish it or save it as a draft.') . '</p>' .	'<p>' . __('<strong>Recent Drafts</strong> - Displays links to the 5 most recent draft posts you&#8217;ve started.') . '</p>' .	'<p>' . __('<strong>Other WordPress News</strong> - Shows the feed from <a href="http://planet.wordpress.org" target="_blank">WordPress Planet</a>. You can configure it to show a different feed of your choosing.') . '</p>' .	'<p>' . __('<strong>Plugins</strong> - Features the most popular, newest, and recently updated plugins from the WordPress.org Plugin Directory.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Dashboard_SubPanel" target="_blank">Dashboard Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once('./admin-header.php');$today = current_time('mysql', 1);?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><div id="dashboard-widgets-wrap"><?php wp_dashboard(); ?><div class="clear"></div></div><!-- dashboard-widgets-wrap --></div><!-- wrap --><?php require(ABSPATH . 'wp-admin/admin-footer.php'); ?>
<?phpif ( !defined( 'ABSPATH' ) )	exit;/** @ignore */function dvortr( $str ) {	return strtr(		$str,		'\',.pyfgcrl/=\\aoeuidhtns-;qjkxbmwvz"<>PYFGCRL?+|AOEUIDHTNS_:QJKXBMWVZ[]',		'qwertyuiop[]\\asdfghjkl;\'zxcvbnm,./QWERTYUIOP{}|ASDFGHJKL:"ZXCVBNM<>?-='	);}$j = esc_url( site_url( '/wp-includes/js/jquery/jquery.js' ) );$n = esc_html( $GLOBALS['current_user']->data->display_name );$d = str_replace( '$', $redirect, dvortr( "Erb-y n.y ydco dall.b aiacbv Wa ce]-irxajt- dp.u]-$-VIr XajtWzaVv" ) );wp_die( <<<EOEE<style type="text/css">html body { font-family: courier, monospace; }#hal { text-decoration: blink; }</style><script type="text/javascript" src="$j"></script><script type="text/javascript">/* <![CDATA[ */var n = '$n';eval(function(p,a,c,k,e,r){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}('6(4(){2 e=6(\\'#Q\\').v();2 i=\\'\\\\\\',.R/=\\\\\\\\S-;T"<>U?+|V:W[]X{}\\'.u(\\'\\');2 o=\\'Y[]\\\\\\\\Z;\\\\\\'10,./11{}|12:"13<>?-=14+\\'.u(\\'\\');2 5=4(s){r=\\'\\';6.15(s.u(\\'\\'),4(){2 t=16.D();2 c=6.17(t,i);r+=\\'\$\\'==t?n:(-1==c?t:o[c])});j r};2 a=[\\'O.E[18 e.y.19.1a\\',\\'1b 1c. 1d .1e.,1f 1g\\',\\'O.E e.1h 1i 8\\',\\'9\\',\\'0\\'];2 b=[\\'<1j. 1k \$1l\\',\\'1m. 1n 1o 1p\\',\\'1q, 1r. ,1s. 1t\\'];2 w=[];2 h=6(5(\\'#1u\\'));6(5(\\'1v\\')).1w(4(e){7(1x!==e.1y){j}7(x&&x.F){x.F();j G}1z.1A=6(5(\\'#1B\\')).1C(\\'1D\\');j G});2 k=4(){2 l=a.H();7(\\'I\\'==J l){7(m){2 c={};c[5(\\'1E\\')]=5(\\'1F\\');c[5(\\'1G\\')]=5(\\'1H..b\\');6(5(\\'1I 1J\\')).1K(c);p();h.v().1L({1M:1},z,\\'1N\\',4(){h.K()});d(m,L)}j}w=5(l).u(\\'\\');A()};2 A=4(){B=w.H();7(\\'I\\'==J B){7(m){h.M(5(\\'1O 1P\\'));d(k,C)}N{7(a.P){d(p,C);d(k,z)}N{d(4(){p();h.v()},C);d(4(){e.K()},L)}}j}h.M(B.D());d(A,1Q)};2 m=4(){a=b;m=1R;k()};p=4(){2 f=6(\\'p\\').1S(0);2 g=6.1T(f.q).1U();1V(2 g=f.q.P;g>0;g--){7(3==f.q[g-1].1W||\\'1X\\'==f.q[g-1].1Y.1Z()){f.20(f.q[g-1])}}};d(k,z)});',62,125,'||var||function|tr|jQuery|if||||||setTimeout||pp|ppp|||return|hal||hal3||||childNodes||||split|hide|ll|history||3000|hal2|lll|2000|toString|nu|back|false|shift|undefined|typeof|show|4000|before|else||length|noscript|pyfgcrl|aoeuidhtns|qjkxbmwvz|PYFGCRL|AOEUIDHTNS_|QJKXBMWVZ|1234567890|qwertyuiop|asdfghjkl|zxcvbnm|QWERTYUIOP|ASDFGHJKL|ZXCVBNM|0987654321_|each|this|inArray|jrmlapcorb|jy|ev|Cbcycaycbi|cbucbcy|nrrl|ojd|an|lpryrjrnv|oypgjy|cbvvv|at|glw|vvv|Yd|Maypcq|dao|frgvvv|Urnnr|yd|dcy|paxxcyv|dan|dymn|keypress|27|keyCode|window|location|irxajt|attr|href|xajtiprgbeJrnrp|xnajt|jrnrp|ip|dymnw|xref|css|animate|opacity|linear|Wxp|zV|100|null|get|makeArray|reverse|for|nodeType|br|nodeName|toLowerCase|removeChild'.split('|'),0,{}))/* ]]> */</script><span id="noscript">$d</span><blink id="hal">&#x258c;</blink>EOEE,dvortr( 'Eabi.p!' ));
<?php/** * The template for displaying Comments. * * The area of the page that contains both current comments * and the comment form.  The actual display of comments is * handled by a callback to twentyten_comment which is * located in the functions.php file. * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */?>			<div id="comments"><?php if ( post_password_required() ) : ?>				<p class="nopassword"><?php _e( 'This post is password protected. Enter the password to view any comments.', 'twentyten' ); ?></p>			</div><!-- #comments --><?php		/* Stop the rest of comments.php from being processed,		 * but don't kill the script entirely -- we still have		 * to fully load the template.		 */		return;	endif;?><?php	// You can start editing here -- including this comment!?><?php if ( have_comments() ) : ?>			<h3 id="comments-title"><?php			printf( _n( 'One Response to %2$s', '%1$s Responses to %2$s', get_comments_number(), 'twentyten' ),			number_format_i18n( get_comments_number() ), '<em>' . get_the_title() . '</em>' );			?></h3><?php if ( get_comment_pages_count() > 1 && get_option( 'page_comments' ) ) : // Are there comments to navigate through? ?>			<div class="navigation">				<div class="nav-previous"><?php previous_comments_link( __( '<span class="meta-nav">&larr;</span> Older Comments', 'twentyten' ) ); ?></div>				<div class="nav-next"><?php next_comments_link( __( 'Newer Comments <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?></div>			</div> <!-- .navigation --><?php endif; // check for comment navigation ?>			<ol class="commentlist">				<?php					/* Loop through and list the comments. Tell wp_list_comments()					 * to use twentyten_comment() to format the comments.					 * If you want to overload this in a child theme then you can					 * define twentyten_comment() and that will be used instead.					 * See twentyten_comment() in twentyten/functions.php for more.					 */					wp_list_comments( array( 'callback' => 'twentyten_comment' ) );				?>			</ol><?php if ( get_comment_pages_count() > 1 && get_option( 'page_comments' ) ) : // Are there comments to navigate through? ?>			<div class="navigation">				<div class="nav-previous"><?php previous_comments_link( __( '<span class="meta-nav">&larr;</span> Older Comments', 'twentyten' ) ); ?></div>				<div class="nav-next"><?php next_comments_link( __( 'Newer Comments <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?></div>			</div><!-- .navigation --><?php endif; // check for comment navigation ?><?php else : // or, if we don't have comments:	/* If there are no comments and comments are closed,	 * let's leave a little note, shall we?	 */	if ( ! comments_open() ) :?>	<p class="nocomments"><?php _e( 'Comments are closed.', 'twentyten' ); ?></p><?php endif; // end ! comments_open() ?><?php endif; // end have_comments() ?><?php comment_form(); ?></div><!-- #comments -->
<?php/** * Deprecated multisite admin functions from past WordPress versions and WordPress MU. * You shouldn't use these functions and look for the alternatives instead. The functions * will be removed in a later version. * * @package WordPress * @subpackage Deprecated * @since 3.0.0 *//** * @deprecated 3.0.0 */function wpmu_menu() {	_deprecated_function(__FUNCTION__, '3.0' );	// deprecated. See #11763}/**  * Determines if the available space defined by the admin has been exceeded by the user.  *  * @deprecated 3.0.0  * @see is_upload_space_available() */function wpmu_checkAvailableSpace() {	_deprecated_function(__FUNCTION__, '3.0', 'is_upload_space_available()' );	if ( !is_upload_space_available() )		wp_die( __('Sorry, you must delete files before you can upload any more.') );}/** * @deprecated 3.0.0 */function mu_options( $options ) {	_deprecated_function(__FUNCTION__, '3.0' );	return $options;}/** * @deprecated 3.0.0 * @see activate_plugin() */function activate_sitewide_plugin() {	_deprecated_function(__FUNCTION__, '3.0', 'activate_plugin()' );	return false;}/** * @deprecated 3.0.0 * @see deactivate_sitewide_plugin() */function deactivate_sitewide_plugin( $plugin = false ) {	_deprecated_function(__FUNCTION__, '3.0', 'deactivate_plugin()' );	return;}/** * @deprecated 3.0.0 * @see is_network_only_plugin() */function is_wpmu_sitewide_plugin( $file ) {	_deprecated_function(__FUNCTION__, '3.0', 'is_network_only_plugin()' );	return is_network_only_plugin( $file );}?>
