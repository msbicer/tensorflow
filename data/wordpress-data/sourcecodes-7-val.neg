<?php/** * A File upgrader class for WordPress. * * This set of classes are designed to be used to upgrade/install a local set of files on the filesystem via the Filesystem Abstraction classes. * * @link http://trac.wordpress.org/ticket/7875 consolidate plugin/theme/core upgrade/install functions * * @package WordPress * @subpackage Upgrader * @since 2.8.0 *//** * WordPress Upgrader class for Upgrading/Installing a local set of files via the Filesystem Abstraction classes from a Zip file. * * @TODO More Detailed docs, for methods as well. * * @package WordPress * @subpackage Upgrader * @since 2.8.0 */class WP_Upgrader {	var $strings = array();	var $skin = null;	var $result = array();	function WP_Upgrader($skin = null) {		return $this->__construct($skin);	}	function __construct($skin = null) {		if ( null == $skin )			$this->skin = new WP_Upgrader_Skin();		else			$this->skin = $skin;	}	function init() {		$this->skin->set_upgrader($this);		$this->generic_strings();	}	function generic_strings() {		$this->strings['bad_request'] = __('Invalid Data provided.');		$this->strings['fs_unavailable'] = __('Could not access filesystem.');		$this->strings['fs_error'] = __('Filesystem error.');		$this->strings['fs_no_root_dir'] = __('Unable to locate WordPress Root directory.');		$this->strings['fs_no_content_dir'] = __('Unable to locate WordPress Content directory (wp-content).');		$this->strings['fs_no_plugins_dir'] = __('Unable to locate WordPress Plugin directory.');		$this->strings['fs_no_themes_dir'] = __('Unable to locate WordPress Theme directory.');		/* translators: %s: directory name */		$this->strings['fs_no_folder'] = __('Unable to locate needed folder (%s).');		$this->strings['download_failed'] = __('Download failed.');		$this->strings['installing_package'] = __('Installing the latest version&#8230;');		$this->strings['folder_exists'] = __('Destination folder already exists.');		$this->strings['mkdir_failed'] = __('Could not create directory.');		$this->strings['bad_package'] = __('Incompatible Archive.');		$this->strings['maintenance_start'] = __('Enabling Maintenance mode&#8230;');		$this->strings['maintenance_end'] = __('Disabling Maintenance mode&#8230;');	}	function fs_connect( $directories = array() ) {		global $wp_filesystem;		if ( false === ($credentials = $this->skin->request_filesystem_credentials()) )			return false;		if ( ! WP_Filesystem($credentials) ) {			$error = true;			if ( is_object($wp_filesystem) && $wp_filesystem->errors->get_error_code() )				$error = $wp_filesystem->errors;			$this->skin->request_filesystem_credentials($error); //Failed to connect, Error and request again			return false;		}		if ( ! is_object($wp_filesystem) )			return new WP_Error('fs_unavailable', $this->strings['fs_unavailable'] );		if ( is_wp_error($wp_filesystem->errors) && $wp_filesystem->errors->get_error_code() )			return new WP_Error('fs_error', $this->strings['fs_error'], $wp_filesystem->errors);		foreach ( (array)$directories as $dir ) {			switch ( $dir ) {				case ABSPATH:					if ( ! $wp_filesystem->abspath() )						return new WP_Error('fs_no_root_dir', $this->strings['fs_no_root_dir']);					break;				case WP_CONTENT_DIR:					if ( ! $wp_filesystem->wp_content_dir() )						return new WP_Error('fs_no_content_dir', $this->strings['fs_no_content_dir']);					break;				case WP_PLUGIN_DIR:					if ( ! $wp_filesystem->wp_plugins_dir() )						return new WP_Error('fs_no_plugins_dir', $this->strings['fs_no_plugins_dir']);					break;				case WP_CONTENT_DIR . '/themes':					if ( ! $wp_filesystem->find_folder(WP_CONTENT_DIR . '/themes') )						return new WP_Error('fs_no_themes_dir', $this->strings['fs_no_themes_dir']);					break;				default:					if ( ! $wp_filesystem->find_folder($dir) )						return new WP_Error('fs_no_folder', sprintf($this->strings['fs_no_folder'], $dir));					break;			}		}		return true;	} //end fs_connect();	function download_package($package) {		if ( ! preg_match('!^(http|https|ftp)://!i', $package) && file_exists($package) ) //Local file or remote?			return $package; //must be a local file..		if ( empty($package) )			return new WP_Error('no_package', $this->strings['no_package']);		$this->skin->feedback('downloading_package', $package);		$download_file = download_url($package);		if ( is_wp_error($download_file) )			return new WP_Error('download_failed', $this->strings['download_failed'], $download_file->get_error_message());		return $download_file;	}	function unpack_package($package, $delete_package = true) {		global $wp_filesystem;		$this->skin->feedback('unpack_package');		$upgrade_folder = $wp_filesystem->wp_content_dir() . 'upgrade/';		//Clean up contents of upgrade directory beforehand.		$upgrade_files = $wp_filesystem->dirlist($upgrade_folder);		if ( !empty($upgrade_files) ) {			foreach ( $upgrade_files as $file )				$wp_filesystem->delete($upgrade_folder . $file['name'], true);		}		//We need a working directory		$working_dir = $upgrade_folder . basename($package, '.zip');		// Clean up working directory		if ( $wp_filesystem->is_dir($working_dir) )			$wp_filesystem->delete($working_dir, true);		// Unzip package to working directory		$result = unzip_file($package, $working_dir); //TODO optimizations, Copy when Move/Rename would suffice?		// Once extracted, delete the package if required.		if ( $delete_package )			unlink($package);		if ( is_wp_error($result) ) {			$wp_filesystem->delete($working_dir, true);			return $result;		}		return $working_dir;	}	function install_package($args = array()) {		global $wp_filesystem;		$defaults = array( 'source' => '', 'destination' => '', //Please always pass these						'clear_destination' => false, 'clear_working' => false,						'hook_extra' => array());		$args = wp_parse_args($args, $defaults);		extract($args);		@set_time_limit( 300 );		if ( empty($source) || empty($destination) )			return new WP_Error('bad_request', $this->strings['bad_request']);		$this->skin->feedback('installing_package');		$res = apply_filters('upgrader_pre_install', true, $hook_extra);		if ( is_wp_error($res) )			return $res;		//Retain the Original source and destinations		$remote_source = $source;		$local_destination = $destination;		$source_files = array_keys( $wp_filesystem->dirlist($remote_source) );		$remote_destination = $wp_filesystem->find_folder($local_destination);		//Locate which directory to copy to the new folder, This is based on the actual folder holding the files.		if ( 1 == count($source_files) && $wp_filesystem->is_dir( trailingslashit($source) . $source_files[0] . '/') ) //Only one folder? Then we want its contents.			$source = trailingslashit($source) . trailingslashit($source_files[0]);		elseif ( count($source_files) == 0 )			return new WP_Error('bad_package', $this->strings['bad_package']); //There are no files?		//else //Its only a single file, The upgrader will use the foldername of this file as the destination folder. foldername is based on zip filename.		//Hook ability to change the source file location..		$source = apply_filters('upgrader_source_selection', $source, $remote_source, $this);		if ( is_wp_error($source) )			return $source;		//Has the source location changed? If so, we need a new source_files list.		if ( $source !== $remote_source )			$source_files = array_keys( $wp_filesystem->dirlist($source) );		//Protection against deleting files in any important base directories.		if ( in_array( $destination, array(ABSPATH, WP_CONTENT_DIR, WP_PLUGIN_DIR, WP_CONTENT_DIR . '/themes') ) ) {			$remote_destination = trailingslashit($remote_destination) . trailingslashit(basename($source));			$destination = trailingslashit($destination) . trailingslashit(basename($source));		}		if ( $wp_filesystem->exists($remote_destination) ) {			if ( $clear_destination ) {				//We're going to clear the destination if theres something there				$this->skin->feedback('remove_old');				$removed = $wp_filesystem->delete($remote_destination, true);				$removed = apply_filters('upgrader_clear_destination', $removed, $local_destination, $remote_destination, $hook_extra);				if ( is_wp_error($removed) )					return $removed;				else if ( ! $removed )					return new WP_Error('remove_old_failed', $this->strings['remove_old_failed']);			} else {				//If we're not clearing the destination folder and something exists there allready, Bail.				//But first check to see if there are actually any files in the folder.				$_files = $wp_filesystem->dirlist($remote_destination);				if ( ! empty($_files) ) {					$wp_filesystem->delete($remote_source, true); //Clear out the source files.					return new WP_Error('folder_exists', $this->strings['folder_exists'], $remote_destination );				}			}		}		//Create destination if needed		if ( !$wp_filesystem->exists($remote_destination) )			if ( !$wp_filesystem->mkdir($remote_destination, FS_CHMOD_DIR) )				return new WP_Error('mkdir_failed', $this->strings['mkdir_failed'], $remote_destination);		// Copy new version of item into place.		$result = copy_dir($source, $remote_destination);		if ( is_wp_error($result) ) {			if ( $clear_working )				$wp_filesystem->delete($remote_source, true);			return $result;		}		//Clear the Working folder?		if ( $clear_working )			$wp_filesystem->delete($remote_source, true);		$destination_name = basename( str_replace($local_destination, '', $destination) );		if ( '.' == $destination_name )			$destination_name = '';		$this->result = compact('local_source', 'source', 'source_name', 'source_files', 'destination', 'destination_name', 'local_destination', 'remote_destination', 'clear_destination', 'delete_source_dir');		$res = apply_filters('upgrader_post_install', true, $hook_extra, $this->result);		if ( is_wp_error($res) ) {			$this->result = $res;			return $res;		}		//Bombard the calling function will all the info which we've just used.		return $this->result;	}	function run($options) {		$defaults = array( 	'package' => '', //Please always pass this.							'destination' => '', //And this							'clear_destination' => false,							'clear_working' => true,							'is_multi' => false,							'hook_extra' => array() //Pass any extra $hook_extra args here, this will be passed to any hooked filters.						);		$options = wp_parse_args($options, $defaults);		extract($options);		//Connect to the Filesystem first.		$res = $this->fs_connect( array(WP_CONTENT_DIR, $destination) );		if ( ! $res ) //Mainly for non-connected filesystem.			return false;		if ( is_wp_error($res) ) {			$this->skin->error($res);			return $res;		}		if ( !$is_multi ) // call $this->header separately if running multiple times			$this->skin->header();		$this->skin->before();		//Download the package (Note, This just returns the filename of the file if the package is a local file)		$download = $this->download_package( $package );		if ( is_wp_error($download) ) {			$this->skin->error($download);			$this->skin->after();			return $download;		}		//Unzip's the file into a temporary directory		$working_dir = $this->unpack_package( $download );		if ( is_wp_error($working_dir) ) {			$this->skin->error($working_dir);			$this->skin->after();			return $working_dir;		}		//With the given options, this installs it to the destination directory.		$result = $this->install_package( array(											'source' => $working_dir,											'destination' => $destination,											'clear_destination' => $clear_destination,											'clear_working' => $clear_working,											'hook_extra' => $hook_extra										) );		$this->skin->set_result($result);		if ( is_wp_error($result) ) {			$this->skin->error($result);			$this->skin->feedback('process_failed');		} else {			//Install Suceeded			$this->skin->feedback('process_success');		}		$this->skin->after();		if ( !$is_multi )			$this->skin->footer();		return $result;	}	function maintenance_mode($enable = false) {		global $wp_filesystem;		$file = $wp_filesystem->abspath() . '.maintenance';		if ( $enable ) {			$this->skin->feedback('maintenance_start');			// Create maintenance file to signal that we are upgrading			$maintenance_string = '<?php $upgrading = ' . time() . '; ?>';			$wp_filesystem->delete($file);			$wp_filesystem->put_contents($file, $maintenance_string, FS_CHMOD_FILE);		} else if ( !$enable && $wp_filesystem->exists($file) ) {			$this->skin->feedback('maintenance_end');			$wp_filesystem->delete($file);		}	}}/** * Plugin Upgrader class for WordPress Plugins, It is designed to upgrade/install plugins from a local zip, remote zip URL, or uploaded zip file. * * @TODO More Detailed docs, for methods as well. * * @package WordPress * @subpackage Upgrader * @since 2.8.0 */class Plugin_Upgrader extends WP_Upgrader {	var $result;	var $bulk = false;	var $show_before = '';	function upgrade_strings() {		$this->strings['up_to_date'] = __('The plugin is at the latest version.');		$this->strings['no_package'] = __('Upgrade package not available.');		$this->strings['downloading_package'] = __('Downloading update from <span class="code">%s</span>&#8230;');		$this->strings['unpack_package'] = __('Unpacking the update&#8230;');		$this->strings['deactivate_plugin'] = __('Deactivating the plugin&#8230;');		$this->strings['remove_old'] = __('Removing the old version of the plugin&#8230;');		$this->strings['remove_old_failed'] = __('Could not remove the old plugin.');		$this->strings['process_failed'] = __('Plugin upgrade failed.');		$this->strings['process_success'] = __('Plugin upgraded successfully.');	}	function install_strings() {		$this->strings['no_package'] = __('Install package not available.');		$this->strings['downloading_package'] = __('Downloading install package from <span class="code">%s</span>&#8230;');		$this->strings['unpack_package'] = __('Unpacking the package&#8230;');		$this->strings['installing_package'] = __('Installing the plugin&#8230;');		$this->strings['process_failed'] = __('Plugin install failed.');		$this->strings['process_success'] = __('Plugin installed successfully.');	}	function install($package) {		$this->init();		$this->install_strings();		$this->run(array(					'package' => $package,					'destination' => WP_PLUGIN_DIR,					'clear_destination' => false, //Do not overwrite files.					'clear_working' => true,					'hook_extra' => array()					));		// Force refresh of plugin update information		delete_site_transient('update_plugins');	}	function upgrade($plugin) {		$this->init();		$this->upgrade_strings();		$current = get_site_transient( 'update_plugins' );		if ( !isset( $current->response[ $plugin ] ) ) {			$this->skin->before();			$this->skin->set_result(false);			$this->skin->error('up_to_date');			$this->skin->after();			return false;		}		// Get the URL to the zip file		$r = $current->response[ $plugin ];		add_filter('upgrader_pre_install', array(&$this, 'deactivate_plugin_before_upgrade'), 10, 2);		add_filter('upgrader_clear_destination', array(&$this, 'delete_old_plugin'), 10, 4);		//'source_selection' => array(&$this, 'source_selection'), //theres a track ticket to move up the directory for zip's which are made a bit differently, useful for non-.org plugins.		$this->run(array(					'package' => $r->package,					'destination' => WP_PLUGIN_DIR,					'clear_destination' => true,					'clear_working' => true,					'hook_extra' => array(								'plugin' => $plugin					)				));		// Cleanup our hooks, incase something else does a upgrade on this connection.		remove_filter('upgrader_pre_install', array(&$this, 'deactivate_plugin_before_upgrade'));		remove_filter('upgrader_clear_destination', array(&$this, 'delete_old_plugin'));		if ( ! $this->result || is_wp_error($this->result) )			return $this->result;		// Force refresh of plugin update information		delete_site_transient('update_plugins');	}	function bulk_upgrade($plugins) {		$this->init();		$this->bulk = true;		$this->upgrade_strings();		$current = get_site_transient( 'update_plugins' );		add_filter('upgrader_clear_destination', array(&$this, 'delete_old_plugin'), 10, 4);		$this->skin->header();		// Connect to the Filesystem first.		$res = $this->fs_connect( array(WP_CONTENT_DIR, WP_PLUGIN_DIR) );		if ( ! $res ) {			$this->skin->footer();			return false;		}		$this->skin->bulk_header();		$this->maintenance_mode(true);		$results = array();		$this->update_count = count($plugins);		$this->update_current = 0;		foreach ( $plugins as $plugin ) {			$this->update_current++;			$this->skin->plugin_info = get_plugin_data( WP_PLUGIN_DIR . '/' . $plugin, false, true);			if ( !isset( $current->response[ $plugin ] ) ) {				$this->skin->set_result(false);				$this->skin->before();				$this->skin->error('up_to_date');				$this->skin->after();				$results[$plugin] = false;				continue;			}			// Get the URL to the zip file			$r = $current->response[ $plugin ];			$this->skin->plugin_active = is_plugin_active($plugin);			$result = $this->run(array(						'package' => $r->package,						'destination' => WP_PLUGIN_DIR,						'clear_destination' => true,						'clear_working' => true,						'is_multi' => true,						'hook_extra' => array(									'plugin' => $plugin						)					));			$results[$plugin] = $this->result;			// Prevent credentials auth screen from displaying multiple times			if ( false === $result )				break;		} //end foreach $plugins		$this->maintenance_mode(false);		$this->skin->bulk_footer();		$this->skin->footer();		// Cleanup our hooks, incase something else does a upgrade on this connection.		remove_filter('upgrader_clear_destination', array(&$this, 'delete_old_plugin'));		// Force refresh of plugin update information		delete_site_transient('update_plugins');		return $results;	}	//return plugin info.	function plugin_info() {		if ( ! is_array($this->result) )			return false;		if ( empty($this->result['destination_name']) )			return false;		$plugin = get_plugins('/' . $this->result['destination_name']); //Ensure to pass with leading slash		if ( empty($plugin) )			return false;		$pluginfiles = array_keys($plugin); //Assume the requested plugin is the first in the list		return $this->result['destination_name'] . '/' . $pluginfiles[0];	}	//Hooked to pre_install	function deactivate_plugin_before_upgrade($return, $plugin) {		if ( is_wp_error($return) ) //Bypass.			return $return;		$plugin = isset($plugin['plugin']) ? $plugin['plugin'] : '';		if ( empty($plugin) )			return new WP_Error('bad_request', $this->strings['bad_request']);		if ( is_plugin_active($plugin) ) {			$this->skin->feedback('deactivate_plugin');			//Deactivate the plugin silently, Prevent deactivation hooks from running.			deactivate_plugins($plugin, true);		}	}	//Hooked to upgrade_clear_destination	function delete_old_plugin($removed, $local_destination, $remote_destination, $plugin) {		global $wp_filesystem;		if ( is_wp_error($removed) )			return $removed; //Pass errors through.		$plugin = isset($plugin['plugin']) ? $plugin['plugin'] : '';		if ( empty($plugin) )			return new WP_Error('bad_request', $this->strings['bad_request']);		$plugins_dir = $wp_filesystem->wp_plugins_dir();		$this_plugin_dir = trailingslashit( dirname($plugins_dir . $plugin) );		if ( ! $wp_filesystem->exists($this_plugin_dir) ) //If its already vanished.			return $removed;		// If plugin is in its own directory, recursively delete the directory.		if ( strpos($plugin, '/') && $this_plugin_dir != $plugins_dir ) //base check on if plugin includes directory seperator AND that its not the root plugin folder			$deleted = $wp_filesystem->delete($this_plugin_dir, true);		else			$deleted = $wp_filesystem->delete($plugins_dir . $plugin);		if ( ! $deleted )			return new WP_Error('remove_old_failed', $this->strings['remove_old_failed']);		return $removed;	}}/** * Theme Upgrader class for WordPress Themes, It is designed to upgrade/install themes from a local zip, remote zip URL, or uploaded zip file. * * @TODO More Detailed docs, for methods as well. * * @package WordPress * @subpackage Upgrader * @since 2.8.0 */class Theme_Upgrader extends WP_Upgrader {	var $result;	function upgrade_strings() {		$this->strings['up_to_date'] = __('The theme is at the latest version.');		$this->strings['no_package'] = __('Upgrade package not available.');		$this->strings['downloading_package'] = __('Downloading update from <span class="code">%s</span>&#8230;');		$this->strings['unpack_package'] = __('Unpacking the update&#8230;');		$this->strings['remove_old'] = __('Removing the old version of the theme&#8230;');		$this->strings['remove_old_failed'] = __('Could not remove the old theme.');		$this->strings['process_failed'] = __('Theme upgrade failed.');		$this->strings['process_success'] = __('Theme upgraded successfully.');	}	function install_strings() {		$this->strings['no_package'] = __('Install package not available.');		$this->strings['downloading_package'] = __('Downloading install package from <span class="code">%s</span>&#8230;');		$this->strings['unpack_package'] = __('Unpacking the package&#8230;');		$this->strings['installing_package'] = __('Installing the theme&#8230;');		$this->strings['process_failed'] = __('Theme install failed.');		$this->strings['process_success'] = __('Theme installed successfully.');	}	function install($package) {		$this->init();		$this->install_strings();		$options = array(						'package' => $package,						'destination' => WP_CONTENT_DIR . '/themes',						'clear_destination' => false, //Do not overwrite files.						'clear_working' => true						);		$this->run($options);		if ( ! $this->result || is_wp_error($this->result) )			return $this->result;		// Force refresh of theme update information		delete_site_transient('update_themes');		if ( empty($result['destination_name']) )			return false;		else			return $result['destination_name'];	}	function upgrade($theme) {		$this->init();		$this->upgrade_strings();		// Is an update available?		$current = get_site_transient( 'update_themes' );		if ( !isset( $current->response[ $theme ] ) ) {			$this->skin->before();			$this->skin->set_result(false);			$this->skin->error('up_to_date');			$this->skin->after();			return false;		}		$r = $current->response[ $theme ];		add_filter('upgrader_pre_install', array(&$this, 'current_before'), 10, 2);		add_filter('upgrader_post_install', array(&$this, 'current_after'), 10, 2);		add_filter('upgrader_clear_destination', array(&$this, 'delete_old_theme'), 10, 4);		$options = array(						'package' => $r['package'],						'destination' => WP_CONTENT_DIR . '/themes',						'clear_destination' => true,						'clear_working' => true,						'hook_extra' => array(											'theme' => $theme											)						);		$this->run($options);		if ( ! $this->result || is_wp_error($this->result) )			return $this->result;		// Force refresh of theme update information		delete_site_transient('update_themes');		return true;	}	function bulk_upgrade($themes) {		$this->init();		$this->bulk = true;		$this->upgrade_strings();		$current = get_site_transient( 'update_themes' );		add_filter('upgrader_pre_install', array(&$this, 'current_before'), 10, 2);		add_filter('upgrader_post_install', array(&$this, 'current_after'), 10, 2);		add_filter('upgrader_clear_destination', array(&$this, 'delete_old_theme'), 10, 4);		$this->skin->header();		// Connect to the Filesystem first.		$res = $this->fs_connect( array(WP_CONTENT_DIR) );		if ( ! $res ) {			$this->skin->footer();			return false;		}		$this->skin->bulk_header();		$this->maintenance_mode(true);		$results = array();		$this->update_count = count($themes);		$this->update_current = 0;		foreach ( $themes as $theme ) {			$this->update_current++;			if ( !isset( $current->response[ $theme ] ) ) {				$this->skin->set_result(false);				$this->skin->before();				$this->skin->error('up_to_date');				$this->skin->after();				$results[$theme] = false;				continue;			}			$this->skin->theme_info = $this->theme_info($theme);			// Get the URL to the zip file			$r = $current->response[ $theme ];			$options = array(							'package' => $r['package'],							'destination' => WP_CONTENT_DIR . '/themes',							'clear_destination' => true,							'clear_working' => true,							'hook_extra' => array(												'theme' => $theme												)							);			$result = $this->run($options);			$results[$theme] = $this->result;			// Prevent credentials auth screen from displaying multiple times			if ( false === $result )				break;		} //end foreach $plugins		$this->maintenance_mode(false);		$this->skin->bulk_footer();		$this->skin->footer();		// Cleanup our hooks, incase something else does a upgrade on this connection.		remove_filter('upgrader_pre_install', array(&$this, 'current_before'), 10, 2);		remove_filter('upgrader_post_install', array(&$this, 'current_after'), 10, 2);		remove_filter('upgrader_clear_destination', array(&$this, 'delete_old_theme'), 10, 4);		// Force refresh of theme update information		delete_site_transient('update_themes');		return $results;	}	function current_before($return, $theme) {		if ( is_wp_error($return) )			return $return;		$theme = isset($theme['theme']) ? $theme['theme'] : '';		if ( $theme != get_stylesheet() ) //If not current			return $return;		//Change to maintainence mode now.		if ( ! $this->bulk )			$this->maintenance_mode(true);		return $return;	}	function current_after($return, $theme) {		if ( is_wp_error($return) )			return $return;		$theme = isset($theme['theme']) ? $theme['theme'] : '';		if ( $theme != get_stylesheet() ) //If not current			return $return;		//Ensure stylesheet name hasnt changed after the upgrade:		if ( $theme == get_stylesheet() && $theme != $this->result['destination_name'] ) {			$theme_info = $this->theme_info();			$stylesheet = $this->result['destination_name'];			$template = !empty($theme_info['Template']) ? $theme_info['Template'] : $stylesheet;			switch_theme($template, $stylesheet, true);		}		//Time to remove maintainence mode		if ( ! $this->bulk )			$this->maintenance_mode(false);		return $return;	}	function delete_old_theme($removed, $local_destination, $remote_destination, $theme) {		global $wp_filesystem;		$theme = isset($theme['theme']) ? $theme['theme'] : '';		if ( is_wp_error($removed) || empty($theme) )			return $removed; //Pass errors through.		$themes_dir = $wp_filesystem->wp_themes_dir();		if ( $wp_filesystem->exists( trailingslashit($themes_dir) . $theme ) )			if ( ! $wp_filesystem->delete( trailingslashit($themes_dir) . $theme, true ) )				return false;		return true;	}	function theme_info($theme = null) {		if ( empty($theme) ) {			if ( !empty($this->result['destination_name']) )				$theme = $this->result['destination_name'];			else				return false;		}		return get_theme_data(WP_CONTENT_DIR . '/themes/' . $theme . '/style.css');	}}/** * Core Upgrader class for WordPress. It allows for WordPress to upgrade itself in combiantion with the wp-admin/includes/update-core.php file * * @TODO More Detailed docs, for methods as well. * * @package WordPress * @subpackage Upgrader * @since 2.8.0 */class Core_Upgrader extends WP_Upgrader {	function upgrade_strings() {		$this->strings['up_to_date'] = __('WordPress is at the latest version.');		$this->strings['no_package'] = __('Upgrade package not available.');		$this->strings['downloading_package'] = __('Downloading update from <span class="code">%s</span>&#8230;');		$this->strings['unpack_package'] = __('Unpacking the update&#8230;');		$this->strings['copy_failed'] = __('Could not copy files.');	}	function upgrade($current) {		global $wp_filesystem;		$this->init();		$this->upgrade_strings();		if ( !empty($feedback) )			add_filter('update_feedback', $feedback);		// Is an update available?		if ( !isset( $current->response ) || $current->response == 'latest' )			return new WP_Error('up_to_date', $this->strings['up_to_date']);		$res = $this->fs_connect( array(ABSPATH, WP_CONTENT_DIR) );		if ( is_wp_error($res) )			return $res;		$wp_dir = trailingslashit($wp_filesystem->abspath());		$download = $this->download_package( $current->package );		if ( is_wp_error($download) )			return $download;		$working_dir = $this->unpack_package( $download );		if ( is_wp_error($working_dir) )			return $working_dir;		// Copy update-core.php from the new version into place.		if ( !$wp_filesystem->copy($working_dir . '/wordpress/wp-admin/includes/update-core.php', $wp_dir . 'wp-admin/includes/update-core.php', true) ) {			$wp_filesystem->delete($working_dir, true);			return new WP_Error('copy_failed', $this->strings['copy_failed']);		}		$wp_filesystem->chmod($wp_dir . 'wp-admin/includes/update-core.php', FS_CHMOD_FILE);		require(ABSPATH . 'wp-admin/includes/update-core.php');		return update_core($working_dir, $wp_dir);	}}/** * Generic Skin for the WordPress Upgrader classes. This skin is designed to be extended for specific purposes. * * @TODO More Detailed docs, for methods as well. * * @package WordPress * @subpackage Upgrader * @since 2.8.0 */class WP_Upgrader_Skin {	var $upgrader;	var $done_header = false;	var $result = false;	function WP_Upgrader_Skin($args = array()) {		return $this->__construct($args);	}	function __construct($args = array()) {		$defaults = array( 'url' => '', 'nonce' => '', 'title' => '', 'context' => false );		$this->options = wp_parse_args($args, $defaults);	}	function set_upgrader(&$upgrader) {		if ( is_object($upgrader) )			$this->upgrader =& $upgrader;		$this->add_strings();	}	function add_strings() {	}	function set_result($result) {		$this->result = $result;	}	function request_filesystem_credentials($error = false) {		$url = $this->options['url'];		$context = $this->options['context'];		if ( !empty($this->options['nonce']) )			$url = wp_nonce_url($url, $this->options['nonce']);		return request_filesystem_credentials($url, '', $error, $context); //Possible to bring inline, Leaving as is for now.	}	function header() {		if ( $this->done_header )			return;		$this->done_header = true;		echo '<div class="wrap">';		echo screen_icon();		echo '<h2>' . $this->options['title'] . '</h2>';	}	function footer() {		echo '</div>';	}	function error($errors) {		if ( ! $this->done_header )			$this->header();		if ( is_string($errors) ) {			$this->feedback($errors);		} elseif ( is_wp_error($errors) && $errors->get_error_code() ) {			foreach ( $errors->get_error_messages() as $message ) {				if ( $errors->get_error_data() )					$this->feedback($message . ' ' . $errors->get_error_data() );				else					$this->feedback($message);			}		}	}	function feedback($string) {		if ( isset( $this->upgrader->strings[$string] ) )			$string = $this->upgrader->strings[$string];		if ( strpos($string, '%') !== false ) {			$args = func_get_args();			$args = array_splice($args, 1);			if ( !empty($args) )				$string = vsprintf($string, $args);		}		if ( empty($string) )			return;		show_message($string);	}	function before() {}	function after() {}}/** * Plugin Upgrader Skin for WordPress Plugin Upgrades. * * @TODO More Detailed docs, for methods as well. * * @package WordPress * @subpackage Upgrader * @since 2.8.0 */class Plugin_Upgrader_Skin extends WP_Upgrader_Skin {	var $plugin = '';	var $plugin_active = false;	var $plugin_network_active = false;	function Plugin_Upgrader_Skin($args = array()) {		return $this->__construct($args);	}	function __construct($args = array()) {		$defaults = array( 'url' => '', 'plugin' => '', 'nonce' => '', 'title' => __('Upgrade Plugin') );		$args = wp_parse_args($args, $defaults);		$this->plugin = $args['plugin'];		$this->plugin_active = is_plugin_active( $this->plugin );		$this->plugin_network_active = is_plugin_active_for_network( $this->plugin );		parent::__construct($args);	}	function after() {		$this->plugin = $this->upgrader->plugin_info();		if ( !empty($this->plugin) && !is_wp_error($this->result) && $this->plugin_active ){			show_message(__('Reactivating the plugin&#8230;'));			echo '<iframe style="border:0;overflow:hidden" width="100%" height="170px" src="' . wp_nonce_url('update.php?action=activate-plugin&networkwide=' . $this->plugin_network_active . '&plugin=' . $this->plugin, 'activate-plugin_' . $this->plugin) .'"></iframe>';		}		$update_actions =  array(			'activate_plugin' => '<a href="' . wp_nonce_url('plugins.php?action=activate&amp;plugin=' . $this->plugin, 'activate-plugin_' . $this->plugin) . '" title="' . esc_attr__('Activate this plugin') . '" target="_parent">' . __('Activate Plugin') . '</a>',			'plugins_page' => '<a href="' . admin_url('plugins.php') . '" title="' . esc_attr__('Goto plugins page') . '" target="_parent">' . __('Return to Plugins page') . '</a>'		);		if ( $this->plugin_active )			unset( $update_actions['activate_plugin'] );		if ( ! $this->result || is_wp_error($this->result) )			unset( $update_actions['activate_plugin'] );		$update_actions = apply_filters('update_plugin_complete_actions', $update_actions, $this->plugin);		if ( ! empty($update_actions) )			$this->feedback('<strong>' . __('Actions:') . '</strong> ' . implode(' | ', (array)$update_actions));	}	function before() {		if ( $this->upgrader->show_before ) {			echo $this->upgrader->show_before;			$this->upgrader->show_before = '';		}	}}/** * Plugin Upgrader Skin for WordPress Plugin Upgrades. * * @package WordPress * @subpackage Upgrader * @since 3.0.0 */class Bulk_Upgrader_Skin extends WP_Upgrader_Skin {	var $in_loop = false;	var $error = false;	function Bulk_Upgrader_Skin($args = array()) {		return $this->__construct($args);	}	function __construct($args = array()) {		$defaults = array( 'url' => '', 'nonce' => '' );		$args = wp_parse_args($args, $defaults);		parent::__construct($args);	}	function add_strings() {		$this->upgrader->strings['skin_upgrade_start'] = __('The update process is starting. This process may take awhile on some hosts, so please be patient.');		$this->upgrader->strings['skin_update_failed_error'] = __('An error occured while updating %1$s: <strong>%2$s</strong>.');		$this->upgrader->strings['skin_update_failed'] = __('The update of %1$s failed.');		$this->upgrader->strings['skin_update_successful'] = __('%1$s updated successfully.').' <a onclick="%2$s" href="#" class="hide-if-no-js"><span>'.__('Show Details').'</span><span class="hidden">'.__('Hide Details').'</span>.</a>';		$this->upgrader->strings['skin_upgrade_end'] = __('All updates have been completed.');	}	function feedback($string) {		if ( isset( $this->upgrader->strings[$string] ) )			$string = $this->upgrader->strings[$string];		if ( strpos($string, '%') !== false ) {			$args = func_get_args();			$args = array_splice($args, 1);			if ( !empty($args) )				$string = vsprintf($string, $args);		}		if ( empty($string) )			return;		if ( $this->in_loop )			echo "$string<br />\n";		else			echo "<p>$string</p>\n";	}	function header() {		// Nothing, This will be displayed within a iframe.	}	function footer() {		// Nothing, This will be displayed within a iframe.	}	function error($error) {		if ( is_string($error) && isset( $this->upgrader->strings[$error] ) )			$this->error = $this->upgrader->strings[$error];		if ( is_wp_error($error) ) {			foreach ( $error->get_error_messages() as $emessage ) {				if ( $error->get_error_data() )					$messages[] = $emessage . ' ' . $error->get_error_data();				else					$messages[] = $emessage;			}			$this->error = implode(', ', $messages);		}		echo '<script type="text/javascript">jQuery(\'.waiting-' . esc_js($this->upgrader->update_current) . '\').hide();</script>';	}	function bulk_header() {		$this->feedback('skin_upgrade_start');	}	function bulk_footer() {		$this->feedback('skin_upgrade_end');	}	function before($title = '') {		$this->in_loop = true;		printf( '<h4>' . $this->upgrader->strings['skin_before_update_header'] . ' <img alt="" src="' . admin_url( 'images/wpspin_light.gif' ) . '" class="hidden waiting-' . $this->upgrader->update_current . '" style="vertical-align:middle;"></h4>',  $title, $this->upgrader->update_current, $this->upgrader->update_count);		echo '<script type="text/javascript">jQuery(\'.waiting-' . esc_js($this->upgrader->update_current) . '\').show();</script>';		echo '<div class="update-messages hide-if-js" id="progress-' . esc_attr($this->upgrader->update_current) . '"><p>';		$this->flush_output();	}	function after($title = '') {		echo '</p></div>';		if ( $this->error || ! $this->result ) {			if ( $this->error )				echo '<div class="error"><p>' . sprintf($this->upgrader->strings['skin_update_failed_error'], $title, $this->error) . '</p></div>';			else				echo '<div class="error"><p>' . sprintf($this->upgrader->strings['skin_update_failed'], $title) . '</p></div>';			echo '<script type="text/javascript">jQuery(\'#progress-' . esc_js($this->upgrader->update_current) . '\').show();</script>';		}		if ( !empty($this->result) && !is_wp_error($this->result) ) {			echo '<div class="updated"><p>' . sprintf($this->upgrader->strings['skin_update_successful'], $title, 'jQuery(\'#progress-' . esc_js($this->upgrader->update_current) . '\').toggle();jQuery(\'span\', this).toggle(); return false;') . '</p></div>';			echo '<script type="text/javascript">jQuery(\'.waiting-' . esc_js($this->upgrader->update_current) . '\').hide();</script>';		}		$this->reset();		$this->flush_output();	}	function reset() {		$this->in_loop = false;		$this->error = false;	}	function flush_output() {		wp_ob_end_flush_all();		flush();	}}class Bulk_Plugin_Upgrader_Skin extends Bulk_Upgrader_Skin {	var $plugin_info = array(); // Plugin_Upgrader::bulk() will fill this in.	function Plugin_Upgrader_Skin($args = array()) {		parent::__construct($args);	}	function add_strings() {		parent::add_strings();		$this->upgrader->strings['skin_before_update_header'] = __('Updating Plugin %1$s (%2$d/%3$d)');	}	function before() {		parent::before($this->plugin_info['Title']);	}	function after() {		parent::after($this->plugin_info['Title']);	}	function bulk_footer() {		parent::bulk_footer();		$update_actions =  array(			'plugins_page' => '<a href="' . admin_url('plugins.php') . '" title="' . esc_attr__('Goto plugins page') . '" target="_parent">' . __('Return to Plugins page') . '</a>',			'updates_page' => '<a href="' . admin_url('update-core.php') . '" title="' . esc_attr__('Goto WordPress Updates page') . '" target="_parent">' . __('Return to WordPress Updates') . '</a>'		);		$update_actions = apply_filters('update_bulk_plugins_complete_actions', $update_actions, $this->plugin_info);		if ( ! empty($update_actions) )			$this->feedback('<strong>' . __('Actions:') . '</strong> ' . implode(' | ', (array)$update_actions));	}}class Bulk_Theme_Upgrader_Skin extends Bulk_Upgrader_Skin {	var $theme_info = array(); // Theme_Upgrader::bulk() will fill this in.	function Theme_Upgrader_Skin($args = array()) {		parent::__construct($args);	}	function add_strings() {		parent::add_strings();		$this->upgrader->strings['skin_before_update_header'] = __('Updating Theme %1$s (%2$d/%3$d)');	}	function before() {		parent::before($this->theme_info['Name']);	}	function after() {		parent::after($this->theme_info['Name']);	}	function bulk_footer() {		parent::bulk_footer();		$update_actions =  array(			'themes_page' => '<a href="' . admin_url('themes.php') . '" title="' . esc_attr__('Goto themes page') . '" target="_parent">' . __('Return to Themes page') . '</a>',			'updates_page' => '<a href="' . admin_url('update-core.php') . '" title="' . esc_attr__('Goto WordPress Updates page') . '" target="_parent">' . __('Return to WordPress Updates') . '</a>'		);		$update_actions = apply_filters('update_bulk_theme_complete_actions', $update_actions, $this->theme_info);		if ( ! empty($update_actions) )			$this->feedback('<strong>' . __('Actions:') . '</strong> ' . implode(' | ', (array)$update_actions));	}}/** * Plugin Installer Skin for WordPress Plugin Installer. * * @TODO More Detailed docs, for methods as well. * * @package WordPress * @subpackage Upgrader * @since 2.8.0 */class Plugin_Installer_Skin extends WP_Upgrader_Skin {	var $api;	var $type;	function Plugin_Installer_Skin($args = array()) {		return $this->__construct($args);	}	function __construct($args = array()) {		$defaults = array( 'type' => 'web', 'url' => '', 'plugin' => '', 'nonce' => '', 'title' => '' );		$args = wp_parse_args($args, $defaults);		$this->type = $args['type'];		$this->api = isset($args['api']) ? $args['api'] : array();		parent::__construct($args);	}	function before() {		if ( !empty($this->api) )			$this->upgrader->strings['process_success'] = sprintf( __('Successfully installed the plugin <strong>%s %s</strong>.'), $this->api->name, $this->api->version);	}	function after() {		$plugin_file = $this->upgrader->plugin_info();		$install_actions = array();		$from = isset($_GET['from']) ? stripslashes($_GET['from']) : 'plugins';		if ( 'import' == $from )			$install_actions['activate_plugin'] = '<a href="' . wp_nonce_url('plugins.php?action=activate&amp;from=import&amp;plugin=' . $plugin_file, 'activate-plugin_' . $plugin_file) . '" title="' . esc_attr__('Activate this plugin') . '" target="_parent">' . __('Activate Plugin &amp; Run Importer') . '</a>';		else			$install_actions['activate_plugin'] = '<a href="' . wp_nonce_url('plugins.php?action=activate&amp;plugin=' . $plugin_file, 'activate-plugin_' . $plugin_file) . '" title="' . esc_attr__('Activate this plugin') . '" target="_parent">' . __('Activate Plugin') . '</a>';		if ( is_multisite() && current_user_can( 'manage_network_plugins' ) )			$install_actions['network_activate'] = '<a href="' . wp_nonce_url('plugins.php?action=activate&amp;networkwide=1&amp;plugin=' . $plugin_file, 'activate-plugin_' . $plugin_file) . '" title="' . __('Activate this plugin for all sites in this network') . '" target="_parent">' . __('Network Activate') . '</a>';		if ( 'import' == $from )			$install_actions['importers_page'] = '<a href="' . admin_url('import.php') . '" title="' . esc_attr__('Return to Importers') . '" target="_parent">' . __('Return to Importers') . '</a>';		else if ( $this->type == 'web' )			$install_actions['plugins_page'] = '<a href="' . admin_url('plugin-install.php') . '" title="' . esc_attr__('Return to Plugin Installer') . '" target="_parent">' . __('Return to Plugin Installer') . '</a>';		else			$install_actions['plugins_page'] = '<a href="' . admin_url('plugins.php') . '" title="' . esc_attr__('Return to Plugins page') . '" target="_parent">' . __('Return to Plugins page') . '</a>';		if ( ! $this->result || is_wp_error($this->result) ) {			unset( $install_actions['activate_plugin'] );			unset( $install_actions['network_activate'] );		}		$install_actions = apply_filters('install_plugin_complete_actions', $install_actions, $this->api, $plugin_file);		if ( ! empty($install_actions) )			$this->feedback('<strong>' . __('Actions:') . '</strong> ' . implode(' | ', (array)$install_actions));	}}/** * Theme Installer Skin for the WordPress Theme Installer. * * @TODO More Detailed docs, for methods as well. * * @package WordPress * @subpackage Upgrader * @since 2.8.0 */class Theme_Installer_Skin extends WP_Upgrader_Skin {	var $api;	var $type;	function Theme_Installer_Skin($args = array()) {		return $this->__construct($args);	}	function __construct($args = array()) {		$defaults = array( 'type' => 'web', 'url' => '', 'theme' => '', 'nonce' => '', 'title' => '' );		$args = wp_parse_args($args, $defaults);		$this->type = $args['type'];		$this->api = isset($args['api']) ? $args['api'] : array();		parent::__construct($args);	}	function before() {		if ( !empty($this->api) ) {			/* translators: 1: theme name, 2: version */			$this->upgrader->strings['process_success'] = sprintf( __('Successfully installed the theme <strong>%1$s %2$s</strong>.'), $this->api->name, $this->api->version);		}	}	function after() {		if ( empty($this->upgrader->result['destination_name']) )			return;		$theme_info = $this->upgrader->theme_info();		if ( empty($theme_info) )			return;		$name = $theme_info['Name'];		$stylesheet = $this->upgrader->result['destination_name'];		$template = !empty($theme_info['Template']) ? $theme_info['Template'] : $stylesheet;		$preview_link = htmlspecialchars( add_query_arg( array('preview' => 1, 'template' => $template, 'stylesheet' => $stylesheet, 'TB_iframe' => 'true' ), trailingslashit(esc_url(get_option('home'))) ) );		$activate_link = wp_nonce_url("themes.php?action=activate&amp;template=" . urlencode($template) . "&amp;stylesheet=" . urlencode($stylesheet), 'switch-theme_' . $template);		$install_actions = array(			'preview' => '<a href="' . $preview_link . '" class="thickbox thickbox-preview" title="' . esc_attr(sprintf(__('Preview &#8220;%s&#8221;'), $name)) . '">' . __('Preview') . '</a>',			'activate' => '<a href="' . $activate_link .  '" class="activatelink" title="' . esc_attr( sprintf( __('Activate &#8220;%s&#8221;'), $name ) ) . '">' . __('Activate') . '</a>'							);		if ( $this->type == 'web' )			$install_actions['themes_page'] = '<a href="' . admin_url('theme-install.php') . '" title="' . esc_attr__('Return to Theme Installer') . '" target="_parent">' . __('Return to Theme Installer') . '</a>';		else			$install_actions['themes_page'] = '<a href="' . admin_url('themes.php') . '" title="' . esc_attr__('Themes page') . '" target="_parent">' . __('Return to Themes page') . '</a>';		if ( ! $this->result || is_wp_error($this->result) )			unset( $install_actions['activate'], $install_actions['preview'] );		$install_actions = apply_filters('install_theme_complete_actions', $install_actions, $this->api, $stylesheet, $theme_info);		if ( ! empty($install_actions) )			$this->feedback('<strong>' . __('Actions:') . '</strong> ' . implode(' | ', (array)$install_actions));	}}/** * Theme Upgrader Skin for WordPress Theme Upgrades. * * @TODO More Detailed docs, for methods as well. * * @package WordPress * @subpackage Upgrader * @since 2.8.0 */class Theme_Upgrader_Skin extends WP_Upgrader_Skin {	var $theme = '';	function Theme_Upgrader_Skin($args = array()) {		return $this->__construct($args);	}	function __construct($args = array()) {		$defaults = array( 'url' => '', 'theme' => '', 'nonce' => '', 'title' => __('Upgrade Theme') );		$args = wp_parse_args($args, $defaults);		$this->theme = $args['theme'];		parent::__construct($args);	}	function after() {		$update_actions = array();		if ( !empty($this->upgrader->result['destination_name']) &&			($theme_info = $this->upgrader->theme_info()) &&			!empty($theme_info) ) {			$name = $theme_info['Name'];			$stylesheet = $this->upgrader->result['destination_name'];			$template = !empty($theme_info['Template']) ? $theme_info['Template'] : $stylesheet;			$preview_link = htmlspecialchars( add_query_arg( array('preview' => 1, 'template' => $template, 'stylesheet' => $stylesheet, 'TB_iframe' => 'true' ), trailingslashit(esc_url(get_option('home'))) ) );			$activate_link = wp_nonce_url("themes.php?action=activate&amp;template=" . urlencode($template) . "&amp;stylesheet=" . urlencode($stylesheet), 'switch-theme_' . $template);			$update_actions['preview'] = '<a href="' . $preview_link . '" class="thickbox thickbox-preview" title="' . esc_attr(sprintf(__('Preview &#8220;%s&#8221;'), $name)) . '">' . __('Preview') . '</a>';			$update_actions['activate'] = '<a href="' . $activate_link .  '" class="activatelink" title="' . esc_attr( sprintf( __('Activate &#8220;%s&#8221;'), $name ) ) . '">' . __('Activate') . '</a>';			if ( ( ! $this->result || is_wp_error($this->result) ) || $stylesheet == get_stylesheet() )				unset($update_actions['preview'], $update_actions['activate']);		}		$update_actions['themes_page'] = '<a href="' . admin_url('themes.php') . '" title="' . esc_attr__('Return to Themes page') . '" target="_parent">' . __('Return to Themes page') . '</a>';		$update_actions = apply_filters('update_theme_complete_actions', $update_actions, $this->theme);		if ( ! empty($update_actions) )			$this->feedback('<strong>' . __('Actions:') . '</strong> ' . implode(' | ', (array)$update_actions));	}}/** * Upgrade Skin helper for File uploads. This class handles the upload process and passes it as if its a local file to the Upgrade/Installer functions. * * @TODO More Detailed docs, for methods as well. * * @package WordPress * @subpackage Upgrader * @since 2.8.0 */class File_Upload_Upgrader {	var $package;	var $filename;	function File_Upload_Upgrader($form, $urlholder) {		return $this->__construct($form, $urlholder);	}	function __construct($form, $urlholder) {		if ( ! ( ( $uploads = wp_upload_dir() ) && false === $uploads['error'] ) )			wp_die($uploads['error']);		if ( empty($_FILES[$form]['name']) && empty($_GET[$urlholder]) )			wp_die(__('Please select a file'));		if ( !empty($_FILES) )			$this->filename = $_FILES[$form]['name'];		else if ( isset($_GET[$urlholder]) )			$this->filename = $_GET[$urlholder];		//Handle a newly uploaded file, Else assume its already been uploaded		if ( !empty($_FILES) ) {			$this->filename = wp_unique_filename( $uploads['basedir'], $this->filename );			$this->package = $uploads['basedir'] . '/' . $this->filename;			// Move the file to the uploads dir			if ( false === @ move_uploaded_file( $_FILES[$form]['tmp_name'], $this->package) )				wp_die( sprintf( __('The uploaded file could not be moved to %s.' ), $uploads['path']));		} else {			$this->package = $uploads['basedir'] . '/' . $this->filename;		}	}}
<?php/** * Action handler for Multisite administration panels. * * @package WordPress * @subpackage Multisite * @since 3.0.0 */require_once( './admin.php' );if ( ! is_multisite() )	wp_die( __( 'Multisite support is not enabled.' ) );if ( empty( $_GET['action'] ) )	wp_redirect( admin_url( 'ms-admin.php' ) );do_action( 'wpmuadminedit' , '');if ( isset( $_GET['id' ]) )	$id = intval( $_GET['id'] );elseif ( isset( $_POST['id'] ) )	$id = intval( $_POST['id'] );switch ( $_GET['action'] ) {	case 'siteoptions':		check_admin_referer( 'siteoptions' );		if ( ! current_user_can( 'manage_network_options' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		if ( empty( $_POST ) )			wp_die( sprintf( __( 'You probably need to go back to the <a href="%s">options page</a>.', esc_url( admin_url( 'ms-options.php' ) ) ) ) );		if ( isset($_POST['WPLANG']) && ( '' === $_POST['WPLANG'] || in_array( $_POST['WPLANG'], get_available_languages() ) ) )			update_site_option( 'WPLANG', $_POST['WPLANG'] );		if ( is_email( $_POST['admin_email'] ) )			update_site_option( 'admin_email', $_POST['admin_email'] );		$illegal_names = split( ' ', $_POST['illegal_names'] );		foreach ( (array) $illegal_names as $name ) {			$name = trim( $name );			if ( $name != '' )				$names[] = trim( $name );		}		update_site_option( 'illegal_names', $names );		if ( $_POST['limited_email_domains'] != '' ) {			$limited_email_domains = str_replace( ' ', "\n", $_POST['limited_email_domains'] );			$limited_email_domains = split( "\n", stripslashes( $limited_email_domains ) );			$limited_email = array();			foreach ( (array) $limited_email_domains as $domain ) {					$domain = trim( $domain );				if ( ! preg_match( '/(--|\.\.)/', $domain ) && preg_match( '|^([a-zA-Z0-9-\.])+$|', $domain ) )					$limited_email[] = trim( $domain );			}			update_site_option( 'limited_email_domains', $limited_email );		} else {			update_site_option( 'limited_email_domains', '' );		}		if ( $_POST['banned_email_domains'] != '' ) {			$banned_email_domains = split( "\n", stripslashes( $_POST['banned_email_domains'] ) );			$banned = array();			foreach ( (array) $banned_email_domains as $domain ) {				$domain = trim( $domain );				if ( ! preg_match( '/(--|\.\.)/', $domain ) && preg_match( '|^([a-zA-Z0-9-\.])+$|', $domain ) )					$banned[] = trim( $domain );			}			update_site_option( 'banned_email_domains', $banned );		} else {			update_site_option( 'banned_email_domains', '' );		}		update_site_option( 'default_user_role', $_POST['default_user_role'] );		if ( trim( $_POST['dashboard_blog_orig'] ) == '' )			$_POST['dashboard_blog_orig'] = $current_site->blog_id;		if ( trim( $_POST['dashboard_blog'] ) == '' ) {			$_POST['dashboard_blog'] = $current_site->blog_id;			$dashboard_blog_id = $current_site->blog_id;		} elseif ( ! preg_match( '/(--|\.)/', $_POST['dashboard_blog'] ) && preg_match( '|^([a-zA-Z0-9-\.])+$|', $_POST['dashboard_blog'] ) ) {			$dashboard_blog = $_POST['dashboard_blog'];			$blog_details = get_blog_details( $dashboard_blog );			if ( false === $blog_details ) {				if ( is_numeric( $dashboard_blog ) )					wp_die( __( 'A dashboard site referenced by ID must already exist' ) );				if ( is_subdomain_install() ) {					$domain = $dashboard_blog . '.' . $current_site->domain;					$path = $current_site->path;				} else {					$domain = $current_site->domain;					$path = trailingslashit( $current_site->path . $dashboard_blog );				}				$wpdb->hide_errors();				$dashboard_blog_id = wpmu_create_blog( $domain, $path, __( 'My Dashboard' ), $current_user->id , array( 'public' => 0 ), $current_site->id );				$wpdb->show_errors();			} else {				$dashboard_blog_id = $blog_details->blog_id;			}		}		if ( is_wp_error( $dashboard_blog_id ) )			wp_die( __( 'Problem creating dashboard site: ' ) . $dashboard_blog_id->get_error_message() );		if ( $_POST['dashboard_blog_orig'] != $_POST['dashboard_blog'] ) {			$users = get_users_of_blog( get_site_option( 'dashboard_blog' ) );			$move_users = array();			foreach ( (array)$users as $user ) {				$user_meta_value = unserialize( $user->meta_value );				if ( is_array( $user_meta_value ) && array_pop( array_keys( $user_meta_value ) ) == 'subscriber' )					$move_users[] = $user->user_id;			}			if ( false == empty( $move_users ) ) {				foreach ( (array)$move_users as $user_id ) {					remove_user_from_blog($user_id, get_site_option( 'dashboard_blog' ) );					add_user_to_blog( $dashboard_blog_id, $user_id, get_site_option( 'default_user_role', 'subscriber' ) );					update_user_meta( $user_id, 'primary_blog', $dashboard_blog_id );				}			}		}		update_site_option( 'dashboard_blog', $dashboard_blog_id );		$options = array( 'registrationnotification', 'registration', 'add_new_users', 'menu_items', 'mu_media_buttons', 'upload_space_check_disabled', 'blog_upload_space', 'upload_filetypes', 'site_name', 'first_post', 'first_page', 'first_comment', 'first_comment_url', 'first_comment_author', 'welcome_email', 'welcome_user_email', 'fileupload_maxk', 'admin_notice_feed', 'global_terms_enabled' );		$checked_options = array( 'mu_media_buttons' => array(), 'menu_items' => array(), 'registrationnotification' => 'no', 'upload_space_check_disabled' => 1 );		foreach ( $checked_options as $option_name => $option_unchecked_value ) {			if ( ! isset( $_POST[$option_name] ) )				$_POST[$option_name] = $option_unchecked_value;		}		foreach ( $options as $option_name ) {			if ( ! isset($_POST[$option_name]) )				continue;			$value = stripslashes_deep( $_POST[$option_name] );			update_site_option( $option_name, $value );		}		// Update more options here		do_action( 'update_wpmu_options' );		wp_redirect( add_query_arg( 'updated', 'true', admin_url( 'ms-options.php' ) ) );		exit();	break;	case 'addblog':		check_admin_referer( 'add-blog', '_wpnonce_add-blog' );		if ( ! current_user_can( 'manage_sites' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		if ( is_array( $_POST['blog'] ) == false )			wp_die(  __( 'Can&#8217;t create an empty site.' ) );		$blog = $_POST['blog'];		$domain = '';		if ( ! preg_match( '/(--)/', $blog['domain'] ) && preg_match( '|^([a-zA-Z0-9-])+$|', $blog['domain'] ) )			$domain = strtolower( $blog['domain'] );		// If not a subdomain install, make sure the domain isn't a reserved word		if ( ! is_subdomain_install() ) {			$subdirectory_reserved_names = apply_filters( 'subdirectory_reserved_names', array( 'page', 'comments', 'blog', 'files', 'feed' ) );			if ( in_array( $domain, $subdirectory_reserved_names ) )				wp_die( sprintf( __('The following words are reserved for use by WordPress functions and cannot be used as blog names: <code>%s</code>' ), implode( '</code>, <code>', $subdirectory_reserved_names ) ) );		}		$email = sanitize_email( $blog['email'] );		$title = $blog['title'];		if ( empty( $domain ) )			wp_die( __( 'Missing or invalid site address.' ) );		if ( empty( $email ) )			wp_die( __( 'Missing email address.' ) );		if ( !is_email( $email ) )			wp_die( __( 'Invalid email address.' ) );		if ( is_subdomain_install() ) {			$newdomain = $domain . '.' . preg_replace( '|^www\.|', '', $current_site->domain );			$path = $base;		} else {			$newdomain = $current_site->domain;			$path = $base . $domain . '/';		}		$password = 'N/A';		$user_id = email_exists($email);		if ( !$user_id ) { // Create a new user with a random password			$password = wp_generate_password();			$user_id = wpmu_create_user( $domain, $password, $email );			if ( false == $user_id )				wp_die( __( 'There was an error creating the user.' ) );			else				wp_new_user_notification( $user_id, $password );		}		$wpdb->hide_errors();		$id = wpmu_create_blog( $newdomain, $path, $title, $user_id , array( 'public' => 1 ), $current_site->id );		$wpdb->show_errors();		if ( !is_wp_error( $id ) ) {			$dashboard_blog = get_dashboard_blog();			if ( !is_super_admin( $user_id ) && get_user_option( 'primary_blog', $user_id ) == $dashboard_blog->blog_id )				update_user_option( $user_id, 'primary_blog', $id, true );			$content_mail = sprintf( __( "New site created by %1s\n\nAddress: http://%2s\nName: %3s"), $current_user->user_login , $newdomain . $path, stripslashes( $title ) );			wp_mail( get_site_option('admin_email'),  sprintf( __( '[%s] New Site Created' ), $current_site->site_name ), $content_mail, 'From: "Site Admin" <' . get_site_option( 'admin_email' ) . '>' );			wpmu_welcome_notification( $id, $user_id, $password, $title, array( 'public' => 1 ) );			wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'add-blog' ), wp_get_referer() ) );			exit();		} else {			wp_die( $id->get_error_message() );		}	break;	case 'updateblog':		check_admin_referer( 'editblog' );		if ( ! current_user_can( 'manage_sites' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		if ( empty( $_POST ) )			wp_die( sprintf( __( 'You probably need to go back to the <a href="%s">sites page</a>', esc_url( admin_url( 'ms-sites.php' ) ) ) ) );		switch_to_blog( $id );		// themes		$allowedthemes = array();		if ( isset($_POST['theme']) && is_array( $_POST['theme'] ) ) {			foreach ( $_POST['theme'] as $theme => $val ) {				if ( 'on' == $val )					$allowedthemes[$theme] = true;			}		}		update_option( 'allowedthemes',  $allowedthemes );		// options		if ( is_array( $_POST['option'] ) ) {			$c = 1;			$count = count( $_POST['option'] );			foreach ( (array) $_POST['option'] as $key => $val ) {				if ( $key === 0 || is_array( $val ) )					continue; // Avoids "0 is a protected WP option and may not be modified" error when edit blog options				if ( $c == $count )					update_option( $key, stripslashes( $val ) );				else					update_option( $key, stripslashes( $val ), false ); // no need to refresh blog details yet				$c++;			}		}		// home and siteurl		if ( isset( $_POST['update_home_url'] ) && $_POST['update_home_url'] == 'update' ) {			$blog_address = get_blogaddress_by_domain( $_POST['blog']['domain'], $_POST['blog']['path'] );			if ( get_option( 'siteurl' ) !=  $blog_address )				update_option( 'siteurl', $blog_address );			if ( get_option( 'home' ) != $blog_address )				update_option( 'home', $blog_address );		}		// rewrite rules can't be flushed during switch to blog		delete_option( 'rewrite_rules' );		// update blogs table		$blog_data = stripslashes_deep( $_POST['blog'] );		update_blog_details( $id, $blog_data );		// get blog prefix		$blog_prefix = $wpdb->get_blog_prefix( $id );		// user roles		if ( isset( $_POST['role'] ) && is_array( $_POST['role'] ) == true ) {			$newroles = $_POST['role'];			reset( $newroles );			foreach ( (array) $newroles as $userid => $role ) {				$user = new WP_User( $userid );				if ( ! $user )					continue;				$user->for_blog( $id );				$user->set_role( $role );			}		}		// remove user		if ( isset( $_POST['blogusers'] ) && is_array( $_POST['blogusers'] ) ) {			reset( $_POST['blogusers'] );			foreach ( (array) $_POST['blogusers'] as $key => $val )				remove_user_from_blog( $key, $id );		}		// change password		if ( isset( $_POST['user_password'] ) && is_array( $_POST['user_password'] ) ) {			reset( $_POST['user_password'] );			$newroles = $_POST['role'];			foreach ( (array) $_POST['user_password'] as $userid => $pass ) {				unset( $_POST['role'] );				$_POST['role'] = $newroles[ $userid ];				if ( $pass != '' ) {					$cap = $wpdb->get_var( "SELECT meta_value FROM {$wpdb->usermeta} WHERE user_id = '{$userid}' AND meta_key = '{$blog_prefix}capabilities' AND meta_value = 'a:0:{}'" );					$userdata = get_userdata($userid);					$_POST['pass1'] = $_POST['pass2'] = $pass;					$_POST['email'] = $userdata->user_email;					$_POST['rich_editing'] = $userdata->rich_editing;					edit_user( $userid );					if ( $cap == null )						$wpdb->query( "DELETE FROM {$wpdb->usermeta} WHERE user_id = '{$userid}' AND meta_key = '{$blog_prefix}capabilities' AND meta_value = 'a:0:{}'" );				}			}			unset( $_POST['role'] );			$_POST['role'] = $newroles;		}		// add user		if ( !empty( $_POST['newuser'] ) ) {			$newuser = $_POST['newuser'];			$userid = $wpdb->get_var( $wpdb->prepare( "SELECT ID FROM " . $wpdb->users . " WHERE user_login = %s", $newuser ) );			if ( $userid ) {				$user = $wpdb->get_var( "SELECT user_id FROM " . $wpdb->usermeta . " WHERE user_id='$userid' AND meta_key='{$blog_prefix}capabilities'" );				if ( $user == false )					add_user_to_blog( $id, $userid, $_POST['new_role'] );			}		}		do_action( 'wpmu_update_blog_options' );		restore_current_blog();		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'editblog', 'id' => $id ), wp_get_referer() ) );	break;	case 'deleteblog':		check_admin_referer('deleteblog');		if ( ! current_user_can( 'manage_sites' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		if ( $id != '0' && $id != $current_site->blog_id )			wpmu_delete_blog( $id, true );		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'delete' ), wp_get_referer() ) );		exit();	break;	case 'allblogs':		if ( isset( $_POST['doaction']) || isset($_POST['doaction2'] ) ) {			check_admin_referer( 'bulk-ms-sites', '_wpnonce_bulk-ms-sites' );			if ( ! current_user_can( 'manage_sites' ) )				wp_die( __( 'You do not have permission to access this page.' ) );			if ( $_GET['action'] != -1 || $_POST['action2'] != -1 )				$doaction = $_POST['action'] != -1 ? $_POST['action'] : $_POST['action2'];			foreach ( (array) $_POST['allblogs'] as $key => $val ) {				if ( $val != '0' && $val != $current_site->blog_id ) {					switch ( $doaction ) {						case 'delete':							$blogfunction = 'all_delete';							wpmu_delete_blog( $val, true );						break;						case 'spam':							$blogfunction = 'all_spam';							update_blog_status( $val, 'spam', '1', 0 );							set_time_limit( 60 );						break;						case 'notspam':							$blogfunction = 'all_notspam';							update_blog_status( $val, 'spam', '0', 0 );							set_time_limit( 60 );						break;					}				} else {					wp_die( __( 'You are not allowed to change the current site.' ) );				}			}			wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => $blogfunction ), wp_get_referer() ) );			exit();		} else {			wp_redirect( admin_url( 'ms-sites.php' ) );		}	break;	case 'archiveblog':		check_admin_referer( 'archiveblog' );		if ( ! current_user_can( 'manage_sites' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		update_blog_status( $id, 'archived', '1' );		do_action( 'archive_blog', $id );		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'archive' ), wp_get_referer() ) );		exit();	break;	case 'unarchiveblog':		check_admin_referer( 'unarchiveblog' );		if ( ! current_user_can( 'manage_sites' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		do_action( 'unarchive_blog', $id );		update_blog_status( $id, 'archived', '0' );		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'unarchive' ), wp_get_referer() ) );		exit();	break;	case 'activateblog':		check_admin_referer( 'activateblog' );		if ( ! current_user_can( 'manage_sites' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		update_blog_status( $id, 'deleted', '0' );		do_action( 'activate_blog', $id );		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'activate' ), wp_get_referer() ) );		exit();	break;	case 'deactivateblog':		check_admin_referer( 'deactivateblog' );		if ( ! current_user_can( 'manage_sites' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		do_action( 'deactivate_blog', $id );		update_blog_status( $id, 'deleted', '1' );		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'deactivate' ), wp_get_referer() ) );		exit();	break;	case 'unspamblog':		check_admin_referer( 'unspamblog' );		if ( ! current_user_can( 'manage_sites' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		update_blog_status( $id, 'spam', '0' );		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'unspam' ), wp_get_referer() ) );		exit();	break;	case 'spamblog':		check_admin_referer( 'spamblog' );		if ( ! current_user_can( 'manage_sites' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		update_blog_status( $id, 'spam', '1' );		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'spam' ), wp_get_referer() ) );		exit();	break;	// Themes    case 'updatethemes':	if ( ! current_user_can( 'manage_network_themes' ) )		wp_die( __( 'You do not have permission to access this page.' ) );    	if ( is_array( $_POST['theme'] ) ) {			$themes = get_themes();			reset( $themes );			$allowed_themes = array();			foreach ( (array) $themes as $key => $theme ) {				if ( $_POST['theme'][ esc_html( $theme['Stylesheet'] ) ] == 'enabled' )					$allowed_themes[ esc_html( $theme['Stylesheet'] ) ] = true;			}			update_site_option( 'allowedthemes', $allowed_themes );		}		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'themes' ),  wp_get_referer() ) );		exit();	break;	// Common	case 'confirm':		if ( !headers_sent() ) {			nocache_headers();			header( 'Content-Type: text/html; charset=utf-8' );		}		if ( $current_site->blog_id == $id )			wp_die( __( 'You are not allowed to change the current site.' ) );		?>		<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">		<html xmlns="http://www.w3.org/1999/xhtml" <?php if ( function_exists( 'language_attributes' ) ) language_attributes(); ?>>			<head>				<title><?php _e( 'WordPress &rsaquo; Confirm your action' ); ?></title>				<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />				<?php				wp_admin_css( 'install', true );				wp_admin_css( 'ie', true );				?>			</head>			<body>				<h1 id="logo"><img alt="WordPress" src="<?php echo esc_attr( admin_url( 'images/wordpress-logo.png' ) ); ?>" /></h1>				<form action="ms-edit.php?action=<?php echo esc_attr( $_GET['action2'] ) ?>" method="post">					<input type="hidden" name="action" value="<?php echo esc_attr( $_GET['action2'] ) ?>" />					<input type="hidden" name="id" value="<?php echo esc_attr( $id ); ?>" />					<input type="hidden" name="_wp_http_referer" value="<?php echo esc_attr( wp_get_referer() ); ?>" />					<?php wp_nonce_field( $_GET['action2'], '_wpnonce', false ); ?>					<p><?php echo esc_html( stripslashes( $_GET['msg'] ) ); ?></p>					<p class="submit"><input class="button" type="submit" value="<?php _e( 'Confirm' ); ?>" /></p>				</form>			</body>		</html>		<?php	break;	// Users	case 'deleteuser':		if ( ! current_user_can( 'manage_network_users' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		check_admin_referer( 'deleteuser' );		if ( $id != '0' && $id != '1' ) {			$_POST['allusers'] = array( $id ); // confirm_delete_users() can only handle with arrays			$title = __( 'Users' );			$parent_file = 'ms-admin.php';			require_once( 'admin-header.php' );			echo '<div class="wrap">';			confirm_delete_users( $_POST['allusers'] );			echo '</div>';            require_once( 'admin-footer.php' );            exit();		} else {			wp_redirect( admin_url( 'ms-users.php' ) );		}	break;	case 'allusers':		if ( ! current_user_can( 'manage_network_users' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		if ( isset( $_POST['doaction']) || isset($_POST['doaction2'] ) ) {			check_admin_referer( 'bulk-ms-users', '_wpnonce_bulk-ms-users' );			if ( $_GET['action'] != -1 || $_POST['action2'] != -1 )				$doaction = $_POST['action'] != -1 ? $_POST['action'] : $_POST['action2'];			foreach ( (array) $_POST['allusers'] as $key => $val ) {				if ( !empty( $val ) ) {					switch ( $doaction ) {						case 'delete':							$title = __( 'Users' );							$parent_file = 'ms-admin.php';							require_once( 'admin-header.php' );							echo '<div class="wrap">';							confirm_delete_users( $_POST['allusers'] );							echo '</div>';				            require_once( 'admin-footer.php' );				            exit();       					break;						case 'spam':							$user = new WP_User( $val );							if ( in_array( $user->user_login, get_super_admins() ) )								wp_die( sprintf( __( 'Warning! User cannot be modified. The user %s is a network administrator.' ), esc_html( $user->user_login ) ) );							$userfunction = 'all_spam';							$blogs = get_blogs_of_user( $val, true );							foreach ( (array) $blogs as $key => $details ) {								if ( $details->userblog_id != $current_site->blog_id ) // main blog not a spam !									update_blog_status( $details->userblog_id, 'spam', '1' );							}							update_user_status( $val, 'spam', '1', 1 );						break;						case 'notspam':							$userfunction = 'all_notspam';							$blogs = get_blogs_of_user( $val, true );							foreach ( (array) $blogs as $key => $details )								update_blog_status( $details->userblog_id, 'spam', '0' );							update_user_status( $val, 'spam', '0', 1 );						break;					}				}			}			wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => $userfunction ), wp_get_referer() ) );			exit();		} else {			wp_redirect( admin_url( 'ms-users.php' ) );		}	break;	case 'dodelete':		check_admin_referer( 'ms-users-delete' );		if ( ! current_user_can( 'manage_network_users' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		if ( ! empty( $_POST['blog'] ) && is_array( $_POST['blog'] ) ) {			foreach ( $_POST['blog'] as $id => $users ) {				foreach ( $users as $blogid => $user_id ) {					if ( ! empty( $_POST['delete'] ) && 'reassign' == $_POST['delete'][$blogid][$id] )						remove_user_from_blog( $id, $blogid, $user_id );					else						remove_user_from_blog( $id, $blogid );				}			}		}		$i = 0;		if ( is_array( $_POST['user'] ) && ! empty( $_POST['user'] ) )			foreach( $_POST['user'] as $id ) {				wpmu_delete_user( $id );				$i++;			}		if ( $i == 1 )			$deletefunction = 'delete';		else			$deletefunction = 'all_delete';		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => $deletefunction ), admin_url( 'ms-users.php' ) ) );	break;	case 'adduser':		check_admin_referer( 'add-user', '_wpnonce_add-user' );		if ( ! current_user_can( 'manage_network_users' ) )			wp_die( __( 'You do not have permission to access this page.' ) );		if ( is_array( $_POST['user'] ) == false )			wp_die( __( 'Cannot create an empty user.' ) );		$user = $_POST['user'];		if ( empty($user['username']) && empty($user['email']) )			wp_die( __( 'Missing username and email.' ) );		elseif ( empty($user['username']) )			wp_die( __( 'Missing username.' ) );		elseif ( empty($user['email']) )			wp_die( __( 'Missing email.' ) );		$password = wp_generate_password();		$user_id = wpmu_create_user( esc_html( strtolower( $user['username'] ) ), $password, esc_html( $user['email'] ) );		if ( false == $user_id ) 			wp_die( __( 'Duplicated username or email address.' ) );		else			wp_new_user_notification( $user_id, $password );		if ( get_site_option( 'dashboard_blog' ) == false )			add_user_to_blog( $current_site->blog_id, $user_id, get_site_option( 'default_user_role', 'subscriber' ) );		else			add_user_to_blog( get_site_option( 'dashboard_blog' ), $user_id, get_site_option( 'default_user_role', 'subscriber' ) );		wp_redirect( add_query_arg( array( 'updated' => 'true', 'action' => 'add' ), wp_get_referer() ) );		exit();	break;	default:		wp_redirect( admin_url( 'ms-admin.php' ) );	break;}?>
<?php/** * Main WordPress Formatting API. * * Handles many functions for formatting output. * * @package WordPress **//** * Replaces common plain text characters into formatted entities * * As an example, * <code> * 'cause today's effort makes it worth tomorrow's "holiday"... * </code> * Becomes: * <code> * &#8217;cause today&#8217;s effort makes it worth tomorrow&#8217;s &#8220;holiday&#8221;&#8230; * </code> * Code within certain html blocks are skipped. * * @since 0.71 * @uses $wp_cockneyreplace Array of formatted entities for certain common phrases * * @param string $text The text to be formatted * @return string The string replaced with html entities */function wptexturize($text) {	global $wp_cockneyreplace;	static $static_setup = false, $opening_quote, $closing_quote, $default_no_texturize_tags, $default_no_texturize_shortcodes, $static_characters, $static_replacements, $dynamic_characters, $dynamic_replacements;	$output = '';	$curl = '';	$textarr = preg_split('/(<.*>|\[.*\])/Us', $text, -1, PREG_SPLIT_DELIM_CAPTURE);	$stop = count($textarr);	// No need to set up these variables more than once	if (!$static_setup) {		/* translators: opening curly quote */		$opening_quote = _x('&#8220;', 'opening curly quote');		/* translators: closing curly quote */		$closing_quote = _x('&#8221;', 'closing curly quote');		$default_no_texturize_tags = array('pre', 'code', 'kbd', 'style', 'script', 'tt');		$default_no_texturize_shortcodes = array('code');		// if a plugin has provided an autocorrect array, use it		if ( isset($wp_cockneyreplace) ) {			$cockney = array_keys($wp_cockneyreplace);			$cockneyreplace = array_values($wp_cockneyreplace);		} else {			$cockney = array("'tain't","'twere","'twas","'tis","'twill","'til","'bout","'nuff","'round","'cause");			$cockneyreplace = array("&#8217;tain&#8217;t","&#8217;twere","&#8217;twas","&#8217;tis","&#8217;twill","&#8217;til","&#8217;bout","&#8217;nuff","&#8217;round","&#8217;cause");		}		$static_characters = array_merge(array('---', ' -- ', '--', ' - ', 'xn&#8211;', '...', '``', '\'\'', ' (tm)'), $cockney);		$static_replacements = array_merge(array('&#8212;', ' &#8212; ', '&#8211;', ' &#8211; ', 'xn--', '&#8230;', $opening_quote, $closing_quote, ' &#8482;'), $cockneyreplace);		$dynamic_characters = array('/\'(\d\d(?:&#8217;|\')?s)/', '/\'(\d+)/', '/(\s|\A|[([{<]|")\'/', '/(\d+)"/', '/(\d+)\'/', '/(\S)\'([^\'\s])/', '/(\s|\A|[([{<])"(?!\s)/', '/"(\s|\S|\Z)/', '/\'([\s.]|\Z)/', '/\b(\d+)x(\d+)\b/');		$dynamic_replacements = array('&#8217;$1','&#8217;$1', '$1&#8216;', '$1&#8243;', '$1&#8242;', '$1&#8217;$2', '$1' . $opening_quote . '$2', $closing_quote . '$1', '&#8217;$1', '$1&#215;$2');		$static_setup = true;	}	// Transform into regexp sub-expression used in _wptexturize_pushpop_element	// Must do this everytime in case plugins use these filters in a context sensitive manner	$no_texturize_tags = '(' . implode('|', apply_filters('no_texturize_tags', $default_no_texturize_tags) ) . ')';	$no_texturize_shortcodes = '(' . implode('|', apply_filters('no_texturize_shortcodes', $default_no_texturize_shortcodes) ) . ')';	$no_texturize_tags_stack = array();	$no_texturize_shortcodes_stack = array();	for ( $i = 0; $i < $stop; $i++ ) {		$curl = $textarr[$i];		if ( !empty($curl) && '<' != $curl{0} && '[' != $curl{0}				&& empty($no_texturize_shortcodes_stack) && empty($no_texturize_tags_stack)) {			// This is not a tag, nor is the texturization disabled			// static strings			$curl = str_replace($static_characters, $static_replacements, $curl);			// regular expressions			$curl = preg_replace($dynamic_characters, $dynamic_replacements, $curl);		} elseif (!empty($curl)) {			/*			 * Only call _wptexturize_pushpop_element if first char is correct			 * tag opening			 */			if ('<' == $curl{0})				_wptexturize_pushpop_element($curl, $no_texturize_tags_stack, $no_texturize_tags, '<', '>');			elseif ('[' == $curl{0})				_wptexturize_pushpop_element($curl, $no_texturize_shortcodes_stack, $no_texturize_shortcodes, '[', ']');		}		$curl = preg_replace('/&([^#])(?![a-zA-Z1-4]{1,8};)/', '&#038;$1', $curl);		$output .= $curl;	}	return $output;}/** * Search for disabled element tags. Push element to stack on tag open and pop * on tag close. Assumes first character of $text is tag opening. * * @access private * @since 2.9.0 * * @param string $text Text to check. First character is assumed to be $opening * @param array $stack Array used as stack of opened tag elements * @param string $disabled_elements Tags to match against formatted as regexp sub-expression * @param string $opening Tag opening character, assumed to be 1 character long * @param string $opening Tag closing  character * @return object */function _wptexturize_pushpop_element($text, &$stack, $disabled_elements, $opening = '<', $closing = '>') {	// Check if it is a closing tag -- otherwise assume opening tag	if (strncmp($opening . '/', $text, 2)) {		// Opening? Check $text+1 against disabled elements		if (preg_match('/^' . $disabled_elements . '\b/', substr($text, 1), $matches)) {			/*			 * This disables texturize until we find a closing tag of our type			 * (e.g. <pre>) even if there was invalid nesting before that			 *			 * Example: in the case <pre>sadsadasd</code>"baba"</pre>			 *          "baba" won't be texturize			 */			array_push($stack, $matches[1]);		}	} else {		// Closing? Check $text+2 against disabled elements		$c = preg_quote($closing, '/');		if (preg_match('/^' . $disabled_elements . $c . '/', substr($text, 2), $matches)) {			$last = array_pop($stack);			// Make sure it matches the opening tag			if ($last != $matches[1])				array_push($stack, $last);		}	}}/** * Accepts matches array from preg_replace_callback in wpautop() or a string. * * Ensures that the contents of a <<pre>>...<</pre>> HTML block are not * converted into paragraphs or line-breaks. * * @since 1.2.0 * * @param array|string $matches The array or string * @return string The pre block without paragraph/line-break conversion. */function clean_pre($matches) {	if ( is_array($matches) )		$text = $matches[1] . $matches[2] . "</pre>";	else		$text = $matches;	$text = str_replace('<br />', '', $text);	$text = str_replace('<p>', "\n", $text);	$text = str_replace('</p>', '', $text);	return $text;}/** * Replaces double line-breaks with paragraph elements. * * A group of regex replaces used to identify text formatted with newlines and * replace double line-breaks with HTML paragraph tags. The remaining * line-breaks after conversion become <<br />> tags, unless $br is set to '0' * or 'false'. * * @since 0.71 * * @param string $pee The text which has to be formatted. * @param int|bool $br Optional. If set, this will convert all remaining line-breaks after paragraphing. Default true. * @return string Text which has been converted into correct paragraph tags. */function wpautop($pee, $br = 1) {	if ( trim($pee) === '' )		return '';	$pee = $pee . "\n"; // just to make things a little easier, pad the end	$pee = preg_replace('|<br />\s*<br />|', "\n\n", $pee);	// Space things out a little	$allblocks = '(?:table|thead|tfoot|caption|col|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|select|option|form|map|area|blockquote|address|math|style|input|p|h[1-6]|hr|fieldset|legend|section|article|aside|hgroup|header|footer|nav|figure|figcaption|details|menu|summary)';	$pee = preg_replace('!(<' . $allblocks . '[^>]*>)!', "\n$1", $pee);	$pee = preg_replace('!(</' . $allblocks . '>)!', "$1\n\n", $pee);	$pee = str_replace(array("\r\n", "\r"), "\n", $pee); // cross-platform newlines	if ( strpos($pee, '<object') !== false ) {		$pee = preg_replace('|\s*<param([^>]*)>\s*|', "<param$1>", $pee); // no pee inside object/embed		$pee = preg_replace('|\s*</embed>\s*|', '</embed>', $pee);	}	$pee = preg_replace("/\n\n+/", "\n\n", $pee); // take care of duplicates	// make paragraphs, including one at the end	$pees = preg_split('/\n\s*\n/', $pee, -1, PREG_SPLIT_NO_EMPTY);	$pee = '';	foreach ( $pees as $tinkle )		$pee .= '<p>' . trim($tinkle, "\n") . "</p>\n";	$pee = preg_replace('|<p>\s*</p>|', '', $pee); // under certain strange conditions it could create a P of entirely whitespace	$pee = preg_replace('!<p>([^<]+)</(div|address|form)>!', "<p>$1</p></$2>", $pee);	$pee = preg_replace('!<p>\s*(</?' . $allblocks . '[^>]*>)\s*</p>!', "$1", $pee); // don't pee all over a tag	$pee = preg_replace("|<p>(<li.+?)</p>|", "$1", $pee); // problem with nested lists	$pee = preg_replace('|<p><blockquote([^>]*)>|i', "<blockquote$1><p>", $pee);	$pee = str_replace('</blockquote></p>', '</p></blockquote>', $pee);	$pee = preg_replace('!<p>\s*(</?' . $allblocks . '[^>]*>)!', "$1", $pee);	$pee = preg_replace('!(</?' . $allblocks . '[^>]*>)\s*</p>!', "$1", $pee);	if ($br) {		$pee = preg_replace_callback('/<(script|style).*?<\/\\1>/s', create_function('$matches', 'return str_replace("\n", "<WPPreserveNewline />", $matches[0]);'), $pee);		$pee = preg_replace('|(?<!<br />)\s*\n|', "<br />\n", $pee); // optionally make line breaks		$pee = str_replace('<WPPreserveNewline />', "\n", $pee);	}	$pee = preg_replace('!(</?' . $allblocks . '[^>]*>)\s*<br />!', "$1", $pee);	$pee = preg_replace('!<br />(\s*</?(?:p|li|div|dl|dd|dt|th|pre|td|ul|ol)[^>]*>)!', '$1', $pee);	if (strpos($pee, '<pre') !== false)		$pee = preg_replace_callback('!(<pre[^>]*>)(.*?)</pre>!is', 'clean_pre', $pee );	$pee = preg_replace( "|\n</p>$|", '</p>', $pee );	return $pee;}/** * Don't auto-p wrap shortcodes that stand alone * * Ensures that shortcodes are not wrapped in <<p>>...<</p>>. * * @since 2.9.0 * * @param string $pee The content. * @return string The filtered content. */function shortcode_unautop($pee) {	global $shortcode_tags;	if ( !empty($shortcode_tags) && is_array($shortcode_tags) ) {		$tagnames = array_keys($shortcode_tags);		$tagregexp = join( '|', array_map('preg_quote', $tagnames) );		$pee = preg_replace('/<p>\\s*?(\\[(' . $tagregexp . ')\\b.*?\\/?\\](?:.+?\\[\\/\\2\\])?)\\s*<\\/p>/s', '$1', $pee);	}	return $pee;}/** * Checks to see if a string is utf8 encoded. * * NOTE: This function checks for 5-Byte sequences, UTF8 *       has Bytes Sequences with a maximum length of 4. * * @author bmorel at ssi dot fr (modified) * @since 1.2.1 * * @param string $str The string to be checked * @return bool True if $str fits a UTF-8 model, false otherwise. */function seems_utf8($str) {	$length = strlen($str);	for ($i=0; $i < $length; $i++) {		$c = ord($str[$i]);		if ($c < 0x80) $n = 0; # 0bbbbbbb		elseif (($c & 0xE0) == 0xC0) $n=1; # 110bbbbb		elseif (($c & 0xF0) == 0xE0) $n=2; # 1110bbbb		elseif (($c & 0xF8) == 0xF0) $n=3; # 11110bbb		elseif (($c & 0xFC) == 0xF8) $n=4; # 111110bb		elseif (($c & 0xFE) == 0xFC) $n=5; # 1111110b		else return false; # Does not match any model		for ($j=0; $j<$n; $j++) { # n bytes matching 10bbbbbb follow ?			if ((++$i == $length) || ((ord($str[$i]) & 0xC0) != 0x80))				return false;		}	}	return true;}/** * Converts a number of special characters into their HTML entities. * * Specifically deals with: &, <, >, ", and '. * * $quote_style can be set to ENT_COMPAT to encode " to * &quot;, or ENT_QUOTES to do both. Default is ENT_NOQUOTES where no quotes are encoded. * * @since 1.2.2 * * @param string $string The text which is to be encoded. * @param mixed $quote_style Optional. Converts double quotes if set to ENT_COMPAT, both single and double if set to ENT_QUOTES or none if set to ENT_NOQUOTES. Also compatible with old values; converting single quotes if set to 'single', double if set to 'double' or both if otherwise set. Default is ENT_NOQUOTES. * @param string $charset Optional. The character encoding of the string. Default is false. * @param boolean $double_encode Optional. Whether to encode existing html entities. Default is false. * @return string The encoded text with HTML entities. */function _wp_specialchars( $string, $quote_style = ENT_NOQUOTES, $charset = false, $double_encode = false ) {	$string = (string) $string;	if ( 0 === strlen( $string ) ) {		return '';	}	// Don't bother if there are no specialchars - saves some processing	if ( !preg_match( '/[&<>"\']/', $string ) ) {		return $string;	}	// Account for the previous behaviour of the function when the $quote_style is not an accepted value	if ( empty( $quote_style ) ) {		$quote_style = ENT_NOQUOTES;	} elseif ( !in_array( $quote_style, array( 0, 2, 3, 'single', 'double' ), true ) ) {		$quote_style = ENT_QUOTES;	}	// Store the site charset as a static to avoid multiple calls to wp_load_alloptions()	if ( !$charset ) {		static $_charset;		if ( !isset( $_charset ) ) {			$alloptions = wp_load_alloptions();			$_charset = isset( $alloptions['blog_charset'] ) ? $alloptions['blog_charset'] : '';		}		$charset = $_charset;	}	if ( in_array( $charset, array( 'utf8', 'utf-8', 'UTF8' ) ) ) {		$charset = 'UTF-8';	}	$_quote_style = $quote_style;	if ( $quote_style === 'double' ) {		$quote_style = ENT_COMPAT;		$_quote_style = ENT_COMPAT;	} elseif ( $quote_style === 'single' ) {		$quote_style = ENT_NOQUOTES;	}	// Handle double encoding ourselves	if ( !$double_encode ) {		$string = wp_specialchars_decode( $string, $_quote_style );		/* Critical */		// The previous line decodes &amp;phrase; into &phrase;  We must guarantee that &phrase; is valid before proceeding.		$string = wp_kses_normalize_entities($string);		// Now proceed with custom double-encoding silliness		$string = preg_replace( '/&(#?x?[0-9a-z]+);/i', '|wp_entity|$1|/wp_entity|', $string );	}	$string = @htmlspecialchars( $string, $quote_style, $charset );	// Handle double encoding ourselves	if ( !$double_encode ) {		$string = str_replace( array( '|wp_entity|', '|/wp_entity|' ), array( '&', ';' ), $string );	}	// Backwards compatibility	if ( 'single' === $_quote_style ) {		$string = str_replace( "'", '&#039;', $string );	}	return $string;}/** * Converts a number of HTML entities into their special characters. * * Specifically deals with: &, <, >, ", and '. * * $quote_style can be set to ENT_COMPAT to decode " entities, * or ENT_QUOTES to do both " and '. Default is ENT_NOQUOTES where no quotes are decoded. * * @since 2.8 * * @param string $string The text which is to be decoded. * @param mixed $quote_style Optional. Converts double quotes if set to ENT_COMPAT, both single and double if set to ENT_QUOTES or none if set to ENT_NOQUOTES. Also compatible with old _wp_specialchars() values; converting single quotes if set to 'single', double if set to 'double' or both if otherwise set. Default is ENT_NOQUOTES. * @return string The decoded text without HTML entities. */function wp_specialchars_decode( $string, $quote_style = ENT_NOQUOTES ) {	$string = (string) $string;	if ( 0 === strlen( $string ) ) {		return '';	}	// Don't bother if there are no entities - saves a lot of processing	if ( strpos( $string, '&' ) === false ) {		return $string;	}	// Match the previous behaviour of _wp_specialchars() when the $quote_style is not an accepted value	if ( empty( $quote_style ) ) {		$quote_style = ENT_NOQUOTES;	} elseif ( !in_array( $quote_style, array( 0, 2, 3, 'single', 'double' ), true ) ) {		$quote_style = ENT_QUOTES;	}	// More complete than get_html_translation_table( HTML_SPECIALCHARS )	$single = array( '&#039;'  => '\'', '&#x27;' => '\'' );	$single_preg = array( '/&#0*39;/'  => '&#039;', '/&#x0*27;/i' => '&#x27;' );	$double = array( '&quot;' => '"', '&#034;'  => '"', '&#x22;' => '"' );	$double_preg = array( '/&#0*34;/'  => '&#034;', '/&#x0*22;/i' => '&#x22;' );	$others = array( '&lt;'   => '<', '&#060;'  => '<', '&gt;'   => '>', '&#062;'  => '>', '&amp;'  => '&', '&#038;'  => '&', '&#x26;' => '&' );	$others_preg = array( '/&#0*60;/'  => '&#060;', '/&#0*62;/'  => '&#062;', '/&#0*38;/'  => '&#038;', '/&#x0*26;/i' => '&#x26;' );	if ( $quote_style === ENT_QUOTES ) {		$translation = array_merge( $single, $double, $others );		$translation_preg = array_merge( $single_preg, $double_preg, $others_preg );	} elseif ( $quote_style === ENT_COMPAT || $quote_style === 'double' ) {		$translation = array_merge( $double, $others );		$translation_preg = array_merge( $double_preg, $others_preg );	} elseif ( $quote_style === 'single' ) {		$translation = array_merge( $single, $others );		$translation_preg = array_merge( $single_preg, $others_preg );	} elseif ( $quote_style === ENT_NOQUOTES ) {		$translation = $others;		$translation_preg = $others_preg;	}	// Remove zero padding on numeric entities	$string = preg_replace( array_keys( $translation_preg ), array_values( $translation_preg ), $string );	// Replace characters according to translation table	return strtr( $string, $translation );}/** * Checks for invalid UTF8 in a string. * * @since 2.8 * * @param string $string The text which is to be checked. * @param boolean $strip Optional. Whether to attempt to strip out invalid UTF8. Default is false. * @return string The checked text. */function wp_check_invalid_utf8( $string, $strip = false ) {	$string = (string) $string;	if ( 0 === strlen( $string ) ) {		return '';	}	// Store the site charset as a static to avoid multiple calls to get_option()	static $is_utf8;	if ( !isset( $is_utf8 ) ) {		$is_utf8 = in_array( get_option( 'blog_charset' ), array( 'utf8', 'utf-8', 'UTF8', 'UTF-8' ) );	}	if ( !$is_utf8 ) {		return $string;	}	// Check for support for utf8 in the installed PCRE library once and store the result in a static	static $utf8_pcre;	if ( !isset( $utf8_pcre ) ) {		$utf8_pcre = @preg_match( '/^./u', 'a' );	}	// We can't demand utf8 in the PCRE installation, so just return the string in those cases	if ( !$utf8_pcre ) {		return $string;	}	// preg_match fails when it encounters invalid UTF8 in $string	if ( 1 === @preg_match( '/^./us', $string ) ) {		return $string;	}	// Attempt to strip the bad chars if requested (not recommended)	if ( $strip && function_exists( 'iconv' ) ) {		return iconv( 'utf-8', 'utf-8', $string );	}	return '';}/** * Encode the Unicode values to be used in the URI. * * @since 1.5.0 * * @param string $utf8_string * @param int $length Max length of the string * @return string String with Unicode encoded for URI. */function utf8_uri_encode( $utf8_string, $length = 0 ) {	$unicode = '';	$values = array();	$num_octets = 1;	$unicode_length = 0;	$string_length = strlen( $utf8_string );	for ($i = 0; $i < $string_length; $i++ ) {		$value = ord( $utf8_string[ $i ] );		if ( $value < 128 ) {			if ( $length && ( $unicode_length >= $length ) )				break;			$unicode .= chr($value);			$unicode_length++;		} else {			if ( count( $values ) == 0 ) $num_octets = ( $value < 224 ) ? 2 : 3;			$values[] = $value;			if ( $length && ( $unicode_length + ($num_octets * 3) ) > $length )				break;			if ( count( $values ) == $num_octets ) {				if ($num_octets == 3) {					$unicode .= '%' . dechex($values[0]) . '%' . dechex($values[1]) . '%' . dechex($values[2]);					$unicode_length += 9;				} else {					$unicode .= '%' . dechex($values[0]) . '%' . dechex($values[1]);					$unicode_length += 6;				}				$values = array();				$num_octets = 1;			}		}	}	return $unicode;}/** * Converts all accent characters to ASCII characters. * * If there are no accent characters, then the string given is just returned. * * @since 1.2.1 * * @param string $string Text that might have accent characters * @return string Filtered string with replaced "nice" characters. */function remove_accents($string) {	if ( !preg_match('/[\x80-\xff]/', $string) )		return $string;	if (seems_utf8($string)) {		$chars = array(		// Decompositions for Latin-1 Supplement		chr(195).chr(128) => 'A', chr(195).chr(129) => 'A',		chr(195).chr(130) => 'A', chr(195).chr(131) => 'A',		chr(195).chr(132) => 'A', chr(195).chr(133) => 'A',		chr(195).chr(135) => 'C', chr(195).chr(136) => 'E',		chr(195).chr(137) => 'E', chr(195).chr(138) => 'E',		chr(195).chr(139) => 'E', chr(195).chr(140) => 'I',		chr(195).chr(141) => 'I', chr(195).chr(142) => 'I',		chr(195).chr(143) => 'I', chr(195).chr(145) => 'N',		chr(195).chr(146) => 'O', chr(195).chr(147) => 'O',		chr(195).chr(148) => 'O', chr(195).chr(149) => 'O',		chr(195).chr(150) => 'O', chr(195).chr(153) => 'U',		chr(195).chr(154) => 'U', chr(195).chr(155) => 'U',		chr(195).chr(156) => 'U', chr(195).chr(157) => 'Y',		chr(195).chr(159) => 's', chr(195).chr(160) => 'a',		chr(195).chr(161) => 'a', chr(195).chr(162) => 'a',		chr(195).chr(163) => 'a', chr(195).chr(164) => 'a',		chr(195).chr(165) => 'a', chr(195).chr(167) => 'c',		chr(195).chr(168) => 'e', chr(195).chr(169) => 'e',		chr(195).chr(170) => 'e', chr(195).chr(171) => 'e',		chr(195).chr(172) => 'i', chr(195).chr(173) => 'i',		chr(195).chr(174) => 'i', chr(195).chr(175) => 'i',		chr(195).chr(177) => 'n', chr(195).chr(178) => 'o',		chr(195).chr(179) => 'o', chr(195).chr(180) => 'o',		chr(195).chr(181) => 'o', chr(195).chr(182) => 'o',		chr(195).chr(182) => 'o', chr(195).chr(185) => 'u',		chr(195).chr(186) => 'u', chr(195).chr(187) => 'u',		chr(195).chr(188) => 'u', chr(195).chr(189) => 'y',		chr(195).chr(191) => 'y',		// Decompositions for Latin Extended-A		chr(196).chr(128) => 'A', chr(196).chr(129) => 'a',		chr(196).chr(130) => 'A', chr(196).chr(131) => 'a',		chr(196).chr(132) => 'A', chr(196).chr(133) => 'a',		chr(196).chr(134) => 'C', chr(196).chr(135) => 'c',		chr(196).chr(136) => 'C', chr(196).chr(137) => 'c',		chr(196).chr(138) => 'C', chr(196).chr(139) => 'c',		chr(196).chr(140) => 'C', chr(196).chr(141) => 'c',		chr(196).chr(142) => 'D', chr(196).chr(143) => 'd',		chr(196).chr(144) => 'D', chr(196).chr(145) => 'd',		chr(196).chr(146) => 'E', chr(196).chr(147) => 'e',		chr(196).chr(148) => 'E', chr(196).chr(149) => 'e',		chr(196).chr(150) => 'E', chr(196).chr(151) => 'e',		chr(196).chr(152) => 'E', chr(196).chr(153) => 'e',		chr(196).chr(154) => 'E', chr(196).chr(155) => 'e',		chr(196).chr(156) => 'G', chr(196).chr(157) => 'g',		chr(196).chr(158) => 'G', chr(196).chr(159) => 'g',		chr(196).chr(160) => 'G', chr(196).chr(161) => 'g',		chr(196).chr(162) => 'G', chr(196).chr(163) => 'g',		chr(196).chr(164) => 'H', chr(196).chr(165) => 'h',		chr(196).chr(166) => 'H', chr(196).chr(167) => 'h',		chr(196).chr(168) => 'I', chr(196).chr(169) => 'i',		chr(196).chr(170) => 'I', chr(196).chr(171) => 'i',		chr(196).chr(172) => 'I', chr(196).chr(173) => 'i',		chr(196).chr(174) => 'I', chr(196).chr(175) => 'i',		chr(196).chr(176) => 'I', chr(196).chr(177) => 'i',		chr(196).chr(178) => 'IJ',chr(196).chr(179) => 'ij',		chr(196).chr(180) => 'J', chr(196).chr(181) => 'j',		chr(196).chr(182) => 'K', chr(196).chr(183) => 'k',		chr(196).chr(184) => 'k', chr(196).chr(185) => 'L',		chr(196).chr(186) => 'l', chr(196).chr(187) => 'L',		chr(196).chr(188) => 'l', chr(196).chr(189) => 'L',		chr(196).chr(190) => 'l', chr(196).chr(191) => 'L',		chr(197).chr(128) => 'l', chr(197).chr(129) => 'L',		chr(197).chr(130) => 'l', chr(197).chr(131) => 'N',		chr(197).chr(132) => 'n', chr(197).chr(133) => 'N',		chr(197).chr(134) => 'n', chr(197).chr(135) => 'N',		chr(197).chr(136) => 'n', chr(197).chr(137) => 'N',		chr(197).chr(138) => 'n', chr(197).chr(139) => 'N',		chr(197).chr(140) => 'O', chr(197).chr(141) => 'o',		chr(197).chr(142) => 'O', chr(197).chr(143) => 'o',		chr(197).chr(144) => 'O', chr(197).chr(145) => 'o',		chr(197).chr(146) => 'OE',chr(197).chr(147) => 'oe',		chr(197).chr(148) => 'R',chr(197).chr(149) => 'r',		chr(197).chr(150) => 'R',chr(197).chr(151) => 'r',		chr(197).chr(152) => 'R',chr(197).chr(153) => 'r',		chr(197).chr(154) => 'S',chr(197).chr(155) => 's',		chr(197).chr(156) => 'S',chr(197).chr(157) => 's',		chr(197).chr(158) => 'S',chr(197).chr(159) => 's',		chr(197).chr(160) => 'S', chr(197).chr(161) => 's',		chr(197).chr(162) => 'T', chr(197).chr(163) => 't',		chr(197).chr(164) => 'T', chr(197).chr(165) => 't',		chr(197).chr(166) => 'T', chr(197).chr(167) => 't',		chr(197).chr(168) => 'U', chr(197).chr(169) => 'u',		chr(197).chr(170) => 'U', chr(197).chr(171) => 'u',		chr(197).chr(172) => 'U', chr(197).chr(173) => 'u',		chr(197).chr(174) => 'U', chr(197).chr(175) => 'u',		chr(197).chr(176) => 'U', chr(197).chr(177) => 'u',		chr(197).chr(178) => 'U', chr(197).chr(179) => 'u',		chr(197).chr(180) => 'W', chr(197).chr(181) => 'w',		chr(197).chr(182) => 'Y', chr(197).chr(183) => 'y',		chr(197).chr(184) => 'Y', chr(197).chr(185) => 'Z',		chr(197).chr(186) => 'z', chr(197).chr(187) => 'Z',		chr(197).chr(188) => 'z', chr(197).chr(189) => 'Z',		chr(197).chr(190) => 'z', chr(197).chr(191) => 's',		// Euro Sign		chr(226).chr(130).chr(172) => 'E',		// GBP (Pound) Sign		chr(194).chr(163) => '');		$string = strtr($string, $chars);	} else {		// Assume ISO-8859-1 if not UTF-8		$chars['in'] = chr(128).chr(131).chr(138).chr(142).chr(154).chr(158)			.chr(159).chr(162).chr(165).chr(181).chr(192).chr(193).chr(194)			.chr(195).chr(196).chr(197).chr(199).chr(200).chr(201).chr(202)			.chr(203).chr(204).chr(205).chr(206).chr(207).chr(209).chr(210)			.chr(211).chr(212).chr(213).chr(214).chr(216).chr(217).chr(218)			.chr(219).chr(220).chr(221).chr(224).chr(225).chr(226).chr(227)			.chr(228).chr(229).chr(231).chr(232).chr(233).chr(234).chr(235)			.chr(236).chr(237).chr(238).chr(239).chr(241).chr(242).chr(243)			.chr(244).chr(245).chr(246).chr(248).chr(249).chr(250).chr(251)			.chr(252).chr(253).chr(255);		$chars['out'] = "EfSZszYcYuAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy";		$string = strtr($string, $chars['in'], $chars['out']);		$double_chars['in'] = array(chr(140), chr(156), chr(198), chr(208), chr(222), chr(223), chr(230), chr(240), chr(254));		$double_chars['out'] = array('OE', 'oe', 'AE', 'DH', 'TH', 'ss', 'ae', 'dh', 'th');		$string = str_replace($double_chars['in'], $double_chars['out'], $string);	}	return $string;}/** * Sanitizes a filename replacing whitespace with dashes * * Removes special characters that are illegal in filenames on certain * operating systems and special characters requiring special escaping * to manipulate at the command line. Replaces spaces and consecutive * dashes with a single dash. Trim period, dash and underscore from beginning * and end of filename. * * @since 2.1.0 * * @param string $filename The filename to be sanitized * @return string The sanitized filename */function sanitize_file_name( $filename ) {	$filename_raw = $filename;	$special_chars = array("?", "[", "]", "/", "\\", "=", "<", ">", ":", ";", ",", "'", "\"", "&", "$", "#", "*", "(", ")", "|", "~", "`", "!", "{", "}", chr(0));	$special_chars = apply_filters('sanitize_file_name_chars', $special_chars, $filename_raw);	$filename = str_replace($special_chars, '', $filename);	$filename = preg_replace('/[\s-]+/', '-', $filename);	$filename = trim($filename, '.-_');	// Split the filename into a base and extension[s]	$parts = explode('.', $filename);	// Return if only one extension	if ( count($parts) <= 2 )		return apply_filters('sanitize_file_name', $filename, $filename_raw);	// Process multiple extensions	$filename = array_shift($parts);	$extension = array_pop($parts);	$mimes = get_allowed_mime_types();	// Loop over any intermediate extensions.  Munge them with a trailing underscore if they are a 2 - 5 character	// long alpha string not in the extension whitelist.	foreach ( (array) $parts as $part) {		$filename .= '.' . $part;		if ( preg_match("/^[a-zA-Z]{2,5}\d?$/", $part) ) {			$allowed = false;			foreach ( $mimes as $ext_preg => $mime_match ) {				$ext_preg = '!(^' . $ext_preg . ')$!i';				if ( preg_match( $ext_preg, $part ) ) {					$allowed = true;					break;				}			}			if ( !$allowed )				$filename .= '_';		}	}	$filename .= '.' . $extension;	return apply_filters('sanitize_file_name', $filename, $filename_raw);}/** * Sanitize username stripping out unsafe characters. * * If $strict is true, only alphanumeric characters (as well as _, space, ., -, * @) are returned. * Removes tags, octets, entities, and if strict is enabled, will remove all * non-ASCII characters. After sanitizing, it passes the username, raw username * (the username in the parameter), and the strict parameter as parameters for * the filter. * * @since 2.0.0 * @uses apply_filters() Calls 'sanitize_user' hook on username, raw username, *		and $strict parameter. * * @param string $username The username to be sanitized. * @param bool $strict If set limits $username to specific characters. Default false. * @return string The sanitized username, after passing through filters. */function sanitize_user( $username, $strict = false ) {	$raw_username = $username;	$username = wp_strip_all_tags( $username );	$username = remove_accents( $username );	// Kill octets	$username = preg_replace( '|%([a-fA-F0-9][a-fA-F0-9])|', '', $username );	$username = preg_replace( '/&.+?;/', '', $username ); // Kill entities	// If strict, reduce to ASCII for max portability.	if ( $strict )		$username = preg_replace( '|[^a-z0-9 _.\-@]|i', '', $username );	// Consolidate contiguous whitespace	$username = preg_replace( '|\s+|', ' ', $username );	return apply_filters( 'sanitize_user', $username, $raw_username, $strict );}/** * Sanitize a string key. * * Keys are used as internal identifiers. They should be lowercase ASCII.  Dashes and underscores are allowed. * * @since 3.0.0 * * @param string $key String key * @return string Sanitized key */function sanitize_key( $key ) {	$raw_key = $key;	$key = wp_strip_all_tags($key);	// Kill octets	$key = preg_replace('|%([a-fA-F0-9][a-fA-F0-9])|', '', $key);	$key = preg_replace('/&.+?;/', '', $key); // Kill entities	$key = preg_replace('|[^a-z0-9 _.\-@]|i', '', $key);	// Consolidate contiguous whitespace	$key = preg_replace('|\s+|', ' ', $key);	return apply_filters('sanitize_key', $key, $raw_key);}/** * Sanitizes title or use fallback title. * * Specifically, HTML and PHP tags are stripped. Further actions can be added * via the plugin API. If $title is empty and $fallback_title is set, the latter * will be used. * * @since 1.0.0 * * @param string $title The string to be sanitized. * @param string $fallback_title Optional. A title to use if $title is empty. * @return string The sanitized string. */function sanitize_title($title, $fallback_title = '') {	$raw_title = $title;	$title = strip_tags($title);	$title = apply_filters('sanitize_title', $title, $raw_title);	if ( '' === $title || false === $title )		$title = $fallback_title;	return $title;}/** * Sanitizes title, replacing whitespace with dashes. * * Limits the output to alphanumeric characters, underscore (_) and dash (-). * Whitespace becomes a dash. * * @since 1.2.0 * * @param string $title The title to be sanitized. * @return string The sanitized title. */function sanitize_title_with_dashes($title) {	$title = strip_tags($title);	// Preserve escaped octets.	$title = preg_replace('|%([a-fA-F0-9][a-fA-F0-9])|', '---$1---', $title);	// Remove percent signs that are not part of an octet.	$title = str_replace('%', '', $title);	// Restore octets.	$title = preg_replace('|---([a-fA-F0-9][a-fA-F0-9])---|', '%$1', $title);	$title = remove_accents($title);	if (seems_utf8($title)) {		if (function_exists('mb_strtolower')) {			$title = mb_strtolower($title, 'UTF-8');		}		$title = utf8_uri_encode($title, 200);	}	$title = strtolower($title);	$title = preg_replace('/&.+?;/', '', $title); // kill entities	$title = str_replace('.', '-', $title);	$title = preg_replace('/[^%a-z0-9 _-]/', '', $title);	$title = preg_replace('/\s+/', '-', $title);	$title = preg_replace('|-+|', '-', $title);	$title = trim($title, '-');	return $title;}/** * Ensures a string is a valid SQL order by clause. * * Accepts one or more columns, with or without ASC/DESC, and also accepts * RAND(). * * @since 2.5.1 * * @param string $orderby Order by string to be checked. * @return string|false Returns the order by clause if it is a match, false otherwise. */function sanitize_sql_orderby( $orderby ){	preg_match('/^\s*([a-z0-9_]+(\s+(ASC|DESC))?(\s*,\s*|\s*$))+|^\s*RAND\(\s*\)\s*$/i', $orderby, $obmatches);	if ( !$obmatches )		return false;	return $orderby;}/** * Santizes a html classname to ensure it only contains valid characters * * Strips the string down to A-Z,a-z,0-9,'-' if this results in an empty * string then it will return the alternative value supplied. * * @todo Expand to support the full range of CDATA that a class attribute can contain. * * @since 2.8.0 * * @param string $class The classname to be sanitized * @param string $fallback Optional. The value to return if the sanitization end's up as an empty string. * 	Defaults to an empty string. * @return string The sanitized value */function sanitize_html_class( $class, $fallback = '' ) {	//Strip out any % encoded octets	$sanitized = preg_replace('|%[a-fA-F0-9][a-fA-F0-9]|', '', $class);	//Limit to A-Z,a-z,0-9,'-'	$sanitized = preg_replace('/[^A-Za-z0-9-]/', '', $sanitized);	if ( '' == $sanitized )		$sanitized = $fallback;	return apply_filters( 'sanitize_html_class', $sanitized, $class, $fallback );}/** * Converts a number of characters from a string. * * Metadata tags <<title>> and <<category>> are removed, <<br>> and <<hr>> are * converted into correct XHTML and Unicode characters are converted to the * valid range. * * @since 0.71 * * @param string $content String of characters to be converted. * @param string $deprecated Not used. * @return string Converted string. */function convert_chars($content, $deprecated = '') {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '0.71' );	// Translation of invalid Unicode references range to valid range	$wp_htmltranswinuni = array(	'&#128;' => '&#8364;', // the Euro sign	'&#129;' => '',	'&#130;' => '&#8218;', // these are Windows CP1252 specific characters	'&#131;' => '&#402;',  // they would look weird on non-Windows browsers	'&#132;' => '&#8222;',	'&#133;' => '&#8230;',	'&#134;' => '&#8224;',	'&#135;' => '&#8225;',	'&#136;' => '&#710;',	'&#137;' => '&#8240;',	'&#138;' => '&#352;',	'&#139;' => '&#8249;',	'&#140;' => '&#338;',	'&#141;' => '',	'&#142;' => '&#382;',	'&#143;' => '',	'&#144;' => '',	'&#145;' => '&#8216;',	'&#146;' => '&#8217;',	'&#147;' => '&#8220;',	'&#148;' => '&#8221;',	'&#149;' => '&#8226;',	'&#150;' => '&#8211;',	'&#151;' => '&#8212;',	'&#152;' => '&#732;',	'&#153;' => '&#8482;',	'&#154;' => '&#353;',	'&#155;' => '&#8250;',	'&#156;' => '&#339;',	'&#157;' => '',	'&#158;' => '',	'&#159;' => '&#376;'	);	// Remove metadata tags	$content = preg_replace('/<title>(.+?)<\/title>/','',$content);	$content = preg_replace('/<category>(.+?)<\/category>/','',$content);	// Converts lone & characters into &#38; (a.k.a. &amp;)	$content = preg_replace('/&([^#])(?![a-z1-4]{1,8};)/i', '&#038;$1', $content);	// Fix Word pasting	$content = strtr($content, $wp_htmltranswinuni);	// Just a little XHTML help	$content = str_replace('<br>', '<br />', $content);	$content = str_replace('<hr>', '<hr />', $content);	return $content;}/** * Will only balance the tags if forced to and the option is set to balance tags. * * The option 'use_balanceTags' is used for whether the tags will be balanced. * Both the $force parameter and 'use_balanceTags' option will have to be true * before the tags will be balanced. * * @since 0.71 * * @param string $text Text to be balanced * @param bool $force Forces balancing, ignoring the value of the option. Default false. * @return string Balanced text */function balanceTags( $text, $force = false ) {	if ( !$force && get_option('use_balanceTags') == 0 )		return $text;	return force_balance_tags( $text );}/** * Balances tags of string using a modified stack. * * @since 2.0.4 * * @author Leonard Lin <leonard@acm.org> * @license GPL v2.0 * @copyright November 4, 2001 * @version 1.1 * @todo Make better - change loop condition to $text in 1.2 * @internal Modified by Scott Reilly (coffee2code) 02 Aug 2004 *		1.1  Fixed handling of append/stack pop order of end text *			 Added Cleaning Hooks *		1.0  First Version * * @param string $text Text to be balanced. * @return string Balanced text. */function force_balance_tags( $text ) {	$tagstack = array();	$stacksize = 0;	$tagqueue = '';	$newtext = '';	$single_tags = array('br', 'hr', 'img', 'input'); // Known single-entity/self-closing tags	$nestable_tags = array('blockquote', 'div', 'span'); // Tags that can be immediately nested within themselves	// WP bug fix for comments - in case you REALLY meant to type '< !--'	$text = str_replace('< !--', '<    !--', $text);	// WP bug fix for LOVE <3 (and other situations with '<' before a number)	$text = preg_replace('#<([0-9]{1})#', '&lt;$1', $text);	while ( preg_match("/<(\/?[\w:]*)\s*([^>]*)>/", $text, $regex) ) {		$newtext .= $tagqueue;		$i = strpos($text, $regex[0]);		$l = strlen($regex[0]);		// clear the shifter		$tagqueue = '';		// Pop or Push		if ( isset($regex[1][0]) && '/' == $regex[1][0] ) { // End Tag			$tag = strtolower(substr($regex[1],1));			// if too many closing tags			if( $stacksize <= 0 ) {				$tag = '';				// or close to be safe $tag = '/' . $tag;			}			// if stacktop value = tag close value then pop			else if ( $tagstack[$stacksize - 1] == $tag ) { // found closing tag				$tag = '</' . $tag . '>'; // Close Tag				// Pop				array_pop( $tagstack );				$stacksize--;			} else { // closing tag not at top, search for it				for ( $j = $stacksize-1; $j >= 0; $j-- ) {					if ( $tagstack[$j] == $tag ) {					// add tag to tagqueue						for ( $k = $stacksize-1; $k >= $j; $k--) {							$tagqueue .= '</' . array_pop( $tagstack ) . '>';							$stacksize--;						}						break;					}				}				$tag = '';			}		} else { // Begin Tag			$tag = strtolower($regex[1]);			// Tag Cleaning			// If self-closing or '', don't do anything.			if ( substr($regex[2],-1) == '/' || $tag == '' ) {				// do nothing			}			// ElseIf it's a known single-entity tag but it doesn't close itself, do so			elseif ( in_array($tag, $single_tags) ) {				$regex[2] .= '/';			} else {	// Push the tag onto the stack				// If the top of the stack is the same as the tag we want to push, close previous tag				if ( $stacksize > 0 && !in_array($tag, $nestable_tags) && $tagstack[$stacksize - 1] == $tag ) {					$tagqueue = '</' . array_pop ($tagstack) . '>';					$stacksize--;				}				$stacksize = array_push ($tagstack, $tag);			}			// Attributes			$attributes = $regex[2];			if( !empty($attributes) )				$attributes = ' '.$attributes;			$tag = '<' . $tag . $attributes . '>';			//If already queuing a close tag, then put this tag on, too			if ( !empty($tagqueue) ) {				$tagqueue .= $tag;				$tag = '';			}		}		$newtext .= substr($text, 0, $i) . $tag;		$text = substr($text, $i + $l);	}	// Clear Tag Queue	$newtext .= $tagqueue;	// Add Remaining text	$newtext .= $text;	// Empty Stack	while( $x = array_pop($tagstack) )		$newtext .= '</' . $x . '>'; // Add remaining tags to close	// WP fix for the bug with HTML comments	$newtext = str_replace("< !--","<!--",$newtext);	$newtext = str_replace("<    !--","< !--",$newtext);	return $newtext;}/** * Acts on text which is about to be edited. * * Unless $richedit is set, it is simply a holder for the 'format_to_edit' * filter. If $richedit is set true htmlspecialchars() will be run on the * content, converting special characters to HTMl entities. * * @since 0.71 * * @param string $content The text about to be edited. * @param bool $richedit Whether the $content should pass through htmlspecialchars(). Default false. * @return string The text after the filter (and possibly htmlspecialchars()) has been run. */function format_to_edit($content, $richedit = false) {	$content = apply_filters('format_to_edit', $content);	if (! $richedit )		$content = htmlspecialchars($content);	return $content;}/** * Holder for the 'format_to_post' filter. * * @since 0.71 * * @param string $content The text to pass through the filter. * @return string Text returned from the 'format_to_post' filter. */function format_to_post($content) {	$content = apply_filters('format_to_post', $content);	return $content;}/** * Add leading zeros when necessary. * * If you set the threshold to '4' and the number is '10', then you will get * back '0010'. If you set the number to '4' and the number is '5000', then you * will get back '5000'. * * Uses sprintf to append the amount of zeros based on the $threshold parameter * and the size of the number. If the number is large enough, then no zeros will * be appended. * * @since 0.71 * * @param mixed $number Number to append zeros to if not greater than threshold. * @param int $threshold Digit places number needs to be to not have zeros added. * @return string Adds leading zeros to number if needed. */function zeroise($number, $threshold) {	return sprintf('%0'.$threshold.'s', $number);}/** * Adds backslashes before letters and before a number at the start of a string. * * @since 0.71 * * @param string $string Value to which backslashes will be added. * @return string String with backslashes inserted. */function backslashit($string) {	$string = preg_replace('/^([0-9])/', '\\\\\\\\\1', $string);	$string = preg_replace('/([a-z])/i', '\\\\\1', $string);	return $string;}/** * Appends a trailing slash. * * Will remove trailing slash if it exists already before adding a trailing * slash. This prevents double slashing a string or path. * * The primary use of this is for paths and thus should be used for paths. It is * not restricted to paths and offers no specific path support. * * @since 1.2.0 * @uses untrailingslashit() Unslashes string if it was slashed already. * * @param string $string What to add the trailing slash to. * @return string String with trailing slash added. */function trailingslashit($string) {	return untrailingslashit($string) . '/';}/** * Removes trailing slash if it exists. * * The primary use of this is for paths and thus should be used for paths. It is * not restricted to paths and offers no specific path support. * * @since 2.2.0 * * @param string $string What to remove the trailing slash from. * @return string String without the trailing slash. */function untrailingslashit($string) {	return rtrim($string, '/');}/** * Adds slashes to escape strings. * * Slashes will first be removed if magic_quotes_gpc is set, see {@link * http://www.php.net/magic_quotes} for more details. * * @since 0.71 * * @param string $gpc The string returned from HTTP request data. * @return string Returns a string escaped with slashes. */function addslashes_gpc($gpc) {	if ( get_magic_quotes_gpc() )		$gpc = stripslashes($gpc);	return esc_sql($gpc);}/** * Navigates through an array and removes slashes from the values. * * If an array is passed, the array_map() function causes a callback to pass the * value back to the function. The slashes from this value will removed. * * @since 2.0.0 * * @param array|string $value The array or string to be striped. * @return array|string Stripped array (or string in the callback). */function stripslashes_deep($value) {	if ( is_array($value) ) {		$value = array_map('stripslashes_deep', $value);	} elseif ( is_object($value) ) {		$vars = get_object_vars( $value );		foreach ($vars as $key=>$data) {			$value->{$key} = stripslashes_deep( $data );		}	} else {		$value = stripslashes($value);	}	return $value;}/** * Navigates through an array and encodes the values to be used in a URL. * * Uses a callback to pass the value of the array back to the function as a * string. * * @since 2.2.0 * * @param array|string $value The array or string to be encoded. * @return array|string $value The encoded array (or string from the callback). */function urlencode_deep($value) {	$value = is_array($value) ? array_map('urlencode_deep', $value) : urlencode($value);	return $value;}/** * Converts email addresses characters to HTML entities to block spam bots. * * @since 0.71 * * @param string $emailaddy Email address. * @param int $mailto Optional. Range from 0 to 1. Used for encoding. * @return string Converted email address. */function antispambot($emailaddy, $mailto=0) {	$emailNOSPAMaddy = '';	srand ((float) microtime() * 1000000);	for ($i = 0; $i < strlen($emailaddy); $i = $i + 1) {		$j = floor(rand(0, 1+$mailto));		if ($j==0) {			$emailNOSPAMaddy .= '&#'.ord(substr($emailaddy,$i,1)).';';		} elseif ($j==1) {			$emailNOSPAMaddy .= substr($emailaddy,$i,1);		} elseif ($j==2) {			$emailNOSPAMaddy .= '%'.zeroise(dechex(ord(substr($emailaddy, $i, 1))), 2);		}	}	$emailNOSPAMaddy = str_replace('@','&#64;',$emailNOSPAMaddy);	return $emailNOSPAMaddy;}/** * Callback to convert URI match to HTML A element. * * This function was backported from 2.5.0 to 2.3.2. Regex callback for {@link * make_clickable()}. * * @since 2.3.2 * @access private * * @param array $matches Single Regex Match. * @return string HTML A element with URI address. */function _make_url_clickable_cb($matches) {	$url = $matches[2];	$url = esc_url($url);	if ( empty($url) )		return $matches[0];	return $matches[1] . "<a href=\"$url\" rel=\"nofollow\">$url</a>";}/** * Callback to convert URL match to HTML A element. * * This function was backported from 2.5.0 to 2.3.2. Regex callback for {@link * make_clickable()}. * * @since 2.3.2 * @access private * * @param array $matches Single Regex Match. * @return string HTML A element with URL address. */function _make_web_ftp_clickable_cb($matches) {	$ret = '';	$dest = $matches[2];	$dest = 'http://' . $dest;	$dest = esc_url($dest);	if ( empty($dest) )		return $matches[0];	// removed trailing [.,;:)] from URL	if ( in_array( substr($dest, -1), array('.', ',', ';', ':', ')') ) === true ) {		$ret = substr($dest, -1);		$dest = substr($dest, 0, strlen($dest)-1);	}	return $matches[1] . "<a href=\"$dest\" rel=\"nofollow\">$dest</a>$ret";}/** * Callback to convert email address match to HTML A element. * * This function was backported from 2.5.0 to 2.3.2. Regex callback for {@link * make_clickable()}. * * @since 2.3.2 * @access private * * @param array $matches Single Regex Match. * @return string HTML A element with email address. */function _make_email_clickable_cb($matches) {	$email = $matches[2] . '@' . $matches[3];	return $matches[1] . "<a href=\"mailto:$email\">$email</a>";}/** * Convert plaintext URI to HTML links. * * Converts URI, www and ftp, and email addresses. Finishes by fixing links * within links. * * @since 0.71 * * @param string $ret Content to convert URIs. * @return string Content with converted URIs. */function make_clickable($ret) {	$ret = ' ' . $ret;	// in testing, using arrays here was found to be faster	$ret = preg_replace_callback('#(?<=[\s>])(\()?([\w]+?://(?:[\w\\x80-\\xff\#$%&~/=?@\[\](+-]|[.,;:](?![\s<]|(\))?([\s]|$))|(?(1)\)(?![\s<.,;:]|$)|\)))+)#is', '_make_url_clickable_cb', $ret);	$ret = preg_replace_callback('#([\s>])((www|ftp)\.[\w\\x80-\\xff\#$%&~/.\-;:=,?@\[\]+]+)#is', '_make_web_ftp_clickable_cb', $ret);	$ret = preg_replace_callback('#([\s>])([.0-9a-z_+-]+)@(([0-9a-z-]+\.)+[0-9a-z]{2,})#i', '_make_email_clickable_cb', $ret);	// this one is not in an array because we need it to run last, for cleanup of accidental links within links	$ret = preg_replace("#(<a( [^>]+?>|>))<a [^>]+?>([^>]+?)</a></a>#i", "$1$3</a>", $ret);	$ret = trim($ret);	return $ret;}/** * Adds rel nofollow string to all HTML A elements in content. * * @since 1.5.0 * * @param string $text Content that may contain HTML A elements. * @return string Converted content. */function wp_rel_nofollow( $text ) {	// This is a pre save filter, so text is already escaped.	$text = stripslashes($text);	$text = preg_replace_callback('|<a (.+?)>|i', 'wp_rel_nofollow_callback', $text);	$text = esc_sql($text);	return $text;}/** * Callback to used to add rel=nofollow string to HTML A element. * * Will remove already existing rel="nofollow" and rel='nofollow' from the * string to prevent from invalidating (X)HTML. * * @since 2.3.0 * * @param array $matches Single Match * @return string HTML A Element with rel nofollow. */function wp_rel_nofollow_callback( $matches ) {	$text = $matches[1];	$text = str_replace(array(' rel="nofollow"', " rel='nofollow'"), '', $text);	return "<a $text rel=\"nofollow\">";}/** * Convert one smiley code to the icon graphic file equivalent. * * Looks up one smiley code in the $wpsmiliestrans global array and returns an * <img> string for that smiley. * * @global array $wpsmiliestrans * @since 2.8.0 * * @param string $smiley Smiley code to convert to image. * @return string Image string for smiley. */function translate_smiley($smiley) {	global $wpsmiliestrans;	if (count($smiley) == 0) {		return '';	}	$siteurl = get_option( 'siteurl' );	$smiley = trim(reset($smiley));	$img = $wpsmiliestrans[$smiley];	$smiley_masked = esc_attr($smiley);	$srcurl = apply_filters('smilies_src', "$siteurl/wp-includes/images/smilies/$img", $img, $siteurl);	return " <img src='$srcurl' alt='$smiley_masked' class='wp-smiley' /> ";}/** * Convert text equivalent of smilies to images. * * Will only convert smilies if the option 'use_smilies' is true and the global * used in the function isn't empty. * * @since 0.71 * @uses $wp_smiliessearch * * @param string $text Content to convert smilies from text. * @return string Converted content with text smilies replaced with images. */function convert_smilies($text) {	global $wp_smiliessearch;	$output = '';	if ( get_option('use_smilies') && !empty($wp_smiliessearch) ) {		// HTML loop taken from texturize function, could possible be consolidated		$textarr = preg_split("/(<.*>)/U", $text, -1, PREG_SPLIT_DELIM_CAPTURE); // capture the tags as well as in between		$stop = count($textarr);// loop stuff		for ($i = 0; $i < $stop; $i++) {			$content = $textarr[$i];			if ((strlen($content) > 0) && ('<' != $content{0})) { // If it's not a tag				$content = preg_replace_callback($wp_smiliessearch, 'translate_smiley', $content);			}			$output .= $content;		}	} else {		// return default text.		$output = $text;	}	return $output;}/** * Verifies that an email is valid. * * Does not grok i18n domains. Not RFC compliant. * * @since 0.71 * * @param string $email Email address to verify. * @param boolean $deprecated. Deprecated. * @return string|bool Either false or the valid email address. */function is_email( $email, $deprecated = false ) {	if ( ! empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '3.0' );	// Test for the minimum length the email can be	if ( strlen( $email ) < 3 ) {		return apply_filters( 'is_email', false, $email, 'email_too_short' );	}	// Test for an @ character after the first position	if ( strpos( $email, '@', 1 ) === false ) {		return apply_filters( 'is_email', false, $email, 'email_no_at' );	}	// Split out the local and domain parts	list( $local, $domain ) = explode( '@', $email, 2 );	// LOCAL PART	// Test for invalid characters	if ( !preg_match( '/^[a-zA-Z0-9!#$%&\'*+\/=?^_`{|}~\.-]+$/', $local ) ) {		return apply_filters( 'is_email', false, $email, 'local_invalid_chars' );	}	// DOMAIN PART	// Test for sequences of periods	if ( preg_match( '/\.{2,}/', $domain ) ) {		return apply_filters( 'is_email', false, $email, 'domain_period_sequence' );	}	// Test for leading and trailing periods and whitespace	if ( trim( $domain, " \t\n\r\0\x0B." ) !== $domain ) {		return apply_filters( 'is_email', false, $email, 'domain_period_limits' );	}	// Split the domain into subs	$subs = explode( '.', $domain );	// Assume the domain will have at least two subs	if ( 2 > count( $subs ) ) {		return apply_filters( 'is_email', false, $email, 'domain_no_periods' );	}	// Loop through each sub	foreach ( $subs as $sub ) {		// Test for leading and trailing hyphens and whitespace		if ( trim( $sub, " \t\n\r\0\x0B-" ) !== $sub ) {			return apply_filters( 'is_email', false, $email, 'sub_hyphen_limits' );		}		// Test for invalid characters		if ( !preg_match('/^[a-z0-9-]+$/i', $sub ) ) {			return apply_filters( 'is_email', false, $email, 'sub_invalid_chars' );		}	}	// Congratulations your email made it!	return apply_filters( 'is_email', $email, $email, null );}/** * Convert to ASCII from email subjects. * * @since 1.2.0 * @usedby wp_mail() handles charsets in email subjects * * @param string $string Subject line * @return string Converted string to ASCII */function wp_iso_descrambler($string) {	/* this may only work with iso-8859-1, I'm afraid */	if (!preg_match('#\=\?(.+)\?Q\?(.+)\?\=#i', $string, $matches)) {		return $string;	} else {		$subject = str_replace('_', ' ', $matches[2]);		$subject = preg_replace_callback('#\=([0-9a-f]{2})#i', create_function('$match', 'return chr(hexdec(strtolower($match[1])));'), $subject);		return $subject;	}}/** * Returns a date in the GMT equivalent. * * Requires and returns a date in the Y-m-d H:i:s format. Simply subtracts the * value of the 'gmt_offset' option. Return format can be overridden using the * $format parameter. If PHP5 is supported, the function uses the DateTime and * DateTimeZone objects to respect time zone differences in DST. * * @since 1.2.0 * * @uses get_option() to retrieve the the value of 'gmt_offset'. * @param string $string The date to be converted. * @param string $format The format string for the returned date (default is Y-m-d H:i:s) * @return string GMT version of the date provided. */function get_gmt_from_date($string, $format = 'Y-m-d H:i:s') {	preg_match('#([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2}) ([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})#', $string, $matches);	$tz = get_option('timezone_string');	if( class_exists('DateTime') && $tz ) {		//PHP5		date_default_timezone_set( $tz );		$datetime = new DateTime( $string );		$datetime->setTimezone( new DateTimeZone('UTC') );		$offset = $datetime->getOffset();		$datetime->modify( '+' . $offset / 3600 . ' hours');		$string_gmt = gmdate($format, $datetime->format('U'));		date_default_timezone_set('UTC');	}	else {		//PHP4		$string_time = gmmktime($matches[4], $matches[5], $matches[6], $matches[2], $matches[3], $matches[1]);		$string_gmt = gmdate($format, $string_time - get_option('gmt_offset') * 3600);	}	return $string_gmt;}/** * Converts a GMT date into the correct format for the blog. * * Requires and returns in the Y-m-d H:i:s format. Simply adds the value of * gmt_offset.Return format can be overridden using the $format parameter * * @since 1.2.0 * * @param string $string The date to be converted. * @param string $format The format string for the returned date (default is Y-m-d H:i:s) * @return string Formatted date relative to the GMT offset. */function get_date_from_gmt($string, $format = 'Y-m-d H:i:s') {	preg_match('#([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2}) ([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})#', $string, $matches);	$string_time = gmmktime($matches[4], $matches[5], $matches[6], $matches[2], $matches[3], $matches[1]);	$string_localtime = gmdate($format, $string_time + get_option('gmt_offset')*3600);	return $string_localtime;}/** * Computes an offset in seconds from an iso8601 timezone. * * @since 1.5.0 * * @param string $timezone Either 'Z' for 0 offset or 'hhmm'. * @return int|float The offset in seconds. */function iso8601_timezone_to_offset($timezone) {	// $timezone is either 'Z' or '[+|-]hhmm'	if ($timezone == 'Z') {		$offset = 0;	} else {		$sign    = (substr($timezone, 0, 1) == '+') ? 1 : -1;		$hours   = intval(substr($timezone, 1, 2));		$minutes = intval(substr($timezone, 3, 4)) / 60;		$offset  = $sign * 3600 * ($hours + $minutes);	}	return $offset;}/** * Converts an iso8601 date to MySQL DateTime format used by post_date[_gmt]. * * @since 1.5.0 * * @param string $date_string Date and time in ISO 8601 format {@link http://en.wikipedia.org/wiki/ISO_8601}. * @param string $timezone Optional. If set to GMT returns the time minus gmt_offset. Default is 'user'. * @return string The date and time in MySQL DateTime format - Y-m-d H:i:s. */function iso8601_to_datetime($date_string, $timezone = 'user') {	$timezone = strtolower($timezone);	if ($timezone == 'gmt') {		preg_match('#([0-9]{4})([0-9]{2})([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(Z|[\+|\-][0-9]{2,4}){0,1}#', $date_string, $date_bits);		if (!empty($date_bits[7])) { // we have a timezone, so let's compute an offset			$offset = iso8601_timezone_to_offset($date_bits[7]);		} else { // we don't have a timezone, so we assume user local timezone (not server's!)			$offset = 3600 * get_option('gmt_offset');		}		$timestamp = gmmktime($date_bits[4], $date_bits[5], $date_bits[6], $date_bits[2], $date_bits[3], $date_bits[1]);		$timestamp -= $offset;		return gmdate('Y-m-d H:i:s', $timestamp);	} else if ($timezone == 'user') {		return preg_replace('#([0-9]{4})([0-9]{2})([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(Z|[\+|\-][0-9]{2,4}){0,1}#', '$1-$2-$3 $4:$5:$6', $date_string);	}}/** * Adds a element attributes to open links in new windows. * * Comment text in popup windows should be filtered through this. Right now it's * a moderately dumb function, ideally it would detect whether a target or rel * attribute was already there and adjust its actions accordingly. * * @since 0.71 * * @param string $text Content to replace links to open in a new window. * @return string Content that has filtered links. */function popuplinks($text) {	$text = preg_replace('/<a (.+?)>/i', "<a $1 target='_blank' rel='external'>", $text);	return $text;}/** * Strips out all characters that are not allowable in an email. * * @since 1.5.0 * * @param string $email Email address to filter. * @return string Filtered email address. */function sanitize_email( $email ) {	// Test for the minimum length the email can be	if ( strlen( $email ) < 3 ) {		return apply_filters( 'sanitize_email', '', $email, 'email_too_short' );	}	// Test for an @ character after the first position	if ( strpos( $email, '@', 1 ) === false ) {		return apply_filters( 'sanitize_email', '', $email, 'email_no_at' );	}	// Split out the local and domain parts	list( $local, $domain ) = explode( '@', $email, 2 );	// LOCAL PART	// Test for invalid characters	$local = preg_replace( '/[^a-zA-Z0-9!#$%&\'*+\/=?^_`{|}~\.-]/', '', $local );	if ( '' === $local ) {		return apply_filters( 'sanitize_email', '', $email, 'local_invalid_chars' );	}	// DOMAIN PART	// Test for sequences of periods	$domain = preg_replace( '/\.{2,}/', '', $domain );	if ( '' === $domain ) {		return apply_filters( 'sanitize_email', '', $email, 'domain_period_sequence' );	}	// Test for leading and trailing periods and whitespace	$domain = trim( $domain, " \t\n\r\0\x0B." );	if ( '' === $domain ) {		return apply_filters( 'sanitize_email', '', $email, 'domain_period_limits' );	}	// Split the domain into subs	$subs = explode( '.', $domain );	// Assume the domain will have at least two subs	if ( 2 > count( $subs ) ) {		return apply_filters( 'sanitize_email', '', $email, 'domain_no_periods' );	}	// Create an array that will contain valid subs	$new_subs = array();	// Loop through each sub	foreach ( $subs as $sub ) {		// Test for leading and trailing hyphens		$sub = trim( $sub, " \t\n\r\0\x0B-" );		// Test for invalid characters		$sub = preg_replace( '/^[^a-z0-9-]+$/i', '', $sub );		// If there's anything left, add it to the valid subs		if ( '' !== $sub ) {			$new_subs[] = $sub;		}	}	// If there aren't 2 or more valid subs	if ( 2 > count( $new_subs ) ) {		return apply_filters( 'sanitize_email', '', $email, 'domain_no_valid_subs' );	}	// Join valid subs into the new domain	$domain = join( '.', $new_subs );	// Put the email back together	$email = $local . '@' . $domain;	// Congratulations your email made it!	return apply_filters( 'sanitize_email', $email, $email, null );}/** * Determines the difference between two timestamps. * * The difference is returned in a human readable format such as "1 hour", * "5 mins", "2 days". * * @since 1.5.0 * * @param int $from Unix timestamp from which the difference begins. * @param int $to Optional. Unix timestamp to end the time difference. Default becomes time() if not set. * @return string Human readable time difference. */function human_time_diff( $from, $to = '' ) {	if ( empty($to) )		$to = time();	$diff = (int) abs($to - $from);	if ($diff <= 3600) {		$mins = round($diff / 60);		if ($mins <= 1) {			$mins = 1;		}		/* translators: min=minute */		$since = sprintf(_n('%s min', '%s mins', $mins), $mins);	} else if (($diff <= 86400) && ($diff > 3600)) {		$hours = round($diff / 3600);		if ($hours <= 1) {			$hours = 1;		}		$since = sprintf(_n('%s hour', '%s hours', $hours), $hours);	} elseif ($diff >= 86400) {		$days = round($diff / 86400);		if ($days <= 1) {			$days = 1;		}		$since = sprintf(_n('%s day', '%s days', $days), $days);	}	return $since;}/** * Generates an excerpt from the content, if needed. * * The excerpt word amount will be 55 words and if the amount is greater than * that, then the string ' [...]' will be appended to the excerpt. If the string * is less than 55 words, then the content will be returned as is. * * The 55 word limit can be modified by plugins/themes using the excerpt_length filter * The ' [...]' string can be modified by plugins/themes using the excerpt_more filter * * @since 1.5.0 * * @param string $text The excerpt. If set to empty an excerpt is generated. * @return string The excerpt. */function wp_trim_excerpt($text) {	$raw_excerpt = $text;	if ( '' == $text ) {		$text = get_the_content('');		$text = strip_shortcodes( $text );		$text = apply_filters('the_content', $text);		$text = str_replace(']]>', ']]&gt;', $text);		$text = strip_tags($text);		$excerpt_length = apply_filters('excerpt_length', 55);		$excerpt_more = apply_filters('excerpt_more', ' ' . '[...]');		$words = preg_split("/[\n\r\t ]+/", $text, $excerpt_length + 1, PREG_SPLIT_NO_EMPTY);		if ( count($words) > $excerpt_length ) {			array_pop($words);			$text = implode(' ', $words);			$text = $text . $excerpt_more;		} else {			$text = implode(' ', $words);		}	}	return apply_filters('wp_trim_excerpt', $text, $raw_excerpt);}/** * Converts named entities into numbered entities. * * @since 1.5.1 * * @param string $text The text within which entities will be converted. * @return string Text with converted entities. */function ent2ncr($text) {	$to_ncr = array(		'&quot;' => '&#34;',		'&amp;' => '&#38;',		'&frasl;' => '&#47;',		'&lt;' => '&#60;',		'&gt;' => '&#62;',		'|' => '&#124;',		'&nbsp;' => '&#160;',		'&iexcl;' => '&#161;',		'&cent;' => '&#162;',		'&pound;' => '&#163;',		'&curren;' => '&#164;',		'&yen;' => '&#165;',		'&brvbar;' => '&#166;',		'&brkbar;' => '&#166;',		'&sect;' => '&#167;',		'&uml;' => '&#168;',		'&die;' => '&#168;',		'&copy;' => '&#169;',		'&ordf;' => '&#170;',		'&laquo;' => '&#171;',		'&not;' => '&#172;',		'&shy;' => '&#173;',		'&reg;' => '&#174;',		'&macr;' => '&#175;',		'&hibar;' => '&#175;',		'&deg;' => '&#176;',		'&plusmn;' => '&#177;',		'&sup2;' => '&#178;',		'&sup3;' => '&#179;',		'&acute;' => '&#180;',		'&micro;' => '&#181;',		'&para;' => '&#182;',		'&middot;' => '&#183;',		'&cedil;' => '&#184;',		'&sup1;' => '&#185;',		'&ordm;' => '&#186;',		'&raquo;' => '&#187;',		'&frac14;' => '&#188;',		'&frac12;' => '&#189;',		'&frac34;' => '&#190;',		'&iquest;' => '&#191;',		'&Agrave;' => '&#192;',		'&Aacute;' => '&#193;',		'&Acirc;' => '&#194;',		'&Atilde;' => '&#195;',		'&Auml;' => '&#196;',		'&Aring;' => '&#197;',		'&AElig;' => '&#198;',		'&Ccedil;' => '&#199;',		'&Egrave;' => '&#200;',		'&Eacute;' => '&#201;',		'&Ecirc;' => '&#202;',		'&Euml;' => '&#203;',		'&Igrave;' => '&#204;',		'&Iacute;' => '&#205;',		'&Icirc;' => '&#206;',		'&Iuml;' => '&#207;',		'&ETH;' => '&#208;',		'&Ntilde;' => '&#209;',		'&Ograve;' => '&#210;',		'&Oacute;' => '&#211;',		'&Ocirc;' => '&#212;',		'&Otilde;' => '&#213;',		'&Ouml;' => '&#214;',		'&times;' => '&#215;',		'&Oslash;' => '&#216;',		'&Ugrave;' => '&#217;',		'&Uacute;' => '&#218;',		'&Ucirc;' => '&#219;',		'&Uuml;' => '&#220;',		'&Yacute;' => '&#221;',		'&THORN;' => '&#222;',		'&szlig;' => '&#223;',		'&agrave;' => '&#224;',		'&aacute;' => '&#225;',		'&acirc;' => '&#226;',		'&atilde;' => '&#227;',		'&auml;' => '&#228;',		'&aring;' => '&#229;',		'&aelig;' => '&#230;',		'&ccedil;' => '&#231;',		'&egrave;' => '&#232;',		'&eacute;' => '&#233;',		'&ecirc;' => '&#234;',		'&euml;' => '&#235;',		'&igrave;' => '&#236;',		'&iacute;' => '&#237;',		'&icirc;' => '&#238;',		'&iuml;' => '&#239;',		'&eth;' => '&#240;',		'&ntilde;' => '&#241;',		'&ograve;' => '&#242;',		'&oacute;' => '&#243;',		'&ocirc;' => '&#244;',		'&otilde;' => '&#245;',		'&ouml;' => '&#246;',		'&divide;' => '&#247;',		'&oslash;' => '&#248;',		'&ugrave;' => '&#249;',		'&uacute;' => '&#250;',		'&ucirc;' => '&#251;',		'&uuml;' => '&#252;',		'&yacute;' => '&#253;',		'&thorn;' => '&#254;',		'&yuml;' => '&#255;',		'&OElig;' => '&#338;',		'&oelig;' => '&#339;',		'&Scaron;' => '&#352;',		'&scaron;' => '&#353;',		'&Yuml;' => '&#376;',		'&fnof;' => '&#402;',		'&circ;' => '&#710;',		'&tilde;' => '&#732;',		'&Alpha;' => '&#913;',		'&Beta;' => '&#914;',		'&Gamma;' => '&#915;',		'&Delta;' => '&#916;',		'&Epsilon;' => '&#917;',		'&Zeta;' => '&#918;',		'&Eta;' => '&#919;',		'&Theta;' => '&#920;',		'&Iota;' => '&#921;',		'&Kappa;' => '&#922;',		'&Lambda;' => '&#923;',		'&Mu;' => '&#924;',		'&Nu;' => '&#925;',		'&Xi;' => '&#926;',		'&Omicron;' => '&#927;',		'&Pi;' => '&#928;',		'&Rho;' => '&#929;',		'&Sigma;' => '&#931;',		'&Tau;' => '&#932;',		'&Upsilon;' => '&#933;',		'&Phi;' => '&#934;',		'&Chi;' => '&#935;',		'&Psi;' => '&#936;',		'&Omega;' => '&#937;',		'&alpha;' => '&#945;',		'&beta;' => '&#946;',		'&gamma;' => '&#947;',		'&delta;' => '&#948;',		'&epsilon;' => '&#949;',		'&zeta;' => '&#950;',		'&eta;' => '&#951;',		'&theta;' => '&#952;',		'&iota;' => '&#953;',		'&kappa;' => '&#954;',		'&lambda;' => '&#955;',		'&mu;' => '&#956;',		'&nu;' => '&#957;',		'&xi;' => '&#958;',		'&omicron;' => '&#959;',		'&pi;' => '&#960;',		'&rho;' => '&#961;',		'&sigmaf;' => '&#962;',		'&sigma;' => '&#963;',		'&tau;' => '&#964;',		'&upsilon;' => '&#965;',		'&phi;' => '&#966;',		'&chi;' => '&#967;',		'&psi;' => '&#968;',		'&omega;' => '&#969;',		'&thetasym;' => '&#977;',		'&upsih;' => '&#978;',		'&piv;' => '&#982;',		'&ensp;' => '&#8194;',		'&emsp;' => '&#8195;',		'&thinsp;' => '&#8201;',		'&zwnj;' => '&#8204;',		'&zwj;' => '&#8205;',		'&lrm;' => '&#8206;',		'&rlm;' => '&#8207;',		'&ndash;' => '&#8211;',		'&mdash;' => '&#8212;',		'&lsquo;' => '&#8216;',		'&rsquo;' => '&#8217;',		'&sbquo;' => '&#8218;',		'&ldquo;' => '&#8220;',		'&rdquo;' => '&#8221;',		'&bdquo;' => '&#8222;',		'&dagger;' => '&#8224;',		'&Dagger;' => '&#8225;',		'&bull;' => '&#8226;',		'&hellip;' => '&#8230;',		'&permil;' => '&#8240;',		'&prime;' => '&#8242;',		'&Prime;' => '&#8243;',		'&lsaquo;' => '&#8249;',		'&rsaquo;' => '&#8250;',		'&oline;' => '&#8254;',		'&frasl;' => '&#8260;',		'&euro;' => '&#8364;',		'&image;' => '&#8465;',		'&weierp;' => '&#8472;',		'&real;' => '&#8476;',		'&trade;' => '&#8482;',		'&alefsym;' => '&#8501;',		'&crarr;' => '&#8629;',		'&lArr;' => '&#8656;',		'&uArr;' => '&#8657;',		'&rArr;' => '&#8658;',		'&dArr;' => '&#8659;',		'&hArr;' => '&#8660;',		'&forall;' => '&#8704;',		'&part;' => '&#8706;',		'&exist;' => '&#8707;',		'&empty;' => '&#8709;',		'&nabla;' => '&#8711;',		'&isin;' => '&#8712;',		'&notin;' => '&#8713;',		'&ni;' => '&#8715;',		'&prod;' => '&#8719;',		'&sum;' => '&#8721;',		'&minus;' => '&#8722;',		'&lowast;' => '&#8727;',		'&radic;' => '&#8730;',		'&prop;' => '&#8733;',		'&infin;' => '&#8734;',		'&ang;' => '&#8736;',		'&and;' => '&#8743;',		'&or;' => '&#8744;',		'&cap;' => '&#8745;',		'&cup;' => '&#8746;',		'&int;' => '&#8747;',		'&there4;' => '&#8756;',		'&sim;' => '&#8764;',		'&cong;' => '&#8773;',		'&asymp;' => '&#8776;',		'&ne;' => '&#8800;',		'&equiv;' => '&#8801;',		'&le;' => '&#8804;',		'&ge;' => '&#8805;',		'&sub;' => '&#8834;',		'&sup;' => '&#8835;',		'&nsub;' => '&#8836;',		'&sube;' => '&#8838;',		'&supe;' => '&#8839;',		'&oplus;' => '&#8853;',		'&otimes;' => '&#8855;',		'&perp;' => '&#8869;',		'&sdot;' => '&#8901;',		'&lceil;' => '&#8968;',		'&rceil;' => '&#8969;',		'&lfloor;' => '&#8970;',		'&rfloor;' => '&#8971;',		'&lang;' => '&#9001;',		'&rang;' => '&#9002;',		'&larr;' => '&#8592;',		'&uarr;' => '&#8593;',		'&rarr;' => '&#8594;',		'&darr;' => '&#8595;',		'&harr;' => '&#8596;',		'&loz;' => '&#9674;',		'&spades;' => '&#9824;',		'&clubs;' => '&#9827;',		'&hearts;' => '&#9829;',		'&diams;' => '&#9830;'	);	return str_replace( array_keys($to_ncr), array_values($to_ncr), $text );}/** * Formats text for the rich text editor. * * The filter 'richedit_pre' is applied here. If $text is empty the filter will * be applied to an empty string. * * @since 2.0.0 * * @param string $text The text to be formatted. * @return string The formatted text after filter is applied. */function wp_richedit_pre($text) {	// Filtering a blank results in an annoying <br />\n	if ( empty($text) ) return apply_filters('richedit_pre', '');	$output = convert_chars($text);	$output = wpautop($output);	$output = htmlspecialchars($output, ENT_NOQUOTES);	return apply_filters('richedit_pre', $output);}/** * Formats text for the HTML editor. * * Unless $output is empty it will pass through htmlspecialchars before the * 'htmledit_pre' filter is applied. * * @since 2.5.0 * * @param string $output The text to be formatted. * @return string Formatted text after filter applied. */function wp_htmledit_pre($output) {	if ( !empty($output) )		$output = htmlspecialchars($output, ENT_NOQUOTES); // convert only < > &	return apply_filters('htmledit_pre', $output);}/** * Perform a deep string replace operation to ensure the values in $search are no longer present * * Repeats the replacement operation until it no longer replaces anything so as to remove "nested" values * e.g. $subject = '%0%0%0DDD', $search ='%0D', $result ='' rather than the '%0%0DD' that * str_replace would return * * @since 2.8.1 * @access private * * @param string|array $search * @param string $subject * @return string The processed string */function _deep_replace( $search, $subject ) {	$found = true;	$subject = (string) $subject;	while ( $found ) {		$found = false;		foreach ( (array) $search as $val ) {			while ( strpos( $subject, $val ) !== false ) {				$found = true;				$subject = str_replace( $val, '', $subject );			}		}	}	return $subject;}/** * Escapes data for use in a MySQL query * * This is just a handy shortcut for $wpdb->escape(), for completeness' sake * * @since 2.8.0 * @param string $sql Unescaped SQL data * @return string The cleaned $sql */function esc_sql( $sql ) {	global $wpdb;	return $wpdb->escape( $sql );}/** * Checks and cleans a URL. * * A number of characters are removed from the URL. If the URL is for displaying * (the default behaviour) amperstands are also replaced. The 'clean_url' filter * is applied to the returned cleaned URL. * * @since 2.8.0 * @uses wp_kses_bad_protocol() To only permit protocols in the URL set *		via $protocols or the common ones set in the function. * * @param string $url The URL to be cleaned. * @param array $protocols Optional. An array of acceptable protocols. *		Defaults to 'http', 'https', 'ftp', 'ftps', 'mailto', 'news', 'irc', 'gopher', 'nntp', 'feed', 'telnet' if not set. * @param string $_context Private. Use esc_url_raw() for database usage. * @return string The cleaned $url after the 'clean_url' filter is applied. */function esc_url( $url, $protocols = null, $_context = 'display' ) {	$original_url = $url;	if ( '' == $url )		return $url;	$url = preg_replace('|[^a-z0-9-~+_.?#=!&;,/:%@$\|*\'()\\x80-\\xff]|i', '', $url);	$strip = array('%0d', '%0a', '%0D', '%0A');	$url = _deep_replace($strip, $url);	$url = str_replace(';//', '://', $url);	/* If the URL doesn't appear to contain a scheme, we	 * presume it needs http:// appended (unless a relative	 * link starting with / or a php file).	 */	if ( strpos($url, ':') === false &&		substr( $url, 0, 1 ) != '/' && substr( $url, 0, 1 ) != '#' && !preg_match('/^[a-z0-9-]+?\.php/i', $url) )		$url = 'http://' . $url;	// Replace ampersands and single quotes only when displaying.	if ( 'display' == $_context ) {		$url = preg_replace('/&([^#])(?![a-z]{2,8};)/', '&#038;$1', $url);		$url = str_replace( "'", '&#039;', $url );	}	if ( !is_array($protocols) )		$protocols = array ('http', 'https', 'ftp', 'ftps', 'mailto', 'news', 'irc', 'gopher', 'nntp', 'feed', 'telnet', 'mms', 'rtsp', 'svn');	if ( wp_kses_bad_protocol( $url, $protocols ) != $url )		return '';	return apply_filters('clean_url', $url, $original_url, $_context);}/** * Performs esc_url() for database usage. * * @since 2.8.0 * @uses esc_url() * * @param string $url The URL to be cleaned. * @param array $protocols An array of acceptable protocols. * @return string The cleaned URL. */function esc_url_raw( $url, $protocols = null ) {	return esc_url( $url, $protocols, 'db' );}/** * Convert entities, while preserving already-encoded entities. * * @link http://www.php.net/htmlentities Borrowed from the PHP Manual user notes. * * @since 1.2.2 * * @param string $myHTML The text to be converted. * @return string Converted text. */function htmlentities2($myHTML) {	$translation_table = get_html_translation_table( HTML_ENTITIES, ENT_QUOTES );	$translation_table[chr(38)] = '&';	return preg_replace( "/&(?![A-Za-z]{0,4}\w{2,3};|#[0-9]{2,3};)/", "&amp;", strtr($myHTML, $translation_table) );}/** * Escape single quotes, htmlspecialchar " < > &, and fix line endings. * * Escapes text strings for echoing in JS. It is intended to be used for inline JS * (in a tag attribute, for example onclick="..."). Note that the strings have to * be in single quotes. The filter 'js_escape' is also applied here. * * @since 2.8.0 * * @param string $text The text to be escaped. * @return string Escaped text. */function esc_js( $text ) {	$safe_text = wp_check_invalid_utf8( $text );	$safe_text = _wp_specialchars( $safe_text, ENT_COMPAT );	$safe_text = preg_replace( '/&#(x)?0*(?(1)27|39);?/i', "'", stripslashes( $safe_text ) );	$safe_text = str_replace( "\r", '', $safe_text );	$safe_text = str_replace( "\n", '\\n', addslashes( $safe_text ) );	return apply_filters( 'js_escape', $safe_text, $text );}/** * Escaping for HTML blocks. * * @since 2.8.0 * * @param string $text * @return string */function esc_html( $text ) {	$safe_text = wp_check_invalid_utf8( $text );	$safe_text = _wp_specialchars( $safe_text, ENT_QUOTES );	return apply_filters( 'esc_html', $safe_text, $text );}/** * Escaping for HTML attributes. * * @since 2.8.0 * * @param string $text * @return string */function esc_attr( $text ) {	$safe_text = wp_check_invalid_utf8( $text );	$safe_text = _wp_specialchars( $safe_text, ENT_QUOTES );	return apply_filters( 'attribute_escape', $safe_text, $text );}/** * Escape a HTML tag name. * * @since 2.5.0 * * @param string $tag_name * @return string */function tag_escape($tag_name) {	$safe_tag = strtolower( preg_replace('/[^a-zA-Z_:]/', '', $tag_name) );	return apply_filters('tag_escape', $safe_tag, $tag_name);}/** * Escapes text for SQL LIKE special characters % and _. * * @since 2.5.0 * * @param string $text The text to be escaped. * @return string text, safe for inclusion in LIKE query. */function like_escape($text) {	return str_replace(array("%", "_"), array("\\%", "\\_"), $text);}/** * Convert full URL paths to absolute paths. * * Removes the http or https protocols and the domain. Keeps the path '/' at the * beginning, so it isn't a true relative link, but from the web root base. * * @since 2.1.0 * * @param string $link Full URL path. * @return string Absolute path. */function wp_make_link_relative( $link ) {	return preg_replace( '|https?://[^/]+(/.*)|i', '$1', $link );}/** * Sanitises various option values based on the nature of the option. * * This is basically a switch statement which will pass $value through a number * of functions depending on the $option. * * @since 2.0.5 * * @param string $option The name of the option. * @param string $value The unsanitised value. * @return string Sanitized value. */function sanitize_option($option, $value) {	switch ( $option ) {		case 'admin_email':			$value = sanitize_email($value);			if ( !is_email($value) ) {				$value = get_option( $option ); // Resets option to stored value in the case of failed sanitization				if ( function_exists('add_settings_error') )					add_settings_error('admin_email', 'invalid_admin_email', __('The email address entered did not appear to be a valid email address. Please enter a valid email address.'));			}			break;		case 'thumbnail_size_w':		case 'thumbnail_size_h':		case 'medium_size_w':		case 'medium_size_h':		case 'large_size_w':		case 'large_size_h':		case 'embed_size_h':		case 'default_post_edit_rows':		case 'mailserver_port':		case 'comment_max_links':		case 'page_on_front':		case 'page_for_posts':		case 'rss_excerpt_length':		case 'default_category':		case 'default_email_category':		case 'default_link_category':		case 'close_comments_days_old':		case 'comments_per_page':		case 'thread_comments_depth':		case 'users_can_register':		case 'start_of_week':			$value = absint( $value );			break;		case 'embed_size_w':			if ( '' !== $value )				$value = absint( $value );			break;		case 'posts_per_page':		case 'posts_per_rss':			$value = (int) $value;			if ( empty($value) )				$value = 1;			if ( $value < -1 )				$value = abs($value);			break;		case 'default_ping_status':		case 'default_comment_status':			// Options that if not there have 0 value but need to be something like "closed"			if ( $value == '0' || $value == '')				$value = 'closed';			break;		case 'blogdescription':		case 'blogname':			$value = addslashes($value);			$value = wp_filter_post_kses( $value ); // calls stripslashes then addslashes			$value = stripslashes($value);			$value = esc_html( $value );			break;		case 'blog_charset':			$value = preg_replace('/[^a-zA-Z0-9_-]/', '', $value); // strips slashes			break;		case 'date_format':		case 'time_format':		case 'mailserver_url':		case 'mailserver_login':		case 'mailserver_pass':		case 'ping_sites':		case 'upload_path':			$value = strip_tags($value);			$value = addslashes($value);			$value = wp_filter_kses($value); // calls stripslashes then addslashes			$value = stripslashes($value);			break;		case 'gmt_offset':			$value = preg_replace('/[^0-9:.-]/', '', $value); // strips slashes			break;		case 'siteurl':			if ( (bool)preg_match( '#http(s?)://(.+)#i', $value) ) {				$value = esc_url_raw($value);			} else {				$value = get_option( $option ); // Resets option to stored value in the case of failed sanitization				if ( function_exists('add_settings_error') )					add_settings_error('siteurl', 'invalid_siteurl', __('The WordPress address you entered did not appear to be a valid URL. Please enter a valid URL.'));			}			break;		case 'home':			if ( (bool)preg_match( '#http(s?)://(.+)#i', $value) ) {				$value = esc_url_raw($value);			} else {				$value = get_option( $option ); // Resets option to stored value in the case of failed sanitization				if ( function_exists('add_settings_error') )					add_settings_error('home', 'invalid_home', __('The Site address you entered did not appear to be a valid URL. Please enter a valid URL.'));			}			break;		default :			$value = apply_filters("sanitize_option_{$option}", $value, $option);			break;	}	return $value;}/** * Parses a string into variables to be stored in an array. * * Uses {@link http://www.php.net/parse_str parse_str()} and stripslashes if * {@link http://www.php.net/magic_quotes magic_quotes_gpc} is on. * * @since 2.2.1 * @uses apply_filters() for the 'wp_parse_str' filter. * * @param string $string The string to be parsed. * @param array $array Variables will be stored in this array. */function wp_parse_str( $string, &$array ) {	parse_str( $string, $array );	if ( get_magic_quotes_gpc() )		$array = stripslashes_deep( $array );	$array = apply_filters( 'wp_parse_str', $array );}/** * Convert lone less than signs. * * KSES already converts lone greater than signs. * * @uses wp_pre_kses_less_than_callback in the callback function. * @since 2.3.0 * * @param string $text Text to be converted. * @return string Converted text. */function wp_pre_kses_less_than( $text ) {	return preg_replace_callback('%<[^>]*?((?=<)|>|$)%', 'wp_pre_kses_less_than_callback', $text);}/** * Callback function used by preg_replace. * * @uses esc_html to format the $matches text. * @since 2.3.0 * * @param array $matches Populated by matches to preg_replace. * @return string The text returned after esc_html if needed. */function wp_pre_kses_less_than_callback( $matches ) {	if ( false === strpos($matches[0], '>') )		return esc_html($matches[0]);	return $matches[0];}/** * WordPress implementation of PHP sprintf() with filters. * * @since 2.5.0 * @link http://www.php.net/sprintf * * @param string $pattern The string which formatted args are inserted. * @param mixed $args,... Arguments to be formatted into the $pattern string. * @return string The formatted string. */function wp_sprintf( $pattern ) {	$args = func_get_args( );	$len = strlen($pattern);	$start = 0;	$result = '';	$arg_index = 0;	while ( $len > $start ) {		// Last character: append and break		if ( strlen($pattern) - 1 == $start ) {			$result .= substr($pattern, -1);			break;		}		// Literal %: append and continue		if ( substr($pattern, $start, 2) == '%%' ) {			$start += 2;			$result .= '%';			continue;		}		// Get fragment before next %		$end = strpos($pattern, '%', $start + 1);		if ( false === $end )			$end = $len;		$fragment = substr($pattern, $start, $end - $start);		// Fragment has a specifier		if ( $pattern{$start} == '%' ) {			// Find numbered arguments or take the next one in order			if ( preg_match('/^%(\d+)\$/', $fragment, $matches) ) {				$arg = isset($args[$matches[1]]) ? $args[$matches[1]] : '';				$fragment = str_replace("%{$matches[1]}$", '%', $fragment);			} else {				++$arg_index;				$arg = isset($args[$arg_index]) ? $args[$arg_index] : '';			}			// Apply filters OR sprintf			$_fragment = apply_filters( 'wp_sprintf', $fragment, $arg );			if ( $_fragment != $fragment )				$fragment = $_fragment;			else				$fragment = sprintf($fragment, strval($arg) );		}		// Append to result and move to next fragment		$result .= $fragment;		$start = $end;	}	return $result;}/** * Localize list items before the rest of the content. * * The '%l' must be at the first characters can then contain the rest of the * content. The list items will have ', ', ', and', and ' and ' added depending * on the amount of list items in the $args parameter. * * @since 2.5.0 * * @param string $pattern Content containing '%l' at the beginning. * @param array $args List items to prepend to the content and replace '%l'. * @return string Localized list items and rest of the content. */function wp_sprintf_l($pattern, $args) {	// Not a match	if ( substr($pattern, 0, 2) != '%l' )		return $pattern;	// Nothing to work with	if ( empty($args) )		return '';	// Translate and filter the delimiter set (avoid ampersands and entities here)	$l = apply_filters('wp_sprintf_l', array(		/* translators: used between list items, there is a space after the coma */		'between'          => __(', '),		/* translators: used between list items, there is a space after the and */		'between_last_two' => __(', and '),		/* translators: used between only two list items, there is a space after the and */		'between_only_two' => __(' and '),		));	$args = (array) $args;	$result = array_shift($args);	if ( count($args) == 1 )		$result .= $l['between_only_two'] . array_shift($args);	// Loop when more than two args	$i = count($args);	while ( $i ) {		$arg = array_shift($args);		$i--;		if ( 0 == $i )			$result .= $l['between_last_two'] . $arg;		else			$result .= $l['between'] . $arg;	}	return $result . substr($pattern, 2);}/** * Safely extracts not more than the first $count characters from html string. * * UTF-8, tags and entities safe prefix extraction. Entities inside will *NOT* * be counted as one character. For example &amp; will be counted as 4, &lt; as * 3, etc. * * @since 2.5.0 * * @param integer $str String to get the excerpt from. * @param integer $count Maximum number of characters to take. * @return string The excerpt. */function wp_html_excerpt( $str, $count ) {	$str = wp_strip_all_tags( $str, true );	$str = mb_substr( $str, 0, $count );	// remove part of an entity at the end	$str = preg_replace( '/&[^;\s]{0,6}$/', '', $str );	return $str;}/** * Add a Base url to relative links in passed content. * * By default it supports the 'src' and 'href' attributes. However this can be * changed via the 3rd param. * * @since 2.7.0 * * @param string $content String to search for links in. * @param string $base The base URL to prefix to links. * @param array $attrs The attributes which should be processed. * @return string The processed content. */function links_add_base_url( $content, $base, $attrs = array('src', 'href') ) {	$attrs = implode('|', (array)$attrs);	return preg_replace_callback("!($attrs)=(['\"])(.+?)\\2!i",			create_function('$m', 'return _links_add_base($m, "' . $base . '");'),			$content);}/** * Callback to add a base url to relative links in passed content. * * @since 2.7.0 * @access private * * @param string $m The matched link. * @param string $base The base URL to prefix to links. * @return string The processed link. */function _links_add_base($m, $base) {	//1 = attribute name  2 = quotation mark  3 = URL	return $m[1] . '=' . $m[2] .		(strpos($m[3], 'http://') === false ?			path_join($base, $m[3]) :			$m[3])		. $m[2];}/** * Adds a Target attribute to all links in passed content. * * This function by default only applies to <a> tags, however this can be * modified by the 3rd param. * * <b>NOTE:</b> Any current target attributed will be striped and replaced. * * @since 2.7.0 * * @param string $content String to search for links in. * @param string $target The Target to add to the links. * @param array $tags An array of tags to apply to. * @return string The processed content. */function links_add_target( $content, $target = '_blank', $tags = array('a') ) {	$tags = implode('|', (array)$tags);	return preg_replace_callback("!<($tags)(.+?)>!i",			create_function('$m', 'return _links_add_target($m, "' . $target . '");'),			$content);}/** * Callback to add a target attribute to all links in passed content. * * @since 2.7.0 * @access private * * @param string $m The matched link. * @param string $target The Target to add to the links. * @return string The processed link. */function _links_add_target( $m, $target ) {	$tag = $m[1];	$link = preg_replace('|(target=[\'"](.*?)[\'"])|i', '', $m[2]);	return '<' . $tag . $link . ' target="' . $target . '">';}// normalize EOL characters and strip duplicate whitespacefunction normalize_whitespace( $str ) {	$str  = trim($str);	$str  = str_replace("\r", "\n", $str);	$str  = preg_replace( array( '/\n+/', '/[ \t]+/' ), array( "\n", ' ' ), $str );	return $str;}/** * Properly strip all HTML tags including script and style * * @since 2.9.0 * * @param string $string String containing HTML tags * @param bool $remove_breaks optional Whether to remove left over line breaks and white space chars * @return string The processed string. */function wp_strip_all_tags($string, $remove_breaks = false) {	$string = preg_replace( '@<(script|style)[^>]*?>.*?</\\1>@si', '', $string );	$string = strip_tags($string);	if ( $remove_breaks )		$string = preg_replace('/[\r\n\t ]+/', ' ', $string);	return trim($string);}/** * Sanitize a string from user input or from the db * * check for invalid UTF-8, * Convert single < characters to entity, * strip all tags, * remove line breaks, tabs and extra white space, * strip octets. * * @since 2.9.0 * * @param string $str * @return string */function sanitize_text_field($str) {	$filtered = wp_check_invalid_utf8( $str );	if ( strpos($filtered, '<') !== false ) {		$filtered = wp_pre_kses_less_than( $filtered );		// This will strip extra whitespace for us.		$filtered = wp_strip_all_tags( $filtered, true );	} else {		$filtered = trim( preg_replace('/[\r\n\t ]+/', ' ', $filtered) );	}	$match = array();	$found = false;	while ( preg_match('/%[a-f0-9]{2}/i', $filtered, $match) ) {		$filtered = str_replace($match[0], '', $filtered);		$found = true;	}	if ( $found ) {		// Strip out the whitespace that may now exist after removing the octets.		$filtered = trim( preg_replace('/ +/', ' ', $filtered) );	}	return apply_filters('sanitize_text_field', $filtered, $str);}/** * Forever eliminate "Wordpress" from the planet (or at least the little bit we can influence). * * Violating our coding standards for a good function name. * * @since 3.0.0 */function capital_P_dangit( $text ) {       return str_replace( 'Wordpress', 'WordPress', $text );}?>
<?php/** * WordPress Upgrade API * * Most of the functions are pluggable and can be overwritten * * @package WordPress * @subpackage Administration *//** Include user install customize script. */if ( file_exists(WP_CONTENT_DIR . '/install.php') )	require (WP_CONTENT_DIR . '/install.php');/** WordPress Administration API */require_once(ABSPATH . 'wp-admin/includes/admin.php');/** WordPress Schema API */require_once(ABSPATH . 'wp-admin/includes/schema.php');if ( !function_exists('wp_install') ) :/** * Installs the blog * * {@internal Missing Long Description}} * * @since unknown * * @param string $blog_title Blog title. * @param string $user_name User's username. * @param string $user_email User's email. * @param bool $public Whether blog is public. * @param null $deprecated Optional. Not used. * @param string $user_password Optional. User's chosen password. Will default to a random password. * @return array Array keys 'url', 'user_id', 'password', 'password_message'. */function wp_install( $blog_title, $user_name, $user_email, $public, $deprecated = '', $user_password = '' ) {	global $wp_rewrite;	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.6' );	wp_check_mysql_version();	wp_cache_flush();	make_db_current_silent();	populate_options();	populate_roles();	update_option('blogname', $blog_title);	update_option('admin_email', $user_email);	update_option('blog_public', $public);	$guessurl = wp_guess_url();	update_option('siteurl', $guessurl);	// If not a public blog, don't ping.	if ( ! $public )		update_option('default_pingback_flag', 0);	// Create default user.  If the user already exists, the user tables are	// being shared among blogs.  Just set the role in that case.	$user_id = username_exists($user_name);	$user_password = trim($user_password);	$email_password = false;	if ( !$user_id && empty($user_password) ) {		$user_password = wp_generate_password();		$message = __('<strong><em>Note that password</em></strong> carefully! It is a <em>random</em> password that was generated just for you.');		$user_id = wp_create_user($user_name, $user_password, $user_email);		update_user_option($user_id, 'default_password_nag', true, true);		$email_password = true;	} else if ( !$user_id ) {		// Password has been provided		$message = '<em>'.__('Your chosen password.').'</em>';		$user_id = wp_create_user($user_name, $user_password, $user_email);	} else {		$message =  __('User already exists. Password inherited.');	}	$user = new WP_User($user_id);	$user->set_role('administrator');	wp_install_defaults($user_id);	$wp_rewrite->flush_rules();	wp_new_blog_notification($blog_title, $guessurl, $user_id, ($email_password ? $user_password : __('The password you chose during the install.') ) );	wp_cache_flush();	return array('url' => $guessurl, 'user_id' => $user_id, 'password' => $user_password, 'password_message' => $message);}endif;if ( !function_exists('wp_install_defaults') ) :/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param int $user_id User ID. */function wp_install_defaults($user_id) {	global $wpdb, $wp_rewrite, $current_site, $table_prefix;	// Default category	$cat_name = __('Uncategorized');	/* translators: Default category slug */	$cat_slug = sanitize_title(_x('Uncategorized', 'Default category slug'));	if ( global_terms_enabled() ) {		$cat_id = $wpdb->get_var( $wpdb->prepare( "SELECT cat_ID FROM {$wpdb->sitecategories} WHERE category_nicename = %s", $cat_slug ) );		if ( $cat_id == null ) {			$wpdb->insert( $wpdb->sitecategories, array('cat_ID' => 0, 'cat_name' => $cat_name, 'category_nicename' => $cat_slug, 'last_updated' => current_time('mysql', true)) );			$cat_id = $wpdb->insert_id;		}		update_option('default_category', $cat_id);	} else {		$cat_id = 1;	}	$wpdb->insert( $wpdb->terms, array('term_id' => $cat_id, 'name' => $cat_name, 'slug' => $cat_slug, 'term_group' => 0) );	$wpdb->insert( $wpdb->term_taxonomy, array('term_id' => $cat_id, 'taxonomy' => 'category', 'description' => '', 'parent' => 0, 'count' => 1));	$cat_tt_id = $wpdb->insert_id;	// Default link category	$cat_name = __('Blogroll');	/* translators: Default link category slug */	$cat_slug = sanitize_title(_x('Blogroll', 'Default link category slug'));	if ( global_terms_enabled() ) {		$blogroll_id = $wpdb->get_var( $wpdb->prepare( "SELECT cat_ID FROM {$wpdb->sitecategories} WHERE category_nicename = %s", $cat_slug ) );		if ( $blogroll_id == null ) {			$wpdb->insert( $wpdb->sitecategories, array('cat_ID' => 0, 'cat_name' => $cat_name, 'category_nicename' => $cat_slug, 'last_updated' => current_time('mysql', true)) );			$blogroll_id = $wpdb->insert_id;		}		update_option('default_link_category', $blogroll_id);	} else {		$blogroll_id = 2;	}	$wpdb->insert( $wpdb->terms, array('term_id' => $blogroll_id, 'name' => $cat_name, 'slug' => $cat_slug, 'term_group' => 0) );	$wpdb->insert( $wpdb->term_taxonomy, array('term_id' => $blogroll_id, 'taxonomy' => 'link_category', 'description' => '', 'parent' => 0, 'count' => 7));	$blogroll_tt_id = $wpdb->insert_id;	// Now drop in some default links	$default_links = array();	$default_links[] = array(	'link_url' => 'http://codex.wordpress.org/',								'link_name' => 'Documentation',								'link_rss' => '',								'link_notes' => '');	$default_links[] = array(	'link_url' => 'http://wordpress.org/development/',								'link_name' => 'WordPress Blog',								'link_rss' => 'http://wordpress.org/development/feed/',								'link_notes' => '');	$default_links[] = array(	'link_url' => 'http://wordpress.org/extend/ideas/',								'link_name' => 'Suggest Ideas',								'link_rss' => '',								'link_notes' =>'');	$default_links[] = array(	'link_url' => 'http://wordpress.org/support/',								'link_name' => 'Support Forum',								'link_rss' => '',								'link_notes' =>'');	$default_links[] = array(	'link_url' => 'http://wordpress.org/extend/plugins/',								'link_name' => 'Plugins',								'link_rss' => '',								'link_notes' =>'');	$default_links[] = array(	'link_url' => 'http://wordpress.org/extend/themes/',								'link_name' => 'Themes',								'link_rss' => '',								'link_notes' =>'');	$default_links[] = array(	'link_url' => 'http://planet.wordpress.org/',								'link_name' => 'WordPress Planet',								'link_rss' => '',								'link_notes' =>'');	foreach ( $default_links as $link ) {		$wpdb->insert( $wpdb->links, $link);		$wpdb->insert( $wpdb->term_relationships, array('term_taxonomy_id' => $blogroll_tt_id, 'object_id' => $wpdb->insert_id) );	}	// First post	$now = date('Y-m-d H:i:s');	$now_gmt = gmdate('Y-m-d H:i:s');	$first_post_guid = get_option('home') . '/?p=1';	if ( is_multisite() ) {		$first_post = get_site_option( 'first_post' );		if ( empty($first_post) )			$first_post = stripslashes( __( 'Welcome to <a href="SITE_URL">SITE_NAME</a>. This is your first post. Edit or delete it, then start blogging!' ) );		$first_post = str_replace( "SITE_URL", esc_url( network_home_url() ), $first_post );		$first_post = str_replace( "SITE_NAME", $current_site->site_name, $first_post );	} else {		$first_post = __('Welcome to WordPress. This is your first post. Edit or delete it, then start blogging!');	}	$wpdb->insert( $wpdb->posts, array(								'post_author' => $user_id,								'post_date' => $now,								'post_date_gmt' => $now_gmt,								'post_content' => $first_post,								'post_excerpt' => '',								'post_title' => __('Hello world!'),								/* translators: Default post slug */								'post_name' => sanitize_title( _x('hello-world', 'Default post slug') ),								'post_modified' => $now,								'post_modified_gmt' => $now_gmt,								'guid' => $first_post_guid,								'comment_count' => 1,								'to_ping' => '',								'pinged' => '',								'post_content_filtered' => ''								));	$wpdb->insert( $wpdb->term_relationships, array('term_taxonomy_id' => $cat_tt_id, 'object_id' => 1) );	// Default comment	$first_comment_author = __('Mr WordPress');	$first_comment_url = 'http://wordpress.org/';	$first_comment = __('Hi, this is a comment.<br />To delete a comment, just log in and view the post&#039;s comments. There you will have the option to edit or delete them.');	if ( is_multisite() ) {		$first_comment_author = get_site_option( 'first_comment_author', $first_comment_author );		$first_comment_url = get_site_option( 'first_comment_url', network_home_url() );		$first_comment = get_site_option( 'first_comment', $first_comment );	}	$wpdb->insert( $wpdb->comments, array(								'comment_post_ID' => 1,								'comment_author' => $first_comment_author,								'comment_author_email' => '',								'comment_author_url' => $first_comment_url,								'comment_date' => $now,								'comment_date_gmt' => $now_gmt,								'comment_content' => $first_comment								));	// First Page	$first_page = __('This is an example of a WordPress page, you could edit this to put information about yourself or your site so readers know where you are coming from. You can create as many pages like this one or sub-pages as you like and manage all of your content inside of WordPress.');	if ( is_multisite() )		$first_page = get_site_option( 'first_page', $first_page );	$first_post_guid = get_option('home') . '/?page_id=2';	$wpdb->insert( $wpdb->posts, array(								'post_author' => $user_id,								'post_date' => $now,								'post_date_gmt' => $now_gmt,								'post_content' => $first_page,								'post_excerpt' => '',								'post_title' => __('About'),								/* translators: Default page slug */								'post_name' => _x('about', 'Default page slug'),								'post_modified' => $now,								'post_modified_gmt' => $now_gmt,								'guid' => $first_post_guid,								'post_type' => 'page',								'to_ping' => '',								'pinged' => '',								'post_content_filtered' => ''								));	$wpdb->insert( $wpdb->postmeta, array( 'post_id' => 2, 'meta_key' => '_wp_page_template', 'meta_value' => 'default' ) );	// Setup default widgets for default theme.	update_option( 'widget_search', array ( 2 => array ( 'title' => '' ), '_multiwidget' => 1 ) );	update_option( 'widget_recent-posts', array ( 2 => array ( 'title' => '', 'number' => 5 ), '_multiwidget' => 1 ) );	update_option( 'widget_recent-comments', array ( 2 => array ( 'title' => '', 'number' => 5 ), '_multiwidget' => 1 ) );	update_option( 'widget_archives', array ( 2 => array ( 'title' => '', 'count' => 0, 'dropdown' => 0 ), '_multiwidget' => 1 ) );	update_option( 'widget_categories', array ( 2 => array ( 'title' => '', 'count' => 0, 'hierarchical' => 0, 'dropdown' => 0 ), '_multiwidget' => 1 ) );	update_option( 'widget_meta', array ( 2 => array ( 'title' => '' ), '_multiwidget' => 1 ) );	update_option( 'sidebars_widgets', array ( 'wp_inactive_widgets' => array ( ), 'primary-widget-area' => array ( 0 => 'search-2', 1 => 'recent-posts-2', 2 => 'recent-comments-2', 3 => 'archives-2', 4 => 'categories-2', 5 => 'meta-2', ), 'secondary-widget-area' => array ( ), 'first-footer-widget-area' => array ( ), 'second-footer-widget-area' => array ( ), 'third-footer-widget-area' => array ( ), 'fourth-footer-widget-area' => array ( ), 'array_version' => 3 ) );	if ( is_multisite() ) {		// Flush rules to pick up the new page.		$wp_rewrite->init();		$wp_rewrite->flush_rules();		$user = new WP_User($user_id);		$wpdb->update( $wpdb->options, array('option_value' => $user->user_email), array('option_name' => 'admin_email') );		// Remove all perms except for the login user.		$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->usermeta WHERE user_id != %d AND meta_key = %s", $user_id, $table_prefix.'user_level') );		$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->usermeta WHERE user_id != %d AND meta_key = %s", $user_id, $table_prefix.'capabilities') );		// Delete any caps that snuck into the previously active blog. (Hardcoded to blog 1 for now.) TODO: Get previous_blog_id.		if ( !is_super_admin( $user_id ) && $user_id != 1 )			$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->usermeta WHERE user_id = %d AND meta_key = %s", $user_id, $wpdb->base_prefix.'1_capabilities') );	}}endif;if ( !function_exists('wp_new_blog_notification') ) :/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param string $blog_title Blog title. * @param string $blog_url Blog url. * @param int $user_id User ID. * @param string $password User's Password. */function wp_new_blog_notification($blog_title, $blog_url, $user_id, $password) {	$user = new WP_User($user_id);	$email = $user->user_email;	$name = $user->user_login;	$message = sprintf(__("Your new WordPress site has been successfully set up at:%1\$sYou can log in to the administrator account with the following information:Username: %2\$sPassword: %3\$sWe hope you enjoy your new site. Thanks!--The WordPress Teamhttp://wordpress.org/"), $blog_url, $name, $password);	@wp_mail($email, __('New WordPress Site'), $message);}endif;if ( !function_exists('wp_upgrade') ) :/** * Run WordPress Upgrade functions. * * {@internal Missing Long Description}} * * @since unknown * * @return null */function wp_upgrade() {	global $wp_current_db_version, $wp_db_version, $wpdb;	$wp_current_db_version = __get_option('db_version');	// We are up-to-date.  Nothing to do.	if ( $wp_db_version == $wp_current_db_version )		return;	if ( ! is_blog_installed() )		return;	wp_check_mysql_version();	wp_cache_flush();	pre_schema_upgrade();	make_db_current_silent();	upgrade_all();	if ( is_multisite() && is_main_site() )		upgrade_network();	wp_cache_flush();	if ( is_multisite() ) {		if ( $wpdb->get_row( "SELECT blog_id FROM {$wpdb->blog_versions} WHERE blog_id = '{$wpdb->blogid}'" ) )			$wpdb->query( "UPDATE {$wpdb->blog_versions} SET db_version = '{$wp_db_version}' WHERE blog_id = '{$wpdb->blogid}'" );		else			$wpdb->query( "INSERT INTO {$wpdb->blog_versions} ( `blog_id` , `db_version` , `last_updated` ) VALUES ( '{$wpdb->blogid}', '{$wp_db_version}', NOW());" );	}}endif;/** * Functions to be called in install and upgrade scripts. * * {@internal Missing Long Description}} * * @since unknown */function upgrade_all() {	global $wp_current_db_version, $wp_db_version, $wp_rewrite;	$wp_current_db_version = __get_option('db_version');	// We are up-to-date.  Nothing to do.	if ( $wp_db_version == $wp_current_db_version )		return;	// If the version is not set in the DB, try to guess the version.	if ( empty($wp_current_db_version) ) {		$wp_current_db_version = 0;		// If the template option exists, we have 1.5.		$template = __get_option('template');		if ( !empty($template) )			$wp_current_db_version = 2541;	}	if ( $wp_current_db_version < 6039 )		upgrade_230_options_table();	populate_options();	if ( $wp_current_db_version < 2541 ) {		upgrade_100();		upgrade_101();		upgrade_110();		upgrade_130();	}	if ( $wp_current_db_version < 3308 )		upgrade_160();	if ( $wp_current_db_version < 4772 )		upgrade_210();	if ( $wp_current_db_version < 4351 )		upgrade_old_slugs();	if ( $wp_current_db_version < 5539 )		upgrade_230();	if ( $wp_current_db_version < 6124 )		upgrade_230_old_tables();	if ( $wp_current_db_version < 7499 )		upgrade_250();	if ( $wp_current_db_version < 7935 )		upgrade_252();	if ( $wp_current_db_version < 8201 )		upgrade_260();	if ( $wp_current_db_version < 8989 )		upgrade_270();	if ( $wp_current_db_version < 10360 )		upgrade_280();	if ( $wp_current_db_version < 11958 )		upgrade_290();	if ( $wp_current_db_version < 15260 )		upgrade_300();	maybe_disable_automattic_widgets();	update_option( 'db_version', $wp_db_version );	update_option( 'db_upgraded', true );}/** * Execute changes made in WordPress 1.0. * * @since 1.0.0 */function upgrade_100() {	global $wpdb;	// Get the title and ID of every post, post_name to check if it already has a value	$posts = $wpdb->get_results("SELECT ID, post_title, post_name FROM $wpdb->posts WHERE post_name = ''");	if ($posts) {		foreach($posts as $post) {			if ('' == $post->post_name) {				$newtitle = sanitize_title($post->post_title);				$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET post_name = %s WHERE ID = %d", $newtitle, $post->ID) );			}		}	}	$categories = $wpdb->get_results("SELECT cat_ID, cat_name, category_nicename FROM $wpdb->categories");	foreach ($categories as $category) {		if ('' == $category->category_nicename) {			$newtitle = sanitize_title($category->cat_name);			$wpdb>update( $wpdb->categories, array('category_nicename' => $newtitle), array('cat_ID' => $category->cat_ID) );		}	}	$wpdb->query("UPDATE $wpdb->options SET option_value = REPLACE(option_value, 'wp-links/links-images/', 'wp-images/links/')	WHERE option_name LIKE 'links_rating_image%'	AND option_value LIKE 'wp-links/links-images/%'");	$done_ids = $wpdb->get_results("SELECT DISTINCT post_id FROM $wpdb->post2cat");	if ($done_ids) :		foreach ($done_ids as $done_id) :			$done_posts[] = $done_id->post_id;		endforeach;		$catwhere = ' AND ID NOT IN (' . implode(',', $done_posts) . ')';	else:		$catwhere = '';	endif;	$allposts = $wpdb->get_results("SELECT ID, post_category FROM $wpdb->posts WHERE post_category != '0' $catwhere");	if ($allposts) :		foreach ($allposts as $post) {			// Check to see if it's already been imported			$cat = $wpdb->get_row( $wpdb->prepare("SELECT * FROM $wpdb->post2cat WHERE post_id = %d AND category_id = %d", $post->ID, $post->post_category) );			if (!$cat && 0 != $post->post_category) { // If there's no result				$wpdb->insert( $wpdb->post2cat, array('post_id' => $post->ID, 'category_id' => $post->post_category) );			}		}	endif;}/** * Execute changes made in WordPress 1.0.1. * * @since 1.0.1 */function upgrade_101() {	global $wpdb;	// Clean up indices, add a few	add_clean_index($wpdb->posts, 'post_name');	add_clean_index($wpdb->posts, 'post_status');	add_clean_index($wpdb->categories, 'category_nicename');	add_clean_index($wpdb->comments, 'comment_approved');	add_clean_index($wpdb->comments, 'comment_post_ID');	add_clean_index($wpdb->links , 'link_category');	add_clean_index($wpdb->links , 'link_visible');}/** * Execute changes made in WordPress 1.2. * * @since 1.2.0 */function upgrade_110() {	global $wpdb;	// Set user_nicename.	$users = $wpdb->get_results("SELECT ID, user_nickname, user_nicename FROM $wpdb->users");	foreach ($users as $user) {		if ('' == $user->user_nicename) {			$newname = sanitize_title($user->user_nickname);			$wpdb->update( $wpdb->users, array('user_nicename' => $newname), array('ID' => $user->ID) );		}	}	$users = $wpdb->get_results("SELECT ID, user_pass from $wpdb->users");	foreach ($users as $row) {		if (!preg_match('/^[A-Fa-f0-9]{32}$/', $row->user_pass)) {			$wpdb->update( $wpdb->users, array('user_pass' => md5($row->user_pass)), array('ID' => $row->ID) );		}	}	// Get the GMT offset, we'll use that later on	$all_options = get_alloptions_110();	$time_difference = $all_options->time_difference;	$server_time = time()+date('Z');	$weblogger_time = $server_time + $time_difference*3600;	$gmt_time = time();	$diff_gmt_server = ($gmt_time - $server_time) / 3600;	$diff_weblogger_server = ($weblogger_time - $server_time) / 3600;	$diff_gmt_weblogger = $diff_gmt_server - $diff_weblogger_server;	$gmt_offset = -$diff_gmt_weblogger;	// Add a gmt_offset option, with value $gmt_offset	add_option('gmt_offset', $gmt_offset);	// Check if we already set the GMT fields (if we did, then	// MAX(post_date_gmt) can't be '0000-00-00 00:00:00'	// <michel_v> I just slapped myself silly for not thinking about it earlier	$got_gmt_fields = ! ($wpdb->get_var("SELECT MAX(post_date_gmt) FROM $wpdb->posts") == '0000-00-00 00:00:00');	if (!$got_gmt_fields) {		// Add or substract time to all dates, to get GMT dates		$add_hours = intval($diff_gmt_weblogger);		$add_minutes = intval(60 * ($diff_gmt_weblogger - $add_hours));		$wpdb->query("UPDATE $wpdb->posts SET post_date_gmt = DATE_ADD(post_date, INTERVAL '$add_hours:$add_minutes' HOUR_MINUTE)");		$wpdb->query("UPDATE $wpdb->posts SET post_modified = post_date");		$wpdb->query("UPDATE $wpdb->posts SET post_modified_gmt = DATE_ADD(post_modified, INTERVAL '$add_hours:$add_minutes' HOUR_MINUTE) WHERE post_modified != '0000-00-00 00:00:00'");		$wpdb->query("UPDATE $wpdb->comments SET comment_date_gmt = DATE_ADD(comment_date, INTERVAL '$add_hours:$add_minutes' HOUR_MINUTE)");		$wpdb->query("UPDATE $wpdb->users SET user_registered = DATE_ADD(user_registered, INTERVAL '$add_hours:$add_minutes' HOUR_MINUTE)");	}}/** * Execute changes made in WordPress 1.5. * * @since 1.5.0 */function upgrade_130() {	global $wpdb;	// Remove extraneous backslashes.	$posts = $wpdb->get_results("SELECT ID, post_title, post_content, post_excerpt, guid, post_date, post_name, post_status, post_author FROM $wpdb->posts");	if ($posts) {		foreach($posts as $post) {			$post_content = addslashes(deslash($post->post_content));			$post_title = addslashes(deslash($post->post_title));			$post_excerpt = addslashes(deslash($post->post_excerpt));			if ( empty($post->guid) )				$guid = get_permalink($post->ID);			else				$guid = $post->guid;			$wpdb->update( $wpdb->posts, compact('post_title', 'post_content', 'post_excerpt', 'guid'), array('ID' => $post->ID) );		}	}	// Remove extraneous backslashes.	$comments = $wpdb->get_results("SELECT comment_ID, comment_author, comment_content FROM $wpdb->comments");	if ($comments) {		foreach($comments as $comment) {			$comment_content = deslash($comment->comment_content);			$comment_author = deslash($comment->comment_author);			$wpdb->update($wpdb->comments, compact('comment_content', 'comment_author'), array('comment_ID' => $comment->comment_ID) );		}	}	// Remove extraneous backslashes.	$links = $wpdb->get_results("SELECT link_id, link_name, link_description FROM $wpdb->links");	if ($links) {		foreach($links as $link) {			$link_name = deslash($link->link_name);			$link_description = deslash($link->link_description);			$wpdb->update( $wpdb->links, compact('link_name', 'link_description'), array('link_id' => $link->link_id) );		}	}	$active_plugins = __get_option('active_plugins');	// If plugins are not stored in an array, they're stored in the old	// newline separated format.  Convert to new format.	if ( !is_array( $active_plugins ) ) {		$active_plugins = explode("\n", trim($active_plugins));		update_option('active_plugins', $active_plugins);	}	// Obsolete tables	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'optionvalues');	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'optiontypes');	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'optiongroups');	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'optiongroup_options');	// Update comments table to use comment_type	$wpdb->query("UPDATE $wpdb->comments SET comment_type='trackback', comment_content = REPLACE(comment_content, '<trackback />', '') WHERE comment_content LIKE '<trackback />%'");	$wpdb->query("UPDATE $wpdb->comments SET comment_type='pingback', comment_content = REPLACE(comment_content, '<pingback />', '') WHERE comment_content LIKE '<pingback />%'");	// Some versions have multiple duplicate option_name rows with the same values	$options = $wpdb->get_results("SELECT option_name, COUNT(option_name) AS dupes FROM `$wpdb->options` GROUP BY option_name");	foreach ( $options as $option ) {		if ( 1 != $option->dupes ) { // Could this be done in the query?			$limit = $option->dupes - 1;			$dupe_ids = $wpdb->get_col( $wpdb->prepare("SELECT option_id FROM $wpdb->options WHERE option_name = %s LIMIT %d", $option->option_name, $limit) );			if ( $dupe_ids ) {				$dupe_ids = join($dupe_ids, ',');				$wpdb->query("DELETE FROM $wpdb->options WHERE option_id IN ($dupe_ids)");			}		}	}	make_site_theme();}/** * Execute changes made in WordPress 2.0. * * @since 2.0.0 */function upgrade_160() {	global $wpdb, $wp_current_db_version;	populate_roles_160();	$users = $wpdb->get_results("SELECT * FROM $wpdb->users");	foreach ( $users as $user ) :		if ( !empty( $user->user_firstname ) )			update_user_meta( $user->ID, 'first_name', $wpdb->escape($user->user_firstname) );		if ( !empty( $user->user_lastname ) )			update_user_meta( $user->ID, 'last_name', $wpdb->escape($user->user_lastname) );		if ( !empty( $user->user_nickname ) )			update_user_meta( $user->ID, 'nickname', $wpdb->escape($user->user_nickname) );		if ( !empty( $user->user_level ) )			update_user_meta( $user->ID, $wpdb->prefix . 'user_level', $user->user_level );		if ( !empty( $user->user_icq ) )			update_user_meta( $user->ID, 'icq', $wpdb->escape($user->user_icq) );		if ( !empty( $user->user_aim ) )			update_user_meta( $user->ID, 'aim', $wpdb->escape($user->user_aim) );		if ( !empty( $user->user_msn ) )			update_user_meta( $user->ID, 'msn', $wpdb->escape($user->user_msn) );		if ( !empty( $user->user_yim ) )			update_user_meta( $user->ID, 'yim', $wpdb->escape($user->user_icq) );		if ( !empty( $user->user_description ) )			update_user_meta( $user->ID, 'description', $wpdb->escape($user->user_description) );		if ( isset( $user->user_idmode ) ):			$idmode = $user->user_idmode;			if ($idmode == 'nickname') $id = $user->user_nickname;			if ($idmode == 'login') $id = $user->user_login;			if ($idmode == 'firstname') $id = $user->user_firstname;			if ($idmode == 'lastname') $id = $user->user_lastname;			if ($idmode == 'namefl') $id = $user->user_firstname.' '.$user->user_lastname;			if ($idmode == 'namelf') $id = $user->user_lastname.' '.$user->user_firstname;			if (!$idmode) $id = $user->user_nickname;			$wpdb->update( $wpdb->users, array('display_name' => $id), array('ID' => $user->ID) );		endif;		// FIXME: RESET_CAPS is temporary code to reset roles and caps if flag is set.		$caps = get_user_meta( $user->ID, $wpdb->prefix . 'capabilities');		if ( empty($caps) || defined('RESET_CAPS') ) {			$level = get_user_meta($user->ID, $wpdb->prefix . 'user_level', true);			$role = translate_level_to_role($level);			update_user_meta( $user->ID, $wpdb->prefix . 'capabilities', array($role => true) );		}	endforeach;	$old_user_fields = array( 'user_firstname', 'user_lastname', 'user_icq', 'user_aim', 'user_msn', 'user_yim', 'user_idmode', 'user_ip', 'user_domain', 'user_browser', 'user_description', 'user_nickname', 'user_level' );	$wpdb->hide_errors();	foreach ( $old_user_fields as $old )		$wpdb->query("ALTER TABLE $wpdb->users DROP $old");	$wpdb->show_errors();	// populate comment_count field of posts table	$comments = $wpdb->get_results( "SELECT comment_post_ID, COUNT(*) as c FROM $wpdb->comments WHERE comment_approved = '1' GROUP BY comment_post_ID" );	if ( is_array( $comments ) )		foreach ($comments as $comment)			$wpdb->update( $wpdb->posts, array('comment_count' => $comment->c), array('ID' => $comment->comment_post_ID) );	// Some alpha versions used a post status of object instead of attachment and put	// the mime type in post_type instead of post_mime_type.	if ( $wp_current_db_version > 2541 && $wp_current_db_version <= 3091 ) {		$objects = $wpdb->get_results("SELECT ID, post_type FROM $wpdb->posts WHERE post_status = 'object'");		foreach ($objects as $object) {			$wpdb->update( $wpdb->posts, array(	'post_status' => 'attachment',												'post_mime_type' => $object->post_type,												'post_type' => ''),										 array( 'ID' => $object->ID ) );			$meta = get_post_meta($object->ID, 'imagedata', true);			if ( ! empty($meta['file']) )				update_attached_file( $object->ID, $meta['file'] );		}	}}/** * Execute changes made in WordPress 2.1. * * @since 2.1.0 */function upgrade_210() {	global $wpdb, $wp_current_db_version;	if ( $wp_current_db_version < 3506 ) {		// Update status and type.		$posts = $wpdb->get_results("SELECT ID, post_status FROM $wpdb->posts");		if ( ! empty($posts) ) foreach ($posts as $post) {			$status = $post->post_status;			$type = 'post';			if ( 'static' == $status ) {				$status = 'publish';				$type = 'page';			} else if ( 'attachment' == $status ) {				$status = 'inherit';				$type = 'attachment';			}			$wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET post_status = %s, post_type = %s WHERE ID = %d", $status, $type, $post->ID) );		}	}	if ( $wp_current_db_version < 3845 ) {		populate_roles_210();	}	if ( $wp_current_db_version < 3531 ) {		// Give future posts a post_status of future.		$now = gmdate('Y-m-d H:i:59');		$wpdb->query ("UPDATE $wpdb->posts SET post_status = 'future' WHERE post_status = 'publish' AND post_date_gmt > '$now'");		$posts = $wpdb->get_results("SELECT ID, post_date FROM $wpdb->posts WHERE post_status ='future'");		if ( !empty($posts) )			foreach ( $posts as $post )				wp_schedule_single_event(mysql2date('U', $post->post_date, false), 'publish_future_post', array($post->ID));	}}/** * Execute changes made in WordPress 2.3. * * @since 2.3.0 */function upgrade_230() {	global $wp_current_db_version, $wpdb;	if ( $wp_current_db_version < 5200 ) {		populate_roles_230();	}	// Convert categories to terms.	$tt_ids = array();	$have_tags = false;	$categories = $wpdb->get_results("SELECT * FROM $wpdb->categories ORDER BY cat_ID");	foreach ($categories as $category) {		$term_id = (int) $category->cat_ID;		$name = $category->cat_name;		$description = $category->category_description;		$slug = $category->category_nicename;		$parent = $category->category_parent;		$term_group = 0;		// Associate terms with the same slug in a term group and make slugs unique.		if ( $exists = $wpdb->get_results( $wpdb->prepare("SELECT term_id, term_group FROM $wpdb->terms WHERE slug = %s", $slug) ) ) {			$term_group = $exists[0]->term_group;			$id = $exists[0]->term_id;			$num = 2;			do {				$alt_slug = $slug . "-$num";				$num++;				$slug_check = $wpdb->get_var( $wpdb->prepare("SELECT slug FROM $wpdb->terms WHERE slug = %s", $alt_slug) );			} while ( $slug_check );			$slug = $alt_slug;			if ( empty( $term_group ) ) {				$term_group = $wpdb->get_var("SELECT MAX(term_group) FROM $wpdb->terms GROUP BY term_group") + 1;				$wpdb->query( $wpdb->prepare("UPDATE $wpdb->terms SET term_group = %d WHERE term_id = %d", $term_group, $id) );			}		}		$wpdb->query( $wpdb->prepare("INSERT INTO $wpdb->terms (term_id, name, slug, term_group) VALUES		(%d, %s, %s, %d)", $term_id, $name, $slug, $term_group) );		$count = 0;		if ( !empty($category->category_count) ) {			$count = (int) $category->category_count;			$taxonomy = 'category';			$wpdb->query( $wpdb->prepare("INSERT INTO $wpdb->term_taxonomy (term_id, taxonomy, description, parent, count) VALUES ( %d, %s, %s, %d, %d)", $term_id, $taxonomy, $description, $parent, $count) );			$tt_ids[$term_id][$taxonomy] = (int) $wpdb->insert_id;		}		if ( !empty($category->link_count) ) {			$count = (int) $category->link_count;			$taxonomy = 'link_category';			$wpdb->query( $wpdb->prepare("INSERT INTO $wpdb->term_taxonomy (term_id, taxonomy, description, parent, count) VALUES ( %d, %s, %s, %d, %d)", $term_id, $taxonomy, $description, $parent, $count) );			$tt_ids[$term_id][$taxonomy] = (int) $wpdb->insert_id;		}		if ( !empty($category->tag_count) ) {			$have_tags = true;			$count = (int) $category->tag_count;			$taxonomy = 'post_tag';			$wpdb->insert( $wpdb->term_taxonomy, compact('term_id', 'taxonomy', 'description', 'parent', 'count') );			$tt_ids[$term_id][$taxonomy] = (int) $wpdb->insert_id;		}		if ( empty($count) ) {			$count = 0;			$taxonomy = 'category';			$wpdb->insert( $wpdb->term_taxonomy, compact('term_id', 'taxonomy', 'description', 'parent', 'count') );			$tt_ids[$term_id][$taxonomy] = (int) $wpdb->insert_id;		}	}	$select = 'post_id, category_id';	if ( $have_tags )		$select .= ', rel_type';	$posts = $wpdb->get_results("SELECT $select FROM $wpdb->post2cat GROUP BY post_id, category_id");	foreach ( $posts as $post ) {		$post_id = (int) $post->post_id;		$term_id = (int) $post->category_id;		$taxonomy = 'category';		if ( !empty($post->rel_type) && 'tag' == $post->rel_type)			$taxonomy = 'tag';		$tt_id = $tt_ids[$term_id][$taxonomy];		if ( empty($tt_id) )			continue;		$wpdb->insert( $wpdb->term_relationships, array('object_id' => $post_id, 'term_taxonomy_id' => $tt_id) );	}	// < 3570 we used linkcategories.  >= 3570 we used categories and link2cat.	if ( $wp_current_db_version < 3570 ) {		// Create link_category terms for link categories.  Create a map of link cat IDs		// to link_category terms.		$link_cat_id_map = array();		$default_link_cat = 0;		$tt_ids = array();		$link_cats = $wpdb->get_results("SELECT cat_id, cat_name FROM " . $wpdb->prefix . 'linkcategories');		foreach ( $link_cats as $category) {			$cat_id = (int) $category->cat_id;			$term_id = 0;			$name = $wpdb->escape($category->cat_name);			$slug = sanitize_title($name);			$term_group = 0;			// Associate terms with the same slug in a term group and make slugs unique.			if ( $exists = $wpdb->get_results( $wpdb->prepare("SELECT term_id, term_group FROM $wpdb->terms WHERE slug = %s", $slug) ) ) {				$term_group = $exists[0]->term_group;				$term_id = $exists[0]->term_id;			}			if ( empty($term_id) ) {				$wpdb->insert( $wpdb->terms, compact('name', 'slug', 'term_group') );				$term_id = (int) $wpdb->insert_id;			}			$link_cat_id_map[$cat_id] = $term_id;			$default_link_cat = $term_id;			$wpdb->insert( $wpdb->term_taxonomy, array('term_id' => $term_id, 'taxonomy' => 'link_category', 'description' => '', 'parent' => 0, 'count' => 0) );			$tt_ids[$term_id] = (int) $wpdb->insert_id;		}		// Associate links to cats.		$links = $wpdb->get_results("SELECT link_id, link_category FROM $wpdb->links");		if ( !empty($links) ) foreach ( $links as $link ) {			if ( 0 == $link->link_category )				continue;			if ( ! isset($link_cat_id_map[$link->link_category]) )				continue;			$term_id = $link_cat_id_map[$link->link_category];			$tt_id = $tt_ids[$term_id];			if ( empty($tt_id) )				continue;			$wpdb->insert( $wpdb->term_relationships, array('object_id' => $link->link_id, 'term_taxonomy_id' => $tt_id) );		}		// Set default to the last category we grabbed during the upgrade loop.		update_option('default_link_category', $default_link_cat);	} else {		$links = $wpdb->get_results("SELECT link_id, category_id FROM $wpdb->link2cat GROUP BY link_id, category_id");		foreach ( $links as $link ) {			$link_id = (int) $link->link_id;			$term_id = (int) $link->category_id;			$taxonomy = 'link_category';			$tt_id = $tt_ids[$term_id][$taxonomy];			if ( empty($tt_id) )				continue;			$wpdb->insert( $wpdb->term_relationships, array('object_id' => $link_id, 'term_taxonomy_id' => $tt_id) );		}	}	if ( $wp_current_db_version < 4772 ) {		// Obsolete linkcategories table		$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'linkcategories');	}	// Recalculate all counts	$terms = $wpdb->get_results("SELECT term_taxonomy_id, taxonomy FROM $wpdb->term_taxonomy");	foreach ( (array) $terms as $term ) {		if ( ('post_tag' == $term->taxonomy) || ('category' == $term->taxonomy) )			$count = $wpdb->get_var( $wpdb->prepare("SELECT COUNT(*) FROM $wpdb->term_relationships, $wpdb->posts WHERE $wpdb->posts.ID = $wpdb->term_relationships.object_id AND post_status = 'publish' AND post_type = 'post' AND term_taxonomy_id = %d", $term->term_taxonomy_id) );		else			$count = $wpdb->get_var( $wpdb->prepare("SELECT COUNT(*) FROM $wpdb->term_relationships WHERE term_taxonomy_id = %d", $term->term_taxonomy_id) );		$wpdb->update( $wpdb->term_taxonomy, array('count' => $count), array('term_taxonomy_id' => $term->term_taxonomy_id) );	}}/** * Remove old options from the database. * * @since 2.3.0 */function upgrade_230_options_table() {	global $wpdb;	$old_options_fields = array( 'option_can_override', 'option_type', 'option_width', 'option_height', 'option_description', 'option_admin_level' );	$wpdb->hide_errors();	foreach ( $old_options_fields as $old )		$wpdb->query("ALTER TABLE $wpdb->options DROP $old");	$wpdb->show_errors();}/** * Remove old categories, link2cat, and post2cat database tables. * * @since 2.3.0 */function upgrade_230_old_tables() {	global $wpdb;	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'categories');	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'link2cat');	$wpdb->query('DROP TABLE IF EXISTS ' . $wpdb->prefix . 'post2cat');}/** * Upgrade old slugs made in version 2.2. * * @since 2.2.0 */function upgrade_old_slugs() {	// upgrade people who were using the Redirect Old Slugs plugin	global $wpdb;	$wpdb->query("UPDATE $wpdb->postmeta SET meta_key = '_wp_old_slug' WHERE meta_key = 'old_slug'");}/** * Execute changes made in WordPress 2.5.0. * * @since 2.5.0 */function upgrade_250() {	global $wp_current_db_version;	if ( $wp_current_db_version < 6689 ) {		populate_roles_250();	}}/** * Execute changes made in WordPress 2.5.2. * * @since 2.5.2 */function upgrade_252() {	global $wpdb;	$wpdb->query("UPDATE $wpdb->users SET user_activation_key = ''");}/** * Execute changes made in WordPress 2.6. * * @since 2.6.0 */function upgrade_260() {	global $wp_current_db_version;	if ( $wp_current_db_version < 8000 )		populate_roles_260();	if ( $wp_current_db_version < 8201 ) {		update_option('enable_app', 1);		update_option('enable_xmlrpc', 1);	}}/** * Execute changes made in WordPress 2.7. * * @since 2.7.0 */function upgrade_270() {	global $wpdb, $wp_current_db_version;	if ( $wp_current_db_version < 8980 )		populate_roles_270();	// Update post_date for unpublished posts with empty timestamp	if ( $wp_current_db_version < 8921 )		$wpdb->query( "UPDATE $wpdb->posts SET post_date = post_modified WHERE post_date = '0000-00-00 00:00:00'" );}/** * Execute changes made in WordPress 2.8. * * @since 2.8.0 */function upgrade_280() {	global $wp_current_db_version, $wpdb;	if ( $wp_current_db_version < 10360 )		populate_roles_280();	if ( is_multisite() ) {		$start = 0;		while( $rows = $wpdb->get_results( "SELECT option_name, option_value FROM $wpdb->options ORDER BY option_id LIMIT $start, 20" ) ) {			foreach( $rows as $row ) {				$value = $row->option_value;				if ( !@unserialize( $value ) )					$value = stripslashes( $value );				if ( $value !== $row->option_value ) {					update_option( $row->option_name, $value );				}			}			$start += 20;		}		refresh_blog_details( $wpdb->blogid );	}}/** * Execute changes made in WordPress 2.9. * * @since 2.9.0 */function upgrade_290() {	global $wp_current_db_version;	if ( $wp_current_db_version < 11958 ) {		// Previously, setting depth to 1 would redundantly disable threading, but now 2 is the minimum depth to avoid confusion		if ( get_option( 'thread_comments_depth' ) == '1' ) {			update_option( 'thread_comments_depth', 2 );			update_option( 'thread_comments', 0 );		}	}}/** * Execute changes made in WordPress 3.0. * * @since 3.0.0 */function upgrade_300() {	global $wp_current_db_version, $wpdb;	if ( $wp_current_db_version < 15093 )		populate_roles_300();	if ( $wp_current_db_version < 14139 && is_multisite() && is_main_site() && ! defined( 'MULTISITE' ) && get_site_option( 'siteurl' ) === false )		add_site_option( 'siteurl', '' );	// 3.0-alpha nav menu postmeta changes. can be removed before release. // r13802	if ( $wp_current_db_version >= 13226 && $wp_current_db_version < 13974 )		$wpdb->query( "DELETE FROM $wpdb->postmeta WHERE meta_key IN( 'menu_type', 'object_id', 'menu_new_window', 'menu_link', '_menu_item_append', 'menu_item_append', 'menu_item_type', 'menu_item_object_id', 'menu_item_target', 'menu_item_classes', 'menu_item_xfn', 'menu_item_url' )" );	// 3.0-beta1 remove_user primitive->meta cap. can be removed before release. r13956	if ( $wp_current_db_version >= 12751 && $wp_current_db_version < 13974 ) {		$role =& get_role( 'administrator' );		if ( ! empty( $role ) )			$role->remove_cap( 'remove_user' );	}	// 3.0-beta1 nav menu postmeta changes. can be removed before release. r13974	if ( $wp_current_db_version >= 13802 && $wp_current_db_version < 13974 )		$wpdb->update( $wpdb->postmeta, array( 'meta_value' => '' ), array( 'meta_key' => '_menu_item_target', 'meta_value' => '_self' ) );	// 3.0 screen options key name changes.	if ( !is_multisite() || is_main_site() ) {		$prefix = like_escape($wpdb->base_prefix);		$wpdb->query( "DELETE FROM $wpdb->usermeta WHERE meta_key LIKE '{$prefix}%meta-box-hidden%' OR meta_key LIKE '{$prefix}%closedpostboxes%' OR meta_key LIKE '{$prefix}%manage-%-columns-hidden%' OR meta_key LIKE '{$prefix}%meta-box-order%' OR meta_key LIKE '{$prefix}%metaboxorder%' OR meta_key LIKE '{$prefix}%screen_layout%'					 OR meta_key = 'manageedittagscolumnshidden' OR meta_key='managecategoriescolumnshidden' OR meta_key = 'manageedit-tagscolumnshidden' OR meta_key = 'manageeditcolumnshidden' OR meta_key = 'categories_per_page' OR meta_key = 'edit_tags_per_page'" );	}}/** * Execute network level changes * * @since 3.0.0 */function upgrade_network() {	global $wp_current_db_version, $wpdb;	// 2.8	if ( $wp_current_db_version < 11549 ) {		$wpmu_sitewide_plugins = get_site_option( 'wpmu_sitewide_plugins' );		$active_sitewide_plugins = get_site_option( 'active_sitewide_plugins' );		if ( $wpmu_sitewide_plugins ) {			if ( !$active_sitewide_plugins )				$sitewide_plugins = (array) $wpmu_sitewide_plugins;			else				$sitewide_plugins = array_merge( (array) $active_sitewide_plugins, (array) $wpmu_sitewide_plugins );			update_site_option( 'active_sitewide_plugins', $sitewide_plugins );		}		delete_site_option( 'wpmu_sitewide_plugins' );		delete_site_option( 'deactivated_sitewide_plugins' );		$start = 0;		while( $rows = $wpdb->get_results( "SELECT meta_key, meta_value FROM {$wpdb->sitemeta} ORDER BY meta_id LIMIT $start, 20" ) ) {			foreach( $rows as $row ) {				$value = $row->meta_value;				if ( !@unserialize( $value ) )					$value = stripslashes( $value );				if ( $value !== $row->meta_value ) {					update_site_option( $row->meta_key, $value );				}			}			$start += 20;		}	}	// 3.0	if ( $wp_current_db_version < 13576 )		update_site_option( 'global_terms_enabled', '1' );}// The functions we use to actually do stuff// General/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param string $table_name Database table name to create. * @param string $create_ddl SQL statement to create table. * @return bool If table already exists or was created by function. */function maybe_create_table($table_name, $create_ddl) {	global $wpdb;	if ( $wpdb->get_var("SHOW TABLES LIKE '$table_name'") == $table_name )		return true;	//didn't find it try to create it.	$q = $wpdb->query($create_ddl);	// we cannot directly tell that whether this succeeded!	if ( $wpdb->get_var("SHOW TABLES LIKE '$table_name'") == $table_name )		return true;	return false;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param string $table Database table name. * @param string $index Index name to drop. * @return bool True, when finished. */function drop_index($table, $index) {	global $wpdb;	$wpdb->hide_errors();	$wpdb->query("ALTER TABLE `$table` DROP INDEX `$index`");	// Now we need to take out all the extra ones we may have created	for ($i = 0; $i < 25; $i++) {		$wpdb->query("ALTER TABLE `$table` DROP INDEX `{$index}_$i`");	}	$wpdb->show_errors();	return true;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param string $table Database table name. * @param string $index Database table index column. * @return bool True, when done with execution. */function add_clean_index($table, $index) {	global $wpdb;	drop_index($table, $index);	$wpdb->query("ALTER TABLE `$table` ADD INDEX ( `$index` )");	return true;}/** ** maybe_add_column() ** Add column to db table if it doesn't exist. ** Returns:  true if already exists or on successful completion **           false on error */function maybe_add_column($table_name, $column_name, $create_ddl) {	global $wpdb, $debug;	foreach ($wpdb->get_col("DESC $table_name", 0) as $column ) {		if ($debug) echo("checking $column == $column_name<br />");		if ($column == $column_name) {			return true;		}	}	//didn't find it try to create it.	$q = $wpdb->query($create_ddl);	// we cannot directly tell that whether this succeeded!	foreach ($wpdb->get_col("DESC $table_name", 0) as $column ) {		if ($column == $column_name) {			return true;		}	}	return false;}/** * Retrieve all options as it was for 1.2. * * @since 1.2.0 * * @return array List of options. */function get_alloptions_110() {	global $wpdb;	if ($options = $wpdb->get_results("SELECT option_name, option_value FROM $wpdb->options")) {		foreach ($options as $option) {			// "When trying to design a foolproof system,			//  never underestimate the ingenuity of the fools :)" -- Dougal			if ('siteurl' == $option->option_name) $option->option_value = preg_replace('|/+$|', '', $option->option_value);			if ('home' == $option->option_name) $option->option_value = preg_replace('|/+$|', '', $option->option_value);			if ('category_base' == $option->option_name) $option->option_value = preg_replace('|/+$|', '', $option->option_value);			$all_options->{$option->option_name} = stripslashes($option->option_value);		}	}	return $all_options;}/** * Version of get_option that is private to install/upgrade. * * @since unknown * @access private * * @param string $setting Option name. * @return mixed */function __get_option($setting) {	global $wpdb;	if ( $setting == 'home' && defined( 'WP_HOME' ) ) {		return preg_replace( '|/+$|', '', WP_HOME );	}	if ( $setting == 'siteurl' && defined( 'WP_SITEURL' ) ) {		return preg_replace( '|/+$|', '', WP_SITEURL );	}	$option = $wpdb->get_var( $wpdb->prepare("SELECT option_value FROM $wpdb->options WHERE option_name = %s", $setting) );	if ( 'home' == $setting && '' == $option )		return __get_option('siteurl');	if ( 'siteurl' == $setting || 'home' == $setting || 'category_base' == $setting )		$option = preg_replace('|/+$|', '', $option);	@ $kellogs = unserialize($option);	if ($kellogs !== FALSE)		return $kellogs;	else		return $option;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param string $content * @return string */function deslash($content) {	// Note: \\\ inside a regex denotes a single backslash.	// Replace one or more backslashes followed by a single quote with	// a single quote.	$content = preg_replace("/\\\+'/", "'", $content);	// Replace one or more backslashes followed by a double quote with	// a double quote.	$content = preg_replace('/\\\+"/', '"', $content);	// Replace one or more backslashes with one backslash.	$content = preg_replace("/\\\+/", "\\", $content);	return $content;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param unknown_type $queries * @param unknown_type $execute * @return unknown */function dbDelta($queries, $execute = true) {	global $wpdb;	// Separate individual queries into an array	if ( !is_array($queries) ) {		$queries = explode( ';', $queries );		if ('' == $queries[count($queries) - 1]) array_pop($queries);	}	$cqueries = array(); // Creation Queries	$iqueries = array(); // Insertion Queries	$for_update = array();	// Create a tablename index for an array ($cqueries) of queries	foreach($queries as $qry) {		if (preg_match("|CREATE TABLE ([^ ]*)|", $qry, $matches)) {			$cqueries[trim( strtolower($matches[1]), '`' )] = $qry;			$for_update[$matches[1]] = 'Created table '.$matches[1];		} else if (preg_match("|CREATE DATABASE ([^ ]*)|", $qry, $matches)) {			array_unshift($cqueries, $qry);		} else if (preg_match("|INSERT INTO ([^ ]*)|", $qry, $matches)) {			$iqueries[] = $qry;		} else if (preg_match("|UPDATE ([^ ]*)|", $qry, $matches)) {			$iqueries[] = $qry;		} else {			// Unrecognized query type		}	}	// Check to see which tables and fields exist	if ($tables = $wpdb->get_col('SHOW TABLES;')) {		// For every table in the database		foreach ($tables as $table) {			// If a table query exists for the database table...			if ( array_key_exists(strtolower($table), $cqueries) ) {				// Clear the field and index arrays				$cfields = $indices = array();				// Get all of the field names in the query from between the parens				preg_match("|\((.*)\)|ms", $cqueries[strtolower($table)], $match2);				$qryline = trim($match2[1]);				// Separate field lines into an array				$flds = explode("\n", $qryline);				//echo "<hr/><pre>\n".print_r(strtolower($table), true).":\n".print_r($cqueries, true)."</pre><hr/>";				// For every field line specified in the query				foreach ($flds as $fld) {					// Extract the field name					preg_match("|^([^ ]*)|", trim($fld), $fvals);					$fieldname = trim( $fvals[1], '`' );					// Verify the found field name					$validfield = true;					switch (strtolower($fieldname)) {					case '':					case 'primary':					case 'index':					case 'fulltext':					case 'unique':					case 'key':						$validfield = false;						$indices[] = trim(trim($fld), ", \n");						break;					}					$fld = trim($fld);					// If it's a valid field, add it to the field array					if ($validfield) {						$cfields[strtolower($fieldname)] = trim($fld, ", \n");					}				}				// Fetch the table column structure from the database				$tablefields = $wpdb->get_results("DESCRIBE {$table};");				// For every field in the table				foreach ($tablefields as $tablefield) {					// If the table field exists in the field array...					if (array_key_exists(strtolower($tablefield->Field), $cfields)) {						// Get the field type from the query						preg_match("|".$tablefield->Field." ([^ ]*( unsigned)?)|i", $cfields[strtolower($tablefield->Field)], $matches);						$fieldtype = $matches[1];						// Is actual field type different from the field type in query?						if ($tablefield->Type != $fieldtype) {							// Add a query to change the column type							$cqueries[] = "ALTER TABLE {$table} CHANGE COLUMN {$tablefield->Field} " . $cfields[strtolower($tablefield->Field)];							$for_update[$table.'.'.$tablefield->Field] = "Changed type of {$table}.{$tablefield->Field} from {$tablefield->Type} to {$fieldtype}";						}						// Get the default value from the array							//echo "{$cfields[strtolower($tablefield->Field)]}<br>";						if (preg_match("| DEFAULT '(.*)'|i", $cfields[strtolower($tablefield->Field)], $matches)) {							$default_value = $matches[1];							if ($tablefield->Default != $default_value) {								// Add a query to change the column's default value								$cqueries[] = "ALTER TABLE {$table} ALTER COLUMN {$tablefield->Field} SET DEFAULT '{$default_value}'";								$for_update[$table.'.'.$tablefield->Field] = "Changed default value of {$table}.{$tablefield->Field} from {$tablefield->Default} to {$default_value}";							}						}						// Remove the field from the array (so it's not added)						unset($cfields[strtolower($tablefield->Field)]);					} else {						// This field exists in the table, but not in the creation queries?					}				}				// For every remaining field specified for the table				foreach ($cfields as $fieldname => $fielddef) {					// Push a query line into $cqueries that adds the field to that table					$cqueries[] = "ALTER TABLE {$table} ADD COLUMN $fielddef";					$for_update[$table.'.'.$fieldname] = 'Added column '.$table.'.'.$fieldname;				}				// Index stuff goes here				// Fetch the table index structure from the database				$tableindices = $wpdb->get_results("SHOW INDEX FROM {$table};");				if ($tableindices) {					// Clear the index array					unset($index_ary);					// For every index in the table					foreach ($tableindices as $tableindex) {						// Add the index to the index data array						$keyname = $tableindex->Key_name;						$index_ary[$keyname]['columns'][] = array('fieldname' => $tableindex->Column_name, 'subpart' => $tableindex->Sub_part);						$index_ary[$keyname]['unique'] = ($tableindex->Non_unique == 0)?true:false;					}					// For each actual index in the index array					foreach ($index_ary as $index_name => $index_data) {						// Build a create string to compare to the query						$index_string = '';						if ($index_name == 'PRIMARY') {							$index_string .= 'PRIMARY ';						} else if($index_data['unique']) {							$index_string .= 'UNIQUE ';						}						$index_string .= 'KEY ';						if ($index_name != 'PRIMARY') {							$index_string .= $index_name;						}						$index_columns = '';						// For each column in the index						foreach ($index_data['columns'] as $column_data) {							if ($index_columns != '') $index_columns .= ',';							// Add the field to the column list string							$index_columns .= $column_data['fieldname'];							if ($column_data['subpart'] != '') {								$index_columns .= '('.$column_data['subpart'].')';							}						}						// Add the column list to the index create string						$index_string .= ' ('.$index_columns.')';						if (!(($aindex = array_search($index_string, $indices)) === false)) {							unset($indices[$aindex]);							//echo "<pre style=\"border:1px solid #ccc;margin-top:5px;\">{$table}:<br />Found index:".$index_string."</pre>\n";						}						//else echo "<pre style=\"border:1px solid #ccc;margin-top:5px;\">{$table}:<br /><b>Did not find index:</b>".$index_string."<br />".print_r($indices, true)."</pre>\n";					}				}				// For every remaining index specified for the table				foreach ( (array) $indices as $index ) {					// Push a query line into $cqueries that adds the index to that table					$cqueries[] = "ALTER TABLE {$table} ADD $index";					$for_update[$table.'.'.$fieldname] = 'Added index '.$table.' '.$index;				}				// Remove the original table creation query from processing				unset($cqueries[strtolower($table)]);				unset($for_update[strtolower($table)]);			} else {				// This table exists in the database, but not in the creation queries?			}		}	}	$allqueries = array_merge($cqueries, $iqueries);	if ($execute) {		foreach ($allqueries as $query) {			//echo "<pre style=\"border:1px solid #ccc;margin-top:5px;\">".print_r($query, true)."</pre>\n";			$wpdb->query($query);		}	}	return $for_update;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown */function make_db_current() {	global $wp_queries;	$alterations = dbDelta($wp_queries);	echo "<ol>\n";	foreach($alterations as $alteration) echo "<li>$alteration</li>\n";	echo "</ol>\n";}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown */function make_db_current_silent() {	global $wp_queries;	$alterations = dbDelta($wp_queries);}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param unknown_type $theme_name * @param unknown_type $template * @return unknown */function make_site_theme_from_oldschool($theme_name, $template) {	$home_path = get_home_path();	$site_dir = WP_CONTENT_DIR . "/themes/$template";	if (! file_exists("$home_path/index.php"))		return false;	// Copy files from the old locations to the site theme.	// TODO: This does not copy arbitarary include dependencies.  Only the	// standard WP files are copied.	$files = array('index.php' => 'index.php', 'wp-layout.css' => 'style.css', 'wp-comments.php' => 'comments.php', 'wp-comments-popup.php' => 'comments-popup.php');	foreach ($files as $oldfile => $newfile) {		if ($oldfile == 'index.php')			$oldpath = $home_path;		else			$oldpath = ABSPATH;		if ($oldfile == 'index.php') { // Check to make sure it's not a new index			$index = implode('', file("$oldpath/$oldfile"));			if (strpos($index, 'WP_USE_THEMES') !== false) {				if (! @copy(WP_CONTENT_DIR . '/themes/' . WP_DEFAULT_THEME . '/index.php', "$site_dir/$newfile"))					return false;				continue; // Don't copy anything				}		}		if (! @copy("$oldpath/$oldfile", "$site_dir/$newfile"))			return false;		chmod("$site_dir/$newfile", 0777);		// Update the blog header include in each file.		$lines = explode("\n", implode('', file("$site_dir/$newfile")));		if ($lines) {			$f = fopen("$site_dir/$newfile", 'w');			foreach ($lines as $line) {				if (preg_match('/require.*wp-blog-header/', $line))					$line = '//' . $line;				// Update stylesheet references.				$line = str_replace("<?php echo __get_option('siteurl'); ?>/wp-layout.css", "<?php bloginfo('stylesheet_url'); ?>", $line);				// Update comments template inclusion.				$line = str_replace("<?php include(ABSPATH . 'wp-comments.php'); ?>", "<?php comments_template(); ?>", $line);				fwrite($f, "{$line}\n");			}			fclose($f);		}	}	// Add a theme header.	$header = "/*\nTheme Name: $theme_name\nTheme URI: " . __get_option('siteurl') . "\nDescription: A theme automatically created by the upgrade.\nVersion: 1.0\nAuthor: Moi\n*/\n";	$stylelines = file_get_contents("$site_dir/style.css");	if ($stylelines) {		$f = fopen("$site_dir/style.css", 'w');		fwrite($f, $header);		fwrite($f, $stylelines);		fclose($f);	}	return true;}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @param unknown_type $theme_name * @param unknown_type $template * @return unknown */function make_site_theme_from_default($theme_name, $template) {	$site_dir = WP_CONTENT_DIR . "/themes/$template";	$default_dir = WP_CONTENT_DIR . '/themes/' . WP_DEFAULT_THEME;	// Copy files from the default theme to the site theme.	//$files = array('index.php', 'comments.php', 'comments-popup.php', 'footer.php', 'header.php', 'sidebar.php', 'style.css');	$theme_dir = @ opendir($default_dir);	if ($theme_dir) {		while(($theme_file = readdir( $theme_dir )) !== false) {			if (is_dir("$default_dir/$theme_file"))				continue;			if (! @copy("$default_dir/$theme_file", "$site_dir/$theme_file"))				return;			chmod("$site_dir/$theme_file", 0777);		}	}	@closedir($theme_dir);	// Rewrite the theme header.	$stylelines = explode("\n", implode('', file("$site_dir/style.css")));	if ($stylelines) {		$f = fopen("$site_dir/style.css", 'w');		foreach ($stylelines as $line) {			if (strpos($line, 'Theme Name:') !== false) $line = 'Theme Name: ' . $theme_name;			elseif (strpos($line, 'Theme URI:') !== false) $line = 'Theme URI: ' . __get_option('url');			elseif (strpos($line, 'Description:') !== false) $line = 'Description: Your theme.';			elseif (strpos($line, 'Version:') !== false) $line = 'Version: 1';			elseif (strpos($line, 'Author:') !== false) $line = 'Author: You';			fwrite($f, $line . "\n");		}		fclose($f);	}	// Copy the images.	umask(0);	if (! mkdir("$site_dir/images", 0777)) {		return false;	}	$images_dir = @ opendir("$default_dir/images");	if ($images_dir) {		while(($image = readdir($images_dir)) !== false) {			if (is_dir("$default_dir/images/$image"))				continue;			if (! @copy("$default_dir/images/$image", "$site_dir/images/$image"))				return;			chmod("$site_dir/images/$image", 0777);		}	}	@closedir($images_dir);}// Create a site theme from the default theme./** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown * * @return unknown */function make_site_theme() {	// Name the theme after the blog.	$theme_name = __get_option('blogname');	$template = sanitize_title($theme_name);	$site_dir = WP_CONTENT_DIR . "/themes/$template";	// If the theme already exists, nothing to do.	if ( is_dir($site_dir)) {		return false;	}	// We must be able to write to the themes dir.	if (! is_writable(WP_CONTENT_DIR . "/themes")) {		return false;	}	umask(0);	if (! mkdir($site_dir, 0777)) {		return false;	}	if (file_exists(ABSPATH . 'wp-layout.css')) {		if (! make_site_theme_from_oldschool($theme_name, $template)) {			// TODO:  rm -rf the site theme directory.			return false;		}	} else {		if (! make_site_theme_from_default($theme_name, $template))			// TODO:  rm -rf the site theme directory.			return false;	}	// Make the new site theme active.	$current_template = __get_option('template');	if ($current_template == WP_DEFAULT_THEME) {		update_option('template', $template);		update_option('stylesheet', $template);	}	return $template;}/** * Translate user level to user role name. * * @since unknown * * @param int $level User level. * @return string User role name. */function translate_level_to_role($level) {	switch ($level) {	case 10:	case 9:	case 8:		return 'administrator';	case 7:	case 6:	case 5:		return 'editor';	case 4:	case 3:	case 2:		return 'author';	case 1:		return 'contributor';	case 0:		return 'subscriber';	}}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown */function wp_check_mysql_version() {	global $wpdb;	$result = $wpdb->check_database_version();	if ( is_wp_error( $result ) )		die( $result->get_error_message() );}/** * {@internal Missing Short Description}} * * {@internal Missing Long Description}} * * @since unknown */function maybe_disable_automattic_widgets() {	$plugins = __get_option( 'active_plugins' );	foreach ( (array) $plugins as $plugin ) {		if ( basename( $plugin ) == 'widgets.php' ) {			array_splice( $plugins, array_search( $plugin, $plugins ), 1 );			update_option( 'active_plugins', $plugins );			break;		}	}}/** * Runs before the schema is upgraded. */function pre_schema_upgrade() {	global $wp_current_db_version, $wp_db_version, $wpdb;	// Upgrade versions prior to 2.9	if ( $wp_current_db_version < 11557 ) {		// Delete duplicate options.  Keep the option with the highest option_id.		$wpdb->query("DELETE o1 FROM $wpdb->options AS o1 JOIN $wpdb->options AS o2 USING (`option_name`) WHERE o2.option_id > o1.option_id");		// Drop the old primary key and add the new.		$wpdb->query("ALTER TABLE $wpdb->options DROP PRIMARY KEY, ADD PRIMARY KEY(option_id)");		// Drop the old option_name index. dbDelta() doesn't do the drop.		$wpdb->query("ALTER TABLE $wpdb->options DROP INDEX option_name");	}}/** * Install Network. * * @since 3.0.0 * */if ( !function_exists( 'install_network' ) ) :function install_network() {	global $wpdb, $charset_collate;	$ms_queries = "CREATE TABLE $wpdb->users (  ID bigint(20) unsigned NOT NULL auto_increment,  user_login varchar(60) NOT NULL default '',  user_pass varchar(64) NOT NULL default '',  user_nicename varchar(50) NOT NULL default '',  user_email varchar(100) NOT NULL default '',  user_url varchar(100) NOT NULL default '',  user_registered datetime NOT NULL default '0000-00-00 00:00:00',  user_activation_key varchar(60) NOT NULL default '',  user_status int(11) NOT NULL default '0',  display_name varchar(250) NOT NULL default '',  spam tinyint(2) NOT NULL default '0',  deleted tinyint(2) NOT NULL default '0',  PRIMARY KEY  (ID),  KEY user_login_key (user_login),  KEY user_nicename (user_nicename)) $charset_collate;CREATE TABLE $wpdb->blogs (  blog_id bigint(20) NOT NULL auto_increment,  site_id bigint(20) NOT NULL default '0',  domain varchar(200) NOT NULL default '',  path varchar(100) NOT NULL default '',  registered datetime NOT NULL default '0000-00-00 00:00:00',  last_updated datetime NOT NULL default '0000-00-00 00:00:00',  public tinyint(2) NOT NULL default '1',  archived enum('0','1') NOT NULL default '0',  mature tinyint(2) NOT NULL default '0',  spam tinyint(2) NOT NULL default '0',  deleted tinyint(2) NOT NULL default '0',  lang_id int(11) NOT NULL default '0',  PRIMARY KEY  (blog_id),  KEY domain (domain(50),path(5)),  KEY lang_id (lang_id)) $charset_collate;CREATE TABLE $wpdb->blog_versions (  blog_id bigint(20) NOT NULL default '0',  db_version varchar(20) NOT NULL default '',  last_updated datetime NOT NULL default '0000-00-00 00:00:00',  PRIMARY KEY  (blog_id),  KEY db_version (db_version)) $charset_collate;CREATE TABLE $wpdb->registration_log (  ID bigint(20) NOT NULL auto_increment,  email varchar(255) NOT NULL default '',  IP varchar(30) NOT NULL default '',  blog_id bigint(20) NOT NULL default '0',  date_registered datetime NOT NULL default '0000-00-00 00:00:00',  PRIMARY KEY  (ID),  KEY IP (IP)) $charset_collate;CREATE TABLE $wpdb->site (  id bigint(20) NOT NULL auto_increment,  domain varchar(200) NOT NULL default '',  path varchar(100) NOT NULL default '',  PRIMARY KEY  (id),  KEY domain (domain,path)) $charset_collate;CREATE TABLE $wpdb->sitemeta (  meta_id bigint(20) NOT NULL auto_increment,  site_id bigint(20) NOT NULL default '0',  meta_key varchar(255) default NULL,  meta_value longtext,  PRIMARY KEY  (meta_id),  KEY meta_key (meta_key),  KEY site_id (site_id)) $charset_collate;CREATE TABLE $wpdb->signups (  domain varchar(200) NOT NULL default '',  path varchar(100) NOT NULL default '',  title longtext NOT NULL,  user_login varchar(60) NOT NULL default '',  user_email varchar(100) NOT NULL default '',  registered datetime NOT NULL default '0000-00-00 00:00:00',  activated datetime NOT NULL default '0000-00-00 00:00:00',  active tinyint(1) NOT NULL default '0',  activation_key varchar(50) NOT NULL default '',  meta longtext,  KEY activation_key (activation_key),  KEY domain (domain)) $charset_collate;";// now create tables	dbDelta( $ms_queries );}endif;/** * Install global terms. * * @since 3.0.0 * */if ( !function_exists( 'install_global_terms' ) ) :function install_global_terms() {	global $wpdb, $charset_collate;	$ms_queries = "CREATE TABLE $wpdb->sitecategories (  cat_ID bigint(20) NOT NULL auto_increment,  cat_name varchar(55) NOT NULL default '',  category_nicename varchar(200) NOT NULL default '',  last_updated timestamp NOT NULL,  PRIMARY KEY  (cat_ID),  KEY category_nicename (category_nicename),  KEY last_updated (last_updated)) $charset_collate;";// now create tables	dbDelta( $ms_queries );}endif;?>
<?php/** * Taxonomy API * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 *///// Taxonomy Registration///** * Creates the initial taxonomies when 'init' action is fired. */function create_initial_taxonomies() {	register_taxonomy( 'category', 'post', array(		'hierarchical' => true,	 	'update_count_callback' => '_update_post_term_count',		'query_var' => false,		'rewrite' => false,		'public' => true,		'show_ui' => true,		'_builtin' => true,	) ) ;	register_taxonomy( 'post_tag', 'post', array(	 	'hierarchical' => false,		'update_count_callback' => '_update_post_term_count',		'query_var' => false,		'rewrite' => false,		'public' => true,		'show_ui' => true,		'_builtin' => true,	) );	register_taxonomy( 'nav_menu', 'nav_menu_item', array(		'hierarchical' => false,		'labels' => array(			'name' => __( 'Navigation Menus' ),			'singular_name' => __( 'Navigation Menu' ),		),		'query_var' => false,		'rewrite' => false,		'show_ui' => false,		'_builtin' => true,		'show_in_nav_menus' => false,	) ) ;	register_taxonomy( 'link_category', 'link', array(		'hierarchical' => false,		'labels' => array(			'name' => __( 'Categories' ),			'singular_name' => __( 'Category' ),			'update_item' => __( 'Update Category' ),		),		'query_var' => false,		'rewrite' => false,		'public' => false,		'show_ui' => false,		'_builtin' => true,	) ) ;}add_action( 'init', 'create_initial_taxonomies', 0 ); // highest priority/** * Get a list of registered taxonomy objects. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * @uses $wp_taxonomies * @see register_taxonomy * * @param array $args An array of key => value arguments to match against the taxonomy objects. * @param string $output The type of output to return, either taxonomy 'names' or 'objects'. 'names' is the default. * @param string $operator The logical operation to perform. 'or' means only one element *  from the array needs to match; 'and' means all elements must match. The default is 'and'. * @return array A list of taxonomy names or objects */function get_taxonomies( $args = array(), $output = 'names', $operator = 'and' ) {	global $wp_taxonomies;	$field = ('names' == $output) ? 'name' : false;	return wp_filter_object_list($wp_taxonomies, $args, $operator, $field);}/** * Return all of the taxonomy names that are of $object_type. * * It appears that this function can be used to find all of the names inside of * $wp_taxonomies global variable. * * <code><?php $taxonomies = get_object_taxonomies('post'); ?></code> Should * result in <code>Array('category', 'post_tag')</code> * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wp_taxonomies * * @param array|string|object $object Name of the type of taxonomy object, or an object (row from posts) * @param string $output The type of output to return, either taxonomy 'names' or 'objects'. 'names' is the default. * @return array The names of all taxonomy of $object_type. */function get_object_taxonomies($object, $output = 'names') {	global $wp_taxonomies;	if ( is_object($object) ) {		if ( $object->post_type == 'attachment' )			return get_attachment_taxonomies($object);		$object = $object->post_type;	}	$object = (array) $object;	$taxonomies = array();	foreach ( (array) $wp_taxonomies as $tax_name => $tax_obj ) {		if ( array_intersect($object, (array) $tax_obj->object_type) ) {			if ( 'names' == $output )				$taxonomies[] = $tax_name;			else				$taxonomies[ $tax_name ] = $tax_obj;		}	}	return $taxonomies;}/** * Retrieves the taxonomy object of $taxonomy. * * The get_taxonomy function will first check that the parameter string given * is a taxonomy object and if it is, it will return it. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wp_taxonomies * @uses taxonomy_exists() Checks whether taxonomy exists * * @param string $taxonomy Name of taxonomy object to return * @return object|bool The Taxonomy Object or false if $taxonomy doesn't exist */function get_taxonomy( $taxonomy ) {	global $wp_taxonomies;	if ( ! taxonomy_exists( $taxonomy ) )		return false;	return $wp_taxonomies[$taxonomy];}/** * Checks that the taxonomy name exists. * * Formerly is_taxonomy(), introduced in 2.3.0. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * * @uses $wp_taxonomies * * @param string $taxonomy Name of taxonomy object * @return bool Whether the taxonomy exists. */function taxonomy_exists( $taxonomy ) {	global $wp_taxonomies;	return isset( $wp_taxonomies[$taxonomy] );}/** * Whether the taxonomy object is hierarchical. * * Checks to make sure that the taxonomy is an object first. Then Gets the * object, and finally returns the hierarchical value in the object. * * A false return value might also mean that the taxonomy does not exist. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses taxonomy_exists() Checks whether taxonomy exists * @uses get_taxonomy() Used to get the taxonomy object * * @param string $taxonomy Name of taxonomy object * @return bool Whether the taxonomy is hierarchical */function is_taxonomy_hierarchical($taxonomy) {	if ( ! taxonomy_exists($taxonomy) )		return false;	$taxonomy = get_taxonomy($taxonomy);	return $taxonomy->hierarchical;}/** * Create or modify a taxonomy object. Do not use before init. * * A simple function for creating or modifying a taxonomy object based on the * parameters given. The function will accept an array (third optional * parameter), along with strings for the taxonomy name and another string for * the object type. * * Nothing is returned, so expect error maybe or use taxonomy_exists() to check * whether taxonomy exists. * * Optional $args contents: * * label - Name of the taxonomy shown in the menu. Usually plural. If not set, labels['name'] will be used. * * hierarchical - has some defined purpose at other parts of the API and is a * boolean value. * * update_count_callback - works much like a hook, in that it will be called * when the count is updated. * * rewrite - false to prevent rewrite, or array('slug'=>$slug) to customize * permastruct; default will use $taxonomy as slug. * * query_var - false to prevent queries, or string to customize query var * (?$query_var=$term); default will use $taxonomy as query var. * * public - If the taxonomy should be publically queryable; //@TODO not implemented. * defaults to true. * * show_ui - If the WordPress UI admin tags UI should apply to this taxonomy; * defaults to public. * * show_in_nav_menus - true makes this taxonomy available for selection in navigation menus. * Defaults to public. * * show_tagcloud - false to prevent the taxonomy being listed in the Tag Cloud Widget; * defaults to show_ui which defalts to public. * * labels - An array of labels for this taxonomy. You can see accepted values in {@link get_taxonomy_labels()}. By default tag labels are used for non-hierarchical types and category labels for hierarchical ones. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wp_taxonomies Inserts new taxonomy object into the list * @uses $wp_rewrite Adds rewrite tags and permastructs * @uses $wp Adds query vars * * @param string $taxonomy Name of taxonomy object * @param array|string $object_type Name of the object type for the taxonomy object. * @param array|string $args See above description for the two keys values. */function register_taxonomy( $taxonomy, $object_type, $args = array() ) {	global $wp_taxonomies, $wp_rewrite, $wp;	if ( ! is_array($wp_taxonomies) )		$wp_taxonomies = array();	$defaults = array(	'hierarchical' => false,						'update_count_callback' => '',						'rewrite' => true,						'query_var' => $taxonomy,						'public' => true,						'show_ui' => null,						'show_tagcloud' => null,						'_builtin' => false,						'labels' => array(),						'capabilities' => array(),						'show_in_nav_menus' => null,					);	$args = wp_parse_args($args, $defaults);	if ( false !== $args['query_var'] && !empty($wp) ) {		if ( true === $args['query_var'] )			$args['query_var'] = $taxonomy;		$args['query_var'] = sanitize_title_with_dashes($args['query_var']);		$wp->add_query_var($args['query_var']);	}	if ( false !== $args['rewrite'] && '' != get_option('permalink_structure') ) {		$args['rewrite'] = wp_parse_args($args['rewrite'], array(			'slug' => sanitize_title_with_dashes($taxonomy),			'with_front' => true,		));		$wp_rewrite->add_rewrite_tag("%$taxonomy%", '([^/]+)', $args['query_var'] ? "{$args['query_var']}=" : "taxonomy=$taxonomy&term=");		$wp_rewrite->add_permastruct($taxonomy, "{$args['rewrite']['slug']}/%$taxonomy%", $args['rewrite']['with_front']);	}	if ( is_null($args['show_ui']) )		$args['show_ui'] = $args['public'];	// Whether to show this type in nav-menus.php. Defaults to the setting for public.	if ( null === $args['show_in_nav_menus'] )		$args['show_in_nav_menus'] = $args['public'];	if ( is_null($args['show_tagcloud']) )		$args['show_tagcloud'] = $args['show_ui'];	$default_caps = array(		'manage_terms' => 'manage_categories',		'edit_terms'   => 'manage_categories',		'delete_terms' => 'manage_categories',		'assign_terms' => 'edit_posts',	);	$args['cap'] = (object) array_merge( $default_caps, $args['capabilities'] );	unset( $args['capabilities'] );	$args['name'] = $taxonomy;	$args['object_type'] = (array) $object_type;	$args['labels'] = get_taxonomy_labels( (object) $args );	$args['label'] = $args['labels']->name;	$wp_taxonomies[$taxonomy] = (object) $args;	// register callback handling for metabox 	add_filter('wp_ajax_add-'.$taxonomy, '_wp_ajax_add_hierarchical_term');}/** * Builds an object with all taxonomy labels out of a taxonomy object * * Accepted keys of the label array in the taxonomy object: * - name - general name for the taxonomy, usually plural. The same as and overriden by $tax->label. Default is Post Tags/Categories * - singular_name - name for one object of this taxonomy. Default is Post Tag/Category * - search_items - Default is Search Tags/Search Categories * - popular_items - This string isn't used on hierarchical taxonomies. Default is Popular Tags * - all_items - Default is All Tags/All Categories * - parent_item - This string isn't used on non-hierarchical taxonomies. In hierarchical ones the default is Parent Category * - parent_item_colon - The same as <code>parent_item</code>, but with colon <code>:</code> in the end * - edit_item - Default is Edit Tag/Edit Category * - update_item - Default is Update Tag/Update Category * - add_new_item - Default is Add New Tag/Add New Category * - new_item_name - Default is New Tag Name/New Category Name * - separate_items_with_commas - This string isn't used on hierarchical taxonomies. Default is "Separate tags with commas," used in the meta box. * - add_or_remove_items - This string isn't used on hierarchical taxonomies. Default is "Add or remove tags," used in the meta box when JavaScript is disabled. * - choose_from_most_used - This string isn't used on hierarchical taxonomies. Default is "Choose from the most used tags," used in the meta box. * * Above, the first default value is for non-hierarchical taxonomies (like tags) and the second one is for hierarchical taxonomies (like categories.) * * @since 3.0.0 * @param object $tax Taxonomy object * @return object object with all the labels as member variables */function get_taxonomy_labels( $tax ) {	if ( isset( $tax->helps ) && empty( $tax->labels['separate_items_with_commas'] ) )		$tax->labels['separate_items_with_commas'] = $tax->helps;	$nohier_vs_hier_defaults = array(		'name' => array( _x( 'Post Tags', 'taxonomy general name' ), _x( 'Categories', 'taxonomy general name' ) ),		'singular_name' => array( _x( 'Post Tag', 'taxonomy singular name' ), _x( 'Category', 'taxonomy singular name' ) ),		'search_items' => array( __( 'Search Tags' ), __( 'Search Categories' ) ),		'popular_items' => array( __( 'Popular Tags' ), null ),		'all_items' => array( __( 'All Tags' ), __( 'All Categories' ) ),		'parent_item' => array( null, __( 'Parent Category' ) ),		'parent_item_colon' => array( null, __( 'Parent Category:' ) ),		'edit_item' => array( __( 'Edit Tag' ), __( 'Edit Category' ) ),		'update_item' => array( __( 'Update Tag' ), __( 'Update Category' ) ),		'add_new_item' => array( __( 'Add New Tag' ), __( 'Add New Category' ) ),		'new_item_name' => array( __( 'New Tag Name' ), __( 'New Category Name' ) ),		'separate_items_with_commas' => array( __( 'Separate tags with commas' ), null ),		'add_or_remove_items' => array( __( 'Add or remove tags' ), null ),		'choose_from_most_used' => array( __( 'Choose from the most used tags' ), null ),	);	return _get_custom_object_labels( $tax, $nohier_vs_hier_defaults );}/** * Add an already registered taxonomy to an object type. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * @uses $wp_taxonomies Modifies taxonomy object * * @param string $taxonomy Name of taxonomy object * @param array|string $object_type Name of the object type * @return bool True if successful, false if not */function register_taxonomy_for_object_type( $taxonomy, $object_type) {	global $wp_taxonomies;	if ( !isset($wp_taxonomies[$taxonomy]) )		return false;	if ( ! get_post_type_object($object_type) )		return false;	$wp_taxonomies[$taxonomy]->object_type[] = $object_type;	return true;}//// Term API///** * Retrieve object_ids of valid taxonomy and term. * * The strings of $taxonomies must exist before this function will continue. On * failure of finding a valid taxonomy, it will return an WP_Error class, kind * of like Exceptions in PHP 5, except you can't catch them. Even so, you can * still test for the WP_Error class and get the error message. * * The $terms aren't checked the same as $taxonomies, but still need to exist * for $object_ids to be returned. * * It is possible to change the order that object_ids is returned by either * using PHP sort family functions or using the database by using $args with * either ASC or DESC array. The value should be in the key named 'order'. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses wp_parse_args() Creates an array from string $args. * * @param int|array $term_ids Term id or array of term ids of terms that will be used * @param string|array $taxonomies String of taxonomy name or Array of string values of taxonomy names * @param array|string $args Change the order of the object_ids, either ASC or DESC * @return WP_Error|array If the taxonomy does not exist, then WP_Error will be returned. On success *	the array can be empty meaning that there are no $object_ids found or it will return the $object_ids found. */function get_objects_in_term( $term_ids, $taxonomies, $args = array() ) {	global $wpdb;	if ( ! is_array( $term_ids ) )		$term_ids = array( $term_ids );	if ( ! is_array( $taxonomies ) )		$taxonomies = array( $taxonomies );	foreach ( (array) $taxonomies as $taxonomy ) {		if ( ! taxonomy_exists( $taxonomy ) )			return new WP_Error( 'invalid_taxonomy', __( 'Invalid Taxonomy' ) );	}	$defaults = array( 'order' => 'ASC' );	$args = wp_parse_args( $args, $defaults );	extract( $args, EXTR_SKIP );	$order = ( 'desc' == strtolower( $order ) ) ? 'DESC' : 'ASC';	$term_ids = array_map('intval', $term_ids );	$taxonomies = "'" . implode( "', '", $taxonomies ) . "'";	$term_ids = "'" . implode( "', '", $term_ids ) . "'";	$object_ids = $wpdb->get_col("SELECT tr.object_id FROM $wpdb->term_relationships AS tr INNER JOIN $wpdb->term_taxonomy AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy IN ($taxonomies) AND tt.term_id IN ($term_ids) ORDER BY tr.object_id $order");	if ( ! $object_ids )		return array();	return $object_ids;}/** * Get all Term data from database by Term ID. * * The usage of the get_term function is to apply filters to a term object. It * is possible to get a term object from the database before applying the * filters. * * $term ID must be part of $taxonomy, to get from the database. Failure, might * be able to be captured by the hooks. Failure would be the same value as $wpdb * returns for the get_row method. * * There are two hooks, one is specifically for each term, named 'get_term', and * the second is for the taxonomy name, 'term_$taxonomy'. Both hooks gets the * term object, and the taxonomy name as parameters. Both hooks are expected to * return a Term object. * * 'get_term' hook - Takes two parameters the term Object and the taxonomy name. * Must return term object. Used in get_term() as a catch-all filter for every * $term. * * 'get_$taxonomy' hook - Takes two parameters the term Object and the taxonomy * name. Must return term object. $taxonomy will be the taxonomy name, so for * example, if 'category', it would be 'get_category' as the filter name. Useful * for custom taxonomies or plugging into default taxonomies. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses sanitize_term() Cleanses the term based on $filter context before returning. * @see sanitize_term_field() The $context param lists the available values for get_term_by() $filter param. * * @param int|object $term If integer, will get from database. If object will apply filters and return $term. * @param string $taxonomy Taxonomy name that $term is part of. * @param string $output Constant OBJECT, ARRAY_A, or ARRAY_N * @param string $filter Optional, default is raw or no WordPress defined filter will applied. * @return mixed|null|WP_Error Term Row from database. Will return null if $term is empty. If taxonomy does not * exist then WP_Error will be returned. */function &get_term($term, $taxonomy, $output = OBJECT, $filter = 'raw') {	global $wpdb;	$null = null;	if ( empty($term) ) {		$error = new WP_Error('invalid_term', __('Empty Term'));		return $error;	}	if ( ! taxonomy_exists($taxonomy) ) {		$error = new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));		return $error;	}	if ( is_object($term) && empty($term->filter) ) {		wp_cache_add($term->term_id, $term, $taxonomy);		$_term = $term;	} else {		if ( is_object($term) )			$term = $term->term_id;		$term = (int) $term;		if ( ! $_term = wp_cache_get($term, $taxonomy) ) {			$_term = $wpdb->get_row( $wpdb->prepare( "SELECT t.*, tt.* FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy = %s AND t.term_id = %s LIMIT 1", $taxonomy, $term) );			if ( ! $_term )				return $null;			wp_cache_add($term, $_term, $taxonomy);		}	}	$_term = apply_filters('get_term', $_term, $taxonomy);	$_term = apply_filters("get_$taxonomy", $_term, $taxonomy);	$_term = sanitize_term($_term, $taxonomy, $filter);	if ( $output == OBJECT ) {		return $_term;	} elseif ( $output == ARRAY_A ) {		$__term = get_object_vars($_term);		return $__term;	} elseif ( $output == ARRAY_N ) {		$__term = array_values(get_object_vars($_term));		return $__term;	} else {		return $_term;	}}/** * Get all Term data from database by Term field and data. * * Warning: $value is not escaped for 'name' $field. You must do it yourself, if * required. * * The default $field is 'id', therefore it is possible to also use null for * field, but not recommended that you do so. * * If $value does not exist, the return value will be false. If $taxonomy exists * and $field and $value combinations exist, the Term will be returned. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses sanitize_term() Cleanses the term based on $filter context before returning. * @see sanitize_term_field() The $context param lists the available values for get_term_by() $filter param. * * @param string $field Either 'slug', 'name', or 'id' * @param string|int $value Search for this term value * @param string $taxonomy Taxonomy Name * @param string $output Constant OBJECT, ARRAY_A, or ARRAY_N * @param string $filter Optional, default is raw or no WordPress defined filter will applied. * @return mixed Term Row from database. Will return false if $taxonomy does not exist or $term was not found. */function get_term_by($field, $value, $taxonomy, $output = OBJECT, $filter = 'raw') {	global $wpdb;	if ( ! taxonomy_exists($taxonomy) )		return false;	if ( 'slug' == $field ) {		$field = 't.slug';		$value = sanitize_title($value);		if ( empty($value) )			return false;	} else if ( 'name' == $field ) {		// Assume already escaped		$value = stripslashes($value);		$field = 't.name';	} else {		return get_term( (int) $value, $taxonomy, $output, $filter);	}	$term = $wpdb->get_row( $wpdb->prepare( "SELECT t.*, tt.* FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy = %s AND $field = %s LIMIT 1", $taxonomy, $value) );	if ( !$term )		return false;	wp_cache_add($term->term_id, $term, $taxonomy);	$term = apply_filters('get_term', $term, $taxonomy);	$term = apply_filters("get_$taxonomy", $term, $taxonomy);	$term = sanitize_term($term, $taxonomy, $filter);	if ( $output == OBJECT ) {		return $term;	} elseif ( $output == ARRAY_A ) {		return get_object_vars($term);	} elseif ( $output == ARRAY_N ) {		return array_values(get_object_vars($term));	} else {		return $term;	}}/** * Merge all term children into a single array of their IDs. * * This recursive function will merge all of the children of $term into the same * array of term IDs. Only useful for taxonomies which are hierarchical. * * Will return an empty array if $term does not exist in $taxonomy. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses _get_term_hierarchy() * @uses get_term_children() Used to get the children of both $taxonomy and the parent $term * * @param string $term ID of Term to get children * @param string $taxonomy Taxonomy Name * @return array|WP_Error List of Term Objects. WP_Error returned if $taxonomy does not exist */function get_term_children( $term_id, $taxonomy ) {	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));	$term_id = intval( $term_id );	$terms = _get_term_hierarchy($taxonomy);	if ( ! isset($terms[$term_id]) )		return array();	$children = $terms[$term_id];	foreach ( (array) $terms[$term_id] as $child ) {		if ( isset($terms[$child]) )			$children = array_merge($children, get_term_children($child, $taxonomy));	}	return $children;}/** * Get sanitized Term field. * * Does checks for $term, based on the $taxonomy. The function is for contextual * reasons and for simplicity of usage. See sanitize_term_field() for more * information. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses sanitize_term_field() Passes the return value in sanitize_term_field on success. * * @param string $field Term field to fetch * @param int $term Term ID * @param string $taxonomy Taxonomy Name * @param string $context Optional, default is display. Look at sanitize_term_field() for available options. * @return mixed Will return an empty string if $term is not an object or if $field is not set in $term. */function get_term_field( $field, $term, $taxonomy, $context = 'display' ) {	$term = (int) $term;	$term = get_term( $term, $taxonomy );	if ( is_wp_error($term) )		return $term;	if ( !is_object($term) )		return '';	if ( !isset($term->$field) )		return '';	return sanitize_term_field($field, $term->$field, $term->term_id, $taxonomy, $context);}/** * Sanitizes Term for editing. * * Return value is sanitize_term() and usage is for sanitizing the term for * editing. Function is for contextual and simplicity. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses sanitize_term() Passes the return value on success * * @param int|object $id Term ID or Object * @param string $taxonomy Taxonomy Name * @return mixed|null|WP_Error Will return empty string if $term is not an object. */function get_term_to_edit( $id, $taxonomy ) {	$term = get_term( $id, $taxonomy );	if ( is_wp_error($term) )		return $term;	if ( !is_object($term) )		return '';	return sanitize_term($term, $taxonomy, 'edit');}/** * Retrieve the terms in a given taxonomy or list of taxonomies. * * You can fully inject any customizations to the query before it is sent, as * well as control the output with a filter. * * The 'get_terms' filter will be called when the cache has the term and will * pass the found term along with the array of $taxonomies and array of $args. * This filter is also called before the array of terms is passed and will pass * the array of terms, along with the $taxonomies and $args. * * The 'list_terms_exclusions' filter passes the compiled exclusions along with * the $args. * * The 'get_terms_orderby' filter passes the ORDER BY clause for the query * along with the $args array. * * The 'get_terms_fields' filter passes the fields for the SELECT query * along with the $args array. * * The list of arguments that $args can contain, which will overwrite the defaults: * * orderby - Default is 'name'. Can be name, count, term_group, slug or nothing * (will use term_id), Passing a custom value other than these will cause it to * order based on the custom value. * * order - Default is ASC. Can use DESC. * * hide_empty - Default is true. Will not return empty terms, which means * terms whose count is 0 according to the given taxonomy. * * exclude - Default is an empty array.  An array, comma- or space-delimited string * of term ids to exclude from the return array.  If 'include' is non-empty, * 'exclude' is ignored. * * exclude_tree - Default is an empty array.  An array, comma- or space-delimited * string of term ids to exclude from the return array, along with all of their * descendant terms according to the primary taxonomy.  If 'include' is non-empty, * 'exclude_tree' is ignored. * * include - Default is an empty array.  An array, comma- or space-delimited string * of term ids to include in the return array. * * number - The maximum number of terms to return.  Default is to return them all. * * offset - The number by which to offset the terms query. * * fields - Default is 'all', which returns an array of term objects. * If 'fields' is 'ids' or 'names', returns an array of * integers or strings, respectively. * * slug - Returns terms whose "slug" matches this value. Default is empty string. * * hierarchical - Whether to include terms that have non-empty descendants * (even if 'hide_empty' is set to true). * * search - Returned terms' names will contain the value of 'search', * case-insensitive.  Default is an empty string. * * name__like - Returned terms' names will begin with the value of 'name__like', * case-insensitive. Default is empty string. * * The argument 'pad_counts', if set to true will include the quantity of a term's * children in the quantity of each term's "count" object variable. * * The 'get' argument, if set to 'all' instead of its default empty string, * returns terms regardless of ancestry or whether the terms are empty. * * The 'child_of' argument, when used, should be set to the integer of a term ID.  Its default * is 0.  If set to a non-zero value, all returned terms will be descendants * of that term according to the given taxonomy.  Hence 'child_of' is set to 0 * if more than one taxonomy is passed in $taxonomies, because multiple taxonomies * make term ancestry ambiguous. * * The 'parent' argument, when used, should be set to the integer of a term ID.  Its default is * the empty string '', which has a different meaning from the integer 0. * If set to an integer value, all returned terms will have as an immediate * ancestor the term whose ID is specified by that integer according to the given taxonomy. * The 'parent' argument is different from 'child_of' in that a term X is considered a 'parent' * of term Y only if term X is the father of term Y, not its grandfather or great-grandfather, etc. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses wp_parse_args() Merges the defaults with those defined by $args and allows for strings. * * @param string|array Taxonomy name or list of Taxonomy names * @param string|array $args The values of what to search for when returning terms * @return array|WP_Error List of Term Objects and their children. Will return WP_Error, if any of $taxonomies do not exist. */function &get_terms($taxonomies, $args = '') {	global $wpdb;	$empty_array = array();	$single_taxonomy = false;	if ( !is_array($taxonomies) ) {		$single_taxonomy = true;		$taxonomies = array($taxonomies);	}	foreach ( (array) $taxonomies as $taxonomy ) {		if ( ! taxonomy_exists($taxonomy) ) {			$error = & new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));			return $error;		}	}	$in_taxonomies = "'" . implode("', '", $taxonomies) . "'";	$defaults = array('orderby' => 'name', 'order' => 'ASC',		'hide_empty' => true, 'exclude' => array(), 'exclude_tree' => array(), 'include' => array(),		'number' => '', 'fields' => 'all', 'slug' => '', 'parent' => '',		'hierarchical' => true, 'child_of' => 0, 'get' => '', 'name__like' => '',		'pad_counts' => false, 'offset' => '', 'search' => '');	$args = wp_parse_args( $args, $defaults );	$args['number'] = absint( $args['number'] );	$args['offset'] = absint( $args['offset'] );	if ( !$single_taxonomy || !is_taxonomy_hierarchical($taxonomies[0]) ||		'' !== $args['parent'] ) {		$args['child_of'] = 0;		$args['hierarchical'] = false;		$args['pad_counts'] = false;	}	if ( 'all' == $args['get'] ) {		$args['child_of'] = 0;		$args['hide_empty'] = 0;		$args['hierarchical'] = false;		$args['pad_counts'] = false;	}	extract($args, EXTR_SKIP);	if ( $child_of ) {		$hierarchy = _get_term_hierarchy($taxonomies[0]);		if ( !isset($hierarchy[$child_of]) )			return $empty_array;	}	if ( $parent ) {		$hierarchy = _get_term_hierarchy($taxonomies[0]);		if ( !isset($hierarchy[$parent]) )			return $empty_array;	}	// $args can be whatever, only use the args defined in defaults to compute the key	$filter_key = ( has_filter('list_terms_exclusions') ) ? serialize($GLOBALS['wp_filter']['list_terms_exclusions']) : '';	$key = md5( serialize( compact(array_keys($defaults)) ) . serialize( $taxonomies ) . $filter_key );	$last_changed = wp_cache_get('last_changed', 'terms');	if ( !$last_changed ) {		$last_changed = time();		wp_cache_set('last_changed', $last_changed, 'terms');	}	$cache_key = "get_terms:$key:$last_changed";	$cache = wp_cache_get( $cache_key, 'terms' );	if ( false !== $cache ) {		$cache = apply_filters('get_terms', $cache, $taxonomies, $args);		return $cache;	}	$_orderby = strtolower($orderby);	if ( 'count' == $_orderby )		$orderby = 'tt.count';	else if ( 'name' == $_orderby )		$orderby = 't.name';	else if ( 'slug' == $_orderby )		$orderby = 't.slug';	else if ( 'term_group' == $_orderby )		$orderby = 't.term_group';	else if ( 'none' == $_orderby )		$orderby = '';	elseif ( empty($_orderby) || 'id' == $_orderby )		$orderby = 't.term_id';	$orderby = apply_filters( 'get_terms_orderby', $orderby, $args );	if ( !empty($orderby) )		$orderby = "ORDER BY $orderby";	else		$order = '';	$where = '';	$inclusions = '';	if ( !empty($include) ) {		$exclude = '';		$exclude_tree = '';		$interms = wp_parse_id_list($include);		foreach ( $interms as $interm ) {			if ( empty($inclusions) )				$inclusions = ' AND ( t.term_id = ' . intval($interm) . ' ';			else				$inclusions .= ' OR t.term_id = ' . intval($interm) . ' ';		}	}	if ( !empty($inclusions) )		$inclusions .= ')';	$where .= $inclusions;	$exclusions = '';	if ( !empty( $exclude_tree ) ) {		$excluded_trunks = wp_parse_id_list($exclude_tree);		foreach ( $excluded_trunks as $extrunk ) {			$excluded_children = (array) get_terms($taxonomies[0], array('child_of' => intval($extrunk), 'fields' => 'ids'));			$excluded_children[] = $extrunk;			foreach( $excluded_children as $exterm ) {				if ( empty($exclusions) )					$exclusions = ' AND ( t.term_id <> ' . intval($exterm) . ' ';				else					$exclusions .= ' AND t.term_id <> ' . intval($exterm) . ' ';			}		}	}	if ( !empty($exclude) ) {		$exterms = wp_parse_id_list($exclude);		foreach ( $exterms as $exterm ) {			if ( empty($exclusions) )				$exclusions = ' AND ( t.term_id <> ' . intval($exterm) . ' ';			else				$exclusions .= ' AND t.term_id <> ' . intval($exterm) . ' ';		}	}	if ( !empty($exclusions) )		$exclusions .= ')';	$exclusions = apply_filters('list_terms_exclusions', $exclusions, $args );	$where .= $exclusions;	if ( !empty($slug) ) {		$slug = sanitize_title($slug);		$where .= " AND t.slug = '$slug'";	}	if ( !empty($name__like) )		$where .= " AND t.name LIKE '{$name__like}%'";	if ( '' !== $parent ) {		$parent = (int) $parent;		$where .= " AND tt.parent = '$parent'";	}	if ( $hide_empty && !$hierarchical )		$where .= ' AND tt.count > 0';	// don't limit the query results when we have to descend the family tree	if ( ! empty($number) && ! $hierarchical && empty( $child_of ) && '' === $parent ) {		if ( $offset )			$limit = 'LIMIT ' . $offset . ',' . $number;		else			$limit = 'LIMIT ' . $number;	} else {		$limit = '';	}	if ( !empty($search) ) {		$search = like_escape($search);		$where .= " AND (t.name LIKE '%$search%')";	}	$selects = array();	switch ( $fields ) { 		case 'all': 			$selects = array('t.*', 'tt.*'); 			break; 		case 'ids':		case 'id=>parent': 			$selects = array('t.term_id', 'tt.parent', 'tt.count'); 			break; 		case 'names': 			$selects = array('t.term_id', 'tt.parent', 'tt.count', 't.name'); 			break; 		case 'count':			$orderby = '';			$order = ''; 			$selects = array('COUNT(*)'); 	}    $select_this = implode(', ', apply_filters( 'get_terms_fields', $selects, $args ));	$query = "SELECT $select_this FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON t.term_id = tt.term_id WHERE tt.taxonomy IN ($in_taxonomies) $where $orderby $order $limit";	if ( 'count' == $fields ) {		$term_count = $wpdb->get_var($query);		return $term_count;	}	$terms = $wpdb->get_results($query);	if ( 'all' == $fields ) {		update_term_cache($terms);	}	if ( empty($terms) ) {		wp_cache_add( $cache_key, array(), 'terms' );		$terms = apply_filters('get_terms', array(), $taxonomies, $args);		return $terms;	}	if ( $child_of ) {		$children = _get_term_hierarchy($taxonomies[0]);		if ( ! empty($children) )			$terms = & _get_term_children($child_of, $terms, $taxonomies[0]);	}	// Update term counts to include children.	if ( $pad_counts && 'all' == $fields )		_pad_term_counts($terms, $taxonomies[0]);	// Make sure we show empty categories that have children.	if ( $hierarchical && $hide_empty && is_array($terms) ) {		foreach ( $terms as $k => $term ) {			if ( ! $term->count ) {				$children = _get_term_children($term->term_id, $terms, $taxonomies[0]);				if ( is_array($children) )					foreach ( $children as $child )						if ( $child->count )							continue 2;				// It really is empty				unset($terms[$k]);			}		}	}	reset ( $terms );	$_terms = array();	if ( 'id=>parent' == $fields ) {		while ( $term = array_shift($terms) )			$_terms[$term->term_id] = $term->parent;		$terms = $_terms;	} elseif ( 'ids' == $fields ) {		while ( $term = array_shift($terms) )			$_terms[] = $term->term_id;		$terms = $_terms;	} elseif ( 'names' == $fields ) {		while ( $term = array_shift($terms) )			$_terms[] = $term->name;		$terms = $_terms;	}	if ( 0 < $number && intval(@count($terms)) > $number ) {		$terms = array_slice($terms, $offset, $number);	}	wp_cache_add( $cache_key, $terms, 'terms' );	$terms = apply_filters('get_terms', $terms, $taxonomies, $args);	return $terms;}/** * Check if Term exists. * * Returns the index of a defined term, or 0 (false) if the term doesn't exist. * * Formerly is_term(), introduced in 2.3.0. * * @package WordPress * @subpackage Taxonomy * @since 3.0.0 * * @uses $wpdb * * @param int|string $term The term to check * @param string $taxonomy The taxonomy name to use * @param int $parent ID of parent term under which to confine the exists search. * @return mixed Get the term id or Term Object, if exists. */function term_exists($term, $taxonomy = '', $parent = 0) {	global $wpdb;	$select = "SELECT term_id FROM $wpdb->terms as t WHERE ";	$tax_select = "SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy as tt ON tt.term_id = t.term_id WHERE ";	if ( is_int($term) ) {		if ( 0 == $term )			return 0;		$where = 't.term_id = %d';		if ( !empty($taxonomy) )			return $wpdb->get_row( $wpdb->prepare( $tax_select . $where . " AND tt.taxonomy = %s", $term, $taxonomy ), ARRAY_A );		else			return $wpdb->get_var( $wpdb->prepare( $select . $where, $term ) );	}	$term = trim( stripslashes( $term ) );	if ( '' === $slug = sanitize_title($term) )		return 0;	$where = 't.slug = %s';	$else_where = 't.name = %s';	$where_fields = array($slug);	$else_where_fields = array($term);	if ( !empty($taxonomy) ) {		$parent = (int) $parent;		if ( $parent > 0 ) {			$where_fields[] = $parent;			$else_where_fields[] = $parent;			$where .= ' AND tt.parent = %d';			$else_where .= ' AND tt.parent = %d';		}		$where_fields[] = $taxonomy;		$else_where_fields[] = $taxonomy;		if ( $result = $wpdb->get_row( $wpdb->prepare("SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy as tt ON tt.term_id = t.term_id WHERE $where AND tt.taxonomy = %s", $where_fields), ARRAY_A) )			return $result;		return $wpdb->get_row( $wpdb->prepare("SELECT tt.term_id, tt.term_taxonomy_id FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy as tt ON tt.term_id = t.term_id WHERE $else_where AND tt.taxonomy = %s", $else_where_fields), ARRAY_A);	}	if ( $result = $wpdb->get_var( $wpdb->prepare("SELECT term_id FROM $wpdb->terms as t WHERE $where", $where_fields) ) )		return $result;	return $wpdb->get_var( $wpdb->prepare("SELECT term_id FROM $wpdb->terms as t WHERE $else_where", $else_where_fields) );}/** * Sanitize Term all fields. * * Relys on sanitize_term_field() to sanitize the term. The difference is that * this function will sanitize <strong>all</strong> fields. The context is based * on sanitize_term_field(). * * The $term is expected to be either an array or an object. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses sanitize_term_field Used to sanitize all fields in a term * * @param array|object $term The term to check * @param string $taxonomy The taxonomy name to use * @param string $context Default is 'display'. * @return array|object Term with all fields sanitized */function sanitize_term($term, $taxonomy, $context = 'display') {	if ( 'raw' == $context )		return $term;	$fields = array('term_id', 'name', 'description', 'slug', 'count', 'parent', 'term_group');	$do_object = false;	if ( is_object($term) )		$do_object = true;	$term_id = $do_object ? $term->term_id : (isset($term['term_id']) ? $term['term_id'] : 0);	foreach ( (array) $fields as $field ) {		if ( $do_object ) {			if ( isset($term->$field) )				$term->$field = sanitize_term_field($field, $term->$field, $term_id, $taxonomy, $context);		} else {			if ( isset($term[$field]) )				$term[$field] = sanitize_term_field($field, $term[$field], $term_id, $taxonomy, $context);		}	}	if ( $do_object )		$term->filter = $context;	else		$term['filter'] = $context;	return $term;}/** * Cleanse the field value in the term based on the context. * * Passing a term field value through the function should be assumed to have * cleansed the value for whatever context the term field is going to be used. * * If no context or an unsupported context is given, then default filters will * be applied. * * There are enough filters for each context to support a custom filtering * without creating your own filter function. Simply create a function that * hooks into the filter you need. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * * @param string $field Term field to sanitize * @param string $value Search for this term value * @param int $term_id Term ID * @param string $taxonomy Taxonomy Name * @param string $context Either edit, db, display, attribute, or js. * @return mixed sanitized field */function sanitize_term_field($field, $value, $term_id, $taxonomy, $context) {	if ( 'parent' == $field  || 'term_id' == $field || 'count' == $field || 'term_group' == $field ) {		$value = (int) $value;		if ( $value < 0 )			$value = 0;	}	if ( 'raw' == $context )		return $value;	if ( 'edit' == $context ) {		$value = apply_filters("edit_term_$field", $value, $term_id, $taxonomy);		$value = apply_filters("edit_${taxonomy}_$field", $value, $term_id);		if ( 'description' == $field )			$value = format_to_edit($value);		else			$value = esc_attr($value);	} else if ( 'db' == $context ) {		$value = apply_filters("pre_term_$field", $value, $taxonomy);		$value = apply_filters("pre_${taxonomy}_$field", $value);		// Back compat filters		if ( 'slug' == $field )			$value = apply_filters('pre_category_nicename', $value);	} else if ( 'rss' == $context ) {		$value = apply_filters("term_${field}_rss", $value, $taxonomy);		$value = apply_filters("${taxonomy}_${field}_rss", $value);	} else {		// Use display filters by default.		$value = apply_filters("term_$field", $value, $term_id, $taxonomy, $context);		$value = apply_filters("${taxonomy}_$field", $value, $term_id, $context);	}	if ( 'attribute' == $context )		$value = esc_attr($value);	else if ( 'js' == $context )		$value = esc_js($value);	return $value;}/** * Count how many terms are in Taxonomy. * * Default $args is 'hide_empty' which can be 'hide_empty=true' or array('hide_empty' => true). * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses get_terms() * @uses wp_parse_args() Turns strings into arrays and merges defaults into an array. * * @param string $taxonomy Taxonomy name * @param array|string $args Overwrite defaults. See get_terms() * @return int How many terms are in $taxonomy */function wp_count_terms( $taxonomy, $args = array() ) {	$defaults = array('hide_empty' => false);	$args = wp_parse_args($args, $defaults);	// backwards compatibility	if ( isset($args['ignore_empty']) ) {		$args['hide_empty'] = $args['ignore_empty'];		unset($args['ignore_empty']);	}	$args['fields'] = 'count';	return get_terms($taxonomy, $args);}/** * Will unlink the term from the taxonomy. * * Will remove the term's relationship to the taxonomy, not the term or taxonomy * itself. The term and taxonomy will still exist. Will require the term's * object ID to perform the operation. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int $object_id The term Object Id that refers to the term * @param string|array $taxonomy List of Taxonomy Names or single Taxonomy name. */function wp_delete_object_term_relationships( $object_id, $taxonomies ) {	global $wpdb;	$object_id = (int) $object_id;	if ( !is_array($taxonomies) )		$taxonomies = array($taxonomies);	foreach ( (array) $taxonomies as $taxonomy ) {		$tt_ids = wp_get_object_terms($object_id, $taxonomy, array('fields' => 'tt_ids'));		$in_tt_ids = "'" . implode("', '", $tt_ids) . "'";		do_action( 'delete_term_relationships', $object_id, $tt_ids );		$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->term_relationships WHERE object_id = %d AND term_taxonomy_id IN ($in_tt_ids)", $object_id) );		do_action( 'deleted_term_relationships', $object_id, $tt_ids );		wp_update_term_count($tt_ids, $taxonomy);	}}/** * Removes a term from the database. * * If the term is a parent of other terms, then the children will be updated to * that term's parent. * * The $args 'default' will only override the terms found, if there is only one * term found. Any other and the found terms are used. * * The $args 'force_default' will force the term supplied as default to be * assigned even if the object was not going to be termless * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses do_action() Calls both 'delete_term' and 'delete_$taxonomy' action *	hooks, passing term object, term id. 'delete_term' gets an additional *	parameter with the $taxonomy parameter. * * @param int $term Term ID * @param string $taxonomy Taxonomy Name * @param array|string $args Optional. Change 'default' term id and override found term ids. * @return bool|WP_Error Returns false if not term; true if completes delete action. */function wp_delete_term( $term, $taxonomy, $args = array() ) {	global $wpdb;	$term = (int) $term;	if ( ! $ids = term_exists($term, $taxonomy) )		return false;	if ( is_wp_error( $ids ) )		return $ids;	$tt_id = $ids['term_taxonomy_id'];	$defaults = array();	$args = wp_parse_args($args, $defaults);	extract($args, EXTR_SKIP);	if ( isset($default) ) {		$default = (int) $default;		if ( ! term_exists($default, $taxonomy) )			unset($default);	}	// Update children to point to new parent	if ( is_taxonomy_hierarchical($taxonomy) ) {		$term_obj = get_term($term, $taxonomy);		if ( is_wp_error( $term_obj ) )			return $term_obj;		$parent = $term_obj->parent;		$edit_tt_ids = $wpdb->get_col( "SELECT `term_taxonomy_id` FROM $wpdb->term_taxonomy WHERE `parent` = " . (int)$term_obj->term_id );		do_action( 'edit_term_taxonomies', $edit_tt_ids );		$wpdb->update( $wpdb->term_taxonomy, compact( 'parent' ), array( 'parent' => $term_obj->term_id) + compact( 'taxonomy' ) );		do_action( 'edited_term_taxonomies', $edit_tt_ids );	}	$objects = $wpdb->get_col( $wpdb->prepare( "SELECT object_id FROM $wpdb->term_relationships WHERE term_taxonomy_id = %d", $tt_id ) );	foreach ( (array) $objects as $object ) {		$terms = wp_get_object_terms($object, $taxonomy, array('fields' => 'ids', 'orderby' => 'none'));		if ( 1 == count($terms) && isset($default) ) {			$terms = array($default);		} else {			$terms = array_diff($terms, array($term));			if (isset($default) && isset($force_default) && $force_default)				$terms = array_merge($terms, array($default));		}		$terms = array_map('intval', $terms);		wp_set_object_terms($object, $terms, $taxonomy);	}	do_action( 'delete_term_taxonomy', $tt_id );	$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->term_taxonomy WHERE term_taxonomy_id = %d", $tt_id ) );	do_action( 'deleted_term_taxonomy', $tt_id );	// Delete the term if no taxonomies use it.	if ( !$wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM $wpdb->term_taxonomy WHERE term_id = %d", $term) ) )		$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->terms WHERE term_id = %d", $term) );	clean_term_cache($term, $taxonomy);	do_action('delete_term', $term, $tt_id, $taxonomy);	do_action("delete_$taxonomy", $term, $tt_id);	return true;}/** * Retrieves the terms associated with the given object(s), in the supplied taxonomies. * * The following information has to do the $args parameter and for what can be * contained in the string or array of that parameter, if it exists. * * The first argument is called, 'orderby' and has the default value of 'name'. * The other value that is supported is 'count'. * * The second argument is called, 'order' and has the default value of 'ASC'. * The only other value that will be acceptable is 'DESC'. * * The final argument supported is called, 'fields' and has the default value of * 'all'. There are multiple other options that can be used instead. Supported * values are as follows: 'all', 'ids', 'names', and finally * 'all_with_object_id'. * * The fields argument also decides what will be returned. If 'all' or * 'all_with_object_id' is choosen or the default kept intact, then all matching * terms objects will be returned. If either 'ids' or 'names' is used, then an * array of all matching term ids or term names will be returned respectively. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int|array $object_id The id of the object(s) to retrieve. * @param string|array $taxonomies The taxonomies to retrieve terms from. * @param array|string $args Change what is returned * @return array|WP_Error The requested term data or empty array if no terms found. WP_Error if $taxonomy does not exist. */function wp_get_object_terms($object_ids, $taxonomies, $args = array()) {	global $wpdb;	if ( !is_array($taxonomies) )		$taxonomies = array($taxonomies);	foreach ( (array) $taxonomies as $taxonomy ) {		if ( ! taxonomy_exists($taxonomy) )			return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));	}	if ( !is_array($object_ids) )		$object_ids = array($object_ids);	$object_ids = array_map('intval', $object_ids);	$defaults = array('orderby' => 'name', 'order' => 'ASC', 'fields' => 'all');	$args = wp_parse_args( $args, $defaults );	$terms = array();	if ( count($taxonomies) > 1 ) {		foreach ( $taxonomies as $index => $taxonomy ) {			$t = get_taxonomy($taxonomy);			if ( isset($t->args) && is_array($t->args) && $args != array_merge($args, $t->args) ) {				unset($taxonomies[$index]);				$terms = array_merge($terms, wp_get_object_terms($object_ids, $taxonomy, array_merge($args, $t->args)));			}		}	} else {		$t = get_taxonomy($taxonomies[0]);		if ( isset($t->args) && is_array($t->args) )			$args = array_merge($args, $t->args);	}	extract($args, EXTR_SKIP);	if ( 'count' == $orderby )		$orderby = 'tt.count';	else if ( 'name' == $orderby )		$orderby = 't.name';	else if ( 'slug' == $orderby )		$orderby = 't.slug';	else if ( 'term_group' == $orderby )		$orderby = 't.term_group';	else if ( 'term_order' == $orderby )		$orderby = 'tr.term_order';	else if ( 'none' == $orderby ) {		$orderby = '';		$order = '';	} else {		$orderby = 't.term_id';	}	// tt_ids queries can only be none or tr.term_taxonomy_id	if ( ('tt_ids' == $fields) && !empty($orderby) )		$orderby = 'tr.term_taxonomy_id';	if ( !empty($orderby) )		$orderby = "ORDER BY $orderby";	$taxonomies = "'" . implode("', '", $taxonomies) . "'";	$object_ids = implode(', ', $object_ids);	$select_this = '';	if ( 'all' == $fields )		$select_this = 't.*, tt.*';	else if ( 'ids' == $fields )		$select_this = 't.term_id';	else if ( 'names' == $fields )		$select_this = 't.name';	else if ( 'all_with_object_id' == $fields )		$select_this = 't.*, tt.*, tr.object_id';	$query = "SELECT $select_this FROM $wpdb->terms AS t INNER JOIN $wpdb->term_taxonomy AS tt ON tt.term_id = t.term_id INNER JOIN $wpdb->term_relationships AS tr ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tt.taxonomy IN ($taxonomies) AND tr.object_id IN ($object_ids) $orderby $order";	if ( 'all' == $fields || 'all_with_object_id' == $fields ) {		$terms = array_merge($terms, $wpdb->get_results($query));		update_term_cache($terms);	} else if ( 'ids' == $fields || 'names' == $fields ) {		$terms = array_merge($terms, $wpdb->get_col($query));	} else if ( 'tt_ids' == $fields ) {		$terms = $wpdb->get_col("SELECT tr.term_taxonomy_id FROM $wpdb->term_relationships AS tr INNER JOIN $wpdb->term_taxonomy AS tt ON tr.term_taxonomy_id = tt.term_taxonomy_id WHERE tr.object_id IN ($object_ids) AND tt.taxonomy IN ($taxonomies) $orderby $order");	}	if ( ! $terms )		$terms = array();	return apply_filters('wp_get_object_terms', $terms, $object_ids, $taxonomies, $args);}/** * Adds a new term to the database. Optionally marks it as an alias of an existing term. * * Error handling is assigned for the nonexistance of the $taxonomy and $term * parameters before inserting. If both the term id and taxonomy exist * previously, then an array will be returned that contains the term id and the * contents of what is returned. The keys of the array are 'term_id' and * 'term_taxonomy_id' containing numeric values. * * It is assumed that the term does not yet exist or the above will apply. The * term will be first added to the term table and then related to the taxonomy * if everything is well. If everything is correct, then several actions will be * run prior to a filter and then several actions will be run after the filter * is run. * * The arguments decide how the term is handled based on the $args parameter. * The following is a list of the available overrides and the defaults. * * 'alias_of'. There is no default, but if added, expected is the slug that the * term will be an alias of. Expected to be a string. * * 'description'. There is no default. If exists, will be added to the database * along with the term. Expected to be a string. * * 'parent'. Expected to be numeric and default is 0 (zero). Will assign value * of 'parent' to the term. * * 'slug'. Expected to be a string. There is no default. * * If 'slug' argument exists then the slug will be checked to see if it is not * a valid term. If that check succeeds (it is not a valid term), then it is * added and the term id is given. If it fails, then a check is made to whether * the taxonomy is hierarchical and the parent argument is not empty. If the * second check succeeds, the term will be inserted and the term id will be * given. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @uses apply_filters() Calls 'pre_insert_term' hook with term and taxonomy as parameters. * @uses do_action() Calls 'create_term' hook with the term id and taxonomy id as parameters. * @uses do_action() Calls 'create_$taxonomy' hook with term id and taxonomy id as parameters. * @uses apply_filters() Calls 'term_id_filter' hook with term id and taxonomy id as parameters. * @uses do_action() Calls 'created_term' hook with the term id and taxonomy id as parameters. * @uses do_action() Calls 'created_$taxonomy' hook with term id and taxonomy id as parameters. * * @param string $term The term to add or update. * @param string $taxonomy The taxonomy to which to add the term * @param array|string $args Change the values of the inserted term * @return array|WP_Error The Term ID and Term Taxonomy ID */function wp_insert_term( $term, $taxonomy, $args = array() ) {	global $wpdb;	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid taxonomy'));	$term = apply_filters( 'pre_insert_term', $term, $taxonomy );		if ( is_wp_error( $term ) )			return $term;	if ( is_int($term) && 0 == $term )		return new WP_Error('invalid_term_id', __('Invalid term ID'));	if ( '' == trim($term) )		return new WP_Error('empty_term_name', __('A name is required for this term'));	$defaults = array( 'alias_of' => '', 'description' => '', 'parent' => 0, 'slug' => '');	$args = wp_parse_args($args, $defaults);	$args['name'] = $term;	$args['taxonomy'] = $taxonomy;	$args = sanitize_term($args, $taxonomy, 'db');	extract($args, EXTR_SKIP);	// expected_slashed ($name)	$name = stripslashes($name);	$description = stripslashes($description);	if ( empty($slug) )		$slug = sanitize_title($name);	$term_group = 0;	if ( $alias_of ) {		$alias = $wpdb->get_row( $wpdb->prepare( "SELECT term_id, term_group FROM $wpdb->terms WHERE slug = %s", $alias_of) );		if ( $alias->term_group ) {			// The alias we want is already in a group, so let's use that one.			$term_group = $alias->term_group;		} else {			// The alias isn't in a group, so let's create a new one and firstly add the alias term to it.			$term_group = $wpdb->get_var("SELECT MAX(term_group) FROM $wpdb->terms") + 1;			do_action( 'edit_terms', $alias->term_id );			$wpdb->update($wpdb->terms, compact('term_group'), array('term_id' => $alias->term_id) );			do_action( 'edited_terms', $alias->term_id );		}	}	if ( $term_id = term_exists($slug) ) {		$existing_term = $wpdb->get_row( $wpdb->prepare( "SELECT name FROM $wpdb->terms WHERE term_id = %d", $term_id), ARRAY_A );		// We've got an existing term in the same taxonomy, which matches the name of the new term:		if ( is_taxonomy_hierarchical($taxonomy) && $existing_term['name'] == $name && term_exists( (int) $term_id, $taxonomy ) ) {			// Hierarchical, and it matches an existing term, Do not allow same "name" in the same level.			$siblings = get_terms($taxonomy, array('fields' => 'names', 'get' => 'all', 'parent' => (int)$parent) );			if ( in_array($name, $siblings) ) {				return new WP_Error('term_exists', __('A term with the name provided already exists with this parent.'));			} else {				$slug = wp_unique_term_slug($slug, (object) $args);				if ( false === $wpdb->insert( $wpdb->terms, compact( 'name', 'slug', 'term_group' ) ) )					return new WP_Error('db_insert_error', __('Could not insert term into the database'), $wpdb->last_error);				$term_id = (int) $wpdb->insert_id;			}		} elseif ( $existing_term['name'] != $name ) {			// We've got an existing term, with a different name, Create the new term.			$slug = wp_unique_term_slug($slug, (object) $args);			if ( false === $wpdb->insert( $wpdb->terms, compact( 'name', 'slug', 'term_group' ) ) )				return new WP_Error('db_insert_error', __('Could not insert term into the database'), $wpdb->last_error);			$term_id = (int) $wpdb->insert_id;		} elseif ( term_exists( (int) $term_id, $taxonomy ) )  {			// Same name, same slug.			return new WP_Error('term_exists', __('A term with the name provided already exists.'));		}	} else {		// This term does not exist at all in the database, Create it.		$slug = wp_unique_term_slug($slug, (object) $args);		if ( false === $wpdb->insert( $wpdb->terms, compact( 'name', 'slug', 'term_group' ) ) )			return new WP_Error('db_insert_error', __('Could not insert term into the database'), $wpdb->last_error);		$term_id = (int) $wpdb->insert_id;	}	// Seems unreachable, However, Is used in the case that a term name is provided, which sanitizes to an empty string.	if ( empty($slug) ) {		$slug = sanitize_title($slug, $term_id);		do_action( 'edit_terms', $term_id );		$wpdb->update( $wpdb->terms, compact( 'slug' ), compact( 'term_id' ) );		do_action( 'edited_terms', $term_id );	}	$tt_id = $wpdb->get_var( $wpdb->prepare( "SELECT tt.term_taxonomy_id FROM $wpdb->term_taxonomy AS tt INNER JOIN $wpdb->terms AS t ON tt.term_id = t.term_id WHERE tt.taxonomy = %s AND t.term_id = %d", $taxonomy, $term_id ) );	if ( !empty($tt_id) )		return array('term_id' => $term_id, 'term_taxonomy_id' => $tt_id);	$wpdb->insert( $wpdb->term_taxonomy, compact( 'term_id', 'taxonomy', 'description', 'parent') + array( 'count' => 0 ) );	$tt_id = (int) $wpdb->insert_id;	do_action("create_term", $term_id, $tt_id, $taxonomy);	do_action("create_$taxonomy", $term_id, $tt_id);	$term_id = apply_filters('term_id_filter', $term_id, $tt_id);	clean_term_cache($term_id, $taxonomy);	do_action("created_term", $term_id, $tt_id, $taxonomy);	do_action("created_$taxonomy", $term_id, $tt_id);	return array('term_id' => $term_id, 'term_taxonomy_id' => $tt_id);}/** * Create Term and Taxonomy Relationships. * * Relates an object (post, link etc) to a term and taxonomy type. Creates the * term and taxonomy relationship if it doesn't already exist. Creates a term if * it doesn't exist (using the slug). * * A relationship means that the term is grouped in or belongs to the taxonomy. * A term has no meaning until it is given context by defining which taxonomy it * exists under. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int $object_id The object to relate to. * @param array|int|string $term The slug or id of the term, will replace all existing * related terms in this taxonomy. * @param array|string $taxonomy The context in which to relate the term to the object. * @param bool $append If false will delete difference of terms. * @return array|WP_Error Affected Term IDs */function wp_set_object_terms($object_id, $terms, $taxonomy, $append = false) {	global $wpdb;	$object_id = (int) $object_id;	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid Taxonomy'));	if ( !is_array($terms) )		$terms = array($terms);	if ( ! $append )		$old_tt_ids =  wp_get_object_terms($object_id, $taxonomy, array('fields' => 'tt_ids', 'orderby' => 'none'));	else		$old_tt_ids = array();	$tt_ids = array();	$term_ids = array();	foreach ( (array) $terms as $term) {		if ( !strlen(trim($term)) )			continue;		if ( !$term_info = term_exists($term, $taxonomy) ) {			// Skip if a non-existent term ID is passed.			if ( is_int($term) )				continue;			$term_info = wp_insert_term($term, $taxonomy);		}		if ( is_wp_error($term_info) )			return $term_info;		$term_ids[] = $term_info['term_id'];		$tt_id = $term_info['term_taxonomy_id'];		$tt_ids[] = $tt_id;		if ( $wpdb->get_var( $wpdb->prepare( "SELECT term_taxonomy_id FROM $wpdb->term_relationships WHERE object_id = %d AND term_taxonomy_id = %d", $object_id, $tt_id ) ) )			continue;		do_action( 'add_term_relationship', $object_id, $tt_id );		$wpdb->insert( $wpdb->term_relationships, array( 'object_id' => $object_id, 'term_taxonomy_id' => $tt_id ) );		do_action( 'added_term_relationship', $object_id, $tt_id );	}	wp_update_term_count($tt_ids, $taxonomy);	if ( ! $append ) {		$delete_terms = array_diff($old_tt_ids, $tt_ids);		if ( $delete_terms ) {			$in_delete_terms = "'" . implode("', '", $delete_terms) . "'";			do_action( 'delete_term_relationships', $object_id, $delete_terms );			$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->term_relationships WHERE object_id = %d AND term_taxonomy_id IN ($in_delete_terms)", $object_id) );			do_action( 'deleted_term_relationships', $object_id, $delete_terms );			wp_update_term_count($delete_terms, $taxonomy);		}	}	$t = get_taxonomy($taxonomy);	if ( ! $append && isset($t->sort) && $t->sort ) {		$values = array();		$term_order = 0;		$final_tt_ids = wp_get_object_terms($object_id, $taxonomy, array('fields' => 'tt_ids'));		foreach ( $tt_ids as $tt_id )			if ( in_array($tt_id, $final_tt_ids) )				$values[] = $wpdb->prepare( "(%d, %d, %d)", $object_id, $tt_id, ++$term_order);		if ( $values )			$wpdb->query("INSERT INTO $wpdb->term_relationships (object_id, term_taxonomy_id, term_order) VALUES " . join(',', $values) . " ON DUPLICATE KEY UPDATE term_order = VALUES(term_order)");	}	do_action('set_object_terms', $object_id, $terms, $tt_ids, $taxonomy, $append, $old_tt_ids);	return $tt_ids;}/** * Will make slug unique, if it isn't already. * * The $slug has to be unique global to every taxonomy, meaning that one * taxonomy term can't have a matching slug with another taxonomy term. Each * slug has to be globally unique for every taxonomy. * * The way this works is that if the taxonomy that the term belongs to is * hierarchical and has a parent, it will append that parent to the $slug. * * If that still doesn't return an unique slug, then it try to append a number * until it finds a number that is truely unique. * * The only purpose for $term is for appending a parent, if one exists. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param string $slug The string that will be tried for a unique slug * @param object $term The term object that the $slug will belong too * @return string Will return a true unique slug. */function wp_unique_term_slug($slug, $term) {	global $wpdb;	if ( ! term_exists( $slug ) )		return $slug;	// If the taxonomy supports hierarchy and the term has a parent, make the slug unique	// by incorporating parent slugs.	if ( is_taxonomy_hierarchical($term->taxonomy) && !empty($term->parent) ) {		$the_parent = $term->parent;		while ( ! empty($the_parent) ) {			$parent_term = get_term($the_parent, $term->taxonomy);			if ( is_wp_error($parent_term) || empty($parent_term) )				break;			$slug .= '-' . $parent_term->slug;			if ( ! term_exists( $slug ) )				return $slug;			if ( empty($parent_term->parent) )				break;			$the_parent = $parent_term->parent;		}	}	// If we didn't get a unique slug, try appending a number to make it unique.	if ( !empty($args['term_id']) )		$query = $wpdb->prepare( "SELECT slug FROM $wpdb->terms WHERE slug = %s AND term_id != %d", $slug, $args['term_id'] );	else		$query = $wpdb->prepare( "SELECT slug FROM $wpdb->terms WHERE slug = %s", $slug );	if ( $wpdb->get_var( $query ) ) {		$num = 2;		do {			$alt_slug = $slug . "-$num";			$num++;			$slug_check = $wpdb->get_var( $wpdb->prepare( "SELECT slug FROM $wpdb->terms WHERE slug = %s", $alt_slug ) );		} while ( $slug_check );		$slug = $alt_slug;	}	return $slug;}/** * Update term based on arguments provided. * * The $args will indiscriminately override all values with the same field name. * Care must be taken to not override important information need to update or * update will fail (or perhaps create a new term, neither would be acceptable). * * Defaults will set 'alias_of', 'description', 'parent', and 'slug' if not * defined in $args already. * * 'alias_of' will create a term group, if it doesn't already exist, and update * it for the $term. * * If the 'slug' argument in $args is missing, then the 'name' in $args will be * used. It should also be noted that if you set 'slug' and it isn't unique then * a WP_Error will be passed back. If you don't pass any slug, then a unique one * will be created for you. * * For what can be overrode in $args, check the term scheme can contain and stay * away from the term keys. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses $wpdb * @uses do_action() Will call both 'edit_term' and 'edit_$taxonomy' twice. * @uses apply_filters() Will call the 'term_id_filter' filter and pass the term *	id and taxonomy id. * * @param int $term_id The ID of the term * @param string $taxonomy The context in which to relate the term to the object. * @param array|string $args Overwrite term field values * @return array|WP_Error Returns Term ID and Taxonomy Term ID */function wp_update_term( $term_id, $taxonomy, $args = array() ) {	global $wpdb;	if ( ! taxonomy_exists($taxonomy) )		return new WP_Error('invalid_taxonomy', __('Invalid taxonomy'));	$term_id = (int) $term_id;	// First, get all of the original args	$term = get_term ($term_id, $taxonomy, ARRAY_A);	if ( is_wp_error( $term ) )		return $term;	// Escape data pulled from DB.	$term = add_magic_quotes($term);	// Merge old and new args with new args overwriting old ones.	$args = array_merge($term, $args);	$defaults = array( 'alias_of' => '', 'description' => '', 'parent' => 0, 'slug' => '');	$args = wp_parse_args($args, $defaults);	$args = sanitize_term($args, $taxonomy, 'db');	extract($args, EXTR_SKIP);	// expected_slashed ($name)	$name = stripslashes($name);	$description = stripslashes($description);	if ( '' == trim($name) )		return new WP_Error('empty_term_name', __('A name is required for this term'));	$empty_slug = false;	if ( empty($slug) ) {		$empty_slug = true;		$slug = sanitize_title($name);	}	if ( $alias_of ) {		$alias = $wpdb->get_row( $wpdb->prepare( "SELECT term_id, term_group FROM $wpdb->terms WHERE slug = %s", $alias_of) );		if ( $alias->term_group ) {			// The alias we want is already in a group, so let's use that one.			$term_group = $alias->term_group;		} else {			// The alias isn't in a group, so let's create a new one and firstly add the alias term to it.			$term_group = $wpdb->get_var("SELECT MAX(term_group) FROM $wpdb->terms") + 1;			do_action( 'edit_terms', $alias->term_id );			$wpdb->update( $wpdb->terms, compact('term_group'), array( 'term_id' => $alias->term_id ) );			do_action( 'edited_terms', $alias->term_id );		}	}	// Check for duplicate slug	$id = $wpdb->get_var( $wpdb->prepare( "SELECT term_id FROM $wpdb->terms WHERE slug = %s", $slug ) );	if ( $id && ($id != $term_id) ) {		// If an empty slug was passed or the parent changed, reset the slug to something unique.		// Otherwise, bail.		if ( $empty_slug || ( $parent != $term['parent']) )			$slug = wp_unique_term_slug($slug, (object) $args);		else			return new WP_Error('duplicate_term_slug', sprintf(__('The slug &#8220;%s&#8221; is already in use by another term'), $slug));	}	do_action( 'edit_terms', $term_id );	$wpdb->update($wpdb->terms, compact( 'name', 'slug', 'term_group' ), compact( 'term_id' ) );	if ( empty($slug) ) {		$slug = sanitize_title($name, $term_id);		$wpdb->update( $wpdb->terms, compact( 'slug' ), compact( 'term_id' ) );	}	do_action( 'edited_terms', $term_id );	$tt_id = $wpdb->get_var( $wpdb->prepare( "SELECT tt.term_taxonomy_id FROM $wpdb->term_taxonomy AS tt INNER JOIN $wpdb->terms AS t ON tt.term_id = t.term_id WHERE tt.taxonomy = %s AND t.term_id = %d", $taxonomy, $term_id) );	do_action( 'edit_term_taxonomy', $tt_id, $taxonomy );	$wpdb->update( $wpdb->term_taxonomy, compact( 'term_id', 'taxonomy', 'description', 'parent' ), array( 'term_taxonomy_id' => $tt_id ) );	do_action( 'edited_term_taxonomy', $tt_id, $taxonomy );	do_action("edit_term", $term_id, $tt_id, $taxonomy);	do_action("edit_$taxonomy", $term_id, $tt_id);	$term_id = apply_filters('term_id_filter', $term_id, $tt_id);	clean_term_cache($term_id, $taxonomy);	do_action("edited_term", $term_id, $tt_id, $taxonomy);	do_action("edited_$taxonomy", $term_id, $tt_id);	return array('term_id' => $term_id, 'term_taxonomy_id' => $tt_id);}/** * Enable or disable term counting. * * @since 2.5.0 * * @param bool $defer Optional. Enable if true, disable if false. * @return bool Whether term counting is enabled or disabled. */function wp_defer_term_counting($defer=null) {	static $_defer = false;	if ( is_bool($defer) ) {		$_defer = $defer;		// flush any deferred counts		if ( !$defer )			wp_update_term_count( null, null, true );	}	return $_defer;}/** * Updates the amount of terms in taxonomy. * * If there is a taxonomy callback applyed, then it will be called for updating * the count. * * The default action is to count what the amount of terms have the relationship * of term ID. Once that is done, then update the database. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int|array $terms The term_taxonomy_id of the terms * @param string $taxonomy The context of the term. * @return bool If no terms will return false, and if successful will return true. */function wp_update_term_count( $terms, $taxonomy, $do_deferred=false ) {	static $_deferred = array();	if ( $do_deferred ) {		foreach ( (array) array_keys($_deferred) as $tax ) {			wp_update_term_count_now( $_deferred[$tax], $tax );			unset( $_deferred[$tax] );		}	}	if ( empty($terms) )		return false;	if ( !is_array($terms) )		$terms = array($terms);	if ( wp_defer_term_counting() ) {		if ( !isset($_deferred[$taxonomy]) )			$_deferred[$taxonomy] = array();		$_deferred[$taxonomy] = array_unique( array_merge($_deferred[$taxonomy], $terms) );		return true;	}	return wp_update_term_count_now( $terms, $taxonomy );}/** * Perform term count update immediately. * * @since 2.5.0 * * @param array $terms The term_taxonomy_id of terms to update. * @param string $taxonomy The context of the term. * @return bool Always true when complete. */function wp_update_term_count_now( $terms, $taxonomy ) {	global $wpdb;	$terms = array_map('intval', $terms);	$taxonomy = get_taxonomy($taxonomy);	if ( !empty($taxonomy->update_count_callback) ) {		call_user_func($taxonomy->update_count_callback, $terms, $taxonomy);	} else {		// Default count updater		foreach ( (array) $terms as $term) {			$count = $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM $wpdb->term_relationships WHERE term_taxonomy_id = %d", $term) );			do_action( 'edit_term_taxonomy', $term, $taxonomy );			$wpdb->update( $wpdb->term_taxonomy, compact( 'count' ), array( 'term_taxonomy_id' => $term ) );			do_action( 'edited_term_taxonomy', $term, $taxonomy );		}	}	clean_term_cache($terms, '', false);	return true;}//// Cache///** * Removes the taxonomy relationship to terms from the cache. * * Will remove the entire taxonomy relationship containing term $object_id. The * term IDs have to exist within the taxonomy $object_type for the deletion to * take place. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @see get_object_taxonomies() for more on $object_type * @uses do_action() Will call action hook named, 'clean_object_term_cache' after completion. *	Passes, function params in same order. * * @param int|array $object_ids Single or list of term object ID(s) * @param array|string $object_type The taxonomy object type */function clean_object_term_cache($object_ids, $object_type) {	if ( !is_array($object_ids) )		$object_ids = array($object_ids);	foreach ( $object_ids as $id )		foreach ( get_object_taxonomies($object_type) as $taxonomy )			wp_cache_delete($id, "{$taxonomy}_relationships");	do_action('clean_object_term_cache', $object_ids, $object_type);}/** * Will remove all of the term ids from the cache. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses $wpdb * * @param int|array $ids Single or list of Term IDs * @param string $taxonomy Can be empty and will assume tt_ids, else will use for context. * @param bool $clean_taxonomy Whether to clean taxonomy wide caches (true), or just individual term object caches (false). Default is true. */function clean_term_cache($ids, $taxonomy = '', $clean_taxonomy = true) {	global $wpdb;	static $cleaned = array();	if ( !is_array($ids) )		$ids = array($ids);	$taxonomies = array();	// If no taxonomy, assume tt_ids.	if ( empty($taxonomy) ) {		$tt_ids = array_map('intval', $ids);		$tt_ids = implode(', ', $tt_ids);		$terms = $wpdb->get_results("SELECT term_id, taxonomy FROM $wpdb->term_taxonomy WHERE term_taxonomy_id IN ($tt_ids)");		$ids = array();		foreach ( (array) $terms as $term ) {			$taxonomies[] = $term->taxonomy;			$ids[] = $term->term_id;			wp_cache_delete($term->term_id, $term->taxonomy);		}		$taxonomies = array_unique($taxonomies);	} else {		$taxonomies = array($taxonomy);		foreach ( $taxonomies as $taxonomy ) {			foreach ( $ids as $id ) {				wp_cache_delete($id, $taxonomy);			}		}	}	foreach ( $taxonomies as $taxonomy ) {		if ( isset($cleaned[$taxonomy]) )			continue;		$cleaned[$taxonomy] = true;		if ( $clean_taxonomy ) {			wp_cache_delete('all_ids', $taxonomy);			wp_cache_delete('get', $taxonomy);			delete_option("{$taxonomy}_children");			// Regenerate {$taxonomy}_children			_get_term_hierarchy($taxonomy);		}		do_action('clean_term_cache', $ids, $taxonomy);	}	wp_cache_set('last_changed', time(), 'terms');}/** * Retrieves the taxonomy relationship to the term object id. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @uses wp_cache_get() Retrieves taxonomy relationship from cache * * @param int|array $id Term object ID * @param string $taxonomy Taxonomy Name * @return bool|array Empty array if $terms found, but not $taxonomy. False if nothing is in cache for $taxonomy and $id. */function &get_object_term_cache($id, $taxonomy) {	$cache = wp_cache_get($id, "{$taxonomy}_relationships");	return $cache;}/** * Updates the cache for Term ID(s). * * Will only update the cache for terms not already cached. * * The $object_ids expects that the ids be separated by commas, if it is a * string. * * It should be noted that update_object_term_cache() is very time extensive. It * is advised that the function is not called very often or at least not for a * lot of terms that exist in a lot of taxonomies. The amount of time increases * for each term and it also increases for each taxonomy the term belongs to. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * @uses wp_get_object_terms() Used to get terms from the database to update * * @param string|array $object_ids Single or list of term object ID(s) * @param array|string $object_type The taxonomy object type * @return null|bool Null value is given with empty $object_ids. False if */function update_object_term_cache($object_ids, $object_type) {	if ( empty($object_ids) )		return;	if ( !is_array($object_ids) )		$object_ids = explode(',', $object_ids);	$object_ids = array_map('intval', $object_ids);	$taxonomies = get_object_taxonomies($object_type);	$ids = array();	foreach ( (array) $object_ids as $id ) {		foreach ( $taxonomies as $taxonomy ) {			if ( false === wp_cache_get($id, "{$taxonomy}_relationships") ) {				$ids[] = $id;				break;			}		}	}	if ( empty( $ids ) )		return false;	$terms = wp_get_object_terms($ids, $taxonomies, array('fields' => 'all_with_object_id'));	$object_terms = array();	foreach ( (array) $terms as $term )		$object_terms[$term->object_id][$term->taxonomy][$term->term_id] = $term;	foreach ( $ids as $id ) {		foreach ( $taxonomies  as $taxonomy ) {			if ( ! isset($object_terms[$id][$taxonomy]) ) {				if ( !isset($object_terms[$id]) )					$object_terms[$id] = array();				$object_terms[$id][$taxonomy] = array();			}		}	}	foreach ( $object_terms as $id => $value ) {		foreach ( $value as $taxonomy => $terms ) {			wp_cache_set($id, $terms, "{$taxonomy}_relationships");		}	}}/** * Updates Terms to Taxonomy in cache. * * @package WordPress * @subpackage Taxonomy * @since 2.3.0 * * @param array $terms List of Term objects to change * @param string $taxonomy Optional. Update Term to this taxonomy in cache */function update_term_cache($terms, $taxonomy = '') {	foreach ( (array) $terms as $term ) {		$term_taxonomy = $taxonomy;		if ( empty($term_taxonomy) )			$term_taxonomy = $term->taxonomy;		wp_cache_add($term->term_id, $term, $term_taxonomy);	}}//// Private///** * Retrieves children of taxonomy as Term IDs. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * * @uses update_option() Stores all of the children in "$taxonomy_children" *	 option. That is the name of the taxonomy, immediately followed by '_children'. * * @param string $taxonomy Taxonomy Name * @return array Empty if $taxonomy isn't hierarchical or returns children as Term IDs. */function _get_term_hierarchy($taxonomy) {	if ( !is_taxonomy_hierarchical($taxonomy) )		return array();	$children = get_option("{$taxonomy}_children");	if ( is_array($children) )		return $children;	$children = array();	$terms = get_terms($taxonomy, array('get' => 'all', 'orderby' => 'id', 'fields' => 'id=>parent'));	foreach ( $terms as $term_id => $parent ) {		if ( $parent > 0 )			$children[$parent][] = $term_id;	}	update_option("{$taxonomy}_children", $children);	return $children;}/** * Get the subset of $terms that are descendants of $term_id. * * If $terms is an array of objects, then _get_term_children returns an array of objects. * If $terms is an array of IDs, then _get_term_children returns an array of IDs. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * * @param int $term_id The ancestor term: all returned terms should be descendants of $term_id. * @param array $terms The set of terms---either an array of term objects or term IDs---from which those that are descendants of $term_id will be chosen. * @param string $taxonomy The taxonomy which determines the hierarchy of the terms. * @return array The subset of $terms that are descendants of $term_id. */function &_get_term_children($term_id, $terms, $taxonomy) {	$empty_array = array();	if ( empty($terms) )		return $empty_array;	$term_list = array();	$has_children = _get_term_hierarchy($taxonomy);	if  ( ( 0 != $term_id ) && ! isset($has_children[$term_id]) )		return $empty_array;	foreach ( (array) $terms as $term ) {		$use_id = false;		if ( !is_object($term) ) {			$term = get_term($term, $taxonomy);			if ( is_wp_error( $term ) )				return $term;			$use_id = true;		}		if ( $term->term_id == $term_id )			continue;		if ( $term->parent == $term_id ) {			if ( $use_id )				$term_list[] = $term->term_id;			else				$term_list[] = $term;			if ( !isset($has_children[$term->term_id]) )				continue;			if ( $children = _get_term_children($term->term_id, $terms, $taxonomy) )				$term_list = array_merge($term_list, $children);		}	}	return $term_list;}/** * Add count of children to parent count. * * Recalculates term counts by including items from child terms. Assumes all * relevant children are already in the $terms argument. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * @uses $wpdb * * @param array $terms List of Term IDs * @param string $taxonomy Term Context * @return null Will break from function if conditions are not met. */function _pad_term_counts(&$terms, $taxonomy) {	global $wpdb;	// This function only works for hierarchical taxonomies like post categories.	if ( !is_taxonomy_hierarchical( $taxonomy ) )		return;	$term_hier = _get_term_hierarchy($taxonomy);	if ( empty($term_hier) )		return;	$term_items = array();	foreach ( (array) $terms as $key => $term ) {		$terms_by_id[$term->term_id] = & $terms[$key];		$term_ids[$term->term_taxonomy_id] = $term->term_id;	}	// Get the object and term ids and stick them in a lookup table	$tax_obj = get_taxonomy($taxonomy);	$object_types = esc_sql($tax_obj->object_type);	$results = $wpdb->get_results("SELECT object_id, term_taxonomy_id FROM $wpdb->term_relationships INNER JOIN $wpdb->posts ON object_id = ID WHERE term_taxonomy_id IN (" . implode(',', array_keys($term_ids)) . ") AND post_type IN ('" . implode("', '", $object_types) . "') AND post_status = 'publish'");	foreach ( $results as $row ) {		$id = $term_ids[$row->term_taxonomy_id];		$term_items[$id][$row->object_id] = isset($term_items[$id][$row->object_id]) ? ++$term_items[$id][$row->object_id] : 1;	}	// Touch every ancestor's lookup row for each post in each term	foreach ( $term_ids as $term_id ) {		$child = $term_id;		while ( $parent = $terms_by_id[$child]->parent ) {			if ( !empty($term_items[$term_id]) )				foreach ( $term_items[$term_id] as $item_id => $touches ) {					$term_items[$parent][$item_id] = isset($term_items[$parent][$item_id]) ? ++$term_items[$parent][$item_id]: 1;				}			$child = $parent;		}	}	// Transfer the touched cells	foreach ( (array) $term_items as $id => $items )		if ( isset($terms_by_id[$id]) )			$terms_by_id[$id]->count = count($items);}//// Default callbacks///** * Will update term count based on object types of the current taxonomy. * * Private function for the default callback for post_tag and category * taxonomies. * * @package WordPress * @subpackage Taxonomy * @access private * @since 2.3.0 * @uses $wpdb * * @param array $terms List of Term taxonomy IDs * @param object $taxonomy Current taxonomy object of terms */function _update_post_term_count( $terms, $taxonomy ) {	global $wpdb;	$object_types = is_array($taxonomy->object_type) ? $taxonomy->object_type : array($taxonomy->object_type);	$object_types = esc_sql($object_types);	foreach ( (array) $terms as $term ) {		$count = $wpdb->get_var( $wpdb->prepare( "SELECT COUNT(*) FROM $wpdb->term_relationships, $wpdb->posts WHERE $wpdb->posts.ID = $wpdb->term_relationships.object_id AND post_status = 'publish' AND post_type IN ('" . implode("', '", $object_types) . "') AND term_taxonomy_id = %d", $term ) );		do_action( 'edit_term_taxonomy', $term, $taxonomy );		$wpdb->update( $wpdb->term_taxonomy, compact( 'count' ), array( 'term_taxonomy_id' => $term ) );		do_action( 'edited_term_taxonomy', $term, $taxonomy );	}}/** * Generates a permalink for a taxonomy term archive. * * @since 2.5.0 * * @param object|int|string $term * @param string $taxonomy * @return string HTML link to taxonomy term archive */function get_term_link( $term, $taxonomy ) {	global $wp_rewrite;	if ( !is_object($term) ) {		if ( is_int($term) ) {			$term = &get_term($term, $taxonomy);		} else {			$term = &get_term_by('slug', $term, $taxonomy);		}	}	if ( !is_object($term) )		$term = new WP_Error('invalid_term', __('Empty Term'));	if ( is_wp_error( $term ) )		return $term;	// use legacy functions for core taxonomies until they are fully plugged in	if ( $taxonomy == 'category' )		return get_category_link((int) $term->term_id);	if ( $taxonomy == 'post_tag' )		return get_tag_link((int) $term->term_id);	$termlink = $wp_rewrite->get_extra_permastruct($taxonomy);	$slug = $term->slug;	if ( empty($termlink) ) {		$t = get_taxonomy($taxonomy);		if ( $t->query_var )			$termlink = "?$t->query_var=$slug";		else			$termlink = "?taxonomy=$taxonomy&term=$slug";		$termlink = home_url($termlink);	} else {		$termlink = str_replace("%$taxonomy%", $slug, $termlink);		$termlink = home_url( user_trailingslashit($termlink, 'category') );	}	return apply_filters('term_link', $termlink, $term, $taxonomy);}/** * Display the taxonomies of a post with available options. * * This function can be used within the loop to display the taxonomies for a * post without specifying the Post ID. You can also use it outside the Loop to * display the taxonomies for a specific post. * * The available defaults are: * 'post' : default is 0. The post ID to get taxonomies of. * 'before' : default is empty string. Display before taxonomies list. * 'sep' : default is empty string. Separate every taxonomy with value in this. * 'after' : default is empty string. Display this after the taxonomies list. * * @since 2.5.0 * @uses get_the_taxonomies() * * @param array $args Override the defaults. */function the_taxonomies($args = array()) {	$defaults = array(		'post' => 0,		'before' => '',		'sep' => ' ',		'after' => '',	);	$r = wp_parse_args( $args, $defaults );	extract( $r, EXTR_SKIP );	echo $before . join($sep, get_the_taxonomies($post)) . $after;}/** * Retrieve all taxonomies associated with a post. * * This function can be used within the loop. It will also return an array of * the taxonomies with links to the taxonomy and name. * * @since 2.5.0 * * @param int $post Optional. Post ID or will use Global Post ID (in loop). * @return array */function get_the_taxonomies($post = 0) {	if ( is_int($post) )		$post =& get_post($post);	elseif ( !is_object($post) )		$post =& $GLOBALS['post'];	$taxonomies = array();	if ( !$post )		return $taxonomies;	$template = apply_filters('taxonomy_template', '%s: %l.');	foreach ( get_object_taxonomies($post) as $taxonomy ) {		$t = (array) get_taxonomy($taxonomy);		if ( empty($t['label']) )			$t['label'] = $taxonomy;		if ( empty($t['args']) )			$t['args'] = array();		if ( empty($t['template']) )			$t['template'] = $template;		$terms = get_object_term_cache($post->ID, $taxonomy);		if ( empty($terms) )			$terms = wp_get_object_terms($post->ID, $taxonomy, $t['args']);		$links = array();		foreach ( $terms as $term )			$links[] = "<a href='" . esc_attr(get_term_link($term, $taxonomy)) . "'>$term->name</a>";		if ( $links )			$taxonomies[$taxonomy] = wp_sprintf($t['template'], $t['label'], $links, $terms);	}	return $taxonomies;}/** * Retrieve all taxonomies of a post with just the names. * * @since 2.5.0 * @uses get_object_taxonomies() * * @param int $post Optional. Post ID * @return array */function get_post_taxonomies($post = 0) {	$post =& get_post($post);	return get_object_taxonomies($post);}/** * Determine if the given object is associated with any of the given terms. * * The given terms are checked against the object's terms' term_ids, names and slugs. * Terms given as integers will only be checked against the object's terms' term_ids. * If no terms are given, determines if object is associated with any terms in the given taxonomy. * * @since 2.7.0 * @uses get_object_term_cache() * @uses wp_get_object_terms() * * @param int $object_id.  ID of the object (post ID, link ID, ...) * @param string $taxonomy.  Single taxonomy name * @param int|string|array $terms Optional.  Term term_id, name, slug or array of said * @return bool|WP_Error. WP_Error on input error. */function is_object_in_term( $object_id, $taxonomy, $terms = null ) {	if ( !$object_id = (int) $object_id )		return new WP_Error( 'invalid_object', __( 'Invalid object ID' ) );	$object_terms = get_object_term_cache( $object_id, $taxonomy );	if ( empty( $object_terms ) )		 $object_terms = wp_get_object_terms( $object_id, $taxonomy );	if ( is_wp_error( $object_terms ) )		return $object_terms;	if ( empty( $object_terms ) )		return false;	if ( empty( $terms ) )		return ( !empty( $object_terms ) );	$terms = (array) $terms;	if ( $ints = array_filter( $terms, 'is_int' ) )		$strs = array_diff( $terms, $ints );	else		$strs =& $terms;	foreach ( $object_terms as $object_term ) {		if ( $ints && in_array( $object_term->term_id, $ints ) ) return true; // If int, check against term_id		if ( $strs ) {			if ( in_array( $object_term->term_id, $strs ) ) return true;			if ( in_array( $object_term->name, $strs ) )    return true;			if ( in_array( $object_term->slug, $strs ) )    return true;		}	}	return false;}/** * Determine if the given object type is associated with the given taxonomy. * * @since 3.0.0 * @uses get_object_taxonomies() * * @param string $object_type Object type string * @param string $taxonomy.  Single taxonomy name * @return bool True if object is associated with the taxonomy, otherwise false. */function is_object_in_taxonomy($object_type, $taxonomy) {	$taxonomies = get_object_taxonomies($object_type);	if ( empty($taxonomies) )		return false;	if ( in_array($taxonomy, $taxonomies) )		return true;	return false;}
<?php/** * WordPress Administration for Navigation Menus * Interface functions * * @version 2.0.0 * * @package WordPress * @subpackage Administration *//** Load WordPress Administration Bootstrap */require_once( 'admin.php' );// Load all the nav menu interface functionsrequire_once( ABSPATH . 'wp-admin/includes/nav-menu.php' );if ( ! current_theme_supports( 'menus' ) && ! current_theme_supports( 'widgets' ) )	wp_die( __( 'Your theme does not support navigation menus or widgets.' ) );// Permissions Checkif ( ! current_user_can('edit_theme_options') )	wp_die( __( 'Cheatin&#8217; uh?' ) );// Nav Menu CSSwp_admin_css( 'nav-menu' );// jQuerywp_enqueue_script( 'jquery' );wp_enqueue_script( 'jquery-ui-draggable' );wp_enqueue_script( 'jquery-ui-droppable' );wp_enqueue_script( 'jquery-ui-sortable' );// Nav Menu functionswp_enqueue_script( 'nav-menu' );// Metaboxeswp_enqueue_script( 'common' );wp_enqueue_script( 'wp-lists' );wp_enqueue_script( 'postbox' );// Container for any messages displayed to the user$messages = array();// Container that stores the name of the active menu$nav_menu_selected_title = '';// The menu id of the current menu being edited$nav_menu_selected_id = isset( $_REQUEST['menu'] ) ? (int) $_REQUEST['menu'] : 0;// Allowed actions: add, update, delete$action = isset( $_REQUEST['action'] ) ? $_REQUEST['action'] : 'edit';switch ( $action ) {	case 'add-menu-item':		check_admin_referer( 'add-menu_item', 'menu-settings-column-nonce' );		if ( isset( $_REQUEST['nav-menu-locations'] ) )			set_theme_mod( 'nav_menu_locations', array_map( 'absint', $_REQUEST['menu-locations'] ) );		elseif ( isset( $_REQUEST['menu-item'] ) )			wp_save_nav_menu_items( $nav_menu_selected_id, $_REQUEST['menu-item'] );		break;	case 'move-down-menu-item' :		// moving down a menu item is the same as moving up the next in order		check_admin_referer( 'move-menu_item' );		$menu_item_id = isset( $_REQUEST['menu-item'] ) ? (int) $_REQUEST['menu-item'] : 0;		if ( is_nav_menu_item( $menu_item_id ) ) {			$menus = isset( $_REQUEST['menu'] ) ? array( (int) $_REQUEST['menu'] ) : wp_get_object_terms( $menu_item_id, 'nav_menu', array( 'fields' => 'ids' ) );			if ( ! is_wp_error( $menus ) && ! empty( $menus[0] ) ) {				$menu_id = (int) $menus[0];				$ordered_menu_items = wp_get_nav_menu_items( $menu_id );				$menu_item_data = (array) wp_setup_nav_menu_item( get_post( $menu_item_id ) );				// setup the data we need in one pass through the array of menu items				$dbids_to_orders = array();				$orders_to_dbids = array();				foreach( (array) $ordered_menu_items as $ordered_menu_item_object ) {					if ( isset( $ordered_menu_item_object->ID ) ) {						if ( isset( $ordered_menu_item_object->menu_order ) ) {							$dbids_to_orders[$ordered_menu_item_object->ID] = $ordered_menu_item_object->menu_order;							$orders_to_dbids[$ordered_menu_item_object->menu_order] = $ordered_menu_item_object->ID;						}					}				}				// get next in order				if (					isset( $orders_to_dbids[$dbids_to_orders[$menu_item_id] + 1] )				) {					$next_item_id = $orders_to_dbids[$dbids_to_orders[$menu_item_id] + 1];					$next_item_data = (array) wp_setup_nav_menu_item( get_post( $next_item_id ) );					// if not siblings of same parent, bubble menu item up but keep order					if (						! empty( $menu_item_data['menu_item_parent'] ) &&						(							empty( $next_item_data['menu_item_parent'] ) ||							$next_item_data['menu_item_parent'] != $menu_item_data['menu_item_parent']						)					) {						$parent_db_id = in_array( $menu_item_data['menu_item_parent'], $orders_to_dbids ) ? (int) $menu_item_data['menu_item_parent'] : 0;						$parent_object = wp_setup_nav_menu_item( get_post( $parent_db_id ) );						if ( ! is_wp_error( $parent_object ) ) {							$parent_data = (array) $parent_object;							$menu_item_data['menu_item_parent'] = $parent_data['menu_item_parent'];							update_post_meta( $menu_item_data['ID'], '_menu_item_menu_item_parent', (int) $menu_item_data['menu_item_parent'] );						}					// make menu item a child of its next sibling					} else {						$next_item_data['menu_order'] = $next_item_data['menu_order'] - 1;						$menu_item_data['menu_order'] = $menu_item_data['menu_order'] + 1;						$menu_item_data['menu_item_parent'] = $next_item_data['ID'];						update_post_meta( $menu_item_data['ID'], '_menu_item_menu_item_parent', (int) $menu_item_data['menu_item_parent'] );						wp_update_post($menu_item_data);						wp_update_post($next_item_data);					}				// the item is last but still has a parent, so bubble up				} elseif (					! empty( $menu_item_data['menu_item_parent'] ) &&					in_array( $menu_item_data['menu_item_parent'], $orders_to_dbids )				) {					$menu_item_data['menu_item_parent'] = (int) get_post_meta( $menu_item_data['menu_item_parent'], '_menu_item_menu_item_parent', true);					update_post_meta( $menu_item_data['ID'], '_menu_item_menu_item_parent', (int) $menu_item_data['menu_item_parent'] );				}			}		}		break;	case 'move-up-menu-item' :		check_admin_referer( 'move-menu_item' );		$menu_item_id = isset( $_REQUEST['menu-item'] ) ? (int) $_REQUEST['menu-item'] : 0;		if ( is_nav_menu_item( $menu_item_id ) ) {			$menus = isset( $_REQUEST['menu'] ) ? array( (int) $_REQUEST['menu'] ) : wp_get_object_terms( $menu_item_id, 'nav_menu', array( 'fields' => 'ids' ) );			if ( ! is_wp_error( $menus ) && ! empty( $menus[0] ) ) {				$menu_id = (int) $menus[0];				$ordered_menu_items = wp_get_nav_menu_items( $menu_id );				$menu_item_data = (array) wp_setup_nav_menu_item( get_post( $menu_item_id ) );				// setup the data we need in one pass through the array of menu items				$dbids_to_orders = array();				$orders_to_dbids = array();				foreach( (array) $ordered_menu_items as $ordered_menu_item_object ) {					if ( isset( $ordered_menu_item_object->ID ) ) {						if ( isset( $ordered_menu_item_object->menu_order ) ) {							$dbids_to_orders[$ordered_menu_item_object->ID] = $ordered_menu_item_object->menu_order;							$orders_to_dbids[$ordered_menu_item_object->menu_order] = $ordered_menu_item_object->ID;						}					}				}				// if this menu item is not first				if ( ! empty( $dbids_to_orders[$menu_item_id] ) && ! empty( $orders_to_dbids[$dbids_to_orders[$menu_item_id] - 1] ) ) {					// if this menu item is a child of the previous					if (						! empty( $menu_item_data['menu_item_parent'] ) &&						in_array( $menu_item_data['menu_item_parent'], array_keys( $dbids_to_orders ) ) &&						isset( $orders_to_dbids[$dbids_to_orders[$menu_item_id] - 1] ) &&						( $menu_item_data['menu_item_parent'] == $orders_to_dbids[$dbids_to_orders[$menu_item_id] - 1] )					) {						$parent_db_id = in_array( $menu_item_data['menu_item_parent'], $orders_to_dbids ) ? (int) $menu_item_data['menu_item_parent'] : 0;						$parent_object = wp_setup_nav_menu_item( get_post( $parent_db_id ) );						if ( ! is_wp_error( $parent_object ) ) {							$parent_data = (array) $parent_object;							// if there is something before the parent and parent a child of it, make menu item a child also of it							if (								! empty( $dbids_to_orders[$parent_db_id] ) &&								! empty( $orders_to_dbids[$dbids_to_orders[$parent_db_id] - 1] ) &&								! empty( $parent_data['menu_item_parent'] )							) {								$menu_item_data['menu_item_parent'] = $parent_data['menu_item_parent'];							// else if there is something before parent and parent not a child of it, make menu item a child of that something's parent							} elseif (								! empty( $dbids_to_orders[$parent_db_id] ) &&								! empty( $orders_to_dbids[$dbids_to_orders[$parent_db_id] - 1] )							) {								$_possible_parent_id = (int) get_post_meta( $orders_to_dbids[$dbids_to_orders[$parent_db_id] - 1], '_menu_item_menu_item_parent', true);								if ( in_array( $_possible_parent_id, array_keys( $dbids_to_orders ) ) )									$menu_item_data['menu_item_parent'] = $_possible_parent_id;								else									$menu_item_data['menu_item_parent'] = 0;							// else there isn't something before the parent							} else {								$menu_item_data['menu_item_parent'] = 0;							}							// set former parent's [menu_order] to that of menu-item's							$parent_data['menu_order'] = $parent_data['menu_order'] + 1;							// set menu-item's [menu_order] to that of former parent							$menu_item_data['menu_order'] = $menu_item_data['menu_order'] - 1;							// save changes							update_post_meta( $menu_item_data['ID'], '_menu_item_menu_item_parent', (int) $menu_item_data['menu_item_parent'] );							wp_update_post($menu_item_data);							wp_update_post($parent_data);						}					// else this menu item is not a child of the previous					} elseif (						empty( $menu_item_data['menu_order'] ) ||						empty( $menu_item_data['menu_item_parent'] ) ||						! in_array( $menu_item_data['menu_item_parent'], array_keys( $dbids_to_orders ) ) ||						empty( $orders_to_dbids[$dbids_to_orders[$menu_item_id] - 1] ) ||						$orders_to_dbids[$dbids_to_orders[$menu_item_id] - 1] != $menu_item_data['menu_item_parent']					) {						// just make it a child of the previous; keep the order						$menu_item_data['menu_item_parent'] = (int) $orders_to_dbids[$dbids_to_orders[$menu_item_id] - 1];						update_post_meta( $menu_item_data['ID'], '_menu_item_menu_item_parent', (int) $menu_item_data['menu_item_parent'] );						wp_update_post($menu_item_data);					}				}			}		}		break;	case 'delete-menu-item':		$menu_item_id = (int) $_REQUEST['menu-item'];		check_admin_referer( 'delete-menu_item_' . $menu_item_id );		if ( is_nav_menu_item( $menu_item_id ) && wp_delete_post( $menu_item_id, true ) )			$messages[] = '<div id="message" class="updated"><p>' . __('The menu item has been successfully deleted.') . '</p></div>';		break;	case 'delete':		check_admin_referer( 'delete-nav_menu-' . $nav_menu_selected_id );		if ( is_nav_menu( $nav_menu_selected_id ) ) {			$deleted_nav_menu = wp_get_nav_menu_object( $nav_menu_selected_id );			$delete_nav_menu = wp_delete_nav_menu( $nav_menu_selected_id );			if ( is_wp_error($delete_nav_menu) ) {				$messages[] = '<div id="message" class="error"><p>' . $delete_nav_menu->get_error_message() . '</p></div>';			} else {				// Remove this menu from any locations.				$locations = get_theme_mod( 'nav_menu_locations' );				foreach ( (array) $locations as $location => $menu_id ) {					if ( $menu_id == $nav_menu_selected_id )						$locations[ $location ] = 0;				}				set_theme_mod( 'nav_menu_locations', $locations );				$messages[] = '<div id="message" class="updated"><p>' . __('The menu has been successfully deleted.') . '</p></div>';				// Select the next available menu				$nav_menu_selected_id = 0;				$_nav_menus = wp_get_nav_menus( array('orderby' => 'name') );				foreach( $_nav_menus as $index => $_nav_menu ) {					if ( strcmp( $_nav_menu->name, $deleted_nav_menu->name ) >= 0					 || $index == count( $_nav_menus ) - 1 ) {						$nav_menu_selected_id = $_nav_menu->term_id;						break;					}				}			}			unset( $delete_nav_menu, $deleted_nav_menu, $_nav_menus );		} else {			// Reset the selected menu			$nav_menu_selected_id = 0;			unset( $_REQUEST['menu'] );		}		break;	case 'update':		check_admin_referer( 'update-nav_menu', 'update-nav-menu-nonce' );		// Update menu theme locations		if ( isset( $_POST['menu-locations'] ) )			set_theme_mod( 'nav_menu_locations', array_map( 'absint', $_POST['menu-locations'] ) );		// Add Menu		if ( 0 == $nav_menu_selected_id ) {			$new_menu_title = trim( esc_html( $_POST['menu-name'] ) );			if ( $new_menu_title ) {				$_nav_menu_selected_id = wp_update_nav_menu_object( 0, array('menu-name' => $new_menu_title) );				if ( is_wp_error( $_nav_menu_selected_id ) ) {					$messages[] = '<div id="message" class="error"><p>' . $_nav_menu_selected_id->get_error_message() . '</p></div>';				} else {					if ( ( $_menu_locations = get_registered_nav_menus() ) && 1 == count( wp_get_nav_menus() ) )						set_theme_mod( 'nav_menu_locations', array( key( $_menu_locations ) => $_nav_menu_selected_id ) );					unset( $_menu_locations );					$_menu_object = wp_get_nav_menu_object( $_nav_menu_selected_id );					$nav_menu_selected_id = $_nav_menu_selected_id;					$nav_menu_selected_title = $_menu_object->name;					$messages[] = '<div id="message" class="updated"><p>' . sprintf( __('The <strong>%s</strong> menu has been successfully created.'), $nav_menu_selected_title ) . '</p></div>';				}			} else {				$messages[] = '<div id="message" class="error"><p>' . __('Please enter a valid menu name.') . '</p></div>';			}		// update existing menu		} else {			$_menu_object = wp_get_nav_menu_object( $nav_menu_selected_id );			$menu_title = trim( esc_html( $_POST['menu-name'] ) );			if ( ! $menu_title ) {				$messages[] = '<div id="message" class="error"><p>' . __('Please enter a valid menu name.') . '</p></div>';				$menu_title = $_menu_object->name;			}			if ( ! is_wp_error( $_menu_object ) ) {				$_nav_menu_selected_id = wp_update_nav_menu_object( $nav_menu_selected_id, array( 'menu-name' => $menu_title ) );				if ( is_wp_error( $_nav_menu_selected_id ) ) {					$_menu_object = $_nav_menu_selected_id;					$messages[] = '<div id="message" class="error"><p>' . $_nav_menu_selected_id->get_error_message() . '</p></div>';				} else {					$_menu_object = wp_get_nav_menu_object( $_nav_menu_selected_id );					$nav_menu_selected_title = $_menu_object->name;				}			}			// Update menu items			if ( ! is_wp_error( $_menu_object ) ) {				$unsorted_menu_items = wp_get_nav_menu_items( $nav_menu_selected_id, array('orderby' => 'ID', 'output' => ARRAY_A, 'output_key' => 'ID', 'post_status' => 'draft,publish') );				$menu_items = array();				// Index menu items by db ID				foreach( $unsorted_menu_items as $_item )					$menu_items[$_item->db_id] = $_item;				$post_fields = array( 'menu-item-db-id', 'menu-item-object-id', 'menu-item-object', 'menu-item-parent-id', 'menu-item-position', 'menu-item-type', 'menu-item-title', 'menu-item-url', 'menu-item-description', 'menu-item-attr-title', 'menu-item-target', 'menu-item-classes', 'menu-item-xfn' );				wp_defer_term_counting(true);				// Loop through all the menu items' POST variables				if ( ! empty( $_POST['menu-item-db-id'] ) ) {					foreach( (array) $_POST['menu-item-db-id'] as $_key => $k ) {						// Menu item title can't be blank						if ( empty( $_POST['menu-item-title'][$_key] ) )							continue;						$args = array();						foreach ( $post_fields as $field )							$args[$field] = isset( $_POST[$field][$_key] ) ? $_POST[$field][$_key] : '';						$menu_item_db_id = wp_update_nav_menu_item( $nav_menu_selected_id, ( $_POST['menu-item-db-id'][$_key] != $_key ? 0 : $_key ), $args );						if ( is_wp_error( $menu_item_db_id ) )							$messages[] = '<div id="message" class="error"><p>' . $menu_item_db_id->get_error_message() . '</p></div>';						elseif ( isset( $menu_items[$menu_item_db_id] ) )							unset( $menu_items[$menu_item_db_id] );					}				}				// Remove menu items from the menu that weren't in $_POST				if ( ! empty( $menu_items ) ) {					foreach ( array_keys( $menu_items ) as $menu_item_id ) {						if ( is_nav_menu_item( $menu_item_id ) ) {							wp_delete_post( $menu_item_id );						}					}				}				// Store 'auto-add' pages.				$auto_add = ! empty( $_POST['auto-add-pages'] );				$nav_menu_option = (array) get_option( 'nav_menu_options' );				if ( ! isset( $nav_menu_option['auto_add'] ) )					$nav_menu_option['auto_add'] = array();				if ( $auto_add ) {					if ( ! in_array( $nav_menu_selected_id, $nav_menu_option['auto_add'] ) )						$nav_menu_option['auto_add'][] = $nav_menu_selected_id;				} else {					if ( false !== ( $key = array_search( $nav_menu_selected_id, $nav_menu_option['auto_add'] ) ) )						unset( $nav_menu_option['auto_add'][$key] );				}				// Remove nonexistent/deleted menus				$nav_menu_option['auto_add'] = array_intersect( $nav_menu_option['auto_add'], wp_get_nav_menus( array( 'fields' => 'ids' ) ) );				update_option( 'nav_menu_options', $nav_menu_option );				wp_defer_term_counting(false);				do_action( 'wp_update_nav_menu', $nav_menu_selected_id );				$messages[] = '<div id="message" class="updated"><p>' . sprintf( __('The <strong>%s</strong> menu has been updated.'), $nav_menu_selected_title ) . '</p></div>';				unset( $menu_items, $unsorted_menu_items );			}		}		break;}// Get all nav menus$nav_menus = wp_get_nav_menus( array('orderby' => 'name') );// Get recently edited nav menu$recently_edited = (int) get_user_option( 'nav_menu_recently_edited' );// If there was no recently edited menu, and $nav_menu_selected_id is a nav menu, update recently edited menu.if ( !$recently_edited && is_nav_menu( $nav_menu_selected_id ) ) {	$recently_edited = $nav_menu_selected_id;// Else if $nav_menu_selected_id is not a menu and not requesting that we create a new menu, but $recently_edited is a menu, grab that one.} elseif ( 0 == $nav_menu_selected_id && ! isset( $_REQUEST['menu'] ) && is_nav_menu( $recently_edited ) ) {	$nav_menu_selected_id = $recently_edited;// Else try to grab the first menu from the menus list} elseif ( 0 == $nav_menu_selected_id && ! isset( $_REQUEST['menu'] ) && ! empty($nav_menus) ) {	$nav_menu_selected_id = $nav_menus[0]->term_id;}// Update the user's settingif ( $nav_menu_selected_id != $recently_edited && is_nav_menu( $nav_menu_selected_id ) )	update_user_meta( $current_user->ID, 'nav_menu_recently_edited', $nav_menu_selected_id );// If there's a menu, get its name.if ( ! $nav_menu_selected_title && is_nav_menu( $nav_menu_selected_id ) ) {	$_menu_object = wp_get_nav_menu_object( $nav_menu_selected_id );	$nav_menu_selected_title = ! is_wp_error( $_menu_object ) ? $_menu_object->name : '';}// Generate truncated menu namesforeach( (array) $nav_menus as $key => $_nav_menu ) {	$_nav_menu->truncated_name = trim( wp_html_excerpt( $_nav_menu->name, 40 ) );	if ( $_nav_menu->truncated_name != $_nav_menu->name )		$_nav_menu->truncated_name .= '&hellip;';	$nav_menus[$key]->truncated_name = $_nav_menu->truncated_name;}// Ensure the user will be able to scroll horizontally// by adding a class for the max menu depth.global $_wp_nav_menu_max_depth;$_wp_nav_menu_max_depth = 0;// Calling wp_get_nav_menu_to_edit generates $_wp_nav_menu_max_depthif ( is_nav_menu( $nav_menu_selected_id ) )	$edit_markup = wp_get_nav_menu_to_edit( $nav_menu_selected_id  );function wp_nav_menu_max_depth() {	global $_wp_nav_menu_max_depth;	return "menu-max-depth-$_wp_nav_menu_max_depth";}add_action('admin_body_class','wp_nav_menu_max_depth');wp_nav_menu_setup();wp_initial_nav_menu_meta_boxes();if ( ! current_theme_supports( 'menus' ) && ! wp_get_nav_menus() )	echo '<div id="message" class="updated"><p>' . __('The current theme does not natively support menus, but you can use the &#8220;Custom Menu&#8221; widget to add any menus you create here to the theme&#8217;s sidebar.') . '</p></div>';$help =  '<p>' . __('This feature is new in version 3.0; to use a custom menu in place of your theme&#8217;s default menus, support for this feature must be registered in the theme&#8217;s functions.php file. If your theme does not support the custom menus feature yet (the new default theme, Twenty Ten, does), you can learn about adding support yourself by following the below link.') . '</p>';$help .= '<p>' . __('You can create custom menus for your site. These menus may contain links to pages, categories, custom links or other content types (use the Screen Options tab to decide which ones to show on the screen). You can specify a different navigation label for a menu item as well as other attributes. You can create multiple menus. If your theme includes more than one menu, you can choose which custom menu to associate with each. You can also use custom menus in conjunction with the Custom Menus widget.') . '</p>';$help .= '<p>' . __('To create a new custom menu, click on the + tab, give the menu a name, and click Create Menu. Next, add menu items from the appropriate boxes. You&#8217;ll be able to edit the information for each menu item, and can drag and drop to put them in order. You can also drag a menu item a little to the right to make it a submenu, to create menus with hierarchy. You&#8217;ll see when the position of the drop target shifts over to create the nested placement. Don&#8217;t forget to click Save when you&#8217;re finished.') . '</p>';$help .= '<p><strong>' . __('For more information:') . '</strong></p>';$help .= '<p>' . __('<a href="http://codex.wordpress.org/Appearance_Menus_SubPanel" target="_blank">Menus Documentation</a>') . '</p>';$help .= '<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>';add_contextual_help($current_screen, $help);// Get the admin headerrequire_once( 'admin-header.php' );?><div class="wrap">	<?php screen_icon(); ?>	<h2><?php esc_html_e('Menus'); ?></h2>	<?php	foreach( $messages as $message ) :		echo $message . "\n";	endforeach;	?>	<div id="nav-menus-frame">	<div id="menu-settings-column" class="metabox-holder<?php if ( !$nav_menu_selected_id ) { echo ' metabox-holder-disabled'; } ?>">		<form id="nav-menu-meta" action="<?php echo admin_url( 'nav-menus.php' ); ?>" class="nav-menu-meta" method="post" enctype="multipart/form-data">			<input type="hidden" name="menu" id="nav-menu-meta-object-id" value="<?php echo esc_attr( $nav_menu_selected_id ); ?>" />			<input type="hidden" name="action" value="add-menu-item" />			<?php wp_nonce_field( 'add-menu_item', 'menu-settings-column-nonce' ); ?>			<?php do_meta_boxes( 'nav-menus', 'side', null ); ?>		</form>	</div><!-- /#menu-settings-column -->	<div id="menu-management-liquid">		<div id="menu-management">			<div id="select-nav-menu-container" class="hide-if-js">				<form id="select-nav-menu" action="">					<strong><label for="select-nav-menu"><?php esc_html_e( 'Select Menu:' ); ?></label></strong>					<select class="select-nav-menu" name="menu">						<?php foreach( (array) $nav_menus as $_nav_menu ) : ?>							<option value="<?php echo esc_attr($_nav_menu->term_id) ?>" <?php selected($nav_menu_selected_id, $_nav_menu->term_id); ?>>								<?php echo esc_html( $_nav_menu->truncated_name ); ?>							</option>						<?php endforeach; ?>						<option value="0"><?php esc_html_e('Add New Menu'); ?></option>					</select>					<input type="hidden" name="action" value="edit" />					<input class="button-secondary" name="select_menu" type="submit" value="<?php esc_attr_e('Select'); ?>" />				</form>			</div>			<div class="nav-tabs-wrapper">			<div class="nav-tabs">				<?php				foreach( (array) $nav_menus as $_nav_menu ) :					if ( $nav_menu_selected_id == $_nav_menu->term_id ) : ?><span class="nav-tab nav-tab-active">							<?php echo esc_html( $_nav_menu->truncated_name ); ?>						</span><?php else : ?><a href="<?php							echo esc_url(add_query_arg(								array(									'action' => 'edit',									'menu' => $_nav_menu->term_id,								),								admin_url( 'nav-menus.php' )							));						?>" class="nav-tab hide-if-no-js">							<?php echo esc_html( $_nav_menu->truncated_name ); ?>						</a><?php endif;				endforeach;				if ( 0 == $nav_menu_selected_id ) : ?><span class="nav-tab menu-add-new nav-tab-active">					<?php printf( '<abbr title="%s">+</abbr>', esc_html__( 'Add menu' ) ); ?>				</span><?php else : ?><a href="<?php					echo esc_url(add_query_arg(						array(							'action' => 'edit',							'menu' => 0,						),						admin_url( 'nav-menus.php' )					));				?>" class="nav-tab menu-add-new">					<?php printf( '<abbr title="%s">+</abbr>', esc_html__( 'Add menu' ) ); ?>				</a><?php endif; ?>			</div>			</div>			<div class="menu-edit">				<form id="update-nav-menu" action="<?php echo admin_url( 'nav-menus.php' ); ?>" method="post" enctype="multipart/form-data">					<div id="nav-menu-header">						<div id="submitpost" class="submitbox">							<div class="major-publishing-actions">								<label class="menu-name-label howto open-label" for="menu-name">									<span><?php _e('Menu Name'); ?></span>									<input name="menu-name" id="menu-name" type="text" class="menu-name regular-text menu-item-textbox input-with-default-title" title="<?php esc_attr_e('Enter menu name here'); ?>" value="<?php echo esc_attr( $nav_menu_selected_title  ); ?>" />								</label>								<?php if ( !empty( $nav_menu_selected_id ) ) :									if ( ! isset( $auto_add ) ) {										$auto_add = get_option( 'nav_menu_options' );										if ( ! isset( $auto_add['auto_add'] ) )											$auto_add = false;										elseif ( false !== array_search( $nav_menu_selected_id, $auto_add['auto_add'] ) )											$auto_add = true;										else											$auto_add = false;									}								?>								<div class="auto-add-pages">									<label class="howto"><input type="checkbox"<?php checked( $auto_add ); ?> name="auto-add-pages" value="1" /> <?php printf( __('Automatically add new top-level pages' ), esc_url( admin_url( 'edit.php?post_type=page' ) ) ); ?></label>								</div>								<?php endif; ?>								<br class="clear" />								<div class="publishing-action">									<input class="button-primary menu-save" name="save_menu" type="submit" value="<?php empty($nav_menu_selected_id) ? esc_attr_e('Create Menu') : esc_attr_e('Save Menu'); ?>" />								</div><!-- END .publishing-action -->								<?php if ( ! empty( $nav_menu_selected_id ) ) : ?>								<div class="delete-action">									<a class="submitdelete deletion menu-delete" href="<?php echo esc_url( wp_nonce_url( admin_url('nav-menus.php?action=delete&amp;menu=' . $nav_menu_selected_id), 'delete-nav_menu-' . $nav_menu_selected_id ) ); ?>"><?php _e('Delete Menu'); ?></a>								</div><!-- END .delete-action -->								<?php endif; ?>							</div><!-- END .major-publishing-actions -->						</div><!-- END #submitpost .submitbox -->						<?php						wp_nonce_field( 'closedpostboxes', 'closedpostboxesnonce', false );						wp_nonce_field( 'meta-box-order', 'meta-box-order-nonce', false );						wp_nonce_field( 'update-nav_menu', 'update-nav-menu-nonce' );						?>						<input type="hidden" name="action" value="update" />						<input type="hidden" name="menu" id="menu" value="<?php echo esc_attr( $nav_menu_selected_id ); ?>" />					</div><!-- END #nav-menu-header -->					<div id="post-body">						<div id="post-body-content">							<?php							if ( isset( $edit_markup ) ) {								if ( ! is_wp_error( $edit_markup ) )									echo $edit_markup;							} else if ( empty( $nav_menu_selected_id ) ) {								echo '<div class="post-body-plain">';								echo '<p>' . __('To create a custom menu, give it a name above and click Create Menu. Then choose items like pages, categories or custom links from the left column to add to this menu.') . '</p>';								echo '<p>' . __('After you have added your items, drag and drop to put them in the order you want. You can also click each item to reveal additional configuration options.') . '</p>';								echo '<p>' . __('When you have finished building your custom menu, make sure you click the Save Menu button.') . '</p>';								echo '</div>';							}							?>						</div><!-- /#post-body-content -->					</div><!-- /#post-body -->				</form><!-- /#update-nav-menu -->			</div><!-- /.menu-edit -->		</div><!-- /#menu-management -->	</div><!-- /#menu-management-liquid -->	</div><!-- /#nav-menus-frame --></div><!-- /.wrap--><?php include( 'admin-footer.php' ); ?>
<?php/** * The loop that displays posts. * * The loop displays the posts and the post content.  See * http://codex.wordpress.org/The_Loop to understand it and * http://codex.wordpress.org/Template_Tags to understand * the tags used in it. * * This can be overridden in child themes with loop.php or * loop-template.php, where 'template' is the loop context * requested by a template. For example, loop-index.php would * be used if it exists and we ask for the loop with: * <code>get_template_part( 'loop', 'index' );</code> * * @package WordPress * @subpackage Twenty_Ten * @since Twenty Ten 1.0 */?><?php /* Display navigation to next/previous pages when applicable */ ?><?php if ( $wp_query->max_num_pages > 1 ) : ?>	<div id="nav-above" class="navigation">		<div class="nav-previous"><?php next_posts_link( __( '<span class="meta-nav">&larr;</span> Older posts', 'twentyten' ) ); ?></div>		<div class="nav-next"><?php previous_posts_link( __( 'Newer posts <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?></div>	</div><!-- #nav-above --><?php endif; ?><?php /* If there are no posts to display, such as an empty archive page */ ?><?php if ( ! have_posts() ) : ?>	<div id="post-0" class="post error404 not-found">		<h1 class="entry-title"><?php _e( 'Not Found', 'twentyten' ); ?></h1>		<div class="entry-content">			<p><?php _e( 'Apologies, but no results were found for the requested archive. Perhaps searching will help find a related post.', 'twentyten' ); ?></p>			<?php get_search_form(); ?>		</div><!-- .entry-content -->	</div><!-- #post-0 --><?php endif; ?><?php	/* Start the Loop.	 *	 * In Twenty Ten we use the same loop in multiple contexts.	 * It is broken into three main parts: when we're displaying	 * posts that are in the gallery category, when we're displaying	 * posts in the asides category, and finally all other posts.	 *	 * Additionally, we sometimes check for whether we are on an	 * archive page, a search page, etc., allowing for small differences	 * in the loop on each template without actually duplicating	 * the rest of the loop that is shared.	 *	 * Without further ado, the loop:	 */ ?><?php while ( have_posts() ) : the_post(); ?><?php /* How to display posts in the Gallery category. */ ?>	<?php if ( in_category( _x('gallery', 'gallery category slug', 'twentyten') ) ) : ?>		<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>			<h2 class="entry-title"><a href="<?php the_permalink(); ?>" title="<?php printf( esc_attr__( 'Permalink to %s', 'twentyten' ), the_title_attribute( 'echo=0' ) ); ?>" rel="bookmark"><?php the_title(); ?></a></h2>			<div class="entry-meta">				<?php twentyten_posted_on(); ?>			</div><!-- .entry-meta -->			<div class="entry-content"><?php if ( post_password_required() ) : ?>				<?php the_content(); ?><?php else : ?>				<div class="gallery-thumb"><?php	$images = get_children( array( 'post_parent' => $post->ID, 'post_type' => 'attachment', 'post_mime_type' => 'image', 'orderby' => 'menu_order', 'order' => 'ASC', 'numberposts' => 999 ) );	$total_images = count( $images );	$image = array_shift( $images );	$image_img_tag = wp_get_attachment_image( $image->ID, 'thumbnail' );?>					<a class="size-thumbnail" href="<?php the_permalink(); ?>"><?php echo $image_img_tag; ?></a>				</div><!-- .gallery-thumb -->				<p><em><?php printf( __( 'This gallery contains <a %1$s>%2$s photos</a>.', 'twentyten' ),						'href="' . get_permalink() . '" title="' . sprintf( esc_attr__( 'Permalink to %s', 'twentyten' ), the_title_attribute( 'echo=0' ) ) . '" rel="bookmark"',						$total_images					); ?></em></p>				<?php the_excerpt(); ?><?php endif; ?>			</div><!-- .entry-content -->			<div class="entry-utility">				<a href="<?php echo get_term_link( _x('gallery', 'gallery category slug', 'twentyten'), 'category' ); ?>" title="<?php esc_attr_e( 'View posts in the Gallery category', 'twentyten' ); ?>"><?php _e( 'More Galleries', 'twentyten' ); ?></a>				<span class="meta-sep">|</span>				<span class="comments-link"><?php comments_popup_link( __( 'Leave a comment', 'twentyten' ), __( '1 Comment', 'twentyten' ), __( '% Comments', 'twentyten' ) ); ?></span>				<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="meta-sep">|</span> <span class="edit-link">', '</span>' ); ?>			</div><!-- .entry-utility -->		</div><!-- #post-## --><?php /* How to display posts in the asides category */ ?>	<?php elseif ( in_category( _x('asides', 'asides category slug', 'twentyten') ) ) : ?>		<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>		<?php if ( is_archive() || is_search() ) : // Display excerpts for archives and search. ?>			<div class="entry-summary">				<?php the_excerpt(); ?>			</div><!-- .entry-summary -->		<?php else : ?>			<div class="entry-content">				<?php the_content( __( 'Continue reading <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?>			</div><!-- .entry-content -->		<?php endif; ?>			<div class="entry-utility">				<?php twentyten_posted_on(); ?>				<span class="meta-sep">|</span>				<span class="comments-link"><?php comments_popup_link( __( 'Leave a comment', 'twentyten' ), __( '1 Comment', 'twentyten' ), __( '% Comments', 'twentyten' ) ); ?></span>				<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="meta-sep">|</span> <span class="edit-link">', '</span>' ); ?>			</div><!-- .entry-utility -->		</div><!-- #post-## --><?php /* How to display all other posts. */ ?>	<?php else : ?>		<div id="post-<?php the_ID(); ?>" <?php post_class(); ?>>			<h2 class="entry-title"><a href="<?php the_permalink(); ?>" title="<?php printf( esc_attr__( 'Permalink to %s', 'twentyten' ), the_title_attribute( 'echo=0' ) ); ?>" rel="bookmark"><?php the_title(); ?></a></h2>			<div class="entry-meta">				<?php twentyten_posted_on(); ?>			</div><!-- .entry-meta -->	<?php if ( is_archive() || is_search() ) : // Only display excerpts for archives and search. ?>			<div class="entry-summary">				<?php the_excerpt(); ?>			</div><!-- .entry-summary -->	<?php else : ?>			<div class="entry-content">				<?php the_content( __( 'Continue reading <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?>				<?php wp_link_pages( array( 'before' => '<div class="page-link">' . __( 'Pages:', 'twentyten' ), 'after' => '</div>' ) ); ?>			</div><!-- .entry-content -->	<?php endif; ?>			<div class="entry-utility">				<?php if ( count( get_the_category() ) ) : ?>					<span class="cat-links">						<?php printf( __( '<span class="%1$s">Posted in</span> %2$s', 'twentyten' ), 'entry-utility-prep entry-utility-prep-cat-links', get_the_category_list( ', ' ) ); ?>					</span>					<span class="meta-sep">|</span>				<?php endif; ?>				<?php					$tags_list = get_the_tag_list( '', ', ' );					if ( $tags_list ):				?>					<span class="tag-links">						<?php printf( __( '<span class="%1$s">Tagged</span> %2$s', 'twentyten' ), 'entry-utility-prep entry-utility-prep-tag-links', $tags_list ); ?>					</span>					<span class="meta-sep">|</span>				<?php endif; ?>				<span class="comments-link"><?php comments_popup_link( __( 'Leave a comment', 'twentyten' ), __( '1 Comment', 'twentyten' ), __( '% Comments', 'twentyten' ) ); ?></span>				<?php edit_post_link( __( 'Edit', 'twentyten' ), '<span class="meta-sep">|</span> <span class="edit-link">', '</span>' ); ?>			</div><!-- .entry-utility -->		</div><!-- #post-## -->		<?php comments_template( '', true ); ?>	<?php endif; // This was the if statement that broke the loop into three parts based on categories. ?><?php endwhile; // End the loop. Whew. ?><?php /* Display navigation to next/previous pages when applicable */ ?><?php if (  $wp_query->max_num_pages > 1 ) : ?>				<div id="nav-below" class="navigation">					<div class="nav-previous"><?php next_posts_link( __( '<span class="meta-nav">&larr;</span> Older posts', 'twentyten' ) ); ?></div>					<div class="nav-next"><?php previous_posts_link( __( 'Newer posts <span class="meta-nav">&rarr;</span>', 'twentyten' ) ); ?></div>				</div><!-- #nav-below --><?php endif; ?>
<?php/** * Post advanced form for inclusion in the administration panels. * * @package WordPress * @subpackage Administration */// don't load directlyif ( !defined('ABSPATH') )	die('-1');wp_enqueue_script('post');if ( post_type_supports($post_type, 'editor') ) {	if ( user_can_richedit() )		wp_enqueue_script('editor');	wp_enqueue_script('word-count');}if ( post_type_supports($post_type, 'editor') || post_type_supports($post_type, 'thumbnail') ) {	add_thickbox();	wp_enqueue_script('media-upload');}/** * Post ID global * @name $post_ID * @var int */$post_ID = isset($post_ID) ? (int) $post_ID : 0;$temp_ID = isset($temp_ID) ? (int) $temp_ID : 0;$user_ID = isset($user_ID) ? (int) $user_ID : 0;$action = isset($action) ? $action : '';$messages = array();$messages['post'] = array(	 0 => '', // Unused. Messages start at index 1.	 1 => sprintf( __('Post updated. <a href="%s">View post</a>'), esc_url( get_permalink($post_ID) ) ),	 2 => __('Custom field updated.'),	 3 => __('Custom field deleted.'),	 4 => __('Post updated.'),	/* translators: %s: date and time of the revision */	 5 => isset($_GET['revision']) ? sprintf( __('Post restored to revision from %s'), wp_post_revision_title( (int) $_GET['revision'], false ) ) : false,	 6 => sprintf( __('Post published. <a href="%s">View post</a>'), esc_url( get_permalink($post_ID) ) ),	 7 => __('Post saved.'),	 8 => sprintf( __('Post submitted. <a target="_blank" href="%s">Preview post</a>'), esc_url( add_query_arg( 'preview', 'true', get_permalink($post_ID) ) ) ),	 9 => sprintf( __('Post scheduled for: <strong>%1$s</strong>. <a target="_blank" href="%2$s">Preview post</a>'),		// translators: Publish box date format, see http://php.net/date		date_i18n( __( 'M j, Y @ G:i' ), strtotime( $post->post_date ) ), esc_url( get_permalink($post_ID) ) ),	10 => sprintf( __('Post draft updated. <a target="_blank" href="%s">Preview post</a>'), esc_url( add_query_arg( 'preview', 'true', get_permalink($post_ID) ) ) ),);$messages['page'] = array(	 0 => '', // Unused. Messages start at index 1.	 1 => sprintf( __('Page updated. <a href="%s">View page</a>'), esc_url( get_permalink($post_ID) ) ),	 2 => __('Custom field updated.'),	 3 => __('Custom field deleted.'),	 4 => __('Page updated.'),	 5 => isset($_GET['revision']) ? sprintf( __('Page restored to revision from %s'), wp_post_revision_title( (int) $_GET['revision'], false ) ) : false,	 6 => sprintf( __('Page published. <a href="%s">View page</a>'), esc_url( get_permalink($post_ID) ) ),	 7 => __('Page saved.'),	 8 => sprintf( __('Page submitted. <a target="_blank" href="%s">Preview page</a>'), esc_url( add_query_arg( 'preview', 'true', get_permalink($post_ID) ) ) ),	 9 => sprintf( __('Page scheduled for: <strong>%1$s</strong>. <a target="_blank" href="%2$s">Preview page</a>'), date_i18n( __( 'M j, Y @ G:i' ), strtotime( $post->post_date ) ), esc_url( get_permalink($post_ID) ) ),	10 => sprintf( __('Page draft updated. <a target="_blank" href="%s">Preview page</a>'), esc_url( add_query_arg( 'preview', 'true', get_permalink($post_ID) ) ) ),);$messages = apply_filters( 'post_updated_messages', $messages );$message = false;if ( isset($_GET['message']) ) {	$_GET['message'] = absint( $_GET['message'] );	if ( isset($messages[$post_type][$_GET['message']]) )		$message = $messages[$post_type][$_GET['message']];	elseif ( !isset($messages[$post_type]) && isset($messages['post'][$_GET['message']]) )		$message = $messages['post'][$_GET['message']];}$notice = false;$form_extra = '';if ( 'auto-draft' == $post->post_status ) {	if ( 'edit' == $action )		$post->post_title = '';	$autosave = false;	$form_extra .= "<input type='hidden' id='auto_draft' name='auto_draft' value='1' />";} else {	$autosave = wp_get_post_autosave( $post_ID );}$form_action = 'editpost';$nonce_action = 'update-' . $post_type . '_' . $post_ID;$form_extra .= "<input type='hidden' id='post_ID' name='post_ID' value='" . esc_attr($post_ID) . "' />";// Detect if there exists an autosave newer than the post and if that autosave is different than the postif ( $autosave && mysql2date( 'U', $autosave->post_modified_gmt, false ) > mysql2date( 'U', $post->post_modified_gmt, false ) ) {	foreach ( _wp_post_revision_fields() as $autosave_field => $_autosave_field ) {		if ( normalize_whitespace( $autosave->$autosave_field ) != normalize_whitespace( $post->$autosave_field ) ) {			$notice = sprintf( __( 'There is an autosave of this post that is more recent than the version below.  <a href="%s">View the autosave</a>' ), get_edit_post_link( $autosave->ID ) );			break;		}	}	unset($autosave_field, $_autosave_field);}$post_type_object = get_post_type_object($post_type);// All meta boxes should be defined and added before the first do_meta_boxes() call (or potentially during the do_meta_boxes action).require_once('./includes/meta-boxes.php');add_meta_box('submitdiv', __('Publish'), 'post_submit_meta_box', $post_type, 'side', 'core');// all taxonomiesforeach ( get_object_taxonomies($post_type) as $tax_name ) {	$taxonomy = get_taxonomy($tax_name);	if ( ! $taxonomy->show_ui )		continue;	$label = $taxonomy->labels->name;	if ( !is_taxonomy_hierarchical($tax_name) )		add_meta_box('tagsdiv-' . $tax_name, $label, 'post_tags_meta_box', $post_type, 'side', 'core', array( 'taxonomy' => $tax_name ));	else		add_meta_box($tax_name . 'div', $label, 'post_categories_meta_box', $post_type, 'side', 'core', array( 'taxonomy' => $tax_name ));}if ( post_type_supports($post_type, 'page-attributes') )	add_meta_box('pageparentdiv', 'page' == $post_type ? __('Page Attributes') : __('Attributes'), 'page_attributes_meta_box', $post_type, 'side', 'core');if ( current_theme_supports( 'post-thumbnails', $post_type ) && post_type_supports( $post_type, 'thumbnail' )	&& ( ! is_multisite() || ( ( $mu_media_buttons = get_site_option( 'mu_media_buttons', array() ) ) && ! empty( $mu_media_buttons['image'] ) ) ) )		add_meta_box('postimagediv', __('Featured Image'), 'post_thumbnail_meta_box', $post_type, 'side', 'low');if ( post_type_supports($post_type, 'excerpt') )	add_meta_box('postexcerpt', __('Excerpt'), 'post_excerpt_meta_box', $post_type, 'normal', 'core');if ( post_type_supports($post_type, 'trackbacks') )	add_meta_box('trackbacksdiv', __('Send Trackbacks'), 'post_trackback_meta_box', $post_type, 'normal', 'core');if ( post_type_supports($post_type, 'custom-fields') )	add_meta_box('postcustom', __('Custom Fields'), 'post_custom_meta_box', $post_type, 'normal', 'core');do_action('dbx_post_advanced');if ( post_type_supports($post_type, 'comments') )	add_meta_box('commentstatusdiv', __('Discussion'), 'post_comment_status_meta_box', $post_type, 'normal', 'core');if ( ('publish' == $post->post_status || 'private' == $post->post_status) && post_type_supports($post_type, 'comments') )	add_meta_box('commentsdiv', __('Comments'), 'post_comment_meta_box', $post_type, 'normal', 'core');if ( !( 'pending' == $post->post_status && !current_user_can( $post_type_object->cap->publish_posts ) ) )	add_meta_box('slugdiv', __('Slug'), 'post_slug_meta_box', $post_type, 'normal', 'core');if ( post_type_supports($post_type, 'author') ) {	$authors = get_editable_user_ids( $current_user->id ); // TODO: ROLE SYSTEM	if ( $post->post_author && !in_array($post->post_author, $authors) )		$authors[] = $post->post_author;	if ( ( $authors && count( $authors ) > 1 ) || is_super_admin() )		add_meta_box('authordiv', __('Author'), 'post_author_meta_box', $post_type, 'normal', 'core');}if ( post_type_supports($post_type, 'revisions') && 0 < $post_ID && wp_get_post_revisions( $post_ID ) )	add_meta_box('revisionsdiv', __('Revisions'), 'post_revisions_meta_box', $post_type, 'normal', 'core');do_action('add_meta_boxes', $post_type, $post);do_action('add_meta_boxes_' . $post_type, $post);do_action('do_meta_boxes', $post_type, 'normal', $post);do_action('do_meta_boxes', $post_type, 'advanced', $post);do_action('do_meta_boxes', $post_type, 'side', $post);if ( 'post' == $post_type ) {	add_contextual_help($current_screen,	'<p>' . __('The title field and the big Post Editing Area are fixed in place, but you can reposition all the other boxes that allow you to add metadata to your post using drag and drop, and can minimize or expand them by clicking the title bar of the box. You can also hide any of the boxes by using the Screen Options tab, where you can also choose a 1- or 2-column layout for this screen.') . '</p>' .	'<p>' . __('<strong>Title</strong> - Enter a title for your post. After you enter a title, you&#8217;ll see the permalink below, which you can edit.') . '</p>' .	'<p>' . __('<strong>Post editor</strong> - Enter the text for your post. There are two modes of editing: Visual and HTML. Choose the mode by clicking on the appropriate tab. Visual mode gives you a WYSIWYG editor. Click the last icon in the row to get a second row of controls. The HTML mode allows you to enter raw HTML along with your post text. You can insert media files by clicking the icons above the post editor and following the directions.') . '</p>' .	'<p>' . __('<strong>Publish</strong> - You can set the terms of publishing your post in the Publish box. For Status, Visibility, and Publish (immediately), click on the Edit link to reveal more options. Visibility includes options for password-protecting a post or making it stay at the top of your blog indefinitely (sticky). Publish (immediately) allows you to set a future or past date and time, so you can schedule a post to be published in the future or backdate a post.') . '</p>' .	'<p>' . __('<strong>Featured Image</strong> - This allows you to associate an image with your post without inserting it. This is usually useful only if your theme makes use of the featured image as a post thumbnail on the home page, a custom header, etc.') . '</p>' .	'<p>' . __('<strong>Send Trackbacks</strong> - Trackbacks are a way to notify legacy blog systems that you&#8217;ve linked to them. Enter the URL(s) you want to send trackbacks. If you link to other WordPress sites they&#8217;ll be notified automatically using pingbacks, and this field is unnecessary.') . '</p>' .	'<p>' . __('<strong>Discussion</strong> - You can turn comments and pings on or off, and if there are comments on the post, you can see them here and moderate them.') . '</p>' .	'<p>' . sprintf(__('You can also create posts with the <a href="%s">Press This bookmarklet</a>.'), 'options-writing.php') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Writing_Posts" target="_blank">Documentation on Writing Posts</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>'	);} elseif ( 'page' == $post_type ) {	add_contextual_help($current_screen, '<p>' . __('Pages are similar to Posts in that they have a title, body text, and associated metadata, but they are different in that they are not part of the chronological blog stream, kind of like permanent posts. Pages are not categorized or tagged, but can have a hierarchy. You can nest Pages under other Pages by making one the &#8220;Parent&#8221; of the other, creating a group of Pages.') . '</p>' .	'<p>' . __('Creating a Page is very similar to creating a Post, and the screens can be customized in the same way using drag and drop, the Screen Options tab, and expanding/collapsing boxes as you choose. The Page editor mostly works the same Post editor, but there are some Page-specific features in the Page Attributes box:') . '</p>' .	'<p>' . __('<strong>Parent</strong> - You can arrange your pages in hierarchies. For example, you could have an &#8220;About&#8221; page that has &#8220;Life Story&#8221; and &#8220;My Dog&#8221; pages under it. There are no limits to how many levels you can nest pages.') . '</p>' .	'<p>' . __('<strong>Template</strong> - Some themes have custom templates you can use for certain pages that might have additional features or custom layouts. If so, you&#8217;ll see them in this dropdown menu.') . '</p>' .	'<p>' . __('<strong>Order</strong> - Pages are usually ordered alphabetically, but you can choose your own order by entering a number (1 for first, etc.) in this field.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Pages_Add_New_SubPanel" target="_blank">Page Creation Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>'	);}require_once('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2><?php if ( $notice ) : ?><div id="notice" class="error"><p><?php echo $notice ?></p></div><?php endif; ?><?php if ( $message ) : ?><div id="message" class="updated"><p><?php echo $message; ?></p></div><?php endif; ?><form name="post" action="post.php" method="post" id="post"<?php do_action('post_edit_form_tag'); ?>><?php wp_nonce_field($nonce_action); ?><input type="hidden" id="user-id" name="user_ID" value="<?php echo (int) $user_ID ?>" /><input type="hidden" id="hiddenaction" name="action" value="<?php echo esc_attr($form_action) ?>" /><input type="hidden" id="originalaction" name="originalaction" value="<?php echo esc_attr($form_action) ?>" /><input type="hidden" id="post_author" name="post_author" value="<?php echo esc_attr( $post->post_author ); ?>" /><input type="hidden" id="post_type" name="post_type" value="<?php echo esc_attr($post_type) ?>" /><input type="hidden" id="original_post_status" name="original_post_status" value="<?php echo esc_attr($post->post_status) ?>" /><input type="hidden" id="referredby" name="referredby" value="<?php echo esc_url(stripslashes(wp_get_referer())); ?>" /><?phpif ( 'draft' != $post->post_status )	wp_original_referer_field(true, 'previous');echo $form_extra;wp_nonce_field( 'autosave', 'autosavenonce', false );wp_nonce_field( 'meta-box-order', 'meta-box-order-nonce', false );wp_nonce_field( 'closedpostboxes', 'closedpostboxesnonce', false );?><div id="poststuff" class="metabox-holder<?php echo 2 == $screen_layout_columns ? ' has-right-sidebar' : ''; ?>"><div id="side-info-column" class="inner-sidebar"><?php('page' == $post_type) ? do_action('submitpage_box') : do_action('submitpost_box');$side_meta_boxes = do_meta_boxes($post_type, 'side', $post);?></div><div id="post-body"><div id="post-body-content"><?php if ( post_type_supports($post_type, 'title') ) { ?><div id="titlediv"><div id="titlewrap">	<label class="hide-if-no-js" style="visibility:hidden" id="title-prompt-text" for="title"><?php _e('Enter title here') ?></label>	<input type="text" name="post_title" size="30" tabindex="1" value="<?php echo esc_attr( htmlspecialchars( $post->post_title ) ); ?>" id="title" autocomplete="off" /></div><div class="inside"><?php$sample_permalink_html = get_sample_permalink_html($post->ID);$shortlink = wp_get_shortlink($post->ID, 'post');if ( !empty($shortlink) )    $sample_permalink_html .= '<input id="shortlink" type="hidden" value="' . esc_attr($shortlink) . '" /><a href="#" class="button" onclick="prompt(&#39;URL:&#39;, jQuery(\'#shortlink\').val()); return false;">' . __('Get Shortlink') . '</a>';if ( !( 'pending' == $post->post_status && !current_user_can( $post_type_object->cap->publish_posts ) ) ) { ?>	<div id="edit-slug-box">	<?php		if ( ! empty($post->ID) && ! empty($sample_permalink_html) && 'auto-draft' != $post->post_status )			echo $sample_permalink_html;	?>	</div><?php}?></div><?phpwp_nonce_field( 'samplepermalink', 'samplepermalinknonce', false );?></div><?php } ?><?php if ( post_type_supports($post_type, 'editor') ) { ?><div id="<?php echo user_can_richedit() ? 'postdivrich' : 'postdiv'; ?>" class="postarea"><?php the_editor($post->post_content); ?><table id="post-status-info" cellspacing="0"><tbody><tr>	<td id="wp-word-count"></td>	<td class="autosave-info">	<span id="autosave">&nbsp;</span><?php	if ( 'auto-draft' != $post->post_status ) {		echo '<span id="last-edit">';		if ( $last_id = get_post_meta($post_ID, '_edit_last', true) ) {			$last_user = get_userdata($last_id);			printf(__('Last edited by %1$s on %2$s at %3$s'), esc_html( $last_user->display_name ), mysql2date(get_option('date_format'), $post->post_modified), mysql2date(get_option('time_format'), $post->post_modified));		} else {			printf(__('Last edited on %1$s at %2$s'), mysql2date(get_option('date_format'), $post->post_modified), mysql2date(get_option('time_format'), $post->post_modified));		}		echo '</span>';	} ?>	</td></tr></tbody></table></div><?php}do_meta_boxes($post_type, 'normal', $post);( 'page' == $post_type ) ? do_action('edit_page_form') : do_action('edit_form_advanced');do_meta_boxes($post_type, 'advanced', $post);do_action('dbx_post_sidebar'); ?></div></div><br class="clear" /></div><!-- /poststuff --></form></div><?php wp_comment_reply(); ?><?php if ((isset($post->post_title) && '' == $post->post_title) || (isset($_GET['message']) && 2 > $_GET['message'])) : ?><script type="text/javascript">try{document.post.title.focus();}catch(e){}</script><?php endif; ?>
<?php/** * Main WordPress API * * @package WordPress *//** * Converts MySQL DATETIME field to user specified date format. * * If $dateformatstring has 'G' value, then gmmktime() function will be used to * make the time. If $dateformatstring is set to 'U', then mktime() function * will be used to make the time. * * The $translate will only be used, if it is set to true and it is by default * and if the $wp_locale object has the month and weekday set. * * @since 0.71 * * @param string $dateformatstring Either 'G', 'U', or php date format. * @param string $mysqlstring Time from mysql DATETIME field. * @param bool $translate Optional. Default is true. Will switch format to locale. * @return string Date formated by $dateformatstring or locale (if available). */function mysql2date( $dateformatstring, $mysqlstring, $translate = true ) {	$m = $mysqlstring;	if ( empty( $m ) )		return false;	if ( 'G' == $dateformatstring ) {		return strtotime( $m . ' +0000' );	}	$i = strtotime( $m );	if ( 'U' == $dateformatstring )		return $i;	if ( $translate)	    return date_i18n( $dateformatstring, $i );	else	    return date( $dateformatstring, $i );}/** * Retrieve the current time based on specified type. * * The 'mysql' type will return the time in the format for MySQL DATETIME field. * The 'timestamp' type will return the current timestamp. * * If $gmt is set to either '1' or 'true', then both types will use GMT time. * if $gmt is false, the output is adjusted with the GMT offset in the WordPress option. * * @since 1.0.0 * * @param string $type Either 'mysql' or 'timestamp'. * @param int|bool $gmt Optional. Whether to use GMT timezone. Default is false. * @return int|string String if $type is 'gmt', int if $type is 'timestamp'. */function current_time( $type, $gmt = 0 ) {	switch ( $type ) {		case 'mysql':			return ( $gmt ) ? gmdate( 'Y-m-d H:i:s' ) : gmdate( 'Y-m-d H:i:s', ( time() + ( get_option( 'gmt_offset' ) * 3600 ) ) );			break;		case 'timestamp':			return ( $gmt ) ? time() : time() + ( get_option( 'gmt_offset' ) * 3600 );			break;	}}/** * Retrieve the date in localized format, based on timestamp. * * If the locale specifies the locale month and weekday, then the locale will * take over the format for the date. If it isn't, then the date format string * will be used instead. * * @since 0.71 * * @param string $dateformatstring Format to display the date. * @param int $unixtimestamp Optional. Unix timestamp. * @param bool $gmt Optional, default is false. Whether to convert to GMT for time. * @return string The date, translated if locale specifies it. */function date_i18n( $dateformatstring, $unixtimestamp = false, $gmt = false ) {	global $wp_locale;	$i = $unixtimestamp;	// Sanity check for PHP 5.1.0-	if ( false === $i || intval($i) < 0 ) {		if ( ! $gmt )			$i = current_time( 'timestamp' );		else			$i = time();		// we should not let date() interfere with our		// specially computed timestamp		$gmt = true;	}	// store original value for language with untypical grammars	// see http://core.trac.wordpress.org/ticket/9396	$req_format = $dateformatstring;	$datefunc = $gmt? 'gmdate' : 'date';	if ( ( !empty( $wp_locale->month ) ) && ( !empty( $wp_locale->weekday ) ) ) {		$datemonth = $wp_locale->get_month( $datefunc( 'm', $i ) );		$datemonth_abbrev = $wp_locale->get_month_abbrev( $datemonth );		$dateweekday = $wp_locale->get_weekday( $datefunc( 'w', $i ) );		$dateweekday_abbrev = $wp_locale->get_weekday_abbrev( $dateweekday );		$datemeridiem = $wp_locale->get_meridiem( $datefunc( 'a', $i ) );		$datemeridiem_capital = $wp_locale->get_meridiem( $datefunc( 'A', $i ) );		$dateformatstring = ' '.$dateformatstring;		$dateformatstring = preg_replace( "/([^\\\])D/", "\\1" . backslashit( $dateweekday_abbrev ), $dateformatstring );		$dateformatstring = preg_replace( "/([^\\\])F/", "\\1" . backslashit( $datemonth ), $dateformatstring );		$dateformatstring = preg_replace( "/([^\\\])l/", "\\1" . backslashit( $dateweekday ), $dateformatstring );		$dateformatstring = preg_replace( "/([^\\\])M/", "\\1" . backslashit( $datemonth_abbrev ), $dateformatstring );		$dateformatstring = preg_replace( "/([^\\\])a/", "\\1" . backslashit( $datemeridiem ), $dateformatstring );		$dateformatstring = preg_replace( "/([^\\\])A/", "\\1" . backslashit( $datemeridiem_capital ), $dateformatstring );		$dateformatstring = substr( $dateformatstring, 1, strlen( $dateformatstring ) -1 );	}	$j = @$datefunc( $dateformatstring, $i );	// allow plugins to redo this entirely for languages with untypical grammars	$j = apply_filters('date_i18n', $j, $req_format, $i, $gmt);	return $j;}/** * Convert integer number to format based on the locale. * * @since 2.3.0 * * @param int $number The number to convert based on locale. * @param int $decimals Precision of the number of decimal places. * @return string Converted number in string format. */function number_format_i18n( $number, $decimals = 0 ) {	global $wp_locale;	$formatted = number_format( $number, absint( $decimals ), $wp_locale->number_format['decimal_point'], $wp_locale->number_format['thousands_sep'] );	return apply_filters( 'number_format_i18n', $formatted );}/** * Convert number of bytes largest unit bytes will fit into. * * It is easier to read 1kB than 1024 bytes and 1MB than 1048576 bytes. Converts * number of bytes to human readable number by taking the number of that unit * that the bytes will go into it. Supports TB value. * * Please note that integers in PHP are limited to 32 bits, unless they are on * 64 bit architecture, then they have 64 bit size. If you need to place the * larger size then what PHP integer type will hold, then use a string. It will * be converted to a double, which should always have 64 bit length. * * Technically the correct unit names for powers of 1024 are KiB, MiB etc. * @link http://en.wikipedia.org/wiki/Byte * * @since 2.3.0 * * @param int|string $bytes Number of bytes. Note max integer size for integers. * @param int $decimals Precision of number of decimal places. Deprecated. * @return bool|string False on failure. Number string on success. */function size_format( $bytes, $decimals = 0 ) {	$quant = array(		// ========================= Origin ====		'TB' => 1099511627776,  // pow( 1024, 4)		'GB' => 1073741824,     // pow( 1024, 3)		'MB' => 1048576,        // pow( 1024, 2)		'kB' => 1024,           // pow( 1024, 1)		'B ' => 1,              // pow( 1024, 0)	);	foreach ( $quant as $unit => $mag )		if ( doubleval($bytes) >= $mag )			return number_format_i18n( $bytes / $mag, $decimals ) . ' ' . $unit;	return false;}/** * Get the week start and end from the datetime or date string from mysql. * * @since 0.71 * * @param string $mysqlstring Date or datetime field type from mysql. * @param int $start_of_week Optional. Start of the week as an integer. * @return array Keys are 'start' and 'end'. */function get_weekstartend( $mysqlstring, $start_of_week = '' ) {	$my = substr( $mysqlstring, 0, 4 ); // Mysql string Year	$mm = substr( $mysqlstring, 8, 2 ); // Mysql string Month	$md = substr( $mysqlstring, 5, 2 ); // Mysql string day	$day = mktime( 0, 0, 0, $md, $mm, $my ); // The timestamp for mysqlstring day.	$weekday = date( 'w', $day ); // The day of the week from the timestamp	if ( !is_numeric($start_of_week) )		$start_of_week = get_option( 'start_of_week' );	if ( $weekday < $start_of_week )		$weekday += 7;	$start = $day - 86400 * ( $weekday - $start_of_week ); // The most recent week start day on or before $day	$end = $start + 604799; // $start + 7 days - 1 second	return compact( 'start', 'end' );}/** * Unserialize value only if it was serialized. * * @since 2.0.0 * * @param string $original Maybe unserialized original, if is needed. * @return mixed Unserialized data can be any type. */function maybe_unserialize( $original ) {	if ( is_serialized( $original ) ) // don't attempt to unserialize data that wasn't serialized going in		return @unserialize( $original );	return $original;}/** * Check value to find if it was serialized. * * If $data is not an string, then returned value will always be false. * Serialized data is always a string. * * @since 2.0.5 * * @param mixed $data Value to check to see if was serialized. * @return bool False if not serialized and true if it was. */function is_serialized( $data ) {	// if it isn't a string, it isn't serialized	if ( !is_string( $data ) )		return false;	$data = trim( $data );	if ( 'N;' == $data )		return true;	if ( !preg_match( '/^([adObis]):/', $data, $badions ) )		return false;	switch ( $badions[1] ) {		case 'a' :		case 'O' :		case 's' :			if ( preg_match( "/^{$badions[1]}:[0-9]+:.*[;}]\$/s", $data ) )				return true;			break;		case 'b' :		case 'i' :		case 'd' :			if ( preg_match( "/^{$badions[1]}:[0-9.E-]+;\$/", $data ) )				return true;			break;	}	return false;}/** * Check whether serialized data is of string type. * * @since 2.0.5 * * @param mixed $data Serialized data * @return bool False if not a serialized string, true if it is. */function is_serialized_string( $data ) {	// if it isn't a string, it isn't a serialized string	if ( !is_string( $data ) )		return false;	$data = trim( $data );	if ( preg_match( '/^s:[0-9]+:.*;$/s', $data ) ) // this should fetch all serialized strings		return true;	return false;}/** * Retrieve option value based on name of option. * * If the option does not exist or does not have a value, then the return value * will be false. This is useful to check whether you need to install an option * and is commonly used during installation of plugin options and to test * whether upgrading is required. * * If the option was serialized then it will be unserialized when it is returned. * * @since 1.5.0 * @package WordPress * @subpackage Option * @uses apply_filters() Calls 'pre_option_$option' before checking the option. * 	Any value other than false will "short-circuit" the retrieval of the option *	and return the returned value. You should not try to override special options, * 	but you will not be prevented from doing so. * @uses apply_filters() Calls 'option_$option', after checking the option, with * 	the option value. * * @param string $option Name of option to retrieve. Expected to not be SQL-escaped. * @return mixed Value set for the option. */function get_option( $option, $default = false ) {	global $wpdb;	// Allow plugins to short-circuit options.	$pre = apply_filters( 'pre_option_' . $option, false );	if ( false !== $pre )		return $pre;	$option = trim($option);	if ( empty($option) )		return false;	if ( defined( 'WP_SETUP_CONFIG' ) )		return false;	if ( ! defined( 'WP_INSTALLING' ) ) {		// prevent non-existent options from triggering multiple queries		$notoptions = wp_cache_get( 'notoptions', 'options' );		if ( isset( $notoptions[$option] ) )			return $default;		$alloptions = wp_load_alloptions();		if ( isset( $alloptions[$option] ) ) {			$value = $alloptions[$option];		} else {			$value = wp_cache_get( $option, 'options' );			if ( false === $value ) {				$row = $wpdb->get_row( $wpdb->prepare( "SELECT option_value FROM $wpdb->options WHERE option_name = %s LIMIT 1", $option ) );				// Has to be get_row instead of get_var because of funkiness with 0, false, null values				if ( is_object( $row ) ) {					$value = $row->option_value;					wp_cache_add( $option, $value, 'options' );				} else { // option does not exist, so we must cache its non-existence					$notoptions[$option] = true;					wp_cache_set( 'notoptions', $notoptions, 'options' );					return $default;				}			}		}	} else {		$suppress = $wpdb->suppress_errors();		$row = $wpdb->get_row( $wpdb->prepare( "SELECT option_value FROM $wpdb->options WHERE option_name = %s LIMIT 1", $option ) );		$wpdb->suppress_errors( $suppress );		if ( is_object( $row ) )			$value = $row->option_value;		else			return $default;	}	// If home is not set use siteurl.	if ( 'home' == $option && '' == $value )		return get_option( 'siteurl' );	if ( in_array( $option, array('siteurl', 'home', 'category_base', 'tag_base') ) )		$value = untrailingslashit( $value );	return apply_filters( 'option_' . $option, maybe_unserialize( $value ) );}/** * Protect WordPress special option from being modified. * * Will die if $option is in protected list. Protected options are 'alloptions' * and 'notoptions' options. * * @since 2.2.0 * @package WordPress * @subpackage Option * * @param string $option Option name. */function wp_protect_special_option( $option ) {	$protected = array( 'alloptions', 'notoptions' );	if ( in_array( $option, $protected ) )		wp_die( sprintf( __( '%s is a protected WP option and may not be modified' ), esc_html( $option ) ) );}/** * Print option value after sanitizing for forms. * * @uses attr Sanitizes value. * @since 1.5.0 * @package WordPress * @subpackage Option * * @param string $option Option name. */function form_option( $option ) {	echo esc_attr( get_option( $option ) );}/** * Loads and caches all autoloaded options, if available or all options. * * @since 2.2.0 * @package WordPress * @subpackage Option * * @return array List of all options. */function wp_load_alloptions() {	global $wpdb;	if ( !defined( 'WP_INSTALLING' ) || !is_multisite() )		$alloptions = wp_cache_get( 'alloptions', 'options' );	else		$alloptions = false;	if ( !$alloptions ) {		$suppress = $wpdb->suppress_errors();		if ( !$alloptions_db = $wpdb->get_results( "SELECT option_name, option_value FROM $wpdb->options WHERE autoload = 'yes'" ) )			$alloptions_db = $wpdb->get_results( "SELECT option_name, option_value FROM $wpdb->options" );		$wpdb->suppress_errors($suppress);		$alloptions = array();		foreach ( (array) $alloptions_db as $o )			$alloptions[$o->option_name] = $o->option_value;			if ( !defined( 'WP_INSTALLING' ) || !is_multisite() )				wp_cache_add( 'alloptions', $alloptions, 'options' );	}	return $alloptions;}/** * Loads and caches certain often requested site options if is_multisite() and a peristent cache is not being used. * * @since 3.0.0 * @package WordPress * @subpackage Option * * @param int $site_id Optional site ID for which to query the options. Defaults to the current site. */function wp_load_core_site_options( $site_id = null ) {	global $wpdb, $_wp_using_ext_object_cache;	if ( !is_multisite() || $_wp_using_ext_object_cache || defined( 'WP_INSTALLING' ) )		return;	if ( empty($site_id) )		$site_id = $wpdb->siteid;	$core_options = array('site_name', 'siteurl', 'active_sitewide_plugins', '_site_transient_timeout_theme_roots', '_site_transient_theme_roots', 'site_admins', 'dashboard_blog', 'can_compress_scripts', 'global_terms_enabled' );	$core_options_in = "'" . implode("', '", $core_options) . "'";	$options = $wpdb->get_results( $wpdb->prepare("SELECT meta_key, meta_value FROM $wpdb->sitemeta WHERE meta_key IN ($core_options_in) AND site_id = %d", $site_id) );	foreach ( $options as $option ) {		$key = $option->meta_key;		$cache_key = "{$site_id}:$key";		$option->meta_value = maybe_unserialize( $option->meta_value );		wp_cache_set( $cache_key, $option->meta_value, 'site-options' );	}}/** * Update the value of an option that was already added. * * You do not need to serialize values. If the value needs to be serialized, then * it will be serialized before it is inserted into the database. Remember, * resources can not be serialized or added as an option. * * If the option does not exist, then the option will be added with the option * value, but you will not be able to set whether it is autoloaded. If you want * to set whether an option is autoloaded, then you need to use the add_option(). * * @since 1.0.0 * @package WordPress * @subpackage Option * * @uses apply_filters() Calls 'pre_update_option_$option' hook to allow overwriting the * 	option value to be stored. * @uses do_action() Calls 'update_option' hook before updating the option. * @uses do_action() Calls 'update_option_$option' and 'updated_option' hooks on success. * * @param string $option Option name. Expected to not be SQL-escaped. * @param mixed $newvalue Option value. Expected to not be SQL-escaped. * @return bool False if value was not updated and true if value was updated. */function update_option( $option, $newvalue ) {	global $wpdb;	$option = trim($option);	if ( empty($option) )		return false;	wp_protect_special_option( $option );	if ( is_object($newvalue) )		$newvalue = wp_clone($newvalue);	$newvalue = sanitize_option( $option, $newvalue );	$oldvalue = get_option( $option );	$newvalue = apply_filters( 'pre_update_option_' . $option, $newvalue, $oldvalue );	// If the new and old values are the same, no need to update.	if ( $newvalue === $oldvalue )		return false;	if ( false === $oldvalue )		return add_option( $option, $newvalue );	$notoptions = wp_cache_get( 'notoptions', 'options' );	if ( is_array( $notoptions ) && isset( $notoptions[$option] ) ) {		unset( $notoptions[$option] );		wp_cache_set( 'notoptions', $notoptions, 'options' );	}	$_newvalue = $newvalue;	$newvalue = maybe_serialize( $newvalue );	do_action( 'update_option', $option, $oldvalue, $_newvalue );	if ( ! defined( 'WP_INSTALLING' ) ) {		$alloptions = wp_load_alloptions();		if ( isset( $alloptions[$option] ) ) {			$alloptions[$option] = $_newvalue;			wp_cache_set( 'alloptions', $alloptions, 'options' );		} else {			wp_cache_set( $option, $_newvalue, 'options' );		}	}	$result = $wpdb->update( $wpdb->options, array( 'option_value' => $newvalue ), array( 'option_name' => $option ) );	if ( $result ) {		do_action( "update_option_{$option}", $oldvalue, $_newvalue );		do_action( 'updated_option', $option, $oldvalue, $_newvalue );		return true;	}	return false;}/** * Add a new option. * * You do not need to serialize values. If the value needs to be serialized, then * it will be serialized before it is inserted into the database. Remember, * resources can not be serialized or added as an option. * * You can create options without values and then add values later. Does not * check whether the option has already been added, but does check that you * aren't adding a protected WordPress option. Care should be taken to not name * options the same as the ones which are protected and to not add options * that were already added. * * @package WordPress * @subpackage Option * @since 1.0.0 * @link http://alex.vort-x.net/blog/ Thanks Alex Stapleton * * @uses do_action() Calls 'add_option' hook before adding the option. * @uses do_action() Calls 'add_option_$option' and 'added_option' hooks on success. * * @param string $option Name of option to add. Expected to not be SQL-escaped. * @param mixed $value Optional. Option value, can be anything. Expected to not be SQL-escaped. * @param mixed $deprecated Optional. Description. Not used anymore. * @param bool $autoload Optional. Default is enabled. Whether to load the option when WordPress starts up. * @return null returns when finished. */function add_option( $option, $value = '', $deprecated = '', $autoload = 'yes' ) {	global $wpdb;	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.3' );	$option = trim($option);	if ( empty($option) )		return false;	wp_protect_special_option( $option );	if ( is_object($value) )		$value = wp_clone($value);	$value = sanitize_option( $option, $value );	// Make sure the option doesn't already exist. We can check the 'notoptions' cache before we ask for a db query	$notoptions = wp_cache_get( 'notoptions', 'options' );	if ( !is_array( $notoptions ) || !isset( $notoptions[$option] ) )		if ( false !== get_option( $option ) )			return;	$_value = $value;	$value = maybe_serialize( $value );	$autoload = ( 'no' === $autoload ) ? 'no' : 'yes';	do_action( 'add_option', $option, $_value );	if ( ! defined( 'WP_INSTALLING' ) ) {		if ( 'yes' == $autoload ) {			$alloptions = wp_load_alloptions();			$alloptions[$option] = $value;			wp_cache_set( 'alloptions', $alloptions, 'options' );		} else {			wp_cache_set( $option, $value, 'options' );		}	}	// This option exists now	$notoptions = wp_cache_get( 'notoptions', 'options' ); // yes, again... we need it to be fresh	if ( is_array( $notoptions ) && isset( $notoptions[$option] ) ) {		unset( $notoptions[$option] );		wp_cache_set( 'notoptions', $notoptions, 'options' );	}	$result = $wpdb->query( $wpdb->prepare( "INSERT INTO `$wpdb->options` (`option_name`, `option_value`, `autoload`) VALUES (%s, %s, %s) ON DUPLICATE KEY UPDATE `option_name` = VALUES(`option_name`), `option_value` = VALUES(`option_value`), `autoload` = VALUES(`autoload`)", $option, $value, $autoload ) );	if ( $result ) {		do_action( "add_option_{$option}", $option, $_value );		do_action( 'added_option', $option, $_value );		return true;	}	return false;}/** * Removes option by name. Prevents removal of protected WordPress options. * * @package WordPress * @subpackage Option * @since 1.2.0 * * @uses do_action() Calls 'delete_option' hook before option is deleted. * @uses do_action() Calls 'deleted_option' and 'delete_option_$option' hooks on success. * * @param string $option Name of option to remove. Expected to not be SQL-escaped. * @return bool True, if option is successfully deleted. False on failure. */function delete_option( $option ) {	global $wpdb;	wp_protect_special_option( $option );	// Get the ID, if no ID then return	$row = $wpdb->get_row( $wpdb->prepare( "SELECT autoload FROM $wpdb->options WHERE option_name = %s", $option ) );	if ( is_null( $row ) )		return false;	do_action( 'delete_option', $option );	$result = $wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->options WHERE option_name = %s", $option) );	if ( ! defined( 'WP_INSTALLING' ) ) {		if ( 'yes' == $row->autoload ) {			$alloptions = wp_load_alloptions();			if ( is_array( $alloptions ) && isset( $alloptions[$option] ) ) {				unset( $alloptions[$option] );				wp_cache_set( 'alloptions', $alloptions, 'options' );			}		} else {			wp_cache_delete( $option, 'options' );		}	}	if ( $result ) {		do_action( "delete_option_$option", $option );		do_action( 'deleted_option', $option );		return true;	}	return false;}/** * Delete a transient * * @since 2.8.0 * @package WordPress * @subpackage Transient * * @uses do_action() Calls 'delete_transient_$transient' hook before transient is deleted. * @uses do_action() Calls 'deleted_transient' hook on success. * * @param string $transient Transient name. Expected to not be SQL-escaped. * @return bool true if successful, false otherwise */function delete_transient( $transient ) {	global $_wp_using_ext_object_cache;    do_action( 'delete_transient_' . $transient, $transient );	if ( $_wp_using_ext_object_cache ) {		$result = wp_cache_delete( $transient, 'transient' );	} else {		$option_timeout = '_transient_timeout_' . $transient;		$option = '_transient_' . $transient;		$result = delete_option( $option );		if ( $result )			delete_option( $option_timeout );	}	if ( $result )		do_action( 'deleted_transient', $transient );	return $result;}/** * Get the value of a transient * * If the transient does not exist or does not have a value, then the return value * will be false. * * @uses apply_filters() Calls 'pre_transient_$transient' hook before checking the transient. * 	Any value other than false will "short-circuit" the retrieval of the transient *	and return the returned value. * @uses apply_filters() Calls 'transient_$option' hook, after checking the transient, with * 	the transient value. * * @since 2.8.0 * @package WordPress * @subpackage Transient * * @param string $transient Transient name. Expected to not be SQL-escaped * @return mixed Value of transient */function get_transient( $transient ) {	global $_wp_using_ext_object_cache;	$pre = apply_filters( 'pre_transient_' . $transient, false );	if ( false !== $pre )		return $pre;	if ( $_wp_using_ext_object_cache ) {		$value = wp_cache_get( $transient, 'transient' );	} else {		$transient_option = '_transient_' . $transient;		if ( ! defined( 'WP_INSTALLING' ) ) {			// If option is not in alloptions, it is not autoloaded and thus has a timeout			$alloptions = wp_load_alloptions();			if ( !isset( $alloptions[$transient_option] ) ) {				$transient_timeout = '_transient_timeout_' . $transient;				if ( get_option( $transient_timeout ) < time() ) {					delete_option( $transient_option  );					delete_option( $transient_timeout );					return false;				}			}		}		$value = get_option( $transient_option );	}	return apply_filters( 'transient_' . $transient, $value );}/** * Set/update the value of a transient * * You do not need to serialize values. If the value needs to be serialized, then * it will be serialized before it is set. * * @since 2.8.0 * @package WordPress * @subpackage Transient * * @uses apply_filters() Calls 'pre_set_transient_$transient' hook to allow overwriting the * 	transient value to be stored. * @uses do_action() Calls 'set_transient_$transient' and 'setted_transient' hooks on success. * * @param string $transient Transient name. Expected to not be SQL-escaped. * @param mixed $value Transient value. Expected to not be SQL-escaped. * @param int $expiration Time until expiration in seconds, default 0 * @return bool False if value was not set and true if value was set. */function set_transient( $transient, $value, $expiration = 0 ) {	global $_wp_using_ext_object_cache;    $value = apply_filters( 'pre_set_transient_' . $transient, $value );	if ( $_wp_using_ext_object_cache ) {		$result = wp_cache_set( $transient, $value, 'transient', $expiration );	} else {		$transient_timeout = '_transient_timeout_' . $transient;		$transient = '_transient_' . $transient;		if ( false === get_option( $transient ) ) {			$autoload = 'yes';			if ( $expiration ) {				$autoload = 'no';				add_option( $transient_timeout, time() + $expiration, '', 'no' );			}			$result = add_option( $transient, $value, '', $autoload );		} else {			if ( $expiration )				update_option( $transient_timeout, time() + $expiration );			$result = update_option( $transient, $value );		}	}	if ( $result ) {		do_action( 'set_transient_' . $transient );		do_action( 'setted_transient', $transient );	}	return $result;}/** * Saves and restores user interface settings stored in a cookie. * * Checks if the current user-settings cookie is updated and stores it. When no * cookie exists (different browser used), adds the last saved cookie restoring * the settings. * * @package WordPress * @subpackage Option * @since 2.7.0 */function wp_user_settings() {	if ( ! is_admin() )		return;	if ( defined('DOING_AJAX') )		return;	if ( ! $user = wp_get_current_user() )		return;	$settings = get_user_option( 'user-settings', $user->ID );	if ( isset( $_COOKIE['wp-settings-' . $user->ID] ) ) {		$cookie = preg_replace( '/[^A-Za-z0-9=&_]/', '', $_COOKIE['wp-settings-' . $user->ID] );		if ( ! empty( $cookie ) && strpos( $cookie, '=' ) ) {			if ( $cookie == $settings )				return;			$last_time = (int) get_user_option( 'user-settings-time', $user->ID );			$saved = isset( $_COOKIE['wp-settings-time-' . $user->ID]) ? preg_replace( '/[^0-9]/', '', $_COOKIE['wp-settings-time-' . $user->ID] ) : 0;			if ( $saved > $last_time ) {				update_user_option( $user->ID, 'user-settings', $cookie, false );				update_user_option( $user->ID, 'user-settings-time', time() - 5, false );				return;			}		}	}	setcookie( 'wp-settings-' . $user->ID, $settings, time() + 31536000, SITECOOKIEPATH );	setcookie( 'wp-settings-time-' . $user->ID, time(), time() + 31536000, SITECOOKIEPATH );	$_COOKIE['wp-settings-' . $user->ID] = $settings;}/** * Retrieve user interface setting value based on setting name. * * @package WordPress * @subpackage Option * @since 2.7.0 * * @param string $name The name of the setting. * @param string $default Optional default value to return when $name is not set. * @return mixed the last saved user setting or the default value/false if it doesn't exist. */function get_user_setting( $name, $default = false ) {	$all = get_all_user_settings();	return isset($all[$name]) ? $all[$name] : $default;}/** * Add or update user interface setting. * * Both $name and $value can contain only ASCII letters, numbers and underscores. * This function has to be used before any output has started as it calls setcookie(). * * @package WordPress * @subpackage Option * @since 2.8.0 * * @param string $name The name of the setting. * @param string $value The value for the setting. * @return bool true if set successfully/false if not. */function set_user_setting( $name, $value ) {	if ( headers_sent() )		return false;	$all = get_all_user_settings();	$name = preg_replace( '/[^A-Za-z0-9_]+/', '', $name );	if ( empty($name) )		return false;	$all[$name] = $value;	return wp_set_all_user_settings($all);}/** * Delete user interface settings. * * Deleting settings would reset them to the defaults. * This function has to be used before any output has started as it calls setcookie(). * * @package WordPress * @subpackage Option * @since 2.7.0 * * @param mixed $names The name or array of names of the setting to be deleted. * @return bool true if deleted successfully/false if not. */function delete_user_setting( $names ) {	if ( headers_sent() )		return false;	$all = get_all_user_settings();	$names = (array) $names;	foreach ( $names as $name ) {		if ( isset($all[$name]) ) {			unset($all[$name]);			$deleted = true;		}	}	if ( isset($deleted) )		return wp_set_all_user_settings($all);	return false;}/** * Retrieve all user interface settings. * * @package WordPress * @subpackage Option * @since 2.7.0 * * @return array the last saved user settings or empty array. */function get_all_user_settings() {	global $_updated_user_settings;	if ( ! $user = wp_get_current_user() )		return array();	if ( isset($_updated_user_settings) && is_array($_updated_user_settings) )		return $_updated_user_settings;	$all = array();	if ( isset($_COOKIE['wp-settings-' . $user->ID]) ) {		$cookie = preg_replace( '/[^A-Za-z0-9=&_]/', '', $_COOKIE['wp-settings-' . $user->ID] );		if ( $cookie && strpos($cookie, '=') ) // the '=' cannot be 1st char			parse_str($cookie, $all);	} else {		$option = get_user_option('user-settings', $user->ID);		if ( $option && is_string($option) )			parse_str( $option, $all );	}	return $all;}/** * Private. Set all user interface settings. * * @package WordPress * @subpackage Option * @since 2.8.0 * * @param unknown $all * @return bool */function wp_set_all_user_settings($all) {	global $_updated_user_settings;	if ( ! $user = wp_get_current_user() )		return false;	$_updated_user_settings = $all;	$settings = '';	foreach ( $all as $k => $v ) {		$v = preg_replace( '/[^A-Za-z0-9_]+/', '', $v );		$settings .= $k . '=' . $v . '&';	}	$settings = rtrim($settings, '&');	update_user_option( $user->ID, 'user-settings', $settings, false );	update_user_option( $user->ID, 'user-settings-time', time(), false );	return true;}/** * Delete the user settings of the current user. * * @package WordPress * @subpackage Option * @since 2.7.0 */function delete_all_user_settings() {	if ( ! $user = wp_get_current_user() )		return;	update_user_option( $user->ID, 'user-settings', '', false );	setcookie('wp-settings-' . $user->ID, ' ', time() - 31536000, SITECOOKIEPATH);}/** * Serialize data, if needed. * * @since 2.0.5 * * @param mixed $data Data that might be serialized. * @return mixed A scalar data */function maybe_serialize( $data ) {	if ( is_array( $data ) || is_object( $data ) )		return serialize( $data );	if ( is_serialized( $data ) )		return serialize( $data );	return $data;}/** * Retrieve post title from XMLRPC XML. * * If the title element is not part of the XML, then the default post title from * the $post_default_title will be used instead. * * @package WordPress * @subpackage XMLRPC * @since 0.71 * * @global string $post_default_title Default XMLRPC post title. * * @param string $content XMLRPC XML Request content * @return string Post title */function xmlrpc_getposttitle( $content ) {	global $post_default_title;	if ( preg_match( '/<title>(.+?)<\/title>/is', $content, $matchtitle ) ) {		$post_title = $matchtitle[1];	} else {		$post_title = $post_default_title;	}	return $post_title;}/** * Retrieve the post category or categories from XMLRPC XML. * * If the category element is not found, then the default post category will be * used. The return type then would be what $post_default_category. If the * category is found, then it will always be an array. * * @package WordPress * @subpackage XMLRPC * @since 0.71 * * @global string $post_default_category Default XMLRPC post category. * * @param string $content XMLRPC XML Request content * @return string|array List of categories or category name. */function xmlrpc_getpostcategory( $content ) {	global $post_default_category;	if ( preg_match( '/<category>(.+?)<\/category>/is', $content, $matchcat ) ) {		$post_category = trim( $matchcat[1], ',' );		$post_category = explode( ',', $post_category );	} else {		$post_category = $post_default_category;	}	return $post_category;}/** * XMLRPC XML content without title and category elements. * * @package WordPress * @subpackage XMLRPC * @since 0.71 * * @param string $content XMLRPC XML Request content * @return string XMLRPC XML Request content without title and category elements. */function xmlrpc_removepostdata( $content ) {	$content = preg_replace( '/<title>(.+?)<\/title>/si', '', $content );	$content = preg_replace( '/<category>(.+?)<\/category>/si', '', $content );	$content = trim( $content );	return $content;}/** * Open the file handle for debugging. * * This function is used for XMLRPC feature, but it is general purpose enough * to be used in anywhere. * * @see fopen() for mode options. * @package WordPress * @subpackage Debug * @since 0.71 * @uses $debug Used for whether debugging is enabled. * * @param string $filename File path to debug file. * @param string $mode Same as fopen() mode parameter. * @return bool|resource File handle. False on failure. */function debug_fopen( $filename, $mode ) {	global $debug;	if ( 1 == $debug ) {		$fp = fopen( $filename, $mode );		return $fp;	} else {		return false;	}}/** * Write contents to the file used for debugging. * * Technically, this can be used to write to any file handle when the global * $debug is set to 1 or true. * * @package WordPress * @subpackage Debug * @since 0.71 * @uses $debug Used for whether debugging is enabled. * * @param resource $fp File handle for debugging file. * @param string $string Content to write to debug file. */function debug_fwrite( $fp, $string ) {	global $debug;	if ( 1 == $debug )		fwrite( $fp, $string );}/** * Close the debugging file handle. * * Technically, this can be used to close any file handle when the global $debug * is set to 1 or true. * * @package WordPress * @subpackage Debug * @since 0.71 * @uses $debug Used for whether debugging is enabled. * * @param resource $fp Debug File handle. */function debug_fclose( $fp ) {	global $debug;	if ( 1 == $debug )		fclose( $fp );}/** * Check content for video and audio links to add as enclosures. * * Will not add enclosures that have already been added and will * remove enclosures that are no longer in the post. This is called as * pingbacks and trackbacks. * * @package WordPress * @since 1.5.0 * * @uses $wpdb * * @param string $content Post Content * @param int $post_ID Post ID */function do_enclose( $content, $post_ID ) {	global $wpdb;	include_once( ABSPATH . WPINC . '/class-IXR.php' );	$log = debug_fopen( ABSPATH . 'enclosures.log', 'a' );	$post_links = array();	debug_fwrite( $log, 'BEGIN ' . date( 'YmdHis', time() ) . "\n" );	$pung = get_enclosed( $post_ID );	$ltrs = '\w';	$gunk = '/#~:.?+=&%@!\-';	$punc = '.:?\-';	$any = $ltrs . $gunk . $punc;	preg_match_all( "{\b http : [$any] +? (?= [$punc] * [^$any] | $)}x", $content, $post_links_temp );	debug_fwrite( $log, 'Post contents:' );	debug_fwrite( $log, $content . "\n" );	foreach ( $pung as $link_test ) {		if ( !in_array( $link_test, $post_links_temp[0] ) ) { // link no longer in post			$mid = $wpdb->get_col( $wpdb->prepare("SELECT meta_id FROM $wpdb->postmeta WHERE post_id = %d AND meta_key = 'enclosure' AND meta_value LIKE (%s)", $post_ID, $link_test . '%') );			do_action( 'delete_postmeta', $mid );			$wpdb->query( $wpdb->prepare("DELETE FROM $wpdb->postmeta WHERE meta_id IN(%s)", implode( ',', $mid ) ) );			do_action( 'deleted_postmeta', $mid );		}	}	foreach ( (array) $post_links_temp[0] as $link_test ) {		if ( !in_array( $link_test, $pung ) ) { // If we haven't pung it already			$test = @parse_url( $link_test );			if ( false === $test )				continue;			if ( isset( $test['query'] ) )				$post_links[] = $link_test;			elseif ( $test['path'] != '/' && $test['path'] != '' )				$post_links[] = $link_test;		}	}	foreach ( (array) $post_links as $url ) {		if ( $url != '' && !$wpdb->get_var( $wpdb->prepare( "SELECT post_id FROM $wpdb->postmeta WHERE post_id = %d AND meta_key = 'enclosure' AND meta_value LIKE (%s)", $post_ID, $url . '%' ) ) ) {			if ( $headers = wp_get_http_headers( $url) ) {				$len = (int) $headers['content-length'];				$type = $headers['content-type'];				$allowed_types = array( 'video', 'audio' );				// Check to see if we can figure out the mime type from				// the extension				$url_parts = @parse_url( $url );				if ( false !== $url_parts ) {					$extension = pathinfo( $url_parts['path'], PATHINFO_EXTENSION );					if ( !empty( $extension ) ) {						foreach ( get_allowed_mime_types( ) as $exts => $mime ) {							if ( preg_match( '!^(' . $exts . ')$!i', $extension ) ) {								$type = $mime;								break;							}						}					}				}				if ( in_array( substr( $type, 0, strpos( $type, "/" ) ), $allowed_types ) ) {					$meta_value = "$url\n$len\n$type\n";					$wpdb->insert($wpdb->postmeta, array('post_id' => $post_ID, 'meta_key' => 'enclosure', 'meta_value' => $meta_value) );					do_action( 'added_postmeta', $wpdb->insert_id, $post_ID, 'enclosure', $meta_value );				}			}		}	}}/** * Perform a HTTP HEAD or GET request. * * If $file_path is a writable filename, this will do a GET request and write * the file to that path. * * @since 2.5.0 * * @param string $url URL to fetch. * @param string|bool $file_path Optional. File path to write request to. * @param int $red (private) The number of Redirects followed, Upon 5 being hit, returns false. * @return bool|string False on failure and string of headers if HEAD request. */function wp_get_http( $url, $file_path = false, $red = 1 ) {	@set_time_limit( 60 );	if ( $red > 5 )		return false;	$options = array();	$options['redirection'] = 5;	if ( false == $file_path )		$options['method'] = 'HEAD';	else		$options['method'] = 'GET';	$response = wp_remote_request($url, $options);	if ( is_wp_error( $response ) )		return false;	$headers = wp_remote_retrieve_headers( $response );	$headers['response'] = $response['response']['code'];	// WP_HTTP no longer follows redirects for HEAD requests.	if ( 'HEAD' == $options['method'] && in_array($headers['response'], array(301, 302)) && isset( $headers['location'] ) ) {		return wp_get_http( $headers['location'], $file_path, ++$red );	}	if ( false == $file_path )		return $headers;	// GET request - write it to the supplied filename	$out_fp = fopen($file_path, 'w');	if ( !$out_fp )		return $headers;	fwrite( $out_fp,  $response['body']);	fclose($out_fp);	clearstatcache();	return $headers;}/** * Retrieve HTTP Headers from URL. * * @since 1.5.1 * * @param string $url * @param bool $deprecated Not Used. * @return bool|string False on failure, headers on success. */function wp_get_http_headers( $url, $deprecated = false ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.7' );	$response = wp_remote_head( $url );	if ( is_wp_error( $response ) )		return false;	return wp_remote_retrieve_headers( $response );}/** * Whether today is a new day. * * @since 0.71 * @uses $day Today * @uses $previousday Previous day * * @return int 1 when new day, 0 if not a new day. */function is_new_day() {	global $day, $previousday;	if ( $day != $previousday )		return 1;	else		return 0;}/** * Build URL query based on an associative and, or indexed array. * * This is a convenient function for easily building url queries. It sets the * separator to '&' and uses _http_build_query() function. * * @see _http_build_query() Used to build the query * @link http://us2.php.net/manual/en/function.http-build-query.php more on what *		http_build_query() does. * * @since 2.3.0 * * @param array $data URL-encode key/value pairs. * @return string URL encoded string */function build_query( $data ) {	return _http_build_query( $data, null, '&', '', false );}/** * Retrieve a modified URL query string. * * You can rebuild the URL and append a new query variable to the URL query by * using this function. You can also retrieve the full URL with query data. * * Adding a single key & value or an associative array. Setting a key value to * emptystring removes the key. Omitting oldquery_or_uri uses the $_SERVER * value. * * @since 1.5.0 * * @param mixed $param1 Either newkey or an associative_array * @param mixed $param2 Either newvalue or oldquery or uri * @param mixed $param3 Optional. Old query or uri * @return string New URL query string. */function add_query_arg() {	$ret = '';	if ( is_array( func_get_arg(0) ) ) {		if ( @func_num_args() < 2 || false === @func_get_arg( 1 ) )			$uri = $_SERVER['REQUEST_URI'];		else			$uri = @func_get_arg( 1 );	} else {		if ( @func_num_args() < 3 || false === @func_get_arg( 2 ) )			$uri = $_SERVER['REQUEST_URI'];		else			$uri = @func_get_arg( 2 );	}	if ( $frag = strstr( $uri, '#' ) )		$uri = substr( $uri, 0, -strlen( $frag ) );	else		$frag = '';	if ( preg_match( '|^https?://|i', $uri, $matches ) ) {		$protocol = $matches[0];		$uri = substr( $uri, strlen( $protocol ) );	} else {		$protocol = '';	}	if ( strpos( $uri, '?' ) !== false ) {		$parts = explode( '?', $uri, 2 );		if ( 1 == count( $parts ) ) {			$base = '?';			$query = $parts[0];		} else {			$base = $parts[0] . '?';			$query = $parts[1];		}	} elseif ( !empty( $protocol ) || strpos( $uri, '=' ) === false ) {		$base = $uri . '?';		$query = '';	} else {		$base = '';		$query = $uri;	}	wp_parse_str( $query, $qs );	$qs = urlencode_deep( $qs ); // this re-URL-encodes things that were already in the query string	if ( is_array( func_get_arg( 0 ) ) ) {		$kayvees = func_get_arg( 0 );		$qs = array_merge( $qs, $kayvees );	} else {		$qs[func_get_arg( 0 )] = func_get_arg( 1 );	}	foreach ( (array) $qs as $k => $v ) {		if ( $v === false )			unset( $qs[$k] );	}	$ret = build_query( $qs );	$ret = trim( $ret, '?' );	$ret = preg_replace( '#=(&|$)#', '$1', $ret );	$ret = $protocol . $base . $ret . $frag;	$ret = rtrim( $ret, '?' );	return $ret;}/** * Removes an item or list from the query string. * * @since 1.5.0 * * @param string|array $key Query key or keys to remove. * @param bool $query When false uses the $_SERVER value. * @return string New URL query string. */function remove_query_arg( $key, $query=false ) {	if ( is_array( $key ) ) { // removing multiple keys		foreach ( $key as $k )			$query = add_query_arg( $k, false, $query );		return $query;	}	return add_query_arg( $key, false, $query );}/** * Walks the array while sanitizing the contents. * * @since 0.71 * * @param array $array Array to used to walk while sanitizing contents. * @return array Sanitized $array. */function add_magic_quotes( $array ) {	foreach ( (array) $array as $k => $v ) {		if ( is_array( $v ) ) {			$array[$k] = add_magic_quotes( $v );		} else {			$array[$k] = addslashes( $v );		}	}	return $array;}/** * HTTP request for URI to retrieve content. * * @since 1.5.1 * @uses wp_remote_get() * * @param string $uri URI/URL of web page to retrieve. * @return bool|string HTTP content. False on failure. */function wp_remote_fopen( $uri ) {	$parsed_url = @parse_url( $uri );	if ( !$parsed_url || !is_array( $parsed_url ) )		return false;	$options = array();	$options['timeout'] = 10;	$response = wp_remote_get( $uri, $options );	if ( is_wp_error( $response ) )		return false;	return $response['body'];}/** * Set up the WordPress query. * * @since 2.0.0 * * @param string $query_vars Default WP_Query arguments. */function wp( $query_vars = '' ) {	global $wp, $wp_query, $wp_the_query;	$wp->main( $query_vars );	if ( !isset($wp_the_query) )		$wp_the_query = $wp_query;}/** * Retrieve the description for the HTTP status. * * @since 2.3.0 * * @param int $code HTTP status code. * @return string Empty string if not found, or description if found. */function get_status_header_desc( $code ) {	global $wp_header_to_desc;	$code = absint( $code );	if ( !isset( $wp_header_to_desc ) ) {		$wp_header_to_desc = array(			100 => 'Continue',			101 => 'Switching Protocols',			102 => 'Processing',			200 => 'OK',			201 => 'Created',			202 => 'Accepted',			203 => 'Non-Authoritative Information',			204 => 'No Content',			205 => 'Reset Content',			206 => 'Partial Content',			207 => 'Multi-Status',			226 => 'IM Used',			300 => 'Multiple Choices',			301 => 'Moved Permanently',			302 => 'Found',			303 => 'See Other',			304 => 'Not Modified',			305 => 'Use Proxy',			306 => 'Reserved',			307 => 'Temporary Redirect',			400 => 'Bad Request',			401 => 'Unauthorized',			402 => 'Payment Required',			403 => 'Forbidden',			404 => 'Not Found',			405 => 'Method Not Allowed',			406 => 'Not Acceptable',			407 => 'Proxy Authentication Required',			408 => 'Request Timeout',			409 => 'Conflict',			410 => 'Gone',			411 => 'Length Required',			412 => 'Precondition Failed',			413 => 'Request Entity Too Large',			414 => 'Request-URI Too Long',			415 => 'Unsupported Media Type',			416 => 'Requested Range Not Satisfiable',			417 => 'Expectation Failed',			422 => 'Unprocessable Entity',			423 => 'Locked',			424 => 'Failed Dependency',			426 => 'Upgrade Required',			500 => 'Internal Server Error',			501 => 'Not Implemented',			502 => 'Bad Gateway',			503 => 'Service Unavailable',			504 => 'Gateway Timeout',			505 => 'HTTP Version Not Supported',			506 => 'Variant Also Negotiates',			507 => 'Insufficient Storage',			510 => 'Not Extended'		);	}	if ( isset( $wp_header_to_desc[$code] ) )		return $wp_header_to_desc[$code];	else		return '';}/** * Set HTTP status header. * * @since 2.0.0 * @uses apply_filters() Calls 'status_header' on status header string, HTTP *		HTTP code, HTTP code description, and protocol string as separate *		parameters. * * @param int $header HTTP status code * @return unknown */function status_header( $header ) {	$text = get_status_header_desc( $header );	if ( empty( $text ) )		return false;	$protocol = $_SERVER["SERVER_PROTOCOL"];	if ( 'HTTP/1.1' != $protocol && 'HTTP/1.0' != $protocol )		$protocol = 'HTTP/1.0';	$status_header = "$protocol $header $text";	if ( function_exists( 'apply_filters' ) )		$status_header = apply_filters( 'status_header', $status_header, $header, $text, $protocol );	return @header( $status_header, true, $header );}/** * Gets the header information to prevent caching. * * The several different headers cover the different ways cache prevention is handled * by different browsers * * @since 2.8 * * @uses apply_filters() * @return array The associative array of header names and field values. */function wp_get_nocache_headers() {	$headers = array(		'Expires' => 'Wed, 11 Jan 1984 05:00:00 GMT',		'Last-Modified' => gmdate( 'D, d M Y H:i:s' ) . ' GMT',		'Cache-Control' => 'no-cache, must-revalidate, max-age=0',		'Pragma' => 'no-cache',	);	if ( function_exists('apply_filters') ) {		$headers = apply_filters('nocache_headers', $headers);	}	return $headers;}/** * Sets the headers to prevent caching for the different browsers. * * Different browsers support different nocache headers, so several headers must * be sent so that all of them get the point that no caching should occur. * * @since 2.0.0 * @uses wp_get_nocache_headers() */function nocache_headers() {	$headers = wp_get_nocache_headers();	foreach( (array) $headers as $name => $field_value )		@header("{$name}: {$field_value}");}/** * Set the headers for caching for 10 days with JavaScript content type. * * @since 2.1.0 */function cache_javascript_headers() {	$expiresOffset = 864000; // 10 days	header( "Content-Type: text/javascript; charset=" . get_bloginfo( 'charset' ) );	header( "Vary: Accept-Encoding" ); // Handle proxies	header( "Expires: " . gmdate( "D, d M Y H:i:s", time() + $expiresOffset ) . " GMT" );}/** * Retrieve the number of database queries during the WordPress execution. * * @since 2.0.0 * * @return int Number of database queries */function get_num_queries() {	global $wpdb;	return $wpdb->num_queries;}/** * Whether input is yes or no. Must be 'y' to be true. * * @since 1.0.0 * * @param string $yn Character string containing either 'y' or 'n' * @return bool True if yes, false on anything else */function bool_from_yn( $yn ) {	return ( strtolower( $yn ) == 'y' );}/** * Loads the feed template from the use of an action hook. * * If the feed action does not have a hook, then the function will die with a * message telling the visitor that the feed is not valid. * * It is better to only have one hook for each feed. * * @since 2.1.0 * @uses $wp_query Used to tell if the use a comment feed. * @uses do_action() Calls 'do_feed_$feed' hook, if a hook exists for the feed. */function do_feed() {	global $wp_query;	$feed = get_query_var( 'feed' );	// Remove the pad, if present.	$feed = preg_replace( '/^_+/', '', $feed );	if ( $feed == '' || $feed == 'feed' )		$feed = get_default_feed();	$hook = 'do_feed_' . $feed;	if ( !has_action($hook) ) {		$message = sprintf( __( 'ERROR: %s is not a valid feed template.' ), esc_html($feed));		wp_die( $message, '', array( 'response' => 404 ) );	}	do_action( $hook, $wp_query->is_comment_feed );}/** * Load the RDF RSS 0.91 Feed template. * * @since 2.1.0 */function do_feed_rdf() {	load_template( ABSPATH . WPINC . '/feed-rdf.php' );}/** * Load the RSS 1.0 Feed Template * * @since 2.1.0 */function do_feed_rss() {	load_template( ABSPATH . WPINC . '/feed-rss.php' );}/** * Load either the RSS2 comment feed or the RSS2 posts feed. * * @since 2.1.0 * * @param bool $for_comments True for the comment feed, false for normal feed. */function do_feed_rss2( $for_comments ) {	if ( $for_comments )		load_template( ABSPATH . WPINC . '/feed-rss2-comments.php' );	else		load_template( ABSPATH . WPINC . '/feed-rss2.php' );}/** * Load either Atom comment feed or Atom posts feed. * * @since 2.1.0 * * @param bool $for_comments True for the comment feed, false for normal feed. */function do_feed_atom( $for_comments ) {	if ($for_comments)		load_template( ABSPATH . WPINC . '/feed-atom-comments.php');	else		load_template( ABSPATH . WPINC . '/feed-atom.php' );}/** * Display the robot.txt file content. * * The echo content should be with usage of the permalinks or for creating the * robot.txt file. * * @since 2.1.0 * @uses do_action() Calls 'do_robotstxt' hook for displaying robot.txt rules. */function do_robots() {	header( 'Content-Type: text/plain; charset=utf-8' );	do_action( 'do_robotstxt' );	$output = '';	$public = get_option( 'blog_public' );	if ( '0' ==  $public ) {		$output .= "User-agent: *\n";		$output .= "Disallow: /\n";	} else {		$output .= "User-agent: *\n";		$output .= "Disallow:\n";	}	echo apply_filters('robots_txt', $output, $public);}/** * Test whether blog is already installed. * * The cache will be checked first. If you have a cache plugin, which saves the * cache values, then this will work. If you use the default WordPress cache, * and the database goes away, then you might have problems. * * Checks for the option siteurl for whether WordPress is installed. * * @since 2.1.0 * @uses $wpdb * * @return bool Whether blog is already installed. */function is_blog_installed() {	global $wpdb;	// Check cache first. If options table goes away and we have true cached, oh well.	if ( wp_cache_get( 'is_blog_installed' ) )		return true;	$suppress = $wpdb->suppress_errors();	if ( ! defined( 'WP_INSTALLING' ) ) {		$alloptions = wp_load_alloptions();	}	// If siteurl is not set to autoload, check it specifically	if ( !isset( $alloptions['siteurl'] ) )		$installed = $wpdb->get_var( "SELECT option_value FROM $wpdb->options WHERE option_name = 'siteurl'" );	else		$installed = $alloptions['siteurl'];	$wpdb->suppress_errors( $suppress );	$installed = !empty( $installed );	wp_cache_set( 'is_blog_installed', $installed );	if ( $installed )		return true;	$suppress = $wpdb->suppress_errors();	$tables = $wpdb->get_col('SHOW TABLES');	$wpdb->suppress_errors( $suppress );	$wp_tables = $wpdb->tables();	// Loop over the WP tables.  If none exist, then scratch install is allowed.	// If one or more exist, suggest table repair since we got here because the options	// table could not be accessed.	foreach ( $wp_tables as $table ) {		// If one of the WP tables exist, then we are in an insane state.		if ( in_array( $table, $tables ) ) {			// The existence of custom user tables shouldn't suggest an insane state or prevent a clean install.			if ( defined( 'CUSTOM_USER_TABLE' ) && CUSTOM_USER_TABLE == $table )				continue;			if ( defined( 'CUSTOM_USER_META_TABLE' ) && CUSTOM_USER_META_TABLE == $table )				continue;			// If visiting repair.php, return true and let it take over.			if ( defined('WP_REPAIRING') )				return true;			// Die with a DB error.			$wpdb->error = sprintf( /*WP_I18N_NO_TABLES*/'One or more database tables are unavailable.  The database may need to be <a href="%s">repaired</a>.'/*/WP_I18N_NO_TABLES*/, 'maint/repair.php?referrer=is_blog_installed' );			dead_db();		}	}	wp_cache_set( 'is_blog_installed', false );	return false;}/** * Retrieve URL with nonce added to URL query. * * @package WordPress * @subpackage Security * @since 2.0.4 * * @param string $actionurl URL to add nonce action * @param string $action Optional. Nonce action name * @return string URL with nonce action added. */function wp_nonce_url( $actionurl, $action = -1 ) {	$actionurl = str_replace( '&amp;', '&', $actionurl );	return esc_html( add_query_arg( '_wpnonce', wp_create_nonce( $action ), $actionurl ) );}/** * Retrieve or display nonce hidden field for forms. * * The nonce field is used to validate that the contents of the form came from * the location on the current site and not somewhere else. The nonce does not * offer absolute protection, but should protect against most cases. It is very * important to use nonce field in forms. * * If you set $echo to true and set $referer to true, then you will need to * retrieve the {@link wp_referer_field() wp referer field}. If you have the * $referer set to true and are echoing the nonce field, it will also echo the * referer field. * * The $action and $name are optional, but if you want to have better security, * it is strongly suggested to set those two parameters. It is easier to just * call the function without any parameters, because validation of the nonce * doesn't require any parameters, but since crackers know what the default is * it won't be difficult for them to find a way around your nonce and cause * damage. * * The input name will be whatever $name value you gave. The input value will be * the nonce creation value. * * @package WordPress * @subpackage Security * @since 2.0.4 * * @param string $action Optional. Action name. * @param string $name Optional. Nonce name. * @param bool $referer Optional, default true. Whether to set the referer field for validation. * @param bool $echo Optional, default true. Whether to display or return hidden form field. * @return string Nonce field. */function wp_nonce_field( $action = -1, $name = "_wpnonce", $referer = true , $echo = true ) {	$name = esc_attr( $name );	$nonce_field = '<input type="hidden" id="' . $name . '" name="' . $name . '" value="' . wp_create_nonce( $action ) . '" />';	if ( $echo )		echo $nonce_field;	if ( $referer )		wp_referer_field( $echo );	return $nonce_field;}/** * Retrieve or display referer hidden field for forms. * * The referer link is the current Request URI from the server super global. The * input name is '_wp_http_referer', in case you wanted to check manually. * * @package WordPress * @subpackage Security * @since 2.0.4 * * @param bool $echo Whether to echo or return the referer field. * @return string Referer field. */function wp_referer_field( $echo = true ) {	$ref = esc_attr( $_SERVER['REQUEST_URI'] );	$referer_field = '<input type="hidden" name="_wp_http_referer" value="'. $ref . '" />';	if ( $echo )		echo $referer_field;	return $referer_field;}/** * Retrieve or display original referer hidden field for forms. * * The input name is '_wp_original_http_referer' and will be either the same * value of {@link wp_referer_field()}, if that was posted already or it will * be the current page, if it doesn't exist. * * @package WordPress * @subpackage Security * @since 2.0.4 * * @param bool $echo Whether to echo the original http referer * @param string $jump_back_to Optional, default is 'current'. Can be 'previous' or page you want to jump back to. * @return string Original referer field. */function wp_original_referer_field( $echo = true, $jump_back_to = 'current' ) {	$jump_back_to = ( 'previous' == $jump_back_to ) ? wp_get_referer() : $_SERVER['REQUEST_URI'];	$ref = ( wp_get_original_referer() ) ? wp_get_original_referer() : $jump_back_to;	$orig_referer_field = '<input type="hidden" name="_wp_original_http_referer" value="' . esc_attr( stripslashes( $ref ) ) . '" />';	if ( $echo )		echo $orig_referer_field;	return $orig_referer_field;}/** * Retrieve referer from '_wp_http_referer', HTTP referer, or current page respectively. * * @package WordPress * @subpackage Security * @since 2.0.4 * * @return string|bool False on failure. Referer URL on success. */function wp_get_referer() {	$ref = '';	if ( ! empty( $_REQUEST['_wp_http_referer'] ) )		$ref = $_REQUEST['_wp_http_referer'];	else if ( ! empty( $_SERVER['HTTP_REFERER'] ) )		$ref = $_SERVER['HTTP_REFERER'];	if ( $ref !== $_SERVER['REQUEST_URI'] )		return $ref;	return false;}/** * Retrieve original referer that was posted, if it exists. * * @package WordPress * @subpackage Security * @since 2.0.4 * * @return string|bool False if no original referer or original referer if set. */function wp_get_original_referer() {	if ( !empty( $_REQUEST['_wp_original_http_referer'] ) )		return $_REQUEST['_wp_original_http_referer'];	return false;}/** * Recursive directory creation based on full path. * * Will attempt to set permissions on folders. * * @since 2.0.1 * * @param string $target Full path to attempt to create. * @return bool Whether the path was created. True if path already exists. */function wp_mkdir_p( $target ) {	// from php.net/mkdir user contributed notes	$target = str_replace( '//', '/', $target );	// safe mode fails with a trailing slash under certain PHP versions.	$target = rtrim($target, '/'); // Use rtrim() instead of untrailingslashit to avoid formatting.php dependency.	if ( empty($target) )		$target = '/';	if ( file_exists( $target ) )		return @is_dir( $target );	// Attempting to create the directory may clutter up our display.	if ( @mkdir( $target ) ) {		$stat = @stat( dirname( $target ) );		$dir_perms = $stat['mode'] & 0007777;  // Get the permission bits.		@chmod( $target, $dir_perms );		return true;	} elseif ( is_dir( dirname( $target ) ) ) {			return false;	}	// If the above failed, attempt to create the parent node, then try again.	if ( ( $target != '/' ) && ( wp_mkdir_p( dirname( $target ) ) ) )		return wp_mkdir_p( $target );	return false;}/** * Test if a give filesystem path is absolute ('/foo/bar', 'c:\windows'). * * @since 2.5.0 * * @param string $path File path * @return bool True if path is absolute, false is not absolute. */function path_is_absolute( $path ) {	// this is definitive if true but fails if $path does not exist or contains a symbolic link	if ( realpath($path) == $path )		return true;	if ( strlen($path) == 0 || $path{0} == '.' )		return false;	// windows allows absolute paths like this	if ( preg_match('#^[a-zA-Z]:\\\\#', $path) )		return true;	// a path starting with / or \ is absolute; anything else is relative	return (bool) preg_match('#^[/\\\\]#', $path);}/** * Join two filesystem paths together (e.g. 'give me $path relative to $base'). * * If the $path is absolute, then it the full path is returned. * * @since 2.5.0 * * @param string $base * @param string $path * @return string The path with the base or absolute path. */function path_join( $base, $path ) {	if ( path_is_absolute($path) )		return $path;	return rtrim($base, '/') . '/' . ltrim($path, '/');}/** * Get an array containing the current upload directory's path and url. * * Checks the 'upload_path' option, which should be from the web root folder, * and if it isn't empty it will be used. If it is empty, then the path will be * 'WP_CONTENT_DIR/uploads'. If the 'UPLOADS' constant is defined, then it will * override the 'upload_path' option and 'WP_CONTENT_DIR/uploads' path. * * The upload URL path is set either by the 'upload_url_path' option or by using * the 'WP_CONTENT_URL' constant and appending '/uploads' to the path. * * If the 'uploads_use_yearmonth_folders' is set to true (checkbox if checked in * the administration settings panel), then the time will be used. The format * will be year first and then month. * * If the path couldn't be created, then an error will be returned with the key * 'error' containing the error message. The error suggests that the parent * directory is not writable by the server. * * On success, the returned array will have many indices: * 'path' - base directory and sub directory or full path to upload directory. * 'url' - base url and sub directory or absolute URL to upload directory. * 'subdir' - sub directory if uploads use year/month folders option is on. * 'basedir' - path without subdir. * 'baseurl' - URL path without subdir. * 'error' - set to false. * * @since 2.0.0 * @uses apply_filters() Calls 'upload_dir' on returned array. * * @param string $time Optional. Time formatted in 'yyyy/mm'. * @return array See above for description. */function wp_upload_dir( $time = null ) {	global $switched;	$siteurl = get_option( 'siteurl' );	$upload_path = get_option( 'upload_path' );	$upload_path = trim($upload_path);	$main_override = defined( 'MULTISITE' ) && is_main_site();	if ( empty($upload_path) ) {		$dir = WP_CONTENT_DIR . '/uploads';	} else {		$dir = $upload_path;		if ( 'wp-content/uploads' == $upload_path ) {			$dir = WP_CONTENT_DIR . '/uploads';		} elseif ( 0 !== strpos($dir, ABSPATH) ) {			// $dir is absolute, $upload_path is (maybe) relative to ABSPATH			$dir = path_join( ABSPATH, $dir );		}	}	if ( !$url = get_option( 'upload_url_path' ) ) {		if ( empty($upload_path) || ( 'wp-content/uploads' == $upload_path ) || ( $upload_path == $dir ) )			$url = WP_CONTENT_URL . '/uploads';		else			$url = trailingslashit( $siteurl ) . $upload_path;	}	if ( defined('UPLOADS') && !$main_override && ( !isset( $switched ) || $switched === false ) ) {		$dir = ABSPATH . UPLOADS;		$url = trailingslashit( $siteurl ) . UPLOADS;	}	if ( is_multisite() && !$main_override && ( !isset( $switched ) || $switched === false ) ) {		if ( defined( 'BLOGUPLOADDIR' ) )			$dir = untrailingslashit(BLOGUPLOADDIR);		$url = str_replace( UPLOADS, 'files', $url );	}	$bdir = $dir;	$burl = $url;	$subdir = '';	if ( get_option( 'uploads_use_yearmonth_folders' ) ) {		// Generate the yearly and monthly dirs		if ( !$time )			$time = current_time( 'mysql' );		$y = substr( $time, 0, 4 );		$m = substr( $time, 5, 2 );		$subdir = "/$y/$m";	}	$dir .= $subdir;	$url .= $subdir;	$uploads = apply_filters( 'upload_dir', array( 'path' => $dir, 'url' => $url, 'subdir' => $subdir, 'basedir' => $bdir, 'baseurl' => $burl, 'error' => false ) );	// Make sure we have an uploads dir	if ( ! wp_mkdir_p( $uploads['path'] ) ) {		$message = sprintf( __( 'Unable to create directory %s. Is its parent directory writable by the server?' ), $uploads['path'] );		return array( 'error' => $message );	}	return $uploads;}/** * Get a filename that is sanitized and unique for the given directory. * * If the filename is not unique, then a number will be added to the filename * before the extension, and will continue adding numbers until the filename is * unique. * * The callback must accept two parameters, the first one is the directory and * the second is the filename. The callback must be a function. * * @since 2.5 * * @param string $dir * @param string $filename * @param string $unique_filename_callback Function name, must be a function. * @return string New filename, if given wasn't unique. */function wp_unique_filename( $dir, $filename, $unique_filename_callback = null ) {	// sanitize the file name before we begin processing	$filename = sanitize_file_name($filename);	// separate the filename into a name and extension	$info = pathinfo($filename);	$ext = !empty($info['extension']) ? '.' . $info['extension'] : '';	$name = basename($filename, $ext);	// edge case: if file is named '.ext', treat as an empty name	if ( $name === $ext )		$name = '';	// Increment the file number until we have a unique file to save in $dir. Use $override['unique_filename_callback'] if supplied.	if ( $unique_filename_callback && is_callable( $unique_filename_callback ) ) {		$filename = $unique_filename_callback( $dir, $name );	} else {		$number = '';		// change '.ext' to lower case		if ( $ext && strtolower($ext) != $ext ) {			$ext2 = strtolower($ext);			$filename2 = preg_replace( '|' . preg_quote($ext) . '$|', $ext2, $filename );			// check for both lower and upper case extension or image sub-sizes may be overwritten			while ( file_exists($dir . "/$filename") || file_exists($dir . "/$filename2") ) {				$new_number = $number + 1;				$filename = str_replace( "$number$ext", "$new_number$ext", $filename );				$filename2 = str_replace( "$number$ext2", "$new_number$ext2", $filename2 );				$number = $new_number;			}			return $filename2;		}		while ( file_exists( $dir . "/$filename" ) ) {			if ( '' == "$number$ext" )				$filename = $filename . ++$number . $ext;			else				$filename = str_replace( "$number$ext", ++$number . $ext, $filename );		}	}	return $filename;}/** * Create a file in the upload folder with given content. * * If there is an error, then the key 'error' will exist with the error message. * If success, then the key 'file' will have the unique file path, the 'url' key * will have the link to the new file. and the 'error' key will be set to false. * * This function will not move an uploaded file to the upload folder. It will * create a new file with the content in $bits parameter. If you move the upload * file, read the content of the uploaded file, and then you can give the * filename and content to this function, which will add it to the upload * folder. * * The permissions will be set on the new file automatically by this function. * * @since 2.0.0 * * @param string $name * @param null $deprecated Never used. Set to null. * @param mixed $bits File content * @param string $time Optional. Time formatted in 'yyyy/mm'. * @return array */function wp_upload_bits( $name, $deprecated, $bits, $time = null ) {	if ( !empty( $deprecated ) )		_deprecated_argument( __FUNCTION__, '2.0' );	if ( empty( $name ) )		return array( 'error' => __( 'Empty filename' ) );	$wp_filetype = wp_check_filetype( $name );	if ( !$wp_filetype['ext'] )		return array( 'error' => __( 'Invalid file type' ) );	$upload = wp_upload_dir( $time );	if ( $upload['error'] !== false )		return $upload;	$upload_bits_error = apply_filters( 'wp_upload_bits', array( 'name' => $name, 'bits' => $bits, 'time' => $time ) );	if ( !is_array( $upload_bits_error ) ) {		$upload[ 'error' ] = $upload_bits_error;		return $upload;	}	$filename = wp_unique_filename( $upload['path'], $name );	$new_file = $upload['path'] . "/$filename";	if ( ! wp_mkdir_p( dirname( $new_file ) ) ) {		$message = sprintf( __( 'Unable to create directory %s. Is its parent directory writable by the server?' ), dirname( $new_file ) );		return array( 'error' => $message );	}	$ifp = @ fopen( $new_file, 'wb' );	if ( ! $ifp )		return array( 'error' => sprintf( __( 'Could not write file %s' ), $new_file ) );	@fwrite( $ifp, $bits );	fclose( $ifp );	clearstatcache();	// Set correct file permissions	$stat = @ stat( dirname( $new_file ) );	$perms = $stat['mode'] & 0007777;	$perms = $perms & 0000666;	@ chmod( $new_file, $perms );	clearstatcache();	// Compute the URL	$url = $upload['url'] . "/$filename";	return array( 'file' => $new_file, 'url' => $url, 'error' => false );}/** * Retrieve the file type based on the extension name. * * @package WordPress * @since 2.5.0 * @uses apply_filters() Calls 'ext2type' hook on default supported types. * * @param string $ext The extension to search. * @return string|null The file type, example: audio, video, document, spreadsheet, etc. Null if not found. */function wp_ext2type( $ext ) {	$ext2type = apply_filters( 'ext2type', array(		'audio'       => array( 'aac', 'ac3',  'aif',  'aiff', 'm3a',  'm4a',   'm4b', 'mka', 'mp1', 'mp2',  'mp3', 'ogg', 'oga', 'ram', 'wav', 'wma' ),		'video'       => array( 'asf', 'avi',  'divx', 'dv',   'flv',  'm4v',   'mkv', 'mov', 'mp4', 'mpeg', 'mpg', 'mpv', 'ogm', 'ogv', 'qt',  'rm', 'vob', 'wmv' ),		'document'    => array( 'doc', 'docx', 'docm', 'dotm', 'odt',  'pages', 'pdf', 'rtf', 'wp',  'wpd' ),		'spreadsheet' => array( 'numbers',     'ods',  'xls',  'xlsx', 'xlsb',  'xlsm' ),		'interactive' => array( 'key', 'ppt',  'pptx', 'pptm', 'odp',  'swf' ),		'text'        => array( 'asc', 'csv',  'tsv',  'txt' ),		'archive'     => array( 'bz2', 'cab',  'dmg',  'gz',   'rar',  'sea',   'sit', 'sqx', 'tar', 'tgz',  'zip' ),		'code'        => array( 'css', 'htm',  'html', 'php',  'js' ),	));	foreach ( $ext2type as $type => $exts )		if ( in_array( $ext, $exts ) )			return $type;}/** * Retrieve the file type from the file name. * * You can optionally define the mime array, if needed. * * @since 2.0.4 * * @param string $filename File name or path. * @param array $mimes Optional. Key is the file extension with value as the mime type. * @return array Values with extension first and mime type. */function wp_check_filetype( $filename, $mimes = null ) {	if ( empty($mimes) )		$mimes = get_allowed_mime_types();	$type = false;	$ext = false;	foreach ( $mimes as $ext_preg => $mime_match ) {		$ext_preg = '!\.(' . $ext_preg . ')$!i';		if ( preg_match( $ext_preg, $filename, $ext_matches ) ) {			$type = $mime_match;			$ext = $ext_matches[1];			break;		}	}	return compact( 'ext', 'type' );}/** * Attempt to determine the real file type of a file. * If unable to, the file name extension will be used to determine type. * * If it's determined that the extension does not match the file's real type, * then the "proper_filename" value will be set with a proper filename and extension. * * Currently this function only supports validating images known to getimagesize(). * * @since 3.0.0 * * @param string $file Full path to the image. * @param string $filename The filename of the image (may differ from $file due to $file being in a tmp directory) * @param array $mimes Optional. Key is the file extension with value as the mime type. * @return array Values for the extension, MIME, and either a corrected filename or false if original $filename is valid */function wp_check_filetype_and_ext( $file, $filename, $mimes = null ) {	$proper_filename = false;	// Do basic extension validation and MIME mapping	$wp_filetype = wp_check_filetype( $filename, $mimes );	extract( $wp_filetype );	// We can't do any further validation without a file to work with	if ( ! file_exists( $file ) )		return compact( 'ext', 'type', 'proper_filename' );	// We're able to validate images using GD	if ( $type && 0 === strpos( $type, 'image/' ) && function_exists('getimagesize') ) {		// Attempt to figure out what type of image it actually is		$imgstats = @getimagesize( $file );		// If getimagesize() knows what kind of image it really is and if the real MIME doesn't match the claimed MIME		if ( !empty($imgstats['mime']) && $imgstats['mime'] != $type ) {			// This is a simplified array of MIMEs that getimagesize() can detect and their extensions			// You shouldn't need to use this filter, but it's here just in case			$mime_to_ext = apply_filters( 'getimagesize_mimes_to_exts', array(				'image/jpeg' => 'jpg',				'image/png'  => 'png',				'image/gif'  => 'gif',				'image/bmp'  => 'bmp',				'image/tiff' => 'tif',			) );			// Replace whatever is after the last period in the filename with the correct extension			if ( ! empty( $mime_to_ext[ $imgstats['mime'] ] ) ) {				$filename_parts = explode( '.', $filename );				array_pop( $filename_parts );				$filename_parts[] = $mime_to_ext[ $imgstats['mime'] ];				$new_filename = implode( '.', $filename_parts );				if ( $new_filename != $filename )					$proper_filename = $new_filename; // Mark that it changed				// Redefine the extension / MIME				$wp_filetype = wp_check_filetype( $new_filename, $mimes );				extract( $wp_filetype );			}		}	}	// Let plugins try and validate other types of files	// Should return an array in the style of array( 'ext' => $ext, 'type' => $type, 'proper_filename' => $proper_filename )	return apply_filters( 'wp_check_filetype_and_ext', compact( 'ext', 'type', 'proper_filename' ), $file, $filename, $mimes );}/** * Retrieve list of allowed mime types and file extensions. * * @since 2.8.6 * * @return array Array of mime types keyed by the file extension regex corresponding to those types. */function get_allowed_mime_types() {	static $mimes = false;	if ( !$mimes ) {		// Accepted MIME types are set here as PCRE unless provided.		$mimes = apply_filters( 'upload_mimes', array(		'jpg|jpeg|jpe' => 'image/jpeg',		'gif' => 'image/gif',		'png' => 'image/png',		'bmp' => 'image/bmp',		'tif|tiff' => 'image/tiff',		'ico' => 'image/x-icon',		'asf|asx|wax|wmv|wmx' => 'video/asf',		'avi' => 'video/avi',		'divx' => 'video/divx',		'flv' => 'video/x-flv',		'mov|qt' => 'video/quicktime',		'mpeg|mpg|mpe' => 'video/mpeg',		'txt|asc|c|cc|h' => 'text/plain',		'csv' => 'text/csv',		'tsv' => 'text/tab-separated-values',		'rtx' => 'text/richtext',		'css' => 'text/css',		'htm|html' => 'text/html',		'mp3|m4a|m4b' => 'audio/mpeg',		'mp4|m4v' => 'video/mp4',		'ra|ram' => 'audio/x-realaudio',		'wav' => 'audio/wav',		'ogg|oga' => 'audio/ogg',		'ogv' => 'video/ogg',		'mid|midi' => 'audio/midi',		'wma' => 'audio/wma',		'mka' => 'audio/x-matroska',		'mkv' => 'video/x-matroska',		'rtf' => 'application/rtf',		'js' => 'application/javascript',		'pdf' => 'application/pdf',		'doc|docx' => 'application/msword',		'pot|pps|ppt|pptx|ppam|pptm|sldm|ppsm|potm' => 'application/vnd.ms-powerpoint',		'wri' => 'application/vnd.ms-write',		'xla|xls|xlsx|xlt|xlw|xlam|xlsb|xlsm|xltm' => 'application/vnd.ms-excel',		'mdb' => 'application/vnd.ms-access',		'mpp' => 'application/vnd.ms-project',		'docm|dotm' => 'application/vnd.ms-word',		'pptx|sldx|ppsx|potx' => 'application/vnd.openxmlformats-officedocument.presentationml',		'xlsx|xltx' => 'application/vnd.openxmlformats-officedocument.spreadsheetml',		'docx|dotx' => 'application/vnd.openxmlformats-officedocument.wordprocessingml',		'onetoc|onetoc2|onetmp|onepkg' => 'application/onenote',		'swf' => 'application/x-shockwave-flash',		'class' => 'application/java',		'tar' => 'application/x-tar',		'zip' => 'application/zip',		'gz|gzip' => 'application/x-gzip',		'exe' => 'application/x-msdownload',		// openoffice formats		'odt' => 'application/vnd.oasis.opendocument.text',		'odp' => 'application/vnd.oasis.opendocument.presentation',		'ods' => 'application/vnd.oasis.opendocument.spreadsheet',		'odg' => 'application/vnd.oasis.opendocument.graphics',		'odc' => 'application/vnd.oasis.opendocument.chart',		'odb' => 'application/vnd.oasis.opendocument.database',		'odf' => 'application/vnd.oasis.opendocument.formula',		// wordperfect formats		'wp|wpd' => 'application/wordperfect',		) );	}	return $mimes;}/** * Retrieve nonce action "Are you sure" message. * * The action is split by verb and noun. The action format is as follows: * verb-action_extra. The verb is before the first dash and has the format of * letters and no spaces and numbers. The noun is after the dash and before the * underscore, if an underscore exists. The noun is also only letters. * * The filter will be called for any action, which is not defined by WordPress. * You may use the filter for your plugin to explain nonce actions to the user, * when they get the "Are you sure?" message. The filter is in the format of * 'explain_nonce_$verb-$noun' with the $verb replaced by the found verb and the * $noun replaced by the found noun. The two parameters that are given to the * hook are the localized "Are you sure you want to do this?" message with the * extra text (the text after the underscore). * * @package WordPress * @subpackage Security * @since 2.0.4 * * @param string $action Nonce action. * @return string Are you sure message. */function wp_explain_nonce( $action ) {	if ( $action !== -1 && preg_match( '/([a-z]+)-([a-z]+)(_(.+))?/', $action, $matches ) ) {		$verb = $matches[1];		$noun = $matches[2];		$trans = array();		$trans['update']['attachment'] = array( __( 'Your attempt to edit this attachment: &#8220;%s&#8221; has failed.' ), 'get_the_title' );		$trans['add']['category']      = array( __( 'Your attempt to add this category has failed.' ), false );		$trans['delete']['category']   = array( __( 'Your attempt to delete this category: &#8220;%s&#8221; has failed.' ), 'get_cat_name' );		$trans['update']['category']   = array( __( 'Your attempt to edit this category: &#8220;%s&#8221; has failed.' ), 'get_cat_name' );		$trans['delete']['comment']    = array( __( 'Your attempt to delete this comment: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['unapprove']['comment'] = array( __( 'Your attempt to unapprove this comment: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['approve']['comment']   = array( __( 'Your attempt to approve this comment: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['update']['comment']    = array( __( 'Your attempt to edit this comment: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['bulk']['comments']     = array( __( 'Your attempt to bulk modify comments has failed.' ), false );		$trans['moderate']['comments'] = array( __( 'Your attempt to moderate comments has failed.' ), false );		$trans['add']['bookmark']      = array( __( 'Your attempt to add this link has failed.' ), false );		$trans['delete']['bookmark']   = array( __( 'Your attempt to delete this link: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['update']['bookmark']   = array( __( 'Your attempt to edit this link: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['bulk']['bookmarks']    = array( __( 'Your attempt to bulk modify links has failed.' ), false );		$trans['add']['page']          = array( __( 'Your attempt to add this page has failed.' ), false );		$trans['delete']['page']       = array( __( 'Your attempt to delete this page: &#8220;%s&#8221; has failed.' ), 'get_the_title' );		$trans['update']['page']       = array( __( 'Your attempt to edit this page: &#8220;%s&#8221; has failed.' ), 'get_the_title' );		$trans['edit']['plugin']       = array( __( 'Your attempt to edit this plugin file: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['activate']['plugin']   = array( __( 'Your attempt to activate this plugin: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['deactivate']['plugin'] = array( __( 'Your attempt to deactivate this plugin: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['upgrade']['plugin']    = array( __( 'Your attempt to upgrade this plugin: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['add']['post']          = array( __( 'Your attempt to add this post has failed.' ), false );		$trans['delete']['post']       = array( __( 'Your attempt to delete this post: &#8220;%s&#8221; has failed.' ), 'get_the_title' );		$trans['update']['post']       = array( __( 'Your attempt to edit this post: &#8220;%s&#8221; has failed.' ), 'get_the_title' );		$trans['add']['user']          = array( __( 'Your attempt to add this user has failed.' ), false );		$trans['delete']['users']      = array( __( 'Your attempt to delete users has failed.' ), false );		$trans['bulk']['users']        = array( __( 'Your attempt to bulk modify users has failed.' ), false );		$trans['update']['user']       = array( __( 'Your attempt to edit this user: &#8220;%s&#8221; has failed.' ), 'get_the_author_meta', 'display_name' );		$trans['update']['profile']    = array( __( 'Your attempt to modify the profile for: &#8220;%s&#8221; has failed.' ), 'get_the_author_meta', 'display_name' );		$trans['update']['options']    = array( __( 'Your attempt to edit your settings has failed.' ), false );		$trans['update']['permalink']  = array( __( 'Your attempt to change your permalink structure to: %s has failed.' ), 'use_id' );		$trans['edit']['file']         = array( __( 'Your attempt to edit this file: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['edit']['theme']        = array( __( 'Your attempt to edit this theme file: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['switch']['theme']      = array( __( 'Your attempt to switch to this theme: &#8220;%s&#8221; has failed.' ), 'use_id' );		$trans['log']['out']           = array( sprintf( __( 'You are attempting to log out of %s' ), get_bloginfo( 'sitename' ) ), false );		if ( isset( $trans[$verb][$noun] ) ) {			if ( !empty( $trans[$verb][$noun][1] ) ) {				$lookup = $trans[$verb][$noun][1];				if ( isset($trans[$verb][$noun][2]) )					$lookup_value = $trans[$verb][$noun][2];				$object = $matches[4];				if ( 'use_id' != $lookup ) {					if ( isset( $lookup_value ) )						$object = call_user_func( $lookup, $lookup_value, $object );					else						$object = call_user_func( $lookup, $object );				}				return sprintf( $trans[$verb][$noun][0], esc_html($object) );			} else {				return $trans[$verb][$noun][0];			}		}		return apply_filters( 'explain_nonce_' . $verb . '-' . $noun, __( 'Are you sure you want to do this?' ), isset($matches[4]) ? $matches[4] : '' );	} else {		return apply_filters( 'explain_nonce_' . $action, __( 'Are you sure you want to do this?' ) );	}}/** * Display "Are You Sure" message to confirm the action being taken. * * If the action has the nonce explain message, then it will be displayed along * with the "Are you sure?" message. * * @package WordPress * @subpackage Security * @since 2.0.4 * * @param string $action The nonce action. */function wp_nonce_ays( $action ) {	$title = __( 'WordPress Failure Notice' );	$html = esc_html( wp_explain_nonce( $action ) );	if ( 'log-out' == $action )		$html .= "</p><p>" . sprintf( __( "Do you really want to <a href='%s'>log out</a>?"), wp_logout_url() );	elseif ( wp_get_referer() )		$html .= "</p><p><a href='" . esc_url( remove_query_arg( 'updated', wp_get_referer() ) ) . "'>" . __( 'Please try again.' ) . "</a>";	wp_die( $html, $title, array('response' => 403) );}/** * Kill WordPress execution and display HTML message with error message. * * This function complements the die() PHP function. The difference is that * HTML will be displayed to the user. It is recommended to use this function * only, when the execution should not continue any further. It is not * recommended to call this function very often and try to handle as many errors * as possible siliently. * * @since 2.0.4 * * @param string $message Error message. * @param string $title Error title. * @param string|array $args Optional arguements to control behaviour. */function wp_die( $message, $title = '', $args = array() ) {	if ( function_exists( 'apply_filters' ) ) {		$function = apply_filters( 'wp_die_handler', '_default_wp_die_handler');	}else {		$function = '_default_wp_die_handler';	}	call_user_func( $function, $message, $title, $args );}/** * Kill WordPress execution and display HTML message with error message. * * This is the default handler for wp_die if you want a custom one for your * site then you can overload using the wp_die_handler filter in wp_die * * @since 3.0.0 * @access private * * @param string $message Error message. * @param string $title Error title. * @param string|array $args Optional arguements to control behaviour. */function _default_wp_die_handler( $message, $title = '', $args = array() ) {	$defaults = array( 'response' => 500 );	$r = wp_parse_args($args, $defaults);	$have_gettext = function_exists('__');	if ( function_exists( 'is_wp_error' ) && is_wp_error( $message ) ) {		if ( empty( $title ) ) {			$error_data = $message->get_error_data();			if ( is_array( $error_data ) && isset( $error_data['title'] ) )				$title = $error_data['title'];		}		$errors = $message->get_error_messages();		switch ( count( $errors ) ) :		case 0 :			$message = '';			break;		case 1 :			$message = "<p>{$errors[0]}</p>";			break;		default :			$message = "<ul>\n\t\t<li>" . join( "</li>\n\t\t<li>", $errors ) . "</li>\n\t</ul>";			break;		endswitch;	} elseif ( is_string( $message ) ) {		$message = "<p>$message</p>";	}	if ( isset( $r['back_link'] ) && $r['back_link'] ) {		$back_text = $have_gettext? __('&laquo; Back') : '&laquo; Back';		$message .= "\n<p><a href='javascript:history.back()'>$back_text</p>";	}	if ( defined( 'WP_SITEURL' ) && '' != WP_SITEURL )		$admin_dir = WP_SITEURL . '/wp-admin/';	elseif ( function_exists( 'get_bloginfo' ) && '' != get_bloginfo( 'wpurl' ) )		$admin_dir = get_bloginfo( 'wpurl' ) . '/wp-admin/';	elseif ( strpos( $_SERVER['PHP_SELF'], 'wp-admin' ) !== false )		$admin_dir = '';	else		$admin_dir = 'wp-admin/';	if ( !function_exists( 'did_action' ) || !did_action( 'admin_head' ) ) :	if ( !headers_sent() ) {		status_header( $r['response'] );		nocache_headers();		header( 'Content-Type: text/html; charset=utf-8' );	}	if ( empty($title) )		$title = $have_gettext ? __('WordPress &rsaquo; Error') : 'WordPress &rsaquo; Error';	$text_direction = 'ltr';	if ( isset($r['text_direction']) && 'rtl' == $r['text_direction'] )		$text_direction = 'rtl';	elseif ( function_exists( 'is_rtl' ) && is_rtl() )		$text_direction = 'rtl';?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><!-- Ticket #11289, IE bug fix: always pad the error page with enough characters such that it is greater than 512 bytes, even after gzip compression abcdefghijklmnopqrstuvwxyz1234567890aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz11223344556677889900abacbcbdcdcededfefegfgfhghgihihjijikjkjlklkmlmlnmnmononpopoqpqprqrqsrsrtstsubcbcdcdedefefgfabcadefbghicjkldmnoepqrfstugvwxhyz1i234j567k890laabmbccnddeoeffpgghqhiirjjksklltmmnunoovppqwqrrxsstytuuzvvw0wxx1yyz2z113223434455666777889890091abc2def3ghi4jkl5mno6pqr7stu8vwx9yz11aab2bcc3dd4ee5ff6gg7hh8ii9j0jk1kl2lmm3nnoo4p5pq6qrr7ss8tt9uuvv0wwx1x2yyzz13aba4cbcb5dcdc6dedfef8egf9gfh0ghg1ihi2hji3jik4jkj5lkl6kml7mln8mnm9ono --><html xmlns="http://www.w3.org/1999/xhtml" <?php if ( function_exists( 'language_attributes' ) ) language_attributes(); ?>><head>	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />	<title><?php echo $title ?></title>	<link rel="stylesheet" href="<?php echo $admin_dir; ?>css/install.css" type="text/css" /><?phpif ( 'rtl' == $text_direction ) : ?>	<link rel="stylesheet" href="<?php echo $admin_dir; ?>css/install-rtl.css" type="text/css" /><?php endif; ?></head><body id="error-page"><?php endif; ?>	<?php echo $message; ?></body></html><?php	die();}/** * Retrieve the WordPress home page URL. * * If the constant named 'WP_HOME' exists, then it willl be used and returned by * the function. This can be used to counter the redirection on your local * development environment. * * @access private * @package WordPress * @since 2.2.0 * * @param string $url URL for the home location * @return string Homepage location. */function _config_wp_home( $url = '' ) {	if ( defined( 'WP_HOME' ) )		return WP_HOME;	return $url;}/** * Retrieve the WordPress site URL. * * If the constant named 'WP_SITEURL' is defined, then the value in that * constant will always be returned. This can be used for debugging a site on * your localhost while not having to change the database to your URL. * * @access private * @package WordPress * @since 2.2.0 * * @param string $url URL to set the WordPress site location. * @return string The WordPress Site URL */function _config_wp_siteurl( $url = '' ) {	if ( defined( 'WP_SITEURL' ) )		return WP_SITEURL;	return $url;}/** * Set the localized direction for MCE plugin. * * Will only set the direction to 'rtl', if the WordPress locale has the text * direction set to 'rtl'. * * Fills in the 'directionality', 'plugins', and 'theme_advanced_button1' array * keys. These keys are then returned in the $input array. * * @access private * @package WordPress * @subpackage MCE * @since 2.1.0 * * @param array $input MCE plugin array. * @return array Direction set for 'rtl', if needed by locale. */function _mce_set_direction( $input ) {	if ( is_rtl() ) {		$input['directionality'] = 'rtl';		$input['plugins'] .= ',directionality';		$input['theme_advanced_buttons1'] .= ',ltr';	}	return $input;}/** * Convert smiley code to the icon graphic file equivalent. * * You can turn off smilies, by going to the write setting screen and unchecking * the box, or by setting 'use_smilies' option to false or removing the option. * * Plugins may override the default smiley list by setting the $wpsmiliestrans * to an array, with the key the code the blogger types in and the value the * image file. * * The $wp_smiliessearch global is for the regular expression and is set each * time the function is called. * * The full list of smilies can be found in the function and won't be listed in * the description. Probably should create a Codex page for it, so that it is * available. * * @global array $wpsmiliestrans * @global array $wp_smiliessearch * @since 2.2.0 */function smilies_init() {	global $wpsmiliestrans, $wp_smiliessearch;	// don't bother setting up smilies if they are disabled	if ( !get_option( 'use_smilies' ) )		return;	if ( !isset( $wpsmiliestrans ) ) {		$wpsmiliestrans = array(		':mrgreen:' => 'icon_mrgreen.gif',		':neutral:' => 'icon_neutral.gif',		':twisted:' => 'icon_twisted.gif',		  ':arrow:' => 'icon_arrow.gif',		  ':shock:' => 'icon_eek.gif',		  ':smile:' => 'icon_smile.gif',		    ':???:' => 'icon_confused.gif',		   ':cool:' => 'icon_cool.gif',		   ':evil:' => 'icon_evil.gif',		   ':grin:' => 'icon_biggrin.gif',		   ':idea:' => 'icon_idea.gif',		   ':oops:' => 'icon_redface.gif',		   ':razz:' => 'icon_razz.gif',		   ':roll:' => 'icon_rolleyes.gif',		   ':wink:' => 'icon_wink.gif',		    ':cry:' => 'icon_cry.gif',		    ':eek:' => 'icon_surprised.gif',		    ':lol:' => 'icon_lol.gif',		    ':mad:' => 'icon_mad.gif',		    ':sad:' => 'icon_sad.gif',		      '8-)' => 'icon_cool.gif',		      '8-O' => 'icon_eek.gif',		      ':-(' => 'icon_sad.gif',		      ':-)' => 'icon_smile.gif',		      ':-?' => 'icon_confused.gif',		      ':-D' => 'icon_biggrin.gif',		      ':-P' => 'icon_razz.gif',		      ':-o' => 'icon_surprised.gif',		      ':-x' => 'icon_mad.gif',		      ':-|' => 'icon_neutral.gif',		      ';-)' => 'icon_wink.gif',		       '8)' => 'icon_cool.gif',		       '8O' => 'icon_eek.gif',		       ':(' => 'icon_sad.gif',		       ':)' => 'icon_smile.gif',		       ':?' => 'icon_confused.gif',		       ':D' => 'icon_biggrin.gif',		       ':P' => 'icon_razz.gif',		       ':o' => 'icon_surprised.gif',		       ':x' => 'icon_mad.gif',		       ':|' => 'icon_neutral.gif',		       ';)' => 'icon_wink.gif',		      ':!:' => 'icon_exclaim.gif',		      ':?:' => 'icon_question.gif',		);	}	if (count($wpsmiliestrans) == 0) {		return;	}	/*	 * NOTE: we sort the smilies in reverse key order. This is to make sure	 * we match the longest possible smilie (:???: vs :?) as the regular	 * expression used below is first-match	 */	krsort($wpsmiliestrans);	$wp_smiliessearch = '/(?:\s|^)';	$subchar = '';	foreach ( (array) $wpsmiliestrans as $smiley => $img ) {		$firstchar = substr($smiley, 0, 1);		$rest = substr($smiley, 1);		// new subpattern?		if ($firstchar != $subchar) {			if ($subchar != '') {				$wp_smiliessearch .= ')|(?:\s|^)';			}			$subchar = $firstchar;			$wp_smiliessearch .= preg_quote($firstchar, '/') . '(?:';		} else {			$wp_smiliessearch .= '|';		}		$wp_smiliessearch .= preg_quote($rest, '/');	}	$wp_smiliessearch .= ')(?:\s|$)/m';}/** * Merge user defined arguments into defaults array. * * This function is used throughout WordPress to allow for both string or array * to be merged into another array. * * @since 2.2.0 * * @param string|array $args Value to merge with $defaults * @param array $defaults Array that serves as the defaults. * @return array Merged user defined values with defaults. */function wp_parse_args( $args, $defaults = '' ) {	if ( is_object( $args ) )		$r = get_object_vars( $args );	elseif ( is_array( $args ) )		$r =& $args;	else		wp_parse_str( $args, $r );	if ( is_array( $defaults ) )		return array_merge( $defaults, $r );	return $r;}/** * Clean up an array, comma- or space-separated list of IDs * * @since 3.0.0 * * @param array|string $list * @return array Sanitized array of IDs */function wp_parse_id_list( $list ) {	if ( !is_array($list) )		$list = preg_split('/[\s,]+/', $list);	return array_unique(array_map('absint', $list));}/** * Filters a list of objects, based on a set of key => value arguments * * @since 3.0.0 * * @param array $list An array of objects to filter * @param array $args An array of key => value arguments to match against each object * @param string $operator The logical operation to perform. 'or' means only one element *	from the array needs to match; 'and' means all elements must match. The default is 'and'. * @param bool|string $field A field from the object to place instead of the entire object * @return array A list of objects or object fields */function wp_filter_object_list( $list, $args = array(), $operator = 'and', $field = false ) {	if ( !is_array($list) )		return array();	if ( empty($args) )		$args = array();	if ( empty($args) && !$field )		return $list;	// nothing to do	$count = count($args);	$filtered = array();	foreach ( $list as $key => $obj ) {		$matched = count(array_intersect_assoc(get_object_vars($obj), $args));		if ( ('and' == $operator && $matched == $count) || ('or' == $operator && $matched <= $count) ) {			if ( $field )				$filtered[] = $obj->$field;			else				$filtered[$key] = $obj;		}	}	return $filtered;}/** * Determines if default embed handlers should be loaded. * * Checks to make sure that the embeds library hasn't already been loaded. If * it hasn't, then it will load the embeds library. * * @since 2.9.0 */function wp_maybe_load_embeds() {	if ( ! apply_filters('load_default_embeds', true) )		return;	require_once( ABSPATH . WPINC . '/default-embeds.php' );}/** * Determines if Widgets library should be loaded. * * Checks to make sure that the widgets library hasn't already been loaded. If * it hasn't, then it will load the widgets library and run an action hook. * * @since 2.2.0 * @uses add_action() Calls '_admin_menu' hook with 'wp_widgets_add_menu' value. */function wp_maybe_load_widgets() {	if ( ! apply_filters('load_default_widgets', true) )		return;	require_once( ABSPATH . WPINC . '/default-widgets.php' );	add_action( '_admin_menu', 'wp_widgets_add_menu' );}/** * Append the Widgets menu to the themes main menu. * * @since 2.2.0 * @uses $submenu The administration submenu list. */function wp_widgets_add_menu() {	global $submenu;	$submenu['themes.php'][7] = array( __( 'Widgets' ), 'edit_theme_options', 'widgets.php' );	ksort( $submenu['themes.php'], SORT_NUMERIC );}/** * Flush all output buffers for PHP 5.2. * * Make sure all output buffers are flushed before our singletons our destroyed. * * @since 2.2.0 */function wp_ob_end_flush_all() {	$levels = ob_get_level();	for ($i=0; $i<$levels; $i++)		ob_end_flush();}/** * Load the correct database class file. * * This function is used to load the database class file either at runtime or by * wp-admin/setup-config.php We must globalise $wpdb to ensure that it is * defined globally by the inline code in wp-db.php. * * @since 2.5.0 * @global $wpdb WordPress Database Object */function require_wp_db() {	global $wpdb;	if ( file_exists( WP_CONTENT_DIR . '/db.php' ) )		require_once( WP_CONTENT_DIR . '/db.php' );	else		require_once( ABSPATH . WPINC . '/wp-db.php' );}/** * Load custom DB error or display WordPress DB error. * * If a file exists in the wp-content directory named db-error.php, then it will * be loaded instead of displaying the WordPress DB error. If it is not found, * then the WordPress DB error will be displayed instead. * * The WordPress DB error sets the HTTP status header to 500 to try to prevent * search engines from caching the message. Custom DB messages should do the * same. * * This function was backported to the the WordPress 2.3.2, but originally was * added in WordPress 2.5.0. * * @since 2.3.2 * @uses $wpdb */function dead_db() {	global $wpdb;	// Load custom DB error template, if present.	if ( file_exists( WP_CONTENT_DIR . '/db-error.php' ) ) {		require_once( WP_CONTENT_DIR . '/db-error.php' );		die();	}	// If installing or in the admin, provide the verbose message.	if ( defined('WP_INSTALLING') || defined('WP_ADMIN') )		wp_die($wpdb->error);	// Otherwise, be terse.	status_header( 500 );	nocache_headers();	header( 'Content-Type: text/html; charset=utf-8' );?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" <?php if ( function_exists( 'language_attributes' ) ) language_attributes(); ?>><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />	<title>Database Error</title></head><body>	<h1>Error establishing a database connection</h1></body></html><?php	die();}/** * Converts value to nonnegative integer. * * @since 2.5.0 * * @param mixed $maybeint Data you wish to have convered to an nonnegative integer * @return int An nonnegative integer */function absint( $maybeint ) {	return abs( intval( $maybeint ) );}/** * Determines if the blog can be accessed over SSL. * * Determines if blog can be accessed over SSL by using cURL to access the site * using the https in the siteurl. Requires cURL extension to work correctly. * * @since 2.5.0 * * @param string $url * @return bool Whether SSL access is available */function url_is_accessable_via_ssl($url){	if (in_array('curl', get_loaded_extensions())) {		$ssl = preg_replace( '/^http:\/\//', 'https://',  $url );		$ch = curl_init();		curl_setopt($ch, CURLOPT_URL, $ssl);		curl_setopt($ch, CURLOPT_FAILONERROR, true);		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);		curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);		curl_exec($ch);		$status = curl_getinfo($ch, CURLINFO_HTTP_CODE);		curl_close ($ch);		if ($status == 200 || $status == 401) {			return true;		}	}	return false;}/** * Secure URL, if available or the given URL. * * @since 2.5.0 * * @param string $url Complete URL path with transport. * @return string Secure or regular URL path. */function atom_service_url_filter($url){	if ( url_is_accessable_via_ssl($url) )		return preg_replace( '/^http:\/\//', 'https://',  $url );	else		return $url;}/** * Marks a function as deprecated and informs when it has been used. * * There is a hook deprecated_function_run that will be called that can be used * to get the backtrace up to what file and function called the deprecated * function. * * The current behavior is to trigger an user error if WP_DEBUG is true. * * This function is to be used in every function in depreceated.php * * @package WordPress * @subpackage Debug * @since 2.5.0 * @access private * * @uses do_action() Calls 'deprecated_function_run' and passes the function name, what to use instead, *   and the version the function was deprecated in. * @uses apply_filters() Calls 'deprecated_function_trigger_error' and expects boolean value of true to do *   trigger or false to not trigger error. * * @param string $function The function that was called * @param string $version The version of WordPress that deprecated the function * @param string $replacement Optional. The function that should have been called */function _deprecated_function( $function, $version, $replacement=null ) {	do_action( 'deprecated_function_run', $function, $replacement, $version );	// Allow plugin to filter the output error trigger	if ( WP_DEBUG && apply_filters( 'deprecated_function_trigger_error', true ) ) {		if ( ! is_null($replacement) )			trigger_error( sprintf( __('%1$s is <strong>deprecated</strong> since version %2$s! Use %3$s instead.'), $function, $version, $replacement ) );		else			trigger_error( sprintf( __('%1$s is <strong>deprecated</strong> since version %2$s with no alternative available.'), $function, $version ) );	}}/** * Marks a file as deprecated and informs when it has been used. * * There is a hook deprecated_file_included that will be called that can be used * to get the backtrace up to what file and function included the deprecated * file. * * The current behavior is to trigger an user error if WP_DEBUG is true. * * This function is to be used in every file that is depreceated * * @package WordPress * @subpackage Debug * @since 2.5.0 * @access private * * @uses do_action() Calls 'deprecated_file_included' and passes the file name, what to use instead, *   the version in which the file was deprecated, and any message regarding the change. * @uses apply_filters() Calls 'deprecated_file_trigger_error' and expects boolean value of true to do *   trigger or false to not trigger error. * * @param string $file The file that was included * @param string $version The version of WordPress that deprecated the file * @param string $replacement Optional. The file that should have been included based on ABSPATH * @param string $message Optional. A message regarding the change */function _deprecated_file( $file, $version, $replacement = null, $message = '' ) {	do_action( 'deprecated_file_included', $file, $replacement, $version, $message );	// Allow plugin to filter the output error trigger	if ( WP_DEBUG && apply_filters( 'deprecated_file_trigger_error', true ) ) {		$message = empty( $message ) ? '' : ' ' . $message;		if ( ! is_null( $replacement ) )			trigger_error( sprintf( __('%1$s is <strong>deprecated</strong> since version %2$s! Use %3$s instead.'), $file, $version, $replacement ) . $message );		else			trigger_error( sprintf( __('%1$s is <strong>deprecated</strong> since version %2$s with no alternative available.'), $file, $version ) . $message );	}}/** * Marks a function argument as deprecated and informs when it has been used. * * This function is to be used whenever a deprecated function argument is used. * Before this function is called, the argument must be checked for whether it was * used by comparing it to its default value or evaluating whether it is empty. * For example: * <code> * if ( !empty($deprecated) ) * 	_deprecated_argument( __FUNCTION__, '3.0' ); * </code> * * There is a hook deprecated_argument_run that will be called that can be used * to get the backtrace up to what file and function used the deprecated * argument. * * The current behavior is to trigger an user error if WP_DEBUG is true. * * @package WordPress * @subpackage Debug * @since 3.0.0 * @access private * * @uses do_action() Calls 'deprecated_argument_run' and passes the function name, a message on the change, *   and the version in which the argument was deprecated. * @uses apply_filters() Calls 'deprecated_argument_trigger_error' and expects boolean value of true to do *   trigger or false to not trigger error. * * @param string $function The function that was called * @param string $version The version of WordPress that deprecated the argument used * @param string $message Optional. A message regarding the change. */function _deprecated_argument( $function, $version, $message = null ) {	do_action( 'deprecated_argument_run', $function, $message, $version );	// Allow plugin to filter the output error trigger	if ( WP_DEBUG && apply_filters( 'deprecated_argument_trigger_error', true ) ) {		if ( ! is_null( $message ) )			trigger_error( sprintf( __('%1$s was called with an argument that is <strong>deprecated</strong> since version %2$s! %3$s'), $function, $version, $message ) );		else			trigger_error( sprintf( __('%1$s was called with an argument that is <strong>deprecated</strong> since version %2$s with no alternative available.'), $function, $version ) );	}}/** * Is the server running earlier than 1.5.0 version of lighttpd * * @since 2.5.0 * * @return bool Whether the server is running lighttpd < 1.5.0 */function is_lighttpd_before_150() {	$server_parts = explode( '/', isset( $_SERVER['SERVER_SOFTWARE'] )? $_SERVER['SERVER_SOFTWARE'] : '' );	$server_parts[1] = isset( $server_parts[1] )? $server_parts[1] : '';	return  'lighttpd' == $server_parts[0] && -1 == version_compare( $server_parts[1], '1.5.0' );}/** * Does the specified module exist in the apache config? * * @since 2.5.0 * * @param string $mod e.g. mod_rewrite * @param bool $default The default return value if the module is not found * @return bool */function apache_mod_loaded($mod, $default = false) {	global $is_apache;	if ( !$is_apache )		return false;	if ( function_exists('apache_get_modules') ) {		$mods = apache_get_modules();		if ( in_array($mod, $mods) )			return true;	} elseif ( function_exists('phpinfo') ) {			ob_start();			phpinfo(8);			$phpinfo = ob_get_clean();			if ( false !== strpos($phpinfo, $mod) )				return true;	}	return $default;}/** * File validates against allowed set of defined rules. * * A return value of '1' means that the $file contains either '..' or './'. A * return value of '2' means that the $file contains ':' after the first * character. A return value of '3' means that the file is not in the allowed * files list. * * @since 1.2.0 * * @param string $file File path. * @param array $allowed_files List of allowed files. * @return int 0 means nothing is wrong, greater than 0 means something was wrong. */function validate_file( $file, $allowed_files = '' ) {	if ( false !== strpos( $file, '..' ))		return 1;	if ( false !== strpos( $file, './' ))		return 1;	if (!empty ( $allowed_files ) && (!in_array( $file, $allowed_files ) ) )		return 3;	if (':' == substr( $file, 1, 1 ))		return 2;	return 0;}/** * Determine if SSL is used. * * @since 2.6.0 * * @return bool True if SSL, false if not used. */function is_ssl() {	if ( isset($_SERVER['HTTPS']) ) {		if ( 'on' == strtolower($_SERVER['HTTPS']) )			return true;		if ( '1' == $_SERVER['HTTPS'] )			return true;	} elseif ( isset($_SERVER['SERVER_PORT']) && ( '443' == $_SERVER['SERVER_PORT'] ) ) {		return true;	}	return false;}/** * Whether SSL login should be forced. * * @since 2.6.0 * * @param string|bool $force Optional. * @return bool True if forced, false if not forced. */function force_ssl_login( $force = null ) {	static $forced = false;	if ( !is_null( $force ) ) {		$old_forced = $forced;		$forced = $force;		return $old_forced;	}	return $forced;}/** * Whether to force SSL used for the Administration Panels. * * @since 2.6.0 * * @param string|bool $force * @return bool True if forced, false if not forced. */function force_ssl_admin( $force = null ) {	static $forced = false;	if ( !is_null( $force ) ) {		$old_forced = $forced;		$forced = $force;		return $old_forced;	}	return $forced;}/** * Guess the URL for the site. * * Will remove wp-admin links to retrieve only return URLs not in the wp-admin * directory. * * @since 2.6.0 * * @return string */function wp_guess_url() {	if ( defined('WP_SITEURL') && '' != WP_SITEURL ) {		$url = WP_SITEURL;	} else {		$schema = is_ssl() ? 'https://' : 'http://';		$url = preg_replace('|/wp-admin/.*|i', '', $schema . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI']);	}	return $url;}/** * Suspend cache invalidation. * * Turns cache invalidation on and off.  Useful during imports where you don't wont to do invalidations * every time a post is inserted.  Callers must be sure that what they are doing won't lead to an inconsistent * cache when invalidation is suspended. * * @since 2.7.0 * * @param bool $suspend Whether to suspend or enable cache invalidation * @return bool The current suspend setting */function wp_suspend_cache_invalidation($suspend = true) {	global $_wp_suspend_cache_invalidation;	$current_suspend = $_wp_suspend_cache_invalidation;	$_wp_suspend_cache_invalidation = $suspend;	return $current_suspend;}/** * Retrieve site option value based on name of option. * * @see get_option() * @package WordPress * @subpackage Option * @since 2.8.0 * * @uses apply_filters() Calls 'pre_site_option_$option' before checking the option. * 	Any value other than false will "short-circuit" the retrieval of the option *	and return the returned value. * @uses apply_filters() Calls 'site_option_$option', after checking the  option, with * 	the option value. * * @param string $option Name of option to retrieve. Expected to not be SQL-escaped. * @param mixed $default Optional value to return if option doesn't exist. Default false. * @param bool $use_cache Whether to use cache. Multisite only. Default true. * @return mixed Value set for the option. */function get_site_option( $option, $default = false, $use_cache = true ) {	global $wpdb;	// Allow plugins to short-circuit site options. 	$pre = apply_filters( 'pre_site_option_' . $option, false ); 	if ( false !== $pre ) 		return $pre;	if ( !is_multisite() ) {		$value = get_option($option, $default);	} else {		$cache_key = "{$wpdb->siteid}:$option";		if ( $use_cache )			$value = wp_cache_get($cache_key, 'site-options');		if ( !isset($value) || (false === $value) ) {			$row = $wpdb->get_row( $wpdb->prepare("SELECT meta_value FROM $wpdb->sitemeta WHERE meta_key = %s AND site_id = %d", $option, $wpdb->siteid ) );			// Has to be get_row instead of get_var because of funkiness with 0, false, null values			if ( is_object( $row ) )				$value = $row->meta_value;			else				$value = $default;			$value = maybe_unserialize( $value );			wp_cache_set( $cache_key, $value, 'site-options' );		}	} 	return apply_filters( 'site_option_' . $option, $value );}/** * Add a new site option. * * @see add_option() * @package WordPress * @subpackage Option * @since 2.8.0 * * @uses apply_filters() Calls 'pre_add_site_option_$option' hook to allow overwriting the * 	option value to be stored. * @uses do_action() Calls 'add_site_option_$option' and 'add_site_option' hooks on success. * * @param string $option Name of option to add. Expected to not be SQL-escaped. * @param mixed $value Optional. Option value, can be anything. Expected to not be SQL-escaped. * @return bool False if option was not added and true if option was added. */function add_site_option( $option, $value ) {	global $wpdb;	$value = apply_filters( 'pre_add_site_option_' . $option, $value );	if ( !is_multisite() ) {		$result = add_option( $option, $value );	} else {		$cache_key = "{$wpdb->siteid}:$option";		if ( $wpdb->get_row( $wpdb->prepare( "SELECT meta_value FROM $wpdb->sitemeta WHERE meta_key = %s AND site_id = %d", $option, $wpdb->siteid ) ) )			return update_site_option( $option, $value );		$value = sanitize_option( $option, $value );		wp_cache_set( $cache_key, $value, 'site-options' );		$_value = $value;		$value = maybe_serialize($value);		$result = $wpdb->insert( $wpdb->sitemeta, array('site_id' => $wpdb->siteid, 'meta_key' => $option, 'meta_value' => $value ) );		$value = $_value;	}	do_action( "add_site_option_{$option}", $option, $value );	do_action( "add_site_option", $option, $value );	return $result;}/** * Removes site option by name. * * @see delete_option() * @package WordPress * @subpackage Option * @since 2.8.0 * * @uses do_action() Calls 'pre_delete_site_option_$option' hook before option is deleted. * @uses do_action() Calls 'delete_site_option' and 'delete_site_option_$option' * 	hooks on success. * * @param string $option Name of option to remove. Expected to not be SQL-escaped. * @return bool True, if succeed. False, if failure. */function delete_site_option( $option ) {	global $wpdb;	// ms_protect_special_option( $option ); @todo	do_action( 'pre_delete_site_option_' . $option );	if ( !is_multisite() ) {		$result = delete_option( $option );	} else {		$row = $wpdb->get_row( $wpdb->prepare( "SELECT meta_id FROM {$wpdb->sitemeta} WHERE meta_key = %s AND site_id = %d", $option, $wpdb->siteid ) );		if ( is_null( $row ) || !$row->meta_id )			return false;		$cache_key = "{$wpdb->siteid}:$option";		wp_cache_delete( $cache_key, 'site-options' );		$result = $wpdb->query( $wpdb->prepare( "DELETE FROM {$wpdb->sitemeta} WHERE meta_key = %s AND site_id = %d", $option, $wpdb->siteid ) );	}	if ( $result ) {		do_action( "delete_site_option_{$option}", $option );		do_action( "delete_site_option", $option );		return true;	}	return false;}/** * Update the value of a site option that was already added. * * @see update_option() * @since 2.8.0 * @package WordPress * @subpackage Option * * @uses apply_filters() Calls 'pre_update_site_option_$option' hook to allow overwriting the * 	option value to be stored. * @uses do_action() Calls 'update_site_option_$option' and 'update_site_option' hooks on success. * * @param string $option Name of option. Expected to not be SQL-escaped. * @param mixed $value Option value. Expected to not be SQL-escaped. * @return bool False if value was not updated and true if value was updated. */function update_site_option( $option, $value ) {	global $wpdb;	$oldvalue = get_site_option( $option );	$value = apply_filters( 'pre_update_site_option_' . $option, $value, $oldvalue );	if ( $value === $oldvalue )		return false;	if ( !is_multisite() ) {		$result = update_option( $option, $value );	} else {		$cache_key = "{$wpdb->siteid}:$option";		if ( $value && !$wpdb->get_row( $wpdb->prepare( "SELECT meta_value FROM $wpdb->sitemeta WHERE meta_key = %s AND site_id = %d", $option, $wpdb->siteid ) ) )			return add_site_option( $option, $value );		$value = sanitize_option( $option, $value );		wp_cache_set( $cache_key, $value, 'site-options' );		$_value = $value;		$value = maybe_serialize( $value );		$result = $wpdb->update( $wpdb->sitemeta, array( 'meta_value' => $value ), array( 'site_id' => $wpdb->siteid, 'meta_key' => $option ) );		$value = $_value;	}	if ( $result ) {		do_action( "update_site_option_{$option}", $option, $value );		do_action( "update_site_option", $option, $value );		return true;	}	return false;}/** * Delete a site transient * * @since 2.9.0 * @package WordPress * @subpackage Transient * * @uses do_action() Calls 'delete_site_transient_$transient' hook before transient is deleted. * @uses do_action() Calls 'deleted_site_transient' hook on success. * * @param string $transient Transient name. Expected to not be SQL-escaped. * @return bool True if successful, false otherwise */function delete_site_transient( $transient ) {	global $_wp_using_ext_object_cache;	do_action( 'delete_site_transient_' . $transient, $transient );	if ( $_wp_using_ext_object_cache ) {		$result = wp_cache_delete( $transient, 'site-transient' );	} else {		$option_timeout = '_site_transient_timeout_' . $transient;		$option = '_site_transient_' . $transient;		$result = delete_site_option( $option );		if ( $result )			delete_site_option( $option_timeout );	}	if ( $result )		do_action( 'deleted_site_transient', $transient );	return $result;}/** * Get the value of a site transient * * If the transient does not exist or does not have a value, then the return value * will be false. * * @see get_transient() * @since 2.9.0 * @package WordPress * @subpackage Transient * * @uses apply_filters() Calls 'pre_site_transient_$transient' hook before checking the transient. * 	Any value other than false will "short-circuit" the retrieval of the transient *	and return the returned value. * @uses apply_filters() Calls 'site_transient_$option' hook, after checking the transient, with * 	the transient value. * * @param string $transient Transient name. Expected to not be SQL-escaped. * @return mixed Value of transient */function get_site_transient( $transient ) {	global $_wp_using_ext_object_cache;	$pre = apply_filters( 'pre_site_transient_' . $transient, false );	if ( false !== $pre )		return $pre;	if ( $_wp_using_ext_object_cache ) {		$value = wp_cache_get( $transient, 'site-transient' );	} else {		// Core transients that do not have a timeout. Listed here so querying timeouts can be avoided.		$no_timeout = array('update_core', 'update_plugins', 'update_themes');		$transient_option = '_site_transient_' . $transient;		if ( ! in_array( $transient, $no_timeout ) ) {			$transient_timeout = '_site_transient_timeout_' . $transient;			$timeout = get_site_option( $transient_timeout );			if ( false !== $timeout && $timeout < time() ) {				delete_site_option( $transient_option  );				delete_site_option( $transient_timeout );				return false;			}		}		$value = get_site_option( $transient_option );	}	return apply_filters( 'site_transient_' . $transient, $value );}/** * Set/update the value of a site transient * * You do not need to serialize values, if the value needs to be serialize, then * it will be serialized before it is set. * * @see set_transient() * @since 2.9.0 * @package WordPress * @subpackage Transient * * @uses apply_filters() Calls 'pre_set_site_transient_$transient' hook to allow overwriting the * 	transient value to be stored. * @uses do_action() Calls 'set_site_transient_$transient' and 'setted_site_transient' hooks on success. * * @param string $transient Transient name. Expected to not be SQL-escaped. * @param mixed $value Transient value. Expected to not be SQL-escaped. * @param int $expiration Time until expiration in seconds, default 0 * @return bool False if value was not set and true if value was set. */function set_site_transient( $transient, $value, $expiration = 0 ) {	global $_wp_using_ext_object_cache;    $value = apply_filters( 'pre_set_site_transient_' . $transient, $value );	if ( $_wp_using_ext_object_cache ) {		$result = wp_cache_set( $transient, $value, 'site-transient', $expiration );	} else {		$transient_timeout = '_site_transient_timeout_' . $transient;		$transient = '_site_transient_' . $transient;		if ( false === get_site_option( $transient ) ) {			if ( $expiration )				add_site_option( $transient_timeout, time() + $expiration );			$result = add_site_option( $transient, $value );		} else {			if ( $expiration )				update_site_option( $transient_timeout, time() + $expiration );			$result = update_site_option( $transient, $value );		}	}	if ( $result ) {		do_action( 'set_site_transient_' . $transient );		do_action( 'setted_site_transient', $transient );	}	return $result;}/** * is main site * * * @since 3.0.0 * @package WordPress * * @param int $blog_id optional blog id to test (default current blog) * @return bool True if not multisite or $blog_id is main site */function is_main_site( $blog_id = '' ) {	global $current_site, $current_blog;	if ( !is_multisite() )		return true;	if ( !$blog_id )		$blog_id = $current_blog->blog_id;	return $blog_id == $current_site->blog_id;}/** * Whether global terms are enabled. * * * @since 3.0.0 * @package WordPress * * @return bool True if multisite and global terms enabled */function global_terms_enabled() {	if ( ! is_multisite() )		return false;	static $global_terms = null;	if ( is_null( $global_terms ) ) {		$filter = apply_filters( 'global_terms_enabled', null );		if ( ! is_null( $filter ) )			$global_terms = (bool) $filter;		else			$global_terms = (bool) get_site_option( 'global_terms_enabled', false );	}	return $global_terms;}/** * gmt_offset modification for smart timezone handling * * Overrides the gmt_offset option if we have a timezone_string available * * @since 2.8.0 * * @return float|bool */function wp_timezone_override_offset() {	if ( !wp_timezone_supported() ) {		return false;	}	if ( !$timezone_string = get_option( 'timezone_string' ) ) {		return false;	}	$timezone_object = timezone_open( $timezone_string );	$datetime_object = date_create();	if ( false === $timezone_object || false === $datetime_object ) {		return false;	}	return round( timezone_offset_get( $timezone_object, $datetime_object ) / 3600, 2 );}/** * Check for PHP timezone support * * @since 2.9.0 * * @return bool */function wp_timezone_supported() {	$support = false;	if (		function_exists( 'date_create' ) &&		function_exists( 'date_default_timezone_set' ) &&		function_exists( 'timezone_identifiers_list' ) &&		function_exists( 'timezone_open' ) &&		function_exists( 'timezone_offset_get' )	) {		$support = true;	}	return apply_filters( 'timezone_support', $support );}/** * {@internal Missing Short Description}} * * @since 2.9.0 * * @param unknown_type $a * @param unknown_type $b * @return int */function _wp_timezone_choice_usort_callback( $a, $b ) {	// Don't use translated versions of Etc	if ( 'Etc' === $a['continent'] && 'Etc' === $b['continent'] ) {		// Make the order of these more like the old dropdown		if ( 'GMT+' === substr( $a['city'], 0, 4 ) && 'GMT+' === substr( $b['city'], 0, 4 ) ) {			return -1 * ( strnatcasecmp( $a['city'], $b['city'] ) );		}		if ( 'UTC' === $a['city'] ) {			if ( 'GMT+' === substr( $b['city'], 0, 4 ) ) {				return 1;			}			return -1;		}		if ( 'UTC' === $b['city'] ) {			if ( 'GMT+' === substr( $a['city'], 0, 4 ) ) {				return -1;			}			return 1;		}		return strnatcasecmp( $a['city'], $b['city'] );	}	if ( $a['t_continent'] == $b['t_continent'] ) {		if ( $a['t_city'] == $b['t_city'] ) {			return strnatcasecmp( $a['t_subcity'], $b['t_subcity'] );		}		return strnatcasecmp( $a['t_city'], $b['t_city'] );	} else {		// Force Etc to the bottom of the list		if ( 'Etc' === $a['continent'] ) {			return 1;		}		if ( 'Etc' === $b['continent'] ) {			return -1;		}		return strnatcasecmp( $a['t_continent'], $b['t_continent'] );	}}/** * Gives a nicely formatted list of timezone strings // temporary! Not in final * * @since 2.9.0 * * @param string $selected_zone Selected Zone * @return string */function wp_timezone_choice( $selected_zone ) {	static $mo_loaded = false;	$continents = array( 'Africa', 'America', 'Antarctica', 'Arctic', 'Asia', 'Atlantic', 'Australia', 'Europe', 'Indian', 'Pacific');	// Load translations for continents and cities	if ( !$mo_loaded ) {		$locale = get_locale();		$mofile = WP_LANG_DIR . '/continents-cities-' . $locale . '.mo';		load_textdomain( 'continents-cities', $mofile );		$mo_loaded = true;	}	$zonen = array();	foreach ( timezone_identifiers_list() as $zone ) {		$zone = explode( '/', $zone );		if ( !in_array( $zone[0], $continents ) ) {			continue;		}		// This determines what gets set and translated - we don't translate Etc/* strings here, they are done later		$exists = array(			0 => ( isset( $zone[0] ) && $zone[0] ),			1 => ( isset( $zone[1] ) && $zone[1] ),			2 => ( isset( $zone[2] ) && $zone[2] ),		);		$exists[3] = ( $exists[0] && 'Etc' !== $zone[0] );		$exists[4] = ( $exists[1] && $exists[3] );		$exists[5] = ( $exists[2] && $exists[3] );		$zonen[] = array(			'continent'   => ( $exists[0] ? $zone[0] : '' ),			'city'        => ( $exists[1] ? $zone[1] : '' ),			'subcity'     => ( $exists[2] ? $zone[2] : '' ),			't_continent' => ( $exists[3] ? translate( str_replace( '_', ' ', $zone[0] ), 'continents-cities' ) : '' ),			't_city'      => ( $exists[4] ? translate( str_replace( '_', ' ', $zone[1] ), 'continents-cities' ) : '' ),			't_subcity'   => ( $exists[5] ? translate( str_replace( '_', ' ', $zone[2] ), 'continents-cities' ) : '' )		);	}	usort( $zonen, '_wp_timezone_choice_usort_callback' );	$structure = array();	if ( empty( $selected_zone ) ) {		$structure[] = '<option selected="selected" value="">' . __( 'Select a city' ) . '</option>';	}	foreach ( $zonen as $key => $zone ) {		// Build value in an array to join later		$value = array( $zone['continent'] );		if ( empty( $zone['city'] ) ) {			// It's at the continent level (generally won't happen)			$display = $zone['t_continent'];		} else {			// It's inside a continent group			// Continent optgroup			if ( !isset( $zonen[$key - 1] ) || $zonen[$key - 1]['continent'] !== $zone['continent'] ) {				$label = $zone['t_continent'];				$structure[] = '<optgroup label="'. esc_attr( $label ) .'">';			}			// Add the city to the value			$value[] = $zone['city'];			$display = $zone['t_city'];			if ( !empty( $zone['subcity'] ) ) {				// Add the subcity to the value				$value[] = $zone['subcity'];				$display .= ' - ' . $zone['t_subcity'];			}		}		// Build the value		$value = join( '/', $value );		$selected = '';		if ( $value === $selected_zone ) {			$selected = 'selected="selected" ';		}		$structure[] = '<option ' . $selected . 'value="' . esc_attr( $value ) . '">' . esc_html( $display ) . "</option>";		// Close continent optgroup		if ( !empty( $zone['city'] ) && ( !isset($zonen[$key + 1]) || (isset( $zonen[$key + 1] ) && $zonen[$key + 1]['continent'] !== $zone['continent']) ) ) {			$structure[] = '</optgroup>';		}	}	// Do UTC	$structure[] = '<optgroup label="'. esc_attr__( 'UTC' ) .'">';	$selected = '';	if ( 'UTC' === $selected_zone )		$selected = 'selected="selected" ';	$structure[] = '<option ' . $selected . 'value="' . esc_attr( 'UTC' ) . '">' . __('UTC') . '</option>';	$structure[] = '</optgroup>';	// Do manual UTC offsets	$structure[] = '<optgroup label="'. esc_attr__( 'Manual Offsets' ) .'">';	$offset_range = array (-12, -11.5, -11, -10.5, -10, -9.5, -9, -8.5, -8, -7.5, -7, -6.5, -6, -5.5, -5, -4.5, -4, -3.5, -3, -2.5, -2, -1.5, -1, -0.5,		0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 5.75, 6, 6.5, 7, 7.5, 8, 8.5, 8.75, 9, 9.5, 10, 10.5, 11, 11.5, 12, 12.75, 13, 13.75, 14);	foreach ( $offset_range as $offset ) {		if ( 0 <= $offset )			$offset_name = '+' . $offset;		else			$offset_name = (string) $offset;		$offset_value = $offset_name;		$offset_name = str_replace(array('.25','.5','.75'), array(':15',':30',':45'), $offset_name);		$offset_name = 'UTC' . $offset_name;		$offset_value = 'UTC' . $offset_value;		$selected = '';		if ( $offset_value === $selected_zone )			$selected = 'selected="selected" ';		$structure[] = '<option ' . $selected . 'value="' . esc_attr( $offset_value ) . '">' . esc_html( $offset_name ) . "</option>";	}	$structure[] = '</optgroup>';	return join( "\n", $structure );}/** * Strip close comment and close php tags from file headers used by WP * See http://core.trac.wordpress.org/ticket/8497 * * @since 2.8.0 * * @param string $str * @return string */function _cleanup_header_comment($str) {	return trim(preg_replace("/\s*(?:\*\/|\?>).*/", '', $str));}/** * Permanently deletes posts, pages, attachments, and comments which have been in the trash for EMPTY_TRASH_DAYS. * * @since 2.9.0 */function wp_scheduled_delete() {	global $wpdb;	$delete_timestamp = time() - (60*60*24*EMPTY_TRASH_DAYS);	$posts_to_delete = $wpdb->get_results($wpdb->prepare("SELECT post_id FROM $wpdb->postmeta WHERE meta_key = '_wp_trash_meta_time' AND meta_value < '%d'", $delete_timestamp), ARRAY_A);	foreach ( (array) $posts_to_delete as $post ) {		$post_id = (int) $post['post_id'];		if ( !$post_id )			continue;		$del_post = get_post($post_id);		if ( !$del_post || 'trash' != $del_post->post_status ) {			delete_post_meta($post_id, '_wp_trash_meta_status');			delete_post_meta($post_id, '_wp_trash_meta_time');		} else {			wp_delete_post($post_id);		}	}	$comments_to_delete = $wpdb->get_results($wpdb->prepare("SELECT comment_id FROM $wpdb->commentmeta WHERE meta_key = '_wp_trash_meta_time' AND meta_value < '%d'", $delete_timestamp), ARRAY_A);	foreach ( (array) $comments_to_delete as $comment ) {		$comment_id = (int) $comment['comment_id'];		if ( !$comment_id )			continue;		$del_comment = get_comment($comment_id);		if ( !$del_comment || 'trash' != $del_comment->comment_approved ) {			delete_comment_meta($comment_id, '_wp_trash_meta_time');			delete_comment_meta($comment_id, '_wp_trash_meta_status');		} else {			wp_delete_comment($comment_id);		}	}}/** * Parse the file contents to retrieve its metadata. * * Searches for metadata for a file, such as a plugin or theme.  Each piece of * metadata must be on its own line. For a field spanning multple lines, it * must not have any newlines or only parts of it will be displayed. * * Some users have issues with opening large files and manipulating the contents * for want is usually the first 1kiB or 2kiB. This function stops pulling in * the file contents when it has all of the required data. * * The first 8kiB of the file will be pulled in and if the file data is not * within that first 8kiB, then the author should correct their plugin file * and move the data headers to the top. * * The file is assumed to have permissions to allow for scripts to read * the file. This is not checked however and the file is only opened for * reading. * * @since 2.9.0 * * @param string $file Path to the file * @param bool $markup If the returned data should have HTML markup applied * @param string $context If specified adds filter hook "extra_<$context>_headers" */function get_file_data( $file, $default_headers, $context = '' ) {	// We don't need to write to the file, so just open for reading.	$fp = fopen( $file, 'r' );	// Pull only the first 8kiB of the file in.	$file_data = fread( $fp, 8192 );	// PHP will close file handle, but we are good citizens.	fclose( $fp );	if ( $context != '' ) {		$extra_headers = apply_filters( "extra_$context".'_headers', array() );		$extra_headers = array_flip( $extra_headers );		foreach( $extra_headers as $key=>$value ) {			$extra_headers[$key] = $key;		}		$all_headers = array_merge($extra_headers, $default_headers);	} else {		$all_headers = $default_headers;	}	foreach ( $all_headers as $field => $regex ) {		preg_match( '/' . preg_quote( $regex, '/' ) . ':(.*)$/mi', $file_data, ${$field});		if ( !empty( ${$field} ) )			${$field} = _cleanup_header_comment( ${$field}[1] );		else			${$field} = '';	}	$file_data = compact( array_keys( $all_headers ) );	return $file_data;}/* * Used internally to tidy up the search terms * * @access private * @since 2.9.0 * * @param string $t * @return string */function _search_terms_tidy($t) {	return trim($t, "\"'\n\r ");}/** * Returns true * * Useful for returning true to filters easily * * @since 3.0.0 * @see __return_false() * @return bool true */function __return_true() {	return true;}/** * Returns false * * Useful for returning false to filters easily * * @since 3.0.0 * @see __return_true() * @return bool false */function __return_false() {	return false;}/** * Returns 0 * * Useful for returning 0 to filters easily * * @since 3.0.0 * @see __return_zero() * @return int 0 */function __return_zero() {	return 0;}/** * Returns an empty array * * Useful for returning an empty array to filters easily * * @since 3.0.0 * @see __return_zero() * @return array Empty array */function __return_empty_array() {	return array();}/** * Send a HTTP header to disable content type sniffing in browsers which support it. * * @link http://blogs.msdn.com/ie/archive/2008/07/02/ie8-security-part-v-comprehensive-protection.aspx * @link http://src.chromium.org/viewvc/chrome?view=rev&revision=6985 * * @since 3.0.0 * @return none */function send_nosniff_header() {	@header( 'X-Content-Type-Options: nosniff' );}/** * Returns a MySQL expression for selecting the week number based on the start_of_week option. * * @internal * @since 3.0.0 * @param string $column * @return string */function _wp_mysql_week( $column ) {	switch ( $start_of_week = (int) get_option( 'start_of_week' ) ) {	default :	case 0 :		return "WEEK( $column, 0 )";	case 1 :		return "WEEK( $column, 1 )";	case 2 :	case 3 :	case 4 :	case 5 :	case 6 :		return "WEEK( DATE_SUB( $column, INTERVAL $start_of_week DAY ), 0 )";	}}?>
<?php/** * Media Library administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');wp_enqueue_script( 'wp-ajax-response' );wp_enqueue_script( 'jquery-ui-draggable' );if ( !current_user_can('upload_files') )	wp_die(__('You do not have permission to upload files.'));if ( isset($_GET['find_detached']) ) {	check_admin_referer('bulk-media');	if ( !current_user_can('edit_posts') )		wp_die( __('You are not allowed to scan for lost attachments.') );	$lost = $wpdb->get_col("SELECT ID FROM $wpdb->posts WHERE post_type = 'attachment' AND post_parent > '0' and post_parent NOT IN ( SELECT ID FROM $wpdb->posts WHERE post_type NOT IN ('attachment', '" . join("', '", get_post_types( array( 'public' => false ) ) ) . "') )");	$_GET['detached'] = 1;} elseif ( isset($_GET['found_post_id']) && isset($_GET['media']) ) {	check_admin_referer('bulk-media');	if ( ! ( $parent_id = (int) $_GET['found_post_id'] ) )		return;	$parent = &get_post($parent_id);	if ( !current_user_can('edit_post', $parent_id) )		wp_die( __('You are not allowed to edit this post.') );	$attach = array();	foreach( (array) $_GET['media'] as $att_id ) {		$att_id = (int) $att_id;		if ( !current_user_can('edit_post', $att_id) )			continue;		$attach[] = $att_id;		clean_attachment_cache($att_id);	}	if ( ! empty($attach) ) {		$attach = implode(',', $attach);		$attached = $wpdb->query( $wpdb->prepare("UPDATE $wpdb->posts SET post_parent = %d WHERE post_type = 'attachment' AND ID IN ($attach)", $parent_id) );	}	if ( isset($attached) ) {		$location = 'upload.php';		if ( $referer = wp_get_referer() ) {			if ( false !== strpos($referer, 'upload.php') )				$location = $referer;		}		$location = add_query_arg( array( 'attached' => $attached ) , $location );		wp_redirect($location);		exit;	}} elseif ( isset($_GET['doaction']) || isset($_GET['doaction2']) || isset($_GET['delete_all']) || isset($_GET['delete_all2']) ) {	check_admin_referer('bulk-media');	if ( isset($_GET['delete_all']) || isset($_GET['delete_all2']) ) {		$post_ids = $wpdb->get_col( "SELECT ID FROM $wpdb->posts WHERE post_type='attachment' AND post_status = 'trash'" );		$doaction = 'delete';	} elseif ( ( $_GET['action'] != -1 || $_GET['action2'] != -1 ) && ( isset($_GET['media']) || isset($_GET['ids']) ) ) {		$post_ids = isset($_GET['media']) ? $_GET['media'] : explode(',', $_GET['ids']);		$doaction = ($_GET['action'] != -1) ? $_GET['action'] : $_GET['action2'];	} else {		wp_redirect($_SERVER['HTTP_REFERER']);	}	$location = 'upload.php';	if ( $referer = wp_get_referer() ) {		if ( false !== strpos($referer, 'upload.php') )			$location = remove_query_arg( array('trashed', 'untrashed', 'deleted', 'message', 'ids', 'posted'), $referer );	}	switch ( $doaction ) {		case 'trash':			foreach( (array) $post_ids as $post_id ) {				if ( !current_user_can('delete_post', $post_id) )					wp_die( __('You are not allowed to move this post to the trash.') );				if ( !wp_trash_post($post_id) )					wp_die( __('Error in moving to trash...') );			}			$location = add_query_arg( array( 'trashed' => count($post_ids), 'ids' => join(',', $post_ids) ), $location );			break;		case 'untrash':			foreach( (array) $post_ids as $post_id ) {				if ( !current_user_can('delete_post', $post_id) )					wp_die( __('You are not allowed to move this post out of the trash.') );				if ( !wp_untrash_post($post_id) )					wp_die( __('Error in restoring from trash...') );			}			$location = add_query_arg('untrashed', count($post_ids), $location);			break;		case 'delete':			foreach( (array) $post_ids as $post_id_del ) {				if ( !current_user_can('delete_post', $post_id_del) )					wp_die( __('You are not allowed to delete this post.') );				if ( !wp_delete_attachment($post_id_del) )					wp_die( __('Error in deleting...') );			}			$location = add_query_arg('deleted', count($post_ids), $location);			break;	}	wp_redirect($location);	exit;} elseif ( ! empty($_GET['_wp_http_referer']) ) {	 wp_redirect( remove_query_arg( array('_wp_http_referer', '_wpnonce'), stripslashes($_SERVER['REQUEST_URI']) ) );	 exit;}$title = __('Media Library');$parent_file = 'upload.php';if ( ! isset( $_GET['paged'] ) || $_GET['paged'] < 1 )	$_GET['paged'] = 1;if ( isset($_GET['detached']) ) {	$media_per_page = (int) get_user_option( 'upload_per_page' );	if ( empty($media_per_page) || $media_per_page < 1 )		$media_per_page = 20;	$media_per_page = apply_filters( 'upload_per_page', $media_per_page );	if ( !empty($lost) ) {		$start = ( (int) $_GET['paged'] - 1 ) * $media_per_page;		$page_links_total = ceil(count($lost) / $media_per_page);		$lost = implode(',', $lost);		$orphans = $wpdb->get_results( $wpdb->prepare( "SELECT * FROM $wpdb->posts WHERE post_type = 'attachment' AND ID IN (%s) LIMIT %d, %d", $lost, $start, $media_per_page ) );	} else {		$start = ( (int) $_GET['paged'] - 1 ) * $media_per_page;		$orphans = $wpdb->get_results( $wpdb->prepare( "SELECT SQL_CALC_FOUND_ROWS * FROM $wpdb->posts WHERE post_type = 'attachment' AND post_status != 'trash' AND post_parent < 1 LIMIT %d, %d", $start, $media_per_page ) );		$total_orphans = $wpdb->get_var( "SELECT FOUND_ROWS()" );		$page_links_total = ceil( $total_orphans / $media_per_page );		$wp_query->found_posts = $total_orphans;		$wp_query->query_vars['posts_per_page'] = $media_per_page;	}	$post_mime_types = get_post_mime_types();	$avail_post_mime_types = get_available_post_mime_types('attachment');	if ( isset($_GET['post_mime_type']) && !array_intersect( (array) $_GET['post_mime_type'], array_keys($post_mime_types) ) )		unset($_GET['post_mime_type']);} else {	list($post_mime_types, $avail_post_mime_types) = wp_edit_attachments_query();}$is_trash = ( isset($_GET['status']) && $_GET['status'] == 'trash' );wp_enqueue_script('media');add_contextual_help( $current_screen,	'<p>' . __('All the files you&#8217;ve uploaded are listed in the Media Library, with the most recent uploads listed first. You can use the <em>Screen Options</em> tab to customize the display of this screen.') . '</p>' .	'<p>' . __('You can narrow the list by file type/status using the text link filters at the top of the screen. You also can refine the list by date using the dropdown menu above the media table.') . '</p>' .	'<p>' . __('Hovering over a row reveals action links: <em>Edit</em>, <em>Delete Permanently</em>, and <em>View</em>. Clicking <em>Edit</em> or on the media file&#8217;s name displays a simple screen to edit that individual file&#8217;s metadata. Clicking <em>Delete Permanently</em> will delete the file from the media library (as well as from any posts to which it is currently attached). <em>View</em> will take you to the display page for that file.') . '</p>' .	'<p>' . __('If a media file has not been attached to any post, you will see that in the <em>Attached To</em> column, and can click on <em>Attach File</em> to launch a small popup that will allow you to search for a post and attach the file.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Media_Library_SubPanel" target="_blank">Media Library Documentation</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');require_once('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?> <a href="media-new.php" class="button add-new-h2"><?php echo esc_html_x('Add New', 'file'); ?></a> <?phpif ( isset($_GET['s']) && $_GET['s'] )	printf( '<span class="subtitle">' . __('Search results for &#8220;%s&#8221;') . '</span>', get_search_query() ); ?></h2><?php$message = '';if ( isset($_GET['posted']) && (int) $_GET['posted'] ) {	$message = __('Media attachment updated.');	$_SERVER['REQUEST_URI'] = remove_query_arg(array('posted'), $_SERVER['REQUEST_URI']);}if ( isset($_GET['attached']) && (int) $_GET['attached'] ) {	$attached = (int) $_GET['attached'];	$message = sprintf( _n('Reattached %d attachment.', 'Reattached %d attachments.', $attached), $attached );	$_SERVER['REQUEST_URI'] = remove_query_arg(array('attached'), $_SERVER['REQUEST_URI']);}if ( isset($_GET['deleted']) && (int) $_GET['deleted'] ) {	$message = sprintf( _n( 'Media attachment permanently deleted.', '%d media attachments permanently deleted.', $_GET['deleted'] ), number_format_i18n( $_GET['deleted'] ) );	$_SERVER['REQUEST_URI'] = remove_query_arg(array('deleted'), $_SERVER['REQUEST_URI']);}if ( isset($_GET['trashed']) && (int) $_GET['trashed'] ) {	$message = sprintf( _n( 'Media attachment moved to the trash.', '%d media attachments moved to the trash.', $_GET['trashed'] ), number_format_i18n( $_GET['trashed'] ) );	$message .= ' <a href="' . esc_url( wp_nonce_url( 'upload.php?doaction=undo&action=untrash&ids='.(isset($_GET['ids']) ? $_GET['ids'] : ''), "bulk-media" ) ) . '">' . __('Undo') . '</a>';	$_SERVER['REQUEST_URI'] = remove_query_arg(array('trashed'), $_SERVER['REQUEST_URI']);}if ( isset($_GET['untrashed']) && (int) $_GET['untrashed'] ) {	$message = sprintf( _n( 'Media attachment restored from the trash.', '%d media attachments restored from the trash.', $_GET['untrashed'] ), number_format_i18n( $_GET['untrashed'] ) );	$_SERVER['REQUEST_URI'] = remove_query_arg(array('untrashed'), $_SERVER['REQUEST_URI']);}$messages[1] = __('Media attachment updated.');$messages[2] = __('Media permanently deleted.');$messages[3] = __('Error saving media attachment.');$messages[4] = __('Media moved to the trash.') . ' <a href="' . esc_url( wp_nonce_url( 'upload.php?doaction=undo&action=untrash&ids='.(isset($_GET['ids']) ? $_GET['ids'] : ''), "bulk-media" ) ) . '">' . __('Undo') . '</a>';$messages[5] = __('Media restored from the trash.');if ( isset($_GET['message']) && (int) $_GET['message'] ) {	$message = $messages[$_GET['message']];	$_SERVER['REQUEST_URI'] = remove_query_arg(array('message'), $_SERVER['REQUEST_URI']);}if ( !empty($message) ) { ?><div id="message" class="updated"><p><?php echo $message; ?></p></div><?php } ?><ul class="subsubsub"><?php$type_links = array();$_num_posts = (array) wp_count_attachments();$_total_posts = array_sum($_num_posts) - $_num_posts['trash'];if ( !isset( $total_orphans ) )		$total_orphans = $wpdb->get_var( "SELECT COUNT( * ) FROM $wpdb->posts WHERE post_type = 'attachment' AND post_status != 'trash' AND post_parent < 1" );$matches = wp_match_mime_types(array_keys($post_mime_types), array_keys($_num_posts));foreach ( $matches as $type => $reals )	foreach ( $reals as $real )		$num_posts[$type] = ( isset( $num_posts[$type] ) ) ? $num_posts[$type] + $_num_posts[$real] : $_num_posts[$real];$class = ( empty($_GET['post_mime_type']) && !isset($_GET['detached']) && !isset($_GET['status']) ) ? ' class="current"' : '';$type_links[] = "<li><a href='upload.php'$class>" . sprintf( _nx( 'All <span class="count">(%s)</span>', 'All <span class="count">(%s)</span>', $_total_posts, 'uploaded files' ), number_format_i18n( $_total_posts ) ) . '</a>';foreach ( $post_mime_types as $mime_type => $label ) {	$class = '';	if ( !wp_match_mime_types($mime_type, $avail_post_mime_types) )		continue;	if ( !empty($_GET['post_mime_type']) && wp_match_mime_types($mime_type, $_GET['post_mime_type']) )		$class = ' class="current"';	if ( !empty( $num_posts[$mime_type] ) )		$type_links[] = "<li><a href='upload.php?post_mime_type=$mime_type'$class>" . sprintf( _n( $label[2][0], $label[2][1], $num_posts[$mime_type] ), number_format_i18n( $num_posts[$mime_type] )) . '</a>';}$type_links[] = '<li><a href="upload.php?detached=1"' . ( isset($_GET['detached']) ? ' class="current"' : '' ) . '>' . sprintf( _nx( 'Unattached <span class="count">(%s)</span>', 'Unattached <span class="count">(%s)</span>', $total_orphans, 'detached files' ), number_format_i18n( $total_orphans ) ) . '</a>';if ( !empty($_num_posts['trash']) )	$type_links[] = '<li><a href="upload.php?status=trash"' . ( (isset($_GET['status']) && $_GET['status'] == 'trash' ) ? ' class="current"' : '') . '>' . sprintf( _nx( 'Trash <span class="count">(%s)</span>', 'Trash <span class="count">(%s)</span>', $_num_posts['trash'], 'uploaded files' ), number_format_i18n( $_num_posts['trash'] ) ) . '</a>';echo implode( " |</li>\n", $type_links) . '</li>';unset($type_links);?></ul><form class="search-form" action="" method="get"><p class="search-box">	<label class="screen-reader-text" for="media-search-input"><?php _e( 'Search Media' ); ?>:</label>	<input type="text" id="media-search-input" name="s" value="<?php the_search_query(); ?>" />	<input type="submit" value="<?php esc_attr_e( 'Search Media' ); ?>" class="button" /></p></form><form id="posts-filter" action="" method="get"><?php wp_nonce_field('bulk-media'); ?><?php if ( have_posts() || isset( $orphans ) ) { ?><div class="tablenav"><?phpif ( ! isset($page_links_total) )	$page_links_total =  $wp_query->max_num_pages;$page_links = paginate_links( array(	'base' => add_query_arg( 'paged', '%#%' ),	'format' => '',	'prev_text' => __('&laquo;'),	'next_text' => __('&raquo;'),	'total' => $page_links_total,	'current' => $_GET['paged']));if ( $page_links ) : ?><div class="tablenav-pages"><?php $page_links_text = sprintf( '<span class="displaying-num">' . __( 'Displaying %s&#8211;%s of %s' ) . '</span>%s',	number_format_i18n( ( $_GET['paged'] - 1 ) * $wp_query->query_vars['posts_per_page'] + 1 ),	number_format_i18n( min( $_GET['paged'] * $wp_query->query_vars['posts_per_page'], $wp_query->found_posts ) ),	number_format_i18n( $wp_query->found_posts ),	$page_links); echo $page_links_text; ?></div><?php endif; ?><div class="alignleft actions"><?php if ( ! isset( $orphans ) || ! empty( $orphans ) ) { ?><select name="action" class="select-action"><option value="-1" selected="selected"><?php _e('Bulk Actions'); ?></option><?php if ( $is_trash ) { ?><option value="untrash"><?php _e('Restore'); ?></option><?php } if ( $is_trash || !EMPTY_TRASH_DAYS || !MEDIA_TRASH ) { ?><option value="delete"><?php _e('Delete Permanently'); ?></option><?php } else { ?><option value="trash"><?php _e('Move to Trash'); ?></option><?php } if ( isset($orphans) ) { ?><option value="attach"><?php _e('Attach to a post'); ?></option><?php } ?></select><input type="submit" value="<?php esc_attr_e('Apply'); ?>" name="doaction" id="doaction" class="button-secondary action" /><?phpif ( !is_singular() && !isset($_GET['detached']) && !$is_trash ) {	$arc_query = "SELECT DISTINCT YEAR(post_date) AS yyear, MONTH(post_date) AS mmonth FROM $wpdb->posts WHERE post_type = 'attachment' ORDER BY post_date DESC";	$arc_result = $wpdb->get_results( $arc_query );	$month_count = count($arc_result);	if ( $month_count && !( 1 == $month_count && 0 == $arc_result[0]->mmonth ) ) : ?><select name='m'><option value='0'><?php _e('Show all dates'); ?></option><?phpforeach ($arc_result as $arc_row) {	if ( $arc_row->yyear == 0 )		continue;	$arc_row->mmonth = zeroise( $arc_row->mmonth, 2 );	if ( isset($_GET['m']) && ( $arc_row->yyear . $arc_row->mmonth == $_GET['m'] ) )		$default = ' selected="selected"';	else		$default = '';	echo "<option$default value='" . esc_attr("$arc_row->yyear$arc_row->mmonth") . "'>";	echo $wp_locale->get_month($arc_row->mmonth) . " $arc_row->yyear";	echo "</option>\n";}?></select><?php endif; // month_count ?><?php do_action('restrict_manage_posts'); ?><input type="submit" id="post-query-submit" value="<?php esc_attr_e('Filter'); ?>" class="button-secondary" /><?php } // ! is_singular ?><?php} // ! empty( $orphans )if ( isset($_GET['detached']) ) { ?>	<input type="submit" id="find_detached" name="find_detached" value="<?php esc_attr_e('Scan for lost attachments'); ?>" class="button-secondary" /><?php } elseif ( isset($_GET['status']) && $_GET['status'] == 'trash' && current_user_can('edit_others_posts') ) { ?>	<input type="submit" id="delete_all" name="delete_all" value="<?php esc_attr_e('Empty Trash'); ?>" class="button-secondary apply" /><?php } ?></div><br class="clear" /></div><?php } // have_posts() || !empty( $orphans ) ?><div class="clear"></div><?php if ( ! empty( $orphans ) ) { ?><table class="widefat" cellspacing="0"><thead><tr>	<th scope="col" class="check-column"><input type="checkbox" /></th>	<th scope="col"></th>	<th scope="col"><?php /* translators: column name in media */ _ex('Media', 'media column name'); ?></th>	<th scope="col"><?php /* translators: column name in media */ _ex('Author', 'media column name'); ?></th>	<th scope="col"><?php /* translators: column name in media */ _ex('Date Added', 'media column name'); ?></th></tr></thead><tfoot><tr>	<th scope="col" class="check-column"><input type="checkbox" /></th>	<th scope="col"></th>	<th scope="col"><?php /* translators: column name in media */ _ex('Media', 'media column name'); ?></th>	<th scope="col"><?php /* translators: column name in media */ _ex('Author', 'media column name'); ?></th>	<th scope="col"><?php /* translators: column name in media */ _ex('Date Added', 'media column name'); ?></th></tr></tfoot><tbody id="the-list" class="list:post"><?php		foreach ( $orphans as $post ) {			$class = 'alternate' == $class ? '' : 'alternate';			$att_title = esc_html( _draft_or_post_title($post->ID) );?>	<tr id='post-<?php echo $post->ID; ?>' class='<?php echo $class; ?>' valign="top">		<th scope="row" class="check-column"><?php if ( current_user_can('edit_post', $post->ID) ) { ?><input type="checkbox" name="media[]" value="<?php echo esc_attr($post->ID); ?>" /><?php } ?></th>		<td class="media-icon"><?php		if ( $thumb = wp_get_attachment_image( $post->ID, array(80, 60), true ) ) { ?>			<a href="media.php?action=edit&amp;attachment_id=<?php echo $post->ID; ?>" title="<?php echo esc_attr(sprintf(__('Edit &#8220;%s&#8221;'), $att_title)); ?>"><?php echo $thumb; ?></a><?php	} ?></td>		<td class="media column-media"><strong><a href="<?php echo get_edit_post_link( $post->ID ); ?>" title="<?php echo esc_attr(sprintf(__('Edit &#8220;%s&#8221;'), $att_title)); ?>"><?php echo $att_title; ?></a></strong><br />		<?php		if ( preg_match( '/^.*?\.(\w+)$/', get_attached_file( $post->ID ), $matches ) )			echo esc_html( strtoupper( $matches[1] ) );		else			echo strtoupper( str_replace( 'image/', '', get_post_mime_type() ) );		?>		<div class="row-actions">		<?php		$actions = array();		if ( current_user_can('edit_post', $post->ID) )			$actions['edit'] = '<a href="' . get_edit_post_link($post->ID, true) . '">' . __('Edit') . '</a>';		if ( current_user_can('delete_post', $post->ID) )			if ( EMPTY_TRASH_DAYS && MEDIA_TRASH ) {				$actions['trash'] = "<a class='submitdelete' href='" . wp_nonce_url("post.php?action=trash&amp;post=$post->ID", 'trash-attachment_' . $post->ID) . "'>" . __('Trash') . "</a>";			} else {				$delete_ays = !MEDIA_TRASH ? " onclick='return showNotice.warn();'" : '';				$actions['delete'] = "<a class='submitdelete'$delete_ays href='" . wp_nonce_url("post.php?action=delete&amp;post=$post->ID", 'delete-attachment_' . $post->ID) . "'>" . __('Delete Permanently') . "</a>";			}		$actions['view'] = '<a href="' . get_permalink($post->ID) . '" title="' . esc_attr(sprintf(__('View &#8220;%s&#8221;'), $title)) . '" rel="permalink">' . __('View') . '</a>';		if ( current_user_can('edit_post', $post->ID) )			$actions['attach'] = '<a href="#the-list" onclick="findPosts.open(\'media[]\',\''.$post->ID.'\');return false;" class="hide-if-no-js">'.__('Attach').'</a>';		$actions = apply_filters( 'media_row_actions', $actions, $post );		$action_count = count($actions);		$i = 0;		foreach ( $actions as $action => $link ) {			++$i;			( $i == $action_count ) ? $sep = '' : $sep = ' | ';			echo "<span class='$action'>$link$sep</span>";		} ?>		</div></td>		<td class="author column-author"><?php $author = get_userdata($post->post_author); echo $author->display_name; ?></td><?php	if ( '0000-00-00 00:00:00' == $post->post_date && 'date' == $column_name ) {			$t_time = $h_time = __('Unpublished');		} else {			$t_time = get_the_time(__('Y/m/d g:i:s A'));			$m_time = $post->post_date;			$time = get_post_time( 'G', true );			if ( ( abs($t_diff = time() - $time) ) < 86400 ) {				if ( $t_diff < 0 )					$h_time = sprintf( __('%s from now'), human_time_diff( $time ) );				else					$h_time = sprintf( __('%s ago'), human_time_diff( $time ) );			} else {				$h_time = mysql2date(__('Y/m/d'), $m_time);			}		} ?>		<td class="date column-date"><?php echo $h_time ?></td>	</tr><?php	} ?></tbody></table><?php} else {	include( './edit-attachment-rows.php' );} ?><div id="ajax-response"></div><div class="tablenav"><?phpif ( have_posts() || ! empty( $orphans ) ) {if ( $page_links )	echo "<div class='tablenav-pages'>$page_links_text</div>";?><div class="alignleft actions"><select name="action2" class="select-action"><option value="-1" selected="selected"><?php _e('Bulk Actions'); ?></option><?php if ($is_trash) { ?><option value="untrash"><?php _e('Restore'); ?></option><?php } if ( $is_trash || !EMPTY_TRASH_DAYS || !MEDIA_TRASH ) { ?><option value="delete"><?php _e('Delete Permanently'); ?></option><?php } else { ?><option value="trash"><?php _e('Move to Trash'); ?></option><?php } if (isset($orphans)) { ?><option value="attach"><?php _e('Attach to a post'); ?></option><?php } ?></select><input type="submit" value="<?php esc_attr_e('Apply'); ?>" name="doaction2" id="doaction2" class="button-secondary action" /><?php if ( isset($_GET['status']) && $_GET['status'] == 'trash' && current_user_can('edit_others_posts') ) { ?>	<input type="submit" id="delete_all2" name="delete_all2" value="<?php esc_attr_e('Empty Trash'); ?>" class="button-secondary apply" /><?php } ?></div><?php } ?><br class="clear" /></div><?php find_posts_div(); ?></form><br class="clear" /></div><?phpinclude('./admin-footer.php');
<?php/** * Multisite administration functions. * * @package WordPress * @subpackage Multisite * @since 3.0.0 *//** * Determine if uploaded file exceeds space quota. * * @since 3.0.0 * * @param array $file $_FILES array for a given file. * @return array $_FILES array with 'error' key set if file exceeds quota. 'error' is empty otherwise. */function check_upload_size( $file ) {	if ( get_site_option( 'upload_space_check_disabled' ) )		return $file;	if ( $file['error'] != '0' ) // there's already an error		return $file;	if ( defined( 'WP_IMPORTING' ) )		return $file;	$space_allowed = 1048576 * get_space_allowed();	$space_used = get_dirsize( BLOGUPLOADDIR );	$space_left = $space_allowed - $space_used;	$file_size = filesize( $file['tmp_name'] );	if ( $space_left < $file_size )		$file['error'] = sprintf( __( 'Not enough space to upload. %1$s KB needed.' ), number_format( ($file_size - $space_left) /1024 ) );	if ( $file_size > ( 1024 * get_site_option( 'fileupload_maxk', 1500 ) ) )		$file['error'] = sprintf(__('This file is too big. Files must be less than %1$s KB in size.'), get_site_option( 'fileupload_maxk', 1500 ) );	if ( upload_is_user_over_quota( false ) ) {		$file['error'] = __( 'You have used your space quota. Please delete files before uploading.' );	}	if ( $file['error'] != '0' && !isset($_POST['html-upload']) )		wp_die( $file['error'] . ' <a href="javascript:history.go(-1)">' . __( 'Back' ) . '</a>' );	return $file;}add_filter( 'wp_handle_upload_prefilter', 'check_upload_size' );/** * Delete a blog * * @since 3.0.0 * * @param int $blog_id Blog ID * @param bool $drop True if blog's table should be dropped.  Default is false. * @return void */function wpmu_delete_blog( $blog_id, $drop = false ) {	global $wpdb;	$switch = false;	if ( $blog_id != $wpdb->blogid ) {		$switch = true;		switch_to_blog( $blog_id );	}	$blog_prefix = $wpdb->get_blog_prefix( $blog_id );	do_action( 'delete_blog', $blog_id, $drop );	$users = get_users_of_blog( $blog_id );	// Remove users from this blog.	if ( ! empty( $users ) ) {		foreach ( $users as $user ) {			remove_user_from_blog( $user->user_id, $blog_id) ;		}	}	update_blog_status( $blog_id, 'deleted', 1 );	if ( $drop ) {		if ( substr( $blog_prefix, -1 ) == '_' )			$blog_prefix =  substr( $blog_prefix, 0, -1 ) . '\_';		$drop_tables = $wpdb->get_results( "SHOW TABLES LIKE '{$blog_prefix}%'", ARRAY_A );		$drop_tables = apply_filters( 'wpmu_drop_tables', $drop_tables );		reset( $drop_tables );		foreach ( (array) $drop_tables as $drop_table) {			$wpdb->query( "DROP TABLE IF EXISTS ". current( $drop_table ) ."" );		}		$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->blogs WHERE blog_id = %d", $blog_id ) );		$dir = apply_filters( 'wpmu_delete_blog_upload_dir', WP_CONTENT_DIR . "/blogs.dir/{$blog_id}/files/", $blog_id );		$dir = rtrim( $dir, DIRECTORY_SEPARATOR );		$top_dir = $dir;		$stack = array($dir);		$index = 0;		while ( $index < count( $stack ) ) {			# Get indexed directory from stack			$dir = $stack[$index];			$dh = @opendir( $dir );			if ( $dh ) {				while ( ( $file = @readdir( $dh ) ) !== false ) {					if ( $file == '.' || $file == '..' )						continue;					if ( @is_dir( $dir . DIRECTORY_SEPARATOR . $file ) )						$stack[] = $dir . DIRECTORY_SEPARATOR . $file;					else if ( @is_file( $dir . DIRECTORY_SEPARATOR . $file ) )						@unlink( $dir . DIRECTORY_SEPARATOR . $file );				}			}			$index++;		}		$stack = array_reverse( $stack );  // Last added dirs are deepest		foreach( (array) $stack as $dir ) {			if ( $dir != $top_dir)			@rmdir( $dir );		}	}	$wpdb->query( "DELETE FROM {$wpdb->usermeta} WHERE meta_key = '{$blog_prefix}autosave_draft_ids'" );	$blogs = get_site_option( 'blog_list' );	if ( is_array( $blogs ) ) {		foreach ( $blogs as $n => $blog ) {			if ( $blog['blog_id'] == $blog_id )				unset( $blogs[$n] );		}		update_site_option( 'blog_list', $blogs );	}	if ( $switch === true )		restore_current_blog();}// @todo Merge with wp_delete_user() ?function wpmu_delete_user( $id ) {	global $wpdb;	$id = (int) $id;	do_action( 'wpmu_delete_user', $id );	$blogs = get_blogs_of_user( $id );	if ( ! empty( $blogs ) ) {		foreach ( $blogs as $blog ) {			switch_to_blog( $blog->userblog_id );			remove_user_from_blog( $id, $blog->userblog_id );			$post_ids = $wpdb->get_col( $wpdb->prepare( "SELECT ID FROM $wpdb->posts WHERE post_author = %d", $id ) );			foreach ( (array) $post_ids as $post_id ) {				wp_delete_post( $post_id );			}			// Clean links			$link_ids = $wpdb->get_col( $wpdb->prepare( "SELECT link_id FROM $wpdb->links WHERE link_owner = %d", $id ) );			if ( $link_ids ) {				foreach ( $link_ids as $link_id )					wp_delete_link( $link_id );			}			restore_current_blog();		}	}	$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->users WHERE ID = %d", $id ) );	$wpdb->query( $wpdb->prepare( "DELETE FROM $wpdb->usermeta WHERE user_id = %d", $id ) );	clean_user_cache( $id );	// allow for commit transaction	do_action( 'deleted_user', $id );	return true;}function confirm_delete_users( $users ) {	global $current_user;	if ( !is_array( $users ) )		return false;    screen_icon();    ?>	<h2><?php esc_html_e( 'Users' ); ?></h2>	<p><?php _e( 'Transfer or delete posts and links before deleting users.' ); ?></p>	<form action="ms-edit.php?action=dodelete" method="post">	<input type="hidden" name="dodelete" />    <?php	wp_nonce_field( 'ms-users-delete' );	$site_admins = get_super_admins();	$admin_out = "<option value='$current_user->ID'>$current_user->user_login</option>";	foreach ( ( $allusers = (array) $_POST['allusers'] ) as $key => $val ) {		if ( $val != '' && $val != '0' ) {			$delete_user = new WP_User( $val );			if ( in_array( $delete_user->user_login, $site_admins ) )				wp_die( sprintf( __( 'Warning! User cannot be deleted. The user %s is a network admnistrator.' ), $delete_user->user_login ) );			echo "<input type='hidden' name='user[]' value='{$val}'/>\n";			$blogs = get_blogs_of_user( $val, true );			if ( !empty( $blogs ) ) {				?>				<br /><fieldset><p><legend><?php printf( __( "What should be done with posts and links owned by <em>%s</em>?" ), $delete_user->user_login ); ?></legend></p>				<?php				foreach ( (array) $blogs as $key => $details ) {					$blog_users = get_users_of_blog( $details->userblog_id );					if ( is_array( $blog_users ) && !empty( $blog_users ) ) {						$user_site = "<a href='" . esc_url( get_home_url( $details->userblog_id ) ) . "'>{$details->blogname}</a>";						$user_dropdown = "<select name='blog[$val][{$key}]'>";						$user_list = '';						foreach ( $blog_users as $user ) {							if ( $user->user_id != $val && !in_array( $user->user_id, $allusers ) )								$user_list .= "<option value='{$user->user_id}'>{$user->user_login}</option>";						}						if ( '' == $user_list )							$user_list = $admin_out;						$user_dropdown .= $user_list;						$user_dropdown .= "</select>\n";						?>						<ul style="list-style:none;">							<li><?php printf( __( 'Site: %s' ), $user_site ); ?></li>							<li><label><input type="radio" id="delete_option0" name="delete[<?php echo $details->userblog_id . '][' . $delete_user->ID ?>]" value="delete" checked="checked" />							<?php _e( 'Delete all posts and links.' ); ?></label></li>							<li><label><input type="radio" id="delete_option1" name="delete[<?php echo $details->userblog_id . '][' . $delete_user->ID ?>]" value="reassign" />							<?php echo __( 'Attribute all posts and links to:' ) . '</label>' . $user_dropdown; ?></li>						</ul>						<?php					}				}				echo "</fieldset>";			}		}	}	?>	<p class="submit"><input type="submit" class="button-secondary delete" value="<?php esc_attr_e( 'Confirm Deletion' ); ?>" /></p>	</form>    <?php	return true;}function wpmu_get_blog_allowedthemes( $blog_id = 0 ) {	$themes = get_themes();	if ( $blog_id != 0 )		switch_to_blog( $blog_id );	$blog_allowed_themes = get_option( 'allowedthemes' );	if ( !is_array( $blog_allowed_themes ) || empty( $blog_allowed_themes ) ) { // convert old allowed_themes to new allowedthemes		$blog_allowed_themes = get_option( 'allowed_themes' );		if ( is_array( $blog_allowed_themes ) ) {			foreach( (array) $themes as $key => $theme ) {				$theme_key = esc_html( $theme['Stylesheet'] );				if ( isset( $blog_allowed_themes[$key] ) == true ) {					$blog_allowedthemes[$theme_key] = 1;				}			}			$blog_allowed_themes = $blog_allowedthemes;			add_option( 'allowedthemes', $blog_allowed_themes );			delete_option( 'allowed_themes' );		}	}	if ( $blog_id != 0 )		restore_current_blog();	return $blog_allowed_themes;}function update_option_new_admin_email( $old_value, $value ) {	$email = get_option( 'admin_email' );	if ( $value == get_option( 'admin_email' ) || !is_email( $value ) )		return;	$hash = md5( $value. time() .mt_rand() );	$new_admin_email = array(		'hash' => $hash,		'newemail' => $value	);	update_option( 'adminhash', $new_admin_email );	$content = apply_filters( 'new_admin_email_content', __( "Dear user,You recently requested to have the administration email address onyour site changed.If this is correct, please click on the following link to change it:###ADMIN_URL###You can safely ignore and delete this email if you do not want totake this action.This email has been sent to ###EMAIL###Regards,All at ###SITENAME######SITEURL### "), $new_admin_email );	$content = str_replace( '###ADMIN_URL###', esc_url( admin_url( 'options.php?adminhash='.$hash ) ), $content );	$content = str_replace( '###EMAIL###', $value, $content );	$content = str_replace( '###SITENAME###', get_site_option( 'site_name' ), $content );	$content = str_replace( '###SITEURL###', network_home_url(), $content );	wp_mail( $value, sprintf( __( '[%s] New Admin Email Address' ), get_option( 'blogname' ) ), $content );}add_action( 'update_option_new_admin_email', 'update_option_new_admin_email', 10, 2 );add_action( 'add_option_new_admin_email', 'update_option_new_admin_email', 10, 2 );function send_confirmation_on_profile_email() {	global $errors, $wpdb, $current_user;	if ( ! is_object($errors) )		$errors = new WP_Error();	if ( $current_user->id != $_POST['user_id'] )		return false;	if ( $current_user->user_email != $_POST['email'] ) {		if ( !is_email( $_POST['email'] ) ) {			$errors->add( 'user_email', __( "<strong>ERROR</strong>: The e-mail address isn't correct." ), array( 'form-field' => 'email' ) );			return;		}		if ( $wpdb->get_var( $wpdb->prepare( "SELECT user_email FROM {$wpdb->users} WHERE user_email=%s", $_POST['email'] ) ) ) {			$errors->add( 'user_email', __( "<strong>ERROR</strong>: The e-mail address is already used." ), array( 'form-field' => 'email' ) );			delete_option( $current_user->ID . '_new_email' );			return;		}		$hash = md5( $_POST['email'] . time() . mt_rand() );		$new_user_email = array(				'hash' => $hash,				'newemail' => $_POST['email']				);		update_option( $current_user->ID . '_new_email', $new_user_email );		$content = apply_filters( 'new_user_email_content', __( "Dear user,You recently requested to have the email address on your account changed.If this is correct, please click on the following link to change it:###ADMIN_URL###You can safely ignore and delete this email if you do not want totake this action.This email has been sent to ###EMAIL###Regards,All at ###SITENAME######SITEURL###" ), $new_user_email );		$content = str_replace( '###ADMIN_URL###', esc_url( admin_url( 'profile.php?newuseremail='.$hash ) ), $content );		$content = str_replace( '###EMAIL###', $_POST['email'], $content);		$content = str_replace( '###SITENAME###', get_site_option( 'site_name' ), $content );		$content = str_replace( '###SITEURL###', network_home_url(), $content );		wp_mail( $_POST['email'], sprintf( __( '[%s] New Email Address' ), get_option( 'blogname' ) ), $content );		$_POST['email'] = $current_user->user_email;	}}add_action( 'personal_options_update', 'send_confirmation_on_profile_email' );function new_user_email_admin_notice() {	global $current_user;	if ( strpos( $_SERVER['PHP_SELF'], 'profile.php' ) && isset( $_GET['updated'] ) && $email = get_option( $current_user->ID . '_new_email' ) )		echo "<div class='update-nag'>" . sprintf( __( "Your email address has not been updated yet. Please check your inbox at %s for a confirmation email." ), $email['newemail'] ) . "</div>";}add_action( 'admin_notices', 'new_user_email_admin_notice' );function get_site_allowed_themes() {	$themes = get_themes();	$allowed_themes = get_site_option( 'allowedthemes' );	if ( !is_array( $allowed_themes ) || empty( $allowed_themes ) ) {		$allowed_themes = get_site_option( 'allowed_themes' ); // convert old allowed_themes format		if ( !is_array( $allowed_themes ) ) {			$allowed_themes = array();		} else {			foreach( (array) $themes as $key => $theme ) {				$theme_key = esc_html( $theme['Stylesheet'] );				if ( isset( $allowed_themes[ $key ] ) == true ) {					$allowedthemes[ $theme_key ] = 1;				}			}			$allowed_themes = $allowedthemes;		}	}	return $allowed_themes;}/** * Determines if there is any upload space left in the current blog's quota. * * @since 3.0.0 * @return bool True if space is available, false otherwise. */function is_upload_space_available() {	if ( get_site_option( 'upload_space_check_disabled' ) )		return true;	if ( !( $space_allowed = get_upload_space_available() ) )		return false;	return true;}/* * @since 3.0.0 * * @return int of upload size limit in bytes */function upload_size_limit_filter( $size ) {	$fileupload_maxk = 1024 * get_site_option( 'fileupload_maxk', 1500 );	return min( $size, $fileupload_maxk, get_upload_space_available() );}/** * Determines if there is any upload space left in the current blog's quota. * * @return int of upload space available in bytes */function get_upload_space_available() {	$space_allowed = get_space_allowed() * 1024 * 1024;	if ( get_site_option( 'upload_space_check_disabled' ) )		return $space_allowed;	$dir_name = trailingslashit( BLOGUPLOADDIR );	if ( !( is_dir( $dir_name) && is_readable( $dir_name ) ) )		return $space_allowed;  	$dir = dir( $dir_name );   	$size = 0;	while ( $file = $dir->read() ) {		if ( $file != '.' && $file != '..' ) {			if ( is_dir( $dir_name . $file) ) {				$size += get_dirsize( $dir_name . $file );			} else {				$size += filesize( $dir_name . $file );			}		}	}	$dir->close();	if ( ( $space_allowed - $size ) <= 0 )		return 0;	return $space_allowed - $size;}/** * Returns the upload quota for the current blog. * * @return int Quota */function get_space_allowed() {	$space_allowed = get_option( 'blog_upload_space' );	if ( $space_allowed == false )		$space_allowed = get_site_option( 'blog_upload_space' );	if ( empty( $space_allowed ) || !is_numeric( $space_allowed ) )		$space_allowed = 50;	return $space_allowed;}function display_space_usage() {	$space = get_space_allowed();	$used = get_dirsize( BLOGUPLOADDIR ) / 1024 / 1024;	$percentused = ( $used / $space ) * 100;	if ( $space > 1000 ) {		$space = number_format( $space / 1024 );		/* translators: Gigabytes */		$space .= __( 'GB' );	} else {		/* translators: Megabytes */		$space .= __( 'MB' );	}	?>	<strong><?php printf( __( 'Used: %1s%% of %2s' ), number_format( $percentused ), $space ); ?></strong>	<?php}// Display File upload quota on dashboardfunction dashboard_quota() {	if ( get_site_option( 'upload_space_check_disabled' ) )		return true;	$quota = get_space_allowed();	$used = get_dirsize( BLOGUPLOADDIR ) / 1024 / 1024;	if ( $used > $quota )		$percentused = '100';	else		$percentused = ( $used / $quota ) * 100;	$used_color = ( $percentused < 70 ) ? ( ( $percentused >= 40 ) ? 'waiting' : 'approved' ) : 'spam';	$used = round( $used, 2 );	$percentused = number_format( $percentused );	?>	<p class="sub musub"><?php _e( 'Storage Space' ); ?></p>	<div class="table table_content musubtable">	<table>		<tr class="first">			<td class="first b b-posts"><?php printf( __( '<a href="%1$s" title="Manage Uploads" class="musublink">%2$sMB</a>' ), esc_url( admin_url( 'upload.php' ) ), $quota ); ?></td>			<td class="t posts"><?php _e( 'Space Allowed' ); ?></td>		</tr>	</table>	</div>	<div class="table table_discussion musubtable">	<table>		<tr class="first">			<td class="b b-comments"><?php printf( __( '<a href="%1$s" title="Manage Uploads" class="musublink">%2$sMB (%3$s%%)</a>' ), esc_url( admin_url( 'upload.php' ) ), $used, $percentused ); ?></td>			<td class="last t comments <?php echo $used_color;?>"><?php _e( 'Space Used' );?></td>		</tr>	</table>	</div>	<br class="clear" />	<?php}if ( current_user_can( 'edit_posts' ) )	add_action( 'activity_box_end', 'dashboard_quota' );// Edit blog upload space setting on Edit Blog pagefunction upload_space_setting( $id ) {	$quota = get_blog_option( $id, 'blog_upload_space' );	if ( !$quota )		$quota = '';	?>	<tr>		<th><?php _e( 'Site Upload Space Quota '); ?></th>		<td><input type="text" size="3" name="option[blog_upload_space]" value="<?php echo $quota; ?>" /> <?php _e( 'MB (Leave blank for network default)' ); ?></td>	</tr>	<?php}add_action( 'wpmueditblogaction', 'upload_space_setting' );function update_user_status( $id, $pref, $value, $refresh = 1 ) {	global $wpdb;	$wpdb->update( $wpdb->users, array( $pref => $value ), array( 'ID' => $id ) );	if ( $refresh == 1 )		refresh_user_details( $id );	if ( $pref == 'spam' ) {		if ( $value == 1 )			do_action( 'make_spam_user', $id );		else			do_action( 'make_ham_user', $id );	}	return $value;}function refresh_user_details( $id ) {	$id = (int) $id;	if ( !$user = get_userdata( $id ) )		return false;	clean_user_cache( $id );	return $id;}function format_code_lang( $code = '' ) {	$code = strtolower( substr( $code, 0, 2 ) );	$lang_codes = array(		'aa' => 'Afar', 'ab' => 'Abkhazian', 'af' => 'Afrikaans', 'ak' => 'Akan', 'sq' => 'Albanian', 'am' => 'Amharic', 'ar' => 'Arabic', 'an' => 'Aragonese', 'hy' => 'Armenian', 'as' => 'Assamese', 'av' => 'Avaric', 'ae' => 'Avestan', 'ay' => 'Aymara', 'az' => 'Azerbaijani', 'ba' => 'Bashkir', 'bm' => 'Bambara', 'eu' => 'Basque', 'be' => 'Belarusian', 'bn' => 'Bengali',		'bh' => 'Bihari', 'bi' => 'Bislama', 'bs' => 'Bosnian', 'br' => 'Breton', 'bg' => 'Bulgarian', 'my' => 'Burmese', 'ca' => 'Catalan; Valencian', 'ch' => 'Chamorro', 'ce' => 'Chechen', 'zh' => 'Chinese', 'cu' => 'Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic', 'cv' => 'Chuvash', 'kw' => 'Cornish', 'co' => 'Corsican', 'cr' => 'Cree',		'cs' => 'Czech', 'da' => 'Danish', 'dv' => 'Divehi; Dhivehi; Maldivian', 'nl' => 'Dutch; Flemish', 'dz' => 'Dzongkha', 'en' => 'English', 'eo' => 'Esperanto', 'et' => 'Estonian', 'ee' => 'Ewe', 'fo' => 'Faroese', 'fj' => 'Fijjian', 'fi' => 'Finnish', 'fr' => 'French', 'fy' => 'Western Frisian', 'ff' => 'Fulah', 'ka' => 'Georgian', 'de' => 'German', 'gd' => 'Gaelic; Scottish Gaelic',		'ga' => 'Irish', 'gl' => 'Galician', 'gv' => 'Manx', 'el' => 'Greek, Modern', 'gn' => 'Guarani', 'gu' => 'Gujarati', 'ht' => 'Haitian; Haitian Creole', 'ha' => 'Hausa', 'he' => 'Hebrew', 'hz' => 'Herero', 'hi' => 'Hindi', 'ho' => 'Hiri Motu', 'hu' => 'Hungarian', 'ig' => 'Igbo', 'is' => 'Icelandic', 'io' => 'Ido', 'ii' => 'Sichuan Yi', 'iu' => 'Inuktitut', 'ie' => 'Interlingue',		'ia' => 'Interlingua (International Auxiliary Language Association)', 'id' => 'Indonesian', 'ik' => 'Inupiaq', 'it' => 'Italian', 'jv' => 'Javanese', 'ja' => 'Japanese', 'kl' => 'Kalaallisut; Greenlandic', 'kn' => 'Kannada', 'ks' => 'Kashmiri', 'kr' => 'Kanuri', 'kk' => 'Kazakh', 'km' => 'Central Khmer', 'ki' => 'Kikuyu; Gikuyu', 'rw' => 'Kinyarwanda', 'ky' => 'Kirghiz; Kyrgyz',		'kv' => 'Komi', 'kg' => 'Kongo', 'ko' => 'Korean', 'kj' => 'Kuanyama; Kwanyama', 'ku' => 'Kurdish', 'lo' => 'Lao', 'la' => 'Latin', 'lv' => 'Latvian', 'li' => 'Limburgan; Limburger; Limburgish', 'ln' => 'Lingala', 'lt' => 'Lithuanian', 'lb' => 'Luxembourgish; Letzeburgesch', 'lu' => 'Luba-Katanga', 'lg' => 'Ganda', 'mk' => 'Macedonian', 'mh' => 'Marshallese', 'ml' => 'Malayalam',		'mi' => 'Maori', 'mr' => 'Marathi', 'ms' => 'Malay', 'mg' => 'Malagasy', 'mt' => 'Maltese', 'mo' => 'Moldavian', 'mn' => 'Mongolian', 'na' => 'Nauru', 'nv' => 'Navajo; Navaho', 'nr' => 'Ndebele, South; South Ndebele', 'nd' => 'Ndebele, North; North Ndebele', 'ng' => 'Ndonga', 'ne' => 'Nepali', 'nn' => 'Norwegian Nynorsk; Nynorsk, Norwegian', 'nb' => 'Bokml, Norwegian, Norwegian Bokml',		'no' => 'Norwegian', 'ny' => 'Chichewa; Chewa; Nyanja', 'oc' => 'Occitan, Provenal', 'oj' => 'Ojibwa', 'or' => 'Oriya', 'om' => 'Oromo', 'os' => 'Ossetian; Ossetic', 'pa' => 'Panjabi; Punjabi', 'fa' => 'Persian', 'pi' => 'Pali', 'pl' => 'Polish', 'pt' => 'Portuguese', 'ps' => 'Pushto', 'qu' => 'Quechua', 'rm' => 'Romansh', 'ro' => 'Romanian', 'rn' => 'Rundi', 'ru' => 'Russian',		'sg' => 'Sango', 'sa' => 'Sanskrit', 'sr' => 'Serbian', 'hr' => 'Croatian', 'si' => 'Sinhala; Sinhalese', 'sk' => 'Slovak', 'sl' => 'Slovenian', 'se' => 'Northern Sami', 'sm' => 'Samoan', 'sn' => 'Shona', 'sd' => 'Sindhi', 'so' => 'Somali', 'st' => 'Sotho, Southern', 'es' => 'Spanish; Castilian', 'sc' => 'Sardinian', 'ss' => 'Swati', 'su' => 'Sundanese', 'sw' => 'Swahili',		'sv' => 'Swedish', 'ty' => 'Tahitian', 'ta' => 'Tamil', 'tt' => 'Tatar', 'te' => 'Telugu', 'tg' => 'Tajik', 'tl' => 'Tagalog', 'th' => 'Thai', 'bo' => 'Tibetan', 'ti' => 'Tigrinya', 'to' => 'Tonga (Tonga Islands)', 'tn' => 'Tswana', 'ts' => 'Tsonga', 'tk' => 'Turkmen', 'tr' => 'Turkish', 'tw' => 'Twi', 'ug' => 'Uighur; Uyghur', 'uk' => 'Ukrainian', 'ur' => 'Urdu', 'uz' => 'Uzbek',		've' => 'Venda', 'vi' => 'Vietnamese', 'vo' => 'Volapk', 'cy' => 'Welsh','wa' => 'Walloon','wo' => 'Wolof', 'xh' => 'Xhosa', 'yi' => 'Yiddish', 'yo' => 'Yoruba', 'za' => 'Zhuang; Chuang', 'zu' => 'Zulu' );	$lang_codes = apply_filters( 'lang_codes', $lang_codes, $code );	return strtr( $code, $lang_codes );}function sync_category_tag_slugs( $term, $taxonomy ) {	if ( global_terms_enabled() && ( $taxonomy == 'category' || $taxonomy == 'post_tag' ) ) {		if ( is_object( $term ) ) {			$term->slug = sanitize_title( $term->name );		} else {			$term['slug'] = sanitize_title( $term['name'] );		}	}	return $term;}add_filter( 'get_term', 'sync_category_tag_slugs', 10, 2 );function redirect_user_to_blog() {	global $current_user;	$c = 0;	if ( isset( $_GET['c'] ) )		$c = (int) $_GET['c'];	if ( $c >= 5 ) {		wp_die( __( "You don&#8217;t have permission to view this site. Please contact the system administrator." ) );	}	$c ++;	$blog = get_active_blog_for_user( $current_user->ID );	$dashboard_blog = get_dashboard_blog();	if ( is_object( $blog ) ) {		wp_redirect( get_admin_url( $blog->blog_id, '?c=' . $c ) ); // redirect and count to 5, "just in case"		exit;	}	/*	   If the user is a member of only 1 blog and the user's primary_blog isn't set to that blog,	   then update the primary_blog record to match the user's blog	 */	$blogs = get_blogs_of_user( $current_user->ID );	if ( !empty( $blogs ) ) {		foreach( $blogs as $blogid => $blog ) {			if ( $blogid != $dashboard_blog->blog_id && get_user_meta( $current_user->ID , 'primary_blog', true ) == $dashboard_blog->blog_id ) {				update_user_meta( $current_user->ID, 'primary_blog', $blogid );				continue;			}		}		$blog = get_blog_details( get_user_meta( $current_user->ID, 'primary_blog', true ) );			wp_redirect( get_admin_url( $blog->blog_id, '?c=' . $c ) );		exit;	}	wp_die( __( 'You do not have sufficient permissions to access this page.' ) );}add_action( 'admin_page_access_denied', 'redirect_user_to_blog', 99 );function check_import_new_users( $permission ) {	if ( !is_super_admin() )		return false;	return true;}add_filter( 'import_allow_create_users', 'check_import_new_users' );// See "import_allow_fetch_attachments" and "import_attachment_size_limit" filters too.function mu_dropdown_languages( $lang_files = array(), $current = '' ) {	$flag = false;	$output = array();	foreach ( (array) $lang_files as $val ) {		$code_lang = basename( $val, '.mo' );		if ( $code_lang == 'en_US' ) { // American English			$flag = true;			$ae = __( 'American English' );			$output[$ae] = '<option value="' . esc_attr( $code_lang ) . '"' . selected( $current, $code_lang ) . '> ' . $ae . '</option>';		} elseif ( $code_lang == 'en_GB' ) { // British English			$flag = true;			$be = __( 'British English' );			$output[$be] = '<option value="' . esc_attr( $code_lang ) . '"' . selected( $current, $code_lang ) . '> ' . $be . '</option>';		} else {			$translated = format_code_lang( $code_lang );			$output[$translated] =  '<option value="' . esc_attr( $code_lang ) . '"' . selected( $current, $code_lang ) . '> ' . esc_html ( $translated ) . '</option>';		}	}	if ( $flag === false ) // WordPress english		$output[] = '<option value=""' . selected( $current, '' ) . '>' . __( 'English' ) . "</option>";	// Order by name	uksort( $output, 'strnatcasecmp' );	$output = apply_filters( 'mu_dropdown_languages', $output, $lang_files, $current );	echo implode( "\n\t", $output );}/* Warn the admin if SECRET SALT information is missing from wp-config.php */function secret_salt_warning() {	if ( !is_super_admin() )		return;	$secret_keys = array( 'AUTH_KEY', 'SECURE_AUTH_KEY', 'LOGGED_IN_KEY', 'NONCE_KEY', 'AUTH_SALT', 'SECURE_AUTH_SALT', 'LOGGED_IN_SALT', 'NONCE_SALT' );	$out = '';	foreach( $secret_keys as $key ) {		if ( ! defined( $key ) )			$out .= "define( '$key', '" . esc_html( wp_generate_password( 64, true, true ) ) . "' );<br />";	}	if ( $out != '' ) {		$msg  = __( 'Warning! WordPress encrypts user cookies, but you must add the following lines to <strong>wp-config.php</strong> for it to be more secure.' );		$msg .= '<br/>' . __( "Before the line <code>/* That's all, stop editing! Happy blogging. */</code> please add this code:" );		$msg .= "<br/><br/><code>$out</code>";		echo "<div class='update-nag'>$msg</div>";	}}add_action( 'admin_notices', 'secret_salt_warning' );function admin_notice_feed() {	global $current_user, $current_screen;	if ( $current_screen->id != 'dashboard' )		return;	if ( !empty( $_GET['feed_dismiss'] ) ) {		update_user_option( $current_user->id, 'admin_feed_dismiss', $_GET['feed_dismiss'], true );		return;	}	$url = get_site_option( 'admin_notice_feed' );	if ( empty( $url ) )		return;	$rss = fetch_feed( $url );	if ( ! is_wp_error( $rss ) && $item = $rss->get_item() ) {		$title = $item->get_title();		if ( md5( $title ) == get_user_option( 'admin_feed_dismiss' ) )			return;		$msg = "<h3>" . esc_html( $title ) . "</h3>\n";		$content = $item->get_description();		$content = $content ? wp_html_excerpt( $content, 200 ) . ' &hellip; ' : '';		$link = esc_url( strip_tags( $item->get_link() ) );		$msg .= "<p>" . $content . "<a href='$link'>" . __( 'Read More' ) . "</a> <a href='index.php?feed_dismiss=" . md5( $title ) . "'>" . __( 'Dismiss' ) . "</a></p>";		echo "<div class='updated'>$msg</div>";	} elseif ( is_super_admin() ) {		printf( '<div class="update-nag">' . __( 'Your feed at %s is empty.' ) . '</div>', esc_html( $url ) );	}}add_action( 'admin_notices', 'admin_notice_feed' );function site_admin_notice() {	global $current_user, $wp_db_version;	if ( !is_super_admin() )		return false;	if ( get_site_option( 'wpmu_upgrade_site' ) != $wp_db_version )		echo "<div class='update-nag'>" . sprintf( __( 'Thank you for Updating! Please visit the <a href="%s">Update Network</a> page to update all your sites.' ), esc_url( admin_url( 'ms-upgrade-network.php' ) ) ) . "</div>";}add_action( 'admin_notices', 'site_admin_notice' );function avoid_blog_page_permalink_collision( $data, $postarr ) {	if ( is_subdomain_install() )		return $data;	if ( $data['post_type'] != 'page' )		return $data;	if ( !isset( $data['post_name'] ) || $data['post_name'] == '' )		return $data;	if ( !is_main_site() )		return $data;	$post_name = $data['post_name'];	$c = 0;	while( $c < 10 && get_id_from_blogname( $post_name ) ) {		$post_name .= mt_rand( 1, 10 );		$c ++;	}	if ( $post_name != $data['post_name'] ) {		$data['post_name'] = $post_name;	}	return $data;}add_filter( 'wp_insert_post_data', 'avoid_blog_page_permalink_collision', 10, 2 );function choose_primary_blog() {	global $current_user;	?>	<table class="form-table">	<tr>	<?php /* translators: My sites label */ ?>		<th scope="row"><?php _e( 'Primary Site' ); ?></th>		<td>		<?php		$all_blogs = get_blogs_of_user( $current_user->ID );		$primary_blog = get_user_meta( $current_user->ID, 'primary_blog', true );		if ( count( $all_blogs ) > 1 ) {			$found = false;			?>			<select name="primary_blog">				<?php foreach( (array) $all_blogs as $blog ) {					if ( $primary_blog == $blog->userblog_id )						$found = true;					?><option value="<?php echo $blog->userblog_id ?>"<?php selected( $primary_blog,  $blog->userblog_id ); ?>><?php echo esc_url( get_home_url( $blog->userblog_id ) ) ?></option><?php				} ?>			</select>			<?php			if ( !$found ) {				$blog = array_shift( $all_blogs );				update_user_meta( $current_user->ID, 'primary_blog', $blog->userblog_id );			}		} elseif ( count( $all_blogs ) == 1 ) {			$blog = array_shift( $all_blogs );			echo $blog->domain;			if ( $primary_blog != $blog->userblog_id ) // Set the primary blog again if it's out of sync with blog list.				update_user_meta( $current_user->ID, 'primary_blog', $blog->userblog_id );		} else {			echo "N/A";		}		?>		</td>	</tr>	<?php if ( in_array( get_site_option( 'registration' ), array( 'all', 'blog' ) ) ) : ?>		<tr>			<th scope="row" colspan="2" class="th-full">				<a href="<?php echo apply_filters( 'wp_signup_location', network_home_url( 'wp-signup.php' ) ); ?>"><?php _e( 'Create a New Site' ); ?></a>			</th>		</tr>	<?php endif; ?>	</table>	<?php}function show_post_thumbnail_warning() {	if ( ! is_super_admin() )		return;	$mu_media_buttons = get_site_option( 'mu_media_buttons', array() );	if ( empty($mu_media_buttons['image']) && current_theme_supports( 'post-thumbnails' ) ) {		echo "<div class='update-nag'>" . sprintf( __( "Warning! The current theme supports Featured Images. You must enable image uploads on <a href='%s'>the options page</a> for it to work." ), esc_url( admin_url( 'ms-options.php' ) ) ) . "</div>";	}}add_action( 'admin_notices', 'show_post_thumbnail_warning' );function ms_deprecated_blogs_file() {	if ( ! is_super_admin() )		return;	if ( ! file_exists( WP_CONTENT_DIR . '/blogs.php' ) )		return;	echo '<div class="update-nag">' . sprintf( __( 'The <code>%1$s</code> file is deprecated. Please remove it and update your server rewrite rules to use <code>%2$s</code> instead.' ), 'wp-content/blogs.php', 'wp-includes/ms-files.php' ) . '</div>';}add_action( 'admin_notices', 'ms_deprecated_blogs_file' );/** * Outputs the notice message for multisite regarding activation of plugin page. * * @since 3.0.0 * @return none */function _admin_notice_multisite_activate_plugins_page() {	$message = sprintf( __( 'The plugins page is not visible to normal users. It must be activated first. %s' ), '<a href="' . esc_url( admin_url( 'ms-options.php#menu' ) ) . '">' . __( 'Activate' ) . '</a>' );	echo "<div class='error'><p>$message</p></div>";}/** * Grants super admin privileges. * * @since 3.0.0 * @param $user_id */function grant_super_admin( $user_id ) {	global $super_admins;	// If global super_admins override is defined, there is nothing to do here.	if ( isset($super_admins) )		return false;	do_action( 'grant_super_admin', $user_id );	// Directly fetch site_admins instead of using get_super_admins()	$super_admins = get_site_option( 'site_admins', array( 'admin' ) );	$user = new WP_User( $user_id );	if ( ! in_array( $user->user_login, $super_admins ) ) {		$super_admins[] = $user->user_login;		update_site_option( 'site_admins' , $super_admins );		do_action( 'granted_super_admin', $user_id );		return true;	}	return false;}/** * Revokes super admin privileges. * * @since 3.0.0 * @param $user_id */function revoke_super_admin( $user_id ) {	global $super_admins;	// If global super_admins override is defined, there is nothing to do here.	if ( isset($super_admins) )		return false;	do_action( 'revoke_super_admin', $user_id );	// Directly fetch site_admins instead of using get_super_admins()	$super_admins = get_site_option( 'site_admins', array( 'admin' ) );	$user = new WP_User( $user_id );	if ( $user->user_email != get_site_option( 'admin_email' ) ) {		if ( false !== ( $key = array_search( $user->user_login, $super_admins ) ) ) {			unset( $super_admins[$key] );			update_site_option( 'site_admins', $super_admins );			do_action( 'revoked_super_admin', $user_id );			return true;		}	}	return false;}?>
<?php/** * Install plugin administration panel. * * @package WordPress * @subpackage Administration *//** WordPress Administration Bootstrap */require_once('./admin.php');if ( ! current_user_can('install_plugins') )	wp_die(__('You do not have sufficient permissions to install plugins on this site.'));include(ABSPATH . 'wp-admin/includes/plugin-install.php');$title = __('Install Plugins');$parent_file = 'plugins.php';wp_reset_vars( array('tab', 'paged') );//These are the tabs which are shown on the page,$tabs = array();$tabs['dashboard'] = __('Search');if ( 'search' == $tab )	$tabs['search']	= __('Search Results');$tabs['upload'] = __('Upload');$tabs['featured'] = _x('Featured','Plugin Installer');$tabs['popular']  = _x('Popular','Plugin Installer');$tabs['new']      = _x('Newest','Plugin Installer');$tabs['updated']  = _x('Recently Updated','Plugin Installer');$nonmenu_tabs = array('plugin-information'); //Valid actions to perform which do not have a Menu item.$tabs = apply_filters('install_plugins_tabs', $tabs );$nonmenu_tabs = apply_filters('install_plugins_nonmenu_tabs', $nonmenu_tabs);//If a non-valid menu tab has been selected, And its not a non-menu action.if ( empty($tab) || ( ! isset($tabs[ $tab ]) && ! in_array($tab, (array)$nonmenu_tabs) ) ) {	$tab_actions = array_keys($tabs);	$tab = $tab_actions[0];}if ( empty($paged) )	$paged = 1;wp_enqueue_style( 'plugin-install' );wp_enqueue_script( 'plugin-install' );if ( 'plugin-information' != $tab )	add_thickbox();$body_id = $tab;do_action('install_plugins_pre_' . $tab); //Used to override the general interface, Eg, install or plugin information.add_contextual_help($current_screen,	'<p>' . sprintf(__('Plugins hook into WordPress to extend its functionality with custom features. Plugins are developed independently from WordPress core by thousands of developers all over the world. All plugins in the official <a href="%s" target="_blank">WordPress.org Plugin Directory</a> are compatible with the WordPress GPL v2 license. You can find new plugins to install by searching or browsing the Directory right here in your own Plugins section.'), 'http://wordpress.org/extend/plugins/') . '</p>' .	'<p>' . __('If you know what you&#8217;re looking for, Search is your best bet. The Search screen has options to search the WordPress.org Plugin Directory for a particular Term, Author, or Tag. You can also search the directory by selecting a popular tags. Tags in larger type mean more plugins have been labeled with that tag.') . '</p>' .	'<p>' . __('If you just want to get an idea of what&#8217;s available, you can browse Featured, Popular, Newest, and Recently Updated plugins by using the links in the upper left of the screen. These sections rotate regularly.') . '</p>' .	'<p>' . __('If you want to install a plugin that you&#8217;ve downloaded elsewhere, click Upload in the upper left. You will be prompted to upload the .zip package, and once uploaded, you can activate the new plugin.') . '</p>' .	'<p><strong>' . __('For more information:') . '</strong></p>' .	'<p>' . __('<a href="http://codex.wordpress.org/Plugins_Add_New_SubPanel" target="_blank">Documentation on Installing Plugins</a>') . '</p>' .	'<p>' . __('<a href="http://wordpress.org/support/" target="_blank">Support Forums</a>') . '</p>');include('./admin-header.php');?><div class="wrap"><?php screen_icon(); ?><h2><?php echo esc_html( $title ); ?></h2>	<ul class="subsubsub"><?php$display_tabs = array();foreach ( (array)$tabs as $action => $text ) {	$sep = ( end($tabs) != $text ) ? ' | ' : '';	$class = ( $action == $tab ) ? ' class="current"' : '';	$href = admin_url('plugin-install.php?tab=' . $action);	echo "\t\t<li><a href='$href'$class>$text</a>$sep</li>\n";}?>	</ul>	<br class="clear" />	<?php do_action('install_plugins_' . $tab, $paged); ?></div><?phpinclude('./admin-footer.php');
<?php/** * WordPress Taxonomy Administration API. * * @package WordPress * @subpackage Administration *///// Category///** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $cat_name * @return unknown */function category_exists($cat_name, $parent = 0) {	$id = term_exists($cat_name, 'category', $parent);	if ( is_array($id) )		$id = $id['term_id'];	return $id;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $id * @return unknown */function get_category_to_edit( $id ) {	$category = get_category( $id, OBJECT, 'edit' );	return $category;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $cat_name * @param unknown_type $parent * @return unknown */function wp_create_category( $cat_name, $parent = 0 ) {	if ( $id = category_exists($cat_name, $parent) )		return $id;	return wp_insert_category( array('cat_name' => $cat_name, 'category_parent' => $parent) );}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $categories * @param unknown_type $post_id * @return unknown */function wp_create_categories($categories, $post_id = '') {	$cat_ids = array ();	foreach ($categories as $category) {		if ($id = category_exists($category))			$cat_ids[] = $id;		else			if ($id = wp_create_category($category))				$cat_ids[] = $id;	}	if ( $post_id )		wp_set_post_categories($post_id, $cat_ids);	return $cat_ids;}/** * Deletes one existing category. * * @since 2.0.0 * * @param int $cat_ID * @return mixed Returns true if completes delete action; false if term doesnt exist; Zero on attempted deletion of default Category; WP_Error object is also a possibility. */function wp_delete_category($cat_ID) {	$cat_ID = (int) $cat_ID;	$default = get_option('default_category');	// Don't delete the default cat	if ( $cat_ID == $default )		return 0;	return wp_delete_term($cat_ID, 'category', array('default' => $default));}/** * Updates an existing Category or creates a new Category. * * @since 2.0.0 * * @param mixed $catarr See defaults below. Set 'cat_ID' to a non-zero value to update an existing category. The 'taxonomy' key was added in 3.0.0. * @param bool $wp_error Optional, since 2.5.0. Set this to true if the caller handles WP_Error return values. * @return int|object The ID number of the new or updated Category on success.  Zero or a WP_Error on failure, depending on param $wp_error. */function wp_insert_category($catarr, $wp_error = false) {	$cat_defaults = array('cat_ID' => 0, 'taxonomy' => 'category', 'cat_name' => '', 'category_description' => '', 'category_nicename' => '', 'category_parent' => '');	$catarr = wp_parse_args($catarr, $cat_defaults);	extract($catarr, EXTR_SKIP);	if ( trim( $cat_name ) == '' ) {		if ( ! $wp_error )			return 0;		else			return new WP_Error( 'cat_name', __('You did not enter a category name.') );	}	$cat_ID = (int) $cat_ID;	// Are we updating or creating?	if ( !empty ($cat_ID) )		$update = true;	else		$update = false;	$name = $cat_name;	$description = $category_description;	$slug = $category_nicename;	$parent = $category_parent;	$parent = (int) $parent;	if ( $parent < 0 )		$parent = 0;	if ( empty($parent) || !category_exists( $parent ) || ($cat_ID && cat_is_ancestor_of($cat_ID, $parent) ) )		$parent = 0;	$args = compact('name', 'slug', 'parent', 'description');	if ( $update )		$cat_ID = wp_update_term($cat_ID, $taxonomy, $args);	else		$cat_ID = wp_insert_term($cat_name, $taxonomy, $args);	if ( is_wp_error($cat_ID) ) {		if ( $wp_error )			return $cat_ID;		else			return 0;	}	return $cat_ID['term_id'];}/** * Aliases wp_insert_category() with minimal args. * * If you want to update only some fields of an existing category, call this * function with only the new values set inside $catarr. * * @since 2.0.0 * * @param array $catarr The 'cat_ID' value is required.  All other keys are optional. * @return int|bool The ID number of the new or updated Category on success. Zero or FALSE on failure. */function wp_update_category($catarr) {	$cat_ID = (int) $catarr['cat_ID'];	if ( isset($catarr['category_parent']) && ($cat_ID == $catarr['category_parent']) )		return false;	// First, get all of the original fields	$category = get_category($cat_ID, ARRAY_A);	// Escape data pulled from DB.	$category = add_magic_quotes($category);	// Merge old and new fields with new fields overwriting old ones.	$catarr = array_merge($category, $catarr);	return wp_insert_category($catarr);}//// Tags///** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $post_id * @return unknown */function get_tags_to_edit( $post_id, $taxonomy = 'post_tag' ) {	return get_terms_to_edit( $post_id, $taxonomy);}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $post_id * @return unknown */function get_terms_to_edit( $post_id, $taxonomy = 'post_tag' ) {	$post_id = (int) $post_id;	if ( !$post_id )		return false;	$tags = wp_get_post_terms($post_id, $taxonomy, array());	if ( !$tags )		return false;	if ( is_wp_error($tags) )		return $tags;	foreach ( $tags as $tag )		$tag_names[] = $tag->name;	$tags_to_edit = join( ',', $tag_names );	$tags_to_edit = esc_attr( $tags_to_edit );	$tags_to_edit = apply_filters( 'terms_to_edit', $tags_to_edit, $taxonomy );	return $tags_to_edit;}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $tag_name * @return unknown */function tag_exists($tag_name) {	return term_exists($tag_name, 'post_tag');}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $tag_name * @return unknown */function wp_create_tag($tag_name) {	return wp_create_term( $tag_name, 'post_tag');}/** * {@internal Missing Short Description}} * * @since unknown * * @param unknown_type $tag_name * @return unknown */function wp_create_term($tag_name, $taxonomy = 'post_tag') {	if ( $id = term_exists($tag_name, $taxonomy) )		return $id;	return wp_insert_term($tag_name, $taxonomy);}
